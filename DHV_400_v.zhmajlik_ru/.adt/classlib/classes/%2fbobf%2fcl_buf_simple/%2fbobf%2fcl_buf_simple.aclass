class /BOBF/CL_BUF_SIMPLE definition
  public
  create protected

  global friends /BOBF/CL_TRA_TRANSACTION_MGR .

public section.

  interfaces /BOBF/IF_FRW_BUFFER .
  interfaces /BOBF/IF_FRW_CLONEABLE .

  methods CONSTRUCTOR
    importing
      !IV_BO_KEY type /BOBF/OBM_BO_KEY
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IT_NODE_KEY type /BOBF/T_FRW_KEY optional
    raising
      /BOBF/CX_FRW .
  methods DESTROY_INSTANCE .
protected section.

  types:
*"* protected components of class /BOBF/CL_BUF_SIMPLE
*"* do not include other source files here!!!
    BEGIN OF ts_comp,
       source_node_key  TYPE /BOBF/OBM_NODE_KEY,
       source_key       TYPE /BOBF/CONF_KEY,
       target_node_key  TYPE /BOBF/OBM_NODE_KEY,
       with_data        TYPE boole_d,
       selection        TYPE /BOBF/T_BUF_SELECTION,
    END OF ts_comp .
  types:
    tt_comp             TYPE SORTED TABLE OF ts_comp
                       WITH NON-UNIQUE KEY source_node_key source_key target_node_key .
  types:
    BEGIN OF ts_rev_fk,
       assoc_key        TYPE /BOBF/OBM_ASSOC_KEY,
       source_key       TYPE /BOBF/CONF_KEY,
       source_node_key  TYPE /BOBF/OBM_NODE_KEY,
       target_node_key  TYPE /BOBF/OBM_NODE_KEY,
    END OF ts_rev_fk .
  types:
    tt_rev_fk           TYPE SORTED TABLE OF ts_rev_fk
                        WITH NON-UNIQUE KEY assoc_key source_key
                        WITH NON-UNIQUE SORTED KEY target_node_key COMPONENTS target_node_key
                        WITH NON-UNIQUE SORTED KEY source_node_key COMPONENTS source_node_key source_key .
  types:
    BEGIN OF ts_change,
           node_key         TYPE /BOBF/OBM_NODE_KEY,
           key              TYPE /BOBF/CONF_KEY,
           change           TYPE /BOBF/CONF_CHANGE_MODE,
        END OF ts_change .
  types:
    tt_change           TYPE SORTED TABLE OF ts_change
                        WITH UNIQUE KEY primary_key COMPONENTS node_key key change
                        WITH NON-UNIQUE SORTED KEY change COMPONENTS change node_key .
  types:
    BEGIN OF ty_alternative_key,
        altkey_key        TYPE /BOBF/OBM_ALTKEY_KEY,
        value             TYPE xstring,
    END OF ty_alternative_key .
  types:
    tt_alternative_key  TYPE HASHED TABLE OF ty_alternative_key
                              WITH UNIQUE KEY altkey_key value .
  types:
    tt_node TYPE SORTED TABLE OF /BOBF/OBM_NODE_KEY WITH UNIQUE KEY table_line .
  types:
    BEGIN OF ty_change_sync,
      state         TYPE /BOBF/CONF_STATE,
      change        TYPE tt_change,
      rollback_done TYPE boole_d,
    END OF ty_change_sync .
  types:
    tt_change_sync TYPE HASHED TABLE OF ty_change_sync WITH UNIQUE KEY state .
  types:
    BEGIN OF ts_instance,
       bo_key           TYPE /BOBF/OBM_BO_KEY,
       node_key         TYPE /BOBF/OBM_NODE_KEY,
       buffer           TYPE REF TO /BOBF/IF_FRW_BUFFER,
    END OF ts_instance .
  types:
    tt_instance         TYPE HASHED TABLE OF ts_instance
                        WITH UNIQUE KEY bo_key node_key .

  data MO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION .
  data MO_DATA_ACCESS type ref to /BOBF/IF_BUF_DATA_ACCESS .
  data MO_MAIN_BUFFER type ref to /BOBF/IF_FRW_BUFFER .
  data MT_BUFFER type /BOBF/T_BUF_SIMPLE_BUFFER .
  data MT_BUFFER_COMP type TT_COMP .
  data MT_BUFFER_REV_FK type TT_REV_FK .
  data MT_CHANGE type TT_CHANGE .
  data MT_NODE_KEY type /BOBF/T_FRW_NODE_ONLY .
  data MV_BO_KEY type /BOBF/OBM_BO_KEY .
  class-data ST_INSTANCE type TT_INSTANCE .
  data MO_NON_CACHE_REG type ref to /BOBF/IF_TRA_NON_CACHE_REG .

  methods _EVAL_ASSOC_BINDING
    importing
      !IT_RUNTIME_ASSOC_BINDING type /BOBF/IF_FRW_CONFIGURATION=>GTT_RUNTIME_ASSOC_BINDING
      !IS_DATA type ref to DATA
      !IS_PARAMETERS type ref to DATA optional
      !IT_FILTERED_ATTRIBUTES type /BOBF/T_FRW_NAME optional
    returning
      value(RV_RESULT) type BOOLE_D .
  methods EVAL_ASSOC_BINDING
    importing
      !IS_ASSOCB type ref to /BOBF/T_CONFRO_ASSOCB
      !IS_DATA type ref to DATA
      !IS_PARAMETERS type ref to DATA optional
      !IT_FILTERED_ATTRIBUTES type /BOBF/T_FRW_NAME optional
    returning
      value(RV_RESULT) type BOOLE_D .
  methods FILL_KEYS
    importing
      !IS_KEYS type /BOBF/S_FRW_KEY_INCL
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
    changing
      !CS_DATA type ANY .
  class-methods GET_LOADABLE_NODE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION
      !IV_BUFFER_CLASS type STRING
    exporting
      !EV_NODE_KEY type /BOBF/OBM_NODE_KEY
    raising
      /BOBF/CX_BUF .
  class-methods GET_SUBTREE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION
      !IV_BUFFER_CLASS type STRING
    exporting
      !ET_NODE_KEY type /BOBF/T_FRW_KEY .
  methods HANDLE_EVENT_END_LOAD
    for event END_LOAD of /BOBF/IF_FRW_BUFFER
    importing
      !IV_BO_KEY
      !IO_CHANGE
      !IT_REQUESTED_NODE .
  methods LOAD_COMPOSITION
    importing
      !IT_KEY type /BOBF/T_FRW_KEY
      !IS_ASSOC type /BOBF/S_CONFRO_ASSOC
      !IV_FILL_DATA type BOOLE_D
      !IV_STATE type /BOBF/CONF_STATE
      !IT_SELECTION type /BOBF/T_BUF_SELECTION optional
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_NOTIFY_KEYLOAD type BOOLE_D
      !IV_INVALIDATE_CACHE type BOOLE_D default ABAP_FALSE
    raising
      /BOBF/CX_FRW .
  methods UPDATE_PROPERTY_NODE
    importing
      !IS_MOD type /BOBF/S_FRW_MODIFICATION
      !IV_STATE type /BOBF/CONF_STATE
      !IS_NODE type /BOBF/S_CONFRO_NODE
    changing
      !CT_CHG type /BOBF/T_FRW_CHANGE
    raising
      /BOBF/CX_FRW .
  methods WRITE_LOADED_DATA
    importing
      !IT_DATA type /BOBF/T_BUF_DATA_READ
      !IT_FAILED_NODE type /BOBF/T_FRW_NODE optional
      !IV_STATE type /BOBF/CONF_STATE
      !IV_RELOAD type BOOLE_D default ABAP_FALSE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_CHANGE_MODE type /BOBF/CONF_CHANGE_MODE
      !IV_SCOPE type /BOBF/BUF_READ_SCOPE
    raising
      /BOBF/CX_FRW .
  methods FILTER_BUFFER_PARENT_ROOT_KEY
    importing
      !IT_BUFFER type /BOBF/T_BUF_SIMPLE_BUFFER
      !IV_PARENT_IN_ALTKEY type ABAP_BOOL
      !IV_ROOT_IN_ALTKEY type ABAP_BOOL
      !IV_ALTKEY_IS_STRUCTURED type ABAP_BOOL
      !IT_ALTKEY_VALUE type INDEX TABLE
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IV_STATE type /BOBF/CONF_STATE
    exporting
      !ET_BUFFER_FILTERED type /BOBF/T_BUF_SIMPLE_BUFFER .
private section.

  constants GC_SYNC_STATE type STRING value 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' ##NO_TEXT.
  data MT_ALTERNATIVE_KEY type TT_ALTERNATIVE_KEY .
  data MT_CHANGE_SYNC type TT_CHANGE_SYNC .
  data MT_CONF_COMP type /BOBF/T_CONFRO_ASSOC2 .
  data MT_ASSOCIATION type /BOBF/T_CONFRO_ASSOC .
  data MT_COMPOSITION type /BOBF/T_CONFRO_ASSOC2 .
  data MT_PARENT_NOLOAD type TT_NODE .
  data MT_ROOT_KEYS type /BOBF/T_FRW_KEY_SORTED .
  data MT_ROOT_KEYS_CHANGED type /BOBF/T_FRW_KEY_SORTED .
  data MV_IS_MAIN_BUFFER type BOOLE_D .
  data MV_PARENT_NODE_KEY type /BOBF/OBM_NODE_KEY .
  data MV_NO_CONTENT_CHANGES type ABAP_BOOL .

  methods APPLY_UPDATE_DISABLED_FIELDS
    importing
      !IT_PROPERTY_INT type /BOBF/T_CONFRO_PROP_INT
      !IS_BUFFERED_DATA type DATA
    changing
      !CS_CHANGED_DATA type DATA .
  methods RETRIEVE_WITHOUT_CACHING
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_STATE type /BOBF/CONF_STATE
      !IV_FILL_DATA type BOOLE_D
      !IV_BUFFER_ONLY type BOOLE_D default ABAP_FALSE
      !IV_NOTIFY_KEYLOAD type BOOLE_D default ABAP_FALSE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
    changing
      !CT_NODE_CAT type /BOBF/T_FRW_NODE_CAT
      !CT_FAILED_KEY type /BOBF/T_FRW_KEY
      !CT_DATA type INDEX TABLE
    raising
      /BOBF/CX_FRW .
  class-methods RECURSIVE_COLLECT_SUBTREE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_COMPOSITION type /BOBF/T_CONFRO_ASSOC2
      !IV_BUFFER_CLASS type STRING
    changing
      !CT_NODE_KEY type /BOBF/T_FRW_KEY .
  methods IS_RELEVANT_FOR_LOADGROUP
    importing
      !IT_REQUESTED_NODE type /BOBF/T_FRW_NODE_ONLY
      !IV_NODES_ARE_SUPPLIED type BOOLE_D
    returning
      value(RV_RELEVANT) type BOOLE_D .
  methods CLEAR_COMP_TAB
    importing
      !IV_STATE type /BOBF/CONF_STATE
      !IV_SOURCE_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IT_SOURCE_KEY type /BOBF/T_FRW_KEY optional
      !IT_SOURCE_NODE type /BOBF/T_FRW_NODE optional
    raising
      /BOBF/CX_FRW .
  methods DELETE_SUBNODES
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IV_STATE type /BOBF/CONF_STATE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    changing
      !CT_NODE type /BOBF/T_FRW_NODE .
  methods CONVERT_ALT_KEY_FROM_BUFFER
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IV_ALTKEY_KEY type /BOBF/OBM_ALTKEY_KEY
      !IT_KEY type INDEX TABLE
      !IV_STATE type /BOBF/CONF_STATE
      !IV_INVALIDATE_CACHE type BOOLE_D default ABAP_FALSE
    exporting
      !ET_RESULT type /BOBF/T_FRW_KEYINDEX
    raising
      /BOBF/CX_FRW .
  methods IS_CHANGED
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IV_KEY type /BOBF/CONF_KEY
    returning
      value(EV_CHANGED) type BOOLE_D .
  methods SIMPLE_RETRIEVE_BY_COMP_DB
    importing
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_STATE type /BOBF/CONF_STATE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_BUFFER_ONLY type BOOLE_D
      !IV_FILL_DATA type BOOLE_D
      !IS_ASSOC type /BOBF/S_CONFRO_ASSOC
    exporting
      !ET_KEY_LINK type /BOBF/T_FRW_KEY_LINK
      !ET_TARGET_KEY type /BOBF/T_FRW_KEY
      !ET_DATA type INDEX TABLE
    raising
      /BOBF/CX_FRW .
  methods SIMPLE_RETRIEVE_DB
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_STATE type /BOBF/CONF_STATE
      !IV_BUFFER_ONLY type BOOLE_D
      !IV_FILL_DATA type BOOLE_D
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IS_NODECONF type /BOBF/S_CONFRO_NODE
    exporting
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !ET_DATA type INDEX TABLE
    raising
      /BOBF/CX_FRW .
  methods UPDATE_LOCK_NODE
    importing
      !IS_MOD type /BOBF/S_FRW_MODIFICATION
      !IV_STATE type /BOBF/CONF_STATE
      !IS_NODE type /BOBF/S_CONFRO_NODE
    changing
      !CT_CHG type /BOBF/T_FRW_CHANGE
    raising
      /BOBF/CX_FRW .
  methods LOAD
    importing
      !IT_NODE type /BOBF/T_FRW_NODE
      !IV_STATE type /BOBF/CONF_STATE
      !IV_FILL_DATA type BOOLE_D
      !IV_RELOAD type BOOLE_D default ABAP_FALSE
      !IV_NOTIFY_KEYLOAD type BOOLE_D default ABAP_FALSE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !ET_FAILED_NODE type /BOBF/T_FRW_NODE
    raising
      /BOBF/CX_FRW .

ENDCLASS.



CLASS /BOBF/CL_BUF_SIMPLE IMPLEMENTATION.


METHOD /bobf/if_frw_buffer~check_state_exists.

  DATA: ls_key    TYPE /bobf/s_frw_key,
        ls_buffer TYPE /bobf/s_buf_simple_buffer.


  CLEAR: et_key_exists,
         et_key_exists_not.

  LOOP AT it_key INTO ls_key.
    READ TABLE mt_buffer
      WITH TABLE KEY state = iv_state
                     node  = iv_node_key
                     key   = ls_key-key
    INTO ls_buffer.

    IF sy-subrc          <> 0 OR
        ( ls_buffer-data IS NOT BOUND AND
        iv_with_data     = abap_true ).
      APPEND ls_key TO et_key_exists_not.
    ELSE.
      IF iv_with_data = abap_true.
        READ TABLE mt_change
          WITH KEY change   = /bobf/if_frw_c=>sc_modify_load_key
                   node_key = iv_node_key
                   key      = ls_key-key TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          APPEND ls_key TO et_key_exists_not.
        ELSE.
          APPEND ls_key TO et_key_exists.
        ENDIF.
      ELSE.
        APPEND ls_key TO et_key_exists.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD /bobf/if_frw_buffer~compare.

* This method moves elements of supplied it_data into the combined structure
* and compares with existing data in buffer or from DB in case of non-caching mode

  DATA lr_existing   TYPE REF TO data.
  DATA lr_new        TYPE REF TO data.
  DATA lr_node_data  TYPE REF TO data.
  DATA ls_node_conf  TYPE /bobf/s_confro_node.
  DATA lt_key        TYPE /bobf/t_frw_key.
  DATA lt_node_cat   TYPE /bobf/t_frw_node_cat.
  DATA lt_failed_key TYPE /bobf/t_frw_key.
  DATA lv_different  TYPE boole_d.

  FIELD-SYMBOLS <ls_node_data> TYPE /bobf/s_frw_node_data.
  FIELD-SYMBOLS <ls_data>   TYPE any.
  FIELD-SYMBOLS <ls_existing> TYPE data.
  FIELD-SYMBOLS <lt_node_data> TYPE STANDARD TABLE.
  FIELD-SYMBOLS <ls_new> TYPE data.
  FIELD-SYMBOLS <lv_existing_field> TYPE any.
  FIELD-SYMBOLS <lv_new_field> TYPE any.


  BREAK-POINT ID /bobf/buf_simple.

  CLEAR: et_equal,
         et_different.

  LOOP AT it_data ASSIGNING FIELD-SYMBOL(<ls_node_group>) GROUP BY ( node = <ls_node_group>-node ).

    CLEAR lt_key.

    mo_conf->get_node(
      EXPORTING
        iv_node_key = <ls_node_group>-node
      IMPORTING
        es_node     = ls_node_conf
    ).

    IF mo_non_cache_reg->is_read_cache_disabled( iv_node_key = <ls_node_group>-node ).
      "non-caching mode: check for record in buffer. If it doesn't exist, retrieve it from the DAC
      LOOP AT GROUP <ls_node_group> ASSIGNING <ls_node_data>.
        IF NOT VALUE #( mt_buffer[
            node = <ls_node_data>-node
            key = <ls_node_data>-key
            state = iv_state
             ]-data OPTIONAL ) IS BOUND.
          INSERT VALUE #( key = <ls_node_data>-key ) INTO TABLE lt_key.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF lt_key IS INITIAL.
      UNASSIGN <lt_node_data>.
    ELSE.

      CREATE DATA lr_node_data TYPE STANDARD TABLE OF (ls_node_conf-data_type) WITH EMPTY KEY.
      ASSIGN lr_node_data->* TO <lt_node_data>.

      retrieve_without_caching(
        EXPORTING
          iv_node_key       = <ls_node_group>-node
          it_key            = lt_key
          iv_state          = iv_state
          iv_fill_data      = abap_true
        CHANGING
          ct_node_cat       = lt_node_cat
          ct_failed_key     = lt_failed_key
          ct_data           = <lt_node_data>
      ).

      SORT <lt_node_data> BY (/bobf/if_conf_c=>sc_attribute_name_key).

    ENDIF.
    CREATE DATA lr_new TYPE (ls_node_conf-data_type).
    ASSIGN lr_new->* TO <ls_new>.
    LOOP AT GROUP <ls_node_group> ASSIGNING <ls_node_data>.
      ASSIGN <ls_node_data>-data->* TO <ls_data>.
      <ls_new> = CORRESPONDING #( <ls_data> ).

      CLEAR lr_existing.
      "buffer check
      lr_existing = VALUE #( mt_buffer[
          node = <ls_node_data>-node
          key = <ls_node_data>-key
          state = iv_state
           ]-data OPTIONAL ).
      IF lr_existing IS NOT BOUND AND <lt_node_data> IS ASSIGNED.
        "non cached data check
        READ TABLE <lt_node_data> REFERENCE INTO lr_existing WITH KEY
          (/bobf/if_conf_c=>sc_attribute_name_key) =  <ls_node_data>-key BINARY SEARCH.
      ENDIF.

      IF lr_existing IS BOUND.
        ASSIGN lr_existing->* TO <ls_existing>.
        "compare
        IF <ls_node_data>-changed_fields IS INITIAL.
          IF <ls_existing> = <ls_new> AND et_equal IS SUPPLIED.
            INSERT <ls_node_data> INTO TABLE et_equal.
          ELSEIF et_different IS SUPPLIED.
            INSERT <ls_node_data> INTO TABLE et_different.
          ENDIF.
        ELSE.
          CLEAR lv_different.
          LOOP AT <ls_node_data>-changed_fields INTO DATA(lv_changed_field).
            UNASSIGN: <lv_new_field>, <lv_existing_field>.
            ASSIGN COMPONENT lv_changed_field OF STRUCTURE:
               <ls_new> TO <lv_new_field>,
               <ls_existing> TO <lv_existing_field>.
            IF <lv_new_field> IS NOT ASSIGNED OR <lv_existing_field> IS NOT ASSIGNED.
              ASSERT ID /bobf/buf_simple CONDITION <lv_new_field> IS NOT ASSIGNED OR <lv_existing_field> IS NOT ASSIGNED.
              RAISE EXCEPTION TYPE /bobf/cx_buf.
            ENDIF.

            IF <lv_new_field> <> <lv_existing_field>.
              lv_different = abap_true.
              IF et_different IS SUPPLIED.
                INSERT <ls_node_data> INTO TABLE et_different.
                EXIT.
              ENDIF.
            ENDIF.
          ENDLOOP.
          IF lv_different = abap_false AND et_equal IS SUPPLIED.
            INSERT <ls_node_data> INTO TABLE et_equal.
          ENDIF.
        ENDIF.
      ELSE.
        INSERT <ls_node_data> INTO TABLE et_different.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

ENDMETHOD.


METHOD /bobf/if_frw_buffer~compare_states.

  DATA: ls_key              TYPE /bobf/s_frw_key,
        ls_current          TYPE /bobf/s_buf_simple_buffer,
        ls_before           TYPE /bobf/s_buf_simple_buffer,
        lv_current          TYPE boole_d,
        lv_before           TYPE boole_d,
        lt_change           TYPE /bobf/t_frw_change,
        lt_change_initial   TYPE /bobf/t_frw_change,
        ls_change           TYPE /bobf/s_frw_change,
        lo_structdescr      TYPE REF TO cl_abap_structdescr,
        lt_ddic             TYPE ddfields,
        ls_node             TYPE /bobf/s_confro_node.

  FIELD-SYMBOLS: <ls_current> TYPE any,
                 <ls_before>  TYPE any,
                 <lv_current> TYPE any,
                 <lv_before>  TYPE any,
                 <ls_ddic>    TYPE dfies.

  BREAK-POINT ID /bobf/buf_simple.

  IF iv_incl_subtree = abap_false.
*   without subtree
    IF io_change->mv_attributes_requested = abap_true.
      TRY.
          IF iv_node_key = mo_conf->ms_last_node-node_key.
            ls_node = mo_conf->ms_last_node.
          ELSE.
            mo_conf->get_node(
              EXPORTING iv_node_key = iv_node_key
              IMPORTING es_node     = ls_node ).
          ENDIF.
          lo_structdescr ?= cl_abap_typedescr=>describe_by_name( ls_node-data_type ).
          lo_structdescr->get_ddic_field_list(
            RECEIVING
              p_field_list = lt_ddic
            EXCEPTIONS
              no_ddic_type = 1
              not_found    = 1 ).
          IF sy-subrc = 0.
            DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_key.
            DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_parent_key.
            DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_root_key.
          ELSE.
            CLEAR lt_ddic.
          ENDIF.

        CATCH cx_sy_move_cast_error.
          ASSERT ID /bobf/buf_simple CONDITION 1 = 0.      "#EC BOOL_OK
      ENDTRY.
    ENDIF.

*   start search
    LOOP AT it_key INTO ls_key.
*     check change table first
      READ TABLE mt_change TRANSPORTING NO FIELDS
        WITH TABLE KEY node_key = iv_node_key
                       key      = ls_key-key
                       change   = /bobf/if_frw_c=>sc_modify_create.
      IF sy-subrc <> 0.
        READ TABLE mt_change TRANSPORTING NO FIELDS
          WITH TABLE KEY node_key = iv_node_key
                         key      = ls_key-key
                         change   = /bobf/if_frw_c=>sc_modify_update.
        IF sy-subrc <> 0.
          READ TABLE mt_change TRANSPORTING NO FIELDS
            WITH TABLE KEY node_key = iv_node_key
                           key      = ls_key-key
                           change   = /bobf/if_frw_c=>sc_modify_delete.
        ENDIF.
      ENDIF.

      CHECK sy-subrc = 0.

      CLEAR ls_change.
      lv_current = abap_false.
      lv_before  = abap_false.

*     search for current state
      READ TABLE mt_buffer INTO ls_current
        WITH TABLE KEY state = iv_state_current
                       node  = iv_node_key
                       key   = ls_key-key.
      IF sy-subrc = 0.
        lv_current = abap_true.
      ENDIF.

*     search for before state
      READ TABLE mt_buffer INTO ls_before
        WITH TABLE KEY state = iv_state_before
                       node  = iv_node_key
                       key   = ls_key-key.
      IF sy-subrc = 0.
        lv_before = abap_true.
      ENDIF.

*     check
      IF lv_current = abap_true AND
         lv_before  = abap_false.
*       create
        IF io_change->mv_attributes_requested = abap_true.
*         fill attributes if required
          ASSIGN ls_current-data->* TO <ls_current>.
          LOOP AT lt_ddic ASSIGNING <ls_ddic>.
            ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_current> TO <lv_current>.
            CHECK sy-subrc = 0.
            CHECK <lv_current> IS NOT INITIAL.
            APPEND <ls_ddic>-fieldname TO ls_change-attributes.
          ENDLOOP.
        ENDIF.

        ls_change-change_mode = /bobf/if_frw_c=>sc_modify_create.
        ls_change-node_key    = iv_node_key.
        ls_change-key         = ls_key-key.
        APPEND ls_change TO lt_change.

      ELSEIF lv_current = abap_true   AND
             lv_before  = abap_true   AND
             ls_current-data IS BOUND AND
             ls_before-data  IS BOUND AND
             ls_current-data <> ls_before-data.
*       change
        ASSIGN ls_current-data->* TO <ls_current>.
        ASSIGN ls_before-data->*  TO <ls_before>.
        IF <ls_current> <> <ls_before>.
          IF io_change->mv_attributes_requested = abap_true.
*           fill attributes if required
            LOOP AT lt_ddic ASSIGNING <ls_ddic>.
              ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_current> TO <lv_current>.
              CHECK sy-subrc = 0.
              ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_before>  TO <lv_before>.
              CHECK sy-subrc = 0.
              IF <lv_current> <> <lv_before>.
                APPEND <ls_ddic>-fieldname TO ls_change-attributes.
              ENDIF.
            ENDLOOP.
          ENDIF.

          ls_change-change_mode = /bobf/if_frw_c=>sc_modify_update.
          ls_change-node_key    = iv_node_key.
          ls_change-key         = ls_key-key.
          APPEND ls_change TO lt_change.
        ENDIF.

      ELSEIF lv_current = abap_false AND
             lv_before  = abap_true.
*       delete
        IF io_change->mv_attributes_requested = abap_true AND
           ls_before-data IS BOUND.
*         fill attributes if required
          ASSIGN ls_before-data->* TO <ls_before>.
          LOOP AT lt_ddic ASSIGNING <ls_ddic>.
            ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_before> TO <lv_before>.
            CHECK sy-subrc = 0.
            CHECK <lv_before> IS NOT INITIAL.
            APPEND <ls_ddic>-fieldname TO ls_change-attributes.
          ENDLOOP.
        ENDIF.

        ls_change-change_mode = /bobf/if_frw_c=>sc_modify_delete.
        ls_change-node_key    = iv_node_key.
        ls_change-key         = ls_key-key.
        APPEND ls_change TO lt_change.
      ENDIF.
    ENDLOOP.

  ELSE.
*   with subtree (only for root nodes)
    LOOP AT it_key INTO ls_key.
      LOOP AT mt_buffer INTO ls_current USING KEY root_key
        WHERE state    = iv_state_current
          AND root_key = ls_key-key.

*       search for before state
        CLEAR ls_change.
        READ TABLE mt_buffer INTO ls_before
          WITH TABLE KEY state = iv_state_before
                         node  = ls_current-node
                         key   = ls_current-key.

        ASSERT ID /bobf/buf_simple
          CONDITION sy-subrc <> 0 OR
          ( ls_current-data IS BOUND     AND ls_before-data IS BOUND OR
            ls_current-data IS NOT BOUND AND ls_before-data IS NOT BOUND ).

        IF sy-subrc = 0.
          IF ls_current-data IS BOUND AND
             ls_before-data  IS BOUND.
*           found in both states -> maybe change
            ASSIGN ls_current-data->* TO <ls_current>.
            ASSIGN ls_before-data->*  TO <ls_before>.
            IF <ls_current> <> <ls_before>.
              IF io_change->mv_attributes_requested = abap_true.
*               fill attributes if required
                IF ls_current-node <> ls_node-node_key.
                  TRY.
                      mo_conf->get_node(
                        EXPORTING iv_node_key = ls_current-node
                        IMPORTING es_node     = ls_node ).

                      lo_structdescr ?= cl_abap_typedescr=>describe_by_name( ls_node-data_type ).
                      lo_structdescr->get_ddic_field_list(
                        RECEIVING
                          p_field_list = lt_ddic
                        EXCEPTIONS
                          no_ddic_type = 1
                          not_found    = 1 ).
                      IF sy-subrc = 0.
                        DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_key.
                        DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_parent_key.
                        DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_root_key.
                      ELSE.
                        CLEAR lt_ddic.
                      ENDIF.

                    CATCH cx_sy_move_cast_error.
                      ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
                  ENDTRY.
                ENDIF.
*               search for changed attributes
                LOOP AT lt_ddic ASSIGNING <ls_ddic>.
                  ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_current> TO <lv_current>.
                  CHECK sy-subrc = 0.
                  ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_before>  TO <lv_before>.
                  CHECK sy-subrc = 0.
                  IF <lv_current> <> <lv_before>.
                    APPEND <ls_ddic>-fieldname TO ls_change-attributes.
                  ENDIF.
                ENDLOOP.
              ENDIF.

              ls_change-change_mode = /bobf/if_frw_c=>sc_modify_update.
              ls_change-node_key    = ls_current-node.
              ls_change-key         = ls_current-key.
              APPEND ls_change TO lt_change.
            ENDIF.
          ENDIF.
        ELSE.
*         not found in before state -> created
          IF io_change->mv_attributes_requested = abap_true.
            ASSIGN ls_current-data->* TO <ls_current>.
*           search for non-initial attributes
            IF ls_current-node <> ls_node-node_key.
              TRY.
                  mo_conf->get_node(
                    EXPORTING iv_node_key = ls_current-node
                    IMPORTING es_node     = ls_node ).

                  lo_structdescr ?= cl_abap_typedescr=>describe_by_name( ls_node-data_type ).
                  lo_structdescr->get_ddic_field_list(
                    RECEIVING
                      p_field_list = lt_ddic
                    EXCEPTIONS
                      no_ddic_type = 1
                      not_found    = 1 ).
                  IF sy-subrc = 0.
                    DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_key.
                    DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_parent_key.
                    DELETE lt_ddic WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_root_key.
                  ELSE.
                    CLEAR lt_ddic.
                  ENDIF.

                CATCH cx_sy_move_cast_error.
                  ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
              ENDTRY.
            ENDIF.
            LOOP AT lt_ddic ASSIGNING <ls_ddic>.
              ASSIGN COMPONENT <ls_ddic>-fieldname OF STRUCTURE <ls_current> TO <lv_current>.
              CHECK sy-subrc = 0.
              IF <lv_current> IS NOT INITIAL.
                APPEND <ls_ddic>-fieldname TO ls_change-attributes.
              ENDIF.
            ENDLOOP.
          ENDIF.
          ls_change-change_mode = /bobf/if_frw_c=>sc_modify_create.
          ls_change-node_key    = ls_current-node.
          ls_change-key         = ls_current-key.
          APPEND ls_change TO lt_change.
        ENDIF.
      ENDLOOP.

*     check vice versa for deleted node instances
      LOOP AT mt_buffer INTO ls_before USING KEY root_key
        WHERE state    = iv_state_before
          AND root_key = ls_key-key.
*       search for current state
        READ TABLE mt_buffer
          WITH TABLE KEY
            state = iv_state_current
            node  = ls_before-node
            key   = ls_before-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
*         not found -> deleted
          ls_change-change_mode = /bobf/if_frw_c=>sc_modify_delete.
          ls_change-node_key    = ls_before-node.
          ls_change-key         = ls_before-key.
          APPEND ls_change TO lt_change.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.

* write changes
  IF lt_change IS NOT INITIAL.
    io_change->add(
      it_change          = lt_change
      it_change_load     = lt_change_initial
      it_change_load_key = lt_change_initial
      iv_reload_del      = abap_false
      iv_reload_int      = abap_false ).
  ENDIF.

ENDMETHOD.


METHOD /bobf/if_frw_buffer~convert_altern_key.

  TYPES: BEGIN OF ty_ls_index,
           original TYPE i,
           database TYPE i,
         END OF ty_ls_index.
  DATA:
    lt_result           TYPE                   /bobf/t_frw_keyindex,
    ls_result           TYPE                   /bobf/s_frw_keyindex,
    lt_data             TYPE                   /bobf/t_buf_data_read,
    lv_position         TYPE                   i,
    lt_altkey           TYPE REF TO            data,
    lv_xstring          TYPE                   xstring,
    ls_altkey_conf      TYPE                   /bobf/s_confro_altkey,
    lt_alternative_key  TYPE                   tt_alternative_key,
    ls_alternative_key  TYPE                   ty_alternative_key,
    ls_index            TYPE                   ty_ls_index,
    ls_index2           TYPE                   ty_ls_index,
    lt_index            TYPE SORTED TABLE OF   ty_ls_index WITH NON-UNIQUE KEY database
                             WITH NON-UNIQUE SORTED KEY original COMPONENTS original,
    lt_index_duplicates TYPE STANDARD TABLE OF ty_ls_index,
    lv_index_database   TYPE                   i.

  FIELD-SYMBOLS:
    <lt_altkey> TYPE INDEX TABLE,
    <ls_altkey> TYPE              any.

  CLEAR et_result.
  CHECK it_key IS NOT INITIAL.
*______________________________________________________________________*
* check buffer
  convert_alt_key_from_buffer(
    EXPORTING
      iv_node_key         = iv_node_key
      iv_altkey_key       = iv_altkey_key
      it_key              = it_key
      iv_state            = iv_state
      iv_invalidate_cache = iv_invalidate_cache
    IMPORTING
      et_result           = et_result
  ).
  " Due to performance reasons, it's sufficient to check the buffer only
  CHECK iv_buffer_sufficient_hint = abap_false.
*______________________________________________________________________*
* check database
  IF mo_conf->ms_last_altkey-altkey_key <> iv_altkey_key.
    mo_conf->get_altkey( iv_altkey_key = iv_altkey_key ).
  ENDIF.
  ls_altkey_conf = mo_conf->ms_last_altkey.
  CREATE DATA lt_altkey LIKE it_key.
  ASSIGN lt_altkey->* TO <lt_altkey>.
  ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
  CHECK mo_data_access IS BOUND.

  LOOP AT it_key ASSIGNING <ls_altkey>.
    lv_position  = sy-tabix.
*   check if data access has already been done
    IF io_change IS BOUND AND iv_invalidate_cache = abap_false.
*     only for optimized access and if cache should be used
      EXPORT data FROM <ls_altkey> TO DATA BUFFER lv_xstring.
      READ TABLE mt_alternative_key TRANSPORTING NO FIELDS WITH KEY
          altkey_key = iv_altkey_key
          value      = lv_xstring.
*     not already read from database or added to read now(!)
      IF sy-subrc = 0.
        CONTINUE.
      ELSE.
*       check if (in case of duplicates) the key is read now
        READ TABLE lt_alternative_key TRANSPORTING NO FIELDS WITH KEY
            altkey_key = iv_altkey_key
            value      = lv_xstring.
        IF sy-subrc = 0.
*         find index for entry that is read and add it for distribution
*          READ TABLE it_key TRANSPORTING NO FIELDS FROM <ls_altkey>. "#EC CI_ANYSEQ
          READ TABLE it_key with key table_line = <ls_altkey> TRANSPORTING NO FIELDS . "#EC CI_ANYSEQ
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          ls_index-database = sy-tabix.  "first one, not actual one!!
          READ TABLE lt_index INTO ls_index WITH KEY original COMPONENTS original = sy-tabix.
          ls_index-original = lv_position.
          APPEND ls_index TO lt_index_duplicates.
          CONTINUE.
        ELSE.
          ls_alternative_key-altkey_key = iv_altkey_key.
          ls_alternative_key-value      = lv_xstring.
*        INSERT ls_alternative_key INTO TABLE mt_alternative_key.
          INSERT ls_alternative_key INTO TABLE lt_alternative_key.
*       entry found -> if not modified unique by definition
          READ TABLE et_result INTO ls_result
            WITH KEY index = lv_position.
          IF sy-subrc = 0 AND
            ls_altkey_conf-not_unique <> /bobf/if_conf_c=>sc_altkey_non_unique AND
            mo_conf->ms_obj-objcat <> /bobf/if_conf_c=>sc_objcat_draft AND " for draft-enabled BOs, alt. keys are technically not unique
            is_changed( iv_node_key = iv_node_key
                        iv_key      = ls_result-key ) = abap_false.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

    ELSE.
*     without optimized access or if cache should be ignored
*     check at least the modify buffer (for found entries)
*     entry found -> if not modified unique by definition
      READ TABLE et_result INTO ls_result
        WITH KEY index = lv_position.
      IF sy-subrc = 0 AND
         ls_altkey_conf-not_unique <> /bobf/if_conf_c=>sc_altkey_non_unique AND
         is_changed( iv_node_key = iv_node_key
                       iv_key      = ls_result-key ) = abap_false.
        CONTINUE.
      ENDIF.
*     check if (in case of duplicates) the key is read now
      EXPORT data FROM <ls_altkey> TO DATA BUFFER lv_xstring.
      READ TABLE lt_alternative_key TRANSPORTING NO FIELDS WITH KEY
          altkey_key = iv_altkey_key
          value      = lv_xstring.
      IF sy-subrc = 0.
*       find index for entry that is read and add it for distribution
*        READ TABLE it_key TRANSPORTING NO FIELDS FROM <ls_altkey>. "#EC CI_ANYSEQ
        READ TABLE it_key with key table_line = <ls_altkey> TRANSPORTING NO FIELDS . "#EC CI_ANYSEQ
        ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
        ls_index-database = sy-tabix.
        READ TABLE lt_index INTO ls_index WITH KEY original COMPONENTS original = sy-tabix.
        ls_index-original = lv_position.
        APPEND ls_index TO lt_index_duplicates.
        CONTINUE.
      ELSE.
        ls_alternative_key-altkey_key = iv_altkey_key.
        ls_alternative_key-value      = lv_xstring.
        INSERT ls_alternative_key INTO TABLE lt_alternative_key.
      ENDIF.
    ENDIF.

    APPEND <ls_altkey> TO <lt_altkey>.
*   build index mapping
    ls_index-original = lv_position.
    ADD 1 TO lv_index_database.
    ls_index-database = lv_index_database.
    IF ls_index-original <> ls_index-database.
      APPEND ls_index TO lt_index.
    ENDIF.
  ENDLOOP.

  CHECK <lt_altkey> IS NOT INITIAL.

  IF ls_altkey_conf-node->loadable = abap_true AND
      io_change                    IS BOUND.
    mo_data_access->read_by_attributes(
      EXPORTING
        iv_node_key   = iv_node_key
        it_data       = <lt_altkey>
        it_attributes = ls_altkey_conf-field_names->*
        iv_fill_data  = abap_true
        iv_scope      = /bobf/if_buf_c=>sc_scope_loadgroup
      IMPORTING
        et_result     = lt_result
        et_data       = lt_data ).

  ELSE.
    mo_data_access->read_by_attributes(
      EXPORTING
        iv_node_key   = iv_node_key
        it_data       = <lt_altkey>
        it_attributes = ls_altkey_conf-field_names->*
        iv_fill_data  = abap_false
        iv_scope      = /bobf/if_buf_c=>sc_scope_till_loadable
      IMPORTING
        et_result     = lt_result ).
  ENDIF.

* check deleted entries and adjust result index
  LOOP AT lt_result INTO ls_result.
    IF lt_index IS NOT INITIAL.
      READ TABLE lt_index INTO ls_index
        WITH KEY database = ls_result-index.
      IF sy-subrc = 0.
        ls_result-index = ls_index-original.
      ENDIF.
    ENDIF.

*   Prepare lookup buffer (only for optimized access and if cache should be used)
    IF io_change IS BOUND.
      READ TABLE it_key ASSIGNING <ls_altkey> INDEX ls_result-index.
      EXPORT data FROM <ls_altkey> TO DATA BUFFER lv_xstring.
      ls_alternative_key-altkey_key = iv_altkey_key.
      ls_alternative_key-value      = lv_xstring.
      INSERT ls_alternative_key INTO TABLE mt_alternative_key.
    ENDIF.

*   already found?
    READ TABLE et_result TRANSPORTING NO FIELDS
      WITH KEY index_and_key COMPONENTS index = ls_result-index
                                        key   = ls_result-key.
    IF sy-subrc = 0.
*     key already found in buffer (delete also read data)
      DELETE lt_data WHERE node = iv_node_key
                      AND  key  = ls_result-key.
      CONTINUE.
    ENDIF.
    IF iv_state <> /bobf/if_conf_c=>sc_state_database.
      READ TABLE mt_change TRANSPORTING NO FIELDS
        WITH KEY change   = /bobf/if_frw_c=>sc_modify_delete
                 node_key = iv_node_key
                 key      = ls_result-key.
      IF sy-subrc <> 0.
*       changed alternative keys
        READ TABLE mt_change TRANSPORTING NO FIELDS
          WITH KEY change   = /bobf/if_frw_c=>sc_modify_update
                   node_key = iv_node_key
                   key      = ls_result-key.
      ENDIF.
      IF sy-subrc = 0.
*       key has been deleted (delete also read data)
        DELETE lt_data WHERE node = iv_node_key
                       AND   key  = ls_result-key.
        CONTINUE.
      ENDIF.
    ENDIF.

    INSERT ls_result INTO TABLE et_result.
  ENDLOOP.

* provide duplicates in result table
  LOOP AT lt_index_duplicates INTO ls_index.
    LOOP at lt_result INTO ls_result using key primary_key where index = ls_index-database.
      IF lt_index IS NOT INITIAL.
        READ TABLE lt_index INTO ls_index2
          WITH KEY database = ls_result-index.
        IF sy-subrc = 0.
          ls_result-index = ls_index2-original.
        ENDIF.
      ENDIF.
*     already found?
      READ TABLE et_result TRANSPORTING NO FIELDS
        WITH KEY index_and_key COMPONENTS index = ls_result-index
                                          key   = ls_result-key.
      CHECK sy-subrc = 0.
      IF iv_state <> /bobf/if_conf_c=>sc_state_database.
        READ TABLE mt_change TRANSPORTING NO FIELDS
          WITH KEY change   = /bobf/if_frw_c=>sc_modify_delete
                   node_key = iv_node_key
                   key      = ls_result-key.
        IF sy-subrc <> 0.
*         changed alternative keys
          READ TABLE mt_change TRANSPORTING NO FIELDS
            WITH KEY change   = /bobf/if_frw_c=>sc_modify_update
                     node_key = iv_node_key
                     key      = ls_result-key.
        ENDIF.
        CHECK sy-subrc <> 0.
      ENDIF.
      ls_result-index = ls_index-original.
      INSERT ls_result INTO TABLE et_result.
    ENDLOOP.
  ENDLOOP.
  DELETE ADJACENT DUPLICATES FROM et_result USING KEY index_and_key .

  IF io_change IS BOUND AND lt_data IS NOT INITIAL.
*   insert data into the buffer
    write_loaded_data(
        it_data        = lt_data
        iv_state       = iv_state
        iv_reload      = iv_invalidate_cache
        iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
        iv_scope       = /bobf/if_buf_c=>sc_scope_loadgroup
        io_change      = io_change ).
  ENDIF.

ENDMETHOD.


method /BOBF/IF_FRW_BUFFER~DELETE_STATE.

* note: subtree deletion is only implemented for the root node!

  DATA: lv_state_exists TYPE boole_d.

  FIELD-SYMBOLS <ls_buffer> TYPE /bobf/s_buf_simple_buffer.
  FIELD-SYMBOLS <ls_node>   TYPE /bobf/s_frw_node.
  BREAK-POINT ID /bobf/buf_simple.

  READ TABLE mt_buffer WITH KEY state = iv_state TRANSPORTING NO FIELDS.
  lv_state_exists = boolc( sy-subrc = 0 ).

  IF iv_incl_subtree = abap_true.
*   delete with subtree
    IF ( iv_state = /bobf/if_conf_c=>sc_state_current ) AND
       ( mt_change IS NOT INITIAL OR lv_state_exists = abap_true ).
      LOOP AT it_node ASSIGNING <ls_node>.
        LOOP AT mt_buffer ASSIGNING <ls_buffer> USING KEY root_key
          WHERE root_key = <ls_node>-key.
          DELETE mt_change
            WHERE node_key = <ls_buffer>-node
              AND key      = <ls_buffer>-key.
          IF <ls_buffer>-state = iv_state.
            DELETE TABLE mt_buffer WITH TABLE KEY
              state = <ls_buffer>-state
              node = <ls_buffer>-node
              key = <ls_buffer>-key.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
    ELSEIF lv_state_exists = abap_true.
      LOOP AT it_node ASSIGNING <ls_node>.
        LOOP AT mt_buffer ASSIGNING <ls_buffer> USING KEY root_key
               WHERE state    = iv_state AND
                     root_key = <ls_node>-key.
          DELETE mt_buffer INDEX sy-tabix USING KEY root_key.
        ENDLOOP.

      ENDLOOP.
    ENDIF.
  ELSEIF lv_state_exists = abap_true.
*   delete just defined node instances
    LOOP AT it_node ASSIGNING <ls_node>.
      DELETE mt_buffer
        WHERE state = iv_state
          AND node  = <ls_node>-node
          AND key   = <ls_node>-key.
    ENDLOOP.
  ENDIF.

* Additional coding for sync point support
  IF iv_state CO gc_sync_state.
    DELETE TABLE mt_change_sync WITH TABLE KEY state = iv_state.
    ASSERT ID /BOBF/BUF_SIMPLE CONDITION sy-subrc = 0.
  ENDIF.

endmethod.


method /BOBF/IF_FRW_BUFFER~DO_CLEANUP.

  DATA: ls_key    TYPE /BOBF/S_FRW_KEY,
        ls_buffer TYPE /BOBF/S_BUF_SIMPLE_BUFFER.

  BREAK-POINT ID /BOBF/BUF_SIMPLE.


  IF iv_keep_cache = abap_false.
    IF it_root_key IS INITIAL.
      CLEAR: mt_buffer,
             mt_buffer_comp,
             mt_buffer_rev_fk,
             mt_root_keys,
             mt_root_keys_changed,
             mt_change.
    ELSE.
      LOOP AT it_root_key INTO ls_key.
        DELETE mt_root_keys         WHERE key = ls_key-key.
        DELETE mt_root_keys_changed WHERE key = ls_key-key.
        LOOP AT mt_buffer INTO ls_buffer USING KEY root_key
          WHERE root_key = ls_key-key.
          DELETE mt_change
            WHERE node_key = ls_buffer-node
              AND key      = ls_buffer-key.
        ENDLOOP.
        DELETE mt_buffer USING KEY root_key WHERE root_key = ls_key-key.
      ENDLOOP.
    ENDIF.

    CLEAR: mt_alternative_key,
           mt_buffer_comp,
           mt_buffer_rev_fk.

  ELSE.
    CLEAR: mt_root_keys_changed,
           mt_buffer_rev_fk,
           mt_buffer_comp,
           mt_alternative_key.

    " Keep key load notifications as they are necessary to trigger the execution of after loading determinations
    mt_change = FILTER #( mt_change USING KEY change WHERE change = /bobf/if_frw_c=>sc_modify_load_key ).
  ENDIF.

endmethod.


method /bobf/if_frw_buffer~do_save.

  data: ls_current      type /bobf/s_buf_simple_buffer,
        lv_current      type i,
        ls_before       type /bobf/s_buf_simple_buffer,
        lv_before       type i,
        lv_subrc        type i,
        lt_nodeconf     type /bobf/t_confro_node,
        ls_nodeconf     type /bobf/s_confro_node,
        lt_data         type /bobf/t_buf_data_write,
        ls_data         type /bobf/s_buf_data_write,
        ls_change       type ts_change,
        lt_node         type /bobf/t_frw_node,
        ls_node         type /bobf/s_frw_node,
        lt_root_key     type /bobf/t_frw_key.

  field-symbols: <ls_data1>  type any,
                 <ls_data2>  type any,
                 <ls_source> type any,
                 <ls_target> type any.

  break-point id /bobf/buf_simple.

* no relevant nodes have been changed, e.g. only transient nodes
  if mo_data_access is not bound.
    return.
  endif.

* ____________________________________________________________________ *
* select objects to save
  check mt_change is not initial.
  loop at mt_change into ls_change.
    if ls_change-change = /bobf/if_frw_c=>sc_modify_create
      or ls_change-change = /bobf/if_frw_c=>sc_modify_update
      or ls_change-change = /bobf/if_frw_c=>sc_modify_delete.
      ls_node-node = ls_change-node_key.
      ls_node-key  = ls_change-key.
      insert ls_node into table lt_node.
    endif.
  endloop.
  delete adjacent duplicates from lt_node.
  mo_conf->get_node_tab( importing et_node = lt_nodeconf ).

  lt_root_key = it_root_key.
  sort lt_root_key.
  delete adjacent duplicates from lt_root_key.

  loop at lt_node into ls_node.
    at new node.
*     check for framework nodes
      read table lt_nodeconf
        with table key node_key = ls_node-node
        into ls_nodeconf.
      lv_subrc = sy-subrc.
    endat.
    if lv_subrc <> 0 or
       ls_nodeconf-transient = abap_true                              or
       ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_lock     or
       ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_property or
       ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_qrtn     or
     ( ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_message and
       mv_is_main_buffer = abap_true ).
      continue.
    endif.

*   check current state
    read table mt_buffer
      with table key
        state = iv_state_current
        node  = ls_node-node
        key   = ls_node-key
      into ls_current.
    lv_current = sy-subrc.
    if lv_current = 0.
      read table lt_root_key with key key_sort
        components key = ls_current-root_key
        transporting no fields.
      if sy-subrc <> 0. " entry does not belong to the roots to be saved
        continue.
      endif.
    endif.

*   check last state
    read table mt_buffer
      with table key
        state = iv_state_before_image
        node  = ls_node-node
        key   = ls_node-key
      into ls_before.
    lv_before = sy-subrc.
    if lv_before = 0 and lv_current <> 0.
      read table lt_root_key with key key_sort
        components key = ls_before-root_key
        transporting no fields.
      if sy-subrc <> 0. " entry does not belong to the roots to be saved
        continue.
      endif.
    endif.

    clear ls_data.
    if lv_current = 0 and
       lv_before <> 0.
*     new instance
      ls_data-node         = ls_current-node.
      ls_data-key          = ls_current-key.
      ls_data-root_key     = ls_current-root_key.
      ls_data-parent_key   = ls_current-parent_key.
      ls_data-node_cat_key = ls_current-node_cat_key.
      ls_data-change_mode  = /bobf/if_frw_c=>sc_modify_create.
      create data ls_data-data_current type (ls_nodeconf-data_data_type).
      assign ls_current-data->*      to <ls_source>.
      assign ls_data-data_current->* to <ls_target>.
      move-corresponding <ls_source> to <ls_target>.
      insert ls_data into table lt_data.

    elseif lv_current <> 0
       and lv_before   = 0.
*     deleted instance
      clear ls_data.
      ls_data-node         = ls_before-node.
      ls_data-key          = ls_before-key.
      ls_data-root_key     = ls_before-root_key.
      ls_data-parent_key   = ls_before-parent_key.
      ls_data-node_cat_key = ls_before-node_cat_key.
      ls_data-change_mode  = /bobf/if_frw_c=>sc_modify_delete.
      create data ls_data-data_before_image type (ls_nodeconf-data_data_type).
      if ls_before-data is bound.
        assign ls_before-data->*            to <ls_source>.
        assign ls_data-data_before_image->* to <ls_target>.
        move-corresponding <ls_source> to <ls_target>.
      endif.
      insert ls_data into table lt_data.

    elseif lv_current = 0 and
           lv_before  = 0.
*     maybe changed
      if ls_current-data = ls_before-data.
*       nothing has changed - same data reference
        continue.
      else.
        assign ls_current-data->* to <ls_data1>.
        assign ls_before-data->*  to <ls_data2>.
        if <ls_data1>              = <ls_data2> and
           ls_current-node_cat_key = ls_before-node_cat_key.
*         nothing has changed - compared fields
          continue.
        else.
*         node has changed
          ls_data-node         = ls_current-node.
          ls_data-key          = ls_current-key.
          ls_data-root_key     = ls_current-root_key.
          ls_data-parent_key   = ls_current-parent_key.
          ls_data-node_cat_key = ls_current-node_cat_key.
          ls_data-change_mode  = /bobf/if_frw_c=>sc_modify_update.
          create data ls_data-data_current type (ls_nodeconf-data_data_type).
          assign ls_data-data_current->* to <ls_target>.
          move-corresponding <ls_data1> to <ls_target>.
          create data ls_data-data_before_image type (ls_nodeconf-data_data_type).
          assign ls_data-data_before_image->* to <ls_target>.
          move-corresponding <ls_data2> to <ls_target>.
          insert ls_data into table lt_data.
        endif.
      endif.
    endif.
  endloop.

* ____________________________________________________________________ *
* write data
  if lt_data is not initial.
    mo_data_access->write( it_data = lt_data ).

*   inform DAC if no dispatcher is involved
    if mv_is_main_buffer = abap_true.
      raise event /bobf/if_frw_buffer~end_save
        exporting iv_bo_key = mv_bo_key.
    endif.
  endif.

endmethod.


method /BOBF/IF_FRW_BUFFER~GET_INSTANCE.

  DATA: ls_instance   TYPE ts_instance,
        ls_instance_r TYPE REF TO ts_instance,
        lo_conf       TYPE REF TO /BOBF/IF_FRW_CONFIGURATION,
        ls_subnode    TYPE /BOBF/S_FRW_KEY,
        lv_node_key   TYPE /BOBF/OBM_NODE_KEY,
        ls_node       TYPE /BOBF/S_CONFRO_NODE.

  READ TABLE st_instance
    WITH TABLE KEY bo_key   = iv_bo_key
                   node_key = iv_node_key
    INTO ls_instance.

  IF sy-subrc = 0.
    eo_buffer = ls_instance-buffer.
  ELSE.

    CLEAR eo_buffer.

    lo_conf = /BOBF/CL_FRW_FACTORY=>GET_CONFIGURATION( iv_bo_key ).
    IF iv_node_key IS NOT INITIAL.
*     node buffer requested -> get highest node within my loadgroup with my buffer
      IF iv_node_key = lo_conf->ms_last_node-node_key.
        ls_node = lo_conf->ms_last_node.
      ELSE.
        lo_conf->get_node(
          EXPORTING iv_node_key = iv_node_key
          IMPORTING es_node     = ls_node ).
      ENDIF.

      get_loadable_node(
        EXPORTING iv_node_key     = iv_node_key
                  io_conf         = lo_conf
                  iv_buffer_class = ls_node-buf_class
        IMPORTING ev_node_key     = lv_node_key ).
*     get subtree within the same loadgroup with my buffer
      get_subtree(
        EXPORTING iv_node_key     = lv_node_key
                  io_conf         = lo_conf
                  iv_buffer_class = ls_node-buf_class
        IMPORTING et_node_key     = et_node_key ).

      LOOP AT et_node_key INTO ls_subnode.
          READ TABLE st_instance WITH TABLE KEY
            bo_key   = iv_bo_key
            node_key = ls_subnode-key
            INTO ls_instance.
*           subnode has already buffer instance (can happen in case of locknode)
        IF sy-subrc = 0.
          ls_instance-node_key = iv_node_key.
          INSERT ls_instance INTO TABLE st_instance.
          eo_buffer = ls_instance-buffer.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF eo_buffer IS NOT BOUND.
*       create buffer
        IF iv_buffer_class IS NOT INITIAL.
            CREATE OBJECT ls_instance-buffer
              TYPE
                (iv_buffer_class)
            EXPORTING
            iv_bo_key = iv_bo_key
            iv_node_key = lv_node_key
            it_node_key = et_node_key.
        ELSE.
            CREATE OBJECT ls_instance-buffer
              TYPE
                (ls_node-buf_class)
            EXPORTING
            iv_bo_key = iv_bo_key
            iv_node_key = lv_node_key
            it_node_key = et_node_key.
        ENDIF.

*       update instance table
        ls_instance-bo_key   = iv_bo_key.
        ls_instance-node_key = iv_node_key.
        INSERT ls_instance INTO TABLE st_instance.
        LOOP AT et_node_key INTO ls_subnode.
          ls_instance-node_key = ls_subnode-key.
          INSERT ls_instance INTO TABLE st_instance.
        ENDLOOP.
        eo_buffer = ls_instance-buffer.
      ENDIF.

    ELSE.
*     global buffer requested -> create one
      ls_instance-bo_key = iv_bo_key.
      INSERT ls_instance INTO TABLE st_instance REFERENCE INTO ls_instance_r.
      IF iv_buffer_class IS NOT INITIAL.
          CREATE OBJECT ls_instance_r->buffer
            TYPE
              (iv_buffer_class)
          EXPORTING
          iv_bo_key = iv_bo_key.
      ELSE.
          CREATE OBJECT ls_instance_r->buffer
            TYPE
              (lo_conf->ms_obj-buffer_class)
          EXPORTING
          iv_bo_key = iv_bo_key.
      ENDIF.

      eo_buffer = ls_instance_r->buffer.
    ENDIF.

  ENDIF.

endmethod.


method /BOBF/IF_FRW_BUFFER~GET_KEYS.

  DATA: ls_buffer        TYPE /BOBF/S_BUF_SIMPLE_BUFFER,
        ls_root_key      TYPE /BOBF/S_FRW_KEY,
        ls_key           TYPE /BOBF/S_FRW_KEY.

  CLEAR et_key.

  IF it_root_key IS INITIAL.
    LOOP AT mt_buffer INTO ls_buffer
      WHERE state = iv_state
        AND node  = iv_node_key.
      ls_key-key = ls_buffer-key.
      APPEND ls_key TO et_key.
    ENDLOOP.

  ELSE.
    LOOP AT it_root_key INTO ls_root_key.
      LOOP AT mt_buffer INTO ls_buffer USING KEY root_key
        WHERE root_key = ls_root_key-key
          AND state    = iv_state
          AND node     = iv_node_key.
        ls_key-key = ls_buffer-key.
        APPEND ls_key TO et_key.
      ENDLOOP.
    ENDLOOP.
  ENDIF.

endmethod.


method /BOBF/IF_FRW_BUFFER~GET_ROOT_KEY.

  DATA: ls_key         TYPE /BOBF/S_FRW_KEY,
        ls_key_link    TYPE /BOBF/S_FRW_KEY_LINK,
        ls_target_key  TYPE /BOBF/S_FRW_KEY,
        ls_buffer      TYPE /BOBF/S_BUF_SIMPLE_BUFFER,
        lt_failed_node TYPE /BOBF/T_FRW_NODE,
        lt_node        TYPE /BOBF/T_FRW_NODE,
        ls_node        TYPE /BOBF/S_FRW_NODE,
        ls_nodeconf    TYPE /BOBF/S_CONFRO_NODE,
        lt_data        TYPE /BOBF/T_BUF_DATA_READ,
        ls_data        TYPE /BOBF/S_BUF_DATA_READ.

  CLEAR: et_key_link,
         et_target_key,
         et_failed_key.

  BREAK-POINT ID /BOBF/BUF_SIMPLE.

* ____________________________________________________________________ *
* search in buffer
  LOOP AT it_key INTO ls_key.
    READ TABLE mt_buffer
      WITH TABLE KEY
        state = iv_state
        node  = iv_node_key
        key   = ls_key-key
      INTO ls_buffer.
    IF sy-subrc = 0.
*     found
      ls_key_link-source_key = ls_buffer-key.
      ls_key_link-target_key = ls_buffer-root_key.
      INSERT ls_key_link   INTO TABLE et_key_link.
      ls_target_key-key      = ls_buffer-root_key.
      INSERT ls_target_key INTO TABLE et_target_key.
    ELSE.
*     not found
      INSERT ls_key INTO TABLE et_failed_key.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* search on DB
  IF et_failed_key IS NOT INITIAL.
*   check for transient node
    IF iv_node_key = mo_conf->ms_last_node-node_key.
      ls_nodeconf = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
        EXPORTING iv_node_key = iv_node_key
        IMPORTING es_node     = ls_nodeconf ).
    ENDIF.

    IF ls_nodeconf-transient = abap_false.
      ls_node-node = iv_node_key.
      IF iv_state <> /BOBF/IF_CONF_C=>SC_STATE_DATABASE.
*       for current state
        LOOP AT et_failed_key INTO ls_key.
*         check for deleted objects
          READ TABLE mt_change
            WITH TABLE KEY
              node_key = iv_node_key
              key      = ls_key-key
              change   = /BOBF/IF_FRW_C=>SC_MODIFY_DELETE
            TRANSPORTING NO FIELDS.
          IF sy-subrc <> 0.
            READ TABLE mt_change
              WITH TABLE KEY
                node_key = iv_node_key
                key      = ls_key-key
                change   = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE
              TRANSPORTING NO FIELDS.
          ENDIF.
          CHECK sy-subrc <> 0.
          ls_node-key = ls_key-key.
          DELETE et_failed_key.
          INSERT ls_node INTO TABLE lt_node.
        ENDLOOP.
      ELSE.
*       for DB-state
        LOOP AT et_failed_key INTO ls_key.
          ls_node-key = ls_key-key.
          INSERT ls_node INTO TABLE lt_node.
        ENDLOOP.
        CLEAR et_failed_key.
      ENDIF.

      IF lt_node IS NOT INITIAL.
        mo_data_access->read(
          EXPORTING
            it_node      = lt_node
            iv_fill_data = abap_false
            iv_scope     = /BOBF/IF_BUF_C=>SC_SCOPE_TILL_LOADABLE
          IMPORTING
            et_data      = lt_data
            et_failed    = lt_failed_node ).

        LOOP AT lt_data INTO ls_data
          WHERE node = iv_node_key.
          ls_key_link-source_key = ls_data-key.
          ls_key_link-target_key = ls_data-root_key.
          INSERT ls_key_link   INTO TABLE et_key_link.
          ls_target_key-key      = ls_data-root_key.
          INSERT ls_target_key INTO TABLE et_target_key.
        ENDLOOP.

        LOOP AT lt_failed_node INTO ls_node.
          ls_key-key = ls_node-key.
          APPEND ls_key TO et_failed_key.
        ENDLOOP.

        IF io_change IS BOUND.
          write_loaded_data(
            it_data        = lt_data
            it_failed_node = lt_failed_node
            iv_state       = iv_state
            iv_reload      = abap_false
            iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_LOAD_KEY
            iv_scope       = /BOBF/IF_BUF_C=>SC_SCOPE_TILL_LOADABLE
            io_change      = io_change ).
        ENDIF.

      ENDIF.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* sort and reduce target key table
  IF et_target_key IS REQUESTED.
    SORT et_target_key.
    DELETE ADJACENT DUPLICATES FROM et_target_key.
  ENDIF.

endmethod.


method /BOBF/IF_FRW_BUFFER~GET_ROOT_KEYS.

  DATA: lv_root_key TYPE /BOBF/OBM_NODE_KEY,
        ls_key      TYPE /BOBF/S_FRW_KEY.

  IF iv_changed_only = abap_true.
*   check for created and deleted root keys
    lv_root_key = mo_conf->ms_obj-root_node_key.
    et_root_key = mt_root_keys_changed.

    LOOP AT et_root_key INTO ls_key.
      READ TABLE mt_change TRANSPORTING NO FIELDS
          WITH TABLE KEY node_key = lv_root_key
                         key      = ls_key-key
                         change   = /bobf/if_frw_c=>sc_modify_create.
      CHECK sy-subrc = 0.
      READ TABLE mt_change TRANSPORTING NO FIELDS
          WITH TABLE KEY node_key = lv_root_key
                         key      = ls_key-key
                         change   = /bobf/if_frw_c=>sc_modify_delete.
      CHECK sy-subrc = 0.
      DELETE et_root_key.
    ENDLOOP.

  ELSE.
    et_root_key = mt_root_keys.
  ENDIF.

endmethod.


METHOD /bobf/if_frw_buffer~load.

  DATA(lt_node) = it_node.

  mo_non_cache_reg->filter_by_cached_nodes(
    CHANGING
      ct_node = lt_node
  ).

  load(
    EXPORTING
      it_node           = lt_node
      iv_state          = iv_state
      iv_fill_data      = iv_fill_data
      iv_reload         = iv_reload
      iv_notify_keyload = iv_notify_keyload
      io_change         = io_change    " Interface for Change Class
    IMPORTING
      et_failed_node    = et_failed_node    " Node Table
  ).


ENDMETHOD.


METHOD /bobf/if_frw_buffer~modify.

  DATA:
    ls_buffer             TYPE /bobf/s_buf_simple_buffer,
    ls_confassocb         TYPE /bobf/s_confro_assocb,
    ls_nodeconf           TYPE /bobf/s_confro_node,
    ls_association_source TYPE /bobf/if_frw_change=>ty_association_source,
    lt_key_source         TYPE /bobf/t_frw_key,
    lt_key_root           TYPE /bobf/t_frw_key,
    ls_key                TYPE /bobf/s_frw_key,
    ls_data               TYPE REF TO data,
    lt_association_source TYPE /bobf/if_frw_change=>tt_association_source,
    lt_chg                TYPE /bobf/t_frw_change,
    lt_chg_initial        TYPE /bobf/t_frw_change,
    ls_chg                TYPE /bobf/s_frw_change,
    ls_chg_int            TYPE ts_change,
    lv_root_node_key      TYPE /bobf/obm_node_key.

  FIELD-SYMBOLS:
    <lv_attribute>     TYPE string,
    <ls_mod>           TYPE /bobf/s_frw_modification,
    <ls_source>        TYPE any,
    <ls_target>        TYPE any,
    <ls_target_old>    TYPE any,
    <lv_source_field>  TYPE any,
    <lv_target_field>  TYPE any,
    <ls_buffer>        TYPE any,
    <ls_buffer_table>  TYPE /bobf/s_buf_simple_buffer,
    <lv_ass_attribute> TYPE any,
    <lv_constant>      TYPE any.

  BREAK-POINT ID /bobf/buf_simple.

  CLEAR eo_message.
  CHECK it_modification IS NOT INITIAL.

  lv_root_node_key = mo_conf->ms_obj-root_node_key.

  LOOP AT it_modification ASSIGNING <ls_mod>.

    AT NEW node.
      mo_conf->get_node( exporting iv_node_key = <ls_mod>-node
                         importing es_node     = ls_nodeconf ).
      ls_association_source-parent_node_key = ls_nodeconf-parent_node_key.
      ls_association_source-node_key        = ls_nodeconf-node_key.
    ENDAT.

    IF ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_lock.
      update_lock_node(
        EXPORTING
          is_mod    = <ls_mod>
          iv_state  = iv_state
          is_node   = ls_nodeconf
         CHANGING
           ct_chg   = lt_chg ).
      CONTINUE.
    ENDIF.

    IF ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_property.
      update_property_node(
        EXPORTING
          is_mod    = <ls_mod>
          iv_state  = iv_state
          is_node   = ls_nodeconf
         CHANGING
           ct_chg   = lt_chg ).
      CONTINUE.
    ENDIF.

    ls_chg-change_mode  = <ls_mod>-change_mode.
    ls_chg-node_key     = <ls_mod>-node.
    ls_chg-key          = <ls_mod>-key.
    ls_chg_int-change   = <ls_mod>-change_mode.
    ls_chg_int-node_key = <ls_mod>-node.
    ls_chg_int-key      = <ls_mod>-key.

    CASE <ls_mod>-change_mode.
*     CREATE
      WHEN /bobf/if_frw_c=>sc_modify_create.
        CLEAR ls_buffer.
        ls_buffer-node         = <ls_mod>-node.
        ls_buffer-key          = <ls_mod>-key.
        ls_buffer-parent_key   = <ls_mod>-source_key.
        ls_buffer-state        = iv_state.
        ls_buffer-node_cat_key = <ls_mod>-node_cat.

        ASSERT ID /bobf/buf_simple CONDITION ls_nodeconf-data_type IS NOT INITIAL.
        CREATE DATA ls_buffer-data TYPE (ls_nodeconf-data_type).
        ASSIGN ls_buffer-data->* TO <ls_target>.
        IF <ls_mod>-data IS BOUND.
          ASSIGN <ls_mod>-data->*  TO <ls_source>.

          IF <ls_mod>-changed_fields IS INITIAL.
*           move all fields
            MOVE-CORRESPONDING <ls_source> TO <ls_target>.
          ELSE.
*           move only selected fields
            LOOP AT <ls_mod>-changed_fields ASSIGNING <lv_attribute>.
              ASSIGN COMPONENT <lv_attribute> OF STRUCTURE <ls_source> TO <lv_source_field>.
              IF sy-subrc <> 0.
                ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
                RAISE EXCEPTION TYPE /bobf/cx_buf
                  EXPORTING
                    textid            = /bobf/cx_buf=>sc_unknown_attribute
                    mv_attribute_name = <lv_attribute>
                    mv_node_name      = ls_nodeconf-node_name.
              ENDIF.
              ASSIGN COMPONENT <lv_attribute> OF STRUCTURE <ls_target> TO <lv_target_field>.
              IF sy-subrc <> 0.
                ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
                RAISE EXCEPTION TYPE /bobf/cx_buf
                  EXPORTING
                    textid            = /bobf/cx_buf=>sc_unknown_attribute
                    mv_attribute_name = <lv_attribute>
                    mv_node_name      = ls_nodeconf-node_name.
              ENDIF.
              <lv_target_field> = <lv_source_field>.
            ENDLOOP.
          ENDIF.
        ENDIF.

        IF <ls_mod>-root_key IS NOT INITIAL.
*         root key already supplied
          ls_buffer-root_key = <ls_mod>-root_key.
        ELSEIF <ls_mod>-node = mo_conf->ms_obj-root_node_key.
*         created node == root node
          ls_buffer-root_key = ls_buffer-key.
        ELSE.
*         different node
          CLEAR lt_key_source.
          ls_key-key = <ls_mod>-source_key.
          INSERT ls_key INTO TABLE lt_key_source.
          mo_main_buffer->get_root_key(
            EXPORTING
              iv_node_key   = <ls_mod>-source_node
              it_key        = lt_key_source
              iv_state      = iv_state
              io_change     = io_change
            IMPORTING
              et_target_key = lt_key_root ).
          READ TABLE lt_key_root INTO ls_key INDEX 1.
          IF sy-subrc = 0.
            ls_buffer-root_key = ls_key-key.
          ELSE.
*           parent not found -> failed
            ls_chg-failed = abap_true.
            APPEND ls_chg TO lt_chg.
            ls_chg-failed = abap_false.
            CONTINUE.
          ENDIF.
        ENDIF.

*       set new root key
        ls_key-key = ls_buffer-root_key.
        INSERT ls_key INTO TABLE mt_root_keys.
        IF ( ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_normal OR
             ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_status  ) AND
           iv_only_transient     = abap_false.
          INSERT ls_key INTO TABLE mt_root_keys_changed.
        ENDIF.

*       check for initial values in case of specializations
        IF <ls_mod>-association IS NOT INITIAL.
          IF <ls_mod>-association <> mo_conf->ms_last_assoc-assoc_key.
            mo_conf->get_assoc( iv_assoc_key = <ls_mod>-association ).
          ENDIF.

*         Creation of nodes along (reverse) foreign key associations works only by chance (if it is parallel to the
*         composition. Otherwise a association implementation is necessary
          ASSERT ID /bobf/buf_simple CONDITION mo_conf->ms_last_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_foreign_key
                                           AND mo_conf->ms_last_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_foreign_key_r.
          IF mo_conf->ms_last_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_specialization.
            ASSIGN ls_buffer-data->* TO <ls_buffer>.
            LOOP AT mo_conf->ms_last_assoc-assoc_binding->* INTO ls_confassocb
              WHERE from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_constant
                AND sign             = /bobf/if_conf_c=>sc_sign_equal. "#EC CI_STDSEQ
              ASSIGN COMPONENT ls_confassocb-attribute OF STRUCTURE <ls_buffer> TO <lv_ass_attribute>.
              ASSIGN (ls_confassocb-constant) TO <lv_constant>.
              <lv_ass_attribute> = <lv_constant>.
            ENDLOOP.
          ENDIF.
        ENDIF.

*       create buffer entry
        fill_keys(
          EXPORTING iv_node_key = <ls_mod>-node
                    is_keys     = ls_buffer-keys
          CHANGING  cs_data     = <ls_target> ).

        INSERT ls_buffer INTO TABLE mt_buffer.
*       fill change object
        IF sy-subrc = 0.
          IF iv_only_transient = abap_false.
            INSERT ls_chg_int INTO TABLE mt_change.
          ENDIF.
*         successfull create
          IF io_change->mv_attributes_requested = abap_true.
            ls_chg-attributes = <ls_mod>-changed_fields.
          ENDIF.
          ls_chg-failed = abap_false.
*         notify association change
          IF  iv_only_transient = abap_false " set to true for defaults and after loading
            AND <ls_mod>-association IS NOT INITIAL AND <ls_mod>-node <> lv_root_node_key.

              ls_association_source-parent_key  = <ls_mod>-source_key.

              ls_association_source-association_kind = /bobf/if_conf_c=>sc_assoc_kind_composition. " Composition
              INSERT ls_association_source INTO TABLE lt_association_source.

              ls_association_source-association_kind = /bobf/if_conf_c=>sc_assoc_kind_specialization. " Specialization
              INSERT ls_association_source INTO TABLE lt_association_source.
            ENDIF.
        ELSE.
*         failed create
          ls_chg-failed = abap_true.
        ENDIF.
        APPEND ls_chg TO lt_chg.

*     UPDATE
      WHEN /bobf/if_frw_c=>sc_modify_update.
        READ TABLE mt_buffer
          WITH TABLE KEY
            state = iv_state
            node  = <ls_mod>-node
            key   = <ls_mod>-key
          ASSIGNING <ls_buffer_table>.
        IF sy-subrc = 0.
          ls_data = <ls_buffer_table>-data.
          CREATE DATA <ls_buffer_table>-data TYPE (ls_nodeconf-data_type).
          IF <ls_mod>-data IS BOUND.
            ASSIGN <ls_mod>-data->*          TO <ls_source>.
            ASSIGN <ls_buffer_table>-data->* TO <ls_target>.
            IF <ls_mod>-changed_fields IS INITIAL.
*             move all fields
              MOVE-CORRESPONDING <ls_source> TO <ls_target>.
            ELSE.
*             move only selected fields
              IF ls_data IS BOUND.
                ASSIGN ls_data->* TO <ls_target_old>.
                MOVE-CORRESPONDING <ls_target_old> TO <ls_target>.
              ENDIF.
              LOOP AT <ls_mod>-changed_fields ASSIGNING <lv_attribute>.
                ASSIGN COMPONENT <lv_attribute> OF STRUCTURE <ls_source> TO <lv_source_field>.
                IF sy-subrc <> 0.
                  ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
                  RAISE EXCEPTION TYPE /bobf/cx_buf
                    EXPORTING
                      textid            = /bobf/cx_buf=>sc_unknown_attribute
                      mv_attribute_name = <lv_attribute>
                      mv_node_name      = ls_nodeconf-node_name.
                ENDIF.
                ASSIGN COMPONENT <lv_attribute> OF STRUCTURE <ls_target> TO <lv_target_field>.
                IF sy-subrc <> 0.
                  ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
                  RAISE EXCEPTION TYPE /bobf/cx_buf
                    EXPORTING
                      textid            = /bobf/cx_buf=>sc_unknown_attribute
                      mv_attribute_name = <lv_attribute>
                      mv_node_name      = ls_nodeconf-node_name.
                ENDIF.
                <lv_target_field> = <lv_source_field>.
              ENDLOOP.
            ENDIF.

            fill_keys(
              EXPORTING iv_node_key = <ls_mod>-node
                        is_keys     = <ls_buffer_table>-keys
              CHANGING  cs_data     = <ls_target> ).

            IF ls_nodeconf-internal_properties IS BOUND.
              ASSIGN ls_data->* TO <ls_target_old>.
              apply_update_disabled_fields(
                EXPORTING
                  it_property_int  = ls_nodeconf-internal_properties->*
                  is_buffered_data = <ls_target_old>
                CHANGING
                  cs_changed_data  = <ls_target>
              ).
            ENDIF.
          ENDIF.

          IF ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_normal OR
             ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_status  .
            IF iv_only_transient = abap_false.
              ls_key-key = <ls_buffer_table>-root_key.
              INSERT ls_key INTO TABLE mt_root_keys_changed.
            ENDIF.
          ENDIF.

          IF io_change->mv_attributes_requested = abap_true.
            ls_chg-attributes = <ls_mod>-changed_fields.
          ENDIF.
          ls_chg-failed = abap_false.
          IF iv_only_transient = abap_false.
            INSERT ls_chg_int INTO TABLE mt_change.
          ENDIF.
*         notify association change
          IF  iv_only_transient = abap_false " set to true for defaults and after loading
            AND <ls_buffer_table>-parent_key IS NOT INITIAL AND <ls_mod>-node <> lv_root_node_key.

              ls_association_source-parent_key  = <ls_buffer_table>-parent_key.
              ls_association_source-association_kind = /bobf/if_conf_c=>sc_assoc_kind_specialization. " Specialization
              INSERT ls_association_source INTO TABLE lt_association_source.
            ENDIF.
        ELSE.
*         instance not found -> nothing updated
          ASSERT ID /bobf/buf_simple CONDITION 1 = 0.      "#EC BOOL_OK
          ls_chg-failed = abap_true.
        ENDIF.
        APPEND ls_chg TO lt_chg.

*     DELETE
      WHEN /bobf/if_frw_c=>sc_modify_delete.
        READ TABLE mt_buffer
          WITH TABLE KEY state = iv_state
                         node  = <ls_mod>-node
                         key   = <ls_mod>-key
          INTO ls_buffer.

        IF sy-subrc = 0.
*         success
          DELETE mt_buffer INDEX sy-tabix.
*         Purge pending keyload notifications to prevent deleted instances to reappear
          DELETE mt_change WHERE node_key = ls_chg-node_key
                             AND key      = ls_chg-key
                             AND change   = /bobf/if_frw_c=>sc_modify_load_key.
          IF ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_normal OR
             ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_status.
            IF iv_only_transient = abap_false.
              ls_key-key = ls_buffer-root_key.
              INSERT ls_key INTO TABLE mt_root_keys_changed.
            ENDIF.
          ENDIF.
          ls_chg-failed = abap_false.

          IF iv_only_transient = abap_false.
            INSERT ls_chg_int INTO TABLE mt_change.
          ENDIF.

*         notify association change
          IF  ls_buffer-parent_key IS NOT INITIAL
            AND iv_only_transient = abap_false " set to true for defaults and after loading
            AND <ls_mod>-node <> lv_root_node_key.

            ls_association_source-parent_key  = ls_buffer-parent_key.
            ls_association_source-association_kind = /bobf/if_conf_c=>sc_assoc_kind_composition. " Composition
            INSERT ls_association_source INTO TABLE lt_association_source.

            ls_association_source-association_kind = /bobf/if_conf_c=>sc_assoc_kind_specialization. " Specialization
            INSERT ls_association_source INTO TABLE lt_association_source.
          ENDIF.
        ELSE.
*         instance not found -> nothing deleted
          ASSERT ID /bobf/buf_simple CONDITION iv_state = /bobf/if_conf_c=>sc_state_default.
          ls_chg-failed = abap_true.
        ENDIF.
        APPEND ls_chg TO lt_chg.

*     Update of node category
      WHEN /bobf/if_frw_c=>sc_modify_set_node_category.
        READ TABLE mt_buffer
          WITH TABLE KEY state = iv_state
                         node  = <ls_mod>-node
                         key   = <ls_mod>-key
          ASSIGNING <ls_buffer_table>.

        IF sy-subrc = 0.
*         set new node category
          <ls_buffer_table>-node_cat_key = <ls_mod>-node_cat.
          ls_chg-failed = abap_false.
        ELSE.
*         instance not found -> no node category updated
          ASSERT ID /bobf/buf_simple CONDITION 1 = 0.      "#EC BOOL_OK
          ls_chg-failed = abap_true.
        ENDIF.
        APPEND ls_chg TO lt_chg.

      WHEN OTHERS.
*       unknown change mode value
        ASSERT ID /bobf/buf_simple CONDITION 1 = 0.        "#EC BOOL_OK
    ENDCASE.

  ENDLOOP.

  " We are not adding content change directly anymore because of performance reasons
  " (Internal incident https://support.wdf.sap.corp/sap/support/message/1670432776)
  io_change->add( it_change             = lt_chg
                  it_change_load        = lt_chg_initial
                  it_change_load_key    = lt_chg_initial
                  it_association_source = lt_association_source
                  iv_reload_del         = abap_false
                  iv_reload_int         = abap_false ).
ENDMETHOD.


method /BOBF/IF_FRW_BUFFER~QUERY.

  BREAK-POINT ID /BOBF/BUF_SIMPLE.

  CLEAR: et_key,
         es_query_info.

  IF mo_data_access IS NOT BOUND.
    ASSERT ID /BOBF/BUF_SIMPLE CONDITION 1 = 0."#EC BOOL_OK
    RAISE EXCEPTION TYPE /BOBF/CX_BUF.
  ENDIF.

  mo_data_access->query(
    EXPORTING
      iv_node_key              = iv_node_key
      iv_query_key             = iv_query_key
      it_filter_key            = it_filter_key
      it_selection_parameters  = it_selection_parameters
      io_query_authorities     = io_query_authorities
      is_query_options         = is_query_options
    IMPORTING
      et_key                  = et_key
      es_query_info           = es_query_info ).

endmethod.


METHOD /bobf/if_frw_buffer~retrieve.

  DATA: ls_nodeconf         TYPE /bobf/s_confro_node,
        lt_node             TYPE /bobf/t_frw_node,
        ls_node             TYPE /bobf/s_frw_node,
        lv_notify_data_load TYPE boole_d,
        ls_key              TYPE /bobf/s_frw_key,
        ls_nodecat          TYPE /bobf/s_frw_node_cat,
        lt_node_cat	        TYPE /bobf/t_frw_node_cat,
        lt_key              TYPE /bobf/t_frw_key,
        lt_failed_key       TYPE /bobf/t_frw_key,
        lt_failed_node      TYPE /bobf/t_frw_node,
        lt_data             TYPE REF TO data.

  FIELD-SYMBOLS: <ls_data>   TYPE any,
                 <ls_buffer> TYPE /bobf/s_buf_simple_buffer,
                 <lt_data>   TYPE ANY TABLE.

  BREAK-POINT ID /bobf/buf_simple.

  CLEAR: et_failed_key,
         et_node_cat,
         et_data.

  CHECK it_key IS NOT INITIAL.

  " get configuration
  IF iv_node_key = mo_conf->ms_last_node-node_key.
    ls_nodeconf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
      EXPORTING iv_node_key = iv_node_key
      IMPORTING es_node     = ls_nodeconf ).
  ENDIF.

  " unknown node
  ASSERT ls_nodeconf IS NOT INITIAL.

  " switch to simple retrieve method if applicable
  DATA lv_use_optimized_retrieve TYPE boole_d.
  GET PARAMETER ID '/BOBF/BUF_OPTIMIZED' FIELD lv_use_optimized_retrieve.
  IF lv_use_optimized_retrieve = abap_true.

    IF iv_notify_keyload        = abap_false AND " just loading keys
       ls_nodeconf-loadable     = abap_true  AND " node is loadable itself (no trasient node)
       lines( mt_node_key )     = 1          AND " only one node loading group
       ls_nodeconf-mapper_class = /bobf/if_conf_def_classes_c=>gc_cl_dac_table AND " our DAC us used
       et_node_cat                IS NOT REQUESTED AND
       io_change                  IS BOUND.

      DATA lt_mapping      TYPE /bobf/t_confro_mapping.
      mo_conf->get_fieldmapping( IMPORTING et_fieldmapping = lt_mapping ).
      READ TABLE lt_mapping TRANSPORTING NO FIELDS
        WITH KEY content_cat = /bobf/if_conf_c=>sc_content_per
                 content_key = iv_node_key.
      IF sy-subrc <> 0. " no persistency mapping used for this node

        simple_retrieve_db(
          EXPORTING
            iv_node_key    = iv_node_key
            it_key         = it_key
            iv_state       = iv_state
            iv_buffer_only = iv_buffer_only
            iv_fill_data   = iv_fill_data
            io_change      = io_change
            is_nodeconf    = ls_nodeconf
          IMPORTING
           et_failed_key   = et_failed_key
           et_data         = et_data ).

        RETURN.
      ENDIF.
    ENDIF.

  ENDIF.

  " standard implementation *********************************************************

  " with data
  IF iv_fill_data = abap_true.

    IF iv_notify_keyload = abap_false AND
       iv_buffer_only    = abap_false AND
       io_change IS BOUND.
      READ TABLE mt_change WITH TABLE KEY change COMPONENTS
        node_key = iv_node_key
        change = /bobf/if_frw_c=>sc_modify_load_key
      TRANSPORTING NO FIELDS.
      lv_notify_data_load = boolc( sy-subrc = 0 ).
    ENDIF.
    LOOP AT it_key INTO ls_key.
      READ TABLE mt_buffer
        WITH TABLE KEY
          state = iv_state
          node  = iv_node_key
          key   = ls_key-key
        ASSIGNING <ls_buffer>.
      IF sy-subrc = 0.
        IF <ls_buffer>-data IS BOUND.
          " data found and requested
          ASSIGN <ls_buffer>-data->* TO <ls_data>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.

          " if you get a dump here look at the call stack and
          " find the one doing a retrieve with the wrong type of et_data
          INSERT <ls_data> INTO TABLE et_data.

          " requested node cat
          IF et_node_cat IS REQUESTED.
            ls_nodecat-key          = <ls_buffer>-key.
            ls_nodecat-node_cat_key = <ls_buffer>-node_cat_key.
            INSERT ls_nodecat INTO TABLE et_node_cat.
          ENDIF.
          " check for change: load?
          IF lv_notify_data_load = abap_true.
            DELETE TABLE mt_change WITH TABLE KEY
              change   = /bobf/if_frw_c=>sc_modify_load_key
              node_key = iv_node_key
              key      = ls_key-key.
            IF sy-subrc = 0.
              io_change->add_change(
                  iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                  iv_node_key    = iv_node_key
                  iv_key         = ls_key-key ).
            ENDIF.
          ENDIF.
        ELSE.
          " data not found
          INSERT ls_key INTO TABLE lt_failed_key.
        ENDIF.
      ELSE.
        " keys not found
        INSERT ls_key INTO TABLE lt_failed_key.
      ENDIF.
    ENDLOOP.

  ELSE.
*   search for keys -> existence check
    IF et_node_cat IS NOT REQUESTED.
      LOOP AT it_key INTO ls_key.
        READ TABLE mt_buffer
          WITH TABLE KEY state = iv_state
                         node  = iv_node_key
                         key   = ls_key-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
*         not found
          INSERT ls_key INTO TABLE lt_failed_key.
        ENDIF.
      ENDLOOP.

    ELSE.
*    check for requested node cat
      LOOP AT it_key INTO ls_key.
        READ TABLE mt_buffer
          WITH TABLE KEY
            state = iv_state
            node  = iv_node_key
            key   = ls_key-key
          ASSIGNING <ls_buffer>.
        IF sy-subrc = 0.
          ls_nodecat-key          = <ls_buffer>-key.
          ls_nodecat-node_cat_key = <ls_buffer>-node_cat_key.
          INSERT ls_nodecat INTO TABLE et_node_cat.
        ELSE.
*         data not found
          INSERT ls_key INTO TABLE lt_failed_key.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

* get missing data from data access if allowed
  IF  mo_non_cache_reg->is_read_cache_disabled( iv_node_key = iv_node_key ) AND
      ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_normal and
      ls_nodeconf-transient = abap_false.
    retrieve_without_caching(
      EXPORTING
        iv_node_key       = iv_node_key
        it_key            = lt_failed_key
        iv_state          = iv_state
        iv_fill_data      = iv_fill_data
        iv_buffer_only    = iv_buffer_only
        iv_notify_keyload = iv_notify_keyload
        io_change         = io_change
      CHANGING
        ct_node_cat       = et_node_cat
        ct_failed_key     = et_failed_key
        ct_data           = et_data
    ).
  ELSE.
    IF iv_buffer_only                      = abap_false AND
     ls_nodeconf-optimized_buffer_access = abap_true  AND
     lt_failed_key IS NOT INITIAL.

      ls_node-node = iv_node_key.
      LOOP AT lt_failed_key INTO ls_key.
        ls_node-key = ls_key-key.
        INSERT ls_node INTO TABLE lt_node.
      ENDLOOP.

      /bobf/if_frw_buffer~load(
        EXPORTING
          it_node           = lt_node
          iv_state          = iv_state
          iv_fill_data      = iv_fill_data
          iv_reload         = abap_false
          iv_notify_keyload = iv_notify_keyload
          io_change         = io_change
        IMPORTING
          et_failed_node    = lt_failed_node ).

      lt_key = lt_failed_key.
      LOOP AT lt_failed_node INTO ls_node.
        DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
        ls_key-key = ls_node-key.
        APPEND ls_key TO et_failed_key.
      ENDLOOP.

      IF lt_key IS NOT INITIAL.
        " try to read all again
        IF et_data IS INITIAL.

          /bobf/if_frw_buffer~retrieve(
             EXPORTING
               iv_node_key    = iv_node_key
               it_key         = lt_key
               iv_state       = iv_state
               iv_fill_data   = iv_fill_data
               iv_buffer_only = abap_true
             IMPORTING
               et_node_cat    = lt_node_cat
               et_failed_key  = lt_failed_key
               et_data        = et_data ).

        ELSE.
          " try to read only failed again and mix with already found once
          CREATE DATA lt_data LIKE et_data.
          ASSIGN lt_data->* TO <lt_data>.

          /bobf/if_frw_buffer~retrieve(
            EXPORTING
              iv_node_key    = iv_node_key
              it_key         = lt_key
              iv_state       = iv_state
              iv_fill_data   = iv_fill_data
              iv_buffer_only = abap_true
            IMPORTING
              et_node_cat    = lt_node_cat
              et_failed_key  = lt_failed_key
              et_data        = <lt_data> ).

          " merge together results
          INSERT LINES OF <lt_data>   INTO TABLE et_data.
        ENDIF.
        INSERT LINES OF lt_node_cat INTO TABLE et_node_cat.
        APPEND LINES OF lt_failed_key TO et_failed_key.
      ENDIF.
    ELSE.
      et_failed_key = lt_failed_key.
    ENDIF.
  ENDIF.
ENDMETHOD.


METHOD /bobf/if_frw_buffer~retrieve_altern_key.

  DATA: lt_node_data TYPE REF TO data,
        lt_key_data  TYPE REF TO data,
        ls_key_data  TYPE REF TO data,
        ls_key       TYPE /bobf/s_frw_key.

  FIELD-SYMBOLS: <lt_node_data> TYPE INDEX TABLE,
                 <ls_node_data> TYPE any,
                 <lt_key_data>  TYPE INDEX TABLE,
                 <ls_key_data>  TYPE any,
                 <ls_key_value> TYPE any.

  INTERFACE /bobf/if_conf_c LOAD.

  CLEAR: et_key,
         et_failed_key.

  IF mo_conf->ms_last_altkey-altkey_key <> iv_altkey_key.
    mo_conf->get_altkey( iv_altkey_key = iv_altkey_key ).
  ENDIF.

  CREATE DATA lt_node_data TYPE TABLE OF (mo_conf->ms_last_altkey-node->data_type).
  ASSIGN lt_node_data->* TO <lt_node_data>.

  /bobf/if_frw_buffer~retrieve(
    EXPORTING
      iv_node_key       = iv_node_key
      it_key            = it_key
      iv_state          = iv_state
      iv_fill_data      = abap_true
      iv_buffer_only    = abap_false
      iv_notify_keyload = abap_true
      io_change         = io_change
    IMPORTING
      et_failed_key     = et_failed_key
      et_data           = <lt_node_data> ).

  IF mo_conf->ms_last_altkey-altkey_key <> iv_altkey_key.
    mo_conf->get_altkey( iv_altkey_key = iv_altkey_key ).
  ENDIF.

  IF mo_conf->ms_last_altkey-data_table_type IS INITIAL.
    CREATE DATA lt_key_data TYPE STANDARD TABLE OF (mo_conf->ms_last_altkey-data_type).
  ELSE.
    CREATE DATA lt_key_data TYPE (mo_conf->ms_last_altkey-data_table_type).
  ENDIF.
  CREATE DATA ls_key_data TYPE (mo_conf->ms_last_altkey-data_type).
  ASSIGN lt_key_data->* TO <lt_key_data>.
  ASSIGN ls_key_data->* TO <ls_key_data>.

  IF <lt_node_data> IS NOT INITIAL.
    SORT <lt_node_data> BY (/bobf/if_conf_c=>sc_attribute_name_key).
    LOOP AT it_key INTO ls_key.
      READ TABLE <lt_node_data> ASSIGNING <ls_node_data>
        WITH KEY (/bobf/if_conf_c=>sc_attribute_name_key) = ls_key-key BINARY SEARCH.
      IF sy-subrc = 0.
        IF mo_conf->ms_last_altkey-altkey_is_structured = abap_true.
          MOVE-CORRESPONDING <ls_node_data> TO <ls_key_data>.
        ELSE.
          ASSIGN COMPONENT mo_conf->ms_last_altkey-altkey_name OF STRUCTURE <ls_node_data> TO <ls_key_value>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          <ls_key_data> = <ls_key_value>.
        ENDIF.
      ELSE.
        CLEAR <ls_key_data>.
      ENDIF.
      APPEND <ls_key_data> TO <lt_key_data>.
    ENDLOOP.
  ELSE.
    LOOP AT it_key INTO ls_key.
      APPEND <ls_key_data> TO <lt_key_data>.
    ENDLOOP.
  ENDIF.

  et_key = <lt_key_data>.

ENDMETHOD.


METHOD /bobf/if_frw_buffer~retrieve_by_association.

  DATA: ls_keylink               TYPE        /bobf/s_frw_key_link,
        ls_assoc                 TYPE        /bobf/s_confro_assoc,
        ls_target_node           TYPE        /bobf/s_confro_node,
        lv_lead_node_key         TYPE        /bobf/obm_node_key,
        lt_group_node_key        TYPE        /bobf/t_frw_key,
        ls_node_key              TYPE        /bobf/s_frw_key,
        lt_load_node             TYPE        /bobf/t_frw_node,
        ls_node                  TYPE        /bobf/s_frw_node,
        lt_node                  TYPE        /bobf/t_frw_node,
        lt_key                   TYPE        /bobf/t_frw_key,
        lt_source_key            TYPE        /bobf/t_frw_key,
        ls_key                   TYPE        /bobf/s_frw_key,
        lt_key2                  TYPE        /bobf/t_frw_key2,
        ls_target_key            TYPE        /bobf/s_frw_key,
        lv_ref_buffer            TYPE REF TO /bobf/s_buf_simple_buffer,
        lt_attribute             TYPE        /bobf/t_frw_name,
        ls_result                TYPE        /bobf/s_frw_keyindex,
        lt_result                TYPE        /bobf/t_frw_keyindex,
        lt_node_cat              TYPE        /bobf/t_frw_node_cat,
        ls_data                  TYPE REF TO data,
        lt_data                  TYPE REF TO data,
        lt_buf_data_read         TYPE        /bobf/t_buf_data_read,
        lt_runtime_assoc_binding TYPE /bobf/if_frw_configuration=>gtt_runtime_assoc_binding,
        lv_tabix                 TYPE        i,
        lv_found                 TYPE        boole_d,
        lv_valid                 TYPE        boole_d,
        lv_filter                TYPE        boole_d,
        lv_fill_data             TYPE        boole_d,
        ls_rev_fk                TYPE        ts_rev_fk,
        lr_source_data           TYPE        REF TO data,
        ls_change                TYPE        ts_change,
        lt_selection             TYPE        /bobf/t_buf_selection,
        ls_selection             TYPE REF TO /bobf/s_buf_selection,
        ls_range                 TYPE        /bobf/s_buf_string_range,
        lv_root_only_asc         TYPE        abap_bool.    "true for reverse foreign key assocs from ROOT with only ROOT_KEY binding attribute

  FIELD-SYMBOLS:
    <ls_buffer>      TYPE              any,
    <ls_assocb>      TYPE /bobf/if_frw_configuration=>gty_runtime_assoc_binding,
    <ls_assocb_lead> TYPE /bobf/if_frw_configuration=>gty_runtime_assoc_binding,
    <lv_attribute>   TYPE              any,
    <lv_target_key>  TYPE              /bobf/conf_key,
    <lv_constant>    TYPE              any,
    <ls_filter>      TYPE              any,
    <lv_filter>      TYPE              any,
    <ls_data>        TYPE              any,
    <lt_data>        TYPE INDEX TABLE,
    <lt_source_data> TYPE INDEX TABLE,
    <ls_buf_adm>     TYPE              /bobf/s_buf_simple_buffer,
    <ls_key>         TYPE              /bobf/s_frw_key.


  BREAK-POINT ID /bobf/buf_simple.

  CLEAR: et_target_key,
         et_failed_key,
         et_key_link.

* ____________________________________________________________________ *
* find target node key
  IF iv_association = mo_conf->ms_last_assoc-assoc_key.
    ls_assoc = mo_conf->ms_last_assoc.
  ELSE.
    mo_conf->get_assoc(
      EXPORTING iv_assoc_key = iv_association
      IMPORTING es_assoc     = ls_assoc ).
  ENDIF.

  IF ls_assoc IS INITIAL OR
     ls_assoc-source_node_key <> iv_node_key AND
     ls_assoc-target_node_key <> iv_node_key.
*   no association class to resolve this association
    ASSERT ID /bobf/buf_simple CONDITION 1 = 0.            "#EC BOOL_OK
    RAISE EXCEPTION TYPE /bobf/cx_buf.
  ENDIF.

* generic association implementation not supported by simple buffer
* association might work only by chance!!!
  ASSERT ID /bobf/buf_simple CONDITION ls_assoc-assoc_type =  /bobf/if_conf_c=>sc_assoctype_comp
                                    OR ls_assoc-assoc_cat  <> /bobf/if_conf_c=>sc_assoccat_normal.

  lt_runtime_assoc_binding = mo_conf->convert_runtime_assoc_binding(
    iv_assoc_key = iv_association
    ir_assocb = ls_assoc-assoc_binding ).
* ____________________________________________________________________ *
  " switch to simple retrieve method if applicable
  DATA lv_use_optimized_retrieve TYPE boole_d.
  GET PARAMETER ID '/BOBF/BUF_OPTIMIZED' FIELD lv_use_optimized_retrieve.
  IF lv_use_optimized_retrieve = abap_true.

    " check for simple RBA for compositions
    IF ls_assoc-assoc_type            = /bobf/if_conf_c=>sc_assoctype_comp AND
       iv_notify_keyload              = abap_false                         AND
       iv_fill_failed_key             = abap_false                         AND
       ls_assoc-target_node->loadable = abap_true                          AND
       lines( mt_node_key )           = 1                                  AND " only one node loading group
       ls_assoc-target_node->mapper_class = /bobf/if_conf_def_classes_c=>gc_cl_dac_table AND " our DAC us used
       it_filtered_attributes     IS INITIAL                               AND
       is_parameters              IS NOT BOUND                             AND
       io_change                  IS BOUND.

      DATA lt_mapping      TYPE /bobf/t_confro_mapping.
      mo_conf->get_fieldmapping( IMPORTING et_fieldmapping = lt_mapping ).
      READ TABLE lt_mapping TRANSPORTING NO FIELDS
        WITH KEY content_cat = /bobf/if_conf_c=>sc_content_per
                 content_key = ls_assoc-target_node_key.

      simple_retrieve_by_comp_db(
        EXPORTING
          it_key         = it_key
          iv_state       = iv_state
          iv_buffer_only = iv_buffer_only
          iv_fill_data   = iv_fill_data
          io_change      = io_change
          is_assoc       = ls_assoc
        IMPORTING
          et_key_link    = et_key_link
          et_target_key  = et_target_key
          et_data        = et_data ).

      RETURN.
    ENDIF.

  ENDIF.

* ____________________________________________________________________ *
  IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_root OR
     ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent.
    ASSERT ID /bobf/buf_simple CONDITION ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.

*   resolve associations to root or parent nodes
    IF mt_buffer IS INITIAL.
      ls_node-node = iv_node_key.
      LOOP AT it_key INTO ls_key.
        ls_node-key  = ls_key-key.
        INSERT ls_node INTO TABLE lt_load_node.
      ENDLOOP.
      et_failed_key = it_key.
    ELSE.
      LOOP AT it_key INTO ls_key.
        READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
          WITH TABLE KEY state = iv_state
                         node  = iv_node_key
                         key   = ls_key-key.
        IF sy-subrc = 0.
          ls_keylink-source_key = <ls_buf_adm>-key.
          IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_root.
*         Resolve associations to root
            ls_keylink-target_key = <ls_buf_adm>-root_key.
          ELSE.
*         Resolve associations to parent node
            ls_keylink-target_key = <ls_buf_adm>-parent_key.
          ENDIF.
          INSERT ls_keylink INTO TABLE et_key_link.
          ls_target_key-key = ls_keylink-target_key.
          APPEND ls_target_key TO et_target_key.
        ELSE.
          ls_node-node = iv_node_key.
          ls_node-key  = ls_key-key.
          INSERT ls_node INTO TABLE lt_load_node.
          APPEND ls_key TO et_failed_key.
        ENDIF.
      ENDLOOP.
    ENDIF.

*   load not found source nodes and try again
    IF lt_load_node IS NOT INITIAL AND
       ls_assoc-source_node->transient = abap_false AND
       iv_buffer_only = abap_false.

      lt_key = et_failed_key.
      CLEAR et_failed_key.
      IF mo_non_cache_reg->is_read_cache_disabled( iv_node_key ).
        CREATE DATA lr_source_data TYPE STANDARD TABLE OF (ls_assoc-source_node->data_type).
        ASSIGN lr_source_data->* TO <lt_source_data>.
        DATA lt_failed_dummy TYPE /bobf/t_frw_key.
        retrieve_without_caching(
          EXPORTING
            iv_node_key       = iv_node_key
            it_key            = lt_key
            iv_state          = iv_state
            iv_fill_data      = abap_true    " Data element for domain BOOLE: TRUE (='X') and FALSE (=' ')
            iv_buffer_only    = iv_buffer_only
            iv_notify_keyload = iv_notify_keyload    " Data element for domain BOOLE: TRUE (='X') and FALSE (=' ')
            io_change         = io_change
          CHANGING
            ct_node_cat       = lt_node_cat    " Node Category Assignment
            ct_failed_key     = lt_failed_dummy    " Key Table
            ct_data           = <lt_source_data>
        ).
        SORT <lt_source_data> BY (/bobf/if_conf_c=>sc_attribute_name_key).
      ELSE.
        /bobf/if_frw_buffer~load(
           it_node           = lt_load_node
           iv_state          = iv_state
           iv_fill_data      = abap_false
           iv_reload         = abap_false
           iv_notify_keyload = iv_notify_keyload
           io_change         = io_change ).
      ENDIF.

      DATA ls_key_incl TYPE /bobf/s_frw_key_incl.
      DATA lv_hit TYPE boole_d.
      LOOP AT lt_key INTO ls_key.
        CLEAR lv_hit.
        IF <lt_source_data> IS ASSIGNED.
          FIELD-SYMBOLS <ls_key_incl> TYPE /bobf/s_frw_key_incl.
          READ TABLE <lt_source_data> WITH KEY (/bobf/if_conf_c=>sc_attribute_name_key) = ls_key-key BINARY SEARCH
            ASSIGNING <ls_key_incl> CASTING.
          IF sy-subrc = 0.
            lv_hit = abap_true.
            ls_key_incl = <ls_key_incl>.
          ENDIF.
        ELSE.
          READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
            WITH TABLE KEY state = iv_state
                           node  = iv_node_key
                           key   = ls_key-key.
          IF sy-subrc = 0.
            lv_hit = abap_true.
            ls_key_incl = CORRESPONDING #( <ls_buf_adm> ).
          ENDIF.
        ENDIF.
        IF lv_hit = abap_true.
          ls_keylink-source_key = ls_key_incl-key.
          IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_root.
            ls_keylink-target_key = ls_key_incl-root_key.
          ELSE.
            ls_keylink-target_key = ls_key_incl-parent_key.
          ENDIF.
          INSERT ls_keylink INTO TABLE et_key_link.
          ls_target_key-key = ls_keylink-target_key.
          APPEND ls_target_key TO et_target_key.
        ELSE.
          APPEND ls_key TO et_failed_key.
        ENDIF.
      ENDLOOP.
    ENDIF.


*   shorten exporting list
    IF et_target_key IS REQUESTED.
      SORT et_target_key.
      DELETE ADJACENT DUPLICATES FROM et_target_key.
    ENDIF.

    IF iv_fill_data = abap_true.
      /bobf/if_frw_buffer~retrieve(
        EXPORTING
          iv_node_key       = ls_assoc-target_node_key
          it_key            = et_target_key
          iv_state          = iv_state
          iv_fill_data      = abap_true
          iv_buffer_only    = iv_buffer_only
          iv_notify_keyload = iv_notify_keyload
          io_change         = io_change
        IMPORTING
          et_data           = et_data ).
    ENDIF.
    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* foreign key association
  IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_foreign_key.
    ASSERT ID /bobf/buf_simple CONDITION ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.

    READ TABLE lt_runtime_assoc_binding
      WITH KEY from_binding     = /bobf/if_conf_c=>sc_attribute_name_key
               from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_target
      ASSIGNING <ls_assocb>.
    IF sy-subrc = 0.

      IF <ls_assocb>-attribute = /bobf/if_conf_c=>sc_attribute_name_key.
        lv_fill_data = abap_false.
        LOOP AT it_key INTO ls_key.
          READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
            WITH TABLE KEY state = iv_state
                           node  = iv_node_key
                           key   = ls_key-key.
          IF sy-subrc = 0.
            ls_keylink-source_key = <ls_buf_adm>-key.
            ls_keylink-target_key = <ls_buf_adm>-key.
            INSERT ls_keylink INTO TABLE et_key_link.
            ls_target_key-key = ls_keylink-target_key.
            APPEND ls_target_key TO et_target_key.
          ELSE.
            ls_node-node = iv_node_key.
            ls_node-key  = ls_key-key.
            INSERT ls_node INTO TABLE lt_load_node.
            APPEND ls_key TO et_failed_key.
          ENDIF.
        ENDLOOP.
      ELSE.
        lv_fill_data = abap_true.
        LOOP AT it_key INTO ls_key.
          READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
            WITH TABLE KEY state = iv_state
                           node  = iv_node_key
                           key   = ls_key-key.
          IF sy-subrc = 0 AND
             <ls_buf_adm>-data IS BOUND.
            ASSIGN <ls_buf_adm>-data->* TO <ls_buffer>.
            ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
            ASSIGN COMPONENT <ls_assocb>-attribute OF STRUCTURE <ls_buffer> TO <lv_target_key>.
*         configuration error - check your foreign key association
            ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
            CHECK sy-subrc = 0 AND <lv_target_key> IS NOT INITIAL.
            ls_keylink-source_key = <ls_buf_adm>-key.
            ls_keylink-target_key = <lv_target_key>.
            INSERT ls_keylink INTO TABLE et_key_link.
            ls_target_key-key = ls_keylink-target_key.
            APPEND ls_target_key TO et_target_key.
          ELSE.
            ls_node-node = iv_node_key.
            ls_node-key  = ls_key-key.
            INSERT ls_node INTO TABLE lt_load_node.
            APPEND ls_key TO et_failed_key.
          ENDIF.
        ENDLOOP.
      ENDIF.
*     load not found instances and try to read them again
      IF lt_load_node IS NOT INITIAL AND
         ls_assoc-source_node->transient = abap_false AND
         iv_buffer_only = abap_false.
        /bobf/if_frw_buffer~load(
           it_node           = lt_load_node
           iv_state          = iv_state
           iv_fill_data      = lv_fill_data
           iv_reload         = abap_false
           iv_notify_keyload = iv_notify_keyload
           io_change         = io_change ).

        lt_key = et_failed_key.
        CLEAR et_failed_key.
        LOOP AT lt_key INTO ls_key.
          READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
            WITH TABLE KEY state = iv_state
                           node  = iv_node_key
                           key   = ls_key-key.
          IF sy-subrc = 0.
            IF <ls_assocb>-attribute = /bobf/if_conf_c=>sc_attribute_name_key.
              ls_keylink-source_key = <ls_buf_adm>-key.
              ls_keylink-target_key = <ls_buf_adm>-key.
              INSERT ls_keylink INTO TABLE et_key_link.
              ls_target_key-key = ls_keylink-target_key.
              APPEND ls_target_key TO et_target_key.
            ELSEIF <ls_buf_adm>-data IS BOUND.
              ASSIGN <ls_buf_adm>-data->* TO <ls_buffer>.
              ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
              ASSIGN COMPONENT <ls_assocb>-attribute OF STRUCTURE <ls_buffer> TO <lv_target_key>.
*             configuration error - check your foreign key association
              ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
              CHECK sy-subrc = 0 AND <lv_target_key> IS NOT INITIAL.
              ls_keylink-source_key = <ls_buf_adm>-key.
              ls_keylink-target_key = <lv_target_key>.
              INSERT ls_keylink INTO TABLE et_key_link.
              ls_target_key-key = ls_keylink-target_key.
              APPEND ls_target_key TO et_target_key.
            ELSE.
              APPEND ls_key TO et_failed_key.
            ENDIF.
          ELSE.
            APPEND ls_key TO et_failed_key.
          ENDIF.

        ENDLOOP.
      ENDIF.

    ELSE.
*     no binding defined
      ASSERT ID /bobf/buf_simple CONDITION 1 = 0.          "#EC BOOL_OK
      et_failed_key = it_key.
    ENDIF.

*   shorten exporting list
    IF et_target_key IS REQUESTED.
      SORT et_target_key.
      DELETE ADJACENT DUPLICATES FROM et_target_key.
    ENDIF.

    IF iv_fill_data = abap_true AND
       et_target_key IS NOT INITIAL.
      DATA lt_failed_load TYPE /bobf/t_frw_key.
      DATA ls_failed_load TYPE /bobf/s_frw_key.
      /bobf/if_frw_buffer~retrieve(
        EXPORTING
          iv_node_key       = ls_assoc-target_node_key
          it_key            = et_target_key
          iv_state          = iv_state
          iv_fill_data      = abap_true
          iv_buffer_only    = iv_buffer_only
          iv_notify_keyload = iv_notify_keyload
          io_change         = io_change
        IMPORTING
          et_failed_key     = lt_failed_load
          et_data           = et_data ).
      " adapt ET_TARGET_KEY, ET_KEY_LINK and ET_FAILED_KEY to failed load
      LOOP AT lt_failed_load INTO ls_failed_load.
        DELETE et_target_key  WHERE key = ls_failed_load-key.
        DELETE et_key_link    USING KEY target_key  WHERE target_key = ls_failed_load-key.
      ENDLOOP.
    ENDIF.
    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* reverse specialization association
  IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_specialization_r.
    ASSERT ID /bobf/buf_simple CONDITION ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.

    READ TABLE lt_runtime_assoc_binding
      WITH KEY attribute        = /bobf/if_conf_c=>sc_attribute_name_key
               from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_target
               from_binding     = /bobf/if_conf_c=>sc_attribute_name_parent_key
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.

      LOOP AT it_key INTO ls_key.
        READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
          WITH KEY state = iv_state
                   node  = iv_node_key
                   key   = ls_key-key.
        IF sy-subrc = 0 AND <ls_buf_adm>-data IS BOUND.

          lv_found = _eval_assoc_binding(
                     it_runtime_assoc_binding = lt_runtime_assoc_binding
                     is_data                  = <ls_buf_adm>-data
                     is_parameters            = is_parameters
                     it_filtered_attributes   = it_filtered_attributes ).
*         add result
          IF lv_found = abap_true.
            ls_keylink-source_key = <ls_buf_adm>-key.
            ls_keylink-target_key = <ls_buf_adm>-parent_key.
            INSERT ls_keylink INTO TABLE et_key_link.
            ls_target_key-key = ls_keylink-target_key.
            APPEND ls_target_key TO et_target_key.
          ENDIF.
        ELSE.
          ls_node-node = iv_node_key.
          ls_node-key  = ls_key-key.
          INSERT ls_node INTO TABLE lt_load_node.
          APPEND ls_key TO et_failed_key.
        ENDIF.
      ENDLOOP.
*     load not found instances and try to read them again
      IF lt_load_node IS NOT INITIAL AND
         ls_assoc-source_node->transient = abap_false AND
         iv_buffer_only = abap_false.
        /bobf/if_frw_buffer~load(
           it_node           = lt_load_node
           iv_state          = iv_state
           iv_fill_data      = abap_true
           iv_reload         = abap_false
           iv_notify_keyload = iv_notify_keyload
           io_change         = io_change ).

        lt_key = et_failed_key.
        CLEAR et_failed_key.
        LOOP AT lt_key INTO ls_key.
          READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
            WITH KEY state = iv_state
                     node  = iv_node_key
                     key   = ls_key-key.
          IF sy-subrc = 0 AND <ls_buf_adm>-data IS BOUND.
            lv_found = _eval_assoc_binding(
                     it_runtime_assoc_binding = lt_runtime_assoc_binding
                     is_data                  = <ls_buf_adm>-data ).
            IF lv_found = abap_true.
              ls_keylink-source_key = <ls_buf_adm>-key.
              ls_keylink-target_key = <ls_buf_adm>-parent_key.
              INSERT ls_keylink INTO TABLE et_key_link.
              ls_target_key-key = ls_keylink-target_key.
              APPEND ls_target_key TO et_target_key.
            ENDIF.
          ELSE.
            APPEND ls_key TO et_failed_key.
          ENDIF.
        ENDLOOP.
      ENDIF.

    ELSE.
*     no binding defined
      ASSERT ID /bobf/buf_simple CONDITION 1 = 0.          "#EC BOOL_OK
      et_failed_key = it_key.
    ENDIF.

    IF iv_fill_data = abap_true AND
       et_target_key IS NOT INITIAL.
      /bobf/if_frw_buffer~retrieve(
       EXPORTING
         iv_node_key       = ls_assoc-target_node_key
         it_key            = et_target_key
         iv_state          = iv_state
         iv_fill_data      = abap_true
         iv_buffer_only    = iv_buffer_only
         iv_notify_keyload = iv_notify_keyload
         io_change         = io_change
       IMPORTING
         et_data           = et_data ).
    ENDIF.
    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* determine failed keys for target implemented associations
  lt_source_key = it_key.
  IF iv_fill_failed_key = abap_true.
    READ TABLE mt_node_key
      WITH KEY node = iv_node_key
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
*     I'm also buffering the source node -> so check failed keys
*     if not the caller has to care about it (e.g. buffer dispatcher)
      /bobf/if_frw_buffer~retrieve(
        EXPORTING
          iv_node_key       = iv_node_key
          it_key            = lt_source_key
          iv_state          = iv_state
          iv_fill_data      = abap_false
          iv_buffer_only    = iv_buffer_only
          iv_notify_keyload = iv_notify_keyload
          io_change         = io_change
        IMPORTING
          et_failed_key     = et_failed_key ).
*     filter failed keys
      IF et_failed_key IS NOT INITIAL.
        LOOP AT lt_source_key INTO ls_key.
          READ TABLE et_failed_key WITH KEY key_sort
            COMPONENTS key = ls_key-key
            TRANSPORTING NO FIELDS.
          CHECK sy-subrc = 0.
          DELETE lt_source_key.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDIF.
  CHECK lt_source_key IS NOT INITIAL.

* ____________________________________________________________________ *
* reverse foreign key association
  IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_foreign_key_r.
*   standard binding with key of source node
    READ TABLE lt_runtime_assoc_binding
      WITH KEY from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_source
               from_binding     = /bobf/if_conf_c=>sc_attribute_name_key
      ASSIGNING <ls_assocb_lead>.
    IF sy-subrc = 0.
*     search buffer
      IF <ls_assocb_lead>-attribute EQ /bobf/if_conf_c=>sc_attribute_name_root_key AND
         ls_assoc-source_node_key EQ ls_assoc-target_node->root_node_key.
*       Optimized access for association from ROOT node
        IF lines( lt_runtime_assoc_binding ) GT 1.
          lv_root_only_asc = abap_false.
        ELSE.
          lv_root_only_asc = abap_true.
        ENDIF.
        LOOP AT lt_source_key ASSIGNING <ls_key>.
          LOOP AT mt_buffer ASSIGNING <ls_buf_adm> USING KEY root_key
            WHERE root_key = <ls_key>-key
              AND state    = iv_state
              AND node     = ls_assoc-target_node_key.
            IF lv_root_only_asc EQ abap_false.   ":-(
              CHECK <ls_buf_adm>-data IS BOUND.
              ASSIGN <ls_buf_adm>-data->* TO <ls_buffer>.
              ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
*             check for fitting entries
              lv_found = _eval_assoc_binding(
                 it_runtime_assoc_binding = lt_runtime_assoc_binding
                 is_data                  = <ls_buf_adm>-data
              ).
            ENDIF.
            IF lv_root_only_asc EQ abap_true OR
               lv_found         EQ abap_true.
              ls_keylink-source_key = <ls_key>-key.
              ls_keylink-target_key = <ls_buf_adm>-key.
              INSERT ls_keylink INTO TABLE et_key_link.
              ls_target_key-key = <ls_buf_adm>-key.
              APPEND ls_target_key TO et_target_key.
            ENDIF.
          ENDLOOP.
        ENDLOOP.
      ELSE.
*       Standard case
        LOOP AT mt_buffer ASSIGNING <ls_buf_adm>
          WHERE state = iv_state
            AND node  = ls_assoc-target_node_key.
          CHECK <ls_buf_adm>-data IS BOUND.
          ASSIGN <ls_buf_adm>-data->* TO <ls_buffer>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
*         evaluate source binding
          ASSIGN COMPONENT <ls_assocb_lead>-attribute OF STRUCTURE <ls_buffer> TO <lv_target_key>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          READ TABLE lt_source_key INTO ls_key WITH KEY key_sort COMPONENTS key = <lv_target_key>.
          CHECK sy-subrc = 0.

*         check for fitting entries
          lv_found = _eval_assoc_binding(
               it_runtime_assoc_binding = lt_runtime_assoc_binding
               is_data                  = <ls_buf_adm>-data
           ).
          IF lv_found = abap_true.
            ls_keylink-source_key = ls_key-key.
            ls_keylink-target_key = <ls_buf_adm>-key.
            INSERT ls_keylink INTO TABLE et_key_link.
            ls_target_key-key = <ls_buf_adm>-key.
            APPEND ls_target_key TO et_target_key.
          ENDIF.
        ENDLOOP.
      ENDIF.
*     read keys from database
      APPEND <ls_assocb_lead>-attribute TO lt_attribute.
      LOOP AT lt_runtime_assoc_binding ASSIGNING <ls_assocb>
        WHERE from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_constant.
        APPEND <ls_assocb>-attribute TO lt_attribute.
      ENDLOOP.
      IF sy-subrc = 0.
        CREATE DATA ls_data TYPE (ls_assoc-target_node->data_type).   "combined data type
        ASSIGN ls_data->* TO <ls_data>.
        CREATE DATA lt_data TYPE STANDARD TABLE OF (ls_assoc-target_node->data_type).   "combined data type
        ASSIGN lt_data->* TO <lt_data>.
        LOOP AT lt_runtime_assoc_binding ASSIGNING <ls_assocb>
          WHERE from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_constant.
          ASSIGN COMPONENT <ls_assocb>-attribute OF STRUCTURE <ls_data> TO <lv_attribute>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          ASSIGN (<ls_assocb>-constant) TO <lv_constant>.
          <lv_attribute> = <lv_constant>.
        ENDLOOP.
        ASSIGN COMPONENT <ls_assocb_lead>-attribute OF STRUCTURE <ls_data> TO <lv_target_key>.
        ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
        ls_rev_fk-assoc_key       = ls_assoc-assoc_key.
        ls_rev_fk-source_node_key = ls_assoc-source_node_key.
        ls_rev_fk-target_node_key = ls_assoc-target_node_key.
        LOOP AT lt_source_key INTO ls_key.
          IF ls_assoc-target_node->loadable = abap_true.
            READ TABLE mt_buffer_rev_fk WITH KEY assoc_key = ls_assoc-assoc_key
                                                 source_key = ls_key-key
                                                 TRANSPORTING NO FIELDS.
            CHECK sy-subrc <> 0.
            ls_rev_fk-source_key      = ls_key-key.
            INSERT ls_rev_fk INTO TABLE mt_buffer_rev_fk.
          ENDIF.
          <lv_target_key> = ls_key-key.
          APPEND <ls_data> TO <lt_data>.
          APPEND ls_key-key TO lt_key2.
        ENDLOOP.
      ELSE.
        ls_rev_fk-assoc_key       = ls_assoc-assoc_key.
        ls_rev_fk-source_node_key = ls_assoc-source_node_key.
        ls_rev_fk-target_node_key = ls_assoc-target_node_key.
        LOOP AT lt_source_key INTO ls_key.
          IF ls_assoc-target_node->loadable = abap_true.
            READ TABLE mt_buffer_rev_fk WITH KEY assoc_key = ls_assoc-assoc_key
                                                 source_key = ls_key-key
                                                 TRANSPORTING NO FIELDS.
            CHECK sy-subrc <> 0.
*           Assume the data will be loaded successfully in a later step of this method
            ls_rev_fk-source_key      = ls_key-key.
            INSERT ls_rev_fk INTO TABLE mt_buffer_rev_fk.
          ENDIF.
          APPEND ls_key-key TO lt_key2.
        ENDLOOP.
        ASSIGN lt_key2 TO <lt_data>.
      ENDIF.

      IF <lt_data> IS NOT INITIAL.
        IF ls_assoc-target_node->loadable = abap_true AND io_change IS SUPPLIED.
          mo_data_access->read_by_attributes(
            EXPORTING
              iv_node_key   = ls_assoc-target_node_key
              it_data       = <lt_data>
              it_attributes = lt_attribute
              iv_scope      = /bobf/if_buf_c=>sc_scope_loadgroup
              iv_fill_data  = abap_true
            IMPORTING
              et_result     = lt_result
              et_data       = lt_buf_data_read ).

          IF lt_buf_data_read IS NOT INITIAL.
            IF iv_fill_data = abap_false OR iv_notify_keyload = abap_true.
              write_loaded_data(
                it_data        = lt_buf_data_read
                iv_state       = iv_state
                iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
                iv_scope       = /bobf/if_buf_c=>sc_scope_loadgroup
                io_change      = io_change ).
            ELSE.
              write_loaded_data(
                it_data        = lt_buf_data_read
                iv_state       = iv_state
                iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                iv_scope       = /bobf/if_buf_c=>sc_scope_loadgroup
                io_change      = io_change ).
            ENDIF.
          ENDIF.
        ELSE.
          mo_data_access->read_by_attributes(
            EXPORTING
              iv_node_key   = ls_assoc-target_node_key
              it_data       = <lt_data>
              it_attributes = lt_attribute
              iv_scope      = /bobf/if_buf_c=>sc_scope_node
              iv_fill_data  = abap_false
            IMPORTING
              et_result     = lt_result ).

          IF iv_fill_data = abap_false AND io_change IS SUPPLIED.
*         data not loaded - put loaded keys in buffer
            ls_node-node = ls_assoc-target_node_key.
            LOOP AT lt_result INTO ls_result.
              READ TABLE mt_buffer WITH KEY
                  state = iv_state
                  node  = ls_node-node
                  key   = ls_result-key
                  TRANSPORTING NO FIELDS.
              IF sy-subrc <> 0.
                ls_node-key = ls_result-key.
                INSERT ls_node INTO TABLE lt_node.
              ENDIF.
            ENDLOOP.

            IF lt_node IS NOT INITIAL.
              mo_data_access->read(
                EXPORTING
                  it_node      = lt_node
                  iv_fill_data = abap_false
                  iv_scope     = /bobf/if_buf_c=>sc_scope_till_loadable
                IMPORTING
                  et_data      = lt_buf_data_read ).
            ENDIF.

            IF lt_buf_data_read IS NOT INITIAL.
              write_loaded_data(
                it_data        = lt_buf_data_read
                iv_state       = iv_state
                iv_reload      = abap_false
                iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
                iv_scope       = /bobf/if_buf_c=>sc_scope_till_loadable
                io_change      = io_change ).
            ENDIF.
          ENDIF.
        ENDIF.

        "  filter result target instances
        LOOP AT lt_result INTO ls_result.
          lv_valid = abap_true.
          IF iv_state <> /bobf/if_conf_c=>sc_state_database.
            " filter out deleted target instances
            READ TABLE mt_change
              WITH KEY change   = /bobf/if_frw_c=>sc_modify_delete
                       node_key = ls_assoc-target_node_key
                       key      = ls_result-key
                       TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              lv_valid = abap_false.
            ELSE.
              " filter out target node instances, whose foreign key attribut is cleared or does not fit to source key anymore
              READ TABLE mt_buffer
                WITH KEY state = iv_state
                         node  = ls_assoc-target_node_key
                         key   = ls_result-key
                         REFERENCE INTO lv_ref_buffer.
              IF sy-subrc = 0 AND lv_ref_buffer->data IS BOUND.
                ASSIGN lv_ref_buffer->data->* TO <ls_buffer>.
                ASSERT CONDITION sy-subrc = 0.
                ASSIGN COMPONENT <ls_assocb_lead>-attribute OF STRUCTURE <ls_buffer> TO <lv_target_key>.
                ASSERT CONDITION sy-subrc = 0.
                IF <lv_target_key> IS INITIAL.
                  lv_valid = abap_false.
                ELSE.
                  READ TABLE lt_key2 INTO ls_key-key INDEX ls_result-index.
                  ASSERT CONDITION sy-subrc = 0.
                  IF <lv_target_key> NE ls_key-key.
                    lv_valid = abap_false.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
          IF lv_valid = abap_true.
            READ TABLE lt_key2 INTO ls_key-key INDEX ls_result-index.
            ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
            READ TABLE et_key_link INTO ls_keylink
              WITH KEY source_key = ls_key-key
                       target_key = ls_result-key.
            IF sy-subrc <> 0.
              ls_keylink-source_key = ls_key-key.
              ls_keylink-target_key = ls_result-key.
              INSERT ls_keylink INTO TABLE et_key_link.
              ls_target_key-key = ls_result-key.
              APPEND ls_target_key TO et_target_key.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ELSE.
*     no key binding defined -> not supported
      ASSERT ID /bobf/buf_simple CONDITION 1 = 0.          "#EC BOOL_OK
      RETURN.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* check filtering
  IF it_filtered_attributes IS NOT INITIAL AND
     is_parameters          IS BOUND.
    READ TABLE lt_runtime_assoc_binding
      WITH KEY from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_filter
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_filter = abap_true.
      ASSIGN is_parameters->* TO <ls_filter>.
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* check whether association can be answered
  IF lv_filter           = abap_false                        AND
     ls_assoc-assoc_type = /bobf/if_conf_c=>sc_assoctype_std AND
     ls_assoc-assoc_cat  = /bobf/if_conf_c=>sc_assoccat_normal.
    ASSERT ID /bobf/buf_simple CONDITION 1 = 0.            "#EC BOOL_OK
    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* check for associations with target node in other loadable node
  IF ls_assoc-target_node->transient = abap_false AND
     iv_buffer_only                  = abap_false.

    IF lv_filter    = abap_true OR
       iv_fill_data = abap_true OR
       ( ls_assoc-assoc_type <> /bobf/if_conf_c=>sc_assoctype_comp AND
         lt_runtime_assoc_binding IS NOT INITIAL ).
      lv_fill_data = abap_true.
    ENDIF.

    CLEAR lt_selection.
    LOOP AT lt_runtime_assoc_binding ASSIGNING <ls_assocb> WHERE data_access_rele = abap_true. "#EC CI_SORTSEQ
      CHECK <ls_assocb>-attribute <> 'PARENT_KEY'.
      READ TABLE lt_selection WITH TABLE KEY attribute = <ls_assocb>-attribute REFERENCE INTO ls_selection.
      IF sy-subrc <> 0.
        CREATE DATA ls_selection.
        ls_selection->attribute = <ls_assocb>-attribute.
        INSERT ls_selection->* INTO TABLE lt_selection REFERENCE INTO ls_selection.
      ENDIF.

      CASE <ls_assocb>-from_binding_cat.

*       Constant Binding
        WHEN /bobf/if_conf_c=>sc_assocbcat_constant.
          ls_range-sign = 'I'.
          ls_range-option = <ls_assocb>-sign.
          ASSIGN <ls_assocb>-constant_value->* TO <lv_constant>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          CASE <ls_assocb>-sign.
            WHEN /bobf/if_conf_c=>sc_sign_equal
              OR /bobf/if_conf_c=>sc_sign_not_equal
              OR /bobf/if_conf_c=>sc_sign_greater
              OR /bobf/if_conf_c=>sc_sign_greater_equal
              OR /bobf/if_conf_c=>sc_sign_less
              OR /bobf/if_conf_c=>sc_sign_less_equal.
              ls_range-low = <lv_constant>.
              INSERT ls_range INTO TABLE ls_selection->range.
            WHEN OTHERS.
*             "Between" not yet supported for binding
              ASSERT ID /bobf/buf_simple CONDITION 1 = 0.  "#EC BOOL_OK
          ENDCASE.

*       Filtered Binding
        WHEN /bobf/if_conf_c=>sc_assocbcat_filter.
          READ TABLE it_filtered_attributes
            WITH KEY table_line = <ls_assocb>-from_binding
            TRANSPORTING NO FIELDS.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          CHECK sy-subrc = 0.
*         assign fields
          ASSIGN COMPONENT <ls_assocb>-from_binding OF STRUCTURE <ls_filter> TO <lv_filter>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          ls_range-sign = 'I'.
          ls_range-option = <ls_assocb>-sign.
          CASE <ls_assocb>-sign.
            WHEN /bobf/if_conf_c=>sc_sign_equal
              OR /bobf/if_conf_c=>sc_sign_not_equal
              OR /bobf/if_conf_c=>sc_sign_greater
              OR /bobf/if_conf_c=>sc_sign_greater_equal
              OR /bobf/if_conf_c=>sc_sign_less
              OR /bobf/if_conf_c=>sc_sign_less_equal.
              ls_range-low = <lv_filter>.
              INSERT ls_range INTO TABLE ls_selection->range.
            WHEN OTHERS.
*             "Between" not yet supported for binding
              ASSERT ID /bobf/buf_simple CONDITION 1 = 0.  "#EC BOOL_OK
          ENDCASE.

*       Source Binding
        WHEN /bobf/if_conf_c=>sc_assocbcat_source.
          LOOP AT it_key INTO ls_key.
            READ TABLE mt_buffer ASSIGNING <ls_data>
              WITH KEY node  = iv_node_key
                       state = iv_state
                       key   = ls_key-key.
            IF sy-subrc = 0.
              ASSIGN COMPONENT <ls_assocb>-from_binding OF STRUCTURE <ls_data> TO <lv_attribute>.
              ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
              CHECK sy-subrc = 0.
              ls_range-sign = 'I'.
              ls_range-option = <ls_assocb>-sign.
              CASE <ls_assocb>-sign.
                WHEN /bobf/if_conf_c=>sc_sign_equal
                  OR /bobf/if_conf_c=>sc_sign_not_equal
                  OR /bobf/if_conf_c=>sc_sign_greater
                  OR /bobf/if_conf_c=>sc_sign_greater_equal
                  OR /bobf/if_conf_c=>sc_sign_less
                  OR /bobf/if_conf_c=>sc_sign_less_equal.
                  ls_range-low = <lv_attribute>.
                  INSERT ls_range INTO TABLE ls_selection->range.
                WHEN OTHERS.
*                 "Between" not yet supported for binding
                  ASSERT ID /bobf/buf_simple CONDITION 1 = 0. "#EC BOOL_OK
              ENDCASE.
            ENDIF.
          ENDLOOP.

        WHEN /bobf/if_conf_c=>sc_assocbcat_target.
          ASSERT ID /bobf/buf_simple CONDITION 1 = 0.      "#EC BOOL_OK
      ENDCASE.
    ENDLOOP.

    load_composition(
      it_key              = lt_source_key
      is_assoc            = ls_assoc
      iv_fill_data        = lv_fill_data
      iv_state            = iv_state
      it_selection        = lt_selection
      iv_notify_keyload   = iv_notify_keyload
      iv_invalidate_cache = iv_invalidate_cache
      io_change           = io_change ).
  ENDIF.

* sort key table if read is expected
  READ TABLE mt_buffer TRANSPORTING NO FIELDS
    WITH KEY state = iv_state
             node  = ls_assoc-target_node_key.
  CLEAR lv_tabix.
  IF sy-subrc = 0.
    lv_tabix = sy-tabix.
  ENDIF.

* ____________________________________________________________________ *
  IF ls_assoc-assoc_type = /bobf/if_conf_c=>sc_assoctype_comp.
    ASSERT ID /bobf/buf_simple CONDITION
        ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target OR
        ls_assoc-target_node->key_inherited = abap_true.

*   resolve compositions
    LOOP AT lt_source_key INTO ls_key.
      LOOP AT mt_buffer ASSIGNING <ls_buf_adm> USING KEY parent_key
         WHERE state = iv_state AND
               node = ls_assoc-target_node_key AND
               parent_key = ls_key-key.
        ls_keylink-source_key = <ls_buf_adm>-parent_key.
        ls_keylink-target_key = <ls_buf_adm>-key.
        INSERT ls_keylink INTO TABLE et_key_link.
        ls_target_key-key = <ls_buf_adm>-key.
        APPEND ls_target_key TO et_target_key.
      ENDLOOP.
    ENDLOOP.
  ELSE.
* ____________________________________________________________________ *
    IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_specialization.
      ASSERT ID /bobf/buf_simple CONDITION ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target.

*     specialization parallel to a composition
      READ TABLE lt_runtime_assoc_binding
        WITH KEY attribute        = /bobf/if_conf_c=>sc_attribute_name_parent_key
                 from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_source
                 from_binding     = /bobf/if_conf_c=>sc_attribute_name_key
        TRANSPORTING NO FIELDS.

      IF sy-subrc = 0.
        LOOP AT lt_source_key INTO ls_key.
          LOOP AT mt_buffer ASSIGNING <ls_buf_adm> USING KEY parent_key
             WHERE state = iv_state AND
                   node = ls_assoc-target_node_key AND
                   parent_key = ls_key-key.
            lv_found = _eval_assoc_binding(
                   it_runtime_assoc_binding = lt_runtime_assoc_binding
                   is_parameters          = is_parameters
                   is_data                = <ls_buf_adm>-data ).
            IF lv_found = abap_true.
              ls_keylink-source_key = <ls_buf_adm>-parent_key.
              ls_keylink-target_key = <ls_buf_adm>-key.
              INSERT ls_keylink INTO TABLE et_key_link.
              ls_target_key-key = <ls_buf_adm>-key.
              APPEND ls_target_key TO et_target_key.
            ENDIF.
          ENDLOOP.
        ENDLOOP.

      ELSE.
*       no binding defined
        ASSERT ID /bobf/buf_simple CONDITION 1 = 0.        "#EC BOOL_OK
        RETURN.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
    IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_normal.

*     standard binding with key of source node
      READ TABLE lt_runtime_assoc_binding
        WITH KEY from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_source
                 from_binding     = /bobf/if_conf_c=>sc_attribute_name_key
        ASSIGNING <ls_assocb_lead>.
      IF sy-subrc = 0.
*       association category should be reverse foreign key -> run check & correct
        ASSERT ID /bobf/buf_simple CONDITION 1 = 0.        "#EC BOOL_OK
        IF lv_tabix <> 0.
*         search buffer
          LOOP AT mt_buffer ASSIGNING <ls_buf_adm> FROM lv_tabix
            WHERE state = iv_state
              AND node  = ls_assoc-target_node_key.
            CHECK <ls_buf_adm>-data IS BOUND.
            ASSIGN <ls_buf_adm>-data->* TO <ls_buffer>.
            ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
*           evaluate source binding
            ASSIGN COMPONENT <ls_assocb_lead>-attribute OF STRUCTURE <ls_buffer> TO <lv_target_key>.
            ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.

            READ TABLE lt_source_key WITH KEY key_sort
              COMPONENTS key = <lv_target_key>
              TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
*             check constants for target node
              lv_found = _eval_assoc_binding(
                     it_runtime_assoc_binding = lt_runtime_assoc_binding
                     is_data                  = <ls_buf_adm>-data ).
              IF lv_found = abap_true.
                ls_keylink-source_key = <lv_target_key>.
                ls_keylink-target_key = <ls_buf_adm>-key.
                INSERT ls_keylink INTO TABLE et_key_link.
                ls_target_key-key = <ls_buf_adm>-key.
                APPEND ls_target_key TO et_target_key.
              ENDIF.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ELSE.
*       no key binding defined -> not supported
        ASSERT ID /bobf/buf_simple CONDITION 1 = 0.        "#EC BOOL_OK
        RETURN.
      ENDIF.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* evaluate filter
  IF lv_filter = abap_true.
*   load target node if optimized access is enabled
    LOOP AT et_key_link INTO ls_keylink.
      READ TABLE mt_buffer ASSIGNING <ls_buf_adm>
        WITH TABLE KEY state = iv_state
                       node  = ls_assoc-target_node_key
                       key   = ls_keylink-target_key.
*     target node data not found in buffer (filter cannot be checked!)
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
      CHECK sy-subrc = 0.

      lv_found = _eval_assoc_binding(
                     it_runtime_assoc_binding = lt_runtime_assoc_binding
                     is_data                  = <ls_buf_adm>-data
                     is_parameters            = is_parameters
                     it_filtered_attributes   = it_filtered_attributes ).

      IF lv_found = abap_false.
*       filter entry out of the result list
        DELETE et_target_key USING KEY key_sort WHERE key = ls_keylink-target_key.
        DELETE et_key_link.
      ENDIF.

    ENDLOOP.
  ENDIF.

  SORT et_target_key.
  DELETE ADJACENT DUPLICATES FROM et_target_key.

* fill data if requested
  IF iv_fill_data = abap_true.
    /bobf/if_frw_buffer~retrieve(
     EXPORTING
       iv_node_key       = ls_assoc-target_node_key
       it_key            = et_target_key
       iv_state          = iv_state
       iv_fill_data      = abap_true
       iv_buffer_only    = iv_buffer_only
       iv_notify_keyload = iv_notify_keyload
       io_change         = io_change
     IMPORTING
       et_data           = et_data
       et_failed_key     = lt_key ).

    LOOP AT lt_key INTO ls_key.
      DELETE et_target_key USING KEY key_sort WHERE key = ls_key-key.
      DELETE et_key_link   USING KEY target_key WHERE target_key = ls_key-key.
    ENDLOOP.
  ELSEIF iv_notify_keyload = abap_false
     AND io_change IS BOUND.
*   check for keyload -> notify load if necessary

    "performance optimization: do we have to call the (expensive) GET_SUBTREE method at all?
    READ TABLE mt_change TRANSPORTING NO FIELDS WITH KEY change = /bobf/if_frw_c=>sc_modify_load_key ##PRIMKEY[CHANGE].
    IF sy-subrc = 0.

*     Create pending load notifications for entire loading group

*     First determine all nodes in local loading group
      IF ls_assoc-target_node_key = mo_conf->ms_last_node-node_key.
        ls_target_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node( EXPORTING iv_node_key = ls_assoc-target_node_key
                           IMPORTING es_node     = ls_target_node ).
      ENDIF.
      get_loadable_node( EXPORTING iv_node_key     = ls_target_node-node_key
                                   io_conf         = mo_conf
                                   iv_buffer_class = ls_target_node-buf_class
                         IMPORTING ev_node_key     = lv_lead_node_key ).
      get_subtree( EXPORTING iv_node_key     = lv_lead_node_key
                             io_conf         = mo_conf
                             iv_buffer_class = ls_target_node-buf_class
                   IMPORTING et_node_key     = lt_group_node_key ).

      LOOP AT lt_group_node_key INTO ls_node_key.
        CLEAR lt_key.
        LOOP AT mt_change INTO ls_change
          WHERE node_key = ls_node_key-key
            AND change   = /bobf/if_frw_c=>sc_modify_load_key.
          ls_key-key = ls_change-key.
          APPEND ls_key TO lt_key.
          DELETE mt_change.
        ENDLOOP.
        IF lt_key IS NOT INITIAL.
          io_change->add_change(
            EXPORTING
              iv_change_mode = /bobf/if_frw_c=>sc_modify_load
              iv_node_key    = ls_node_key-key
              it_key         = lt_key ).
        ENDIF.
      ENDLOOP.

    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD /bobf/if_frw_buffer~transfer_state.

* copies all entries from one state to another
* note: the subtree is only transferred if root node is used!

  DATA: ls_source              TYPE                   /bobf/s_buf_simple_buffer,
        ls_target              TYPE                   /bobf/s_buf_simple_buffer,
        lt_buffer_new          TYPE STANDARD TABLE OF /bobf/s_buf_simple_buffer,
        lv_source_state_exists TYPE                   boole_d,
        lv_no_target_state     TYPE                   c,
        lv_state_dest          TYPE                   /bobf/conf_state,
        lt_state_dest          TYPE SORTED TABLE OF   /bobf/conf_state WITH UNIQUE KEY table_line,
        lt_state_to_delete     LIKE                   lt_state_dest,
        lv_state_to_delete     TYPE                   /bobf/conf_state,
        lv_tabix               TYPE                   i.

  FIELD-SYMBOLS:
    <ls_node>       TYPE /bobf/s_frw_node,
    <ls_buf_delete> TYPE /bobf/s_buf_simple_buffer.


  BREAK-POINT ID /bobf/buf_simple.

  ev_add_state_dest_transferred = abap_true.

  "analyze states
  INSERT iv_state_dest INTO TABLE lt_state_dest.
  INSERT LINES OF it_additional_state_dest INTO TABLE lt_state_dest.
  lt_state_to_delete = lt_state_dest.

  LOOP AT lt_state_to_delete INTO lv_state_to_delete.
    IF lv_state_to_delete = iv_state_source.
      DELETE lt_state_to_delete.
      DELETE lt_state_dest FROM lv_state_to_delete.
    ENDIF.
    READ TABLE mt_buffer WITH KEY state = lv_state_to_delete BINARY SEARCH TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE lt_state_to_delete.
    ENDIF.
  ENDLOOP.

  IF lt_state_dest IS INITIAL.
    RETURN.
  ENDIF.

  IF NOT mt_buffer IS INITIAL.

    IF iv_incl_subtree = abap_true."with subtree (node has to be root node)

      "check for source state
      READ TABLE mt_buffer WITH KEY
         state = iv_state_source BINARY SEARCH TRANSPORTING NO FIELDS.
      lv_source_state_exists = boolc( sy-subrc = 0 ).

      IF lv_source_state_exists = abap_true OR lt_state_to_delete IS NOT INITIAL.

        LOOP AT it_node ASSIGNING <ls_node>.

*         delete target state
          IF NOT lt_state_to_delete IS INITIAL.
            LOOP AT mt_buffer ASSIGNING <ls_buf_delete>
               USING KEY root_key
                 WHERE root_key = <ls_node>-key.
              READ TABLE lt_state_to_delete WITH TABLE KEY
                table_line = <ls_buf_delete>-state TRANSPORTING NO FIELDS.
              CHECK sy-subrc = 0.
              DELETE TABLE mt_buffer WITH TABLE KEY
                  state = <ls_buf_delete>-state
                  node = <ls_buf_delete>-node
                  key = <ls_buf_delete>-key.
            ENDLOOP.
          ENDIF.

*         copy source state
          IF lv_source_state_exists = abap_true.
            LOOP AT mt_buffer INTO ls_target USING KEY root_key
              WHERE state    = iv_state_source
                AND root_key = <ls_node>-key.
              LOOP AT lt_state_dest INTO ls_target-state.
                APPEND ls_target TO lt_buffer_new.
              ENDLOOP.
            ENDLOOP.
          ENDIF.

        ENDLOOP.

*       separate append insert faster due to unique primary key of buffer table
        INSERT LINES OF lt_buffer_new INTO TABLE mt_buffer.
      ENDIF.

    ELSE.

      LOOP AT lt_state_dest INTO lv_state_dest.

        CLEAR lv_no_target_state.
        CLEAR lv_tabix.

*   check if target state exists at all
        READ TABLE mt_buffer TRANSPORTING NO FIELDS
              WITH KEY state = lv_state_dest
          BINARY SEARCH.
        IF sy-subrc <> 0.
          lv_no_target_state = abap_true.
          lv_tabix = sy-tabix.
        ENDIF.

*   transfer only defined node instances
        LOOP AT it_node ASSIGNING <ls_node>.
*     get source
          READ TABLE mt_buffer
            WITH TABLE KEY
              state = iv_state_source
                node  = <ls_node>-node
                key   = <ls_node>-key
            INTO ls_source.
          IF sy-subrc <> 0.
*       source not found -> delete in target state
            DELETE mt_buffer
                  WHERE state = lv_state_dest
                  AND node  = <ls_node>-node
                  AND key   = <ls_node>-key.

          ELSEIF lv_no_target_state = abap_true.
*       not existing target state -> create in target state
            ls_source-state = lv_state_dest.
            INSERT ls_source INTO mt_buffer INDEX lv_tabix.
            ADD 1 TO lv_tabix. "next entry as it_node sorted also
          ELSE.
*       search for target
            READ TABLE mt_buffer
              WITH TABLE KEY
                    state = lv_state_dest
                  node  = <ls_node>-node
                  key   = <ls_node>-key
              INTO ls_target.
            lv_tabix = sy-tabix.
            IF sy-subrc <> 0.
*         not found in target -> create in target state
              ls_source-state = lv_state_dest.
              INSERT ls_source INTO mt_buffer INDEX lv_tabix.
            ELSE.
*         found in target -> update target
              ls_target-node_cat_key = ls_source-node_cat_key.
              ls_target-data         = ls_source-data.
              MODIFY mt_buffer INDEX lv_tabix FROM ls_target.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Additional coding for sync point support
  DATA:
    ls_change_sync TYPE REF TO ty_change_sync.

* create sync point -> keep current changes
  LOOP AT lt_state_dest INTO lv_state_dest WHERE table_line CO gc_sync_state. "#EC CI_SORTSEQ
    CLEAR ls_change_sync.
    READ TABLE mt_change_sync REFERENCE INTO ls_change_sync
      WITH TABLE KEY state = lv_state_dest.
    ASSERT ID /bobf/buf_simple CONDITION sy-subrc <> 0.
    IF sy-subrc = 0.
      ls_change_sync->change = mt_change.
    ELSE.
      CREATE DATA ls_change_sync.
      ls_change_sync->state  = lv_state_dest.
      ls_change_sync->change = mt_change.
      INSERT ls_change_sync->* INTO TABLE mt_change_sync.
    ENDIF.

  ENDLOOP.

* rollback to sync point -> remove new changes
  IF iv_state_source CO gc_sync_state.
    IF mt_change IS NOT INITIAL.
      READ TABLE mt_change_sync REFERENCE INTO ls_change_sync
        WITH TABLE KEY state = iv_state_source.
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
      IF sy-subrc = 0 AND ls_change_sync->rollback_done = abap_false.
        DELETE ls_change_sync->change
          WHERE change <> /bobf/if_frw_c=>sc_modify_create
            AND change <> /bobf/if_frw_c=>sc_modify_update
            AND change <> /bobf/if_frw_c=>sc_modify_delete. "#EC CI_SORTSEQ
        DELETE mt_change
          WHERE change =  /bobf/if_frw_c=>sc_modify_create
            OR  change =  /bobf/if_frw_c=>sc_modify_update
            OR  change =  /bobf/if_frw_c=>sc_modify_delete. "#EC CI_SORTSEQ
        INSERT LINES OF ls_change_sync->change INTO TABLE mt_change.
        ls_change_sync->rollback_done = abap_true.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD /bobf/if_frw_cloneable~clone.

  DATA: lo_descr        TYPE REF TO cl_abap_objectdescr,
        ls_attr_descr   TYPE abap_attrdescr,
        ls_node_key     TYPE /bobf/s_frw_node_only,
        ls_leading_node TYPE /bobf/s_confro_node,
        lv_classname    TYPE string,
        ls_node_key2    TYPE /bobf/s_frw_key,
        lt_node_key     TYPE /bobf/t_frw_key,
        lx_root         TYPE REF TO cx_root.

  "Dont delete
  DATA:        lo_buffer TYPE REF TO /bobf/cl_buf_simple.

  FIELD-SYMBOLS:
    <lv_src_field> TYPE any,
    <lv_tgt_field> TYPE any.

  IF iv_deep_clone = abap_false.
    LOOP AT mt_node_key INTO ls_node_key.
      ls_node_key2-key = ls_node_key-node.
      INSERT ls_node_key2 INTO TABLE lt_node_key.
    ENDLOOP.

    LOOP AT mt_node_key INTO ls_node_key.
      mo_conf->get_node(
        EXPORTING
          iv_node_key = ls_node_key-node
        IMPORTING
          es_node     = ls_leading_node ).

      IF ls_leading_node-loadable = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    TRY.

        lo_descr ?= cl_abap_typedescr=>describe_by_object_ref( me ).
        lv_classname = lo_descr->get_relative_name( ).
        CREATE OBJECT eo_buffer TYPE (lv_classname)
          EXPORTING
            iv_bo_key   = me->mv_bo_key
            iv_node_key = ls_leading_node-node_key
            it_node_key = lt_node_key.

        lo_buffer ?= eo_buffer.

        LOOP AT lo_descr->attributes INTO ls_attr_descr
          WHERE is_class    = abap_false
            AND is_constant = abap_false.

          ASSIGN me->(ls_attr_descr-name) TO <lv_src_field>.
          ASSERT sy-subrc = 0.
          ASSIGN lo_buffer->(ls_attr_descr-name) TO <lv_tgt_field>.
          ASSERT sy-subrc = 0.
          <lv_tgt_field> = <lv_src_field>.
        ENDLOOP.

      CATCH cx_root INTO lx_root.

        RAISE EXCEPTION TYPE /bobf/cx_frw_fatal
          EXPORTING
            previous = lx_root.

    ENDTRY.
  ELSE.
    TYPES: BEGIN OF lty_data_ref_association,
             original TYPE REF TO data,
             clone    TYPE REF TO data,
           END OF lty_data_ref_association.
    DATA: lt_data_ref_dictionary  TYPE SORTED TABLE OF lty_data_ref_association WITH UNIQUE KEY original,
          ls_data_ref_association TYPE lty_data_ref_association.
    FIELD-SYMBOLS: <ls_buffer>        LIKE LINE OF mt_buffer,
                   <ls_original_data> TYPE data,
                   <ls_clone_data>    TYPE data.

    SYSTEM-CALL OBJMGR CLONE me TO eo_buffer.        "#EC CI_SYSTEMCALL
    lo_buffer ?= eo_buffer.
    LOOP AT lo_buffer->mt_buffer ASSIGNING <ls_buffer> WHERE data IS BOUND.
      " re-use already cloned memory addresses:
      READ TABLE lt_data_ref_dictionary
           INTO ls_data_ref_association TRANSPORTING clone
           WITH KEY original = <ls_buffer>-data.
      IF sy-subrc = 0.
        <ls_buffer>-data = ls_data_ref_association-clone.
      ELSE.
        "create new data reference and store replacement in dictionary:
        ls_data_ref_association-original = <ls_buffer>-data.
        ASSIGN <ls_buffer>-data->* TO <ls_original_data>.
        CREATE DATA <ls_buffer>-data LIKE <ls_original_data>.
        ls_data_ref_association-clone = <ls_buffer>-data.
        ASSIGN <ls_buffer>-data->* TO <ls_clone_data>.
        <ls_clone_data> = <ls_original_data>.
        INSERT ls_data_ref_association INTO TABLE lt_data_ref_dictionary.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDMETHOD.


  METHOD apply_update_disabled_fields.

    "overwrite update disabled fields from original value
    FIELD-SYMBOLS <lv_buffered_field> TYPE any.
    FIELD-SYMBOLS <lv_target_field> TYPE any.

    LOOP AT it_property_int ASSIGNING FIELD-SYMBOL(<ls_property_int>) USING KEY property WHERE
        property_name = /bobf/if_conf_c=>sc_property_name_update_enable AND
        value = abap_false.
      ASSIGN COMPONENT <ls_property_int>-component OF STRUCTURE is_buffered_data TO <lv_buffered_field>.
      ASSIGN COMPONENT <ls_property_int>-component OF STRUCTURE cs_changed_data TO <lv_target_field>.
      <lv_target_field> = <lv_buffered_field>.
    ENDLOOP.

  ENDMETHOD.


METHOD clear_comp_tab.

  DATA:
    ls_conf_comp  TYPE /bobf/s_confro_assoc2,
    ls_node       TYPE /bobf/s_frw_node,
    ls_key        TYPE /bobf/s_frw_key,
    lt_key        TYPE /bobf/t_frw_key,
    lt_target_key TYPE /bobf/t_frw_key.


  IF iv_source_node_key IS INITIAL.
    LOOP AT it_source_node INTO ls_node.
      AT NEW node.
        CLEAR lt_key.
      ENDAT.

      LOOP AT mt_conf_comp INTO ls_conf_comp WHERE
          source_node_key       = ls_node-node AND
          target_node->loadable = abap_false.

        DELETE mt_buffer_comp
          WHERE source_node_key = ls_node-node
            AND source_key      = ls_node-key
            AND target_node_key = ls_conf_comp-target_node_key.
        IF mt_buffer_comp IS INITIAL.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF mt_buffer_comp IS INITIAL.
        EXIT.
      ENDIF.

      ls_key-key = ls_node-key.
      INSERT ls_key INTO TABLE lt_key.

      AT END OF node.
        LOOP AT mt_conf_comp INTO ls_conf_comp WHERE
            source_node_key       = ls_node-node AND
            target_node->loadable = abap_false.

          READ TABLE mt_conf_comp WITH KEY
              source_node_key       = ls_conf_comp-target_node_key
              target_node->loadable = abap_false
              TRANSPORTING NO FIELDS.
          CHECK sy-subrc = 0.

          READ TABLE mt_buffer_comp WITH KEY
              source_node_key = ls_conf_comp-target_node_key
          TRANSPORTING NO FIELDS
          BINARY SEARCH.
          CHECK sy-subrc = 0.

          /bobf/if_frw_buffer~retrieve_by_association(
            EXPORTING
              iv_node_key       = ls_node-node
              it_key            = lt_key
              iv_association    = ls_conf_comp-assoc_key
              iv_state          = iv_state
              iv_buffer_only    = abap_true
              iv_notify_keyload = abap_true
            IMPORTING
              et_target_key     = lt_target_key ).

          clear_comp_tab(
            EXPORTING
              iv_state           = iv_state
              iv_source_node_key = ls_conf_comp-target_node_key
              it_source_key      = lt_target_key ).
        ENDLOOP.
      ENDAT.
    ENDLOOP.
  ELSE.
    LOOP AT mt_conf_comp INTO ls_conf_comp WHERE
        source_node_key       = iv_source_node_key AND
        target_node->loadable = abap_false.

      LOOP AT it_source_key INTO ls_key.
        DELETE mt_buffer_comp
          WHERE source_node_key = iv_source_node_key
            AND source_key      = ls_key-key
            AND target_node_key = ls_conf_comp-target_node_key.
        IF mt_buffer_comp IS INITIAL.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF mt_buffer_comp IS INITIAL.
        EXIT.
      ENDIF.

      READ TABLE mt_conf_comp WITH KEY
          source_node_key       = ls_conf_comp-target_node_key
          target_node->loadable = abap_false
          TRANSPORTING NO FIELDS.
      CHECK sy-subrc = 0.

      READ TABLE mt_buffer_comp WITH KEY
          source_node_key = ls_conf_comp-target_node_key
          TRANSPORTING NO FIELDS
          BINARY SEARCH.
      CHECK sy-subrc = 0.

      /bobf/if_frw_buffer~retrieve_by_association(
        EXPORTING
          iv_node_key       = iv_source_node_key
          it_key            = it_source_key
          iv_association    = ls_conf_comp-assoc_key
          iv_state          = iv_state
          iv_buffer_only    = abap_true
          iv_notify_keyload = abap_true
        IMPORTING
          et_target_key     = lt_target_key ).

      clear_comp_tab(
        EXPORTING
          iv_state           = iv_state
          iv_source_node_key = ls_conf_comp-target_node_key
          it_source_key      = lt_target_key ).
    ENDLOOP.
  ENDIF.

ENDMETHOD.


METHOD constructor.

  DATA: ls_node_key  TYPE /bobf/s_frw_node_only,
        lt_node      TYPE /bobf/t_confro_node,
        ls_assoc     TYPE /bobf/s_confro_assoc2,
        lv_dac_class TYPE string.

  FIELD-SYMBOLS:
        <ls_node>      TYPE /bobf/s_confro_node.

  BREAK-POINT ID /bobf/buf_simple.
  mv_bo_key = iv_bo_key.
  DATA(lo_transaction_manager) = /bobf/cl_tra_trans_mgr_factory=>get_transaction_manager( ).
  mo_non_cache_reg = CAST /bobf/if_tra_trans_mgr_compl( lo_transaction_manager )->mo_non_cache_reg.
  mv_no_content_changes = CAST /bobf/if_tra_trans_mgr_compl( lo_transaction_manager )->mv_no_content_changes.
* set configuration object
  mo_conf = /bobf/cl_frw_factory=>get_configuration( iv_bo_key = mv_bo_key ).
  IF mo_conf IS NOT BOUND.
    ASSERT ID /bobf/buf_simple CONDITION 1 = 0.            "#EC BOOL_OK
    RAISE EXCEPTION TYPE /bobf/cx_buf.
  ENDIF.

* set buffer level & get configuation data
  IF iv_node_key IS INITIAL.
    mv_is_main_buffer = abap_true.
    mo_main_buffer    = me.
    IF mo_conf->ms_last_node-node_key <> mo_conf->ms_obj-root_node_key.
      mo_conf->get_node( iv_node_key = mo_conf->ms_obj-root_node_key ).
    ENDIF.
    IF mo_conf->ms_obj-mapper_class IS NOT INITIAL.
      lv_dac_class = mo_conf->ms_obj-mapper_class.
    ENDIF.

  ELSE.
*  set buffer to secondary buffer
    mv_is_main_buffer = abap_false.
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( iv_node_key = iv_node_key ).
    ENDIF.
    mv_parent_node_key = mo_conf->ms_last_node-parent_node_key.
    IF mo_conf->ms_last_node-mapper_class IS NOT INITIAL.
      lv_dac_class = mo_conf->ms_last_node-mapper_class.
    ELSE.
      lv_dac_class = mo_conf->ms_obj-mapper_class.
    ENDIF.
    mo_main_buffer = /bobf/cl_frw_factory=>get_main_buffer( iv_bo_key ).
    IF mv_parent_node_key IS NOT INITIAL.
      SET HANDLER me->handle_event_end_load FOR mo_main_buffer.
    ENDIF.
  ENDIF.

* get instance of data access if node is not transient
  IF mo_conf->ms_last_node-transient = abap_false.
    IF lv_dac_class IS INITIAL.
*     no data access class defined (must be either on BO or Node level)
      ASSERT ID /bobf/buf_simple CONDITION 1 = 0.          "#EC BOOL_OK
      RAISE EXCEPTION TYPE /bobf/cx_buf
        EXPORTING
          textid = /bobf/cx_buf=>sc_no_dac.
    ENDIF.

*   sort transient and delegated nodes out
    IF mv_is_main_buffer = abap_true.
      mo_conf->get_node_tab( IMPORTING et_node = lt_node ).
      LOOP AT lt_node ASSIGNING <ls_node>
        WHERE transient = abap_false
          AND delegation_class IS INITIAL
          AND node_type <> /bobf/if_conf_c=>sc_node_type_bo. "#EC CI_SORTSEQ
        ls_node_key-node = <ls_node>-node_key.
        INSERT ls_node_key INTO TABLE mt_node_key.
      ENDLOOP.
    ELSE.
      LOOP AT it_node_key INTO ls_node_key.
        IF mo_conf->ms_last_node-node_key <> ls_node_key-node.
          mo_conf->get_node( iv_node_key = ls_node_key-node ).
        ENDIF.
        CHECK mo_conf->ms_last_node-transient = abap_false
          AND mo_conf->ms_last_node-delegation_class IS INITIAL.
        INSERT ls_node_key INTO TABLE mt_node_key.
      ENDLOOP.
    ENDIF.

*   create data access
    CALL METHOD (lv_dac_class)=>/bobf/if_buf_data_access~get_instance
      EXPORTING
        iv_bo_key            = mv_bo_key
        iv_node_key          = iv_node_key
        it_node_key          = mt_node_key
        iv_data_access_class = lv_dac_class
      IMPORTING
        eo_data_access       = mo_data_access.

    IF mo_data_access IS NOT BOUND.
      ASSERT ID /bobf/buf_simple CONDITION 1 = 0.          "#EC BOOL_OK
      RAISE EXCEPTION TYPE /bobf/cx_buf
        EXPORTING
          textid = /bobf/cx_buf=>sc_no_dac.
    ENDIF.
  ENDIF.

  IF iv_node_key IS NOT INITIAL.
    ls_node_key-node = iv_node_key.
    INSERT ls_node_key INTO TABLE mt_node_key.
  ENDIF.

* create list of critical compositions
  mo_conf->get_assoc_tab( IMPORTING et_comp  = mt_composition
                                    et_assoc = mt_association ).
  LOOP AT mt_node_key INTO ls_node_key.
    LOOP AT mt_composition INTO ls_assoc
      WHERE source_node_key = ls_node_key-node.
      INSERT ls_assoc INTO TABLE mt_conf_comp.
    ENDLOOP.
    LOOP AT mt_composition INTO ls_assoc USING KEY target_key
      WHERE target_node_key = ls_node_key-node.
      INSERT ls_assoc INTO TABLE mt_conf_comp.
    ENDLOOP.
  ENDLOOP.

  LOOP AT mt_node_key INTO ls_node_key.
    LOOP AT mt_conf_comp INTO ls_assoc
      WHERE source_node_key = ls_node_key-node.
      IF ls_assoc-target_node->loadable  = abap_false AND
         ls_assoc-target_node->transient = abap_false.
        INSERT ls_assoc-source_node_key INTO TABLE mt_parent_noload.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

ENDMETHOD.


METHOD convert_alt_key_from_buffer.

  TYPES BEGIN OF lty_index_rel.
  TYPES   source                         TYPE i.
  TYPES   target                         TYPE i.
  TYPES END OF lty_index_rel.

  TYPES ltt_index_rel                    TYPE STANDARD TABLE OF lty_index_rel
          WITH DEFAULT KEY
          WITH NON-UNIQUE SORTED KEY target COMPONENTS target.

  DATA lr_altkey_sort                    TYPE REF TO data.
  DATA ls_altkey_conf                    TYPE /bobf/s_confro_altkey.
  DATA lr_altkey                         TYPE REF TO data.
  DATA ls_index_rel                      TYPE lty_index_rel.
  DATA lt_index_rel                      TYPE ltt_index_rel.
  DATA lv_altkey_type                    TYPE abap_typekind.
  DATA lv_tabix                          TYPE i.

  FIELD-SYMBOLS <lt_altkey_sort>         TYPE STANDARD TABLE.
  FIELD-SYMBOLS <ls_altkey>              TYPE any.
  FIELD-SYMBOLS <lv_unstructured_altkey> TYPE any.
  FIELD-SYMBOLS <ls_buffer>              TYPE /bobf/s_buf_simple_buffer.
    FIELD-SYMBOLS <lt_buffer>              TYPE /bobf/t_buf_simple_buffer.
    FIELD-SYMBOLS <ls_node>                TYPE any.


  CLEAR et_result.
  CHECK it_key IS NOT INITIAL.

  mo_conf->get_altkey(
    EXPORTING
      iv_altkey_key  = iv_altkey_key
    IMPORTING
      es_altkey      = ls_altkey_conf
  ).

  "is node data in buffer state?
  READ TABLE mt_buffer WITH KEY state = iv_state node = iv_node_key TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    "build sorted table for fast access
    CREATE DATA lr_altkey_sort TYPE STANDARD TABLE OF (ls_altkey_conf-data_type).
    ASSIGN lr_altkey_sort->* TO <lt_altkey_sort>.
    <lt_altkey_sort> = it_key.
    SORT <lt_altkey_sort> BY table_line.

    "build relationships table for table indexes to fill result table
    LOOP AT it_key ASSIGNING <ls_altkey>.
      ls_index_rel-source = sy-tabix.
      READ TABLE <lt_altkey_sort> WITH KEY table_line = <ls_altkey>
          BINARY SEARCH TRANSPORTING NO FIELDS.
      ls_index_rel-target = sy-tabix.
      APPEND ls_index_rel TO lt_index_rel.
    ENDLOOP.

    CREATE DATA lr_altkey TYPE (ls_altkey_conf-data_type).
    ASSIGN lr_altkey->* TO <ls_altkey>.

    DESCRIBE FIELD <ls_altkey> TYPE lv_altkey_type."BOPF load may not have the latest DDIC info
    ls_altkey_conf-altkey_is_structured = boolc(
      lv_altkey_type = cl_abap_typedescr=>typekind_struct1 OR
      lv_altkey_type = cl_abap_typedescr=>typekind_struct2
     ).

    " Performance optimization: if root_key and/or parent_key are part of the altkey,
    " filter relevant entries in mt_buffer before the subsequent loop
    "---------------------------------------------------------------------------------------------

    " Is parent_key part of altkey?
    IF line_exists( ls_altkey_conf-field_names->*[ table_line = CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) ] ).
      DATA(lv_parent_in_altkey) = abap_true.
    ENDIF.

    " Is root_key part of altkey?
    IF line_exists( ls_altkey_conf-field_names->*[ table_line = CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) ] ).
      DATA(lv_root_in_altkey) = abap_true.
    ENDIF.

    IF lv_parent_in_altkey = abap_true OR
       lv_root_in_altkey   = abap_true.
      filter_buffer_parent_root_key( EXPORTING it_buffer               = mt_buffer
                                               iv_parent_in_altkey     = lv_parent_in_altkey
                                               iv_root_in_altkey       = lv_root_in_altkey
                                               iv_altkey_is_structured = ls_altkey_conf-altkey_is_structured
                                               it_altkey_value         = <lt_altkey_sort>
                                               iv_node_key             = iv_node_key
                                               iv_state                = iv_state
                                     IMPORTING et_buffer_filtered      = DATA(lt_filtered_buffer) ).
      ASSIGN lt_filtered_buffer TO <lt_buffer>.
    ELSE.
      ASSIGN mt_buffer TO <lt_buffer>.
    ENDIF.
    "---------------------------------------------------------------------------------------------


    LOOP AT <lt_buffer> ASSIGNING <ls_buffer> WHERE state = iv_state
                                              AND   node  = iv_node_key
                                              AND   data IS BOUND.

      " Fill altkey from current buffer entry
      ASSIGN <ls_buffer>-data->* TO <ls_node>.
      IF ls_altkey_conf-altkey_is_structured = abap_true.
        MOVE-CORRESPONDING <ls_node> TO <ls_altkey>.
      ELSE.
        ASSIGN COMPONENT ls_altkey_conf-altkey_name OF STRUCTURE <ls_node> TO <lv_unstructured_altkey>.
        <ls_altkey> = <lv_unstructured_altkey>.
      ENDIF.

      " Is current altkey in input table?
      READ TABLE <lt_altkey_sort> WITH KEY table_line = <ls_altkey> BINARY SEARCH TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        lv_tabix = sy-tabix.
        IF iv_invalidate_cache = abap_false OR
           is_changed( iv_node_key = iv_node_key
                       iv_key      = <ls_buffer>-key ) = abap_true.
          et_result = VALUE #( BASE et_result FOR ls_index_rel2 IN lt_index_rel USING KEY target WHERE ( target = lv_tabix )
                                                   ( index = ls_index_rel2-source  key = <ls_buffer>-key ) ).
        ENDIF.
      ENDIF.

    ENDLOOP.

ENDMETHOD.


METHOD delete_subnodes.

  DATA:
    lv_tabix     TYPE i,
    ls_conf_comp TYPE /bobf/s_confro_assoc2,
    ls_node      TYPE /bobf/s_frw_node,
    ls_node_del  TYPE /bobf/s_frw_node,
    ls_buffer    TYPE /bobf/s_buf_simple_buffer,
    lt_change    TYPE /bobf/t_frw_change,
    ls_change    TYPE /bobf/s_frw_change.


* loop at all relevant composition (optimal are none such compositions...)
  LOOP AT mt_conf_comp INTO ls_conf_comp
    WHERE source_node_key        = iv_node_key
      AND target_node->loadable  = abap_false
      AND target_node->transient = abap_false.

*   delete obsolete nodes
    LOOP AT ct_node INTO ls_node WHERE node = iv_node_key.
*     check buffer
      LOOP AT mt_buffer INTO ls_buffer USING KEY parent_key
        WHERE state      = iv_state
        AND   node       = ls_conf_comp-target_node_key
        AND   parent_key = ls_node-key.

        lv_tabix = sy-tabix.
        READ TABLE ct_node TRANSPORTING NO FIELDS
          WITH TABLE KEY node = ls_conf_comp-target_node_key
                         key  = ls_buffer-key.
        IF sy-subrc <> 0.
          DELETE mt_buffer INDEX lv_tabix USING KEY parent_key.
          ls_change-node_key    = ls_conf_comp-target_node_key.
          ls_change-key         = ls_buffer-key.
          ls_change-change_mode = /bobf/if_frw_c=>sc_modify_reload_int_delete.
          APPEND ls_change TO lt_change.
          ls_node_del-node = ls_conf_comp-target_node_key.
          ls_node_del-key  = ls_buffer-key.
          INSERT ls_node_del INTO TABLE ct_node.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

*   now start recursion for further subnodes
    delete_subnodes(
      EXPORTING
        iv_node_key = ls_conf_comp-target_node_key
        iv_state    = iv_state
        io_change   = io_change
      CHANGING
        ct_node     = ct_node ).
  ENDLOOP.

  io_change->add( it_change     = lt_change
                  iv_reload_del = abap_true ).

ENDMETHOD.


METHOD destroy_instance.
  "Purpose is to allow buffer dispatcher to get rid of certain buffer instances.
  "Buffer instances can't be freed until event registration is canceled

  IF mo_main_buffer IS BOUND.
    SET HANDLER handle_event_end_load FOR mo_main_buffer ACTIVATION abap_false.
  ENDIF.

ENDMETHOD.


METHOD eval_assoc_binding.

  rv_result = _eval_assoc_binding(
    EXPORTING
      it_runtime_assoc_binding = mo_conf->convert_runtime_assoc_binding(
                                    iv_assoc_key = mo_conf->ms_last_assoc-assoc_key
                                    ir_assocb = is_assocb )
      is_data                  = is_data
      is_parameters            = is_parameters
      it_filtered_attributes   = it_filtered_attributes
  ).

ENDMETHOD.


METHOD fill_keys.
  MOVE-CORRESPONDING is_keys TO cs_data.
ENDMETHOD.


  METHOD filter_buffer_parent_root_key.

    TYPES:
      tt_one_key_unstructured TYPE SORTED TABLE OF /bobf/conf_key WITH UNIQUE KEY table_line,
      BEGIN OF ty_parent_key_structured,
        parent_key TYPE /bobf/conf_key,
      END OF ty_parent_key_structured,
      tt_parent_key_structured TYPE SORTED TABLE OF ty_parent_key_structured WITH UNIQUE KEY table_line,
      BEGIN OF ty_root_key_structured,
        root_key TYPE /bobf/conf_key,
      END OF ty_root_key_structured,
      tt_root_key_structured TYPE SORTED TABLE OF ty_root_key_structured WITH UNIQUE KEY table_line,
      BEGIN OF ty_parent_root_key,
        parent_key TYPE /bobf/conf_key,
        root_key   TYPE /bobf/conf_key,
      END OF ty_parent_root_key,
      tt_parent_root_key TYPE SORTED TABLE OF ty_parent_root_key WITH UNIQUE KEY table_line.

    DATA:
      lt_one_key_unstructured  TYPE tt_one_key_unstructured,
      lt_parent_key_structured TYPE tt_parent_key_structured,
      lt_root_key_structured   TYPE tt_root_key_structured,
      lt_parent_root_key       TYPE tt_parent_root_key,
      lt_buffer_prefiltered    TYPE /bobf/t_buf_simple_buffer.

    CLEAR:
      et_buffer_filtered.

    " Apply different filters on the buffer data depending on whether the altkey ...
    " ... contains parent_key and/or root_key
    " ... is structured or not in case it contains only parent_key or only root_key
    IF iv_parent_in_altkey = abap_true.
      IF iv_root_in_altkey = abap_true.

        " Structured altkey which contains the fields parent_key and root_key
        lt_parent_root_key = CORRESPONDING #( it_altkey_value DISCARDING DUPLICATES ).
        lt_buffer_prefiltered = FILTER #( it_buffer WHERE state = iv_state AND node = iv_node_key ).

        " FILTER #( ... IN ... ) does not work with WHERE + AND in this release
        LOOP AT lt_buffer_prefiltered ASSIGNING FIELD-SYMBOL(<ls_buffer>).
          CHECK line_exists( lt_parent_root_key[ parent_key = <ls_buffer>-parent_key  root_key = <ls_buffer>-root_key ] ).
          INSERT <ls_buffer> into table et_buffer_filtered.
        ENDLOOP.
      ELSE.
        IF iv_altkey_is_structured = abap_true.

          " Structured altkey which contains the field parent_key, but not the field root_key
          lt_parent_key_structured = CORRESPONDING #( it_altkey_value DISCARDING DUPLICATES ).
          et_buffer_filtered = FILTER #( FILTER #( it_buffer WHERE state = iv_state AND node = iv_node_key )
                                         IN lt_parent_key_structured WHERE parent_key = parent_key ).
        ELSE.

          " Unstructured altkey which only has the field parent_key
          lt_one_key_unstructured = CORRESPONDING #( it_altkey_value DISCARDING DUPLICATES ).
          et_buffer_filtered = FILTER #( FILTER #( it_buffer WHERE state = iv_state AND node = iv_node_key )
                                         IN lt_one_key_unstructured WHERE parent_key = table_line ).
        ENDIF.
      ENDIF.
    ELSE.
      IF iv_root_in_altkey = abap_true.
        IF iv_altkey_is_structured = abap_true.

          " Structured altkey which contains the field root_key, but not the field parent_key
          lt_root_key_structured = CORRESPONDING #( it_altkey_value DISCARDING DUPLICATES ).
          et_buffer_filtered = FILTER #( FILTER #( it_buffer WHERE state = iv_state AND node = iv_node_key )
                                         IN lt_root_key_structured WHERE root_key = root_key ).
        ELSE.

          " Unstructured altkey which only has the field root_key
          lt_one_key_unstructured = CORRESPONDING #( it_altkey_value DISCARDING DUPLICATES ).
          et_buffer_filtered = FILTER #( FILTER #( it_buffer WHERE state = iv_state AND node = iv_node_key )
                                         IN lt_one_key_unstructured WHERE root_key = table_line ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.


METHOD get_loadable_node.

  DATA: ls_node  TYPE /bobf/s_confro_node,
        ls_assoc TYPE /bobf/s_confro_assoc.

  CLEAR ev_node_key.

  IF iv_node_key = io_conf->ms_last_node-node_key.
    ls_node = io_conf->ms_last_node.
  ELSE.
    io_conf->get_node(
      EXPORTING iv_node_key = iv_node_key
      IMPORTING es_node     = ls_node ).
  ENDIF.

* exit if node does not use my buffer class
  CHECK ls_node-buf_class = iv_buffer_class.

  IF ls_node-loadable = abap_true OR
     ( ls_node-transient = abap_true AND
       ls_node-node_key  = ls_node-root_node_key ).
    ev_node_key = iv_node_key.
  ELSE.
*   get parent node
    io_conf->get_assoc(
      EXPORTING
        iv_node_key   = iv_node_key
        iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_parent
        iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_std
      IMPORTING
        es_assoc      = ls_assoc ).
    IF ls_assoc IS NOT INITIAL.
      get_loadable_node(
        EXPORTING
          iv_buffer_class = iv_buffer_class
          iv_node_key     = ls_assoc-target_node_key
          io_conf         = io_conf
        IMPORTING
          ev_node_key     = ev_node_key ).
      IF ev_node_key IS INITIAL.
        ev_node_key = iv_node_key.
      ENDIF.
    ELSE.
*     no parent association found
      ASSERT ID /bobf/buf_simple CONDITION 1 = 0.          "#EC BOOL_OK
      RAISE EXCEPTION TYPE /bobf/cx_buf.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD get_subtree.
  DATA lt_composition TYPE /bobf/t_confro_assoc2.

  CLEAR et_node_key.
  io_conf->get_assoc_tab( IMPORTING et_comp = lt_composition ).
  DELETE lt_composition WHERE target_node->buf_class <> iv_buffer_class
                           OR target_node->loadable  = abap_true
                           OR assoc_cat = /bobf/if_conf_c=>sc_assoccat_property
                           OR assoc_cat = /bobf/if_conf_c=>sc_assoccat_lock
                           OR assoc_cat = /bobf/if_conf_c=>sc_assoccat_message.
  recursive_collect_subtree( EXPORTING iv_node_key     = iv_node_key
                                       it_composition  = lt_composition
                                       iv_buffer_class = iv_buffer_class
                             CHANGING  ct_node_key     = et_node_key ).
ENDMETHOD.


METHOD handle_event_end_load.

  DATA: lt_node  TYPE /bobf/t_frw_node,
        lt_node2 TYPE /bobf/t_frw_node,
        ls_node  TYPE /bobf/s_frw_node.


* cleanup composition cache
  CHECK mt_buffer_comp IS NOT INITIAL
     OR mt_buffer_rev_fk IS NOT INITIAL.

  IF is_relevant_for_loadgroup(
       it_requested_node     = it_requested_node
       iv_nodes_are_supplied = boolc( it_requested_node IS SUPPLIED )
    ) = abap_false.
    RETURN.
  ENDIF.

  io_change->get_changes(
    EXPORTING
      iv_change_mode = /bobf/if_frw_c=>sc_modify_reload_int_buf
    IMPORTING
      et_changed_node = lt_node ).

  io_change->get_changes(
   EXPORTING
     iv_change_mode = /bobf/if_frw_c=>sc_modify_reload_int
   IMPORTING
     et_changed_node = lt_node2 ).

  INSERT LINES OF lt_node2 INTO TABLE lt_node.

  LOOP AT lt_node INTO ls_node
    WHERE node = mv_parent_node_key.
    DELETE mt_buffer_comp
      WHERE source_node_key = mv_parent_node_key
        AND source_key      = ls_node-key.
  ENDLOOP.

  LOOP AT lt_node INTO ls_node.
    DELETE mt_buffer_rev_fk USING KEY source_node_key
      WHERE source_node_key = ls_node-node
        AND source_key      = ls_node-key.
  ENDLOOP.

ENDMETHOD.


METHOD IS_CHANGED.

  ev_changed = abap_false.

  LOOP AT mt_change TRANSPORTING NO FIELDS
    WHERE node_key = iv_node_key
      AND key      = iv_key
      AND change   = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
    ev_changed = abap_true.
    EXIT.
  ENDLOOP.

  CHECK ev_changed = abap_false.

  LOOP AT mt_change TRANSPORTING NO FIELDS
    WHERE node_key = iv_node_key
      AND key      = iv_key
      AND change   = /BOBF/IF_FRW_C=>SC_MODIFY_UPDATE.
    ev_changed = abap_true.
    EXIT.
  ENDLOOP.

  CHECK ev_changed = abap_false.

  LOOP AT mt_change TRANSPORTING NO FIELDS
    WHERE node_key = iv_node_key
      AND key      = iv_key
      AND change   = /BOBF/IF_FRW_C=>SC_MODIFY_DELETE.
    ev_changed = abap_true.
    EXIT.
  ENDLOOP.

ENDMETHOD.


  METHOD is_relevant_for_loadgroup.
    "check: is this relevant for my loading group?
    FIELD-SYMBOLS <ls_requested_node> TYPE /bobf/s_frw_node_only.
    FIELD-SYMBOLS <lt_small_table> TYPE /bobf/t_frw_node_only.
    FIELD-SYMBOLS <lt_large_table> TYPE /bobf/t_frw_node_only.

    IF iv_nodes_are_supplied = abap_false OR mt_node_key IS INITIAL.
      rv_relevant = abap_true.
    ELSE.

      IF lines( it_requested_node ) > lines( mt_node_key ).
        ASSIGN it_requested_node TO <lt_large_table>.
        ASSIGN mt_node_key TO <lt_small_table>.
      ELSE.
        ASSIGN it_requested_node TO <lt_small_table>.
        ASSIGN mt_node_key TO <lt_large_table>.
      ENDIF.

      LOOP AT <lt_small_table> ASSIGNING <ls_requested_node>.
        READ TABLE <lt_large_table> WITH KEY node = <ls_requested_node>-node TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          rv_relevant = abap_true.
          RETURN.
        ENDIF.
      ENDLOOP.

    ENDIF.

  ENDMETHOD.


METHOD load.

  DATA: lt_data             TYPE /bobf/t_buf_data_read,
        ls_data             TYPE /bobf/s_buf_data_read,
        lt_node             TYPE /bobf/t_frw_node,
        lt_node2            TYPE /bobf/t_frw_node,
        ls_node             TYPE /bobf/s_frw_node,
        lt_failed           TYPE /bobf/t_frw_node,
        lv_fill_data        TYPE boole_d,
        lv_scope            TYPE /bobf/buf_read_scope,
        lv_change_mode      TYPE /bobf/conf_change_mode,
        ls_conf_comp        TYPE /bobf/s_confro_assoc2,
        ls_buffer_comp      TYPE ts_comp.

  FIELD-SYMBOLS: <ls_buffer> TYPE /bobf/s_buf_simple_buffer.

  BREAK-POINT ID /bobf/buf_simple.

  CLEAR et_failed_node.

  IF mo_data_access IS NOT BOUND.
    RETURN.
  ENDIF.

  lv_fill_data = iv_fill_data.

* ____________________________________________________________________ *
* sort objects out that are deleted or (if IV_RELOAD = true) newly created
  IF mt_change IS NOT INITIAL.
    READ TABLE mt_change WITH KEY change COMPONENTS change = /bobf/if_frw_c=>sc_modify_delete
        TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      READ TABLE mt_change WITH KEY change COMPONENTS change = /bobf/if_frw_c=>sc_modify_create
        TRANSPORTING NO FIELDS.
    ENDIF.
    IF sy-subrc = 0.
      LOOP AT it_node INTO ls_node.
        READ TABLE mt_change
          WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_delete
                   node_key = ls_node-node
                   key      = ls_node-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          READ TABLE mt_change
            WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_create
                     node_key = ls_node-node
                     key      = ls_node-key
            TRANSPORTING NO FIELDS.
          IF sy-subrc <> 0.
            INSERT ls_node INTO TABLE lt_node.
          ENDIF.
        ELSE.
*         Check if Instance is really deleted in requested state
          READ TABLE mt_buffer TRANSPORTING NO FIELDS
            WITH TABLE KEY state = iv_state
                     node  = ls_node-node
                     key   = ls_node-key.
          IF sy-subrc = 0.
            INSERT ls_node INTO TABLE lt_node.
          ENDIF.
        ENDIF.
      ENDLOOP.
      CHECK lt_node IS NOT INITIAL.
    ELSE.
      lt_node = it_node.
    ENDIF.
  ELSE.
    lt_node = it_node.
  ENDIF.

* ____________________________________________________________________ *
* sort objects out that are not yet in the buffer if reload is requ.
  IF iv_reload = abap_true.
*     AND iv_fill_data = abap_true.
*    load only data that is already in buffer
    LOOP AT lt_node INTO ls_node.
      READ TABLE mt_buffer ASSIGNING <ls_buffer>
        WITH TABLE KEY
          state = iv_state
          node  = ls_node-node
          key   = ls_node-key.
      IF sy-subrc = 0.
*       If Buffer already contained data -> make sure data stays
        IF <ls_buffer>-data IS BOUND.
          lv_fill_data = abap_true.
        ENDIF.
*           TODO - clear of mt_change for complete loadable group
        INSERT ls_node INTO TABLE lt_node2.

*        ENDIF.

        IF <ls_buffer>-parent_key IS NOT INITIAL.
          READ TABLE mt_conf_comp INTO ls_conf_comp WITH KEY target_key
            COMPONENTS target_node_key = ls_node-node.
          DELETE mt_buffer_comp
            WHERE source_node_key = ls_conf_comp-source_node_key
              AND source_key      = <ls_buffer>-parent_key
              AND target_node_key = ls_node-node.
        ENDIF.

        AT NEW node.
          DELETE mt_buffer_rev_fk USING KEY target_node_key
            WHERE target_node_key = ls_node-node.
        ENDAT.

      ENDIF.

    ENDLOOP.

    IF mt_buffer_comp IS NOT INITIAL.
      clear_comp_tab(
        EXPORTING
          iv_state       = iv_state
          it_source_node = lt_node ).
    ENDIF.

  ELSE.
    lt_node2 = lt_node.
  ENDIF.

  CHECK lt_node2 IS NOT INITIAL.

* ____________________________________________________________________ *
* read data from DB
  IF lt_node2 IS NOT INITIAL.
    IF lv_fill_data = abap_true OR iv_reload = abap_true.
      lv_scope = /bobf/if_buf_c=>sc_scope_loadgroup.
    ELSE.
      lv_scope = /bobf/if_buf_c=>sc_scope_till_loadable.
    ENDIF.
    mo_data_access->read(
      EXPORTING
        it_node      = lt_node2
        iv_fill_data = lv_fill_data
        iv_scope     = lv_scope
      IMPORTING
        et_data      = lt_data
        et_failed    = lt_failed ).
  ENDIF.
  INSERT LINES OF lt_failed INTO TABLE et_failed_node.
  IF iv_reload = abap_false.
    CLEAR lt_failed.
  ENDIF.

* ____________________________________________________________________ *
* move keys (and data) into local buffer
  IF iv_reload = abap_true AND iv_notify_keyload = abap_false.
    lv_change_mode = /bobf/if_frw_c=>sc_modify_reload_int.
  ELSE.
    IF iv_notify_keyload = abap_true OR
       lv_fill_data      = abap_false.
      lv_change_mode = /bobf/if_frw_c=>sc_modify_load_key.
    ELSE.
      lv_change_mode = /bobf/if_frw_c=>sc_modify_load.
    ENDIF.
  ENDIF.

  write_loaded_data(
    it_data        = lt_data
    it_failed_node = lt_failed
    iv_state       = iv_state
    iv_reload      = iv_reload
    iv_change_mode = lv_change_mode
    iv_scope       = lv_scope
    io_change      = io_change ).

* ____________________________________________________________________ *
* invalidate critical composition buffer for reloaded node instances
  IF iv_reload         = abap_true AND
     mv_is_main_buffer = abap_true AND
     ( mt_buffer_comp IS NOT INITIAL OR
       mt_buffer_rev_fk IS NOT INITIAL ).
    LOOP AT lt_data INTO ls_data.

      LOOP AT mt_buffer_comp INTO ls_buffer_comp WHERE
          source_node_key = ls_data-node AND
          source_key      = ls_data-key.
        IF ls_buffer_comp-target_node_key <> mo_conf->ms_last_node-node_key.
          mo_conf->get_node( ls_buffer_comp-target_node_key ).
        ENDIF.
        IF mo_conf->ms_last_node-loadable = abap_true.
          DELETE mt_buffer_comp.
        ENDIF.
      ENDLOOP.

      DELETE mt_buffer_rev_fk USING KEY source_node_key
        WHERE source_node_key = ls_data-node
          AND source_key      = ls_data-key.
    ENDLOOP.
  ENDIF.

* Invalidate alternative key buffer
  IF iv_reload = abap_true.
    CLEAR mt_alternative_key.
  ENDIF.

* ____________________________________________________________________ *
* inform DAC if no dispatcher is involved
  IF mv_is_main_buffer = abap_true.
    RAISE EVENT /bobf/if_frw_buffer~end_load
      EXPORTING iv_bo_key = mv_bo_key
                io_change = io_change.
  ENDIF.

ENDMETHOD.


 METHOD load_composition.

   DATA:  lt_key_search_data_access TYPE /bobf/t_frw_key,
          lt_data                   TYPE /bobf/t_buf_data_read,
          ls_data                   TYPE /bobf/s_buf_data_read,
          lt_failed                 TYPE /bobf/t_frw_node,
          lt_node                   TYPE /bobf/t_frw_node,
          ls_node                   TYPE /bobf/s_frw_node,
          lt_key_check_for_create   TYPE /bobf/t_frw_key,
          lt_comp_found             TYPE /bobf/t_frw_key,
          lt_created_key            TYPE /bobf/t_frw_key,
          lt_failed_key             TYPE /bobf/t_frw_key,
          ls_root_key               TYPE /bobf/s_frw_key,
          ls_buffer                 TYPE /bobf/s_buf_simple_buffer,
          ls_buffer_comp            TYPE ts_comp,
          ls_conf_comp              TYPE /bobf/s_confro_assoc2,
          ls_key                    TYPE /bobf/s_frw_key,
          lv_comp_found             TYPE boole_d,
          lv_fill_data              TYPE boole_d,
          lv_scope                  TYPE /bobf/buf_read_scope,
          lv_change_mode            TYPE /bobf/conf_change_mode,
          lt_change                 TYPE /bobf/t_frw_change,
          ls_change                 TYPE /bobf/s_frw_change,
          lo_change                 TYPE REF TO /bobf/if_frw_change.

   FIELD-SYMBOLS:
     <ls_buffer_comp> TYPE ts_comp,
     <ls_buffer>      TYPE /bobf/s_buf_simple_buffer,
     <ls_key>         TYPE /bobf/s_frw_key.

* ____________________________________________________________________ *
* check for associations with target node in other loadable node
   IF iv_fill_data = abap_true.
     READ TABLE mt_conf_comp WITH KEY target_key
       COMPONENTS target_node_key = is_assoc-target_node_key
       INTO ls_conf_comp.
     CHECK sy-subrc = 0
       AND ( ls_conf_comp-target_node->loadable  = abap_true OR
             ls_conf_comp-target_node->transient = abap_true )
       AND ls_conf_comp-source_node_key       = is_assoc-source_node_key.
   ELSE.
     READ TABLE mt_conf_comp WITH KEY target_key
       COMPONENTS target_node_key = is_assoc-target_node_key
       INTO ls_conf_comp.
     CHECK sy-subrc = 0
       AND ls_conf_comp-source_node_key = is_assoc-source_node_key.
   ENDIF.

   IF iv_invalidate_cache = abap_true.
    " Delete composition cache as the existing mechanisms don't take affect if the target node of the composition
    " is in a different loading group than the source node. For example HANDLE_EVENT_END_LOAD works only if the data
    " of the source node has been loaded before (missing notifications)
    LOOP AT it_key ASSIGNING <ls_key>.
      " Delete buffered composition
      DELETE mt_buffer_comp
        WHERE source_node_key = is_assoc-source_node_key
          AND source_key      = <ls_key>-key
          AND target_node_key = is_assoc-target_node_key.
    ENDLOOP.
   ENDIF.

   LOOP AT it_key ASSIGNING <ls_key>.

     lv_comp_found = abap_false.
     LOOP AT mt_buffer_comp ASSIGNING <ls_buffer_comp>
       WHERE source_node_key = is_assoc-source_node_key
         AND source_key      = <ls_key>-key
         AND target_node_key = is_assoc-target_node_key.
       IF <ls_buffer_comp>-selection IS INITIAL OR
          <ls_buffer_comp>-selection = it_selection.
         lv_comp_found = abap_true.
         EXIT.
       ENDIF.
     ENDLOOP.

     IF lv_comp_found = abap_true.
       APPEND <ls_key> TO lt_comp_found.
     ENDIF.

     IF lv_comp_found = abap_false OR
       ( ls_buffer_comp-with_data = abap_false AND iv_fill_data = abap_true ).
       APPEND <ls_key> TO lt_key_check_for_create.
     ENDIF.

   ENDLOOP.

   IF NOT lt_key_check_for_create IS INITIAL.
*    composition incomplete -> check for created instances
     READ TABLE mt_node_key TRANSPORTING NO FIELDS
       WITH KEY node = is_assoc-source_node_key.
     DATA(lv_compare) = xsdbool( sy-subrc <> 0 ).

     IF lv_compare = abap_true.
       lo_change = /bobf/cl_frw_factory=>get_change( ).
       mo_main_buffer->compare_states(
         EXPORTING
           iv_node_key      = is_assoc-source_node_key
           it_key           = lt_key_check_for_create
           iv_state_current = /bobf/if_conf_c=>sc_state_current
           iv_state_before  = /bobf/if_conf_c=>sc_state_database
           iv_incl_subtree  = abap_false
           io_change        = lo_change ).
       lo_change->get_changes(
         EXPORTING
           iv_change_mode  = /bobf/if_frw_c=>sc_modify_create
           iv_node_key     = is_assoc-source_node_key
         IMPORTING
           et_changed_key  = lt_created_key
       ).
     ENDIF.

     LOOP AT lt_key_check_for_create ASSIGNING FIELD-SYMBOL(<ls_key_check_for_create>).
       IF lv_compare = abap_true.
         READ TABLE lt_created_key WITH TABLE KEY key_sort COMPONENTS key = <ls_key_check_for_create>-key
            TRANSPORTING NO FIELDS.
       ELSE.
         READ TABLE mt_change TRANSPORTING NO FIELDS
           WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_create
                          node_key = is_assoc-source_node_key
                          key      = <ls_key_check_for_create>-key.
       ENDIF.

       IF sy-subrc = 0.
*        set composition as complete
         CLEAR ls_buffer_comp.
         ls_buffer_comp-source_node_key = is_assoc-source_node_key.
         ls_buffer_comp-target_node_key = is_assoc-target_node_key.
         ls_buffer_comp-source_key      = <ls_key_check_for_create>-key.
         ls_buffer_comp-with_data       = abap_true.
         INSERT ls_buffer_comp INTO TABLE mt_buffer_comp.
       ELSE.
         READ TABLE lt_comp_found WITH TABLE KEY key_sort COMPONENTS key = <ls_key_check_for_create>-key
            TRANSPORTING NO FIELDS.
         IF sy-subrc = 0.
           ls_node-node = is_assoc-target_node_key.
           LOOP AT mt_buffer ASSIGNING <ls_buffer> USING KEY parent_key
             WHERE state      = iv_state
             AND   node       = is_assoc-target_node_key
             AND   parent_key = <ls_key_check_for_create>-key
             AND   data IS NOT BOUND.
             ls_node-key  = <ls_buffer>-key.
             INSERT ls_node INTO TABLE lt_node.
           ENDLOOP.
           CLEAR ls_buffer_comp.
           ls_buffer_comp-source_node_key = is_assoc-source_node_key.
           ls_buffer_comp-source_key      = <ls_key_check_for_create>-key.
           ls_buffer_comp-target_node_key = is_assoc-target_node_key.
           ls_buffer_comp-with_data       = abap_true.
           MODIFY TABLE mt_buffer_comp FROM ls_buffer_comp TRANSPORTING with_data.
         ELSE.
           INSERT <ls_key_check_for_create> INTO TABLE lt_key_search_data_access.
         ENDIF.
       ENDIF.

     ENDLOOP.
   ENDIF.

   CHECK lt_key_search_data_access IS NOT INITIAL
   OR lt_node                   IS NOT INITIAL.

* ____________________________________________________________________ *
* read incomplete compositions
   IF mo_data_access IS NOT BOUND.
     ASSERT ID /bobf/buf_simple CONDITION 1 = 0.           "#EC BOOL_OK
     RAISE EXCEPTION TYPE /bobf/cx_buf.
   ENDIF.

   IF lt_key_search_data_access IS NOT INITIAL.
     IF is_assoc-target_node->optimized_buffer_access = abap_true.
       lv_fill_data = iv_fill_data.
     ELSE.
       lv_fill_data = abap_false.
     ENDIF.

     IF lv_fill_data = abap_true.
       lv_scope = /bobf/if_buf_c=>sc_scope_loadgroup.
     ELSE.
       lv_scope = /bobf/if_buf_c=>sc_scope_node.
     ENDIF.

     mo_data_access->read_composition(
       EXPORTING
         iv_node_key   = is_assoc-target_node_key
         it_parent_key = lt_key_search_data_access
         it_selection  = it_selection
         iv_fill_data  = lv_fill_data
         iv_scope      = lv_scope
       IMPORTING
         et_data       = lt_data
         et_failed_key = lt_failed_key ).
   ENDIF.

* ____________________________________________________________________ *
* read data if requested
   IF lt_data IS NOT INITIAL OR
   lt_node IS NOT INITIAL.

     IF iv_fill_data = abap_true AND
        is_assoc-target_node->optimized_buffer_access = abap_true.

       LOOP AT lt_data INTO ls_data.
*       check whether the data is supplied
         IF ls_data-data IS NOT BOUND.
           DELETE lt_data.
*         check for deleted node instances
           READ TABLE mt_change
             WITH KEY change   = /bobf/if_frw_c=>sc_modify_delete
                      node_key = ls_data-node
                      key      = ls_data-key
             TRANSPORTING NO FIELDS.
           IF sy-subrc <> 0.
             ls_node-node = ls_data-node.
             ls_node-key  = ls_data-key.
             INSERT ls_node INTO TABLE lt_node.
           ENDIF.
         ENDIF.
       ENDLOOP.

       IF iv_notify_keyload = abap_true.
         lv_change_mode = /bobf/if_frw_c=>sc_modify_load_key.
       ELSE.
         lv_change_mode = /bobf/if_frw_c=>sc_modify_load.
       ENDIF.

       IF lt_data IS NOT INITIAL.
*       distribute result for loaded data
         write_loaded_data(
           it_data        = lt_data
           it_failed_node = lt_failed
           iv_state       = iv_state
           iv_reload      = abap_false
           io_change      = io_change
           iv_scope       = lv_scope
           iv_change_mode = lv_change_mode ).
       ENDIF.

       IF lt_node IS NOT INITIAL.
*       DAC does not support the fill data yet -> perform extra read
         mo_data_access->read(
           EXPORTING
             it_node      = lt_node
             iv_fill_data = abap_true
             iv_scope     = /bobf/if_buf_c=>sc_scope_till_loadable
           IMPORTING
             et_data      = lt_data
             et_failed    = lt_failed ).

         ASSERT ID /bobf/buf_simple CONDITION lt_failed IS INITIAL.
         LOOP AT lt_failed INTO ls_node.
           ls_key-key = ls_node-key.
           APPEND ls_key TO lt_failed_key.
         ENDLOOP.
*       distribute result for loaded data
         write_loaded_data(
           it_data        = lt_data
           it_failed_node = lt_failed
           iv_state       = iv_state
           iv_reload      = abap_false
           io_change      = io_change
           iv_scope       = /bobf/if_buf_c=>sc_scope_till_loadable
           iv_change_mode = lv_change_mode ).
       ENDIF.
     ELSE.

* ____________________________________________________________________ *
*     distribute result for loaded keys
       ls_change-change_mode = /bobf/if_frw_c=>sc_modify_load_key.
       LOOP AT lt_data INTO ls_data.
*       check if instance is already in the buffer
         READ TABLE mt_buffer
           WITH KEY state = iv_state
                    node  = ls_data-node
                    key   = ls_data-key
           TRANSPORTING NO FIELDS.
         CHECK sy-subrc <> 0.
*       check for deleted node instances
         READ TABLE mt_change
           WITH KEY change   = /bobf/if_frw_c=>sc_modify_delete
                    node_key = ls_data-node
                    key      = ls_data-key
           TRANSPORTING NO FIELDS.
         CHECK sy-subrc <> 0.
*       node instance is not yet in buffer and not deleted -> insert it
         ls_buffer-node         = ls_data-node.
         ls_buffer-key          = ls_data-key.
         ls_buffer-root_key     = ls_data-root_key.
         ls_buffer-parent_key   = ls_data-parent_key.
         ls_buffer-node_cat_key = ls_data-node_cat_key.
         ls_buffer-state        = iv_state.
         INSERT ls_buffer INTO TABLE mt_buffer.
         ls_root_key-key        = ls_buffer-root_key.
         INSERT ls_root_key INTO TABLE mt_root_keys.

         ls_change-node_key    = ls_data-node.
         ls_change-key         = ls_data-key.
         APPEND ls_change TO lt_change.
       ENDLOOP.
     ENDIF.
   ENDIF.

* ____________________________________________________________________ *
* write complete buffer
   LOOP AT lt_key_search_data_access INTO ls_key.
*   set complete
     lv_comp_found = abap_false.
     LOOP AT mt_buffer_comp ASSIGNING <ls_buffer_comp>
       WHERE source_node_key = is_assoc-source_node_key
         AND source_key      = ls_key-key
         AND target_node_key = is_assoc-target_node_key.
       IF <ls_buffer_comp>-selection IS INITIAL OR
          <ls_buffer_comp>-selection = it_selection.
         lv_comp_found = abap_true.
         EXIT.
       ENDIF.
     ENDLOOP.
     IF lv_comp_found = abap_false.
       IF it_selection IS INITIAL.
*       Loaded complete composition -> cleanup information of previously followed partial compositions
         DELETE mt_buffer_comp
           WHERE source_node_key = is_assoc-source_node_key
             AND source_key      = ls_key-key
             AND target_node_key = is_assoc-target_node_key.
       ENDIF.
       ls_buffer_comp-source_node_key = is_assoc-source_node_key.
       ls_buffer_comp-target_node_key = is_assoc-target_node_key.
       ls_buffer_comp-source_key      = ls_key-key.
       ls_buffer_comp-with_data       = iv_fill_data.
       ls_buffer_comp-selection       = it_selection.
*     if no subnodes are available also a later read with data is not necessary
       IF iv_fill_data = abap_false AND lt_failed_key IS NOT INITIAL.
         READ TABLE lt_failed_key WITH KEY key_sort
           COMPONENTS key = ls_key-key
           TRANSPORTING NO FIELDS.
         IF sy-subrc = 0.
           ls_buffer_comp-with_data   = abap_true.
         ENDIF.
       ENDIF.
       INSERT ls_buffer_comp INTO TABLE mt_buffer_comp.
     ELSE.
       <ls_buffer_comp>-with_data     = iv_fill_data.
     ENDIF.
   ENDLOOP.

* ____________________________________________________________________ *
* post processing
   IF lt_change IS NOT INITIAL.
     io_change->add( it_change_load_key = lt_change ).
   ENDIF.

 ENDMETHOD.


METHOD recursive_collect_subtree.

  DATA ls_node_key LIKE LINE OF ct_node_key.
  FIELD-SYMBOLS <ls_composition> TYPE /bobf/s_confro_assoc2.

  LOOP AT it_composition ASSIGNING <ls_composition> WHERE source_node_key = iv_node_key.

    recursive_collect_subtree( EXPORTING iv_node_key     = <ls_composition>-target_node_key
                                         it_composition  = it_composition
                                         iv_buffer_class = iv_buffer_class
                               CHANGING  ct_node_key     = ct_node_key ).

    ls_node_key-key = <ls_composition>-target_node_key.
    INSERT ls_node_key INTO TABLE ct_node_key.

  ENDLOOP.

ENDMETHOD.


  METHOD retrieve_without_caching.

    "The purpose of this method is to retrieve data from the DAC without caching it afterwards,
    "but returning directly

    DATA lt_node_dac    TYPE /bobf/t_frw_node.
    DATA ls_node_dac    TYPE /bobf/s_frw_node.
    DATA lr_data        TYPE REF TO data.

    CHECK it_key IS NOT INITIAL.
    ls_node_dac = VALUE #( node = iv_node_key ).

    LOOP AT it_key ASSIGNING FIELD-SYMBOL(<ls_key>).
      IF line_exists( mt_change[
            node_key = iv_node_key
            key = <ls_key>-key
            change = /bobf/if_frw_c=>sc_modify_delete ] ).
        INSERT VALUE #( key = <ls_key>-key ) INTO TABLE ct_failed_key .
      ELSE.
        ls_node_dac-key = <ls_key>-key.
        INSERT ls_node_dac INTO TABLE lt_node_dac.
      ENDIF.
    ENDLOOP.

    IF NOT lt_node_dac IS INITIAL.

      mo_data_access->read(
        EXPORTING
          it_node      = lt_node_dac
          iv_fill_data = iv_fill_data
          iv_scope = /bobf/if_frw_c=>sc_scope_local
        IMPORTING
          et_data      = DATA(lt_dac_data)
          et_failed    = DATA(lt_failed_key)
      ).

      MOVE-CORRESPONDING lt_failed_key TO ct_failed_key KEEPING TARGET LINES.
      ct_node_cat = CORRESPONDING #( BASE ( ct_node_cat ) lt_dac_data ).

      IF iv_fill_data = abap_true.
        CREATE DATA lr_data LIKE LINE OF ct_data.
        ASSIGN lr_data->* TO FIELD-SYMBOL(<ls_data_export>).
        LOOP AT lt_dac_data ASSIGNING FIELD-SYMBOL(<ls_dac_data>).
          MOVE-CORRESPONDING <ls_dac_data> TO <ls_data_export>.
          ASSIGN <ls_dac_data>-data->* TO FIELD-SYMBOL(<ls_db_data>).
          MOVE-CORRESPONDING <ls_db_data> TO <ls_data_export>.
          INSERT <ls_data_export> INTO TABLE ct_data.
        ENDLOOP.
      ENDIF.

    ENDIF.

  ENDMETHOD.


  METHOD simple_retrieve_by_comp_db.

    DATA: ls_buffer                  TYPE /bobf/s_buf_simple_buffer,
          ls_change                  TYPE /bobf/s_frw_change,
          lt_change_load             TYPE /bobf/t_frw_change,
          lt_parent_keys_to_load     TYPE /bobf/t_frw_key,
          ls_buffer_comp             TYPE ts_comp,
          lt_key                     TYPE /bobf/t_frw_key,
          lt_source_key              TYPE /bobf/t_frw_key,
          ls_key                     TYPE /bobf/s_frw_key,
          ls_key_incl                TYPE /bobf/s_frw_key_incl,
          lt_result                  TYPE REF TO data,
          ls_result                  TYPE REF TO data,
          ls_key_link                TYPE /bobf/s_frw_key_link,
          lv_deletions_exist         TYPE boole_d,
          lv_buffer_initially_empty  TYPE boole_d,
          lv_keyloads_exist          TYPE boole_d,
          lv_buffer_position         TYPE int4,
          lo_change                  TYPE REF TO /bobf/if_frw_change.

    FIELD-SYMBOLS:
          <lt_result>                TYPE ANY TABLE,
          <ls_result>                TYPE any,
          <ls_target>                TYPE any,
          <lv_key>                   TYPE /bobf/conf_key,
          <lv_root>                  TYPE /bobf/conf_key,
          <lv_parent>                TYPE /bobf/conf_key,
          <lv_node_cat>              TYPE /bobf/conf_key.

    " check buffer state for later optimizations
    READ TABLE mt_change WITH KEY change
      COMPONENTS change   = /bobf/if_frw_c=>sc_modify_load_key
                 node_key = is_assoc-target_node_key
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      " keys have been loaded already --> delete keyload notifications for loaded records later on
      lv_keyloads_exist = abap_true.
    ENDIF.

    " delete duplicates in IT_KEY
    lt_source_key = it_key.
    SORT lt_source_key.
    DELETE ADJACENT DUPLICATES FROM lt_source_key.

    " look in buffer first
    LOOP AT lt_source_key INTO ls_key.

      " check if composition is already loaded completely for this source key
      IF iv_buffer_only = abap_false.
        READ TABLE mt_buffer_comp INTO ls_buffer_comp
           WITH KEY source_node_key = is_assoc-source_node_key
                    source_key      = ls_key-key
                    target_node_key = is_assoc-target_node_key
                    with_data       = abap_true.
        IF sy-subrc <> 0 OR ls_buffer_comp-selection IS NOT INITIAL.
          " check for newly created parent instance
          lo_change = /bobf/cl_frw_factory=>get_change( ).
          CLEAR lt_key.
          APPEND ls_key TO lt_key.
          mo_main_buffer->compare_states(
            EXPORTING
              iv_node_key      = is_assoc-source_node_key
              it_key           = lt_key
              iv_state_current = /bobf/if_conf_c=>sc_state_current
              iv_state_before  = /bobf/if_conf_c=>sc_state_database
              iv_incl_subtree  = abap_false
              io_change        = lo_change ).
          IF lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true.
            " parent newly created -> don't load and mark as complete
            " write composition cache
            ls_buffer_comp-source_node_key = is_assoc-source_node_key.
            ls_buffer_comp-source_key      = ls_key-key.
            ls_buffer_comp-target_node_key = is_assoc-target_node_key.
            ls_buffer_comp-with_data       = abap_true.
            CLEAR ls_buffer_comp-selection.
            INSERT ls_buffer_comp INTO TABLE mt_buffer_comp.
          ELSE.
            " parent not newly created, but composition incomplete -> load completely new
            APPEND ls_key TO lt_parent_keys_to_load.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

      LOOP AT mt_buffer INTO ls_buffer USING KEY parent_key
         WHERE state      = iv_state
           AND node       = is_assoc-target_node_key
           AND parent_key = ls_key-key.

        IF iv_fill_data = abap_true.
          ASSIGN ls_buffer-data->* TO <ls_target>.
          INSERT <ls_target> INTO TABLE et_data.
        ENDIF.

        " write links and target keys
        ls_key_link-source_key = ls_buffer-parent_key.
        ls_key_link-target_key = ls_buffer-key.
        INSERT ls_key_link INTO TABLE et_key_link.
        ls_key-key = ls_buffer-key.
        APPEND ls_key TO et_target_key.

        " if keyloads exist for loaded records that delete keyload and create load notification
        IF lv_keyloads_exist = abap_true.
          DELETE mt_change
            WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
              AND node_key = is_assoc-target_node_key
              AND key      = ls_key-key.
          IF sy-subrc = 0. " a keyload has been deleted
            io_change->add_change(
                iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                iv_node_key    = is_assoc-target_node_key
                iv_key         = ls_key-key ).
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    " everything found in buffer? --> yes: that it
    IF lt_parent_keys_to_load IS INITIAL OR iv_buffer_only = abap_true.
      RETURN.
    ENDIF.

    " search on DB
    CREATE DATA lt_result TYPE TABLE OF (is_assoc-target_node->database_table).
    ASSIGN lt_result->* TO <lt_result>.

    SELECT *
      FROM (is_assoc-target_node->database_table)
      INTO TABLE <lt_result>
      FOR ALL ENTRIES IN lt_parent_keys_to_load
      WHERE ('PARENT_KEY = LT_PARENT_KEYS_TO_LOAD-KEY').

    " nothing found on DB? --> yes: stop here
    IF sy-dbcnt = 0.
      RETURN.
    ENDIF.

    " check buffer state for later optimizations
    READ TABLE mt_change WITH KEY change
       COMPONENTS change   = /bobf/if_frw_c=>sc_modify_delete
                  node_key = is_assoc-target_node_key
       TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      " deletions of this node exist --> filter DB results later on
      lv_deletions_exist = abap_true.
    ENDIF.

    IF mt_buffer IS INITIAL.
      " buffer was empty before --> avoid to check for buffer update (keys might already be loaded before)
      lv_buffer_initially_empty = abap_true.
    ENDIF.

    " prepare to handle DB data
    CREATE DATA ls_result TYPE (is_assoc-target_node->database_table).
    ASSIGN ls_result->* TO <ls_result>.
    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_db_key       OF STRUCTURE <ls_result> TO <lv_key>.
    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_parent_key   OF STRUCTURE <ls_result> TO <lv_parent>.

    " try root itself first
    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_root_key     OF STRUCTURE <ls_result> TO <lv_root>.
    IF sy-subrc <> 0.
      " try parent is root is not there explicitely
      ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_parent_key OF STRUCTURE <ls_result> TO <lv_root>.
      IF sy-subrc <> 0.
        " not yet found -> take key
        ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_db_key   OF STRUCTURE <ls_result> TO <lv_root>.
      ENDIF.
    ENDIF.

    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_node_cat_key OF STRUCTURE <ls_result> TO <lv_node_cat>.
    ls_buffer-node                 = is_assoc-target_node_key.
    ls_buffer-state                = iv_state.
    ls_change-node_key             = is_assoc-target_node_key.
    ls_change-change_mode          = /bobf/if_frw_c=>sc_modify_load.
    ls_buffer_comp-source_node_key = is_assoc-source_node_key.
    ls_buffer_comp-target_node_key = is_assoc-target_node_key.
    ls_buffer_comp-with_data       = abap_true.
    CLEAR ls_buffer_comp-selection.

    " do the big loop...
    LOOP AT <lt_result> INTO <ls_result>.

      " already marked as deleted? --> if yes skip this entry
      IF lv_deletions_exist = abap_true.
        READ TABLE mt_change
           WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_delete
                          node_key = is_assoc-target_node_key
                          key      = <lv_key>
           TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          CONTINUE.
        ENDIF.
      ENDIF.

      " convert DB-data to BOPF model (combined data type)
      CREATE DATA ls_buffer-data TYPE (is_assoc-target_node->data_type).
      ASSIGN ls_buffer-data->* TO <ls_target>.
      MOVE-CORRESPONDING <ls_result> TO <ls_target>.
      ls_buffer-key = <lv_key>.
      IF <lv_parent> IS ASSIGNED.
        ls_buffer-parent_key = <lv_parent>.
      ENDIF.
      IF <lv_root> IS ASSIGNED.
        ls_buffer-root_key   = <lv_root>.
      ENDIF.
      IF <lv_node_cat> IS ASSIGNED AND <lv_node_cat> IS NOT INITIAL.
        ls_buffer-node_cat_key = <lv_node_cat>.
      ELSE.
        ls_buffer-node_cat_key = is_assoc-target_node->node_cat_key.
      ENDIF.
      MOVE-CORRESPONDING ls_buffer   TO ls_key_incl.
      MOVE-CORRESPONDING ls_key_incl TO <ls_target>.

      " update buffer
      IF lv_buffer_initially_empty = abap_true.
        " just insert new record
        INSERT ls_buffer INTO TABLE mt_buffer.
      ELSE.
        " check for maybe existing entry
        READ TABLE mt_buffer TRANSPORTING NO FIELDS
          WITH TABLE KEY node  = is_assoc-target_node_key
                         key   = <lv_key>
                         state = iv_state.
        lv_buffer_position = sy-tabix.

        IF sy-subrc = 0. " found in buffer -> update
          MODIFY mt_buffer INDEX lv_buffer_position FROM ls_buffer.

          " check for keyload to delete
          IF lv_keyloads_exist = abap_true.
            DELETE mt_change
             WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
               AND node_key = is_assoc-target_node_key
               AND key      = <lv_key>.
          ENDIF.

        ELSE. " not found in buffer -> insert
          INSERT ls_buffer INTO mt_buffer INDEX lv_buffer_position.
        ENDIF.
      ENDIF.

      " fill root key table
      ls_key-key    = ls_buffer-root_key.
      INSERT ls_key INTO TABLE mt_root_keys. " sorted unique

      " create load notification
      ls_change-key = ls_buffer-key.
      APPEND ls_change TO lt_change_load. " unsorted

      IF iv_fill_data = abap_true.
        " if you get a dump here look at the call stack and
        " find the one doing a retrieve with the wrong type of et_data
        INSERT <ls_target> INTO TABLE et_data.
      ENDIF.

      " write links and target keys
      ls_key_link-source_key = ls_buffer-parent_key.
      ls_key_link-target_key = ls_buffer-key.
      INSERT ls_key_link INTO TABLE et_key_link.
      ls_key-key = ls_buffer-key.
      APPEND ls_key TO et_target_key.

      " write composition cache
      ls_buffer_comp-source_key      = ls_buffer-parent_key.
      INSERT ls_buffer_comp INTO TABLE mt_buffer_comp.

    ENDLOOP.

    io_change->add( it_change_load = lt_change_load ).

  ENDMETHOD.


  METHOD simple_retrieve_db.

    DATA: ls_buffer                  TYPE /bobf/s_buf_simple_buffer,
          ls_change                  TYPE /bobf/s_frw_change,
          lt_change_load             TYPE /bobf/t_frw_change,
          lt_key_to_load             TYPE /bobf/t_frw_key,
          ls_key                     TYPE /bobf/s_frw_key,
          ls_key_incl                TYPE /bobf/s_frw_key_incl,
          lt_result                  TYPE REF TO data,
          ls_result                  TYPE REF TO data,
          lv_deletions_exist         TYPE boole_d,
          lv_buffer_initially_empty  TYPE boole_d,
          lv_keyloads_exist          TYPE boole_d,
          lv_buffer_position         TYPE int4.

    FIELD-SYMBOLS:
          <lt_result>                TYPE ANY TABLE,
          <ls_result>                TYPE any,
          <ls_target>                TYPE any,
          <lv_key>                   TYPE /bobf/conf_key,
          <lv_root>                  TYPE /bobf/conf_key,
          <lv_parent>                TYPE /bobf/conf_key,
          <lv_node_cat>              TYPE /bobf/conf_key.

    " check buffer state for later optimizations
    READ TABLE mt_change WITH KEY change
      COMPONENTS change   = /bobf/if_frw_c=>sc_modify_load_key
                 node_key = iv_node_key
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      " keys have been loaded already --> delete keyload notifications for loaded records later on
      lv_keyloads_exist = abap_true.
    ENDIF.

    " search in buffer first
    IF mt_buffer IS NOT INITIAL.
      LOOP AT it_key INTO ls_key.
        READ TABLE mt_buffer
          WITH TABLE KEY state = iv_state
                         node  = iv_node_key
                         key   = ls_key-key
          INTO ls_buffer.
        IF sy-subrc = 0.
          IF iv_fill_data = abap_true.
            IF ls_buffer-data IS BOUND.
              ASSIGN ls_buffer-data->* TO <ls_target>.
              INSERT <ls_target> INTO TABLE et_data.
            ELSE.
              " data requested, but not found -> load
              APPEND ls_key TO lt_key_to_load.
              CONTINUE.
            ENDIF.
          ENDIF.

          " if keyloads exist for loaded records that delete keyload and create load notification
          IF lv_keyloads_exist = abap_true.
            DELETE mt_change
              WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
                AND node_key = iv_node_key
                AND key      = ls_key-key.
            IF sy-subrc = 0. " a keyload has been deleted
              io_change->add_change(
                  iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                  iv_node_key    = iv_node_key
                  iv_key         = ls_key-key ).
            ENDIF.
          ENDIF.

        ELSE.
          " not found in buffer at all -> load
          APPEND ls_key TO lt_key_to_load.
        ENDIF.
      ENDLOOP.
    ELSE.
      " nothing found in buffer -> load all
      lt_key_to_load = it_key.
    ENDIF.

    " everything found in buffer? --> yes: that it
    IF lt_key_to_load IS INITIAL OR iv_buffer_only = abap_true.
      et_failed_key = lt_key_to_load.
      RETURN.
    ENDIF.

    " search on DB
    CREATE DATA lt_result TYPE TABLE OF (is_nodeconf-database_table).
    ASSIGN lt_result->* TO <lt_result>.

    SELECT *
      FROM (is_nodeconf-database_table)
      INTO TABLE <lt_result>
      FOR ALL ENTRIES IN lt_key_to_load
      WHERE ('DB_KEY = LT_KEY_TO_LOAD-KEY').

    " nothing found on DB? --> yes: stop here
    IF sy-dbcnt = 0.
      et_failed_key = lt_key_to_load.
      RETURN.
    ENDIF.

    " check buffer state for later optimizations
    READ TABLE mt_change WITH KEY change
       COMPONENTS change   = /bobf/if_frw_c=>sc_modify_delete
                  node_key = iv_node_key
       TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      " deletions of this node exist --> filter DB results later on
      lv_deletions_exist = abap_true.
    ENDIF.

    IF mt_buffer IS INITIAL.
      " buffer was empty before --> avoid to check for buffer update (keys might already be loaded before)
      lv_buffer_initially_empty = abap_true.
    ENDIF.

    " prepare to handle DB data
    CREATE DATA ls_result TYPE (is_nodeconf-database_table).
    ASSIGN ls_result->* TO <ls_result>.
    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_db_key       OF STRUCTURE <ls_result> TO <lv_key>.
    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_parent_key   OF STRUCTURE <ls_result> TO <lv_parent>.

    " try root itself first
    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_root_key     OF STRUCTURE <ls_result> TO <lv_root>.
    IF sy-subrc <> 0.
      " try parent is root is not there explicitely
      ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_parent_key OF STRUCTURE <ls_result> TO <lv_root>.
      IF sy-subrc <> 0.
        " not yet found -> take key
        ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_db_key   OF STRUCTURE <ls_result> TO <lv_root>.
      ENDIF.
    ENDIF.

    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_node_cat_key OF STRUCTURE <ls_result> TO <lv_node_cat>.
    ls_buffer-node        = iv_node_key.
    ls_buffer-state       = iv_state.
    ls_change-node_key    = iv_node_key.
    ls_change-change_mode = /bobf/if_frw_c=>sc_modify_load.

    " do the big loop...
    LOOP AT <lt_result> INTO <ls_result>.

      " already marked as deleted? --> if yes skip this entry
      IF lv_deletions_exist = abap_true.
        READ TABLE mt_change
           WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_delete
                          node_key = iv_node_key
                          key      = <lv_key>
           TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          CONTINUE.
        ENDIF.
      ENDIF.

      " convert DB-data to BOPF model (combined data type)
      CREATE DATA ls_buffer-data TYPE (is_nodeconf-data_type).
      ASSIGN ls_buffer-data->* TO <ls_target>.
      MOVE-CORRESPONDING <ls_result> TO <ls_target>.
      ls_buffer-key = <lv_key>.
      IF <lv_parent> IS ASSIGNED.
        ls_buffer-parent_key = <lv_parent>.
      ENDIF.
      IF <lv_root> IS ASSIGNED.
        ls_buffer-root_key   = <lv_root>.
      ENDIF.
      IF <lv_node_cat> IS ASSIGNED AND <lv_node_cat> IS NOT INITIAL.
        ls_buffer-node_cat_key = <lv_node_cat>.
      ELSE.
        ls_buffer-node_cat_key = is_nodeconf-node_cat_key.
      ENDIF.
      MOVE-CORRESPONDING ls_buffer   TO ls_key_incl.
      MOVE-CORRESPONDING ls_key_incl TO <ls_target>.

      " update buffer
      IF lv_buffer_initially_empty = abap_true.
        " just insert new record
        INSERT ls_buffer INTO TABLE mt_buffer.
      ELSE.
        " check for maybe existing entry
        READ TABLE mt_buffer TRANSPORTING NO FIELDS
          WITH TABLE KEY node  = iv_node_key
                         key   = <lv_key>
                         state = iv_state.
        lv_buffer_position = sy-tabix.

        IF sy-subrc = 0. " found in buffer -> update
          MODIFY mt_buffer INDEX lv_buffer_position FROM ls_buffer.

          " check for keyload to delete
          IF lv_keyloads_exist = abap_true.
            DELETE mt_change
             WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
               AND node_key = iv_node_key
               AND key      = <lv_key>.
          ENDIF.

        ELSE. " not found in buffer -> insert
          INSERT ls_buffer INTO mt_buffer INDEX lv_buffer_position.
        ENDIF.
      ENDIF.

      " fill root key table
      ls_key-key    = ls_buffer-root_key.
      INSERT ls_key INTO TABLE mt_root_keys. " sorted unique

      " create load notification
      ls_change-key = ls_buffer-key.
      APPEND ls_change TO lt_change_load. " unsorted

      IF iv_fill_data = abap_true.
        " if you get a dump here look at the call stack and
        " find the one doing a retrieve with the wrong type of et_data
        INSERT <ls_target> INTO TABLE et_data.
      ENDIF.
    ENDLOOP.

    io_change->add( it_change_load = lt_change_load ).

    " add failed keys
    IF lines( lt_key_to_load ) > lines( lt_change_load ).
      LOOP AT it_key INTO ls_key.
        READ TABLE lt_change_load TRANSPORTING NO FIELDS
          WITH KEY key = ls_key-key.
        IF sy-subrc <> 0.
          APPEND ls_key TO et_failed_key.
        ENDIF.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.


METHOD UPDATE_LOCK_NODE.

* since the lock node has a bit different behavior
* a special update method is necessary

  DATA: ls_buffer     TYPE /BOBF/S_BUF_SIMPLE_BUFFER,
        ls_source     TYPE REF TO /BOBF/S_FRW_LOCK_NODE,
        ls_target     TYPE REF TO /BOBF/S_FRW_LOCK_NODE,
        ls_chg        TYPE /BOBF/S_FRW_CHANGE,
        ls_field      TYPE /BOBF/OBM_NAME,
        lv_tabix      TYPE i.

  FIELD-SYMBOLS: <ls_buffer> TYPE /BOBF/S_BUF_SIMPLE_BUFFER.

  ls_chg-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_LOCK.

  IF is_mod-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_DELETE.
*   delete lock entry
    LOOP AT mt_buffer ASSIGNING <ls_buffer>
      WHERE state = iv_state
        AND node  = is_mod-node
        AND key   = is_mod-key.
      ls_chg-node_key = is_node-parent_node_key.
      ls_chg-key      = <ls_buffer>-parent_key.
      APPEND ls_chg TO ct_chg.
      DELETE mt_buffer.
    ENDLOOP.
  ELSE.
*   create / update new node
    READ TABLE mt_buffer
      WITH TABLE KEY
        state = iv_state
        node  = is_mod-node
        key   = is_mod-key
      ASSIGNING <ls_buffer>.

    lv_tabix = sy-tabix.
    IF sy-subrc = 0.
*     update entry
      IF is_mod-changed_fields IS INITIAL.
        <ls_buffer>-data = is_mod-data.
      ELSE.
        ls_source ?= is_mod-data.
        ls_target ?= <ls_buffer>-data.
        LOOP AT is_mod-changed_fields INTO ls_field.
          IF ls_field = 'EDIT_MODE'.
            ls_target->edit_mode = ls_source->edit_mode.
          ELSEIF ls_field = 'GENERIC'.
            ls_target->generic   = ls_source->generic.
          ELSEIF ls_field = 'PARENT_EDIT_MODE'.
            ls_target->parent_edit_mode = ls_source->parent_edit_mode.
          ELSEIF ls_field = 'EDIT_MODE_UPDATE'.
            ls_target->edit_mode_update = ls_source->edit_mode_update.
          ELSEIF ls_field = 'EDIT_MODE_DIALOG'.
            ls_target->edit_mode_dialog = ls_source->edit_mode_dialog.
          ENDIF.
        ENDLOOP.
      ENDIF.
      ls_chg-node_key      = is_node-parent_node_key.
      ls_chg-key           = <ls_buffer>-parent_key.
      APPEND ls_chg TO ct_chg.

    ELSE.
*     create entry
      ls_buffer-state      = iv_state.
      ls_buffer-node       = is_mod-node.
      ls_buffer-key        = is_mod-key.
      ls_buffer-parent_key = is_mod-key.
      ls_buffer-root_key   = is_mod-root_key.
      ls_buffer-data       = is_mod-data.
      INSERT ls_buffer INTO mt_buffer INDEX lv_tabix.
      ls_chg-node_key      = is_node-parent_node_key.
      ls_chg-key           = is_mod-key.
      APPEND ls_chg TO ct_chg.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD UPDATE_PROPERTY_NODE.

* since the property node has a bit different behavior
* a special update method is necessary

  DATA: ls_buffer         TYPE /BOBF/S_BUF_SIMPLE_BUFFER,
        ls_change            TYPE /BOBF/S_FRW_CHANGE,
        ls_tmp            TYPE /BOBF/S_FRW_PROPERTY_K,
        ls_property_line  TYPE REF TO /BOBF/S_FRW_PROPERTY_K,
        lv_attribute_name TYPE string,
        lv_tabix          TYPE i.

  FIELD-SYMBOLS: <ls_buffer> TYPE /BOBF/S_BUF_SIMPLE_BUFFER,
                 <ls_source> TYPE any,
                 <ls_target> TYPE /BOBF/S_FRW_PROPERTY_K.

  ls_change-change_mode = is_mod-change_mode.
  ls_change-node_key    = is_mod-node.
  ls_change-key         = is_mod-key.

  CASE is_mod-change_mode.
    WHEN /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
*     create entry
      IF is_mod-data IS BOUND.
        TRY.
            ls_property_line            ?= is_mod-data.
            ls_buffer-data               = ls_property_line.
            ls_property_line->key        = is_mod-key.
            ls_property_line->parent_key = is_mod-source_key.

            IF ls_property_line->content_cat IS INITIAL.
*             not all mandatory fields are provided
              ASSERT ID /BOBF/BUF_SIMPLE CONDITION 1 = 0."#EC BOOL_OK
              RETURN.
            ENDIF.

*           wrong call -> property name not supplied
            ASSERT ID /BOBF/BUF_SIMPLE CONDITION ls_property_line->property_name IS NOT INITIAL.

          CATCH cx_sy_move_cast_error.
*           if you stop here the property node was created by using the data data type
*           instead of the combined data type. Please adjust the caller.
            ASSERT ID /BOBF/BUF_SIMPLE CONDITION 1 = 0."#EC BOOL_OK

            CREATE DATA ls_buffer-data TYPE /BOBF/S_FRW_PROPERTY_K.
            ASSIGN ls_buffer-data->* TO <ls_target>.
            ASSIGN is_mod-data->*    TO <ls_source>.
            MOVE-CORRESPONDING <ls_source> TO <ls_target>.
            <ls_target>-key        = is_mod-key.
            <ls_target>-parent_key = is_mod-source_key.

*           wrong call -> property name not supplied
            ASSERT ID /BOBF/BUF_SIMPLE CONDITION <ls_target>-property_name IS NOT INITIAL.
        ENDTRY.

        ls_buffer-state      = iv_state.
        ls_buffer-node       = is_mod-node.
        ls_buffer-key        = is_mod-key.
        ls_buffer-parent_key = is_mod-source_key.
        ls_buffer-root_key   = is_mod-root_key.
        INSERT ls_buffer INTO TABLE mt_buffer.
      ELSE.
        ls_change-failed = abap_true.
      ENDIF.

    WHEN /BOBF/IF_FRW_C=>SC_MODIFY_UPDATE.
*     update property
      IF is_mod-data IS BOUND.
        READ TABLE mt_buffer
          WITH TABLE KEY
            state = iv_state
            node  = is_mod-node
            key   = is_mod-key
          ASSIGNING <ls_buffer>.

        ASSERT ID /BOBF/BUF_SIMPLE CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          ASSIGN is_mod-data->*      TO <ls_source>.
          ASSIGN <ls_buffer>-data->* TO <ls_target>.
          IF is_mod-changed_fields IS INITIAL.
            MOVE-CORRESPONDING <ls_source> TO <ls_target>.
            <ls_target>-key        = <ls_buffer>-key.
            <ls_target>-parent_key = <ls_buffer>-parent_key.
          ELSE.
            MOVE-CORRESPONDING <ls_source> TO ls_tmp.
            LOOP AT is_mod-changed_fields INTO lv_attribute_name.
              CASE lv_attribute_name.
                WHEN 'CONTENT_CAT'.
                  <ls_target>-content_cat    = ls_tmp-content_cat.
                WHEN 'CONTENT_KEY'.
                  <ls_target>-content_key    = ls_tmp-content_key.
                WHEN 'ATTRIBUTE_NAME'.
                  <ls_target>-attribute_name = ls_tmp-attribute_name.
                WHEN 'PROPERTY_NAME'.
                  <ls_target>-property_name  = ls_tmp-property_name.
                WHEN 'VALUE'.
                  <ls_target>-value          = ls_tmp-value.
                WHEN OTHERS.
                  ASSERT ID /BOBF/BUF_SIMPLE CONDITION 1 = 0."#EC BOOL_OK
              ENDCASE.
            ENDLOOP.
          ENDIF.

*         wrong call -> property name not supplied
          ASSERT ID /BOBF/BUF_SIMPLE CONDITION <ls_target>-property_name IS NOT INITIAL.
        ELSE.
          ls_change-failed = abap_true.
        ENDIF.
      ELSE.
        ls_change-failed = abap_true.
      ENDIF.

    WHEN /BOBF/IF_FRW_C=>SC_MODIFY_DELETE.
*     delete property
      READ TABLE mt_buffer
        WITH TABLE KEY
          state = iv_state
          node  = is_mod-node
          key   = is_mod-key
        ASSIGNING <ls_buffer>.
      lv_tabix = sy-tabix.

      ASSERT ID /BOBF/BUF_SIMPLE CONDITION sy-subrc = 0.
      IF sy-subrc = 0.
        ASSIGN <ls_buffer>-data->* TO <ls_target>.
        DELETE mt_buffer INDEX lv_tabix.
      ELSE.
        ls_change-failed       = abap_true.
      ENDIF.

  ENDCASE.

* set property change information
  IF ls_change-failed = abap_false.
    APPEND ls_change TO ct_chg.
  ENDIF.

ENDMETHOD.


METHOD write_loaded_data.

  DATA: ls_data             TYPE /bobf/s_buf_data_read,
        ls_buffer           TYPE /bobf/s_buf_simple_buffer,
        lt_change           TYPE /bobf/t_frw_change,
        lt_change_load      TYPE /bobf/t_frw_change,
        lt_change_load_key  TYPE /bobf/t_frw_change,
        lv_reload_del       TYPE boole_d,
        lv_reload_int       TYPE boole_d,
        ls_change           TYPE /bobf/s_frw_change,
        ls_change_int       TYPE ts_change,
        ls_key              TYPE /bobf/s_frw_key,
        ls_node             TYPE /bobf/s_frw_node,
        lt_node             TYPE /bobf/t_frw_node,
        lv_tabix            TYPE i,
        lv_mark_comp        TYPE boole_d,
        lv_change           TYPE boole_d,
        ls_assoc2           TYPE /bobf/s_confro_assoc2,
        ls_buffer_comp      TYPE ts_comp.

  FIELD-SYMBOLS:
        <ls_source>         TYPE any,
        <ls_target>         TYPE any,
        <ls_target_data>    TYPE any.


  IF iv_change_mode = /bobf/if_frw_c=>sc_modify_reload_int.
    lt_node = it_failed_node.
  ENDIF.

  LOOP AT it_data INTO ls_data.
    AT NEW node.
      READ TABLE mt_parent_noload WITH TABLE KEY table_line = ls_data-node TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        lv_mark_comp = abap_true.
      ELSE.
        lv_mark_comp = abap_false.
      ENDIF.
    ENDAT.

*   Update composition information for compositions in the loaded loading group
    IF lv_mark_comp = abap_true AND
       iv_scope     = /bobf/if_buf_c=>sc_scope_loadgroup.
*        AND ls_data-data IS BOUND.
      LOOP AT mt_conf_comp INTO ls_assoc2
        WHERE source_node_key        = ls_data-node
          AND target_node->transient = abap_false
          AND target_node->loadable  = abap_false.
        ls_buffer_comp-source_node_key = ls_data-node.
        ls_buffer_comp-source_key      = ls_data-key.
        ls_buffer_comp-target_node_key = ls_assoc2-target_node_key.
        IF ls_data-data IS BOUND.
          ls_buffer_comp-with_data = abap_true.
        ELSE.
          ls_buffer_comp-with_data = abap_false.
        ENDIF.
        INSERT ls_buffer_comp INTO TABLE mt_buffer_comp.
      ENDLOOP.
    ENDIF.

    IF iv_change_mode = /bobf/if_frw_c=>sc_modify_reload_int.
      ls_node-node = ls_data-node.
      ls_node-key  = ls_data-key.
      INSERT ls_node INTO TABLE lt_node.
    ENDIF.
    ls_change-node_key = ls_data-node.
    ls_change-key      = ls_data-key.
*   search for existing entry to update
    READ TABLE mt_buffer INTO ls_buffer
      WITH TABLE KEY node  = ls_data-node
                     key   = ls_data-key
                     state = iv_state.
    lv_tabix = sy-tabix.

*   check for keyload
    IF iv_reload = abap_false AND
       sy-subrc  = 0          AND
       ls_buffer-data IS BOUND.
      IF iv_change_mode = /bobf/if_frw_c=>sc_modify_load.
        READ TABLE mt_change TRANSPORTING NO FIELDS
          WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_load_key
                         node_key = ls_data-node
                         key      = ls_data-key.
        IF sy-subrc = 0.
          DELETE mt_change INDEX sy-tabix.
          ls_change-change_mode = iv_change_mode.
          APPEND ls_change TO lt_change_load.
        ENDIF.
      ENDIF.
      CONTINUE.
    ENDIF.

    IF ls_data-data IS NOT BOUND. " only keys available
      IF sy-subrc <> 0.
*       not found -> insert key
        READ TABLE mt_change
          WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_delete
                         node_key = ls_data-node
                         key      = ls_data-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CLEAR ls_buffer.
          ls_buffer-node         = ls_data-node.
          ls_buffer-key          = ls_data-key.
          ls_buffer-state        = iv_state.
          ls_buffer-root_key     = ls_data-root_key.
          ls_buffer-parent_key   = ls_data-parent_key.
          ls_buffer-node_cat_key = ls_data-node_cat_key.
          INSERT ls_buffer INTO mt_buffer INDEX lv_tabix.
          ls_key-key = ls_data-root_key.
          INSERT ls_key INTO TABLE mt_root_keys.
          ls_change-change_mode = /bobf/if_frw_c=>sc_modify_load_key.
          APPEND ls_change TO lt_change_load_key.
        ENDIF.

      ELSE.
*       clear data from buffer
        CLEAR ls_buffer-data.
        MODIFY mt_buffer INDEX lv_tabix FROM ls_buffer.
        ls_change-change_mode = /bobf/if_frw_c=>sc_modify_load_key.
        APPEND ls_change TO lt_change_load_key.
      ENDIF.

    ELSE.
      ls_change-change_mode = iv_change_mode.
      IF sy-subrc = 0.
*       data found in buffer
        UNASSIGN <ls_target_data>.
        ASSIGN ls_data-data->*   TO <ls_source>. " data data type
        IF ls_buffer-data IS BOUND.
          ASSIGN ls_buffer-data->* TO <ls_target>. " combined data type
*         check whether the data would change
          ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_node_data
            OF STRUCTURE <ls_target> TO <ls_target_data>. " data data type
        ELSE.
          IF mo_conf->ms_last_node-node_key <> ls_data-node.
            mo_conf->get_node( ls_data-node ).
          ENDIF.
          CREATE DATA ls_buffer-data TYPE (mo_conf->ms_last_node-data_type).
          ASSIGN ls_buffer-data->* TO <ls_target>. " combined data type
          lv_change = abap_true.
        ENDIF.

*       set/update data
        READ TABLE mt_change
          WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_update
                         node_key = ls_data-node
                         key      = ls_data-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          READ TABLE mt_change
            WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_delete
                           node_key = ls_data-node
                           key      = ls_data-key
            TRANSPORTING NO FIELDS.
          IF sy-subrc <> 0 OR lv_change = abap_true.
*           Not deleted or keys are still present in buffer -> not deleted in this state
            IF lv_change         = abap_true  OR
                <ls_target_data> IS NOT ASSIGNED OR
                <ls_source>      <> <ls_target_data>.
*               transform data into combined structure
              CLEAR <ls_target>.
              MOVE-CORRESPONDING <ls_source> TO <ls_target>.
              fill_keys(
                EXPORTING iv_node_key = ls_buffer-node
                          is_keys     = ls_buffer-keys
                CHANGING  cs_data     = <ls_target> ).
              ls_buffer-node_cat_key = ls_data-node_cat_key.
              MODIFY mt_buffer INDEX lv_tabix FROM ls_buffer.
*              APPEND ls_change TO lt_change.
              CASE ls_change-change_mode.
                WHEN /bobf/if_frw_c=>sc_modify_load.
                  APPEND ls_change TO lt_change_load.
                WHEN /bobf/if_frw_c=>sc_modify_load_key.
                  APPEND ls_change TO lt_change_load_key.
                WHEN /bobf/if_frw_c=>sc_modify_reload_int.
                  lv_reload_int = abap_true.
                  APPEND ls_change TO lt_change.
*             Remove pending keyload notifications
                  DELETE mt_change WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
                                     AND node_key = ls_change-node_key
                                     AND key      = ls_change-key.
                WHEN /bobf/if_frw_c=>sc_modify_reload_int_delete.
                  lv_reload_del = abap_true.
                  APPEND ls_change TO lt_change.
*             Remove pending keyload notifications
                  DELETE mt_change WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
                                     AND node_key = ls_change-node_key
                                     AND key      = ls_change-key.
                WHEN OTHERS.
                  APPEND ls_change TO lt_change.
              ENDCASE.
              IF iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key.
                ls_change_int-change   = iv_change_mode.
                ls_change_int-node_key = ls_change-node_key.
                ls_change_int-key      = ls_change-key.
                INSERT ls_change_int INTO TABLE mt_change.
              ENDIF.

            ELSE.
*             Check if there are pending keyload notifications to be notified
              IF iv_change_mode <> /bobf/if_frw_c=>sc_modify_load_key.
                READ TABLE mt_change WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_load_key
                                                    node_key = ls_change-node_key
                                                    key      = ls_change-key TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
                  CASE ls_change-change_mode.
                    WHEN /bobf/if_frw_c=>sc_modify_load.
                      APPEND ls_change TO lt_change_load.
                    WHEN /bobf/if_frw_c=>sc_modify_reload_int.
                      lv_reload_int = abap_true.
                      APPEND ls_change TO lt_change.
                  ENDCASE.
                  DELETE mt_change WHERE change   = /bobf/if_frw_c=>sc_modify_load_key
                                     AND node_key = ls_change-node_key
                                     AND key      = ls_change-key.
                ENDIF.
              ENDIF.
              IF sy-subrc <> 0 AND mv_is_main_buffer = abap_false.
*               insert reload change for buffer dispatcher
                ls_change-change_mode = /bobf/if_frw_c=>sc_modify_reload_int_buf.
                APPEND ls_change TO lt_change.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
        lv_change = abap_false.

      ELSE.
*       data not found in buffer -> insert with data
        READ TABLE mt_change
          WITH TABLE KEY change   = /bobf/if_frw_c=>sc_modify_delete
                         node_key = ls_data-node
                         key      = ls_data-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CLEAR ls_buffer.
          ls_buffer-node         = ls_data-node.
          ls_buffer-key          = ls_data-key.
          ls_buffer-state        = iv_state.
          ls_buffer-root_key     = ls_data-root_key.
          ls_buffer-parent_key   = ls_data-parent_key.
          ls_buffer-node_cat_key = ls_data-node_cat_key.
*         transform data into combined structure
          IF mo_conf->ms_last_node-node_key <> ls_data-node.
            mo_conf->get_node( ls_data-node ).
          ENDIF.
          CREATE DATA ls_buffer-data TYPE (mo_conf->ms_last_node-data_type).
          ASSIGN ls_data-data->*   TO <ls_source>.
          ASSIGN ls_buffer-data->* TO <ls_target>.
          MOVE-CORRESPONDING <ls_source> TO <ls_target>.
          fill_keys(
            EXPORTING iv_node_key = ls_buffer-node
                      is_keys     = ls_buffer-keys
            CHANGING  cs_data     = <ls_target> ).
          INSERT ls_buffer INTO mt_buffer INDEX lv_tabix.

          ls_key-key = ls_data-root_key.
          INSERT ls_key INTO TABLE mt_root_keys.
          CASE ls_change-change_mode.
            WHEN /bobf/if_frw_c=>sc_modify_load.
              APPEND ls_change TO lt_change_load.
            WHEN /bobf/if_frw_c=>sc_modify_load_key.
              APPEND ls_change TO lt_change_load_key.
            WHEN /bobf/if_frw_c=>sc_modify_reload_int.
              lv_reload_int = abap_true.
              APPEND ls_change TO lt_change.
            WHEN /bobf/if_frw_c=>sc_modify_reload_int_delete.
              lv_reload_del = abap_true.
              APPEND ls_change TO lt_change.
            WHEN OTHERS.
              APPEND ls_change TO lt_change.
          ENDCASE.
          IF iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key.
            ls_change_int-change   = iv_change_mode.
            ls_change_int-node_key = ls_change-node_key.
            ls_change_int-key      = ls_change-key.
            INSERT ls_change_int INTO TABLE mt_change.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

  LOOP AT it_failed_node INTO ls_node.
    DELETE mt_buffer
      WHERE node  = ls_node-node
      AND   key   = ls_node-key
      AND   state = iv_state.
    IF sy-subrc = 0.
      ls_change-node_key    = ls_node-node.
      ls_change-key         = ls_node-key.
      ls_change-change_mode = /bobf/if_frw_c=>sc_modify_reload_int_delete.
      APPEND ls_change TO lt_change.
      lv_reload_del = abap_true.
*    ELSE.
*      ASSERT ID /bopf/buf_simple CONDITION sy-subrc = 0.
* Assert not valid: if access is done with not existing instance, processing always runs into this assert
    ENDIF.
  ENDLOOP.

  io_change->add( it_change          = lt_change
                  it_change_load     = lt_change_load
                  it_change_load_key = lt_change_load_key
                  iv_reload_int      = lv_reload_int
                  iv_reload_del      = lv_reload_del ).

* delete not reloaded instances in the same load group
  IF lt_node IS NOT INITIAL.
    delete_subnodes(
      EXPORTING
        iv_node_key = mo_conf->ms_obj-root_node_key
        iv_state    = iv_state
        io_change   = io_change
      CHANGING
        ct_node     = lt_node ).
  ENDIF.

ENDMETHOD.


METHOD _eval_assoc_binding.

  DATA: lv_found    TYPE boole_d.

  FIELD-SYMBOLS:
     <ls_data>                  TYPE any,
     <ls_runtime_assoc_binding> TYPE /bobf/if_frw_configuration=>gty_runtime_assoc_binding,
     <lv_attribute>             TYPE any,
     <ls_filter>                TYPE any,
     <lv_value>                 TYPE any,
     <lv_value2>                TYPE any.

  IF is_parameters IS SUPPLIED.
    ASSIGN is_parameters->* TO <ls_filter>.
    ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
  ENDIF.

  lv_found = abap_true.
  ASSIGN is_data->* TO <ls_data>.
  ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
  IF sy-subrc <> 0.
    lv_found = abap_false.
    RETURN.
  ENDIF.
  LOOP AT it_runtime_assoc_binding ASSIGNING <ls_runtime_assoc_binding>
    WHERE from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_filter OR
          from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_constant. "#EC CI_SORTSEQ
    IF <ls_runtime_assoc_binding>-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_constant.
      ASSIGN COMPONENT <ls_runtime_assoc_binding>-attribute OF STRUCTURE <ls_data> TO <lv_attribute>.
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
      ASSIGN <ls_runtime_assoc_binding>-constant_value->* TO <lv_value>.
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
    ELSE.
*       check for filtered attributes
      READ TABLE it_filtered_attributes
        WITH KEY table_line = <ls_runtime_assoc_binding>-from_binding
        TRANSPORTING NO FIELDS.
      CHECK sy-subrc = 0.
*       assign fields
      ASSIGN COMPONENT <ls_runtime_assoc_binding>-attribute    OF STRUCTURE <ls_data> TO <lv_attribute>.
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
      ASSIGN COMPONENT <ls_runtime_assoc_binding>-from_binding OF STRUCTURE <ls_filter> TO <lv_value>.
      ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
    ENDIF.

    CASE <ls_runtime_assoc_binding>-sign.
      WHEN /bobf/if_conf_c=>sc_sign_between.
        IF <ls_runtime_assoc_binding>-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_filter.
          ASSIGN COMPONENT <ls_runtime_assoc_binding>-to_binding OF STRUCTURE <ls_filter> TO <lv_value2>.
          ASSERT ID /bobf/buf_simple CONDITION sy-subrc = 0.
          IF <lv_attribute> < <lv_value> OR
             <lv_attribute> > <lv_value2>.
            lv_found = abap_false.
            EXIT.
          ENDIF.
        ELSE.
*             between only supported for filters -> configuration error
          ASSERT ID /bobf/buf_simple CONDITION 1 = 0.      "#EC BOOL_OK
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_sign_equal.
        IF <lv_attribute> <> <lv_value>.
          lv_found = abap_false.
          EXIT.
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_sign_not_equal.
        IF <lv_attribute> = <lv_value>.
          lv_found = abap_false.
          EXIT.
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_sign_greater.
        IF <lv_attribute> <= <lv_value>.
          lv_found = abap_false.
          EXIT.
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_sign_greater_equal.
        IF <lv_attribute> < <lv_value>.
          lv_found = abap_false.
          EXIT.
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_sign_less.
        IF <lv_attribute> >= <lv_value>.
          lv_found = abap_false.
          EXIT.
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_sign_less_equal.
        IF <lv_attribute> > <lv_value>.
          lv_found = abap_false.
          EXIT.
        ENDIF.

      WHEN OTHERS.
*             unknown sign -> configuration error
        ASSERT ID /bobf/buf_simple CONDITION 1 = 0.        "#EC BOOL_OK
    ENDCASE.
  ENDLOOP.

  rv_result = lv_found.

ENDMETHOD.
ENDCLASS.