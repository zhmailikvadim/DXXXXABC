* ----------------------------------------------------------------------
INTERFACE lif_test_bo.
  CONSTANTS BEGIN OF bo.
  CONSTANTS   key TYPE /bobf/conf_key VALUE 1.
  CONSTANTS   name TYPE /bobf/obm_name VALUE 'BUSINESS_OBJECT'.
  CONSTANTS END OF bo.
  CONSTANTS BEGIN OF node.
  CONSTANTS   BEGIN OF root.
  CONSTANTS     name TYPE /bobf/obm_name VALUE 'ROOT'.
  CONSTANTS     key  TYPE /bobf/obm_node_key VALUE 2.
  CONSTANTS   END OF root.
  CONSTANTS   BEGIN OF item.
  CONSTANTS     name TYPE /bobf/obm_name VALUE 'ITEM'.
  CONSTANTS     key  TYPE /bobf/obm_node_key VALUE 3.
  CONSTANTS   END OF item.
  CONSTANTS END OF node.
  CONSTANTS BEGIN OF association.
  CONSTANTS   BEGIN OF root.
  CONSTANTS     to_item TYPE /bobf/conf_key VALUE 4.
  CONSTANTS   END OF root.
  CONSTANTS item_spec1 TYPE /bobf/obm_assoc_key VALUE 5.
  CONSTANTS item_spec2 TYPE /bobf/obm_assoc_key VALUE 6.
  CONSTANTS item_spec3 TYPE /bobf/obm_assoc_key VALUE 7.
  CONSTANTS END OF association.

  TYPES BEGIN OF gty_root_combined.
  INCLUDE TYPE /bobf/s_frw_key_incl.
  TYPES flag TYPE c LENGTH 1.
  TYPES field TYPE string.
  TYPES END OF gty_root_combined.
ENDINTERFACE.                    "lif_test_bo

*----------------------------------------------------------------------*
*       CLASS ltd_configuration DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_configuration DEFINITION FOR TESTING.
  PUBLIC SECTION.
    DATA mt_node TYPE /bobf/t_confro_node.
    INTERFACES /bobf/if_frw_configuration PARTIALLY IMPLEMENTED.
    METHODS set_bo
      IMPORTING is_bo TYPE /bobf/s_confro_obj.
    METHODS set_nodes IMPORTING it_node TYPE /bobf/t_confro_node.

ENDCLASS.                    "ltd_configuration DEFINITION

*----------------------------------------------------------------------*
*       CLASS ltd_configuration IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_configuration IMPLEMENTATION.
  METHOD set_bo.
    /bobf/if_frw_configuration~ms_obj = is_bo.
  ENDMETHOD.                    "set_bo
  METHOD set_nodes.
    mt_node = it_node.
  ENDMETHOD.
  METHOD /bobf/if_frw_configuration~get_node_tab.
  ENDMETHOD.                    "/bobf/if_frw_configuration~get_node_tab
  METHOD /bobf/if_frw_configuration~get_assoc_tab.
  ENDMETHOD.                    "/bobf/if_frw_configuration~get_assoc_tab

  METHOD /bobf/if_frw_configuration~get_node.
    es_node = VALUE #( mt_node[ node_key = iv_node_key ] DEFAULT VALUE #( node_key = iv_node_key ) ).
    /bobf/if_frw_configuration~ms_last_node = es_node.
  ENDMETHOD.
ENDCLASS.                    "ltd_configuration IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS ltd_factory DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_factory DEFINITION FOR TESTING INHERITING FROM /bobf/cl_frw_factory.
  PUBLIC SECTION.
    CLASS-METHODS inject_configuration
      IMPORTING
        io_conf TYPE REF TO /bobf/if_frw_configuration.
ENDCLASS.                    "ltd_factory DEFINITION

*----------------------------------------------------------------------*
*       CLASS ltd_factory IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_factory IMPLEMENTATION.

  METHOD inject_configuration.
    CLEAR gt_factory.
    DATA ls_factory LIKE LINE OF gt_factory.
    ls_factory-key = io_conf->ms_obj-bo_key.
    ls_factory-bo_name = io_conf->ms_obj-bo_name.
    ls_factory-conf = io_conf.
    INSERT ls_factory INTO TABLE gt_factory.
  ENDMETHOD.                    "inject_configuration
ENDCLASS.                    "ltd_factory IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS ltd_dac DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_dac DEFINITION FOR TESTING.
  PUBLIC SECTION.
    TYPES BEGIN OF gty_in_read_composition.
    TYPES   iv_node_key TYPE /bobf/obm_node_key.
    TYPES   it_parent_key TYPE /bobf/t_frw_key.
    TYPES   iv_fill_data TYPE boole_d.
    TYPES   iv_scope TYPE /bobf/buf_read_scope.
    TYPES END OF gty_in_read_composition.
    CLASS-DATA gs_in_read_composition TYPE gty_in_read_composition.
    CLASS-DATA gs_read_buffer_data TYPE /bobf/s_buf_data_read.
    INTERFACES /bobf/if_buf_data_access PARTIALLY IMPLEMENTED.
ENDCLASS.                    "ltd_dac DEFINITION

*----------------------------------------------------------------------*
*       CLASS ltd_dac IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_dac IMPLEMENTATION.
  METHOD /bobf/if_buf_data_access~get_instance.
    DATA lo_dac TYPE REF TO ltd_dac.
    CREATE OBJECT lo_dac.
    eo_data_access = lo_dac.
  ENDMETHOD.                    "/bobf/if_buf_data_access~get_instance
  METHOD /bobf/if_buf_data_access~read_composition.
    gs_in_read_composition = VALUE #(
      iv_node_key = iv_node_key
      iv_fill_data = iv_fill_data
      it_parent_key = it_parent_key
      iv_scope = iv_scope
    ).
    DATA ls_data TYPE /bobf/s_buf_data_read.
    ls_data-node = iv_node_key.
    ls_data-key  = iv_node_key.
    ls_data-data = NEW lif_test_bo=>gty_root_combined( flag = abap_true ).
    APPEND ls_data TO et_data.
  ENDMETHOD.
  METHOD /bobf/if_buf_data_access~read.
    DATA ls_data TYPE /bobf/s_buf_data_read.
    CLEAR ltd_dac=>gs_read_buffer_data.
    LOOP AT it_node ASSIGNING FIELD-SYMBOL(<ls_node>).
      IF <ls_node>-key IS INITIAL.
        APPEND <ls_node> TO et_failed.
      ELSE.
        ls_data-node = <ls_node>-node.
        ls_data-key  = <ls_node>-key.
        ls_data-data = NEW lif_test_bo=>gty_root_combined( flag = abap_true ).
        MOVE-CORRESPONDING ls_data TO ltd_dac=>gs_read_buffer_data.  "to verify test
        INSERT ls_data INTO TABLE et_data.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.                    "ltd_dac IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS ltd_buffer DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_buffer DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltd_buffer.
*----------------------------------------------------------------------*
*       CLASS ltd_buffer DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_buffer DEFINITION FOR TESTING INHERITING FROM /bobf/cl_buf_simple CREATE PUBLIC.
  PUBLIC SECTION.
    CLASS-DATA gt_created_root_key TYPE /bobf/t_frw_key.
    DATA mv_end_load_raised TYPE boole_d.
    METHODS constructor
      IMPORTING iv_bo_key TYPE /bobf/conf_key
      RAISING   /bobf/cx_frw.

    METHODS /bobf/if_frw_buffer~compare_states REDEFINITION.
    CLASS-METHODS on_teardown.

  PROTECTED SECTION.
    METHODS handle_event_end_load REDEFINITION.
    METHODS write_loaded_data REDEFINITION.
ENDCLASS.                    "ltd_buffer DEFINITION

*----------------------------------------------------------------------*
*       CLASS ltd_buffer IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltd_buffer IMPLEMENTATION.
  METHOD constructor.
    super->constructor(
      EXPORTING
        iv_bo_key   = iv_bo_key
    ).
  ENDMETHOD.                    "constructor
  METHOD on_teardown.
    CLEAR st_instance.
  ENDMETHOD.                    "teardown

  METHOD /bobf/if_frw_buffer~compare_states.
    IF gt_created_root_key IS NOT INITIAL.
      LOOP AT it_key INTO DATA(ls_key).
        READ TABLE gt_created_root_key FROM ls_key TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          io_change->add_change(
            EXPORTING
              iv_change_mode = /bobf/if_frw_c=>sc_modify_create
              iv_node_key    = iv_node_key
              iv_key         = ls_key-key
          ).
        ENDIF.
      ENDLOOP.
    ELSE.
      super->/bobf/if_frw_buffer~compare_states(
        EXPORTING
          iv_node_key      = iv_node_key
          it_key           = it_key
          iv_state_current = iv_state_current
          iv_state_before  = iv_state_before
          iv_incl_subtree  = iv_incl_subtree
          io_change        = io_change
      ).
    ENDIF.
  ENDMETHOD.

  METHOD handle_event_end_load.
    mv_end_load_raised = abap_true.
  ENDMETHOD.

  METHOD write_loaded_data.
*  nothing to do here.
  ENDMETHOD.

ENDCLASS.                    "ltd_buffer IMPLEMENTATION
CLASS lth_setup DEFINITION FOR TESTING.
  PUBLIC SECTION.
    CLASS-METHODS setup_environment
      IMPORTING
                io_conf          TYPE REF TO ltd_configuration
      RETURNING VALUE(ro_buffer) TYPE REF TO /bobf/cl_buf_simple
      RAISING   /bobf/cx_frw.
ENDCLASS.

CLASS lth_setup IMPLEMENTATION.
  METHOD setup_environment.

    io_conf->set_bo(
      is_bo = VALUE #(
          bo_name = lif_test_bo=>bo-name
          bo_key  = lif_test_bo=>bo-key
          mapper_class = 'LTD_DAC' )
    ).
    ltd_factory=>inject_configuration( io_conf = io_conf ).
    ltd_buffer=>on_teardown( ).

    ltd_buffer=>/bobf/if_frw_buffer~get_instance(
      EXPORTING
        iv_bo_key       = lif_test_bo=>bo-key
        iv_buffer_class = 'LTD_BUFFER'
      IMPORTING
        eo_buffer       = DATA(lo_buffer)
    ).

    ro_buffer ?= lo_buffer.
    CLEAR ltd_dac=>gs_in_read_composition.

  ENDMETHOD.
ENDCLASS.

*----------------------------------------------------------------------*
*       CLASS ltc_transfer_states DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltc_transfer_states DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltc_transfer_states.

*----------------------------------------------------------------------*
*       CLASS ltc_transfer_states DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltc_transfer_states DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.

  PRIVATE SECTION.
    DATA mo_buffer TYPE REF TO /bobf/cl_buf_simple.
    DATA mo_conf TYPE REF TO ltd_configuration.
    METHODS setup RAISING /bobf/cx_frw.
    METHODS one_state_root_w_subtree FOR TESTING RAISING /bobf/cx_frw.
    METHODS multiple_states_w_subtree FOR TESTING RAISING /bobf/cx_frw.
    METHODS one_state_root_wo_subtree FOR TESTING RAISING /bobf/cx_frw.
    METHODS multiple_statew_wo_subtree FOR TESTING RAISING /bobf/cx_frw.
    METHODS with_subtree_no_source_state FOR TESTING RAISING /bobf/cx_frw.

ENDCLASS.                    "ltc_transfer_states DEFINITION

*----------------------------------------------------------------------*
*       CLASS ltc_transfer_states IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltc_transfer_states IMPLEMENTATION.

  METHOD setup.
    CREATE OBJECT mo_conf.
    mo_buffer = lth_setup=>setup_environment( mo_conf ).
  ENDMETHOD.                    "setup

  METHOD one_state_root_w_subtree.

    DATA ls_node      TYPE /bobf/s_frw_node.
    DATA lt_node      TYPE   /bobf/t_frw_node.
    DATA ls_buffer    TYPE /bobf/s_buf_simple_buffer.
    DATA lv_root1_key TYPE /bobf/conf_key.
    DATA lv_root2_key TYPE /bobf/conf_key.
    DATA lv_item1_key TYPE /bobf/conf_key.
    DATA lv_item2_key TYPE /bobf/conf_key.

    lv_root1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_root2_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item2_key = /bobf/cl_frw_factory=>get_new_key( ).

    "prepare buffer table
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-root2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_root2_key.
    INSERT ls_buffer INTO TABLE  mo_buffer->mt_buffer.

    "-item1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_item1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-item2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_item2_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    ls_node-key = lv_root2_key.
    ls_node-node = lif_test_bo=>node-root-key.
    APPEND ls_node TO lt_node.

    mo_buffer->/bobf/if_frw_buffer~transfer_state(
      EXPORTING
        it_node                       = lt_node
        iv_incl_subtree               = abap_true
        iv_state_source               = /bobf/if_conf_c=>sc_state_current
        iv_state_dest                 = /bobf/if_conf_c=>sc_state_database
    ).

    cl_abap_unit_assert=>assert_equals( exp = 6 act = lines( mo_buffer->mt_buffer ) ).

    READ TABLE mo_buffer->mt_buffer INTO ls_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       node = lif_test_bo=>node-root-key
       root_key = lv_root2_key
       key = lv_root2_key.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).
    cl_abap_unit_assert=>assert_bound( ls_buffer-data ).

    READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       node = lif_test_bo=>node-root-key
       root_key = lv_root1_key
       key = lv_root1_key TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      cl_abap_unit_assert=>fail( ).
    ENDIF.

    READ TABLE mo_buffer->mt_buffer INTO ls_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       node = lif_test_bo=>node-item-key
       root_key = lv_root2_key
       key = lv_item2_key.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).
    cl_abap_unit_assert=>assert_bound( ls_buffer-data ).

    READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       node = lif_test_bo=>node-item-key
       root_key = lv_root1_key
       key = lv_item1_key TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      cl_abap_unit_assert=>fail( ).
    ENDIF.

  ENDMETHOD.                    "one_state_root_w_subtree

  METHOD multiple_states_w_subtree.

    DATA ls_node                  TYPE /bobf/s_frw_node.
    DATA lt_node                  TYPE /bobf/t_frw_node.
    DATA ls_buffer                TYPE /bobf/s_buf_simple_buffer.
    DATA lv_root1_key             TYPE /bobf/conf_key.
    DATA lv_root2_key             TYPE /bobf/conf_key.
    DATA lv_item1_key             TYPE /bobf/conf_key.
    DATA lv_item2_key             TYPE /bobf/conf_key.
    DATA lr_root1                 TYPE REF TO /bobf/s_frw_node.
    DATA lt_additional_state_dest TYPE /bobf/if_frw_buffer=>tt_state.
    DATA lv_add_state_dest_trans  TYPE boole_d.

    lv_root1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_root2_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item2_key = /bobf/cl_frw_factory=>get_new_key( ).

    "prepare buffer table - current state
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA lr_root1.
    ls_buffer-data = lr_root1.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-root2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_root2_key.
    INSERT ls_buffer INTO TABLE  mo_buffer->mt_buffer.

    "-item1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_item1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-item2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_item2_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "prepare buffer table - db state
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_database.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "prepare node
    ls_node-key = lv_root2_key.
    ls_node-node = lif_test_bo=>node-root-key.
    INSERT ls_node INTO TABLE lt_node.
    ls_node-key = lv_root1_key.
    ls_node-node = lif_test_bo=>node-root-key.
    INSERT ls_node INTO TABLE lt_node.

    APPEND /bobf/if_conf_c=>sc_state_last_determined TO lt_additional_state_dest.
    APPEND /bobf/if_conf_c=>sc_state_last_validated  TO lt_additional_state_dest.

    mo_buffer->/bobf/if_frw_buffer~transfer_state(
      EXPORTING
        it_node                       = lt_node
        iv_incl_subtree               = abap_true
        iv_state_source               = /bobf/if_conf_c=>sc_state_current
        iv_state_dest                 = /bobf/if_conf_c=>sc_state_database
        it_additional_state_dest      = lt_additional_state_dest
      IMPORTING
        ev_add_state_dest_transferred = lv_add_state_dest_trans
    ).


    cl_abap_unit_assert=>assert_equals( exp = 16 act = lines( mo_buffer->mt_buffer ) ).
    "current image must remain unchanged - check sample for root1
    READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_current
       node = lif_test_bo=>node-root-key
       root_key = lv_root1_key
       key = lv_root1_key
       data = lr_root1 TRANSPORTING NO FIELDS.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).

    "for each record in state 1 we should find exactly the same record in all other buffer states
    DATA lv_state1_cnt TYPE i.
    LOOP AT mo_buffer->mt_buffer INTO ls_buffer WHERE state = /bobf/if_conf_c=>sc_state_current.

      ADD 1 TO lv_state1_cnt.

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_last_determined
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_last_validated
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = 4 act = lv_state1_cnt ).

  ENDMETHOD.                    "multiple_states_w_subtree

  METHOD one_state_root_wo_subtree.

    DATA ls_node      TYPE /bobf/s_frw_node.
    DATA lt_node      TYPE   /bobf/t_frw_node.
    DATA ls_buffer    TYPE /bobf/s_buf_simple_buffer.
    DATA lv_root1_key TYPE /bobf/conf_key.
    DATA lv_root2_key TYPE /bobf/conf_key.
    DATA lv_item1_key TYPE /bobf/conf_key.
    DATA lv_item2_key TYPE /bobf/conf_key.
    DATA lt_buffer    LIKE mo_buffer->mt_buffer.
    DATA lr_root2     TYPE REF TO /bobf/s_frw_node.

    lv_root1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_root2_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item2_key = /bobf/cl_frw_factory=>get_new_key( ).

    "prepare buffer table
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-root2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA lr_root2.
    ls_buffer-data = lr_root2.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_root2_key.
    INSERT ls_buffer INTO TABLE  mo_buffer->mt_buffer.

    "-item1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_item1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-item2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_item2_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    lt_buffer = mo_buffer->mt_buffer.

    ls_node-key = lv_root2_key.
    ls_node-node = lif_test_bo=>node-root-key.
    APPEND ls_node TO lt_node.

    mo_buffer->/bobf/if_frw_buffer~transfer_state(
      EXPORTING
        it_node                       = lt_node
        iv_incl_subtree               = abap_false
        iv_state_source               = /bobf/if_conf_c=>sc_state_current
        iv_state_dest                 = /bobf/if_conf_c=>sc_state_database
    ).

    cl_abap_unit_assert=>assert_equals( exp = 5 act = lines( mo_buffer->mt_buffer ) ).

    "each line of lt_buffer must be in mt_buffer.

    LOOP AT lt_buffer INTO ls_buffer.
      READ TABLE mo_buffer->mt_buffer WITH KEY
      state = ls_buffer-state
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data
             TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

    ENDLOOP.

    "additionally, there must be the root2 in database image
    READ TABLE mo_buffer->mt_buffer WITH KEY
    state = /bobf/if_conf_c=>sc_state_database
     node = lif_test_bo=>node-root-key
     root_key = lv_root2_key
     key = lv_root2_key
     data = lr_root2
           TRANSPORTING NO FIELDS.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).

  ENDMETHOD.                    "one_state_root_wo_subtree

  METHOD multiple_statew_wo_subtree.

    DATA ls_node                  TYPE /bobf/s_frw_node.
    DATA lt_node                  TYPE /bobf/t_frw_node.
    DATA ls_buffer                TYPE /bobf/s_buf_simple_buffer.
    DATA lv_root1_key             TYPE /bobf/conf_key.
    DATA lv_root2_key             TYPE /bobf/conf_key.
    DATA lv_item1_key             TYPE /bobf/conf_key.
    DATA lv_item2_key             TYPE /bobf/conf_key.
    DATA lr_root1                 TYPE REF TO /bobf/s_frw_node.
    DATA lt_additional_state_dest TYPE /bobf/if_frw_buffer=>tt_state.
    DATA lv_add_state_dest_trans  TYPE boole_d.

    lv_root1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_root2_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item2_key = /bobf/cl_frw_factory=>get_new_key( ).

    "prepare buffer table - current state
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA lr_root1.
    ls_buffer-data = lr_root1.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-root2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_root2_key.
    INSERT ls_buffer INTO TABLE  mo_buffer->mt_buffer.

    "-item1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_item1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-item2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_item2_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "prepare buffer table - db state
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_database.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "prepare node
    ls_node-key = lv_root2_key.
    ls_node-node = lif_test_bo=>node-root-key.
    INSERT ls_node INTO TABLE lt_node.
    ls_node-key = lv_root1_key.
    ls_node-node = lif_test_bo=>node-root-key.
    INSERT ls_node INTO TABLE lt_node.

    APPEND /bobf/if_conf_c=>sc_state_last_determined TO lt_additional_state_dest.
    APPEND /bobf/if_conf_c=>sc_state_last_validated  TO lt_additional_state_dest.

    mo_buffer->/bobf/if_frw_buffer~transfer_state(
      EXPORTING
        it_node                       = lt_node
        iv_incl_subtree               = abap_false
        iv_state_source               = /bobf/if_conf_c=>sc_state_current
        iv_state_dest                 = /bobf/if_conf_c=>sc_state_database
        it_additional_state_dest      = lt_additional_state_dest
      IMPORTING
        ev_add_state_dest_transferred = lv_add_state_dest_trans
    ).

    cl_abap_unit_assert=>assert_equals( exp = 10 act = lines( mo_buffer->mt_buffer ) ).
    "current image must remain unchanged - check sample for root1
    READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_current
       node = lif_test_bo=>node-root-key
       root_key = lv_root1_key
       key = lv_root1_key
       data = lr_root1 TRANSPORTING NO FIELDS.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).

    "for each root record in state 1 we should find exactly the same record in all other buffer states
    DATA lv_state1_cnt TYPE i.
    LOOP AT mo_buffer->mt_buffer INTO ls_buffer
      WHERE state = /bobf/if_conf_c=>sc_state_current AND
         node = lif_test_bo=>node-root-key.

      ADD 1 TO lv_state1_cnt.

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_last_determined
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_last_validated
       node = ls_buffer-node
       root_key = ls_buffer-root_key
       key = ls_buffer-key
       data = ls_buffer-data TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0 ).

    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = 2 act = lv_state1_cnt ).

    "we shouldn't find any item records in states other than current
    LOOP AT mo_buffer->mt_buffer INTO ls_buffer
      WHERE state = /bobf/if_conf_c=>sc_state_current AND
         node = lif_test_bo=>node-item-key.

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_database
       key = ls_buffer-key
      TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        cl_abap_unit_assert=>fail( ).
      ENDIF.

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_last_determined
       key = ls_buffer-key
      TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        cl_abap_unit_assert=>fail( ).
      ENDIF.

      READ TABLE mo_buffer->mt_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_last_validated
       key = ls_buffer-key
      TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        cl_abap_unit_assert=>fail( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "multiple_states_w_subtree

  METHOD with_subtree_no_source_state.

    "setup: current state in buffer
    "transfer state: from before modify image to current image -> current data will be deleted,
    "                because source state is not in the buffer


    DATA ls_node      TYPE /bobf/s_frw_node.
    DATA lt_node      TYPE   /bobf/t_frw_node.
    DATA ls_buffer    TYPE /bobf/s_buf_simple_buffer.
    DATA lv_root1_key TYPE /bobf/conf_key.
    DATA lv_root2_key TYPE /bobf/conf_key.
    DATA lv_item1_key TYPE /bobf/conf_key.
    DATA lv_item2_key TYPE /bobf/conf_key.

    lv_root1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_root2_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item1_key = /bobf/cl_frw_factory=>get_new_key( ).
    lv_item2_key = /bobf/cl_frw_factory=>get_new_key( ).

    "prepare buffer table
    "-root1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_root1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-root2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-root-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_root2_key.
    INSERT ls_buffer INTO TABLE  mo_buffer->mt_buffer.

    "-item1
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root1_key.
    ls_buffer-key = lv_item1_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    "-item2
    ls_buffer-state = /bobf/if_conf_c=>sc_state_current.
    CREATE DATA ls_buffer-data TYPE /bobf/s_frw_node.
    ls_buffer-node = lif_test_bo=>node-item-key.
    ls_buffer-root_key = lv_root2_key.
    ls_buffer-key = lv_item2_key.
    INSERT ls_buffer INTO TABLE mo_buffer->mt_buffer.

    ls_node-key = lv_root2_key.
    ls_node-node = lif_test_bo=>node-root-key.
    APPEND ls_node TO lt_node.

    mo_buffer->/bobf/if_frw_buffer~transfer_state(
      EXPORTING
        it_node                       = lt_node
        iv_incl_subtree               = abap_true
        iv_state_source               = /bobf/if_conf_c=>sc_state_before_modification
        iv_state_dest                 = /bobf/if_conf_c=>sc_state_current
    ).

    cl_abap_unit_assert=>assert_equals( exp = 2 act = lines( mo_buffer->mt_buffer ) ).

    READ TABLE mo_buffer->mt_buffer INTO ls_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_current
       node = lif_test_bo=>node-root-key
       root_key = lv_root1_key
       key = lv_root1_key.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).
    cl_abap_unit_assert=>assert_bound( ls_buffer-data ).

    READ TABLE mo_buffer->mt_buffer INTO ls_buffer WITH KEY
       state = /bobf/if_conf_c=>sc_state_current
       node = lif_test_bo=>node-item-key
       root_key = lv_root1_key
       key = lv_item1_key.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).
    cl_abap_unit_assert=>assert_bound( ls_buffer-data ).

  ENDMETHOD.                    "one_state_root_w_subtree

ENDCLASS.                    "ltc_transfer_states IMPLEMENTATION

CLASS ltc_load_composition DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltc_load_composition.
CLASS ltc_load_composition DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.

  PRIVATE SECTION.
    DATA mo_buffer TYPE REF TO /bobf/cl_buf_simple.
    DATA mo_conf TYPE REF TO ltd_configuration.
    METHODS setup RAISING /bobf/cx_frw.
    METHODS load_composition FOR TESTING RAISING /bobf/cx_frw.
    METHODS load_comp_with_created FOR TESTING RAISING /bobf/cx_frw.
    METHODS load_comp_with_retrieve FOR TESTING RAISING /bobf/cx_frw.
ENDCLASS.                    "ltc_transfer_states DEFINITION


CLASS ltc_load_composition IMPLEMENTATION.
  METHOD setup.
    CREATE OBJECT mo_conf.
    mo_buffer = lth_setup=>setup_environment( io_conf = mo_conf ).
  ENDMETHOD.

  METHOD load_composition.
    "Test Scenario:
    "- 2 compositions not yet buffered
    "- 2 compositions already buffered, but keys only
    "- 2 compositions already buffered with data

    DATA ls_buffer_comp TYPE /bobf/cl_buf_simple=>ts_comp.
    DATA ls_assoc TYPE /bobf/s_confro_assoc.
    DATA ls_assoc2 TYPE /bobf/s_confro_assoc2.

    CONSTANTS BEGIN OF lc_key.
    CONSTANTS  not_buffered1       TYPE /bobf/conf_key VALUE '999'.
    CONSTANTS  not_buffered2       TYPE /bobf/conf_key VALUE '998'.
    CONSTANTS  buffered_keys_only1 TYPE /bobf/conf_key VALUE '997'.
    CONSTANTS  buffered_keys_only2 TYPE /bobf/conf_key VALUE '996'.
    CONSTANTS  buffered_with_data1 TYPE /bobf/conf_key VALUE '995'.
    CONSTANTS  buffered_with_data2 TYPE /bobf/conf_key VALUE '994'.
    CONSTANTS END OF lc_key.

    ls_assoc = VALUE #( assoc_key = lif_test_bo=>association-root-to_item
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        target_node = NEW #( loadable = abap_true
                             optimized_buffer_access = abap_true )
    ).

    MOVE-CORRESPONDING ls_assoc TO ls_assoc2.
    mo_buffer->mt_conf_comp = VALUE #( ( ls_assoc2 ) ).

    mo_buffer->mt_buffer_comp = VALUE #(
      ( source_key = lc_key-buffered_keys_only1
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_false )
      ( source_key = lc_key-buffered_keys_only2
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_false )
      ( source_key = lc_key-buffered_with_data1
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_true )
      ( source_key = lc_key-buffered_with_data2
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_true )
    ).

    mo_buffer->load_composition(
      EXPORTING
        it_key            = VALUE #(
                              ( key = lc_key-not_buffered1 )
                              ( key = lc_key-not_buffered2 )
                              ( key = lc_key-buffered_keys_only1 )
                              ( key = lc_key-buffered_keys_only2 )
                              ( key = lc_key-buffered_with_data1 )
                              ( key = lc_key-buffered_with_data2 )
                            )
        is_assoc          = ls_assoc
        iv_fill_data      = abap_true
        iv_state          = /bobf/if_conf_c=>sc_state_current
        io_change         = /bobf/cl_frw_factory=>get_change( )
        iv_notify_keyload = abap_false
    ).

    cl_abap_unit_assert=>assert_equals(
      exp = VALUE ltd_dac=>gty_in_read_composition(
              iv_fill_data = abap_true
              iv_node_key = lif_test_bo=>node-item-key
              it_parent_key = VALUE #(
                ( key = lc_key-not_buffered1 )
                ( key = lc_key-not_buffered2 )
              )
              iv_scope = /bobf/if_buf_c=>sc_scope_loadgroup
            )
      act = ltd_dac=>gs_in_read_composition
    ).

  ENDMETHOD.

  METHOD load_comp_with_created.

    "Test Scenario:
    "- 1 composition not yet buffered
    "- 1 composition buffered
    "- 2 records newly created and not yet marked as buffered composition
    "=>after loading composition, 1 composition has to be loaded from dac;
    "  the 2 newly created instances have to be marked as buffered compositions

    DATA ls_buffer_comp TYPE /bobf/cl_buf_simple=>ts_comp.
    DATA ls_assoc TYPE /bobf/s_confro_assoc.
    DATA ls_assoc2 TYPE /bobf/s_confro_assoc2.

    CONSTANTS BEGIN OF lc_key.
    CONSTANTS  not_buffered1        TYPE /bobf/conf_key VALUE '999'.
    CONSTANTS  buffered_with_data1  TYPE /bobf/conf_key VALUE '997'.
    CONSTANTS  newly_created1       TYPE /bobf/conf_key VALUE '995'.
    CONSTANTS  newly_created2       TYPE /bobf/conf_key VALUE '996'.
    CONSTANTS END OF lc_key.

    ls_assoc = VALUE #( assoc_key = lif_test_bo=>association-root-to_item
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        target_node = NEW #( loadable = abap_true
                             optimized_buffer_access = abap_true )
    ).

    MOVE-CORRESPONDING ls_assoc TO ls_assoc2.
    mo_buffer->mt_conf_comp = VALUE #( ( ls_assoc2 ) ).

    mo_buffer->mt_buffer_comp = VALUE #(
      ( source_key = lc_key-buffered_with_data1
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_true )
    ).


    CAST ltd_buffer( mo_buffer )->gt_created_root_key = VALUE #(
      ( key = lc_key-newly_created1 )
      ( key = lc_key-newly_created2 )
    ).

    mo_buffer->load_composition(
      EXPORTING
        it_key            = VALUE #(
                              ( key = lc_key-not_buffered1 )
                              ( key = lc_key-buffered_with_data1 )
                              ( key = lc_key-newly_created1 )
                              ( key = lc_key-newly_created2 )
                            )
        is_assoc          = ls_assoc
        iv_fill_data      = abap_true
        iv_state          = /bobf/if_conf_c=>sc_state_current
        io_change         = /bobf/cl_frw_factory=>get_change( )
        iv_notify_keyload = abap_false
    ).

    cl_abap_unit_assert=>assert_equals(
      exp = VALUE ltd_dac=>gty_in_read_composition(
              iv_fill_data = abap_true
              iv_node_key = lif_test_bo=>node-item-key
              it_parent_key = VALUE #(
                ( key = lc_key-not_buffered1 )
              )
              iv_scope = /bobf/if_buf_c=>sc_scope_loadgroup
            )
      act = ltd_dac=>gs_in_read_composition
    ).

    cl_abap_unit_assert=>assert_equals( exp = 4 act = lines( mo_buffer->mt_buffer_comp ) ).

    READ TABLE mo_buffer->mt_buffer_comp WITH KEY
      source_node_key = lif_test_bo=>node-root-key
      source_key = lc_key-newly_created1
      target_node_key = lif_test_bo=>node-item-key
      with_data = abap_true
      TRANSPORTING NO FIELDS.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).

    READ TABLE mo_buffer->mt_buffer_comp WITH KEY
      source_node_key = lif_test_bo=>node-root-key
      source_key = lc_key-newly_created2
      target_node_key = lif_test_bo=>node-item-key
      with_data = abap_true
      TRANSPORTING NO FIELDS.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).

  ENDMETHOD.

  METHOD load_comp_with_retrieve.
    "Test Scenario:
    "- 2 compositions not yet buffered
    "- 2 compositions already buffered, but keys only
    "- 2 compositions already buffered with data

    DATA ls_buffer_comp TYPE /bobf/cl_buf_simple=>ts_comp.
    DATA ls_assoc TYPE /bobf/s_confro_assoc.
    DATA ls_assoc2 TYPE /bobf/s_confro_assoc2.

    CONSTANTS BEGIN OF lc_key.
    CONSTANTS  not_buffered1       TYPE /bobf/conf_key VALUE '999'.
    CONSTANTS  not_buffered2       TYPE /bobf/conf_key VALUE '998'.
    CONSTANTS  buffered_keys_only1 TYPE /bobf/conf_key VALUE '997'.
    CONSTANTS  buffered_keys_only2 TYPE /bobf/conf_key VALUE '996'.
    CONSTANTS  buffered_with_data1 TYPE /bobf/conf_key VALUE '995'.
    CONSTANTS  buffered_with_data2 TYPE /bobf/conf_key VALUE '994'.
    CONSTANTS END OF lc_key.

    ls_assoc = VALUE #( assoc_key = lif_test_bo=>association-root-to_item
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        target_node = NEW #( loadable = abap_true
                             optimized_buffer_access = abap_true )
    ).

    MOVE-CORRESPONDING ls_assoc TO ls_assoc2.
    mo_buffer->mt_conf_comp = VALUE #( ( ls_assoc2 ) ).

    mo_buffer->mt_buffer_comp = VALUE #(
      ( source_key = lc_key-buffered_keys_only1
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_false )
      ( source_key = lc_key-buffered_keys_only2
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_false )
      ( source_key = lc_key-buffered_with_data1
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_true )
      ( source_key = lc_key-buffered_with_data2
        source_node_key = lif_test_bo=>node-root-key
        target_node_key = lif_test_bo=>node-item-key
        with_data = abap_true )
    ).

    "insert test data to be retrieved
    mo_buffer->mt_buffer = VALUE #(
      ( node = lif_test_bo=>node-item-key
        key  = lif_test_bo=>node-item-key
        parent_key = lc_key-buffered_keys_only1
        root_key = lif_test_bo=>node-root-key
        state = /bobf/if_conf_c=>sc_state_current )
*      ( node = lif_test_bo=>node-root-key
*        key  = lif_test_bo=>node-item-key
*        parent_key = lc_key-buffered_keys_only1
*        root_key = lif_test_bo=>node-root-key
*        state = /bobf/if_conf_c=>sc_state_current )
    ).

    mo_buffer->load_composition(
      EXPORTING
        it_key            = VALUE #(
                              ( key = lc_key-not_buffered1 )
                              ( key = lc_key-not_buffered2 )
                              ( key = lc_key-buffered_keys_only1 )
                              ( key = lc_key-buffered_keys_only2 )
                              ( key = lc_key-buffered_with_data1 )
                              ( key = lc_key-buffered_with_data2 )
                            )
        is_assoc          = ls_assoc
        iv_fill_data      = abap_true
        iv_state          = /bobf/if_conf_c=>sc_state_current
        io_change         = /bobf/cl_frw_factory=>get_change( )
        iv_notify_keyload = abap_false
    ).

    cl_abap_unit_assert=>assert_not_initial( ltd_dac=>gs_read_buffer_data ).


  ENDMETHOD.

ENDCLASS.


CLASS ltc_retrieve DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltc_retrieve.
CLASS ltc_retrieve DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.

  PRIVATE SECTION.
    DATA mo_buffer TYPE REF TO /bobf/cl_buf_simple.
    DATA mo_conf TYPE REF TO ltd_configuration.
    METHODS setup RAISING /bobf/cx_frw.
    METHODS retrieve_buffered_wo_keyload FOR TESTING RAISING /bobf/cx_frw.

ENDCLASS.                    "ltc_transfer_states DEFINITION


CLASS ltc_retrieve IMPLEMENTATION.
  METHOD setup.
    CREATE OBJECT mo_conf.
    mo_buffer = lth_setup=>setup_environment( mo_conf ).
  ENDMETHOD.

  METHOD retrieve_buffered_wo_keyload.

    DATA lo_change TYPE REF TO /bobf/if_frw_change.
    DATA lt_root TYPE STANDARD TABLE OF lif_test_bo=>gty_root_combined.
    "test scenario: retrieve buffered data without notifying keyload

    "insert test data to be retrieved
    mo_buffer->mt_buffer = VALUE #(
      ( node = lif_test_bo=>node-root-key
        key  = 1001
        parent_key = 1001
        root_key = 1001
        state = /bobf/if_conf_c=>sc_state_database
        data = NEW lif_test_bo=>gty_root_combined( flag = abap_true ) )
      ( node = lif_test_bo=>node-root-key
        key  = 1002
        parent_key = 1002
        root_key = 1002
        state = /bobf/if_conf_c=>sc_state_database
        data = NEW lif_test_bo=>gty_root_combined( flag = abap_true ) )
    ).

    mo_buffer->mt_change = VALUE #(
      ( change = /bobf/if_frw_c=>sc_modify_load_key
        node_key = lif_test_bo=>node-root-key
        key      = 1001 )
    ).

    lo_change = /bobf/cl_frw_factory=>get_change( ).

    mo_buffer->/bobf/if_frw_buffer~retrieve(
      EXPORTING
        iv_node_key       = lif_test_bo=>node-root-key
        it_key            = VALUE #( ( key = 1001 ) ( key = 1002 ) )
        iv_state          = /bobf/if_conf_c=>sc_state_database
        iv_fill_data      = abap_true
        iv_buffer_only    = abap_false    " Search only in buffer and do not load data
        iv_notify_keyload = abap_false    " Notify loaded keys only (when loading data)
        io_change         = lo_change
      IMPORTING
        et_data           = lt_root
    ).

    cl_abap_unit_assert=>assert_equals( exp = 2 act = lines( lt_root ) ).
    lo_change->get_changes(
      EXPORTING
        iv_change_mode  = /bobf/if_frw_c=>sc_modify_load
      IMPORTING
        et_change       = DATA(lt_change)
    ).
    cl_abap_unit_assert=>assert_equals( exp = 1 act = lines( lt_change ) ) .

    READ TABLE lt_change WITH TABLE KEY key1 COMPONENTS
      node_key = lif_test_bo=>node-root-key
      key = 1001
      change_mode = /bobf/if_frw_c=>sc_modify_load TRANSPORTING NO FIELDS.
    cl_abap_unit_assert=>assert_subrc( exp = 0 ).
    cl_abap_unit_assert=>assert_initial( mo_buffer->mt_change ).

  ENDMETHOD.

ENDCLASS.

CLASS ltd_main_buffer DEFINITION FOR TESTING.
  PUBLIC SECTION.
    INTERFACES /bobf/if_frw_buffer PARTIALLY IMPLEMENTED.

ENDCLASS.

CLASS ltd_main_buffer IMPLEMENTATION.
  METHOD /bobf/if_frw_buffer~load.

    FIELD-SYMBOLS <ls_node> TYPE /bobf/s_frw_node.
    DATA ls_requested_node  TYPE /bobf/s_frw_node_only.
    DATA lt_requested_node  TYPE /bobf/t_frw_node_only.

    LOOP AT it_node ASSIGNING <ls_node>.
      AT NEW node.
        ls_requested_node-node = <ls_node>-node.
        APPEND ls_requested_node TO lt_requested_node.
      ENDAT.
    ENDLOOP.

    RAISE EVENT /bobf/if_frw_buffer~end_load
      EXPORTING
        io_change         = /bobf/cl_frw_factory=>get_change( )
        iv_bo_key         = lif_test_bo=>bo-key
        it_requested_node = lt_requested_node.

  ENDMETHOD.

ENDCLASS.

CLASS ltc_event_end_load DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltc_event_end_load.

CLASS ltc_event_end_load DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.
  PRIVATE SECTION.
    DATA mo_buffer TYPE REF TO /bobf/cl_buf_simple.
    DATA mo_main_buffer TYPE REF TO ltd_main_buffer.
    DATA mo_conf TYPE REF TO ltd_configuration.

    METHODS setup RAISING /bobf/cx_frw.
    METHODS loadgroup_rel_no_nodes FOR TESTING.
    METHODS loadgroup_rel_is_part_of_group FOR TESTING.
    METHODS loadgrp_rel_not_part_of_group FOR TESTING.
    METHODS register_unregister_load_end FOR TESTING RAISING /bobf/cx_frw.


ENDCLASS.

CLASS ltc_event_end_load IMPLEMENTATION.
  METHOD setup.
    create object mo_conf.
    mo_buffer = lth_setup=>setup_environment( mo_conf ).
    CREATE OBJECT mo_main_buffer.
    mo_buffer->mo_main_buffer = mo_main_buffer.
  ENDMETHOD.
  METHOD loadgroup_rel_no_nodes.

    "loadgroup is undefined through mt_node_Key -> relevant
    mo_buffer->mt_node_key = VALUE #( ).
    cl_abap_unit_assert=>assert_true(  mo_buffer->is_relevant_for_loadgroup(
       EXPORTING
         it_requested_node     = VALUE #( )
         iv_nodes_are_supplied = abap_true
      )
     ).

    "no nodes are supplied with it_requested_node -> relevant
    mo_buffer->mt_node_key = VALUE #( ( node = lif_test_bo=>node-root-key ) ).
    cl_abap_unit_assert=>assert_true(  mo_buffer->is_relevant_for_loadgroup(
       EXPORTING
         it_requested_node     = VALUE #( ( node = lif_test_bo=>node-root-key ) )
         iv_nodes_are_supplied = abap_false
      )
     ).

  ENDMETHOD.
  METHOD loadgroup_rel_is_part_of_group.

    "requested node is part of loadgroup; requested nodes < mt_node_key
    mo_buffer->mt_node_key = VALUE #(
      ( node = lif_test_bo=>node-root-key )
      ( node = lif_test_bo=>node-item-key )
    ).

    cl_abap_unit_assert=>assert_true(
      mo_buffer->is_relevant_for_loadgroup(
          it_requested_node     = VALUE #( ( node = lif_test_bo=>node-item-key ) )
          iv_nodes_are_supplied = abap_true
      )
    ).

    "requested node is part of loadgroup; requested nodes > mt_node_key
    mo_buffer->mt_node_key = VALUE #(
      ( node = lif_test_bo=>node-item-key )
    ).

    cl_abap_unit_assert=>assert_true(
       mo_buffer->is_relevant_for_loadgroup(
          it_requested_node = VALUE #(
            ( node = lif_test_bo=>node-root-key )
            ( node = lif_test_bo=>node-item-key ) )
          iv_nodes_are_supplied = abap_true
       )
    ).

  ENDMETHOD.

  METHOD loadgrp_rel_not_part_of_group.

    "requested node not part of loadgroup
    mo_buffer->mt_node_key = VALUE #(
       ( node = lif_test_bo=>node-root-key )
     ).

    cl_abap_unit_assert=>assert_false(
       mo_buffer->is_relevant_for_loadgroup(
        it_requested_node     = VALUE #( ( node = lif_test_bo=>node-item-key ) )
        iv_nodes_are_supplied = abap_true
      )
    ).

  ENDMETHOD.

  METHOD register_unregister_load_end.

    "first register the buffer for the end load event of the main buffer
    DATA lo_buffer TYPE REF TO ltd_buffer.

    SET HANDLER mo_buffer->handle_event_end_load FOR mo_main_buffer.
    lo_buffer ?= mo_buffer.
    lo_buffer->mv_end_load_raised = abap_false.
    mo_main_buffer->/bobf/if_frw_buffer~load(
      EXPORTING
        it_node           = VALUE #( ( node = lif_test_bo=>node-root-key ) )
        iv_state          = /bobf/if_conf_c=>sc_state_current
        iv_fill_data      = abap_true
        io_change         = /bobf/cl_frw_factory=>get_change( )
    ).

    "assert that the event handler of the buffer was executed
    cl_abap_unit_assert=>assert_true( lo_buffer->mv_end_load_raised ).

    "now test that the deregistration works when calling the destroy_instance
    lo_buffer->mv_end_load_raised = abap_false.
    mo_buffer->destroy_instance( ).

    mo_main_buffer->/bobf/if_frw_buffer~load(
      EXPORTING
        it_node           = VALUE #( ( node = lif_test_bo=>node-root-key ) )
        iv_state          = /bobf/if_conf_c=>sc_state_current
        iv_fill_data      = abap_true
        io_change         = /bobf/cl_frw_factory=>get_change( )
    ).

    "assert that the event handler method was not executed
    cl_abap_unit_assert=>assert_false( lo_buffer->mv_end_load_raised ).

  ENDMETHOD.

ENDCLASS.

CLASS ltc_update_disabled_fields DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltc_update_disabled_fields.
CLASS ltc_update_disabled_fields DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.
  PRIVATE SECTION.

    DATA mo_conf TYPE REF TO ltd_configuration.
    DATA mo_buffer TYPE REF TO /bobf/cl_buf_simple.
    METHODS setup RAISING /bobf/cx_frw.
    METHODS apply_update_disabled FOR TESTING.
    METHODS update_with_disabled FOR TESTING RAISING /bobf/cx_frw.

ENDCLASS.

CLASS ltc_update_disabled_fields IMPLEMENTATION.
  METHOD setup.
    CREATE OBJECT mo_conf.
    mo_buffer = lth_setup=>setup_environment( mo_conf ).
  ENDMETHOD.

  METHOD apply_update_disabled.
    DATA ls_buffered     TYPE lif_test_bo=>gty_root_combined.
    DATA ls_changed_data TYPE lif_test_bo=>gty_root_combined.

    ls_buffered = VALUE #(
      key   = 1
      flag  = abap_true
      field = 'before_update' ).

    ls_changed_data = VALUE #(
      key = 1
      flag = abap_undefined
      field = 'after_update' ).


    mo_buffer->apply_update_disabled_fields(
      EXPORTING
        it_property_int  = VALUE #(
                            ( field_name = 'FLAG'
                              component = 4
                              property_name = /bobf/if_conf_c=>sc_property_name_create_enable
                              value = abap_false )
                            ( field_name = 'FIELD'
                              component = 5
                              property_name = /bobf/if_conf_c=>sc_property_name_update_enable
                              value = abap_false ) )
        is_buffered_data = ls_buffered
      CHANGING
        cs_changed_data  = ls_changed_data
    ).

    cl_abap_unit_assert=>assert_equals(
      exp = VALUE lif_test_bo=>gty_root_combined(
              key = 1
              flag = abap_undefined
              field = 'before_update' )
      act = ls_changed_data
    ).

  ENDMETHOD.

  METHOD update_with_disabled.
    "integration test with update disabled field via modify method
    DATA lv_key TYPE x LENGTH 16 VALUE 111111.

**** Prepare
    "- set instance to be updated in buffer
    mo_buffer->mt_buffer = VALUE #(
      ( node = lif_test_bo=>node-root-key
        key = lv_key
        state = /bobf/if_conf_c=>sc_state_last_validated
        data = NEW lif_test_bo=>gty_root_combined(
                 key = lv_key
                 flag = abap_true
                 field = 'before_update' ) ) ).
    "- set meta data for node
    mo_conf->set_nodes(
      it_node = VALUE #(
        ( node_key = lif_test_bo=>node-root-key
          data_type = 'LIF_TEST_BO=>GTY_ROOT_COMBINED'
          internal_properties = NEW #(
              ( field_name = 'FIELD'
                component = 5
                property_name = /bobf/if_conf_c=>sc_property_name_update_enable
                value = abap_false ) ) ) ) ).
**** execute
    mo_buffer->/bobf/if_frw_buffer~modify(
      EXPORTING
        it_modification   = VALUE #(
                              ( change_mode = /bobf/if_frw_c=>sc_modify_update
                                data = NEW lif_test_bo=>gty_root_combined(
                                          key = 2
                                          flag = abap_undefined
                                          field = 'after_update' )
                                key = lv_key
                                node = lif_test_bo=>node-root-key ) )
        iv_state          = /bobf/if_conf_c=>sc_state_last_validated
        iv_only_transient = abap_false
        io_change         = /bobf/cl_frw_factory=>get_change( )
    ).

**** assert
    DATA(ls_buffer) = mo_buffer->mt_buffer[ node = lif_test_bo=>node-root-key  key = lv_key  state = /bobf/if_conf_c=>sc_state_last_validated ].
    cl_abap_unit_assert=>assert_bound( ls_buffer-data ).
    DATA(lr_changed) = CAST lif_test_bo=>gty_root_combined( ls_buffer-data ).
    cl_abap_unit_assert=>assert_equals(
      exp = VALUE lif_test_bo=>gty_root_combined(
              key = lv_key
              flag = abap_undefined
              field = 'before_update' )
      act = lr_changed->*
    ).

  ENDMETHOD.


ENDCLASS.



CLASS ltc_add_comp_spec_notification DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltc_add_comp_spec_notification.
CLASS ltc_add_comp_spec_notification DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.
  PRIVATE SECTION.
    DATA mo_buffer TYPE REF TO /bobf/cl_buf_simple.
    DATA mo_conf TYPE REF TO ltd_configuration.
    METHODS setup RAISING /bobf/cx_frw.
    METHODS prepare_compositions.
    METHODS prepare_specializations.
    METHODS prepare_input_table IMPORTING it_parent_key          TYPE /bobf/t_frw_key
                                RETURNING VALUE(rt_comp_spec_id) TYPE /bobf/if_frw_change=>tt_association_source.
    METHODS add_comp_spec FOR TESTING RAISING /bobf/cx_frw.
ENDCLASS.


CLASS ltc_add_comp_spec_notification IMPLEMENTATION.

  METHOD setup.
    CREATE OBJECT mo_conf.
    mo_buffer = lth_setup=>setup_environment( mo_conf ).
    CLEAR:
      mo_buffer->mt_composition,
      mo_buffer->mt_association.
    prepare_compositions( ).
    prepare_specializations( ).
  ENDMETHOD.


  METHOD prepare_compositions.
    DATA ls_assoc TYPE /bobf/s_confro_assoc.
    DATA ls_assoc2 TYPE /bobf/s_confro_assoc2.
    ls_assoc2-assoc_cat = /bobf/if_conf_c=>sc_assoctype_comp.

    ls_assoc2-assoc_key = lif_test_bo=>association-root-to_item.
    ls_assoc2-source_node_key = lif_test_bo=>node-root-key.
    ls_assoc2-target_node_key = lif_test_bo=>node-item-key.
    INSERT ls_assoc2 INTO TABLE mo_buffer->mt_composition.

    LOOP AT mo_buffer->mt_composition ASSIGNING FIELD-SYMBOL(<ls_assoc2>).
      MOVE-CORRESPONDING ls_assoc2 TO ls_assoc.
      INSERT ls_assoc INTO TABLE mo_buffer->mt_association.
    ENDLOOP.

  ENDMETHOD.


  METHOD prepare_specializations.
    DATA ls_assoc TYPE /bobf/s_confro_assoc.
    ls_assoc-assoc_cat  = /bobf/if_conf_c=>sc_assoccat_specialization.
    ls_assoc-assoc_type = /bobf/if_conf_c=>sc_assoctype_std.

    ls_assoc-source_node_key = lif_test_bo=>node-root-key.
    ls_assoc-target_node_key = lif_test_bo=>node-item-key.

    ls_assoc-assoc_key = lif_test_bo=>association-item_spec1.
    INSERT ls_assoc INTO TABLE mo_buffer->mt_association.

    ls_assoc-assoc_key = lif_test_bo=>association-item_spec2.
    INSERT ls_assoc INTO TABLE mo_buffer->mt_association.

    ls_assoc-assoc_key = lif_test_bo=>association-item_spec3.
    INSERT ls_assoc INTO TABLE mo_buffer->mt_association.

  ENDMETHOD.


  METHOD prepare_input_table.
    DATA ts_comp_spec_id TYPE /bobf/if_frw_change=>ty_association_source.
    ts_comp_spec_id-node_key        = lif_test_bo=>node-item-key.
    ts_comp_spec_id-parent_node_key = lif_test_bo=>node-root-key.

    LOOP AT it_parent_key INTO DATA(ls_parent_key).
      ts_comp_spec_id-parent_key  = ls_parent_key-key.
      ts_comp_spec_id-association_kind = /bobf/if_conf_c=>sc_assoc_kind_composition.
      INSERT ts_comp_spec_id INTO TABLE rt_comp_spec_id.
      ts_comp_spec_id-association_kind = /bobf/if_conf_c=>sc_assoc_kind_specialization.
      INSERT ts_comp_spec_id INTO TABLE rt_comp_spec_id.
    ENDLOOP.
  ENDMETHOD.


  METHOD add_comp_spec.
*    DATA lt_content_chg TYPE /bobf/t_frw_change_content.
*    DATA ls_content_chg TYPE /bobf/s_frw_change_content.
*    DATA ls_root_key TYPE /bobf/s_frw_key.
*    DATA lt_root_key TYPE /bobf/t_frw_key.
*    DATA lv_n_o_roots TYPE i VALUE 2.
*
*    DO lv_n_o_roots TIMES.
*      ls_root_key-key = /bobf/cl_frw_factory=>get_new_transient_key( ).
*      APPEND ls_root_key TO lt_root_key.
*    ENDDO.
*    DATA(lt_comp_spec_id) = prepare_input_table( lt_root_key ).
*    mo_buffer->add_comp_spec_notifications( EXPORTING it_comp_spec_id = lt_comp_spec_id
*                                            CHANGING  ct_content_chg  = lt_content_chg ).
*
*    cl_abap_unit_assert=>assert_equals( act = lines( lt_content_chg ) exp = lv_n_o_roots * 4 ).
*
*    ls_content_chg-change_mode = /bobf/if_frw_c=>sc_modify_association.
*    ls_content_chg-node_key    = lif_test_bo=>node-root-key.
*
*    LOOP AT lt_root_key INTO ls_root_key.
*      ls_content_chg-key = ls_root_key-key.
*
*      ls_content_chg-content_key = lif_test_bo=>association-root-to_item.
*      cl_abap_unit_assert=>assert_table_contains( line  = ls_content_chg table = lt_content_chg ).
*
*      ls_content_chg-content_key = lif_test_bo=>association-item_spec1.
*      cl_abap_unit_assert=>assert_table_contains( line  = ls_content_chg table = lt_content_chg ).
*
*      ls_content_chg-content_key = lif_test_bo=>association-item_spec2.
*      cl_abap_unit_assert=>assert_table_contains( line  = ls_content_chg table = lt_content_chg ).
*
*      ls_content_chg-content_key = lif_test_bo=>association-item_spec3.
*      cl_abap_unit_assert=>assert_table_contains( line  = ls_content_chg table = lt_content_chg ).
*    ENDLOOP.
  ENDMETHOD.

ENDCLASS.












CLASS ltd_buffer_content DEFINITION FOR TESTING FINAL.
  PUBLIC SECTION.
    CONSTANTS:
      gc_state0   TYPE /bobf/conf_state VALUE /bobf/if_conf_c=>sc_state_database,
      gc_state1   TYPE /bobf/conf_state VALUE /bobf/if_conf_c=>sc_state_current,
      gc_rootnode TYPE /bobf/obm_node_key VALUE '100',
      gc_subnode  TYPE /bobf/obm_node_key VALUE '200',
      gc_i0       TYPE i VALUE 0,
      gc_i11      TYPE i VALUE 11,
      gc_i12      TYPE i VALUE 12,
      gc_i13      TYPE i VALUE 13,
      gc_i14      TYPE i VALUE 14,
      gc_i15      TYPE i VALUE 15,
      gc_i16      TYPE i VALUE 16,
      gc_i21      TYPE i VALUE 21,
      gc_parent30 TYPE /bobf/conf_key VALUE '30',
      gc_parent40 TYPE /bobf/conf_key VALUE '40',
      gc_parent50 TYPE /bobf/conf_key VALUE '50',
      gc_parent60 TYPE /bobf/conf_key VALUE '60',
      gc_root1    TYPE /bobf/conf_key VALUE '1',
      gc_root2    TYPE /bobf/conf_key VALUE '2'.

    TYPES:
      BEGIN OF ty_data,
        key          TYPE /bobf/conf_key,
        parent_key   TYPE /bobf/conf_key,
        root_key     TYPE /bobf/conf_key,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
      END OF ty_data.
    CLASS-DATA:
      gs_line1  TYPE /bobf/s_buf_simple_buffer,
      gs_line2  TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line3  TYPE /bobf/s_buf_simple_buffer,
      gs_line4  TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line5  TYPE /bobf/s_buf_simple_buffer,
      gs_line6  TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line7  TYPE /bobf/s_buf_simple_buffer,
      gs_line8  TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line9  TYPE /bobf/s_buf_simple_buffer,
      gs_line10 TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line11 TYPE /bobf/s_buf_simple_buffer,
      gs_line12 TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line13 TYPE /bobf/s_buf_simple_buffer,
      gs_line14 TYPE /bobf/s_buf_simple_buffer ##NEEDED,
      gs_line15 TYPE /bobf/s_buf_simple_buffer,
      gs_line16 TYPE /bobf/s_buf_simple_buffer ##NEEDED.
    CLASS-METHODS:
      class_constructor,
      create_data IMPORTING iv_key         TYPE /bobf/conf_key
                            iv_state       TYPE /bobf/conf_state
                            iv_node        TYPE /bobf/obm_node_key
                            iv_parent_key  TYPE /bobf/conf_key
                            iv_root_key    TYPE /bobf/conf_key
                            iv_int_1       TYPE i
                            iv_int_2       TYPE i
                  RETURNING VALUE(rs_data) TYPE /bobf/s_buf_simple_buffer,
      get_buffer_content RETURNING VALUE(rt_buffer_content) TYPE /bobf/t_buf_simple_buffer.

  PRIVATE SECTION.
    CLASS-DATA:
      gt_buffer_content TYPE /bobf/t_buf_simple_buffer.
ENDCLASS.


CLASS ltd_buffer_content IMPLEMENTATION.

  METHOD class_constructor.

    DATA nokey TYPE /bobf/conf_key. " just an initial key

    " Buffer contents:
    " 2 ROOT nodes (root_key = 1, 2)
    " 3 subnodes per ROOT: root_key = 1 -> altkey_int_1 = 11, 12, 13, altkey_int_2 = 21
    "                      root_key = 2 -> altkey_int_1 = 14, 15, 16, altkey_int_2 = 21
    " Everything for state = 0, 1

    gs_line1  = create_data( iv_key = '1'  iv_node = gc_rootnode  iv_state = gc_state0  iv_parent_key = nokey         iv_root_key = gc_root1  iv_int_1 = gc_i0   iv_int_2 = gc_i0  ) ##LITERAL.
    gs_line2  = create_data( iv_key = '1'  iv_node = gc_rootnode  iv_state = gc_state1  iv_parent_key = nokey         iv_root_key = gc_root1  iv_int_1 = gc_i0   iv_int_2 = gc_i0  ) ##LITERAL.
    gs_line3  = create_data( iv_key = '2'  iv_node = gc_rootnode  iv_state = gc_state0  iv_parent_key = nokey         iv_root_key = gc_root2  iv_int_1 = gc_i0   iv_int_2 = gc_i0  ) ##LITERAL.
    gs_line4  = create_data( iv_key = '2'  iv_node = gc_rootnode  iv_state = gc_state1  iv_parent_key = nokey         iv_root_key = gc_root2  iv_int_1 = gc_i0   iv_int_2 = gc_i0  ) ##LITERAL.

    gs_line5  = create_data( iv_key = '3'  iv_node = gc_subnode   iv_state = gc_state0  iv_parent_key = gc_parent30   iv_root_key = gc_root1  iv_int_1 = gc_i11  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line6  = create_data( iv_key = '3'  iv_node = gc_subnode   iv_state = gc_state1  iv_parent_key = gc_parent30   iv_root_key = gc_root1  iv_int_1 = gc_i11  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line7  = create_data( iv_key = '4'  iv_node = gc_subnode   iv_state = gc_state0  iv_parent_key = gc_parent40   iv_root_key = gc_root1  iv_int_1 = gc_i12  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line8  = create_data( iv_key = '4'  iv_node = gc_subnode   iv_state = gc_state1  iv_parent_key = gc_parent40   iv_root_key = gc_root1  iv_int_1 = gc_i12  iv_int_2 = gc_i21 ) ##LITERAL.

    gs_line9  = create_data( iv_key = '5'  iv_node = gc_subnode   iv_state = gc_state0  iv_parent_key = gc_parent30   iv_root_key = gc_root1  iv_int_1 = gc_i13  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line10 = create_data( iv_key = '5'  iv_node = gc_subnode   iv_state = gc_state1  iv_parent_key = gc_parent30   iv_root_key = gc_root1  iv_int_1 = gc_i13  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line11 = create_data( iv_key = '6'  iv_node = gc_subnode   iv_state = gc_state0  iv_parent_key = gc_parent50   iv_root_key = gc_root2  iv_int_1 = gc_i14  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line12 = create_data( iv_key = '6'  iv_node = gc_subnode   iv_state = gc_state1  iv_parent_key = gc_parent50   iv_root_key = gc_root2  iv_int_1 = gc_i14  iv_int_2 = gc_i21 ) ##LITERAL.

    gs_line13 = create_data( iv_key = '7'  iv_node = gc_subnode   iv_state = gc_state0  iv_parent_key = gc_parent60   iv_root_key = gc_root2  iv_int_1 = gc_i15  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line14 = create_data( iv_key = '7'  iv_node = gc_subnode   iv_state = gc_state1  iv_parent_key = gc_parent60   iv_root_key = gc_root2  iv_int_1 = gc_i15  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line15 = create_data( iv_key = '8'  iv_node = gc_subnode   iv_state = gc_state0  iv_parent_key = gc_parent50   iv_root_key = gc_root2  iv_int_1 = gc_i16  iv_int_2 = gc_i21 ) ##LITERAL.
    gs_line16 = create_data( iv_key = '8'  iv_node = gc_subnode   iv_state = gc_state1  iv_parent_key = gc_parent50   iv_root_key = gc_root2  iv_int_1 = gc_i16  iv_int_2 = gc_i21 ) ##LITERAL.

  ENDMETHOD.


  METHOD create_data.

    rs_data = VALUE #( key        = iv_key
                       node       = iv_node
                       state      = iv_state
                       parent_key = iv_parent_key
                       root_key   = iv_root_key
                       data       = NEW ty_data( key          = iv_key
                                                 parent_key   = iv_parent_key
                                                 root_key     = iv_root_key
                                                 altkey_int_1 = iv_int_1
                                                 altkey_int_2 = iv_int_2 ) ).
    INSERT rs_data INTO TABLE gt_buffer_content.

  ENDMETHOD.


  METHOD get_buffer_content.
    rt_buffer_content = gt_buffer_content.
  ENDMETHOD.

ENDCLASS.










CLASS ltca_filter_buffer_parent_root DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltca_filter_buffer_parent_root.
CLASS ltca_filter_buffer_parent_root DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT ABSTRACT.
  PUBLIC SECTION.
    CONSTANTS:
      BEGIN OF sc_altkey_fieldname,
        altkey_int_1 TYPE string VALUE 'ALTKEY_INT_1',
        altkey_int_2 TYPE string VALUE 'ALTKEY_INT_2',
      END OF sc_altkey_fieldname.
  PROTECTED SECTION.
    CLASS-DATA:
      gs_altkey_conf TYPE /bobf/s_confro_altkey.
    DATA:
      mo_cut                 TYPE REF TO /bobf/cl_buf_simple,
      mt_buffer              TYPE /bobf/t_buf_simple_buffer,
      mt_buffer_filtered_act TYPE /bobf/t_buf_simple_buffer,
      mv_use_filtered_table  TYPE abap_bool.
    METHODS:
      test_filtering ABSTRACT FOR TESTING RAISING cx_static_check,
      do_filtering IMPORTING it_altkey_data TYPE INDEX TABLE,
      assert_filtered_buffer_data IMPORTING it_buffer_filtered_exp TYPE /bobf/t_buf_simple_buffer.
  PRIVATE SECTION.
    CLASS-METHODS:
      class_setup.
    METHODS:
      setup RAISING /bobf/cx_frw.
ENDCLASS.


CLASS ltca_filter_buffer_parent_root IMPLEMENTATION.

  METHOD class_setup.
    gs_altkey_conf-field_names = NEW #( ).
  ENDMETHOD.

  METHOD setup.

    mo_cut = lth_setup=>setup_environment( io_conf = NEW ltd_configuration( ) ).
    CLEAR:
      mt_buffer,
      mv_use_filtered_table.

    mt_buffer = ltd_buffer_content=>get_buffer_content( ).

  ENDMETHOD.


  METHOD do_filtering.

    " Determine, if parent_key and/or root_key are contained in altkey
    cl_abap_unit_assert=>assert_bound( gs_altkey_conf-field_names ).
    ASSIGN gs_altkey_conf-field_names->* TO FIELD-SYMBOL(<lt_altkey_field_name>).
    cl_abap_unit_assert=>assert_subrc( 0 ).
    READ TABLE <lt_altkey_field_name> WITH KEY table_line = /bobf/if_conf_c=>sc_attribute_name_parent_key TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      DATA(lv_parent_in_altkey) = abap_true.
    ENDIF.
    READ TABLE <lt_altkey_field_name> WITH KEY table_line = /bobf/if_conf_c=>sc_attribute_name_root_key TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      DATA(lv_root_in_altkey) = abap_true.
    ENDIF.


    mo_cut->filter_buffer_parent_root_key( EXPORTING it_buffer               = mt_buffer
                                                     iv_parent_in_altkey     = lv_parent_in_altkey
                                                     iv_root_in_altkey       = lv_root_in_altkey
                                                     iv_altkey_is_structured = gs_altkey_conf-altkey_is_structured
                                                     it_altkey_value         = it_altkey_data
                                                     iv_node_key             = ltd_buffer_content=>gc_subnode
                                                     iv_state                = ltd_buffer_content=>gc_state0
                                           IMPORTING et_buffer_filtered      = mt_buffer_filtered_act ).
  ENDMETHOD.


  METHOD assert_filtered_buffer_data.

    cl_abap_unit_assert=>assert_equals( act = lines( mt_buffer_filtered_act )  exp = lines( it_buffer_filtered_exp )  quit = if_aunit_constants=>no ).
    LOOP AT it_buffer_filtered_exp ASSIGNING FIELD-SYMBOL(<ls_buffer_data_exp>).
      READ TABLE mt_buffer_filtered_act WITH KEY table_line = <ls_buffer_data_exp> TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0  quit = if_aunit_constants=>no ).
    ENDLOOP.

  ENDMETHOD.

ENDCLASS.








CLASS ltc_filter_nokey_unstruct DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      altkey_int_1             TYPE i,
      tt_altkey_nokey_unstruct TYPE STANDARD TABLE OF altkey_int_1 WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_nokey_unstruct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which contains neither parent_key nor root_key
    gs_altkey_conf-altkey_is_structured = abap_false.
    INSERT sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with unstructured altkey which contains neither parent_key nor root_key
    do_filtering( it_altkey_data = VALUE tt_altkey_nokey_unstruct( ( ltd_buffer_content=>gc_i11 )
                                                                   ( ltd_buffer_content=>gc_i12 )
                                                                   ( ltd_buffer_content=>gc_i13 )
                                                                   ( ltd_buffer_content=>gc_i14 )
                                                                   ( ltd_buffer_content=>gc_i15 )
                                                                   ( ltd_buffer_content=>gc_i16 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ) ).

  ENDMETHOD.

ENDCLASS.












CLASS ltc_filter_nokey_struct DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_nokey_struct,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
      END OF ty_altkey_nokey_struct,
      tt_altkey_nokey_struct TYPE STANDARD TABLE OF ty_altkey_nokey_struct WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_nokey_struct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of structured altkey which contains neither parent_key nor root_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with structured altkey which contains neither parent_key nor root_key
    do_filtering( it_altkey_data = VALUE tt_altkey_nokey_struct( ( altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                 ( altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                 ( altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                 ( altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                 ( altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                 ( altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ) ).

  ENDMETHOD.

ENDCLASS.













CLASS ltc_filter_parent_unstruct DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      parent_key                TYPE /bobf/conf_key,
      tt_altkey_parent_unstruct TYPE STANDARD TABLE OF parent_key WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_parent_unstruct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which consists of parent_key
    gs_altkey_conf-altkey_is_structured = abap_false.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with unstructured altkey which consists of parent_key
    do_filtering( it_altkey_data = VALUE tt_altkey_parent_unstruct( ( ltd_buffer_content=>gc_parent30 )
                                                                    ( ltd_buffer_content=>gc_parent40 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ( ltd_buffer_content=>gs_line5  )
                                                                   ( ltd_buffer_content=>gs_line7  )
                                                                   ( ltd_buffer_content=>gs_line9  ) ) ).

  ENDMETHOD.

ENDCLASS.








CLASS ltc_filter_parent_struct DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_parent_struct,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
        parent_key   TYPE /bobf/conf_key,
      END OF ty_altkey_parent_struct,
      tt_altkey_parent_struct TYPE STANDARD TABLE OF ty_altkey_parent_struct WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_parent_struct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of structured altkey which contains parent_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with structured altkey which contains parent_key
    do_filtering( it_altkey_data = VALUE tt_altkey_parent_struct( ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                  ( parent_key = ltd_buffer_content=>gc_parent40  altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                  ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                  ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                  ( parent_key = ltd_buffer_content=>gc_parent40  altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                  ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ( ltd_buffer_content=>gs_line5  )
                                                                   ( ltd_buffer_content=>gs_line7  )
                                                                   ( ltd_buffer_content=>gs_line9  ) ) ).

  ENDMETHOD.

ENDCLASS.
















CLASS ltc_filter_root_unstruct DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      root_key                TYPE /bobf/conf_key,
      tt_altkey_root_unstruct TYPE STANDARD TABLE OF root_key WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_root_unstruct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which consists of root_key
    gs_altkey_conf-altkey_is_structured = abap_false.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with unstructured altkey which consists of root_key
    do_filtering( it_altkey_data = VALUE tt_altkey_root_unstruct( ( ltd_buffer_content=>gc_root1 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ( ltd_buffer_content=>gs_line5  )
                                                                   ( ltd_buffer_content=>gs_line7  )
                                                                   ( ltd_buffer_content=>gs_line9  ) ) ).

  ENDMETHOD.

ENDCLASS.



















CLASS ltc_filter_root_struct DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_root_struct,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
        root_key     TYPE /bobf/conf_key,
      END OF ty_altkey_root_struct,
      tt_altkey_root_struct TYPE STANDARD TABLE OF ty_altkey_root_struct WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_root_struct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of structured altkey which contains root_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with structured altkey which contains root_key
    do_filtering( it_altkey_data = VALUE tt_altkey_root_struct( ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ( ltd_buffer_content=>gs_line5  )
                                                                   ( ltd_buffer_content=>gs_line7  )
                                                                   ( ltd_buffer_content=>gs_line9  ) ) ).

  ENDMETHOD.

ENDCLASS.













CLASS ltc_filter_parent_root DEFINITION INHERITING FROM ltca_filter_buffer_parent_root
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_filtering REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_parent_root,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
        parent_key   TYPE /bobf/conf_key,
        root_key     TYPE /bobf/conf_key,
      END OF ty_altkey_parent_root,
      tt_altkey_parent_root TYPE STANDARD TABLE OF ty_altkey_parent_root WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_filter_parent_root IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of altkey which contains parent_key and root_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_filtering.

    " Preparation of buffer content was done in SETUP

    " Execute FILTER_BUFFER_PARENT_ROOT_KEY with altkey which contains parent_key and root_key
    do_filtering( it_altkey_data = VALUE tt_altkey_parent_root(
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent40  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent40  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_filtered_buffer_data( it_buffer_filtered_exp = VALUE #( ( ltd_buffer_content=>gs_line5  )
                                                                   ( ltd_buffer_content=>gs_line7  )
                                                                   ( ltd_buffer_content=>gs_line9  ) ) ).

  ENDMETHOD.

ENDCLASS.


















CLASS ltca_conv_altkey_from_buffer DEFINITION DEFERRED.
CLASS /bobf/cl_buf_simple DEFINITION LOCAL FRIENDS ltca_conv_altkey_from_buffer.
CLASS ltca_conv_altkey_from_buffer DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT ABSTRACT.
  PUBLIC SECTION.
    CONSTANTS:
      gc_altkey_key TYPE /bobf/obm_altkey_key VALUE '12345'.
  PROTECTED SECTION.
    CLASS-DATA:
      gs_altkey_conf TYPE /bobf/s_confro_altkey.
    DATA:
      mo_cut         TYPE REF TO /bobf/cl_buf_simple,
      mo_conf_double TYPE REF TO /bobf/if_frw_configuration,
      mt_result_act  TYPE /bobf/t_frw_keyindex.
    METHODS:
      test_conversion ABSTRACT FOR TESTING RAISING cx_static_check,
      do_convert_altkey IMPORTING it_altkey_data TYPE INDEX TABLE
                        RAISING   /bobf/cx_frw,
      assert_conversion_result IMPORTING it_result_exp TYPE /bobf/t_frw_keyindex.
  PRIVATE SECTION.
    CLASS-METHODS:
      class_setup.
    METHODS:
      setup RAISING /bobf/cx_frw.
ENDCLASS.


CLASS ltca_conv_altkey_from_buffer IMPLEMENTATION.

  METHOD class_setup.
    gs_altkey_conf-field_names = NEW #( ).
  ENDMETHOD.


  METHOD setup.

    CLEAR:
      mt_result_act.

    " Instantiate test instance
    mo_cut = lth_setup=>setup_environment( io_conf = NEW ltd_configuration( ) ).

    " Inject buffer data
    mo_cut->mt_buffer = ltd_buffer_content=>get_buffer_content( ).

  ENDMETHOD.


  METHOD do_convert_altkey.

    DATA:
      lo_altkey_table_descr TYPE REF TO cl_abap_tabledescr.

    " Get data type of altkey
    lo_altkey_table_descr ?= cl_abap_typedescr=>describe_by_data_ref( REF #( it_altkey_data ) ).
    DATA(lo_altkey_descr) = lo_altkey_table_descr->get_table_line_type( ).
    gs_altkey_conf-data_type = lo_altkey_descr->absolute_name.

    " Prepare mo_conf test double
    mo_conf_double ?= cl_abap_testdouble=>create( '/BOBF/IF_FRW_CONFIGURATION' ).
    cl_abap_testdouble=>configure_call( mo_conf_double
      )->set_parameter( name = 'ES_ALTKEY'  value = gs_altkey_conf ).
    mo_conf_double->get_altkey( iv_altkey_key = gc_altkey_key ).

    " Inject mo_conf test double
    mo_cut->mo_conf = mo_conf_double.

    mo_cut->convert_alt_key_from_buffer( EXPORTING iv_node_key         = ltd_buffer_content=>gc_subnode
                                                   iv_altkey_key       = gc_altkey_key
                                                   it_key              = it_altkey_data
                                                   iv_state            = ltd_buffer_content=>gc_state0
                                                   iv_invalidate_cache = abap_false
                                         IMPORTING et_result           = mt_result_act ).

  ENDMETHOD.


  METHOD assert_conversion_result.
    cl_abap_unit_assert=>assert_equals( act = lines( mt_result_act )  exp = lines( it_result_exp )  quit = if_aunit_constants=>no ).
    LOOP AT it_result_exp ASSIGNING FIELD-SYMBOL(<ls_key_index>).
      READ TABLE mt_result_act WITH KEY index_and_key COMPONENTS index = <ls_key_index>-index
                                                                 key   = <ls_key_index>-key  TRANSPORTING NO FIELDS.
      cl_abap_unit_assert=>assert_subrc( exp = 0  quit = if_aunit_constants=>no ).
    ENDLOOP.
  ENDMETHOD.

ENDCLASS.













CLASS ltc_convert_nokey_unstruct DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      altkey_int_1             TYPE i,
      tt_altkey_nokey_unstruct TYPE STANDARD TABLE OF altkey_int_1 WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_nokey_unstruct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which contains neither parent_key nor root_key
    gs_altkey_conf-altkey_is_structured = abap_false.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    gs_altkey_conf-altkey_name = ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_1.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with unstructured altkey which contains neither parent_key nor root_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_nokey_unstruct( ( ltd_buffer_content=>gc_i11 )
                                                                        ( ltd_buffer_content=>gc_i12 )
                                                                        ( ltd_buffer_content=>gc_i13 )
                                                                        ( ltd_buffer_content=>gc_i14 )
                                                                        ( ltd_buffer_content=>gc_i15 )
                                                                        ( ltd_buffer_content=>gc_i16 ) ) ).

    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 2  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 3  key = ltd_buffer_content=>gs_line9-key  )
                                                       ( index = 4  key = ltd_buffer_content=>gs_line11-key )
                                                       ( index = 5  key = ltd_buffer_content=>gs_line13-key )
                                                       ( index = 6  key = ltd_buffer_content=>gs_line15-key ) ) ).

  ENDMETHOD.

ENDCLASS.













CLASS ltc_convert_nokey_struct DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_nokey_struct,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
      END OF ty_altkey_nokey_struct,
      tt_altkey_nokey_struct TYPE STANDARD TABLE OF ty_altkey_nokey_struct WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_nokey_struct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of structured altkey which contains neither parent_key nor root_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with structured altkey which contains neither parent_key nor root_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_nokey_struct( ( altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                      ( altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                      ( altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                      ( altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                      ( altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
                                                                      ( altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 2  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 3  key = ltd_buffer_content=>gs_line9-key  )
                                                       ( index = 4  key = ltd_buffer_content=>gs_line11-key )
                                                       ( index = 5  key = ltd_buffer_content=>gs_line13-key )
                                                       ( index = 6  key = ltd_buffer_content=>gs_line15-key ) ) ).

  ENDMETHOD.

ENDCLASS.











CLASS ltc_convert_parent_unstruct DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      parent_key                TYPE /bobf/conf_key,
      tt_altkey_parent_unstruct TYPE STANDARD TABLE OF parent_key WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_parent_unstruct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which consists of parent_key
    gs_altkey_conf-altkey_is_structured = abap_false.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) INTO TABLE gs_altkey_conf-field_names->*.
    gs_altkey_conf-altkey_name = /bobf/if_conf_c=>sc_attribute_name_parent_key.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with structured altkey which consists of parent_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_parent_unstruct( ( ltd_buffer_content=>gc_parent30 )
                                                                         ( ltd_buffer_content=>gc_parent40 ) ) ).
    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 2  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 1  key = ltd_buffer_content=>gs_line9-key  ) ) ).

  ENDMETHOD.

ENDCLASS.











CLASS ltc_convert_parent_struct DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_parent_struct,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
        parent_key   TYPE /bobf/conf_key,
      END OF ty_altkey_parent_struct,
      tt_altkey_parent_struct TYPE STANDARD TABLE OF ty_altkey_parent_struct WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_parent_struct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of structured altkey which contains parent_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with structured altkey which contains parent_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_parent_struct(
      ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent40  altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent40  altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 2  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 3  key = ltd_buffer_content=>gs_line9-key  ) ) ).

  ENDMETHOD.

ENDCLASS.















CLASS ltc_convert_root_unstruct DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      root_key                TYPE /bobf/conf_key,
      tt_altkey_root_unstruct TYPE STANDARD TABLE OF root_key WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_root_unstruct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which consists of root_key
    gs_altkey_conf-altkey_is_structured = abap_false.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) INTO TABLE gs_altkey_conf-field_names->*.
    gs_altkey_conf-altkey_name = /bobf/if_conf_c=>sc_attribute_name_root_key.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with structured altkey which consists of root_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_root_unstruct( ( ltd_buffer_content=>gc_root1 ) ) ).

    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 1  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 1  key = ltd_buffer_content=>gs_line9-key  ) ) ).

  ENDMETHOD.

ENDCLASS.

















CLASS ltc_convert_root_struct DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_root_struct,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
        root_key     TYPE /bobf/conf_key,
      END OF ty_altkey_root_struct,
      tt_altkey_root_struct TYPE STANDARD TABLE OF ty_altkey_root_struct WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_root_struct IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which contains root_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with structured altkey which contains root_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_root_struct(
      ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 2  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 3  key = ltd_buffer_content=>gs_line9-key  ) ) ).

  ENDMETHOD.

ENDCLASS.














CLASS ltc_convert_parent_root DEFINITION INHERITING FROM ltca_conv_altkey_from_buffer
FOR TESTING RISK LEVEL HARMLESS DURATION SHORT FINAL.
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS test_conversion REDEFINITION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_altkey_parent_root,
        altkey_int_1 TYPE i,
        altkey_int_2 TYPE i,
        parent_key   TYPE /bobf/conf_key,
        root_key     TYPE /bobf/conf_key,
      END OF ty_altkey_parent_root,
      tt_altkey_parent_root TYPE STANDARD TABLE OF ty_altkey_parent_root WITH EMPTY KEY.
    CLASS-METHODS class_setup.
ENDCLASS.


CLASS ltc_convert_parent_root IMPLEMENTATION.

  METHOD class_setup.
    " Prepare metadata of unstructured altkey which contains parent_key and root_key
    gs_altkey_conf-altkey_is_structured = abap_true.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_parent_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT CONV #( /bobf/if_conf_c=>sc_attribute_name_root_key ) INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_1 INTO TABLE gs_altkey_conf-field_names->*.
    INSERT ltca_filter_buffer_parent_root=>sc_altkey_fieldname-altkey_int_2 INTO TABLE gs_altkey_conf-field_names->*.
  ENDMETHOD.


  METHOD test_conversion.

    " Preparation of buffer content was done in SETUP

    " Execute CONVERT_ALT_KEY_FROM_BUFFER with structured altkey which contains parent_key and root_key
    do_convert_altkey( it_altkey_data = VALUE tt_altkey_parent_root(
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i11  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent40  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i12  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i13  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i14  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent40  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i15  altkey_int_2 = ltd_buffer_content=>gc_i21 )
      ( parent_key = ltd_buffer_content=>gc_parent30  root_key = ltd_buffer_content=>gc_root1  altkey_int_1 = ltd_buffer_content=>gc_i16  altkey_int_2 = ltd_buffer_content=>gc_i21 ) ) ).

    " Verify result
    assert_conversion_result( it_result_exp = VALUE #( ( index = 1  key = ltd_buffer_content=>gs_line5-key  )
                                                       ( index = 2  key = ltd_buffer_content=>gs_line7-key  )
                                                       ( index = 3  key = ltd_buffer_content=>gs_line9-key  ) ) ).

  ENDMETHOD.

ENDCLASS.
