class /BOBF/CL_CONF_READONLY definition
  public
  final
  create public
  shared memory enabled .

public section.
  type-pools ABAP .

  interfaces /BOBF/IF_CONFRT_COMPLETE .

  aliases MS_OBJ
    for /BOBF/IF_CONFRT_COMPLETE~MS_OBJ .
  aliases MT_ACT
    for /BOBF/IF_CONFRT_COMPLETE~MT_ACT .
  aliases MT_ALTKEY
    for /BOBF/IF_CONFRT_COMPLETE~MT_ALTKEY .
  aliases MT_ASSOC
    for /BOBF/IF_CONFRT_COMPLETE~MT_ASSOC .
  aliases MT_ASSOC_CHANGE
    for /BOBF/IF_CONFRT_COMPLETE~MT_ASSOC_CHANGE .
  aliases MT_COMP
    for /BOBF/IF_CONFRT_COMPLETE~MT_COMP .
  aliases MT_CONTENT_KEY_MAP
    for /BOBF/IF_CONFRT_COMPLETE~MT_CONTENT_KEY_MAP .
  aliases MT_EXECTIME
    for /BOBF/IF_CONFRT_COMPLETE~MT_EXECTIME .
  aliases MT_FIELDMAPPING
    for /BOBF/IF_CONFRT_COMPLETE~MT_FIELDMAPPING .
  aliases MT_GROUP
    for /BOBF/IF_CONFRT_COMPLETE~MT_GROUP .
  aliases MT_GROUPC
    for /BOBF/IF_CONFRT_COMPLETE~MT_GROUPC .
  aliases MT_NODE
    for /BOBF/IF_CONFRT_COMPLETE~MT_NODE .
  aliases MT_PROPERTY
    for /BOBF/IF_CONFRT_COMPLETE~MT_PROPERTY .
  aliases MT_PROPERTY_CHANGE
    for /BOBF/IF_CONFRT_COMPLETE~MT_PROPERTY_CHANGE .
  aliases MT_PROPERTY_PRX
    for /BOBF/IF_CONFRT_COMPLETE~MT_PROPERTY_PRX .
  aliases MT_QUERY
    for /BOBF/IF_CONFRT_COMPLETE~MT_QUERY .
  aliases MT_STA_ASSOC
    for /BOBF/IF_CONFRT_COMPLETE~MT_STA_ASSOC .
  aliases MT_STA_DERIV
    for /BOBF/IF_CONFRT_COMPLETE~MT_STA_DERIV .
  aliases MT_STA_VAR
    for /BOBF/IF_CONFRT_COMPLETE~MT_STA_VAR .
  aliases MT_VALIDATION
    for /BOBF/IF_CONFRT_COMPLETE~MT_VALIDATION .
  aliases MT_VSET
    for /BOBF/IF_CONFRT_COMPLETE~MT_VSET .

  data MV_BUILD_TIMESTAMP type TIMESTAMPL read-only .
  "!LAST_CHANGE_TIME from /BOBF/OBM_OBJ and all referenced DOs: Date on which the BO-settings Were Changed Last
  data MV_LAST_CHANGE_TIME type TIMESTAMPL read-only .
  data MT_COLLECTED_BOS type /BOBF/CL_FRW_FACTORY=>TT_BO_NAME .

  class-methods ADAPT_REF_BO_KEY
    changing
      !CV_BO_KEY type /BOBF/OBM_BO_KEY .
  class-methods is_loadable_bo
    IMPORTING iv_bo_key type /bobf/obm_bo_key RETURNING VALUE(ro_exc) type ref to /bobf/cx_conf.

  methods CONSTRUCTOR
    importing
      !IV_BO_KEY type /BOBF/CONF_KEY
    raising
      /BOBF/CX_FRW .
  methods CHECK_CONSISTENCY
    returning
      value(RV_CONSISTENT) type BOOLE_D .
  methods INITIALIZE_FROM_DB
    importing
      !IS_OBM_OBJ type /BOBF/OBM_OBJ optional
    preferred parameter IS_OBM_OBJ
    raising
      /BOBF/CX_FRW .
  methods INITIALIZE_FROM_SHARED
    importing
      !IO_SHARED_INSTANCE type ref to /BOBF/CL_CONF_READONLY
      !IS_CONTEXT type /BOBF/S_FRW_CONTEXT optional
    raising
      /BOBF/CX_FRW .
protected section.
*"* protected components of class /BOBF/CL_CONF_READONLY
*"* do not include other source files here!!!

  types:
    BEGIN OF ts_bo ,
     bo_key        TYPE /bobf/obm_bo_key,
     bo_name       TYPE /bobf/obm_name,
     bo_proxy_name TYPE /bobf/obm_esr_name,
     test          TYPE boole_d,
   END OF ts_bo .
  types:
    tt_bo TYPE HASHED TABLE OF ts_bo WITH UNIQUE KEY bo_key
               WITH NON-UNIQUE SORTED KEY proxy_name    COMPONENTS bo_proxy_name test
               WITH UNIQUE     SORTED KEY internal_name COMPONENTS bo_name .
  types:
    tt_ext_incl TYPE STANDARD TABLE OF REF TO data .

  data MV_BO_KEY type /BOBF/OBM_BO_KEY .
private section.

  types:
    BEGIN OF ts_referenced_do,
      do_key          type /bobf/conf_key,
      do_name         type /bobf/obm_name,
      build_timestamp type timestampl,
    END OF ts_referenced_do .
  types:
    tt_referenced_do TYPE STANDARD TABLE OF ts_referenced_do .
  types:
    tt_sortednet                   TYPE SORTED TABLE OF /bobf/det_net
                                      WITH NON-UNIQUE KEY det_key_to
                                      WITH NON-UNIQUE SORTED KEY key2 COMPONENTS det_key_from .
  types:
    BEGIN OF ts_models,
      bo_name                      TYPE /bobf/obm_name,
      super_bo_name                TYPE /bobf/obm_name,
      extension                    TYPE boole_d,
      det_list                     TYPE /bobf/t_confro_det_list,
      det_net                      TYPE tt_sortednet,
    END OF ts_models .
  types:
    tt_models TYPE STANDARD TABLE OF ts_models .
  types:
    begin of TY_PLUGIN,
    name type /bobf/obm_name,
    class type seoclsname,
    object type ref to /BOBF/IF_CONF_LOAD_PLUGIN,
  end of ty_plugin .
  types:
    tt_plugin type STANDARD TABLE OF ty_plugin with NON-UNIQUE key table_line .

  data MT_EXT_INCL type TT_EXT_INCL .
  constants GC_GENIL_SEPARATOR type CHAR1 value '_' ##NO_TEXT.
  data MT_REFERENCED_DO type TT_REFERENCED_DO .

  class-methods BUILD_NODE_INTERNAL_PROPS
    importing
      !IV_OBJCAT type /BOBF/S_CONFRO_OBJ-OBJCAT
      !IT_FIELD_DESCR type DDX031LTAB
      !IO_AREA_HANDLE type ref to CL_ABAP_MEMORY_AREA
    returning
      value(RR_INTERNAL_PROPERTY) type ref to /BOBF/T_CONFRO_PROP_INT .
  methods BUILD_ACTION
    importing
      !IT_RTW type TT_RTW
      !IT_ACT_CONF type TT_ACTCONF
    raising
      /BOBF/CX_FRW .
  methods BUILD_ALTKEY
    raising
      /BOBF/CX_FRW .
  methods BUILD_ASSOCIATION
    importing
      !IT_ASSOCC type /BOBF/T_CONFRO_ASSOCC
      !IT_ASSOCB type TT_ASSOCB
      !IT_DETCONF type TT_DETCONF
      !IT_RTW type TT_RTW
    raising
      /BOBF/CX_FRW .
  methods BUILD_ASSOCIATION_CHANGE .
  methods BUILD_DETERMINATION
    importing
      !IT_RTW type TT_RTW
      !IT_RTW_A type TT_RTW_A
      !IT_DETCONF type TT_DETCONF
      !IT_DETNET type TT_DETNET
      !IT_DET type TT_DET
    changing
      !CT_MODELS type TT_MODELS
    raising
      /BOBF/CX_CONF .
  methods BUILD_FIELDMAPPING
    importing
      !IS_FIELDMAPPING type ref to /BOBF/S_CONFRO_MAPPING optional
      !IT_FIELDMAPPING type TT_MAP optional
    preferred parameter IS_FIELDMAPPING .
  methods BUILD_NODE
    importing
      !IT_NODE type TT_NODE
      !IT_NODE_CAT type TT_NODECAT
      !IT_STA_SCHEMA type TT_STA_SCHEMA
      !IT_AUTH_OBJ type TT_AUTH_OBJ
      !IT_ACF_MAP type TT_ACF_MAP
      !IT_DET type TT_DET
      !IT_VAL type TT_VAL
      !IT_RTW_A_TRIGGER type TT_RTW_A
    changing
      !CT_RTW type TT_RTW .
  methods BUILD_PROPERTY
    importing
      !IT_PROPERTY type TT_PROPERTY
      !IT_PROPERTY_PRX type TT_PROPERTY_PRX
      !IT_ACT_CONF type TT_ACTCONF
      !IT_ASSOC_CONF type /BOBF/T_CONFRO_ASSOCC .
  methods BUILD_PROPERTY_CHANGE
    importing
      !IT_RTW type TT_RTW .
  methods BUILD_QUERY .
  methods BUILD_STATUS_VARIABLE .
  methods BUILD_VALIDATION
    importing
      !IT_RTW type TT_RTW
      !IT_VALCONF type TT_VALCONF
      !IT_GROUP type TT_GROUP
      !IT_VALNET type TT_VALNET
    changing
      !CT_VAL type TT_VAL
    raising
      /BOBF/CX_CONF .
  methods BUILD_VALUE_SET
    importing
      !IT_VSET type TT_VAL_SET
      !IT_CODE_LIST type TT_CODE_LIST .
  methods CREATE_EXT_INCL .
  methods FILTER_INACTIVE_GROUPS
    importing
      !IT_INACTIVE_GROUPS type /BOBF/T_CONFRO_GROUP .
  methods FLUSH_TABLE_KEYS .
  methods DETERMINE_NODE_AUTH_NODE_KEY
    importing
      !IS_NODE type /BOBF/S_CONFRO_NODE
    exporting
      !EV_AUTH_NODE_KEY type /BOBF/OBM_NODE_KEY .
  methods DETERMINE_NODE_HAS_AUTH_CHECKS
    importing
      !IS_NODE type /BOBF/S_CONFRO_NODE
    returning
      value(RV_HAS_AUTH_CHECKS) type ABAP_BOOL .
  methods GET_SUBNODE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
    exporting
      !ET_SUBNODE_KEY type /BOBF/T_FRW_KEY2 .
  methods MERGE_DELEGATED_MODEL
    raising
      /BOBF/CX_FRW .
  methods MERGE_DELEGATED_MODEL_OLD
    importing
      !IT_ACTION type /BOBF/T_CONFDO_ACTION
      !IT_ALTKEY type /BOBF/T_CONFDO_ALTKEY
      !IT_ASSOCIATION type /BOBF/T_CONFDO_ASSOC
      !IT_NODE type /BOBF/T_CONFDO_NODE
      !IT_QUERY type /BOBF/T_CONFDO_QUERY
      !IT_VSET type /BOBF/T_CONFDO_VALUE_SET
      !IS_HOST_NODE type ref to /BOBF/S_CONFRO_NODE .
  methods SET_LOCKLOAD_SUBNODE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY .
  methods BUILD_AUTHORIZATION
    importing
      !IV_HEADER_AUTH_CHECK_RELEVANT type ABAP_BOOL .
  methods BUILD_NODE_DET_TRIGGER_ATTR
    importing
      !IS_NODE_CONF type /BOBF/S_CONFRO_NODE
      !IT_DET type TT_DET
      !IT_RTW type TT_RTW
      !IT_RTW_A_TRIGGER type TT_RTW_A
    exporting
      !EV_TRIGGER_ATTR_CREATE_ALL type BOOLE_D
      !EV_TRIGGER_ATTR_UPDATE_ALL type BOOLE_D
      !EV_TRIGGER_ATTR_DELETE_ALL type BOOLE_D
      !ET_TRIGGER_ATTR_CREATE type /BOBF/T_FRW_NAME
      !ET_TRIGGER_ATTR_UPDATE type /BOBF/T_FRW_NAME
      !ET_TRIGGER_ATTR_DELETE type /BOBF/T_FRW_NAME .
  methods BUILD_NODE_VAL_TRIGGER_ATTR
    importing
      !IS_NODE_CONF type /BOBF/S_CONFRO_NODE
      !IT_VAL type TT_VAL
      !IT_RTW type TT_RTW
      !IT_RTW_A_TRIGGER type TT_RTW_A
    exporting
      !EV_TRIGGER_ATTR_CREATE_ALL type BOOLE_D
      !EV_TRIGGER_ATTR_UPDATE_ALL type BOOLE_D
      !EV_TRIGGER_ATTR_DELETE_ALL type BOOLE_D
      !ET_TRIGGER_ATTR_CREATE type /BOBF/T_FRW_NAME
      !ET_TRIGGER_ATTR_UPDATE type /BOBF/T_FRW_NAME
      !ET_TRIGGER_ATTR_DELETE type /BOBF/T_FRW_NAME .
  methods INITIALIZE_LOAD_PLUGINS
    returning
      value(RT_PLUGIN) type TT_PLUGIN .
ENDCLASS.



CLASS /BOBF/CL_CONF_READONLY IMPLEMENTATION.


  METHOD adapt_ref_bo_key.

    "Purpose: Replace the reference BO key by the core BO key, in case it is an enhancement BO

    DATA lv_super_bo_key  TYPE /bobf/obm_bo_key.

    CHECK cv_bo_key IS NOT INITIAL.

    DO.
      SELECT SINGLE super_bo_key INTO lv_super_bo_key
        FROM /bobf/obm_bo
        WHERE bo_key     = cv_bo_key
          AND extension  = abap_true
          AND bo_deleted = abap_false.     "#EC CI_NOORDER

      IF sy-subrc <> 0 OR lv_super_bo_key IS INITIAL.
        EXIT.
      ENDIF.

      "prepare next iteration and returing parameter
      cv_bo_key = lv_super_bo_key.
    ENDDO.

  ENDMETHOD.


METHOD build_action.

  DATA: ls_actread         TYPE /bobf/s_confro_read,
        ls_actwrite        TYPE /bobf/s_confro_act_write,
        ls_rtw             TYPE /bobf/obm_rtw,
        lt_acts_to_process TYPE /bobf/t_frw_key2,
        lt_processed_acts  TYPE SORTED TABLE OF /bobf/conf_key WITH UNIQUE KEY table_line,
        ls_act             TYPE /bobf/s_confro_act_list,
        ls_act_temp        TYPE /bobf/s_confro_act_list,
        lv_act_key         TYPE /bobf/conf_key,
        lv_act_key_copy    TYPE /bobf/conf_key,
        lv_no_pred         TYPE abap_bool,
        ls_act_base        TYPE REF TO /bobf/s_confro_act_list,
        lo_area_handle     TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_act> TYPE /bobf/s_confro_act_list.

  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

* ____________________________________________________________________ *
* distribute RTW for actions

  LOOP AT mt_act ASSIGNING <ls_act>.
    CREATE DATA <ls_act>-act_read AREA HANDLE lo_area_handle.
    CREATE DATA <ls_act>-act_write AREA HANDLE lo_area_handle.
    CREATE DATA <ls_act>-val_list AREA HANDLE lo_area_handle.
    CREATE DATA <ls_act>-node_cat AREA HANDLE lo_area_handle.
    IF <ls_act>-use_proxy_type = abap_true.
      <ls_act>-param_data_type = <ls_act>-esr_param_data_t.
    ENDIF.
    IF ms_obj-genil_prefix IS NOT INITIAL AND <ls_act>-act_genil_name IS NOT INITIAL.
      CONCATENATE ms_obj-genil_prefix
                  gc_genil_separator
                  <ls_act>-act_genil_name
             INTO <ls_act>-act_genil_name.
    ENDIF.
  ENDLOOP.

  LOOP AT it_rtw INTO ls_rtw
    WHERE content_cat = /bobf/if_conf_c=>sc_content_act.
    READ TABLE mt_act
      WITH TABLE KEY act_key = ls_rtw-content_key
      ASSIGNING <ls_act>.

    CHECK sy-subrc = 0.

    IF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_read.
      CLEAR ls_actread.
      MOVE-CORRESPONDING ls_rtw TO ls_actread.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill assocication action-node -> read-node
        READ TABLE mt_assoc
          WITH KEY assoc_key = ls_rtw-assoc_key
          REFERENCE INTO ls_actread-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE /bobf/cx_conf.
        ENDIF.
      ENDIF.
      INSERT ls_actread INTO TABLE <ls_act>-act_read->*.

    ELSEIF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_write.
      CLEAR ls_actwrite.
      MOVE-CORRESPONDING ls_rtw TO ls_actwrite.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill association action-node -> write-node
        READ TABLE mt_assoc
          WITH KEY assoc_key = ls_rtw-assoc_key
          REFERENCE INTO ls_actwrite-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE /bobf/cx_conf.
        ENDIF.
      ENDIF.
      INSERT ls_actwrite INTO TABLE <ls_act>-act_write->*.

    ENDIF.
  ENDLOOP.

  " node categories...
  LOOP AT it_act_conf ASSIGNING FIELD-SYMBOL(<ls_act_conf>).
    READ TABLE mt_act
      WITH TABLE KEY act_key = <ls_act_conf>-act_key
        ASSIGNING <ls_act>.
    CHECK sy-subrc = 0.
    INSERT VALUE #( node_cat_key = <ls_act_conf>-node_cat_key ) INTO TABLE <ls_act>-node_cat->*.
  ENDLOOP.

* Merge Enhancement information into action

* Find enhancements w/o predecessors
  LOOP AT mt_act INTO ls_act
    WHERE act_cat = /bobf/if_conf_c=>sc_action_enhancement_post OR
          act_cat = /bobf/if_conf_c=>sc_action_enhancement_pre. "#EC CI_SORTSEQ
    READ TABLE mt_act WITH KEY base_action COMPONENTS base_action_key = ls_act-act_key TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      INSERT ls_act-act_key INTO TABLE lt_acts_to_process.
    ENDIF.
  ENDLOOP.

  WHILE lt_acts_to_process IS NOT INITIAL.
    ASSERT sy-index <= lines( mt_act ).
    READ TABLE lt_acts_to_process INDEX 1 INTO lv_act_key.
    ASSERT sy-subrc = 0.
    DELETE lt_acts_to_process INDEX 1.
    READ TABLE mt_act INTO ls_act WITH KEY act_key = lv_act_key.
    ASSERT sy-subrc = 0.
    READ TABLE mt_act REFERENCE INTO ls_act_base WITH KEY act_key = ls_act-base_action_key.
    ASSERT sy-subrc = 0.

*   Build processing order list on the actions
    IF ls_act-act_cat = /bobf/if_conf_c=>sc_action_enhancement_pre.
      IF ls_act_base->pre_enhancement_keys IS NOT BOUND.
        CREATE DATA ls_act_base->pre_enhancement_keys AREA HANDLE lo_area_handle.
      ENDIF.
      IF ls_act-pre_enhancement_keys IS BOUND.
        APPEND LINES OF ls_act-pre_enhancement_keys->* TO ls_act_base->pre_enhancement_keys->*.
      ENDIF.
      APPEND ls_act-act_key TO ls_act_base->pre_enhancement_keys->*.
    ELSE.
      IF ls_act_base->post_enhancement_keys IS NOT BOUND.
        CREATE DATA ls_act_base->post_enhancement_keys AREA HANDLE lo_area_handle.
      ENDIF.
      IF ls_act-post_enhancement_keys IS BOUND.
        INSERT LINES OF ls_act-post_enhancement_keys->* INTO ls_act_base->post_enhancement_keys->* INDEX 1.
      ENDIF.
      INSERT ls_act-act_key INTO ls_act_base->post_enhancement_keys->* INDEX 1.
    ENDIF.

*   Merge Read and Write nodes down into enhanced action
    IF ls_act-act_read IS BOUND AND ls_act-act_read IS NOT INITIAL.
      IF ls_act_base->act_read IS NOT BOUND.
        CREATE DATA ls_act_base->act_read AREA HANDLE lo_area_handle.
      ENDIF.
      INSERT LINES OF ls_act-act_read->* INTO TABLE ls_act_base->act_read->*.
    ENDIF.
    IF ls_act-act_write IS BOUND AND ls_act-act_write IS NOT INITIAL.
      IF ls_act_base->act_write IS NOT BOUND.
        CREATE DATA ls_act_base->act_write AREA HANDLE lo_area_handle.
      ENDIF.
      INSERT LINES OF ls_act-act_write->* INTO TABLE ls_act_base->act_write->*.
    ENDIF.

    INSERT lv_act_key INTO TABLE lt_processed_acts.

*   Find new procesable enhancements (elements for which all predecessors are already processed)
    IF ls_act_base->base_action_key IS NOT INITIAL.
      lv_no_pred = abap_true.
      LOOP AT mt_act INTO ls_act_temp USING KEY base_action WHERE base_action_key = ls_act-base_action_key.
        READ TABLE lt_processed_acts WITH KEY table_line = ls_act_temp-act_key TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          lv_no_pred = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF lv_no_pred = abap_true.
        INSERT ls_act-base_action_key INTO TABLE lt_acts_to_process.
      ENDIF.
    ENDIF.
  ENDWHILE.

ENDMETHOD.


METHOD BUILD_ALTKEY.

  DATA: lv_tabname     TYPE tabname,
        lv_name        TYPE string,
        lv_name2       TYPE string,
        lv_name3       TYPE fieldname,
        lv_dummy       TYPE string,                         "#EC NEEDED
        lv_objtype     TYPE dd02v-tabclass,
        lt_x031l       TYPE TABLE OF x031l,
        ls_x031l       TYPE x031l,
        ls_x031l_last  TYPE x031l,
        lt_stack       TYPE TABLE OF fieldname,
        lv_stack       TYPE fieldname,
        ls_mapping     TYPE /BOBF/S_CONFRO_MAPPING,
        lo_area_handle TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_altkey>  TYPE /BOBF/S_CONFRO_ALTKEY.

  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).

  LOOP AT mt_altkey ASSIGNING <ls_altkey>.

    READ TABLE mt_node REFERENCE INTO <ls_altkey>-node
      WITH KEY node_key = <ls_altkey>-node_key.

    CREATE DATA <ls_altkey>-prx_field_names AREA HANDLE lo_area_handle.
    CREATE DATA <ls_altkey>-field_names     AREA HANDLE lo_area_handle.

    IF <ls_altkey>-use_proxy_type = abap_true.
      <ls_altkey>-data_type = <ls_altkey>-prx_data_type.
    ENDIF.

* ___________________________________________________________________________ *
*   proxy data type

    IF <ls_altkey>-prx_data_type IS NOT INITIAL.
      CLEAR:
        lv_objtype,
        lt_x031l.

      lv_tabname = <ls_altkey>-prx_data_type.
      CALL FUNCTION 'DDIF_NAMETAB_GET'
        EXPORTING
          tabname   = lv_tabname
          all_types = abap_true
        IMPORTING
          ddobjtype = lv_objtype
        TABLES
          x031l_tab = lt_x031l
        EXCEPTIONS
          not_found = 1.

      IF lv_objtype = 'INTTAB' AND
         sy-subrc   = 0.

*       it's a structure
        CLEAR lt_stack.
        <ls_altkey>-prx_altkey_is_structured = abap_true.
        LOOP AT lt_x031l INTO ls_x031l WHERE dtyp <> 'TTAB'."#EC CI_STDSEQ
          IF ls_x031l-depth > ls_x031l_last-depth.
            APPEND ls_x031l_last-fieldname TO lt_stack.
          ELSEIF ls_x031l-depth < ls_x031l_last-depth.
            DO ls_x031l_last-depth - ls_x031l-depth TIMES.
              DELETE lt_stack INDEX ls_x031l_last-depth - sy-index + 1.
            ENDDO.
          ENDIF.

          IF ls_x031l-dtyp <> 'STR2'.
            lv_name = <ls_altkey>-altkey_esr_name.
            LOOP AT lt_stack INTO lv_stack.
              CONCATENATE lv_name '-' lv_stack INTO lv_name.
            ENDLOOP.
            CONCATENATE lv_name '-' ls_x031l-fieldname INTO lv_name.
            INSERT lv_name INTO TABLE <ls_altkey>-prx_field_names->*.
          ENDIF.

          ls_x031l_last = ls_x031l.
        ENDLOOP.

      ELSEIF lv_objtype = 'DTEL'.
*       it's a single field
        <ls_altkey>-prx_altkey_is_structured = abap_false.
        lv_name = <ls_altkey>-altkey_esr_name.
        INSERT lv_name INTO TABLE <ls_altkey>-prx_field_names->*.

      ELSE.
*       wrong type
        ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
        RAISE EXCEPTION TYPE /bobf/cx_conf
          EXPORTING
            textid       = /bobf/cx_conf=>type_not_existing
            mv_type_name = lv_tabname.
      ENDIF.

* ___________________________________________________________________________ *
*     internal type
*     check if alternative key corresponds to BOPF key
      READ TABLE mt_fieldmapping INTO ls_mapping
        WITH KEY content_cat   = /BOBF/IF_CONF_C=>SC_CONTENT_NOD
                 content_key   = <ls_altkey>-node_key
                 fieldname_int = /BOBF/IF_CONF_C=>SC_ATTRIBUTE_NAME_KEY.

      IF sy-subrc = 0.
        <ls_altkey>-altkey_is_key = abap_true.
      ELSE.
        <ls_altkey>-altkey_is_key = abap_false.
      ENDIF.

      LOOP AT <ls_altkey>-prx_field_names->* INTO lv_name.

        READ TABLE mt_fieldmapping INTO ls_mapping
          WITH KEY fieldname_ext COMPONENTS content_cat        = /BOBF/IF_CONF_C=>SC_CONTENT_NOD
                                            content_key        = <ls_altkey>-node_key
                                            fieldname_ext_long = lv_name.

        CHECK sy-subrc = 0.
        IF ls_mapping-fieldname_int IS NOT INITIAL.
          APPEND ls_mapping-fieldname_int TO <ls_altkey>-field_names->*.
          IF ls_mapping-fieldname_int <> /BOBF/IF_CONF_C=>SC_ATTRIBUTE_NAME_KEY.
            <ls_altkey>-altkey_is_key = abap_false.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.

* ___________________________________________________________________________ *
*   internal type
    IF <ls_altkey>-data_type IS NOT INITIAL AND
       <ls_altkey>-use_proxy_type = abap_false.
      CLEAR:
        lv_objtype,
        lt_x031l.

      lv_tabname = <ls_altkey>-data_type.
      CALL FUNCTION 'DDIF_NAMETAB_GET'  "#EC CI_SEL_NESTED
        EXPORTING
          tabname   = lv_tabname
          all_types = abap_true
        IMPORTING
          ddobjtype = lv_objtype
        TABLES
          x031l_tab = lt_x031l
        EXCEPTIONS
          not_found = 1.

      IF lv_objtype = 'INTTAB' AND
         sy-subrc   = 0.

*       it's a structure
        <ls_altkey>-altkey_is_structured = abap_true.

        IF <ls_altkey>-prx_data_type IS INITIAL.
          LOOP AT lt_x031l INTO ls_x031l.
            lv_name = ls_x031l-fieldname.
            INSERT lv_name INTO TABLE <ls_altkey>-field_names->*.
          ENDLOOP.
        ELSE.
          LOOP AT <ls_altkey>-field_names->* INTO lv_name.
            lv_name3 = lv_name.
            READ TABLE lt_x031l TRANSPORTING NO FIELDS
              WITH KEY fieldname = lv_name3.             "#EC CI_STDSEQ
            IF sy-subrc <> 0.
              DELETE <ls_altkey>-field_names->*.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ELSEIF lv_objtype = 'DTEL'.

*       it's a single field
        <ls_altkey>-altkey_is_structured = abap_false.

        IF <ls_altkey>-prx_altkey_is_structured = abap_true.
          LOOP AT <ls_altkey>-field_names->* INTO lv_name.
            IF lv_name <> <ls_altkey>-altkey_name.
              DELETE <ls_altkey>-field_names->*.
            ENDIF.
          ENDLOOP.
        ELSEIF <ls_altkey>-field_names->* IS INITIAL.
          lv_name = <ls_altkey>-altkey_name.
          INSERT lv_name INTO TABLE <ls_altkey>-field_names->*.
        ENDIF.
      ELSE.

*       wrong type
        ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
        RAISE EXCEPTION TYPE /BOBF/CX_CONF.
      ENDIF.
    ENDIF.

*   set proxy attribute names
    IF <ls_altkey>-use_proxy_type = abap_true.
      IF <ls_altkey>-prx_altkey_is_structured = abap_true.
        CLEAR <ls_altkey>-field_names->*.
        LOOP AT <ls_altkey>-prx_field_names->* INTO lv_name.
          SPLIT lv_name AT '-' INTO lv_dummy lv_name2.
          APPEND lv_name2 TO <ls_altkey>-field_names->*.
        ENDLOOP.
      ELSE.
        <ls_altkey>-field_names->* = <ls_altkey>-prx_field_names->*.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD build_association.

  DATA: ls_assoc             TYPE /bobf/s_confro_assoc2,
        ls_assoc_help        TYPE /bobf/s_confro_assoc,
        ls_assocb_db         TYPE /bobf/obm_assocb,
        ls_assocb            TYPE /bobf/s_confro_assocb,
        ls_assocc            TYPE /bobf/s_confro_assocc,
        ls_nodecat           TYPE /bobf/s_confro_node_cat,
        ls_node              TYPE REF TO /bobf/s_confro_node,
        ls_node2             TYPE REF TO /bobf/s_confro_node,
        ls_rtw               TYPE /bobf/obm_rtw,
        lv_parent_node_key   TYPE /bobf/obm_node_key,
        lv_ncat_assoc        TYPE i,
        lv_ncat_all          TYPE i,
        lv_lock_count        TYPE i,
        lv_lockable_node_key TYPE /bobf/obm_node_key,
        lv_attribute         TYPE c LENGTH 256,
        lo_area_handle       TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_assoc>       TYPE /bobf/s_confro_assoc,
                 <ls_node>        TYPE /bobf/s_confro_node,
                 <ls_node_parent> TYPE /bobf/s_confro_node.

  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

* ____________________________________________________________________ *
* link associations to the node table
* insert possible nodecats
  LOOP AT mt_assoc ASSIGNING <ls_assoc>.
    IF <ls_assoc>-use_proxy_type = abap_true.
      <ls_assoc>-param_data_type = <ls_assoc>-esr_param_data_t.
    ENDIF.

    IF ms_obj-genil_prefix IS NOT INITIAL AND <ls_assoc>-assoc_genil_name IS NOT INITIAL.
      CONCATENATE ms_obj-genil_prefix
                  gc_genil_separator
                  <ls_assoc>-assoc_genil_name
             INTO <ls_assoc>-assoc_genil_name.
    ENDIF.

*   source node
    READ TABLE mt_node
      WITH TABLE KEY node_key = <ls_assoc>-source_node_key
      REFERENCE INTO <ls_assoc>-source_node.
    IF sy-subrc <> 0.
*     source node does not exist
      ASSERT ID /bobf/conf CONDITION 0 = 1.                "#EC BOOL_OK
      DELETE mt_assoc.
      CONTINUE.
    ENDIF.

*   target node
    IF <ls_assoc>-target_node_key IS NOT INITIAL.
      READ TABLE mt_node
        WITH TABLE KEY node_key = <ls_assoc>-target_node_key
        REFERENCE INTO <ls_assoc>-target_node.
      IF sy-subrc <> 0.
*       target node does not exist
        ASSERT ID /bobf/conf CONDITION 0 = 1.              "#EC BOOL_OK
        DELETE mt_assoc.
        CONTINUE.
      ENDIF.
    ENDIF.

    CREATE DATA <ls_assoc>-node_cat      AREA HANDLE lo_area_handle.
    CREATE DATA <ls_assoc>-assoc_binding AREA HANDLE lo_area_handle.

    IF <ls_assoc>-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_property AND
       <ls_assoc>-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_message  AND
       <ls_assoc>-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_lock     AND
       <ls_assoc>-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_status   AND
       <ls_assoc>-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent   AND
       <ls_assoc>-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_root.

*     set source nodecat (only for non-framework associations)
      LOOP AT it_assocc INTO ls_assocc
        WHERE assoc_key = <ls_assoc>-assoc_key.
        ls_nodecat-node_cat_key = ls_assocc-node_cat_key.
        INSERT ls_nodecat INTO TABLE <ls_assoc>-node_cat->*.
      ENDLOOP.

*     all node categories allowed?, delete node cats
      DESCRIBE TABLE <ls_assoc>-node_cat->*              LINES lv_ncat_assoc.
      DESCRIBE TABLE <ls_assoc>-source_node->node_cat->* LINES lv_ncat_all.
      IF lv_ncat_all = lv_ncat_assoc.
*       association is for all node cats allowed
        FREE <ls_assoc>-node_cat->*.
      ENDIF.
    ENDIF.

*   fill association binding
    LOOP AT it_assocb INTO ls_assocb_db
      WHERE assoc_key = <ls_assoc>-assoc_key.
*     temporary switch of attributes
      IF ls_assocb_db-attribute_cat IS INITIAL.
        ls_assocb_db-attribute_cat = /bobf/if_conf_c=>sc_assocbcat_target.
      ENDIF.
      IF     <ls_assoc>-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source AND
             ls_assocb_db-attribute_cat <> /bobf/if_conf_c=>sc_assocbcat_source AND
             ls_assocb_db-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_source.
        ls_assocb_db-attribute_cat    = /bobf/if_conf_c=>sc_assocbcat_source.
        lv_attribute                  = ls_assocb_db-attribute.
        ls_assocb_db-attribute        = ls_assocb_db-from_binding.
        ls_assocb_db-from_binding     = lv_attribute.
        ls_assocb_db-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_target.
        IF ls_assocb_db-to_binding_cat IS NOT INITIAL.
          ls_assocb_db-to_binding_cat = /bobf/if_conf_c=>sc_assocbcat_target.
        ENDIF.
      ELSEIF <ls_assoc>-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target AND
             ls_assocb_db-attribute_cat <> /bobf/if_conf_c=>sc_assocbcat_target AND
             ls_assocb_db-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_target.
        ls_assocb_db-attribute_cat    = /bobf/if_conf_c=>sc_assocbcat_source.
        lv_attribute                = ls_assocb_db-attribute.
        ls_assocb_db-attribute        = ls_assocb_db-from_binding.
        ls_assocb_db-from_binding     = lv_attribute.
        ls_assocb_db-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_source.
        IF ls_assocb_db-to_binding_cat IS NOT INITIAL.
          ls_assocb_db-to_binding_cat = /bobf/if_conf_c=>sc_assocbcat_source.
        ENDIF.
      ENDIF.
*     end of temporary switch of attributes
      MOVE-CORRESPONDING ls_assocb_db TO ls_assocb.
      IF ls_assocb-from_binding_cat = /bobf/if_conf_c=>sc_assocbcat_constant.
        CONCATENATE ls_assocb_db-const_interface '=>' ls_assocb_db-from_binding INTO ls_assocb-constant.
      ENDIF.
      INSERT ls_assocb INTO TABLE <ls_assoc>-assoc_binding->*.
    ENDLOOP.
  ENDLOOP.

* ____________________________________________________________________ *
* fill parent and root node into node table
  LOOP AT mt_assoc ASSIGNING <ls_assoc>
    WHERE assoc_type = /bobf/if_conf_c=>sc_assoctype_comp. "#EC CI_SORTSEQ
*   fill composition table
    CLEAR ls_assoc.
    MOVE-CORRESPONDING <ls_assoc> TO ls_assoc.
    INSERT ls_assoc INTO TABLE mt_comp.

    ASSERT ID /bobf/conf CONDITION <ls_assoc>-target_node IS BOUND AND <ls_assoc>-source_node IS BOUND.
    IF <ls_assoc>-target_node IS NOT BOUND OR
       <ls_assoc>-source_node IS NOT BOUND.
      DELETE mt_assoc.
      CONTINUE.
    ENDIF.
    <ls_assoc>-target_node->root_node_key   = ms_obj-root_node_key.
    <ls_assoc>-target_node->parent_node_key = <ls_assoc>-source_node_key.
*   has lock node?
    IF <ls_assoc>-target_node->node_type = /bobf/if_conf_c=>sc_node_type_lock.
      <ls_assoc>-source_node->lock_node_key = <ls_assoc>-target_node_key.
      ADD 1 TO lv_lock_count.
      lv_lockable_node_key = <ls_assoc>-source_node_key.
    ENDIF.
*   has message node?
    IF <ls_assoc>-target_node->node_type = /bobf/if_conf_c=>sc_node_type_message.
      <ls_assoc>-source_node->message_node_key = <ls_assoc>-target_node_key.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* set "source data required" flag
  LOOP AT mt_assoc ASSIGNING <ls_assoc> WHERE           "#EC CI_SORTSEQ
      assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent AND
      assoc_cat <> /bobf/if_conf_c=>sc_assoccat_root.
    IF <ls_assoc>-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.
      <ls_assoc>-source_data_required = abap_true.

    ELSEIF <ls_assoc>-target_node->optimized_buffer_access = abap_false AND
        <ls_assoc>-assoc_binding                           IS BOUND     AND
        <ls_assoc>-assoc_binding->*                        IS NOT INITIAL.
*     check if target node and source node are in same loading group

      ls_node = <ls_assoc>-target_node.
      WHILE ls_node->loadable = abap_false AND
          ls_node->node_key <> ms_obj-root_node_key.
        READ TABLE mt_comp INTO ls_assoc WITH KEY target_key COMPONENTS
            target_node_key = ls_node->node_key.
        ls_node = ls_assoc-source_node.
      ENDWHILE.
      ls_node2 = <ls_assoc>-source_node.
      WHILE ls_node2->node_key <> ls_node->node_key AND
          ls_node2->loadable = abap_false           AND
          ls_node2->node_key <> ms_obj-root_node_key.
        READ TABLE mt_comp INTO ls_assoc WITH KEY target_key COMPONENTS
            target_node_key = ls_node2->node_key.
        ls_node2 = ls_assoc-source_node.
      ENDWHILE.
      IF ls_node2           = ls_node AND
          ls_node->lockable = abap_true.
        <ls_assoc>-source_data_required = abap_true.
      ENDIF.
    ENDIF.
  ENDLOOP.

* set "lock_only_root" flag
  IF lv_lock_count = 1 AND
     lv_lockable_node_key = ms_obj-root_node_key.
    ms_obj-lock_only_root = abap_true.
  ELSEIF lv_lock_count = 0.
    ms_obj-no_lock = abap_true.
  ENDIF.

* set "target locked with source" and "target loaded with source" flags
  LOOP AT mt_assoc ASSIGNING <ls_assoc> WHERE
*      source_node->transient = abap_false AND
*      target_node->transient = abap_false AND
      assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_xbo. "#EC CI_SORTSEQ

* "target locked with source"
    IF <ls_assoc>-source_node_key        = <ls_assoc>-target_node_key AND
        <ls_assoc>-source_node->lockable = abap_true.
*       assumption: cross instance association
      <ls_assoc>-target_locked_with_source = abap_false.

    ELSEIF ms_obj-lock_only_root = abap_true.
      <ls_assoc>-target_locked_with_source = abap_true.

    ELSEIF <ls_assoc>-assoc_type = /bobf/if_conf_c=>sc_assoctype_comp.
      IF <ls_assoc>-target_node->lockable = abap_true.
        <ls_assoc>-target_locked_with_source = abap_false.
      ELSE.
        <ls_assoc>-target_locked_with_source = abap_true.
      ENDIF.

    ELSEIF <ls_assoc>-assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent.
      IF <ls_assoc>-source_node->lockable = abap_true.
        <ls_assoc>-target_locked_with_source = abap_false.
      ELSE.
        <ls_assoc>-target_locked_with_source = abap_true.
      ENDIF.

    ELSE.
      ls_node = <ls_assoc>-target_node.
      WHILE ls_node->lockable = abap_false AND
          ls_node->node_key <> ms_obj-root_node_key.
        READ TABLE mt_comp INTO ls_assoc WITH KEY target_key COMPONENTS
            target_node_key = ls_node->node_key.
        ls_node = ls_assoc-source_node.
      ENDWHILE.
      ls_node2 = <ls_assoc>-source_node.
      WHILE ls_node2->node_key <> ls_node->node_key AND
          ls_node2->lockable = abap_false           AND
          ls_node2->node_key <> ms_obj-root_node_key.
        READ TABLE mt_comp INTO ls_assoc WITH KEY target_key COMPONENTS
            target_node_key = ls_node2->node_key.
        ls_node2 = ls_assoc-source_node.
      ENDWHILE.
      IF ls_node2           = ls_node AND
          ls_node->lockable = abap_true.
        <ls_assoc>-target_locked_with_source = abap_true.
      ENDIF.
    ENDIF.

* "target loaded with source"
    IF <ls_assoc>-source_node_key        = <ls_assoc>-target_node_key AND
        <ls_assoc>-source_node->loadable = abap_true.
*     assumption: cross instance association
      <ls_assoc>-target_loaded_with_source = abap_false.

    ELSEIF <ls_assoc>-assoc_cat = /bobf/if_conf_c=>sc_assoccat_lock
        OR <ls_assoc>-assoc_cat = /bobf/if_conf_c=>sc_assoccat_message
        OR <ls_assoc>-assoc_cat = /bobf/if_conf_c=>sc_assoccat_property.
*     transient framework nodes
      <ls_assoc>-target_loaded_with_source = abap_false.

    ELSEIF <ls_assoc>-assoc_type = /bobf/if_conf_c=>sc_assoctype_comp.
      IF <ls_assoc>-target_node->loadable = abap_true.
        <ls_assoc>-target_loaded_with_source = abap_false.
      ELSEIF <ls_assoc>-target_node->transient = abap_true.
        <ls_assoc>-target_loaded_with_source = abap_true.
*       check if node is determined "before retrieve"
        READ TABLE mt_assoc INTO ls_assoc_help WITH KEY key3
          COMPONENTS assoc_cat       = /bobf/if_conf_c=>sc_assoccat_parent
                     source_node_key = <ls_assoc>-target_node_key
                     target_node_key = <ls_assoc>-source_node_key.
        IF sy-subrc = 0.
          LOOP AT it_rtw INTO ls_rtw
            WHERE content_cat = /bobf/if_conf_c=>sc_content_det
              AND access_cat  = /bobf/if_conf_c=>sc_access_trigger
              AND node_key    = <ls_assoc>-target_node_key
              AND assoc_key   = ls_assoc_help-assoc_key.

            READ TABLE it_detconf TRANSPORTING NO FIELDS
              WITH KEY det_key   = ls_rtw-content_key
                       exec_time = /bobf/if_conf_c=>sc_time_before_retrieve.
            IF sy-subrc = 0.
              <ls_assoc>-target_loaded_with_source = abap_false.
              EXIT.
            ENDIF.
          ENDLOOP.
        ELSE.
          ASSERT ID /bobf/conf CONDITION 0 = 1.            "#EC BOOL_OK
        ENDIF.
      ELSE.
        <ls_assoc>-target_loaded_with_source = abap_true.
      ENDIF.

    ELSEIF <ls_assoc>-assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent.
      IF <ls_assoc>-source_node->loadable = abap_true.
        <ls_assoc>-target_loaded_with_source = abap_false.
      ELSE.
        <ls_assoc>-target_loaded_with_source = abap_true.
      ENDIF.

    ELSE.
*     association within one loading group
      ls_node = <ls_assoc>-target_node.
      WHILE ls_node->loadable = abap_false AND
          ls_node->node_key <> ms_obj-root_node_key.
        READ TABLE mt_comp INTO ls_assoc WITH KEY target_key COMPONENTS
            target_node_key = ls_node->node_key.
        ls_node = ls_assoc-source_node.
      ENDWHILE.
      ls_node2 = <ls_assoc>-source_node.
      WHILE ls_node2->node_key <> ls_node->node_key AND
          ls_node2->loadable = abap_false           AND
          ls_node2->node_key <> ms_obj-root_node_key.
        READ TABLE mt_comp INTO ls_assoc WITH KEY target_key COMPONENTS
            target_node_key = ls_node2->node_key.
        ls_node2 = ls_assoc-source_node.
      ENDWHILE.
      IF ls_node2           = ls_node AND
          ls_node->loadable = abap_true.
        <ls_assoc>-target_loaded_with_source = abap_true.
      ENDIF.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* fill root node key of root node (no composition avail)
  READ TABLE mt_node
    WITH TABLE KEY node_key = ms_obj-root_node_key
    ASSIGNING <ls_node>.
  IF sy-subrc = 0.
    <ls_node>-root_node_key = ms_obj-root_node_key.
  ELSE.
*   no root node defined
    ASSERT ID /bobf/conf CONDITION 0 = 1.                  "#EC BOOL_OK
    RAISE EXCEPTION TYPE /bobf/cx_conf.
  ENDIF.

* ____________________________________________________________________ *
* set optimized buffer access flag
  LOOP AT mt_node ASSIGNING <ls_node>
    WHERE loadable = abap_true.                         "#EC CI_SORTSEQ
    <ls_node>-optimized_buffer_access = abap_true.
    IF <ls_node>-lockable = abap_true.
      READ TABLE mt_node WITH KEY
          parent_node_key = <ls_node>-node_key
          lockable        = abap_false
          loadable        = abap_true
          TRANSPORTING NO FIELDS.                       "#EC CI_SORTSEQ
      IF sy-subrc <> 0.
        <ls_node>-loadgroup_eq_lockgroup = abap_true.
      ENDIF.
    ENDIF.
  ENDLOOP.
  LOOP AT mt_comp INTO ls_assoc
    WHERE target_node IS BOUND
      AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_object. "#EC CI_SORTSEQ
    IF ls_assoc-target_node->loadable  =  abap_false AND
       ls_assoc-target_node->transient =  abap_false AND
       ls_assoc-source_node->buf_class <> ls_assoc-target_node->buf_class AND
       ls_assoc-source_node->buf_class IS NOT INITIAL AND
       ls_assoc-target_node->buf_class IS NOT INITIAL.
      ls_assoc-source_node->optimized_buffer_access = abap_false.
    ENDIF.
  ENDLOOP.
  IF ms_obj-no_lock = abap_false.
    LOOP AT mt_node ASSIGNING <ls_node>
      WHERE loadable = abap_true
        AND lockable = abap_false.                      "#EC CI_SORTSEQ
      lv_parent_node_key = <ls_node>-parent_node_key.
      DO.
        READ TABLE mt_node
          WITH KEY node_key = lv_parent_node_key
          ASSIGNING <ls_node_parent>.
        IF sy-subrc = 0.
          IF <ls_node_parent>-lockable = abap_true.
            <ls_node_parent>-loadgroup_eq_lockgroup = abap_false.
            EXIT.
          ENDIF.
          lv_parent_node_key = <ls_node_parent>-parent_node_key.
        ELSE.
          EXIT.
        ENDIF.
      ENDDO.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
* temporary !!!
  LOOP AT mt_node ASSIGNING <ls_node>
    WHERE sp_id_map_class IS INITIAL.                   "#EC CI_SORTSEQ
    <ls_node>-sp_id_map_class = <ls_node>-sp_mapper_class.
  ENDLOOP.

ENDMETHOD.


METHOD BUILD_ASSOCIATION_CHANGE.

  DATA: ls_node           TYPE REF TO /BOBF/S_CONFRO_NODE,
        ls_assoc          TYPE REF TO /BOBF/S_CONFRO_ASSOC,
        ls_assoc_resolve  TYPE /BOBF/S_CONFRO_ASSOC,
        ls_assocb         TYPE /BOBF/S_CONFRO_ASSOCB,
        ls_assocb2        TYPE /BOBF/S_CONFRO_ASSOCB,
        ls_assoc_chg      TYPE /BOBF/S_CONFRO_ASSOC_CHG,
        ls_assoc_chg_trig TYPE /BOBF/S_CONFRO_ASSOC_CHG_TRIG,
        lv_assoc_found    TYPE boole_d,
        lv_binding_match  TYPE boole_d,
        lo_area_handle    TYPE REF TO cl_abap_memory_area.

  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).

  LOOP AT mt_node REFERENCE INTO ls_node WHERE node_type <> /BOBF/IF_CONF_C=>SC_NODE_TYPE_PROPERTY
                                           AND node_type <> /BOBF/IF_CONF_C=>SC_NODE_TYPE_MESSAGE
                                           AND node_type <> /BOBF/IF_CONF_C=>SC_NODE_TYPE_LOCK. "#EC CI_SORTSEQ
    CREATE DATA ls_assoc_chg-trigger AREA HANDLE lo_area_handle.
    CLEAR ls_assoc_chg_trig.

*   Create trigger info for outgoing source resolved assocs.
    LOOP AT mt_assoc REFERENCE INTO ls_assoc USING KEY key2
       WHERE source_node_key = ls_node->node_key
         AND assoc_resolve   = /BOBF/IF_CONF_C=>SC_ASSOC_RESOLVE_SOURCE.
      ls_assoc_chg_trig-assoc_key = ls_assoc->assoc_key.
      ls_assoc_chg_trig-assoc     = ls_assoc.

*     Reverse specializations
      IF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_SPECIALIZATION_R.
        ls_assoc_chg_trig-create = abap_false.
        ls_assoc_chg_trig-update = abap_true.
        ls_assoc_chg_trig-delete = abap_false.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

*     Foreign key associations
      ELSEIF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_FOREIGN_KEY.
        ls_assoc_chg_trig-create = abap_false.
        ls_assoc_chg_trig-update = abap_true.
        ls_assoc_chg_trig-delete = abap_false.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

*     Cross-BO associations
      ELSEIF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_XBO.
        ls_assoc_chg_trig-create = abap_false.
        ls_assoc_chg_trig-update = abap_true.
        ls_assoc_chg_trig-delete = abap_false.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

*     Association to DO
      ELSEIF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_OBJECT.
        ls_assoc_chg_trig-create = abap_false.
        ls_assoc_chg_trig-update = abap_true.
        ls_assoc_chg_trig-delete = abap_false.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

      ENDIF.
    ENDLOOP.

*   Create trigger info for incoming target resolved assocs.
    LOOP AT mt_assoc REFERENCE INTO ls_assoc
      WHERE target_node_key = ls_node->node_key
        AND assoc_resolve   = /BOBF/IF_CONF_C=>SC_ASSOC_RESOLVE_TARGET. "#EC CI_SORTSEQ
      ls_assoc_chg_trig-assoc_key = ls_assoc->assoc_key.
      ls_assoc_chg_trig-assoc     = ls_assoc.

*     Composition assocations
      IF ls_assoc->assoc_type = /BOBF/IF_CONF_C=>SC_ASSOCTYPE_COMP.
        ls_assoc_chg_trig-create = abap_true.
        ls_assoc_chg_trig-update = abap_false.
        ls_assoc_chg_trig-delete = abap_true.
        READ TABLE mt_assoc INTO ls_assoc_resolve WITH KEY key3
          COMPONENTS source_node_key = ls_assoc->target_node_key
                     target_node_key = ls_assoc->source_node_key
                     assoc_cat       = /BOBF/IF_CONF_C=>SC_ASSOCCAT_PARENT.
        ASSERT ID /BOBF/CONF CONDITION sy-subrc = 0.
        ls_assoc_chg_trig-resolve_assoc_key = ls_assoc_resolve-assoc_key.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

*     Specialization associations
      ELSEIF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_SPECIALIZATION.
        ls_assoc_chg_trig-create = abap_true.
        ls_assoc_chg_trig-update = abap_true.
        ls_assoc_chg_trig-delete = abap_true.
        READ TABLE mt_assoc INTO ls_assoc_resolve WITH KEY key3
          COMPONENTS source_node_key = ls_assoc->target_node_key
                     target_node_key = ls_assoc->source_node_key
                     assoc_cat       = /BOBF/IF_CONF_C=>SC_ASSOCCAT_PARENT.
        ASSERT ID /BOBF/CONF CONDITION sy-subrc = 0.
        ls_assoc_chg_trig-resolve_assoc_key = ls_assoc_resolve-assoc_key.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

*     Associations to delegated node
      ELSEIF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_OBJECT.
        ls_assoc_chg_trig-create = abap_true.
        ls_assoc_chg_trig-update = abap_false.
        ls_assoc_chg_trig-delete = abap_true.
*       1:c assoc to DO
        IF ls_assoc->cardinality = /BOBF/IF_CONF_C=>SC_CARD_ONE OR
           ls_assoc->cardinality = /BOBF/IF_CONF_C=>SC_CARD_ZERO_TO_ONE.
          READ TABLE mt_assoc INTO ls_assoc_resolve WITH KEY key3
            COMPONENTS source_node_key = ls_assoc->target_node_key
                       target_node_key = ls_assoc->source_node_key
                       assoc_cat       = /BOBF/IF_CONF_C=>SC_ASSOCCAT_PARENT.
          ASSERT ID /BOBF/CONF CONDITION sy-subrc = 0.
*       1:n assoc to DO
        ELSE.
*         need to create additional association from DO node to host node.
          CLEAR ls_assoc_resolve.
          ls_assoc_resolve-assoc_cat       = /BOBF/IF_CONF_C=>SC_ASSOCCAT_NORMAL.
          ls_assoc_resolve-assoc_name      = '%TO_HOST_NODE'.
          ls_assoc_resolve-assoc_key       = /BOBF/CL_FRW_FACTORY=>GET_NEW_TRANSIENT_KEY( ).
          ls_assoc_resolve-assoc_type      = /BOBF/IF_CONF_C=>SC_ASSOCTYPE_STD.
          ls_assoc_resolve-cardinality     = /BOBF/IF_CONF_C=>SC_CARD_ONE.
          ls_assoc_resolve-assoc_class     = /BOBF/IF_CONF_DEF_CLASSES_C=>GC_CL_ASSOC_ANCESTOR.
          ls_assoc_resolve-source_node     = ls_assoc->target_node.
          ls_assoc_resolve-source_node_key = ls_assoc->target_node_key.
          ls_assoc_resolve-target_node     = ls_assoc->source_node.
          ls_assoc_resolve-target_node_key = ls_assoc->source_node_key.
          CREATE DATA ls_assoc_resolve-node_cat AREA HANDLE lo_area_handle.
          CREATE DATA ls_assoc_resolve-assoc_binding AREA HANDLE lo_area_handle.
          ls_assoc_resolve-assoc_resolve   = /BOBF/IF_CONF_C=>SC_ASSOC_RESOLVE_SOURCE.
          INSERT ls_assoc_resolve INTO TABLE mt_assoc.
        ENDIF.
        ls_assoc_chg_trig-resolve_assoc_key = ls_assoc_resolve-assoc_key.
        INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
        IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
          ls_node->assoc_change_notifs_by_bopf = abap_true.
          ms_obj-assoc_change_notifs_by_bopf   = abap_true.
        ENDIF.

*     Reverse foreign key association
      ELSEIF ls_assoc->assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_FOREIGN_KEY_R.
        ls_assoc_chg_trig-create = abap_true.
        ls_assoc_chg_trig-update = abap_true.
        ls_assoc_chg_trig-delete = abap_true.
        lv_assoc_found = abap_false.
        LOOP AT mt_assoc INTO ls_assoc_resolve USING KEY key3
              WHERE source_node_key = ls_assoc->target_node_key
                AND target_node_key = ls_assoc->source_node_key
                AND assoc_cat       = /BOBF/IF_CONF_C=>SC_ASSOCCAT_FOREIGN_KEY.
*         Compare association bindings.
          IF lines( ls_assoc->assoc_binding->* ) <> lines( ls_assoc_resolve-assoc_binding->* ).
            lv_binding_match = abap_false.
          ELSE.
            lv_binding_match = abap_true.
*           Attribute and From_Binding information have to be identical,
*           binding categories have to be source for the rev. foreign key assoc and target for the matching foreign key assoc.
            LOOP AT ls_assoc->assoc_binding->* INTO ls_assocb.
              READ TABLE ls_assoc_resolve-assoc_binding->* INTO ls_assocb2 WITH KEY attribute = ls_assocb-attribute. "#EC CI_SORTSEQ
              IF sy-subrc = 0.
                IF ls_assocb-from_binding <> ls_assocb2-from_binding.
                  lv_binding_match = abap_false.
                  EXIT.
                ELSEIF NOT ( ls_assocb-from_binding_cat  = /BOBF/IF_CONF_C=>SC_ASSOCBCAT_SOURCE AND
                             ls_assocb2-from_binding_cat = /BOBF/IF_CONF_C=>SC_ASSOCBCAT_TARGET ).
                  lv_binding_match = abap_false.
                  EXIT.
                ENDIF.
              ELSE.
                lv_binding_match = abap_false.
                EXIT.
              ENDIF.
            ENDLOOP.
          ENDIF.
          IF lv_binding_match = abap_true.
            lv_assoc_found = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.
*        ASSERT ID /bopf/conf CONDITION lv_assoc_found = abap_true.
        IF lv_assoc_found = abap_true.
          ls_assoc_chg_trig-resolve_assoc_key = ls_assoc_resolve-assoc_key.
          INSERT ls_assoc_chg_trig INTO TABLE ls_assoc_chg-trigger->*.
          IF ls_assoc->change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.
            ls_node->assoc_change_notifs_by_bopf = abap_true.
            ms_obj-assoc_change_notifs_by_bopf   = abap_true.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.
    ls_assoc_chg-node_key = ls_node->node_key.
    INSERT ls_assoc_chg INTO TABLE mt_assoc_change.
  ENDLOOP.

ENDMETHOD.


METHOD build_authorization.

  FIELD-SYMBOLS <ls_node> TYPE /bobf/s_confro_node.


  IF iv_header_auth_check_relevant = abap_false.

    " main switch at header should always win: clear all dependent fields

    ms_obj-has_authority_checks = abap_false.

    LOOP AT mt_node ASSIGNING <ls_node>.
      <ls_node>-auth_check_relevant = abap_false.
      CLEAR <ls_node>-auth_check_class.
      CLEAR <ls_node>-auth_node_key.
      " table node-AUTH_OBJ_NAMES is already cleared
      " table node-ACF_MAPPING is already cleared
    ENDLOOP.

  ELSE.

    " calculate -AUTH_NODE_KEY on node level and -HAS_AUTHORITY_CHECKS on BO level

    ms_obj-has_authority_checks = abap_false. " initialize for subsequent calculation

    LOOP AT mt_node ASSIGNING <ls_node>.

      IF <ls_node>-node_type = /bobf/if_conf_c=>sc_node_type_normal.

        IF ms_obj-has_authority_checks = abap_false.
          ms_obj-has_authority_checks = me->determine_node_has_auth_checks( <ls_node> ).
        ENDIF.
        " node-AUTH_CHECK_RELEVANT is already set
        " node-AUTH_CHECK_CLASS is already set
        CLEAR <ls_node>-auth_node_key.
        me->determine_node_auth_node_key(
          EXPORTING
            is_node          = <ls_node>
          IMPORTING
            ev_auth_node_key = <ls_node>-auth_node_key ).
        " table node-AUTH_OBJ_NAMES is already set
        " table node-ACF_MAPPING is already set

      ELSE.

        " _abormal_ nodes like lock nodes
        <ls_node>-auth_check_relevant = abap_false.
        CLEAR <ls_node>-auth_check_class.
        CLEAR <ls_node>-auth_node_key.
        " table node-AUTH_OBJ_NAMES should be initial, since it's not maintainable for _abnormal_nodes
        " table node-ACF_MAPPING should be initial, since it's not maintainable for _abnormal_nodes

      ENDIF.

    ENDLOOP.

  ENDIF.

ENDMETHOD.


METHOD build_determination.

  TYPES:
    BEGIN OF ty_model_group,
      line_type TYPE STANDARD TABLE OF /bobf/obm_name WITH DEFAULT KEY,
    END OF ty_model_group.

  DATA: lt_det         TYPE /bobf/t_confro_det_list,
        ls_curr_det    TYPE /bobf/s_confro_det_list,
        lt_det2        TYPE /bobf/t_confro_det_list,
        lt_det_sorted  TYPE /bobf/t_confro_det_list,
        ls_det_insert  TYPE REF TO /bobf/s_confro_det_list,
        lt_det_tmp     TYPE /bobf/t_confro_det_list,
        ls_detread     TYPE /bobf/s_confro_read,
        ls_detwrite    TYPE /bobf/s_confro_det_write,
        ls_dettrigger  TYPE /bobf/s_confro_det_trigger,
        ls_curr_detnet TYPE /bobf/det_net,
        lt_sortednet   TYPE tt_sortednet,
        lt_model_group TYPE TABLE OF ty_model_group,
        ls_model_group TYPE ty_model_group,
        ls_detnet      TYPE /bobf/det_net,
        ls_rtw         TYPE /bobf/obm_rtw,
        ls_rtw_a       TYPE /bobf/obm_rtw_a,
        ls_nodecat     TYPE /bobf/s_confro_node_cat,
        lv_ncat_all    TYPE i,
        lv_ncat_det    TYPE i,
        lv_inital      TYPE /bobf/obm_name,
        lv_name_source TYPE /bobf/obm_name,
        lv_name_target TYPE /bobf/obm_name,
        lv_index       TYPE i,
        lo_area_handle TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS:
    <ls_det>             TYPE /bobf/s_confro_det_list,
    <ls_db_det>          TYPE /bobf/det_list,
    <ls_models>          TYPE ts_models,
    <ls_models_tmp>      TYPE ts_models,
    <ls_model_group>     TYPE ty_model_group,
    <ls_model_group_tmp> TYPE ty_model_group,
    <ls_root_model>      TYPE ts_models,
    <ls_node>            TYPE /bobf/s_confro_node,
    <ls_exectime>        TYPE /bobf/s_confro_exectime,
    <ls_detconf>         TYPE /bobf/det_conf.


  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

* ____________________________________________________________________ *
  " convert determination list into confro table types
  LOOP AT it_det ASSIGNING <ls_db_det>.
    MOVE-CORRESPONDING <ls_db_det> TO ls_curr_det.          "#EC ENHOK
    APPEND ls_curr_det TO lt_det.
  ENDLOOP.

* ____________________________________________________________________ *
  " assign rtw information to determinations
  LOOP AT it_rtw INTO ls_rtw
    WHERE content_cat = /bobf/if_conf_c=>sc_content_det.
    READ TABLE lt_det ASSIGNING <ls_det>
      WITH KEY det_key = ls_rtw-content_key.
    CHECK sy-subrc = 0.

    IF <ls_det>-det_read IS NOT BOUND.
      CREATE DATA <ls_det>-det_read AREA HANDLE lo_area_handle.
      CREATE DATA <ls_det>-det_write AREA HANDLE lo_area_handle.
      CREATE DATA <ls_det>-det_trigger AREA HANDLE lo_area_handle.
    ENDIF.

    IF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_read.
      CLEAR ls_detread.
      MOVE-CORRESPONDING ls_rtw TO ls_detread.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill assocication determination-node -> read-node
        READ TABLE mt_assoc
          WITH KEY assoc_key = ls_rtw-assoc_key
          REFERENCE INTO ls_detread-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          APPEND ls_detread TO <ls_det>-det_read->*.
        ENDIF.
      ELSE.
        APPEND ls_detread TO <ls_det>-det_read->*.
      ENDIF.

    ELSEIF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_write.
      CLEAR ls_detwrite.
      MOVE-CORRESPONDING ls_rtw TO ls_detwrite.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill association determination-node -> write-node
        READ TABLE mt_assoc
          WITH KEY assoc_key = ls_rtw-assoc_key
          REFERENCE INTO ls_detwrite-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          APPEND ls_detwrite TO <ls_det>-det_write->*.
        ENDIF.
      ELSE.
        APPEND ls_detwrite TO <ls_det>-det_write->*.
      ENDIF.

    ELSEIF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_trigger.
      CLEAR ls_dettrigger.
      MOVE-CORRESPONDING ls_rtw TO ls_dettrigger.           "#EC ENHOK
      ls_dettrigger-load = ls_rtw-trigger_load.
      ls_dettrigger-create   = ls_rtw-trigger_create.
      ls_dettrigger-update   = ls_rtw-trigger_update.
      ls_dettrigger-delete   = ls_rtw-trigger_delete.
      ls_dettrigger-property = ls_rtw-trigger_property.
      ls_dettrigger-lock     = ls_rtw-trigger_lock.
      ls_dettrigger-check    = ls_rtw-trigger_check.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill association trigger-node -> determination-node
        READ TABLE mt_assoc
         WITH KEY assoc_key = ls_rtw-assoc_key
         REFERENCE INTO ls_dettrigger-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          APPEND ls_dettrigger TO <ls_det>-det_trigger->*.
        ENDIF.
      ELSE.
        APPEND ls_dettrigger TO <ls_det>-det_trigger->*.
      ENDIF.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
  " delete all determinations without trigger nodes
  DELETE lt_det
    WHERE det_trigger IS NOT BOUND
       OR det_trigger->* IS INITIAL.

* ____________________________________________________________________ *
  " Remove det-confs for dets without trigger that have been removed above
  lt_sortednet = it_detnet.
  LOOP AT lt_sortednet INTO ls_curr_detnet.
    READ TABLE lt_det WITH KEY det_key = ls_curr_detnet-det_key_to TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE lt_sortednet.
    ELSE.
      READ TABLE lt_det WITH KEY det_key = ls_curr_detnet-det_key_from TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        DELETE lt_sortednet.
      ENDIF.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
  " distribute determinations and dependencies according to different models
  IF lines( ct_models ) = 1.
    READ TABLE ct_models INDEX 1 ASSIGNING <ls_models>.
    <ls_models>-det_list = lt_det.
    <ls_models>-det_net  = lt_sortednet.
  ELSE.
    LOOP AT it_det ASSIGNING <ls_db_det>.
      READ TABLE ct_models ASSIGNING <ls_models>
        WITH KEY bo_name = <ls_db_det>-name.
      ASSERT sy-subrc = 0.
      READ TABLE lt_det ASSIGNING <ls_det>
        WITH KEY det_key = <ls_db_det>-det_key.
      CHECK sy-subrc = 0.
      APPEND <ls_det> TO <ls_models>-det_list.
    ENDLOOP.
    LOOP AT lt_sortednet INTO ls_curr_detnet.
      READ TABLE ct_models ASSIGNING <ls_models>
        WITH KEY bo_name = ls_curr_detnet-name.
      CHECK sy-subrc = 0.
      INSERT ls_curr_detnet INTO TABLE <ls_models>-det_net.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
  " determine all models that are linked via dependencies
  IF lines( ct_models ) > 1.
    " create one group for all non-extension models
    APPEND ls_model_group TO lt_model_group ASSIGNING <ls_model_group>.
    LOOP AT ct_models ASSIGNING <ls_models>
      WHERE extension = abap_false.
      APPEND <ls_models>-bo_name TO <ls_model_group>-line_type.
    ENDLOOP.
    IF lines( <ls_model_group>-line_type ) = 1. " no projections found
      CLEAR lt_model_group.
    ENDIF.

    LOOP AT lt_sortednet INTO ls_detnet.
      CLEAR: lv_name_source, lv_name_target.
      " search source of dependency
      LOOP AT ct_models ASSIGNING <ls_models>.
        READ TABLE <ls_models>-det_list TRANSPORTING NO FIELDS
          WITH KEY det_key = ls_detnet-det_key_from.
        IF sy-subrc = 0.
          lv_name_source = <ls_models>-bo_name.
          EXIT.
        ENDIF.
      ENDLOOP.
      " search target of dependency
      LOOP AT ct_models ASSIGNING <ls_models>.
        READ TABLE <ls_models>-det_list TRANSPORTING NO FIELDS
          WITH KEY det_key = ls_detnet-det_key_to.
        IF sy-subrc = 0.
          lv_name_target = <ls_models>-bo_name.
          EXIT.
        ENDIF.
      ENDLOOP.
      " write new model group if object names differ
      IF lv_name_source <> lv_name_target OR
         lv_name_source <> ls_detnet-name OR
         lv_name_target <> ls_detnet-name.
        CLEAR ls_model_group.
        APPEND lv_name_source TO ls_model_group-line_type.
        APPEND lv_name_target TO ls_model_group-line_type.
        APPEND ls_detnet-name TO ls_model_group-line_type.
        SORT ls_model_group-line_type.
        DELETE ADJACENT DUPLICATES FROM ls_model_group-line_type.
        APPEND ls_model_group TO lt_model_group.
      ENDIF.
    ENDLOOP.

    "delete dublicated groups due to dependencies
    SORT lt_model_group BY line_type.
    DELETE ADJACENT DUPLICATES FROM lt_model_group COMPARING line_type.
  ENDIF.

* ____________________________________________________________________ *
  " merge all groups that are linked by the same models
  IF lines( lt_model_group ) > 1.
    LOOP AT lt_model_group ASSIGNING <ls_model_group>. " for every model group
      CHECK <ls_model_group>-line_type IS NOT INITIAL.
      lv_index = sy-tabix.
      LOOP AT <ls_model_group>-line_type INTO lv_name_source. " for every model within this group
        " search all following groups for same model
        LOOP AT lt_model_group ASSIGNING <ls_model_group_tmp> FROM lv_index + 1.
          CHECK <ls_model_group_tmp>-line_type IS NOT INITIAL.
          READ TABLE ls_model_group-line_type TRANSPORTING NO FIELDS
            WITH KEY table_line = lv_name_source.
          IF sy-subrc = 0. " found a group containing the same model -> merge into the first one
            APPEND LINES OF <ls_model_group_tmp>-line_type TO <ls_model_group>-line_type.
            CLEAR <ls_model_group_tmp>-line_type.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
    ENDLOOP.
    DELETE lt_model_group WHERE line_type IS INITIAL.
    LOOP AT lt_model_group ASSIGNING <ls_model_group>.
      SORT <ls_model_group>-line_type.
      DELETE ADJACENT DUPLICATES FROM <ls_model_group>-line_type.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
  " merge all models
  LOOP AT ct_models ASSIGNING <ls_models>.
    CHECK <ls_models>-det_list IS NOT INITIAL.

    " search groups containing this model (should be none or one due to the merge above)
    LOOP AT lt_model_group INTO ls_model_group.
      READ TABLE ls_model_group-line_type TRANSPORTING NO FIELDS
        WITH KEY table_line = <ls_models>-bo_name.
      IF sy-subrc = 0. " group found -> merge all models of the same group into this one
        LOOP AT ls_model_group-line_type INTO lv_name_source.
          CHECK lv_name_source <> <ls_models>-bo_name. " don't merge the same model into itself
          READ TABLE ct_models ASSIGNING <ls_models_tmp>
            WITH KEY bo_name = lv_name_source.
          ASSERT sy-subrc = 0.
          APPEND LINES OF <ls_models_tmp>-det_list TO <ls_models>-det_list.
          INSERT LINES OF <ls_models_tmp>-det_net INTO TABLE <ls_models>-det_net.
          CLEAR <ls_models_tmp>-det_list.
          CLEAR <ls_models_tmp>-det_net.
        ENDLOOP.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDLOOP.
  DELETE ct_models WHERE det_list IS INITIAL.

* ____________________________________________________________________ *
  " sort determinations according to dependencies
  LOOP AT ct_models ASSIGNING <ls_models>.
    " det list was sorted by name directly after the select
    " as models are als sorted by name the overall order is stable
    CLEAR: lt_det2, lt_det_sorted.

    " Determine all determinations, that do not have any predecessors
    LOOP AT <ls_models>-det_list INTO ls_curr_det.
      READ TABLE <ls_models>-det_net WITH KEY det_key_to = ls_curr_det-det_key TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        APPEND ls_curr_det TO lt_det2.
      ENDIF.
    ENDLOOP.
    " While there are determinations without successors
    WHILE lt_det2 IS NOT INITIAL.
      " Chose a determination and move it from temporary table to sorted table
      READ TABLE lt_det2 INDEX 1 INTO ls_curr_det.
      READ TABLE lt_det_sorted WITH KEY det_key = ls_curr_det-det_key TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        APPEND ls_curr_det TO lt_det_sorted.
      ENDIF.
      DELETE lt_det2 INDEX 1.
      " Loop over all outgoing dependencies of this determination
      LOOP AT <ls_models>-det_net INTO ls_curr_detnet USING KEY key2
        WHERE det_key_from = ls_curr_det-det_key.
        " Delete processed edge
        DELETE <ls_models>-det_net INDEX sy-tabix USING KEY key2.
        " Check if target of edge has any other incoming edges
        READ TABLE <ls_models>-det_net WITH KEY det_key_to = ls_curr_detnet-det_key_to TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          " When last edge was removed -> A new node without incoming edges was found, so append it
          READ TABLE <ls_models>-det_list WITH KEY det_key = ls_curr_detnet-det_key_to INTO ls_curr_det.
          APPEND ls_curr_det TO lt_det2.
        ENDIF.
      ENDLOOP.
    ENDWHILE.
    " If some edges are left -> Cycle was found
    IF <ls_models>-det_net IS NOT INITIAL.
      ASSERT ID /bobf/conf CONDITION 0 = 1.                "#EC BOOL_OK
      RAISE EXCEPTION TYPE /bobf/cx_conf
        EXPORTING
          textid     = /bobf/cx_conf=>det_net_inconsistent
          mv_bo_name = <ls_models>-det_net[ 1 ]-name.
    ENDIF.

    <ls_models>-det_list = lt_det_sorted.
  ENDLOOP.

* ____________________________________________________________________ *
  " fill determination-tables of table mt_exectime
  LOOP AT ct_models ASSIGNING <ls_models>.
    LOOP AT <ls_models>-det_list ASSIGNING <ls_det>.
      LOOP AT it_detconf ASSIGNING <ls_detconf>
        WHERE det_key = <ls_det>-det_key.
        " exec time specific constraints
        IF <ls_detconf>-exec_time = /bobf/if_conf_c=>sc_time_after_loading.
          READ TABLE <ls_det>-det_trigger->*
            WITH KEY load = abap_true
            TRANSPORTING NO FIELDS.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.
        ENDIF.
        " insert determination to exectime
        READ TABLE mt_exectime
          WITH KEY exectime = <ls_detconf>-exec_time
          ASSIGNING <ls_exectime>.
        IF <ls_exectime>-det_list IS NOT BOUND.
          CREATE DATA <ls_exectime>-det_list AREA HANDLE lo_area_handle.
        ENDIF.
        READ TABLE <ls_exectime>-det_list->*
          WITH KEY det_key = <ls_det>-det_key
          REFERENCE INTO ls_det_insert.
        IF sy-subrc <> 0.
          " determination is not yet in mt_exectime table
          APPEND <ls_det> TO <ls_exectime>-det_list->*
            REFERENCE INTO ls_det_insert.
          CREATE DATA ls_det_insert->node_cat AREA HANDLE lo_area_handle.
        ENDIF.
        ls_nodecat-node_cat_key = <ls_detconf>-node_cat_key.
        INSERT ls_nodecat INTO TABLE ls_det_insert->node_cat->*.
      ENDLOOP.
    ENDLOOP.
  ENDLOOP.

* ____________________________________________________________________ *
  " make sure that admin data determinations are always at the end
  READ TABLE mt_exectime
    WITH KEY exectime = /bobf/if_conf_c=>sc_time_before_save " finalize only
    ASSIGNING <ls_exectime>.
  IF sy-subrc = 0 AND
     <ls_exectime>-det_list IS BOUND.
    LOOP AT <ls_exectime>-det_list->* REFERENCE INTO ls_det_insert.
      IF ls_det_insert->det_cat = /bobf/if_conf_c=>sc_detcat_admin_data.
        APPEND ls_det_insert->* TO lt_det_tmp.
        DELETE <ls_exectime>-det_list->*.
      ENDIF.
    ENDLOOP.
    APPEND LINES OF lt_det_tmp TO <ls_exectime>-det_list->*.
  ENDIF.

* ____________________________________________________________________ *
  " filter node categories
  LOOP AT mt_exectime ASSIGNING <ls_exectime>.
    IF <ls_exectime>-det_list IS NOT BOUND.
      CREATE DATA <ls_exectime>-det_list AREA HANDLE lo_area_handle.
    ENDIF.
    LOOP AT <ls_exectime>-det_list->* ASSIGNING <ls_det>.
      DESCRIBE TABLE <ls_det>-node_cat->* LINES lv_ncat_det.
      READ TABLE mt_node
        WITH KEY node_key = <ls_det>-node_key
        ASSIGNING <ls_node>.
      DESCRIBE TABLE <ls_node>-node_cat->* LINES lv_ncat_all.
      IF lv_ncat_all = lv_ncat_det.
        " determination is allowed for all node categories
        FREE <ls_det>-node_cat->*.
      ENDIF.
      IF <ls_det>-det_cat = /bobf/if_conf_c=>sc_detcat_admin_data.
        <ls_det>-det_cat   = /bobf/if_conf_c=>sc_detcat_persistent.
        <ls_det>-edit_mode = /bobf/if_conf_c=>sc_edit_exclusive.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

* ____________________________________________________________________ *
  " determine attributes that are written by determinations after loading
  READ TABLE mt_exectime ASSIGNING <ls_exectime>
    WITH KEY exectime = /bobf/if_conf_c=>sc_time_after_loading.
  LOOP AT <ls_exectime>-det_list->* ASSIGNING <ls_det>.

    LOOP AT it_rtw INTO ls_rtw
      WHERE content_cat = /bobf/if_conf_c=>sc_content_det
        AND content_key = <ls_det>-det_key
        AND access_cat  = /bobf/if_conf_c=>sc_access_write.

*     get write node
      READ TABLE mt_node ASSIGNING <ls_node>
        WITH KEY node_key = ls_rtw-node_key.

      IF <ls_node>-det_load_attributes IS NOT BOUND.
        CREATE DATA <ls_node>-det_load_attributes AREA HANDLE lo_area_handle.
      ELSEIF <ls_node>-det_load_attributes->* IS INITIAL.
*       emtpy table does already exist
*       -> there was already a write node processed without any attribute information
*       -> do not fill any attributes
        CONTINUE.
      ENDIF.

*     add defined attributes
      LOOP AT it_rtw_a INTO ls_rtw_a
        WHERE rtw_key = ls_rtw-rtw_key.
        APPEND ls_rtw_a-attribute_name TO <ls_node>-det_load_attributes->*.
      ENDLOOP.

      IF sy-subrc <> 0.
*       no attributes defined for this write node
*       -> clear attribute information of former write nodes
*       -> ignore authority determinations, because they don't need an attribute assignment
        IF <ls_det>-det_cat <> /bobf/if_conf_c=>sc_detcat_authority.
          CLEAR <ls_node>-det_load_attributes->*.
        ENDIF.
      ENDIF.

    ENDLOOP.

    IF sy-subrc <> 0.
*     no write node defined for this determination
*     -> ignore authority determinations, because they don't need an attribute assignment
      IF <ls_det>-det_cat <> /bobf/if_conf_c=>sc_detcat_authority.
*       -> assume write node is the node where determination is defined and clear attribute information for that node
        READ TABLE mt_node ASSIGNING <ls_node> WITH KEY node_key = <ls_det>-node_key.
*       -> clear attribute information collected from other write nodes
        IF <ls_node>-det_load_attributes IS NOT BOUND.
          CREATE DATA <ls_node>-det_load_attributes AREA HANDLE lo_area_handle.
        ENDIF.
        CLEAR <ls_node>-det_load_attributes->*.
      ENDIF.
    ENDIF.

*   remember if at least one authority determination exists
    IF <ls_det>-det_cat = /bobf/if_conf_c=>sc_detcat_authority.
      ms_obj-has_authority_dets = abap_true.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* check if two determination states (2+3) are needed
  IF ms_obj-objcat <> /bobf/if_conf_c=>sc_objcat_mo.
    READ TABLE mt_exectime ASSIGNING <ls_exectime>
      WITH KEY exectime = /bobf/if_conf_c=>sc_time_after_validation.
    IF <ls_exectime>-det_list->* IS INITIAL.
      ms_obj-last_det_state_not_relevant = abap_true.
*   Adjust state relations of det. after modify to state 3.
      READ TABLE mt_exectime ASSIGNING <ls_exectime>
        WITH KEY exectime = /bobf/if_conf_c=>sc_time_after_modify.
      <ls_exectime>-last_state = /bobf/if_conf_c=>sc_state_last_validated.
      CLEAR <ls_exectime>-new_state.
    ELSE.
      ms_obj-last_det_state_not_relevant = abap_false.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* remove determination and validation states for MOs
  IF ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_mo.
    READ TABLE mt_exectime ASSIGNING <ls_exectime>
      WITH KEY exectime = /bobf/if_conf_c=>sc_time_after_modify.
    <ls_exectime>-last_state = /bobf/if_conf_c=>sc_state_database.
    CLEAR <ls_exectime>-new_state.
    ms_obj-last_det_state_not_relevant = abap_true.

    READ TABLE mt_exectime ASSIGNING <ls_exectime>
      WITH KEY exectime = /bobf/if_conf_c=>sc_time_after_validation.
    <ls_exectime>-last_state = /bobf/if_conf_c=>sc_state_database.
    CLEAR <ls_exectime>-new_state.
    ms_obj-last_val_state_not_relevant = abap_true.
  ENDIF.

ENDMETHOD.


METHOD build_fieldmapping.

  DATA: ls_fm               TYPE REF TO /bobf/s_confro_mapping,
        lt_fieldmapping     TYPE tt_map,
        ls_fieldmapping     TYPE /bobf/obm_map,
        lv_delete_node      TYPE boole_d,
        lv_last_node_key    TYPE /bobf/obm_node_key,
        ls_map_nodecat_key  TYPE /bobf/obm_map,
        ls_map_key          TYPE /bobf/obm_map,
        ls_map_parent_key   TYPE /bobf/obm_map,
        ls_map_root_key     TYPE /bobf/obm_map,
        ls_map_node_key     TYPE /bobf/obm_map.

  IF it_fieldmapping IS SUPPLIED.
    " check for unnecessary persistency mappings
    lt_fieldmapping = it_fieldmapping.
    SORT lt_fieldmapping ASCENDING BY content_cat content_key fieldname_ext.

    CLEAR lv_last_node_key.
    LOOP AT lt_fieldmapping INTO ls_fieldmapping
      WHERE content_cat = /bobf/if_conf_c=>sc_content_per.

      IF lv_last_node_key = ls_fieldmapping-content_key.
        CONTINUE. " still on the same node
      ENDIF.

      CLEAR: ls_map_nodecat_key,
             ls_map_key,
             ls_map_parent_key,
             ls_map_root_key,
             ls_map_node_key.

      " at new node
      READ TABLE lt_fieldmapping INTO ls_map_key BINARY SEARCH
        WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                 content_key   = ls_fieldmapping-content_key
                 fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_key.

      READ TABLE lt_fieldmapping INTO ls_map_root_key BINARY SEARCH
        WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                 content_key   = ls_fieldmapping-content_key
                 fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_root_key.

      READ TABLE lt_fieldmapping INTO ls_map_parent_key BINARY SEARCH
        WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                 content_key   = ls_fieldmapping-content_key
                 fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_parent_key.

      READ TABLE lt_fieldmapping INTO ls_map_nodecat_key BINARY SEARCH
        WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                 content_key   = ls_fieldmapping-content_key
                 fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_node_cat_key.

      READ TABLE lt_fieldmapping INTO ls_map_node_key BINARY SEARCH
        WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                 content_key   = ls_fieldmapping-content_key
                 fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_node_key.

      IF ls_map_key-fieldname_int = /bobf/if_conf_c=>sc_attribute_name_db_key
        AND
         ( ls_map_root_key IS INITIAL OR
           ls_map_root_key-fieldname_int = /bobf/if_conf_c=>sc_attribute_name_root_key OR
           ls_map_root_key-fieldname_int = /bobf/if_conf_c=>sc_attribute_name_parent_key )
        AND
         ( ls_map_parent_key IS INITIAL OR
           ls_map_parent_key-fieldname_int = /bobf/if_conf_c=>sc_attribute_name_parent_key )
        AND
         ls_map_nodecat_key IS INITIAL AND
         ls_map_node_key    IS INITIAL.
        " delete all persistency node mappings for this node
        DELETE lt_fieldmapping
          WHERE content_cat   = /bobf/if_conf_c=>sc_content_per
            AND content_key   = ls_fieldmapping-content_key.
      ENDIF.

      lv_last_node_key = ls_fieldmapping-content_key.
    ENDLOOP.

    " convert into mt_fieldmapping
    CREATE DATA ls_fm.
    LOOP AT lt_fieldmapping INTO ls_fieldmapping.
      MOVE-CORRESPONDING ls_fieldmapping TO ls_fm->*.
      IF ls_fieldmapping-const_interface IS NOT INITIAL.
        CONCATENATE ls_fieldmapping-const_interface '=>' ls_fieldmapping-fieldname_int INTO ls_fm->constant.
        CLEAR ls_fm->fieldname_int.
      ELSE.
        CLEAR ls_fm->constant.
      ENDIF.
      INSERT ls_fm->* INTO TABLE mt_fieldmapping.
    ENDLOOP.
  ENDIF.

  IF is_fieldmapping IS NOT SUPPLIED.
    LOOP AT mt_fieldmapping REFERENCE INTO ls_fm
      WHERE fieldname_ext_long IS INITIAL.              "#EC CI_SORTSEQ

      IF ls_fm->hierarchy_key IS NOT INITIAL.
        build_fieldmapping( is_fieldmapping = ls_fm ).
      ELSE.
        ls_fm->fieldname_ext_long = ls_fm->fieldname_ext.
      ENDIF.
    ENDLOOP.

  ELSE.
*   recursion
    READ TABLE mt_fieldmapping
      WITH KEY map_key = is_fieldmapping->hierarchy_key
      REFERENCE INTO ls_fm.                             "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      IF ls_fm->hierarchy_key IS NOT INITIAL.
        build_fieldmapping( is_fieldmapping = ls_fm ).
        CONCATENATE ls_fm->fieldname_ext_long '-'
                    is_fieldmapping->fieldname_ext
               INTO is_fieldmapping->fieldname_ext_long.
      ELSE.
        CONCATENATE ls_fm->fieldname_ext '-'
                    is_fieldmapping->fieldname_ext
               INTO is_fieldmapping->fieldname_ext_long.
      ENDIF.
    ELSE.
      ASSERT ID /bobf/conf CONDITION 0 = 1.                "#EC BOOL_OK
    ENDIF.

  ENDIF.

ENDMETHOD.


METHOD build_node.

  TYPES:
    BEGIN OF ty_dependent_db_node_keys,
      node_key               TYPE /bobf/obm_node_key,
      dependent_db_node_keys TYPE /bobf/t_frw_node_only,
    END OF ty_dependent_db_node_keys,
    tt_dependent_db_node_keys TYPE STANDARD TABLE OF ty_dependent_db_node_keys.

  DATA:
    ls_node                   TYPE /bobf/obm_node,
    ls_node2                  TYPE /bobf/obm_node,
    ls_sta_schema             TYPE /bobf/sta_schema,
    ls_node_conf              TYPE /bobf/s_confro_node,
    lv_type_name              TYPE tabname,
    lt_descr                  TYPE TABLE OF x031l,
    ls_descr                  TYPE x031l,
    ls_descr_last             TYPE x031l,
    lt_stack                  TYPE TABLE OF fieldname,
    lv_stack                  TYPE fieldname,
    lv_field_name             TYPE string,
    ls_node_cat               TYPE /bobf/obm_ncat,
    ls_node_cat_conf          TYPE /bobf/s_confro_node_cat,
    ls_auth_obj               TYPE /bobf/auth_obj,
    ls_acf_map                TYPE /bobf/acf_map,
    ls_acf_map_conf           TYPE /bobf/s_confro_acf_mapping,
    ls_altkey_conf            TYPE /bobf/s_confro_altkey,
    ls_assoc_conf             TYPE /bobf/s_confro_assoc,
    ls_sta_assoc_conf         TYPE /bobf/s_confro_assoc3,
    lv_node_key               TYPE /bobf/obm_node_key,
    ls_node_only              TYPE /bobf/s_frw_node_only,
    ls_mapping                TYPE /bobf/s_confro_mapping,
    ls_dependent_db_node_keys TYPE ty_dependent_db_node_keys,
    lt_dependent_db_node_keys TYPE tt_dependent_db_node_keys,
    lo_area_handle            TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS:
    <ls_node_conf>              TYPE /bobf/s_confro_node,
    <ls_node_conf2>             TYPE /bobf/s_confro_node,
    <ls_dependent_db_node_keys> TYPE ty_dependent_db_node_keys.


  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

  LOOP AT it_node INTO ls_node.

    IF ls_node-subtree_property = abap_true.
      ms_obj-subtree_property = abap_true.
    ENDIF.

    CLEAR ls_node_conf.
    MOVE-CORRESPONDING ls_node TO ls_node_conf.
    ls_node_conf-has_trans_fields = boolc( ls_node-data_data_type_t IS NOT INITIAL ).
    ls_node_conf-has_auth_determ = boolc( line_exists( it_det[ node_key = ls_node-node_key det_cat = /bobf/if_conf_c=>sc_detcat_authority ] ) ).

    "replacing the reference BO key with the bo key of the root BO key of the inheritance hierarchy
    adapt_ref_bo_key( CHANGING cv_bo_key = ls_node_conf-ref_bo_key ).

    "handling GENIL prefix
    IF ms_obj-genil_prefix             IS NOT INITIAL AND
       ls_node_conf-node_genil_name    IS NOT INITIAL AND
       ls_node_conf-node_type <> /bobf/if_conf_c=>sc_node_type_do.
      CONCATENATE ms_obj-genil_prefix
                  gc_genil_separator
                  ls_node_conf-node_genil_name
             INTO ls_node_conf-node_genil_name.
    ENDIF.

    CREATE DATA ls_node_conf-dependent_db_node_keys AREA HANDLE lo_area_handle.
    CREATE DATA ls_node_conf-node_cat               AREA HANDLE lo_area_handle.

*   delete status nodes if no status class is maintained
    IF ms_obj-status_class IS INITIAL AND
       ls_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_status.
      LOOP AT mt_assoc INTO ls_assoc_conf USING KEY key2
        WHERE source_node_key = ls_node_conf-node_key.
        DELETE ct_rtw   WHERE assoc_key = ls_assoc_conf-assoc_key. "#EC CI_SORTSEQ
        DELETE mt_assoc WHERE assoc_key = ls_assoc_conf-assoc_key.
      ENDLOOP.
      DELETE mt_assoc WHERE target_node_key = ls_node_conf-node_key. "#EC CI_SORTSEQ
      CONTINUE.

    ELSEIF ls_node-sta_child_assoc  IS NOT INITIAL AND
           ls_node-sta_parent_assoc IS NOT INITIAL.
      READ TABLE mt_assoc INTO ls_assoc_conf
        WITH KEY assoc_key = ls_node-sta_parent_assoc.
      MOVE-CORRESPONDING ls_assoc_conf TO ls_sta_assoc_conf.
      ls_sta_assoc_conf-sta_assoc_cat   = /bobf/if_conf_c=>sc_sta_assoccat_parent.
      INSERT ls_sta_assoc_conf INTO TABLE mt_sta_assoc.
      READ TABLE mt_assoc INTO ls_assoc_conf
        WITH KEY assoc_key = ls_node-sta_child_assoc.
      MOVE-CORRESPONDING ls_assoc_conf TO ls_sta_assoc_conf.
      ls_sta_assoc_conf-sta_assoc_cat   = /bobf/if_conf_c=>sc_sta_assoccat_child.
      INSERT ls_sta_assoc_conf INTO TABLE mt_sta_assoc.
    ENDIF.

*   set proxy business objectname for internal business object representation nodes
    IF ls_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_bo AND
       ls_node_conf-node_esr_name IS INITIAL AND
       ms_obj-bo_esr_name IS NOT INITIAL.
      ls_node_conf-node_esr_name = ls_node_conf-node_name.
    ENDIF.

*   determine subtree property node
    IF ls_node-node_key <> ms_obj-root_node_key AND
       ( ls_node-node_type = /bobf/if_conf_c=>sc_node_type_normal OR
         ls_node-node_type = /bobf/if_conf_c=>sc_node_type_status OR
         ls_node-node_type = /bobf/if_conf_c=>sc_node_type_do ).
      ls_node2 = ls_node.

      DO.
        READ TABLE mt_assoc INTO ls_assoc_conf
          WITH KEY target_node_key = ls_node2-node_key
                   assoc_type      = /bobf/if_conf_c=>sc_assoctype_comp. "#EC CI_SORTSEQ
        IF sy-subrc <> 0.
          ASSERT ID /bobf/conf CONDITION 0 = 1.            "#EC BOOL_OK
          EXIT.
        ENDIF.
        READ TABLE it_node INTO ls_node2
          WITH KEY node_key = ls_assoc_conf-source_node_key.
        IF sy-subrc <> 0.
          ASSERT ID /bobf/conf CONDITION 0 = 1.            "#EC BOOL_OK
          EXIT.
        ENDIF.

        IF ls_node2-subtree_property = abap_true.
          ls_node_conf-subtree_property_node_key = ls_node2-node_key.
          EXIT.
        ELSEIF ls_node2-node_key = ms_obj-root_node_key.
          EXIT.
        ENDIF.
      ENDDO.
    ENDIF.

    INSERT ls_node_conf INTO TABLE mt_node ASSIGNING <ls_node_conf>.

*   check if node is used as check trigger
    READ TABLE ct_rtw TRANSPORTING NO FIELDS
      WITH KEY access_cat    = /bobf/if_conf_c=>sc_access_trigger
               content_cat   = /bobf/if_conf_c=>sc_content_val
               node_key      = <ls_node_conf>-node_key
               trigger_check = abap_true.               "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      <ls_node_conf>-check_trigger = abap_true.
    ENDIF.

*   add field names (not for framework nodes)
    IF <ls_node_conf>-node_type <> /bobf/if_conf_c=>sc_node_type_message  AND
       <ls_node_conf>-node_type <> /bobf/if_conf_c=>sc_node_type_property AND
       <ls_node_conf>-node_type <> /bobf/if_conf_c=>sc_node_type_lock.

      IF <ls_node_conf>-use_proxy_type = abap_false.
        lv_type_name = <ls_node_conf>-data_type.
      ELSE.
        lv_type_name = <ls_node_conf>-prx_dat_dat_type.
      ENDIF.

      CLEAR lt_descr.
      IF lv_type_name IS NOT INITIAL.
        CALL FUNCTION 'DDIF_NAMETAB_GET'
          EXPORTING
            tabname   = lv_type_name
            all_types = abap_true
          TABLES
            x031l_tab = lt_descr
          EXCEPTIONS
            not_found = 0.

        IF <ls_node_conf>-use_proxy_type = abap_false.
          DELETE lt_descr WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_key.
          DELETE lt_descr WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_parent_key.
          DELETE lt_descr WHERE fieldname = /bobf/if_conf_c=>sc_attribute_name_root_key.
        ENDIF.
      ENDIF.

      CLEAR lt_stack.
      LOOP AT lt_descr INTO ls_descr
        WHERE dtyp <> 'TTAB'.
        IF ls_descr-depth > ls_descr_last-depth.
          APPEND ls_descr_last-fieldname TO lt_stack.
        ELSEIF ls_descr-depth < ls_descr_last-depth.
          DO ls_descr_last-depth - ls_descr-depth TIMES.
            DELETE lt_stack INDEX ls_descr_last-depth - sy-index + 1.
          ENDDO.
        ENDIF.

        IF ls_descr-dtyp <> 'STR2'.
          CLEAR lv_field_name.
          LOOP AT lt_stack INTO lv_stack.
            CONCATENATE lv_field_name lv_stack '-' INTO lv_field_name.
          ENDLOOP.
          CONCATENATE lv_field_name ls_descr-fieldname INTO lv_field_name.
          IF <ls_node_conf>-field_names IS NOT BOUND.
            CREATE DATA <ls_node_conf>-field_names AREA HANDLE lo_area_handle.
          ENDIF.
          APPEND lv_field_name TO <ls_node_conf>-field_names->*.
        ENDIF.

        ls_descr_last = ls_descr.
      ENDLOOP.

      <ls_node_conf>-internal_properties = build_node_internal_props(
        EXPORTING
          io_area_handle       = lo_area_handle
          iv_objcat            = ms_obj-objcat
          it_field_descr       = lt_descr
      ).

    ENDIF.

    " calculate determination trigger attributes (aka request attributes).
    " needed for stateless performance optimization...
    build_node_det_trigger_attr(
      EXPORTING
        is_node_conf               = <ls_node_conf>
        it_det                     = it_det
        it_rtw                     = ct_rtw
        it_rtw_a_trigger           = it_rtw_a_trigger
      IMPORTING
        ev_trigger_attr_create_all = DATA(lv_det_trigger_attr_create_all)
        ev_trigger_attr_update_all = DATA(lv_det_trigger_attr_update_all)
        ev_trigger_attr_delete_all = DATA(lv_det_trigger_attr_delete_all)
        et_trigger_attr_create     = DATA(lt_det_trigger_attr_create)
        et_trigger_attr_update     = DATA(lt_det_trigger_attr_update)
        et_trigger_attr_delete     = DATA(lt_det_trigger_attr_delete) ).
    <ls_node_conf>-det_trigger_attr_create_all = lv_det_trigger_attr_create_all.
    <ls_node_conf>-det_trigger_attr_update_all = lv_det_trigger_attr_update_all.
    <ls_node_conf>-det_trigger_attr_delete_all = lv_det_trigger_attr_delete_all.
    IF <ls_node_conf>-det_trigger_attr_create IS NOT BOUND.
      CREATE DATA <ls_node_conf>-det_trigger_attr_create AREA HANDLE lo_area_handle.
    ENDIF.
    IF <ls_node_conf>-det_trigger_attr_update IS NOT BOUND.
      CREATE DATA <ls_node_conf>-det_trigger_attr_update AREA HANDLE lo_area_handle.
    ENDIF.
    IF <ls_node_conf>-det_trigger_attr_delete IS NOT BOUND.
      CREATE DATA <ls_node_conf>-det_trigger_attr_delete AREA HANDLE lo_area_handle.
    ENDIF.
    INSERT LINES OF lt_det_trigger_attr_create INTO TABLE <ls_node_conf>-det_trigger_attr_create->*.
    INSERT LINES OF lt_det_trigger_attr_update INTO TABLE <ls_node_conf>-det_trigger_attr_update->*.
    INSERT LINES OF lt_det_trigger_attr_delete INTO TABLE <ls_node_conf>-det_trigger_attr_delete->*.

    " calculate validation trigger attributes (aka request attributes).
    " needed for stateless performance optimization...
    build_node_val_trigger_attr(
      EXPORTING
        is_node_conf               = <ls_node_conf>
        it_val                     = it_val
        it_rtw                     = ct_rtw
        it_rtw_a_trigger           = it_rtw_a_trigger
      IMPORTING
        ev_trigger_attr_create_all = DATA(lv_val_trigger_attr_create_all)
        ev_trigger_attr_update_all = DATA(lv_val_trigger_attr_update_all)
        ev_trigger_attr_delete_all = DATA(lv_val_trigger_attr_delete_all)
        et_trigger_attr_create     = DATA(lt_val_trigger_attr_create)
        et_trigger_attr_update     = DATA(lt_val_trigger_attr_update)
        et_trigger_attr_delete     = DATA(lt_val_trigger_attr_delete) ).
    <ls_node_conf>-val_trigger_attr_create_all = lv_val_trigger_attr_create_all.
    <ls_node_conf>-val_trigger_attr_update_all = lv_val_trigger_attr_update_all.
    <ls_node_conf>-val_trigger_attr_delete_all = lv_val_trigger_attr_delete_all.
    IF <ls_node_conf>-val_trigger_attr_create IS NOT BOUND.
      CREATE DATA <ls_node_conf>-val_trigger_attr_create AREA HANDLE lo_area_handle.
    ENDIF.
    IF <ls_node_conf>-val_trigger_attr_update IS NOT BOUND.
      CREATE DATA <ls_node_conf>-val_trigger_attr_update AREA HANDLE lo_area_handle.
    ENDIF.
    IF <ls_node_conf>-val_trigger_attr_delete IS NOT BOUND.
      CREATE DATA <ls_node_conf>-val_trigger_attr_delete AREA HANDLE lo_area_handle.
    ENDIF.
    INSERT LINES OF lt_val_trigger_attr_create INTO TABLE <ls_node_conf>-val_trigger_attr_create->*.
    INSERT LINES OF lt_val_trigger_attr_update INTO TABLE <ls_node_conf>-val_trigger_attr_update->*.
    INSERT LINES OF lt_val_trigger_attr_delete INTO TABLE <ls_node_conf>-val_trigger_attr_delete->*.

    IF <ls_node_conf>-use_proxy_type = abap_true.
*     set usage of proxy types (default as not available at design time yet)
      ls_altkey_conf-use_proxy_type = abap_true.
      MODIFY mt_altkey FROM ls_altkey_conf USING KEY key2 TRANSPORTING use_proxy_type
        WHERE node_key = <ls_node_conf>-node_key
        AND   altkey_esr_name IS NOT INITIAL.
*     set internal model
      <ls_node_conf>-data_data_type = <ls_node_conf>-prx_dat_dat_type.
      <ls_node_conf>-data_type      = <ls_node_conf>-gdt_data_type.
    ENDIF.

    IF <ls_node_conf>-database_table IS NOT INITIAL.    "#EC CI_SORTSEQ
*     add db grouping information to node
      IF <ls_node_conf>-mapper_class IS INITIAL.
        <ls_node_conf>-mapper_class = ms_obj-mapper_class.
      ENDIF.
      <ls_node_conf>-lead_db_node_key = <ls_node_conf>-node_key.
      READ TABLE lt_dependent_db_node_keys ASSIGNING <ls_dependent_db_node_keys>
        WITH KEY node_key = <ls_node_conf>-node_key.
      IF sy-subrc = 0.
        <ls_node_conf>-dependent_db_node_keys->* = <ls_dependent_db_node_keys>-dependent_db_node_keys.
        DELETE lt_dependent_db_node_keys
          WHERE node_key = <ls_dependent_db_node_keys>-node_key.
      ENDIF.
*     precondition (as currently defined)
      IF <ls_node_conf>-key_inherited = abap_false OR
         <ls_node_conf>-loadable      = abap_true.
        CONTINUE.
      ENDIF.
*     check if parent node is on the same database table and managed by the same DAC
      lv_node_key = <ls_node_conf>-node_key.
      DO.
*       using source node and assoc cat
        READ TABLE mt_assoc WITH KEY key3
          COMPONENTS source_node_key = lv_node_key
                     assoc_cat       = /bobf/if_conf_c=>sc_assoccat_parent
          INTO ls_assoc_conf.
        IF sy-subrc <> 0.
          EXIT.
        ELSE.
          READ TABLE it_node INTO ls_node2
            WITH KEY node_key = ls_assoc_conf-target_node_key.
          IF <ls_node_conf>-database_table = ls_node2-database_table AND
             ( ( <ls_node_conf>-mapper_class = ls_node2-mapper_class ) OR
               ( ls_node2-mapper_class IS INITIAL AND <ls_node_conf>-mapper_class = ms_obj-mapper_class ) ).
            lv_node_key = ls_node2-node_key.
          ELSE.
            EXIT.
          ENDIF.
        ENDIF.
      ENDDO.
      <ls_node_conf>-lead_db_node_key = lv_node_key.

*     add information of dependent db node to lead db node
      IF <ls_node_conf>-lead_db_node_key <> <ls_node_conf>-node_key.
        ls_node_only-node = <ls_node_conf>-node_key.
        READ TABLE mt_node ASSIGNING <ls_node_conf2>
          WITH KEY node_key = <ls_node_conf>-lead_db_node_key.
        IF sy-subrc = 0.
          IF <ls_node_conf2>-dependent_db_node_keys IS NOT BOUND.
            CREATE DATA <ls_node_conf2>-dependent_db_node_keys AREA HANDLE lo_area_handle.
          ENDIF.
          INSERT ls_node_only INTO TABLE <ls_node_conf2>-dependent_db_node_keys->*.
        ELSE.
          READ TABLE lt_dependent_db_node_keys ASSIGNING <ls_dependent_db_node_keys>
            WITH KEY node_key = <ls_node_conf>-lead_db_node_key.
          IF sy-subrc <> 0.
            CLEAR ls_dependent_db_node_keys.
            ls_dependent_db_node_keys-node_key = <ls_node_conf>-lead_db_node_key.
            APPEND ls_dependent_db_node_keys TO lt_dependent_db_node_keys ASSIGNING <ls_dependent_db_node_keys>.
          ENDIF.
          INSERT ls_node_only INTO TABLE <ls_dependent_db_node_keys>-dependent_db_node_keys.
        ENDIF.

*       add parent and root attributes for dependent db nodes
        READ TABLE mt_fieldmapping INTO ls_mapping      "#EC CI_SORTSEQ
          WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                   content_key   = <ls_node_conf>-lead_db_node_key
                   fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_key.
        IF sy-subrc = 0.
          ls_mapping-content_key   = <ls_node_conf>-node_key.
          ls_mapping-fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_parent_key.
*         check for existing entries
          READ TABLE mt_fieldmapping TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_mapping-content_cat
                     content_key   = ls_mapping-content_key
                     fieldname_ext = ls_mapping-fieldname_ext.
          IF sy-subrc <> 0.
            INSERT ls_mapping INTO TABLE mt_fieldmapping.
          ENDIF.
        ENDIF.
        READ TABLE mt_fieldmapping INTO ls_mapping      "#EC CI_SORTSEQ
          WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_per
                   content_key   = <ls_node_conf>-lead_db_node_key
                   fieldname_ext = /bobf/if_conf_c=>sc_attribute_name_root_key.
        IF sy-subrc = 0.
          ls_mapping-content_key   = <ls_node_conf>-node_key.
*         check for existing entries
          READ TABLE mt_fieldmapping TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_mapping-content_cat
                     content_key   = ls_mapping-content_key
                     fieldname_ext = ls_mapping-fieldname_ext.
          IF sy-subrc <> 0.
            INSERT ls_mapping INTO TABLE mt_fieldmapping.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

* add associations to nodes to be deleted if node is deleted
  LOOP AT mt_assoc INTO ls_assoc_conf WHERE assoc_type = /bobf/if_conf_c=>sc_assoctype_comp. "#EC CI_SORTSEQ
    READ TABLE mt_node ASSIGNING <ls_node_conf> WITH KEY
        node_key = ls_assoc_conf-source_node_key.
    IF <ls_node_conf>-delete_associations IS NOT BOUND.
      CREATE DATA <ls_node_conf>-delete_associations AREA HANDLE lo_area_handle.
    ENDIF.
    APPEND ls_assoc_conf-assoc_key TO <ls_node_conf>-delete_associations->*.
  ENDLOOP.

  LOOP AT mt_sta_assoc INTO ls_sta_assoc_conf WHERE sta_assoc_cat = /bobf/if_conf_c=>sc_sta_assoccat_child. "#EC CI_SORTSEQ
    READ TABLE mt_node ASSIGNING <ls_node_conf> WITH KEY
        node_key = ls_sta_assoc_conf-source_node_key.
    IF <ls_node_conf>-delete_associations IS NOT BOUND.
      CREATE DATA <ls_node_conf>-delete_associations AREA HANDLE lo_area_handle.
    ENDIF.
    APPEND ls_sta_assoc_conf-assoc_key TO <ls_node_conf>-delete_associations->*.
  ENDLOOP.

* add relevant node categories
  LOOP AT it_node_cat INTO ls_node_cat.
    READ TABLE mt_node
      WITH TABLE KEY node_key = ls_node_cat-node_key
      ASSIGNING <ls_node_conf>.
    IF sy-subrc = 0.
      MOVE-CORRESPONDING ls_node_cat TO ls_node_cat_conf.
      READ TABLE it_sta_schema INTO ls_sta_schema WITH KEY sta_schema_key = ls_node_cat-stat_schema_key.
      IF sy-subrc = 0.
        IF ls_sta_schema-schema_esr_name IS NOT INITIAL.
          ls_node_cat_conf-status_schema = ls_sta_schema-schema_esr_name.
        ELSE.
          ls_node_cat_conf-status_schema = ls_sta_schema-schema_name.
        ENDIF.
      ENDIF.

      INSERT ls_node_cat_conf INTO TABLE <ls_node_conf>-node_cat->*.
    ENDIF.
  ENDLOOP.

* add auth objects
  LOOP AT it_auth_obj INTO ls_auth_obj.
    READ TABLE mt_node
      WITH TABLE KEY node_key = ls_auth_obj-node_key
      ASSIGNING <ls_node_conf>.
    IF sy-subrc = 0.
      IF <ls_node_conf>-auth_obj_names IS NOT BOUND.
        CREATE DATA <ls_node_conf>-auth_obj_names AREA HANDLE lo_area_handle.
      ENDIF.
      APPEND ls_auth_obj-auth_obj_name TO <ls_node_conf>-auth_obj_names->*.
    ENDIF.
  ENDLOOP.

* add ACF mapping
  LOOP AT it_acf_map INTO ls_acf_map.
    READ TABLE mt_node
      WITH TABLE KEY node_key = ls_acf_map-node_key
      ASSIGNING <ls_node_conf>.
    IF sy-subrc = 0.
      MOVE-CORRESPONDING ls_acf_map TO ls_acf_map_conf.
      IF <ls_node_conf>-acf_mapping IS NOT BOUND.
        CREATE DATA <ls_node_conf>-acf_mapping AREA HANDLE lo_area_handle.
      ENDIF.
      APPEND ls_acf_map_conf TO <ls_node_conf>-acf_mapping->*.
    ENDIF.
  ENDLOOP.

* determine and add SQL view name for CDS view name...
  LOOP AT mt_node ASSIGNING <ls_node_conf> WHERE object_model_cds_view_name IS NOT INITIAL.
    cl_dd_ddl_handler_factory=>create( )->get_viewname_from_entityname(
      EXPORTING
        ddnames        = VALUE #( ( name = <ls_node_conf>-object_model_cds_view_name ) )
      IMPORTING
        view_of_entity = DATA(lt_view_of_entity) ).
    CHECK lt_view_of_entity IS NOT INITIAL.
    <ls_node_conf>-object_model_sql_view_name = lt_view_of_entity[ 1 ]-viewname.
  ENDLOOP.

* set union DAC indication...
  LOOP AT mt_node ASSIGNING <ls_node_conf> WHERE mapper_class = /bobf/if_conf_def_classes_c=>gc_cl_dac_union
                                              OR mapper_class = /bobf/if_conf_def_classes_c=>gc_cl_dac_table_union.
    <ls_node_conf>-union_dac = abap_true.
  ENDLOOP.

ENDMETHOD.


  METHOD build_node_det_trigger_attr.

    " >>>>> calculate determination trigger attributes (aka request attributes).
    " >>>>> needed for stateless performance optimization...


    " initialize...
    ev_trigger_attr_create_all = abap_false.
    ev_trigger_attr_update_all = abap_false.
    ev_trigger_attr_delete_all = abap_false.
    CLEAR et_trigger_attr_create.
    CLEAR et_trigger_attr_update.
    CLEAR et_trigger_attr_delete.


    " don't calculate trigger attributes for framework nodes...
    IF   is_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_message
      OR is_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_property
      OR is_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_lock.
      RETURN. " !!!
    ENDIF.


    " calculate determination trigger attributes...
    LOOP AT it_rtw ASSIGNING FIELD-SYMBOL(<ls_rtw>)
      WHERE   bo_key         = mv_bo_key
        AND   node_key       = is_node_conf-node_key
        AND   content_cat    = /bobf/if_conf_c=>sc_content_det
        AND   access_cat     = /bobf/if_conf_c=>sc_access_trigger
        AND ( trigger_create = abap_true
           OR trigger_update = abap_true
           OR trigger_delete = abap_true ).

      " cross-check content key with determination key...
      READ TABLE it_det ASSIGNING FIELD-SYMBOL(<ls_det>)
        WITH KEY det_key = <ls_rtw>-content_key.
      CHECK sy-subrc = 0.

      " ignore transient and sys admin data determinations...
      CHECK <ls_det>-det_cat   =  /bobf/if_conf_c=>sc_detcat_persistent
        AND <ls_det>-det_class <> /bobf/if_conf_def_classes_c=>gc_cl_admin_data
        AND <ls_det>-det_class <> /bobf/if_conf_def_classes_c=>gc_cl_admin_data_tsm
        AND <ls_det>-det_name  <> /bobf/if_conf_cds_link_c=>gc_determination_name-draft-central_admin_data.

      LOOP AT it_rtw_a_trigger ASSIGNING FIELD-SYMBOL(<ls_rtw_a_trigger>)
        WHERE rtw_key = <ls_rtw>-rtw_key.
        IF <ls_rtw>-trigger_create = abap_true.
          INSERT CONV #( <ls_rtw_a_trigger>-attribute_name ) INTO TABLE et_trigger_attr_create.
        ENDIF.
        IF <ls_rtw>-trigger_update = abap_true.
          INSERT CONV #( <ls_rtw_a_trigger>-attribute_name ) INTO TABLE et_trigger_attr_update.
        ENDIF.
        IF <ls_rtw>-trigger_delete = abap_true.
          INSERT CONV #( <ls_rtw_a_trigger>-attribute_name ) INTO TABLE et_trigger_attr_delete.
        ENDIF.
      ENDLOOP.

      IF sy-subrc <> 0.
        IF <ls_rtw>-trigger_create = abap_true.
          ev_trigger_attr_create_all = abap_true.
        ENDIF.
        IF <ls_rtw>-trigger_update = abap_true.
          ev_trigger_attr_update_all = abap_true.
        ENDIF.
        IF <ls_rtw>-trigger_delete = abap_true.
          ev_trigger_attr_delete_all = abap_true.
        ENDIF.
        EXIT. " !!!
      ENDIF.

    ENDLOOP.


    " consolidate result...
    IF ev_trigger_attr_create_all = abap_true.
      CLEAR et_trigger_attr_create.
    ELSE.
      SORT et_trigger_attr_create.
      DELETE ADJACENT DUPLICATES FROM et_trigger_attr_create.
    ENDIF.
    IF ev_trigger_attr_update_all = abap_true.
      CLEAR et_trigger_attr_update.
    ELSE.
      SORT et_trigger_attr_update.
      DELETE ADJACENT DUPLICATES FROM et_trigger_attr_update.
    ENDIF.
    IF ev_trigger_attr_delete_all = abap_true.
      CLEAR et_trigger_attr_delete.
    ELSE.
      SORT et_trigger_attr_delete.
      DELETE ADJACENT DUPLICATES FROM et_trigger_attr_delete.
    ENDIF.

  ENDMETHOD.


  METHOD build_node_internal_props.
    "Set IsActiveEntity as Update enabled false in draft scenarios

    DATA lt_internal_property TYPE /bobf/t_confro_prop_int.

    lt_internal_property = COND #(
      LET is_active_entity = VALUE #( it_field_descr[ fieldname = /bobf/if_conf_cds_link_c=>gc_element_name-draft-isactiveentity ] OPTIONAL ) IN
      WHEN iv_objcat = /bobf/if_conf_c=>sc_objcat_draft AND
           is_active_entity IS NOT INITIAL
      THEN VALUE #(
          ( field_name = is_active_entity-fieldname
            component  = is_active_entity-position
            property_name = /bobf/if_conf_c=>sc_property_name_update_enable
            value = abap_false ) ) ).

    CHECK lt_internal_property IS NOT INITIAL.
    IF io_area_handle IS BOUND.
      CREATE DATA rr_internal_property AREA HANDLE io_area_handle.
      rr_internal_property->* = lt_internal_property.
    ELSE.
      rr_internal_property = NEW #( lt_internal_property ).
    ENDIF.

  ENDMETHOD.


  METHOD build_node_val_trigger_attr.

    " >>>>> calculate validation trigger attributes (aka request attributes).
    " >>>>> needed for stateless performance optimization...


    " initialize...
    ev_trigger_attr_create_all = abap_false.
    ev_trigger_attr_update_all = abap_false.
    ev_trigger_attr_delete_all = abap_false.
    CLEAR et_trigger_attr_create.
    CLEAR et_trigger_attr_update.
    CLEAR et_trigger_attr_delete.


    " don't calculate trigger attributes for framework nodes...
    IF   is_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_message
      OR is_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_property
      OR is_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_lock.
      RETURN. " !!!
    ENDIF.


    " calculate validation trigger attributes...
    LOOP AT it_rtw ASSIGNING FIELD-SYMBOL(<ls_rtw>)
      WHERE   bo_key         = mv_bo_key
        AND   node_key       = is_node_conf-node_key
        AND   content_cat    = /bobf/if_conf_c=>sc_content_val
        AND   access_cat     = /bobf/if_conf_c=>sc_access_trigger
        AND ( trigger_create = abap_true
           OR trigger_update = abap_true
           OR trigger_delete = abap_true ).

      " cross-check content key with validation key...
      READ TABLE it_val WITH KEY val_key = <ls_rtw>-content_key TRANSPORTING NO FIELDS.
      CHECK sy-subrc = 0.

      LOOP AT it_rtw_a_trigger ASSIGNING FIELD-SYMBOL(<ls_rtw_a_trigger>)
        WHERE rtw_key = <ls_rtw>-rtw_key.
        IF <ls_rtw>-trigger_create = abap_true.
          INSERT CONV #( <ls_rtw_a_trigger>-attribute_name ) INTO TABLE et_trigger_attr_create.
        ENDIF.
        IF <ls_rtw>-trigger_update = abap_true.
          INSERT CONV #( <ls_rtw_a_trigger>-attribute_name ) INTO TABLE et_trigger_attr_update.
        ENDIF.
        IF <ls_rtw>-trigger_delete = abap_true.
          INSERT CONV #( <ls_rtw_a_trigger>-attribute_name ) INTO TABLE et_trigger_attr_delete.
        ENDIF.
      ENDLOOP.

      IF sy-subrc <> 0.
        IF <ls_rtw>-trigger_create = abap_true.
          ev_trigger_attr_create_all = abap_true.
        ENDIF.
        IF <ls_rtw>-trigger_update = abap_true.
          ev_trigger_attr_update_all = abap_true.
        ENDIF.
        IF <ls_rtw>-trigger_delete = abap_true.
          ev_trigger_attr_delete_all = abap_true.
        ENDIF.
      ENDIF.

      IF    ev_trigger_attr_create_all = abap_true
        AND ev_trigger_attr_update_all = abap_true
        AND ev_trigger_attr_delete_all = abap_true.
        EXIT. " save runtime...
      ENDIF.

    ENDLOOP.


    " consolidate result...
    IF ev_trigger_attr_create_all = abap_true.
      CLEAR et_trigger_attr_create.
    ELSE.
      SORT et_trigger_attr_create.
      DELETE ADJACENT DUPLICATES FROM et_trigger_attr_create.
    ENDIF.
    IF ev_trigger_attr_update_all = abap_true.
      CLEAR et_trigger_attr_update.
    ELSE.
      SORT et_trigger_attr_update.
      DELETE ADJACENT DUPLICATES FROM et_trigger_attr_update.
    ENDIF.
    IF ev_trigger_attr_delete_all = abap_true.
      CLEAR et_trigger_attr_delete.
    ELSE.
      SORT et_trigger_attr_delete.
      DELETE ADJACENT DUPLICATES FROM et_trigger_attr_delete.
    ENDIF.

  ENDMETHOD.


METHOD BUILD_PROPERTY.

  DATA: ls_property     TYPE        /BOBF/OBM_PROPTY,
        ls_property_prx TYPE        /BOBF/OBM_PRXPTY,
        ls_property_pr2 TYPE        /BOBF/OBM_PRXPTY,
        ls_prop_ro      TYPE REF TO /BOBF/S_CONFRO_PROPERTY,
        ls_prop_prx     TYPE        /BOBF/S_CONFRO_PROPERTY_PRX,
        ls_prop_ro_d    TYPE        /BOBF/S_FRW_PROPERTY_D,
        lv_attribute    TYPE        string,
        lv_node_key     TYPE        /BOBF/OBM_NODE_KEY,
        ls_fm           TYPE REF TO /BOBF/S_CONFRO_MAPPING,
        ls_node         TYPE        /BOBF/S_CONFRO_NODE,
        ls_nodecat      TYPE        /BOBF/S_CONFRO_NODE_CAT,
        ls_act          TYPE        /BOBF/S_CONFRO_ACT_LIST,
        ls_assoc        TYPE        /BOBF/S_CONFRO_ASSOC,
        ls_query        TYPE        /BOBF/S_CONFRO_QUERY,
        lt_assoc        TYPE SORTED TABLE OF /BOBF/S_CONFRO_ASSOC WITH NON-UNIQUE KEY source_node_key,
        lo_area_handle  TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_prop_prx> TYPE /BOBF/S_CONFRO_PROPERTY_PRX.

  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).

* build proxy properties
  LOOP AT it_property_prx INTO ls_property_prx
    WHERE property_name IS NOT INITIAL.
    CASE ls_property_prx-content_cat.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_NOD.
        lv_node_key = ls_property_prx-content_key.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_ACT.
        READ TABLE mt_act INTO ls_act
          WITH KEY act_key = ls_property_prx-content_key.
        IF sy-subrc = 0.
          lv_node_key = ls_act-node_key.
        ELSE.
          ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
          CONTINUE.
        ENDIF.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_ASS.
        READ TABLE mt_assoc INTO ls_assoc
          WITH KEY assoc_key = ls_property_prx-content_key.
        IF sy-subrc = 0.
          lv_node_key = ls_assoc-source_node_key.
        ELSE.
          ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
          CONTINUE.
        ENDIF.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_QRY.
        READ TABLE mt_query INTO ls_query
          WITH KEY query_key = ls_property_prx-content_key.
        IF sy-subrc = 0.
          lv_node_key = ls_query-node_key.
        ELSE.
          ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
          CONTINUE.
        ENDIF.
    ENDCASE.
    READ TABLE mt_property_prx
      WITH TABLE KEY node_key = lv_node_key
      ASSIGNING <ls_prop_prx>.
    IF sy-subrc <> 0.
      CLEAR ls_prop_prx.
      ls_prop_prx-node_key = lv_node_key.
      INSERT ls_prop_prx INTO TABLE mt_property_prx ASSIGNING <ls_prop_prx>.
      CREATE DATA <ls_prop_prx>-property AREA HANDLE lo_area_handle.
    ENDIF.

    CLEAR ls_prop_ro_d.

*   add static proxy property
    IF ls_property_prx-attribute_name IS INITIAL.
      ls_prop_ro_d-content_cat   = ls_property_prx-content_cat.
      ls_prop_ro_d-content_key   = ls_property_prx-content_key.
      ls_prop_ro_d-property_name = ls_property_prx-property_name.
      ls_prop_ro_d-value         = ls_property_prx-property_value.
      ls_prop_ro_d-final         = ls_property_prx-final.
      INSERT ls_prop_ro_d INTO TABLE <ls_prop_prx>-property->*.
      CONTINUE.
    ENDIF.

*   find internal attribute name
    lv_attribute = ls_property_prx-attribute_name.
    ls_property_pr2 = ls_property_prx.
    DO.
      IF ls_property_pr2-hierarchy_key IS INITIAL.
        EXIT.
      ENDIF.
      READ TABLE it_property_prx INTO ls_property_pr2
        WITH KEY property_key = ls_property_pr2-hierarchy_key.
      IF sy-subrc = 0.
        CONCATENATE ls_property_pr2-attribute_name '-' lv_attribute INTO lv_attribute.
      ELSE.
        ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
        CLEAR lv_attribute.
        EXIT.
      ENDIF.
    ENDDO.

    CHECK lv_attribute IS NOT INITIAL.

    READ TABLE mt_fieldmapping REFERENCE INTO ls_fm WITH KEY fieldname_ext
      COMPONENTS content_cat        = ls_property_prx-content_cat
                 content_key        = ls_property_prx-content_key
                 fieldname_ext_long = lv_attribute
                 redundant_attr     = abap_false.
    IF sy-subrc <> 0 OR ls_fm->fieldname_int IS INITIAL.
      CONTINUE.
    ELSE.
      lv_attribute = ls_fm->fieldname_int.
    ENDIF.

*   add static proxy attribute property
    ls_prop_ro_d-content_cat    = ls_property_prx-content_cat.
    ls_prop_ro_d-content_key    = ls_property_prx-content_key.
    ls_prop_ro_d-attribute_name = lv_attribute.
    ls_prop_ro_d-property_name  = ls_property_prx-property_name.
    ls_prop_ro_d-value          = ls_property_prx-property_value.
    ls_prop_ro_d-final          = ls_property_prx-final.
    INSERT ls_prop_ro_d INTO TABLE <ls_prop_prx>-property->*.
  ENDLOOP.

* build attribute properties
  LOOP AT it_property INTO ls_property.
    READ TABLE mt_property
      WITH TABLE KEY node_cat_key = ls_property-node_cat_key
      REFERENCE INTO ls_prop_ro.
    IF sy-subrc <> 0.
      CREATE DATA ls_prop_ro.
      ls_prop_ro->node_cat_key = ls_property-node_cat_key.
      INSERT ls_prop_ro->* INTO TABLE mt_property REFERENCE INTO ls_prop_ro.
      CREATE DATA ls_prop_ro->property AREA HANDLE lo_area_handle.
    ENDIF.

    ls_prop_ro_d-content_cat    = /BOBF/IF_CONF_C=>SC_CONTENT_NOD.
    ls_prop_ro_d-content_key    = ls_property-node_key.
    ls_prop_ro_d-attribute_name = ls_property-attribute_name.
    ls_prop_ro_d-property_name  = ls_property-property_name.
    ls_prop_ro_d-value          = ls_property-property_value.
    ls_prop_ro_d-final          = ls_property-final.
    INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
  ENDLOOP.

* build node action and association properties
  CLEAR ls_prop_ro_d.
  LOOP AT mt_node INTO ls_node WHERE node_cat IS BOUND. "#EC CI_SORTSEQ
*   get proxy properties
    READ TABLE mt_property_prx ASSIGNING <ls_prop_prx>
      WITH KEY node_key = ls_node-node_key.
    IF sy-subrc <> 0.
      CLEAR ls_prop_prx.
      CREATE DATA ls_prop_prx-property AREA HANDLE lo_area_handle.
      ASSIGN ls_prop_prx TO <ls_prop_prx>.
    ENDIF.

    LOOP AT ls_node-node_cat->* INTO ls_nodecat.
*     read corresponding proxy properties
      READ TABLE mt_property
         WITH KEY node_cat_key = ls_nodecat-node_cat_key
         REFERENCE INTO ls_prop_ro.
      IF sy-subrc <> 0.
        CREATE DATA ls_prop_ro.
        CREATE DATA ls_prop_ro->property AREA HANDLE lo_area_handle.
        ls_prop_ro->node_cat_key = ls_nodecat-node_cat_key.
        INSERT ls_prop_ro->* INTO TABLE mt_property REFERENCE INTO ls_prop_ro.
      ENDIF.

*     add node properties
      ls_prop_ro_d-content_cat = /BOBF/IF_CONF_C=>SC_CONTENT_NOD.
      ls_prop_ro_d-content_key = ls_node-node_key.
*     CREATE_ENABLED
      ls_prop_ro_d-property_name = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_CREATE_ENABLE.
      READ TABLE mt_act INTO ls_act WITH KEY key3
        COMPONENTS node_key = ls_node-node_key
                   act_cat  = /BOBF/IF_CONF_C=>SC_ACTION_CREATE.
      IF sy-subrc = 0.
        READ TABLE it_act_conf
          WITH KEY node_cat_key = ls_nodecat-node_cat_key
                   act_key      = ls_act-act_key
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
*         Check for final create disabled proxy property
          READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_prop_ro_d-content_cat
                     content_key   = ls_prop_ro_d-content_key
                          property_name = ls_prop_ro_d-property_name
                          value         = abap_false
                          final         = abap_true.
          IF sy-subrc = 0.
            ls_prop_ro_d-value = abap_false.
            ls_prop_ro_d-final = abap_true.
          ELSE.
            ls_prop_ro_d-value = abap_true.
            ls_prop_ro_d-final = abap_false.
          ENDIF.
        ELSE.
          ls_prop_ro_d-value = abap_false.
          ls_prop_ro_d-final = abap_true.
        ENDIF.
*       check if property is already set in proxy
        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
          WITH KEY content_cat   = ls_prop_ro_d-content_cat
                   content_key   = ls_prop_ro_d-content_key
                   property_name = ls_prop_ro_d-property_name
                   value         = ls_prop_ro_d-value.
        IF sy-subrc <> 0.
          INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
        ENDIF.
      ELSE.
        ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
      ENDIF.
*     UPDATE enabled
      ls_prop_ro_d-property_name = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_UPDATE_ENABLE.
      READ TABLE mt_act INTO ls_act WITH KEY key3
        COMPONENTS node_key = ls_node-node_key
                   act_cat  = /BOBF/IF_CONF_C=>SC_ACTION_UPDATE.
      IF sy-subrc = 0.
        READ TABLE it_act_conf
          WITH KEY node_cat_key = ls_nodecat-node_cat_key
                   act_key      = ls_act-act_key
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
*         Check for final update disabled proxy property
          READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_prop_ro_d-content_cat
                     content_key   = ls_prop_ro_d-content_key
                          property_name = ls_prop_ro_d-property_name
                          value         = abap_false
                          final         = abap_true.
          IF sy-subrc = 0.
            ls_prop_ro_d-value = abap_false.
            ls_prop_ro_d-final = abap_true.
          ELSE.
            ls_prop_ro_d-value = abap_true.
            ls_prop_ro_d-final = abap_false.
          ENDIF.
        ELSE.
          ls_prop_ro_d-value = abap_false.
          ls_prop_ro_d-final = abap_true.
        ENDIF.
*       check if property is already set in proxy
        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
          WITH KEY content_cat   = ls_prop_ro_d-content_cat
                   content_key   = ls_prop_ro_d-content_key
                   property_name = ls_prop_ro_d-property_name
                   value         = ls_prop_ro_d-value.
        IF sy-subrc <> 0.
          INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
        ENDIF.
      ELSE.
        ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
      ENDIF.
*     DELETE enabled
      ls_prop_ro_d-property_name  = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_DELETE_ENABLE.
      READ TABLE mt_act INTO ls_act WITH KEY key3
        COMPONENTS node_key = ls_node-node_key
                   act_cat  = /BOBF/IF_CONF_C=>SC_ACTION_DELETE.
      IF sy-subrc = 0.
        READ TABLE it_act_conf
          WITH KEY node_cat_key = ls_nodecat-node_cat_key
                   act_key      = ls_act-act_key
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
*         Check for final delete disabled proxy property
          READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_prop_ro_d-content_cat
                     content_key   = ls_prop_ro_d-content_key
                          property_name = ls_prop_ro_d-property_name
                          value         = abap_false
                          final         = abap_true.
          IF sy-subrc = 0.
            ls_prop_ro_d-value = abap_false.
            ls_prop_ro_d-final = abap_true.
          ELSE.
            ls_prop_ro_d-value = abap_true.
            ls_prop_ro_d-final = abap_false.
          ENDIF.
        ELSE.
          ls_prop_ro_d-value = abap_false.
          ls_prop_ro_d-final = abap_true.
        ENDIF.
*       check if property is already set in proxy
        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
          WITH KEY content_cat   = ls_prop_ro_d-content_cat
                   content_key   = ls_prop_ro_d-content_key
                   property_name = ls_prop_ro_d-property_name
                   value         = ls_prop_ro_d-value.
        IF sy-subrc <> 0.
          INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
        ENDIF.
      ELSE.
        ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
      ENDIF.

*     add action properties
      ls_prop_ro_d-content_cat   = /BOBF/IF_CONF_C=>SC_CONTENT_ACT.
      ls_prop_ro_d-property_name = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_ENABLED.
      LOOP AT mt_act INTO ls_act USING KEY key3
        WHERE node_key = ls_node-node_key
          AND act_cat  = /BOBF/IF_CONF_C=>SC_ACTION_STANDARD.
        ls_prop_ro_d-content_key = ls_act-act_key.
        READ TABLE it_act_conf
          WITH KEY node_cat_key = ls_nodecat-node_cat_key
                   act_key      = ls_act-act_key
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
*         Check for final disabled action proxy property
          READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_prop_ro_d-content_cat
                     content_key   = ls_prop_ro_d-content_key
                          property_name = ls_prop_ro_d-property_name
                          value         = abap_false
                          final         = abap_true.
          IF sy-subrc = 0.
            ls_prop_ro_d-value = abap_false.
            ls_prop_ro_d-final = abap_true.
          ELSE.
            ls_prop_ro_d-value = abap_true.
            ls_prop_ro_d-final = abap_false.
          ENDIF.
        ELSE.
          ls_prop_ro_d-value = abap_false.
          ls_prop_ro_d-final = abap_true.
        ENDIF.
*       check if property is already set in proxy
        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
          WITH KEY content_cat   = ls_prop_ro_d-content_cat
                   content_key   = ls_prop_ro_d-content_key
                   property_name = ls_prop_ro_d-property_name
                   value         = ls_prop_ro_d-value.
        IF sy-subrc <> 0.
          INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
        ENDIF.
      ENDLOOP.

*     add association properties
      ls_prop_ro_d-content_cat   = /BOBF/IF_CONF_C=>SC_CONTENT_ASS.
*     ENABLED
      IF lt_assoc IS INITIAL.
        lt_assoc = mt_assoc.
        DELETE lt_assoc
          WHERE assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_PROPERTY
             OR assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_MESSAGE
             OR assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_LOCK
             OR assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_PARENT
             OR assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_ROOT
             OR assoc_cat = /BOBF/IF_CONF_C=>SC_ASSOCCAT_STATUS. "#EC CI_SORTSEQ
      ENDIF.
      ls_prop_ro_d-property_name = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_ENABLED.
      LOOP AT lt_assoc INTO ls_assoc
        WHERE source_node_key = ls_node-node_key.
        ls_prop_ro_d-content_key = ls_assoc-assoc_key.
        READ TABLE it_assoc_conf
          WITH KEY node_cat_key = ls_nodecat-node_cat_key
                   assoc_key    = ls_assoc-assoc_key
          TRANSPORTING NO FIELDS.                       "#EC CI_SORTSEQ
        IF sy-subrc = 0.
*         Check for final disabled association proxy property
          READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
            WITH KEY content_cat   = ls_prop_ro_d-content_cat
                     content_key   = ls_prop_ro_d-content_key
                          property_name = ls_prop_ro_d-property_name
                          value         = abap_false
                          final         = abap_true.
          IF sy-subrc = 0.
            ls_prop_ro_d-value = abap_false.
            ls_prop_ro_d-final = abap_true.
          ELSE.
            ls_prop_ro_d-value = abap_true.
            ls_prop_ro_d-final = abap_false.
          ENDIF.
        ELSE.
          ls_prop_ro_d-value = abap_false.
          ls_prop_ro_d-final = abap_true.
        ENDIF.
*       check if property is already set in proxy
        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
          WITH KEY content_cat   = ls_prop_ro_d-content_cat
                   content_key   = ls_prop_ro_d-content_key
                   property_name = ls_prop_ro_d-property_name
                   value         = ls_prop_ro_d-value.
        IF sy-subrc <> 0.
          INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
        ENDIF.
      ENDLOOP.
*     CREATE_ENABLED (if node is not createable)
      ls_prop_ro_d-property_name  = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_CREATE_ENABLE.

*      LOOP AT lt_assoc INTO ls_assoc
*        WHERE source_node_key = ls_node-node_key.       "#EC CI_SORTSEQ
*
*        ls_prop_ro_d-content_key = ls_assoc-assoc_key.
*        ls_prop_ro_d-value       = abap_false.
*        ls_prop_ro_d-final       = abap_true.
*       check if node is create enabled
*        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
*          WITH KEY content_cat   = /bopf/if_conf_c=>sc_content_nod
*                   content_key   = ls_node-node_key
*                   property_name = ls_prop_ro_d-property_name
*                   value         = ls_prop_ro_d-value
*                   final         = abap_true.
*        IF sy-subrc <> 0.
*          READ TABLE ls_prop_ro->property->* TRANSPORTING NO FIELDS
*            WITH KEY content_cat   = /bopf/if_conf_c=>sc_content_nod
*                     content_key   = ls_node-node_key
*                     property_name = ls_prop_ro_d-property_name
*                     value         = ls_prop_ro_d-value
*                     final         = abap_true.
*          IF sy-subrc <> 0.
*            CONTINUE.
*          ENDIF.
*        ENDIF.
*       check if property is already set in proxy
*        READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
*          WITH KEY content_cat   = ls_prop_ro_d-content_cat
*                   content_key   = ls_prop_ro_d-content_key
*                   property_name = ls_prop_ro_d-property_name
*                   value         = ls_prop_ro_d-value.
*        IF sy-subrc <> 0.
*          INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
*        ENDIF.
*      ENDLOOP.

    ENDLOOP.
  ENDLOOP.

* add properties of UUID fields that have been mapped to the KEY
* set: read-only = true
  LOOP AT mt_node INTO ls_node.
    READ TABLE mt_fieldmapping TRANSPORTING NO FIELDS
      WITH KEY content_cat   = /BOBF/IF_CONF_C=>SC_CONTENT_NOD
               content_key   = ls_node-node_key
               fieldname_int = /BOBF/IF_CONF_C=>SC_ATTRIBUTE_NAME_KEY.
    CHECK sy-subrc = 0.
*   add properties for all node categories
    ls_prop_ro_d-content_cat    = /BOBF/IF_CONF_C=>SC_CONTENT_NOD.
    ls_prop_ro_d-content_key    = ls_node-node_key.
    ls_prop_ro_d-property_name  = /BOBF/IF_CONF_C=>SC_PROPERTY_NAME_READONLY.
    ls_prop_ro_d-attribute_name = /BOBF/IF_CONF_C=>SC_ATTRIBUTE_NAME_KEY.
    ls_prop_ro_d-value          = abap_true.
    ls_prop_ro_d-final          = abap_false.

    LOOP AT ls_node-node_cat->* INTO ls_nodecat.
*     search for node category
      READ TABLE mt_property
         WITH KEY node_cat_key = ls_nodecat-node_cat_key
         REFERENCE INTO ls_prop_ro.
      IF sy-subrc <> 0.
        CREATE DATA ls_prop_ro.
        CREATE DATA ls_prop_ro->property AREA HANDLE lo_area_handle.
        ls_prop_ro->node_cat_key = ls_nodecat-node_cat_key.
        INSERT ls_prop_ro->* INTO TABLE mt_property REFERENCE INTO ls_prop_ro.
      ENDIF.
*     check if property is already set in proxy
      READ TABLE <ls_prop_prx>-property->* TRANSPORTING NO FIELDS
        WITH KEY content_cat   = ls_prop_ro_d-content_cat
                 content_key   = ls_prop_ro_d-content_key
                 property_name = ls_prop_ro_d-property_name
                 value         = ls_prop_ro_d-value.
      IF sy-subrc <> 0.
        INSERT ls_prop_ro_d INTO TABLE ls_prop_ro->property->*.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

ENDMETHOD.


METHOD BUILD_PROPERTY_CHANGE.

  DATA: ls_rtw              TYPE /BOBF/OBM_RTW,
        ls_prop_chg         TYPE /BOBF/S_CONFRO_PROP_CHG,
        ls_prop_chg_trigger TYPE /BOBF/S_CONFRO_PROP_CHG_TRIG,
        lo_area_handle      TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_prop_chg> TYPE /BOBF/S_CONFRO_PROP_CHG.

  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).

  LOOP AT it_rtw INTO ls_rtw.
    CHECK ls_rtw-access_cat = /BOBF/IF_CONF_C=>SC_ACCESS_PROPERTY
      AND ( ls_rtw-trigger_create = abap_true OR
            ls_rtw-trigger_update = abap_true OR
            ls_rtw-trigger_delete = abap_true ).

    CASE ls_rtw-content_cat.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_NOD.
        ls_prop_chg_trigger-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_NODE.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_ACT.
        ls_prop_chg_trigger-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_ACTION.
      WHEN /BOBF/IF_CONF_C=>SC_CONTENT_ASS.
        ls_prop_chg_trigger-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_ASSOCIATION.
      WHEN OTHERS.
        CONTINUE.
    ENDCASE.

    IF ls_rtw-assoc_key IS NOT INITIAL.
      READ TABLE mt_assoc TRANSPORTING NO FIELDS
        WITH KEY assoc_key = ls_rtw-assoc_key.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.
    ENDIF.

    ls_prop_chg_trigger-assoc_key = ls_rtw-assoc_key.
    ls_prop_chg_trigger-create    = ls_rtw-trigger_create.
    ls_prop_chg_trigger-update    = ls_rtw-trigger_update.
    ls_prop_chg_trigger-delete    = ls_rtw-trigger_delete.

    READ TABLE mt_property_change ASSIGNING <ls_prop_chg>
      WITH KEY node_key = ls_rtw-node_key.
    IF sy-subrc = 0.
      INSERT ls_prop_chg_trigger INTO TABLE <ls_prop_chg>-trigger->*.
    ELSE.
      CLEAR ls_prop_chg.
      CREATE DATA ls_prop_chg-trigger AREA HANDLE lo_area_handle.
      INSERT ls_prop_chg_trigger INTO TABLE ls_prop_chg-trigger->*.
      ls_prop_chg-node_key = ls_rtw-node_key.
      INSERT ls_prop_chg INTO TABLE mt_property_change.
    ENDIF.

  ENDLOOP.

ENDMETHOD.


METHOD build_query.

  DATA  lo_badi TYPE REF TO /bobf/badi_hdb_view_query.
  FIELD-SYMBOLS: <ls_node>  TYPE /bobf/s_confro_node,
                 <ls_node2> TYPE /bobf/s_confro_node,
                 <ls_query> TYPE /bobf/s_confro_query.

  LOOP AT mt_node ASSIGNING <ls_node> USING KEY key_proxy.
    CHECK <ls_node>-node_esr_name IS NOT INITIAL.
    <ls_node>-node_esr_name_unique = abap_true.
    IF <ls_node2> IS ASSIGNED AND
       <ls_node>-node_esr_name = <ls_node2>-node_esr_name.
      <ls_node>-node_esr_name_unique  = abap_false.
      <ls_node2>-node_esr_name_unique = abap_false.
    ENDIF.
    ASSIGN <ls_node> TO <ls_node2>.
  ENDLOOP.

  LOOP AT mt_query ASSIGNING <ls_query>.
    IF <ls_query>-use_proxy_type = abap_true.
      <ls_query>-data_type = <ls_query>-prx_data_type.
    ENDIF.

    IF ms_obj-genil_prefix IS NOT INITIAL AND <ls_query>-query_genil_name IS NOT INITIAL.
      CONCATENATE ms_obj-genil_prefix
                  gc_genil_separator
                  <ls_query>-query_genil_name
             INTO <ls_query>-query_genil_name.
    ENDIF.

    " Replace HANA View name if it was copied due to extensibility
    " No checks from BOBF side: valid result is in the responsibilty of BAdI - Impl.
    IF <ls_query>-hana_view IS NOT INITIAL AND sy-dbsys = 'HDB'.
      TRY.
          GET BADI lo_badi.
          CALL BADI lo_badi->replace_hdb_view_with_copy
            CHANGING
              cv_view_name = <ls_query>-hana_view.  " If coppy exists: Name of the copy view
        CATCH cx_badi_not_implemented.
      ENDTRY.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD BUILD_STATUS_VARIABLE.

  DATA:
        ls_mapping_conf    TYPE /BOBF/S_CONFRO_MAPPING,
        ls_node_conf       TYPE /BOBF/S_CONFRO_NODE,
        ls_comp_conf       TYPE /BOBF/S_CONFRO_ASSOC2,
        lo_area_handle     TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS:
        <ls_sta_var>       TYPE /BOBF/S_CONFRO_STA_VAR,
        <ls_node>          TYPE /BOBF/S_CONFRO_NODE.


  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).

  LOOP AT mt_sta_var ASSIGNING <ls_sta_var>.

    IF <ls_sta_var>-sta_var_esr_name IS NOT INITIAL.
*     Resolve long proxy fieldname to internal field name
      READ TABLE mt_node INTO ls_node_conf
        WITH KEY node_key = <ls_sta_var>-node_key.
      IF ls_node_conf-use_proxy_type = abap_false.
        READ TABLE mt_fieldmapping INTO ls_mapping_conf
          WITH KEY fieldname_ext COMPONENTS content_key        = <ls_sta_var>-node_key
                                            content_cat        = /BOBF/IF_CONF_C=>SC_CONTENT_NOD
                                            fieldname_ext_long = <ls_sta_var>-attribute_name.
        IF sy-subrc <> 0.
*       status variable resides on subnode
          READ TABLE mt_comp INTO ls_comp_conf
            WITH KEY source_node_key = <ls_sta_var>-node_key
                     assoc_cat       = /BOBF/IF_CONF_C=>SC_ASSOCCAT_STATUS.
          IF sy-subrc <> 0.
*         no status node and no field mapping -> status field is disabled -> delete status variable
            DELETE mt_sta_var.
            CONTINUE.
          ENDIF.
          READ TABLE mt_fieldmapping INTO ls_mapping_conf
            WITH KEY fieldname_ext COMPONENTS content_key        = ls_comp_conf-target_node_key
                                              content_cat        = /BOBF/IF_CONF_C=>SC_CONTENT_NOD
                                              fieldname_ext_long = <ls_sta_var>-attribute_name.
          IF sy-subrc <> 0.
*         no field mapping on the status node -> status field is disabled -> delete status variable
            DELETE mt_sta_var.
            CONTINUE.
          ENDIF.
          <ls_sta_var>-node_key = ls_comp_conf-target_node_key.
        ENDIF.
        <ls_sta_var>-attribute_name = ls_mapping_conf-fieldname_int.
      ENDIF.
    ENDIF.

    READ TABLE mt_node ASSIGNING <ls_node>
      WITH KEY node_key = <ls_sta_var>-node_key.
    DELETE <ls_node>-field_names->*
      WHERE table_line = <ls_sta_var>-attribute_name.

    IF <ls_node>-status_attributes IS NOT BOUND.
      CREATE DATA <ls_node>-status_attributes AREA HANDLE lo_area_handle.
    ENDIF.
    APPEND <ls_sta_var>-attribute_name TO <ls_node>-status_attributes->*.
  ENDLOOP.

ENDMETHOD.


METHOD build_validation.

  TYPES:
         tt_sortednet       TYPE SORTED TABLE OF /bobf/val_net
                                 WITH NON-UNIQUE KEY val_key_to
                                 WITH NON-UNIQUE SORTED KEY key2 COMPONENTS val_key_from,
         tt_node            TYPE STANDARD TABLE OF /bobf/obm_node_key.

  DATA: ls_val_key          TYPE /bobf/s_frw_key,
        lt_rtw              TYPE STANDARD TABLE OF /bobf/obm_rtw,
        lt_group_db         TYPE tt_group,
        ls_rtw              TYPE /bobf/obm_rtw,
        ls_vallist          TYPE /bobf/s_confro_val_list,
        ls_vallist_first    TYPE /bobf/s_confro_val_list,
        ls_valtrigger       TYPE /bobf/s_confro_val_trigger,
        ls_valread          TYPE /bobf/s_confro_read,
        lt_valconf          TYPE tt_valconf,
        lt_valconf2         TYPE tt_valconf,
        lt_valconf_sorted   TYPE tt_valconf,
        ls_valconf          TYPE REF TO /bobf/val_conf,
        ls_valconf2         TYPE /bobf/val_conf,
        ls_valnet           TYPE /bobf/val_net,
        lt_sortednet        TYPE tt_sortednet,
        lv_valorder_changed TYPE boole_d,
        lv_index_to         TYPE i,
        lv_index_from       TYPE i,
        ls_group_db         TYPE /bobf/obm_group,
        ls_group            TYPE /bobf/s_confro_group,
        ls_group2           TYPE /bobf/s_confro_group,
        ls_groupc           TYPE /bobf/s_confro_groupc,
        lt_group            TYPE /bobf/t_confro_group,
        ls_nodecat          TYPE /bobf/s_confro_node_cat,
        lv_ncat_all         TYPE i,
        lv_ncat_val         TYPE i,
        ls_node             TYPE /bobf/s_confro_node,
        lv_node_key         TYPE /bobf/obm_node_key,
        lt_subnode          TYPE /bobf/t_frw_key2,
        lt_node_key         TYPE tt_node,
        lv_first            TYPE boole_d,
        lv_index            TYPE i,
        lv_index_max        TYPE i,
        ls_comp             TYPE /bobf/s_confro_assoc2,
        lv_group_key        TYPE /bobf/obm_group_key,
        lo_area_handle      TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_act>        TYPE /bobf/s_confro_act_list,
                 <ls_val>        TYPE /bobf/val_list,
                 <ls_vallist>    TYPE /bobf/s_confro_val_list,
                 <ls_group>      TYPE /bobf/s_confro_group,
                 <ls_group2>     TYPE /bobf/s_confro_group,
                 <ls_node>       TYPE /bobf/s_confro_node.

  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

  lt_sortednet = it_valnet.
  lt_valconf   = it_valconf.
  lt_group_db  = it_group.

* Remove all net entries for which both source and target val are not active in configuration
  LOOP AT lt_sortednet INTO ls_valnet.
    READ TABLE lt_valconf TRANSPORTING NO FIELDS WITH KEY val_key = ls_valnet-val_key_from.
    IF sy-subrc <> 0.
      READ TABLE lt_valconf TRANSPORTING NO FIELDS WITH KEY val_key = ls_valnet-val_key_to.
      IF sy-subrc <> 0.
        DELETE lt_sortednet.
      ENDIF.
    ENDIF.
  ENDLOOP.

* valermine all validations, that do not have any predecessors
  LOOP AT lt_valconf INTO ls_valconf2.
    READ TABLE lt_sortednet WITH KEY val_key_to = ls_valconf2-val_key TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND ls_valconf2 TO lt_valconf2.
    ENDIF.
  ENDLOOP.
* While there are valerminations without successors
  WHILE lt_valconf2 IS NOT INITIAL.
* Choose a validation without successors and append it to sorted order
    READ TABLE lt_valconf2 INDEX 1 INTO ls_valconf2.
    READ TABLE lt_valconf_sorted WITH KEY conf_key = ls_valconf2-conf_key TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND ls_valconf2 TO lt_valconf_sorted.
    ENDIF.
    DELETE lt_valconf2 INDEX 1.

*   Loop over all outgoing dependencies of this valermeniation
    LOOP AT lt_sortednet INTO ls_valnet USING KEY key2 WHERE val_key_from = ls_valconf2-val_key.
*     Delete processed edge
      DELETE lt_sortednet INDEX sy-tabix USING KEY key2.
*     Check if target of edge has any other incoming edges
      READ TABLE lt_sortednet WITH KEY val_key_to = ls_valnet-val_key_to TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
*       When last edge was removed -> A new node without incoming edges was found, so append it to list
        LOOP AT lt_valconf INTO ls_valconf2 WHERE val_key = ls_valnet-val_key_to .
          APPEND ls_valconf2 TO lt_valconf2.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
  ENDWHILE.
* If some edges are left -> Cycle was found
  IF lt_sortednet IS NOT INITIAL.
    ASSERT ID /bobf/conf CONDITION 0 = 1.                  "#EC BOOL_OK
    RAISE EXCEPTION TYPE /bobf/cx_conf.
  ENDIF.
  lt_valconf = lt_valconf_sorted.

* sort rtw
  lt_rtw = it_rtw.
  LOOP AT it_valnet INTO ls_valnet.
    lv_valorder_changed = abap_true.
    WHILE lv_valorder_changed = abap_true.
      lv_valorder_changed = abap_false.
      READ TABLE lt_rtw TRANSPORTING NO FIELDS
        WITH KEY content_key = ls_valnet-val_key_to.    "#EC CI_SORTSEQ
      IF sy-subrc = 0.
        lv_index_to = sy-tabix.
        LOOP AT lt_rtw INTO ls_rtw FROM lv_index_to
          WHERE content_key = ls_valnet-val_key_from.
          lv_index_from = sy-tabix.
          EXIT.
        ENDLOOP.
        IF sy-subrc = 0.
          lv_valorder_changed = abap_true.
          DELETE lt_rtw INDEX lv_index_from.
          INSERT ls_rtw INTO lt_rtw INDEX lv_index_to.
        ENDIF.
      ENDIF.
    ENDWHILE.
  ENDLOOP.

* distribute RTW for validations
  LOOP AT lt_rtw INTO ls_rtw
      WHERE content_cat = /bobf/if_conf_c=>sc_content_val.
    READ TABLE mt_validation
      WITH KEY val_key = ls_rtw-content_key
      ASSIGNING <ls_vallist>.

    IF sy-subrc <> 0.
      READ TABLE ct_val
        WITH KEY val_key = ls_rtw-content_key
        ASSIGNING <ls_val>.
      CHECK sy-subrc = 0.
      CLEAR ls_vallist.
      CREATE DATA ls_vallist-val_read    AREA HANDLE lo_area_handle.
      CREATE DATA ls_vallist-val_trigger AREA HANDLE lo_area_handle.
      CREATE DATA ls_vallist-val_group   AREA HANDLE lo_area_handle.
      CREATE DATA ls_vallist-node_cat    AREA HANDLE lo_area_handle.
      MOVE-CORRESPONDING <ls_val> TO ls_vallist.
      APPEND ls_vallist TO mt_validation ASSIGNING <ls_vallist>.
    ENDIF.

    IF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_read.
      CLEAR ls_valread.
      MOVE-CORRESPONDING ls_rtw TO ls_valread.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill assocication validation-node -> read-node
        READ TABLE mt_assoc
          WITH KEY assoc_key = ls_rtw-assoc_key
          REFERENCE INTO ls_valread-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          APPEND ls_valread TO <ls_vallist>-val_read->*.
        ENDIF.
      ELSE.
        APPEND ls_valread TO <ls_vallist>-val_read->*.
      ENDIF.

    ELSEIF ls_rtw-access_cat = /bobf/if_conf_c=>sc_access_trigger.
      CLEAR ls_valtrigger.
      MOVE-CORRESPONDING ls_rtw TO ls_valtrigger.           "#EC ENHOK
      ls_valtrigger-create = ls_rtw-trigger_create.
      ls_valtrigger-update = ls_rtw-trigger_update.
      ls_valtrigger-delete = ls_rtw-trigger_delete.
      ls_valtrigger-check  = ls_rtw-trigger_check.
      IF ls_rtw-assoc_key IS NOT INITIAL.
*       fill assocication trigger-node -> validation-node
        READ TABLE mt_assoc
          WITH KEY assoc_key = ls_rtw-assoc_key
          REFERENCE INTO ls_valtrigger-assoc.
        ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          APPEND ls_valtrigger TO <ls_vallist>-val_trigger->*.
        ENDIF.
      ELSE.
        APPEND ls_valtrigger TO <ls_vallist>-val_trigger->*.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF ms_obj-status_class IS INITIAL.
    DELETE lt_group_db
      WHERE
        sta_var_key     IS NOT INITIAL OR
        status_variable IS NOT INITIAL.
  ENDIF.

* attach consistency and check group information to consistency validations and build consistency group table
  ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_none.
  LOOP AT mt_groupc INTO ls_groupc
    WHERE content_cat = /bobf/if_conf_c=>sc_content_val
       OR content_cat = /bobf/if_conf_c=>sc_content_nod. "#EC CI_SORTSEQ

    READ TABLE lt_group_db INTO ls_group_db
      WITH KEY group_key = ls_groupc-group_key.
    CHECK sy-subrc = 0.

    CASE ls_groupc-content_cat.
*     it's a validation assigned to the group
      WHEN /bobf/if_conf_c=>sc_content_val.
        READ TABLE mt_validation ASSIGNING <ls_vallist>
          WITH KEY val_key = ls_groupc-content_key.
        CHECK sy-subrc = 0.
        ls_vallist = <ls_vallist>.

      WHEN /bobf/if_conf_c=>sc_content_nod.
*       insert pseudo-validation for DO node
        CHECK ls_group_db-group_cat = /bobf/if_conf_c=>sc_group_cat_consistency.
        READ TABLE mt_node ASSIGNING <ls_node> WITH KEY
            node_key = ls_groupc-content_key.
        CHECK sy-subrc          = 0 AND
            <ls_node>-node_type = /bobf/if_conf_c=>sc_node_type_do.
        CLEAR ls_vallist.
        ls_vallist-val_key = /bobf/cl_frw_factory=>get_new_key( ).
        ls_vallist-val_cat = /bobf/if_conf_c=>sc_val_cat_object.
        ls_vallist-node_key = ls_groupc-content_key.
        CREATE DATA ls_vallist-val_group AREA HANDLE lo_area_handle.
        CREATE DATA ls_vallist-val_trigger AREA HANDLE lo_area_handle.
        CLEAR ls_valtrigger.
        ls_valtrigger-node_key = ls_groupc-content_key.
        ls_valtrigger-check    = abap_true.
        APPEND ls_valtrigger TO ls_vallist-val_trigger->*.
        APPEND ls_vallist TO mt_validation ASSIGNING <ls_vallist>.
        <ls_node>-check_trigger = abap_true.
    ENDCASE.

    READ TABLE mt_group WITH KEY group_key
      COMPONENTS group_key = ls_group_db-group_key
      ASSIGNING <ls_group>.

    IF sy-subrc = 0.
      ls_group = <ls_group>.

      IF <ls_group>-local_group = abap_true.
        READ TABLE <ls_group>-val_keys->* INTO ls_val_key INDEX 1.
        READ TABLE mt_validation INTO ls_vallist_first WITH KEY val_key = ls_val_key-key.
        IF ls_vallist_first-node_key <> ls_vallist-node_key.
          <ls_group>-local_group = abap_false.
        ENDIF.
      ENDIF.

      IF ls_groupc-content_cat = /bobf/if_conf_c=>sc_content_val.
        ls_val_key-key = ls_groupc-content_key.
        APPEND ls_val_key TO <ls_group>-val_keys->*.
      ELSEIF ls_groupc-content_cat = /bobf/if_conf_c=>sc_content_nod.
        ls_val_key-key = ls_vallist-val_key.
        APPEND ls_val_key TO <ls_group>-val_keys->*.
      ENDIF.

    ELSE.
      UNASSIGN <ls_group>.
      MOVE-CORRESPONDING ls_group_db TO ls_group.
      CREATE DATA ls_group-val_trigger AREA HANDLE lo_area_handle.
      CREATE DATA ls_group-val_keys    AREA HANDLE lo_area_handle.
      IF ls_groupc-content_cat = /bobf/if_conf_c=>sc_content_val.
        ls_val_key-key = ls_groupc-content_key.
        APPEND ls_val_key TO ls_group-val_keys->*.
      ELSEIF ls_groupc-content_cat = /bobf/if_conf_c=>sc_content_nod.
        ls_val_key-key = ls_vallist-val_key.
        APPEND ls_val_key TO ls_group-val_keys->*.
      ENDIF.
      IF ls_group-sta_var_key IS NOT INITIAL.
        READ TABLE mt_sta_var REFERENCE INTO ls_group-sta_var
          WITH KEY sta_var_key = ls_group-sta_var_key.
      ENDIF.
      ls_group-local_group = abap_true.
      INSERT ls_group INTO TABLE mt_group.
    ENDIF.

    INSERT ls_group INTO TABLE <ls_vallist>-val_group->*.

    IF ls_group_db-group_cat = /bobf/if_conf_c=>sc_group_cat_consistency.
      LOOP AT <ls_vallist>-val_trigger->* INTO ls_valtrigger WHERE check = abap_true.
        APPEND ls_valtrigger-node_key TO ls_group-val_trigger->*.
      ENDLOOP.

      IF lv_group_key                   <> ls_groupc-group_key AND
          ms_obj-has_consistency_groups <> /bobf/if_frw_c=>sc_group_2_3_way_immediate.
        lv_group_key = ls_groupc-group_key.
        IF ls_group-check_immediate       = abap_false                                   AND
            ( ls_group-sta_var_key        IS INITIAL                                     OR
            ls_group-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary ) AND
            ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_none.
          ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_2_way.

        ELSEIF ls_group-check_immediate     = abap_true                                    AND
            ( ls_group-sta_var_key          IS INITIAL                                     OR
            ls_group-sta_var->sta_var_cat   = /bobf/if_conf_c=>sc_sta_cat_consist_binary ) AND
            ( ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_none                OR
            ms_obj-has_consistency_groups   = /bobf/if_frw_c=>sc_group_2_way ).
          ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_2_way_immediate.

        ELSEIF ls_group-sta_var_key        IS NOT INITIAL                                 AND
            ls_group-sta_var->sta_var_cat   = /bobf/if_conf_c=>sc_sta_cat_consist_ternary AND
            ( ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_none               OR
            ms_obj-has_consistency_groups   = /bobf/if_frw_c=>sc_group_2_way ).
          ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_3_way.

        ELSEIF ls_group-check_immediate   = abap_true                                    AND
            ( ls_group-sta_var_key        IS INITIAL                                     OR
            ls_group-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary ) AND
            ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_3_way.
          ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_2_3_way_immediate.

        ELSEIF ls_group-sta_var_key       IS NOT INITIAL                                AND
            ls_group-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_ternary AND
            ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_2_way_immediate.
          ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_2_3_way_immediate.

        ELSEIF ls_group-sta_var_key       IS NOT INITIAL                                AND
            ls_group-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_ternary AND
            ls_group-check_immediate      = abap_true.
          ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_2_3_way_immediate.
        ENDIF.
      ENDIF.
    ENDIF.

    CLEAR ls_group.

  ENDLOOP.

* fill consistency groups with trigger information
  LOOP AT mt_group ASSIGNING <ls_group>.
    SORT <ls_group>-val_trigger->*.
    DELETE ADJACENT DUPLICATES FROM <ls_group>-val_trigger->*.
    READ TABLE <ls_group>-val_trigger->* TRANSPORTING NO FIELDS
      WITH KEY table_line = ms_obj-root_node_key.
    IF sy-subrc = 0.
      <ls_group>-checkdet_node_key = ms_obj-root_node_key.
    ELSE.
      LOOP AT <ls_group>-val_trigger->* INTO lv_node_key.
        IF lt_node_key IS INITIAL.
          APPEND lv_node_key TO lt_node_key.
          lv_first = abap_true.
        ENDIF.
        WHILE lv_node_key <> ms_obj-root_node_key.
          IF lv_first = abap_false.
            READ TABLE lt_node_key WITH KEY table_line = lv_node_key TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              lv_index = sy-tabix.
              EXIT.
            ENDIF.
          ENDIF.
          READ TABLE mt_comp INTO ls_comp WITH KEY target_key COMPONENTS
              target_node_key = lv_node_key.
          lv_node_key = ls_comp-source_node_key.
          IF lv_first = abap_true.
            APPEND lv_node_key TO lt_node_key.
          ENDIF.
        ENDWHILE.
        lv_first = abap_false.
        IF <ls_group>-checkdet_node_key IS INITIAL.
          READ TABLE lt_node_key INTO <ls_group>-checkdet_node_key INDEX 1.
        ELSEIF lv_node_key = ms_obj-root_node_key OR
            lv_index > lv_index_max.
          lv_index_max = lv_index.
          <ls_group>-checkdet_node_key = lv_node_key.
          IF lv_node_key = ms_obj-root_node_key.
            EXIT.
          ENDIF.
        ENDIF.
      ENDLOOP.
      IF <ls_group>-checkdet_node_key <> ms_obj-root_node_key.
        lv_index = lv_index_max + 1.
        CREATE DATA <ls_group>-checkdet_super_node_keys AREA HANDLE lo_area_handle.
        LOOP AT lt_node_key INTO lv_node_key FROM lv_index.
          APPEND lv_node_key TO <ls_group>-checkdet_super_node_keys->*.
        ENDLOOP.
      ENDIF.
      CLEAR:
          lt_node_key,
          lv_index_max.
    ENDIF.
    LOOP AT <ls_group>-val_keys->* INTO ls_val_key.
      READ TABLE mt_validation ASSIGNING <ls_vallist>
        WITH KEY val_key = ls_val_key-key.
      READ TABLE <ls_vallist>-val_group->* ASSIGNING <ls_group2>
        WITH KEY group_key COMPONENTS group_key = <ls_group>-group_key.
      <ls_group2> = <ls_group>.
    ENDLOOP.
  ENDLOOP.

  IF ms_obj-feature_annotation CS /bobf/if_conf_c=>sc_feature-draft_new_consistency AND
     ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_none.

     " If the BO uses 'new consistency feature' (aka. smart validations) but has no consistency validations
     " so far, add the group metadata to the load so that the BOPF standard status handling can do the job:
     " set the status to 'pending' after each change and to 'consistent' during CHECK_AND_DETERMINE
     " Otherwise the draft instance never gets consistent and hence it can't get activated

     " Create group
     READ TABLE lt_group_db INTO ls_group_db WITH KEY group_name = /bobf/if_conf_c=>sc_group_name_draft_consist.
     ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
     MOVE-CORRESPONDING ls_group_db to ls_group.
     ls_group-local_group = abap_true.
     ls_group-checkdet_node_key = ms_obj-root_node_key.
     CREATE DATA ls_group-val_keys AREA HANDLE lo_area_handle.
     READ TABLE mt_sta_var REFERENCE INTO ls_group-sta_var WITH KEY sta_var_key = ls_group-sta_var_key.

     INSERT ls_group into table mt_group.
     ms_obj-has_consistency_groups = /bobf/if_frw_c=>sc_group_3_way.

  ENDIF.

* hierarchically sort mt_group
  LOOP AT mt_group INTO ls_group.
    lv_index = -1.
    get_subnode(
      EXPORTING
        iv_node_key    = ls_group-checkdet_node_key
      IMPORTING
        et_subnode_key = lt_subnode ).
    LOOP AT lt_group INTO ls_group2.
      lv_index = sy-tabix.
      LOOP AT lt_subnode INTO lv_node_key USING KEY key_sort WHERE
          table_line = ls_group2-checkdet_node_key.
        EXIT.
      ENDLOOP.
      IF sy-subrc = 0.
        EXIT.
      ELSE.
        lv_index = -1.
      ENDIF.
    ENDLOOP.
    IF lv_index = -1.
      APPEND ls_group TO lt_group.
    ELSE.
      INSERT ls_group INTO lt_group INDEX lv_index.
    ENDIF.
  ENDLOOP.
  mt_group = lt_group.

* distribute validations into action table
  LOOP AT lt_valconf REFERENCE INTO ls_valconf.
    READ TABLE mt_act
      WITH TABLE KEY act_key = ls_valconf->act_key
      ASSIGNING <ls_act>.
    ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
    CHECK sy-subrc = 0.

    CLEAR ls_vallist.
    READ TABLE <ls_act>-val_list->*
      WITH KEY val_key = ls_valconf->val_key
      ASSIGNING <ls_vallist>.
    IF sy-subrc <> 0.
      READ TABLE mt_validation
        WITH KEY val_key = ls_valconf->val_key
        INTO ls_vallist.
      IF sy-subrc <> 0.
        READ TABLE ct_val
          WITH KEY val_key = ls_valconf->val_key
          ASSIGNING <ls_val>.
        IF sy-subrc = 0.
          MOVE-CORRESPONDING <ls_val> TO ls_vallist.
          CREATE DATA ls_vallist-node_cat AREA HANDLE lo_area_handle.
          CREATE DATA ls_vallist-val_read AREA HANDLE lo_area_handle.
          CREATE DATA ls_vallist-val_trigger AREA HANDLE lo_area_handle.
          CREATE DATA ls_vallist-val_group AREA HANDLE lo_area_handle.
          APPEND ls_vallist TO mt_validation.
        ENDIF.
      ENDIF.
      IF ls_vallist IS NOT INITIAL.
        ls_nodecat-node_cat_key = ls_valconf->node_cat_key.
        IF ls_vallist-val_cat = /bobf/if_conf_c=>sc_val_cat_action.
          CREATE DATA ls_vallist-node_cat AREA HANDLE lo_area_handle.
        ENDIF.
        INSERT ls_nodecat INTO TABLE ls_vallist-node_cat->*.
        APPEND ls_vallist TO <ls_act>-val_list->*.
        CLEAR ls_vallist.
      ENDIF.
    ELSE.
      ls_nodecat-node_cat_key = ls_valconf->node_cat_key.
      INSERT ls_nodecat INTO TABLE <ls_vallist>-node_cat->*.
    ENDIF.
  ENDLOOP.

* filter ncats out if validation is enabled for all nodecats
  LOOP AT mt_act ASSIGNING <ls_act>.
    IF <ls_act>-act_cat = /bobf/if_conf_c=>sc_action_validate.
      FREE <ls_act>-val_list->*.
      CONTINUE.
    ENDIF.
    LOOP AT <ls_act>-val_list->* ASSIGNING <ls_vallist>.
      READ TABLE mt_node
        WITH TABLE KEY node_key = <ls_vallist>-node_key
        INTO ls_node.
      IF ls_node-node_type = /bobf/if_conf_c=>sc_node_type_bo.
        DESCRIBE TABLE ls_node-node_cat->*      LINES lv_ncat_all.
        DESCRIBE TABLE <ls_vallist>-node_cat->* LINES lv_ncat_val.
        IF lv_ncat_val = lv_ncat_all.
*       validation is enabled for all node cat
          FREE <ls_vallist>-node_cat->*.
          CONTINUE.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  LOOP AT mt_validation ASSIGNING <ls_vallist>.
    IF <ls_vallist>-val_cat = /bobf/if_conf_c=>sc_val_cat_action.
      DELETE mt_validation.
      CONTINUE.
    ENDIF.
    CHECK <ls_vallist>-node_cat IS BOUND.
    READ TABLE mt_node
        WITH TABLE KEY node_key = <ls_vallist>-node_key
        INTO ls_node.
    DESCRIBE TABLE <ls_vallist>-node_cat->* LINES lv_ncat_val.
    IF lv_ncat_val = 0.
*     validation not enabled for any node cat
      DELETE mt_validation.
      CONTINUE.
    ENDIF.
    DESCRIBE TABLE ls_node-node_cat->* LINES lv_ncat_all.
    IF lv_ncat_all = lv_ncat_val.
*     validation is enabled for all node cats
      FREE <ls_vallist>-node_cat->*.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD BUILD_VALUE_SET.

  DATA: ls_vset_d      TYPE        /BOBF/OBM_VSET,
        ls_vset        TYPE        /BOBF/S_CONFRO_VALUE_SET,
        ls_code_list_d TYPE        /BOBF/OBM_CODE_L,
        ls_code_list   TYPE        /BOBF/S_CONFRO_CODE_LIST,
        lo_area_handle TYPE REF TO cl_abap_memory_area,
        lv_tabix       TYPE        i,
        lv_const_name  TYPE        string.

  FIELD-SYMBOLS: <ls_vset>     TYPE /BOBF/S_CONFRO_VALUE_SET,
                 <lv_constant> TYPE any.

  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).
  lv_tabix = 0.
  LOOP AT it_vset INTO ls_vset_d.
    IF ls_vset_d-vset_cat = /BOBF/IF_CONF_C=>SC_VSET_CAT_IDENTIFIER AND
       ls_vset_d-assoc_key IS INITIAL.
*     no association assign to an identifier value set
      ASSERT ID /BOBF/CONF CONDITION 0 = 1. "#EC BOOL_OK
    ENDIF.

    MOVE-CORRESPONDING ls_vset_d TO ls_vset.
    INSERT ls_vset INTO TABLE mt_vset ASSIGNING <ls_vset>.
*   set code list
    IF ls_vset_d-vset_cat = /BOBF/IF_CONF_C=>SC_VSET_CAT_CODE.
      CREATE DATA <ls_vset>-code_list AREA HANDLE lo_area_handle.
      CHECK <ls_vset>-code_cif_name IS NOT INITIAL.
      LOOP AT it_code_list INTO ls_code_list_d FROM lv_tabix WHERE vset_key = ls_vset_d-vset_key.
        CONCATENATE  <ls_vset>-code_cif_name '=>' ls_code_list_d-code_name INTO lv_const_name.
        ASSIGN (lv_const_name) TO <lv_constant>.
        ls_code_list-content = <lv_constant>.
        INSERT ls_code_list INTO TABLE <ls_vset>-code_list->*.
        lv_tabix = sy-tabix.
      ENDLOOP.
    ENDIF.
*   link association
    IF ls_vset_d-assoc_key IS NOT INITIAL.
      READ TABLE mt_assoc REFERENCE INTO <ls_vset>-assoc
        WITH KEY assoc_key = ls_vset_d-assoc_key.
    ENDIF.
*   link node
    IF ls_vset_d-node_key IS NOT INITIAL.
      READ TABLE mt_node REFERENCE INTO <ls_vset>-node
        WITH KEY node_key = ls_vset_d-node_key.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD check_consistency.

  DATA:
    ls_ref_do          TYPE ts_referenced_do,
    lo_log             TYPE REF TO /bobf/cl_conf_log,
    lo_confrt_complete TYPE REF TO /bobf/cl_confrt_complete.

  rv_consistent = abap_true.

  LOOP AT mt_referenced_do INTO ls_ref_do.
    TRY .
        lo_confrt_complete ?= /bobf/cl_frw_factory=>get_configuration( iv_bo_key = ls_ref_do-do_key ).
      CATCH /bobf/cx_frw.
        CREATE OBJECT lo_log.
        lo_log->write_log(
           iv_severity = /bobf/cl_conf_log=>gc_severity-error
           iv_info = |Exception while retrieving configuration of BO { ls_ref_do-do_name }|
        ).
        rv_consistent = abap_false.
        RETURN.
    ENDTRY.

    IF ls_ref_do-build_timestamp <> lo_confrt_complete->get_build_timestamp( ).
      CREATE OBJECT lo_log.
      lo_log->write_log(
        EXPORTING
          iv_severity = /bobf/cl_conf_log=>gc_severity-error
          iv_info     = |Referenced object { ls_ref_do-do_name } is outdated in conf object of { ms_obj-bo_name }. Expected: {
                         ls_ref_do-build_timestamp } Actual: { lo_confrt_complete->get_build_timestamp( ) }|
      ).

      rv_consistent = abap_false.
      RETURN.
    ENDIF.
  ENDLOOP.
ENDMETHOD.


METHOD constructor.

  mv_bo_key  = iv_bo_key.

  GET TIME STAMP FIELD mv_build_timestamp.
ENDMETHOD.


METHOD CREATE_EXT_INCL.

* instanciate all extension include in order to get this shared object
* invalidated if extension fields change. Either by import or by extension.

  DATA:   ls_node            TYPE /BOBF/S_CONFRO_NODE,
          lo_area_handle     TYPE REF TO cl_abap_memory_area,
          lo_ext_incl        TYPE REF TO data.

  lo_area_handle = /BOBF/CL_CONF_SHARED_CONSTRUCT=>GET_AREA_HANDLE( ).

  LOOP AT mt_node INTO ls_node
    WHERE ext_incl_name IS NOT INITIAL.                 "#EC CI_SORTSEQ
    TRY.
        CREATE DATA lo_ext_incl AREA HANDLE lo_area_handle TYPE (ls_node-ext_incl_name).
        APPEND lo_ext_incl TO mt_ext_incl.
      CATCH cx_sy_create_data_error.
        " ignore this, seems to be something like a CI include
        " (CI include is a 'placeholder', which is populated with components at customer site)
    ENDTRY.
  ENDLOOP.

ENDMETHOD.


METHOD determine_node_auth_node_key.

  " calculate node key, which has auth checks (also the "own" node key is ok)...

  IF me->determine_node_has_auth_checks( is_node ) = abap_true.

    ev_auth_node_key = is_node-node_key.

  ELSEIF is_node-parent_node_key IS NOT INITIAL.

    FIELD-SYMBOLS <ls_parent_node> TYPE /bobf/s_confro_node.
    READ TABLE mt_node WITH TABLE KEY node_key = is_node-parent_node_key ASSIGNING <ls_parent_node>.

    me->determine_node_auth_node_key(
      EXPORTING
        is_node          = <ls_parent_node>
      IMPORTING
        ev_auth_node_key = ev_auth_node_key ).

  ENDIF.

ENDMETHOD.


METHOD determine_node_has_auth_checks.

  " 3 criteria have to be met...
  "   - auth check flag is active
  "   - auth check class is set
  "   - at least one auth obj is assigned

  IF is_node-auth_check_relevant = abap_true
    AND is_node-auth_check_class IS NOT INITIAL.
    " AND lines( is_node-auth_obj_names->* ) > 0.  // no criteria anymore...

    rv_has_auth_checks  = abap_true.

  ELSE.

    rv_has_auth_checks  = abap_false.

  ENDIF.

ENDMETHOD.


METHOD FILTER_INACTIVE_GROUPS.

  DATA: ls_groups    TYPE /BOBF/S_CONFRO_GROUPC.

  FIELD-SYMBOLS:
        <ls_exec>    TYPE /BOBF/S_CONFRO_EXECTIME,
        <ls_det>     TYPE /BOBF/S_CONFRO_DET_LIST,
        <ls_act>     TYPE /BOBF/S_CONFRO_ACT_LIST,
        <ls_val>     TYPE /BOBF/S_CONFRO_VAL_LIST.

* ____________________________________________________________________ *
* use context information to reduce grouped items
  LOOP AT mt_groupc INTO ls_groups.
    READ TABLE it_inactive_groups WITH KEY group_key
      COMPONENTS group_key = ls_groups-group_key
      TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
*     group is active -> delete it from groupc
      DELETE mt_groupc.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* filter determinations
  LOOP AT mt_exectime ASSIGNING <ls_exec>.
    LOOP AT <ls_exec>-det_list->* ASSIGNING <ls_det>.
*     check if determination is inactive
      READ TABLE mt_groupc
        WITH KEY content_cat = /BOBF/IF_CONF_C=>SC_CONTENT_DET
                 content_key = <ls_det>-det_key
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        DELETE <ls_exec>-det_list->*.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

* ____________________________________________________________________ *
* filter action validations
  LOOP AT mt_act ASSIGNING <ls_act>.
    LOOP AT <ls_act>-val_list->* ASSIGNING <ls_val>.
*     check if validation is inactive
      READ TABLE mt_groupc
        WITH KEY content_cat = /BOBF/IF_CONF_C=>SC_CONTENT_VAL
                 content_key = <ls_val>-val_key
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        DELETE <ls_act>-val_list->*.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

* ____________________________________________________________________ *
* filter consistency validations
  LOOP AT mt_validation ASSIGNING <ls_val>.
*     check if validation is inactive
    READ TABLE mt_groupc
      WITH KEY content_cat = /BOBF/IF_CONF_C=>SC_CONTENT_VAL
               content_key = <ls_val>-val_key
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      DELETE mt_validation.
    ENDIF.
  ENDLOOP.

* not used any more
  CLEAR mt_groupc.

ENDMETHOD.


METHOD flush_table_keys.

  FIELD-SYMBOLS:
    <ls_act>          TYPE /bobf/s_confro_act_list,
    <ls_altkey>       TYPE /bobf/s_confro_altkey,
    <ls_assoc>        TYPE /bobf/s_confro_assoc,
    <ls_assoc_chg>    TYPE /bobf/s_confro_assoc_chg,
    <ls_exectime>     TYPE /bobf/s_confro_exectime,
    <ls_det>          TYPE /bobf/s_confro_det_list,
    <ls_node>         TYPE /bobf/s_confro_node,
    <ls_property>     TYPE /bobf/s_confro_property,
    <ls_property_prx> TYPE /bobf/s_confro_property_prx,
    <ls_property_chg> TYPE /bobf/s_confro_prop_chg,
    <ls_val>          TYPE /bobf/s_confro_val_list.


  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_act ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_altkey ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_assoc ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_assoc_change ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_comp ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_content_key_map ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_group ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_exectime ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_fieldmapping ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_groupc ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_node ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_property ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_property_prx ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_property_change ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_fieldmapping ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_query ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_sta_deriv ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_sta_var ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_validation ).
  cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = mt_vset ).

  LOOP AT mt_act ASSIGNING <ls_act>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_act>-val_list->* ).
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_act>-act_read->* ).
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_act>-act_write->* ).
  ENDLOOP.
  LOOP AT mt_altkey ASSIGNING <ls_altkey>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_altkey>-field_names->* ).
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_altkey>-prx_field_names->* ).
  ENDLOOP.
  LOOP AT mt_assoc ASSIGNING <ls_assoc>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_assoc>-node_cat->* ).
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_assoc>-assoc_binding->* ).
  ENDLOOP.
  LOOP AT mt_assoc_change ASSIGNING <ls_assoc_chg>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_assoc_chg>-trigger->* ).
  ENDLOOP.
  LOOP AT mt_exectime ASSIGNING <ls_exectime>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_exectime>-det_list->* ).
    LOOP AT <ls_exectime>-det_list->* ASSIGNING <ls_det>.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_det>-det_trigger->* ).
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_det>-det_read->* ).
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_det>-det_write->* ).
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_det>-node_cat->* ).
    ENDLOOP.
  ENDLOOP.
  LOOP AT mt_node ASSIGNING <ls_node>.
    IF <ls_node>-node_cat IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-node_cat->* ).
    ENDIF.
    IF <ls_node>-dependent_db_node_keys IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-dependent_db_node_keys->* ).
    ENDIF.
    IF <ls_node>-field_names IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-field_names->* ).
    ENDIF.
    IF <ls_node>-det_trigger_attr_create IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-det_trigger_attr_create->* ).
    ENDIF.
    IF <ls_node>-det_trigger_attr_update IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-det_trigger_attr_update->* ).
    ENDIF.
    IF <ls_node>-det_trigger_attr_delete IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-det_trigger_attr_delete->* ).
    ENDIF.
    IF <ls_node>-val_trigger_attr_create IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-val_trigger_attr_create->* ).
    ENDIF.
    IF <ls_node>-val_trigger_attr_update IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-val_trigger_attr_update->* ).
    ENDIF.
    IF <ls_node>-val_trigger_attr_delete IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-val_trigger_attr_delete->* ).
    ENDIF.
    IF <ls_node>-status_attributes IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-status_attributes->* ).
    ENDIF.
    IF <ls_node>-det_load_attributes IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-det_load_attributes->* ).
    ENDIF.
    IF <ls_node>-internal_properties IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_node>-internal_properties->* ).
    ENDIF.
  ENDLOOP.

  LOOP AT mt_property ASSIGNING <ls_property>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_property>-property->* ).
  ENDLOOP.
  LOOP AT mt_property_prx ASSIGNING <ls_property_prx>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_property_prx>-property->* ).
  ENDLOOP.
  LOOP AT mt_property_change ASSIGNING <ls_property_chg>.
    cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_property_chg>-trigger->* ).
  ENDLOOP.
  LOOP AT mt_validation ASSIGNING <ls_val>.
    IF <ls_val>-val_read IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_val>-val_read->* ).
    ENDIF.
    IF <ls_val>-val_trigger IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_val>-val_trigger->* ).
    ENDIF.
    IF <ls_val>-node_cat IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_val>-node_cat->* ).
    ENDIF.
    IF <ls_val>-val_group IS BOUND.
      cl_abap_itab_utilities=>flush_itab_keys( CHANGING itab = <ls_val>-val_group->* ).
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD GET_SUBNODE.

  DATA:
        ls_comp        TYPE /BOBF/S_CONFRO_ASSOC2,
        lt_subnode_key TYPE /BOBF/T_FRW_KEY2.

  CLEAR et_subnode_key.

  LOOP AT mt_comp INTO ls_comp WHERE
      source_node_key = iv_node_key.
    get_subnode(
      EXPORTING
        iv_node_key = ls_comp-target_node_key
      IMPORTING
        et_subnode_key = lt_subnode_key ).
    APPEND LINES OF lt_subnode_key TO et_subnode_key.
    APPEND ls_comp-target_node_key TO et_subnode_key.
  ENDLOOP.

ENDMETHOD.


METHOD initialize_from_db.

  DATA: lt_bo                TYPE TABLE OF /bobf/obm_bo,
        ls_bo                TYPE          /bobf/obm_bo,
        lt_bo_key            TYPE          /bobf/t_frw_key,
        lt_new_bo_key        TYPE          /bobf/t_frw_key,
        ls_key               TYPE          /bobf/s_frw_key,
        lt_models            TYPE          tt_models,
        lt_models_temp       TYPE          tt_models,
        ls_models            TYPE          ts_models,
        ls_obj               TYPE          /bobf/obm_obj,
        lt_node              TYPE          tt_node,
        lt_node_redef        TYPE          tt_node,
        ls_node              TYPE          /bobf/obm_node,
        ls_node_origin       TYPE          /bobf/obm_node,
        lv_node_key          TYPE          /bobf/obm_node_key,
        lt_bo_name           TYPE TABLE OF /bobf/obm_name,
        lv_bo_name           TYPE          /bobf/obm_name,
        lt_assocb            TYPE          tt_assocb,
        lt_act_conf          TYPE TABLE OF /bobf/act_conf,
        lt_rtw               TYPE          tt_rtw,
        lt_rtw_a             TYPE          tt_rtw_a,
        lt_val_group         TYPE TABLE OF /bobf/obm_group,
        lt_det               TYPE TABLE OF /bobf/det_list,
        ls_det               TYPE          /bobf/det_list,
        lt_det1              TYPE          /bobf/t_confro_det_list,
        ls_det1              TYPE          /bobf/s_confro_det_list,
        lt_detconf           TYPE          tt_detconf,
        lt_detnet            TYPE TABLE OF /bobf/det_net,
        lt_nodecat           TYPE          tt_nodecat,
        lt_sta_schema        TYPE          tt_sta_schema,
        lt_acf_map           TYPE          tt_acf_map,
        lt_auth_obj          TYPE          tt_auth_obj,
        lt_property          TYPE TABLE OF /bobf/obm_propty,
        lt_property_prx      TYPE TABLE OF /bobf/obm_prxpty,
        lt_val               TYPE TABLE OF /bobf/val_list,
        lt_valconf           TYPE TABLE OF /bobf/val_conf,
        lt_valnet            TYPE TABLE OF /bobf/val_net,
        lt_vset              TYPE          tt_val_set,
        lt_code_list         TYPE          tt_code_list,
        lt_assocc            TYPE          /bobf/t_confro_assocc,
        lt_disabled_elements TYPE SORTED TABLE OF /bobf/obm_disel WITH NON-UNIQUE KEY content_node_key,
        ls_disabled_elements TYPE          /bobf/obm_disel,
        lt_fieldmapping      TYPE          tt_map,
        lv_version           TYPE          /bobf/conf_version VALUE /bobf/if_conf_c=>sc_version_active.

  FIELD-SYMBOLS:
    <ls_node>      TYPE          /bobf/obm_node,
    <ls_node_conf> TYPE          /bobf/s_confro_node.

  DATA(lx_exception) = is_loadable_bo( iv_bo_key = mv_bo_key ).
  IF lx_exception IS BOUND.
    RAISE EXCEPTION lx_exception.
  ENDIF.

  IF is_obm_obj IS NOT INITIAL.
*   If it was selected before in shared_constructor->build
*   do not access DB Table again
    ls_obj = is_obm_obj.
  ELSE.
*   read BO table
    SELECT SINGLE *                                         "#EC WARNOK
      FROM /bobf/obm_obj
      INTO ls_obj
      WHERE bo_key  = mv_bo_key
        AND version = lv_version.
  ENDIF.

  MOVE-CORRESPONDING ls_obj TO ms_obj.
  ms_obj-bo_name = ls_obj-name.
  mv_last_change_time = ls_obj-last_change_time.

  /bobf/cl_frw_factory=>collect_connected_bos(
    EXPORTING
      iv_bo_key = mv_bo_key
    IMPORTING
      et_bo     = mt_collected_bos
  ).

* Business object can be instantiated
  IF ls_obj-abstract = abap_true.
    ASSERT ID /bobf/conf CONDITION 0 = 1.                  "#EC BOOL_OK
    RAISE EXCEPTION TYPE /bobf/cx_conf
      EXPORTING
        textid     = /bobf/cx_conf=>bo_is_abstract
        mv_bo_name = ls_obj-name.
  ENDIF.

  IF ls_obj-genil_enabled = abap_false.
    CLEAR ms_obj-genil_comp_name.
    CLEAR ms_obj-genil_prefix.
  ENDIF.

* read Proxy BO name
  SELECT SINGLE bo_key bo_esr_name bo_name super_bo_key super_bo_name extension "#EC WARNOK
    FROM /bobf/obm_bo
    INTO CORRESPONDING FIELDS OF ls_bo
    WHERE bo_key = mv_bo_key.
  ms_obj-bo_esr_name = ls_bo-bo_esr_name.
  ls_key-key = mv_bo_key.
  APPEND ls_key        TO lt_bo_key.
  APPEND ls_bo-bo_name TO lt_bo_name.

  ls_models-bo_name       = ls_bo-bo_name.
  ls_models-super_bo_name = ls_bo-super_bo_name.
  ls_models-extension     = ls_bo-extension.
  APPEND ls_models TO lt_models.

* search for super objects
  DO.
    IF ls_bo-super_bo_key IS INITIAL.
      EXIT.
    ENDIF.
    ls_key-key = ls_bo-super_bo_key.
    APPEND ls_key        TO lt_bo_key.
    APPEND ls_bo-bo_name TO lt_bo_name.

    SELECT SINGLE bo_key bo_name bo_esr_name super_bo_key super_bo_name extension "#EC WARNOK
      FROM /bobf/obm_bo
      INTO CORRESPONDING FIELDS OF ls_bo
      WHERE bo_key = ls_bo-super_bo_key.
    IF ms_obj-bo_esr_name IS INITIAL.
      " set the bo name of available, the name of the most upper one cannot be used
      ms_obj-bo_esr_name = ls_bo-bo_esr_name.
    ENDIF.
    ls_models-bo_name       = ls_bo-bo_name.
    ls_models-super_bo_name = ls_bo-super_bo_name.
    ls_models-extension     = ls_bo-extension.
    APPEND ls_models TO lt_models.
  ENDDO.

* super object found > read buffer and derivator class of top most version
  IF lines( lt_bo_name ) > 1.
    SELECT SINGLE *                                         "#EC WARNOK
      FROM /bobf/obm_obj
      INTO ls_obj
      WHERE bo_key  = ls_bo-bo_key
        AND version = lv_version.
    ms_obj-buffer_class    = ls_obj-buffer_class.
    ms_obj-derivator_class = ls_obj-derivator_class.
    IF ms_obj-mapper_class IS INITIAL.
      ms_obj-mapper_class = ls_obj-mapper_class.
    ENDIF.
  ENDIF.

  " initialize load plugins
  DATA lv_active TYPE boole_d.
  DATA(lt_load_plugin) = initialize_load_plugins( ).

* search for extensions
  " [IM 2754646 2012] take also extensions of super objects into account
  " ls_key-key = mv_bo_key.
  " INSERT ls_key INTO TABLE lt_new_bo_key.
  lt_new_bo_key = lt_bo_key.

  WHILE lt_new_bo_key IS NOT INITIAL.

    SELECT *
      FROM /bobf/obm_bo
      INTO TABLE lt_bo
      FOR ALL ENTRIES IN lt_new_bo_key
      WHERE super_bo_key = lt_new_bo_key-key AND
            extension    = abap_true.
    CLEAR lt_new_bo_key.
    LOOP AT lt_bo INTO ls_bo.
      " check if enhancement is active (might be disabled by load plugins)
      lv_active = abap_true.
      LOOP AT lt_load_plugin INTO DATA(ls_load_plugin).
        lv_active = ls_load_plugin-object->is_enhancement_active(
          EXPORTING
            iv_enhancement_bo_key  = ls_bo-bo_key
            iv_enhancement_bo_name = ls_bo-bo_name ).
        IF lv_active = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF lv_active = abap_false.
        CONTINUE.
      ENDIF.
      ls_key-key = ls_bo-bo_key.
      APPEND ls_key TO lt_bo_key.
      APPEND ls_key TO lt_new_bo_key.
      ls_models-bo_name       = ls_bo-bo_name.
      ls_models-super_bo_name = ls_bo-super_bo_name.
      ls_models-extension     = ls_bo-extension.
      APPEND ls_models TO lt_models.
    ENDLOOP.
  ENDWHILE.

  " sort models according to super relations
  SORT lt_models ASCENDING BY super_bo_name bo_name.
  LOOP AT lt_models INTO ls_models
    WHERE super_bo_name IS INITIAL.
    APPEND ls_models TO lt_models_temp. " all models without a super (should be always one)
    DELETE lt_models.
  ENDLOOP.
  WHILE lt_models IS NOT INITIAL. " loop to append all models that's super models are already in ~temp
    LOOP AT lt_models INTO ls_models.
      READ TABLE lt_models_temp TRANSPORTING NO FIELDS
        WITH KEY bo_name = ls_models-super_bo_name.
      CHECK sy-subrc = 0.
      APPEND ls_models TO lt_models_temp.
      DELETE lt_models.
    ENDLOOP.
  ENDWHILE.
  lt_models = lt_models_temp.

  BREAK-POINT ID /bobf/conf.
  BREAK-POINT ID /bobf/conf_sh.

  ms_obj-delete_loads_data = abap_false.

  IF ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_mo.
    ms_obj-notify_association_changes = abap_false.
    ms_obj-notify_property_changes    = abap_false.
  ELSE.
    ms_obj-notify_association_changes = abap_true.
    ms_obj-notify_property_changes    = abap_true.
  ENDIF.

  IF ms_obj-check_services IS INITIAL.
    ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_skip.
  ENDIF.
  IF ms_obj-chk_serv_action IS INITIAL.
    ms_obj-chk_serv_action = ms_obj-check_services.
  ENDIF.
  IF ms_obj-chk_serv_assoc IS INITIAL.
    ms_obj-chk_serv_assoc = ms_obj-check_services.
  ENDIF.

* set union DAC indication...
  IF   ms_obj-mapper_class = /bobf/if_conf_def_classes_c=>gc_cl_dac_union
    OR ms_obj-mapper_class = /bobf/if_conf_def_classes_c=>gc_cl_dac_table_union.
    ms_obj-union_dac = abap_true.
  ENDIF.

* adjust feature annotation regarding 'union DAC' (draft), since early 'union DAC' BOs may not have been synchronized...
  IF ms_obj-feature_annotation NS /bobf/if_conf_c=>sc_feature-draft_union_dac.
    IF ms_obj-union_dac = abap_true.
      IF ms_obj-feature_annotation IS INITIAL.
        ms_obj-feature_annotation = /bobf/if_conf_c=>sc_feature-draft_union_dac.
      ELSE.
        ms_obj-feature_annotation = |{ ms_obj-feature_annotation },{ /bobf/if_conf_c=>sc_feature-draft_union_dac }|.
      ENDIF.
    ENDIF.
  ENDIF.

* adjust feature annotation regarding 'refactored lib' (draft), since early 'refactored lib' BOs may not have been synchronized...
  IF ms_obj-feature_annotation NS /bobf/if_conf_c=>sc_feature-draft_refactored_lib.
    SELECT SINGLE act_class INTO @DATA(lv_edit_class)
      FROM /bobf/act_list
        WHERE bo_key         = @mv_bo_key
          AND version        = @lv_version
          AND act_annotation = @/bobf/if_conf_c=>sc_act_anno_draft_edit.   "#EC CI_NOORDER
    IF lv_edit_class = /bobf/if_conf_def_classes_c=>gc_cl_lib_draft_edit.
      IF ms_obj-feature_annotation IS INITIAL.
        ms_obj-feature_annotation = /bobf/if_conf_c=>sc_feature-draft_refactored_lib.
      ELSE.
        ms_obj-feature_annotation = |{ ms_obj-feature_annotation },{ /bobf/if_conf_c=>sc_feature-draft_refactored_lib }|.
      ENDIF.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* select required data
  SELECT *
    FROM /bobf/obm_disel
    INTO TABLE lt_disabled_elements
    WHERE bo_key  = mv_bo_key
      AND version = lv_version.

* get group definitions
  SELECT *
    FROM /bobf/obm_groupc
    INTO CORRESPONDING FIELDS OF TABLE mt_groupc
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
     AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-group_conf.
    READ TABLE mt_groupc TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE mt_groupc INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

* get all other data
  SELECT *
    FROM /bobf/obm_altkey
    INTO CORRESPONDING FIELDS OF TABLE mt_altkey
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-alternative_key.
    READ TABLE mt_altkey TRANSPORTING NO FIELDS
      WITH KEY altkey_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE mt_altkey INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_assoc
    INTO CORRESPONDING FIELDS OF TABLE mt_assoc
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-association.
    READ TABLE mt_assoc TRANSPORTING NO FIELDS
      WITH KEY assoc_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE mt_assoc INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_assocb
    INTO TABLE lt_assocb
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-association_binding.
    READ TABLE lt_assocb TRANSPORTING NO FIELDS
      WITH KEY assocb_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_assocb INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_assocc
    INTO CORRESPONDING FIELDS OF TABLE lt_assocc
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-association_conf.
    READ TABLE lt_assocc TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_assocc INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_node
    INTO CORRESPONDING FIELDS OF TABLE lt_node
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-node.
    DELETE lt_node WHERE node_key = ls_disabled_elements-content_key.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_ncat
    INTO CORRESPONDING FIELDS OF TABLE lt_nodecat
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-node_cat.
    READ TABLE lt_nodecat TRANSPORTING NO FIELDS
      WITH KEY node_cat_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_nodecat INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_rtw
    INTO TABLE lt_rtw
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version
      AND modeled_only = abap_false.

  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-determination_read
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-determination_write
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-determination_trigger
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-action_read
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-action_write
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-validation_read
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-validation_trigger
       OR content_node_key = /bobf/if_conf_obj_c=>sc_node-property_change_trigger. "#EC CI_SORTSEQ
    READ TABLE lt_rtw TRANSPORTING NO FIELDS
      WITH KEY rtw_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_rtw INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_rtw_a
    INTO TABLE lt_rtw_a
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version
      AND access_cat = /bobf/if_conf_c=>sc_access_write
      AND content_cat = /bobf/if_conf_c=>sc_content_det.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-attribute_information.
    READ TABLE lt_rtw_a TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_rtw_a INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  DATA lt_rtw_a_trigger TYPE tt_rtw_a.
  SELECT *
    FROM /bobf/obm_rtw_a
    INTO TABLE lt_rtw_a_trigger
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version
      AND access_cat = /bobf/if_conf_c=>sc_access_trigger.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-attribute_information.
    READ TABLE lt_rtw_a_trigger TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_rtw_a_trigger INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/act_list
    INTO CORRESPONDING FIELDS OF TABLE mt_act
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-action.
    READ TABLE mt_act TRANSPORTING NO FIELDS
      WITH KEY act_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE mt_act INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/act_conf
    INTO TABLE lt_act_conf
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-action_conf.
    READ TABLE lt_act_conf TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_act_conf INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/det_list
    INTO TABLE lt_det
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-determination.
    READ TABLE lt_det TRANSPORTING NO FIELDS
      WITH KEY det_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_det INDEX sy-tabix.
    ENDIF.
  ENDLOOP.
  SORT lt_det BY det_name.

  SELECT *
    FROM /bobf/det_conf
    INTO CORRESPONDING FIELDS OF TABLE lt_detconf
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-determination_conf.
    READ TABLE lt_detconf TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_detconf INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/det_net
    INTO TABLE lt_detnet
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-determination_dep.
    READ TABLE lt_detnet TRANSPORTING NO FIELDS
      WITH KEY net_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_detnet INDEX sy-tabix.
    ENDIF.
  ENDLOOP.
  SORT lt_detnet BY det_key_from det_key_to.

  SELECT *
    FROM /bobf/obm_propty
    INTO TABLE lt_property
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-static_prty.
    READ TABLE lt_property TRANSPORTING NO FIELDS
      WITH KEY property_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_property INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_prxpty
    INTO TABLE lt_property_prx
    WHERE bo_key  = mv_bo_key
      AND version = lv_version.

  SELECT *
    FROM /bobf/obm_query
    INTO CORRESPONDING FIELDS OF TABLE mt_query
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-query.
    READ TABLE mt_query TRANSPORTING NO FIELDS
      WITH KEY query_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE mt_query INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/val_list
    INTO TABLE lt_val
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-validation.
    READ TABLE lt_val TRANSPORTING NO FIELDS
      WITH KEY val_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_val INDEX sy-tabix.
    ENDIF.
  ENDLOOP.
  SORT lt_val BY val_name.

  SELECT *
    FROM /bobf/val_conf
    INTO TABLE lt_valconf
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-validation_conf.
    READ TABLE lt_valconf TRANSPORTING NO FIELDS
      WITH KEY conf_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_valconf INDEX sy-tabix.
    ENDIF.
  ENDLOOP.
  SORT lt_valconf BY val_key.

  SELECT *
    FROM /bobf/val_net
    INTO TABLE lt_valnet
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-validation_dep.
    READ TABLE lt_valnet TRANSPORTING NO FIELDS
      WITH KEY net_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_valnet INDEX sy-tabix.
    ENDIF.
  ENDLOOP.
  SORT lt_valnet BY val_key_from val_key_to.

  SELECT *
    FROM /bobf/obm_map
    INTO TABLE lt_fieldmapping
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key      = lt_bo_key-key
      AND version     = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-mapping.
    READ TABLE lt_fieldmapping TRANSPORTING NO FIELDS
      WITH KEY map_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_fieldmapping INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_group
    INTO CORRESPONDING FIELDS OF TABLE lt_val_group
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key      = lt_bo_key-key
      AND version     = lv_version
      AND ( group_cat = /bobf/if_conf_c=>sc_group_cat_consistency
      OR  group_cat   = /bobf/if_conf_c=>sc_group_cat_check ).
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-group.
    READ TABLE lt_val_group TRANSPORTING NO FIELDS
      WITH KEY group_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_val_group INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_vset
    INTO TABLE lt_vset
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-value_set.
    READ TABLE lt_vset TRANSPORTING NO FIELDS
      WITH KEY vset_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_vset INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/obm_code_l
    INTO TABLE lt_code_list
    FOR ALL ENTRIES IN lt_bo_key
      WHERE bo_key  = lt_bo_key-key
        AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-value_set_code_list.
    READ TABLE lt_code_list TRANSPORTING NO FIELDS
      WITH KEY vset_cl_key = ls_disabled_elements-content_key. "#EC CI_SORTSEQ
    IF sy-subrc = 0.
      DELETE lt_code_list INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/sta_var
    INTO CORRESPONDING FIELDS OF TABLE mt_sta_var
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key  = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-status_variable.
    READ TABLE mt_sta_var TRANSPORTING NO FIELDS
      WITH KEY sta_var_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE mt_sta_var INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/sta_deriv
    INTO CORRESPONDING FIELDS OF TABLE mt_sta_deriv
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-status_derivator.
    READ TABLE mt_sta_deriv TRANSPORTING NO FIELDS
      WITH KEY sta_deriv_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE mt_sta_deriv INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/sta_schema
    INTO TABLE lt_sta_schema
    FOR ALL ENTRIES IN lt_bo_key
    WHERE bo_key = lt_bo_key-key
      AND version = lv_version.
  LOOP AT lt_disabled_elements INTO ls_disabled_elements
    WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-status_schema.
    READ TABLE lt_sta_schema TRANSPORTING NO FIELDS
      WITH KEY sta_schema_key = ls_disabled_elements-content_key.
    IF sy-subrc = 0.
      DELETE lt_sta_schema INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  SELECT *
    FROM /bobf/conf_time
    INTO CORRESPONDING FIELDS OF TABLE mt_exectime.

  " main switch at header should always win...
  IF ls_obj-auth_check_relevant = abap_true.
    SELECT *
      FROM /bobf/auth_obj
      INTO TABLE lt_auth_obj
      FOR ALL ENTRIES IN lt_bo_key
      WHERE bo_key = lt_bo_key-key
        AND version = lv_version.
    LOOP AT lt_disabled_elements INTO ls_disabled_elements
      WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-authorization_object.
      READ TABLE lt_auth_obj TRANSPORTING NO FIELDS
        WITH KEY auth_obj_key = ls_disabled_elements-content_key.
      IF sy-subrc = 0.
        DELETE lt_auth_obj INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
    SELECT *
      FROM /bobf/acf_map
      INTO TABLE lt_acf_map
      FOR ALL ENTRIES IN lt_bo_key
      WHERE bo_key = lt_bo_key-key
        AND version = lv_version.
    LOOP AT lt_disabled_elements INTO ls_disabled_elements
      WHERE content_node_key = /bobf/if_conf_obj_c=>sc_node-access_ctrl_field_mapping.
      READ TABLE lt_acf_map TRANSPORTING NO FIELDS
        WITH KEY acf_map_key = ls_disabled_elements-content_key.
      IF sy-subrc = 0.
        DELETE lt_acf_map INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
* adopt model for redefinitions
  SORT lt_node BY node_key.
  LOOP AT lt_node ASSIGNING <ls_node>.
    IF <ls_node>-node_key <> lv_node_key.
      IF lines( lt_node_redef ) > 1.
*       find lowest inherited instance
        DO.
          READ TABLE lt_bo_name INTO lv_bo_name INDEX sy-index.
          ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
          IF sy-subrc <> 0.
            CLEAR lv_bo_name.
            EXIT.
          ENDIF.
          READ TABLE lt_node_redef INTO ls_node_origin
            WITH KEY name = lv_bo_name.
          IF sy-subrc = 0.
            EXIT.
          ENDIF.
        ENDDO.
*       add redefinable attributes to inherited node and delete other nodes
        IF lv_bo_name IS NOT INITIAL.
          DELETE lt_node_redef INDEX sy-tabix.
          READ TABLE lt_node_redef INTO ls_node INDEX 1.
          ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
          DELETE lt_node WHERE node_key = lv_node_key.
          ls_node-database_table   = ls_node_origin-database_table.
          ls_node-node_cat_key     = ls_node_origin-node_cat_key.
          ls_node-node_class       = ls_node_origin-node_class.
          ls_node-mapper_class     = ls_node_origin-mapper_class.
          ls_node-lcp_wrap_class   = ls_node_origin-lcp_wrap_class.
          ls_node-sta_parent_assoc = ls_node_origin-sta_parent_assoc.
          ls_node-sta_child_assoc  = ls_node_origin-sta_child_assoc.
          INSERT ls_node INTO lt_node INDEX 1.
        ENDIF.
      ENDIF.
      CLEAR lt_node_redef.
    ENDIF.
    APPEND <ls_node> TO lt_node_redef.
    lv_node_key = <ls_node>-node_key.
  ENDLOOP.
  IF lines( lt_node_redef ) > 1.
*   find lowest inherited instance
    DO.
      READ TABLE lt_bo_name INTO lv_bo_name INDEX sy-index.
      ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
      IF sy-subrc <> 0.
        CLEAR lv_bo_name.
        EXIT.
      ENDIF.
      READ TABLE lt_node_redef INTO ls_node_origin
        WITH KEY name = lv_bo_name.
      IF sy-subrc = 0.
        EXIT.
      ENDIF.
    ENDDO.
*   add redefinable attributes to inherited node and delete other nodes
    IF lv_bo_name IS NOT INITIAL.
      DELETE lt_node_redef INDEX sy-tabix.
      READ TABLE lt_node_redef INTO ls_node INDEX 1.
      ASSERT ID /bobf/conf CONDITION sy-subrc = 0.
      DELETE lt_node WHERE node_key = lv_node_key.
      ls_node-database_table = ls_node_origin-database_table.
      ls_node-node_cat_key   = ls_node_origin-node_cat_key.
      ls_node-node_class     = ls_node_origin-node_class.
      ls_node-mapper_class   = ls_node_origin-mapper_class.
      ls_node-lcp_wrap_class = ls_node_origin-lcp_wrap_class.
      INSERT ls_node INTO lt_node INDEX 1.
    ENDIF.
  ENDIF.
  CLEAR lt_node_redef.




* ____________________________________________________________________ *
* build internal tables

  build_node(
    EXPORTING
      it_node       = lt_node
      it_node_cat   = lt_nodecat
      it_sta_schema = lt_sta_schema
      it_auth_obj   = lt_auth_obj
      it_acf_map    = lt_acf_map
      it_det           = lt_det
      it_val           = lt_val
      it_rtw_a_trigger = lt_rtw_a_trigger
    CHANGING
      ct_rtw        = lt_rtw ).

  build_association( it_assocc  = lt_assocc
                     it_assocb  = lt_assocb
                     it_detconf = lt_detconf
                     it_rtw     = lt_rtw ).

  build_association_change( ).

  build_determination(
    EXPORTING
      it_rtw     = lt_rtw
      it_rtw_a   = lt_rtw_a
      it_detconf = lt_detconf
      it_detnet  = lt_detnet
      it_det     = lt_det
    CHANGING                 " only changing to avoid a table copy within the method
      ct_models  = lt_models ).

  build_fieldmapping( it_fieldmapping = lt_fieldmapping ).

  build_status_variable( ).

  build_action(
    it_rtw      = lt_rtw
    it_act_conf = lt_act_conf ).

  build_validation(
    EXPORTING
      it_rtw     = lt_rtw
      it_group   = lt_val_group
      it_valconf = lt_valconf
      it_valnet  = lt_valnet
    CHANGING
      ct_val     = lt_val ).

  build_property_change( it_rtw = lt_rtw ).

  build_query( ).

  build_altkey( ).

  build_property( it_property     = lt_property
                  it_property_prx = lt_property_prx
                  it_act_conf     = lt_act_conf
                  it_assoc_conf   = lt_assocc ).

  build_value_set( it_vset       = lt_vset
                   it_code_list  = lt_code_list ).

  set_lockload_subnode( ms_obj-root_node_key ).
  create_ext_incl( ).

* get model information of delegated nodes (black box approach)
  merge_delegated_model( ).

* (has to be called after the DO merge!)
  build_authorization( ls_obj-auth_check_relevant ).

* explicitely ensure that all secondary indexes are built
  flush_table_keys( ).

ENDMETHOD.


METHOD initialize_from_shared.

  DATA: ls_obj            TYPE /bobf/s_confro_obj,
        lo_shared         TYPE REF TO /bobf/if_confrt_complete,
        ls_exectime       TYPE /bobf/s_confro_exectime,
        ls_exectime_copy  TYPE /bobf/s_confro_exectime,
        ls_act_copy       TYPE /bobf/s_confro_act_list,
        lt_read           TYPE REF TO /bobf/t_confro_read,
        lt_act_write      TYPE REF TO /bobf/t_confro_act_write,
        lt_val_trig       TYPE REF TO /bobf/t_confro_val_trigger,
        lt_val_group      TYPE REF TO /bobf/t_confro_group,
        lt_det_trig       TYPE REF TO /bobf/t_confro_det_trigger,
        lt_det_write      TYPE REF TO /bobf/t_confro_det_write,
        lt_code_list      TYPE REF TO /bobf/t_confro_code_list,
        lt_node_cat       TYPE REF TO /bobf/t_confro_node_cat,
        lt_assoc_binding  TYPE REF TO /bobf/t_confro_assocb,
        lt_group_val_trig TYPE REF TO /bobf/t_confro_node_key.

  FIELD-SYMBOLS:
        <ls_act>          TYPE /bobf/s_confro_act_list,
        <ls_val>          TYPE /bobf/s_confro_val_list,
        <ls_det>          TYPE /bobf/s_confro_det_list,
        <ls_read>         TYPE /bobf/s_confro_read,
        <ls_act_write>    TYPE /bobf/s_confro_act_write,
        <ls_val_trig>     TYPE /bobf/s_confro_val_trigger,
        <ls_det_trig>     TYPE /bobf/s_confro_det_trigger,
        <ls_det_write>    TYPE /bobf/s_confro_det_write,
        <ls_val_group>    TYPE /bobf/s_confro_group,
        <ls_assoc>        TYPE /bobf/s_confro_assoc,
        <ls_comp>         TYPE /bobf/s_confro_assoc2,
        <ls_vset>         TYPE /bobf/s_confro_value_set.

  BREAK-POINT ID /bobf/conf_sh.

  lo_shared = io_shared_instance.
  ls_obj    = lo_shared->ms_obj.

* check if bo_key is correct
  IF ls_obj IS INITIAL OR
     ls_obj-bo_key <> mv_bo_key .
    ASSERT ID /bobf/conf CONDITION 0 = 1.                  "#EC BOOL_OK
    RAISE EXCEPTION TYPE /bobf/cx_conf
      EXPORTING
        textid = /bobf/cx_conf=>/bobf/cx_frw.
*     application error -> no configuration available
  ENDIF.

* _____________________________________________________________________________ *
* copy data
  mv_last_change_time = io_shared_instance->mv_last_change_time.

  ms_obj             = lo_shared->ms_obj.
  mt_altkey          = lo_shared->mt_altkey.
  mt_assoc           = lo_shared->mt_assoc.
  mt_assoc_change    = lo_shared->mt_assoc_change.
  mt_comp            = lo_shared->mt_comp.
  mt_content_key_map = lo_shared->mt_content_key_map.
  mt_fieldmapping    = lo_shared->mt_fieldmapping.
  mt_node            = lo_shared->mt_node.
  mt_property        = lo_shared->mt_property.
  mt_property_prx    = lo_shared->mt_property_prx.
  mt_property_change = lo_shared->mt_property_change.
  mt_query           = lo_shared->mt_query.
  mt_groupc          = lo_shared->mt_groupc.
  mt_validation      = lo_shared->mt_validation.
  mt_group           = lo_shared->mt_group.
  mt_vset            = lo_shared->mt_vset.
  mt_sta_var         = lo_shared->mt_sta_var.
  mt_sta_assoc       = lo_shared->mt_sta_assoc.
  mt_sta_deriv       = lo_shared->mt_sta_deriv.

* _____________________________________________________________________________ *
* hard copy deep internal tables (hold as reference) and relink internal references

* force copy of mt_exectime->det_list
  LOOP AT lo_shared->mt_exectime INTO ls_exectime.
    ls_exectime_copy = ls_exectime.
    CREATE DATA ls_exectime_copy-det_list.
    ls_exectime_copy-det_list->* = ls_exectime-det_list->*.
*   relink determinations
    LOOP AT ls_exectime_copy-det_list->* ASSIGNING <ls_det>.
*     relink determination read nodes
      lt_read = <ls_det>-det_read.
      CREATE DATA <ls_det>-det_read.
      <ls_det>-det_read->* = lt_read->*.
      LOOP AT <ls_det>-det_read->* ASSIGNING <ls_read>.
        CHECK <ls_read>-assoc IS NOT INITIAL.
        READ TABLE mt_assoc REFERENCE INTO <ls_read>-assoc
        WITH KEY assoc_key = <ls_read>-assoc->assoc_key.
      ENDLOOP.
*     relink determination trigger nodes
      lt_det_trig = <ls_det>-det_trigger.
      CREATE DATA <ls_det>-det_trigger.
      <ls_det>-det_trigger->* = lt_det_trig->*.
      LOOP AT <ls_det>-det_trigger->* ASSIGNING <ls_det_trig>.
        CHECK <ls_det_trig>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_det_trig>-assoc
          WITH KEY assoc_key = <ls_det_trig>-assoc->assoc_key.
      ENDLOOP.
*     relink determination write nodes
      lt_det_write = <ls_det>-det_write.
      CREATE DATA <ls_det>-det_write.
      <ls_det>-det_write->* = lt_det_write->*.
      LOOP AT <ls_det>-det_write->* ASSIGNING <ls_det_write>.
        CHECK <ls_det_write>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_det_write>-assoc
         WITH KEY assoc_key = <ls_det_write>-assoc->assoc_key.
      ENDLOOP.
    ENDLOOP.
    INSERT ls_exectime_copy INTO TABLE mt_exectime.
  ENDLOOP.

* force copy of mt_act->val_list
  LOOP AT lo_shared->mt_act ASSIGNING <ls_act>.
*   copy val list
    ls_act_copy = <ls_act>.
    CREATE DATA ls_act_copy-val_list.
    ls_act_copy-val_list->* = <ls_act>-val_list->*.
    LOOP AT ls_act_copy-val_list->* ASSIGNING <ls_val>.
*   Adjust action validations
*   relink validation read nodes
      lt_read = <ls_val>-val_read.
      CREATE DATA <ls_val>-val_read.
      <ls_val>-val_read->* = lt_read->*.
      LOOP AT <ls_val>-val_read->* ASSIGNING <ls_read>.
        CHECK <ls_read>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_read>-assoc
          WITH KEY assoc_key = <ls_read>-assoc->assoc_key.
      ENDLOOP.
*   relink validation trigger nodes
      lt_val_trig = <ls_val>-val_trigger.
      CREATE DATA <ls_val>-val_trigger.
      <ls_val>-val_trigger->* = lt_val_trig->*.
      LOOP AT <ls_val>-val_trigger->* ASSIGNING <ls_val_trig>.
        CHECK <ls_val_trig>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_val_trig>-assoc
          WITH KEY assoc_key = <ls_val_trig>-assoc->assoc_key.
      ENDLOOP.
*  relink validation groups
      lt_val_group = <ls_val>-val_group.
      CREATE DATA <ls_val>-val_group.
      <ls_val>-val_group->* = lt_val_group->*.
      LOOP AT <ls_val>-val_group->* ASSIGNING <ls_val_group>.
*     relink status variable
        READ TABLE mt_sta_var REFERENCE INTO <ls_val_group>-sta_var
          WITH KEY sta_var_key = <ls_val_group>-sta_var_key.
*     relink validation trigger nodes
        IF <ls_val_group>-val_trigger IS BOUND.
          lt_group_val_trig = <ls_val_group>-val_trigger.
          CREATE DATA <ls_val_group>-val_trigger.
          <ls_val_group>-val_trigger->* = lt_group_val_trig->*.
*          LOOP AT <ls_val_group>-val_trigger->* ASSIGNING <ls_val_trig>.
*            CHECK <ls_val_trig>-assoc IS BOUND.
*            READ TABLE mt_assoc REFERENCE INTO <ls_val_trig>-assoc
*              WITH KEY assoc_key = <ls_val_trig>-assoc->assoc_key.
*          ENDLOOP.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
*   relink action read nodes
    lt_read = ls_act_copy-act_read.
    CREATE DATA ls_act_copy-act_read.
    ls_act_copy-act_read->* = lt_read->*.
    LOOP AT ls_act_copy-act_read->* ASSIGNING <ls_read>.
      CHECK <ls_read>-assoc IS BOUND.
      READ TABLE mt_assoc REFERENCE INTO <ls_read>-assoc
        WITH KEY assoc_key = <ls_read>-assoc->assoc_key.
    ENDLOOP.
*   relink action write nodes
    lt_act_write = ls_act_copy-act_write.
    CREATE DATA ls_act_copy-act_write.
    ls_act_copy-act_write->* = lt_act_write->*.
    LOOP AT ls_act_copy-act_write->* ASSIGNING <ls_act_write>.
      CHECK <ls_act_write>-assoc IS BOUND.
      READ TABLE mt_assoc REFERENCE INTO <ls_act_write>-assoc
        WITH KEY assoc_key = <ls_act_write>-assoc->assoc_key.
    ENDLOOP.
    INSERT ls_act_copy INTO TABLE mt_act.
  ENDLOOP.


  LOOP AT mt_validation ASSIGNING <ls_val>.
*   relink validation read nodes
    IF <ls_val>-val_read IS BOUND.
      lt_read = <ls_val>-val_read.
      CREATE DATA <ls_val>-val_read.
      <ls_val>-val_read->* = lt_read->*.
      LOOP AT <ls_val>-val_read->* ASSIGNING <ls_read>.
        CHECK <ls_read>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_read>-assoc
          WITH KEY assoc_key = <ls_read>-assoc->assoc_key.
      ENDLOOP.
    ENDIF.
*   relink validation trigger nodes
    IF <ls_val>-val_trigger IS BOUND.
      lt_val_trig = <ls_val>-val_trigger.
      CREATE DATA <ls_val>-val_trigger.
      <ls_val>-val_trigger->* = lt_val_trig->*.
      LOOP AT <ls_val>-val_trigger->* ASSIGNING <ls_val_trig>.
        CHECK <ls_val_trig>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_val_trig>-assoc
          WITH KEY assoc_key = <ls_val_trig>-assoc->assoc_key.
      ENDLOOP.
    ENDIF.
*  relink validation groups
    IF <ls_val>-val_group IS BOUND.
      lt_val_group = <ls_val>-val_group.
      CREATE DATA <ls_val>-val_group.
      <ls_val>-val_group->* = lt_val_group->*.
      LOOP AT <ls_val>-val_group->* ASSIGNING <ls_val_group>.
*     relink status variable
        READ TABLE mt_sta_var REFERENCE INTO <ls_val_group>-sta_var
          WITH KEY sta_var_key = <ls_val_group>-sta_var_key.
*     relink validation trigger nodes
        IF <ls_val_group>-val_trigger IS BOUND.
          lt_group_val_trig = <ls_val_group>-val_trigger.
          CREATE DATA <ls_val_group>-val_trigger.
          <ls_val_group>-val_trigger->* = lt_group_val_trig->*.
*        LOOP AT <ls_val_group>-val_trigger->* ASSIGNING <ls_val_trig>.
*          CHECK <ls_val_trig>-assoc IS BOUND.
*          READ TABLE mt_assoc REFERENCE INTO <ls_val_trig>-assoc
*            WITH KEY assoc_key = <ls_val_trig>-assoc->assoc_key.
*        ENDLOOP.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDLOOP.
* ...

  LOOP AT mt_assoc ASSIGNING <ls_assoc>.
*   copy binding
    CREATE DATA lt_assoc_binding.
    lt_assoc_binding->* = <ls_assoc>-assoc_binding->*.
    <ls_assoc>-assoc_binding = lt_assoc_binding.
*   copy node cats
    CREATE DATA lt_node_cat.
    lt_node_cat->* = <ls_assoc>-node_cat->*.
    <ls_assoc>-node_cat = lt_node_cat.
*   relink nodes
    READ TABLE mt_node REFERENCE INTO <ls_assoc>-source_node
      WITH KEY node_key = <ls_assoc>-source_node_key.
    READ TABLE mt_node REFERENCE INTO <ls_assoc>-target_node
      WITH KEY node_key = <ls_assoc>-target_node_key.
  ENDLOOP.

  LOOP AT mt_comp ASSIGNING <ls_comp>.
*   relink nodes
    READ TABLE mt_node REFERENCE INTO <ls_comp>-source_node
      WITH KEY node_key = <ls_comp>-source_node_key.
    READ TABLE mt_node REFERENCE INTO <ls_comp>-target_node
      WITH KEY node_key = <ls_comp>-target_node_key.
  ENDLOOP.

  LOOP AT mt_vset ASSIGNING <ls_vset>.
*   copy code list
    IF <ls_vset>-code_list IS BOUND.
      CREATE DATA lt_code_list.
      lt_code_list->* = <ls_vset>-code_list->*.
      <ls_vset>-code_list = lt_code_list.
*     relink assoc
      IF <ls_vset>-assoc IS BOUND.
        READ TABLE mt_assoc REFERENCE INTO <ls_vset>-assoc
          WITH KEY assoc_key = <ls_vset>-assoc->assoc_key.
      ENDIF.
*     relink node
      IF <ls_vset>-node IS BOUND.
        READ TABLE mt_node REFERENCE INTO <ls_vset>-node
          WITH KEY node_key = <ls_vset>-node->node_key.
      ENDIF.
    ENDIF.
  ENDLOOP.

* _____________________________________________________________________________ *
* set modes
  IF is_context-cleanup_mode IS NOT INITIAL.
    ms_obj-cleanup_mode = is_context-cleanup_mode.
  ENDIF.
  IF is_context-enqueue_scope IS NOT INITIAL.
    ms_obj-enqueue_scope = is_context-enqueue_scope.
  ENDIF.

* filter with inactive groups
  IF is_context-inactive_groups IS NOT INITIAL.
    filter_inactive_groups( is_context-inactive_groups ).
  ENDIF.

ENDMETHOD.


METHOD INITIALIZE_LOAD_PLUGINS.

  DATA:
    ls_load_plugin      TYPE                   ty_plugin,
    ls_tra_pi           TYPE                   /bobf/tra_pi,
    ls_tra_pi_act       TYPE                   /bobf/tra_pi_act,
    lo_plugin            TYPE REF TO            object,
    lt_tra_pi_act       TYPE STANDARD TABLE OF /bobf/tra_pi_act,
    lt_tra_pi           TYPE STANDARD TABLE OF /bobf/tra_pi.

  " read all active plugins (using no joins/sort options in order to avoid bypassing the buffered table)
  SELECT * FROM /bobf/tra_pi INTO TABLE lt_tra_pi.
  SELECT * FROM /bobf/tra_pi_act INTO TABLE lt_tra_pi_act.
  LOOP AT lt_tra_pi INTO ls_tra_pi.
    READ TABLE lt_tra_pi_act WITH KEY plugin_name = ls_tra_pi-plugin_name INTO ls_tra_pi_act.
    IF sy-subrc = 0 AND ls_tra_pi_act-is_active = abap_true.
      ls_load_plugin-class = ls_tra_pi-plugin_class.
      ls_load_plugin-name  = ls_tra_pi-plugin_name.
      CREATE OBJECT lo_plugin TYPE (ls_load_plugin-class).
      TRY.
          ls_load_plugin-object ?= lo_plugin.
          " if this cast was successful, take the load plugin it over to the result
          INSERT ls_load_plugin INTO TABLE rt_plugin.
        CATCH cx_sy_move_cast_error.
      ENDTRY.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD is_loadable_bo.
  DATA lv_abstract TYPE /bobf/obm_obj-abstract.
  SELECT SINGLE abstract FROM /bobf/obm_obj INTO lv_abstract WHERE bo_key = iv_bo_key AND version = /bobf/if_conf_c=>sc_version_active.
  ro_exc = COND #(
    WHEN sy-subrc <> 0           THEN NEW #( textid = /bobf/cx_conf=>bo_not_found_in_conf )
    WHEN lv_abstract = abap_true THEN NEW #( textid = /bobf/cx_conf=>bo_is_abstract )
  ).
ENDMETHOD.


METHOD merge_delegated_model.

  DATA: lt_do_action TYPE /bobf/t_confdo_action,
        lt_do_altkey TYPE /bobf/t_confdo_altkey,
        lt_do_assoc  TYPE /bobf/t_confdo_assoc,
        lt_do_node   TYPE /bobf/t_confdo_node,
        lt_do_query  TYPE /bobf/t_confdo_query,
        lt_do_vset   TYPE /bobf/t_confdo_value_set.

  DATA: ls_node                    TYPE /bobf/s_confro_node,
        ls_host_node               TYPE REF TO /bobf/s_confro_node,
        ls_action                  TYPE /bobf/s_confro_act_list,
        ls_altkey                  TYPE /bobf/s_confro_altkey,
        ls_assoc                   TYPE /bobf/s_confro_assoc,
        ls_assoc2                  TYPE /bobf/s_confro_assoc2,
        ls_query                   TYPE /bobf/s_confro_query,
        ls_vset                    TYPE /bobf/s_confro_value_set,
        ls_content_key_map         TYPE /bobf/s_confro_content_key_map,
        lv_offset                  TYPE i,
        lv_genil_prefix            TYPE /bobf/conf_genil_prefix,
        lt_field_names             TYPE /bobf/t_frw_name,
        lo_do_conf                 TYPE REF TO /bobf/if_confrt_complete,
        lo_area_handle             TYPE REF TO cl_abap_memory_area,
        lo_do_conf_readonly        TYPE REF TO /bobf/cl_conf_readonly,
        ls_ref_do                  TYPE ts_referenced_do,
        lt_det_trigger_attr_create TYPE /bobf/t_frw_name,
        lt_det_trigger_attr_update TYPE /bobf/t_frw_name,
        lt_det_trigger_attr_delete TYPE /bobf/t_frw_name,
        lt_val_trigger_attr_create TYPE /bobf/t_frw_name,
        lt_val_trigger_attr_update TYPE /bobf/t_frw_name,
        lt_val_trigger_attr_delete TYPE /bobf/t_frw_name.

  FIELD-SYMBOLS:
    <ls_node>   TYPE /bobf/s_confro_node,
    <ls_assoc>  TYPE /bobf/s_confro_assoc,
    <ls_action> TYPE /bobf/s_confro_act_list,
    <ls_query>  TYPE /bobf/s_confro_query,
    <ls_altkey> TYPE /bobf/s_confro_altkey,
    <ls_vset>   TYPE /bobf/s_confro_value_set.


  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

* get dynamic parts of the meta model
  LOOP AT mt_node REFERENCE INTO ls_host_node
    WHERE node_type = /bobf/if_conf_c=>sc_node_type_do. "#EC CI_SORTSEQ
    ms_obj-has_dependent_object = abap_true.


* ____________________________________________________________________ *
*   get meta data
    CALL METHOD (ls_host_node->delegation_class)=>/bobf/if_frw_delegation~get_runtime_model
      EXPORTING
        iv_host_bo_key = ms_obj-bo_key
        iv_node_key    = ls_host_node->node_key " delegation representation node
        io_conf        = me
      IMPORTING
        et_action      = lt_do_action
        et_altkey      = lt_do_altkey
        et_association = lt_do_assoc
        et_node        = lt_do_node
        et_query       = lt_do_query
        et_vset        = lt_do_vset
        eo_do_conf     = lo_do_conf.

    lo_do_conf_readonly ?= lo_do_conf.
    ls_ref_do-do_key          = lo_do_conf_readonly->ms_obj-bo_key.
    ls_ref_do-do_name         = lo_do_conf_readonly->ms_obj-bo_name.
    ls_ref_do-build_timestamp = lo_do_conf_readonly->mv_build_timestamp.
    APPEND ls_ref_do TO mt_referenced_do.
    IF mv_last_change_time < lo_do_conf_readonly->mv_last_change_time.
      mv_last_change_time = lo_do_conf_readonly->mv_last_change_time.
    ENDIF.

*   merge old style table model... :(
    IF lo_do_conf IS NOT BOUND.
      merge_delegated_model_old(
        EXPORTING
          it_action      = lt_do_action
          it_altkey      = lt_do_altkey
          it_association = lt_do_assoc
          it_node        = lt_do_node
          it_query       = lt_do_query
          it_vset        = lt_do_vset
          is_host_node   = ls_host_node ).
      CONTINUE.
    ENDIF.

* ____________________________________________________________________ *
*   create content key mapping for DO representation node if not yet there
    READ TABLE mt_content_key_map
      WITH KEY content_cat      = /bobf/if_conf_c=>sc_content_nod
               host_content_key = ls_host_node->node_key
      INTO ls_content_key_map.
    IF sy-subrc <> 0.
      ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_nod.
      ls_content_key_map-do_content_key   = lo_do_conf->ms_obj-root_node_key.
      ls_content_key_map-do_root_node_key = ls_host_node->node_key.
      ls_content_key_map-host_content_key = ls_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
    ls_host_node->delegation_root_node_key = ls_host_node->node_key.

    lv_genil_prefix =  ls_host_node->node_genil_name.

* ____________________________________________________________________ *
*   merge nodes
    LOOP AT lo_do_conf->mt_node INTO ls_node.
      CHECK ls_node-node_type = /bobf/if_conf_c=>sc_node_type_normal
         OR ls_node-node_type = /bobf/if_conf_c=>sc_node_type_bo.

*     create content key mapping if not yet done
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                   do_content_key   = ls_node-node_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc <> 0.
        ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_nod.
        ls_content_key_map-do_content_key   = ls_node-node_key.
        ls_content_key_map-do_root_node_key = ls_host_node->node_key.
        ls_content_key_map-host_content_key = /bobf/cl_frw_factory=>get_new_key( ).
        INSERT ls_content_key_map INTO TABLE mt_content_key_map.
      ELSE. " content key mapping exists -> check for node
        READ TABLE mt_node ASSIGNING <ls_node>
          WITH KEY node_key = ls_content_key_map-host_content_key.
        IF sy-subrc = 0.
*         positive list of what is copied to host if node exists already in host
          <ls_node>-data_data_type   = ls_node-data_data_type.
          <ls_node>-data_table_type  = ls_node-data_table_type.
          <ls_node>-data_type        = ls_node-data_type.
          <ls_node>-gdt_data_type    = ls_node-gdt_data_type.
          <ls_node>-prx_dat_dat_type = ls_node-prx_dat_dat_type.
          <ls_node>-node_type        = /bobf/if_conf_c=>sc_node_type_normal.
          <ls_node>-node_name        = ls_node-node_name.
          <ls_node>-node_esr_name    = ls_node-node_esr_name.
          <ls_node>-ref_bo_key       = lo_do_conf->ms_obj-bo_key.

          IF ls_node-field_names IS BOUND.
            lt_field_names = ls_node-field_names->*.
            CREATE DATA <ls_node>-field_names            AREA HANDLE lo_area_handle.
            <ls_node>-field_names->* = lt_field_names.
          ENDIF.
          IF ls_node-det_trigger_attr_create IS BOUND.
            lt_det_trigger_attr_create = ls_node-det_trigger_attr_create->*.
            CREATE DATA <ls_node>-det_trigger_attr_create AREA HANDLE lo_area_handle.
            <ls_node>-det_trigger_attr_create->* = lt_det_trigger_attr_create.
          ENDIF.
          IF ls_node-det_trigger_attr_update IS BOUND.
            lt_det_trigger_attr_update = ls_node-det_trigger_attr_update->*.
            CREATE DATA <ls_node>-det_trigger_attr_update AREA HANDLE lo_area_handle.
            <ls_node>-det_trigger_attr_update->* = lt_det_trigger_attr_update.
          ENDIF.
          IF ls_node-det_trigger_attr_delete IS BOUND.
            lt_det_trigger_attr_delete = ls_node-det_trigger_attr_delete->*.
            CREATE DATA <ls_node>-det_trigger_attr_delete AREA HANDLE lo_area_handle.
            <ls_node>-det_trigger_attr_delete->* = lt_det_trigger_attr_delete.
          ENDIF.
          IF ls_node-val_trigger_attr_create IS BOUND.
            lt_val_trigger_attr_create = ls_node-val_trigger_attr_create->*.
            CREATE DATA <ls_node>-val_trigger_attr_create AREA HANDLE lo_area_handle.
            <ls_node>-val_trigger_attr_create->* = lt_val_trigger_attr_create.
          ENDIF.
          IF ls_node-val_trigger_attr_update IS BOUND.
            lt_val_trigger_attr_update = ls_node-val_trigger_attr_update->*.
            CREATE DATA <ls_node>-val_trigger_attr_update AREA HANDLE lo_area_handle.
            <ls_node>-val_trigger_attr_update->* = lt_val_trigger_attr_update.
          ENDIF.
          IF ls_node-val_trigger_attr_delete IS BOUND.
            lt_val_trigger_attr_delete = ls_node-val_trigger_attr_delete->*.
            CREATE DATA <ls_node>-val_trigger_attr_delete AREA HANDLE lo_area_handle.
            <ls_node>-val_trigger_attr_delete->* = lt_val_trigger_attr_delete.
          ENDIF.

          IF ls_node-internal_properties IS BOUND.
            CREATE DATA <ls_node>-internal_properties AREA HANDLE lo_area_handle.
            <ls_node>-internal_properties->* = ls_node-internal_properties->*.
          ENDIF.

          IF <ls_node>-node_esr_name IS INITIAL.
            CONCATENATE ls_host_node->node_esr_prefix
                        /bobf/if_conf_c=>sc_dependent_object_separator
                        <ls_node>-node_name
                   INTO <ls_node>-node_esr_name.
          ELSE.
            CONCATENATE ls_host_node->node_esr_prefix
                        /bobf/if_conf_c=>sc_dependent_object_separator
                        <ls_node>-node_esr_name
                   INTO <ls_node>-node_esr_name.
          ENDIF.

          IF ls_node-node_genil_name IS NOT INITIAL AND " contains the genil name of the DO node defined in the DO
             lv_genil_prefix         IS NOT INITIAL.    " contains the prefix of the DO usage within the host object
            CONCATENATE lv_genil_prefix gc_genil_separator ls_node-node_genil_name INTO <ls_node>-node_genil_name.
          ELSE.
            CLEAR <ls_node>-node_genil_name.
          ENDIF.

          CONTINUE.
        ENDIF.
      ENDIF.

      CREATE DATA ls_node-node_cat               AREA HANDLE lo_area_handle.
      CREATE DATA ls_node-dependent_db_node_keys AREA HANDLE lo_area_handle.
      CREATE DATA ls_node-status_attributes      AREA HANDLE lo_area_handle.
      CREATE DATA ls_node-det_load_attributes    AREA HANDLE lo_area_handle.
      CREATE DATA ls_node-delete_associations    AREA HANDLE lo_area_handle.

*     all fields not changed here are copied from DO to host unchanged
      CLEAR ls_node-node_cat_key. " do not copy standard node category from DO
      CLEAR ls_node-node_class.
      ls_node-node_key                  = ls_content_key_map-host_content_key.
      ls_node-root_node_key             = ms_obj-root_node_key.
      ls_node-delegation_class          = ls_host_node->delegation_class.
      ls_node-subtree_property_node_key = ls_host_node->subtree_property_node_key.
      ls_node-delegation_root_node_key  = ls_host_node->delegation_root_node_key.
      ls_node-node_esr_prefix           = ls_host_node->node_esr_prefix.
      ls_node-node_esr_name_unique      = abap_true.
      IF ls_node-node_esr_name IS INITIAL.
        CONCATENATE ls_host_node->node_esr_prefix
                    /bobf/if_conf_c=>sc_dependent_object_separator
                    ls_node-node_name
               INTO ls_node-node_esr_name.
      ELSE.
        CONCATENATE ls_host_node->node_esr_prefix
                    /bobf/if_conf_c=>sc_dependent_object_separator
                    ls_node-node_esr_name
               INTO ls_node-node_esr_name.
      ENDIF.

      IF ls_node-field_names IS BOUND.
        lt_field_names = ls_node-field_names->*.
        CREATE DATA ls_node-field_names            AREA HANDLE lo_area_handle.
        ls_node-field_names->* = lt_field_names.
      ENDIF.
      IF ls_node-det_trigger_attr_create IS BOUND.
        lt_det_trigger_attr_create = ls_node-det_trigger_attr_create->*.
        CREATE DATA ls_node-det_trigger_attr_create AREA HANDLE lo_area_handle.
        ls_node-det_trigger_attr_create->* = lt_det_trigger_attr_create.
      ENDIF.
      IF ls_node-det_trigger_attr_update IS BOUND.
        lt_det_trigger_attr_update = ls_node-det_trigger_attr_update->*.
        CREATE DATA ls_node-det_trigger_attr_update AREA HANDLE lo_area_handle.
        ls_node-det_trigger_attr_update->* = lt_det_trigger_attr_update.
      ENDIF.
      IF ls_node-det_trigger_attr_delete IS BOUND.
        lt_det_trigger_attr_delete = ls_node-det_trigger_attr_delete->*.
        CREATE DATA ls_node-det_trigger_attr_delete AREA HANDLE lo_area_handle.
        ls_node-det_trigger_attr_delete->* = lt_det_trigger_attr_delete.
      ENDIF.
      IF ls_node-val_trigger_attr_create IS BOUND.
        lt_val_trigger_attr_create = ls_node-val_trigger_attr_create->*.
        CREATE DATA ls_node-val_trigger_attr_create AREA HANDLE lo_area_handle.
        ls_node-val_trigger_attr_create->* = lt_val_trigger_attr_create.
      ENDIF.
      IF ls_node-val_trigger_attr_update IS BOUND.
        lt_val_trigger_attr_update = ls_node-val_trigger_attr_update->*.
        CREATE DATA ls_node-val_trigger_attr_update AREA HANDLE lo_area_handle.
        ls_node-val_trigger_attr_update->* = lt_val_trigger_attr_update.
      ENDIF.
      IF ls_node-val_trigger_attr_delete IS BOUND.
        lt_val_trigger_attr_delete = ls_node-val_trigger_attr_delete->*.
        CREATE DATA ls_node-val_trigger_attr_delete AREA HANDLE lo_area_handle.
        ls_node-val_trigger_attr_delete->* = lt_val_trigger_attr_delete.
      ENDIF.

      IF ls_node-node_genil_name IS NOT INITIAL.
        CONCATENATE lv_genil_prefix gc_genil_separator ls_node-node_genil_name INTO ls_node-node_genil_name.
      ENDIF.

      INSERT ls_node INTO TABLE mt_node.
    ENDLOOP.

* ____________________________________________________________________ *
*   merge queries
    LOOP AT lo_do_conf->mt_query INTO ls_query.

*     create content key mapping if not yet done
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_qry
                   do_content_key   = ls_query-query_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc <> 0.      " black box
        ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_qry.
        ls_content_key_map-do_content_key   = ls_query-query_key.
        ls_content_key_map-do_root_node_key = ls_host_node->node_key.
        ls_content_key_map-host_content_key = /bobf/cl_frw_factory=>get_new_key( ).
        INSERT ls_content_key_map INTO TABLE mt_content_key_map.
      ELSE.                  " white box
        READ TABLE mt_query ASSIGNING <ls_query>
          WITH KEY query_key = ls_content_key_map-host_content_key.
        IF sy-subrc = 0.
*         positive list of what is copied to host if query exists already in host
          <ls_query>-data_type     = ls_query-data_type.
          <ls_query>-prx_data_type = ls_query-prx_data_type.
          IF ls_query-query_genil_name IS NOT INITIAL.
            CONCATENATE lv_genil_prefix gc_genil_separator ls_query-query_genil_name INTO <ls_query>-query_genil_name.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

*     all fields not changed here are copied from DO to host unchanged
      ls_query-query_key = ls_content_key_map-host_content_key.
*     map node
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                   do_content_key   = ls_query-node_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      CHECK sy-subrc = 0.
      ls_query-node_key = ls_content_key_map-host_content_key.
      IF ls_query-query_genil_name IS NOT INITIAL.
        CONCATENATE lv_genil_prefix gc_genil_separator ls_query-query_genil_name INTO ls_query-query_genil_name.
      ENDIF.

      INSERT ls_query INTO TABLE mt_query.
    ENDLOOP.

* ____________________________________________________________________ *
*   merge associations
    LOOP AT lo_do_conf->mt_assoc INTO ls_assoc.
      CHECK ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_lock
        AND ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_message
        AND ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_property.

      CHECK   ls_assoc-source_node->node_type = /bobf/if_conf_c=>sc_node_type_normal
        AND ( ls_assoc-target_node->node_type = /bobf/if_conf_c=>sc_node_type_normal
              OR ls_assoc-target_node->node_type = /bobf/if_conf_c=>sc_node_type_bo ).

*     create content key mapping if not yet done
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_ass
                   do_content_key   = ls_assoc-assoc_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc <> 0.      " black box
        ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_ass.
        ls_content_key_map-do_content_key   = ls_assoc-assoc_key.
        ls_content_key_map-do_root_node_key = ls_host_node->node_key.
        ls_content_key_map-host_content_key = /bobf/cl_frw_factory=>get_new_key( ).
        INSERT ls_content_key_map INTO TABLE mt_content_key_map.
      ELSE.                  " white box
        READ TABLE mt_assoc ASSIGNING <ls_assoc>
          WITH KEY assoc_key = ls_content_key_map-host_content_key.
        IF sy-subrc = 0.
*         positive list of what is copied to host if association exists already in host
          <ls_assoc>-param_data_type  = ls_assoc-param_data_type.
          <ls_assoc>-esr_param_data_t = ls_assoc-esr_param_data_t.
          IF ls_assoc-assoc_genil_name IS NOT INITIAL.
            CONCATENATE lv_genil_prefix gc_genil_separator ls_assoc-assoc_genil_name INTO <ls_assoc>-assoc_genil_name.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      CREATE DATA ls_assoc-node_cat      AREA HANDLE lo_area_handle.
      CREATE DATA ls_assoc-assoc_binding AREA HANDLE lo_area_handle.

*     all fields not changed here are copied from DO to host unchanged
      ls_assoc-assoc_key       = ls_content_key_map-host_content_key.
      CLEAR ls_assoc-assoc_class.

      IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_root.
        ls_assoc-target_node_key = ms_obj-root_node_key.
      ENDIF.

*     source node
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                   do_content_key   = ls_assoc-source_node_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      CHECK sy-subrc = 0.
      ls_assoc-source_node_key = ls_content_key_map-host_content_key.
      READ TABLE mt_node REFERENCE INTO ls_assoc-source_node
        WITH KEY node_key = ls_assoc-source_node_key.
*     target node
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                   do_content_key   = ls_assoc-target_node_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc = 0.
        ls_assoc-target_node_key = ls_content_key_map-host_content_key.
      ENDIF.
      READ TABLE mt_node REFERENCE INTO ls_assoc-target_node
        WITH KEY node_key = ls_assoc-target_node_key.
*     query
      IF ls_assoc-query_key IS NOT INITIAL.
        READ TABLE mt_content_key_map WITH KEY do2host
          COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_qry
                     do_content_key   = ls_assoc-query_key
                     do_root_node_key = ls_host_node->node_key
          INTO ls_content_key_map.
        CHECK sy-subrc = 0.
        ls_assoc-query_key = ls_content_key_map-host_content_key.
      ENDIF.

      IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent.
        ls_assoc-source_node->parent_node_key = ls_assoc-target_node->node_key.
      ENDIF.
      ls_assoc-target_loaded_with_source = abap_false.
      ls_assoc-target_locked_with_source = abap_true.
      IF ls_assoc-assoc_genil_name IS NOT INITIAL.
        CONCATENATE lv_genil_prefix gc_genil_separator ls_assoc-assoc_genil_name INTO ls_assoc-assoc_genil_name.
      ENDIF.

      INSERT ls_assoc INTO TABLE mt_assoc.

      IF ls_assoc-assoc_type = /bobf/if_conf_c=>sc_assoctype_comp.
        MOVE-CORRESPONDING ls_assoc TO ls_assoc2.
        INSERT ls_assoc2 INTO TABLE mt_comp.
      ENDIF.
    ENDLOOP.

* ____________________________________________________________________ *
*   merge actions
    LOOP AT lo_do_conf->mt_act INTO ls_action.

*     create content key mapping if not yet done
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_act
                   do_content_key   = ls_action-act_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc <> 0.      " black box
        ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_act.
        ls_content_key_map-do_content_key   = ls_action-act_key.
        ls_content_key_map-do_root_node_key = ls_host_node->node_key.
        ls_content_key_map-host_content_key = /bobf/cl_frw_factory=>get_new_key( ).
        INSERT ls_content_key_map INTO TABLE mt_content_key_map.
      ELSE.                  " white box
        READ TABLE mt_act ASSIGNING <ls_action>
          WITH KEY act_key = ls_content_key_map-host_content_key.
        IF sy-subrc = 0.
*         positive list of what is copied to host if action exists already in host
          <ls_action>-esr_param_data_t = ls_action-esr_param_data_t.
          <ls_action>-param_data_type  = ls_action-param_data_type.
          IF ls_action-act_genil_name IS NOT INITIAL.
            CONCATENATE lv_genil_prefix gc_genil_separator ls_action-act_genil_name INTO <ls_action>-act_genil_name.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      CREATE DATA ls_action-val_list      AREA HANDLE lo_area_handle.
      CREATE DATA ls_action-act_read      AREA HANDLE lo_area_handle.
      CREATE DATA ls_action-act_write     AREA HANDLE lo_area_handle.
      CREATE DATA ls_action-node_cat      AREA HANDLE lo_area_handle.

      " copy content - not the reference itself
      DATA lt_tmp_post_enhancement_key TYPE /bobf/t_frw_key2.
      DATA lt_tmp_pre_enhancement_key  TYPE /bobf/t_frw_key2.
      IF ls_action-post_enhancement_keys IS BOUND.
        lt_tmp_post_enhancement_key = ls_action-post_enhancement_keys->*.
        CREATE DATA ls_action-post_enhancement_keys AREA HANDLE lo_area_handle.
        ls_action-post_enhancement_keys->* = lt_tmp_post_enhancement_key.
      ENDIF.
      IF ls_action-pre_enhancement_keys IS BOUND.
        lt_tmp_pre_enhancement_key  = ls_action-pre_enhancement_keys->*.
        CREATE DATA ls_action-pre_enhancement_keys  AREA HANDLE lo_area_handle.
        ls_action-pre_enhancement_keys->*  = lt_tmp_pre_enhancement_key.
      ENDIF.

*     all fields not changed here are copied from DO to host unchanged
      ls_action-act_key = ls_content_key_map-host_content_key.
*     map node
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                   do_content_key   = ls_action-node_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      CHECK sy-subrc = 0.
      ls_action-node_key = ls_content_key_map-host_content_key.
      IF ls_action-act_genil_name IS NOT INITIAL.
        CONCATENATE lv_genil_prefix gc_genil_separator ls_action-act_genil_name INTO ls_action-act_genil_name.
      ENDIF.

      INSERT ls_action INTO TABLE mt_act.
    ENDLOOP.

* ____________________________________________________________________ *
*   merge alternative keys
    LOOP AT lo_do_conf->mt_altkey INTO ls_altkey.

*     create content key mapping if not yet done
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_alk
                   do_content_key   = ls_altkey-altkey_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc <> 0.      " black box
        ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_alk.
        ls_content_key_map-do_content_key   = ls_altkey-altkey_key.
        ls_content_key_map-do_root_node_key = ls_host_node->node_key.
        ls_content_key_map-host_content_key = /bobf/cl_frw_factory=>get_new_key( ).
        INSERT ls_content_key_map INTO TABLE mt_content_key_map.
      ELSE.                  " white box
        READ TABLE mt_altkey ASSIGNING <ls_altkey>
          WITH KEY altkey_key = ls_content_key_map-host_content_key.
        IF sy-subrc = 0.
*         positive list of what is copied to host if altkey exists already in host
          <ls_altkey>-altkey_is_structured     = ls_altkey-altkey_is_structured.
          <ls_altkey>-data_table_type          = ls_altkey-data_table_type.
          <ls_altkey>-data_type                = ls_altkey-data_type.
          <ls_altkey>-field_names->*           = ls_altkey-field_names->*.
          <ls_altkey>-prx_altkey_is_structured = ls_altkey-prx_altkey_is_structured.
          <ls_altkey>-prx_data_type            = ls_altkey-prx_data_type.
          <ls_altkey>-prx_field_names->*       = ls_altkey-prx_field_names->*.
          CONTINUE.
        ENDIF.
      ENDIF.

      CREATE DATA ls_altkey-field_names         AREA HANDLE lo_area_handle.
      CREATE DATA ls_altkey-prx_field_names     AREA HANDLE lo_area_handle.

*     all fields not changed here are copied from DO to host unchanged
      ls_altkey-altkey_key = ls_content_key_map-host_content_key.
*     map node
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                   do_content_key   = ls_altkey-node_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      CHECK sy-subrc = 0.
      ls_altkey-node_key = ls_content_key_map-host_content_key.
      READ TABLE mt_node REFERENCE INTO ls_altkey-node
        WITH KEY node_key = ls_altkey-node_key.

      INSERT ls_altkey INTO TABLE mt_altkey.
    ENDLOOP.

* ____________________________________________________________________ *
*   merge value sets
    LOOP AT lo_do_conf->mt_vset INTO ls_vset.

*     create content key mapping if not yet done
      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_vset
                   do_content_key   = ls_vset-vset_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      IF sy-subrc <> 0.      " black box
        ls_content_key_map-content_cat      = /bobf/if_conf_c=>sc_content_vset.
        ls_content_key_map-do_content_key   = ls_vset-vset_key.
        ls_content_key_map-do_root_node_key = ls_host_node->node_key.
        ls_content_key_map-host_content_key = /bobf/cl_frw_factory=>get_new_key( ).
        INSERT ls_content_key_map INTO TABLE mt_content_key_map.
      ELSE.                  " white box
        READ TABLE mt_vset ASSIGNING <ls_vset>
          WITH KEY vset_key = ls_content_key_map-host_content_key.
        IF sy-subrc = 0.
*         positive list of what is copied to host if value set exists already in host
          CONTINUE.
        ENDIF.
      ENDIF.

      IF ls_vset-vset_cat = /bobf/if_conf_c=>sc_vset_cat_code.
        CREATE DATA ls_vset-code_list       AREA HANDLE lo_area_handle.
      ENDIF.

*     all fields not changed here are copied from DO to host unchanged
      ls_vset-vset_key = ls_content_key_map-host_content_key.

      IF ls_vset-node IS BOUND.
        READ TABLE mt_content_key_map WITH KEY do2host
          COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_nod
                     do_content_key   = ls_vset-node->node_key
                     do_root_node_key = ls_host_node->node_key
          INTO ls_content_key_map.
        IF sy-subrc = 0.
          READ TABLE mt_node REFERENCE INTO ls_vset-node
            WITH KEY node_key = ls_content_key_map-host_content_key.
        ENDIF.
      ENDIF.

      IF ls_vset-assoc IS BOUND.
        READ TABLE mt_content_key_map WITH KEY do2host
          COMPONENTS content_cat      = /bobf/if_conf_c=>sc_content_ass
                     do_content_key   = ls_vset-assoc->assoc_key
                     do_root_node_key = ls_host_node->node_key
          INTO ls_content_key_map.
        IF sy-subrc = 0.
          READ TABLE mt_assoc REFERENCE INTO ls_vset-assoc
            WITH KEY assoc_key = ls_content_key_map-host_content_key.
        ENDIF.
      ENDIF.

      READ TABLE mt_content_key_map WITH KEY do2host
        COMPONENTS content_cat      = ls_vset-content_cat
                   do_content_key   = ls_vset-content_key
                   do_root_node_key = ls_host_node->node_key
        INTO ls_content_key_map.
      ls_vset-content_key = ls_content_key_map-host_content_key.

      INSERT ls_vset INTO TABLE mt_vset.
    ENDLOOP.

  ENDLOOP.

ENDMETHOD.


METHOD merge_delegated_model_old.

  DATA: ls_do_action         TYPE /bobf/s_confdo_action,
        ls_do_altkey         TYPE /bobf/s_confdo_altkey,
        ls_do_assoc          TYPE /bobf/s_confdo_assoc,
        ls_do_node           TYPE /bobf/s_confdo_node,
        ls_do_query          TYPE /bobf/s_confdo_query,
        ls_do_vset           TYPE /bobf/s_confdo_value_set,
        ls_new_node          TYPE /bobf/s_confro_node,
        ls_new_action        TYPE /bobf/s_confro_act_list,
        ls_new_altkey        TYPE /bobf/s_confro_altkey,
        ls_new_assoc         TYPE /bobf/s_confro_assoc,
        ls_new_assoc2        TYPE /bobf/s_confro_assoc2,
        ls_new_query         TYPE /bobf/s_confro_query,
        ls_new_vset          TYPE /bobf/s_confro_value_set,
        ls_content_key_map   TYPE /bobf/s_confro_content_key_map,
        lv_offset            TYPE i,
        lo_do_conf           TYPE REF TO /bobf/if_confrt_complete,
        lo_area_handle       TYPE REF TO cl_abap_memory_area.

  FIELD-SYMBOLS: <ls_new_node>   TYPE /bobf/s_confro_node,
                 <ls_new_assoc>  TYPE /bobf/s_confro_assoc.

  lo_area_handle = /bobf/cl_conf_shared_construct=>get_area_handle( ).

* ____________________________________________________________________ *
*   merge nodes
  ls_content_key_map-content_cat = /bobf/if_conf_c=>sc_content_nod.
  LOOP AT it_node INTO ls_do_node.
*   check for existing nodes
    READ TABLE mt_node
      WITH TABLE KEY node_key = ls_do_node-node_key
      ASSIGNING <ls_new_node>.
    IF sy-subrc <> 0.
*     new node
      CLEAR ls_new_node.
      MOVE-CORRESPONDING ls_do_node TO ls_new_node.
      CREATE DATA ls_new_node-node_cat AREA HANDLE lo_area_handle.
      CREATE DATA ls_new_node-dependent_db_node_keys AREA HANDLE lo_area_handle.
      ls_new_node-root_node_key   = ms_obj-root_node_key.
      FIND ALL OCCURRENCES OF /bobf/if_conf_c=>sc_dependent_object_separator IN ls_new_node-node_esr_name MATCH OFFSET lv_offset.
      IF sy-subrc = 0.
        ls_new_node-node_esr_prefix = ls_new_node-node_esr_name(lv_offset).
      ELSEIF ls_do_node-node_type <> /bobf/if_conf_c=>sc_node_type_bo.
        ls_new_node-node_esr_prefix = is_host_node->node_esr_prefix.
      ENDIF.
      INSERT ls_new_node INTO TABLE mt_node ASSIGNING <ls_new_node>.
    ELSE.
      <ls_new_node>-node_esr_name    = ls_do_node-node_esr_name.
      <ls_new_node>-gdt_data_type    = ls_do_node-gdt_data_type.
      <ls_new_node>-prx_dat_dat_type = ls_do_node-prx_dat_dat_type.
      <ls_new_node>-use_proxy_type   = ls_do_node-use_proxy_type.
    ENDIF.
    IF <ls_new_node>-use_proxy_type  = abap_true.
      <ls_new_node>-data_data_type   = <ls_new_node>-prx_dat_dat_type.
      <ls_new_node>-data_type        = <ls_new_node>-gdt_data_type.
    ENDIF.
    <ls_new_node>-delegation_class   = is_host_node->delegation_class.
    IF is_host_node->sp_id_map_class IS NOT INITIAL.
      <ls_new_node>-sp_id_map_class = is_host_node->sp_id_map_class.
    ELSE.
      <ls_new_node>-sp_id_map_class = /bobf/if_conf_def_classes_c=>gc_cl_do_node_id_mapping.
    ENDIF.
    <ls_new_node>-delegation_root_node_key = is_host_node->node_key.
    IF ls_do_node-node_type IS NOT INITIAL.
      <ls_new_node>-node_type = ls_do_node-node_type.
    ELSE.
      <ls_new_node>-node_type = /bobf/if_conf_c=>sc_node_type_normal.
    ENDIF.
    <ls_new_node>-node_esr_name_unique      = abap_true.
    <ls_new_node>-subtree_property_node_key = is_host_node->subtree_property_node_key.
*   add content key mapping
    IF ls_do_node-do_node_key IS NOT INITIAL.
      ls_content_key_map-host_content_key = ls_do_node-node_key.
      ls_content_key_map-do_content_key   = ls_do_node-do_node_key.
      ls_content_key_map-do_root_node_key = is_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* merge associations
  ls_content_key_map-content_cat = /bobf/if_conf_c=>sc_content_ass.
  LOOP AT it_association INTO ls_do_assoc.
*   check for existing associations
    READ TABLE mt_assoc
      WITH TABLE KEY assoc_key = ls_do_assoc-assoc_key
      ASSIGNING <ls_new_assoc>.
    IF sy-subrc <> 0.
*     new association
      CLEAR ls_new_assoc.
      MOVE-CORRESPONDING ls_do_assoc TO ls_new_assoc.
      CREATE DATA ls_new_assoc-node_cat AREA HANDLE lo_area_handle.
      CREATE DATA ls_new_assoc-assoc_binding AREA HANDLE lo_area_handle.
      INSERT ls_new_assoc INTO TABLE mt_assoc ASSIGNING <ls_new_assoc>.
*     link source node
      READ TABLE mt_node
        WITH TABLE KEY node_key = <ls_new_assoc>-source_node_key
        ASSIGNING <ls_new_node>.
      IF sy-subrc = 0.
        GET REFERENCE OF <ls_new_node> INTO <ls_new_assoc>-source_node.
      ELSE.
*       source node does not exist
        ASSERT ID /bobf/conf CONDITION 0 = 1.              "#EC BOOL_OK
      ENDIF.
    ELSE.
*     known association -> set target node key
      <ls_new_assoc>-target_node_key = ls_do_assoc-target_node_key.
    ENDIF.
*     link target node
    READ TABLE mt_node
      WITH TABLE KEY node_key = <ls_new_assoc>-target_node_key
      ASSIGNING <ls_new_node>.
    IF sy-subrc = 0.
      GET REFERENCE OF <ls_new_node> INTO <ls_new_assoc>-target_node.
      IF <ls_new_assoc>-assoc_type = /bobf/if_conf_c=>sc_assoctype_comp.
        <ls_new_node>-parent_node_key = <ls_new_assoc>-source_node_key.
      ENDIF.
    ELSE.
*     target node does not exist
      ASSERT ID /bobf/conf CONDITION 0 = 1.                "#EC BOOL_OK
    ENDIF.
    IF <ls_new_assoc>-assoc_cat IS INITIAL.
      IF ls_do_assoc-assoc_cat IS INITIAL.
        <ls_new_assoc>-assoc_cat = /bobf/if_conf_c=>sc_assoccat_normal.
      ELSE.
        <ls_new_assoc>-assoc_cat = ls_do_assoc-assoc_cat.
      ENDIF.
    ENDIF.
    IF <ls_new_assoc>-assoc_type = /bobf/if_conf_c=>sc_assoctype_comp.
      MOVE-CORRESPONDING <ls_new_assoc> TO ls_new_assoc2.
      INSERT ls_new_assoc2 INTO TABLE mt_comp.
    ENDIF.
    <ls_new_assoc>-target_locked_with_source = abap_true.
    <ls_new_assoc>-target_loaded_with_source = abap_false.
*   add content key mapping
    IF ls_do_assoc-do_assoc_key IS NOT INITIAL.
      ls_content_key_map-host_content_key = ls_do_assoc-assoc_key.
      ls_content_key_map-do_content_key   = ls_do_assoc-do_assoc_key.
      ls_content_key_map-do_root_node_key = is_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* merge actions
  ls_content_key_map-content_cat = /bobf/if_conf_c=>sc_content_act.
  LOOP AT it_action INTO ls_do_action.
    MOVE-CORRESPONDING ls_do_action TO ls_new_action.
    ls_new_action-act_cat = /bobf/if_conf_c=>sc_action_standard.
    CREATE DATA ls_new_action-val_list AREA HANDLE lo_area_handle.
    CREATE DATA ls_new_action-act_read AREA HANDLE lo_area_handle.
    CREATE DATA ls_new_action-act_write AREA HANDLE lo_area_handle.
    INSERT ls_new_action INTO TABLE mt_act.
*   add content key mapping
    IF ls_do_action-do_act_key IS NOT INITIAL.
      ls_content_key_map-host_content_key = ls_do_action-act_key.
      ls_content_key_map-do_content_key   = ls_do_action-do_act_key.
      ls_content_key_map-do_root_node_key = is_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* merge alternative keys
  ls_content_key_map-content_cat = /bobf/if_conf_c=>sc_content_alk.
  LOOP AT it_altkey INTO ls_do_altkey.
    MOVE-CORRESPONDING ls_do_altkey TO ls_new_altkey.
    CREATE DATA ls_new_altkey-field_names AREA HANDLE lo_area_handle.
    CREATE DATA ls_new_altkey-prx_field_names AREA HANDLE lo_area_handle.
    READ TABLE mt_node REFERENCE INTO ls_new_altkey-node
      WITH KEY node_key = ls_new_altkey-node_key.
    INSERT ls_new_altkey INTO TABLE mt_altkey.
*   add content key mapping
    IF ls_do_altkey-do_altkey_key IS NOT INITIAL.
      ls_content_key_map-host_content_key = ls_do_altkey-altkey_key.
      ls_content_key_map-do_content_key   = ls_do_altkey-do_altkey_key.
      ls_content_key_map-do_root_node_key = is_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* merge queries
  ls_content_key_map-content_cat = /bobf/if_conf_c=>sc_content_qry.
  LOOP AT it_query INTO ls_do_query.
    MOVE-CORRESPONDING ls_do_query TO ls_new_query.
    INSERT ls_new_query INTO TABLE mt_query.
*   add content key mapping
    IF ls_do_query-do_query_key IS NOT INITIAL.
      ls_content_key_map-host_content_key = ls_do_query-query_key.
      ls_content_key_map-do_content_key   = ls_do_query-do_query_key.
      ls_content_key_map-do_root_node_key = is_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
  ENDLOOP.

* ____________________________________________________________________ *
* merge value sets
  ls_content_key_map-content_cat = /bobf/if_conf_c=>sc_content_vset.
  LOOP AT it_vset INTO ls_do_vset.
    MOVE-CORRESPONDING ls_do_vset TO ls_new_vset.
    CREATE DATA ls_new_vset-code_list AREA HANDLE lo_area_handle.
    INSERT ls_new_vset INTO TABLE mt_vset.
*   add content key mapping
    IF ls_do_vset-do_vset_key IS NOT INITIAL.
      ls_content_key_map-host_content_key = ls_do_vset-vset_key.
      ls_content_key_map-do_content_key   = ls_do_vset-do_vset_key.
      ls_content_key_map-do_root_node_key = is_host_node->node_key.
      INSERT ls_content_key_map INTO TABLE mt_content_key_map.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD SET_LOCKLOAD_SUBNODE.

  DATA:
    ls_assoc                  TYPE REF TO /BOBF/S_CONFRO_ASSOC.

  LOOP AT mt_assoc REFERENCE INTO ls_assoc USING KEY key3
    WHERE source_node_key = iv_node_key
    AND   assoc_type      = /BOBF/IF_CONF_C=>SC_ASSOCTYPE_COMP.

*   derive lockable/loadable subnodes for level below
    set_lockload_subnode( ls_assoc->target_node_key ).

*   now set the correct information
    IF ls_assoc->target_node->lockable          = abap_true OR
       ls_assoc->target_node->lockable_subnodes = abap_true.
      ls_assoc->source_node->lockable_subnodes = abap_true.
    ENDIF.
    IF ls_assoc->target_node->loadable          = abap_true OR
       ls_assoc->target_node->loadable_subnodes = abap_true OR
       ls_assoc->target_node->node_type = /bobf/if_conf_c=>sc_node_type_do.
      ls_assoc->source_node->loadable_subnodes = abap_true.
    ENDIF.
    IF ls_assoc->target_node->check_trigger          = abap_true OR
       ls_assoc->target_node->check_trigger_subnodes = abap_true.
      ls_assoc->source_node->check_trigger_subnodes = abap_true.
    ENDIF.

  ENDLOOP.

ENDMETHOD.
ENDCLASS.