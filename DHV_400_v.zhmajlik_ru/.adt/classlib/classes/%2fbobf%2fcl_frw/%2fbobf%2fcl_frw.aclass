*----------------------------------------------------------------------*
*       CLASS /BOBF/CL_FRW DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class /BOBF/CL_FRW definition
  public
  create protected

  global friends /BOBF/CL_FRW_AUNIT_FRIEND
                 /BOBF/CL_FRW_FACTORY
                 /BOBF/CL_FRW_INT_ACCESS
                 /BOBF/CL_TOOL_ASSERT
                 /BOBF/CL_TOOL_TRACE
                 /BOBF/CL_FRW_LOCK_MANAGER
                 /bobf/cl_lib_durable_lock_mngr. " Temporary needed to call LOCK_ACTIVE_DOCUMENT on the lock action.

public section.

  interfaces /BOBF/IF_FRW_SERVICE_LAYER .
  interfaces /BOBF/IF_TRA_CLONE .
  interfaces /BOBF/IF_FRW_AUTH_HANDLER_INST .

  types:
    tt_access_stack TYPE STANDARD TABLE OF REF TO /bobf/cl_frw_int_access WITH DEFAULT KEY .

  data MO_AUTHORITY_HANDLER type ref to /BOBF/CL_FRW_AUTHORITY_HANDLER read-only .

  class-METHODS class_constructor.

  methods CONSTRUCTOR
    importing
      !IO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION
    raising
      /BOBF/CX_FRW .
  methods GET_DIRECT_ACCESS
    returning
      value(RO_DIRECT_ACCESS) type ref to /BOBF/IF_FRW_DIRECT_ACCESS .
  METHODS get_enqueue_scope RETURNING VALUE(rv_enqueue_scope) TYPE /bobf/conf_enqueue_scope.
  METHODS get_cleanup_mode RETURNING VALUE(rv_cleanup_mode) TYPE /bobf/conf_cleanup_mode.

protected section.

*"* protected components of class /BOBF/CL_FRW
*"* do not include other source files here!!!
  methods CHECK_AND_DETERMINE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IT_KEY type /BOBF/T_FRW_KEY optional
      !IV_CHECK_SCOPE type /BOBF/FRW_SCOPE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
    exporting
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods GET_DELEGATION
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
    returning
      value(EO_DELEGATION) type ref to /BOBF/IF_FRW_DELEGATION .
  methods RAISE_NOTIFY_CHANGES
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
      !IV_NOTIFY_ENTIRE_STACK type BOOLE_D default ABAP_FALSE
    preferred parameter IO_CHANGE .
  methods RETRIEVE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_STATE type /BOBF/CONF_STATE
      !IV_INVALIDATE_CACHE type BOOLE_D default ABAP_FALSE
      !IV_FILL_DATA type BOOLE_D default ABAP_TRUE
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE default /BOBF/IF_CONF_C=>SC_EDIT_READ_ONLY
      !IV_BUFFER_ONLY type BOOLE_D default ABAP_FALSE
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_WITHIN_RETRIEVE type BOOLE_D default ABAP_FALSE
      !IT_REQUESTED_ATTRIBUTES type /BOBF/T_FRW_NAME optional
    exporting
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_DATA type INDEX TABLE
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !ET_NODE_CAT type /BOBF/T_FRW_NODE_CAT .
  methods AFTER_LOADING
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IV_LOAD_STATE type /BOBF/CONF_STATE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
    exporting
      !ET_FAILED_NODE type /BOBF/T_FRW_NODE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_LOADED_NODE type /BOBF/T_FRW_NODE .
  methods RETRIEVE_BY_ASSOCIATION
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_ASSOCIATION type /BOBF/OBM_ASSOC_KEY
      !IS_PARAMETERS type ref to DATA optional
      !IT_FILTERED_ATTRIBUTES type /BOBF/T_FRW_NAME optional
      !IV_STATE type /BOBF/CONF_STATE
      !IV_BEFORE_IMAGE type BOOLE_D optional
      !IV_INVALIDATE_CACHE type BOOLE_D default ABAP_FALSE
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE default /BOBF/IF_CONF_C=>SC_EDIT_READ_ONLY
      !IV_ASK_BUFFER type BOOLE_D default ABAP_FALSE
      !IV_BUFFER_ONLY type BOOLE_D default ABAP_FALSE
      !IV_FILL_DATA type BOOLE_D default ABAP_FALSE
      !IV_FILL_FAILED_KEY type BOOLE_D default ABAP_FALSE
      !IV_WITH_DET_BEFORE_RETRIEVE type BOOLE_D default ABAP_TRUE
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IT_REQUESTED_ATTRIBUTES type /BOBF/T_FRW_NAME optional
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
    exporting
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_DATA type INDEX TABLE
      !ET_KEY_LINK type /BOBF/T_FRW_KEY_LINK
      !ET_TARGET_KEY type /BOBF/T_FRW_KEY
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY .
  methods SET_APPLICATION_ERROR
    importing
      !IO_EXCEPTION type ref to CX_ROOT optional .
  methods DETERMINE_TRIGGERED_VAL_KEYS
    importing
      !IS_VALIDATION type /BOBF/S_CONFRO_VAL_LIST
      !IO_CHANGE type ref to /BOBF/CL_FRW_CHANGE
      !IV_PROCESSING_MODE type /BOBF/FRW_PROCESSING_MODE
      !IV_USE_CHECK_TRIGGER type ABAP_BOOL
      !IV_LAST_STATE type /BOBF/CONF_STATE
    exporting
      !ET_KEY type /BOBF/T_FRW_KEY
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  class-methods NEEDS_NOTIFY_KEYLOAD
    importing
      !IV_HAS_TRANSIENT_ELEMENTS type BOOLE_D
      !IV_HAS_AUTH_DETERM type BOOLE_D
      !IT_REQUESTED_ATTRIBUTES type /BOBF/T_FRW_NAME
      !IR_LOAD_ATTRIBUTE_TAB type ref to /BOBF/T_FRW_NAME
    exporting
      !EV_TRANSIENT_FIELDS_REQUESTED type BOOLE_D
    returning
      value(RV_NOTIFY_KEYLOAD) type BOOLE_D .
private section.

  types:
    BEGIN OF ty_sync_point,
      handle          TYPE        /bobf/conf_key,
      state           TYPE        /bobf/conf_state,
      state_d         TYPE        /bobf/conf_state,
      state_v         TYPE        /bobf/conf_state,
      state_f         TYPE        /bobf/conf_state,
      change_fail_det TYPE REF TO /bobf/cl_frw_change,
      change_fail_val TYPE REF TO /bobf/cl_frw_change,
      states_count    TYPE        i,
    END OF ty_sync_point .
  types:
    tt_sync_point TYPE STANDARD TABLE OF ty_sync_point .
  types:
    ty_transient_node_ctrl TYPE c LENGTH 1 .
  types:
    BEGIN OF ty_dra_consistency_failed_node,
      node_key TYPE /bobf/obm_node_key,
      keys     TYPE /bobf/t_frw_key,
    END OF ty_dra_consistency_failed_node .
  types:
    tt_dra_consistency_failed_node TYPE STANDARD TABLE OF ty_dra_consistency_failed_node .

  data MV_LOADABLE type BOOLE_D .
  data MO_NON_CACHE_REG type ref to /BOBF/CL_TRA_NON_CACHE_REG .
  class-data GV_SYSTEM_CLIENT_ROLE type CCCATEGORY .
  data MO_BUFFER type ref to /BOBF/IF_FRW_BUFFER .
  data MO_CHANGE_FAIL_DET type ref to /BOBF/CL_FRW_CHANGE .
  data MO_CHANGE_FAIL_VAL type ref to /BOBF/CL_FRW_CHANGE .
  data MO_CHANGE_SAVE type ref to /BOBF/IF_FRW_CHANGE .
  data MO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION .
  data MO_DELEGATION_READ type ref to /BOBF/IF_FRW_READ .
  data MO_DELEGATION type ref to /BOBF/IF_FRW_DELEGATION .
  data MO_SAM type ref to /BOBF/IF_FRW_STATUS .
  data MO_DIRECT_ACCESS type ref to /BOBF/IF_FRW_DIRECT_ACCESS .
  data MO_LOCK_MANAGER type ref to /BOBF/CL_FRW_LOCK_MANAGER .
  data MT_ACCESS_STACK type TT_ACCESS_STACK .
  data MT_ACTION type TT_ACTION .
  data MT_ASSOCIATION type TT_ASSOCIATION .
  data MT_CHANGE_SAVE type /BOBF/T_FRW_CHANGE_SAVE .
  data MT_DELEGATION type /BOBF/T_FRW_DELEGATION .
  data MT_DELEGATION2 type /BOBF/T_FRW_DELEGATION2 .
  data MT_DETERMINATION type TT_DETERMINATION .
  data MT_NODE type TT_NODE .
  data MT_NODECAT type /BOBF/T_FRW_NODE_CAT .
  data MT_NODECAT_KEY type /BOBF/T_FRW_KEY .
  data MT_QUERY type TT_QUERY .
  data MT_VALIDATION type TT_VALIDATION .
  data MT_VALUE_SET_CODE type TT_VALUE_SET_CODE .
  data MT_VALUE_SET_ID type TT_VALUE_SET_ID .
  data MV_APPLICATION_ERROR type BOOLE_D .
  data MV_BEFORE_MODIFICATION_EXISTS type BOOLE_D .
  data MV_CONFIGURATION_ERROR type BOOLE_D .
  data MV_DEFAULTS_EXISTS type BOOLE_D .
  data MV_MODIFYING_TRANSACTION type BOOLE_D .
  data MV_NODECAT_NODE_KEY type /BOBF/OBM_NODE_KEY .
  data MT_NODE_PROPERTIES_REQUESTED type /BOBF/T_FRW_KEY2 .
  data MV_NO_DETERMINATIONS type BOOLE_D .
  data MT_SYNC_POINT type TT_SYNC_POINT .
  constants GC_SYNC_STATE type STRING value ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' ##NO_TEXT.
  data MV_SYNC_STATE_INDEX type I .
  data MV_CLEANUP_MODE type /BOBF/CONF_CLEANUP_MODE .
  data MV_ENQUEUE_SCOPE type /BOBF/CONF_ENQUEUE_SCOPE .
  data:
    MT_DRAFT_ADMIN_DATA_BUFFER type table of SDRAFT_ADMIN_S .
  data MV_NO_CONTENT_CHANGES type ABAP_BOOL .
  constants:
    BEGIN OF gc_transient_node_ctrl.
  CONSTANTS   none                           TYPE ty_transient_node_ctrl VALUE IS INITIAL.
  CONSTANTS   return_transient_nodes         TYPE ty_transient_node_ctrl VALUE 'X'.
  CONSTANTS   return_transient_only_buffered TYPE ty_transient_node_ctrl VALUE 'B'.
  CONSTANTS END OF gc_transient_node_ctrl .
  constants GC_VAL_TIME_NO_VALUE type /BOBF/OBM_NAME value 'NO_VALUE' ##NO_TEXT.

  methods GET_STATE_FOR_READ
    importing
      !IV_BEFORE_IMAGE type BOOLE_D
    returning
      value(RV_STATE) type /BOBF/CONF_STATE .
  methods CLEANUP_MODS_FROM_UNCHANGED
    importing
      !IT_UNCHANGED type /BOBF/T_FRW_NODE_DATA
      !IT_CHANGED type /BOBF/T_FRW_NODE_DATA
    changing
      !CT_MOD type /BOBF/T_FRW_MODIFICATION
      !CT_UPDATE type /BOBF/T_FRW_NODE
      !CT_NODE_STATE_CREATE type /BOBF/T_FRW_NODE
      !CT_UPDATE_DATA type /BOBF/T_FRW_NODE_DATA
      !CT_UPDATE_DATA_STATUS type /BOBF/T_FRW_NODE_DATA .
  methods NOTIFY_NODES_READ_CACHE_ENABLE
    importing
      !IT_NODE_KEY type /BOBF/T_FRW_KEY .
  methods LOCK
    importing
      !IT_LOCK type /BOBF/T_FRW_NODE
      !IV_GENERIC type BOOLE_D
      !IV_WITHIN_LOADING type BOOLE_D
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IT_LOCKED_FOR_DELETE type /BOBF/T_FRW_NODE optional
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !CT_MOD type /BOBF/T_FRW_MODIFICATION
      !CT_FAILED_LOCK type /BOBF/T_FRW_NODE .
  methods DO_DET_FILL_CHANGE_FAIL
    importing
      !IV_EXECTIME type /BOBF/CONF_EXECTIME
      !IV_CURRENT_STATE type /BOBF/CONF_STATE
      !IT_FAILED_ROOT_KEY type /BOBF/T_FRW_KEY
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  class-methods CHECK_FIELDS_ARE_TRIGGERS
    importing
      !IV_TRIGGER_ATTR_ALL type ABAP_BOOL
      !IRT_TRIGGER_ATTR type ref to /BOBF/T_FRW_NAME_SORTED
      !IT_CHANGED_FIELDS type /BOBF/T_FRW_NAME
    returning
      value(RV_FIELDS_ARE_TRIGGERS) type ABAP_BOOL .
  methods TYPE_CHECK
    importing
      !IV_EXPECTED_LINE_TYPE type STRING
      !IV_SERVICE_NAME type STRING
      !IV_PARAMETER_NAME type STRING
      !IT_DATA type INDEX TABLE .
  methods ADD_MESSAGES
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods ADD_TRIGGER_CONDITION
    importing
      !IT_GROUP type /BOBF/T_FRW_GROUP
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE .
  methods CHECK_ACTION
    importing
      !IV_ACT_KEY type /BOBF/ACT_KEY optional
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_ACT_CAT type /BOBF/ACT_CAT optional
      !IS_CONTEXT type /BOBF/S_FRW_CTX_ACT optional
      !IS_PARAMETERS type ref to DATA optional
      !IV_CHECK_PROPERTY type BOOLE_D
      !IV_CHECK_VALIDATION type BOOLE_D
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
    exporting
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    changing
      !CT_KEY type /BOBF/T_FRW_KEY .
  methods CHECK_FATAL_ERROR .
  methods CHECK_MODIFICATION_PROPERTIES
    importing
      !IV_STATE type /BOBF/CONF_STATE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED type /BOBF/T_FRW_NODE
    changing
      !CT_MODIFICATION type /BOBF/T_FRW_MODIFICATION .
  methods CLEANUP_MODIFICATIONS
    importing
      !IT_FAILED_NODE type /BOBF/T_FRW_NODE optional
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IT_FAILED_ROOT_KEY type /BOBF/T_FRW_KEY optional
    changing
      !CT_MOD type /BOBF/T_FRW_MODIFICATION
      !CT_MOD_DO type /BOBF/T_FRW_MODIFICATION_DO
      !CT_LOAD type /BOBF/T_FRW_NODE optional
      !CT_LOCK_CREATED type /BOBF/T_FRW_NODE optional
      !CT_CREATE type /BOBF/T_FRW_NODE optional
      !CT_UPDATE type /BOBF/T_FRW_NODE optional
      !CT_DELETE type /BOBF/T_FRW_NODE optional
      !CT_UPDATE_DATA type /BOBF/T_FRW_NODE_DATA optional
      !CT_UPDATE_DATA_STA type /BOBF/T_FRW_NODE_DATA optional
      !CT_NODE_STATE_CREATE type /BOBF/T_FRW_NODE optional
      !CT_UPDATE_DATA_ALL type /BOBF/T_FRW_NODE_DATA optional
      !CT_LOAD_ONLY_KEYLOAD type /BOBF/T_FRW_NODE optional
      !CT_NODE_CATEGORY type /BOBF/T_FRW_NODE optional .
  methods CONVERT_ALTERN_KEY
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IV_ALTKEY_KEY type /BOBF/OBM_ALTKEY_KEY
      !IV_TARGET_ALTKEY_KEY type /BOBF/OBM_ALTKEY_KEY
      !IT_KEY type INDEX TABLE
      !IV_STATE type /BOBF/CONF_STATE
      !IV_INVALIDATE_CACHE type BOOLE_D
      !IV_CHECK_EXISTENCE type BOOLE_D
      !IV_FILL_TARGET_KEY type BOOLE_D
      !IV_BUFFER_SUFFICIENT_HINT type BOOLE_D default ABAP_FALSE
    exporting
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_RESULT type /BOBF/T_FRW_KEYINDEX
      !ET_KEY type INDEX TABLE .
  methods CREATE
    importing
      !IT_MOD type /BOBF/T_FRW_MODIFICATION
      !IV_ASSOC_KEY type /BOBF/OBM_ASSOC_KEY
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE
      !IV_STATE type /BOBF/CONF_STATE default /BOBF/IF_CONF_C=>SC_STATE_CURRENT
      !IV_WITHIN_LOADING type BOOLE_D
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_WITHIN_RETRIEVE type BOOLE_D
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods CREATE_STATES .
  methods DERIVE_CONSISTENCY_STATUS
    importing
      !IT_FAILED_VAL type /BOBF/T_FRW_VALIDATIONS
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    changing
      !CT_GROUP type /BOBF/T_FRW_GROUP .
  methods DO_ACTION
    importing
      !IS_ACTION type /BOBF/S_FRW_ACTION
      !IV_WITH_DETVAL type BOOLE_D default ABAP_TRUE
      !IV_INTERNAL_CALL type BOOLE_D
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !EV_STATIC_ACTION_FAILED type ABAP_BOOL
      !ET_DATA type INDEX TABLE .
  methods DO_DETERMINATIONS
    importing
      !IV_EXECTIME type /BOBF/CONF_EXECTIME
      !IV_LOAD_STATE type /BOBF/CONF_STATE optional
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_CLEANUP_MODE type /BOBF/CONF_CLEANUP_MODE optional
      !IV_KEEP_CACHE type BOOLE_D optional
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED type /BOBF/T_FRW_NODE .
  methods DO_DETERMINATIONS_RETRIEVE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_ASSOC_KEY type /BOBF/OBM_ASSOC_KEY optional
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_KEY_IS_DEFAULT type BOOLE_D default ABAP_FALSE
      !IS_PARAMETERS type ref to DATA optional
      !IT_FILTERED_ATTRIBUTES type /BOBF/T_FRW_NAME optional
      !IV_STATE type /BOBF/CONF_STATE
      !IV_WITHIN_LOADING type BOOLE_D
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY .
  methods DO_DETVAL
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_VALIDATION_TIME_CONTEXT type /BOBF/OBM_NAME default GC_VAL_TIME_NO_VALUE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods DO_LOADING
    importing
      !IV_NODE_KEY_UNIQUE type /BOBF/OBM_NODE_KEY optional
      !IT_NODE type /BOBF/T_FRW_NODE optional
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IT_KEY type /BOBF/T_FRW_KEY optional
      !IV_CHECK_BUF type BOOLE_D default ABAP_TRUE
      !IV_RELOAD type BOOLE_D default ABAP_FALSE
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_LOAD_DATA type BOOLE_D
      !IV_LOAD_SUBTREE type /BOBF/FRW_LOAD_SUBTREE
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE default /BOBF/IF_CONF_C=>SC_EDIT_READ_ONLY
      !IV_NOTIFY_KEYLOAD type BOOLE_D default ABAP_FALSE
      !IT_NODE_NO_RELOAD type /BOBF/T_FRW_NODE optional
    exporting
      !ET_FAILED type /BOBF/T_FRW_NODE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_LOADED_NODE type /BOBF/T_FRW_NODE .
  methods DO_LOCK_ACTION
    importing
      !IS_LOCK_PARAM type ref to /BOBF/S_FRW_LOCK_PARAMETERS
      !IS_CONTEXT type /BOBF/S_FRW_CTX_ACT
      !IV_ACT_CLASS type STRING
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
    changing
      !CT_KEY type /BOBF/T_FRW_KEY
      !CT_MOD type /BOBF/T_FRW_MODIFICATION optional .
  methods DO_MODIFY
    importing
      !IT_MODIFICATION type /BOBF/T_FRW_MODIFICATION
      !IV_INTERNAL_MODIFY type BOOLE_D default ABAP_FALSE
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE default /BOBF/IF_CONF_C=>SC_EDIT_EXCLUSIVE
      !IV_ASSOC_KEY type /BOBF/OBM_ASSOC_KEY optional
      !IV_ACT_KEY type /BOBF/ACT_KEY optional
      !IV_DET_KEY type /BOBF/DET_KEY optional
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_WITHIN_RETRIEVE type BOOLE_D default ABAP_FALSE
      !IV_STATE type /BOBF/CONF_STATE default /BOBF/IF_CONF_C=>SC_STATE_CURRENT
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE .
  methods DO_VALIDATE
    importing
      !IV_LAST_STATE_DB type BOOLE_D default ABAP_FALSE
      !IV_CHECK_GROUP_KEY type /BOBF/OBM_GROUP_KEY optional
      !IV_ONLY_GIVEN_VALIDATIONS type BOOLE_D
      !IV_PERFORM_CHECK_DELTA type BOOLE_D default ABAP_FALSE
      !IT_VALIDATION type /BOBF/T_FRW_KEY optional
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_CONSISTENCY type BOOLE_D default ABAP_TRUE
      !IV_VALIDATION_TIME_CONTEXT type /BOBF/OBM_NAME default GC_VAL_TIME_NO_VALUE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED_VAL type /BOBF/T_FRW_VALIDATIONS .
  methods FILTER_CONSISTENCY_GROUPS
    changing
      !CT_GROUP type /BOBF/T_FRW_GROUP .
  methods GET_CONTENT_DESCRIPTION
    importing
      !IV_ACT type BOOLE_D default ABAP_FALSE
      !IV_ASSOC type BOOLE_D default ABAP_FALSE
      !IV_DET type BOOLE_D default ABAP_FALSE
      !IV_VAL type BOOLE_D default ABAP_FALSE
      !IV_QUERY type BOOLE_D default ABAP_FALSE
      !IV_NODE type BOOLE_D default ABAP_FALSE
      !IV_VSET type BOOLE_D default ABAP_FALSE
      !IV_KEY type /BOBF/CONF_KEY
    returning
      value(EV_CONTENT_DESCRIPTION) type /BOBF/OBM_NAME .
  methods GET_LOADABLE_NODE
    importing
      !IT_NODE type /BOBF/T_FRW_NODE
      !IV_LOAD_SUBTREE type /BOBF/FRW_LOAD_SUBTREE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !ET_NODE type /BOBF/T_FRW_NODE
      !ET_NODE_LINK type /BOBF/T_FRW_NODE_KEY_LINK
      !ET_FAILED_NODE type /BOBF/T_FRW_NODE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    changing
      !CT_LOAD_DO type TT_LOAD_DO .
  methods GET_LOADABLE_SUBNODE
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_ALL_LOCKGROUPS type BOOLE_D
      !IV_RECURSIVE_CALL type BOOLE_D default ABAP_FALSE
    exporting
      !ET_NODE type /BOBF/T_FRW_NODE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    changing
      !CT_LOAD_DO type TT_LOAD_DO .
  methods GET_LOCKABLE_NODE
    importing
      !IT_NODE type /BOBF/T_FRW_NODE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
    exporting
      !ET_NODE type /BOBF/T_FRW_NODE
      !ET_NODE_LINK type /BOBF/T_FRW_NODE_KEY_LINK
      !ET_FAILED_NODE type /BOBF/T_FRW_NODE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_LOADED_NODE type /BOBF/T_FRW_NODE .
  methods GET_NODE_CAT
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_CURRENT_STATE type /BOBF/CONF_STATE
      !IV_LAST_STATE type /BOBF/CONF_STATE
    exporting
      !ET_NODECAT type /BOBF/T_FRW_NODE_CAT
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods GET_RELEVANT_GROUPS
    importing
      !IV_PROCESSING_MODE type /BOBF/FRW_PROCESSING_MODE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_STATE_CURRENT type /BOBF/CONF_STATE default /BOBF/IF_CONF_C=>SC_STATE_CURRENT
      !IV_STATE_BEFORE type /BOBF/CONF_STATE
    exporting
      !ET_GROUP_2_WAY type /BOBF/T_FRW_GROUP
      !ET_GROUP_3_WAY type /BOBF/T_FRW_GROUP
      !ET_GROUP_NO_STATUS type /BOBF/T_FRW_GROUP
      !ET_VALIDATIONS type /BOBF/T_FRW_KEY
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods GET_ROOT_KEY
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IV_BEFORE_IMAGE type BOOLE_D default ABAP_FALSE
    exporting
      !ET_KEY_LINK type /BOBF/T_FRW_KEY_LINK
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !ET_TARGET_KEY type /BOBF/T_FRW_KEY
      !ET_LOADED_NODE type /BOBF/T_FRW_NODE .
  methods GET_ROOT_KEY_MODIFY
    importing
      !IT_NODE type /BOBF/T_FRW_NODE
      !IV_STATE type /BOBF/CONF_STATE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !ET_KEY type /BOBF/T_FRW_KEY
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_KEY_LINK type /BOBF/T_FRW_KEY_LINK
    changing
      !CT_MOD type /BOBF/T_FRW_MODIFICATION optional .
  methods GET_SUBNODES
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IT_NODE_KEY type /BOBF/T_FRW_KEY2 optional
      !IV_STOP_AT_LOADABLE type BOOLE_D default ABAP_FALSE
      !IV_STOP_AT_LOCKABLE type BOOLE_D default ABAP_FALSE
      !IV_STOP_AT_DELEGATION_ROOT type BOOLE_D default ABAP_FALSE
      !IV_STOP_AT_DELEGATION_SUBTREE type BOOLE_D default ABAP_FALSE
      !IV_RETURN_ONLY_LOADABLE type BOOLE_D default ABAP_FALSE
      !IV_RETURN_ONLY_LOCKABLE type BOOLE_D default ABAP_FALSE
      !IV_RETURN_TRANSIENT_NODES type TY_TRANSIENT_NODE_CTRL default GC_TRANSIENT_NODE_CTRL-NONE
      !IV_RETURN_ONLY_CHECK_TRIGGER type BOOLE_D default ABAP_FALSE
      !IV_BUFFER_ONLY type BOOLE_D default ABAP_FALSE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    changing
      !CT_HOST_NODE type /BOBF/T_FRW_NODE
      !CT_DELEGATION_ROOT_NODE type /BOBF/T_FRW_NODE optional
      !CT_DELEGATION_SUBTREE type /BOBF/T_FRW_NODE optional
      !CT_NODE_KEYS_ON_PATH type /BOBF/T_FRW_KEY2 optional .
  methods MAP_TO_NODE
    importing
      !IV_NODE_KEY type /BOBF/CONF_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
    exporting
      !ET_NODE type /BOBF/T_FRW_NODE .
  methods NOTIFY_ASSOCIATION_CHANGES
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_LAST_STATE type /BOBF/CONF_STATE default /BOBF/IF_CONF_C=>SC_STATE_DATABASE
      !IV_DELETE type BOOLE_D default ABAP_FALSE
      !IV_DEPENDENT_OBJECTS type BOOLE_D default ABAP_FALSE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods NOTIFY_ASSOCIATION_CHANGES_DO
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_STATE type /BOBF/CONF_STATE default /BOBF/IF_CONF_C=>SC_STATE_DATABASE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods NOTIFY_PROPERTY_CHANGES
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_LAST_STATE type /BOBF/CONF_STATE optional
      !IV_DELETE type BOOLE_D default ABAP_FALSE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods NOTIFY_ASSOCIATION_CHANGES_CU
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods RESTRICT_PROPERTY
    importing
      !IV_NODE_PROPERTY type BOOLE_D default ABAP_FALSE
      !IV_NODE_ATTRIBUTE_PROPERTY type BOOLE_D default ABAP_FALSE
      !IT_NODE_ATTRIBUTE type /BOBF/T_FRW_NAME optional
      !IV_ASSOC_PROPERTY type BOOLE_D default ABAP_FALSE
      !IT_ASSOC type /BOBF/T_FRW_KEY2 optional
      !IV_ASSOC_ATTRIBUTE_PROPERTY type BOOLE_D default ABAP_FALSE
      !IV_ACTION_PROPERTY type BOOLE_D default ABAP_FALSE
      !IT_ACTION type /BOBF/T_FRW_KEY2 optional
      !IV_ACTION_ATTRIBUTE_PROPERTY type BOOLE_D default ABAP_FALSE
      !IV_QUERY_PROPERTY type BOOLE_D default ABAP_FALSE
      !IT_QUERY type /BOBF/T_FRW_KEY2 optional
      !IV_QUERY_ATTRIBUTE_PROPERTY type BOOLE_D default ABAP_FALSE
    changing
      !CT_PROPERTY_DATA type /BOBF/T_CONFRO_PROPERTY_D optional .
  methods NOTIFY_ASSOCIATION_CHANGES_D
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_LAST_STATE type /BOBF/CONF_STATE default /BOBF/IF_CONF_C=>SC_STATE_DATABASE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods ADD_NOTIFS_FOR_RESOLVE_ASSOC
    importing
      !IT_SOURCE_KEY type /BOBF/T_FRW_KEY
      !IR_ASSOC type ref to /BOBF/S_CONFRO_ASSOC
      !IV_RESOLVE_ASSOC_KEY type /BOBF/OBM_ASSOC_KEY
      !IV_STATE type /BOBF/CONF_STATE
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !CT_CONTENT_CHANGE type /BOBF/T_FRW_CHANGE_CONTENT .
  methods RETRIEVE_SUBTREE_PROPERTY
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IT_KEY_LINK type /BOBF/T_FRW_KEY_LINK optional
      !IV_STATE type /BOBF/CONF_STATE
      !IV_DETERMINE_PROPERTY type BOOLE_D default ABAP_TRUE
      !IV_RESOLVE_PROPERTY type BOOLE_D optional
      !IV_NODE_PROPERTY type BOOLE_D optional
      !IV_ASSOC_PROPERTY type BOOLE_D optional
      !IT_ASSOC type /BOBF/T_FRW_KEY2 optional
    exporting
      !ET_PROPERTY type /BOBF/T_FRW_PROPERTY_K
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods SET_CONFIGURATION_ERROR
    importing
      !IO_EXCEPTION type ref to CX_ROOT optional .
  methods SET_CONSISTENCY_STATUS
    importing
      !IT_GROUP type /BOBF/T_FRW_GROUP
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods SET_NODE_CATEGORY
    importing
      !IT_NODE type /BOBF/T_FRW_NODE
      !IV_INTERNAL_MODIFY type BOOLE_D
    exporting
      !ET_FAILED type /BOBF/T_FRW_NODE
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods CHECK_PROPERTIES_BEFORE_MODIFY
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_STATE type /BOBF/CONF_STATE
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !CT_MOD type /BOBF/T_FRW_MODIFICATION
      !CT_MOD_DO type /BOBF/T_FRW_MODIFICATION_DO
      !CT_CREATE type /BOBF/T_FRW_NODE
      !CT_UPDATE type /BOBF/T_FRW_NODE
      !CT_DELETE type /BOBF/T_FRW_NODE
      !CT_LOCK_CREATED type /BOBF/T_FRW_NODE
      !CT_NODE_CATEGORY type /BOBF/T_FRW_NODE
      !CT_UPDATE_DATA type /BOBF/T_FRW_NODE_DATA
      !CT_UPDATE_DATA_STATUS type /BOBF/T_FRW_NODE_DATA
      !CT_UPDATE_DATA_ALL type /BOBF/T_FRW_NODE_DATA
      !CT_NODE_STATE_CREATE type /BOBF/T_FRW_NODE .
  methods UNLOCK_LOCKABLE_NODES
    importing
      !IT_NODES type /BOBF/T_FRW_NODE .
  methods CHECK_ACTION_NODE_CATEGORY
    importing
      !IS_CONF_ACTION type /BOBF/S_CONFRO_ACT_LIST
      !IS_CONF_NODE type /BOBF/S_CONFRO_NODE
      !IV_LAST_STATE type /BOBF/CONF_STATE
    changing
      !CT_KEY type /BOBF/T_FRW_KEY
      !CT_FAILED_KEY type /BOBF/T_FRW_KEY
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods COLLECT_MESSAGES
    importing
      !IO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods CREATE_DURABLE_MSG_CONTAINER
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods REMOVE_DURABLE_MESSAGES
    importing
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    changing
      !CO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  methods DO_DELETE_ACTION
    importing
      !IT_DELETE type /BOBF/T_FRW_NODE
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED_NODE type /BOBF/T_FRW_NODE .
  methods FILTER_OUT_UNNECESSARY_KEYS
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IO_DET_CLASS type ref to /BOBF/IF_FRW_DETERMINATION
      !IT_ALL_KEYS type /BOBF/T_FRW_KEY
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    returning
      value(RT_KEY) type /BOBF/T_FRW_KEY .
  methods EXECUTE_ACTION
    importing
      !IS_CONTEXT type /BOBF/S_FRW_CTX_ACT
      !IS_CONF type /BOBF/S_CONFRO_ACT_LIST
      !IS_PARAMETER type ref to DATA optional
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE
      !IV_WITHIN_LOADING type ABAP_BOOL default ABAP_FALSE
      !IV_IS_BASE_ACTION type ABAP_BOOL default ABAP_TRUE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
    exporting
      !ET_FAILED_KEY type /BOBF/T_FRW_KEY
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !EV_STATIC_ACTION_FAILED type ABAP_BOOL
      !ET_DATA type INDEX TABLE
    changing
      !CT_KEY type /BOBF/T_FRW_KEY .
  methods CHECK_INCONSISTENT_COMPOSITION
    importing
      !IT_CREATE_NODE type /BOBF/T_FRW_NODE
    exporting
      !EO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
      !ET_FAILED_NODE type /BOBF/T_FRW_NODE .
  methods LIB_ENQUEUE_CONTEXT_PUSH_KEYS
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY .
  methods LIB_ENQUEUE_CONTEXT_POP .
  methods SET_DRAFT_CONSISTENCY_STATUS
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IT_FAILED_VAL type /BOBF/T_FRW_VALIDATIONS
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE .
  methods RESET_DRAFT_CONSISTENCY_STATUS
    importing
      !IT_CREATE type /BOBF/T_FRW_NODE
      !IT_UPDATE type /BOBF/T_FRW_NODE_DATA .
  methods EVALUATE_FAILED_VALIDATE_KEYS
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IT_KEY type /BOBF/T_FRW_KEY
      !IT_FAILED_VAL type /BOBF/T_FRW_VALIDATIONS
    exporting
      !ET_INCONSISTENT_KEY type /BOBF/T_FRW_KEY
    raising
      /BOBF/CX_FRW .
  "! @parameter iv_state_current | can be omitted if an internal access object is on mt_access_stack
  "! @parameter iv_state_before  | can be omitted if an internal access object is on mt_access_stack
  methods GET_VALIDATION_TRIGGER
    importing
      !IV_PROCESSING_MODE type /BOBF/FRW_PROCESSING_MODE
      !IS_CHANGE_MODE type /BOBF/S_CONFRO_CHG_MODE
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IO_CHANGE type ref to /BOBF/CL_FRW_CHANGE
      !IV_STATE_CURRENT type /BOBF/CONF_STATE optional
      !IV_STATE_BEFORE type /BOBF/CONF_STATE optional
    exporting
      !ET_KEY type /BOBF/T_FRW_KEY .
  methods VAL_TIME_TO_PROCESSING_MODE
    importing
      !IV_VAL_TIME type /BOBF/OBM_NAME
    returning
      value(RV_PROCESSING_MODE) type /BOBF/FRW_PROCESSING_MODE .
  methods PREPARE_NOTIFICATIONS_F_EXPORT
    importing
      !IO_CHANGE type ref to /BOBF/CL_FRW_CHANGE .
  methods CONVERT_ASC_SRC_TO_CONT_CHANGE
    importing
      !IT_ASSOCIATION_SOURCE type /BOBF/IF_FRW_CHANGE=>TT_ASSOCIATION_SOURCE
    returning
      value(RT_CONTENT_CHANGE) type /BOBF/T_FRW_CHANGE_CONTENT .
ENDCLASS.



CLASS /BOBF/CL_FRW IMPLEMENTATION.


method /BOBF/IF_FRW_SERVICE_LAYER~ADJUST_NUMBERS.

  DATA: lt_root_key         TYPE /BOBF/T_FRW_KEY,
        lt_tmp_key          TYPE /BOBF/T_FRW_KEY,
        lt_failed_node      TYPE /BOBF/T_FRW_NODE,
        lt_adjusted_numbers TYPE /BOBF/T_FRW_ADJUSTED_NUMBERS,
        lo_delegation       TYPE REF TO /BOBF/IF_FRW_DELEGATION,
        lo_change           TYPE REF TO /BOBF/CL_FRW_CHANGE,
        lo_change_save      TYPE REF TO /BOBF/IF_FRW_CHANGE,
        ls_change_save      TYPE /BOBF/S_FRW_CHANGE_SAVE,
        lx_root             TYPE REF TO cx_root.

  BREAK-POINT ID /BOBF/FRW.
  ASSERT ID /BOBF/FRW CONDITION eo_message IS REQUESTED.
  ASSERT ID /BOBF/FRW_ERROR CONDITION mt_access_stack IS INITIAL.
  CLEAR: eo_message.

  IF it_root_key IS INITIAL.
    lo_change_save = mo_change_save.
  ELSE.
    lt_root_key = it_root_key.
    SORT lt_root_key BY key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.
    READ TABLE mt_change_save INTO ls_change_save
      WITH KEY root_keys = lt_root_key.
*    Dealing with a strange access pattern, try best effort to support this
    IF sy-subrc <> 0.
      lo_change_save = /BOBF/CL_FRW_FACTORY=>GET_CHANGE( ).
      lo_change ?= lo_change_save.
      lo_change->trace_external_changes( abap_false ).
      TRY.
          IF mv_modifying_transaction = abap_true.
            mo_buffer->compare_states(
             EXPORTING
               iv_node_key      = mo_conf->ms_obj-root_node_key
               it_key           = lt_root_key
               iv_state_current = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
               iv_state_before  = /BOBF/IF_CONF_C=>SC_STATE_DATABASE
               iv_incl_subtree  = abap_true
               io_change        = lo_change_save ).
          ENDIF.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_changes(
             it_root_key = lt_root_key
             io_change   = lo_change_save ).
          ENDLOOP.
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      lo_change->trace_external_changes( abap_true ).
    ELSE.
      lo_change_save = ls_change_save-change.
    ENDIF.

    ASSERT ID /BOBF/FRW CONDITION lo_change_save IS BOUND.
    CLEAR lt_root_key.
  ENDIF.

* ____________________________________________________________________ *
* check if there is really something to do
  CHECK lo_change_save IS BOUND.

* ____________________________________________________________________ *
* check for fatal errors
  check_fatal_error( ).

* ____________________________________________________________________ *
* get_list of changed objects to save
  IF it_root_key IS INITIAL.
    TRY.
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
  ENDIF.

  CHECK lt_root_key IS NOT INITIAL.
  SORT lt_root_key BY key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* perform determinations (before save to draw numbers)
  do_determinations(
      EXPORTING
        iv_exectime = /BOBF/IF_CONF_C=>SC_TIME_BEFORE_SAVE_NUMBERS
        io_change   = lo_change_save
      IMPORTING
        eo_message  = eo_message
        et_failed   = lt_failed_node ).

  IF lt_failed_node IS NOT INITIAL.
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1. "#EC BOOL_OK
    set_application_error( ).
  ENDIF.

* ____________________________________________________________________ *
* adjust numbers of delegated objects
  TRY.
      LOOP AT mt_delegation2 INTO lo_delegation.
        lo_delegation->adjust_numbers(
          EXPORTING
            it_root_key         = lt_root_key
          IMPORTING
            et_adjusted_numbers = lt_adjusted_numbers ).
        APPEND LINES OF lt_adjusted_numbers TO et_adjusted_numbers.
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* create change object for external world
  eo_change = /BOBF/CL_FRW_FACTORY=>GET_CHANGE( ).
  eo_change->merge( lo_change_save ).
  lo_change ?= eo_change.
  prepare_notifications_f_export( lo_change ).
  notify_association_changes_cu( eo_change ).
  notify_property_changes( eo_change ).
  lo_change->delete_duplicate_notifications( ).

  ASSERT ID /BOBF/FRW_ERROR CONDITION mt_access_stack IS INITIAL.

endmethod.


 METHOD /bobf/if_frw_service_layer~after_failed_save.

   DATA: lt_root_key    TYPE /bobf/t_frw_key,
         lt_tmp_key     TYPE /bobf/t_frw_key,
         lo_change      TYPE REF TO /bobf/cl_frw_change,
         lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
         lo_message     TYPE REF TO /bobf/if_frw_message,
         lo_change_save TYPE REF TO /bobf/if_frw_change,
         ls_change_save TYPE /bobf/s_frw_change_save,
         lx_root        TYPE REF TO cx_root.

   BREAK-POINT ID /bobf/frw.
   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
   CLEAR: eo_message,
          eo_change.

   mv_no_determinations = abap_false.

   IF it_root_key IS INITIAL.
     lo_change_save = mo_change_save.
   ELSE.
     lt_root_key = it_root_key.
     SORT lt_root_key BY key.
     DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.
     READ TABLE mt_change_save INTO ls_change_save
       WITH KEY root_keys = lt_root_key.

*    Dealing with a save that was reject in FINALIZE
     IF sy-subrc <> 0.
       lo_change_save = /bobf/cl_frw_factory=>get_change( ).
       lo_change ?= lo_change_save.
       lo_change->trace_external_changes( abap_false ).
       TRY.
           IF mv_modifying_transaction = abap_true.
             mo_buffer->compare_states(
              EXPORTING
                iv_node_key      = mo_conf->ms_obj-root_node_key
                it_key           = lt_root_key
                iv_state_current = /bobf/if_conf_c=>sc_state_current
                iv_state_before  = /bobf/if_conf_c=>sc_state_database
                iv_incl_subtree  = abap_true
                io_change        = lo_change_save ).
           ENDIF.
           LOOP AT mt_delegation2 INTO lo_delegation.
             lo_delegation->get_changes(
              it_root_key = lt_root_key
              io_change   = lo_change_save ).
           ENDLOOP.
         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           set_application_error( lx_root ).
       ENDTRY.
       lo_change->trace_external_changes( abap_true ).
     ELSE.
       lo_change_save = ls_change_save-change.
     ENDIF.

     ASSERT ID /bobf/frw CONDITION lo_change_save IS BOUND.
     CLEAR lt_root_key.
   ENDIF.

*  ____________________________________________________________________ *
*  check if there is really something to do
*  if lo_change_save is not bound the object wasn't called yet
   CHECK lo_change_save IS BOUND.
   CHECK lo_change_save->has_changes( ) = abap_true.

*  ____________________________________________________________________ *
*  get_list of changed objects
   IF it_root_key IS INITIAL.
     TRY.
         mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
         LOOP AT mt_delegation2 INTO lo_delegation.
           lo_delegation->get_root_keys(
             EXPORTING io_read     = mo_delegation_read
             IMPORTING et_root_key = lt_tmp_key ).
           APPEND LINES OF lt_tmp_key TO lt_root_key.
         ENDLOOP.
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.
   ELSE.
     lt_root_key = it_root_key.
   ENDIF.

   SORT lt_root_key BY key.
   DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.
*  ____________________________________________________________________ *
*  after save for delegated objects
   TRY.
       LOOP AT mt_delegation2 INTO lo_delegation.
         lo_delegation->after_failed_save(
           EXPORTING
             it_root_key = lt_root_key
             io_change   = lo_change_save
           IMPORTING
             eo_message  = lo_message ).

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).
       ENDLOOP.

     CATCH cx_root INTO lx_root.                         "#EC CATCH_ALL
       set_application_error( lx_root ).
   ENDTRY.

*  ____________________________________________________________________ *
*  perform determinations (before save)
   do_determinations(
     EXPORTING
       iv_exectime = /bobf/if_conf_c=>sc_time_after_fail_save
       io_change   = lo_change_save
     IMPORTING
       eo_message  = lo_message ).

   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = eo_message ).

   lo_change ?= lo_change_save.
   prepare_notifications_f_export( lo_change ).
   eo_change = lo_change_save.
   notify_association_changes_cu( eo_change ).
   notify_property_changes( eo_change ).
   lo_change->delete_duplicate_notifications( ).

*  ____________________________________________________________________ *
*  clear save change object
   IF it_root_key IS INITIAL.
     CLEAR mo_change_save.
   ELSE.
     DELETE mt_change_save WHERE root_keys = it_root_key.
   ENDIF.

   IF mo_sam IS BOUND.
     mo_sam->cleanup( ).
   ENDIF.


   ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

 ENDMETHOD.


METHOD /bobf/if_frw_service_layer~after_successful_save.

  DATA: lt_root_key                    TYPE /bobf/t_frw_key,
        lt_chngd_and_unchngd_root_keys TYPE /bobf/t_frw_key,
        lt_root_key3                   TYPE /bobf/t_frw_key,
        lt_tmp_key                     TYPE /bobf/t_frw_key,
        lt_root_node                   TYPE /bobf/t_frw_node,
        lv_cleanup_mode                TYPE /bobf/conf_cleanup_mode,
        lv_application_information     TYPE string,
        lx_frw                         TYPE REF TO /bobf/cx_frw_core,
        ls_determination               TYPE REF TO /bobf/s_confro_exectime,
        lo_delegation                  TYPE REF TO /bobf/if_frw_delegation,
        lo_message                     TYPE REF TO /bobf/if_frw_message,
        lx_root                        TYPE REF TO cx_root,
        lo_change                      TYPE REF TO /bobf/cl_frw_change,
        lo_change_lock                 TYPE REF TO /bobf/if_frw_change,
        lo_change_save                 TYPE REF TO /bobf/if_frw_change,
        ls_change_save                 TYPE /bobf/s_frw_change_save,
        lo_cleanup_change              TYPE REF TO /bobf/if_frw_change.

  CONSTANTS:
    lc_edit_mode_update_attribute TYPE string VALUE 'EDIT_MODE_UPDATE',
    lc_edit_mode_attribute        TYPE string VALUE 'EDIT_MODE'.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
  CLEAR: eo_message,
         eo_change.

  mv_no_determinations = abap_false.

*  ____________________________________________________________________ *
*  transaction manager may overrule the cleanup mode
*  in case of asynchronous save & continue transaction pattern

  lv_cleanup_mode = mv_cleanup_mode.
  IF /bobf/cl_tra_transaction_mgr=>gv_tp_asynchronous_save = abap_true.
    "  As the BOPF update task writing the changes to database run asynchronously in that case,
    "  it is not ensured, that its execution was finished until a BO reload old data from the database.
    "  Thus all BOs must reuse their buffer as the new database state
    IF lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_refresh.
      lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_keep.
    ENDIF.

    " also ensure, that there is no AfterCommit Determination for the same reason
    ls_determination = mo_conf->get_determination( /bobf/if_conf_c=>sc_time_after_succ_save ).
    IF ls_determination IS NOT INITIAL AND ls_determination->det_list IS BOUND.
      IF ls_determination->det_list->* IS NOT INITIAL.
        " AfterCommit determinations are not allowed in scenarios using Asynchronous Save & Continue Patterns
        lv_application_information = 'AfterCommit Determinations are not allowed in Asynchronous Save & Continue scenarios' ##no_text.  " shall be English as part of dump
        CREATE OBJECT lx_frw
          EXPORTING
            previous                   = lx_root
            textid                     = /bobf/cx_frw_core=>sc_transaction_mode_error
            mv_application_information = lv_application_information.
        set_application_error( lx_frw ).
      ENDIF.
    ENDIF.
  ENDIF.

*  ____________________________________________________________________ *
*  get_list of changed objects
  IF it_root_key IS INITIAL.
    TRY.
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys( EXPORTING io_read     = mo_delegation_read
                                        IMPORTING et_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
  ENDIF.

  SORT lt_root_key BY key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

  IF it_root_key IS INITIAL.
    lo_change_save = mo_change_save.
  ELSE.
    lt_root_key3 = it_root_key.
    SORT lt_root_key3 BY key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key3 COMPARING key.
    READ TABLE mt_change_save INTO ls_change_save WITH KEY root_keys = lt_root_key3 TRANSPORTING change.
*    Dealing with a strange access pattern, try best effort to support this
    IF sy-subrc <> 0.
      lo_change_save = /bobf/cl_frw_factory=>get_change( ).
      lo_change ?= lo_change_save.
      lo_change->trace_external_changes( abap_false ).
      TRY.
          IF mv_modifying_transaction = abap_true.
            mo_buffer->compare_states(
               iv_node_key      = mo_conf->ms_obj-root_node_key
               it_key           = lt_root_key3
               iv_state_current = /bobf/if_conf_c=>sc_state_current
               iv_state_before  = /bobf/if_conf_c=>sc_state_database
               iv_incl_subtree  = abap_true
               io_change        = lo_change_save ).
          ENDIF.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_changes(
             it_root_key = lt_root_key3
             io_change   = lo_change_save ).
          ENDLOOP.
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      lo_change->trace_external_changes( abap_true ).
    ELSE.
      lo_change_save = ls_change_save-change.
    ENDIF.
    ASSERT ID /bobf/frw CONDITION lo_change_save IS BOUND.

  ENDIF.

  IF lo_change_save IS BOUND.
*  ____________________________________________________________________ *
*    after save for delegated objects
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->after_successful_save( EXPORTING it_root_key = lt_root_key
                                                          io_change   = lo_change_save
                                                IMPORTING eo_message  = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

*  ____________________________________________________________________ *
*    perform determinations (after successful save)
    IF lo_change_save->has_changes( ) = abap_true.
      do_determinations( EXPORTING iv_exectime = /bobf/if_conf_c=>sc_time_after_succ_save
                                   io_change   = lo_change_save
                         IMPORTING eo_message  = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
      lo_change ?= lo_change_save.
      prepare_notifications_f_export( lo_change ).
      notify_association_changes_cu( lo_change ).
      lo_change->delete_duplicate_notifications( ).
    ENDIF.

    eo_change = lo_change_save.
    notify_property_changes( eo_change ).
  ENDIF.

*  ____________________________________________________________________ *
*  cleanup locks
  mo_lock_manager->after_successful_save( EXPORTING iv_cleanup_mode = lv_cleanup_mode
                                          IMPORTING eo_message      = lo_message
                                                    eo_change       = lo_change_lock ).
  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).
  IF lo_change_lock IS BOUND.
    IF eo_change IS BOUND.
      eo_change->merge( lo_change_lock ).
    ELSE.
      eo_change = lo_change_lock.
    ENDIF.
  ENDIF.

*  ____________________________________________________________________ *
*  clear buffer states - copy current to database

  TRY.
      mo_buffer->get_root_keys( EXPORTING iv_changed_only = abap_false
                                IMPORTING et_root_key     = lt_chngd_and_unchngd_root_keys ).
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

  IF lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_keep
  OR lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_keep_lock.
*    endless transaction
    map_to_node( EXPORTING iv_node_key = mo_conf->ms_obj-root_node_key
                           it_key      = lt_chngd_and_unchngd_root_keys
                 IMPORTING et_node     = lt_root_node ).
    IF mv_modifying_transaction = abap_true.
      TRY.
          " perform determinations 'cleanup'
          IF lo_change_save IS BOUND.
            lo_cleanup_change = lo_change_save.
          ELSE.
            lo_cleanup_change = /bobf/cl_frw_factory=>get_change( ).
          ENDIF.
          do_determinations( EXPORTING iv_exectime   = /bobf/if_conf_c=>sc_time_cleanup
                                       io_change     = lo_change_save
                                       iv_keep_cache = abap_true
                             IMPORTING eo_message    = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          " Reset state to non-modifying transaction...
          mv_modifying_transaction = abap_false.
          " Clear change buffers
          mo_buffer->do_cleanup( it_root_key   = lt_chngd_and_unchngd_root_keys
                                 iv_keep_cache = abap_true ).
          " And remove unnecessary states from buffer (will be created later on)!
          mo_buffer->delete_state( it_node         = lt_root_node
                                   iv_incl_subtree = abap_true
                                   iv_state        = /bobf/if_conf_c=>sc_state_database ).
          IF mo_conf->ms_obj-last_val_state_not_relevant = abap_false.
            mo_buffer->delete_state( it_node         = lt_root_node
                                     iv_incl_subtree = abap_true
                                     iv_state        = /bobf/if_conf_c=>sc_state_last_validated ).
          ENDIF.
          IF mo_conf->ms_obj-last_det_state_not_relevant = abap_false.
            mo_buffer->delete_state( it_node         = lt_root_node
                                     iv_incl_subtree = abap_true
                                     iv_state        = /bobf/if_conf_c=>sc_state_last_determined ).
          ENDIF.
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.
    IF mv_defaults_exists = abap_true.
      TRY.
          mo_buffer->delete_state( it_node         = lt_root_node
                                   iv_incl_subtree = abap_true
                                   iv_state        = /bobf/if_conf_c=>sc_state_default ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

  ELSE. "cleanup mode is REFRESH
    mv_modifying_transaction = abap_false.

    " perform determinations 'cleanup'
    IF lo_change_save IS BOUND.
      lo_cleanup_change = lo_change_save.
    ELSE.
      lo_cleanup_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.
    do_determinations( EXPORTING iv_exectime   = /bobf/if_conf_c=>sc_time_cleanup
                                 io_change     = lo_change_save
                                 iv_keep_cache = abap_false
                       IMPORTING eo_message  = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    " do complete cleanup
    TRY.
        mo_buffer->do_cleanup( it_root_key = lt_chngd_and_unchngd_root_keys ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.

  mv_defaults_exists = abap_false.

*  ____________________________________________________________________ *
*  clear save change object
  IF it_root_key IS INITIAL.
    CLEAR mo_change_save.
  ELSE.
    DELETE mt_change_save WHERE root_keys = it_root_key.
  ENDIF.

  IF mo_sam IS BOUND.
    mo_sam->cleanup( ).
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~check_action.

  DATA: lt_key                TYPE /bobf/t_frw_key,
        ls_actconf            TYPE /bobf/s_confro_act_list,
        ls_key                TYPE /bobf/s_frw_key,
        lt_failed_key         TYPE /bobf/t_frw_key,
        lo_change             TYPE REF TO /bobf/if_frw_change,
        lo_message            TYPE REF TO /bobf/if_frw_message,
        lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
        lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
        lt_auth_failed_key    TYPE /bobf/t_frw_key.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         et_failed_key.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
  ENDIF.

* check for the action
  lt_key = is_action-key.
  lo_change = /bobf/cl_frw_factory=>get_change( ).

* ____________________________________________________________________ *
* check existence of all node instances the action is called with
  IF lt_key IS NOT INITIAL.
    IF mo_conf->ms_last_action-act_key NE is_action-act_key.
      mo_conf->get_act(
        EXPORTING
          iv_act_key = is_action-act_key
        IMPORTING
          es_action  = ls_actconf ).
    ELSE.
      ls_actconf = mo_conf->ms_last_action.
    ENDIF.

    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_set(
           it_key_set = lt_key ) = abap_true.

    retrieve(
      EXPORTING
        iv_node_key         = ls_actconf-node_key
        it_key              = lt_key
        iv_state            = /bobf/if_conf_c=>sc_state_current
        iv_invalidate_cache = abap_false
        iv_fill_data        = abap_false
        iv_edit_mode        = /bobf/if_conf_c=>sc_edit_read_only
        iv_buffer_only      = abap_false
        iv_within_loading   = abap_false
      IMPORTING
        eo_message          = lo_message
        et_failed_key       = lt_failed_key ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    LOOP AT lt_failed_key INTO ls_key.
      DELETE lt_key WHERE key = ls_key-key.
    ENDLOOP.

    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_check(
           it_key_subset = lt_failed_key ) = abap_true.

    IF lt_key IS INITIAL.
      et_failed_key = lt_failed_key.
      RETURN.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* check authorization
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-check_action
                                  bo_service          = space
                                  node_key            = ls_actconf-node_key )
      iv_cleanse_keys  = abap_true
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    IMPORTING
      et_failed_key    = lt_auth_failed_key
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_key
      co_message       = lo_auth_message_dummy
  ).

  ASSERT ID /bobf/frw CONDITION
     /bobf/cl_tool_assert=>is_key_subset_stack_set(
         it_key_set = lt_key ) = abap_true.

  check_action(
    EXPORTING
      iv_act_key          = is_action-act_key
      is_parameters       = is_action-parameters
      iv_check_property   = abap_true
      iv_check_validation = abap_true
      io_change           = lo_change
    IMPORTING
      eo_message          = lo_message
      et_failed_key       = et_failed_key
    CHANGING
      ct_key              = lt_key ).

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  LOOP AT lt_failed_key INTO ls_key.
    INSERT ls_key INTO TABLE et_failed_key.
  ENDLOOP.

  LOOP AT lt_auth_failed_key INTO ls_key.
    INSERT ls_key INTO TABLE et_failed_key.
  ENDLOOP.

  ASSERT ID /bobf/frw CONDITION
     /bobf/cl_tool_assert=>is_key_subset_stack_check(
         it_key_subset = et_failed_key ) = abap_true.
  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~check_and_determine.

* consistency check + calculation of consistency groups with status

  DATA: lo_message            TYPE REF TO /bobf/if_frw_message,
        lo_message2           TYPE REF TO /bobf/if_frw_message,
        lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
        lo_change             TYPE REF TO /bobf/if_frw_change,
        lo_change_cl          TYPE REF TO /bobf/cl_frw_change,
        lt_failed_val         TYPE /bobf/t_frw_validations,
        lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
        lo_auth_change        TYPE REF TO /bobf/if_frw_change,
        lt_key                TYPE /bobf/t_frw_key.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         eo_change,
         ev_rejected. " can be deleted

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
    IF lo_int_access->mv_valid_if_check = abap_false.
      ASSERT ID /bobf/frw_error CONDITION 0 = 1.           "#EC BOOL_OK
*     todo
    ENDIF.
  ENDIF.

  lt_key = it_key.

* ____________________________________________________________________ *
* check authorization (ignore IV_CHECK_SCOPE!)
  lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-change
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-check_and_determine
                                  bo_service          = space
                                  node_key            = iv_node_key )
      iv_cleanse_keys  = abap_true
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_key
      co_message       = lo_auth_message_dummy
  ).

* ____________________________________________________________________ *
* check for pending determinations
  IF mo_change_fail_det IS BOUND.
    lo_change = /bobf/cl_frw_factory=>get_change( ).
    lo_change->merge( mo_change_fail_det ).
    CLEAR mo_change_fail_det.
    do_determinations(
      EXPORTING
        iv_exectime = /bobf/if_conf_c=>sc_time_after_modify
        io_change   = lo_change
      IMPORTING
        eo_message  = lo_message ).
  ENDIF.

  IF mo_change_fail_val IS BOUND.
    IF lo_change IS NOT BOUND.
      lo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.
    lo_change->merge( mo_change_fail_val ).
    CLEAR mo_change_fail_val.
    do_validate(
      EXPORTING
        iv_only_given_validations  = abap_false
        io_change                  = lo_change
        iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check_and_determ
      IMPORTING
        et_failed_val              = lt_failed_val
        eo_message                 = lo_message2 ).
    collect_messages( EXPORTING io_message = lo_message2
                      CHANGING  co_message = lo_message ).

    do_determinations(
      EXPORTING
        iv_exectime = /bobf/if_conf_c=>sc_time_after_validation
        io_change   = lo_change
      IMPORTING
        eo_message  = lo_message2 ).
    collect_messages( EXPORTING io_message = lo_message2
                      CHANGING  co_message = lo_message ).
  ENDIF.

* ____________________________________________________________________ *
* call internal method
  check_and_determine(
    EXPORTING
      iv_node_key    = iv_node_key
      it_key         = lt_key
      iv_check_scope = iv_check_scope
    IMPORTING
      eo_change      = eo_change
      eo_message     = eo_message ).

* ____________________________________________________________________ *
* merge output from pending determinations into output from regular check_and_determine
  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  IF lt_failed_val IS NOT INITIAL.
    ev_rejected = abap_true.
  ENDIF.

  IF lo_change IS BOUND.
    IF eo_change IS BOUND.
      eo_change->merge( lo_change ).
    ELSE.
      eo_change = lo_change.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* handle changes
  IF eo_change IS BOUND.
    eo_change->merge( lo_auth_change ).
  ELSE.
    eo_change = lo_auth_change.
  ENDIF.
  lo_change_cl ?= eo_change.
  prepare_notifications_f_export( lo_change_cl ).
  notify_association_changes_cu( eo_change ).
  notify_property_changes( eo_change ).
  lo_change_cl->delete_duplicate_notifications( ).

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_authority.

    DATA lt_key TYPE /bobf/t_frw_key.
    lt_key = it_key.

    CLEAR et_failed_key.
    CLEAR eo_message.

    CALL METHOD mo_authority_handler->check_authority
      EXPORTING
        io_bopf          = me
        io_buffer        = mo_buffer
        io_change        = /bobf/cl_frw_factory=>get_change( )
        is_ctx           = is_ctx
        iv_cleanse_keys  = abap_false
        iv_last_state    = /bobf/if_conf_c=>sc_state_before_modification
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = et_failed_key
      CHANGING
        co_message       = eo_message
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_authority_statically.

    mo_authority_handler->check_authority_statically(
      EXPORTING
        is_ctx     = is_ctx
      IMPORTING
        eo_message = eo_message
        ev_failed  = ev_failed
    ).

  ENDMETHOD.


METHOD /bobf/if_frw_service_layer~check_before_save.

  DATA: lt_node        TYPE /bobf/t_frw_node,
        ls_node        TYPE /bobf/s_frw_node,
        lt_failed_key  TYPE /bobf/t_frw_key,
        lt_root_key    TYPE /bobf/t_frw_key,
        lt_tmp_key     TYPE /bobf/t_frw_key,
        lt_key         TYPE /bobf/t_frw_key,
        ls_key         TYPE /bobf/s_frw_key,
        ls_change_mode TYPE /bobf/s_confro_chg_mode,
        lv_rejected    TYPE boole_d,
        lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
        lo_message     TYPE REF TO /bobf/if_frw_message,
        lo_change_save TYPE REF TO /bobf/if_frw_change,
        ls_change_save TYPE /bobf/s_frw_change_save,
        lo_change      TYPE REF TO /bobf/cl_frw_change,
        lt_group       TYPE /bobf/t_frw_group,
        lt_validation  TYPE /bobf/t_frw_key,
        lt_failed_val  TYPE /bobf/t_frw_validations,
        lx_root        TYPE REF TO cx_root.


  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
  CLEAR: eo_message,
         ev_rejected.

  mv_no_determinations = abap_true.

  IF it_root_key IS INITIAL.
    lo_change_save = mo_change_save.
  ELSE.
    lo_change_save = /bobf/cl_frw_factory=>get_change( ).
    lo_change ?= lo_change_save.
    lo_change->trace_external_changes( abap_false ).
    TRY.
        IF mv_modifying_transaction = abap_true.
          mo_buffer->compare_states(
            EXPORTING
              iv_node_key      = mo_conf->ms_obj-root_node_key
              it_key           = it_root_key
              iv_state_current = /bobf/if_conf_c=>sc_state_current
              iv_state_before  = /bobf/if_conf_c=>sc_state_database
              iv_incl_subtree  = abap_true
              io_change        = lo_change_save ).
        ENDIF.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_changes(
           it_root_key = lt_root_key
           io_change   = lo_change_save ).
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    lo_change->trace_external_changes( abap_true ).

    ls_change_save-root_keys = it_root_key.
    SORT ls_change_save-root_keys BY key.
    DELETE ADJACENT DUPLICATES FROM ls_change_save-root_keys COMPARING key.
    ls_change_save-change    = lo_change_save.
    APPEND ls_change_save TO mt_change_save.
  ENDIF.

* ____________________________________________________________________ *
* check if there is really something to do
  CHECK lo_change_save IS BOUND.
  CHECK lo_change_save->has_changes( ) = abap_true.
  lo_change ?= lo_change_save.

* ____________________________________________________________________ *
* get_list of changed objects
  IF it_root_key IS INITIAL.
    TRY.
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
*   WORKAOUND for CSN 0120061532 0001550573 2008: Call GET_ROOT_KEYS of delegation to make sure internal caches are filled.
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.
  SORT lt_root_key BY key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* check delegated objects
  TRY.
      LOOP AT mt_delegation2 INTO lo_delegation.
        lo_delegation->check_before_save(
          EXPORTING
            it_root_key     = lt_root_key
          IMPORTING
            eo_message      = lo_message
            ev_rejected     = lv_rejected ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF lv_rejected = abap_true.
          ASSERT ID /bobf/frw_warning CONDITION 0 = 1.     "#EC BOOL_OK
          ev_rejected = abap_true.
        ENDIF.
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* check host object
  ls_change_mode-create = abap_true.
  ls_change_mode-update = abap_true.
  lo_change_save->get_changes(
    EXPORTING is_change_mode  = ls_change_mode
    IMPORTING et_changed_node = lt_node ).

  LOOP AT lt_node INTO ls_node.
    ls_key-key = ls_node-key.
    APPEND ls_key TO lt_key.

    AT END OF node.
      IF mo_conf->ms_last_node-node_key <> ls_node-node.
        mo_conf->get_node( iv_node_key = ls_node-node ).
      ENDIF.
      IF mo_conf->ms_last_node-node_type <> /bobf/if_conf_c=>sc_node_type_normal OR
         mo_conf->ms_last_node-transient = abap_true OR
         mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
        CLEAR lt_key.
        CONTINUE.
      ENDIF.

      ASSERT ID /bobf/frw CONDITION
         /bobf/cl_tool_assert=>is_key_subset_stack_set(
             it_key_set = lt_key ) = abap_true.

      check_action(
        EXPORTING
          iv_node_key         = ls_node-node
          iv_act_cat          = /bobf/if_conf_c=>sc_action_save
          iv_check_property   = abap_false
          iv_check_validation = abap_true
        IMPORTING
          eo_message          = lo_message
          et_failed_key       = lt_failed_key
        CHANGING
          ct_key              = lt_key  ).

      ASSERT ID /bobf/frw CONDITION
         /bobf/cl_tool_assert=>is_key_subset_stack_check(
             it_key_subset = lt_failed_key ) = abap_true.

      CLEAR lt_key.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_failed_key IS NOT INITIAL.
        ASSERT ID /bobf/frw_warning CONDITION 0 = 1.       "#EC BOOL_OK
        ev_rejected = abap_true.
      ENDIF.
    ENDAT.
  ENDLOOP.

* ____________________________________________________________________ *
* check consistency groups without status assignment
  get_relevant_groups(
    EXPORTING
      iv_processing_mode = /bobf/if_frw_c=>sc_mode_check_before_save
      iv_state_before    = /bobf/if_conf_c=>sc_state_database
      io_change          = lo_change_save
    IMPORTING
      et_group_no_status = lt_group
      et_validations     = lt_validation
      eo_message         = lo_message ).

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  IF lt_group IS NOT INITIAL.
    IF mo_conf->ms_obj-smart_validations = abap_false.
      " add check trigger, otherwise validations only triggered on check are not called
      add_trigger_condition( it_group   = lt_group
                             io_change  = lo_change_save ).
    ENDIF.

    do_validate(
      EXPORTING
        iv_last_state_db           = abap_true
        it_validation              = lt_validation
        iv_only_given_validations  = abap_true
        iv_consistency             = abap_false " set lifetime to state messages
        io_change                  = lo_change_save
        iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check_before_save
      IMPORTING
        eo_message                 = lo_message
        et_failed_val              = lt_failed_val ).

    add_messages(
      EXPORTING
        io_change  = lo_change
      CHANGING
        co_message = eo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_check ).

    IF lt_failed_val IS NOT INITIAL.
      ASSERT ID /bobf/frw_warning CONDITION 0 = 1.         "#EC BOOL_OK
      ev_rejected = abap_true.
    ENDIF.
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~check_consistency.

* consistency check

  DATA: lo_message                TYPE REF TO /bobf/if_frw_message,
        lo_delegation             TYPE REF TO /bobf/if_frw_delegation,
        ls_nodeconf               TYPE /bobf/s_confro_node,
        ls_group                  TYPE /bobf/s_confro_group,
        lt_delegated_nodes        TYPE /bobf/t_frw_node,
        lt_host_nodes             TYPE /bobf/t_frw_node,
        ls_node                   TYPE /bobf/s_frw_node,
        lt_key                    TYPE /bobf/t_frw_key,
        lt_validations            TYPE /bobf/t_frw_key,
        ls_key                    TYPE /bobf/s_frw_key,
        lo_change                 TYPE REF TO /bobf/cl_frw_change,
        lv_only_given_validations TYPE boole_d,
        lx_root                   TYPE REF TO cx_root,
        lt_auth_key               TYPE /bobf/t_frw_key,
        lo_auth_message_dummy     TYPE REF TO /bobf/if_frw_message,
        lo_auth_change            TYPE REF TO /bobf/if_frw_change.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

* ____________________________________________________________________ *
* check authorization (ignore IV_CHECK_SCOPE!)
  lt_auth_key = it_key.
  lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-check
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-check_consistency
                                  bo_service          = space
                                  node_key            = iv_node_key )
      iv_cleanse_keys  = abap_true
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_auth_key
      co_message       = lo_auth_message_dummy
  ).

* ____________________________________________________________________ *
* check for complete delegation
  IF mo_conf->ms_last_node-node_key = iv_node_key.
    ls_nodeconf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
       EXPORTING iv_node_key = iv_node_key
       IMPORTING es_node     = ls_nodeconf ).
  ENDIF.

  IF ls_nodeconf-delegation_class IS NOT INITIAL.
    TRY.
        lo_delegation = get_delegation( iv_node_key ).
        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        lo_delegation->check_consistency(
          EXPORTING
            iv_node_key    = iv_node_key
            it_key         = lt_auth_key
            iv_check_scope = iv_check_scope
          IMPORTING
            eo_message     = eo_message ).
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* determine objects to check
  CREATE OBJECT lo_change.
  CASE iv_check_scope.
    WHEN: /bobf/if_frw_c=>sc_scope_substructure.
      get_subnodes(
        EXPORTING
          iv_node_key                   = iv_node_key
          it_key                        = lt_auth_key
          iv_stop_at_delegation_subtree = abap_true
          iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_nodes
        IMPORTING
          eo_message                    = lo_message
        CHANGING
          ct_host_node                  = lt_host_nodes
          ct_delegation_root_node       = lt_delegated_nodes ).
      LOOP AT lt_host_nodes INTO ls_node.
        lo_change->add_change(
           iv_change_mode = /bobf/if_frw_c=>sc_modify_check
           iv_node_key    = ls_node-node
           iv_key         = ls_node-key ).
      ENDLOOP.

    WHEN: /bobf/if_frw_c=>sc_scope_local.
      lo_change->add_change(
         iv_change_mode = /bobf/if_frw_c=>sc_modify_check
         iv_node_key    = iv_node_key
         it_key         = lt_auth_key ).

    WHEN OTHERS.
*     unknown scope
      ASSERT ID /bobf/frw CONDITION 0 = 1.                 "#EC BOOL_OK

      ASSERT ID /bobf/frw_error CONDITION
         /bobf/cl_tool_assert=>access_stack_stack_check(
             it_access_stack = mt_access_stack ) = abap_true.

      RETURN.
  ENDCASE.

* ____________________________________________________________________ *
* call consistency check for delegated nodes within subtree
  TRY.
      LOOP AT lt_delegated_nodes INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.
        AT END OF node.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_node-node
            IMPORTING es_node     = ls_nodeconf ).

          lo_delegation = get_delegation( ls_node-node ).
          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          lo_delegation->check_consistency(
              EXPORTING
                iv_node_key    = ls_node-node
                it_key         = lt_key
                iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure
              IMPORTING
                eo_message     = lo_message ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          CLEAR lt_key.
        ENDAT.
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* call consistency check for own nodes
  IF iv_check_group IS NOT INITIAL.
    mo_conf->get_group(
      EXPORTING
        iv_group_key = iv_check_group
      IMPORTING
        es_group     = ls_group ).
    IF ls_group-val_keys IS BOUND.
      lt_validations = ls_group-val_keys->*.
    ENDIF.
    lv_only_given_validations = abap_true.
  ENDIF.

  do_validate(
    EXPORTING
      iv_check_group_key         = iv_check_group
      it_validation              = lt_validations
      iv_perform_check_delta     = abap_false
      iv_only_given_validations  = lv_only_given_validations
      io_change                  = lo_change
      iv_last_state_db           = abap_true
      iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check
    IMPORTING
      eo_message                 = lo_message
      et_failed_val              = DATA(lt_failed_val) ).

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  IF iv_fill_inconsistent_key = abap_true.
    TRY.
        evaluate_failed_validate_keys( EXPORTING
                                        iv_node_key         = iv_node_key
                                        it_key              = it_key
                                        it_failed_val       = lt_failed_val
                                       IMPORTING
                                        et_inconsistent_key = et_inconsistent_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.

* ____________________________________________________________________ *
* collect messages from validation message node
  add_messages(
    EXPORTING
      io_change  = lo_change
    CHANGING
      co_message = eo_message ).

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~compare.

  DATA lo_int_access TYPE REF TO /bobf/cl_frw_int_access.

  BREAK-POINT ID /bobf/frw.

  CLEAR eo_change.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  /bobf/cl_frw_int_access=>new_instance(
    EXPORTING
      io_bopf            =  me
      io_conf            =  mo_conf
      io_buffer          =  mo_buffer
      io_change          =  eo_change
    RECEIVING
      eo_internal_access = lo_int_access
  ).

  lo_int_access->set_context( iv_read_allowed = abap_true ).
  lo_int_access->set_last_state( iv_last_state = iv_last_state ).
  lo_int_access->set_current_state( iv_current_state = iv_current_state ).

*  DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

  lo_int_access->/bobf/if_frw_read~compare(
    EXPORTING
      iv_node_key        = iv_node_key
      it_key             = it_key
      iv_fill_attributes = iv_fill_attributes
      iv_scope           = iv_scope
    IMPORTING
       eo_change         = eo_change ).

*   /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

  lo_int_access->invalidate( ).

  ASSERT ID /bobf/frw_error CONDITION
   /bobf/cl_tool_assert=>access_stack_stack_check(
       it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~convert_altern_key.

  DATA: lv_state              TYPE /bobf/conf_state,
        lv_fill_target_key    TYPE boole_d,
        lo_message            TYPE REF TO /bobf/if_frw_message, "#EC NEEDED
        lt_auth_key           TYPE /bobf/t_frw_key,
        lt_auth_result        TYPE /bobf/t_frw_keyindex,
        lt_auth_failed_key    TYPE /bobf/t_frw_key,
        lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
        lt_auth_failed_altkey TYPE REF TO data,
        lo_auth_change        TYPE REF TO /bobf/if_frw_change,
        lo_auth_change_ak1    TYPE REF TO /bobf/if_frw_change,
        lo_auth_change_ak2    TYPE REF TO /bobf/if_frw_change.

  FIELD-SYMBOLS: <ls_auth_failed_key>    TYPE /bobf/s_frw_key,
                 <lt_auth_failed_altkey> TYPE INDEX TABLE,
                 <ls_failed_key>         TYPE any,
                 <ls_auth_failed_altkey> TYPE any,
                 <lt_key>                TYPE /bobf/t_frw_key.

  BREAK-POINT ID /bobf/frw.
  CLEAR: et_result, et_key.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  lv_fill_target_key = boolc( et_key IS REQUESTED ).
  lv_state = get_state_for_read( iv_before_image ).

  convert_altern_key(
    EXPORTING
      iv_node_key                = iv_node_key
      iv_altkey_key              = iv_altkey_key
      iv_target_altkey_key       = iv_target_altkey_key
      it_key                     = it_key
      iv_check_existence         = iv_check_existence
      iv_state                   = lv_state
      iv_invalidate_cache        = iv_invalidate_cache
      iv_fill_target_key         = lv_fill_target_key
      iv_buffer_sufficient_hint  = iv_buffer_sufficient_hint
    IMPORTING
      eo_message                 = lo_message
      eo_change                  = eo_change
      et_result                  = et_result
      et_key                     = et_key ).

  collect_messages(
    EXPORTING
      io_message = lo_message
    CHANGING
      co_message = eo_message
  ).

* ____________________________________________________________________
* check authorization as _after burner_
  IF mo_authority_handler->is_authority_check_expected( iv_node_key ) = abap_true.
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( EXPORTING iv_node_key = iv_node_key ).
    ENDIF.
    " authority checking for key->key/altkey (non-delegated) and key/altkey->key/altkey (delegated)
    " requests is missing. authority checking for altkey->altkey/key (non-delegated) requests was
    " already processed in a performant way in previous CONVERT_ALTERN_KEY call...
    IF iv_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key
      OR mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
      IF iv_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key.
        lt_auth_key = it_key.
      ELSEIF iv_target_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key.
        lt_auth_key = et_key.
      ELSE.
        " altkey -> altkey is requested: for auth check need to determine keys first
        convert_altern_key(
          EXPORTING
            iv_node_key               = iv_node_key
            iv_altkey_key             = iv_altkey_key
            iv_target_altkey_key      = /bobf/if_frw_c=>sc_alternative_key_key
            it_key                    = it_key
            iv_check_existence        = iv_check_existence
            iv_state                  = lv_state
            iv_invalidate_cache       = iv_invalidate_cache
            iv_buffer_sufficient_hint = iv_buffer_sufficient_hint
            iv_fill_target_key        = abap_true
          IMPORTING
            eo_message                = lo_message
            eo_change                 = lo_auth_change_ak1
            et_key               = lt_auth_key ).
        collect_messages(
          EXPORTING
            io_message = lo_message
          CHANGING
            co_message = eo_message
        ).

      ENDIF.
      lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
      mo_authority_handler->check_authority(
        EXPORTING
          io_change        = lo_auth_change
          is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                      activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-convert_altern_key
                                      bo_service          = space
                                      node_key            = iv_node_key )
          iv_cleanse_keys  = abap_false
          io_bopf          = me
          io_buffer        = mo_buffer
          iv_last_state    = /bobf/if_conf_c=>sc_state_database
          iv_current_state = /bobf/if_conf_c=>sc_state_current
        IMPORTING
          et_failed_key    = lt_auth_failed_key
        CHANGING
          ct_access_stack  = mt_access_stack
          ct_key           = lt_auth_key
          co_message       = lo_auth_message_dummy
      ).
      " update exporting tables for result and key
      IF lt_auth_failed_key IS NOT INITIAL.
        IF et_result IS REQUESTED.
          LOOP AT lt_auth_failed_key ASSIGNING <ls_auth_failed_key>.
            DELETE et_result WHERE key = <ls_auth_failed_key>-key. "#EC CI_SORTSEQ
          ENDLOOP.
        ENDIF.
        IF lv_fill_target_key = abap_true.
          IF iv_target_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key.
            IF lt_auth_failed_key IS NOT INITIAL.
              ASSIGN et_key TO <lt_key>.
              LOOP AT <lt_key> ASSIGNING FIELD-SYMBOL(<ls_key>).
                READ TABLE lt_auth_failed_key WITH TABLE KEY key = <ls_key>-key TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
                  CLEAR <ls_key>.
                ENDIF.
              ENDLOOP.
            ENDIF.
          ELSE.
            " for cleanup of ET_KEY re-conversion of failed keys -> altkeys is needed
            IF mo_conf->ms_last_altkey-altkey_key <> iv_target_altkey_key.
              mo_conf->get_altkey( iv_altkey_key = iv_target_altkey_key ).
            ENDIF.
            CREATE DATA lt_auth_failed_altkey TYPE TABLE OF (mo_conf->ms_last_altkey-data_type).
            ASSIGN lt_auth_failed_altkey->* TO <lt_auth_failed_altkey>.
            convert_altern_key(
              EXPORTING
                iv_node_key          = iv_node_key
                iv_altkey_key        = /bobf/if_frw_c=>sc_alternative_key_key
                iv_target_altkey_key = iv_target_altkey_key
                it_key               = lt_auth_failed_key
                iv_check_existence   = iv_check_existence
                iv_state             = lv_state
                iv_invalidate_cache  = iv_invalidate_cache
                iv_fill_target_key   = abap_true
              IMPORTING
                eo_message           = lo_message
                eo_change            = lo_auth_change_ak2
                et_key               = <lt_auth_failed_altkey> ).
            collect_messages(
              EXPORTING
                io_message = lo_message
              CHANGING
                co_message = eo_message
            ).

            SORT <lt_auth_failed_altkey> BY table_line.

            LOOP AT et_key ASSIGNING <ls_failed_key>.
              READ TABLE <lt_auth_failed_altkey> BINARY SEARCH WITH KEY table_line = <ls_failed_key> TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CLEAR <ls_failed_key>.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ENDIF.
      IF eo_change IS BOUND.
        eo_change->merge( lo_auth_change ).
      ELSE.
        eo_change = lo_auth_change.
      ENDIF.
      IF lo_auth_change_ak1 IS BOUND.
        eo_change->merge( lo_auth_change_ak1 ).
      ENDIF.
      IF lo_auth_change_ak2 IS BOUND.
        eo_change->merge( lo_auth_change_ak2 ).
      ENDIF.
    ENDIF.
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~create_sync_point.

  DATA:
    ls_sync_point TYPE ty_sync_point,
    lt_key        TYPE /bobf/t_frw_key,
    lt_node       TYPE /bobf/t_frw_node,
    lo_int_access TYPE REF TO /bobf/cl_frw_int_access,
*    lt_conf_node  TYPE /bobf/t_confro_node,
*    ls_conf_node  TYPE /bobf/s_confro_node,
    lx_root       TYPE REF TO cx_root.


* check if there is already a syncpoint with the same handle
  READ TABLE mt_sync_point TRANSPORTING NO FIELDS
    WITH KEY handle = iv_handle.                         "#EC CI_STDSEQ
  IF sy-subrc = 0.
    set_application_error( ).
  ENDIF.

  IF mv_modifying_transaction = abap_true.
    ADD 1 TO mv_sync_state_index.
    ADD 1 TO ls_sync_point-states_count.
    ls_sync_point-state = gc_sync_state+mv_sync_state_index(1).
    ls_sync_point-handle  = iv_handle.
    ls_sync_point-state_d = ls_sync_point-state.
    ls_sync_point-state_v = ls_sync_point-state.
*    ls_sync_point-state_f = ls_sync_point-state.
    IF mt_access_stack IS NOT INITIAL.
      READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
      IF lo_int_access->mv_process_immediately_allowed = abap_true.
        lo_int_access->end_modify( iv_process_immediately = abap_true ).
        ADD 1 TO mv_sync_state_index.
        ADD 1 TO ls_sync_point-states_count.
        ls_sync_point-state_d = gc_sync_state+mv_sync_state_index(1).
        ls_sync_point-state_v = ls_sync_point-state_d.
      ENDIF.
    ENDIF.
*   pending determinations or validations
    IF mo_change_fail_det IS NOT INITIAL.
      ls_sync_point-change_fail_det ?= /bobf/cl_frw_factory=>get_change( ).
      ls_sync_point-change_fail_det->merge( mo_change_fail_det ).
      IF ls_sync_point-state_d = ls_sync_point-state.
        ADD 1 TO mv_sync_state_index.
        ADD 1 TO ls_sync_point-states_count.
        IF mo_conf->ms_obj-last_det_state_not_relevant = abap_true.
          ls_sync_point-state_v = gc_sync_state+mv_sync_state_index(1).
        ELSE.
          ls_sync_point-state_d = gc_sync_state+mv_sync_state_index(1).
        ENDIF.
      ENDIF.
    ENDIF.
    IF mo_change_fail_val IS NOT INITIAL.
      ls_sync_point-change_fail_val ?= /bobf/cl_frw_factory=>get_change( ).
      ls_sync_point-change_fail_val->merge( mo_change_fail_val ).
      ADD 1 TO mv_sync_state_index.
      ADD 1 TO ls_sync_point-states_count.
      ls_sync_point-state_v = gc_sync_state+mv_sync_state_index(1).
    ENDIF.

    IF mo_conf->ms_obj-last_det_state_not_relevant = abap_true.
      ls_sync_point-state_d = ls_sync_point-state_v.
    ENDIF.
    IF mo_conf->ms_obj-last_val_state_not_relevant = abap_true.
      ls_sync_point-state_d = ls_sync_point-state.
      ls_sync_point-state_v = ls_sync_point-state.
    ENDIF.
    INSERT ls_sync_point INTO mt_sync_point INDEX 1.

    TRY.
        mo_buffer->get_root_keys(
          EXPORTING
            iv_changed_only = abap_false
          IMPORTING
            et_root_key     = lt_key ).

        map_to_node(
          EXPORTING
            iv_node_key = mo_conf->ms_obj-root_node_key
            it_key      = lt_key
          IMPORTING
            et_node     = lt_node ).

        mo_buffer->transfer_state(
            it_node         = lt_node
            iv_incl_subtree = abap_true
            iv_state_source = /bobf/if_conf_c=>sc_state_current
            iv_state_dest   = ls_sync_point-state ).

        IF ls_sync_point-state_v <> ls_sync_point-state.
          mo_buffer->transfer_state(
              it_node         = lt_node
              iv_incl_subtree = abap_true
              iv_state_source = /bobf/if_conf_c=>sc_state_last_validated
              iv_state_dest   = ls_sync_point-state_v ).
        ENDIF.

        IF ls_sync_point-state_d <> ls_sync_point-state_v.
          mo_buffer->transfer_state(
              it_node         = lt_node
              iv_incl_subtree = abap_true
              iv_state_source = /bobf/if_conf_c=>sc_state_last_determined
              iv_state_dest   = ls_sync_point-state_d ).
        ENDIF.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    ls_sync_point-handle  = iv_handle.
    ls_sync_point-state   = /bobf/if_conf_c=>sc_state_database.
    ls_sync_point-state_d = /bobf/if_conf_c=>sc_state_database.
    ls_sync_point-state_v = /bobf/if_conf_c=>sc_state_database.
*    ADD 1 TO mv_sync_state_index.
*    ADD 1 TO ls_sync_point-states_count.
*    ls_sync_point-state_f = gc_sync_state+mv_sync_state_index(1).
    INSERT ls_sync_point INTO mt_sync_point INDEX 1.
  ENDIF.

** create sync points for framework nodes
*  mo_conf->get_node_tab( IMPORTING et_node = lt_conf_node ).
*  LOOP AT lt_conf_node INTO ls_conf_node WHERE node_type = /bobf/if_conf_c=>sc_node_type_lock. "#EC CI_SORTSEQ
*    mo_buffer->get_keys(
*      EXPORTING
*        iv_node_key = ls_conf_node-node_key
*        iv_state    = /bobf/if_conf_c=>sc_state_current
*      IMPORTING
*        et_key      = lt_key ).
*
*    CHECK lt_key IS NOT INITIAL.
*
*    map_to_node(
*      EXPORTING
*        iv_node_key = ls_conf_node-node_key
*        it_key      = lt_key
*      IMPORTING
*        et_node     = lt_node ).
*
*    mo_buffer->transfer_state(
*        it_node         = lt_node
*        iv_state_source = /bobf/if_conf_c=>sc_state_current
*        iv_state_dest   = ls_sync_point-state_f ).
*  ENDLOOP.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~do_action.

  DATA: lo_change     TYPE REF TO /bobf/cl_frw_change,
        lo_change_if  TYPE REF TO /bobf/if_frw_change,
        lo_message    TYPE REF TO /bobf/if_frw_message,
        lo_int_access TYPE REF TO /bobf/cl_frw_int_access,
        lt_change     TYPE /bobf/t_frw_change.

  BREAK-POINT ID /bobf/frw.

  CLEAR: eo_change,
         eo_message,
         et_failed_key.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

* ____________________________________________________________________ *
* external change during save sequence
  ASSERT ID /bobf/frw CONDITION mo_change_save IS NOT BOUND.

* ____________________________________________________________________ *
* execute determinations and validations that failed before
  IF mo_change_fail_det IS BOUND OR
     mo_change_fail_val IS BOUND.
    eo_change = /bobf/cl_frw_factory=>get_change( ).
    do_detval( EXPORTING io_change                  = eo_change
                         iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_action
               IMPORTING eo_message                 = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF mo_change_fail_det  IS BOUND  OR
        mo_change_fail_val IS BOUND.
      et_failed_key = is_action-key.
      lo_change ?= eo_change.
      prepare_notifications_f_export( lo_change ).

      ASSERT ID /bobf/frw_error CONDITION
         /bobf/cl_tool_assert=>access_stack_stack_check(
             it_access_stack = mt_access_stack ) = abap_true.

      RETURN.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* execute action
  IF mt_access_stack IS INITIAL.
    do_action(
      EXPORTING
        is_action               = is_action
        iv_internal_call        = abap_false
      IMPORTING
        eo_message              = lo_message
        eo_change               = lo_change_if
        et_failed_key           = et_failed_key
        ev_static_action_failed = ev_static_action_failed
        et_data                 = et_data ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = is_action-key
            it_key_subset = et_failed_key ) = abap_true.

    IF eo_change IS BOUND.
      eo_change->merge( lo_change_if ).
    ELSE.
      eo_change = lo_change_if.
    ENDIF.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

  ELSE.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.

    lo_int_access->/bobf/if_frw_modify~do_action(
      EXPORTING
        iv_act_key              = is_action-act_key
        it_key                  = is_action-key
        is_parameters           = is_action-parameters
      IMPORTING
        eo_message              = lo_message
        et_failed_key           = et_failed_key
        eo_change               = lo_change_if
        ev_static_action_failed = ev_static_action_failed
        et_data                 = et_data ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = is_action-key
            it_key_subset = et_failed_key ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    "when no change object is returned, get an empty change object
    IF lo_change_if IS NOT BOUND.
      lo_change_if = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

    lo_change_if->get( IMPORTING et_change = lt_change ).
    lo_change ?= lo_int_access->mo_change.
    IF lt_change IS NOT INITIAL.
      lo_change->clear_external( lt_change ).
    ENDIF.

    IF eo_change IS BOUND.
      eo_change->merge( lo_change_if ).
    ELSE.
      eo_change = lo_change_if.
    ENDIF.

  ENDIF.

* ____________________________________________________________________ *
* add message from the consistency checks
  add_messages(
    EXPORTING
      io_change  = eo_change
    CHANGING
      co_message = eo_message ).

* ____________________________________________________________________ *
* handle changes
  IF eo_change IS BOUND.
    lo_change ?= eo_change.
    prepare_notifications_f_export( lo_change ).
    notify_association_changes_cu( lo_change ).
    notify_property_changes( eo_change ).
    lo_change->delete_duplicate_notifications( ).
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~do_cleanup.

  DATA:
    lt_root_key    TYPE        /bobf/t_frw_key,
    lt_tmp_key     TYPE        /bobf/t_frw_key,
    lt_root_key3   TYPE        /bobf/t_frw_key,
    ls_change_save TYPE        /bobf/s_frw_change_save,
    lo_change      TYPE REF TO /bobf/cl_frw_change,
    lo_change_save TYPE REF TO /bobf/if_frw_change,
    lo_message     TYPE REF TO /bobf/if_frw_message,
    lx_root        TYPE REF TO cx_root,
    lo_delegation  TYPE REF TO /bobf/if_frw_delegation.

  " breakpoints & assertions
  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

  " clear exporting parameter
  CLEAR eo_message.

  " delegate cleanup to dependent objects and get the ROOT keys of all instances contained in the buffer so far
  IF it_root_key IS INITIAL.
    TRY.
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
          lo_delegation->do_cleanup( it_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
  ENDIF.
  SORT lt_root_key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key.

  " get changes done during the current transaction
  IF lo_change_save IS NOT BOUND.
    lo_change_save = /bobf/cl_frw_factory=>get_change( ).
  ENDIF.
  lo_change ?= lo_change_save.
  lo_change->trace_external_changes( abap_false ).
  TRY.
      IF mv_modifying_transaction = abap_true.
        mo_buffer->compare_states( iv_node_key      = mo_conf->ms_obj-root_node_key
                                   it_key           = lt_root_key
                                   iv_state_current = /bobf/if_conf_c=>sc_state_current
                                   iv_state_before  = /bobf/if_conf_c=>sc_state_database
                                   iv_incl_subtree  = abap_true
                                   io_change        = lo_change_save ).
      ENDIF.
      LOOP AT mt_delegation2 INTO lo_delegation.
        lo_delegation->get_changes( it_root_key = lt_root_key
                                    io_change   = lo_change_save ).
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.
  lo_change->trace_external_changes( abap_true ).

  " perform determinations 'cleanup'
  do_determinations( EXPORTING iv_exectime     = /bobf/if_conf_c=>sc_time_cleanup
                               io_change       = lo_change_save
                               iv_cleanup_mode = iv_cleanup_mode
                     IMPORTING eo_message  = lo_message ).
  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  " allow the execution of determinations in the upcoming transaction
  mv_no_determinations = abap_false.

  " unlock all instances locked in the current transaction so far
  " (evaluate the BOPF lock buffer)
  IF it_root_key IS INITIAL.
    mo_lock_manager->unlock_all( IMPORTING eo_message    = lo_message ).
  ELSE.
    mo_lock_manager->unlock_all( EXPORTING it_root_key   = lt_root_key
                                 IMPORTING eo_message    = lo_message ).
  ENDIF.
  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  " cleanup buffer so all changes done so far in the transaction are lost
  TRY.
      IF it_root_key IS INITIAL.
        mo_buffer->do_cleanup( ).
      ELSE.
        mo_buffer->do_cleanup( it_root_key = lt_root_key ).
      ENDIF.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

  " clear framework caches and S&AM
  CLEAR:
    mo_change_save,
    mo_change_fail_det,
    mo_change_fail_val,
    mt_change_save.
  IF mo_sam IS BOUND.
    mo_sam->cleanup( ).
  ENDIF.
  " start the new transaction in readmode (non-modifying)
  IF mo_conf->ms_obj-objcat <> /bobf/if_conf_c=>sc_objcat_tsto.
    mv_modifying_transaction = abap_false.
  ENDIF.
  " consumers are expected to clear their property buffers, therefore this table can be cleared too
  CLEAR mt_node_properties_requested.
  mv_defaults_exists = abap_false.
  mo_authority_handler->cleanup( ).

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~do_save.

  DATA: lt_root_key    TYPE /bobf/t_frw_key,
        lt_tmp_key     TYPE /bobf/t_frw_key,
        lt_failed_node TYPE /bobf/t_frw_node,
        lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
        lx_root        TYPE REF TO cx_root,
        lo_message     TYPE REF TO /bobf/if_frw_message,
        lo_change_save TYPE REF TO /bobf/if_frw_change,
        lo_change      TYPE REF TO /bobf/cl_frw_change,
        ls_change_save TYPE /bobf/s_frw_change_save.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         ev_rejected.

  IF it_root_key IS INITIAL.
    lo_change_save = mo_change_save.
  ELSE.
    lt_root_key = it_root_key.
    SORT lt_root_key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.
    READ TABLE mt_change_save INTO ls_change_save
      WITH KEY root_keys = lt_root_key.
*   Dealing with a strange access pattern, try best effort to support this
    IF sy-subrc <> 0.
      lo_change_save = /bobf/cl_frw_factory=>get_change( ).
      lo_change ?= lo_change_save.
      lo_change->trace_external_changes( abap_false ).
      TRY.
          IF mv_modifying_transaction = abap_true.
            mo_buffer->compare_states(
             EXPORTING
               iv_node_key      = mo_conf->ms_obj-root_node_key
               it_key           = lt_root_key
               iv_state_current = /bobf/if_conf_c=>sc_state_current
               iv_state_before  = /bobf/if_conf_c=>sc_state_database
               iv_incl_subtree  = abap_true
               io_change        = lo_change_save ).
          ENDIF.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_changes(
             it_root_key = lt_root_key
             io_change   = lo_change_save ).
          ENDLOOP.
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      lo_change->trace_external_changes( abap_true ).
    ELSE.
      lo_change_save = ls_change_save-change.
    ENDIF.

    ASSERT ID /bobf/frw CONDITION lo_change_save IS BOUND.
    CLEAR lt_root_key.
  ENDIF.

* ____________________________________________________________________ *
* check if there is really something to do
  CHECK lo_change_save IS BOUND.

* ____________________________________________________________________ *
* check for fatal errors
  check_fatal_error( ).

* ____________________________________________________________________ *
* get_list of changed objects to save
  IF it_root_key IS INITIAL.
    TRY.
        "TEST TEST TEST TODO
        mo_buffer->get_root_keys( "EXPORTING iv_changed_only = boolc( gv_consider_all_keys_on_save = abap_false )
                                  IMPORTING et_root_key = lt_root_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
  ENDIF.

  TRY.
      " Internal incident https://support.wdf.sap.corp/sap/support/message/1770067339
      " if lt_root_key is initial, there can be such draft instances which have neither a before image nor a current image,
      " in this case, the durable lock manager needs to check whether there are such instances and if there are, those
      " enqueue contexts will be removed.
      IF lt_root_key IS INITIAL.
        IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft.
          /bobf/cl_lib_durable_lock_mngr=>during_save( io_configuration = mo_conf
                                                       io_buffer        = mo_buffer ).
        ENDIF.

        RETURN.
      ENDIF.
    CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

  SORT lt_root_key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* check for transient root node -> don't save
  IF mo_conf->get_root_node( )-transient = abap_true.
    ev_rejected = abap_false.
    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* perform determinations (at save)
  do_determinations(
    EXPORTING
      iv_exectime = /bobf/if_conf_c=>sc_time_at_save
      io_change   = lo_change_save
    IMPORTING
      eo_message  = eo_message
      et_failed   = lt_failed_node ).

  IF lt_failed_node IS NOT INITIAL.
    ASSERT ID /bobf/frw_warning CONDITION 0 = 1.           "#EC BOOL_OK
    ev_rejected = abap_true.
    RETURN.
  ENDIF.

* ____________________________________________________________________ *
* check for fatal errors
  check_fatal_error( ).

* ____________________________________________________________________ *
* save delegated objects
  TRY.
      LOOP AT mt_delegation2 INTO lo_delegation.
        lo_delegation->do_save(
          EXPORTING
            it_root_key = lt_root_key
          IMPORTING
            eo_message  = lo_message
            ev_rejected = ev_rejected ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF ev_rejected = abap_true.
          ASSERT ID /bobf/frw_warning CONDITION 0 = 1.     "#EC BOOL_OK
          RETURN.
        ENDIF.
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* save buffer
  TRY.
      mo_buffer->do_save(
      EXPORTING
        it_root_key           = lt_root_key
        iv_state_current      = /bobf/if_conf_c=>sc_state_current
        iv_state_before_image = /bobf/if_conf_c=>sc_state_database ).
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* check for fatal errors
  check_fatal_error( ).

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~finalize.

  DATA: lt_root_key    TYPE /bobf/t_frw_key,
        lt_tmp_key     TYPE /bobf/t_frw_key,
        lo_change_save TYPE REF TO /bobf/if_frw_change,
        lo_change      TYPE REF TO /bobf/cl_frw_change,
        lt_failed_node TYPE /bobf/t_frw_node,
        lt_group_2_way TYPE /bobf/t_frw_group,
        lt_group_3_way TYPE /bobf/t_frw_group,
        lt_validation  TYPE /bobf/t_frw_key,
        lt_failed_val  TYPE /bobf/t_frw_validations,
        lv_rejected    TYPE boole_d,
        lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
        lo_message     TYPE REF TO /bobf/if_frw_message,
        lx_root        TYPE REF TO cx_root.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         eo_change,
         ev_rejected.

* ____________________________________________________________________ *
* execute determinations and validations that failed before
  IF mo_change_fail_det IS BOUND OR mo_change_fail_val IS BOUND.
    lo_change_save = /bobf/cl_frw_factory=>get_change( ).
    do_detval( EXPORTING io_change                  = lo_change_save
                         iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_finalize
               IMPORTING eo_message                 = eo_message ).

    IF mo_change_fail_det  IS BOUND OR
        mo_change_fail_val IS BOUND.
      ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.           "#EC BOOL_OK
      ev_rejected = abap_true.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
      eo_change->merge( lo_change_save ).
      lo_change ?= eo_change.
      prepare_notifications_f_export( lo_change ).

*     prepare local change object for further use
      lo_change ?= lo_change_save.
      lo_change->clear_external( ).
      RETURN.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* get_list of changed objects
  IF it_root_key IS INITIAL.
    TRY.
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
*   WORKAOUND for CSN 0120061532 0001550573 2008: Call GET_ROOT_KEYS of delegation to make sure internal caches are filled.
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.

  SORT lt_root_key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key.

  IF lo_change_save IS NOT BOUND.
    lo_change_save = /bobf/cl_frw_factory=>get_change( ).
  ENDIF.
  lo_change ?= lo_change_save.

* ____________________________________________________________________ *
* get changes
  lo_change->trace_external_changes( abap_false ).
  TRY.
      IF mv_modifying_transaction = abap_true.
        mo_buffer->compare_states(
          EXPORTING
            iv_node_key      = mo_conf->ms_obj-root_node_key
            it_key           = lt_root_key
            iv_state_current = /bobf/if_conf_c=>sc_state_current
            iv_state_before  = /bobf/if_conf_c=>sc_state_database
            iv_incl_subtree  = abap_true
            io_change        = lo_change_save ).
      ENDIF.
      LOOP AT mt_delegation2 INTO lo_delegation.
        lo_delegation->get_changes(
          it_root_key = lt_root_key
          io_change   = lo_change_save ).
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.
  lo_change->trace_external_changes( abap_true ).

  IF lo_change_save->has_changes( ) = abap_true.

    IF NOT ( mo_conf->ms_obj-smart_validations = abap_true AND /bobf/cl_tra_transaction_mgr=>is_session_stateless( ) ).

*   determinations at finalize - before consistency check
      IF mo_conf->ms_obj-has_consistency_groups <> /bobf/if_frw_c=>sc_group_none.
        do_determinations(
          EXPORTING
            iv_exectime = /bobf/if_conf_c=>sc_time_before_save_check
            io_change   = lo_change_save
          IMPORTING
            eo_message  = lo_message
            et_failed   = lt_failed_node ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF lt_failed_node IS NOT INITIAL.
          ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.       "#EC BOOL_OK
          ev_rejected = abap_true.
        ENDIF.
      ENDIF.

*   Check for consistency groups
      get_relevant_groups(
       EXPORTING
         iv_processing_mode = /bobf/if_frw_c=>sc_mode_finalize
         iv_state_before    = /bobf/if_conf_c=>sc_state_database
         io_change          = lo_change_save
       IMPORTING
         et_group_2_way     = lt_group_2_way
         et_group_3_way     = lt_group_3_way
         et_validations     = lt_validation
         eo_message         = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      filter_consistency_groups(
        CHANGING
          ct_group = lt_group_3_way ).

      IF lt_group_2_way IS NOT INITIAL OR
         lt_group_3_way IS NOT INITIAL.

        INSERT LINES OF lt_group_2_way INTO TABLE lt_group_3_way.
        add_trigger_condition( it_group   = lt_group_3_way
                               io_change  = lo_change_save ).

        do_validate(
          EXPORTING
            iv_last_state_db           = abap_true
            io_change                  = lo_change_save
            it_validation              = lt_validation
            iv_only_given_validations  = abap_true
            iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_finalize
          IMPORTING
            eo_message                 = lo_message
            et_failed_val              = lt_failed_val ).

*     merge consistency message from message nodes
        add_messages( EXPORTING io_change  = lo_change
                      CHANGING  co_message = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        derive_consistency_status(
          EXPORTING
            it_failed_val = lt_failed_val
          IMPORTING
            eo_message    = lo_message
          CHANGING
            ct_group      = lt_group_3_way ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        set_consistency_status(
          EXPORTING
            it_group   = lt_group_3_way
            io_change  = lo_change_save
          IMPORTING
            eo_message = lo_message ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_check ).
      ENDIF.
    ENDIF.
    IF ev_rejected = abap_false.
* ____________________________________________________________________ *
*   finalize delegated objects - after consistency check
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->finalize(
              EXPORTING
                it_root_key = lt_root_key
                io_change   = lo_change_save
              IMPORTING
                eo_message  = lo_message
                ev_rejected = lv_rejected ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF lv_rejected = abap_true.
              ASSERT ID /bobf/frw_warning CONDITION 0 = 1. "#EC BOOL_OK
              ev_rejected = lv_rejected.
            ENDIF.
          ENDLOOP.

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

*____________________________________________________________________ *
*   finalize host object -> perform determinations (finalize)
      do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_before_save
          io_change   = lo_change_save
        IMPORTING
          eo_message  = lo_message
          et_failed   = lt_failed_node ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_failed_node IS NOT INITIAL.
        ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.         "#EC BOOL_OK
        ev_rejected = abap_true.
      ENDIF.

* ____________________________________________________________________ *
*   finalize delegated objects (again)
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys(
              EXPORTING io_read     = mo_delegation_read
              IMPORTING et_root_key = lt_root_key ).
            lo_delegation->finalize(
              EXPORTING
                it_root_key = lt_root_key
                io_change   = lo_change_save
              IMPORTING
                eo_message  = lo_message
                ev_rejected = lv_rejected ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF lv_rejected = abap_true.
              ASSERT ID /bobf/frw_warning CONDITION 0 = 1. "#EC BOOL_OK
              ev_rejected = lv_rejected.
            ENDIF.
          ENDLOOP.

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* create change object for external world
  eo_change = /bobf/cl_frw_factory=>get_change( ).
  eo_change->merge( lo_change_save ).

* handle changes
  lo_change ?= eo_change.
  notify_association_changes_cu( lo_change ).
  prepare_notifications_f_export( lo_change ).
  notify_property_changes( eo_change ).
  lo_change->delete_duplicate_notifications( ).

  IF it_root_key IS INITIAL.
* prepare local change object for further use
    lo_change ?= lo_change_save.
    lo_change->clear_external( ).
    lo_change->condense( ).
    mo_change_save = lo_change_save.
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

ENDMETHOD.


  method /BOBF/IF_FRW_SERVICE_LAYER~GET_AUTH_PROFILE_READER.
    ro_auth_profile_reader = mo_authority_handler->get_auth_profile_reader(
      EXPORTING
        iv_bo_key   = iv_bo_key
        iv_node_key = iv_node_key ).
  endmethod.


METHOD /bobf/if_frw_service_layer~get_root_key.

  BREAK-POINT ID /bobf/frw.

  CLEAR: et_key_link,
         et_failed_key.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  IF it_key IS INITIAL.
    RETURN.
  ENDIF.

  get_root_key(
    EXPORTING
      iv_node_key         = iv_node_key
      it_key              = it_key
      iv_before_image     = iv_before_image
    IMPORTING
      et_key_link         = et_key_link
      et_failed_key       = et_failed_key
      et_target_key       = et_target_key ).

  ASSERT ID /bobf/frw_error CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = it_key
          it_key_subset = et_failed_key ) = abap_true.
  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>is_key_link_matching(
         it_key_link = et_key_link
         it_key      = it_key ) = abap_true.
  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~modify.

  DATA: lo_change              TYPE REF TO /bobf/cl_frw_change,
        lo_int_access          TYPE REF TO /bobf/cl_frw_int_access,
        lt_change              TYPE /bobf/t_frw_change,
        lv_process_immediately TYPE boole_d.


  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR eo_message.

  CHECK it_modification IS NOT INITIAL.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

* ____________________________________________________________________ *
* external change during save sequence
  ASSERT ID /bobf/frw CONDITION mo_change_save IS NOT BOUND.

* ____________________________________________________________________ *
* perform modifications
  IF mt_access_stack IS INITIAL.
    do_modify(
      EXPORTING
        it_modification   = it_modification
      IMPORTING
        eo_message        = eo_message
        eo_change         = eo_change ).

  ELSE.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    lo_int_access->end_modify( ).
    lo_int_access->/bobf/if_frw_modify~do_modify( it_modification = it_modification ).
    lv_process_immediately = abap_false.
    IF lo_int_access->mv_process_immediately_allowed = abap_true.
      IF mo_conf->ms_last_action-act_key <> lo_int_access->ms_action-act_key.
        mo_conf->get_act( iv_act_key = lo_int_access->ms_action-act_key ).
      ENDIF.
      IF mo_conf->ms_last_action-act_cardinality = /bobf/if_conf_c=>sc_act_card_static.
        lv_process_immediately = abap_true.
      ENDIF.
    ENDIF.

    lo_int_access->end_modify(
        EXPORTING
          iv_process_immediately = lv_process_immediately
        IMPORTING
          eo_change              = eo_change ).
    IF eo_change IS BOUND.
      eo_change->get( IMPORTING et_change = lt_change ).
      IF lt_change IS NOT INITIAL.
        lo_change ?= lo_int_access->mo_change.
        lo_change->clear_external( lt_change ).
      ENDIF.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* add message from the consistency checks
  add_messages(
    EXPORTING
      io_change  = eo_change
    CHANGING
      co_message = eo_message ).

* ____________________________________________________________________ *
* add property changes and association changes
  IF eo_change IS BOUND.
    lo_change ?= eo_change.
    prepare_notifications_f_export( lo_change ).
    notify_association_changes_cu( lo_change ).
    notify_property_changes( eo_change ).
    lo_change->delete_duplicate_notifications( ).
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~on_business_object_changed.

  DATA:
    ls_actconf    TYPE /bobf/s_confro_act_list,
    ls_action     TYPE /bobf/s_frw_action,
    lt_failed_key TYPE /bobf/t_frw_key,
    lo_change     TYPE REF TO /bobf/cl_frw_change.


  CLEAR:
    eo_message,
    eo_change.

* ____________________________________________________________________ *
* find action for event handling
  mo_conf->get_act(
    EXPORTING
      iv_node_key = iv_node_key
      iv_act_cat  = /bobf/if_conf_c=>sc_action_handle_bo_events
    IMPORTING
      es_action = ls_actconf ).
  IF ls_actconf IS INITIAL.
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.             "#EC BOOL_OK
    RETURN.
  ENDIF.

  ls_action-act_key    = ls_actconf-act_key.
  ls_action-parameters = is_bo_changes.

  /bobf/if_frw_service_layer~do_action(
    EXPORTING
      is_action     = ls_action
    IMPORTING
      eo_change     = eo_change
      eo_message    = eo_message
      et_failed_key = lt_failed_key ).

  IF lt_failed_key IS NOT INITIAL.
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.             "#EC BOOL_OK
    set_application_error( ).
  ENDIF.

*  ____________________________________________________________________ *
*  handle changes
  IF eo_change IS BOUND.
    lo_change ?= eo_change.
    prepare_notifications_f_export( lo_change ).
    notify_association_changes_cu( eo_change ).
    notify_property_changes( eo_change ).
    lo_change->delete_duplicate_notifications( ).
  ENDIF.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~on_numbers_adjusted.

  DATA: ls_actconf       TYPE /bobf/s_confro_act_list,
        ls_action        TYPE /bobf/s_frw_action,
        lt_root_key      TYPE /bobf/t_frw_key,
        lt_tmp_key       TYPE /bobf/t_frw_key,
        lt_failed_key    TYPE /bobf/t_frw_key,
        lo_delegation    TYPE REF TO /bobf/if_frw_delegation,
        lo_change        TYPE REF TO /bobf/cl_frw_change,
        lx_root          TYPE REF TO cx_root.

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

* ____________________________________________________________________ *
* get_list of changed objects to adopt foreign numbers
  IF it_root_key IS INITIAL.
    TRY.
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_root_keys(
            EXPORTING io_read     = mo_delegation_read
            IMPORTING et_root_key = lt_tmp_key ).
          APPEND LINES OF lt_tmp_key TO lt_root_key.
        ENDLOOP.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ELSE.
    lt_root_key = it_root_key.
  ENDIF.

  CHECK lt_root_key IS NOT INITIAL.
  SORT lt_root_key BY key.
  DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* adopt foreign numbers
  mo_conf->get_act(
    EXPORTING
      iv_node_key = mo_conf->ms_obj-root_node_key
      iv_act_cat  = /bobf/if_conf_c=>sc_action_adopt_numbers
    IMPORTING
      es_action = ls_actconf ).
  IF ls_actconf IS NOT INITIAL.
    ls_action-act_key = ls_actconf-act_key.
    ls_action-key     = lt_root_key.

    IF is_param IS SUPPLIED.
      " use the IS_PARAM parameter (filled by the Service Manager)
      ls_action-parameters = is_param.
    ELSE.
      " use the IT_ADJUSTED_NUMBERS parameter
      GET REFERENCE OF it_adjusted_numbers INTO ls_action-parameters.
    ENDIF.

    do_action(
      EXPORTING
        is_action        = ls_action
        iv_with_detval   = abap_false
        iv_internal_call = abap_true
      IMPORTING
        eo_message       = eo_message
        eo_change        = eo_change
        et_failed_key    = lt_failed_key ).

    IF lt_failed_key IS NOT INITIAL.
      ASSERT ID /bobf/frw_error CONDITION 0 = 1.           "#EC BOOL_OK
      set_application_error( ).
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* adopt foreign numbers for delegated objects
  TRY.
      LOOP AT mt_delegation2 INTO lo_delegation.
        lo_delegation->on_numbers_adjusted(
          EXPORTING
            it_root_key         = lt_root_key
            it_adjusted_numbers = it_adjusted_numbers ).
      ENDLOOP.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* handle changes
  IF eo_change IS BOUND.
    lo_change ?= eo_change.
    prepare_notifications_f_export( lo_change ).
    notify_association_changes_cu( eo_change ).
    notify_property_changes( eo_change ).
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~query.

  DATA: ls_query            TYPE        /bobf/s_confro_query,
        ls_query_class      TYPE        ty_query,
        lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
        ls_context          TYPE        /bobf/s_frw_ctx_query,
        lv_content_cat      TYPE        string,
        lv_class            TYPE        seoclsname,
        lv_content_name     TYPE        /bobf/obm_name,
        lx_frw              TYPE REF TO /bobf/cx_frw_core,
        lx_root             TYPE REF TO cx_root,
        lv_application_info TYPE        string,
        lo_change           TYPE REF TO /bobf/if_frw_change.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         es_query_info,
         et_key,
         et_data.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  IF mt_access_stack IS INITIAL.
    mo_conf->get_query(
      EXPORTING iv_query_key = iv_query_key
      IMPORTING es_query     = ls_query ).

    TRY.
        IF ls_query-query_class IS INITIAL.
*         ask buffer
          TRY.
              mo_buffer->query(
                EXPORTING
                  iv_node_key              = ls_query-node_key
                  iv_query_key             = iv_query_key
                  it_filter_key            = it_filter_key
                  it_selection_parameters  = it_selection_parameters
                  io_query_authorities     = io_query_authorities
                  is_query_options         = is_query_options
                IMPORTING
                  et_key                  = et_key
                  es_query_info           = es_query_info ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

        ELSE.
*         call query implementation
          ls_context-bo_key                = mo_conf->ms_obj-bo_key.
          ls_context-root_node_key         = mo_conf->ms_obj-root_node_key.
          ls_context-node_key              = ls_query-node_key.
          ls_context-query_key             = iv_query_key.

*         get query class
          READ TABLE mt_query
             WITH TABLE KEY query_key = ls_query-query_key
             INTO ls_query_class.
          IF sy-subrc <> 0.
            ls_query_class-query_key = ls_query-query_key.
            CREATE OBJECT ls_query_class-class TYPE (ls_query-query_class).
            INSERT ls_query_class INTO TABLE mt_query.
          ENDIF.

*         get internal access class
          lo_change = /bobf/cl_frw_factory=>get_change( ).

          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
              io_change          = lo_change
              iv_class_name      = /bobf/cl_frw_int_access_trans=>gc_class_name
            RECEIVING
              eo_internal_access = lo_int_access
          ).

          lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).
          lo_int_access->set_context(
            is_query          = ls_context
            iv_query_allowed  = abap_true
            iv_read_allowed   = abap_true
            iv_modify_allowed = abap_true ).

          lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_read_only ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.

          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          ls_query_class-class->query(
            EXPORTING
              is_ctx                  = ls_context
              it_filter_key           = it_filter_key
              it_selection_parameters = it_selection_parameters
              io_query_authorities    = io_query_authorities
              is_query_options        = is_query_options
              io_query                = lo_int_access
              io_read                 = lo_int_access
              io_modify               = lo_int_access
              iv_fill_data            = iv_fill_data
              it_requested_attributes = it_requested_attributes
            IMPORTING
              et_key                  = et_key
              eo_message              = eo_message
              es_query_info           = es_query_info
              et_data                 = et_data ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

*         check for undone modifications and flush
          IF lo_int_access->mt_modification IS NOT INITIAL.
            lo_int_access->end_modify( ).
          ENDIF.
          collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                            CHANGING  co_message = eo_message ).
          lo_int_access->invalidate( ).

          DELETE mt_access_stack INDEX 1.
        ENDIF.

      CATCH cx_sy_dyn_call_error INTO lx_root.
        lv_content_name = get_content_description(
          iv_query = abap_true
          iv_key   = iv_query_key ).
        lv_content_cat = TEXT-005.
        lv_class = ls_query-query_class.
        lcl_error_text_provider=>get_text_impl_class_error(
          EXPORTING
            iv_content_cat      = /bobf/if_conf_c=>sc_content_qry
            iv_content_key      = ls_context-query_key
            iv_node_key         = ls_context-node_key
            iv_content_class    = lv_class
            iv_content_name     = lv_content_name
            iv_method_name      = 'QUERY'
            io_configuration    = mo_conf
          RECEIVING
            rv_application_info = lv_application_info
        ).
        CREATE OBJECT lx_frw
          EXPORTING
            textid                     = /bobf/cx_frw_core=>sc_no_instance
            previous                   = lx_root
            mv_method_name             = 'QUERY'
            mv_content_name            = lv_content_name
            mv_content_cat             = lv_content_cat
            mv_application_information = lv_application_info.
        set_configuration_error( lx_frw ).

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        lv_content_name = get_content_description(
          iv_query = abap_true
          iv_key   = iv_query_key ).
        lv_content_cat = TEXT-005.
        CREATE OBJECT lx_frw
          EXPORTING
            textid          = /bobf/cx_frw_core=>sc_content_exception
            previous        = lx_root
            mv_method_name  = 'QUERY'
            mv_content_name = lv_content_name
            mv_content_cat  = lv_content_cat.
        set_application_error( lx_frw ).
    ENDTRY.


  ELSE.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    ls_context-bo_key                = mo_conf->ms_obj-bo_key.
    ls_context-root_node_key         = mo_conf->ms_obj-root_node_key.
    ls_context-node_key              = ls_query-node_key.
    ls_context-query_key             = iv_query_key.

    TRY.
        lo_int_access->/bobf/if_frw_query~query(
          EXPORTING
            is_ctx                   = ls_context
            it_filter_key            = it_filter_key
            it_selection_parameters  = it_selection_parameters
            io_query_authorities     = io_query_authorities
            is_query_options         = is_query_options
            io_query                 = lo_int_access
            io_read                  = lo_int_access
            io_modify                = lo_int_access
            iv_fill_data             = iv_fill_data
            it_requested_attributes  = it_requested_attributes
          IMPORTING
            eo_message               = eo_message
            et_key                   = et_key
            es_query_info            = es_query_info
            et_data                  = et_data ).

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        lv_content_name = get_content_description(
          iv_query = abap_true
          iv_key   = iv_query_key ).
        lv_content_cat = TEXT-005.
        CREATE OBJECT lx_frw
          EXPORTING
            textid          = /bobf/cx_frw_core=>sc_content_exception
            previous        = lx_root
            mv_method_name  = 'QUERY'
            mv_content_name = lv_content_name
            mv_content_cat  = lv_content_cat.
        set_application_error( lx_frw ).
    ENDTRY.
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

  ASSERT ID /bobf/frw_error CONDITION
     is_query_options-maximum_rows <= 0 OR
     lines( et_key ) <= is_query_options-maximum_rows.

ENDMETHOD.


method /BOBF/IF_FRW_SERVICE_LAYER~RELEASE_SYNC_POINT.

  DATA:
    ls_sync_point TYPE ty_sync_point,
    lt_key        TYPE /BOBF/T_FRW_KEY,
    lt_node       TYPE /BOBF/T_FRW_NODE,
*    lt_conf_node  TYPE /bobf/t_confro_node,
*    ls_conf_node  TYPE /bobf/s_confro_node,
    lx_root       TYPE REF TO cx_root.


  READ TABLE mt_sync_point INTO ls_sync_point INDEX 1.
  IF sy-subrc = 0.
*   check if the syncpoints are released in the right order
    IF ls_sync_point-handle <> iv_handle.
      set_application_error( ).
    ENDIF.

*   remove created state if not database state
    IF ls_sync_point-state <> /BOBF/IF_CONF_C=>SC_STATE_DATABASE.
      TRY.
          mo_buffer->get_root_keys(
            EXPORTING
              iv_changed_only = abap_false
            IMPORTING
              et_root_key     = lt_key ).

          map_to_node(
            EXPORTING
              iv_node_key = mo_conf->ms_obj-root_node_key
              it_key      = lt_key
            IMPORTING
              et_node     = lt_node ).

          mo_buffer->delete_state(
              it_node         = lt_node
              iv_incl_subtree = abap_true
              iv_state        = ls_sync_point-state ).

          IF ls_sync_point-state_d IS NOT INITIAL AND ls_sync_point-state_d <> ls_sync_point-state.
            mo_buffer->delete_state(
                it_node         = lt_node
                iv_incl_subtree = abap_true
                iv_state        = ls_sync_point-state_d ).
          ENDIF.

          IF ls_sync_point-state_v IS NOT INITIAL AND ls_sync_point-state_v <> ls_sync_point-state_d.
            mo_buffer->delete_state(
                it_node         = lt_node
                iv_incl_subtree = abap_true
                iv_state        = ls_sync_point-state_v ).
          ENDIF.
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

    DELETE mt_sync_point INDEX 1.

*   reset sync state index
    mv_sync_state_index = mv_sync_state_index - ls_sync_point-states_count.
  ELSE.
*   nothing to do (assumption is that BO has been touched only after sync point creation)
    ASSERT ID /BOBF/FRW_WARNING CONDITION 0 = 1. "#EC BOOL_OK
  ENDIF.

** release sync points for framework nodes
*  mo_conf->get_node_tab( IMPORTING et_node = lt_conf_node ).
*  LOOP AT lt_conf_node INTO ls_conf_node WHERE node_type = /bobf/if_conf_c=>sc_node_type_lock. "#EC CI_SORTSEQ
*    mo_buffer->get_keys(
*      EXPORTING
*        iv_node_key = ls_conf_node-node_key
*        iv_state    = ls_sync_point-state_f
*      IMPORTING
*        et_key      = lt_key ).
*
*    CHECK lt_key IS NOT INITIAL.
*
*    map_to_node(
*      EXPORTING
*        iv_node_key = ls_conf_node-node_key
*        it_key      = lt_key
*      IMPORTING
*        et_node     = lt_node ).
*
*    mo_buffer->delete_state(
*        it_node         = lt_node
*        iv_state        = ls_sync_point-state_f ).
*  ENDLOOP.

endmethod.


METHOD /bobf/if_frw_service_layer~retrieve.

  DATA: lv_state               TYPE /bobf/conf_state,
        lo_change              TYPE REF TO /bobf/cl_frw_change,
        lo_auth_message_dummy  TYPE REF TO /bobf/if_frw_message,
        lo_auth_change         TYPE REF TO /bobf/if_frw_change,
        lt_failed_key          TYPE /bobf/t_frw_key,
        lt_key                 TYPE /bobf/t_frw_key.

  BREAK-POINT ID /bobf/frw.

  CLEAR: eo_message,
         et_failed_key,
         et_data.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  lt_key = it_key.
  lv_state = get_state_for_read( iv_before_image ).

  IF iv_fill_data = abap_true.
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( iv_node_key ).
    ENDIF.
    type_check( iv_expected_line_type = mo_conf->ms_last_node-data_type
                iv_service_name       = 'Retrieve'
                iv_parameter_name     = 'ET_DATA'
                it_data               = et_data ) ##no_text.
  ENDIF.

* ____________________________________________________________________ *
* check authorization
  lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve
                                  bo_service          = space
                                  node_key            = iv_node_key )
      iv_cleanse_keys  = abap_true
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    IMPORTING
      et_failed_key    = et_failed_key
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_key
      co_message       = lo_auth_message_dummy
  ).

* ____________________________________________________________________ *
* retrieve data
  retrieve(
    EXPORTING
      iv_node_key             = iv_node_key
      it_key                  = lt_key
      iv_state                = lv_state
      iv_invalidate_cache     = iv_invalidate_cache
      iv_fill_data            = iv_fill_data
      iv_edit_mode            = iv_edit_mode
      it_requested_attributes = it_requested_attributes
    IMPORTING
      eo_message              = eo_message
      eo_change               = eo_change
      et_data                 = et_data
      et_failed_key           = lt_failed_key ).

  INSERT LINES OF lt_failed_key INTO TABLE et_failed_key.

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = lt_key
          it_key_subset = et_failed_key ) = abap_true.

  IF eo_change IS BOUND.
    eo_change->merge( lo_auth_change ).
  ELSE.
    eo_change = lo_auth_change.
  ENDIF.
  lo_change ?= eo_change.
  prepare_notifications_f_export( lo_change ).
  notify_property_changes( eo_change ).

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~retrieve_by_association.

  DATA: lv_state               TYPE /bobf/conf_state,
        ls_assoc               TYPE /bobf/s_confro_assoc,
        lo_property            TYPE REF TO /bobf/if_frw_property,
        lt_property            TYPE /bobf/t_frw_property_k_sorted,
        lt_key                 TYPE /bobf/t_frw_key,
        lt_failed_key          TYPE /bobf/t_frw_key,
        lt_key_check_exist     TYPE /bobf/t_frw_key,
        ls_key                 TYPE /bobf/s_frw_key,
        lv_check_services      TYPE /bobf/conf_check_services,
        lo_message             TYPE REF TO /bobf/if_frw_message,
        lo_change              TYPE REF TO /bobf/cl_frw_change,
        lv_fill_failed_key     TYPE boole_d,
        lt_auth_failed_src_key TYPE /bobf/t_frw_key,
        lt_auth_failed_trg_key TYPE /bobf/t_frw_key,
        lo_auth_message_dummy  TYPE REF TO /bobf/if_frw_message,
        lo_auth_change         TYPE REF TO /bobf/if_frw_change,
        ls_key_link            TYPE /bobf/s_frw_key_link,
        ls_failed_key          TYPE /bobf/s_frw_key.

  FIELD-SYMBOLS: <ls_data> TYPE any,
                 <lv_key>  TYPE /bobf/conf_key.

  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         et_key_link,
         et_failed_key,
         et_data.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  lt_key = it_key.
  lv_state = get_state_for_read( iv_before_image ).

* check association
  IF mo_conf->ms_last_assoc-assoc_key = iv_association.
    ls_assoc = mo_conf->ms_last_assoc.
  ELSE.
    mo_conf->get_assoc(
      EXPORTING iv_assoc_key = iv_association
      IMPORTING es_assoc     = ls_assoc ).
  ENDIF.

  IF ls_assoc IS INITIAL.
*   unknown association
    set_application_error( ).
  ENDIF.

  IF iv_fill_data = abap_true.
    DATA lv_target_node_data_type TYPE string.
    IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_xbo.
      " xBO association...
      TRY.
        DATA lo_ref_bo_conf TYPE REF TO /bobf/if_frw_configuration.
        lo_ref_bo_conf = /bobf/cl_frw_factory=>get_configuration( iv_bo_key = ls_assoc-target_node->ref_bo_key ).
        DATA ls_ref_node_conf TYPE /bobf/s_confro_node.
        lo_ref_bo_conf->get_node( EXPORTING iv_node_key = ls_assoc-target_node->ref_node_key
                                  IMPORTING es_node     = ls_ref_node_conf ).
        CATCH /bobf/cx_frw.
          " ignore...
      ENDTRY.
      lv_target_node_data_type = ls_ref_node_conf-data_type.
    ELSE.
      " inner BO association...
      lv_target_node_data_type = ls_assoc-target_node->data_type.
    ENDIF.
    type_check( iv_expected_line_type = lv_target_node_data_type
                iv_service_name       = 'RetrieveByAssociation'
                iv_parameter_name     = 'ET_DATA'
                it_data               = et_data ) ##no_text.
  ENDIF.
  lv_fill_failed_key = iv_fill_failed_key.
  IF et_failed_key IS NOT REQUESTED.
    lv_fill_failed_key = abap_false.
  ENDIF.

* ____________________________________________________________________ *
* check association properties
  IF ( mo_conf->ms_obj-chk_serv_assoc = /bobf/if_conf_c=>sc_check_services_stat OR
       mo_conf->ms_obj-chk_serv_assoc = /bobf/if_conf_c=>sc_check_services_stat_dyn ) AND
     ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent AND
     ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_root.

    lv_check_services = mo_conf->ms_obj-chk_serv_assoc.
*   Use only static properties when working on before image as properties relate to current image by definition
    IF iv_before_image = abap_true.
      lv_check_services = /bobf/if_conf_c=>sc_check_services_stat.
    ENDIF.

    /bobf/if_frw_service_layer~retrieve_property(
      EXPORTING
        iv_node_key                = iv_node_key
        it_key                     = lt_key
        iv_check_services          = lv_check_services
        iv_assoc_property          = abap_true
      IMPORTING
        eo_property                = lo_property
        eo_message                 = eo_message ).

    IF lo_property IS BOUND.
      lo_property->get_property( IMPORTING et_property_sorted = lt_property ).

      LOOP AT lt_key INTO ls_key.
        READ TABLE lt_property WITH KEY
            parent_key    = ls_key-key
            content_cat   = /bobf/if_conf_c=>sc_content_ass
            content_key   = iv_association
            property_name = /bobf/if_conf_c=>sc_property_name_enabled
            value         = abap_false
            TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          DELETE lt_key.
          IF lv_fill_failed_key = abap_true.
            INSERT ls_key INTO TABLE lt_key_check_exist.
          ENDIF.
        ENDIF.
      ENDLOOP.
      IF lt_key_check_exist IS NOT INITIAL.
        retrieve(
          EXPORTING
            iv_node_key             = iv_node_key
            it_key                  = lt_key_check_exist
            iv_state                = lv_state
            iv_fill_data            = abap_false
          IMPORTING
            et_failed_key           = et_failed_key ).
      ENDIF.
    ENDIF.

  ENDIF.

* ____________________________________________________________________ *
* check authorization on source node
* (remark: this is ignored in standard library implementation)
  lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-rba_source_node
                                  bo_service          = space
                                  node_key            = ls_assoc-source_node_key )
      iv_cleanse_keys  = abap_true
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    IMPORTING
      et_failed_key    = lt_auth_failed_src_key
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_key
      co_message       = lo_auth_message_dummy
  ).
  IF lv_fill_failed_key = abap_true.
    INSERT LINES OF lt_auth_failed_src_key INTO TABLE et_failed_key.
  ENDIF.

* ____________________________________________________________________ *
* retrieve data
  retrieve_by_association(
   EXPORTING
     iv_node_key             = iv_node_key
     it_key                  = lt_key
     iv_association          = iv_association
     is_parameters           = is_parameters
     it_filtered_attributes  = it_filtered_attributes
     iv_state                = lv_state
     iv_before_image         = iv_before_image
     iv_invalidate_cache     = iv_invalidate_cache
     iv_edit_mode            = iv_edit_mode
     it_requested_attributes = it_requested_attributes
     iv_fill_data            = iv_fill_data
     iv_fill_failed_key      = lv_fill_failed_key
   IMPORTING
     eo_message              = lo_message
     eo_change               = eo_change
     et_data                 = et_data
     et_key_link             = et_key_link
     et_target_key           = et_target_key
     et_failed_key           = lt_failed_key ).

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = lt_key
          it_key_subset = lt_failed_key ) = abap_true.
  ASSERT ID /bobf/frw CONDITION
     /bobf/cl_tool_assert=>is_key_link_matching(
         it_key_link = et_key_link
         it_key      = lt_key ) = abap_true.

  INSERT LINES OF lt_failed_key INTO TABLE et_failed_key.

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

* ____________________________________________________________________ *
* check authorization on target node
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-rba_target_node
                                  bo_service          = space
                                  node_key            = ls_assoc-target_node_key )
      iv_cleanse_keys  = abap_false
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    IMPORTING
      et_failed_key    = lt_auth_failed_trg_key
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = et_target_key
      co_message       = lo_auth_message_dummy
  ).
  " update exporting tables for data, key link, target keys and failed keys
  IF lt_auth_failed_trg_key IS NOT INITIAL.
    LOOP AT lt_auth_failed_trg_key INTO ls_key.
      LOOP AT et_key_link INTO ls_key_link USING KEY target_key WHERE target_key = ls_key-key.
        DELETE et_key_link USING KEY loop_key.
        IF lv_fill_failed_key = abap_true.
          ls_failed_key-key = ls_key_link-source_key.
          APPEND ls_failed_key TO et_failed_key.
        ENDIF.
      ENDLOOP.
      DELETE et_target_key USING KEY key_sort WHERE key = ls_key-key.
      IF iv_fill_data = abap_true.
        LOOP AT et_data ASSIGNING <ls_data>.
          ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_key OF STRUCTURE <ls_data> TO <lv_key>.
          IF sy-subrc = 0 AND <lv_key> = ls_key-key.
            DELETE et_data.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
    IF lv_fill_failed_key = abap_true.
      SORT et_failed_key.
      DELETE ADJACENT DUPLICATES FROM et_failed_key.
    ENDIF.
  ENDIF.

  IF eo_change IS BOUND.
    eo_change->merge( lo_auth_change ).
  ELSE.
    eo_change = lo_auth_change.
  ENDIF.
  lo_change ?= eo_change.
  prepare_notifications_f_export( lo_change ).
  notify_property_changes( eo_change ).

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.                    "retrieve_by_association


METHOD /bobf/if_frw_service_layer~retrieve_code_value_set.

  DATA: ls_vset               TYPE /bobf/s_confro_value_set,
        ls_node               TYPE /bobf/s_confro_node,
        ls_act                TYPE /bobf/s_confro_act_list,
        ls_assoc              TYPE /bobf/s_confro_assoc,
        ls_query              TYPE /bobf/s_confro_query,
        ls_vset_class         TYPE ty_value_set_code,
        lv_content_cat        TYPE string,
        lv_content_name       TYPE /bobf/obm_name,
        lt_fieldmapping       TYPE /bobf/t_confro_mapping,
        ls_fieldmapping       TYPE /bobf/s_confro_mapping,
        lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
        ls_context            TYPE /bobf/s_frw_ctx_value_set,
        lo_delegation         TYPE REF TO /bobf/if_frw_delegation,
        lx_frw                TYPE REF TO /bobf/cx_frw_core,
        lx_root               TYPE REF TO cx_root,
        lv_class              TYPE seoclsname,
        lv_application_info   TYPE string,
        lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
        lo_auth_change        TYPE REF TO /bobf/if_frw_change,
        lt_key                TYPE /bobf/t_frw_key.

  BREAK-POINT ID /bobf/frw.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
  ENDIF.

  IF mo_conf->ms_last_vset-vset_key = iv_vset_key.
    ls_vset = mo_conf->ms_last_vset.
  ELSE.
    mo_conf->get_value_set(
      EXPORTING iv_vset_key = iv_vset_key
      IMPORTING es_vset     = ls_vset ).
  ENDIF.

  CASE ls_vset-content_cat.
    WHEN /bobf/if_conf_c=>sc_content_nod.
      IF mo_conf->ms_last_node-node_key = ls_vset-content_key.
        ls_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_vset-content_key
          IMPORTING es_node     = ls_node ).
      ENDIF.

    WHEN /bobf/if_conf_c=>sc_content_act.
      IF mo_conf->ms_last_action-act_key = ls_vset-content_key.
        ls_act = mo_conf->ms_last_action.
      ELSE.
        mo_conf->get_act(
          EXPORTING iv_act_key = ls_vset-content_key
          IMPORTING es_action  = ls_act ).
      ENDIF.
      IF mo_conf->ms_last_node-node_key = ls_act-node_key.
        ls_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_act-node_key
          IMPORTING es_node     = ls_node ).
      ENDIF.

    WHEN /bobf/if_conf_c=>sc_content_ass.
      IF mo_conf->ms_last_assoc-assoc_key = ls_vset-content_key.
        ls_assoc = mo_conf->ms_last_assoc.
      ELSE.
        mo_conf->get_assoc(
          EXPORTING iv_assoc_key = ls_vset-content_key
          IMPORTING es_assoc  = ls_assoc ).
      ENDIF.
      ls_node = ls_assoc-source_node->*.

    WHEN /bobf/if_conf_c=>sc_content_qry.
      IF mo_conf->ms_last_query-query_key = ls_vset-content_key.
        ls_query = mo_conf->ms_last_query.
      ELSE.
        mo_conf->get_query(
          EXPORTING iv_query_key = ls_vset-content_key
          IMPORTING es_query     = ls_query ).
      ENDIF.
      IF mo_conf->ms_last_node-node_key = ls_query-node_key.
        ls_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_query-node_key
          IMPORTING es_node     = ls_node ).
      ENDIF.
  ENDCASE.

  lt_key = it_key.

* ____________________________________________________________________ *
* check authorization
  IF iv_key_is_default = abap_false.
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_code_value_set
                                    bo_service          = space
                                    node_key            = ls_node-node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).
  ENDIF.

* ____________________________________________________________________ *
* delegate call if necessary
  IF ls_node-delegation_class IS NOT INITIAL.
    TRY.
        lo_delegation = get_delegation( ls_node-node_key ).

        /bobf/cl_frw_int_access=>new_instance(
          EXPORTING
            io_bopf            = me
            io_conf            = mo_conf
            io_buffer          = mo_buffer
          RECEIVING
            eo_internal_access = lo_int_access
        ).

        lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
        lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
        lo_int_access->set_context( iv_read_allowed  = abap_true ).

        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

        lo_delegation->retrieve_code_value_set(
          EXPORTING
            iv_vset_key       = iv_vset_key
            it_key            = lt_key
            iv_key_is_default = iv_key_is_default
            is_parameters     = is_parameters
            it_attributes     = it_attributes
            io_read           = lo_int_access
          IMPORTING
            et_code_values    = et_code_values ).

         /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        lo_int_access->invalidate( ).

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

  ELSE.
* ____________________________________________________________________ *
* call implementation if existing
    IF ls_vset-value_set_class IS NOT INITIAL.

      TRY.
*         get node class
          READ TABLE mt_value_set_code
             WITH TABLE KEY vset_key = iv_vset_key
             INTO ls_vset_class.
          IF sy-subrc <> 0.
            ls_vset_class-vset_key = iv_vset_key.
            CREATE OBJECT ls_vset_class-class TYPE (ls_vset-value_set_class).
            INSERT ls_vset_class INTO TABLE mt_value_set_code.
          ENDIF.

          IF iv_key_is_default = abap_true.
            /bobf/cl_frw_int_access=>new_instance(
              EXPORTING
                io_bopf            = me
                io_conf            = mo_conf
                io_buffer          = mo_buffer
                iv_class_name      = /bobf/cl_frw_int_defaults=>gc_class_name
              RECEIVING
                eo_internal_access = lo_int_access
            ).
          ELSE.
            /bobf/cl_frw_int_access=>new_instance(
              EXPORTING
                io_bopf            = me
                io_conf            = mo_conf
                io_buffer          = mo_buffer
              RECEIVING
                eo_internal_access = lo_int_access
            ).
          ENDIF.

          lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
          lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
          lo_int_access->set_context( iv_read_allowed  = abap_true ).

          mo_conf->get_fieldmapping( IMPORTING et_fieldmapping = lt_fieldmapping ).
          READ TABLE lt_fieldmapping INTO ls_fieldmapping WITH KEY fieldname_ext
            COMPONENTS content_cat        = ls_vset-content_cat
                       content_key        = ls_vset-content_key
                       fieldname_ext_long = ls_vset-vset_esr_name.
          ls_context-attribute     = ls_fieldmapping-fieldname_int.
          ls_context-bo_key        = mo_conf->ms_obj-bo_key.
          ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
          ls_context-value_set_key = iv_vset_key.
          ls_context-node_key      = ls_node-node_key.
          ls_context-act_key       = ls_act-act_key.
          ls_context-assoc_key     = ls_assoc-assoc_key.
          ls_context-query_key     = ls_query-query_key.

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.

          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          ls_vset_class-class->retrieve_code_values(
            EXPORTING
              is_ctx         = ls_context
              it_key         = lt_key
              io_read        = lo_int_access
              is_parameters  = is_parameters
              it_attributes  = it_attributes
            CHANGING
              ct_code_values = et_code_values ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          lo_int_access->invalidate( ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
          DELETE mt_access_stack INDEX 1.

        CATCH cx_sy_dyn_call_error INTO lx_root.
          lv_content_name = get_content_description(
            iv_vset = abap_true
            iv_key  = iv_vset_key ).
          lv_content_cat = text-007.
          CREATE OBJECT lx_frw
            EXPORTING
              textid          = /bobf/cx_frw_core=>sc_no_instance
              previous        = lx_root
              mv_method_name  = 'RETRIEVE_CODE_VALUES'
              mv_content_name = lv_content_name
              mv_content_cat  = lv_content_cat.
          set_configuration_error( lx_frw ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_vset = abap_true
            iv_key  = iv_vset_key ).
          lv_content_cat = text-007.
          lv_class = ls_vset-value_set_class.
          lcl_error_text_provider=>get_text_impl_class_error(
            EXPORTING
              iv_content_cat      = /bobf/if_conf_c=>sc_content_vset
              iv_content_key      = ls_vset-content_key
              iv_node_key         = ls_vset-vset_key
              iv_content_name     = lv_content_name
              iv_content_class    = lv_class
              iv_method_name      = 'RETRIEVE_CODE_VALUES'
              io_configuration    = mo_conf
            RECEIVING
              rv_application_info = lv_application_info
          ).
          CREATE OBJECT lx_frw
            EXPORTING
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              previous                   = lx_root
              mv_method_name             = 'RETRIEVE_CODE_VALUES'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ENDTRY.
    ENDIF.
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~retrieve_default_action_param.

  DATA: ls_action                TYPE /bobf/s_confro_act_list,
        ls_obj                   TYPE /bobf/s_confro_obj,
        lo_delegation            TYPE REF TO /bobf/if_frw_delegation,
        ls_act_class             TYPE ty_action,
        lv_content_name          TYPE /bobf/obm_name,
        lv_content_cat           TYPE string,
        ls_context               TYPE /bobf/s_frw_ctx_act,
        lo_int_access            TYPE REF TO /bobf/cl_frw_int_access,
        lx_root                  TYPE REF TO cx_root,
        lx_frw                   TYPE REF TO /bobf/cx_frw_core,
        lt_action_execution_list TYPE /bobf/t_frw_key2,
        lv_action_execution_list TYPE /bobf/conf_key,
        lv_class                 TYPE seoclsname,
        lv_application_info      TYPE string,
        lo_auth_message_dummy    TYPE REF TO /bobf/if_frw_message,
        lo_auth_change           TYPE REF TO /bobf/if_frw_change,
        lt_key                   TYPE /bobf/t_frw_key.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
    CLEAR lo_int_access.
  ENDIF.

*  ____________________________________________________________________ *
*  create sorted action execution list
*  (pre-enhancement actions, basic action and post-enhancement actions)
  IF mo_conf->ms_last_action-act_key = iv_act_key.
    ls_action = mo_conf->ms_last_action.
  ELSE.
    mo_conf->get_act(
      EXPORTING
        iv_act_key  = iv_act_key
      IMPORTING
        es_action   = ls_action ).
  ENDIF.

  IF ls_action-pre_enhancement_keys IS BOUND.
    lt_action_execution_list = ls_action-pre_enhancement_keys->*.
  ENDIF.

  INSERT ls_action-act_key INTO TABLE lt_action_execution_list.

  IF ls_action-post_enhancement_keys IS BOUND.
    APPEND LINES OF ls_action-post_enhancement_keys->* TO lt_action_execution_list.
  ENDIF.

  lt_key = it_key.

* ____________________________________________________________________ *
* check authorization
  lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_default_action_param
                                  bo_service          = space
                                  node_key            = ls_action-node_key )
      iv_cleanse_keys  = abap_true
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_key
      co_message       = lo_auth_message_dummy
  ).

*  ____________________________________________________________________ *
*  execute the action list
  LOOP AT lt_action_execution_list INTO lv_action_execution_list.

    IF mo_conf->ms_last_action-act_key = lv_action_execution_list.
      ls_action = mo_conf->ms_last_action.
    ELSE.
      mo_conf->get_act(
        EXPORTING
          iv_act_key  = lv_action_execution_list
        IMPORTING
          es_action   = ls_action ).
    ENDIF.

    IF ls_action-act_class IS INITIAL.
*   check for delegation class
      IF mo_conf->ms_last_node-node_key <> ls_action-node_key.
        mo_conf->get_node( iv_node_key = ls_action-node_key ).
      ENDIF.

      IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
        TRY.
            lo_delegation = get_delegation( ls_action-node_key ).
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            lo_delegation->retrieve_default_action_param(
              EXPORTING
                iv_act_key    = lv_action_execution_list
                it_key        = lt_key
              CHANGING
                cs_parameters = cs_parameters ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.

    ELSE.
      lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
      TRY.
*       get action class
          READ TABLE mt_action
            WITH TABLE KEY act_key = lv_action_execution_list
            INTO ls_act_class.
          IF sy-subrc <> 0.
            ls_act_class-act_key = lv_action_execution_list.
            CREATE OBJECT ls_act_class-class TYPE (ls_action-act_class).
          ENDIF.

          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
            RECEIVING
              eo_internal_access = lo_int_access
          ).
          lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.

          ls_obj = mo_conf->ms_obj.
          ls_context-bo_key          = ls_obj-bo_key.
          ls_context-root_node_key   = ls_obj-root_node_key.
          ls_context-node_key        = ls_action-node_key.
          ls_context-act_key         = lv_action_execution_list.
          ls_context-act_cat         = ls_action-act_cat.
          lo_int_access->set_context(
            is_action        = ls_context
            iv_read_allowed  = abap_true ).

*       call action class
          ls_act_class-class->retrieve_default_param(
             EXPORTING
               is_ctx        = ls_context
               it_key        = lt_key
               io_read       = lo_int_access
             CHANGING
               cs_parameters = cs_parameters ).

          lo_int_access->invalidate( ).

        CATCH cx_sy_create_object_error INTO lx_root.
          lv_content_name = get_content_description(
            iv_act = abap_true
            iv_key = ls_action-act_key ).
          lv_content_cat = text-000.
          CREATE OBJECT lx_frw
            EXPORTING
              previous        = lx_root
              textid          = /bobf/cx_frw_core=>sc_no_instance
              mv_classname    = ls_action-act_class
              mv_content_name = lv_content_name
              mv_content_cat  = lv_content_cat.
          set_configuration_error( lx_frw ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_act = abap_true
            iv_key = ls_action-act_key ).
          lv_content_cat = text-000.
          lv_class = ls_action-act_class.
          lcl_error_text_provider=>get_text_impl_class_error(
            EXPORTING
              iv_content_cat      = /bobf/if_conf_c=>sc_content_act
              iv_content_key      = ls_action-act_key
              iv_node_key         = ls_action-node_key
              iv_content_name     = lv_content_name
              iv_content_class    = lv_class
              iv_method_name      = 'RETRIEVE_DEFAULT_PARAM'
              io_configuration    = mo_conf
            RECEIVING
              rv_application_info = lv_application_info
          ).
          CREATE OBJECT lx_frw
            EXPORTING
              previous                   = lx_root
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              mv_node                    = ls_action-node_key
              mv_method_name             = 'RETRIEVE_DEFAULT_PARAM'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ENDTRY.
      /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.

    ENDIF.

  ENDLOOP.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~retrieve_default_node_values.

  DATA: ls_nodeconf           TYPE        /bobf/s_confro_node,
        ls_node_class         TYPE        ty_node,
        lt_key                TYPE        /bobf/t_frw_key,
        ls_key                TYPE        /bobf/s_frw_key,
        lt_node               TYPE        /bobf/t_frw_node,
        ls_node               TYPE        /bobf/s_frw_node,
        lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
        lo_int_defaults       TYPE REF TO /bobf/cl_frw_int_access,
        ls_mod                TYPE        /bobf/s_frw_modification,
        ls_context            TYPE        /bobf/s_frw_ctx_assoc,
        lo_delegation         TYPE REF TO /bobf/if_frw_delegation,
        lo_change             TYPE REF TO /bobf/if_frw_change,
        lv_content_cat        TYPE        string,
        lv_content_name       TYPE        /bobf/obm_name,
        lt_src_key            TYPE        /bobf/t_frw_key,
        ls_key_link           TYPE        /bobf/s_frw_key_link,
        lt_key_link           TYPE        /bobf/t_frw_key_link,
        lt_key_link2          TYPE        /bobf/t_frw_key_link,
        lt_failed_key         TYPE        /bobf/t_frw_key,
        lt_failed_key2        TYPE        /bobf/t_frw_key,
        lt_modification       TYPE        /bobf/t_frw_modification,
        lo_message            TYPE REF TO /bobf/if_frw_message,
        lx_frw                TYPE REF TO /bobf/cx_frw_core,
        lx_root               TYPE REF TO cx_root,
        lv_class              TYPE        seoclsname,
        lv_application_info   TYPE        string,
        lt_auth_key           TYPE        /bobf/t_frw_key,
        lt_auth_failed_key    TYPE        /bobf/t_frw_key,
        lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
        lo_auth_change        TYPE REF TO /bobf/if_frw_change,
        lt_auth_modification  TYPE        /bobf/t_frw_modification.

  FIELD-SYMBOLS: <ls_mod> TYPE /bobf/s_frw_modification.

  BREAK-POINT ID /bobf/frw.

  CLEAR: et_data,
         eo_message,
         eo_property.

  CHECK it_modification IS NOT INITIAL.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
  ENDIF.

  IF mo_conf->ms_last_node-node_key = iv_node_key.
    ls_nodeconf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
      EXPORTING iv_node_key = iv_node_key
      IMPORTING es_node     = ls_nodeconf ).
  ENDIF.

* ____________________________________________________________________ *
* check authorization
  lt_auth_modification = it_modification.
  LOOP AT lt_auth_modification ASSIGNING <ls_mod>.
    ls_key-key = <ls_mod>-key.
    APPEND ls_key TO lt_auth_key.
  ENDLOOP.
  lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
  mo_authority_handler->check_authority(
    EXPORTING
      io_change        = lo_auth_change
      is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                  activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_default_node_values
                                  bo_service          = space
                                  node_key            = iv_node_key )
      iv_cleanse_keys  = abap_false
      io_bopf          = me
      io_buffer        = mo_buffer
      iv_last_state    = /bobf/if_conf_c=>sc_state_database
      iv_current_state = /bobf/if_conf_c=>sc_state_current
    IMPORTING
      et_failed_key    = lt_auth_failed_key
    CHANGING
      ct_access_stack  = mt_access_stack
      ct_key           = lt_auth_key
      co_message       = lo_auth_message_dummy
  ).
  IF lt_auth_failed_key IS NOT INITIAL.
    LOOP AT lt_auth_failed_key INTO ls_key.
      DELETE lt_auth_modification WHERE key = ls_key-key.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
  IF ls_nodeconf-delegation_class IS NOT INITIAL.
*   delegate call if necessary
    TRY.
        CREATE OBJECT eo_property TYPE /bobf/cl_frw_property.
        lo_delegation = get_delegation( iv_node_key ).
        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

        lo_delegation->retrieve_default_node_values(
          EXPORTING
             iv_node_key                  = iv_node_key
             it_modification              = lt_auth_modification
             is_assoc_parameters          = is_assoc_parameters
             it_assoc_filtered_attributes = it_assoc_filtered_attributes
             io_property                  = eo_property
           IMPORTING
             eo_message                   = eo_message
             et_data                      = et_data ).

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

  ELSE.
* ____________________________________________________________________ *
*   no delegation involved
    IF lt_auth_modification IS NOT INITIAL.
      LOOP AT lt_auth_modification ASSIGNING <ls_mod>.
        ls_key-key = <ls_mod>-key.
        APPEND ls_key TO lt_key.
        ls_key-key = <ls_mod>-source_key.
        APPEND ls_key TO lt_src_key.
      ENDLOOP.

      IF <ls_mod>-source_node IS NOT INITIAL.
        TRY.
            mo_buffer->get_root_key(
              EXPORTING
                iv_node_key   = <ls_mod>-source_node
                it_key        = lt_src_key
                iv_state      = /bobf/if_conf_c=>sc_state_default
              IMPORTING
                et_key_link   = lt_key_link
                et_failed_key = lt_failed_key ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        IF lt_failed_key IS NOT INITIAL.
*       Parent was not defaulted -> check in current state
          TRY.
              mo_buffer->get_root_key(
               EXPORTING
                 iv_node_key   = <ls_mod>-source_node
                 it_key        = lt_failed_key
                 iv_state      = /bobf/if_conf_c=>sc_state_current
               IMPORTING
                 et_key_link   = lt_key_link2
                 et_failed_key = lt_failed_key2 ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
          ASSERT ID /bobf/frw_error CONDITION lt_failed_key2 IS INITIAL.
          INSERT LINES OF lt_key_link2 INTO TABLE lt_key_link.
        ENDIF.

        LOOP AT lt_auth_modification INTO ls_mod.
          READ TABLE lt_key_link INTO ls_key_link
            WITH KEY source_key = ls_mod-source_key.
          ASSERT ID /bobf/frw_error CONDITION sy-subrc = 0.
          IF sy-subrc = 0.
            ls_mod-root_key = ls_key_link-target_key.
            APPEND ls_mod TO lt_modification.
          ELSE.
            DELETE lt_key WHERE key = ls_mod-key.
          ENDIF.
        ENDLOOP.
      ELSE.
*     working on ROOT node
        lt_modification = lt_auth_modification.
      ENDIF.
    ENDIF.

    CHECK lt_modification IS NOT INITIAL.

* ____________________________________________________________________ *
*   set node category (default only)
    LOOP AT lt_modification ASSIGNING <ls_mod>.
      IF <ls_mod>-node_cat IS INITIAL.
        <ls_mod>-node_cat = ls_nodeconf-node_cat_key.
      ENDIF.
    ENDLOOP.

* ____________________________________________________________________ *
*   apply defaults to buffer
    TRY.
        mv_defaults_exists = abap_true.
        lo_change = /bobf/cl_frw_factory=>get_change( ).
        mo_buffer->modify(
           EXPORTING
             it_modification   = lt_modification
             iv_state          = /bobf/if_conf_c=>sc_state_default
             iv_only_transient = abap_true
             io_change         = lo_change
           IMPORTING
             eo_message        = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

* ____________________________________________________________________ *
*   set initial status values
    IF mo_conf->ms_obj-status_class  IS NOT INITIAL AND
       ls_nodeconf-status_attributes IS NOT INITIAL.
*     get status adapter
      IF mo_sam IS NOT BOUND.
        TRY.
            CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
              EXPORTING
                iv_bo_key = mo_conf->ms_obj-bo_key.
          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_cat = TEXT-004.
            CREATE OBJECT lx_frw
              EXPORTING
                previous       = lx_root
                textid         = /bobf/cx_frw_core=>sc_no_instance
                mv_classname   = mo_conf->ms_obj-status_class
                mv_content_cat = lv_content_cat.
            set_application_error( lx_frw ).
        ENDTRY.
        ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
      ENDIF.

*     get int access
      lo_int_defaults ?= /bobf/cl_frw_int_access=>new_instance(
        EXPORTING
          io_bopf            = me
          io_conf            = mo_conf
          io_buffer          = mo_buffer
          io_change          = lo_change
          iv_class_name      = /bobf/cl_frw_int_defaults=>gc_class_name
      ).
      lo_int_defaults->set_current_state( /bobf/if_conf_c=>sc_state_current ).
      ls_context-bo_key        = mo_conf->ms_obj-bo_key.
      ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
      ls_context-node_key      = iv_node_key.
      ls_context-assoc_key     = ls_mod-association.
      lo_int_defaults->set_context( iv_read_allowed   = abap_true
                                    iv_modify_allowed = abap_true
                                    is_association    = ls_context ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      INSERT lo_int_defaults INTO mt_access_stack INDEX 1.

      LOOP AT lt_auth_modification INTO ls_mod.
        ls_node-node = ls_mod-node.
        ls_node-key  = ls_mod-key.
        INSERT ls_node INTO TABLE lt_node.
      ENDLOOP.

      lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
      TRY.
          mo_sam->create(
            EXPORTING
              it_node    = lt_node
              io_read    = lo_int_defaults
              io_modify  = lo_int_defaults
           IMPORTING
              eo_message = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

*     check for undone modifications and flush
      IF lo_int_defaults->mt_modification IS NOT INITIAL.
        lo_int_defaults->/bobf/if_frw_modify~end_modify( IMPORTING eo_message = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
      lo_int_defaults->invalidate( ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.
    ENDIF.

* ____________________________________________________________________ *
*   call implementation if existing
    IF ls_nodeconf-node_class IS NOT INITIAL.
      lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
      TRY.
*         get node class
          READ TABLE mt_node
             WITH TABLE KEY node_key = ls_nodeconf-node_key
             INTO ls_node_class.
          IF sy-subrc <> 0.
            ls_node_class-node_key = ls_nodeconf-node_key.
            CREATE OBJECT ls_node_class-class TYPE (ls_nodeconf-node_class).
            INSERT ls_node_class INTO TABLE mt_node.
          ENDIF.

          IF lo_int_defaults IS NOT BOUND.
            lo_int_defaults ?= /bobf/cl_frw_int_access=>new_instance(
              EXPORTING
                io_bopf   = me
                io_conf   = mo_conf
                io_buffer = mo_buffer
                io_change = lo_change
                iv_class_name  = /bobf/cl_frw_int_defaults=>gc_class_name
            ).
            lo_int_defaults->set_current_state( /bobf/if_conf_c=>sc_state_current ).
            ls_context-bo_key        = mo_conf->ms_obj-bo_key.
            ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
            ls_context-node_key      = iv_node_key.
            ls_context-assoc_key     = ls_mod-association.
          ENDIF.
          lo_int_defaults->set_context( iv_read_allowed   = abap_true
                                        iv_modify_allowed = abap_true ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          lo_int_access = lo_int_defaults.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.

          ls_node_class-class->retrieve_default_values(
            EXPORTING
              is_ctx                       = ls_context
              it_key                       = lt_key
              is_assoc_parameters          = is_assoc_parameters
              it_assoc_filtered_attributes = it_assoc_filtered_attributes
              iv_source_node_key           = ls_mod-source_node
              iv_source_key                = ls_mod-source_key
              io_read                      = lo_int_defaults
              io_modify                    = lo_int_defaults
            IMPORTING
              eo_message                   = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

        CATCH cx_sy_dyn_call_error INTO lx_root.
          lv_content_name = get_content_description(
            iv_node = abap_true
            iv_key  = iv_node_key ).
          lv_content_cat = TEXT-006.
          CREATE OBJECT lx_frw
            EXPORTING
              textid          = /bobf/cx_frw_core=>sc_no_instance
              previous        = lx_root
              mv_method_name  = 'RETRIEVE_DEFAULT_VALUES'
              mv_content_name = lv_content_name
              mv_content_cat  = lv_content_cat.
          set_configuration_error( lx_frw ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_node = abap_true
            iv_key  = iv_node_key ).
          lv_content_cat = TEXT-006.
          lv_class = ls_nodeconf-node_class.
          lcl_error_text_provider=>get_text_impl_class_error(
            EXPORTING
              iv_content_cat      = /bobf/if_conf_c=>sc_content_nod
              iv_content_key      = ls_nodeconf-node_key
              iv_node_key         = iv_node_key
              iv_content_name     = lv_content_name
              iv_content_class    = lv_class
              iv_method_name      = 'RETRIEVE_DEFAULT_VALUES'
              io_configuration    = mo_conf
            RECEIVING
              rv_application_info = lv_application_info
          ).
          CREATE OBJECT lx_frw
            EXPORTING
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              previous                   = lx_root
              mv_method_name             = 'RETRIEVE_DEFAULT_VALUES'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ENDTRY.

      /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

*     check for undone modifications and flush
      IF lo_int_defaults->mt_modification IS NOT INITIAL.
        lo_int_defaults->/bobf/if_frw_modify~end_modify( IMPORTING eo_message = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
      lo_int_defaults->invalidate( ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.
    ENDIF.

*   read data from buffer
    TRY.
        mo_buffer->retrieve(
          EXPORTING
            iv_node_key       = iv_node_key
            it_key            = lt_key
            iv_state          = /bobf/if_conf_c=>sc_state_default
            iv_fill_data      = abap_true
            iv_buffer_only    = abap_true
            io_change         = lo_change
          IMPORTING
            et_data           = et_data ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

*   determine properties
    /bobf/if_frw_service_layer~retrieve_property(
      EXPORTING
        iv_node_key                  = iv_node_key
        it_key                       = lt_key
        iv_key_is_default            = abap_true
        iv_node_property             = abap_true
        iv_node_attribute_property   = abap_true
        iv_assoc_property            = abap_true
        iv_assoc_attribute_property  = abap_true
        iv_action_property           = abap_true
        iv_action_attribute_property = abap_true
        iv_query_property            = abap_true
        iv_query_attribute_property  = abap_true
        iv_check_services            = /bobf/if_conf_c=>sc_retrieve_property
      IMPORTING
        eo_message                   = lo_message
        eo_property                  = eo_property ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~retrieve_default_query_param.

  DATA: ls_obj              TYPE /bobf/s_confro_obj,
        ls_query            TYPE /bobf/s_confro_query,
        ls_query_class      TYPE ty_query,
        lv_content_cat      TYPE string,
        lv_content_name    TYPE /bobf/obm_name,
        ls_context          TYPE /bobf/s_frw_ctx_query,
        lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
        lx_frw              TYPE REF TO /bobf/cx_frw_core,
        lx_root             TYPE REF TO cx_root,
        lv_class            TYPE seoclsname,
        lv_application_info TYPE string.

  BREAK-POINT ID /bobf/frw.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
  ENDIF.

  mo_conf->get_query(
    EXPORTING iv_query_key = iv_query_key
    IMPORTING es_query     = ls_query ).

  TRY.
      IF ls_query-query_class IS INITIAL.
*       no implementation available -> no default
        ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>access_stack_stack_check(
               it_access_stack = mt_access_stack ) = abap_true.
        RETURN.

      ELSE.
*       fill context structure
        ls_obj = mo_conf->ms_obj.
        ls_context-bo_key        = ls_obj-bo_key.
        ls_context-root_node_key = ls_obj-root_node_key.
        ls_context-node_key      = ls_query-node_key.
        ls_context-query_key     = iv_query_key.

*       get query class
        READ TABLE mt_query
           WITH TABLE KEY query_key = ls_query-query_key
           INTO ls_query_class.
        IF sy-subrc <> 0.
          ls_query_class-query_key = ls_query-query_key.
          CREATE OBJECT ls_query_class-class TYPE (ls_query-query_class).
          INSERT ls_query_class INTO TABLE mt_query.
        ENDIF.

        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

        ls_query_class-class->retrieve_default_param(
          EXPORTING
            is_ctx                  = ls_context
          CHANGING
            ct_selection_parameters = ct_selection_parameters ).

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      ENDIF.

    CATCH cx_sy_dyn_call_error INTO lx_root.
      lv_content_name = get_content_description(
        iv_query = abap_true
        iv_key   = iv_query_key ).
      lv_content_cat = text-001.
      CREATE OBJECT lx_frw
        EXPORTING
          textid          = /bobf/cx_frw_core=>sc_no_instance
          previous        = lx_root
          mv_method_name  = 'RETRIEVE_DEFAULT_PARAM'
          mv_content_name = lv_content_name
          mv_content_cat  = lv_content_cat.
      set_configuration_error( lx_frw ).

    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      lv_content_name = get_content_description(
        iv_query = abap_true
        iv_key   = iv_query_key ).
      lv_content_cat = text-001.
      lv_class = ls_query-query_class.
      lcl_error_text_provider=>get_text_impl_class_error(
        EXPORTING
          iv_content_cat      = /bobf/if_conf_c=>sc_content_qry
          iv_content_key      = ls_query-query_key
          iv_node_key         = ls_query-node_key
          iv_content_name     = lv_content_name
          iv_content_class    = lv_class
          iv_method_name      = 'RETRIEVE_DEFAULT_PARAM'
          io_configuration    = mo_conf
        RECEIVING
          rv_application_info = lv_application_info
      ).
      CREATE OBJECT lx_frw
        EXPORTING
          textid                     = /bobf/cx_frw_core=>sc_content_exception
          previous                   = lx_root
          mv_method_name             = 'RETRIEVE_DEFAULT_PARAM'
          mv_content_name            = lv_content_name
          mv_content_cat             = lv_content_cat
          mv_application_information = lv_application_info.
      set_application_error( lx_frw ).
  ENDTRY.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~retrieve_id_value_set.

  DATA: ls_vset             TYPE /bobf/s_confro_value_set,
        ls_node             TYPE /bobf/s_confro_node,
        ls_act              TYPE /bobf/s_confro_act_list,
        ls_assoc            TYPE /bobf/s_confro_assoc,
        ls_query            TYPE /bobf/s_confro_query,
        ls_vset_class       TYPE ty_value_set_id,
        lv_content_cat      TYPE string,
        lv_content_name     TYPE /bobf/obm_name,
        lt_fieldmapping     TYPE /bobf/t_confro_mapping,
        ls_fieldmapping     TYPE /bobf/s_confro_mapping,
        lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
        ls_context          TYPE /bobf/s_frw_ctx_value_set,
        lo_delegation       TYPE REF TO /bobf/if_frw_delegation,
        lx_frw              TYPE REF TO /bobf/cx_frw_core,
        lx_root             TYPE REF TO cx_root,
        lv_class            TYPE seoclsname,
        lv_application_info TYPE string.

  BREAK-POINT ID /bobf/frw.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

  READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
  IF lo_int_access IS BOUND.
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    lo_int_access->end_modify( ).
  ENDIF.

  IF mo_conf->ms_last_vset-vset_key = iv_vset_key.
    ls_vset = mo_conf->ms_last_vset.
  ELSE.
    mo_conf->get_value_set(
      EXPORTING iv_vset_key = iv_vset_key
      IMPORTING es_vset     = ls_vset ).
  ENDIF.

  CASE ls_vset-content_cat.
    WHEN /bobf/if_conf_c=>sc_content_nod.
      IF mo_conf->ms_last_node-node_key = ls_vset-content_key.
        ls_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_vset-content_key
          IMPORTING es_node     = ls_node ).
      ENDIF.

    WHEN /bobf/if_conf_c=>sc_content_act.
      IF mo_conf->ms_last_action-act_key = ls_vset-content_key.
        ls_act = mo_conf->ms_last_action.
      ELSE.
        mo_conf->get_act(
          EXPORTING iv_act_key = ls_vset-content_key
          IMPORTING es_action  = ls_act ).
      ENDIF.
      IF mo_conf->ms_last_node-node_key = ls_act-node_key.
        ls_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_act-node_key
          IMPORTING es_node     = ls_node ).
      ENDIF.

    WHEN /bobf/if_conf_c=>sc_content_ass.
      IF mo_conf->ms_last_assoc-assoc_key = ls_vset-content_key.
        ls_assoc = mo_conf->ms_last_assoc.
      ELSE.
        mo_conf->get_assoc(
          EXPORTING iv_assoc_key = ls_vset-content_key
          IMPORTING es_assoc  = ls_assoc ).
      ENDIF.
      ls_node = ls_assoc-source_node->*.

    WHEN /bobf/if_conf_c=>sc_content_qry.
      IF mo_conf->ms_last_query-query_key = ls_vset-content_key.
        ls_query = mo_conf->ms_last_query.
      ELSE.
        mo_conf->get_query(
          EXPORTING iv_query_key = ls_vset-content_key
          IMPORTING es_query     = ls_query ).
      ENDIF.
      IF mo_conf->ms_last_node-node_key = ls_query-node_key.
        ls_node = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_query-node_key
          IMPORTING es_node     = ls_node ).
      ENDIF.
  ENDCASE.

* ____________________________________________________________________ *
* delegate call if necessary
  IF ls_node-delegation_class IS NOT INITIAL.
    TRY.
        lo_delegation = get_delegation( ls_node-node_key ).

        CREATE OBJECT lo_int_access
          EXPORTING
            io_bopf   = me
            io_conf   = mo_conf
            io_buffer = mo_buffer.
        lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
        lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
        lo_int_access->set_context( iv_read_allowed  = abap_true ).

        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

        lo_delegation->retrieve_id_value_set(
          EXPORTING
            iv_vset_key              = iv_vset_key
            it_key                   = it_key
            iv_key_is_default        = iv_key_is_default
            it_selection_parameters  = it_selection_parameters
            is_query_options         = is_query_options
            io_read                  = lo_int_access
          IMPORTING
            et_key                   = et_key ).

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        lo_int_access->invalidate( ).

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

  ELSE.
* ____________________________________________________________________ *
* call implementation if existing
    IF ls_vset-value_set_class IS NOT INITIAL.

      TRY.
*         get node class
          READ TABLE mt_value_set_id
             WITH TABLE KEY vset_key = iv_vset_key
             INTO ls_vset_class.
          IF sy-subrc <> 0.
            ls_vset_class-vset_key = iv_vset_key.
            CREATE OBJECT ls_vset_class-class TYPE (ls_vset-value_set_class).
            INSERT ls_vset_class INTO TABLE mt_value_set_id.
          ENDIF.

          IF iv_key_is_default = abap_true.
            CREATE OBJECT lo_int_access TYPE /bobf/cl_frw_int_defaults
              EXPORTING
                io_bopf   = me
                io_conf   = mo_conf
                io_buffer = mo_buffer.
          ELSE.
            CREATE OBJECT lo_int_access
              EXPORTING
                io_bopf   = me
                io_conf   = mo_conf
                io_buffer = mo_buffer.
          ENDIF.
          lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
          lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
          lo_int_access->set_context( iv_read_allowed  = abap_true ).

          mo_conf->get_fieldmapping( IMPORTING et_fieldmapping = lt_fieldmapping ).
          READ TABLE lt_fieldmapping INTO ls_fieldmapping WITH KEY fieldname_ext
            COMPONENTS content_cat        = ls_vset-content_cat
                       content_key        = ls_vset-content_key
                       fieldname_ext_long = ls_vset-vset_esr_name.
          ls_context-attribute             = ls_fieldmapping-fieldname_int.
          ls_context-bo_key                = mo_conf->ms_obj-bo_key.
          ls_context-root_node_key         = mo_conf->ms_obj-root_node_key.
          ls_context-value_set_key         = iv_vset_key.
          ls_context-node_key              = ls_node-node_key.
          ls_context-act_key               = ls_act-act_key.
          ls_context-assoc_key             = ls_assoc-assoc_key.
          ls_context-query_key             = ls_query-query_key.

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.

          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          ls_vset_class-class->retrieve_value_set(
            EXPORTING
              is_ctx                  = ls_context
              it_key                  = it_key
              io_read                 = lo_int_access
              io_query                = lo_int_access
              it_selection_parameters = it_selection_parameters
              is_query_options        = is_query_options
            CHANGING
              ct_key                  = et_key ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          lo_int_access->invalidate( ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
          DELETE mt_access_stack INDEX 1.

        CATCH cx_sy_dyn_call_error INTO lx_root.
          lv_content_name = get_content_description(
            iv_vset = abap_true
            iv_key  = iv_vset_key ).
          lv_content_cat = text-007.
          CREATE OBJECT lx_frw
            EXPORTING
              textid          = /bobf/cx_frw_core=>sc_no_instance
              previous        = lx_root
              mv_method_name  = 'RETRIEVE_VALUE_SET'
              mv_content_name = lv_content_name
              mv_content_cat  = lv_content_cat.
          set_configuration_error( lx_frw ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_vset = abap_true
            iv_key  = iv_vset_key ).
          lv_content_cat = text-007.
          lcl_error_text_provider=>get_text_impl_class_error(
  EXPORTING
    iv_content_cat      = /bobf/if_conf_c=>sc_content_vset
    iv_content_key      = ls_vset-content_key
    iv_node_key         = ls_vset-vset_key
    iv_content_name     = lv_content_name
    iv_content_class    = lv_class
    iv_method_name      = 'RETRIEVE_VALUE_SET'
    io_configuration    = mo_conf
  RECEIVING
    rv_application_info = lv_application_info
).
          CREATE OBJECT lx_frw
            EXPORTING
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              previous                   = lx_root
              mv_method_name             = 'RETRIEVE_VALUE_SET'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ENDTRY.
    ENDIF.
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~retrieve_property.

  DATA: ls_assoc                TYPE        /bobf/s_confro_assoc,
        lt_assoc                TYPE        /bobf/t_confro_assoc,
        ls_nodeconf             TYPE        /bobf/s_confro_node,
        lo_delegation           TYPE REF TO /bobf/if_frw_delegation,
        lt_node_cat             TYPE        /bobf/t_frw_node_cat,
        ls_node_cat             TYPE        /bobf/s_frw_node_cat,
        lt_key                  TYPE        /bobf/t_frw_key,
        lt_key_lock             TYPE        /bobf/t_frw_key,
        ls_key                  TYPE        /bobf/s_frw_key,
        ls_node_cat_c           TYPE        /bobf/s_confro_node_cat,
        lt_failed_key           TYPE        /bobf/t_frw_key,
        lt_property_ncat        TYPE        /bobf/t_confro_property_d,
        lt_property_dyn         TYPE        /bobf/t_frw_property_k,
        lt_property_subtree     TYPE        /bobf/t_frw_property_k,
        lt_property_sorted      TYPE        /bobf/t_frw_property_k_sorted,
        lt_property_stat        TYPE        /bobf/t_frw_property_k,
        lt_property_sam         TYPE        /bobf/t_frw_property_k,
        lt_property_auth_action TYPE        /bobf/t_frw_property_k,
        lt_property_auth_node   TYPE        /bobf/t_frw_property_k,
        lt_property_auth_assoc  TYPE        /bobf/t_frw_property_k,
        lt_property_do          TYPE        /bobf/t_frw_property_k,
        ls_property             TYPE        /bobf/s_frw_property_k,
        ls_property_parameter   TYPE        /bobf/s_frw_c_property,
        ls_property_parameter_r TYPE REF TO /bobf/s_frw_c_property,
        lt_filtered_attributes  TYPE        /bobf/t_frw_name,
        lt_lock_node            TYPE        /bobf/t_frw_lock_node,
        ls_lock_node            TYPE        /bobf/s_frw_lock_node,
        lo_message              TYPE REF TO /bobf/if_frw_message,
        lt_node                 TYPE        /bobf/t_frw_node,
        lt_node_link            TYPE        /bobf/t_frw_node_key_link,
        ls_node_link            TYPE        /bobf/s_frw_node_key_link,
        ls_act_conf             TYPE        /bobf/s_confro_act_list,
        lv_state                TYPE        /bobf/conf_state,
        lx_root                 TYPE REF TO cx_root,
        lx_frw                  TYPE REF TO /bobf/cx_frw_core,
        lv_content_cat          TYPE        string,
        lo_change               TYPE REF TO /bobf/if_frw_change, "#EC NEEDED
        lo_int_access           TYPE REF TO /bobf/cl_frw_int_access,
        lo_auth_message_dummy   TYPE REF TO /bobf/if_frw_message,
        lo_auth_change          TYPE REF TO /bobf/if_frw_change.

  FIELD-SYMBOLS:
    <ls_property> TYPE /bobf/s_frw_property_k.

  CLEAR: eo_message,
         eo_property.

  CHECK iv_check_services <> /bobf/if_conf_c=>sc_check_services_skip.
  CHECK it_key IS NOT INITIAL.

  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_set(
         it_access_stack = mt_access_stack ) = abap_true.

* remember node for later notifications of association and property changes
  IF iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
    READ TABLE mt_node_properties_requested TRANSPORTING NO FIELDS
      WITH KEY key_sort COMPONENTS table_line = iv_node_key.
    IF sy-subrc <> 0.
      APPEND iv_node_key TO mt_node_properties_requested.
    ENDIF.
  ENDIF.

* check for delegation
  IF mo_conf->ms_last_node-node_key = iv_node_key.
    ls_nodeconf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
       EXPORTING iv_node_key = iv_node_key
       IMPORTING es_node     = ls_nodeconf ).
  ENDIF.

  IF iv_key_is_default = abap_true.
    lv_state = /bobf/if_conf_c=>sc_state_default.
  ELSE.
    lv_state = /bobf/if_conf_c=>sc_state_current.
  ENDIF.

  lt_key = it_key.
  SORT lt_key.
  DELETE ADJACENT DUPLICATES FROM lt_key COMPARING key.
* using secondary key KEY_SORT is slower even if index already built up

* ____________________________________________________________________ *
* check authorization
  IF iv_key_is_default = abap_false
    AND iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_property
                                    bo_service          = space
                                    node_key            = iv_node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).
    " handle keys with no authorization like non-existing keys => just filter them out, don't set properties for them
    CHECK lt_key IS NOT INITIAL.
  ENDIF.

* ____________________________________________________________________ *
* delegate property call
  IF ls_nodeconf-delegation_class IS NOT INITIAL AND
     iv_check_services <> /bobf/if_conf_c=>sc_check_services_stat AND
     iv_check_services <> /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.

    TRY.
        CREATE OBJECT eo_property TYPE /bobf/cl_frw_property.
        lo_delegation = get_delegation( iv_node_key ).

        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        lo_delegation->retrieve_property(
          EXPORTING
            iv_node_key                  = iv_node_key
            it_key                       = lt_key
            iv_key_is_default            = iv_key_is_default
            iv_node_property             = iv_node_property
            iv_node_attribute_property   = iv_node_attribute_property
            it_node_attribute            = it_node_attribute
            iv_assoc_property            = iv_assoc_property
            it_assoc                     = it_assoc
            iv_assoc_attribute_property  = iv_assoc_attribute_property
            iv_action_property           = iv_action_property
            it_action                    = it_action
            iv_action_attribute_property = iv_action_attribute_property
            iv_check_services            = iv_check_services
            io_property                  = eo_property
            io_read                      = mo_delegation_read ).

*       do existency check on DO nodes as no failed keys are returned
        lo_delegation->retrieve(
          EXPORTING
            iv_node_key       = iv_node_key
            it_key            = lt_key
            iv_fill_data      = abap_false
            iv_state          = /bobf/if_conf_c=>sc_state_current
            io_read           = mo_delegation_read
            io_change         = lo_change
          IMPORTING
            et_failed_key     = lt_failed_key ).

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_key WHERE key = ls_key-key.
        ENDLOOP.
        IF lt_key IS INITIAL.
          ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>access_stack_stack_check(
                 it_access_stack = mt_access_stack ) = abap_true.
          RETURN.
        ENDIF.

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.

* ____________________________________________________________________ *
* get dynamic properties
  IF ls_nodeconf-delegation_class IS INITIAL.
    IF iv_check_services = /bobf/if_conf_c=>sc_retrieve_property OR
       iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn.

      mo_conf->get_assoc(
       EXPORTING
         iv_node_key   = iv_node_key
         iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_property
         iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
       IMPORTING
         es_assoc      = ls_assoc ).
      IF ls_assoc IS INITIAL.
*       no property node defined
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK
        ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>access_stack_stack_check(
               it_access_stack = mt_access_stack ) = abap_true.
        RETURN.
      ENDIF.

      ls_property_parameter-all_node_property              = iv_node_property.
      ls_property_parameter-all_node_attribute_property    = iv_node_attribute_property.
      ls_property_parameter-node_attribute                 = it_node_attribute.
      ls_property_parameter-all_association_property       = iv_assoc_property.
      ls_property_parameter-association                    = it_assoc.
      ls_property_parameter-all_association_attribute_prop = iv_assoc_attribute_property.
      ls_property_parameter-all_action_property            = iv_action_property.
      ls_property_parameter-action                         = it_action.
      ls_property_parameter-all_action_attribute_property  = iv_action_attribute_property.
      ls_property_parameter-all_query_property             = iv_query_property.
      ls_property_parameter-query                          = it_query.
      ls_property_parameter-all_query_attribute_property   = iv_query_attribute_property.
      ls_property_parameter-all_subtree_property           = ls_nodeconf-subtree_property.
      GET REFERENCE OF ls_property_parameter INTO ls_property_parameter_r.

      IF iv_node_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_node       TO lt_filtered_attributes.
      ENDIF.
      IF iv_node_attribute_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_node_attr  TO lt_filtered_attributes.
      ENDIF.
      IF it_node_attribute IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_node_attr      TO lt_filtered_attributes.
      ENDIF.
      IF iv_assoc_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_assoc      TO lt_filtered_attributes.
      ENDIF.
      IF iv_assoc_attribute_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_assoc_attr TO lt_filtered_attributes.
      ENDIF.
      IF it_assoc IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_association    TO lt_filtered_attributes.
      ENDIF.
      IF iv_action_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_act        TO lt_filtered_attributes.
      ENDIF.
      IF iv_action_attribute_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_act_attr   TO lt_filtered_attributes.
      ENDIF.
      IF it_action IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_action         TO lt_filtered_attributes.
      ENDIF.
      IF iv_query_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_query      TO lt_filtered_attributes.
      ENDIF.
      IF iv_query_attribute_property IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_qry_attr   TO lt_filtered_attributes.
      ENDIF.
      IF it_query IS NOT INITIAL.
        APPEND /bobf/if_conf_c=>sc_prop_param_query          TO lt_filtered_attributes.
      ENDIF.
      IF ls_nodeconf-subtree_property = abap_true.
        APPEND /bobf/if_conf_c=>sc_prop_param_all_subtree    TO lt_filtered_attributes.
      ENDIF.

      IF iv_key_is_default = abap_false.
        retrieve_by_association(
          EXPORTING
            iv_node_key            = iv_node_key
            it_key                 = lt_key
            iv_association         = ls_assoc-assoc_key
            is_parameters          = ls_property_parameter_r
            it_filtered_attributes = lt_filtered_attributes
            iv_state               = lv_state
            iv_buffer_only         = abap_false
            iv_fill_data           = abap_true
            iv_fill_failed_key     = abap_true
          IMPORTING
            et_data                = lt_property_dyn
            et_failed_key          = lt_failed_key
            eo_message             = eo_message ).
      ELSE.
*       calculate dynamic properties
        do_determinations_retrieve(
          EXPORTING
            iv_assoc_key           = ls_assoc-assoc_key
            it_key                 = lt_key
            iv_key_is_default      = abap_true
            is_parameters          = ls_property_parameter_r
            it_filtered_attributes = lt_filtered_attributes
            iv_state               = /bobf/if_conf_c=>sc_state_current
            iv_within_loading      = abap_false
          IMPORTING
            eo_message             = eo_message ).

*       read dynamic properties
        TRY.
            mo_buffer->retrieve_by_association(
              EXPORTING
                iv_node_key            = iv_node_key
                it_key                 = lt_key
                iv_association         = ls_assoc-assoc_key
                is_parameters          = ls_property_parameter_r
                it_filtered_attributes = lt_filtered_attributes
                iv_state               = lv_state
                iv_buffer_only         = abap_true
                iv_fill_data           = abap_true
                iv_fill_failed_key     = abap_true
              IMPORTING
                et_data                = lt_property_dyn
                et_failed_key          = lt_failed_key ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key
              it_key_subset = lt_failed_key ) = abap_true.

      LOOP AT lt_property_dyn ASSIGNING FIELD-SYMBOL(<ls_property_dyn>).
        <ls_property_dyn>-source = /bobf/if_conf_c=>sc_property_source_dynamic.
      ENDLOOP.
* ____________________________________________________________________ *
*     delete keys which have failed
      IF iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_key WHERE key = ls_key-key.
        ENDLOOP.
        IF lt_key IS INITIAL.
          ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>access_stack_stack_check(
                 it_access_stack = mt_access_stack ) = abap_true.
          RETURN.
        ENDIF.
      ENDIF.

* ____________________________________________________________________ *
*     delete read subtree properties (will be evaluated below)
      IF ls_nodeconf-subtree_property = abap_true.
        DELETE lt_property_dyn WHERE content_cat = /bobf/if_conf_c=>sc_content_subtree.
      ENDIF.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* evaluate subtree properties (only supported for root node)
  IF iv_key_is_default = abap_false AND
     ( ls_nodeconf-subtree_property_node_key IS NOT INITIAL OR
       ls_nodeconf-subtree_property = abap_true ) AND
    ( iv_check_services = /bobf/if_conf_c=>sc_retrieve_property OR
      iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn ).

    READ TABLE mt_node_properties_requested TRANSPORTING NO FIELDS
      WITH KEY key_sort COMPONENTS table_line = iv_node_key.
    IF sy-subrc <> 0.
      APPEND iv_node_key TO mt_node_properties_requested.
    ENDIF.

    retrieve_subtree_property(
      EXPORTING
        iv_node_key           = iv_node_key
        it_key                = lt_key
        iv_state              = lv_state
        iv_resolve_property   = abap_true
        iv_determine_property = abap_false
        iv_node_property      = iv_node_property
        iv_assoc_property     = iv_assoc_property
        it_assoc              = it_assoc
      IMPORTING
        et_property           = lt_property_subtree
        eo_message            = lo_message ).

    LOOP at lt_property_subtree ASSIGNING FIELD-SYMBOL(<ls_property_subtree>).
      <ls_property_subtree>-source = /bobf/if_conf_c=>sc_property_source_subtree.
    ENDLOOP.

    IF lt_property_dyn IS INITIAL.
      lt_property_dyn = lt_property_subtree.
    ELSE.
      INSERT LINES OF lt_property_subtree INTO lt_property_dyn INDEX 1.
    ENDIF.
  ENDIF.
* ____________________________________________________________________ *
* set status dependent properties
  IF iv_key_is_default            = abap_false AND
     ls_nodeconf-delegation_class  IS INITIAL  AND
     ( iv_check_services          = /bobf/if_conf_c=>sc_retrieve_property         OR
     iv_check_services            = /bobf/if_conf_c=>sc_check_services_stat_dyn ) AND
     mo_conf->ms_obj-status_class IS NOT INITIAL                                  AND
     ( iv_action_property         = abap_true                                     OR
     it_action                    IS NOT INITIAL ).

    CLEAR ls_assoc.
    IF ls_nodeconf-status_attributes    IS NOT BOUND OR
       ls_nodeconf-status_attributes->* IS INITIAL.
      mo_conf->get_assoc(
        EXPORTING
          iv_node_key   = ls_nodeconf-node_key
          iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
          iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
        IMPORTING
          es_assoc      = ls_assoc ).
    ENDIF.

    IF ( ls_nodeconf-status_attributes    IS BOUND         AND
         ls_nodeconf-status_attributes->* IS NOT INITIAL ) OR
         ls_assoc                         IS NOT INITIAL.

*     get status adapter
      IF mo_sam IS NOT BOUND.
        TRY.
            CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
              EXPORTING
                iv_bo_key = mo_conf->ms_obj-bo_key.

          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_cat = TEXT-004.
            CREATE OBJECT lx_frw
              EXPORTING
                previous       = lx_root
                textid         = /bobf/cx_frw_core=>sc_no_instance
                mv_classname   = mo_conf->ms_obj-status_class
                mv_content_cat = lv_content_cat.
            set_application_error( lx_frw ).
        ENDTRY.
        ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
      ENDIF.

      /bobf/cl_frw_int_access=>new_instance(
        EXPORTING
          io_bopf            = me
          io_conf            = mo_conf
          io_buffer          = mo_buffer
        RECEIVING
          eo_internal_access = lo_int_access
      ).

      lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
      lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
      lo_int_access->set_context( iv_read_allowed = abap_true ).
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      INSERT lo_int_access INTO mt_access_stack INDEX 1.

      TRY.
          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          mo_sam->get_properties(
            EXPORTING
              iv_node_key = iv_node_key
              it_key      = lt_key
              it_action   = it_action
              io_read     = lo_int_access
            IMPORTING
              et_property = lt_property_sam ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      lo_int_access->invalidate( ).
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.

      mo_conf->get_act(
        EXPORTING
          iv_node_key = iv_node_key
          iv_act_cat  = /bobf/if_conf_c=>sc_action_delete
        IMPORTING
          es_action   = ls_act_conf ).

      CLEAR ls_property.
      LOOP AT lt_property_sam ASSIGNING <ls_property> WHERE
           property_name = /bobf/if_conf_c=>sc_property_name_enabled AND
           value         = abap_false AND
           content_cat   = /bobf/if_conf_c=>sc_content_act.

        IF <ls_property>-content_key EQ ls_act_conf-act_key.
          ls_property-parent_key    = <ls_property>-parent_key.
          ls_property-content_cat   = /bobf/if_conf_c=>sc_content_nod.
          ls_property-content_key   = iv_node_key.
          ls_property-value         = <ls_property>-value.
          ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable.
          ls_property-source          = /bobf/if_conf_c=>sc_property_source_sam.
          INSERT ls_property INTO lt_property_dyn INDEX 1.
        ELSE.
          <ls_property>-source = /bobf/if_conf_c=>sc_property_source_sam.
          INSERT <ls_property> INTO lt_property_dyn INDEX 1.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* set lock dependent properties of nodes and/or associations
  IF iv_key_is_default          = abap_false                            AND
     iv_check_services          = /bobf/if_conf_c=>sc_retrieve_property AND
     ( iv_node_property         = abap_true                             OR
     iv_node_attribute_property = abap_true                             OR
     it_node_attribute          IS NOT INITIAL                          OR
     iv_assoc_property          = abap_true                             OR
     it_assoc                   IS NOT INITIAL )                        AND
     mo_conf->ms_obj-no_lock    = abap_false                            AND
     ls_nodeconf-transient      = abap_false                            AND
     ls_nodeconf-object_model_cds_view_name IS INITIAL. " ...not for CDS generated BOs (Draft, Existing)...

    map_to_node(
      EXPORTING
        iv_node_key = iv_node_key
        it_key      = lt_key
      IMPORTING
        et_node     = lt_node ).

    get_lockable_node(
      EXPORTING
        it_node      = lt_node
      IMPORTING
        et_node_link = lt_node_link
        eo_message   = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    LOOP AT lt_node_link INTO ls_node_link.
      ls_key-key = ls_node_link-target_key.
      APPEND ls_key TO lt_key_lock.
    ENDLOOP.

    IF lt_key_lock IS NOT INITIAL.
      SORT lt_key_lock BY key.
      DELETE ADJACENT DUPLICATES FROM lt_key_lock.

      mo_conf->get_assoc(
       EXPORTING
         iv_node_key   = ls_node_link-target_node
         iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_lock
         iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
       IMPORTING
         es_assoc      = ls_assoc ).

      retrieve_by_association(
        EXPORTING
          iv_node_key    = ls_node_link-target_node
          it_key         = lt_key_lock
          iv_association = ls_assoc-assoc_key
          iv_state       = lv_state
          iv_fill_data   = abap_true
        IMPORTING
          et_data        = lt_lock_node
          eo_message     = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      lt_key_lock = lt_key.

      LOOP AT lt_lock_node INTO ls_lock_node USING KEY edit_mode
        WHERE edit_mode = /bobf/if_conf_c=>sc_edit_exclusive.
        LOOP AT lt_node_link INTO ls_node_link
          WHERE target_node = ls_node_link-target_node
            AND target_key  = ls_lock_node-key.
*         Binary search can be used here as the table (LT_KEY) was sorted at the begiining of the method to eliminate duplicates
          READ TABLE lt_key_lock WITH KEY key = ls_node_link-source_key TRANSPORTING NO FIELDS BINARY SEARCH.
          IF sy-subrc = 0.
            DELETE lt_key_lock INDEX sy-tabix.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
      LOOP AT lt_lock_node INTO ls_lock_node USING KEY edit_mode
        WHERE edit_mode = /bobf/if_conf_c=>sc_edit_optimistic.
        LOOP AT lt_node_link INTO ls_node_link
          WHERE target_node = ls_node_link-target_node
            AND target_key  = ls_lock_node-key.
*         Binary search can be used here as the table (LT_KEY) was sorted at the begiining of the method to eliminate duplicates
          READ TABLE lt_key_lock WITH KEY key = ls_node_link-source_key TRANSPORTING NO FIELDS BINARY SEARCH.
          IF sy-subrc = 0.
            DELETE lt_key_lock INDEX sy-tabix.
          ENDIF.
        ENDLOOP.
      ENDLOOP.

* _______________________________________________________________________________ *
*     not locked nodes: set property value to false, leading entry -> at first
      CLEAR ls_property.
      LOOP AT lt_key_lock INTO ls_key.
        IF iv_node_property           = abap_true OR
           iv_node_attribute_property = abap_true OR
           it_node_attribute IS NOT INITIAL.

          ls_property-parent_key    = ls_key-key.
          ls_property-content_cat   = /bobf/if_conf_c=>sc_content_nod.
          ls_property-content_key   = iv_node_key.
          ls_property-value         = abap_false.
          ls_property-source        = /bobf/if_conf_c=>sc_property_source_lock.
          ls_property-property_name = /bobf/if_conf_c=>sc_property_name_update_enable.
          INSERT ls_property INTO lt_property_dyn INDEX 1.
          ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable.
          INSERT ls_property INTO lt_property_dyn INDEX 1.
        ENDIF.

        IF iv_assoc_property = abap_true OR
           it_assoc IS NOT INITIAL.
          IF lt_assoc IS INITIAL.
            mo_conf->get_assoc_tab(
              IMPORTING
                et_assoc           = lt_assoc ).
          ENDIF.
*         association properties
          ls_property-parent_key    = ls_key-key.
          ls_property-property_name = /bobf/if_conf_c=>sc_property_name_create_enable.
          ls_property-content_cat   = /bobf/if_conf_c=>sc_content_ass.
          ls_property-value         = abap_false.
          LOOP AT lt_assoc INTO ls_assoc
            WHERE source_node_key        = iv_node_key
              AND ( assoc_cat  = /bobf/if_conf_c=>sc_assoccat_specialization OR
                    assoc_cat  = /bobf/if_conf_c=>sc_assoccat_foreign_key OR
                    assoc_cat  = /bobf/if_conf_c=>sc_assoccat_foreign_key_r OR
                    assoc_cat  = /bobf/if_conf_c=>sc_assoccat_normal OR
                    assoc_type = /bobf/if_conf_c=>sc_assoctype_comp )
              AND target_node->lockable  = abap_false
              AND target_node->transient = abap_false.  "#EC CI_SORTSEQ
            ls_property-content_key = ls_assoc-assoc_key.
            ls_property-source        = /bobf/if_conf_c=>sc_property_source_lock.
            INSERT ls_property INTO lt_property_dyn INDEX 1.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
      CLEAR lt_key_lock.
    ENDIF.
  ENDIF.

  IF ls_nodeconf-delegation_class IS INITIAL.
* ____________________________________________________________________ *
*   get static properties
    IF lines( ls_nodeconf-node_cat->* ) = 1.
*     just one node category defined
      READ TABLE ls_nodeconf-node_cat->* INDEX 1 INTO ls_node_cat_c.
      mo_conf->get_property(
        EXPORTING
          iv_node_cat_key = ls_node_cat_c-node_cat_key
        IMPORTING
          et_property     = lt_property_ncat ).
      IF lt_property_ncat IS NOT INITIAL.
        restrict_property(
          EXPORTING
            iv_node_property             = iv_node_property
            iv_node_attribute_property   = iv_node_attribute_property
            it_node_attribute            = it_node_attribute
            iv_assoc_property            = iv_assoc_property
            it_assoc                     = it_assoc
            iv_assoc_attribute_property  = iv_assoc_attribute_property
            iv_action_property           = iv_action_property
            it_action                    = it_action
            iv_action_attribute_property = iv_action_attribute_property
            iv_query_property            = iv_query_property
            it_query                     = it_query
            iv_query_attribute_property  = iv_query_attribute_property
          CHANGING
            ct_property_data             = lt_property_ncat ).

*       create entries for each instance
        LOOP AT lt_key INTO ls_key.
          IF iv_check_services  = /bobf/if_conf_c=>sc_check_services_stat_dyn OR
             iv_check_services  = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre OR
             iv_check_services  = /bobf/if_conf_c=>sc_retrieve_property.
            LOOP AT lt_property_ncat INTO ls_property-node_data.
              ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
              ls_property-parent_key = ls_key-key.
              ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
              APPEND ls_property TO lt_property_stat.
            ENDLOOP.
          ELSEIF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat.
            LOOP AT lt_property_ncat INTO ls_property-node_data
              WHERE final = abap_true.                  "#EC CI_SORTSEQ
              ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
              ls_property-parent_key = ls_key-key.
              ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
              APPEND ls_property TO lt_property_stat.
            ENDLOOP.
          ENDIF.
        ENDLOOP.

      ENDIF.
    ELSE.

*     evaluate node categories
      TRY.
          mo_buffer->retrieve(
           EXPORTING
             iv_node_key    = iv_node_key
             it_key         = lt_key
             iv_state       = lv_state
             iv_fill_data   = abap_false
             iv_buffer_only = abap_true
           IMPORTING
             et_node_cat    = lt_node_cat ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      LOOP AT lt_node_cat INTO ls_node_cat.
        CHECK ls_node_cat-node_cat_key IS NOT INITIAL.

        AT NEW node_cat_key.
          mo_conf->get_property(
            EXPORTING
              iv_node_cat_key = ls_node_cat-node_cat_key
            IMPORTING
              et_property     = lt_property_ncat ).
          IF lt_property_ncat IS NOT INITIAL.
            restrict_property(
             EXPORTING
               iv_node_property             = iv_node_property
               iv_node_attribute_property   = iv_node_attribute_property
               it_node_attribute            = it_node_attribute
               iv_assoc_property            = iv_assoc_property
               it_assoc                     = it_assoc
               iv_assoc_attribute_property  = iv_assoc_attribute_property
               iv_action_property           = iv_action_property
               it_action                    = it_action
               iv_action_attribute_property = iv_action_attribute_property
               iv_query_property            = iv_query_property
               it_query                     = it_query
               iv_query_attribute_property  = iv_query_attribute_property
             CHANGING
               ct_property_data             = lt_property_ncat ).
          ENDIF.
        ENDAT.

        IF lt_property_ncat IS NOT INITIAL.

          IF iv_check_services  = /bobf/if_conf_c=>sc_check_services_stat_dyn OR
              iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
            LOOP AT lt_property_ncat INTO ls_property-node_data.
              ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
              ls_property-parent_key = ls_node_cat-key.
              ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
              APPEND ls_property TO lt_property_stat.
            ENDLOOP.
          ELSEIF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat OR
                 iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
            LOOP AT lt_property_ncat INTO ls_property-node_data WHERE
                final = abap_true.                      "#EC CI_SORTSEQ
              ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
              ls_property-parent_key = ls_node_cat-key.
              ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
              APPEND ls_property TO lt_property_stat.
            ENDLOOP.
          ENDIF.

        ENDIF.
      ENDLOOP.
    ENDIF.

* ____________________________________________________________________ *
*   get static proxy properties
    IF iv_check_services <> /bobf/if_conf_c=>sc_retrieve_property.
      mo_conf->get_property_prx(
        EXPORTING
          iv_node_key  = iv_node_key
        IMPORTING
          et_property  = lt_property_ncat ).
*     create entries for each instance
      IF lt_property_ncat IS NOT INITIAL.
        restrict_property(
          EXPORTING
            iv_node_property             = iv_node_property
            iv_node_attribute_property   = iv_node_attribute_property
            it_node_attribute            = it_node_attribute
            iv_assoc_property            = iv_assoc_property
            it_assoc                     = it_assoc
            iv_assoc_attribute_property  = iv_assoc_attribute_property
            iv_action_property           = iv_action_property
            it_action                    = it_action
            iv_action_attribute_property = iv_action_attribute_property
            iv_query_property            = iv_query_property
            it_query                     = it_query
            iv_query_attribute_property  = iv_query_attribute_property
          CHANGING
            ct_property_data             = lt_property_ncat ).

        LOOP AT lt_key INTO ls_key.
          IF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn  OR
             iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
            LOOP AT lt_property_ncat INTO ls_property-node_data.
              ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
              ls_property-parent_key = ls_key-key.
              ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
              APPEND ls_property TO lt_property_stat.
            ENDLOOP.
          ELSEIF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat.
            LOOP AT lt_property_ncat INTO ls_property-node_data WHERE
                final = abap_true.                      "#EC CI_SORTSEQ
              ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
              ls_property-parent_key = ls_key-key.
              ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
              APPEND ls_property TO lt_property_stat.
            ENDLOOP.
          ENDIF.
        ENDLOOP.

      ENDIF.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* set authority dependent properties
  IF iv_key_is_default = abap_false AND
     iv_check_services          = /bobf/if_conf_c=>sc_retrieve_property AND
     ( iv_action_property         = abap_true OR
       it_action                    IS NOT INITIAL ).

    mo_authority_handler->get_action_properties(
      EXPORTING
        iv_node_key     = iv_node_key
        it_key          = lt_key
        it_action       = it_action
        io_bopf         = me
        io_buffer       = mo_buffer
      IMPORTING
        et_property     = lt_property_auth_action
      CHANGING
        ct_access_stack = mt_access_stack
    ).

    LOOP AT lt_property_auth_action ASSIGNING <ls_property> WHERE
         property_name = /bobf/if_conf_c=>sc_property_name_enabled AND
         value         = abap_false AND
         content_cat   = /bobf/if_conf_c=>sc_content_act.
      <ls_property>-source = /bobf/if_conf_c=>sc_property_source_authority.
      INSERT <ls_property> INTO lt_property_dyn INDEX 1.
    ENDLOOP.

  ENDIF.

  IF iv_key_is_default = abap_false AND
       iv_check_services = /bobf/if_conf_c=>sc_retrieve_property AND
       iv_node_property = abap_true.

    CALL METHOD mo_authority_handler->get_node_properties
      EXPORTING
        iv_node_key     = iv_node_key
        it_key          = lt_key
        io_bopf         = me
        io_buffer       = mo_buffer
      IMPORTING
        et_property     = lt_property_auth_node
      CHANGING
        ct_access_stack = mt_access_stack.

    LOOP AT lt_property_auth_node ASSIGNING <ls_property>.
      <ls_property>-source = /bobf/if_conf_c=>sc_property_source_authority.
      INSERT <ls_property> INTO lt_property_dyn INDEX 1.
    ENDLOOP.

  ENDIF.

  IF iv_key_is_default = abap_false AND
     iv_check_services = /bobf/if_conf_c=>sc_retrieve_property AND
     ( iv_assoc_property = abap_true OR
       it_assoc IS NOT INITIAL ).

    CALL METHOD mo_authority_handler->get_association_properties
      EXPORTING
        iv_node_key    = iv_node_key
        it_key         = lt_key
        it_association = it_assoc
      IMPORTING
        et_property    = lt_property_auth_assoc.

    LOOP AT lt_property_auth_assoc ASSIGNING <ls_property>.
      <ls_property>-source = /bobf/if_conf_c=>sc_property_source_authority.
      INSERT <ls_property> INTO lt_property_dyn INDEX 1.
    ENDLOOP.

  ENDIF.

* ____________________________________________________________________ *
* combine properties
  IF eo_property IS BOUND.
    eo_property->get_property( IMPORTING et_property = lt_property_do ).
    CLEAR eo_property.
  ENDIF.

* dynamic overwrite static properties  -> append static at the end
*   sort and delete
*   keeping sequence stable 1. UNLOCKED/SAM, 2. Dynamic, 3. static, 4. DO
  IF lt_property_dyn IS NOT INITIAL.
    APPEND LINES OF lt_property_stat TO lt_property_dyn.
  ELSE.
    lt_property_dyn = lt_property_stat.
  ENDIF.

  IF lt_property_do IS NOT INITIAL.
    APPEND LINES OF lt_property_do TO lt_property_dyn.
  ENDIF.

  IF lt_property_dyn IS INITIAL.
    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.
    RETURN.
  ENDIF.

  SORT lt_property_dyn
    STABLE BY content_cat parent_key property_name content_key attribute_name.
  DELETE ADJACENT DUPLICATES FROM lt_property_dyn
    COMPARING content_cat parent_key property_name content_key attribute_name.

* copy to sorted defined table attribute
  lt_property_sorted = lt_property_dyn.

  CREATE OBJECT eo_property TYPE /bobf/cl_frw_property
    EXPORTING
      it_property        = lt_property_dyn
      it_property_sorted = lt_property_sorted.


  ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_service_layer~rollback_to_sync_point.

  DATA:
    lt_root_key TYPE        /bobf/t_frw_key,
    lt_key      TYPE        /bobf/t_frw_key,
    lo_change   TYPE REF TO /bobf/cl_frw_change,
    lx_root     TYPE REF TO cx_root.

  TRY.
      " get changes done so far
      mo_buffer->get_root_keys(
        IMPORTING
          et_root_key = lt_key ).

      mo_buffer->get_keys(
        EXPORTING
          iv_node_key = mo_conf->ms_obj-root_node_key
          iv_state    = /bobf/if_conf_c=>sc_state_current
        IMPORTING
          et_key      = lt_root_key ).

      SORT lt_root_key.
      DELETE ADJACENT DUPLICATES FROM lt_root_key.
      lo_change ?= /bobf/cl_frw_factory=>get_change( ).

      mo_buffer->compare_states(
        EXPORTING
          iv_node_key      = mo_conf->ms_obj-root_node_key
          it_key           = lt_key
          iv_state_current = /bobf/if_conf_c=>sc_state_database
          iv_state_before  = /bobf/if_conf_c=>sc_state_current
          iv_incl_subtree  = abap_true
          io_change        = lo_change ).

      " perform determinations 'cleanup'
      " on all changes done between the last and the current sync point
      do_determinations(
        EXPORTING
          iv_exectime   = /bobf/if_conf_c=>sc_time_cleanup
          io_change     = lo_change
          iv_keep_cache = abap_true ).

    CATCH /bobf/cx_frw.
  ENDTRY.

ENDMETHOD.


method /bobf/if_tra_clone~clone.
  data lo_buf        type ref to /bobf/if_tra_clone.
  data lo_bopf_clone TYPE REF TO /BOBF/cl_frw.
  SYSTEM-CALL OBJMGR CLONE me TO eo_clone.
  try.

      lo_bopf_clone ?= eo_clone.
      lo_buf  ?= lo_bopf_clone->mo_buffer.
      lo_bopf_clone->mo_buffer ?= lo_buf->clone( ).
    catch /bobf/cx_frw.
  endtry.
endmethod.


METHOD /bobf/if_tra_clone~destroy_clone.
ENDMETHOD.


method /BOBF/IF_TRA_CLONE~RESTORE_FROM_CLONE.
  DATA lo_buffer TYPE REF TO /bobf/if_tra_clone.
  lo_buffer ?= mo_buffer.
  lo_buffer->restore_from_clone( ).
endmethod.


 METHOD add_messages.

   DATA: lt_change   TYPE /bobf/t_frw_node,
         ls_change   TYPE /bobf/s_frw_node,
         lt_key      TYPE /bobf/t_frw_key,
         ls_key      TYPE /bobf/s_frw_key,
         lt_message  TYPE /bobf/t_frw_message_k,
         ls_message  TYPE /bobf/s_frw_message_k,
         lo_message  TYPE REF TO /bobf/cl_frw_message,
         lo_message2 TYPE REF TO /bobf/if_frw_message,
         ls_nodeconf TYPE /bobf/s_confro_node,
         ls_context  TYPE /bobf/s_frw_runtime_context.

   CHECK io_change IS BOUND.
   io_change->get_changes(
     EXPORTING
       iv_change_mode  = /bobf/if_frw_c=>sc_modify_create
     IMPORTING
       et_changed_node = lt_change ).

   LOOP AT lt_change INTO ls_change.
     ls_key-key = ls_change-key.
     INSERT ls_key INTO TABLE lt_key.

     AT END OF node.
       mo_conf->get_node(
         EXPORTING iv_node_key = ls_change-node
         IMPORTING es_node     = ls_nodeconf ).

       IF ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_message.
*        it's a message node change
         retrieve(
           EXPORTING
             iv_node_key    = ls_change-node
             it_key         = lt_key
             iv_state       = /bobf/if_conf_c=>sc_state_current
             iv_fill_data   = abap_true
           IMPORTING
             eo_message     = lo_message2
             et_data        = lt_message ).

         IF lo_message IS NOT BOUND.
           lo_message ?= /bobf/cl_frw_factory=>get_message( ).
         ENDIF.
         lo_message->/bobf/if_frw_message~add( lo_message2 ).
         LOOP AT lt_message INTO ls_message.
           lo_message->/bobf/if_frw_message~add_cm( ls_message-message ).
         ENDLOOP.
       ENDIF.
       CLEAR lt_key.
     ENDAT.
   ENDLOOP.

   IF lo_message IS BOUND.
     ls_context-consistency = abap_true.
     lo_message->set_context( ls_context ).
     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = co_message ).
   ENDIF.

 ENDMETHOD.


METHOD add_notifs_for_resolve_assoc.

  DATA:
    lt_target_key TYPE /bobf/t_frw_key,
    lo_message    TYPE REF TO /bobf/if_frw_message.

  ASSIGN ir_assoc->* TO FIELD-SYMBOL(<ls_assoc>).
  retrieve_by_association( EXPORTING iv_node_key    = <ls_assoc>-target_node_key
                                     it_key         = it_source_key
                                     iv_association = iv_resolve_assoc_key
                                     iv_state       = iv_state
                           IMPORTING eo_message     = lo_message
                                     et_target_key  = lt_target_key ).
  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = co_message ).

  ct_content_change = VALUE #( BASE ct_content_change
                               FOR wa_key IN lt_target_key
                                   ( key         = wa_key-key
                                     content_key = <ls_assoc>-assoc_key
                                     node_key    = <ls_assoc>-source_node_key
                                     change_mode = /bobf/if_frw_c=>sc_modify_association ) ).

ENDMETHOD.


METHOD ADD_TRIGGER_CONDITION.

  TYPES: BEGIN OF ty_stack,
           stack    TYPE i,
           node_key TYPE /BOBF/OBM_NODE_KEY,
           key      TYPE /BOBF/T_FRW_KEY,
         END OF ty_stack,
         tt_stack TYPE STANDARD TABLE OF ty_stack.

  DATA: ls_group               TYPE /BOBF/S_FRW_GROUP,
        ls_groupconf           TYPE /BOBF/S_CONFRO_GROUP,
        lt_comp                TYPE /BOBF/T_CONFRO_ASSOC2,
        ls_comp                TYPE /BOBF/S_CONFRO_ASSOC2,
        lt_stack               TYPE tt_stack,
        ls_stack               TYPE ty_stack,
        ls_stack_new           TYPE ty_stack,
        lv_current_stack       TYPE i,
        ls_key                 TYPE /BOBF/S_FRW_KEY.


  mo_conf->get_assoc_tab( IMPORTING et_comp = lt_comp ).

  LOOP AT it_group INTO ls_group.

    ls_key-key = ls_group-key.
    APPEND ls_key TO ls_stack-key.

    AT END OF group_key.
      mo_conf->get_group(
        EXPORTING
          iv_group_key = ls_group-group_key
        IMPORTING
          es_group     = ls_groupconf ).

      IF ls_groupconf-node_key IS INITIAL.
        ls_groupconf-node_key = mo_conf->ms_obj-root_node_key.
      ENDIF.

*     check whether the group node has to be added as check trigger as well
      READ TABLE ls_groupconf-val_trigger->* TRANSPORTING NO FIELDS
        WITH KEY table_line = ls_groupconf-node_key.
      IF sy-subrc = 0.
        io_change->add_change(
          EXPORTING
            iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CHECK
            iv_node_key    = ls_groupconf-node_key
            it_key         = ls_stack-key ).
      ENDIF.

*     build stack
      lv_current_stack  = 1.
      ls_stack-stack    = 1.
      ls_stack-node_key = ls_groupconf-node_key.
      APPEND ls_stack TO lt_stack.

      DO.
        LOOP AT lt_stack INTO ls_stack
          WHERE stack = lv_current_stack.

          LOOP AT lt_comp INTO ls_comp
            WHERE source_node_key = ls_stack-node_key.

            CHECK ls_comp-target_node->check_trigger          = abap_true
               OR ls_comp-target_node->check_trigger_subnodes = abap_true.

*           navigate composition
            retrieve_by_association(
              EXPORTING
                iv_node_key                 = ls_stack-node_key
                it_key                      = ls_stack-key
                iv_association              = ls_comp-assoc_key
                iv_state                    = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
              IMPORTING
                et_target_key               = ls_stack_new-key ).

            IF ls_stack_new-key IS NOT INITIAL.
              ls_stack_new-node_key = ls_comp-target_node_key.
              ls_stack_new-stack    = ls_stack-stack + 1.
              APPEND ls_stack_new TO lt_stack.

*             add trigger for this node to the change object
              READ TABLE ls_groupconf-val_trigger->* TRANSPORTING NO FIELDS
                WITH KEY table_line = ls_comp-target_node_key.
              IF sy-subrc = 0.
                io_change->add_change(
                  EXPORTING
                    iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CHECK
                    iv_node_key    = ls_comp-target_node_key
                    it_key         = ls_stack_new-key ).
              ENDIF.
            ENDIF.
          ENDLOOP.
        ENDLOOP.

        IF sy-subrc = 4. " no nodes exist in this level
          EXIT.
        ENDIF.
        lv_current_stack = lv_current_stack + 1.
      ENDDO.

      CLEAR: lt_stack, ls_stack.
    ENDAT.

  ENDLOOP.

ENDMETHOD.


 METHOD after_loading.

   DATA: lt_loaded_node_keyload TYPE /bobf/t_frw_node,
         ls_node                TYPE /bobf/s_frw_node,
         lt_loaded_key          TYPE /bobf/t_frw_key,
         ls_key                 TYPE /bobf/s_frw_key,
         lo_change              TYPE REF TO /bobf/cl_frw_change,
         lo_change_del          TYPE REF TO /bobf/cl_frw_change,
         lt_node_transfer       TYPE /bobf/t_frw_node,
         lt_node_deleted        TYPE /bobf/t_frw_node,
         lt_node_tmp            TYPE /bobf/t_frw_node,
         ls_conf_node           TYPE /bobf/s_confro_node,
         ls_sync_point          TYPE ty_sync_point,
         lx_root                TYPE REF TO cx_root,
         ls_obj                 TYPE /bobf/s_confro_obj.

   CLEAR: eo_message,
          et_failed_node,
          et_loaded_node.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>check_nested_after_load( iv_within_loading   = iv_within_loading
                                                      iv_loading_node_key = iv_loading_node_key
                                                      io_change           = io_change
                                                      io_conf             = mo_conf ).

   IF iv_within_loading = abap_false AND
      ( io_change->has_changes( /bobf/if_frw_c=>sc_modify_load )              = abap_true OR
        io_change->has_changes( /bobf/if_frw_c=>sc_modify_reload_int )        = abap_true OR
        io_change->has_changes( /bobf/if_frw_c=>sc_modify_reload_int_delete ) = abap_true OR
        ( mo_conf->ms_obj-has_authority_dets                           = abap_true AND
          io_change->has_changes( /bobf/if_frw_c=>sc_modify_load_key ) = abap_true ) ).

     do_determinations(
       EXPORTING
         iv_exectime   = /bobf/if_conf_c=>sc_time_after_loading
         iv_load_state = iv_load_state
         io_change     = io_change
       IMPORTING
         eo_message    = eo_message
         et_failed     = et_failed_node ).

     io_change->get_changes(
       EXPORTING
         iv_change_mode  = /bobf/if_frw_c=>sc_modify_load
       IMPORTING
         et_changed_node = et_loaded_node ).

     IF et_failed_node IS NOT INITIAL.

       unlock_lockable_nodes( et_failed_node ). "  CSN: 0120061532 291236 2014, 1486627 2014

*      unload failed objects
       TRY.
           mo_buffer->delete_state(
             EXPORTING
               it_node         = et_failed_node
               iv_incl_subtree = abap_false
               iv_state        = iv_load_state ).
         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           set_application_error( lx_root ).
       ENDTRY.

       IF mv_modifying_transaction = abap_true.
         LOOP AT et_loaded_node INTO ls_node.
           READ TABLE et_failed_node
             WITH KEY node = ls_node-node
                      key  = ls_node-key
             TRANSPORTING NO FIELDS.
           CHECK sy-subrc = 0.
           DELETE et_loaded_node.
         ENDLOOP.
       ENDIF.
     ENDIF.

*    transfer current state to other states for loaded nodes
     IF et_loaded_node IS NOT INITIAL AND
         mv_modifying_transaction = abap_true.

       IF iv_load_state <> /bobf/if_conf_c=>sc_state_current.
*        Make sure only to transfer instances that are not deleted in the target state
         lt_node_transfer = et_loaded_node.

         mo_conf->get_bo(
         IMPORTING
           es_obj = ls_obj ).

         IF ls_obj-delete_loads_data = abap_false.
           lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
           LOOP AT et_loaded_node INTO ls_node.
             AT NEW node.
               mo_conf->get_node(
                 EXPORTING
                   iv_node_key = ls_node-node
                 IMPORTING
                   es_node     = ls_conf_node ).
             ENDAT.
             IF ls_conf_node-transient = abap_false.
               ls_key-key = ls_node-key.
               INSERT ls_key INTO TABLE lt_loaded_key.
             ENDIF.
             AT END OF node.
               IF ls_conf_node-transient = abap_false.
                 TRY.
                     mo_buffer->compare_states(
                       EXPORTING
                         iv_node_key      = ls_node-node
                         it_key           = lt_loaded_key
                         iv_state_current = /bobf/if_conf_c=>sc_state_current
                         iv_state_before  = iv_load_state
                         io_change        = lo_change_del ).
                   CATCH cx_root INTO lx_root.           "#EC CATCH_ALL
                     set_application_error( lx_root ).
                 ENDTRY.
               ENDIF.
               CLEAR lt_loaded_key.
             ENDAT.
           ENDLOOP.
           lo_change_del->get_changes(
                EXPORTING
                  iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                IMPORTING
                  et_changed_node = lt_node_deleted ).
           LOOP AT lt_node_deleted INTO ls_node.
             DELETE lt_node_transfer WHERE table_line = ls_node.
           ENDLOOP.
         ENDIF.

         TRY.
             mo_buffer->transfer_state(
               EXPORTING
                 it_node         = lt_node_transfer
                 iv_incl_subtree = abap_false
                 iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_current ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.
       ENDIF.

       IF iv_load_state <> /bobf/if_conf_c=>sc_state_database.
*        No check for deleted instances necessary as they cannot be deleted in DB state
         TRY.
             mo_buffer->transfer_state(
               EXPORTING
                 it_node         = et_loaded_node
                 iv_incl_subtree = abap_false
                 iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_database ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.
       ENDIF.

       IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_determined AND
          mo_conf->ms_obj-last_det_state_not_relevant = abap_false.
         lt_node_transfer = et_loaded_node.
         IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
           lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
           CLEAR lt_node_tmp.
           LOOP AT lt_node_deleted INTO ls_node.
             ls_key-key = ls_node-key.
             INSERT ls_key INTO TABLE lt_loaded_key.
             AT END OF node.
               TRY.
                   mo_buffer->compare_states(
                     EXPORTING
                       iv_node_key      = ls_node-node
                       it_key           = lt_loaded_key
                       iv_state_current = /bobf/if_conf_c=>sc_state_last_determined
                       iv_state_before  = iv_load_state
                       io_change        = lo_change_del ).
                 CATCH cx_root INTO lx_root.             "#EC CATCH_ALL
                   set_application_error( lx_root ).
               ENDTRY.
               CLEAR lt_loaded_key.
             ENDAT.
           ENDLOOP.
           lo_change_del->get_changes(
                EXPORTING
                  iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                IMPORTING
                  et_changed_node = lt_node_tmp ).
           LOOP AT lt_node_tmp INTO ls_node.
             DELETE lt_node_transfer WHERE table_line = ls_node.
           ENDLOOP.
         ENDIF.

         TRY.
             mo_buffer->transfer_state(
               EXPORTING
                 it_node         = lt_node_transfer
                 iv_incl_subtree = abap_false
                 iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_last_determined ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.
       ENDIF.

       IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_validated AND
          mo_conf->ms_obj-last_val_state_not_relevant = abap_false.
         lt_node_transfer = et_loaded_node.
         IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
           lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
           CLEAR lt_node_tmp.
           LOOP AT lt_node_deleted INTO ls_node.
             ls_key-key = ls_node-key.
             INSERT ls_key INTO TABLE lt_loaded_key.
             AT END OF node.
               TRY.
                   mo_buffer->compare_states(
                     EXPORTING
                       iv_node_key      = ls_node-node
                       it_key           = lt_loaded_key
                       iv_state_current = /bobf/if_conf_c=>sc_state_last_validated
                       iv_state_before  = iv_load_state
                       io_change        = lo_change_del ).
                 CATCH cx_root INTO lx_root.             "#EC CATCH_ALL
                   set_application_error( lx_root ).
               ENDTRY.
               CLEAR lt_loaded_key.
             ENDAT.
           ENDLOOP.
           lo_change_del->get_changes(
                EXPORTING
                  iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                IMPORTING
                  et_changed_node = lt_node_tmp ).
           LOOP AT lt_node_tmp INTO ls_node.
             DELETE lt_node_transfer WHERE table_line = ls_node.
           ENDLOOP.
         ENDIF.
         TRY.
             mo_buffer->transfer_state(
             EXPORTING
               it_node         = lt_node_transfer
               iv_incl_subtree = abap_false
               iv_state_source = iv_load_state
               iv_state_dest   = /bobf/if_conf_c=>sc_state_last_validated ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.
       ENDIF.

       IF iv_load_state <> /bobf/if_conf_c=>sc_state_before_modification AND
           mv_before_modification_exists = abap_true.
         lt_node_transfer = et_loaded_node.
         IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
           lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
           CLEAR lt_node_tmp.
           LOOP AT lt_node_deleted INTO ls_node.
             ls_key-key = ls_node-key.
             INSERT ls_key INTO TABLE lt_loaded_key.
             AT END OF node.
               TRY.
                   mo_buffer->compare_states(
                     EXPORTING
                       iv_node_key      = ls_node-node
                       it_key           = lt_loaded_key
                       iv_state_current = /bobf/if_conf_c=>sc_state_before_modification
                       iv_state_before  = iv_load_state
                       io_change        = lo_change_del ).
                 CATCH cx_root INTO lx_root.             "#EC CATCH_ALL
                   set_application_error( lx_root ).
               ENDTRY.
               CLEAR lt_loaded_key.
             ENDAT.
           ENDLOOP.
           lo_change_del->get_changes(
                EXPORTING
                  iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                IMPORTING
                  et_changed_node = lt_node_tmp ).
           LOOP AT lt_node_tmp INTO ls_node.
             DELETE lt_node_transfer WHERE table_line = ls_node.
           ENDLOOP.
         ENDIF.

         TRY.
             mo_buffer->transfer_state(
               EXPORTING
                 it_node         = lt_node_transfer
                 iv_incl_subtree = abap_false
                 iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_before_modification ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.
       ENDIF.

     ENDIF.
     lo_change ?= io_change.
     lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_load ).
   ENDIF.

*  transfer current state to database state for loaded keys
   IF mv_modifying_transaction = abap_true.
     io_change->get_changes(
       EXPORTING
         iv_change_mode  = /bobf/if_frw_c=>sc_modify_load_key
       IMPORTING
         et_changed_node = lt_loaded_node_keyload ).
*    filter loaded key
     IF et_loaded_node IS NOT INITIAL.
       LOOP AT lt_loaded_node_keyload INTO ls_node.
         READ TABLE et_loaded_node
           WITH KEY node = ls_node-node
                    key  = ls_node-key
           TRANSPORTING NO FIELDS.
         CHECK sy-subrc = 0.
         DELETE lt_loaded_node_keyload.
       ENDLOOP.
     ENDIF.

     INSERT LINES OF lt_loaded_node_keyload INTO TABLE et_loaded_node.

     IF lt_loaded_node_keyload IS NOT INITIAL.

       "It is possible that loading a before image of a deleted node causes
       "a keyload change. (Test /BOBF/CL_TST_CONV_KEY_BEF_IMG->CONV_KEY_AFTER_DELETE)
       "In this specific case, we do not want to distribute
       "the loaded key to the other states:
       IF iv_load_state = /bobf/if_conf_c=>sc_state_database.
         " Make sure only to transfer instances that are not deleted
         lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
         CLEAR lt_loaded_key.
         LOOP AT lt_loaded_node_keyload INTO ls_node.
           ls_key-key = ls_node-key.
           INSERT ls_key INTO TABLE lt_loaded_key.
           AT END OF node.
             TRY.
                 mo_buffer->compare_states(
                   EXPORTING
                     iv_node_key      = ls_node-node
                     it_key           = lt_loaded_key
                     iv_state_current = /bobf/if_conf_c=>sc_state_current
                     iv_state_before  = iv_load_state
                     io_change        = lo_change_del ).
               CATCH cx_root INTO lx_root.               "#EC CATCH_ALL
                 set_application_error( lx_root ).
             ENDTRY.
             CLEAR lt_loaded_key.
           ENDAT.
         ENDLOOP.
         lo_change_del->get_changes(
              EXPORTING
                iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
              IMPORTING
                et_changed_node = lt_node_tmp ).
         LOOP AT lt_node_tmp INTO ls_node.
           DELETE lt_loaded_node_keyload WHERE table_line = ls_node.
         ENDLOOP.
       ENDIF.

       IF lt_loaded_node_keyload IS NOT INITIAL.

         IF iv_load_state <> /bobf/if_conf_c=>sc_state_current.
           TRY.
               mo_buffer->transfer_state(
                 EXPORTING
                   it_node         = lt_loaded_node_keyload
                   iv_incl_subtree = abap_false
                   iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_current ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.
         ENDIF.

         IF iv_load_state <> /bobf/if_conf_c=>sc_state_database.
           TRY.
               mo_buffer->transfer_state(
                 EXPORTING
                   it_node         = lt_loaded_node_keyload
                   iv_incl_subtree = abap_false
                   iv_state_source = iv_load_state
                   iv_state_dest   = /bobf/if_conf_c=>sc_state_database ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.
         ENDIF.

         IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_determined AND
            mo_conf->ms_obj-last_det_state_not_relevant = abap_false..
           TRY.
               mo_buffer->transfer_state(
                  EXPORTING
                    it_node         = lt_loaded_node_keyload
                    iv_incl_subtree = abap_false
                    iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_last_determined ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.
         ENDIF.

         IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_validated AND
            mo_conf->ms_obj-last_val_state_not_relevant = abap_false..
           TRY.
               mo_buffer->transfer_state(
                 EXPORTING
                   it_node         = lt_loaded_node_keyload
                   iv_incl_subtree = abap_false
                   iv_state_source = iv_load_state
               iv_state_dest   = /bobf/if_conf_c=>sc_state_last_validated ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.
         ENDIF.

         IF iv_load_state <> /bobf/if_conf_c=>sc_state_before_modification AND
             mv_before_modification_exists = abap_true.
           TRY.
               mo_buffer->transfer_state(
                 EXPORTING
                   it_node         = lt_loaded_node_keyload
                   iv_incl_subtree = abap_false
                   iv_state_source = iv_load_state
                 iv_state_dest   = /bobf/if_conf_c=>sc_state_before_modification ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.
         ENDIF.

       ENDIF.

       lo_change ?= io_change.
       lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key ).
     ENDIF.

   ELSE.
     io_change->get_changes(
       EXPORTING
         iv_change_mode  = /bobf/if_frw_c=>sc_modify_load_key
       IMPORTING
         et_changed_node = lt_loaded_node_keyload ).
     IF et_loaded_node IS INITIAL.
       et_loaded_node = lt_loaded_node_keyload.
     ELSE.
       INSERT LINES OF lt_loaded_node_keyload INTO TABLE et_loaded_node.
       DELETE ADJACENT DUPLICATES FROM et_loaded_node.
     ENDIF.

     lo_change ?= io_change.
     lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key ).
   ENDIF.

*  also transfer loaded nodes to existing sync states
   TRY.
       LOOP AT mt_sync_point INTO ls_sync_point.
         IF ls_sync_point-state IS NOT INITIAL AND ls_sync_point-state <> /bobf/if_conf_c=>sc_state_database.
           lt_node_transfer = et_loaded_node.
           IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
             lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
             CLEAR lt_node_tmp.
             LOOP AT lt_node_deleted INTO ls_node.
               ls_key-key = ls_node-key.
               INSERT ls_key INTO TABLE lt_loaded_key.
               AT END OF node.
                 TRY.
                     mo_buffer->compare_states(
                       EXPORTING
                         iv_node_key      = ls_node-node
                         it_key           = lt_loaded_key
                         iv_state_current = ls_sync_point-state
                         iv_state_before  = iv_load_state
                         io_change        = lo_change_del ).
                   CATCH cx_root INTO lx_root.           "#EC CATCH_ALL
                     set_application_error( lx_root ).
                 ENDTRY.
                 CLEAR lt_loaded_key.
               ENDAT.
             ENDLOOP.
             lo_change_del->get_changes(
                  EXPORTING
                    iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                  IMPORTING
                    et_changed_node = lt_node_tmp ).
             LOOP AT lt_node_tmp INTO ls_node.
               DELETE lt_node_transfer WHERE table_line = ls_node.
             ENDLOOP.
           ENDIF.
           mo_buffer->transfer_state(
             EXPORTING
               it_node         = lt_node_transfer
               iv_incl_subtree = abap_false
               iv_state_source = iv_load_state
               iv_state_dest   = ls_sync_point-state ).
         ENDIF.

         IF ls_sync_point-state_d IS NOT INITIAL AND ls_sync_point-state_d <> ls_sync_point-state.
           lt_node_transfer = et_loaded_node.
           IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
             lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
             CLEAR lt_node_tmp.
             LOOP AT lt_node_deleted INTO ls_node.
               ls_key-key = ls_node-key.
               INSERT ls_key INTO TABLE lt_loaded_key.
               AT END OF node.
                 TRY.
                     mo_buffer->compare_states(
                       EXPORTING
                         iv_node_key      = ls_node-node
                         it_key           = lt_loaded_key
                         iv_state_current = ls_sync_point-state_d
                         iv_state_before  = iv_load_state
                         io_change        = lo_change_del ).
                   CATCH cx_root INTO lx_root.           "#EC CATCH_ALL
                     set_application_error( lx_root ).
                 ENDTRY.
                 CLEAR lt_loaded_key.
               ENDAT.
             ENDLOOP.
             lo_change_del->get_changes(
                  EXPORTING
                    iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                  IMPORTING
                    et_changed_node = lt_node_tmp ).
             LOOP AT lt_node_tmp INTO ls_node.
               DELETE lt_node_transfer WHERE table_line = ls_node.
             ENDLOOP.
           ENDIF.
           mo_buffer->transfer_state(
             EXPORTING
               it_node         = lt_node_transfer
               iv_incl_subtree = abap_false
               iv_state_source = iv_load_state
               iv_state_dest   = ls_sync_point-state_d ).
         ENDIF.

         IF ls_sync_point-state_v IS NOT INITIAL AND ls_sync_point-state_v <> ls_sync_point-state.
           lt_node_transfer = et_loaded_node.
           IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
             lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
             CLEAR lt_node_tmp.
             LOOP AT lt_node_deleted INTO ls_node.
               ls_key-key = ls_node-key.
               INSERT ls_key INTO TABLE lt_loaded_key.
               AT END OF node.
                 TRY.
                     mo_buffer->compare_states(
                       EXPORTING
                         iv_node_key      = ls_node-node
                         it_key           = lt_loaded_key
                         iv_state_current = ls_sync_point-state_v
                         iv_state_before  = iv_load_state
                         io_change        = lo_change_del ).
                   CATCH cx_root INTO lx_root.           "#EC CATCH_ALL
                     set_application_error( lx_root ).
                 ENDTRY.
                 CLEAR lt_loaded_key.
               ENDAT.
             ENDLOOP.
             lo_change_del->get_changes(
                  EXPORTING
                    iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                  IMPORTING
                    et_changed_node = lt_node_tmp ).
             LOOP AT lt_node_tmp INTO ls_node.
               DELETE lt_node_transfer WHERE table_line = ls_node.
             ENDLOOP.
           ENDIF.
           mo_buffer->transfer_state(
             EXPORTING
               it_node         = lt_node_transfer
               iv_incl_subtree = abap_false
               iv_state_source = iv_load_state
               iv_state_dest   = ls_sync_point-state_v ).
         ENDIF.
       ENDLOOP.
     CATCH cx_root INTO lx_root.                         "#EC CATCH_ALL
       set_application_error( lx_root ).
   ENDTRY.

 ENDMETHOD.


 METHOD check_action.

   DATA: ls_actconf          TYPE /bobf/s_confro_act_list,
         ls_val              TYPE REF TO /bobf/s_confro_val_list,
         ls_val_class        TYPE ty_validation,
         ls_act_class        TYPE ty_action,
         ls_valread          TYPE /bobf/s_confro_read,
         ls_context_val      TYPE /bobf/s_frw_ctx_val,
         ls_context_act      TYPE /bobf/s_frw_ctx_act,
         ls_key              TYPE /bobf/s_frw_key,
         lt_key              TYPE /bobf/t_frw_key,
         lt_initial_key      TYPE /bobf/t_frw_key,
         lt_key_read         TYPE /bobf/t_frw_key,
         lt_failed_key       TYPE /bobf/t_frw_key,
         lt_failed_key_auth  TYPE /bobf/t_frw_key,
         lt_failed_key_all   TYPE /bobf/t_frw_key,
         lo_message          TYPE REF TO /bobf/if_frw_message,
         lo_message_int      TYPE REF TO /bobf/cl_frw_message,
         lv_last_state       TYPE /bobf/conf_state,
         lv_state            TYPE /bobf/conf_state,
         lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
         lt_nodecat          TYPE /bobf/t_frw_node_cat,
         ls_nodecat          TYPE /bobf/s_frw_node_cat,
         lt_sta_var          TYPE /bobf/t_confro_sta_var,
         lx_root             TYPE REF TO cx_root,
         lx_frw_core         TYPE REF TO /bobf/cx_frw_core,
         lx_frw              TYPE REF TO /bobf/cx_frw,
         lv_content_cat      TYPE string,
         lv_content_name     TYPE /bobf/obm_name,
         lv_empty_string     TYPE string,
         lo_property         TYPE REF TO /bobf/if_frw_property,
         lt_property         TYPE /bobf/t_frw_property_k_sorted,
         ls_runtime_context  TYPE /bobf/s_frw_runtime_context,
         ls_location         TYPE /bobf/s_frw_location,
         lm_common_esi       TYPE REF TO /bobf/cm_frw_common_esi,
         lo_delegation       TYPE REF TO /bobf/if_frw_delegation,
         ls_action           TYPE /bobf/s_frw_action,
         lv_rejected         TYPE boole_d,
         lv_class            TYPE seoclsname,
         lv_application_info TYPE string.


   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

   CLEAR: et_failed_key,
          eo_message.

   lt_initial_key = ct_key.

   IF is_context IS INITIAL.
     IF mo_conf->ms_last_action-act_key NE iv_act_key OR
         iv_act_key IS INITIAL.
       mo_conf->get_act(
         EXPORTING
           iv_act_key  = iv_act_key
           iv_node_key = iv_node_key
           iv_act_cat  = iv_act_cat
         IMPORTING
           es_action   = ls_actconf ).
     ELSE.
       ls_actconf = mo_conf->ms_last_action.
     ENDIF.
     ls_context_act-bo_key        = mo_conf->ms_obj-bo_key.
     ls_context_act-root_node_key = mo_conf->ms_obj-root_node_key.
     ls_context_act-node_key      = ls_actconf-node_key.
     ls_context_act-act_key       = ls_actconf-act_key.
     ls_context_act-act_cat       = ls_actconf-act_cat.

   ELSE.
     IF mo_conf->ms_last_action-act_key NE is_context-act_key.
       mo_conf->get_act(
         EXPORTING
           iv_act_key = is_context-act_key
         IMPORTING
           es_action  = ls_actconf ).
     ELSE.
       ls_actconf = mo_conf->ms_last_action.
     ENDIF.
     ls_context_act = is_context.
   ENDIF.

   IF ls_actconf IS INITIAL.
*      unknown action
     set_application_error( ).
   ENDIF.

*  ____________________________________________________________________ *
*  check for delegated action
   IF mo_conf->ms_last_node-node_key <> ls_actconf-node_key.
     mo_conf->get_node( iv_node_key = ls_actconf-node_key ).
   ENDIF.
   IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
*    delegate action
     TRY.
         lo_delegation = get_delegation( ls_actconf-node_key ).
         ls_action-act_key    = iv_act_key.
         ls_action-key        = ct_key.
         ls_action-parameters = is_parameters.
         DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
         lo_delegation->check_action(
           EXPORTING
             is_action     = ls_action
           IMPORTING
             eo_message    = eo_message
             et_failed_key = et_failed_key ).
         /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.
     RETURN.
   ENDIF.

   IF ls_actconf-act_cat  = /bobf/if_conf_c=>sc_action_delete OR
       ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_update OR
       ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_create.
     lv_last_state = /bobf/if_conf_c=>sc_state_before_modification.
     CALL METHOD mo_authority_handler->check_authority_for_modify
       EXPORTING
         io_bopf         = me
         io_buffer       = mo_buffer
         io_change       = io_change
         is_act_conf     = ls_actconf
       IMPORTING
         et_failed_key   = lt_failed_key_auth
       CHANGING
         ct_key          = ct_key
         co_message      = eo_message
         ct_access_stack = mt_access_stack.
     APPEND LINES OF lt_failed_key_auth TO lt_failed_key_all.
   ELSE.
     lv_last_state = /bobf/if_conf_c=>sc_state_database.
   ENDIF.

*  ____________________________________________________________________ *
*  prepare action
   IF ls_actconf-act_class IS NOT INITIAL AND
       ls_actconf-prepare_impl = abap_true.

*    create internal access object for action
     CREATE OBJECT lo_int_access
       EXPORTING
         io_bopf   = me
         io_conf   = mo_conf
         io_buffer = mo_buffer
         io_change = io_change.
     lo_int_access->set_last_state( iv_last_state = lv_last_state ).
     lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).

     ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
     INSERT lo_int_access INTO mt_access_stack INDEX 1.

*    get action class
     READ TABLE mt_action
       WITH TABLE KEY act_key = ls_actconf-act_key
       INTO ls_act_class.
     IF sy-subrc <> 0.
       ls_act_class-act_key = ls_actconf-act_key.
       TRY.
           CREATE OBJECT ls_act_class-class TYPE (ls_actconf-act_class).
         CATCH cx_sy_create_object_error INTO lx_root.
           lv_content_name = get_content_description(
             iv_act = abap_true
             iv_key = ls_actconf-act_key ).
           lv_content_cat = TEXT-000.
           lv_class = ls_actconf-act_class.
           lcl_error_text_provider=>get_text_impl_class_error(
             EXPORTING
               iv_content_cat      = /bobf/if_conf_c=>sc_content_act
               iv_content_key      = ls_actconf-act_key
               iv_node_key         = ls_actconf-node_key
               iv_content_name     = lv_content_name
               iv_content_class    = lv_class
               iv_method_name      = 'PREPARE'
               io_configuration    = mo_conf
             RECEIVING
               rv_application_info = lv_application_info
           ).
           CREATE OBJECT lx_frw_core
             EXPORTING
               previous                   = lx_root
               textid                     = /bobf/cx_frw_core=>sc_no_instance
               mv_classname               = ls_actconf-act_class
               mv_content_name            = lv_content_name
               mv_content_cat             = lv_content_cat
               mv_application_information = lv_application_info.
           set_configuration_error( lx_frw ).
       ENDTRY.

       INSERT ls_act_class INTO TABLE mt_action.
     ENDIF.

     lo_int_access->set_context(
        is_action        = ls_context_act
        iv_read_allowed  = abap_true
        iv_check_allowed = abap_true ).

     /bobf/cl_tool_assert=>is_message_cleared_stack_set( io_message = lo_message ).

     TRY.
         lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
         ls_act_class-class->prepare(
           EXPORTING
             is_ctx        = ls_context_act
             io_read       = lo_int_access
             io_check      = lo_int_access
             is_parameters = is_parameters
           IMPORTING
             eo_message    = lo_message
           CHANGING
             ct_key        = ct_key ).
         /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         lv_content_name = get_content_description(
           iv_act = abap_true
           iv_key = ls_actconf-act_key ).
         lv_content_cat = TEXT-000.
         CREATE OBJECT lx_frw_core
           EXPORTING
             previous        = lx_root
             textid          = /bobf/cx_frw_core=>sc_content_exception
             mv_node         = ls_actconf-node_key
             mv_method_name  = 'PREPARE'
             mv_content_name = lv_content_name
             mv_content_cat  = lv_content_cat.
         set_application_error( lx_frw_core ).
     ENDTRY.

     /bobf/cl_tool_assert=>is_message_cleared_stack_check( io_message = lo_message ).

     lo_int_access->invalidate( ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).
   ENDIF.

*  ____________________________________________________________________ *
*  check action properties
   IF iv_check_property                 = abap_true                               AND
       ct_key                           IS NOT INITIAL                            AND
       ( mo_conf->ms_obj-chk_serv_action = /bobf/if_conf_c=>sc_check_services_stat OR
       mo_conf->ms_obj-chk_serv_action   = /bobf/if_conf_c=>sc_check_services_stat_dyn ).

     " [customer incident 0020079747 0000036035 2016, transportation management, performance]
     " give the implementation of RETRIEVE_PROPERTY the chance, to calculate properties
     " more specific and performant by handing over the concrete action. especially
     " when SAM is in the game, this should gain some performance...
     IF ls_context_act-act_key IS NOT INITIAL.
       DATA(lv_action_property) = abap_false. " TRUE would request ALL action properties...
       DATA(lt_action)          = VALUE /bobf/t_frw_key2( ( ls_context_act-act_key ) ).
     ELSE.
       lv_action_property       = abap_true.
     ENDIF.

     /bobf/if_frw_service_layer~retrieve_property(
       EXPORTING
         iv_node_key        = ls_actconf-node_key
         it_key             = ct_key
         iv_check_services  = mo_conf->ms_obj-chk_serv_action
         iv_action_property = lv_action_property
         it_action          = lt_action
       IMPORTING
         eo_property        = lo_property
         eo_message         = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

     IF lo_property IS BOUND.
       lo_property->get_property( IMPORTING et_property_sorted = lt_property ).
       LOOP AT ct_key INTO ls_key.
         READ TABLE lt_property WITH KEY
             content_cat    = /bobf/if_conf_c=>sc_content_act
             parent_key     = ls_key-key
             property_name  = /bobf/if_conf_c=>sc_property_name_enabled
             content_key    = ls_context_act-act_key
             attribute_name = lv_empty_string
             value          = abap_false
             TRANSPORTING NO FIELDS.
         IF sy-subrc = 0.
           ls_location-node_key = ls_actconf-node_key.
           ls_location-key      = ls_key-key.
           IF ls_actconf-act_esr_name IS INITIAL.
             lv_content_name    = ls_actconf-act_name.
           ELSE.
             lv_content_name    = ls_actconf-act_esr_name.
           ENDIF.
           CREATE OBJECT lm_common_esi
             EXPORTING
               textid                = /bobf/cm_frw_common_esi=>cm_action_disabled
               severity              = /bobf/cm_frw=>co_severity_error
               symptom               = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
               lifetime              = /bobf/cm_frw=>co_lifetime_transition
               ms_origin_location    = ls_location
               cmn_action_proxy_name = lv_content_name.
           IF eo_message IS NOT BOUND.
             eo_message = /bobf/cl_frw_factory=>get_message( ).
           ENDIF.
           eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
           DELETE ct_key.
           APPEND ls_key TO lt_failed_key_all.
         ENDIF.
       ENDLOOP.
     ENDIF.
   ENDIF.

   IF ct_key IS INITIAL.
     IF lo_int_access IS BOUND.
       ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
       DELETE mt_access_stack INDEX 1.
     ENDIF.
     IF ls_actconf-exec_only_all EQ abap_false.
       et_failed_key = lt_failed_key_all.
     ELSE.
       et_failed_key = lt_initial_key.
     ENDIF.
     RETURN.
   ENDIF.

*  ____________________________________________________________________ *
*  check node category of instances vs. node category of action
   check_action_node_category(
     EXPORTING
       is_conf_action = ls_actconf
       is_conf_node   = mo_conf->ms_last_node
       iv_last_state  = lv_last_state
     CHANGING
       ct_key         = ct_key
       ct_failed_key  = lt_failed_key_all
       co_message     = eo_message ).

*  ____________________________________________________________________ *
*  check action in status & action management
   IF mo_conf->ms_obj-status_class IS NOT INITIAL AND
    ( ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_standard OR
      ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_delete ).

*    Check if there are any status variabled on this node -> Node is SAM relevant
     mo_conf->get_status_variables(
       IMPORTING
         et_sta_var = lt_sta_var ).
     READ TABLE lt_sta_var WITH KEY node_key COMPONENTS node_key = ls_context_act-node_key TRANSPORTING NO FIELDS.
     IF sy-subrc = 0.

       IF mo_sam IS NOT BOUND.
         TRY.
             CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
               EXPORTING
                 iv_bo_key = mo_conf->ms_obj-bo_key.

           CATCH cx_sy_create_object_error INTO lx_root.
             lv_content_cat = TEXT-004.
             CREATE OBJECT lx_frw_core
               EXPORTING
                 previous       = lx_root
                 textid         = /bobf/cx_frw_core=>sc_no_instance
                 mv_classname   = mo_conf->ms_obj-status_class
                 mv_content_cat = lv_content_cat.
             set_configuration_error( lx_frw_core ).
         ENDTRY.
       ENDIF.

*    create internal access object for action
       IF lo_int_access IS NOT BOUND.
         CREATE OBJECT lo_int_access
           EXPORTING
             io_bopf   = me
             io_conf   = mo_conf
             io_buffer = mo_buffer.
         lo_int_access->set_last_state( iv_last_state = lv_last_state ).
         lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
         ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
         INSERT lo_int_access INTO mt_access_stack INDEX 1.
       ENDIF.

       ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

       lo_int_access->set_context(
          is_action       = ls_context_act
          iv_read_allowed = abap_true ).

       TRY.
           lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
           mo_sam->check_action(
             EXPORTING
               iv_act_key    = ls_actconf-act_key
               it_key        = ct_key
               io_read       = lo_int_access
             IMPORTING
               et_failed_key = lt_failed_key
               eo_message    = lo_message ).
           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
         CATCH /bobf/cx_frw INTO lx_frw.
           set_application_error( lx_frw ).
       ENDTRY.

       ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>is_key_subset(
               it_key_set    = ct_key
               it_key_subset = lt_failed_key ) = abap_true.
       ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ) = abap_true.

       lo_int_access->invalidate( ).

       APPEND LINES OF lt_failed_key TO lt_failed_key_all.

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).

     ENDIF.
   ENDIF.

*  ____________________________________________________________________ *
*  validate all

   IF iv_check_validation = abap_true.
     IF ls_actconf-act_cat        = /bobf/if_conf_c=>sc_action_delete AND
         mv_modifying_transaction = abap_true.
       lv_state = /bobf/if_conf_c=>sc_state_before_modification.
     ELSE.
       lv_state = /bobf/if_conf_c=>sc_state_current.
     ENDIF.

     ls_context_val-bo_key         = mo_conf->ms_obj-bo_key.
     ls_context_val-root_node_key  = mo_conf->ms_obj-root_node_key.
     ls_context_val-act_key        = ls_actconf-act_key.
     ls_context_val-act_parameters = is_parameters.

     LOOP AT ls_actconf-val_list->* REFERENCE INTO ls_val.
       lt_key = ct_key.

*  ____________________________________________________________________ *
*    filter keys regarding their node category
       IF ls_val->node_cat->* IS NOT INITIAL.
         IF lt_nodecat IS INITIAL.
           retrieve(
             EXPORTING
               iv_node_key    = ls_actconf-node_key
               it_key         = ct_key
               iv_state       = lv_state
               iv_fill_data   = abap_false
             IMPORTING
               et_node_cat    = lt_nodecat
               eo_message     = lo_message ).

           collect_messages( EXPORTING io_message = lo_message
                             CHANGING  co_message = eo_message ).
         ENDIF.

         LOOP AT lt_nodecat INTO ls_nodecat.
*        check if node category is valid
           READ TABLE ls_val->node_cat->*
             WITH KEY node_cat_key = ls_nodecat-node_cat_key
             TRANSPORTING NO FIELDS.
           IF sy-subrc <> 0.
             DELETE TABLE lt_key WITH TABLE KEY key = ls_nodecat-key.
           ENDIF.
         ENDLOOP.
         IF lt_key IS INITIAL.
           CONTINUE.
         ENDIF.
       ENDIF.

*  ____________________________________________________________________ *
*    if action check execution only if not failed
*    => kick out already failed keys
       IF ls_val->no_exec_if_fail = abap_true.
         LOOP AT lt_failed_key_all INTO ls_key.
           DELETE TABLE lt_key WITH TABLE KEY key = ls_key-key.
         ENDLOOP.
         IF lt_key IS INITIAL.
           CONTINUE.
         ENDIF.
       ENDIF.

*  ____________________________________________________________________ *
*    build up context for validation implementation
       ls_context_val-node_key       = ls_val->node_key.
       ls_context_val-val_key        = ls_val->val_key.

*    create internal access object for action
       IF lo_int_access IS NOT BOUND.
         CREATE OBJECT lo_int_access
           EXPORTING
             io_bopf   = me
             io_conf   = mo_conf
             io_buffer = mo_buffer.
         lo_int_access->set_last_state( iv_last_state = lv_last_state ).
         lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
         ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
         INSERT lo_int_access INTO mt_access_stack INDEX 1.
       ENDIF.

*    get validation class
       READ TABLE mt_validation
          WITH TABLE KEY val_key = ls_val->val_key
          INTO ls_val_class.
       IF sy-subrc <> 0.
         ls_val_class-val_key = ls_val->val_key.
         TRY.
             CREATE OBJECT ls_val_class-class TYPE (ls_val->val_class).

           CATCH cx_sy_create_object_error INTO lx_root.
             lv_content_name = get_content_description(
               iv_val = abap_true
               iv_key = ls_val->val_key ).
             lv_content_cat = TEXT-003.
             CREATE OBJECT lx_frw_core
               EXPORTING
                 previous        = lx_root
                 textid          = /bobf/cx_frw_core=>sc_no_instance
                 mv_classname    = ls_actconf-act_class
                 mv_content_cat  = lv_content_cat
                 mv_content_name = lv_content_name.
             set_configuration_error( lx_frw_core ).
         ENDTRY.
         INSERT ls_val_class INTO TABLE mt_validation.
       ENDIF.

*  ____________________________________________________________________ *
*    call method CHECK_DELTA (only for Create/Update/Delete)
       IF ls_val->check_delta_impl = abap_true                         AND
           ( ls_actconf-act_cat    = /bobf/if_conf_c=>sc_action_create OR
           ls_actconf-act_cat      = /bobf/if_conf_c=>sc_action_update OR
           ls_actconf-act_cat      = /bobf/if_conf_c=>sc_action_delete OR
           ls_actconf-act_cat      = /bobf/if_conf_c=>sc_action_save ).
         lo_int_access->set_context(
             is_validation   = ls_context_val
             iv_read_allowed = abap_true ).
         TRY.
             lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
             ls_val_class-class->check_delta(
             EXPORTING
               io_read = lo_int_access
               is_ctx  = ls_context_val
             CHANGING
               ct_key  = lt_key ).
             /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             lv_content_name = get_content_description(
               iv_val = abap_true
               iv_key = ls_val->val_key ).
             lv_content_cat = TEXT-003.
             lv_class = ls_actconf-act_class.
             lcl_error_text_provider=>get_text_impl_class_error(
               EXPORTING
                 iv_content_cat      = /bobf/if_conf_c=>sc_content_val
                 iv_content_key      = ls_val->val_key
                 iv_node_key         = ls_val->node_key
                 iv_content_name     = lv_content_name
                 iv_content_class    = lv_class
                 iv_method_name      = 'CHECK_DELTA'
                 io_configuration    = mo_conf
               RECEIVING
                 rv_application_info = lv_application_info
             ).
             CREATE OBJECT lx_frw_core
               EXPORTING
                 previous                   = lx_root
                 textid                     = /bobf/cx_frw_core=>sc_content_exception
                 mv_node                    = ls_actconf-node_key
                 mv_method_name             = 'CHECK_DELTA'
                 mv_content_name            = lv_content_name
                 mv_content_cat             = lv_content_cat
                 mv_application_information = lv_application_info.
             set_application_error( lx_root ).
         ENDTRY.
         lo_int_access->invalidate( ).
         IF lt_key IS INITIAL.
           CONTINUE.
         ENDIF.
       ENDIF.

*  ____________________________________________________________________ *
*    check if all required nodes are loaded

       LOOP AT ls_val->val_read->* INTO ls_valread.
         IF ls_valread-assoc IS BOUND.
*        association defined from node to be determined to read-node
*        -> retrieve keys of read-nodes
           retrieve_by_association(
             EXPORTING
               iv_node_key    = ls_val->node_key
               it_key         = lt_key
               iv_association = ls_valread-assoc->assoc_key
               iv_state       = lv_state
             IMPORTING
               eo_message     = lo_message
               et_target_key  = lt_key_read ).
           collect_messages( EXPORTING io_message = lo_message
                             CHANGING  co_message = eo_message ).
         ELSE.
*        own node
           lt_key_read = lt_key.
         ENDIF.

         retrieve(
           EXPORTING
             iv_node_key    = ls_valread-node_key
             it_key         = lt_key_read
             iv_state       = lv_state
             iv_fill_data   = abap_false
           IMPORTING
             eo_message     = lo_message ).
         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).
       ENDLOOP.

       IF ls_val->check_impl = abap_true.

*  ____________________________________________________________________ *
*    call method CHECK
         lo_int_access->set_context(
             is_validation   = ls_context_val
             iv_read_allowed = abap_true ).
         TRY.
             lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
             ls_val_class-class->check(
                 EXPORTING
                   io_read = lo_int_access
                   is_ctx  = ls_context_val
                 CHANGING
                   ct_key  = lt_key ).
             /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             lv_content_name = get_content_description(
               iv_val = abap_true
               iv_key = ls_val->val_key ).
             lv_content_cat = TEXT-003.
             lv_class = ls_val->val_class.
             lcl_error_text_provider=>get_text_impl_class_error(
               EXPORTING
                 iv_content_cat      = /bobf/if_conf_c=>sc_content_val
                 iv_content_key      = ls_val->val_key
                 iv_node_key         = iv_node_key
                 iv_content_name     = lv_content_name
                 iv_content_class    = lv_class
                 iv_method_name      = 'CHECK'
                 io_configuration    = mo_conf
               RECEIVING
                 rv_application_info = lv_application_info
             ).
             CREATE OBJECT lx_frw_core
               EXPORTING
                 previous                   = lx_root
                 textid                     = /bobf/cx_frw_core=>sc_content_exception
                 mv_node                    = ls_actconf-node_key
                 mv_method_name             = 'CHECK'
                 mv_content_name            = lv_content_name
                 mv_content_cat             = lv_content_cat
                 mv_application_information = lv_application_info.
             set_application_error( lx_frw_core ).
         ENDTRY.
         lo_int_access->invalidate( ).

         IF lt_key IS INITIAL.
           CONTINUE.
         ENDIF.
       ENDIF.

*  ____________________________________________________________________ *
*    call method EXECUTE
       lo_int_access->set_context(
           is_validation   = ls_context_val
           iv_read_allowed = abap_true ).

       " this method always execute the action_validation
       IF ls_context_val-act_key IS NOT INITIAL.
         ls_context_val-val_time = /bobf/if_conf_c=>sc_val_time_action.
       ENDIF.

       TRY.
           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

           lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
           ls_val_class-class->execute(
             EXPORTING
               is_ctx        = ls_context_val
               it_key        = lt_key
               io_read       = lo_int_access
             IMPORTING
               et_failed_key = lt_failed_key
               eo_message    = lo_message ).
           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_key_subset(
                   it_key_set    = lt_key
                   it_key_subset = lt_failed_key ) = abap_true.
           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_message_cleared_stack_check(
                   io_message    = lo_message )    = abap_true.
           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>failed_key_message(
                   io_message    = lo_message
                   it_failed_key = lt_failed_key ) = abap_true.

         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           lv_content_name = get_content_description(
             iv_val = abap_true
             iv_key = ls_val->val_key ).
           lv_content_cat = TEXT-003.
           lv_class = ls_val->val_class.
           lcl_error_text_provider=>get_text_impl_class_error(
             EXPORTING
               iv_content_cat      = /bobf/if_conf_c=>sc_content_val
               iv_content_key      = ls_val->val_key
               iv_node_key         = ls_val->node_key
               iv_content_name     = lv_content_name
               iv_content_class    = lv_class
               iv_method_name      = 'EXECUTE'
               io_configuration    = mo_conf
             RECEIVING
               rv_application_info = lv_application_info
           ).
           CREATE OBJECT lx_frw_core
             EXPORTING
               previous                   = lx_root
               textid                     = /bobf/cx_frw_core=>sc_content_exception
               mv_method_name             = 'EXECUTE'
               mv_content_name            = lv_content_name
               mv_content_cat             = lv_content_cat
               mv_application_information = lv_application_info.
           set_application_error( lx_frw_core ).
       ENDTRY.

       APPEND LINES OF lt_failed_key TO lt_failed_key_all.

       lo_int_access->invalidate( ).

*    fill message
       create_durable_msg_container( CHANGING co_message = lo_message ).
       IF lo_message IS BOUND.
         lo_message_int ?= lo_message.
         ls_runtime_context-bo_key   =  mo_conf->ms_obj-bo_key.
         ls_runtime_context-node_key = ls_context_val-node_key.
         ls_runtime_context-val_key  = ls_context_val-val_key.
         lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key ).
         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).
       ENDIF.

     ENDLOOP.
   ENDIF.

   IF lo_int_access IS BOUND.
     ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
     DELETE mt_access_stack INDEX 1.
   ENDIF.

   IF lt_failed_key_all IS NOT INITIAL.
     IF ls_actconf-exec_only_all = abap_true.
       et_failed_key = lt_initial_key.
       CLEAR ct_key.
     ELSE.
       SORT lt_failed_key_all.
       DELETE ADJACENT DUPLICATES FROM lt_failed_key_all.
       LOOP AT lt_failed_key_all INTO ls_key.
         READ TABLE lt_initial_key WITH KEY key_sort
           COMPONENTS key = ls_key-key TRANSPORTING NO FIELDS.
         IF sy-subrc = 0.
           APPEND ls_key TO et_failed_key.
         ENDIF.
         DELETE ct_key WHERE key = ls_key-key.
       ENDLOOP.
     ENDIF.
   ENDIF.

 ENDMETHOD.


 METHOD check_action_node_category.

   " first of all check, if it's no framework action (save runtime)...
   IF is_conf_action-act_cat <> /bobf/if_conf_c=>sc_action_standard.
     RETURN. " !!!
   ENDIF.

   " secondly check, if there's more than one node category defined (save runtime)...
   IF is_conf_node-node_cat IS BOUND.
     IF lines( is_conf_node-node_cat->* ) <= 1.
       RETURN. " !!!
     ENDIF.
   ENDIF.

   " check, if it's no CONF MODEL action (partly results in errors)...
   IF mo_conf->ms_obj-bo_key = /bobf/if_conf_obj_c=>sc_bo_key.
     RETURN. " !!!
   ENDIF.

   " be gracious, new component NODE_CAT may no exist in SHM...
   IF is_conf_action-node_cat IS NOT BOUND.
     RETURN. " !!!
   ENDIF.


   " >>>>> check node category of instances vs. node category of action...

   " get node category of instances...
   get_node_cat(
     EXPORTING
       iv_node_key      = is_conf_action-node_key
       it_key           = ct_key
       iv_current_state = /bobf/if_conf_c=>sc_state_current
       iv_last_state    = iv_last_state
     IMPORTING
       et_nodecat       = DATA(lt_node_cat)
       eo_message       = DATA(lo_message) ).
   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = co_message ).

   " check node categories...
   LOOP AT lt_node_cat ASSIGNING FIELD-SYMBOL(<ls_node_cat>).

     READ TABLE is_conf_action-node_cat->* WITH KEY node_cat_key = <ls_node_cat>-node_cat_key TRANSPORTING NO FIELDS.
     IF sy-subrc <> 0.

       " node category of instance differs from action node category(ies)...
       DELETE ct_key WHERE key = <ls_node_cat>-key.
       APPEND VALUE #( key = <ls_node_cat>-key ) TO ct_failed_key.
       DATA(lm_frw) = NEW /bobf/cm_frw_common_esi(
                        textid                = /bobf/cm_frw_common_esi=>cm_action_wrong_nodecat
                        severity              = /bobf/cm_frw=>co_severity_error
                        lifetime              = /bobf/cm_frw=>co_lifetime_transition
                        symptom               = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                        ms_origin_location    = VALUE #( node_key = is_conf_action-node_key
                                                         key      = <ls_node_cat>-key )
                        mv_act_key            = is_conf_action-act_key
                        cmn_action_proxy_name = is_conf_action-act_name ).
       IF co_message IS NOT BOUND.
         co_message = /bobf/cl_frw_factory=>get_message( ).
       ENDIF.
       co_message->add_cm( lm_frw ).

     ENDIF.

   ENDLOOP.

 ENDMETHOD.


METHOD check_and_determine.

  DATA: lo_message           TYPE REF TO /bobf/if_frw_message,
        lv_need_lock         TYPE boole_d,
        lt_node_lock         TYPE /bobf/t_frw_node,
        lt_node_newly_locked TYPE /bobf/t_frw_node,
        lv_lock_generic      TYPE boole_d,
        lt_delegated_node    TYPE /bobf/t_frw_node,
        lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
        ls_detconf           TYPE REF TO /bobf/s_confro_exectime,
        lt_groupconf         TYPE /bobf/t_confro_group,
        ls_groupconf         TYPE /bobf/s_confro_group,
        lt_host_node         TYPE /bobf/t_frw_node,
        ls_node              TYPE /bobf/s_frw_node,
        lt_key               TYPE /bobf/t_frw_key,
        ls_key               TYPE /bobf/s_frw_key,
        lt_check_key         TYPE /bobf/t_frw_key,
        lt_failed_key        TYPE /bobf/t_frw_key,
        lt_failed_val        TYPE /bobf/t_frw_validations,
        lt_group             TYPE /bobf/t_frw_group,
        ls_group             TYPE /bobf/s_frw_group,
        ls_change_mode       TYPE /bobf/s_confro_chg_mode,
        lo_change            TYPE REF TO /bobf/cl_frw_change,
        lx_root              TYPE REF TO cx_root.

  CLEAR:
      eo_change,
      eo_message.

* ____________________________________________________________________ *
* check for complete delegation
  eo_change = /bobf/cl_frw_factory=>get_change( ).
  lo_change ?= eo_change.

  IF io_change IS BOUND.
    lo_change->merge( io_change ).
  ENDIF.

  IF iv_node_key IS NOT INITIAL.
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( EXPORTING iv_node_key = iv_node_key ).
    ENDIF.

    IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
      TRY.
          lo_delegation = get_delegation( iv_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->check_and_determine(
            EXPORTING
              iv_node_key    = iv_node_key
              it_key         = it_key
              iv_check_scope = iv_check_scope
              io_change      = eo_change
            IMPORTING
              eo_message     = eo_message ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      IF mv_modifying_transaction = abap_false AND
         eo_change IS BOUND AND
         ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
           eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
           eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).
        create_states( ).
        mv_modifying_transaction = abap_true.
      ENDIF.

      RETURN.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* determine objects to check
  lo_change->trace_external_changes( abap_false ).

  lt_check_key = it_key.

*  ____________________________________________________________________ *
* check existence of all node instances the check&determine action is called with
  IF lt_check_key IS NOT INITIAL.
    retrieve(
      EXPORTING
        iv_node_key         = iv_node_key
        it_key              = lt_check_key
        iv_state            = /bobf/if_conf_c=>sc_state_current
        iv_invalidate_cache = abap_false
        iv_fill_data        = abap_false
        iv_edit_mode        = /bobf/if_conf_c=>sc_edit_read_only
        iv_buffer_only      = abap_false
        iv_within_loading   = abap_false
      IMPORTING
        eo_message          = lo_message
        et_failed_key       = lt_failed_key ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    LOOP AT lt_failed_key INTO ls_key.
      DELETE lt_check_key WHERE key = ls_key-key.
    ENDLOOP.
  ENDIF.

  mo_conf->get_group_tab( IMPORTING et_group = lt_groupconf ).
  ls_detconf = mo_conf->get_determination( /bobf/if_conf_c=>sc_time_check_and_determine ).

* Pre-Lock all instances that might be affected by setting of consistency status or determinations
  IF ls_detconf IS BOUND AND
    ls_detconf->det_list    IS BOUND AND
    ls_detconf->det_list->* IS NOT INITIAL.
    lv_need_lock = abap_true.
  ELSE.
    LOOP AT lt_groupconf INTO ls_groupconf
      WHERE group_cat = /bobf/if_conf_c=>sc_group_cat_consistency
        AND sta_var_key IS NOT INITIAL.
      IF iv_check_scope = /bobf/if_frw_c=>sc_scope_local.
        IF ls_groupconf-local_group = abap_true AND
           ls_groupconf-node_key    = iv_node_key.
          lv_need_lock = abap_true.
          EXIT.
        ENDIF.
      ELSEIF iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure.
        IF ls_groupconf-checkdet_node_key = iv_node_key.
          lv_need_lock = abap_true.
          EXIT.
        ELSEIF ls_groupconf-checkdet_super_node_keys IS BOUND.
          READ TABLE ls_groupconf-checkdet_super_node_keys->* TRANSPORTING NO FIELDS
            WITH KEY table_line = iv_node_key.
          IF sy-subrc = 0.
            lv_need_lock = abap_true.
            EXIT.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF lv_need_lock = abap_true.
    IF iv_check_scope =  /bobf/if_frw_c=>sc_scope_local.
      lv_lock_generic = abap_false.
    ELSE.
      lv_lock_generic = abap_true.
    ENDIF.
    map_to_node(
      EXPORTING
        iv_node_key = iv_node_key
        it_key      = it_key
      IMPORTING
        et_node     = lt_node_lock ).

    mo_lock_manager->lock(
      EXPORTING
        iv_edit_mode       = /bobf/if_conf_c=>sc_edit_exclusive
        it_node            = lt_node_lock
        io_change          = eo_change
        iv_generic         = lv_lock_generic
      IMPORTING
        et_lockable_node_newly_locked = lt_node_newly_locked
        eo_message         = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF lt_node_newly_locked IS NOT INITIAL.
*     reload lock groups of newly locked lockable nodes
      do_loading(
        EXPORTING
          it_node           = lt_node_newly_locked
          iv_check_buf      = abap_false
          iv_reload         = abap_true
          iv_load_data      = abap_true
          iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
          io_change         = eo_change
        IMPORTING
          eo_message        = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.
  ENDIF.


  CASE iv_check_scope.
    WHEN: /bobf/if_frw_c=>sc_scope_substructure.
      CLEAR lt_delegated_node.
      get_subnodes(
        EXPORTING
          iv_node_key                   = iv_node_key
          it_key                        = lt_check_key
          iv_stop_at_delegation_subtree = abap_true
          iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_nodes
*          iv_return_only_check_trigger  = abap_true
        IMPORTING
          eo_message                    = lo_message
        CHANGING
          ct_host_node                  = lt_host_node
          ct_delegation_root_node       = lt_delegated_node ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_delegated_node IS NOT INITIAL.
        INSERT LINES OF lt_delegated_node INTO TABLE lt_host_node.
      ENDIF.
      LOOP AT lt_host_node INTO ls_node.
        lo_change->add_change(
           iv_change_mode = /bobf/if_frw_c=>sc_modify_check
           iv_node_key    = ls_node-node
           iv_key         = ls_node-key ).
      ENDLOOP.

    WHEN: /bobf/if_frw_c=>sc_scope_local.
      lo_change->add_change(
         iv_change_mode = /bobf/if_frw_c=>sc_modify_check
         iv_node_key    = iv_node_key
         it_key         = lt_check_key ).

    WHEN OTHERS.
*     unknown scope
      ASSERT ID /bobf/frw CONDITION 0 = 1.                 "#EC BOOL_OK
      RETURN.
  ENDCASE.

  lo_change->trace_external_changes( abap_true ).

* ___________________________________________________________________________ *
* Perform Determinations for Check&Determine
  IF ls_detconf              IS BOUND AND
     ls_detconf->det_list    IS BOUND AND
     ls_detconf->det_list->* IS NOT INITIAL.

    do_determinations(
      EXPORTING
        iv_exectime   = /bobf/if_conf_c=>sc_time_check_and_determine
        io_change     = lo_change
      IMPORTING
        eo_message    = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF lo_change IS BOUND AND
       ( lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
         lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
         lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).

      do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_after_modify
          io_change   = lo_change
        IMPORTING
          eo_message  = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    IF lo_change->has_changes(
        iv_selection   = /bobf/if_frw_c=>sc_change_succ_only
        iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
       lo_change->has_changes(
        iv_selection   = /bobf/if_frw_c=>sc_change_succ_only
        iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true.

      lo_change->cleanup( /bobf/if_frw_c=>sc_modify_check ).

*     Re-Determine instances to check if determinations created or deleted instances
      CASE iv_check_scope.
        WHEN: /bobf/if_frw_c=>sc_scope_substructure.
          CLEAR lt_delegated_node.
          get_subnodes(
            EXPORTING
              iv_node_key                   = iv_node_key
              it_key                        = lt_check_key
              iv_stop_at_delegation_subtree = abap_true
              iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_nodes
*              iv_return_only_check_trigger  = abap_true
            IMPORTING
              eo_message                    = lo_message
            CHANGING
              ct_host_node                  = lt_host_node
              ct_delegation_root_node       = lt_delegated_node ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF lt_delegated_node IS NOT INITIAL.
            INSERT LINES OF lt_delegated_node INTO TABLE lt_host_node.
          ENDIF.
          LOOP AT lt_host_node INTO ls_node.
            lo_change->add_change(
               iv_change_mode = /bobf/if_frw_c=>sc_modify_check
               iv_node_key    = ls_node-node
               iv_key         = ls_node-key ).
          ENDLOOP.

        WHEN: /bobf/if_frw_c=>sc_scope_local.
          lo_change->add_change(
             iv_change_mode = /bobf/if_frw_c=>sc_modify_check
             iv_node_key    = iv_node_key
             it_key         = lt_check_key ).
      ENDCASE.

    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* call consistency check for delegated nodes within subtree

  lo_change->trace_external_changes( abap_false ).

  TRY.
      LOOP AT lt_delegated_node INTO ls_node.

        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.

        AT END OF node.
          mo_conf->get_node( ls_node-node ).
          lo_delegation = get_delegation( ls_node-node ).

          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->check_and_determine(
            EXPORTING
              iv_node_key    = ls_node-node
              it_key         = lt_key
              iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure
              io_change      = eo_change
            IMPORTING
              eo_message     = lo_message ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          CLEAR lt_key.
        ENDAT.
      ENDLOOP.


      IF mv_modifying_transaction = abap_false AND
         eo_change IS BOUND AND
         ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
           eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
           eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).
        create_states( ).
        mv_modifying_transaction = abap_true.
      ENDIF.

    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* ____________________________________________________________________ *
* determine groups that are complete
  ls_change_mode-check = abap_true.
  LOOP AT lt_groupconf INTO ls_groupconf
    WHERE group_cat = /bobf/if_conf_c=>sc_group_cat_consistency.
    CHECK ls_groupconf-sta_var_key IS NOT INITIAL.

    IF iv_check_scope           = /bobf/if_frw_c=>sc_scope_local AND
       ls_groupconf-local_group = abap_false.
      CONTINUE.
    ENDIF.

    IF ls_groupconf-checkdet_node_key <> ls_groupconf-node_key.
      IF ls_groupconf-checkdet_super_node_keys IS BOUND.
        READ TABLE ls_groupconf-checkdet_super_node_keys->* TRANSPORTING NO FIELDS
          WITH KEY table_line = iv_node_key.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
      ENDIF.
    ENDIF.

    lo_change->get_trigger(
      EXPORTING
        iv_node_key    = ls_groupconf-node_key
        is_change_mode = ls_change_mode
        iv_exectime    = /bobf/if_conf_c=>sc_time_after_modify
      IMPORTING
        et_changed_key = lt_key ).

    ls_group-group_key    = ls_groupconf-group_key.
    ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.
    LOOP AT lt_key INTO ls_key.
      ls_group-key = ls_key-key.
      INSERT ls_group INTO TABLE lt_group.
    ENDLOOP.
  ENDLOOP.

* ____________________________________________________________________ *
* call consistency check for own nodes
  IF lo_change IS BOUND.
    do_validate(
      EXPORTING
        iv_only_given_validations  = abap_false
        io_change                  = lo_change
        iv_last_state_db           = abap_true
        iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check_and_determ
      IMPORTING
        et_failed_val              = lt_failed_val
        eo_message                 = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

* ____________________________________________________________________ *
*   set consistency status
    lo_change->trace_external_changes( abap_true ).
    derive_consistency_status(
      EXPORTING
        it_failed_val = lt_failed_val
      IMPORTING
        eo_message    = lo_message
      CHANGING
        ct_group      = lt_group ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    set_consistency_status(
      EXPORTING
        it_group   = lt_group
        io_change  = lo_change
      IMPORTING
        eo_message = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    lo_change->set_processed( iv_det_processed = abap_true ).

* ____________________________________________________________________ *
*   call determination after validation
    do_determinations(
      EXPORTING
        iv_exectime = /bobf/if_conf_c=>sc_time_after_validation
        io_change   = lo_change
      IMPORTING
        eo_message  = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

* ____________________________________________________________________ *
* collect messages from validation message node
  add_messages(
    EXPORTING
      io_change  = lo_change
    CHANGING
      co_message = eo_message ).

ENDMETHOD.


 METHOD CHECK_FATAL_ERROR.

   IF mv_application_error = abap_true.
     RAISE EXCEPTION TYPE /BOBF/CX_FRW_FATAL
       EXPORTING
         textid           = /BOBF/CX_FRW_FATAL=>SC_APPLICATION_ERROR
         mv_bo_name       = mo_conf->ms_obj-bo_name
         mv_proxy_bo_name = mo_conf->ms_obj-bo_esr_name.
   ENDIF.

   IF mv_configuration_error = abap_true.
     RAISE EXCEPTION TYPE /BOBF/CX_FRW_FATAL
       EXPORTING
         textid           = /BOBF/CX_FRW_FATAL=>SC_CONFIGURATION_ERROR
         mv_bo_name       = mo_conf->ms_obj-bo_name
         mv_proxy_bo_name = mo_conf->ms_obj-bo_esr_name.
   ENDIF.

 ENDMETHOD.


  METHOD check_fields_are_triggers.
    DATA lv_changed_field_name TYPE string.

    IF iv_trigger_attr_all = abap_true.
      rv_fields_are_triggers = abap_true.
    ELSE.
      IF irt_trigger_attr IS BOUND AND irt_trigger_attr->* IS NOT INITIAL.
        IF it_changed_fields IS INITIAL. "all fields are changed
          rv_fields_are_triggers = abap_true.
        ELSE.
          "check if any changed field triggers a determination or validation:
          LOOP AT it_changed_fields INTO lv_changed_field_name.
            IF line_exists( irt_trigger_attr->*[ table_line = lv_changed_field_name ] ).
              rv_fields_are_triggers = abap_true.
              RETURN.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD check_inconsistent_composition.
    CLEAR: eo_message, et_failed_node.
    DATA lr_data TYPE REF TO data.
    DATA lr_root_data TYPE REF TO data.
    DATA lm_common_esi TYPE REF TO /bobf/cm_frw_common_esi.
    DATA ls_location TYPE /bobf/s_frw_location.
    FIELD-SYMBOLS <lt_root_data> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <lt_data> TYPE STANDARD TABLE.

    LOOP AT it_create_node INTO DATA(ls_node_to_be_created).
      mo_conf->get_node( EXPORTING iv_node_key = ls_node_to_be_created-node
                         IMPORTING es_node     = DATA(ls_node) ).
      IF ls_node-node_key <> ls_node-root_node_key AND
         ls_node-node_type = /bobf/if_conf_c=>sc_node_type_normal.
        mo_conf->get_node( EXPORTING iv_node_key = ls_node-root_node_key
                        IMPORTING es_node     = DATA(ls_root_node) ).

        CREATE DATA lr_data TYPE (ls_node-data_table_type).
        ASSIGN lr_data->* TO <lt_data>.
        retrieve( EXPORTING iv_node_key = ls_node-node_key
                            it_key      = VALUE #( ( key = ls_node_to_be_created-key ) )
                            iv_state    = /bobf/if_conf_c=>sc_state_current
                  IMPORTING et_data     = <lt_data> ).

        CREATE DATA lr_root_data TYPE (ls_root_node-data_table_type).
        ASSIGN lr_root_data->* TO <lt_root_data>.
        get_root_key( EXPORTING iv_node_key     = ls_node_to_be_created-node
                                it_key          = VALUE #( ( key = ls_node_to_be_created-key ) )
                      IMPORTING et_target_key   = DATA(lt_root_key) ).
        retrieve( EXPORTING iv_node_key = ls_node-root_node_key
                            it_key      = VALUE #( ( key = lt_root_key[ 1 ]-key ) )
                            iv_state    = /bobf/if_conf_c=>sc_state_current
                  IMPORTING et_data     = <lt_root_data> ).

        ASSIGN COMPONENT /bobf/if_conf_cds_link_c=>gc_element_name-draft-isactiveentity OF STRUCTURE <lt_data>[ 1 ] TO FIELD-SYMBOL(<lv_is_active_item>).
        ASSERT sy-subrc = 0.

        ASSIGN COMPONENT /bobf/if_conf_cds_link_c=>gc_element_name-draft-isactiveentity OF STRUCTURE <lt_root_data>[ 1 ] TO FIELD-SYMBOL(<lv_is_active_root>).
        ASSERT sy-subrc = 0.

        IF <lv_is_active_root> <> <lv_is_active_item>.
          IF eo_message IS NOT BOUND.
            eo_message = /bobf/cl_frw_factory=>get_message( ).
          ENDIF.
          ls_location-key      = ls_node_to_be_created-key.
          ls_location-node_key = ls_node_to_be_created-node.
          eo_message->add_cm( io_message = NEW /bobf/cm_frw_common_esi( textid             = /bobf/cm_frw_common_esi=>cm_invalid_composition
                                                                        severity           = /bobf/cm_frw=>co_severity_error
                                                                        symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                                                                        lifetime           = /bobf/cm_frw=>co_lifetime_transition
                                                                        ms_origin_location = ls_location ) ).
          INSERT ls_node_to_be_created INTO TABLE et_failed_node.
          "test whether the root node key is also newly created
          READ TABLE it_create_node WITH KEY key = lt_root_key[ 1 ]-key INTO DATA(ls_created_root_node).
          IF sy-subrc = 0.
            "add it to the failed keys too.
            INSERT ls_created_root_node INTO TABLE et_failed_node.
          ENDIF.
        ENDIF.
        CLEAR: lr_data, lr_root_data.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


METHOD check_modification_properties.

  TYPES:
    BEGIN OF ty_mod_with_location,
      location TYPE /bobf/s_frw_location,
      mod      TYPE REF TO /bobf/s_frw_modification,
    END OF ty_mod_with_location,
    tt_mod_with_location TYPE STANDARD TABLE OF ty_mod_with_location.

  DATA: ls_node                  TYPE /bobf/s_frw_node,
        lo_property              TYPE REF TO /bobf/if_frw_property,
        lo_property_source       TYPE REF TO /bobf/if_frw_property,
        lt_property              TYPE /bobf/t_frw_property_k_sorted,
        lt_property_source       TYPE /bobf/t_frw_property_k_sorted,
        ls_property              TYPE /bobf/s_frw_property_k,
        lt_key                   TYPE /bobf/t_frw_key,
        lt_key_source            TYPE /bobf/t_frw_key,
        ls_key                   TYPE /bobf/s_frw_key,
        lv_check_services        TYPE /bobf/conf_check_services,
        lv_check_services_source TYPE /bobf/conf_check_services,
        lv_source_node           TYPE /bobf/obm_node_key,
        lv_changed_field         TYPE string,
        lv_tabix                 TYPE i,
        lv_tabix_first           TYPE i,
        lv_group_change          TYPE boole_d,
        lo_message               TYPE REF TO /bobf/if_frw_message,
        ls_location              TYPE /bobf/s_frw_location,
        lt_read_only_update      TYPE tt_mod_with_location,
        lt_read_only_location    TYPE /bobf/t_frw_location,
        lm_common_esi            TYPE REF TO /bobf/cm_frw_common_esi,
        lrt_node_data            TYPE REF TO data.

  FIELD-SYMBOLS:
    <lt_node_data> TYPE STANDARD TABLE,
    <ls_mod>       TYPE /bobf/s_frw_modification,
    <ls_mod1>      TYPE /bobf/s_frw_modification,
    <ls_mod_next>  TYPE /bobf/s_frw_modification.

  CLEAR:
    eo_message,
    et_failed.

  LOOP AT ct_modification ASSIGNING <ls_mod1>.

    lv_tabix = sy-tabix.

    IF lt_key IS INITIAL.
*     at the beginning of a new group

      lv_tabix_first = sy-tabix.

      lv_check_services = mo_conf->ms_obj-check_services.

      IF <ls_mod1>-association IS NOT INITIAL.
        lv_check_services_source = mo_conf->ms_obj-check_services.
        lv_source_node = <ls_mod1>-source_node.
      ENDIF.

      IF  <ls_mod1>-change_mode          = /bobf/if_frw_c=>sc_modify_create
      AND mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn.

        lv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.

        IF <ls_mod1>-association IS NOT INITIAL.
          READ TABLE ct_modification TRANSPORTING NO FIELDS WITH KEY change
            COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                       node        = <ls_mod1>-source_node
                       key         = <ls_mod1>-source_key.
          IF sy-subrc = 0.
            lv_check_services_source = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    ls_key-key = <ls_mod1>-key.
    APPEND ls_key TO lt_key.

    IF  <ls_mod1>-change_mode = /bobf/if_frw_c=>sc_modify_create
    AND <ls_mod1>-association IS NOT INITIAL.
      ls_key-key     = <ls_mod1>-source_key.
      APPEND ls_key TO lt_key_source.
    ENDIF.

*   check for group change:
    READ TABLE ct_modification ASSIGNING <ls_mod_next> INDEX lv_tabix + 1.
    IF sy-subrc = 0.
      " reasons for a group change:
      " - node change
      " - different associations
      " - different values for LV_CHECK_SERVICES (--> dynamic checks enabled AND create <> {update, delete} )
      " - different values for LV_CHECK_SERVICES_SOURCE
      IF <ls_mod1>-node        <> <ls_mod_next>-node
      OR <ls_mod1>-association <> <ls_mod_next>-association
      OR ( mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn AND
           <ls_mod1>-change_mode <> <ls_mod_next>-change_mode AND
           ( <ls_mod1>-change_mode     = /bobf/if_frw_c=>sc_modify_create OR
             <ls_mod_next>-change_mode = /bobf/if_frw_c=>sc_modify_create ) ).
        lv_group_change = abap_true.
      ELSEIF <ls_mod_next>-association IS NOT INITIAL
         AND mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn.
        " will there be a change in LV_CHECK_SERVICES_SOURCE?
        READ TABLE ct_modification TRANSPORTING NO FIELDS WITH KEY change
         COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                    node        = <ls_mod_next>-source_node
                    key         = <ls_mod_next>-source_key.
        IF sy-subrc = 0 AND lv_check_services_source <> /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
          lv_group_change = abap_true.
        ELSEIF sy-subrc <> 0 AND lv_check_services_source <> /bobf/if_conf_c=>sc_check_services_stat_dyn.
          lv_group_change = abap_true.
        ENDIF.
      ENDIF.
    ELSE.
      lv_group_change = abap_true. " last entry
    ENDIF.

*   at end of one node: read all properties and maintain modifications of node
    IF lv_group_change = abap_true.

      lv_group_change = abap_false.

      /bobf/if_frw_service_layer~retrieve_property(
        EXPORTING
          iv_node_key                = <ls_mod1>-node
          it_key                     = lt_key
          iv_check_services          = lv_check_services
          iv_node_property           = abap_true
          iv_node_attribute_property = abap_true
          iv_assoc_property          = abap_false
        IMPORTING
          eo_property                = lo_property
          eo_message                 = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_key_source IS NOT INITIAL.
        SORT lt_key_source.
        DELETE ADJACENT DUPLICATES FROM lt_key_source.
        /bobf/if_frw_service_layer~retrieve_property(
          EXPORTING
            iv_node_key                = lv_source_node
            it_key                     = lt_key_source
            iv_check_services          = lv_check_services_source
            iv_node_property           = abap_false
            iv_node_attribute_property = abap_false
            iv_assoc_property          = abap_true
          IMPORTING
            eo_property                = lo_property_source
            eo_message                 = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ELSE.
        CLEAR lo_property_source.
      ENDIF.

      CLEAR:
        lt_key,
        lt_key_source,
        lv_source_node.

      IF lo_property_source IS NOT BOUND AND
          lo_property       IS NOT BOUND.
        CONTINUE.
      ENDIF.

      IF lo_property IS BOUND.
        lo_property->get_property( IMPORTING et_property_sorted = lt_property ).
*       Remove irrelevant (all non-restricting) properties
        LOOP AT lt_property INTO ls_property.
          IF ( ls_property-property_name = /bobf/if_conf_c=>sc_property_name_create_enable OR
               ls_property-property_name = /bobf/if_conf_c=>sc_property_name_update_enable OR
               ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable OR
               ls_property-property_name = /bobf/if_conf_c=>sc_property_name_enabled ) AND
             ls_property-value = abap_true.
            DELETE lt_property.
          ELSEIF ls_property-property_name = /bobf/if_conf_c=>sc_property_name_readonly AND
                 ls_property-value         = abap_false.
            DELETE lt_property.
          ENDIF.
        ENDLOOP.
      ELSE.
        CLEAR lt_property.
      ENDIF.

      IF lo_property_source IS BOUND.
        lo_property_source->get_property( IMPORTING et_property_sorted = lt_property_source ).
*       Remove irrelevant (all non-restricting) properties
        LOOP AT lt_property_source INTO ls_property.
          IF ( ls_property-property_name = /bobf/if_conf_c=>sc_property_name_create_enable OR
               ls_property-property_name = /bobf/if_conf_c=>sc_property_name_enabled ) AND
             ls_property-value = abap_true.
            DELETE lt_property_source.
          ENDIF.
        ENDLOOP.
      ELSE.
        CLEAR lt_property_source.
      ENDIF.

*     maintain all lines to current node at end of node according to properties
      ls_node-node = <ls_mod1>-node.
      LOOP AT ct_modification FROM lv_tabix_first TO lv_tabix ASSIGNING <ls_mod>.
        ls_node-key  = <ls_mod>-key.

        ls_location-key      = <ls_mod>-key.
        ls_location-node_key = <ls_mod>-node.
        CLEAR ls_location-attributes.

        CASE <ls_mod>-change_mode.

* ___________________________________________________________________________ *
*         create
          WHEN /bobf/if_frw_c=>sc_modify_create.

*           check association create enabled
            IF <ls_mod>-association IS NOT INITIAL AND
               lt_property_source   IS NOT INITIAL.
              READ TABLE lt_property_source
                WITH KEY  parent_key    = <ls_mod>-source_key
                          content_cat   = /bobf/if_conf_c=>sc_content_ass
                          content_key   = <ls_mod>-association
                          property_name = /bobf/if_conf_c=>sc_property_name_create_enable
                          value         = abap_false
                TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CREATE OBJECT lm_common_esi
                  EXPORTING
                    textid             = /bobf/cm_frw_common_esi=>cm_node_create_disabled
                    severity           = /bobf/cm_frw=>co_severity_error
                    symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                    lifetime           = /bobf/cm_frw=>co_lifetime_transition
                    ms_origin_location = ls_location.
                IF eo_message IS NOT BOUND.
                  eo_message = /bobf/cl_frw_factory=>get_message( ).
                ENDIF.
                eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                INSERT ls_node INTO TABLE et_failed.
                CONTINUE.
              ENDIF.
*
              READ TABLE lt_property_source
                WITH KEY parent_key    = <ls_mod>-source_key
                         content_cat   = /bobf/if_conf_c=>sc_content_ass
                         content_key   = <ls_mod>-association
                         property_name = /bobf/if_conf_c=>sc_property_name_enabled
                         value         = abap_false
                TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CREATE OBJECT lm_common_esi
                  EXPORTING
                    textid             = /bobf/cm_frw_common_esi=>cm_node_create_disabled
                    severity           = /bobf/cm_frw=>co_severity_error
                    symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                    lifetime           = /bobf/cm_frw=>co_lifetime_transition
                    ms_origin_location = ls_location.
                IF eo_message IS NOT BOUND.
                  eo_message = /bobf/cl_frw_factory=>get_message( ).
                ENDIF.
                eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                INSERT ls_node INTO TABLE et_failed.
                CONTINUE.
              ENDIF.
            ENDIF.

*           check node create enabled
            READ TABLE lt_property
              WITH KEY parent_key    = <ls_mod>-key
                       content_cat   = /bobf/if_conf_c=>sc_content_nod
                       content_key   = <ls_mod>-node
                       property_name = /bobf/if_conf_c=>sc_property_name_create_enable
                       value         = abap_false
              TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              CREATE OBJECT lm_common_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_node_create_disabled
                  severity           = /bobf/cm_frw=>co_severity_error
                  symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  ms_origin_location = ls_location.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
              INSERT ls_node INTO TABLE et_failed.
              CONTINUE.
            ENDIF.

            IF <ls_mod>-changed_fields IS NOT INITIAL.
*           check attributes changeable
              LOOP AT <ls_mod>-changed_fields INTO lv_changed_field.
                CHECK lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_key
                  AND lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_parent_key
                  AND lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_root_key.
                CLEAR ls_location-attributes.
                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                           value          = abap_true
                  TRANSPORTING NO FIELDS.

                IF sy-subrc = 0.
*               field not changeable -> remove field and add error message
                  DELETE <ls_mod>-changed_fields.
                  APPEND lv_changed_field TO ls_location-attributes.
                  CREATE OBJECT lm_common_esi
                    EXPORTING
                      textid              = /bobf/cm_frw_common_esi=>cm_attr_read_only
                      severity            = /bobf/cm_frw=>co_severity_error
                      symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                      lifetime            = /bobf/cm_frw=>co_lifetime_transition
                      ms_origin_location  = ls_location
                      cmn_attr_proxy_name = lv_changed_field.
                  IF eo_message IS NOT BOUND.
                    eo_message = /bobf/cl_frw_factory=>get_message( ).
                  ENDIF.
                  eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                  CONTINUE.
                ENDIF.

                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                           value          = abap_false
                  TRANSPORTING NO FIELDS.

                IF sy-subrc = 0.
*               field not enabled -> remove field and add error message
                  DELETE <ls_mod>-changed_fields.
                  APPEND lv_changed_field TO ls_location-attributes.
                  CREATE OBJECT lm_common_esi
                    EXPORTING
                      textid              = /bobf/cm_frw_common_esi=>cm_attr_disabled
                      severity            = /bobf/cm_frw=>co_severity_error
                      symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                      lifetime            = /bobf/cm_frw=>co_lifetime_transition
                      ms_origin_location  = ls_location
                      cmn_attr_proxy_name = lv_changed_field.
                  IF eo_message IS NOT BOUND.
                    eo_message = /bobf/cl_frw_factory=>get_message( ).
                  ENDIF.
                  eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                ENDIF.
              ENDLOOP.

              IF <ls_mod>-changed_fields IS INITIAL.
*             check if node is delegated node
                IF mo_conf->ms_last_node-node_key <> <ls_mod>-node.
                  mo_conf->get_node( <ls_mod>-node ).
                ENDIF.
*             no changeable fields left -> clear modification data
                IF mo_conf->ms_last_node-delegation_class IS INITIAL.
                  CLEAR <ls_mod>-data.
                ENDIF.
              ENDIF.

            ELSE.
*             No changed fields specified -> Derive changed fields out of properties
              IF mo_conf->ms_last_node-node_key <> <ls_mod>-node.
                mo_conf->get_node( <ls_mod>-node ).
              ENDIF.
              LOOP AT mo_conf->ms_last_node-field_names->* INTO lv_changed_field.
                CHECK lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_key
                  AND lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_parent_key
                  AND lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_root_key.
                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                           value          = abap_true
                  TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
*                 Field is read-only -> skip it
                  CONTINUE.
                ENDIF.
                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                           value          = abap_false
                TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
*                 Field is disabled -> skip it
                  CONTINUE.
                ENDIF.
                INSERT lv_changed_field INTO TABLE <ls_mod>-changed_fields.
              ENDLOOP.
              IF <ls_mod>-changed_fields = mo_conf->ms_last_node-field_names->*.
*               If all fields may be moved -> drop changed fields for better performance in buffer
                CLEAR <ls_mod>-changed_fields.
              ENDIF.
            ENDIF.


* ___________________________________________________________________________ *
*         update
          WHEN /bobf/if_frw_c=>sc_modify_update.
*           check node update enabled
            READ TABLE lt_property
              WITH KEY parent_key    = <ls_mod>-key
                       content_cat   = /bobf/if_conf_c=>sc_content_nod
                       content_key   = <ls_mod>-node
                       property_name = /bobf/if_conf_c=>sc_property_name_update_enable
                       value         = abap_false
              TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              CREATE OBJECT lm_common_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_node_update_disabled
                  severity           = /bobf/cm_frw=>co_severity_error
                  symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  ms_origin_location = ls_location.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
              INSERT ls_node INTO TABLE et_failed.
              CONTINUE.
            ENDIF.

*           check attributes changeable
            IF <ls_mod>-changed_fields IS NOT INITIAL.
              LOOP AT <ls_mod>-changed_fields INTO lv_changed_field.
                CLEAR ls_location-attributes.
                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                           value          = abap_true
                   TRANSPORTING NO FIELDS.

                IF sy-subrc = 0.
*                 field not changeable -> remove field and add error message
                  DELETE <ls_mod>-changed_fields.
                  APPEND lv_changed_field TO ls_location-attributes.
                  INSERT VALUE #( location = ls_location
                                  mod      = REF #( <ls_mod> ) ) INTO TABLE lt_read_only_update.
                  CONTINUE.
                ENDIF.

                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                           value          = abap_false
                  TRANSPORTING NO FIELDS.

                IF sy-subrc = 0.
*                 field not enabled -> remove field and add error message
                  DELETE <ls_mod>-changed_fields.
                  APPEND lv_changed_field TO ls_location-attributes.
                  CREATE OBJECT lm_common_esi
                    EXPORTING
                      textid              = /bobf/cm_frw_common_esi=>cm_attr_disabled
                      severity            = /bobf/cm_frw=>co_severity_error
                      symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                      lifetime            = /bobf/cm_frw=>co_lifetime_transition
                      ms_origin_location  = ls_location
                      cmn_attr_proxy_name = lv_changed_field.
                  IF eo_message IS NOT BOUND.
                    eo_message = /bobf/cl_frw_factory=>get_message( ).
                  ENDIF.
                  eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                ENDIF.
              ENDLOOP.

              IF <ls_mod>-changed_fields IS INITIAL.
*               no changeable fields left -> remove modification and add failed change
                INSERT ls_node INTO TABLE et_failed.
                CONTINUE.
              ENDIF.
            ELSE.
*             No changed fields specified -> Derive changed fields out of properties
              IF mo_conf->ms_last_node-node_key <> <ls_mod>-node.
                mo_conf->get_node( <ls_mod>-node ).
              ENDIF.
              LOOP AT mo_conf->ms_last_node-field_names->* INTO lv_changed_field.
                CHECK lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_key
                  AND lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_parent_key
                  AND lv_changed_field <> /bobf/if_conf_c=>sc_attribute_name_root_key.
                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                           value          = abap_true
                  TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
*                 Field is read-only -> skip it
                  CONTINUE.
                ENDIF.
                READ TABLE lt_property
                  WITH KEY parent_key     = <ls_mod>-key
                           content_cat    = /bobf/if_conf_c=>sc_content_nod
                           content_key    = <ls_mod>-node
                           attribute_name = lv_changed_field
                           property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                           value          = abap_false
                TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
*                 Field is disabled -> skip it
                  CONTINUE.
                ENDIF.
                INSERT lv_changed_field INTO TABLE <ls_mod>-changed_fields.
              ENDLOOP.

            ENDIF.

* ___________________________________________________________________________ *
*         delete
          WHEN /bobf/if_frw_c=>sc_modify_delete.
*           check node delete enabled
            READ TABLE lt_property
               WITH KEY parent_key    = <ls_mod>-key
                        content_cat   = /bobf/if_conf_c=>sc_content_nod
                        content_key   = <ls_mod>-node
                        property_name = /bobf/if_conf_c=>sc_property_name_delete_enable
                        value         = abap_false
               TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              CREATE OBJECT lm_common_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_node_delete_disabled
                  severity           = /bobf/cm_frw=>co_severity_error
                  symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  ms_origin_location = ls_location.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
              INSERT ls_node INTO TABLE et_failed.
              CONTINUE.
            ENDIF.
        ENDCASE.
      ENDLOOP.

    ENDIF.
  ENDLOOP.

  IF lt_read_only_update IS NOT INITIAL.
    " LT_READ_ONLY_MOD is the list of all modifications which affect read-only fields.
    " We want to send errors messages only for such changes which attempt to set a value differing from the current buffer value.

    " Find "dummy" changes, i.e. modifications which set the same value as currently in the buffer:
    LOOP AT lt_read_only_update ASSIGNING FIELD-SYMBOL(<ls_group_by_node>)
                                GROUP BY ( node_key = <ls_group_by_node>-location-node_key ).
      "create an ET_DATA container for the RETRIEVE call below:
      mo_conf->get_node( <ls_group_by_node>-location-node_key ).
      CREATE DATA lrt_node_data TYPE STANDARD TABLE OF (mo_conf->ms_last_node-data_type).
      ASSIGN lrt_node_data->* TO <lt_node_data>.

      "compare modifications with buffer, one-by-one:
      "(assuming that the number of changes to read-only fields will be small,
      " there should not be a very big performance impact caused by doing single RETRIEVES.
      " After all, pure buffer retrieves are not too slow.):
      LOOP AT GROUP <ls_group_by_node> ASSIGNING FIELD-SYMBOL(<ls_read_only_update>) WHERE mod->data IS BOUND.
        DATA(lv_same_values) = abap_false.
        TRY.
            mo_buffer->retrieve(
              EXPORTING iv_node_key    = <ls_read_only_update>-location-node_key
                        it_key         = VALUE #( ( key = <ls_read_only_update>-location-key ) )
                        iv_state       = iv_state
                        iv_fill_data   = abap_true
                        iv_buffer_only = abap_true "if it's not in the buffer, we don't bother to fetch it
              IMPORTING et_data        = <lt_node_data> ).
            IF <lt_node_data> IS NOT INITIAL.
              ASSIGN COMPONENT <ls_read_only_update>-location-attributes[ 1 ] OF STRUCTURE <lt_node_data>[ 1 ]
                     TO FIELD-SYMBOL(<lv_attr_in_buffer>).
              ASSIGN <ls_read_only_update>-mod->data->* TO FIELD-SYMBOL(<ls_mod_data>).
              ASSIGN COMPONENT <ls_read_only_update>-location-attributes[ 1 ] OF STRUCTURE <ls_mod_data>
                     TO FIELD-SYMBOL(<lv_attr_in_mod>).
              IF <lv_attr_in_buffer> = <lv_attr_in_mod>.
                lv_same_values = abap_true.
              ENDIF.
            ENDIF.
          CATCH /bobf/cx_frw ##no_handler.
        ENDTRY.
        IF lv_same_values = abap_false.
          INSERT <ls_read_only_update>-location INTO TABLE lt_read_only_location.
        ENDIF.
      ENDLOOP.
      UNASSIGN: <lv_attr_in_buffer>, <lv_attr_in_mod>. "paranoia
    ENDLOOP.

    " send error messages for the remaining (real) changes
    IF lt_read_only_location IS NOT INITIAL.
      IF eo_message IS NOT BOUND.
        eo_message = /bobf/cl_frw_factory=>get_message( ).
      ENDIF.
      LOOP AT lt_read_only_location ASSIGNING FIELD-SYMBOL(<ls_read_only_location>).
        eo_message->add_cm( NEW /bobf/cm_frw_common_esi(
                                    textid              = /bobf/cm_frw_common_esi=>cm_attr_read_only
                                    severity            = /bobf/cm_frw=>co_severity_error
                                    symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                                    lifetime            = /bobf/cm_frw=>co_lifetime_transition
                                    ms_origin_location  = <ls_read_only_location>
                                    cmn_attr_proxy_name = <ls_read_only_location>-attributes[ 1 ] ) ).
      ENDLOOP.
    ENDIF.
  ENDIF.

ENDMETHOD.


  METHOD check_properties_before_modify.
    DATA: lt_failed    TYPE /bobf/t_frw_node,
          lo_message   TYPE REF TO /bobf/if_frw_message,
          lt_failed_do TYPE /bobf/t_frw_node.

    FIELD-SYMBOLS: <ls_mod_do> TYPE /bobf/s_frw_modification_do.

    check_modification_properties( EXPORTING iv_state        = iv_state
                                   IMPORTING eo_message      = lo_message
                                             et_failed       = lt_failed
                                   CHANGING  ct_modification = ct_mod ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = co_message ).

    LOOP AT ct_mod_do ASSIGNING <ls_mod_do>.
      check_modification_properties( EXPORTING iv_state        = iv_state
                                     IMPORTING eo_message      = lo_message
                                               et_failed       = lt_failed_do
                                     CHANGING  ct_modification = <ls_mod_do>-modification ).
      INSERT LINES OF lt_failed_do INTO TABLE lt_failed.
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = co_message ).
    ENDLOOP.

    IF lt_failed IS NOT INITIAL.
*     not all modifications are allowed
      ASSERT ID /bobf/frw_warning CONDITION 0 = 1.         "#EC BOOL_OK

      cleanup_modifications( EXPORTING it_failed_node       = lt_failed
                                       io_change            = io_change
                             CHANGING  ct_mod               = ct_mod
                                       ct_mod_do            = ct_mod_do
                                       ct_lock_created      = ct_lock_created
                                       ct_create            = ct_create
                                       ct_update            = ct_update
                                       ct_delete            = ct_delete
                                       ct_update_data       = ct_update_data
                                       ct_update_data_all   = ct_update_data_all
                                       ct_update_data_sta   = ct_update_data_status
                                       ct_node_state_create = ct_node_state_create
                                       ct_node_category     = ct_node_category ).
    ENDIF.
  ENDMETHOD.


METHOD class_constructor.
  CALL FUNCTION 'TR_SYS_PARAMS' IMPORTING system_client_role = gv_system_client_role.
ENDMETHOD.


METHOD CLEANUP_MODIFICATIONS.

  DATA: lt_node               TYPE /BOBF/T_FRW_NODE,
        ls_node               TYPE /BOBF/S_FRW_NODE,
        lt_failed_root_key    TYPE /BOBF/T_FRW_KEY,
        lt_root_key           TYPE /BOBF/T_FRW_KEY,
        ls_key                TYPE /BOBF/S_FRW_KEY,
        lt_key                TYPE /BOBF/T_FRW_KEY,
        ls_mod                TYPE /BOBF/S_FRW_MODIFICATION,
        ls_mod2               TYPE /BOBF/S_FRW_MODIFICATION,
        lt_mod                TYPE /BOBF/T_FRW_MODIFICATION,
        lt_key_link           TYPE /BOBF/T_FRW_KEY_LINK,
        ls_key_link           TYPE /BOBF/S_FRW_KEY_LINK,
        lo_delegation         TYPE REF TO /BOBF/IF_FRW_DELEGATION,
        lo_change             TYPE REF TO /BOBF/CL_FRW_CHANGE,
        lv_create             TYPE boole_d,
        lv_process            TYPE boole_d,
        lv_check_before_image TYPE boole_d,
        lt_node_mod           TYPE /BOBF/T_FRW_NODE_MOD,
        ls_node_mod           TYPE /BOBF/S_FRW_NODE_MOD,
        lv_index              TYPE i,
        lx_root               TYPE REF TO cx_root.

  FIELD-SYMBOLS:
        <ls_mod_do>           TYPE /BOBF/S_FRW_MODIFICATION_DO.

  lo_change ?= io_change.

  CHECK it_failed_node     IS NOT INITIAL OR
        it_failed_root_key IS NOT INITIAL.

* ___________________________________________________________________________ *
* get root keys
  IF it_failed_node IS NOT INITIAL.
    get_root_key_modify(
      EXPORTING
        it_node   = it_failed_node
        iv_state  = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
        io_change = io_change
      IMPORTING
        et_key    = lt_failed_root_key
      CHANGING
        ct_mod    = ct_mod ).

  ELSE.
    lt_failed_root_key = it_failed_root_key.
  ENDIF.

* ___________________________________________________________________________ *
* cleanup DO modifications
  LOOP AT ct_mod_do ASSIGNING <ls_mod_do>.
    LOOP AT <ls_mod_do>-modification INTO ls_mod.
      lv_index = sy-tabix.
      AT NEW change_mode.
        IF ls_mod-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
          lv_create = abap_true.
        ELSE.
          lv_create = abap_false.
        ENDIF.
      ENDAT.

      AT END OF node.
        lv_process = abap_true.
      ENDAT.

      IF lv_process = abap_false.
        AT END OF change_mode.
          IF lv_create = abap_true.
            lv_process = abap_true.
          ELSE.
            READ TABLE <ls_mod_do>-modification INTO ls_mod2 INDEX lv_index + 1.
            IF ls_mod2-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
              lv_process = abap_true.
            ENDIF.
          ENDIF.
        ENDAT.
      ENDIF.

      IF lv_create = abap_true.
        ls_key-key = ls_mod-source_key.
      ELSE.
        ls_key-key = ls_mod-key.
      ENDIF.
      APPEND ls_key TO lt_key.

      IF lv_process = abap_true.
        IF ls_mod-node = <ls_mod_do>-delegation_root_node_key AND
            lv_create  = abap_true.
          get_root_key(
            EXPORTING
              iv_node_key         = ls_mod-source_node
              it_key              = lt_key
            IMPORTING
              et_key_link         = lt_key_link ).

        ELSE.
          TRY.
              IF lo_delegation IS NOT BOUND.
                lo_delegation = get_delegation( <ls_mod_do>-delegation_root_node_key ).
              ENDIF.

              DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
              IF lv_create = abap_false.
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key         = ls_mod-node
                    it_key              = lt_key
                    iv_state            = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
                    io_read             = mo_delegation_read
                  IMPORTING
                    et_key_link         = lt_key_link ).

              ELSE.
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key         = ls_mod-source_node
                    it_key              = lt_key
                    iv_state            = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
                    io_read             = mo_delegation_read
                  IMPORTING
                    et_key_link         = lt_key_link ).
              ENDIF.
              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

        LOOP AT lt_key_link INTO ls_key_link.
          READ TABLE lt_failed_root_key WITH KEY key_sort
            COMPONENTS key = ls_key_link-target_key
            TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            IF lv_create = abap_true.
              DELETE <ls_mod_do>-modification WHERE
                  source_node = ls_mod-source_node AND
                  source_key  = ls_key_link-source_key.
              lo_change->add_change(
                iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE
                iv_node_key    = ls_mod-node
                iv_key         = ls_mod-key
                iv_failed      = abap_true ).

            ELSE.
              DELETE <ls_mod_do>-modification WHERE
                  node = ls_mod-node AND
                  key  = ls_key_link-source_key.
            ENDIF.
          ENDIF.
        ENDLOOP.

        lv_process = abap_false.
        CLEAR lt_key.
      ENDIF.
      IF <ls_mod_do>-modification IS INITIAL.
        DELETE ct_mod_do.
        EXIT.
      ENDIF.
    ENDLOOP.

    CLEAR lo_delegation.
  ENDLOOP.

* Prepare modifications table with filled root_keys for performance
  CLEAR lt_node.
  LOOP AT ct_mod INTO ls_mod WHERE root_key IS INITIAL.
    CHECK ls_mod-node <> mo_conf->ms_obj-root_node_key.
    IF ls_mod-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
      ls_node-node = ls_mod-source_node.
      ls_node-key  = ls_mod-source_key.
    ELSE.
      ls_node-node = ls_mod-node.
      ls_node-key  = ls_mod-key.
    ENDIF.
    INSERT ls_node INTO TABLE lt_node.
    IF ls_mod-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_DELETE AND
       mv_before_modification_exists = abap_true.
      lv_check_before_image = abap_true.
    ENDIF.
  ENDLOOP.
  IF lt_node IS NOT INITIAL.
    get_root_key_modify(
      EXPORTING
        it_node   = lt_node
        iv_state  = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
        io_change = io_change
      IMPORTING
        et_key    = lt_root_key
      CHANGING
        ct_mod    = ct_mod ).
  ENDIF.
  IF lv_check_before_image = abap_true.
    CLEAR lt_node.
    LOOP AT ct_mod INTO ls_mod WHERE root_key IS INITIAL.
      ls_node-node = ls_mod-node.
      ls_node-key  = ls_mod-key.
      INSERT ls_node INTO TABLE lt_node.
    ENDLOOP.
    IF lt_node IS NOT INITIAL.
      get_root_key_modify(
        EXPORTING
          it_node   = lt_node
          iv_state  = /BOBF/IF_CONF_C=>SC_STATE_BEFORE_MODIFICATION
          io_change = io_change
        IMPORTING
          et_key    = lt_root_key
        CHANGING
          ct_mod    = ct_mod ).
    ENDIF.
  ENDIF.

* ___________________________________________________________________________ *
* analyse modification tables
  LOOP AT ct_mod INTO ls_mod.    "assigning ? JS

    IF ls_mod-node = mo_conf->ms_obj-root_node_key.
      IF ls_mod-source_node = mo_conf->ms_obj-root_node_key.
        ls_key-key = ls_mod-source_key.
      ELSE.
        ls_key-key = ls_mod-key.
      ENDIF.
      sy-subrc = 0.
    ELSEIF ls_mod-root_key IS NOT INITIAL.
      ls_key-key = ls_mod-root_key.
      sy-subrc = 0.
    ELSE.
      CLEAR lt_node.
      IF ls_mod-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
        ls_node-node = ls_mod-source_node.
        ls_node-key  = ls_mod-source_key.
      ELSE.
        ls_node-node = ls_mod-node.
        ls_node-key  = ls_mod-key.
      ENDIF.
      INSERT ls_node INTO TABLE lt_node.

      get_root_key_modify(
        EXPORTING
          it_node   = lt_node
          iv_state  = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
          io_change = io_change
        IMPORTING
          et_key    = lt_root_key
        CHANGING
          ct_mod    = ct_mod ).

      IF lt_root_key IS INITIAL AND
         ls_mod-change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_DELETE AND
         mv_before_modification_exists = abap_true.

        get_root_key_modify(
          EXPORTING
            it_node   = lt_node
            iv_state  = /BOBF/IF_CONF_C=>SC_STATE_BEFORE_MODIFICATION
            io_change = io_change
          IMPORTING
            et_key    = lt_root_key
          CHANGING
            ct_mod    = ct_mod ).
      ENDIF.

      ASSERT ID /BOBF/FRW CONDITION lt_root_key IS NOT INITIAL.
      READ TABLE lt_root_key INTO ls_key INDEX 1.
    ENDIF.

    IF sy-subrc = 0.
*     check whether root key is one of the failed
      READ TABLE lt_failed_root_key WITH KEY key_sort
        COMPONENTS key = ls_key-key
        TRANSPORTING NO FIELDS.

      IF sy-subrc <> 0.
*       keep good ones
*       don't delete failed ones to get root key also for following created subnodes
        APPEND ls_mod TO lt_mod.
        CONTINUE.
      ENDIF.
    ENDIF.

*   clear tables as failed root
    CASE ls_mod-change_mode.
      WHEN /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
        DELETE ct_create
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_lock_created
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_node_state_create
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE CT_NODE_CATEGORY
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.

        lo_change->add_change(
          iv_change_mode = ls_mod-change_mode
          iv_node_key    = ls_mod-node
          iv_key         = ls_mod-key
          iv_failed      = abap_true ).

      WHEN /BOBF/IF_FRW_C=>SC_MODIFY_UPDATE.
        DELETE ct_update
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_update_data
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_update_data_all
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_update_data_sta
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_node_state_create
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        lo_change->add_change(
          iv_change_mode = ls_mod-change_mode
          iv_node_key    = ls_mod-node
          iv_key         = ls_mod-key
          iv_failed      = abap_true ).

      WHEN /BOBF/IF_FRW_C=>SC_MODIFY_DELETE.
        DELETE ct_delete
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        DELETE ct_node_state_create
          WHERE node = ls_mod-node
            AND key  = ls_mod-key.
        lo_change->add_change(
          iv_change_mode = ls_mod-change_mode
          iv_node_key    = ls_mod-node
          iv_key         = ls_mod-key
          iv_failed      = abap_true ).
    ENDCASE.
    DELETE ct_load
      WHERE node = ls_mod-node
        AND key  = ls_mod-key.
    DELETE ct_load_only_keyload
      WHERE node = ls_mod-node
        AND key  = ls_mod-key.

*   Remember node instances to clear change notifications
    ls_node_mod-node        = ls_mod-node.
    ls_node_mod-key         = ls_mod-key.
    ls_node_mod-change_mode = ls_mod-change_mode.
    INSERT ls_node_mod INTO TABLE lt_node_mod.
  ENDLOOP.

* Cleanup change notifications for failed instances
  lo_change->failed_modifications( it_node_mod = lt_node_mod ).


  ct_mod = lt_mod.

ENDMETHOD.


  METHOD cleanup_mods_from_unchanged.

*   Purpose of this method:
*   Update requests containing the same data as the already existing data
*   should be removed from all modification tables
    FIELD-SYMBOLS <ls_unchanged> TYPE /bobf/s_frw_node_data.


    CHECK it_unchanged IS NOT INITIAL.

    LOOP AT it_unchanged ASSIGNING <ls_unchanged>.

      "don't delete the record, if there's another update on the same node instance
      CHECK NOT line_exists( it_changed[ node = <ls_unchanged>-node key = <ls_unchanged>-key ] ).

      DELETE ct_update
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.
      DELETE ct_node_state_create
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.
      DELETE ct_update_data
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.
      DELETE ct_update_data_status
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.

      "don't: delete CT_MOD single-wise via secondary index `change`; This is very slow
      "do:    Mark the record for deletion. mass-delete ct_mod after this loop
      READ TABLE ct_mod ASSIGNING FIELD-SYMBOL(<ls_mod>)
        WITH TABLE KEY change
        COMPONENTS
          change_mode = /bobf/if_frw_c=>sc_modify_update
          node        = <ls_unchanged>-node
          key         = <ls_unchanged>-key.
      CHECK sy-subrc = 0."if record is part of status updates, it may not be part of ct_mod
      <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_no_change.

    ENDLOOP.

    DELETE ct_mod USING KEY change WHERE change_mode = /bobf/if_frw_c=>sc_modify_no_change.

  ENDMETHOD.


  METHOD collect_messages.
    IF io_message IS BOUND.
      IF co_message IS BOUND.
        co_message->add( io_message ).
      ELSE.
        co_message = io_message.
      ENDIF.
    ENDIF.
  ENDMETHOD.


METHOD constructor.

  DATA lx_root TYPE REF TO cx_root.
  DATA lv_trans_enqueue_scope_is_set TYPE boole_d.
  DATA lv_trans_enqueue_scope        TYPE /bobf/conf_enqueue_scope.
  DATA lv_trans_cleanup_mode_is_set  TYPE boole_d.
  DATA lv_trans_cleanup_mode         TYPE /bobf/conf_cleanup_mode.
  DATA lo_if_transaction_manager     TYPE REF TO /bobf/if_tra_transaction_mgr.
  DATA lo_transaction_manager        TYPE REF TO /bobf/cl_tra_transaction_mgr.

* set configuration object
  mo_conf = io_conf.

  TEST-SEAM on_construct.
    "allow unit tests to exit the constructor at this point
  END-TEST-SEAM.
* ___________________________________________________________________________ *
* create new buffer instance
  ASSERT ID /bobf/frw CONDITION mo_conf->ms_obj IS NOT INITIAL.

  IF mo_conf->ms_obj-buffer_class IS INITIAL.
*    todo exception
    set_configuration_error( ).
  ENDIF.

  TRY.
      CALL METHOD (mo_conf->ms_obj-buffer_class)=>/bobf/if_frw_buffer~get_instance
        EXPORTING
          iv_bo_key       = mo_conf->ms_obj-bo_key
          iv_buffer_class = mo_conf->ms_obj-buffer_class
        IMPORTING
          eo_buffer       = mo_buffer.
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

* The buffer could not be created
  IF mo_buffer IS NOT BOUND.
*    todo exception
    set_application_error( ).
  ENDIF.

* ___________________________________________________________________________ *
* switch optimized state handling off
  IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_tsto.
    mv_modifying_transaction = abap_true.
  ENDIF.

  IF mo_conf->ms_obj-has_authority_checks = abap_false OR
     mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_do.
    "not authority relevant -> create empty authority handler
    CREATE OBJECT mo_authority_handler TYPE /bobf/cl_frw_empty_auth_handlr
      EXPORTING
        io_conf = mo_conf.
  ELSE.
    CREATE OBJECT mo_authority_handler
      EXPORTING
        io_conf = mo_conf.
  ENDIF.

  /bobf/if_frw_auth_handler_inst~mo_authority_handler = mo_authority_handler.

  " set enqueue scope and cleanup mode from shared object by default
  mv_enqueue_scope = mo_conf->ms_obj-enqueue_scope.
  mv_cleanup_mode  = mo_conf->ms_obj-cleanup_mode.

  " overrule enqueue scope and cleanup mode from Transaction Manager
  " (only if the stand-alone transaction manager is used)
  lo_if_transaction_manager = /bobf/cl_tra_trans_mgr_factory=>get_transaction_manager( ).
  TRY.
      mo_non_cache_reg = CAST /bobf/cl_tra_non_cache_reg(
         CAST /bobf/if_tra_trans_mgr_compl( lo_if_transaction_manager
         )->mo_non_cache_reg ).
      lo_transaction_manager ?= lo_if_transaction_manager.

      lo_transaction_manager->get_transaction_enqueue_scope(
        IMPORTING
          ev_enqueue_scope_is_set = lv_trans_enqueue_scope_is_set
          ev_enqueue_scope        = lv_trans_enqueue_scope ).
      IF lv_trans_enqueue_scope_is_set = abap_true.
        mv_enqueue_scope = lv_trans_enqueue_scope.
      ENDIF.
      lo_transaction_manager->get_transaction_cleanup_mode(
        IMPORTING
          ev_cleanup_mode_is_set = lv_trans_cleanup_mode_is_set
          ev_cleanup_mode        = lv_trans_cleanup_mode ).
      IF lv_trans_cleanup_mode_is_set = abap_true.
        mv_cleanup_mode = lv_trans_cleanup_mode.
      ENDIF.
    CATCH cx_sy_move_cast_error ##no_handler.
  ENDTRY.

  mv_no_content_changes = CAST /bobf/if_tra_trans_mgr_compl( lo_if_transaction_manager )->mv_no_content_changes.
  mv_loadable = boolc( mo_conf->get_root_node( )-transient = abap_false ).
  TRY.
      mo_lock_manager = /bobf/cl_frw_lock_manager=>create( io_bopf = me ).
    CATCH /bobf/cm_frw INTO lx_root.
      set_configuration_error( lx_root ).
  ENDTRY.

ENDMETHOD.


METHOD convert_altern_key.

  DATA: ls_node               TYPE /bobf/s_confro_node,
        lt_failed_key         TYPE /bobf/t_frw_key,
        lt_key                TYPE /bobf/t_frw_key,
        ls_key                TYPE /bobf/s_frw_key,
        ls_empty              TYPE REF TO data,
        ls_result             TYPE /bobf/s_frw_keyindex,
        lo_message            TYPE REF TO /bobf/if_frw_message,    "#EC NEEDED
        lo_delegation         TYPE REF TO /bobf/if_frw_delegation,
        lx_root               TYPE REF TO cx_root,
        lo_auth_change        TYPE REF TO /bobf/if_frw_change,
        lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
        lt_auth_failed_key    TYPE /bobf/t_frw_key.

  FIELD-SYMBOLS: <ls_line>  TYPE any,
                 <ls_empty> TYPE any.

  CLEAR: et_result,
         et_key,
         eo_message,
         eo_change.

* ___________________________________________________________________________ *
* shortcut for KEY -> KEY without existence check
  IF iv_altkey_key      = iv_target_altkey_key                   AND
     iv_altkey_key      = /bobf/if_frw_c=>sc_alternative_key_key AND
     iv_check_existence = abap_false.
    IF iv_fill_target_key = abap_true.
      et_key = it_key.
    ENDIF.
    IF et_result IS REQUESTED.
      LOOP AT it_key INTO ls_key.
        ls_result-index = sy-tabix.
        ls_result-key   = ls_key-key.
        INSERT ls_result INTO TABLE et_result.
      ENDLOOP.
    ENDIF.
    RETURN.
  ENDIF.

* ___________________________________________________________________________ *
* get conf
  IF mo_conf->ms_last_node-node_key = iv_node_key.
    ls_node = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
      EXPORTING iv_node_key = iv_node_key
      IMPORTING es_node     = ls_node ).
  ENDIF.

* ___________________________________________________________________________ *
* check for delegation
  IF ls_node-delegation_class IS NOT INITIAL.
    IF eo_change IS NOT BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.
    TRY.
        lo_delegation = get_delegation( iv_node_key ).
        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        lo_delegation->convert_altern_key(
          EXPORTING
            iv_node_key                = iv_node_key
            iv_altkey_key              = iv_altkey_key
            iv_target_altkey_key       = iv_target_altkey_key
            it_key                     = it_key
            iv_state                   = iv_state
            iv_check_existence         = iv_check_existence
            iv_invalidate_cache        = iv_invalidate_cache
            iv_buffer_sufficient_hint  = iv_buffer_sufficient_hint
            io_change                  = eo_change
          IMPORTING
            et_result                  = et_result
            et_key                     = et_key ).
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    RETURN.
  ENDIF.

* ___________________________________________________________________________ *
* check for KEY -> KEY with existence check (on KEY)
  IF iv_altkey_key          = iv_target_altkey_key                   AND
     iv_altkey_key          = /bobf/if_frw_c=>sc_alternative_key_key AND
     ls_node-use_proxy_type = abap_false.

    retrieve(
      EXPORTING
        iv_node_key         = iv_node_key
        it_key              = it_key
        iv_state            = iv_state
        iv_fill_data        = abap_false
        iv_invalidate_cache = iv_invalidate_cache
        iv_buffer_only      = iv_buffer_sufficient_hint
      IMPORTING
        eo_change           = eo_change
        et_failed_key       = lt_failed_key ).

    LOOP AT it_key INTO ls_key.
      ls_result-index = sy-tabix.
      READ TABLE lt_failed_key WITH KEY key_sort
        COMPONENTS key = ls_key-key
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        CLEAR ls_key.
      ELSEIF et_result IS REQUESTED.
        ls_result-key   = ls_key-key.
        INSERT ls_result INTO TABLE et_result.
      ENDIF.
      IF iv_fill_target_key = abap_true.
        APPEND ls_key TO et_key.
      ENDIF.
    ENDLOOP.
    RETURN.
  ENDIF.

* ___________________________________________________________________________ *
* ask own buffer -> convert alternative key to KEY
  IF ls_node-optimized_buffer_access = abap_true.
    eo_change = /bobf/cl_frw_factory=>get_change( ).
  ENDIF.

  IF iv_altkey_key          = /bobf/if_frw_c=>sc_alternative_key_key AND
     ls_node-use_proxy_type = abap_false.
*   source key = key
    lt_key = it_key.
    IF et_result IS REQUESTED.
      LOOP AT lt_key INTO ls_key.
        ls_result-index = sy-tabix.
        ls_result-key   = ls_key-key.
        INSERT ls_result INTO TABLE et_result.
      ENDLOOP.
    ENDIF.
  ELSE.
*   source key = altern key
    TRY.
        mo_buffer->convert_altern_key(
          EXPORTING
            iv_node_key                = iv_node_key
            iv_altkey_key              = iv_altkey_key
            it_key                     = it_key
            iv_state                   = iv_state
            iv_invalidate_cache        = iv_invalidate_cache
            iv_buffer_sufficient_hint  = iv_buffer_sufficient_hint
            io_change                  = eo_change
          IMPORTING
            et_result                  = et_result ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    IF ls_node-optimized_buffer_access = abap_true.
      after_loading(
        EXPORTING
          io_change         = eo_change
          iv_load_state     = iv_state
        IMPORTING
          eo_message        = eo_message
           ).
    ENDIF.

*   source == target, but not KEY
    IF iv_altkey_key      = iv_target_altkey_key AND
       iv_fill_target_key = abap_true.
      CREATE DATA ls_empty LIKE LINE OF it_key.
      ASSIGN ls_empty->* TO <ls_empty>.
      LOOP AT it_key ASSIGNING <ls_line>.
        READ TABLE et_result TRANSPORTING NO FIELDS
          WITH KEY index = sy-tabix.
        IF sy-subrc = 0.
          APPEND <ls_line> TO et_key.
        ELSE.
          APPEND <ls_empty> TO et_key.
        ENDIF.
      ENDLOOP.
      lt_key = et_key.
    ELSE.
*     build LT_KEY
      DO lines( it_key ) TIMES.
        APPEND ls_key TO lt_key.
      ENDDO.
      LOOP AT et_result INTO ls_result.
        ls_key-key = ls_result-key.
        MODIFY lt_key INDEX ls_result-index FROM ls_key.
      ENDLOOP.
    ENDIF.

*   check authorization: filter out non-authorized keys
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-convert_altern_key
                                    bo_service          = space
                                    node_key            = iv_node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = lt_auth_failed_key
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).
    IF eo_change IS BOUND.
      eo_change->merge( lo_auth_change ).
    ELSE.
      eo_change = lo_auth_change.
    ENDIF.
    " update exporting table for result
    LOOP AT lt_auth_failed_key INTO ls_key.
      DELETE et_result WHERE key = ls_key-key.        "#EC CI_SORTSEQ
    ENDLOOP.

*   source == target, but not KEY
    IF iv_altkey_key      = iv_target_altkey_key AND
       iv_fill_target_key = abap_true.
      " update exporting table for key
      et_key = lt_key.
      RETURN.
    ENDIF.
  ENDIF.

* ___________________________________________________________________________ *
* ask own buffer -> convert KEY to altern key
  IF iv_fill_target_key = abap_true. " et_key is requested
    IF iv_target_altkey_key   = /bobf/if_frw_c=>sc_alternative_key_key AND
       ls_node-use_proxy_type = abap_false.
*     target key = key
      et_key = lt_key.
    ELSE.
*     target_key = altern key
      TRY.
          mo_buffer->retrieve_altern_key(
            EXPORTING
              iv_node_key         = iv_node_key
              iv_altkey_key       = iv_target_altkey_key
              it_key              = lt_key
              iv_state            = iv_state
              iv_invalidate_cache = iv_invalidate_cache
              io_change           = eo_change
            IMPORTING
              et_key              = et_key
              et_failed_key       = lt_failed_key ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      IF ls_node-optimized_buffer_access = abap_true.
        after_loading(
          EXPORTING
            io_change         = eo_change
            iv_load_state     = iv_state ).
      ENDIF.

      LOOP AT lt_failed_key INTO ls_key.
        DELETE et_result WHERE key = ls_key-key.        "#EC CI_SORTSEQ
      ENDLOOP.
    ENDIF.
  ENDIF.

ENDMETHOD.


  METHOD convert_asc_src_to_cont_change.
    DATA ls_content_chg TYPE /bobf/s_frw_change_content.

    CHECK mv_no_content_changes = abap_false.
    CHECK it_association_source IS NOT INITIAL.

    mo_conf->get_assoc_tab( IMPORTING et_comp  = DATA(lt_composition)
                                      et_assoc = DATA(lt_association) ).

    ls_content_chg-change_mode = /bobf/if_frw_c=>sc_modify_association.

    LOOP AT it_association_source ASSIGNING FIELD-SYMBOL(<ls_comp_spec_id>).

      ASSERT <ls_comp_spec_id>-parent_key IS NOT INITIAL AND
             <ls_comp_spec_id>-parent_node_key IS NOT INITIAL AND
             <ls_comp_spec_id>-node_key IS NOT INITIAL.

      ls_content_chg-key      = <ls_comp_spec_id>-parent_key.
      ls_content_chg-node_key = <ls_comp_spec_id>-parent_node_key.

      CASE <ls_comp_spec_id>-association_kind.

        WHEN /bobf/if_conf_c=>sc_assoc_kind_composition. " Composition
          READ TABLE lt_composition ASSIGNING FIELD-SYMBOL(<ls_composition>) WITH KEY target_key
                                                                           COMPONENTS target_node_key = <ls_comp_spec_id>-node_key
                                                                                      source_node_key = <ls_comp_spec_id>-parent_node_key.
          ASSERT sy-subrc = 0.
          ls_content_chg-content_key = <ls_composition>-assoc_key.
          APPEND ls_content_chg TO rt_content_change.

        WHEN /bobf/if_conf_c=>sc_assoc_kind_specialization. " Specialization
          LOOP AT lt_association ASSIGNING FIELD-SYMBOL(<ls_assoc>) USING KEY key3
            WHERE source_node_key = <ls_comp_spec_id>-parent_node_key
            AND assoc_cat         = /bobf/if_conf_c=>sc_assoccat_specialization
            AND assoc_type        = /bobf/if_conf_c=>sc_assoctype_std
            AND target_node_key   = <ls_comp_spec_id>-node_key.

            ls_content_chg-content_key = <ls_assoc>-assoc_key.
            APPEND ls_content_chg TO rt_content_change.
          ENDLOOP.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.


 METHOD create.

   DATA: lo_int_access      TYPE REF TO /bobf/cl_frw_int_access,
         ls_assoc           TYPE /bobf/s_confro_assoc,
         ls_assoc_context   TYPE /bobf/s_frw_ctx_assoc,
         ls_assoc_class     TYPE ty_association,
         lt_failed_key      TYPE /bobf/t_frw_key,
         lt_key             TYPE /bobf/t_frw_key,
         ls_key             TYPE /bobf/s_frw_key,
         lt_key_link        TYPE /bobf/t_frw_key_link,
         lt_mod             TYPE /bobf/t_frw_modification,
         ls_mod             TYPE /bobf/s_frw_modification,
         ls_mod_tmp         TYPE /bobf/s_frw_modification,
         lo_message         TYPE REF TO /bobf/if_frw_message,
         lm_message_esi     TYPE REF TO /bobf/cm_frw_common_esi,
         ls_origin_location TYPE /bobf/s_frw_location,
         lx_root            TYPE REF TO cx_root,
         lv_node_proxy_name TYPE string.


   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   CLEAR eo_message.

   READ TABLE it_mod INDEX 1 INTO ls_mod.
   IF mo_conf->ms_last_assoc-assoc_key = ls_mod-association.
     ls_assoc = mo_conf->ms_last_assoc.
   ELSE.
     mo_conf->get_assoc(
       EXPORTING iv_assoc_key  = ls_mod-association
       IMPORTING es_assoc      = ls_assoc ).
   ENDIF.

* ___________________________________________________________________________ *
*  existency check for source key
   lt_mod = it_mod.

   IF ls_assoc-source_node_key = ls_assoc-target_node_key. " only for hierarchical creates on one node type
     LOOP AT lt_mod INTO ls_mod.
       READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY change
         COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                    node        = ls_mod-source_node
                    key         = ls_mod-source_key.
       IF sy-subrc <> 0.
         ls_key-key = ls_mod-source_key.
         APPEND ls_key TO lt_key.
       ENDIF.
     ENDLOOP.
   ELSE.
     LOOP AT lt_mod INTO ls_mod.
       ls_key-key = ls_mod-source_key.
       APPEND ls_key TO lt_key.
     ENDLOOP.
   ENDIF.
   SORT lt_key.
   DELETE ADJACENT DUPLICATES FROM lt_key.

   retrieve(
     EXPORTING
       iv_node_key         = ls_assoc-source_node_key
       it_key              = lt_key
       iv_state            = iv_state
       iv_fill_data        = abap_false
     IMPORTING
       eo_message          = lo_message
       et_failed_key       = lt_failed_key ).

   LOOP AT lt_failed_key INTO ls_key.
     LOOP AT lt_mod INTO ls_mod USING KEY source
       WHERE source_node = ls_assoc-source_node_key
         AND source_key  = ls_key-key.
       io_change->add_change(
           iv_change_mode = /bobf/if_frw_c=>sc_modify_create
           iv_node_key    = ls_assoc-target_node_key
           iv_key         = ls_mod-key
           iv_failed      = abap_true ).
       DELETE lt_mod USING KEY loop_key.
     ENDLOOP.
   ENDLOOP.

   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = eo_message ).

* ___________________________________________________________________________ *
*  Check for 1:0..1 and 1:1 delegated objects if cardinality would be violated by create
   IF ls_assoc-target_node->delegation_class IS NOT INITIAL AND
      ( ls_assoc-cardinality = /bobf/if_conf_c=>sc_card_zero_to_one OR
        ls_assoc-cardinality = /bobf/if_conf_c=>sc_card_one ).
     retrieve_by_association(
       EXPORTING
         iv_node_key         = ls_assoc-source_node_key
         it_key              = lt_key
         iv_association      = iv_assoc_key
         iv_state            = iv_state
       IMPORTING
         eo_message          = lo_message
         et_key_link         = lt_key_link ).
     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

     IF lt_key_link IS NOT INITIAL.
       LOOP AT lt_mod INTO ls_mod USING KEY source
         WHERE source_node = ls_assoc-source_node_key.

         READ TABLE lt_key_link WITH KEY source_key = ls_mod-source_key TRANSPORTING NO FIELDS.
         IF sy-subrc = 0.

           io_change->add_change(
              iv_change_mode = /bobf/if_frw_c=>sc_modify_create
              iv_node_key    = ls_assoc-target_node_key
              iv_key         = ls_mod-key
              iv_failed      = abap_true ).
           DELETE lt_mod USING KEY loop_key.

           IF eo_message IS NOT BOUND.
             eo_message = /bobf/cl_frw_factory=>get_message( ).
           ENDIF.

           ls_origin_location-node_key = ls_mod-source_node.
           ls_origin_location-key      = ls_mod-source_key.

           lv_node_proxy_name = ls_assoc-target_node->node_name.
           CREATE OBJECT lm_message_esi
             EXPORTING
               textid              = /bobf/cm_frw_common_esi=>cm_node_not_more_than_one
               severity            = /bobf/cm_frw=>co_severity_error
               symptom             = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
               lifetime            = /bobf/cm_frw=>co_lifetime_transition
               ms_origin_location  = ls_origin_location
               mv_assoc_key        = iv_assoc_key
               cmn_node_proxy_name = lv_node_proxy_name.

           eo_message->add_cm( lm_message_esi ).

         ENDIF.
       ENDLOOP.
     ENDIF.

*    Check for duplicate instances to be created under same source instance
     LOOP AT lt_mod INTO ls_mod USING KEY source
       WHERE source_node = ls_assoc-source_node_key.
       READ TABLE lt_mod INTO ls_mod_tmp INDEX sy-tabix + 1 USING KEY source.
       IF sy-subrc = 0 AND
          ls_mod-source_node = ls_mod_tmp-source_node AND
          ls_mod-source_key  = ls_mod_tmp-source_key.

         io_change->add_change(
            iv_change_mode = /bobf/if_frw_c=>sc_modify_create
            iv_node_key    = ls_assoc-target_node_key
            iv_key         = ls_mod-key
            iv_failed      = abap_true ).
         DELETE lt_mod USING KEY loop_key.

         IF eo_message IS NOT BOUND.
           eo_message = /bobf/cl_frw_factory=>get_message( ).
         ENDIF.

         ls_origin_location-node_key = ls_mod-source_node.
         ls_origin_location-key      = ls_mod-source_key.

         lv_node_proxy_name = ls_assoc-target_node->node_name.
         CREATE OBJECT lm_message_esi
           EXPORTING
             textid              = /bobf/cm_frw_common_esi=>cm_node_not_more_than_one
             severity            = /bobf/cm_frw=>co_severity_error
             symptom             = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
             lifetime            = /bobf/cm_frw=>co_lifetime_transition
             ms_origin_location  = ls_origin_location
             mv_assoc_key        = iv_assoc_key
             cmn_node_proxy_name = lv_node_proxy_name.

         eo_message->add_cm( lm_message_esi ).

       ENDIF.
     ENDLOOP.

   ENDIF.

* ___________________________________________________________________________ *
*  call association class to perform create
   CHECK lt_mod IS NOT INITIAL.
   /bobf/cl_frw_int_access=>new_instance(
     EXPORTING
       io_bopf            = me
       io_conf            = mo_conf
       io_buffer          = mo_buffer
       io_change          = io_change
     RECEIVING
       eo_internal_access = lo_int_access
   ).
   ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
   INSERT lo_int_access INTO mt_access_stack INDEX 1.

   lo_int_access->set_current_state( iv_current_state = iv_state ).
   lo_int_access->set_edit_mode( iv_edit_mode ).
   ls_assoc_context-bo_key        = mo_conf->ms_obj-bo_key.
   ls_assoc_context-root_node_key = mo_conf->ms_obj-root_node_key.
   ls_assoc_context-node_key      = ls_assoc-source_node_key.
   ls_assoc_context-assoc_key     = ls_assoc-assoc_key.
   lo_int_access->set_context(
     is_association     = ls_assoc_context
     iv_read_allowed    = abap_true
     iv_modify_allowed  = abap_true
     iv_within_loading  = iv_within_loading
      iv_loading_node_key = iv_loading_node_key
     iv_within_retrieve = iv_within_retrieve ).

*  get assoc class
   READ TABLE mt_association
      WITH TABLE KEY assoc_key = iv_assoc_key
      INTO ls_assoc_class.
   IF sy-subrc <> 0.
     ls_assoc_class-assoc_key = iv_assoc_key.
     CREATE OBJECT ls_assoc_class-class TYPE (ls_assoc-assoc_class).
     INSERT ls_assoc_class INTO TABLE mt_association.
   ENDIF.

   ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>no_children_existing(
           it_mod_create = lt_mod
           is_assoc      = ls_assoc
           io_assoc      = ls_assoc_class-class
           is_ctx_assoc  = ls_assoc_context
           io_read       = lo_int_access ) = abap_true.

   TRY.
       ls_assoc_class-class->create(
         EXPORTING
           is_ctx          = ls_assoc_context
           it_modification = lt_mod
           io_read         = lo_int_access
           io_modify       = lo_int_access
         IMPORTING
           eo_message      = lo_message ).
     CATCH cx_root INTO lx_root.                         "#EC CATCH_ALL
       set_application_error( lx_root ).
   ENDTRY.

   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = eo_message ).

*  check for undone modifications and flush
   IF lo_int_access->mt_modification IS NOT INITIAL.
     lo_int_access->end_modify( ).
   ENDIF.
   collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                     CHANGING  co_message = eo_message ).

   lo_int_access->invalidate( ).
   ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
   DELETE mt_access_stack INDEX 1.

 ENDMETHOD.


  METHOD CREATE_DURABLE_MSG_CONTAINER.
    IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft AND /bobf/cl_frw_message_factory=>use_durable_message( ).
      " Int. Incident 1570795951: A BO can be an old style transactional BO but have an action that calls a service using
      " Gateway. This is the point where SADL initialize our /BOBF/CL_SADL_TRANSACTION_MNGR with entity_type = CDS and enables
      " durable messages. After finishing the action the runtime is again in a transactional environment but durable message are still enabled.
      IF co_message IS NOT BOUND.
        " If durable messages shall be used, we need a message container even if no container was returned from the application
        " This empty message container will invalidate all messages that were raises previously in this context
        co_message = /bobf/cl_frw_message_factory=>create_container( ).
      ELSE.   "IF lines( co_message->get( importing et_message = DATA(lt_message) ) > 0.
        " The application has returned a message container
        " Check, that the returned message container has an unfinalized (initial) invalidation context. This context
        " is needed to invalidate messages that were raises previously in this context
        " This can happen, if the application just forwards a message container that was received by a nested BO call (e.g. an action calls an action)
          CAST /bobf/cl_frw_durable_message( co_message )->check_and_add_default_invalctx( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.


METHOD create_states.

  DATA:
        lt_root_key  TYPE /bobf/t_frw_key,
        lt_root_node TYPE /bobf/t_frw_node,
        lt_additional_state_dest      TYPE /bobf/if_frw_buffer=>tt_state,
        lv_add_state_dest_transferred TYPE boole_d,
        lv_state_dest                 TYPE /bobf/conf_state,
        lx_root                       TYPE REF TO cx_root.

  TRY.
      mo_buffer->get_root_keys(
         EXPORTING
           iv_changed_only = abap_false
         IMPORTING
           et_root_key     = lt_root_key ).
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

  CHECK lt_root_key IS NOT INITIAL.

  map_to_node(
    EXPORTING
      iv_node_key = mo_conf->ms_obj-root_node_key
      it_key      = lt_root_key
    IMPORTING
      et_node     = lt_root_node ).

  TRY.
      IF mo_conf->ms_obj-last_val_state_not_relevant = abap_false.
        APPEND /bobf/if_conf_c=>sc_state_last_validated TO lt_additional_state_dest.
      ENDIF.

      IF mo_conf->ms_obj-last_det_state_not_relevant = abap_false.
        APPEND /bobf/if_conf_c=>sc_state_last_determined TO lt_additional_state_dest.
      ENDIF.

      mo_buffer->transfer_state(
        EXPORTING
          it_node         = lt_root_node
          iv_incl_subtree = abap_true
          iv_state_source = /bobf/if_conf_c=>sc_state_current
          iv_state_dest   = /bobf/if_conf_c=>sc_state_database
          it_additional_state_dest = lt_additional_state_dest
        IMPORTING
          ev_add_state_dest_transferred = lv_add_state_dest_transferred
        ).
      IF lv_add_state_dest_transferred = abap_false.
        LOOP AT lt_additional_state_dest INTO lv_state_dest.
          mo_buffer->transfer_state(
            EXPORTING
            it_node         = lt_root_node
            iv_incl_subtree = abap_true
            iv_state_source = /bobf/if_conf_c=>sc_state_current
              iv_state_dest   = lv_state_dest
            ).
        ENDLOOP.
      ENDIF.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

ENDMETHOD.


METHOD derive_consistency_status.

  DATA: lt_val_list       TYPE /bobf/t_confro_val_list,
        ls_val_list       TYPE /bobf/s_confro_val_list,
        ls_assoc          TYPE /bobf/s_confro_assoc,
        ls_failed_val     TYPE /bobf/s_frw_validations,
        ls_group          TYPE /bobf/s_confro_group,
        lt_key            TYPE /bobf/t_frw_key,
        lt_relevant_key   TYPE /bobf/t_frw_key,
        lt_key_parent     TYPE /bobf/t_frw_key,
        ls_key            TYPE /bobf/s_frw_key,
        lv_start_node_key TYPE /bobf/obm_node_key,
        lv_group_node_key TYPE /bobf/obm_node_key,
        lo_message        TYPE REF TO /bobf/if_frw_message.

  FIELD-SYMBOLS:
          <ls_group>             TYPE /bobf/s_frw_group.


  CLEAR eo_message.

* if no validation failed the CT_GROUP can remain unchanged, because
* the corresponding default status value is already set by GET_RELEVANT_GROUPS
  CHECK it_failed_val IS NOT INITIAL
    AND ct_group      IS NOT INITIAL.

  mo_conf->get_validation( IMPORTING et_val_list = lt_val_list ).
  SORT lt_val_list.

  LOOP AT it_failed_val INTO ls_failed_val.
*   collect all key to the same validation
    ls_key-key = ls_failed_val-key.
    APPEND ls_key TO lt_relevant_key.

    AT END OF val_key.
      READ TABLE lt_val_list INTO ls_val_list BINARY SEARCH
        WITH KEY val_key = ls_failed_val-val_key.
      ASSERT ID /bobf/frw_error CONDITION sy-subrc = 0. " validation not assigned to a group

*     and loop over its groups
      LOOP AT ls_val_list-val_group->* INTO ls_group.
*       check whether this validation belongs to a group that is looked at
        READ TABLE ct_group TRANSPORTING NO FIELDS
          WITH KEY group_key = ls_group-group_key.
        CHECK sy-subrc = 0.

        lt_key            = lt_relevant_key.
        lv_start_node_key = ls_val_list-node_key.  " source node
        lv_group_node_key = ls_group-node_key.     " target node

*       navigate up to the node the group belongs to (same code as in GET_RELEVANT_GROUPS)
        DO.
          IF lv_start_node_key = lv_group_node_key.
            EXIT.
          ENDIF.

*         navigate TO_PARENT
          mo_conf->get_assoc(
            EXPORTING
              iv_node_key  = lv_start_node_key
              iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
            IMPORTING
              es_assoc     = ls_assoc ).
          IF ls_assoc IS INITIAL.
*           no association to parent found
            set_application_error( ).
          ENDIF.

          retrieve_by_association(
            EXPORTING
              iv_node_key    = lv_start_node_key
              it_key         = lt_key
              iv_association = ls_assoc-assoc_key
              iv_state       = /bobf/if_conf_c=>sc_state_current
            IMPORTING
              eo_message     = lo_message
              et_target_key  = lt_key_parent ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          lt_key            = lt_key_parent.
          lv_start_node_key = ls_assoc-target_node_key.
        ENDDO.

*       set the consistency status to inconsistent if the instances match
        LOOP AT lt_key INTO ls_key.
          READ TABLE ct_group ASSIGNING <ls_group>
            WITH KEY group_key = ls_group-group_key
                     key       = ls_key-key.
          IF sy-subrc = 0.
            <ls_group>-status_value = /bobf/if_frw_c=>sc_status_inconsistent.
          ENDIF.
        ENDLOOP.
      ENDLOOP.

      CLEAR lt_relevant_key.
    ENDAT.

  ENDLOOP.

ENDMETHOD.


  METHOD determine_triggered_val_keys.

    DATA lt_key3 TYPE /bobf/t_frw_key.
    DATA lt_key_missing TYPE /bobf/t_frw_key.
    DATA lt_val_key_missing TYPE /bobf/t_frw_key.

    CLEAR et_key.

    LOOP AT is_validation-val_trigger->* ASSIGNING FIELD-SYMBOL(<ls_val_trigger>).

      IF <ls_val_trigger>-assoc IS BOUND.
        DATA(lv_node_key) = <ls_val_trigger>-assoc->source_node_key.
      ELSE.
        lv_node_key = is_validation-node_key.
      ENDIF.

      DATA(ls_change_mode) = <ls_val_trigger>-change_mode.
      IF iv_use_check_trigger = abap_false. " do not trigger in check
        ls_change_mode-check = abap_false.
      ENDIF.

      get_validation_trigger( EXPORTING iv_processing_mode = iv_processing_mode
                                        is_change_mode     = ls_change_mode
                                        iv_node_key        = lv_node_key
                                        io_change          = io_change
                              IMPORTING et_key             = DATA(lt_key) ).

      CHECK lt_key IS NOT INITIAL.

      IF <ls_val_trigger>-assoc IS BOUND.
*        association defined from trigger-node to node to be validated
*        -> retrieve node to be validated
        retrieve_by_association(
          EXPORTING
            iv_node_key    = <ls_val_trigger>-node_key
            it_key         = lt_key
            iv_association = <ls_val_trigger>-assoc->assoc_key
            iv_state       = /bobf/if_conf_c=>sc_state_current
          IMPORTING
            eo_message     = DATA(lo_message)
            et_key_link    = DATA(lt_key_link)
            et_target_key  = DATA(lt_key2) ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>is_key_link_matching(
                                                              it_key        = lt_key
                                                              it_key_link   = lt_key_link
                                                              it_target_key = lt_key2 ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = co_message ).
        APPEND LINES OF lt_key2 TO lt_key3.
        CLEAR lt_key2.

        IF <ls_val_trigger>-delete = abap_true.
*          check if changed key-table is incomplete due to deleted
*          trigger keys. if yes -> add nodes
          CLEAR lt_key_missing.
          CLEAR lt_val_key_missing.
          LOOP AT lt_key INTO DATA(ls_key1).
            READ TABLE lt_key_link WITH KEY
                source_key = ls_key1-key
                TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              CONTINUE.
            ENDIF.
            INSERT ls_key1 INTO TABLE lt_key_missing.
          ENDLOOP.
          IF lt_key_missing IS NOT INITIAL.
            retrieve_by_association(
              EXPORTING
                iv_node_key    = <ls_val_trigger>-assoc->source_node_key
                it_key         = lt_key_missing
                iv_association = <ls_val_trigger>-assoc->assoc_key
                iv_state       = iv_last_state
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_val_key_missing ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = co_message ).

            TRY.
                "check existence of association's target node key
                mo_buffer->retrieve(
                  EXPORTING
                    iv_node_key       = <ls_val_trigger>-assoc->target_node_key
                    it_key            = lt_val_key_missing
                    iv_state          = /bobf/if_conf_c=>sc_state_current
                    iv_fill_data      = abap_false
                    io_change         = io_change
                  IMPORTING
                    et_failed_key     = DATA(lt_failed_key)
                ).

                APPEND LINES OF
                   FILTER #( lt_val_key_missing EXCEPT IN lt_failed_key USING KEY key_sort WHERE key = key )
                   TO lt_key3. "adding existing keys
              CATCH cx_root INTO DATA(lx_root).          "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

          ENDIF.
        ENDIF.

      ELSE.
*        check existence of instances
        retrieve(
          EXPORTING
            iv_node_key             = <ls_val_trigger>-node_key
            it_key                  = lt_key
            iv_state                = /bobf/if_conf_c=>sc_state_current
            iv_fill_data            = abap_false
          IMPORTING
            et_failed_key           = lt_key2 ).

*        lt_key3 = lt_key.   " Internal incident #1770153074
        APPEND LINES OF lt_key TO lt_key3.
        DELETE ADJACENT DUPLICATES FROM lt_key3 USING KEY key_sort.
        LOOP AT lt_key2 INTO DATA(ls_key2).
          DELETE TABLE lt_key3 WITH TABLE KEY key_sort COMPONENTS key = ls_key2-key.
        ENDLOOP.
        CLEAR lt_key2.
      ENDIF.

    ENDLOOP.

    et_key = lt_key3.

    CHECK et_key IS NOT INITIAL.
    SORT et_key.
    DELETE ADJACENT DUPLICATES FROM et_key.

  ENDMETHOD.


 METHOD do_action.

   DATA: ls_actconf               TYPE /bobf/s_confro_act_list,
         ls_actwrite              TYPE /bobf/s_confro_act_write,
         lo_delegation            TYPE REF TO /bobf/if_frw_delegation,
         lt_node                  TYPE /bobf/t_frw_node,
         lt_failed_node           TYPE /bobf/t_frw_node,
         lt_node_reload           TYPE /bobf/t_frw_node,
         lt_node_all_reload       TYPE /bobf/t_frw_node,
         ls_node                  TYPE /bobf/s_frw_node,
         lt_action_key            TYPE /bobf/t_frw_key,
         lt_failed_key            TYPE /bobf/t_frw_key,
         lt_key                   TYPE /bobf/t_frw_key,
         ls_key                   TYPE /bobf/s_frw_key,
         ls_context               TYPE /bobf/s_frw_ctx_act,
         ls_runtime_context       TYPE /bobf/s_frw_runtime_context,
         ls_param_lock            TYPE /bobf/s_frw_lock_parameters,
         ls_param_lock_r          TYPE REF TO /bobf/s_frw_lock_parameters,
         lo_message               TYPE REF TO /bobf/if_frw_message,
         lo_message_int           TYPE REF TO /bobf/cl_frw_message,
         lo_auth_check            TYPE REF TO /bobf/cl_frw_authority_check,
         lx_root                  TYPE REF TO cx_root,
         lv_prev_privileged_mode  TYPE c length 1,
         lt_key_link              TYPE /bobf/t_frw_key_link,
         ls_key_link              TYPE /bobf/s_frw_key_link,
         lv_check_property        TYPE boole_d,
         lv_load_subtree          TYPE /bobf/frw_load_subtree,
         lt_action_execution_list TYPE /bobf/t_frw_key2,
         ls_failed_key            TYPE /bobf/s_frw_key,
         lv_action_execution_list TYPE /bobf/conf_key.

   FIELD-SYMBOLS: <ls_lockparam> TYPE /bobf/s_frw_lock_parameters.

   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   CLEAR: eo_message,
          eo_change,
          et_failed_key.

   lt_action_key = is_action-key.

*  ____________________________________________________________________ *
*  get configuration
   IF mo_conf->ms_last_action-act_key = is_action-act_key.
     ls_actconf = mo_conf->ms_last_action.
   ELSE.
     mo_conf->get_act(
       EXPORTING iv_act_key = is_action-act_key
       IMPORTING es_action  = ls_actconf ).
     IF ls_actconf IS INITIAL.
*      unknown action
       set_configuration_error( ).
     ENDIF.
   ENDIF.

*____________________________________________________________________ *
*  check for delegated action
   IF mo_conf->ms_last_node-node_key <> ls_actconf-node_key.
     mo_conf->get_node( iv_node_key = ls_actconf-node_key ).
   ENDIF.
   IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
*    delegate action
     TRY.
         eo_change = /bobf/cl_frw_factory=>get_change( ).
         lt_key = is_action-key.
         mo_authority_handler->check_authority(
           EXPORTING
             is_ctx           = VALUE #(
                                 activity = /bobf/cl_frw_authority_check=>sc_activity-execute
                                 bo_service = ls_actconf-act_name
                                 node_key = ls_actconf-node_key )
             io_change        = eo_change
             io_bopf          = me
             io_buffer        = mo_buffer
             iv_cleanse_keys  = abap_true
             iv_last_state    = /bobf/if_conf_c=>sc_state_database
             iv_current_state = /bobf/if_conf_c=>sc_state_current
           IMPORTING
             et_failed_key    = et_failed_key
           CHANGING
             ct_access_stack  = mt_access_stack
             ct_key           = lt_key
             co_message       = eo_message
         ).

         IF lt_key IS NOT INITIAL
           OR is_action-key IS INITIAL. " _static_ action // IM 1648217 (2013)
*          delegate action
           lo_delegation = get_delegation( ls_actconf-node_key ).
           lv_prev_privileged_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
           lo_delegation->do_action(
             EXPORTING
               is_action               = VALUE #(
                                           act_key = is_action-act_key
                                           key = lt_key
                                           parameters = is_action-parameters )
               io_change               = eo_change
             IMPORTING
               eo_message              = lo_message
               et_failed_key           = lt_failed_key
               ev_static_action_failed = ev_static_action_failed ).
           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).

           collect_messages( EXPORTING io_message = lo_message
                             CHANGING  co_message = eo_message ).

           APPEND LINES OF lt_failed_key TO et_failed_key.
         ENDIF.
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.

     IF mv_modifying_transaction = abap_false AND
        eo_change IS BOUND AND
        ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
          eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
          eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).
       create_states( ).
       mv_modifying_transaction = abap_true.
     ENDIF.

*    perform determination and validation
     IF iv_with_detval       = abap_true AND
        mv_no_determinations = abap_false.
       do_detval(
         EXPORTING io_change                  = eo_change
                   iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_action
         IMPORTING eo_message                 = lo_message ).

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).
     ENDIF.
     RETURN.
   ENDIF.

*  ____________________________________________________________________ *
*  if lock action is called -> call locking
   IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_lock     OR
      ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_unlock.
*    object does not have any lock nodes
     ASSERT ID /bobf/frw CONDITION mo_conf->ms_obj-no_lock = abap_false.

     IF is_action-parameters IS BOUND.
       ASSIGN is_action-parameters->* TO <ls_lockparam>.
     ELSE.
       ls_param_lock-all_none = abap_false.
       ls_param_lock-scope    = mv_enqueue_scope.
       IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_lock.
         ls_param_lock-edit_mode = /bobf/if_conf_c=>sc_edit_exclusive.
       ENDIF.
       ASSIGN ls_param_lock TO <ls_lockparam>.
     ENDIF.

*    check action
     GET REFERENCE OF <ls_lockparam> INTO ls_param_lock_r.
     IF eo_change IS NOT BOUND.
       eo_change = /bobf/cl_frw_factory=>get_change( ).
     ENDIF.

     ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset_stack_set(
          it_key_set = lt_action_key ) = abap_true.

     IF iv_internal_call = abap_false.
       lv_check_property = abap_true.
     ENDIF.

     check_action(
       EXPORTING
         iv_act_key          = is_action-act_key
         is_parameters       = ls_param_lock_r
         iv_check_property   = lv_check_property
         iv_check_validation = abap_true
         io_change           = eo_change
       IMPORTING
         et_failed_key       = lt_failed_key
         eo_message          = eo_message
       CHANGING
         ct_key              = lt_action_key ).

     ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset_stack_check(
            it_key_subset = lt_failed_key ) = abap_true.

     APPEND LINES OF lt_failed_key TO et_failed_key.

     IF lt_action_key IS NOT INITIAL.
       ls_node-node = ls_actconf-node_key.
       LOOP AT lt_action_key INTO ls_key.
         ls_node-key = ls_key-key.
         INSERT ls_node INTO TABLE lt_node.
       ENDLOOP.

       IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_lock.
         mo_lock_manager->lock(
           EXPORTING
             it_node                       = lt_node
             iv_edit_mode                  = <ls_lockparam>-edit_mode
             iv_generic                    = <ls_lockparam>-generic
             iv_scope                      = <ls_lockparam>-scope
             iv_all_none                   = <ls_lockparam>-all_none
             io_change                     = eo_change
           IMPORTING
             eo_message                    = lo_message
             et_lockable_node_newly_locked = lt_node_reload
             et_node_not_locked            = lt_failed_node ).
       ELSE.
         mo_lock_manager->unlock(
           EXPORTING
             it_node                       = lt_node
             iv_generic                    = <ls_lockparam>-generic
             iv_scope                      = <ls_lockparam>-scope
             iv_all_none                   = <ls_lockparam>-all_none
             io_change                     = eo_change
           IMPORTING
             eo_message                    = lo_message
             et_lockable_node_newly_locked = lt_node_reload
             et_node_not_locked            = lt_failed_node ).
       ENDIF.

       ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_node_subset(
               it_node_set    = lt_node
               it_node_subset = lt_failed_node ) = abap_true.

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).

       LOOP AT lt_failed_node INTO ls_node
         WHERE node = ls_actconf-node_key.
         ls_key-key = ls_node-key.
         INSERT ls_key INTO TABLE et_failed_key.
       ENDLOOP.

       IF <ls_lockparam>-force_invalidation = abap_true AND
          ls_actconf-act_cat                = /bobf/if_conf_c=>sc_action_lock.
         lt_node_reload = lt_node.
       ENDIF.

*      reload newly locked nodes
       IF lt_node_reload IS NOT INITIAL.
         IF <ls_lockparam>-generic = abap_false.
           lv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup.
         ELSE.
           lv_load_subtree = /bobf/if_frw_c=>sc_load_whole_subtree.
         ENDIF.
         do_loading(
           EXPORTING
             it_node         = lt_node_reload
             iv_reload       = abap_true
             iv_load_data    = abap_true
             iv_check_buf    = abap_false
             iv_load_subtree = lv_load_subtree
             iv_edit_mode    = <ls_lockparam>-edit_mode
             io_change       = eo_change
           IMPORTING
             eo_message      = lo_message ).

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).
       ENDIF.

     ENDIF.
     RETURN.
   ENDIF.

*  ____________________________________________________________________ *
*  check if write nodes of the action have sufficient locking
   IF ls_actconf-edit_mode <> /bobf/if_conf_c=>sc_edit_read_only AND
      lt_action_key IS NOT INITIAL.
     LOOP AT ls_actconf-act_write->* INTO ls_actwrite.
       IF ls_actwrite-assoc IS BOUND.
         retrieve_by_association(
           EXPORTING
             iv_node_key    = ls_actconf-node_key
             it_key         = lt_action_key
             iv_association = ls_actwrite-assoc->assoc_key
             iv_state       = /bobf/if_conf_c=>sc_state_current
           IMPORTING
             eo_message     = lo_message
             et_key_link    = lt_key_link
             et_failed_key  = lt_failed_key
             et_target_key  = lt_key ).

         ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset(
                 it_key_set    = lt_action_key
                 it_key_subset = lt_failed_key ) = abap_true.
         ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_link_matching(
                it_key        = lt_action_key
                it_key_link   = lt_key_link
                it_target_key = lt_key ) = abap_true.

         APPEND LINES OF lt_failed_key TO et_failed_key.

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).

         map_to_node(
           EXPORTING
             iv_node_key = ls_actwrite-assoc->target_node_key
             it_key      = lt_key
           IMPORTING
             et_node     = lt_node ).
       ELSE.
         map_to_node(
           EXPORTING
             iv_node_key = ls_actconf-node_key
             it_key      = lt_action_key
           IMPORTING
             et_node     = lt_node ).
       ENDIF.

       IF lt_node IS NOT INITIAL.

*      check locks of write nodes and lock if necessary
         IF eo_change IS NOT BOUND.
           eo_change = /bobf/cl_frw_factory=>get_change( ).
         ENDIF.
         mo_lock_manager->lock(
           EXPORTING
             iv_edit_mode = ls_actconf-edit_mode
             iv_all_none  = ls_actconf-exec_only_all
             it_node      = lt_node
             io_change    = eo_change
             iv_generic   = abap_false
           IMPORTING
             eo_message                    = lo_message
             et_lockable_node_newly_locked = lt_node_reload
             et_node_not_locked            = lt_failed_node ).
         ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_node_subset(
                 it_node_set    = lt_node
                 it_node_subset = lt_failed_node ) = abap_true.

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).

         INSERT LINES OF lt_node_reload INTO TABLE lt_node_all_reload.

         LOOP AT lt_failed_node INTO ls_node.
           IF ls_actwrite-assoc IS BOUND.
             LOOP AT lt_key_link INTO ls_key_link USING KEY target_key WHERE
                 target_key = ls_node-key.
               ls_key-key = ls_key_link-source_key.
               APPEND ls_key TO et_failed_key.
             ENDLOOP.
           ELSE.
             ls_key-key = ls_node-key.
             APPEND ls_key TO et_failed_key.
           ENDIF.
         ENDLOOP.
       ENDIF.
     ENDLOOP.
   ENDIF.

*  reload newly locked nodes
   IF lt_node_all_reload IS NOT INITIAL.
     do_loading(
       EXPORTING
         it_node         = lt_node_all_reload
         iv_reload       = abap_true
         iv_load_data    = abap_true
         iv_check_buf    = abap_false
         iv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup
         iv_edit_mode    = ls_actconf-edit_mode
         io_change       = eo_change
       IMPORTING
         eo_message      = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).
   ENDIF.

   LOOP AT et_failed_key INTO ls_key.
     DELETE lt_action_key USING KEY key_sort WHERE key = ls_key-key.
   ENDLOOP.

*  ____________________________________________________________________ *
*  check existence of all node instances the action is called with
  IF lt_action_key IS NOT INITIAL.
    retrieve(
      EXPORTING
        iv_node_key         = ls_actconf-node_key
        it_key              = lt_action_key
        iv_state            = /bobf/if_conf_c=>sc_state_current
        iv_invalidate_cache = abap_false
        iv_fill_data        = abap_false
        iv_edit_mode        = /bobf/if_conf_c=>sc_edit_read_only
        iv_buffer_only      = abap_false
        iv_within_loading   = abap_false
      IMPORTING
        eo_message          = lo_message
        et_failed_key       = lt_failed_key ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

     IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_adopt_numbers.
       LOOP AT lt_failed_key INTO ls_key.
         DELETE lt_action_key USING KEY key_sort WHERE key = ls_key-key.
       ENDLOOP.
     ELSE.
       LOOP AT lt_failed_key INTO ls_key.
         DELETE lt_action_key USING KEY key_sort WHERE key = ls_key-key.
         APPEND ls_key TO et_failed_key.
       ENDLOOP.
     ENDIF.
   ENDIF.

   IF et_failed_key IS NOT INITIAL AND
      ls_actconf-exec_only_all = abap_true.
*    action rejected
     et_failed_key = is_action-key.
     RETURN.
   ENDIF.

*  ____________________________________________________________________ *
*  check authority
   mo_authority_handler->check_authority(
     EXPORTING
       io_change        = eo_change
       is_ctx           = VALUE #(
                           activity = /bobf/cl_frw_authority_check=>sc_activity-execute
                           bo_service = ls_actconf-act_name
                           node_key = ls_actconf-node_key )
       iv_cleanse_keys  = abap_true
       io_bopf          = me
       io_buffer        = mo_buffer
       iv_last_state    = /bobf/if_conf_c=>sc_state_database
       iv_current_state = /bobf/if_conf_c=>sc_state_current
     IMPORTING
       et_failed_key    = lt_failed_key
     CHANGING
       ct_key           = lt_action_key
       co_message       = eo_message
       ct_access_stack  = mt_access_stack
   ).

   APPEND LINES OF lt_failed_key TO et_failed_key.

*  ____________________________________________________________________ *
*  create context
   ls_context-bo_key          = mo_conf->ms_obj-bo_key.
   ls_context-root_node_key   = mo_conf->ms_obj-root_node_key.
   ls_context-node_key        = ls_actconf-node_key.
   ls_context-act_key         = is_action-act_key.
   ls_context-act_cat         = ls_actconf-act_cat.
   IF eo_change IS NOT BOUND.
     eo_change = /bobf/cl_frw_factory=>get_change( ).
   ENDIF.

*  ____________________________________________________________________ *
*  prepare and check action - action depending validation
   ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset_stack_set(
          it_key_set = lt_action_key ) = abap_true.

   IF iv_internal_call = abap_false.
     lv_check_property = abap_true.
   ENDIF.

   check_action(
     EXPORTING
       is_context          = ls_context
       is_parameters       = is_action-parameters
       iv_check_property   = lv_check_property
       iv_check_validation = abap_true
       io_change           = eo_change
     IMPORTING
       et_failed_key       = lt_failed_key
       eo_message          = lo_message
     CHANGING
       ct_key              = lt_action_key ).

   ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset_stack_check(
          it_key_subset = lt_failed_key ) = abap_true.

   APPEND LINES OF lt_failed_key TO et_failed_key.

   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = eo_message ).

   IF ls_actconf-act_cardinality <> /bobf/if_conf_c=>sc_act_card_static AND
      lt_action_key IS INITIAL.
*    all keys kicked out by action check
     RETURN.
   ENDIF.

   IF et_failed_key IS NOT INITIAL AND
      ls_actconf-exec_only_all = abap_true.
*    action rejected
     et_failed_key = is_action-key.
     RETURN.
   ENDIF.


*  ____________________________________________________________________ *
*  create sorted action execution list
*  (pre-enhancement actions, basic action and post-enhancement actions)
   IF ls_actconf-pre_enhancement_keys IS BOUND.
     lt_action_execution_list = ls_actconf-pre_enhancement_keys->*.
   ENDIF.

   INSERT is_action-act_key INTO TABLE lt_action_execution_list.

   IF ls_actconf-post_enhancement_keys IS BOUND.
     APPEND LINES OF ls_actconf-post_enhancement_keys->* TO lt_action_execution_list.
   ENDIF.

*  ____________________________________________________________________ *
*  execute the action list
   LOOP AT lt_action_execution_list INTO lv_action_execution_list.

     IF mo_conf->ms_last_action-act_key = lv_action_execution_list.
       ls_actconf = mo_conf->ms_last_action.
     ELSE.
       mo_conf->get_act(
         EXPORTING
           iv_act_key  = lv_action_execution_list
         IMPORTING
           es_action   = ls_actconf ).
     ENDIF.

*  ____________________________________________________________________ *
*  create context
     ls_context-act_key         = lv_action_execution_list.
     IF eo_change IS NOT BOUND.
       eo_change = /bobf/cl_frw_factory=>get_change( ).
     ENDIF.

*  ____________________________________________________________________ *
*  execute action
    ASSERT ID /bobf/frw_error CONDITION
      /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

    DATA(lt_key_for_message_context) = lt_action_key.
    execute_action(
      EXPORTING
        is_context              = ls_context
        is_conf                 = ls_actconf
        is_parameter            = is_action-parameters
        io_change               = eo_change
        iv_within_loading       = iv_within_loading
          iv_loading_node_key     = iv_loading_node_key
        iv_is_base_action       = xsdbool( lv_action_execution_list = is_action-act_key )
      IMPORTING
        et_failed_key           = lt_failed_key
        eo_message              = lo_message
        ev_static_action_failed = ev_static_action_failed
        et_data                 = et_data
      CHANGING
        ct_key                  = lt_action_key
    ).
    APPEND LINES OF lt_failed_key TO et_failed_key.


*  set context
     create_durable_msg_container( CHANGING co_message = lo_message ).
     IF lo_message IS BOUND.
       lo_message_int ?= lo_message.
       ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
       ls_runtime_context-node_key = ls_actconf-node_key.
       ls_runtime_context-act_key  = ls_actconf-act_key.
       lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key_for_message_context ).

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).
     ENDIF.

*  if no keys have been left by the basic action, do no execute any post enhancement actions
*  in case of non static actions only
     IF lv_action_execution_list = is_action-act_key
       AND lt_action_key IS INITIAL
       AND ls_actconf-act_cardinality NE /bobf/if_conf_c=>sc_act_card_static.
       EXIT.
     ENDIF.

   ENDLOOP.

   IF iv_with_detval       = abap_true AND
      mv_no_determinations = abap_false.
*    perform determination and validation
     do_detval(
       EXPORTING io_change                  = eo_change
                 iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_action
       IMPORTING eo_message                 = lo_message ).
     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).
   ENDIF.

 ENDMETHOD.


  METHOD do_delete_action.
    DATA lt_delete_for_Action type /bobf/t_frw_key.
    DATA ls_act_class type ty_action.
    DATA lx_root type ref to cx_root.

    CLEAR: eo_message, et_failed_node.

    LOOP AT it_delete ASSIGNING FIELD-SYMBOL(<ls_delete>) GROUP BY ( node = <ls_delete>-node ) ASSIGNING FIELD-SYMBOL(<ls_node_group>).
      CLEAR lt_delete_for_action.
      "Check whether a implementation for the delete action exists
      mo_conf->get_act( EXPORTING iv_node_key = <ls_node_group>-node
                                  iv_act_cat  = /bobf/if_conf_c=>sc_action_delete
                        IMPORTING es_action   = DATA(ls_act_conf) ).
      IF ls_act_conf-act_class IS NOT INITIAL.
        LOOP AT GROUP <ls_node_group> ASSIGNING FIELD-SYMBOL(<ls_delete_for_same_node>).
          APPEND VALUE #( key = <ls_delete_for_same_node>-key ) to lt_delete_for_action.
        ENDLOOP.

        IF lt_delete_for_action IS NOT INITIAL.
          DATA(ls_action_context) = value /bobf/s_frw_ctx_act( bo_key        = mo_conf->ms_obj-bo_key
                                                               root_node_key = mo_conf->ms_obj-root_node_key
                                                               node_key      = ls_act_conf-node_key
                                                               act_key       = ls_act_conf-act_key ).
          DATA(lt_key_for_message_contex) = lt_delete_for_action.
          execute_action( EXPORTING is_context    = ls_action_context
                                    is_conf       = ls_act_conf
                                    io_change     = io_change
                          IMPORTING et_failed_key = DATA(lt_failed_key)
                                    eo_message    = DATA(lo_message)
                          CHANGING  ct_key        = lt_delete_for_action ).
          " set message context
          create_durable_msg_container( CHANGING co_message = lo_message ).
          IF lo_message IS BOUND.
            DATA(lo_message_int)  = CAST /bobf/cl_frw_message( lo_message ).
            DATA(ls_runtime_context) = VALUE /bobf/s_frw_runtime_context( bo_key   = mo_conf->ms_obj-bo_key
                                                                          node_key = ls_act_conf-node_key
                                                                          act_key  = ls_act_conf-act_key ).
            lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key_for_message_contex ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.

          LOOP AT lt_failed_key ASSIGNING FIELD-SYMBOL(<ls_failed_key>).
            APPEND VALUE #( node = <ls_node_group>-node key = <ls_failed_key>-key ) TO et_failed_node.
          ENDLOOP.

        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


METHOD do_determinations.

  DATA: ls_detconf          TYPE REF TO /bobf/s_confro_exectime,
        ls_det              TYPE REF TO /bobf/s_confro_det_list,
        ls_det_inst         TYPE ty_determination,
        ls_statecr          TYPE /bobf/s_confro_chg_mode,
        ls_dettrig          TYPE /bobf/s_confro_det_trigger,
        ls_detwrite         TYPE /bobf/s_confro_det_write,
        ls_detread          TYPE /bobf/s_confro_read,
        ls_context          TYPE /bobf/s_frw_ctx_det,
        lt_nodecat          TYPE /bobf/t_frw_node_cat,
        ls_nodecat          TYPE /bobf/s_frw_node_cat,
        lt_key              TYPE /bobf/t_frw_key,
        lt_key2             TYPE /bobf/t_frw_key,
        lt_key3             TYPE /bobf/t_frw_key,
        lt_key4             TYPE /bobf/t_frw_key,
        lt_key_for_db       TYPE /bobf/t_frw_key,
        ls_key              TYPE /bobf/s_frw_key,
        ls_key_new          TYPE /bobf/s_frw_key,
        lt_write_key        TYPE /bobf/t_frw_key,
        lt_det_key          TYPE /bobf/t_frw_key,
        lt_det_key_missing  TYPE /bobf/t_frw_key,
        lt_det_key_missing2 TYPE /bobf/t_frw_key,
        lt_changed_key      TYPE /bobf/t_frw_key,
        lt_changed_key2     TYPE /bobf/t_frw_key,
        lt_key_link         TYPE /bobf/t_frw_key_link,
        ls_key_link         TYPE /bobf/s_frw_key_link,
        lt_key_link2        TYPE /bobf/t_frw_key_link,
        lt_key_missing      TYPE /bobf/t_frw_key,
        lt_failed_key       TYPE /bobf/t_frw_key,
        lt_failed_root_key  TYPE /bobf/t_frw_key,
        lt_failed_write_key TYPE /bobf/t_frw_key,
        lt_root_key         TYPE /bobf/t_frw_key,
        lt_tmp_key          TYPE /bobf/t_frw_key,
        lt_write_node       TYPE /bobf/t_frw_node,
        lt_write_node_bef   TYPE /bobf/t_frw_node,
        lt_lock_node        TYPE /bobf/t_frw_node,
        lt_tmp_node         TYPE /bobf/t_frw_node,
        lt_failed_node      TYPE /bobf/t_frw_node,
        lt_node_reload      TYPE /bobf/t_frw_node,
        ls_node             TYPE /bobf/s_frw_node,
        lv_node             TYPE /bobf/obm_node_key,
        lt_change           TYPE /bobf/t_frw_change,
        ls_change           TYPE /bobf/s_frw_change,
        lo_change           TYPE REF TO /bobf/cl_frw_change,
        lo_delegation       TYPE REF TO /bobf/if_frw_delegation,
        lo_message          TYPE REF TO /bobf/if_frw_message,
        lo_message_int      TYPE REF TO /bobf/cl_frw_message,
        ls_runtime_context  TYPE /bobf/s_frw_runtime_context,
        lv_content_cat      TYPE string,
        lv_content_name     TYPE /bobf/obm_name,
        lv_within_loading   TYPE boole_d,
          lv_loading_node_key TYPE  /bobf/obm_node_key,
        lx_root             TYPE REF TO cx_root,
        lx_frw              TYPE REF TO /bobf/cx_frw_core,
        lx_cx_frw           TYPE REF TO /bobf/cx_frw,
        lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
        lv_current_state    TYPE /bobf/conf_state,
        lv_class            TYPE seoclsname,
        lv_application_info TYPE string.

  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR: eo_message,
         et_failed.

  IF iv_exectime <> /bobf/if_conf_c=>sc_time_cleanup AND
     io_change->has_changes( ) = abap_false.
    RETURN.
  ENDIF.

  ls_detconf = mo_conf->get_determination( iv_exectime ).
  IF ls_detconf IS NOT BOUND.
*   unknown exectime
    set_configuration_error( ).
    RETURN.
  ENDIF.
  IF ls_detconf->exectime = /bobf/if_conf_c=>sc_time_after_loading.
    lv_current_state = iv_load_state.
    lv_within_loading = abap_true.
  ELSE.
    lv_current_state = /bobf/if_conf_c=>sc_state_current.
    lv_within_loading = abap_false.
  ENDIF.

  IF ls_detconf->det_list IS BOUND AND
      ls_detconf->det_list->* IS NOT INITIAL.
    lo_change ?= io_change.

*   clear GET_NODE_CAT local buffer
    CLEAR: mt_nodecat_key,
           mv_nodecat_node_key,
           mt_nodecat.
    lo_int_access = /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf   = me
        io_conf   = mo_conf
        io_buffer = mo_buffer
        io_change = io_change ).

    lo_int_access->set_last_state( iv_last_state = ls_detconf->last_state ).
    lo_int_access->set_current_state( iv_current_state = lv_current_state ).

*   loop at determinations (already correctly sorted)
    LOOP AT ls_detconf->det_list->* REFERENCE INTO ls_det.
      CLEAR lt_key.
        lv_loading_node_key = COND #( WHEN lv_within_loading = abap_true THEN ls_det->node_key ELSE VALUE #( ) ).
* ____________________________________________________________________ *
*     analyse changed trigger nodes
      LOOP AT ls_det->det_trigger->* INTO ls_dettrig.
*       get changed source nodes
        IF ls_dettrig-assoc IS BOUND.
          lv_node = ls_dettrig-assoc->source_node_key.
        ELSE.
*         association is missing within the configuration -> check your configuration!
          ASSERT ID /bobf/frw CONDITION ls_det->node_key = ls_dettrig-node_key.
          lv_node = ls_det->node_key.

        ENDIF.
        IF iv_exectime = /bobf/if_conf_c=>sc_time_after_loading.
          CHECK ls_dettrig-load = abap_true.
          lo_change->get_trigger(
            EXPORTING
              iv_exectime    = iv_exectime
              iv_change_mode = /bobf/if_frw_c=>sc_modify_load
              iv_node_key    = lv_node
            IMPORTING
              et_changed_key = lt_changed_key ).

          " remove instances from the trigger list that are already failed by after loading determinations executed before
          IF et_failed IS NOT INITIAL.
            LOOP AT lt_changed_key INTO ls_key.
              READ TABLE et_failed TRANSPORTING NO FIELDS
                WITH KEY node = lv_node
                         key  = ls_key-key.
              IF sy-subrc = 0.
                DELETE lt_changed_key.
              ENDIF.
            ENDLOOP.
          ENDIF.

          ls_dettrig-check  = abap_false.
          ls_dettrig-create = abap_false.
          ls_dettrig-update = abap_false.
          ls_dettrig-delete = abap_false.
        ELSEIF iv_exectime = /bobf/if_conf_c=>sc_time_cleanup.
          " get all node instances which are loaded into the buffer of the request node
          " (don't care about trigger condition as this allows to clear also read buffers)
          TRY.
              mo_buffer->get_keys(
                EXPORTING
                  iv_node_key = lv_node
                  iv_state    = /bobf/if_conf_c=>sc_state_current
                IMPORTING
                  et_key      = lt_changed_key ).
            CATCH /bobf/cx_frw INTO lx_cx_frw.
              set_application_error( lx_cx_frw ).
          ENDTRY.
        ELSE.
          CHECK iv_exectime <> /bobf/if_conf_c=>sc_time_after_modify OR
              ls_dettrig-create = abap_true OR
              ls_dettrig-update = abap_true OR
              ls_dettrig-delete = abap_true.

          IF iv_exectime <> /bobf/if_conf_c=>sc_time_check_and_determine.
            ls_dettrig-check = abap_false.
          ENDIF.
          ls_dettrig-load = abap_false.

          lo_change->get_trigger(
            EXPORTING
              iv_exectime    = iv_exectime
              iv_node_key    = lv_node
              is_change_mode = ls_dettrig-change_mode
            IMPORTING
              et_changed_key = lt_changed_key ).
        ENDIF.

        " if this is an authority determination check keyload trigger additionally
        IF ls_det->det_cat = /bobf/if_conf_c=>sc_detcat_authority.
          lo_change->get_trigger(
            EXPORTING
              iv_exectime    = iv_exectime
              iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
              iv_node_key    = lv_node
            IMPORTING
              et_changed_key = lt_changed_key2 ).
          APPEND LINES OF lt_changed_key2 TO lt_changed_key.
        ENDIF.

        CHECK lt_changed_key IS NOT INITIAL.

*       get corresponding target keys
        IF ls_dettrig-assoc IS BOUND.
          retrieve_by_association(
            EXPORTING
              iv_node_key        = ls_dettrig-assoc->source_node_key
              it_key             = lt_changed_key
              iv_association     = ls_dettrig-assoc->assoc_key
              iv_fill_failed_key = abap_true
              iv_state           = lv_current_state
            IMPORTING
              eo_message         = lo_message
              et_key_link        = lt_key_link
              et_target_key      = lt_det_key
              et_failed_key      = lt_key_missing ).

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_link_matching(
                 it_key_link   = lt_key_link
                 it_key        = lt_changed_key
                 it_target_key = lt_det_key ) = abap_true.

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset(
               it_key_set    = lt_changed_key
               it_key_subset = lt_key_missing ) = abap_true.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF ls_dettrig-delete = abap_true AND lt_key_missing IS NOT INITIAL.
*           check if changed key-table is incomplete due to
*           deleted trigger keys, if yes -> add nodes
            retrieve_by_association(
              EXPORTING
                iv_node_key        = ls_dettrig-assoc->source_node_key
                it_key             = lt_key_missing
                iv_association     = ls_dettrig-assoc->assoc_key
                iv_state           = ls_detconf->last_state
                iv_buffer_only     = abap_true
              IMPORTING
                eo_message         = lo_message
                et_target_key      = lt_det_key_missing ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF ls_detconf->last_state <> /bobf/if_conf_c=>sc_state_database.
              retrieve_by_association(
                EXPORTING
                  iv_node_key        = ls_dettrig-assoc->source_node_key
                  it_key             = lt_key_missing
                  iv_association     = ls_dettrig-assoc->assoc_key
                  iv_state           = /bobf/if_conf_c=>sc_state_database
                  iv_buffer_only     = abap_true
                IMPORTING
                  eo_message         = lo_message
                  et_target_key      = lt_det_key_missing2 ).
              APPEND LINES OF lt_det_key_missing2 TO lt_det_key_missing.
              CLEAR lt_det_key_missing2.
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
              SORT lt_det_key_missing.
              DELETE ADJACENT DUPLICATES FROM lt_det_key_missing.
            ENDIF.

            retrieve(
              EXPORTING
                iv_node_key         = ls_dettrig-assoc->target_node_key
                it_key              = lt_det_key_missing
                iv_state            = lv_current_state
                iv_invalidate_cache = abap_false
                iv_fill_data        = abap_false
              IMPORTING
                et_failed_key       = lt_failed_key
                eo_message          = lo_message ).

            ASSERT ID /bobf/frw CONDITION
                /bobf/cl_tool_assert=>is_key_subset(
                    it_key_set    = lt_det_key_missing
                    it_key_subset = lt_failed_key ) = abap_true.

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF lt_failed_key IS NOT INITIAL.
              LOOP AT lt_det_key_missing INTO ls_key.
                READ TABLE lt_failed_key WITH KEY key_sort
                  COMPONENTS key = ls_key-key
                  TRANSPORTING NO FIELDS.
                CHECK sy-subrc = 0.
                DELETE lt_det_key_missing.
              ENDLOOP.
            ENDIF.
            APPEND LINES OF lt_det_key_missing TO lt_det_key.
          ENDIF.
          APPEND LINES OF lt_det_key TO lt_key.
        ELSE.
*         perform existence check if delete triggers are used to avoid that the
*         determination is called with non-existing keys in current and before image
*         => CHECK DISABLED on REQUEST by AP CCM for FP2.0
*          IF ls_dettrig-delete = abap_true.
*            <...>
*          ENDIF.
          APPEND LINES OF lt_changed_key TO lt_key.
        ENDIF.
      ENDLOOP.

      CHECK lt_key IS NOT INITIAL.
      SORT lt_key.
      DELETE ADJACENT DUPLICATES FROM lt_key.

* ____________________________________________________________________ *
*    filter keys regarding their node category
      IF ls_det->node_cat->* IS NOT INITIAL.
        get_node_cat(
          EXPORTING
            iv_node_key      = ls_det->node_key
            it_key           = lt_key
            iv_current_state = lv_current_state
            iv_last_state    = ls_detconf->last_state
          IMPORTING
            et_nodecat       = lt_nodecat
            et_failed_key    = lt_failed_key
            eo_message       = lo_message ).

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        CLEAR: lt_key, lt_tmp_key.
        LOOP AT lt_nodecat INTO ls_nodecat.
          ls_key_new-key = ls_nodecat-key.
          APPEND ls_key_new TO lt_tmp_key.
          AT END OF node_cat_key.
*            check if node category is valid
            READ TABLE ls_det->node_cat->*
              WITH KEY node_cat_key = ls_nodecat-node_cat_key
              TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              APPEND LINES OF lt_tmp_key TO lt_key.
            ENDIF.
            CLEAR lt_tmp_key.
          ENDAT.
        ENDLOOP.
        CHECK lt_key IS NOT INITIAL.
      ENDIF.

* ____________________________________________________________________ *
*     call determination check delta
      ls_context-bo_key        = mo_conf->ms_obj-bo_key.
      ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
      ls_context-node_key      = ls_det->node_key.
      ls_context-det_key       = ls_det->det_key.
      ls_context-exectime      = iv_exectime.
      ls_context-cleanup_mode  = iv_cleanup_mode.
      ls_context-keep_cache    = iv_keep_cache.

      READ TABLE mt_determination
        WITH TABLE KEY det_key = ls_det->det_key
        INTO ls_det_inst.
      IF sy-subrc <> 0.
        ls_det_inst-det_key = ls_det->det_key.
        TRY.
            CREATE OBJECT ls_det_inst-class TYPE (ls_det->det_class).
          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_det = abap_true
              iv_key = ls_det->det_key ).
            lv_content_cat = TEXT-002.
            CREATE OBJECT lx_frw
              EXPORTING
                previous        = lx_root
                textid          = /bobf/cx_frw_core=>sc_no_instance
                mv_classname    = ls_det->det_class
                mv_content_cat  = lv_content_cat
                mv_content_name = lv_content_name.
            set_configuration_error( lx_frw ).
        ENDTRY.

        INSERT ls_det_inst INTO TABLE mt_determination.
      ENDIF.

*     check for field changes between last and current state
      IF ls_detconf->last_state IS NOT INITIAL AND
         ls_det->check_delta_impl = abap_true.
        lo_int_access->set_context(
          is_determination  = ls_context
          iv_within_loading = lv_within_loading
            iv_loading_node_key = lv_loading_node_key
          iv_read_allowed   = abap_true ).
        INSERT lo_int_access INTO mt_access_stack INDEX 1.
        TRY.
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_det_inst-class->check_delta(
              EXPORTING
                is_ctx  = ls_context
                io_read = lo_int_access
              CHANGING
                ct_key  = lt_key ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            lv_content_name = get_content_description(
              iv_det = abap_true
              iv_key = ls_det->det_key ).
            lv_content_cat = TEXT-002.
            lv_class = ls_det->det_class.
            lcl_error_text_provider=>get_text_impl_class_error(
              EXPORTING
                iv_content_cat      = /bobf/if_conf_c=>sc_content_det
                iv_content_key      = ls_det->det_key
                iv_node_key         = ls_det->node_key
                iv_content_class    = lv_class
                iv_content_name     = lv_content_name
                iv_method_name      = 'CHECK_DELTA'
                io_configuration    = mo_conf
              RECEIVING
                rv_application_info = lv_application_info
            ).
            CREATE OBJECT lx_frw
              EXPORTING
                previous                   = lx_root
                textid                     = /bobf/cx_frw_core=>sc_content_exception
                mv_node                    = ls_det->node_key
                mv_method_name             = 'CHECK_DELTA'
                mv_content_name            = lv_content_name
                mv_content_cat             = lv_content_cat
                mv_application_information = lv_application_info.
            set_application_error( lx_frw ).
        ENDTRY.
        lo_int_access->invalidate( ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.
      ENDIF.

      CHECK lt_key IS NOT INITIAL.

* ____________________________________________________________________ *
*     if determination is transient: check if all required write-nodes are loaded
*     determination then only must happen for already loaded write-nodes
      IF ls_det->det_cat = /bobf/if_conf_c=>sc_detcat_transient.
        CLEAR lt_key_link2.
        LOOP AT ls_det->det_write->* INTO ls_detwrite
          WHERE assoc IS BOUND
            AND assoc->target_node->transient = abap_false.

          retrieve_by_association(
            EXPORTING
              iv_node_key    = ls_det->node_key
              it_key         = lt_key
              iv_association = ls_detwrite-assoc->assoc_key
              iv_state       = lv_current_state
              iv_buffer_only = abap_true
            IMPORTING
              eo_message     = lo_message
              et_key_link    = lt_key_link
              et_target_key  = lt_write_key ).

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_link_matching(
                 it_key_link   = lt_key_link
                 it_key        = lt_key
                 it_target_key = lt_write_key ) = abap_true.

          retrieve(
            EXPORTING
              iv_node_key         = ls_detwrite-assoc->target_node_key
              it_key              = lt_write_key
              iv_state            = lv_current_state
              iv_invalidate_cache = abap_false
              iv_fill_data        = abap_false
              iv_buffer_only      = abap_true
            IMPORTING
              et_failed_key       = lt_failed_key
              eo_message          = lo_message ).

          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_tmp_key
                  it_key_subset = lt_failed_key ) = abap_true.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_failed_key INTO ls_key.
            DELETE lt_key_link USING KEY target_key WHERE target_key = ls_key-key.
          ENDLOOP.
          INSERT LINES OF lt_key_link INTO TABLE lt_key_link2.

        ENDLOOP.

        IF sy-subrc = 0.
          LOOP AT lt_key INTO ls_key.
            READ TABLE lt_key_link2 WITH KEY
                source_key = ls_key-key
                TRANSPORTING NO FIELDS.
            IF sy-subrc <> 0.
*             no write node yet in buffer -> do not execute determination
              DELETE lt_key.
            ENDIF.
          ENDLOOP.
        ENDIF.
        CHECK lt_key IS NOT INITIAL.
      ENDIF.

* ____________________________________________________________________ *
*     check if all required nodes are locked
      IF ls_det->edit_mode <> /bobf/if_conf_c=>sc_edit_read_only     AND
         iv_exectime       <> /bobf/if_conf_c=>sc_time_after_loading AND
         mo_conf->ms_obj-no_lock = abap_false                        AND
         ls_det->det_write IS NOT INITIAL.
        CLEAR lt_lock_node.
        LOOP AT ls_det->det_write->* INTO ls_detwrite.
          IF ls_detwrite-assoc IS BOUND.
            retrieve_by_association(
              EXPORTING
                iv_node_key    = ls_det->node_key
                it_key         = lt_key
                iv_association = ls_detwrite-assoc->assoc_key
                iv_state       = lv_current_state
              IMPORTING
                eo_message     = lo_message
                et_failed_key  = lt_failed_write_key
                et_target_key  = lt_write_key ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
            map_to_node(
              EXPORTING
                iv_node_key = ls_detwrite-assoc->target_node_key
                it_key      = lt_write_key
              IMPORTING
                et_node     = lt_write_node ).
            IF lt_failed_write_key IS NOT INITIAL.
              retrieve_by_association(
               EXPORTING
                 iv_node_key    = ls_det->node_key
                 it_key         = lt_failed_write_key
                 iv_association = ls_detwrite-assoc->assoc_key
                 iv_state       = ls_detconf->last_state
               IMPORTING
                 eo_message     = lo_message
                 et_target_key  = lt_write_key ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
              map_to_node(
                EXPORTING
                  iv_node_key = ls_detwrite-assoc->target_node_key
                  it_key      = lt_write_key
                IMPORTING
                  et_node     = lt_write_node_bef ).
              INSERT LINES OF lt_write_node_bef INTO TABLE lt_write_node.
            ENDIF.
          ELSE.
*           no association maintained -> take own node
            map_to_node(
              EXPORTING
                iv_node_key = ls_det->node_key
                it_key      = lt_key
              IMPORTING
                et_node     = lt_write_node ).
          ENDIF.
          INSERT LINES OF lt_write_node INTO TABLE lt_lock_node.
          CLEAR lt_write_node.
        ENDLOOP.

        IF lt_lock_node IS NOT INITIAL.

          DELETE ADJACENT DUPLICATES FROM lt_lock_node.
*       lock required nodes
          mo_lock_manager->lock(
            EXPORTING
              iv_edit_mode                  = ls_det->edit_mode
              iv_all_none                   = abap_true
              it_node                       = lt_lock_node
              io_change                     = io_change
              iv_generic                    = abap_false
            IMPORTING
              eo_message                    = lo_message
              et_lockable_node_newly_locked = lt_node_reload
              et_node_not_locked            = lt_failed_node ).

          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_node_subset(
                  it_node_set    = lt_lock_node
                  it_node_subset = lt_failed_node ) = abap_true.

          INSERT LINES OF lt_failed_node INTO TABLE et_failed.
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF lt_failed_node IS NOT INITIAL.
*         skip determination if required nodes are not locked
            CONTINUE.
          ENDIF.

*       reload newly locked nodes
          IF lt_node_reload IS NOT INITIAL.
            do_loading(
              EXPORTING
                it_node         = lt_node_reload
                iv_reload       = abap_true
                iv_load_data    = abap_true
                iv_check_buf    = abap_false
                iv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup
                iv_edit_mode    = ls_det->edit_mode
                io_change       = io_change
              IMPORTING
                eo_message      = lo_message ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.
        ENDIF.
      ENDIF.

* ____________________________________________________________________ *
*     check read-nodes
      LOOP AT ls_det->det_read->* INTO ls_detread.
        IF ls_detread-assoc IS BOUND.
          retrieve_by_association(
            EXPORTING
              iv_node_key    = ls_det->node_key
              it_key         = lt_key
              iv_association = ls_detread-assoc->assoc_key
              iv_state       = lv_current_state
            IMPORTING
              eo_message     = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ELSE.
*         no association maintained -> take own node
          retrieve(
            EXPORTING
              iv_node_key         = ls_det->node_key
              it_key              = lt_key
              iv_state            = lv_current_state
              iv_invalidate_cache = abap_false
              iv_fill_data        = abap_false
            IMPORTING
              eo_message          = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.
      ENDLOOP.

* ____________________________________________________________________ *
*     call determination check
*     check for field values of current state
      IF ls_det->check_impl = abap_true.
        lo_int_access->set_context(
          is_determination  = ls_context
          iv_within_loading = lv_within_loading
            iv_loading_node_key = lv_loading_node_key
          iv_read_allowed   = abap_true ).
        INSERT lo_int_access INTO mt_access_stack INDEX 1.
        TRY.
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_det_inst-class->check(
              EXPORTING
                is_ctx  = ls_context
                io_read = lo_int_access
              CHANGING
                ct_key  = lt_key ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            lv_content_name = get_content_description(
              iv_det = abap_true
              iv_key = ls_det->det_key ).
            lv_content_cat = TEXT-002.
            lv_class = ls_det->det_class.
            lcl_error_text_provider=>get_text_impl_class_error(
              EXPORTING
                iv_content_cat      = /bobf/if_conf_c=>sc_content_det
                iv_content_key      = ls_det->det_key
                iv_node_key         = ls_det->node_key
                iv_content_name     = lv_content_name
                iv_content_class    = lv_class
                iv_method_name      = 'CHECK'
                io_configuration    = mo_conf
              RECEIVING
                rv_application_info = lv_application_info
            ).
            CREATE OBJECT lx_frw
              EXPORTING
                previous                   = lx_root
                textid                     = /bobf/cx_frw_core=>sc_content_exception
                mv_node                    = ls_det->node_key
                mv_method_name             = 'CHECK'
                mv_content_name            = lv_content_name
                mv_content_cat             = lv_content_cat
                mv_application_information = lv_application_info.
            set_application_error( lx_frw ).
        ENDTRY.
        lo_int_access->invalidate( ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.
        CHECK lt_key IS NOT INITIAL.
      ENDIF.

* ____________________________________________________________________ *
*     call determination execution
      CLEAR: lt_failed_key,
             lo_message.
      IF ls_det->edit_mode = /bobf/if_conf_c=>sc_edit_read_only OR
         ls_det->edit_mode = /bobf/if_conf_c=>sc_edit_shared.
        lo_int_access->set_edit_mode( ls_det->edit_mode ).
      ELSE.
        lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_exclusive ).
      ENDIF.
      IF iv_exectime = /bobf/if_conf_c=>sc_time_cleanup.
        " modifications done during this determination time are immediately lost
        " as cleanup is performed afterwards - thus don't all modification at all
        lo_int_access->set_context(
          is_determination  = ls_context
          iv_read_allowed   = abap_true
          iv_within_loading = lv_within_loading
            iv_loading_node_key = lv_loading_node_key
          iv_modify_allowed = abap_false ).
      ELSE.
        lo_int_access->set_context(
          is_determination  = ls_context
          iv_read_allowed   = abap_true
          iv_within_loading = lv_within_loading
            iv_loading_node_key = lv_loading_node_key
          iv_modify_allowed = abap_true ).
      ENDIF.
      INSERT lo_int_access INTO mt_access_stack INDEX 1.

      TRY.
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.
          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          lib_enqueue_context_push_keys( iv_node_key = ls_context-node_key
                                         it_key      = lt_key ).

          ls_det_inst-class->execute(
            EXPORTING
              is_ctx        = ls_context
              it_key        = lt_key
              io_read       = lo_int_access
              io_modify     = lo_int_access
            IMPORTING
              eo_message    = lo_message
              et_failed_key = lt_failed_key ).

          lib_enqueue_context_pop( ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_key
                  it_key_subset = lt_failed_key ) = abap_true.
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ) = abap_true.
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>failed_key_message(
                  io_message    = lo_message
                  it_failed_key = lt_failed_key ) = abap_true.

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_det = abap_true
            iv_key = ls_det->det_key ).
          lv_content_cat = TEXT-002.
          lv_class = ls_det->det_class.
          lcl_error_text_provider=>get_text_impl_class_error(
            EXPORTING
              iv_content_cat      = /bobf/if_conf_c=>sc_content_det
              iv_content_key      = ls_det->det_key
              iv_node_key         = ls_det->node_key
              iv_content_name     = lv_content_name
              iv_content_class    = lv_class
              iv_method_name      = 'EXECUTE'
              io_configuration    = mo_conf
            RECEIVING
              rv_application_info = lv_application_info
          ).
          CREATE OBJECT lx_frw
            EXPORTING
              previous                   = lx_root
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              mv_node                    = ls_det->node_key
              mv_method_name             = 'EXECUTE'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      CLEANUP.
        lib_enqueue_context_pop( ).
      ENDTRY.

      ASSERT ID /bobf/frw CONDITION lt_failed_key IS INITIAL.

*     check for undone modifications and flush
      IF lo_int_access->mt_modification IS NOT INITIAL.
        TRY.
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_int_access->end_modify( ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            " >>>>> enhance shortdump // customer ticket 2534832 2012 // internal ticket 3156594 2012
            " set_application_error( lx_root ).
            lv_content_name = get_content_description( iv_det = abap_true  iv_key = ls_det->det_key ).
            lv_content_cat = TEXT-002.
            lv_class = ls_det->det_class.
            lv_application_info = lcl_error_text_provider=>get_text_impl_class_error(
              iv_content_cat      = /bobf/if_conf_c=>sc_content_det
              iv_content_key      = ls_det->det_key
              iv_node_key         = ls_det->node_key
              iv_content_name     = lv_content_name
              iv_content_class    = lv_class
              iv_method_name      = 'FRW_END_MODIFY'
              io_configuration    = mo_conf ).
            CREATE OBJECT lx_frw
              EXPORTING
                previous                   = lx_root
                textid                     = /bobf/cx_frw_core=>sc_content_exception
                mv_node                    = ls_det->node_key
                mv_method_name             = 'FRW_END_MODIFY'
                mv_content_name            = lv_content_name
                mv_content_cat             = lv_content_cat
                mv_application_information = lv_application_info.
            set_application_error( lx_frw ).
        ENDTRY.
      ENDIF.
      collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                        CHANGING  co_message = lo_message ).
      lo_int_access->invalidate( ).
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.

*     fill message
      create_durable_msg_container( Changing co_message = lo_message ).
      IF lo_message IS BOUND.
        lo_message_int ?= lo_message.
        ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
        ls_runtime_context-node_key = ls_context-node_key.
        ls_runtime_context-det_key  = ls_context-det_key.
        lo_message_int->set_context( is_context = ls_runtime_context
                                     it_key     = filter_out_unnecessary_keys( iv_node_key  = ls_context-node_key
                                                                               io_det_class = ls_det_inst-class
                                                                               it_all_keys  = lt_key
                                                                               io_change    = lo_int_access->mo_change
                                                                               io_message   = lo_message_int ) ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

*     fill failed keys
      IF lt_failed_key IS NOT INITIAL.
        map_to_node(
          EXPORTING
            iv_node_key = ls_context-node_key
            it_key      = lt_failed_key
          IMPORTING
            et_node     = lt_failed_node ).
        INSERT LINES OF lt_failed_node INTO TABLE et_failed.

        " add trigger nodes if failed for authority determinations
        IF ls_det->det_cat = /bobf/if_conf_c=>sc_detcat_authority.
          LOOP AT ls_det->det_trigger->* INTO ls_dettrig.
            IF ls_dettrig-assoc IS BOUND. " only if the node is not the same otherwise just take lt_failed_key
              lo_change->get_trigger(
                 EXPORTING
                   iv_exectime    = iv_exectime
                   iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                   iv_node_key    = ls_dettrig-assoc->source_node_key
                 IMPORTING
                   et_changed_key = lt_changed_key ).

              lo_change->get_trigger(
                 EXPORTING
                   iv_exectime    = iv_exectime
                   iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
                   iv_node_key    = ls_dettrig-assoc->source_node_key
                 IMPORTING
                   et_changed_key = lt_changed_key2 ).
              APPEND LINES OF lt_changed_key2 TO lt_changed_key.

              IF lt_changed_key IS NOT INITIAL.
                retrieve_by_association(
                  EXPORTING
                    iv_node_key        = ls_dettrig-assoc->source_node_key
                    it_key             = lt_changed_key
                    iv_association     = ls_dettrig-assoc->assoc_key
                    iv_fill_failed_key = abap_false
                    iv_state           = lv_current_state
                  IMPORTING
                    eo_message         = lo_message
                    et_key_link        = lt_key_link
                    et_target_key      = lt_det_key ).

                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).

                LOOP AT lt_key_link INTO ls_key_link.
                  READ TABLE lt_failed_key TRANSPORTING NO FIELDS
                    WITH KEY key_sort COMPONENTS key = ls_key_link-target_key.
                  IF sy-subrc = 0.
                    ls_node-node = ls_dettrig-node_key.
                    ls_node-key  = ls_key_link-source_key.
                    INSERT ls_node INTO TABLE et_failed.
                  ENDIF.
                ENDLOOP.
              ENDIF.
            ENDIF.
          ENDLOOP.
        ENDIF.

      ENDIF.
    ENDLOOP.

* ____________________________________________________________________ *
*   if exectime = after_val: prevent state creation of keys that failed
*   during the validation execution
    IF mo_change_fail_val IS BOUND AND
       iv_exectime = /bobf/if_conf_c=>sc_time_after_validation.

      mo_change_fail_val->get( IMPORTING et_change = lt_change ).
      LOOP AT lt_change INTO ls_change.
        CLEAR lt_key.
        ls_key-key = ls_change-key.
        APPEND ls_key TO lt_key.

        IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
          mo_conf->get_node( iv_node_key = ls_change-node_key ).
        ENDIF.

        IF mo_conf->ms_last_node-delegation_class IS INITIAL.
          TRY.
              mo_buffer->get_root_key(
                EXPORTING
                  iv_node_key   = ls_change-node_key
                  it_key        = lt_key
                  iv_state      = lv_current_state
                  io_change     = io_change
                IMPORTING
                  et_target_key = lt_root_key ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          after_loading(
            EXPORTING
              io_change         = io_change
              iv_load_state     = lv_current_state
            IMPORTING
              eo_message        = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF lt_root_key IS INITIAL.
            TRY.
                mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_change-node_key
                    it_key        = lt_key
                    iv_state      = /bobf/if_conf_c=>sc_state_database
                    io_change     = io_change
                  IMPORTING
                    et_target_key = lt_root_key ).
              CATCH cx_root INTO lx_root.                "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            after_loading(
              EXPORTING
                io_change         = io_change
                iv_load_state     = /bobf/if_conf_c=>sc_state_database
              IMPORTING
                eo_message        = lo_message ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.
          INSERT LINES OF lt_root_key INTO TABLE lt_failed_root_key.

        ELSE.
          TRY.
              lo_delegation = get_delegation( ls_change-node_key ).
              lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
              lo_delegation->get_root_key(
                EXPORTING
                  iv_node_key = ls_change-node_key
                  it_key      = lt_key
                  iv_state    = lv_current_state
                  io_read     = mo_delegation_read
                IMPORTING
                  et_key_link = lt_key_link ).

              IF lt_key_link IS INITIAL.
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key = ls_change-node_key
                    it_key      = lt_key
                    iv_state    = /bobf/if_conf_c=>sc_state_database
                    io_read     = mo_delegation_read
                  IMPORTING
                    et_key_link = lt_key_link ).
              ENDIF.
              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>is_key_link_matching(
                 it_key_link = lt_key_link
                 it_key      = lt_key ) = abap_true.

          READ TABLE lt_key_link INTO ls_key_link INDEX 1.
          ls_key-key = ls_key_link-target_key.
          INSERT ls_key INTO TABLE lt_failed_root_key.
        ENDIF.
      ENDLOOP.
      SORT lt_failed_root_key.
      DELETE ADJACENT DUPLICATES FROM lt_failed_root_key.
      CLEAR: mo_change_fail_val, lt_key.
    ENDIF.

* ____________________________________________________________________ *
*   insert all changes belonging to failed keys into
*   mo_change_fail_det/mo_change_fail_val
    IF iv_exectime = /bobf/if_conf_c=>sc_time_after_modify.
      CLEAR mo_change_fail_det.
    ENDIF.

    IF et_failed IS NOT INITIAL AND
     ( iv_exectime = /bobf/if_conf_c=>sc_time_after_validation OR
       iv_exectime = /bobf/if_conf_c=>sc_time_after_modify ).

      CLEAR: lt_key2, lt_key3, lt_key4, lt_key_for_db.
      LOOP AT et_failed INTO ls_node.
        ls_key-key = ls_node-key.
        INSERT ls_key INTO TABLE lt_key2.

        AT END OF node.
          IF mo_conf->ms_last_node-node_key <> ls_node-node.
            mo_conf->get_node( iv_node_key = ls_node-node ).
          ENDIF.

          IF mo_conf->ms_last_node-delegation_class IS INITIAL.
            TRY.
                mo_buffer->get_root_key(
                EXPORTING
                  iv_node_key   = ls_node-node
                  it_key        = lt_key2
                  iv_state      = lv_current_state
                  io_change     = io_change
                IMPORTING
                  et_target_key = lt_key3
                  et_failed_key = lt_key4 ).
              CATCH cx_root INTO lx_root.                "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key2
                it_key_subset = lt_key4 ) = abap_true.

            after_loading(
              EXPORTING
                io_change     = io_change
                iv_load_state = lv_current_state
              IMPORTING
                eo_message    = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            INSERT LINES OF lt_key3 INTO TABLE lt_failed_root_key.
            IF lt_key4 IS NOT INITIAL.
              IF ls_detconf->last_state IS NOT INITIAL.
                TRY.
                    mo_buffer->get_root_key(
                      EXPORTING
                        it_key        = lt_key4
                        iv_node_key   = ls_node-node
   iv_state      = ls_detconf->last_state
                          io_change     = io_change
                        IMPORTING
                          et_target_key = lt_key3
                          et_failed_key = lt_key_for_db ).
                  CATCH cx_root INTO lx_root.            "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.

                after_loading(
                  EXPORTING
                    io_change     = io_change
                    iv_load_state = ls_detconf->last_state
                  IMPORTING
                    eo_message    = lo_message ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).

                INSERT LINES OF lt_key3 INTO TABLE lt_failed_root_key.
              ELSE.
                lt_key_for_db = lt_key4.
              ENDIF.

              IF lt_key_for_db IS NOT INITIAL.
                TRY.
                    mo_buffer->get_root_key(
                      EXPORTING
                        it_key        = lt_key_for_db
                        iv_node_key   = ls_node-node
                      iv_state      = /bobf/if_conf_c=>sc_state_database
                      io_change     = io_change
                    IMPORTING
                      et_target_key = lt_key3 ).
                  CATCH cx_root INTO lx_root.            "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.

                after_loading(
                  EXPORTING
                    io_change     = io_change
                    iv_load_state = /bobf/if_conf_c=>sc_state_database
                  IMPORTING
                    eo_message    = lo_message ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).

                INSERT LINES OF lt_key3 INTO TABLE lt_failed_root_key.
              ENDIF.

            ENDIF.
            CLEAR: lt_key2, lt_key3, lt_key4, lt_key_for_db.

          ELSE.
            lo_delegation = get_delegation( ls_node-node ).
            TRY.
                lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key = ls_node-node
                    it_key      = lt_key2
                    iv_state    = lv_current_state
                    io_read     = mo_delegation_read
                  IMPORTING
                    et_key_link = lt_key_link ).
                /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
              CATCH cx_root INTO lx_root.                "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
            ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_key_link_matching(
                   it_key_link = lt_key_link
                   it_key      = lt_key2 ) = abap_true.

            LOOP AT lt_key2 INTO ls_key.
              READ TABLE lt_key_link
                 WITH KEY source_key = ls_key-key
                 INTO ls_key_link.
              IF sy-subrc = 0.
                ls_key-key = ls_key_link-target_key.
                APPEND ls_key TO lt_failed_root_key.
              ELSE.
                APPEND ls_key TO lt_key3.
              ENDIF.
            ENDLOOP.
            IF lt_key3 IS NOT INITIAL.
              TRY.
                  lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                  lo_delegation->get_root_key(
                    EXPORTING
                      iv_node_key = ls_node-node
                      it_key      = lt_key3
                      iv_state    = /bobf/if_conf_c=>sc_state_database
                      io_read     = mo_delegation_read
                    IMPORTING
                      et_key_link = lt_key_link ).
                  /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
                CATCH cx_root INTO lx_root.              "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.
              ASSERT ID /bobf/frw_error CONDITION
                 /bobf/cl_tool_assert=>is_key_link_matching(
                     it_key_link = lt_key_link
                     it_key      = lt_key3 ) = abap_true.

              LOOP AT lt_key_link INTO ls_key_link.
                ls_key-key = ls_key_link-target_key.
                APPEND ls_key TO lt_failed_root_key.
              ENDLOOP.
            ENDIF.
            CLEAR: lt_key2,
                   lt_key3.
          ENDIF.
        ENDAT.
      ENDLOOP.
      SORT lt_failed_root_key.
      DELETE ADJACENT DUPLICATES FROM lt_failed_root_key.

      do_det_fill_change_fail(
        EXPORTING
          iv_exectime = iv_exectime
          io_change   = io_change
          it_failed_root_key = lt_failed_root_key
          iv_current_state = lv_current_state
        CHANGING
          co_message  = eo_message
      ).

    ENDIF.

  ENDIF.

* ____________________________________________________________________ *
* create new state for all changed objects
  IF ls_detconf->new_state IS NOT INITIAL AND
     ls_detconf->exectime <> /bobf/if_conf_c=>sc_time_after_loading.

    IF ls_detconf->exectime <> /bobf/if_conf_c=>sc_time_after_validation OR
       NOT ( mo_conf->ms_obj-last_det_state_not_relevant = abap_true AND
             mo_change_fail_det IS BOUND ).

      ls_statecr-create = abap_true.
      ls_statecr-update = abap_true.
      ls_statecr-delete = abap_true.

      io_change->get_changes(
        EXPORTING
          is_change_mode = ls_statecr
        IMPORTING
          et_change      = lt_change ).

      IF lt_failed_root_key IS INITIAL.
*     no failed keys -> perform state handling on node level
        CLEAR lt_tmp_node.
        IF lt_change IS NOT INITIAL.
          LOOP AT lt_change INTO ls_change.
            IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
              mo_conf->get_node( iv_node_key = ls_change-node_key ).
            ENDIF.
            IF mo_conf->ms_last_node-delegation_class IS INITIAL.
              ls_node-node = ls_change-node_key.
              ls_node-key  = ls_change-key.
              INSERT ls_node INTO TABLE lt_tmp_node.
            ENDIF.
          ENDLOOP.
          DELETE ADJACENT DUPLICATES FROM lt_tmp_node.

          TRY.
              mo_buffer->transfer_state(
                EXPORTING
                  it_node         = lt_tmp_node
                  iv_incl_subtree = abap_false
                  iv_state_source = lv_current_state
                  iv_state_dest   = ls_detconf->new_state ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

      ELSE.
*     failed keys are filled -> perform state handling on BO level
        CLEAR lt_key.
        LOOP AT lt_change INTO ls_change.
          ls_key_new-key = ls_change-key.
          APPEND ls_key_new TO lt_key.
          AT END OF node_key.
*         get root key
            IF ls_change-node_key = mo_conf->ms_obj-root_node_key.
              APPEND LINES OF lt_key TO lt_root_key.
            ELSE.
              IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
                mo_conf->get_node( iv_node_key = ls_change-node_key ).
              ENDIF.
              IF mo_conf->ms_last_node-delegation_class IS INITIAL.
                TRY.
                    mo_buffer->get_root_key(
                    EXPORTING
                      iv_node_key   = ls_change-node_key
                      it_key        = lt_key
                      iv_state      = lv_current_state
                      io_change     = io_change
                    IMPORTING
                      et_target_key = lt_tmp_key
                      et_failed_key = lt_failed_key ).
                  CATCH cx_root INTO lx_root.            "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.
                ASSERT ID /bobf/frw_error CONDITION
                    /bobf/cl_tool_assert=>is_key_subset(
                        it_key_set    = lt_key
                        it_key_subset = lt_failed_key ) = abap_true.

                after_loading(
                  EXPORTING
                    io_change     = io_change
                    iv_load_state = lv_current_state
                  IMPORTING
                    eo_message    = lo_message ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).

                APPEND LINES OF lt_tmp_key TO lt_root_key.

              ELSE.
                CLEAR lt_failed_key.
              ENDIF.
            ENDIF.

            IF lt_failed_key IS NOT INITIAL AND
               ls_detconf->last_state IS NOT INITIAL.
*           get root of deleted objects
              TRY.
                  mo_buffer->get_root_key(
                    EXPORTING
                      iv_node_key   = ls_change-node_key
                      it_key        = lt_failed_key
                      iv_state      = ls_detconf->last_state
                      io_change     = io_change
                    IMPORTING
                      et_target_key = lt_tmp_key ).
                CATCH cx_root INTO lx_root.              "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.

              after_loading(
                EXPORTING
                  io_change     = io_change
                  iv_load_state = ls_detconf->last_state
                IMPORTING
                  eo_message    = lo_message ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              APPEND LINES OF lt_tmp_key TO lt_root_key.
            ENDIF.
            CLEAR: lt_tmp_key,
                   lt_key.
          ENDAT.
        ENDLOOP.

        SORT lt_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_root_key.

*     filter root keys regarding failed keys
        IF lt_failed_root_key IS NOT INITIAL.
          LOOP AT lt_root_key INTO ls_key_new.
            READ TABLE lt_failed_root_key WITH KEY key_sort
              COMPONENTS key = ls_key_new-key
              TRANSPORTING NO FIELDS.
            CHECK sy-subrc = 0.
            DELETE lt_root_key.
          ENDLOOP.
        ENDIF.

*     transfer state
        IF lt_root_key IS NOT INITIAL.
          map_to_node(
            EXPORTING
              iv_node_key = mo_conf->ms_obj-root_node_key
              it_key      = lt_root_key
            IMPORTING
              et_node     = lt_tmp_node ).
          TRY.
              mo_buffer->transfer_state(
              EXPORTING
                it_node         = lt_tmp_node
                iv_incl_subtree = abap_true
                iv_state_source = lv_current_state
                iv_state_dest   = ls_detconf->new_state ).
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


 METHOD do_determinations_retrieve.

   DATA: lt_key              TYPE        /bobf/t_frw_key,
         lt_tmp_key          TYPE        /bobf/t_frw_key,
         lv_node_key         TYPE        /bobf/obm_node_key,
         lv_trigger_node_key TYPE        /bobf/obm_node_key,
         ls_detconf          TYPE REF TO /bobf/s_confro_exectime,
         ls_detlist          TYPE        /bobf/s_confro_det_list,
         ls_ctx_det          TYPE        /bobf/s_frw_ctx_det,
         ls_ctx_assoc        TYPE        /bobf/s_frw_ctx_assoc,
         ls_det              TYPE        ty_determination,
         ls_key_new          TYPE        /bobf/s_frw_key,
         lo_change           TYPE REF TO /bobf/cl_frw_change,
         lo_message          TYPE REF TO /bobf/if_frw_message,
         lo_message_int      TYPE REF TO /bobf/cl_frw_message,
         ls_runtime_context  TYPE        /bobf/s_frw_runtime_context,
         lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
         lv_content_cat      TYPE        string,
         lt_nodecat          TYPE        /bobf/t_frw_node_cat,
         ls_nodecat          TYPE        /bobf/s_frw_node_cat,
         lv_content_name     TYPE        /bobf/obm_name,
         lt_failed_key       TYPE        /bobf/t_frw_key,
         lx_root             TYPE REF TO cx_root,
         lx_frw              TYPE REF TO /bobf/cx_frw_core,
         ls_statecr          TYPE        /bobf/s_confro_chg_mode,
         lt_change           TYPE        /bobf/t_frw_change,
         lt_tmp_node         TYPE        /bobf/t_frw_node,
         ls_change           TYPE        /bobf/s_frw_change,
         ls_node             TYPE        /bobf/s_frw_node,
         lv_class            TYPE        seoclsname,
         lv_application_info TYPE        string.

   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   CLEAR: eo_message,
          et_failed_key.

*  get configuration
   ls_detconf = mo_conf->get_determination( /bobf/if_conf_c=>sc_time_before_retrieve ).

   IF iv_assoc_key IS NOT INITIAL.
     IF mo_conf->ms_last_assoc-assoc_key <> iv_assoc_key.
       mo_conf->get_assoc( iv_assoc_key  = iv_assoc_key ).
     ENDIF.
   ENDIF.

   IF iv_node_key IS INITIAL.
     lv_node_key         = mo_conf->ms_last_assoc-source_node_key.
     lv_trigger_node_key = mo_conf->ms_last_assoc-target_node_key.
   ELSE.
     lv_node_key         = iv_node_key.
     lv_trigger_node_key = iv_node_key.
   ENDIF.

*  loop at all determinations
   LOOP AT ls_detconf->det_list->* INTO ls_detlist
     WHERE node_key = lv_node_key.

     " take over keys
     lt_key = it_key.

*    check trigger nodes
     READ TABLE ls_detlist-det_trigger->*
       WITH KEY node_key = lv_trigger_node_key
       TRANSPORTING NO FIELDS.
     CHECK sy-subrc = 0.

* ____________________________________________________________________ *
*    filter keys regarding their node category
     IF ls_detlist-node_cat->* IS NOT INITIAL.
       get_node_cat(
         EXPORTING
           iv_node_key      = ls_detlist-node_key
           it_key           = lt_key
           iv_current_state = /bobf/if_conf_c=>sc_state_current
           iv_last_state    = ls_detconf->last_state
         IMPORTING
           et_nodecat       = lt_nodecat
           et_failed_key    = lt_failed_key
           eo_message       = lo_message ).

       ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset(
               it_key_set    = lt_key
               it_key_subset = lt_failed_key ) = abap_true.

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).

       CLEAR: lt_key, lt_tmp_key.
       LOOP AT lt_nodecat INTO ls_nodecat.
         ls_key_new-key = ls_nodecat-key.
         APPEND ls_key_new TO lt_tmp_key.
         AT END OF node_cat_key.
*            check if node category is valid
           READ TABLE ls_detlist-node_cat->*
             WITH KEY node_cat_key = ls_nodecat-node_cat_key
             TRANSPORTING NO FIELDS.
           IF sy-subrc = 0.
             APPEND LINES OF lt_tmp_key TO lt_key.
           ENDIF.
           CLEAR lt_tmp_key.
         ENDAT.
       ENDLOOP.
       CHECK lt_key IS NOT INITIAL.
     ENDIF.

*    create internal access object and context for determinations
     IF lo_int_access IS NOT BOUND.
       CREATE OBJECT lo_change.
       IF iv_key_is_default = abap_true.
         /bobf/cl_frw_int_access=>new_instance(
           EXPORTING
             io_bopf            = me
             io_conf            = mo_conf
             io_buffer          = mo_buffer
             io_change          = lo_change
             iv_class_name      = /bobf/cl_frw_int_defaults=>gc_class_name
           RECEIVING
             eo_internal_access = lo_int_access
         ).
       ELSE.
         /bobf/cl_frw_int_access=>new_instance(
           EXPORTING
             io_bopf            = me
             io_conf            = mo_conf
             io_buffer          = mo_buffer
             io_change          = lo_change
             iv_class_name      = /bobf/cl_frw_int_access_trans=>gc_class_name
           RECEIVING
             eo_internal_access = lo_int_access
         ).
       ENDIF.
       lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
       lo_int_access->set_current_state( iv_current_state  = iv_state ).
       lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_read_only ).

       ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
       INSERT lo_int_access INTO mt_access_stack INDEX 1.

       ls_ctx_det-bo_key              = mo_conf->ms_obj-bo_key.
       ls_ctx_det-root_node_key       = mo_conf->ms_obj-root_node_key.
       ls_ctx_det-node_key            = lv_node_key.
       ls_ctx_det-exectime            = /bobf/if_conf_c=>sc_time_before_retrieve.
       ls_ctx_det-assoc_key           = iv_assoc_key.
       ls_ctx_det-assoc_parameters    = is_parameters.
       ls_ctx_det-filtered_attributes = it_filtered_attributes.
       IF iv_assoc_key IS NOT INITIAL.
         ls_ctx_assoc-bo_key          = mo_conf->ms_obj-bo_key.
         ls_ctx_assoc-root_node_key   = mo_conf->ms_obj-root_node_key.
         ls_ctx_assoc-node_key        = iv_node_key.
         ls_ctx_assoc-assoc_key       = iv_assoc_key.
       ENDIF.
     ENDIF.

*    call determination
     ls_ctx_det-det_key = ls_detlist-det_key.

     READ TABLE mt_determination
       WITH TABLE KEY det_key = ls_detlist-det_key
       INTO ls_det.
     IF sy-subrc <> 0.
       ls_det-det_key = ls_detlist-det_key.
       TRY.
           CREATE OBJECT ls_det-class TYPE (ls_detlist-det_class).
         CATCH cx_sy_create_object_error INTO lx_root.
           lv_content_name = get_content_description(
             iv_det = abap_true
             iv_key = ls_detlist-det_key ).
           lv_content_cat = TEXT-002.
           CREATE OBJECT lx_frw
             EXPORTING
               previous        = lx_root
               textid          = /bobf/cx_frw_core=>sc_no_instance
               mv_classname    = ls_detlist-det_class
               mv_content_cat  = lv_content_cat
               mv_content_name = lv_content_name.
           set_configuration_error( lx_frw ).
       ENDTRY.
       INSERT ls_det INTO TABLE mt_determination.
     ENDIF.

*    call determination check
     IF lt_key IS NOT INITIAL.
       lo_int_access->set_context(
         is_determination   = ls_ctx_det
         is_association     = ls_ctx_assoc
         iv_within_loading  = iv_within_loading
          iv_loading_node_key = iv_loading_node_key
         iv_within_retrieve = abap_true
         iv_read_allowed    = abap_true ).
       TRY.
           DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

           ls_det-class->check(
             EXPORTING
               is_ctx  = ls_ctx_det
               io_read = lo_int_access
             CHANGING
               ct_key  = lt_key ).

           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           lv_content_name = get_content_description(
             iv_det = abap_true
             iv_key = ls_det-det_key ).
           lv_content_cat = TEXT-002.
           lv_class = ls_detlist-det_class.
           lcl_error_text_provider=>get_text_impl_class_error(
             EXPORTING
               iv_content_cat      = /bobf/if_conf_c=>sc_content_det
               iv_content_key      = ls_det-det_key
               iv_node_key         = ls_detlist-node_key
               iv_content_name     = lv_content_name
               iv_content_class    = lv_class
               iv_method_name      = 'CHECK'
               io_configuration    = mo_conf
             RECEIVING
               rv_application_info = lv_application_info
           ).
           CREATE OBJECT lx_frw
             EXPORTING
               previous                   = lx_root
               textid                     = /bobf/cx_frw_core=>sc_content_exception
               mv_node                    = ls_detlist-node_key
               mv_method_name             = 'CHECK'
               mv_content_name            = lv_content_name
               mv_content_cat             = lv_content_cat
               mv_application_information = lv_application_info.
           set_application_error( lx_frw ).
       ENDTRY.
       lo_int_access->invalidate( ).
     ENDIF.

     CHECK lt_key IS NOT INITIAL.

     lo_int_access->set_context(
       is_determination   = ls_ctx_det
       is_association     = ls_ctx_assoc
       iv_read_allowed    = abap_true
       iv_modify_allowed  = abap_true
       iv_within_loading  = iv_within_loading
        iv_loading_node_key = iv_loading_node_key
       iv_within_retrieve = abap_true ).
     TRY.
         lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

         lib_enqueue_context_push_keys( iv_node_key = ls_ctx_det-node_key
                                        it_key      = lt_key ).

         ls_det-class->execute(
           EXPORTING
             is_ctx        = ls_ctx_det
             it_key        = lt_key
             io_read       = lo_int_access
             io_modify     = lo_int_access
           IMPORTING
             eo_message    = lo_message
             et_failed_key = lt_failed_key ).

         lib_enqueue_context_pop( ).

         /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

         ASSERT ID /bobf/frw_error
           CONDITION lt_failed_key IS INITIAL
                  OR iv_node_key   IS INITIAL.

         ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>is_key_subset(
                 it_key_set    = it_key
                 it_key_subset = lt_failed_key ) = abap_true.
         ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>failed_key_message(
                 io_message    = lo_message
                 it_failed_key = lt_failed_key ) = abap_true.

       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         lv_content_name = get_content_description(
           iv_det = abap_true
           iv_key = ls_detlist-det_key ).
         lv_content_cat = TEXT-002.
         lv_class = ls_detlist-det_class.
         lcl_error_text_provider=>get_text_impl_class_error(
           EXPORTING
             iv_content_cat      = /bobf/if_conf_c=>sc_content_det
             iv_content_key      = ls_detlist-det_key
             iv_node_key         = ls_detlist-node_key
             iv_content_name     = lv_content_name
             iv_content_class    = lv_class
             iv_method_name      = 'EXECUTE'
             io_configuration    = mo_conf
           RECEIVING
             rv_application_info = lv_application_info
         ).
         CREATE OBJECT lx_frw
           EXPORTING
             previous                   = lx_root
             textid                     = /bobf/cx_frw_core=>sc_content_exception
             mv_node                    = ls_detlist-node_key
             mv_method_name             = 'EXECUTE'
             mv_content_name            = lv_content_name
             mv_content_cat             = lv_content_cat
             mv_application_information = lv_application_info.
         set_application_error( lx_frw ).
     CLEANUP.
       lib_enqueue_context_pop( ).
     ENDTRY.

     APPEND LINES OF lt_failed_key TO et_failed_key.
     CLEAR lt_failed_key.

     create_durable_msg_container( CHANGING co_message = lo_message ).
     IF lo_message IS BOUND.
       lo_message_int ?= lo_message.
       ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
       ls_runtime_context-node_key = ls_ctx_det-node_key.
       ls_runtime_context-det_key  = ls_ctx_det-det_key.
       lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key ).

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).
     ENDIF.

*    check for undone modifications and flush
     IF lo_int_access->mt_modification IS NOT INITIAL.
       " >>>>> enhance shortdump // customer ticket 2534832 2012 // internal ticket 3156594 2012
       " lo_int_access->end_modify( ).
       TRY.
           lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
           lo_int_access->end_modify( ).
           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           lv_content_name = get_content_description( iv_det = abap_true iv_key = ls_detlist-det_key ).
           lv_content_cat = TEXT-002.
           lv_class = ls_detlist-det_class.
           lv_application_info = lcl_error_text_provider=>get_text_impl_class_error(
             iv_content_cat      = /bobf/if_conf_c=>sc_content_det
             iv_content_key      = ls_detlist-det_key
             iv_node_key         = ls_detlist-node_key
             iv_content_name     = lv_content_name
             iv_content_class    = lv_class
             iv_method_name      = 'FRW_END_MODIFY'
             io_configuration    = mo_conf ).
           CREATE OBJECT lx_frw
             EXPORTING
               previous                   = lx_root
               textid                     = /bobf/cx_frw_core=>sc_content_exception
               mv_node                    = ls_detlist-node_key
               mv_method_name             = 'FRW_END_MODIFY'
               mv_content_name            = lv_content_name
               mv_content_cat             = lv_content_cat
               mv_application_information = lv_application_info.
           set_application_error( lx_frw ).
       ENDTRY.
     ENDIF.
     collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                       CHANGING  co_message = eo_message ).
     lo_int_access->invalidate( ).
   ENDLOOP.

   " collect changes
   IF lo_int_access IS BOUND.
     ls_statecr-create = abap_true.
     ls_statecr-update = abap_true.
     ls_statecr-delete = abap_true.
     lo_int_access->mo_change->get_changes(
       EXPORTING
         is_change_mode = ls_statecr
       IMPORTING
         et_change      = lt_change ).
   ENDIF.

   " transfer state (on node level)
   CLEAR lt_tmp_node.
   IF lt_change IS NOT INITIAL.
     LOOP AT lt_change INTO ls_change.
       IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
         mo_conf->get_node( iv_node_key = ls_change-node_key ).
       ENDIF.
       IF mo_conf->ms_last_node-delegation_class IS INITIAL.
         ls_node-node = ls_change-node_key.
         ls_node-key  = ls_change-key.
         INSERT ls_node INTO TABLE lt_tmp_node.
       ENDIF.
     ENDLOOP.
     DELETE ADJACENT DUPLICATES FROM lt_tmp_node.
     " copy to image 2
     TRY.
         mo_buffer->transfer_state(
           EXPORTING
             it_node         = lt_tmp_node
             iv_incl_subtree = abap_false
             iv_state_source = /bobf/if_conf_c=>sc_state_current
             iv_state_dest   = /bobf/if_conf_c=>sc_state_last_determined ).
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.
     " copy to image 3
     TRY.
         mo_buffer->transfer_state(
           EXPORTING
             it_node         = lt_tmp_node
             iv_incl_subtree = abap_false
             iv_state_source = /bobf/if_conf_c=>sc_state_current
             iv_state_dest   = /bobf/if_conf_c=>sc_state_last_validated ).
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.
   ENDIF.

   IF lo_int_access IS BOUND.
     ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
     DELETE mt_access_stack INDEX 1.
   ENDIF.

   IF et_failed_key IS NOT INITIAL.
     SORT et_failed_key.
     DELETE ADJACENT DUPLICATES FROM et_failed_key.
   ENDIF.

 ENDMETHOD.


 METHOD do_detval.

   DATA: lo_change      TYPE REF TO /bobf/cl_frw_change,
         lt_group_2_way TYPE /bobf/t_frw_group,
         lt_group_3_way TYPE /bobf/t_frw_group,
         lt_failed_val  TYPE /bobf/t_frw_validations,
         lt_validations TYPE /bobf/t_frw_key,
         lo_message     TYPE REF TO /bobf/if_frw_message.


   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   ASSERT ID /bobf/frw CONDITION io_change  IS BOUND.
   CLEAR eo_message.

   lo_change ?= io_change.

   DO.
     ASSERT ID /bobf/frw_error CONDITION sy-index < 4.
*  ____________________________________________________________________ *
*    perform determinations  (after data change)
*    compare: current state - last determined state
     io_change->merge( mo_change_fail_det ).
     CLEAR mo_change_fail_det.
     do_determinations(
       EXPORTING
         iv_exectime      = /bobf/if_conf_c=>sc_time_after_modify
         io_change        = io_change
       IMPORTING
         eo_message       = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

*  ____________________________________________________________________ *
*    new consistency calculation
     get_relevant_groups(
       EXPORTING
         iv_processing_mode = /bobf/if_frw_c=>sc_mode_modify
         iv_state_before    = /bobf/if_conf_c=>sc_state_last_validated
         io_change          = io_change
       IMPORTING
         et_group_2_way     = lt_group_2_way
         et_group_3_way     = lt_group_3_way
         et_validations     = lt_validations
         eo_message         = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

     IF lt_group_2_way IS NOT INITIAL.
       add_trigger_condition( it_group   = lt_group_2_way
                              io_change  = io_change ).
     ENDIF.

*  ____________________________________________________________________ *
*    perform consistency validations
     io_change->merge( mo_change_fail_val ).
     CLEAR mo_change_fail_val.
     do_validate(
       EXPORTING
         io_change                  = io_change
         it_validation              = lt_validations
         iv_only_given_validations  = abap_false
         iv_perform_check_delta     = abap_true
         iv_validation_time_context = iv_validation_time_context
       IMPORTING
         eo_message                 = lo_message
         et_failed_val              = lt_failed_val ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

*  ____________________________________________________________________ *
*    new consistency calculation
     derive_consistency_status(
       EXPORTING
         it_failed_val = lt_failed_val
       IMPORTING
         eo_message    = lo_message
       CHANGING
         ct_group      = lt_group_2_way ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

     INSERT LINES OF lt_group_3_way INTO TABLE lt_group_2_way.
     filter_consistency_groups(
       CHANGING
         ct_group = lt_group_2_way ).

     set_consistency_status(
       EXPORTING
         it_group   = lt_group_2_way
         io_change  = io_change
      IMPORTING
        eo_message = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

*  ____________________________________________________________________ *
*      perform determinations (after validation).
*      compare: current state - last validated state
*      create : last validated state
     lo_change->set_processed( iv_det_processed = abap_true ).

     do_determinations(
       EXPORTING
         iv_exectime      = /bobf/if_conf_c=>sc_time_after_validation
         io_change        = io_change
       IMPORTING
         eo_message       = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

     lo_change->set_processed( iv_val_processed = abap_true ).

*    loop again?
     IF lo_change->has_unprocessed_changes( iv_det_processed = abap_false ) = abap_false.
       EXIT.
     ENDIF.

   ENDDO.

 ENDMETHOD.


  METHOD do_det_fill_change_fail.

    "this methods fills mo_change_fail_val/mo_change_fail_det from io_change,
    "by taking the IT_FAILED_ROOT_KEYS into consideration

    DATA lt_change              TYPE /bobf/t_frw_change.
    DATA lo_message             TYPE REF TO /bobf/if_frw_message.
    DATA lt_key_change          TYPE /bobf/t_frw_key.
    DATA lx_root                TYPE REF TO cx_root.
    DATA lt_key_link            TYPE /bobf/t_frw_key_link.
    DATA lt_key_link_db         TYPE /bobf/t_frw_key_link.
    DATA lt_failed_in_current   TYPE /bobf/t_frw_key.
    DATA lo_delegation          TYPE REF TO /bobf/if_frw_delegation.
    DATA lo_change_fail         TYPE REF TO /bobf/if_frw_change.
    DATA lt_change_fail         TYPE /bobf/t_frw_change.
    DATA lv_from_index          TYPE i.
    DATA ls_key_change          TYPE /bobf/s_frw_key.
    DATA ls_node_meta           TYPE /bobf/s_confro_node.


    FIELD-SYMBOLS <ls_change>            TYPE /bobf/s_frw_change.
    FIELD-SYMBOLS <ls_change_node_key>   TYPE /bobf/s_frw_change.
    FIELD-SYMBOLS <ls_key_link>          TYPE /bobf/s_frw_key_link.


    IF NOT io_change IS BOUND OR
      ( iv_exectime <> /bobf/if_conf_c=>sc_time_after_validation AND
        iv_exectime <> /bobf/if_conf_c=>sc_time_after_modify ).
      RETURN.
    ENDIF.

    lo_change_fail = /bobf/cl_frw_factory=>get_change( ).
    CAST /bobf/cl_frw_change( lo_change_fail )->trace_external_changes( abap_false ).

    "get the destination change object for the change notifications
    IF iv_exectime = /bobf/if_conf_c=>sc_time_after_validation.
      mo_change_fail_val ?= lo_change_fail.
    ELSEIF iv_exectime = /bobf/if_conf_c=>sc_time_after_modify.
      mo_change_fail_det ?= lo_change_fail.
    ENDIF.

    IF it_failed_root_key IS INITIAL.
      RETURN.
    ENDIF.

    io_change->get(
      EXPORTING
        iv_sorted = /bobf/if_frw_c=>sc_change_sort_node_key
      IMPORTING
        et_change = lt_change
     ).

    LOOP AT lt_change ASSIGNING <ls_change>.

      AT NEW node_key.
        lv_from_index = sy-tabix.

        mo_conf->get_node(
          EXPORTING
            iv_node_key = <ls_change>-node_key
          IMPORTING
            es_node = ls_node_meta ).

        CLEAR lt_key_change.
        CLEAR lt_failed_in_current.
        CLEAR lt_key_link.
        CLEAR lt_key_link_db.
      ENDAT.

      "collect all keys of one node
      ls_key_change-key = <ls_change>-key.
      INSERT ls_key_change INTO TABLE lt_key_change.

      AT END OF node_key.

        "get root keys either from buffer or from delegation
        IF ls_node_meta-delegation_class IS INITIAL.
          "common node: get root keys from buffer
          TRY.
              "- try current state
              mo_buffer->get_root_key(
                EXPORTING
                  iv_node_key   = ls_node_meta-node_key
                  it_key        = lt_key_change
                  iv_state      = iv_current_state
                  io_change     = io_change
                IMPORTING
                  et_failed_key = lt_failed_in_current
                  et_key_link   = lt_key_link
              ).

              "- deleted instances: try database state
              IF NOT lt_failed_in_current IS INITIAL.

                mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node_meta-node_key
                    it_key        = lt_failed_in_current
                    iv_state      = /bobf/if_conf_c=>sc_state_database
                    io_change     = io_change
                  IMPORTING
                    et_key_link   = lt_key_link_db
                ).
                INSERT LINES OF lt_key_link_db INTO TABLE lt_key_link.
              ENDIF.

            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          "execute after loadings for newly loaded data
          after_loading(
            EXPORTING
              io_change     = io_change
              iv_load_state = iv_current_state
            IMPORTING
              eo_message    = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = co_message ).
        ELSE.

          "delegation scenario
          lo_delegation = get_delegation( iv_node_key = ls_node_meta-node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
          TRY.
              "- try current state
              lo_delegation->get_root_key(
                EXPORTING
                  iv_node_key   = ls_node_meta-node_key
                  it_key        = lt_key_change
                  iv_state      = iv_current_state
                  io_read       = mo_delegation_read
                IMPORTING
                  et_failed_key = lt_failed_in_current
                  et_key_link   = lt_key_link
               ).

              "- deleted instances: try database state
              IF NOT lt_failed_in_current IS INITIAL.
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node_meta-node_key
                    it_key        = lt_failed_in_current
                    iv_state      = /bobf/if_conf_c=>sc_state_database
                    io_read       = mo_delegation_read
                  IMPORTING
                    et_key_link   = lt_key_link_db
                 ).
                INSERT LINES OF lt_key_link_db INTO TABLE lt_key_link.
              ENDIF.

            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        ENDIF.

        "collect all changes belonging to a failed root key
        LOOP AT lt_change ASSIGNING <ls_change_node_key> FROM lv_from_index.

          "exit condition: next node reached
          IF <ls_change_node_key>-node_key <> ls_node_meta-node_key.
            EXIT.
          ENDIF.

          READ TABLE lt_key_link WITH KEY source_key = <ls_change_node_key>-key ASSIGNING <ls_key_link>.
          IF sy-subrc = 0.
            READ TABLE it_failed_root_key WITH TABLE KEY key_sort COMPONENTS key = <ls_key_link>-target_key
                TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              INSERT <ls_change_node_key> INTO TABLE lt_change_fail.
            ENDIF.
          ENDIF.

        ENDLOOP.

      ENDAT."node key
    ENDLOOP.

    "notify failed changes
    IF NOT lt_change_fail IS INITIAL.
      lo_change_fail->add(
        EXPORTING
          it_change          = lt_change_fail
      ).
    ENDIF.

  ENDMETHOD.


 METHOD do_loading .

*  IV_RELOAD = abap_true  -> load even if objects are in the buffer
*  IV_RELOAD = abap_false -> load only if objects that are not in buffer

   DATA: ls_node        TYPE /bobf/s_frw_node,
         lt_load        TYPE /bobf/t_frw_node,
         ls_load_do     TYPE ts_load_do,
         lt_load_do     TYPE tt_load_do,
         lt_loadable    TYPE /bobf/t_frw_node,
         lt_load_key    TYPE /bobf/t_frw_key,
         ls_node_link   TYPE /bobf/s_frw_node_key_link,
         lt_node_link   TYPE /bobf/t_frw_node_key_link,
         lt_failed_key  TYPE /bobf/t_frw_key,
         ls_failed_node TYPE /bobf/s_frw_node,
         lt_failed_node TYPE /bobf/t_frw_node,
         lt_key         TYPE /bobf/t_frw_key,
         ls_key         TYPE /bobf/s_frw_key,
         lt_tmp_node    TYPE /bobf/t_frw_node,
         lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
         lo_change      TYPE REF TO /bobf/cl_frw_change,
         lo_message     TYPE REF TO /bobf/if_frw_message,
         lx_root        TYPE REF TO cx_root.

   FIELD-SYMBOLS: <ls_load_do>  TYPE ts_load_do.

   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   CLEAR: eo_message,
          et_failed,
          et_loaded_node.

* Check if BO is loadable at all (not completely transient).
   CHECK mv_loadable = abap_true.


*  ____________________________________________________________________ *
*  check buffer first
   IF iv_check_buf = abap_true AND
       iv_reload   = abap_false.

     IF iv_node_key IS INITIAL.
       LOOP AT it_node INTO ls_node.
         ls_key-key = ls_node-key.
         APPEND ls_key TO lt_key.

         AT END OF node.
           IF mo_conf->ms_last_node-node_key <> ls_node-node.
             mo_conf->get_node( ls_node-node ).
           ENDIF.
           CHECK mo_conf->ms_last_node-transient = abap_false.

           TRY.
               mo_buffer->check_state_exists(
               EXPORTING
                 iv_node_key       = ls_node-node
                 it_key            = lt_key
                 iv_state          = /bobf/if_conf_c=>sc_state_current
                 iv_with_data      = iv_load_data
               IMPORTING
                 et_key_exists_not = lt_failed_key ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.

           ASSERT ID /bobf/frw CONDITION
               /bobf/cl_tool_assert=>is_key_subset(
                   it_key_set    = lt_key
                   it_key_subset = lt_failed_key ) = abap_true.

           IF lt_failed_key IS NOT INITIAL.
             TRY.
                 mo_buffer->check_state_exists(
                 EXPORTING
                   iv_node_key       = ls_node-node
                   it_key            = lt_failed_key
                   iv_state          = /bobf/if_conf_c=>sc_state_database
                   iv_with_data      = iv_load_data
                 IMPORTING
                   et_key_exists_not = lt_load_key ).
               CATCH cx_root INTO lx_root.               "#EC CATCH_ALL
                 set_application_error( lx_root ).
             ENDTRY.

             ASSERT ID /bobf/frw CONDITION
                 /bobf/cl_tool_assert=>is_key_subset(
                     it_key_set    = lt_failed_key
                     it_key_subset = lt_load_key ) = abap_true.

             IF lt_load_key IS NOT INITIAL.
               map_to_node(
                 EXPORTING
                   iv_node_key = ls_node-node
                   it_key      = lt_load_key
                 IMPORTING
                   et_node     = lt_tmp_node ).
               INSERT LINES OF lt_tmp_node INTO TABLE lt_load.
               CLEAR lt_load_key.
             ENDIF.
           ENDIF.
           CLEAR lt_key.
         ENDAT.
       ENDLOOP.

     ELSE.
*      call is only for one node (must not be a DO-node)
       IF mo_conf->ms_last_node-node_key <> iv_node_key.
         mo_conf->get_node( iv_node_key ).
       ENDIF.
       CHECK mo_conf->ms_last_node-transient = abap_false.

       TRY.
           mo_buffer->check_state_exists(
           EXPORTING
             iv_node_key       = iv_node_key
             it_key            = it_key
             iv_state          = /bobf/if_conf_c=>sc_state_current
             iv_with_data      = iv_load_data
           IMPORTING
             et_key_exists_not = lt_failed_key ).
         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           set_application_error( lx_root ).
       ENDTRY.

       ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset(
               it_key_set    = it_key
               it_key_subset = lt_failed_key ) = abap_true.

       IF lt_failed_key IS NOT INITIAL.
         TRY.
             mo_buffer->check_state_exists(
             EXPORTING
               iv_node_key       = iv_node_key
               it_key            = lt_failed_key
               iv_state          = /bobf/if_conf_c=>sc_state_database
               iv_with_data      = iv_load_data
             IMPORTING
               et_key_exists_not = lt_load_key ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.

         ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset(
                 it_key_set    = lt_failed_key
                 it_key_subset = lt_load_key ) = abap_true.

         IF lt_load_key IS NOT INITIAL.
           map_to_node(
             EXPORTING
               iv_node_key = iv_node_key
               it_key      = lt_load_key
             IMPORTING
               et_node     = lt_tmp_node ).
           INSERT LINES OF lt_tmp_node INTO TABLE lt_load.
           CLEAR lt_load_key.
         ENDIF.
       ENDIF.
     ENDIF.

   ELSE.
     IF iv_node_key IS INITIAL.
       lt_load = it_node.
     ELSE.
       map_to_node(
         EXPORTING
           iv_node_key = iv_node_key
           it_key      = it_key
         IMPORTING
           et_node     = lt_load ).
     ENDIF.
   ENDIF.

   CHECK lt_load IS NOT INITIAL.

   IF io_change IS NOT BOUND.
     CREATE OBJECT lo_change TYPE /bobf/cl_frw_change.
   ELSE.
     lo_change ?= io_change.
   ENDIF.

*  ____________________________________________________________________ *
*  get loadable nodes (for data load)
   IF iv_load_data    = abap_false AND
      iv_reload       = abap_false AND
      iv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree.

*    check for delegated nodes
     IF iv_node_key IS NOT INITIAL.
       IF mo_conf->ms_last_node-node_key <> iv_node_key.
         mo_conf->get_node( iv_node_key ).
       ENDIF.
       IF mo_conf->ms_last_node-delegation_class IS INITIAL.
         lt_loadable = lt_load.
       ELSE.
         ls_load_do-delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
         ls_load_do-node                     = lt_load.
         INSERT ls_load_do INTO TABLE lt_load_do.
       ENDIF.
     ELSEIF iv_node_key_unique IS NOT INITIAL.
       IF mo_conf->ms_last_node-node_key <> iv_node_key_unique.
         mo_conf->get_node( iv_node_key_unique ).
       ENDIF.
       IF mo_conf->ms_last_node-delegation_class IS INITIAL.
         lt_loadable = lt_load.
       ELSE.
         ls_load_do-delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
         ls_load_do-node                     = lt_load.
         INSERT ls_load_do INTO TABLE lt_load_do.
       ENDIF.
     ELSE.
*      fallback (should not happen due to existing calls)
       ASSERT ID /bobf/frw CONDITION 0 = 1.                "#EC BOOL_OK
       lt_loadable = lt_load.
     ENDIF.

   ELSE.
     get_loadable_node(
       EXPORTING
         it_node         = lt_load
         iv_load_subtree = iv_load_subtree
         io_change       = lo_change
       IMPORTING
         et_node         = lt_loadable
         et_node_link    = lt_node_link
         et_failed_node  = et_failed
         eo_message      = lo_message
       CHANGING
         ct_load_do      = lt_load_do ).

     ASSERT ID /bobf/frw CONDITION
         /bobf/cl_tool_assert=>is_node_subset(
             it_node_set    = lt_load
             it_node_subset = et_failed ) = abap_true.

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).
   ENDIF.

   IF iv_reload = abap_true.
     LOOP AT it_node_no_reload INTO ls_node.
       DELETE lt_loadable WHERE
          node = ls_node-node AND
          key  = ls_node-key.
     ENDLOOP.
   ENDIF.

*  ____________________________________________________________________ *
*  reload DO nodes
   IF lt_load_do IS NOT INITIAL AND
      iv_reload = abap_true.
     TRY.
         LOOP AT lt_load_do ASSIGNING <ls_load_do>.
           lo_delegation = get_delegation( <ls_load_do>-delegation_root_node_key ).
           DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
           lo_delegation->reload(
             it_node      = <ls_load_do>-node
             iv_edit_mode = iv_edit_mode
             io_change    = lo_change ).
           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

         ENDLOOP.
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.
   ENDIF.

*  ____________________________________________________________________ *
*  load data into currect state (host nodes only)
   IF lt_loadable IS NOT INITIAL.
     TRY.
         mo_buffer->load(
           EXPORTING
             it_node           = lt_loadable
             iv_state          = /bobf/if_conf_c=>sc_state_current
             iv_reload         = iv_reload
             io_change         = lo_change
             iv_fill_data      = iv_load_data
             iv_notify_keyload = iv_notify_keyload
           IMPORTING
             et_failed_node    = lt_failed_node ).
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.
   ENDIF.

   IF iv_load_data     = abap_true OR
       iv_load_subtree <> /bobf/if_frw_c=>sc_load_no_subtree.
     LOOP AT lt_failed_node INTO ls_node.
       LOOP AT lt_node_link INTO ls_node_link
         WHERE target_node = ls_node-node
           AND target_key  = ls_node-key.
         ls_failed_node-node = ls_node_link-source_node.
         ls_failed_node-key  = ls_node_link-source_key.
         INSERT ls_failed_node INTO TABLE et_failed.
       ENDLOOP.
     ENDLOOP.
   ELSE.
     INSERT LINES OF lt_failed_node INTO TABLE et_failed.
   ENDIF.

*  ____________________________________________________________________ *
*  do determination after loading on current state
   after_loading(
     EXPORTING
       io_change         = lo_change
       iv_within_loading = iv_within_loading
        iv_loading_node_key = iv_loading_node_key
        iv_load_state       = /bobf/if_conf_c=>sc_state_current
     IMPORTING
       et_loaded_node    = et_loaded_node
       eo_message        = lo_message ).

   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = eo_message ).

 ENDMETHOD.


 METHOD do_lock_action.
   DATA: lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
         lv_content_name     TYPE        /bobf/obm_name,
         lv_content_cat      TYPE        string,
         ls_act_class        TYPE        ty_action,
         lt_failed_key       TYPE        /bobf/t_frw_key,
         lo_message          TYPE REF TO /bobf/if_frw_message,
         lx_root             TYPE REF TO cx_root,
         lx_frw              TYPE REF TO /bobf/cx_frw_core,
         lv_class            TYPE        seoclsname,
         lv_application_info TYPE        string,
         lo_message_int      TYPE REF TO /bobf/cl_frw_message,
         ls_runtime_context  TYPE /bobf/s_frw_runtime_context.

   BREAK-POINT ID /bobf/frw_lock.
   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

   CLEAR: eo_message,
          et_failed_key.

   lo_int_access ?= /bobf/cl_frw_int_access=>new_instance( io_bopf       = me
                                                           io_conf       = mo_conf
                                                           io_buffer     = mo_buffer
                                                           io_change     = io_change
                                                           iv_class_name = /bobf/cl_frw_int_access_lock=>gc_class_name ).

   ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
   INSERT lo_int_access INTO mt_access_stack INDEX 1.

   lo_int_access->set_last_state(    /bobf/if_conf_c=>sc_state_current ).
   lo_int_access->set_current_state( /bobf/if_conf_c=>sc_state_current ).

*  get action class
   READ TABLE mt_action
      WITH TABLE KEY act_key = is_context-act_key
      INTO ls_act_class.
   IF sy-subrc <> 0.
     ls_act_class-act_key = is_context-act_key.
     TRY.
         CREATE OBJECT ls_act_class-class TYPE (iv_act_class).
       CATCH cx_sy_create_object_error INTO lx_root.
         set_configuration_error( NEW /bobf/cx_frw_core( previous        = lx_root
                                                         textid          = /bobf/cx_frw_core=>sc_no_instance
                                                         mv_classname    = iv_act_class
                                                         mv_content_cat  = CONV #( TEXT-000 )
                                                         mv_content_name = get_content_description( iv_act = abap_true
                                                                                                    iv_key = is_context-act_key ) ) ).
     ENDTRY.
     INSERT ls_act_class INTO TABLE mt_action.
   ENDIF.

   IF mo_conf->ms_last_action-act_key <> is_context-act_key.
     mo_conf->get_act( iv_act_key = is_context-act_key ).
   ENDIF.

   IF mo_conf->ms_last_action-chk_act_also_int = abap_true AND
      mo_conf->ms_last_action-act_cat          = /bobf/if_conf_c=>sc_action_lock.

     check_action( EXPORTING is_context          = is_context
                             is_parameters       = is_lock_param
                             iv_check_property   = abap_false
                             iv_check_validation = abap_true
                             io_change           = io_change
                   IMPORTING et_failed_key       = et_failed_key
                             eo_message          = eo_message
                   CHANGING  ct_key              = ct_key ).

   ELSEIF mo_conf->ms_last_action-prepare_impl = abap_true.
     TRY.
         lo_int_access->set_context( is_action        = is_context
                                     iv_read_allowed  = abap_true
                                     iv_check_allowed = abap_true
                                     it_mod           = ct_mod ).
         DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

         ls_act_class-class->prepare( EXPORTING is_ctx        = is_context
                                                io_read       = lo_int_access
                                                io_check      = lo_int_access
                                                is_parameters = is_lock_param
                                      CHANGING  ct_key        = ct_key ).

         /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
         lo_int_access->invalidate( IMPORTING et_mod = ct_mod ).

       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         lv_content_name = get_content_description( iv_act = abap_true
                                                    iv_key = is_context-act_key ).
         lv_content_cat = TEXT-000.
         lv_class = iv_act_class.
         lv_application_info = lcl_error_text_provider=>get_text_impl_class_error(
                                 iv_content_cat      = /bobf/if_conf_c=>sc_content_act
                                 iv_content_key      = is_context-act_key
                                 iv_node_key         = is_context-node_key
                                 iv_content_name     = lv_content_name
                                 iv_content_class    = lv_class
                                 iv_method_name      = 'PREPARE'
                                 io_configuration    = mo_conf ).
         CREATE OBJECT lx_frw
           EXPORTING
             previous                   = lx_root
             textid                     = /bobf/cx_frw_core=>sc_content_exception
             mv_node                    = is_context-node_key
             mv_method_name             = 'PREPARE'
             mv_content_name            = lv_content_name
             mv_content_cat             = lv_content_cat
             mv_application_information = lv_application_info.
         set_application_error( lx_frw ).
     ENDTRY.
   ENDIF.

   IF ct_key IS INITIAL.
     ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
     DELETE mt_access_stack INDEX 1.
     RETURN.
   ENDIF.

   TRY.
       lo_int_access->set_context( is_action         = is_context
                                   iv_read_allowed   = abap_true
                                   iv_modify_allowed = abap_true
                                   it_mod            = ct_mod ).

       lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

       ls_act_class-class->execute( EXPORTING is_ctx        = is_context
                                              it_key        = ct_key
                                              io_read       = lo_int_access
                                              io_modify     = lo_int_access
                                              is_parameters = is_lock_param
                                    IMPORTING eo_message    = lo_message
                                              et_failed_key = lt_failed_key ).

       /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

       ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>is_key_subset( it_key_set    = ct_key
                                                it_key_subset = lt_failed_key ) = abap_true.

     CATCH cx_root INTO lx_root.                         "#EC CATCH_ALL
       lv_content_name = get_content_description( iv_act = abap_true
                                                  iv_key = is_context-act_key ).
       lv_content_cat = TEXT-000.
       lv_class = iv_act_class.
       lv_application_info = lcl_error_text_provider=>get_text_impl_class_error(
                               iv_content_cat      = /bobf/if_conf_c=>sc_content_act
                               iv_content_key      = is_context-act_key
                               iv_node_key         = is_context-node_key
                               iv_content_name     = lv_content_name
                               iv_content_class    = lv_class
                               iv_method_name      = 'EXECUTE'
                               io_configuration    = mo_conf ).
       CREATE OBJECT lx_frw
         EXPORTING
           previous                   = lx_root
           textid                     = /bobf/cx_frw_core=>sc_content_exception
           mv_node                    = is_context-node_key
           mv_method_name             = 'EXECUTE'
           mv_content_name            = lv_content_name
           mv_content_cat             = lv_content_cat
           mv_application_information = lv_application_info.
       set_application_error( lx_frw ).
   ENDTRY.

   create_durable_msg_container( CHANGING co_message = lo_message ).
    IF lo_message IS BOUND.
      lo_message_int ?= lo_message.
      ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
      ls_runtime_context-node_key = is_context-node_key.
      ls_runtime_context-act_key  = is_context-act_key.
      lo_message_int->set_context( is_context = ls_runtime_context it_key = ct_key ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

   IF et_failed_key IS INITIAL.
     et_failed_key = lt_failed_key.
   ELSE.
     APPEND LINES OF lt_failed_key TO et_failed_key.
   ENDIF.

*  check for undone modifications and flush
   IF lo_int_access->mt_modification IS NOT INITIAL.
     lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
     lo_int_access->end_modify( ).
     /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
   ENDIF.
   collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                     CHANGING  co_message = eo_message ).

   lo_int_access->invalidate( IMPORTING et_mod = ct_mod ).
   ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
   DELETE mt_access_stack INDEX 1.

 ENDMETHOD.


METHOD do_modify.

  CONSTANTS: co_err_sam_create TYPE string VALUE 'creation', "#EC NOTEXT
             co_err_sam_update TYPE string VALUE 'update',  "#EC NOTEXT
             co_err_sam_delete TYPE string VALUE 'deletion'. "#EC NOTEXT

  DATA: ls_node_c                   TYPE        /bobf/s_confro_node,
        lt_mod                      TYPE        /bobf/t_frw_modification,
        lt_mod_del                  TYPE        /bobf/t_frw_modification,
        lt_mod_tmp                  TYPE        /bobf/t_frw_modification,
        lt_mod_tmp_class            TYPE        /bobf/t_frw_modification,
        lt_mod_remove               TYPE        /bobf/t_frw_modification,
        ls_mod_int                  TYPE        /bobf/s_frw_modification,
        lt_mod_do                   TYPE        /bobf/t_frw_modification_do,
        ls_mod_do                   TYPE        /bobf/s_frw_modification_do,
        lt_node                     TYPE        /bobf/t_frw_node,
        ls_node                     TYPE        /bobf/s_frw_node,
        lt_create                   TYPE        /bobf/t_frw_node,
        lt_update                   TYPE        /bobf/t_frw_node,
        lt_node_restore             TYPE        /bobf/t_frw_node,
        lt_node_restore_del         TYPE        /bobf/t_frw_node,
        lt_node_reload              TYPE        /bobf/t_frw_node,
        lt_root_node_restore        TYPE        /bobf/t_frw_node,
        lt_delete                   TYPE        /bobf/t_frw_node,
        lt_delete_dep               TYPE        /bobf/t_frw_node,
        lt_delete_dep_deleg         TYPE        /bobf/t_frw_node,
        lt_load                     TYPE        /bobf/t_frw_node,
        lt_load_only_keyload        TYPE        /bobf/t_frw_node,
        lt_lock                     TYPE        /bobf/t_frw_node,
        lt_lock_generic             TYPE        /bobf/t_frw_node,
        lt_lock_generic_for_delete  TYPE        /bobf/t_frw_node,
        lt_lock_created             TYPE        /bobf/t_frw_node,
        lt_node_category            TYPE        /bobf/t_frw_node,
        ls_lock_data                TYPE REF TO /bobf/s_frw_lock_node,
        lt_new_node                 TYPE        /bobf/t_frw_node,
        lt_delegated_node           TYPE        /bobf/t_frw_node,
        lv_delegation_root_node_key TYPE        /bobf/obm_node_key,
        lo_delegation               TYPE REF TO /bobf/if_frw_delegation,
        lt_update_data              TYPE        /bobf/t_frw_node_data,
        lt_update_data_status       TYPE        /bobf/t_frw_node_data,
        lt_update_data_all          TYPE        /bobf/t_frw_node_data,
        ls_update_data              TYPE        /bobf/s_frw_node_data,
        ls_update_data_status       TYPE        /bobf/s_frw_node_data,
        lt_changed                  TYPE        /bobf/t_frw_node_data,
        lt_unchanged                TYPE        /bobf/t_frw_node_data,
        lt_failed                   TYPE        /bobf/t_frw_node,
        lt_failed_key               TYPE        /bobf/t_frw_key,
        lt_root_key                 TYPE        /bobf/t_frw_key,
        lt_root_key2                TYPE        /bobf/t_frw_key,
        lt_key                      TYPE        /bobf/t_frw_key,
        ls_key                      TYPE        /bobf/s_frw_key,
        lo_message                  TYPE REF TO /bobf/if_frw_message,
        lm_message_esi              TYPE REF TO /bobf/cm_frw_common_esi,
        ls_assoc_status             TYPE        /bobf/s_confro_assoc,
        ls_assoc                    TYPE        /bobf/s_confro_assoc,
        ls_node_conf                TYPE        /bobf/s_confro_node,
        lo_int_access               TYPE REF TO /bobf/cl_frw_int_access,
        lo_int_access_read          TYPE REF TO /bobf/cl_frw_int_access,
        lt_node_state_create        TYPE        /bobf/t_frw_node,
        lt_node_status_create       TYPE        /bobf/t_frw_node,
        lt_node_status_delete       TYPE        /bobf/t_frw_node,
        lv_only_transient           TYPE        boole_d,
        lv_generic_needed           TYPE        boole_d,
        lx_root                     TYPE REF TO cx_root,
        lx_frw                      TYPE REF TO /bobf/cx_frw_core,
        ls_origin_location          TYPE        /bobf/s_frw_location,
        lv_content_cat              TYPE        string,
        lv_changed_field            TYPE        string,
        lv_implemented_create       TYPE        boole_d,
        lv_delete_status            TYPE        boole_d,
        lv_status_variable          TYPE        boole_d,
        lv_check_validation         TYPE        boole_d,
        ls_obj                      TYPE        /bobf/s_confro_obj,
        lt_failed_change            TYPE        /bobf/t_frw_change,
        ls_change                   TYPE        /bobf/s_frw_change,
        lo_change                   TYPE REF TO /bobf/if_frw_change,
        lv_index                    TYPE        sy-index,
        lv_before_modif_set         TYPE        boole_d,
        lv_state_prop_notif         TYPE        /bobf/conf_state,
        lt_messages                 TYPE        /bobf/t_frw_message_k,
        ls_message                  TYPE        /bobf/s_frw_message_k,
        lt_node_needs_read_cache    TYPE        HASHED TABLE OF /bobf/s_frw_key WITH UNIQUE KEY table_line,
        lv_app_info                 TYPE        string,
        lv_message                  TYPE        string.

  FIELD-SYMBOLS: <ls_mod_do>    TYPE /bobf/s_frw_modification_do,
                 <ls_mod>       TYPE /bobf/s_frw_modification,
                 <ls_mod_next>  TYPE /bobf/s_frw_modification,
                 <ls_unchanged> TYPE /bobf/s_frw_node_data.


  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
  CLEAR eo_message.

  eo_change = /bobf/cl_frw_factory=>get_change( ).

  lt_mod = it_modification.

  IF iv_within_loading   = abap_true OR
      iv_within_retrieve = abap_true.
    lv_only_transient = abap_true.
  ELSEIF iv_act_key IS NOT INITIAL.
    IF mo_conf->ms_last_action-act_key <> iv_act_key.
      mo_conf->get_act( iv_act_key = iv_act_key ).
    ENDIF.
    IF mo_conf->ms_last_action-act_cat = /bobf/if_conf_c=>sc_action_lock OR
       mo_conf->ms_last_action-act_cat = /bobf/if_conf_c=>sc_action_unlock.
      lv_only_transient = abap_true.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* analyse modification request
  LOOP AT lt_mod ASSIGNING <ls_mod>.

    INSERT VALUE #( key = <ls_mod>-node ) INTO TABLE lt_node_needs_read_cache.

    IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_create.
      IF <ls_mod>-association IS NOT INITIAL.
        IF mo_conf->ms_last_assoc-assoc_key = <ls_mod>-association.
          ls_assoc = mo_conf->ms_last_assoc.
        ELSE.
          mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_mod>-association
                              IMPORTING es_assoc     = ls_assoc ).
        ENDIF.

        IF ls_assoc-assoc_class IS NOT INITIAL.
          lv_implemented_create = abap_true.
        ENDIF.
      ENDIF.

      "check consistency:
      IF <ls_mod>-node = mo_conf->ms_obj-root_node_key.
        "ROOT instances usually cannot be created by an association - except for implemented associations
        IF <ls_mod>-association IS INITIAL OR ls_assoc-assoc_class IS INITIAL. "not an implemented association
          IF <ls_mod>-source_key  IS NOT INITIAL
          OR <ls_mod>-source_node IS NOT INITIAL
          OR <ls_mod>-association IS NOT INITIAL.
            " Source information provided for the creation of the ROOT-node
            ASSERT ID /bobf/frw CONDITION 1 = 0.
            set_application_error( NEW /bobf/cx_frw_core(
              mv_application_information = `Invalid modification: Source information (source node, source key, association) given for the creation of the root node` ) ) ##no_text.
          ENDIF.
        ENDIF.
      ELSE.
        IF <ls_mod>-association IS INITIAL
        OR <ls_mod>-source_node IS INITIAL
        OR <ls_mod>-source_key  IS INITIAL.
          " Source information missing for the creation of a ROOT-subnode
          ASSERT ID /bobf/frw CONDITION 1 = 0.
          set_application_error( NEW /bobf/cx_frw_core(
            mv_application_information = `Invalid modification: Source information (source node, source key, association) missing for the creation of a subnode` ) ) ##no_text.
        ENDIF.
      ENDIF.
    ENDIF.

*   get node configuration
    ASSERT ID /bobf/frw CONDITION <ls_mod>-node IS NOT INITIAL.
    IF mo_conf->ms_last_node-node_key = <ls_mod>-node.
      ls_node_c = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
         EXPORTING iv_node_key = <ls_mod>-node
         IMPORTING es_node     = ls_node_c ).
      IF ls_node_c IS INITIAL.
*       unknown node
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK
        set_application_error( ).
      ENDIF.
    ENDIF.

*   check for framework nodes
    IF iv_internal_modify  = abap_false AND
       ls_node_c-node_type <> /bobf/if_conf_c=>sc_node_type_normal.

*     no external change on framework nodes allowed!
      ASSERT ID /bobf/frw CONDITION 0 = 1.                 "#EC BOOL_OK
      set_application_error( ).
    ENDIF.

*   check for delegated modifications
    IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_create AND
       <ls_mod>-association IS NOT INITIAL AND
       <ls_mod>-association <> iv_assoc_key.
      IF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source AND
         ls_assoc-source_node->delegation_class IS NOT INITIAL OR
         ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target AND
         ls_assoc-target_node->delegation_class IS NOT INITIAL.
*       delegated modification (create)
        IF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.
          lv_delegation_root_node_key = ls_assoc-source_node->delegation_root_node_key.
        ELSE.
          lv_delegation_root_node_key = ls_assoc-target_node->delegation_root_node_key.
        ENDIF.
        READ TABLE lt_mod_do
          WITH KEY delegation_root_node_key = lv_delegation_root_node_key
          ASSIGNING <ls_mod_do>.
        IF sy-subrc <> 0.
          ls_mod_do-delegation_root_node_key = lv_delegation_root_node_key.
          INSERT ls_mod_do INTO TABLE lt_mod_do ASSIGNING <ls_mod_do>.
        ENDIF.
        APPEND <ls_mod> TO <ls_mod_do>-modification.

*       locking
        READ TABLE lt_new_node WITH KEY
            node = <ls_mod>-source_node
            key  = <ls_mod>-source_key
            TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          ls_node-node = <ls_mod>-source_node.
          ls_node-key  = <ls_mod>-source_key.
          INSERT ls_node INTO TABLE lt_lock.
        ENDIF.
        ls_node-node = <ls_mod>-node.
        ls_node-key  = <ls_mod>-key.
        INSERT ls_node INTO TABLE lt_new_node.

        DELETE lt_mod.
        CONTINUE.
      ENDIF.

    ELSE.
      IF ls_node_c-delegation_class IS NOT INITIAL.
*       delegated modification (update/delete)
        READ TABLE lt_mod_do
          WITH KEY delegation_root_node_key = ls_node_c-delegation_root_node_key
          ASSIGNING <ls_mod_do>.
        IF sy-subrc <> 0.
          ls_mod_do-delegation_root_node_key = ls_node_c-delegation_root_node_key.
          INSERT ls_mod_do INTO TABLE lt_mod_do ASSIGNING <ls_mod_do>.
        ENDIF.
        APPEND <ls_mod> TO <ls_mod_do>-modification.

*       locking
        ls_node-node = <ls_mod>-node.
        ls_node-key  = <ls_mod>-key.
        INSERT ls_node INTO TABLE lt_lock.

        DELETE lt_mod.
        CONTINUE.
      ENDIF.
    ENDIF.

    IF <ls_mod>-node_cat IS INITIAL.
      <ls_mod>-node_cat = ls_node_c-node_cat_key.
    ENDIF.

    CASE <ls_mod>-change_mode.
*     create
      WHEN: /bobf/if_frw_c=>sc_modify_create.
*       set framework guid
        IF <ls_mod>-key IS INITIAL.
          <ls_mod>-key = /bobf/cl_frw_factory=>get_new_key( ).
        ENDIF.
        IF ls_node_c-delegation_class IS INITIAL.
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_create.
          IF  <ls_mod>-node_cat IS INITIAL
          AND ls_node_c-node_type = /bobf/if_conf_c=>sc_node_type_normal
          AND ( <ls_mod>-association IS INITIAL  OR  ls_assoc-assoc_class IS INITIAL ).
            INSERT ls_node INTO TABLE lt_node_category.
          ENDIF.
        ENDIF.
*       check if node has to be loaded in advance
        IF  <ls_mod>-source_node IS NOT INITIAL
        AND ls_assoc-source_node->transient = abap_false
        AND NOT line_exists( lt_new_node[ node = <ls_mod>-source_node key  = <ls_mod>-source_key ] ).
*           source is not created with same modify call

          IF ls_assoc-assoc_class IS INITIAL  OR  ls_assoc-assoc_key = iv_assoc_key."delayed locking for implemented associations during do_modify call of implemented create method (else node instance hierarchy cannot be determined)
            ls_node-node = <ls_mod>-source_node.
            ls_node-key  = <ls_mod>-source_key.
            INSERT ls_node INTO TABLE lt_load_only_keyload.
            IF ls_node_c-transient = abap_false
            AND mo_conf->ms_obj-no_lock = abap_false.
              IF ls_node_c-lockable = abap_false.
                ls_node-node = <ls_mod>-source_node.
                ls_node-key  = <ls_mod>-source_key.
                INSERT ls_node INTO TABLE lt_lock.
              ELSE.
                ls_node-node = <ls_mod>-node.
                ls_node-key  = <ls_mod>-key.
                INSERT ls_node INTO TABLE lt_lock_generic.
              ENDIF.
            ENDIF.
          ENDIF.
        ELSEIF mo_conf->ms_obj-no_lock = abap_false  AND  ls_node_c-lockable = abap_true.
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_lock_created. "newly created instances may not need a real lock (see below)
        ENDIF.
        ls_node-node = <ls_mod>-node.
        ls_node-key  = <ls_mod>-key.
        INSERT ls_node INTO TABLE lt_new_node.

*     update
      WHEN: /bobf/if_frw_c=>sc_modify_update.
        ls_node-node = <ls_mod>-node.
        ls_node-key  = <ls_mod>-key.
*       check if node has to be loaded in advance
        IF ls_node_c-transient = abap_false.
          IF iv_internal_modify  = abap_true.
            READ TABLE lt_create TRANSPORTING NO FIELDS
              WITH KEY node = <ls_mod>-node
                       key  = <ls_mod>-key.
            IF sy-subrc <> 0.
              INSERT ls_node INTO TABLE lt_load.
              IF mo_conf->ms_obj-no_lock = abap_false.
                INSERT ls_node INTO TABLE lt_lock.
              ENDIF.
            ENDIF.
          ELSE.
            INSERT ls_node INTO TABLE lt_load.
            IF mo_conf->ms_obj-no_lock = abap_false.
              INSERT ls_node INTO TABLE lt_lock.
            ENDIF.
          ENDIF.
        ENDIF.

        ls_update_data-node           = <ls_mod>-node.
        ls_update_data-key            = <ls_mod>-key.
        ls_update_data-changed_fields = <ls_mod>-changed_fields.
        ls_update_data-data           = <ls_mod>-data.
        INSERT ls_update_data INTO TABLE lt_update_data_all.

        INSERT ls_node INTO TABLE lt_update.

        IF ( ls_node_c-status_attributes    IS NOT BOUND OR
             ls_node_c-status_attributes->* IS INITIAL ) OR
           ( iv_act_key                     IS INITIAL   AND
             iv_det_key                     IS INITIAL ) OR
             iv_within_loading = abap_true.
*         no status update
          INSERT ls_update_data INTO TABLE lt_update_data.

        ELSEIF ls_node_c-field_names IS NOT BOUND  OR
               ls_node_c-field_names->* IS INITIAL.
*         update on status node
          INSERT <ls_mod>       INTO TABLE lt_mod_remove.
          INSERT ls_update_data INTO TABLE lt_update_data_status.

        ELSE.
*        possibly mixed status/non-status update
          IF <ls_mod>-changed_fields IS NOT INITIAL.
            LOOP AT <ls_mod>-changed_fields INTO lv_changed_field.
              READ TABLE ls_node_c-status_attributes->* TRANSPORTING NO FIELDS
                WITH KEY table_line = lv_changed_field.
              IF sy-subrc = 0.
                IF ls_update_data_status IS INITIAL.
                  ls_update_data_status-node = <ls_mod>-node.
                  ls_update_data_status-key  = <ls_mod>-key.
                  ls_update_data_status-data = <ls_mod>-data.
                ENDIF.
                APPEND lv_changed_field TO ls_update_data_status-changed_fields.
                DELETE <ls_mod>-changed_fields.
              ENDIF.
            ENDLOOP.
            IF ls_update_data_status IS NOT INITIAL.
              INSERT ls_update_data_status INTO TABLE lt_update_data_status.
              CLEAR ls_update_data_status.
            ENDIF.
            IF <ls_mod>-changed_fields IS INITIAL.
              INSERT <ls_mod> INTO TABLE lt_mod_remove.
            ELSE.
              ls_update_data-changed_fields = <ls_mod>-changed_fields.
              INSERT ls_update_data INTO TABLE lt_update_data.
            ENDIF.
          ELSE.
            <ls_mod>-changed_fields       = ls_node_c-field_names->*.
            ls_update_data-changed_fields = ls_node_c-field_names->*.
            INSERT ls_update_data INTO TABLE lt_update_data.
*           When called without changed fields no status field is allowed
*           to be changed by S&AM contract
*           ls_update_data-changed_fields = ls_node_c-sta_field_names->*.
*            CLEAR ls_update_data-changed_fields.
*            INSERT ls_update_data INTO TABLE lt_update_data_status.
          ENDIF.
        ENDIF.

*     delete
      WHEN: /bobf/if_frw_c=>sc_modify_delete.
        ls_node-node = <ls_mod>-node.
        ls_node-key  = <ls_mod>-key.
        INSERT ls_node INTO TABLE lt_delete.
        IF ls_node_c-node_type <> /bobf/if_conf_c=>sc_node_type_status AND
           ls_node_c-node_type <> /bobf/if_conf_c=>sc_node_type_qrtn   AND
           ls_node_c-transient = abap_false.
          INSERT ls_node INTO TABLE lt_load.
          IF mo_conf->ms_obj-no_lock = abap_false.
            INSERT ls_node INTO TABLE lt_lock_generic.
            INSERT ls_node INTO TABLE lt_lock_generic_for_delete.
          ENDIF.
        ENDIF.
    ENDCASE.
  ENDLOOP.

  "nodes being modified require read caching
  notify_nodes_read_cache_enable( it_node_key = CORRESPONDING #( lt_node_needs_read_cache ) ).

  lt_node_state_create = lt_create.
  INSERT LINES OF lt_update INTO TABLE lt_node_state_create.
  INSERT LINES OF lt_delete INTO TABLE lt_node_state_create.

  ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>mod_tables_consistent(
      io_conf   = mo_conf
      it_mod    = lt_mod
      it_create = lt_create
      it_update = lt_update
      it_delete = lt_delete ) = abap_true.

* ____________________________________________________________________ *
* do lockings

  " Ideally, we only _pretend_ to lock new ROOT instances by modifying the lock
  " buffer (see usage of LT_LOCK_CREATED below).
  " However, when locks shall be kept after SAVE, we need to acquire locks
  " even for newly created instances.
  " In case of exclusive dialog locks we should acquire the locks immediately in
  " order to prevent anyone from stealing them shortly before we can acquire them
  " after save.
  " In case of OPTDIAUPD the re-acquire logic during AFTER_SUCCESSFUL_SAVE
  " expects to loose locks anyway, so it is safe to defer the actual locking
  " to this time.
  IF  mv_cleanup_mode  =  /bobf/if_conf_c=>sc_cleanup_keep_lock
  AND mv_enqueue_scope <> /bobf/if_conf_c=>sc_enqueue_scope_optdiaupd.
    INSERT LINES OF lt_lock_created INTO TABLE lt_lock_generic.
    CLEAR lt_lock_created.
  ENDIF.
  DELETE ADJACENT DUPLICATES FROM: lt_lock, lt_lock_generic.

  lock( "generically
    EXPORTING
      it_lock              = lt_lock_generic    " Node Table
      iv_generic           = abap_true
      iv_within_loading    = iv_within_loading
        iv_loading_node_key  = iv_loading_node_key
      iv_edit_mode         = iv_edit_mode" Change Mode
      io_change            = eo_change   " Interface of Change Object
      it_locked_for_delete = lt_lock_generic_for_delete
    CHANGING
      co_message        = eo_message  " Interface of Message Object
      ct_mod            = lt_mod      " Changes
      ct_failed_lock    = lt_failed   " Key Table
  ).

  lock( "non-generically
    EXPORTING
      it_lock           = lt_lock     " Node Table
      iv_generic        = abap_false
      iv_within_loading = iv_within_loading
        iv_loading_node_key = iv_loading_node_key
        iv_edit_mode        = iv_edit_mode " Change Mode
      io_change         = eo_change   " Interface of Change Object
    CHANGING
      co_message        = eo_message  " Interface of Message Object
      ct_mod            = lt_mod
      ct_failed_lock    = lt_failed   " Key Table
  ).

  IF lt_failed IS NOT INITIAL.
*   error: not all nodes locked
    ASSERT ID /bobf/frw CONDITION lt_failed IS NOT INITIAL.
    cleanup_modifications(
      EXPORTING
        it_failed_node       = lt_failed
        io_change            = eo_change
      CHANGING
        ct_mod               = lt_mod
        ct_mod_do            = lt_mod_do
        ct_load              = lt_load
        ct_load_only_keyload = lt_load_only_keyload
        ct_lock_created      = lt_lock_created
        ct_create            = lt_create
        ct_update            = lt_update
        ct_delete            = lt_delete
        ct_update_data       = lt_update_data
        ct_update_data_all   = lt_update_data_all
        ct_update_data_sta   = lt_update_data_status
        ct_node_state_create = lt_node_state_create
        ct_node_category     = lt_node_category ).
  ENDIF.

* ____________________________________________________________________ *
* load required node instance into the buffer
  IF lt_load IS NOT INITIAL.
    DELETE ADJACENT DUPLICATES FROM lt_load.

    do_loading(
      EXPORTING
        it_node           = lt_load
        iv_check_buf      = abap_true
        iv_reload         = abap_false
        iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
        iv_within_loading = iv_within_loading
          iv_loading_node_key = iv_loading_node_key
          iv_load_data        = abap_true
        io_change         = eo_change
      IMPORTING
        et_failed         = lt_failed
        eo_message        = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_node_subset(
            it_node_set    = lt_load
            it_node_subset = lt_failed ) = abap_true.

    IF lt_failed IS NOT INITIAL.
*     error: not all nodes were loaded
      ASSERT ID /bobf/frw CONDITION 0 = 1.                 "#EC BOOL_OK

      IF iv_internal_modify = abap_false.
*       create esi common messages
        LOOP AT lt_failed INTO ls_node.

*         check for creates
          READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY source
            COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                       source_node = ls_node-node
                       source_key  = ls_node-key.
          IF sy-subrc = 0.
            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.
            ls_origin_location-node_key = ls_node-node.
            ls_origin_location-key      = ls_node-key.
            CREATE OBJECT lm_message_esi
              EXPORTING
                textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_create_src
                lifetime           = /bobf/cm_frw=>co_lifetime_transition
                symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                severity           = /bobf/cm_frw=>co_severity_error
                ms_origin_location = ls_origin_location.
            eo_message->add_cm( lm_message_esi ).
          ENDIF.

*        check for updates
          READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY change
            COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_update
                       node        = ls_node-node
                       key         = ls_node-key.
          IF sy-subrc = 0.
            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.
            ls_origin_location-node_key = ls_node-node.
            ls_origin_location-key      = ls_node-key.
            CREATE OBJECT lm_message_esi
              EXPORTING
                textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_update
                lifetime           = /bobf/cm_frw=>co_lifetime_transition
                symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                severity           = /bobf/cm_frw=>co_severity_error
                ms_origin_location = ls_origin_location.
            eo_message->add_cm( lm_message_esi ).
          ENDIF.

*         check for deletes
          READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY change
            COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_delete
                       node        = ls_node-node
                       key         = ls_node-key.
          IF sy-subrc = 0.
            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.
            ls_origin_location-node_key = ls_node-node.
            ls_origin_location-key      = ls_node-key.
            CREATE OBJECT lm_message_esi
              EXPORTING
                textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_delete
                lifetime           = /bobf/cm_frw=>co_lifetime_transition
                symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                severity           = /bobf/cm_frw=>co_severity_error
                ms_origin_location = ls_origin_location.
            eo_message->add_cm( lm_message_esi ).
          ENDIF.
        ENDLOOP.
      ENDIF.

*     clear modification table
      cleanup_modifications(
        EXPORTING
          it_failed_node       = lt_failed
          io_change            = eo_change
        CHANGING
          ct_mod               = lt_mod
          ct_mod_do            = lt_mod_do
          ct_load_only_keyload = lt_load_only_keyload
          ct_lock_created      = lt_lock_created
          ct_create            = lt_create
          ct_update            = lt_update
          ct_delete            = lt_delete
          ct_update_data       = lt_update_data
          ct_update_data_all   = lt_update_data_all
          ct_update_data_sta   = lt_update_data_status
          ct_node_state_create = lt_node_state_create
          ct_node_category     = lt_node_category ).
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* load required node instance into the buffer
  IF lt_load_only_keyload IS NOT INITIAL.
    DELETE ADJACENT DUPLICATES FROM lt_load_only_keyload.
    do_loading(
      EXPORTING
        it_node           = lt_load_only_keyload
        iv_check_buf      = abap_true
        iv_reload         = abap_false
        iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
        iv_within_loading = iv_within_loading
          iv_loading_node_key = iv_loading_node_key
          iv_load_data        = abap_false
        io_change         = eo_change
      IMPORTING
        et_failed         = lt_failed
        eo_message        = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_node_subset(
            it_node_set    = lt_load_only_keyload
            it_node_subset = lt_failed ) = abap_true.

    IF lt_failed IS NOT INITIAL.
*     error: not all nodes were loaded
      ASSERT ID /bobf/frw CONDITION 0 = 1.                 "#EC BOOL_OK

      IF iv_internal_modify = abap_false.
*       create esi common messages
        LOOP AT lt_failed INTO ls_node.

*         check for creates
          READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY source
            COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                       source_node = ls_node-node
                       source_key  = ls_node-key.
          IF sy-subrc = 0.
            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.
            ls_origin_location-node_key = ls_node-node.
            ls_origin_location-key      = ls_node-key.
            CREATE OBJECT lm_message_esi
              EXPORTING
                textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_create_src
                lifetime           = /bobf/cm_frw=>co_lifetime_transition
                symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                severity           = /bobf/cm_frw=>co_severity_error
                ms_origin_location = ls_origin_location.
            eo_message->add_cm( lm_message_esi ).
          ENDIF.
        ENDLOOP.
      ENDIF.

*     clear modification table
      cleanup_modifications(
        EXPORTING
          it_failed_node       = lt_failed
          io_change            = eo_change
        CHANGING
          ct_mod               = lt_mod
          ct_mod_do            = lt_mod_do
          ct_lock_created      = lt_lock_created
          ct_create            = lt_create
          ct_update            = lt_update
          ct_delete            = lt_delete
          ct_update_data       = lt_update_data
          ct_update_data_all   = lt_update_data_all
          ct_update_data_sta   = lt_update_data_status
          ct_node_state_create = lt_node_state_create
          ct_node_category     = lt_node_category ).
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* remove obsolete entries from lt_mod (not removed before to make cleanup_modifications work correctly)
  LOOP AT lt_mod_remove ASSIGNING <ls_mod>.
    READ TABLE lt_mod WITH KEY change
      COMPONENTS node           = <ls_mod>-node
                 change_mode    = <ls_mod>-change_mode
                 node_cat       = <ls_mod>-node_cat
                 key            = <ls_mod>-key
                 changed_fields = <ls_mod>-changed_fields
                 association    = <ls_mod>-association
                 source_node    = <ls_mod>-source_node
                 source_key     = <ls_mod>-source_key TRANSPORTING NO FIELDS.
    CHECK sy-subrc = 0.
    DELETE lt_mod INDEX sy-tabix USING KEY change.
  ENDLOOP.
  CLEAR lt_mod_remove.

* ____________________________________________________________________ *
* check for property violations in modifications
  IF iv_internal_modify = abap_false AND
      ( mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat OR
        mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn ).
    check_properties_before_modify(
      EXPORTING
        io_change = eo_change
        iv_state  = iv_state
      CHANGING
        co_message            = eo_message
        ct_mod                = lt_mod
        ct_mod_do             = lt_mod_do
        ct_create             = lt_create
        ct_update             = lt_update
        ct_delete             = lt_delete
        ct_lock_created       = lt_lock_created
        ct_node_category      = lt_node_category
        ct_update_data        = lt_update_data
        ct_update_data_status = lt_update_data_status
        ct_update_data_all    = lt_update_data_all
        ct_node_state_create  = lt_node_state_create ).
  ENDIF.

* ____________________________________________________________________ *
* check for recursive delete actions
  IF lt_delete IS NOT INITIAL.
    LOOP AT lt_delete INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.
      AT END OF node.
        CLEAR: lt_node,
               lt_delegated_node.
        get_subnodes(
           EXPORTING
              iv_node_key                   = ls_node-node
              it_key                        = lt_key
              iv_stop_at_delegation_subtree = abap_true
              iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_only_buffered
            IMPORTING
              eo_message                     = lo_message
            CHANGING
              ct_host_node                   = lt_node
              ct_delegation_root_node        = lt_delegated_node ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        DELETE lt_node WHERE node = ls_node-node.
        INSERT LINES OF lt_node           INTO TABLE lt_delete_dep.
        INSERT LINES OF lt_delegated_node INTO TABLE lt_delete_dep_deleg.
        CLEAR: lt_key, lt_node, lt_delegated_node.
      ENDAT.
    ENDLOOP.

    DELETE ADJACENT DUPLICATES FROM lt_delete_dep.
    DELETE ADJACENT DUPLICATES FROM lt_delete_dep_deleg.

    mo_conf->get_bo(
      IMPORTING
        es_obj = ls_obj ).

    IF ls_obj-delete_loads_data = abap_true.
      do_loading(
        EXPORTING
          it_node           = lt_delete_dep
          iv_check_buf      = abap_true
          iv_reload         = abap_false
          iv_load_data      = abap_true
          iv_notify_keyload = abap_true
          iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
          iv_within_loading = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
            io_change           = eo_change
        IMPORTING
          et_failed         = lt_failed
          eo_message        = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_node_subset(
              it_node_set    = lt_delete_dep
              it_node_subset = lt_failed ) = abap_true.
    ENDIF.

*   deletes to be delegated
    LOOP AT lt_delete_dep_deleg INTO ls_node.
      AT NEW node.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_node-node
          IMPORTING es_node     = ls_node_c ).

        READ TABLE lt_mod_do ASSIGNING <ls_mod_do>
          WITH KEY delegation_root_node_key = ls_node_c-delegation_root_node_key.
        IF sy-subrc <> 0.
          CLEAR ls_mod_do.
          ls_mod_do-delegation_root_node_key = ls_node_c-delegation_root_node_key.
          INSERT ls_mod_do INTO TABLE lt_mod_do ASSIGNING <ls_mod_do>.
        ENDIF.
      ENDAT.
      DELETE <ls_mod_do>-modification
        WHERE node = ls_node-node
          AND key  = ls_node-key.
      ls_mod_int-node        = ls_node-node.
      ls_mod_int-change_mode = /bobf/if_frw_c=>sc_modify_delete.
      ls_mod_int-key         = ls_node-key.
      APPEND ls_mod_int TO <ls_mod_do>-modification.
    ENDLOOP.

*   standard deletes
    LOOP AT lt_delete_dep INTO ls_node.
      ls_mod_int-node        = ls_node-node.
      ls_mod_int-change_mode = /bobf/if_frw_c=>sc_modify_delete.
      ls_mod_int-key         = ls_node-key.
      APPEND ls_mod_int TO lt_mod_del.
      INSERT ls_node INTO TABLE lt_load.
      READ TABLE lt_delete TRANSPORTING NO FIELDS
        WITH KEY node = ls_node-node
                 key  = ls_node-key.
      IF sy-subrc NE 0.
        INSERT ls_node INTO lt_delete INDEX sy-tabix.
        DELETE lt_delete_dep.  "also not in lt_mod !!
      ENDIF.
    ENDLOOP.
    IF lt_delete_dep IS NOT INITIAL.
      LOOP AT lt_mod ASSIGNING <ls_mod>.
        READ TABLE lt_delete_dep TRANSPORTING NO FIELDS
          WITH KEY node = <ls_mod>-node
                   key  = <ls_mod>-key.
        IF sy-subrc = 0.
          DELETE lt_mod.
        ENDIF.
      ENDLOOP.
    ENDIF.
    APPEND LINES OF lt_mod_del TO lt_mod.
  ENDIF.

  IF mo_conf->ms_obj-status_class IS NOT INITIAL.
*   deleted nodes: get status nodes to delete if necessary
    LOOP AT lt_delete INTO ls_node.
      AT NEW node.
        mo_conf->get_node(
          EXPORTING
            iv_node_key     = ls_node-node
          IMPORTING
            es_node         = ls_node_conf ).
        IF ls_node_conf-status_attributes IS BOUND AND
           ls_node_conf-status_attributes->* IS NOT INITIAL.
          lv_delete_status = abap_true.
          EXIT.
        ELSE.
          mo_conf->get_assoc(
            EXPORTING
              iv_node_key   = ls_node-node
              iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
              iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
            IMPORTING
              es_assoc      = ls_assoc_status ).
          IF ls_assoc_status IS NOT INITIAL.
            lv_delete_status = abap_true.
            EXIT.
          ENDIF.
        ENDIF.
      ENDAT.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
* filter out non-changing update requests
  IF lt_update_data_all IS NOT INITIAL.
    TRY.
        mo_buffer->compare(
        EXPORTING
          it_data      = lt_update_data_all
          iv_state     = iv_state
        IMPORTING
          et_equal     = lt_unchanged
          et_different = lt_changed ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    IF lt_unchanged IS NOT INITIAL.
      cleanup_mods_from_unchanged(
        EXPORTING
          it_unchanged          = lt_unchanged
          it_changed            = lt_changed
        CHANGING
          ct_mod                = lt_mod
          ct_update             = lt_update
          ct_node_state_create  = lt_node_state_create
          ct_update_data        = lt_update_data
          ct_update_data_status = lt_update_data_status
      ).
    ENDIF.
  ENDIF.

*  ____________________________________________________________________ *
* create before modification state
  IF iv_internal_modify = abap_false OR
     lv_delete_status   = abap_true.

    IF lt_node_state_create IS NOT INITIAL.

      get_root_key_modify(
       EXPORTING
         it_node   = lt_node_state_create
         iv_state  = iv_state
         io_change = eo_change
       IMPORTING
         et_key    = lt_root_key
       CHANGING
          ct_mod   = lt_mod ).
      CLEAR lt_node_state_create.
      ls_node-node = mo_conf->ms_obj-root_node_key.
      LOOP AT lt_root_key INTO ls_key.
        ls_node-key = ls_key-key.
        INSERT ls_node INTO TABLE lt_node_state_create.
      ENDLOOP.
    ENDIF.

*   create state
    IF lt_node_state_create IS NOT INITIAL.
      DELETE ADJACENT DUPLICATES FROM lt_node_state_create.
      TRY.
          mo_buffer->transfer_state(
            EXPORTING
              it_node         = lt_node_state_create
              iv_incl_subtree = abap_true
              iv_state_source = iv_state
              iv_state_dest   = /bobf/if_conf_c=>sc_state_before_modification ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      mv_before_modification_exists = abap_true.
      lv_before_modif_set           = abap_true.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* execute modifications
  IF lt_mod    IS NOT INITIAL OR
     lt_mod_do IS NOT INITIAL.
    IF mv_modifying_transaction = abap_false AND
        lv_only_transient       = abap_false.
      mv_modifying_transaction = abap_true.
      create_states( ).
    ENDIF.

*   own modifications
    lo_change = /bobf/cl_frw_factory=>get_change( ).

    IF lv_implemented_create = abap_true.
      CLEAR: lt_mod_tmp.

      LOOP AT lt_mod ASSIGNING <ls_mod>.
        lv_index = sy-tabix.

        IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_update OR
           <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_delete OR
           <ls_mod>-association = iv_assoc_key                     OR
           <ls_mod>-association IS INITIAL.

          APPEND <ls_mod> TO lt_mod_tmp.

        ELSE.
          IF <ls_mod>-association <> ls_assoc-assoc_key.
            mo_conf->get_assoc(
              EXPORTING iv_assoc_key = <ls_mod>-association
              IMPORTING es_assoc     = ls_assoc ).
          ENDIF.

          IF ls_assoc-assoc_class IS INITIAL.
            APPEND <ls_mod> TO lt_mod_tmp.

          ELSE.
*       flush buffer modifications
            IF lt_mod_tmp IS NOT INITIAL.
              TRY.
                  mo_buffer->modify(
                     EXPORTING
                       it_modification   = lt_mod_tmp
                       iv_state          = iv_state
                       io_change         = lo_change
                       iv_only_transient = lv_only_transient
                     IMPORTING
                       eo_message        = lo_message ).
                CATCH cx_root INTO lx_root.              "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
              CLEAR lt_mod_tmp.
            ENDIF.

            APPEND <ls_mod> TO lt_mod_tmp_class.

            READ TABLE lt_mod ASSIGNING <ls_mod_next> INDEX lv_index + 1.

            IF sy-subrc              <> 0 OR
                <ls_mod>-association <> <ls_mod_next>-association.
              create(
                EXPORTING
                  it_mod             = lt_mod_tmp_class
                  iv_edit_mode       = iv_edit_mode
                  iv_assoc_key       = <ls_mod>-association
                  iv_state           = iv_state
                  io_change          = lo_change
                  iv_within_loading  = iv_within_loading
                    iv_loading_node_key = iv_loading_node_key
                    iv_within_retrieve  = iv_within_retrieve
                IMPORTING
                  eo_message = lo_message ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
              CLEAR lt_mod_tmp_class.
            ENDIF.

          ENDIF.
        ENDIF.
      ENDLOOP.

*     flush left buffer modifications
      IF lt_mod_tmp IS NOT INITIAL.
        TRY.
            mo_buffer->modify(
             EXPORTING
               it_modification   = lt_mod_tmp
               iv_state          = iv_state
               io_change         = lo_change
               iv_only_transient = lv_only_transient
             IMPORTING
               eo_message        = lo_message ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
        CLEAR lt_mod_tmp.
      ENDIF.

    ELSE.
*     no implemented create associations used -> use lt_mod directly
      TRY.
          mo_buffer->modify(
            EXPORTING
              it_modification   = lt_mod
              iv_state          = iv_state
              io_change         = lo_change
              iv_only_transient = lv_only_transient
            IMPORTING
              eo_message        = lo_message ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    after_loading(
      EXPORTING
        io_change         = lo_change
        iv_within_loading = iv_within_loading
          iv_loading_node_key = iv_loading_node_key
          iv_load_state       = iv_state
      IMPORTING
        eo_message        = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

* ____________________________________________________________________ *
* remove failed modifications
  IF lo_change IS BOUND.
    lo_change->get_changes(
      EXPORTING
        iv_failed = abap_true
      IMPORTING
        et_change = lt_failed_change ).
    ASSERT ID /bobf/frw CONDITION lt_failed_change IS INITIAL.
    LOOP AT lt_failed_change INTO ls_change.
      AT NEW node_key.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_change-node_key
          IMPORTING es_node     = ls_node_c ).
      ENDAT.
      CHECK ls_node_c-delegation_class IS INITIAL.
      ls_node-node = ls_change-node_key.
      ls_node-key  = ls_change-key.
      INSERT ls_node INTO TABLE lt_node_restore.
      IF iv_internal_modify = abap_true.
*       cleanups for internal changes. For external ones cleanup for entire BO instance is necessary and done below
        CASE ls_change-change_mode.
          WHEN /bobf/if_frw_c=>sc_modify_create.
            DELETE lt_create
              WHERE node = ls_change-node_key
                AND key  = ls_change-key.
          WHEN /bobf/if_frw_c=>sc_modify_update.
            DELETE lt_update
              WHERE node = ls_change-node_key
                AND key  = ls_change-key.
          WHEN /bobf/if_frw_c=>sc_modify_delete.
            DELETE lt_delete
              WHERE node = ls_change-node_key
                AND key  = ls_change-key.
        ENDCASE.
      ELSEIF ls_change-change_mode = /bobf/if_frw_c=>sc_modify_create.
*       create message for rejected create in case of 1:1/1:c-association with same key
        READ TABLE lt_mod ASSIGNING <ls_mod> WITH KEY change
          COMPONENTS change_mode = ls_change-change_mode
                     node        = ls_change-node_key
                     key         = ls_change-key.
        IF sy-subrc = 0 AND <ls_mod>-association IS NOT INITIAL.
          IF mo_conf->ms_last_assoc-assoc_key <> <ls_mod>-association.
            mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_mod>-association ).
          ENDIF.
          IF mo_conf->ms_last_assoc-target_node->key_inherited = abap_true.
            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.

            ls_origin_location-node_key = ls_change-node_key.
            ls_origin_location-key      = ls_change-key.

            CREATE OBJECT lm_message_esi
              EXPORTING
                textid             = /bobf/cm_frw_common_esi=>cm_node_not_more_than_one
                severity           = /bobf/cm_frw=>co_severity_error
                symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                lifetime           = /bobf/cm_frw=>co_lifetime_transition
                ms_origin_location = ls_origin_location
                mv_assoc_key       = mo_conf->ms_last_assoc-assoc_key.

            eo_message->add_cm( lm_message_esi ).
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF lt_failed_change IS NOT INITIAL AND
       iv_internal_modify = abap_false.
      cleanup_modifications(
      EXPORTING
        it_failed_node  = lt_node_restore
        io_change       = lo_change
      CHANGING
        ct_mod           = lt_mod
        ct_mod_do        = lt_mod_do
        ct_lock_created  = lt_lock_created
        ct_create        = lt_create
        ct_update        = lt_update
        ct_delete        = lt_delete
        ct_node_category = lt_node_category ).
    ENDIF.
  ENDIF.

  eo_change->merge( lo_change ).


* ____________________________________________________________________ *
* set node category
  IF lt_node_category IS NOT INITIAL.
    set_node_category(
      EXPORTING
        iv_internal_modify = iv_internal_modify
        it_node            = lt_node_category
      IMPORTING
        et_failed  = lt_failed
        eo_message = lo_message ).

    LOOP AT lt_failed INTO ls_node.
      INSERT ls_node INTO TABLE lt_node_restore.
      DELETE TABLE lt_create FROM ls_node.
    ENDLOOP.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

  ENDIF.

* ____________________________________________________________________ *
* For new application with draft: Check whether a draft instance is
* trying to create an active child instance and vice versa
  IF mo_conf->identify_scenario( ) = /bobf/if_conf_c=>sc_scenario-new_app_w_draft.
    check_inconsistent_composition( EXPORTING it_create_node  = lt_create
                                    IMPORTING eo_message      = lo_message
                                              et_failed_node  = DATA(lt_failed_node) ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    LOOP AT lt_failed_node INTO ls_node.
      INSERT ls_node INTO TABLE lt_node_restore.
      DELETE TABLE lt_create FROM ls_node.
    ENDLOOP.

    CLEAR lt_failed_node.
  ENDIF.


* ____________________________________________________________________ *
* check action: create/update/delete
  IF iv_internal_modify = abap_false.

    CLEAR: lt_key, lt_failed_key.
    LOOP AT lt_create INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.
      AT END OF node.

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_set(
               it_key_set = lt_key ) = abap_true.

        check_action(
          EXPORTING
            iv_node_key         = ls_node-node
            iv_act_cat          = /bobf/if_conf_c=>sc_action_create
            iv_check_property   = abap_false
            iv_check_validation = abap_true
            io_change           = eo_change
          IMPORTING
            et_failed_key       = lt_failed_key
            eo_message          = lo_message
          CHANGING
            ct_key              = lt_key ).

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_check(
               it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        LOOP AT lt_failed_key INTO ls_key.
          ls_node-key = ls_key-key.
          INSERT ls_node INTO TABLE lt_node_restore.
          DELETE TABLE lt_create FROM ls_node.
        ENDLOOP.

        CLEAR: lt_key, lt_failed_key.
      ENDAT.
    ENDLOOP.

* ____________________________________________________________________ *
*   check action: update
    CLEAR: lt_key, lt_failed_key.
    LOOP AT lt_update INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.
      AT END OF node.

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_set(
               it_key_set = lt_key ) = abap_true.

        check_action(
          EXPORTING
            iv_node_key         = ls_node-node
            iv_act_cat          = /bobf/if_conf_c=>sc_action_update
            iv_check_property   = abap_false
            iv_check_validation = abap_true
            io_change           = eo_change
          IMPORTING
            et_failed_key       = lt_failed_key
            eo_message          = lo_message
          CHANGING
            ct_key              = lt_key ).

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_check(
               it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        LOOP AT lt_failed_key INTO ls_key.
          ls_node-key = ls_key-key.
          INSERT ls_node INTO TABLE lt_node_restore.
          DELETE TABLE lt_update FROM ls_node.
        ENDLOOP.

        CLEAR: lt_key, lt_failed_key.
      ENDAT.
    ENDLOOP.

  ENDIF.

* ____________________________________________________________________ *
* check action: delete
  IF iv_internal_modify = abap_false OR
      mo_conf->ms_obj-status_class IS NOT INITIAL.

    IF iv_internal_modify = abap_false.
      lv_check_validation = abap_true.
    ELSE.
      lv_check_validation = abap_false.
    ENDIF.

    CLEAR: lt_key, lt_failed_key.
    LOOP AT lt_delete INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.
      AT END OF node.
        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.
        IF mo_conf->ms_last_node-node_type <> /bobf/if_conf_c=>sc_node_type_normal.
          CLEAR lt_key.
          CONTINUE.
        ENDIF.

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_set(
               it_key_set = lt_key ) = abap_true.

        check_action(
          EXPORTING
            iv_node_key         = ls_node-node
            iv_act_cat          = /bobf/if_conf_c=>sc_action_delete
            iv_check_property   = abap_false
            iv_check_validation = lv_check_validation
            io_change           = eo_change
          IMPORTING
            et_failed_key       = lt_failed_key
            eo_message          = lo_message
          CHANGING
            ct_key              = lt_key ).
        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_check(
               it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        LOOP AT lt_failed_key INTO ls_key.
          ls_node-key = ls_key-key.
          INSERT ls_node INTO TABLE lt_node_restore_del.
          DELETE TABLE lt_delete FROM ls_node.
        ENDLOOP.
        CLEAR: lt_key, lt_failed_key.
      ENDAT.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
* call delete action
  do_delete_action( EXPORTING it_delete      = lt_delete
                              io_change      = eo_change
                    IMPORTING eo_message     = lo_message
                              et_failed_node = DATA(lt_failed_delete) ).
  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).
  LOOP AT lt_failed_delete INTO DATA(ls_failed_delete).
    INSERT ls_failed_delete INTO TABLE lt_node_restore_del.
    DELETE TABLE lt_delete FROM ls_failed_delete.
  ENDLOOP.

* ____________________________________________________________________ *
* undo failed modifications
  IF ( lt_node_restore    IS NOT INITIAL OR
      lt_node_restore_del IS NOT INITIAL ) AND
      mv_before_modification_exists = abap_true.

    CLEAR lt_root_key.
    IF lt_node_restore IS NOT INITIAL.
      get_root_key_modify(
        EXPORTING
          it_node   = lt_node_restore
          iv_state  = iv_state
          io_change = eo_change
        IMPORTING
          et_key    = lt_root_key
        CHANGING
          ct_mod    = lt_mod ).
    ENDIF.
    IF lt_node_restore_del IS NOT INITIAL.
      get_root_key_modify(
        EXPORTING
          it_node   = lt_node_restore_del
          iv_state  = /bobf/if_conf_c=>sc_state_before_modification
          io_change = eo_change
        IMPORTING
          et_key    = lt_root_key2
        CHANGING
          ct_mod    = lt_mod ).
      IF lt_root_key IS NOT INITIAL.
        APPEND LINES OF lt_root_key2 TO lt_root_key.
        SORT lt_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_root_key.
      ELSE.
        lt_root_key = lt_root_key2.
      ENDIF.
    ENDIF.

    ls_node-node = mo_conf->ms_obj-root_node_key.
    LOOP AT lt_root_key INTO ls_key.
      ls_node-key = ls_key-key.
      INSERT ls_node INTO TABLE lt_root_node_restore.
    ENDLOOP.

    TRY.
        mo_buffer->transfer_state(
          EXPORTING
            it_node         = lt_root_node_restore
            iv_incl_subtree = abap_true
            iv_state_source = /bobf/if_conf_c=>sc_state_before_modification
            iv_state_dest   = iv_state ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    cleanup_modifications(
      EXPORTING
        it_failed_root_key   = lt_root_key
        io_change            = eo_change
      CHANGING
        ct_mod               = lt_mod
        ct_mod_do            = lt_mod_do
        ct_lock_created      = lt_lock_created
        ct_create            = lt_create
        ct_update            = lt_update
        ct_delete            = lt_delete
        ct_node_category     = lt_node_category ).

  ENDIF.

* ____________________________________________________________________ *
* delegated modifications
  IF lt_mod_do IS NOT INITIAL.
    TRY.
        LOOP AT lt_mod_do ASSIGNING <ls_mod_do>.
          lo_delegation = get_delegation( <ls_mod_do>-delegation_root_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          lo_delegation->modify(
            EXPORTING
              it_modification             = <ls_mod_do>-modification
              io_change                   = eo_change
              iv_priv_mode_for_auth_check = lv_previous_priv_mode
            IMPORTING
              eo_message                  = lo_message ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDLOOP.

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.

* ____________________________________________________________________ *
* lock newly created node instances (just write the lock buffer)
* (This happens only if locks are to be discarded after SAVE. See
*  reference to LT_LOCK_CREATED above).
  IF iv_edit_mode <> /bobf/if_conf_c=>sc_edit_read_only AND
     lv_only_transient = abap_false                     AND
     lt_lock_created IS NOT INITIAL.

    CLEAR lt_mod_tmp.

    LOOP AT lt_lock_created INTO ls_node.
      IF mo_conf->ms_last_node-node_key <> ls_node-node.
        mo_conf->get_node( iv_node_key = ls_node-node ).
      ENDIF.

      CREATE DATA ls_lock_data.
      ls_lock_data->edit_mode        = iv_edit_mode.
      IF mv_enqueue_scope = /bobf/if_conf_c=>sc_enqueue_scope_optdiaupd.
        ls_lock_data->edit_mode_dialog = /bobf/if_conf_c=>sc_edit_optimistic.
        ls_lock_data->edit_mode_update = iv_edit_mode.
      ELSE.
        " this part is not expected to be executed for EXCDIAUPD:
        ASSERT mv_enqueue_scope <> /bobf/if_conf_c=>sc_enqueue_scope_excdiaupd.
      ENDIF.
      ls_lock_data->generic          = abap_true.
      ls_lock_data->parent_edit_mode = /bobf/if_conf_c=>sc_edit_read_only.

      ls_mod_int-node                = mo_conf->ms_last_node-lock_node_key.
      ls_mod_int-change_mode         = /bobf/if_frw_c=>sc_modify_create.
      ls_mod_int-key                 = ls_node-key.

      ls_lock_data->key              = ls_mod_int-key.
      ls_lock_data->parent_key       = ls_mod_int-key.

      ls_mod_int-data                = ls_lock_data.
*     LS_MOD_INT-ASSOCIATION = " not necessary
      ls_mod_int-source_node         = ls_node-node.
      ls_mod_int-source_key          = ls_node-key.
      APPEND ls_mod_int TO lt_mod_tmp.
    ENDLOOP.

    TRY.
        mo_buffer->modify(
          EXPORTING
            it_modification   = lt_mod_tmp
            iv_state          = /bobf/if_conf_c=>sc_state_current
            io_change         = eo_change
            iv_only_transient = abap_true
          IMPORTING
            eo_message        = lo_message ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

* update S&AM
  IF mo_conf->ms_obj-status_class IS NOT INITIAL.

*  ____________________________________________________________________ *
*   new and deleted nodes: create and delete status nodes if necessary
    LOOP AT lt_create INTO ls_node.
      AT NEW node.
        mo_conf->get_assoc(
          EXPORTING
            iv_node_key   = ls_node-node
            iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
            iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
          IMPORTING
            es_assoc      = ls_assoc_status ).
        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.
        IF mo_conf->ms_last_node-node_type           <> /bobf/if_conf_c=>sc_node_type_status AND
           mo_conf->ms_last_node-status_attributes    IS BOUND                               AND
           mo_conf->ms_last_node-status_attributes->* IS NOT INITIAL.
          lv_status_variable = abap_true.
        ELSE.
          lv_status_variable = abap_false.
        ENDIF.
      ENDAT.
      IF lv_status_variable = abap_true.
        INSERT ls_node INTO TABLE lt_node_status_create.
      ENDIF.
      IF ls_assoc_status IS NOT INITIAL.
        ls_node-node = ls_assoc_status-target_node->node_key.
        INSERT ls_node INTO TABLE lt_node_status_create.
      ENDIF.
    ENDLOOP.

    LOOP AT lt_delete INTO ls_node.
      AT NEW node.
        mo_conf->get_assoc(
          EXPORTING
            iv_node_key   = ls_node-node
            iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
            iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
          IMPORTING
            es_assoc      = ls_assoc_status ).
        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.
        IF mo_conf->ms_last_node-node_type           <> /bobf/if_conf_c=>sc_node_type_status AND
           mo_conf->ms_last_node-status_attributes    IS BOUND                               AND
           mo_conf->ms_last_node-status_attributes->* IS NOT INITIAL.
          lv_status_variable = abap_true.
        ELSE.
          lv_status_variable = abap_false.
        ENDIF.
      ENDAT.
      IF lv_status_variable = abap_true.
        INSERT ls_node INTO TABLE lt_node_status_delete.
      ENDIF.
      IF ls_assoc_status IS NOT INITIAL.
        ls_node-node = ls_assoc_status-target_node->node_key.
        INSERT ls_node INTO TABLE lt_node_status_delete.
      ENDIF.
    ENDLOOP.

*   check for status changes
    IF lt_node_status_create IS NOT INITIAL OR
       lt_update_data_status IS NOT INITIAL OR
       lt_node_status_delete IS NOT INITIAL.

      lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

*     get status adapter
      IF mo_sam IS NOT BOUND.
        TRY.
            CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
              EXPORTING
                iv_bo_key = mo_conf->ms_obj-bo_key.

          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_cat = TEXT-004.
            CREATE OBJECT lx_frw
              EXPORTING
                previous       = lx_root
                textid         = /bobf/cx_frw_core=>sc_no_instance
                mv_classname   = mo_conf->ms_obj-status_class
                mv_content_cat = lv_content_cat.
            set_application_error( lx_frw ).
        ENDTRY.
        ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
      ENDIF.

*  ____________________________________________________________________ *
*     create, update and delete status nodes
      IF lo_int_access IS NOT BOUND.
        /bobf/cl_frw_int_access=>new_instance(
          EXPORTING
            io_bopf            = me
            io_conf            = mo_conf
            io_buffer          = mo_buffer
            io_change          = eo_change
          RECEIVING
            eo_internal_access = lo_int_access
        ).
      ENDIF.
      lo_int_access->set_current_state( iv_state ).
      lo_int_access->set_last_state( /bobf/if_conf_c=>sc_state_before_modification ).
      lo_int_access->set_context(
        EXPORTING
          iv_read_allowed    = abap_true
          iv_modify_allowed  = abap_true ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      INSERT lo_int_access INTO mt_access_stack INDEX 1.

      IF lt_node_status_create IS NOT INITIAL.
        TRY.
            mo_sam->create(
              EXPORTING
                it_node    = lt_node_status_create
                io_read    = lo_int_access
                io_modify  = lo_int_access
              IMPORTING
                eo_message = lo_message ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            IF lo_message IS BOUND.
              lo_message->get_messages(
                IMPORTING
                  et_message  =  lt_messages ).
            ENDIF.

            CLEAR lv_message.

            IF lt_messages IS NOT INITIAL.
              READ TABLE lt_messages INTO ls_message INDEX 1.
              lv_message = ls_message-message->get_text( ).
            ENDIF.

            lcl_error_text_provider=>get_text_sam_error(
              EXPORTING
                iv_error_type       = co_err_sam_create
                iv_bo_key           = mo_conf->ms_obj-bo_key
                iv_message          = lv_message
                io_configuration    = mo_conf
              RECEIVING
                rv_application_info = lv_app_info
            ).

            CREATE OBJECT lx_frw
              EXPORTING
                previous                   = lx_root
                mv_application_information = lv_app_info.
            set_application_error( io_exception = lx_frw ).
        ENDTRY.
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      IF lt_update_data_status IS NOT INITIAL.
        TRY.
            mo_sam->update(
              EXPORTING
                it_status  = lt_update_data_status
                iv_act_key = iv_act_key
                io_read    = lo_int_access
                io_modify  = lo_int_access
              IMPORTING
                eo_message = lo_message ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            IF lo_message IS BOUND.
              lo_message->get_messages(
                IMPORTING
                  et_message  =  lt_messages ).
            ENDIF.

            CLEAR lv_message.

            IF lt_messages IS NOT INITIAL.
              READ TABLE lt_messages INTO ls_message INDEX 1.
              lv_message = ls_message-message->get_text( ).
            ENDIF.

            lcl_error_text_provider=>get_text_sam_error(
              EXPORTING
                iv_error_type       = co_err_sam_update
                iv_bo_key           = mo_conf->ms_obj-bo_key
                iv_message          = lv_message
                io_configuration    = mo_conf
              RECEIVING
                rv_application_info = lv_app_info
            ).

            CREATE OBJECT lx_frw
              EXPORTING
                previous                   = lx_root
                mv_application_information = lv_app_info.
            set_application_error( io_exception = lx_frw ).
        ENDTRY.
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      IF lt_node_status_delete IS NOT INITIAL.
*       create read interface with different current state
        /bobf/cl_frw_int_access=>new_instance(
          EXPORTING
            io_bopf            = me
            io_conf            = mo_conf
            io_buffer          = mo_buffer
          RECEIVING
            eo_internal_access = lo_int_access_read
        ).

        lo_int_access_read->set_current_state( /bobf/if_conf_c=>sc_state_before_modification ).
        lo_int_access_read->set_last_state( /bobf/if_conf_c=>sc_state_before_modification ).
        lo_int_access_read->set_context(
          EXPORTING
            iv_read_allowed = abap_true ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
        INSERT lo_int_access_read INTO mt_access_stack INDEX 1.

        TRY.
            mo_sam->delete(
              EXPORTING
                it_node    = lt_node_status_delete
                io_read    = lo_int_access_read
                io_modify  = lo_int_access
              IMPORTING
                eo_message = lo_message ).
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            IF lo_message IS BOUND.
              lo_message->get_messages(
                IMPORTING
                  et_message  =  lt_messages ).
            ENDIF.

            CLEAR lv_message.

            IF lt_messages IS NOT INITIAL.
              READ TABLE lt_messages INTO ls_message INDEX 1.
              lv_message = ls_message-message->get_text( ).
            ENDIF.

            lcl_error_text_provider=>get_text_sam_error(
              EXPORTING
                iv_error_type       = co_err_sam_delete
                iv_bo_key           = mo_conf->ms_obj-bo_key
                iv_message          = lv_message
                io_configuration    = mo_conf
              RECEIVING
                rv_application_info = lv_app_info
            ).

            CREATE OBJECT lx_frw
              EXPORTING
                previous                   = lx_root
                mv_application_information = lv_app_info.
            set_application_error( io_exception = lx_frw ).
        ENDTRY.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        lo_int_access_read->invalidate( ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.

      ENDIF.

*     check for undone modifications and flush
      IF lo_int_access->mt_modification IS NOT INITIAL.
        lo_int_access->end_modify( ).
      ENDIF.
      collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                        CHANGING  co_message = lo_message ).
      lo_int_access->invalidate( ).
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.
      /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* remove before modification state
  IF lv_before_modif_set = abap_true.
    TRY.
        mo_buffer->delete_state(
            it_node         = lt_node_state_create
            iv_incl_subtree = abap_true
            iv_state        = /bobf/if_conf_c=>sc_state_before_modification ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    mv_before_modification_exists = abap_false.
  ENDIF.

* ____________________________________________________________________ *
* invalidate properties and add association changes (on delete trigger or DO)
  IF mo_conf->ms_obj-last_det_state_not_relevant = abap_true.
    lv_state_prop_notif = /bobf/if_conf_c=>sc_state_last_validated.
  ELSE.
    lv_state_prop_notif = /bobf/if_conf_c=>sc_state_last_determined.
  ENDIF.

  IF lt_delete IS NOT INITIAL.
    notify_property_changes(
      EXPORTING
        io_change     = eo_change
        iv_last_state = lv_state_prop_notif
        iv_delete     = abap_true
     IMPORTING
       eo_message    = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    notify_association_changes_d( EXPORTING io_change     = eo_change
                                            iv_last_state = lv_state_prop_notif
                                  IMPORTING eo_message    = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

  IF lt_mod_do IS NOT INITIAL.
    notify_association_changes_do( EXPORTING io_change  = eo_change
                                             iv_state   = lv_state_prop_notif
                                   IMPORTING eo_message = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

* ____________________________________________________________________ *
* delete defaults
  IF lt_create IS NOT INITIAL AND
     mv_defaults_exists = abap_true.
    CLEAR: lt_mod,
           ls_mod_int.

    ls_mod_int-change_mode = /bobf/if_frw_c=>sc_modify_delete.
    LOOP AT lt_create INTO ls_node.
      AT NEW node.
        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.
      ENDAT.
      IF mo_conf->ms_last_node-node_type = /bobf/if_conf_c=>sc_node_type_normal.
        ls_mod_int-node = ls_node-node.
        ls_mod_int-key  = ls_node-key.
        APPEND ls_mod_int TO lt_mod.
      ENDIF.
    ENDLOOP.

    IF lt_mod IS NOT INITIAL.
      lo_change = /bobf/cl_frw_factory=>get_change( ).
      TRY.
          mo_buffer->modify(
            EXPORTING
              it_modification   = lt_mod
              iv_state          = /bobf/if_conf_c=>sc_state_default
              io_change         = lo_change
              iv_only_transient = abap_true ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* perform determination and validation loop
  IF iv_internal_modify   = abap_false AND
     mv_no_determinations = abap_false AND
     ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
       eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
       eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).

    FREE lt_mod.
    FREE lt_mod_do.

    do_detval( EXPORTING io_change                  = eo_change
                         iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_after_modify
               IMPORTING eo_message                 = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

* ____________________________________________________________________ *
* remove durable messages if necessary
  remove_durable_messages( EXPORTING io_change =  eo_change
                           CHANGING  co_message = eo_message ).

ENDMETHOD.                    "do_modify


 METHOD do_validate.

*  constistency-check

   DATA: lv_last_state        TYPE /bobf/conf_state,
         lo_int_access        TYPE REF TO /bobf/cl_frw_int_access,
         lo_message           TYPE REF TO /bobf/if_frw_message,
         lo_message_int       TYPE REF TO /bobf/cl_frw_message,
         lt_message           TYPE /bobf/t_frw_message_k,
         ls_message           TYPE /bobf/s_frw_message_k,
         ls_message_r         TYPE REF TO /bobf/s_frw_message_k,
         lt_message_key       TYPE /bobf/t_frw_key,
         ls_val_read          TYPE /bobf/s_confro_read,
         lt_node_unsorted     TYPE /bobf/t_frw_node_unsorted,
         lt_node_load         TYPE /bobf/t_frw_node,
         ls_node_load         TYPE /bobf/s_frw_node,
         lt_nodecat           TYPE /bobf/t_frw_node_cat,
         ls_nodecat           TYPE /bobf/s_frw_node_cat,
         ls_assoc_conf        TYPE /bobf/s_confro_assoc,
         lt_val_list          TYPE /bobf/t_confro_val_list,
         ls_val               TYPE ty_validation,
         lt_key               TYPE /bobf/t_frw_key,
         lt_key_tmp           TYPE /bobf/t_frw_key,
         ls_key               TYPE /bobf/s_frw_key,
         lt_key_link          TYPE /bobf/t_frw_key_link,
         ls_key_link          TYPE /bobf/s_frw_key_link,
         lt_failed_key        TYPE /bobf/t_frw_key,
         ls_context           TYPE /bobf/s_frw_ctx_val,
         ls_runtime_context   TYPE /bobf/s_frw_runtime_context,
         lv_use_check_trigger TYPE boole_d,
         lt_modification      TYPE /bobf/t_frw_modification,
         ls_modification      TYPE /bobf/s_frw_modification,
         lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
         ls_action            TYPE /bobf/s_confro_act_list,
         lx_root              TYPE REF TO cx_root,
         lv_content_cat       TYPE string,
         lv_content_name      TYPE /bobf/obm_name,
         lo_change            TYPE REF TO /bobf/cl_frw_change,
         ls_failed_val        TYPE /bobf/s_frw_validations,
         ls_val_group         TYPE /bobf/s_confro_group,    "#EC NEEDED
         lx_frw               TYPE REF TO /bobf/cx_frw_core,
         lv_external          TYPE boole_d,
         lo_change_int        TYPE REF TO /bobf/cl_frw_change,
         lv_class             TYPE seoclsname,
         lv_application_info  TYPE string.

   DATA:
         ls_val_trigger       TYPE /bobf/s_confro_val_trigger,
         lv_node_key          TYPE /bobf/obm_node_key,
         lt_key2              TYPE /bobf/t_frw_key,
         lt_key3              TYPE /bobf/t_frw_key,
         lt_key_missing       TYPE /bobf/t_frw_key,
         lt_val_key_missing   TYPE /bobf/t_frw_key.

   FIELD-SYMBOLS: <ls_val_list> TYPE /bobf/s_confro_val_list,
                  <ls_key>      TYPE /bobf/s_frw_key.



   ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
   CLEAR: eo_message,
          et_failed_val.

   IF io_change->has_changes( ) = abap_false.
     RETURN.
   ENDIF.
*  ____________________________________________________________________ *
*  get all changed nodes
   mo_conf->get_validation( IMPORTING et_val_list  = lt_val_list ).
   CHECK lt_val_list IS NOT INITIAL.
   lo_change ?= io_change.

*  create internal access object for validation
   /bobf/cl_frw_int_access=>new_instance(
     EXPORTING
       io_bopf            = me
       io_conf            = mo_conf
       io_buffer          = mo_buffer
       io_change          = io_change
     RECEIVING
       eo_internal_access = lo_int_access
   ).

   IF iv_last_state_db = abap_true.
     lv_last_state = /bobf/if_conf_c=>sc_state_database.
   ELSEIF mo_conf->ms_obj-last_val_state_not_relevant = abap_true.
     lv_last_state = /bobf/if_conf_c=>sc_state_database.
   ELSE.
     lv_last_state = /bobf/if_conf_c=>sc_state_last_validated.
   ENDIF.
   lo_int_access->set_last_state(
      iv_last_state = lv_last_state ).
   lo_int_access->set_current_state(
      iv_current_state = /bobf/if_conf_c=>sc_state_current ).

   ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
   INSERT lo_int_access INTO mt_access_stack INDEX 1.

   ls_context-bo_key          = mo_conf->ms_obj-bo_key.
   ls_context-root_node_key   = mo_conf->ms_obj-root_node_key.
   ls_context-check_group_key = iv_check_group_key.

   IF iv_perform_check_delta = abap_true.
     lv_use_check_trigger = abap_false.
   ELSE.
     lv_use_check_trigger = abap_true.
   ENDIF.

*  ____________________________________________________________________ *
*  perform validations
   LOOP AT lt_val_list ASSIGNING <ls_val_list>.

*    check whether to execute this one and with which trigger
     IF it_validation IS NOT INITIAL.
       READ TABLE it_validation TRANSPORTING NO FIELDS
         WITH KEY key_sort COMPONENTS key = <ls_val_list>-val_key.
       IF sy-subrc <> 0.                    " validation not provided
         IF iv_only_given_validations = abap_true.
           CONTINUE.
         ENDIF.
         lv_use_check_trigger = abap_false. " do not trigger on check
       ELSE.
         lv_use_check_trigger = abap_true.  " trigger this validation also on check
       ENDIF.
     ENDIF.

****    look at trigger nodes
     determine_triggered_val_keys( EXPORTING is_validation        = <ls_val_list>
                                             io_change            = lo_change
                                             iv_processing_mode   = val_time_to_processing_mode( iv_validation_time_context )
                                             iv_use_check_trigger = lv_use_check_trigger
                                             iv_last_state        = lv_last_state
                                   IMPORTING et_key               = lt_key
                                   CHANGING  co_message           = eo_message ).
     CHECK lt_key IS NOT INITIAL.

*  ____________________________________________________________________ *
*    filter keys regarding their node category
     IF <ls_val_list>-node_cat IS BOUND AND
        <ls_val_list>-node_cat->* IS NOT INITIAL.
       get_node_cat(
         EXPORTING
           iv_node_key      = <ls_val_list>-node_key
           it_key           = lt_key
           iv_current_state = /bobf/if_conf_c=>sc_state_current
           iv_last_state    = lv_last_state
         IMPORTING
           et_nodecat       = lt_nodecat
           et_failed_key    = lt_failed_key
           eo_message       = lo_message ).

       ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset(
               it_key_set    = lt_key
               it_key_subset = lt_failed_key ) = abap_true.

       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).

       CLEAR: lt_key, lt_key_tmp.
       LOOP AT lt_nodecat INTO ls_nodecat.
         ls_key-key = ls_nodecat-key.
         APPEND ls_key TO lt_key_tmp.
         AT END OF node_cat_key.
*          check if node category is valid
           READ TABLE <ls_val_list>-node_cat->*
             WITH KEY node_cat_key = ls_nodecat-node_cat_key
             TRANSPORTING NO FIELDS.
           IF sy-subrc = 0.
             APPEND LINES OF lt_key_tmp TO lt_key.
           ENDIF.
           CLEAR lt_key_tmp.
         ENDAT.
       ENDLOOP.
       CHECK lt_key IS NOT INITIAL.
     ENDIF.

*  ____________________________________________________________________ *
*  implementation existing
     IF <ls_val_list>-val_class IS NOT INITIAL.
*      create context
       mo_conf->get_act(
         EXPORTING
           iv_node_key = <ls_val_list>-node_key
           iv_act_cat  = /bobf/if_conf_c=>sc_action_validate
         IMPORTING
           es_action   = ls_action ).

       ls_context-node_key = <ls_val_list>-node_key.
       ls_context-val_key  = <ls_val_list>-val_key.
       ls_context-act_key  = ls_action-act_key.

*      get validation class
       READ TABLE mt_validation
          WITH TABLE KEY val_key = <ls_val_list>-val_key
          INTO ls_val.
       IF sy-subrc <> 0.
         ls_val-val_key = <ls_val_list>-val_key.

         TRY.
             CREATE OBJECT ls_val-class TYPE (<ls_val_list>-val_class).
             INSERT ls_val INTO TABLE mt_validation.

           CATCH cx_sy_create_object_error INTO lx_root.
             lv_content_name = get_content_description(
               iv_val = abap_true
               iv_key = <ls_val_list>-val_key ).
             lv_content_cat = TEXT-003.
             CREATE OBJECT lx_frw
               EXPORTING
                 previous        = lx_root
                 textid          = /bobf/cx_frw_core=>sc_no_instance
                 mv_classname    = <ls_val_list>-val_class
                 mv_content_cat  = lv_content_cat
                 mv_content_name = lv_content_name.
             set_configuration_error( lx_frw ).
             CONTINUE.
         ENDTRY.
       ENDIF.

*  ____________________________________________________________________ *
*      perform validation check delta
       IF lv_use_check_trigger           = abap_false AND
          <ls_val_list>-check_delta_impl = abap_true.
         IF mo_conf->ms_obj-smart_validations = abap_true.
           CLEAR ls_context-val_time.
         ELSE.
           ls_context-val_time = iv_validation_time_context.
         ENDIF.
         lo_int_access->set_context(
           is_validation   = ls_context
           iv_read_allowed = abap_true ).
         TRY.
             DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

             ls_val-class->check_delta(
               EXPORTING
                 io_read = lo_int_access
                 is_ctx  = ls_context
               CHANGING
                 ct_key  = lt_key ).

             /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             lv_content_name = get_content_description(
               iv_val = abap_true
               iv_key = <ls_val_list>-val_key ).
             lv_content_cat = TEXT-003.
             lv_class = <ls_val_list>-val_class.
             lcl_error_text_provider=>get_text_impl_class_error(
               EXPORTING
                 iv_content_cat      = /bobf/if_conf_c=>sc_content_val
                 iv_content_key      = <ls_val_list>-val_key
                 iv_node_key         = <ls_val_list>-node_key
                 iv_content_name     = lv_content_name
                 iv_content_class    = lv_class
                 iv_method_name      = 'CHECK_DELTA'
                 io_configuration    = mo_conf
               RECEIVING
                 rv_application_info = lv_application_info
             ).
             CREATE OBJECT lx_frw
               EXPORTING
                 previous                   = lx_root
                 textid                     = /bobf/cx_frw_core=>sc_content_exception
                 mv_node                    = <ls_val_list>-node_key
                 mv_method_name             = 'CHECK_DELTA'
                 mv_content_name            = lv_content_name
                 mv_content_cat             = lv_content_cat
                 mv_application_information = lv_application_info.
             set_application_error( lx_frw ).
             CONTINUE.
         ENDTRY.
         lo_int_access->invalidate( ).
         CHECK lt_key IS NOT INITIAL.
       ENDIF.

*  ____________________________________________________________________ *
*      assure that read-nodes are in buffer
       LOOP AT <ls_val_list>-val_read->* INTO ls_val_read.
         IF ls_val_read-assoc            IS NOT INITIAL AND
            ls_val_read-assoc->assoc_key IS NOT INITIAL.
*        association defined from node to be validated to read-node
*        -> retrieve keys of read-nodes
           retrieve_by_association(
             EXPORTING
               iv_node_key    = <ls_val_list>-node_key
               it_key         = lt_key
               iv_association = ls_val_read-assoc->assoc_key
               iv_state       = /bobf/if_conf_c=>sc_state_current
             IMPORTING
               eo_message     = lo_message
               et_key_link    = lt_key_link ).
           ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_key_link_matching(
                  it_key        = lt_key
                  it_key_link   = lt_key_link )
              = abap_true.

           collect_messages( EXPORTING io_message = lo_message
                             CHANGING  co_message = eo_message ).

           CLEAR ls_node_load.
           LOOP AT lt_key_link INTO ls_key_link.
             IF ls_node_load-node NE ls_val_read-assoc->target_node_key
             OR ls_node_load-key  NE ls_key_link-target_key.
               ls_node_load-node = ls_val_read-assoc->target_node_key.
               ls_node_load-key  = ls_key_link-target_key.
               INSERT ls_node_load INTO TABLE lt_node_unsorted.
             ENDIF.
           ENDLOOP.
         ENDIF.
       ENDLOOP.

*      load nodes
       IF lt_node_unsorted IS NOT INITIAL.
         lt_node_load = lt_node_unsorted.
         DELETE ADJACENT DUPLICATES FROM lt_node_load.
         do_loading(
           EXPORTING
             it_node         = lt_node_load
             iv_check_buf    = abap_true
             iv_reload       = abap_false
             iv_load_data    = abap_true
             iv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree
             io_change       = io_change
           IMPORTING
             eo_message      = lo_message ).

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).
         CLEAR: lt_node_load,
                lt_node_unsorted.
       ENDIF.

*  ____________________________________________________________________ *
*  perform validation check

******************* TODO: delete (lt_key2 not used)
*      store keys for stetting of the consistency status
       lt_key2 = lt_key.
*******************

       IF <ls_val_list>-check_impl = abap_true.
         IF mo_conf->ms_obj-smart_validations = abap_true.
           CLEAR ls_context-val_time.
         ELSE.
           ls_context-val_time = iv_validation_time_context.
         ENDIF.
         lo_int_access->set_context(
            is_validation   = ls_context
            iv_read_allowed = abap_true ).
         TRY.
             lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

             ls_val-class->check(
               EXPORTING
                 io_read = lo_int_access
                 is_ctx  = ls_context
               CHANGING
                 ct_key  = lt_key ).

             /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
           CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
             lv_content_name = get_content_description(
               iv_val = abap_true
               iv_key = <ls_val_list>-val_key ).
             lv_content_cat = TEXT-003.
             lv_class = <ls_val_list>-val_class.
             lcl_error_text_provider=>get_text_impl_class_error(
               EXPORTING
                 iv_content_cat      = /bobf/if_conf_c=>sc_content_val
                 iv_content_key      = <ls_val_list>-val_key
                 iv_node_key         = <ls_val_list>-node_key
                 iv_content_name     = lv_content_name
                 iv_content_class    = lv_class
                 iv_method_name      = 'CHECK'
                 io_configuration    = mo_conf
               RECEIVING
                 rv_application_info = lv_application_info
             ).
             CREATE OBJECT lx_frw
               EXPORTING
                 previous                   = lx_root
                 textid                     = /bobf/cx_frw_core=>sc_content_exception
                 mv_node                    = <ls_val_list>-node_key
                 mv_method_name             = 'CHECK'
                 mv_content_name            = lv_content_name
                 mv_content_cat             = lv_content_cat
                 mv_application_information = lv_application_info.
             set_application_error( lx_frw ).
             CONTINUE.
         ENDTRY.

         lo_int_access->invalidate( ).
         CHECK lt_key IS NOT INITIAL.
       ENDIF.

*  ____________________________________________________________________ *
*  perform validation execution
       CLEAR: lt_failed_key,
              lo_message,
              lo_message_int.
       IF mo_conf->ms_obj-smart_validations = abap_true.
         CLEAR ls_context-val_time.
       ELSE.
         ls_context-val_time = iv_validation_time_context.
       ENDIF.
       lo_int_access->set_context(
         is_validation   = ls_context
         iv_read_allowed = abap_true ).

       TRY.
           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message )
               = abap_true.
           lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

           lib_enqueue_context_push_keys( iv_node_key = ls_context-node_key
                                          it_key      = lt_key ).

           ls_val-class->execute(
             EXPORTING
               is_ctx        = ls_context
               it_key        = lt_key
               io_read       = lo_int_access
             IMPORTING
               et_failed_key = lt_failed_key
               eo_message    = lo_message ).

           lib_enqueue_context_pop( ).

           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_key_subset(
                   it_key_set    = lt_key
                   it_key_subset = lt_failed_key )
               = abap_true.
           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message )
               = abap_true.
           ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>failed_key_message(
                   io_message    = lo_message
                   it_failed_key = lt_failed_key )
               = abap_true.

         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           lv_content_name = get_content_description(
             iv_val = abap_true
             iv_key = <ls_val_list>-val_key ).
           lv_content_cat = TEXT-003.
           lv_class = <ls_val_list>-val_class.
           lcl_error_text_provider=>get_text_impl_class_error(
             EXPORTING
               iv_content_cat      = /bobf/if_conf_c=>sc_content_val
               iv_content_key      = <ls_val_list>-val_key
               iv_node_key         = <ls_val_list>-node_key
               iv_content_name     = lv_content_name
               iv_content_class    = lv_class
               iv_method_name      = 'EXECUTE'
               io_configuration    = mo_conf
             RECEIVING
               rv_application_info = lv_application_info
           ).
           CREATE OBJECT lx_frw
             EXPORTING
               previous                   = lx_root
               textid                     = /bobf/cx_frw_core=>sc_content_exception
               mv_node                    = <ls_val_list>-node_key
               mv_method_name             = 'EXECUTE'
               mv_content_name            = lv_content_name
               mv_content_cat             = lv_content_cat
               mv_application_information = lv_application_info.
           set_application_error( lx_frw ).
           CONTINUE.
        CLEANUP.
          lib_enqueue_context_pop( ).
       ENDTRY.
       lo_int_access->invalidate( ).
     ENDIF. " validation class existing

*    check for pseudo validation for delegation objects
     IF mo_conf->ms_last_node-node_key <> <ls_val_list>-node_key.
       mo_conf->get_node( <ls_val_list>-node_key ).
     ENDIF.
     IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
       TRY.
           lo_delegation = get_delegation( <ls_val_list>-node_key ).
           lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
           lo_delegation->check_consistency(
             EXPORTING
               iv_node_key    = <ls_val_list>-node_key
               it_key         = lt_key
               iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure
             IMPORTING
               eo_message     = lo_message ).
           /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
         CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
           set_application_error( lx_root ).
       ENDTRY.

       IF lo_message IS BOUND.
         lo_message->get_messages(
           EXPORTING iv_severity = /bobf/cm_frw=>co_severity_error
           IMPORTING et_message  = lt_message ).
         IF lt_message IS NOT INITIAL.
           lt_failed_key = lt_key.
         ENDIF.
       ENDIF.
     ENDIF.

*    fill list of failed validations for later consistency group calculation
     ls_failed_val-val_key = <ls_val_list>-val_key.
     LOOP AT lt_failed_key ASSIGNING <ls_key>.
       ls_failed_val-key = <ls_key>-key.
       INSERT ls_failed_val INTO TABLE et_failed_val.
     ENDLOOP.

*    set context
     create_durable_msg_container( CHANGING co_message = lo_message ).
     IF lo_message IS BOUND.
       lo_message_int ?= lo_message.
       ls_runtime_context-bo_key      = mo_conf->ms_obj-bo_key.
       ls_runtime_context-node_key    = <ls_val_list>-node_key.
       ls_runtime_context-act_key     = ls_context-act_key.
       ls_runtime_context-val_key     = ls_context-val_key.
       ls_runtime_context-consistency = iv_consistency.
       lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key ).
     ENDIF.

     IF /bobf/cl_frw_message_factory=>use_durable_message( ) = abap_true.
       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).
     ENDIF.

*  ____________________________________________________________________ *
*    update validation node
     IF /bobf/cl_frw_message_factory=>use_durable_message( ) = abap_false.
       CLEAR lt_modification.

       mo_conf->get_assoc(
         EXPORTING
           iv_node_key   = <ls_val_list>-node_key
           iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_message
           iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
         IMPORTING
           es_assoc      = ls_assoc_conf ).
       IF ls_assoc_conf IS NOT INITIAL.
         TRY.
             mo_buffer->retrieve_by_association(
               EXPORTING
                 iv_node_key        = <ls_val_list>-node_key
                 it_key             = lt_key
                 iv_association     = ls_assoc_conf-assoc_key
                 iv_state           = /bobf/if_conf_c=>sc_state_current
                 io_change          = io_change
                 iv_fill_failed_key = abap_false
               IMPORTING
                 et_target_key      = lt_message_key ).
           CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.

         IF lt_message_key IS NOT INITIAL.
           CLEAR lt_failed_key.
           TRY.
               mo_buffer->retrieve(
                 EXPORTING
                   iv_node_key       = ls_assoc_conf-target_node_key
                   it_key            = lt_message_key
                   iv_state          = /bobf/if_conf_c=>sc_state_current
                   iv_fill_data      = abap_true
                   io_change         = io_change
                 IMPORTING
                   et_data           = lt_message ).
             CATCH cx_root INTO lx_root.                   "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.

           ls_modification-change_mode = /bobf/if_frw_c=>sc_modify_delete.
           ls_modification-node        = ls_assoc_conf-target_node_key.
           LOOP AT lt_message INTO ls_message
             WHERE val_key = <ls_val_list>-val_key.
             ls_modification-key         = ls_message-key.
             INSERT ls_modification INTO TABLE lt_modification.
           ENDLOOP.
         ENDIF.

*        insert all newly create messages from lo_message
         IF lo_message_int IS BOUND.
           lo_message_int->/bobf/if_frw_message~get_messages( IMPORTING et_message = lt_message ).
           ls_modification-node        = ls_assoc_conf-target_node_key.
           ls_modification-change_mode = /bobf/if_frw_c=>sc_modify_create.
           ls_modification-association = ls_assoc_conf-assoc_key.
           LOOP AT lt_message INTO ls_message.

*            If the debugger stops here: MS_ORIGIN_LOCATION is not provided in the validation coding!
*            This will result in the message not being displayed
             ASSERT ID /bobf/frw_error CONDITION ls_message-node_key = <ls_val_list>-node_key AND
                 ls_message-parent_key IS NOT INITIAL.

             IF ls_message-node_key = <ls_val_list>-node_key AND
                ls_message-parent_key IS NOT INITIAL.
               CREATE DATA ls_message_r.
               MOVE-CORRESPONDING ls_message TO ls_message_r->*.
               ls_modification-key         = ls_message-key.
               ls_modification-data        = ls_message_r.
               ls_modification-source_node = ls_message-node_key.
               ls_modification-source_key  = ls_message-parent_key.
               INSERT ls_modification INTO TABLE lt_modification.
             ENDIF.
           ENDLOOP.
         ENDIF.
       ELSE.
*        no message node existing
         ASSERT ID /bobf/frw CONDITION 0 = 1.                "#EC BOOL_OK
       ENDIF.

*      write modifications into message node
       IF lt_modification IS NOT INITIAL.
         CLEAR lo_message.
         lo_change_int ?= io_change.
         lv_external = lo_change_int->mv_external.
         lo_change_int->trace_external_changes( abap_false ).
         TRY.
             mo_buffer->modify(
             EXPORTING
               it_modification   = lt_modification
               iv_state          = /bobf/if_conf_c=>sc_state_current
               io_change         = io_change
               iv_only_transient = abap_false
             IMPORTING
               eo_message        = lo_message ).
           CATCH cx_root INTO lx_root.                     "#EC CATCH_ALL
             set_application_error( lx_root ).
         ENDTRY.
         lo_change_int->trace_external_changes( lv_external ).

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).
       ENDIF.
     ENDIF.

   ENDLOOP.

   ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
   DELETE mt_access_stack INDEX 1.

 ENDMETHOD.


  METHOD evaluate_failed_validate_keys.

    DATA lv_failed_node_key TYPE /bobf/obm_node_key.
    DATA lt_target_key      TYPE /bobf/t_frw_key.
    DATA lv_failed_key      TYPE /bobf/conf_key.

    CLEAR et_inconsistent_key.

    CHECK it_failed_val IS NOT INITIAL.

    " Get the Associations and Validations list from the config
    mo_conf->get_assoc_tab( IMPORTING et_assoc = DATA(lt_assoc) ).
    mo_conf->get_validation( IMPORTING et_val_list = DATA(lt_val_list) ).

    LOOP AT it_failed_val INTO DATA(ls_failed_val) GROUP BY ls_failed_val-val_key INTO DATA(val_key).

      LOOP AT GROUP val_key ASSIGNING FIELD-SYMBOL(<ls_failed_validations>).
        " Get the node key using the failed validation key
        lv_failed_node_key = lt_val_list[ val_key = <ls_failed_validations>-val_key ]-node_key.
        lv_failed_key = <ls_failed_validations>-key.

        " do this until you reach the node from where the consistency check was called
        DO.
          IF lv_failed_node_key = iv_node_key.
            IF line_exists( it_key[ KEY key_sort COMPONENTS key = lv_failed_key ] ).
              INSERT VALUE #( key = lv_failed_key ) INTO TABLE et_inconsistent_key.
            ENDIF.
            EXIT.
          ELSE.
            " Get the association key for the current node -> parent node
            ASSIGN lt_assoc[ assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
                             source_node_key = lv_failed_node_key ] TO FIELD-SYMBOL(<ls_assoc_to_parent>).
            IF sy-subrc <> 0.
              EXIT.
            ENDIF.

            " Retrieve the Instance keys for the parent node
            mo_buffer->retrieve_by_association( EXPORTING
                                                 iv_node_key    = lv_failed_node_key
                                                 it_key         = VALUE #( ( key = lv_failed_key ) )
                                                 iv_association = <ls_assoc_to_parent>-assoc_key
                                                 iv_state       = /bobf/if_conf_c=>sc_state_current
                                                IMPORTING
                                                 et_target_key  = lt_target_key ).

            IF lt_target_key IS INITIAL.
              EXIT.
            ENDIF.

            " Assign the parent node's instance key so that the check is done recursively
            lv_failed_key = lt_target_key[ 1 ]-key.

            " Get the node key of the Parent using the association key
            lv_failed_node_key = <ls_assoc_to_parent>-target_node_key.
          ENDIF.
        ENDDO.
      ENDLOOP.
    ENDLOOP.

    " There can be duplicates when the consistency check calling node has multiple instances
    " that has to be checked for consistency, the check is done recursively instance by instance,
    " In other words, just delete the duplicates
    SORT et_inconsistent_key.
    DELETE ADJACENT DUPLICATES FROM et_inconsistent_key.

  ENDMETHOD.


  METHOD execute_action.
    CONSTANTS: lc_undefined TYPE abap_bool VALUE 'U'.

    DATA lv_content_name     TYPE /bobf/obm_name.
    DATA lx_frw              TYPE REF TO /bobf/cx_frw_core.
    DATA lt_failed_key       TYPE /bobf/t_frw_key.
    DATA lx_root             TYPE REF TO cx_root.
    DATA lv_application_info TYPE string.

    CLEAR: et_failed_key, et_data, eo_message.

    DATA(lo_int_access) = /bobf/cl_frw_int_access=>new_instance( io_bopf   = me
                                                                 io_conf   = mo_conf
                                                                 io_buffer = mo_buffer
                                                                 io_change = io_change ).
    IF is_conf-edit_mode = /bobf/if_conf_c=>sc_edit_read_only OR
       is_conf-edit_mode = /bobf/if_conf_c=>sc_edit_shared.
      lo_int_access->set_edit_mode( is_conf-edit_mode ).
    ELSE.
      lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_exclusive ).
    ENDIF.
    lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
    lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
    IF mt_access_stack IS NOT INITIAL.
      READ TABLE mt_access_stack INTO DATA(lo_int_access2) INDEX 1.
      DATA(lv_allowed) = lo_int_access2->mv_process_immediately_allowed.
    ELSE.
      lv_allowed = abap_true.
    ENDIF.
    lo_int_access->set_context(
       is_action                      = is_context
       iv_read_allowed                = abap_true
       iv_modify_allowed              = abap_true
       iv_process_immediately_allowed = lv_allowed
       iv_within_loading              = iv_within_loading
       iv_loading_node_key            = iv_loading_node_key ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

*  get action class
    READ TABLE mt_action WITH TABLE KEY act_key = is_conf-act_key INTO DATA(ls_act_class).
    IF sy-subrc <> 0.
      ls_act_class-act_key = is_conf-act_key.

      TRY.
          CREATE OBJECT ls_act_class-class TYPE (is_conf-act_class).

        CATCH cx_sy_create_object_error INTO lx_root.
          lv_content_name = get_content_description(
            iv_act = abap_true
            iv_key = is_conf-act_key ).
          CREATE OBJECT lx_frw
            EXPORTING
              previous        = lx_root
              textid          = /bobf/cx_frw_core=>sc_no_instance
              mv_classname    = is_conf-act_class
              mv_content_name = lv_content_name
              mv_content_cat  = CONV #( TEXT-000 ).
          set_configuration_error( lx_frw ).
      ENDTRY.

      INSERT ls_act_class INTO TABLE mt_action.
    ENDIF.

    DATA(lv_prev_privileged_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode( ).

    IF is_conf-act_cardinality = /bobf/if_conf_c=>sc_act_card_static.
      ev_static_action_failed = lc_undefined. "pre-set a dummy value for the parameter, so we can later check if the implementation knows about it
    ENDIF.

    TRY.

        lib_enqueue_context_push_keys( iv_node_key = is_context-node_key
                                       it_key      = ct_key ).

        IF is_conf-export_param = /bobf/if_conf_c=>sc_action_export_param_type.
          " action has export parameter type, create result type to avoid a dump
          " in case of et_data has not the expected type
          DATA lr_result_data TYPE REF TO data.
          IF is_conf-export_param_tt IS NOT INITIAL.
            CREATE DATA lr_result_data TYPE (is_conf-export_param_tt).
          ELSE.
            CREATE DATA lr_result_data TYPE STANDARD TABLE OF (is_conf-export_param_s).
          ENDIF.
          FIELD-SYMBOLS <lt_result_data> TYPE ANY TABLE.
          ASSIGN lr_result_data->* TO <lt_result_data>.

          ls_act_class-class->execute(
            EXPORTING
              is_ctx        = is_context
              it_key        = ct_key
              io_read       = lo_int_access
              io_modify     = lo_int_access
              is_parameters = is_parameter
            IMPORTING
              eo_message    = eo_message
              et_failed_key = lt_failed_key
              ev_static_action_failed = ev_static_action_failed
              et_data       = <lt_result_data> ).

          "check if et_data has the expected type:
          DATA lr_descr_ref TYPE REF TO cl_abap_datadescr.
          lr_descr_ref ?= cl_abap_typedescr=>describe_by_data_ref( lr_result_data ).
          IF lr_descr_ref->applies_to_data( p_data = et_data ) = abap_true.
            APPEND LINES OF <lt_result_data> TO et_data.
          ENDIF.

        ELSE.

          ls_act_class-class->execute(
            EXPORTING
              is_ctx                  = is_context
              it_key                  = ct_key
              io_read                 = lo_int_access
              io_modify               = lo_int_access
              is_parameters           = is_parameter
            IMPORTING
              eo_message              = eo_message
              et_failed_key           = lt_failed_key
              ev_static_action_failed = ev_static_action_failed
              et_data                 = et_data ).

        ENDIF.

        lib_enqueue_context_pop( ).

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = ct_key
                it_key_subset = lt_failed_key ) = abap_true.
        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_message_cleared_stack_check( eo_message ) = abap_true.

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        lv_content_name = get_content_description(
          iv_act = abap_true
          iv_key = is_conf-act_key ).
        lcl_error_text_provider=>get_text_impl_class_error(
          EXPORTING
            iv_content_cat      = /bobf/if_conf_c=>sc_content_act
            iv_content_key      = is_conf-act_key
            iv_node_key         = is_conf-node_key
            iv_content_name     = lv_content_name
            iv_content_class    = CONV #( is_conf-act_class )
            iv_method_name      = 'EXECUTE'
            io_configuration    = mo_conf
          RECEIVING
            rv_application_info = lv_application_info
        ).
        CREATE OBJECT lx_frw
          EXPORTING
            previous                   = lx_root
            textid                     = /bobf/cx_frw_core=>sc_content_exception
            mv_node                    = is_conf-node_key
            mv_method_name             = 'EXECUTE'
            mv_content_name            = lv_content_name
            mv_content_cat             = CONV #( TEXT-000 )
            mv_application_information = lv_application_info.
        set_application_error( lx_frw ).

      CLEANUP.
        lib_enqueue_context_pop( ).
    ENDTRY.

    /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).

*  append only failed keys of the basic action
    IF iv_is_base_action = abap_true.
      APPEND LINES OF lt_failed_key TO et_failed_key.
*  failed keys of the basic action must not be in the IT_KEY of the post enhancement actions
      LOOP AT lt_failed_key INTO DATA(ls_failed_key).
        DELETE ct_key USING KEY key_sort WHERE key = ls_failed_key-key.
      ENDLOOP.

    ENDIF.

*  check for undone modifications and flush
    IF lo_int_access->mt_modification IS NOT INITIAL.
      " >>>>> enhance shortdump // customer ticket 2534832 2012 // internal ticket 3156594 2012
      " lo_int_access->end_modify( ).
      TRY.
          lv_prev_privileged_mode = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
          lo_int_access->end_modify( ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description( iv_act = abap_true  iv_key = is_conf-act_key ).
          lv_application_info = lcl_error_text_provider=>get_text_impl_class_error(
            iv_content_cat      = /bobf/if_conf_c=>sc_content_act
            iv_content_key      = is_conf-act_key
            iv_node_key         = is_conf-node_key
            iv_content_name     = lv_content_name
            iv_content_class    = CONV #( is_conf-act_class )
            iv_method_name      = 'FRW_END_MODIFY'
            io_configuration    = mo_conf ).
          CREATE OBJECT lx_frw
            EXPORTING
              previous                   = lx_root
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              mv_node                    = is_conf-node_key
              mv_method_name             = 'FRW_END_MODIFY'
              mv_content_name            = lv_content_name
              mv_content_cat             = CONV #( TEXT-000 )
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ENDTRY.
    ENDIF.

    "EV_STATIC_ACTION_FAILED has been introduced after many implementations of the interface method
    "already existed.  We have to check if the action implementation is aware of the parameter.
    IF ev_static_action_failed = lc_undefined.
      IF mo_conf->ms_obj-smart_validations = abap_true.
        lv_content_name = get_content_description( iv_act = abap_true  iv_key = is_conf-act_key ).
        lv_application_info = lcl_error_text_provider=>get_text_static_action_fail(
              iv_content_key      = is_conf-act_key
              iv_node_key         = is_conf-node_key
              iv_content_name     = lv_content_name
              iv_content_class    = CONV #( is_conf-act_class )
              io_configuration    = mo_conf ).
        CREATE OBJECT lx_frw
          EXPORTING
            previous                   = lx_root
            textid                     = /bobf/cx_frw_core=>sc_static_action_fail_not_set
            mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ELSE.
        IF eo_message IS BOUND.
          eo_message->get_messages( EXPORTING iv_severity = /bobf/cm_frw=>co_severity_error
                                    IMPORTING et_message  = DATA(lt_local_message) ).
        ENDIF.
        IF lt_local_message IS NOT INITIAL.
          ev_static_action_failed = abap_true.
        ELSE.
          io_change->get_changes( EXPORTING iv_failed       = abap_true
                                  IMPORTING et_change       = DATA(lt_failed_local_change) ).
          ev_static_action_failed = boolc( lt_failed_local_change IS NOT INITIAL ).
        ENDIF.
      ENDIF.
    ENDIF.

    collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                      CHANGING  co_message = eo_message ).
    lo_int_access->invalidate( ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

  ENDMETHOD.


METHOD FILTER_CONSISTENCY_GROUPS.

  DATA: lt_group               TYPE /BOBF/T_FRW_GROUP,
        ls_group               TYPE /BOBF/S_FRW_GROUP,
        ls_group2              TYPE /BOBF/S_FRW_GROUP,
        ls_groupconf           TYPE /BOBF/S_CONFRO_GROUP,
        lo_int_access          TYPE REF TO /BOBF/CL_FRW_INT_ACCESS,
        lt_key                 TYPE /BOBF/T_FRW_KEY,
        ls_key                 TYPE /BOBF/S_FRW_KEY,
        lt_status_values       TYPE /BOBF/T_FRW_STATUS_VALUE,
        ls_status_value        TYPE /BOBF/S_FRW_STATUS_VALUE,
        lv_content_cat         TYPE string,
        lx_frw                 TYPE REF TO /BOBF/CX_FRW_CORE,
        lx_root                TYPE REF TO cx_root.

  CHECK ct_group IS NOT INITIAL
    AND mo_conf->ms_obj-status_class IS NOT INITIAL.

* ___________________________________________________________________________ *
* create status adapter access

  /bobf/cl_frw_int_access=>new_instance(
    EXPORTING
      io_bopf            = me
      io_conf            = mo_conf
      io_buffer          = mo_buffer
    RECEIVING
      eo_internal_access = lo_int_access
  ).

  lo_int_access->set_current_state( iv_current_state  = /BOBF/IF_CONF_C=>SC_STATE_CURRENT ).
  lo_int_access->set_last_state(    iv_last_state = /BOBF/IF_CONF_C=>SC_STATE_CURRENT ).
  lo_int_access->set_context(
    EXPORTING
      iv_read_allowed   = abap_true ).

  ASSERT ID /BOBF/FRW CONDITION /BOBF/CL_TOOL_ASSERT=>ACCESS_STACK_INVALID( mt_access_stack ) = abap_false.
  INSERT lo_int_access INTO mt_access_stack INDEX 1.

* get status adapter
  IF mo_sam IS NOT BOUND.
    TRY.
        CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
          EXPORTING
            iv_bo_key = mo_conf->ms_obj-bo_key.

      CATCH cx_sy_create_object_error INTO lx_root.
        lv_content_cat = text-004.
        CREATE OBJECT lx_frw
          EXPORTING
            previous       = lx_root
            textid         = /BOBF/CX_FRW_CORE=>SC_NO_INSTANCE
            mv_classname   = mo_conf->ms_obj-status_class
            mv_content_cat = lv_content_cat.
        set_application_error( lx_frw ).
    ENDTRY.
    ASSERT ID /BOBF/FRW_ERROR CONDITION mo_sam IS BOUND.
  ENDIF.

* ___________________________________________________________________________ *
* read status
  lt_group = ct_group.
  LOOP AT lt_group INTO ls_group.

    ls_key-key = ls_group-key.
    APPEND ls_key TO lt_key.

    AT END OF group_key.
      mo_conf->get_group(
        EXPORTING
          iv_group_key = ls_group-group_key
        IMPORTING
          es_group     = ls_groupconf ).

      TRY.
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          mo_sam->get_consistency_status(
            EXPORTING
              iv_node_key      = ls_groupconf-node_key
              iv_sta_var_key   = ls_groupconf-sta_var_key
              it_key           = lt_key
              io_read          = lo_int_access
            IMPORTING
              et_status_values = lt_status_values ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

*     filter ct_group with results from lt_status_value
      LOOP AT ct_group INTO ls_group2
        WHERE group_key = ls_group-group_key.

        READ TABLE lt_status_values INTO ls_status_value
          WITH KEY key = ls_group2-key.
        IF sy-subrc <> 0 OR ls_status_value-status_value = ls_group2-status_value.
          DELETE ct_group.
        ENDIF.
      ENDLOOP.

      CLEAR lt_key.
    ENDAT.

  ENDLOOP.

  lo_int_access->invalidate( ).

  ASSERT ID /BOBF/FRW CONDITION /BOBF/CL_TOOL_ASSERT=>UPMOST_INT_ACC_BOUND_AND_INVAL( mt_access_stack ) = abap_true.
  DELETE mt_access_stack INDEX 1.

ENDMETHOD.


  METHOD filter_out_unnecessary_keys.

    CHECK it_all_keys IS NOT INITIAL.

    " For certain library determinations, we do not need to set the context, thus we just return an empty key table
    DATA(lv_determination_class_name) = cl_abap_classdescr=>get_class_name(  io_det_class ).
    lv_determination_class_name = lv_determination_class_name+7. " +7 for skipping the letters '\CLASS='

    IF lv_determination_class_name = /bobf/if_conf_def_classes_c=>gc_cl_lib_dura_lock_clean
    OR lv_determination_class_name = /bobf/if_conf_def_classes_c=>gc_cl_lib_draft_admi.
      RETURN. " Return empty rt_key
    ENDIF.

    " For all other determinations, we check whether there are any newly-created keys without messages, and filter out those keys

    " Empty change objects: We cannot filter anything, so all keys are returned for setting the context
    IF io_change IS NOT BOUND.
      rt_key = it_all_keys.
      RETURN.
    ENDIF.

    " Get all keys for CREATE
    io_change->get_changes( EXPORTING iv_change_mode = /bobf/if_frw_c=>sc_modify_create
                                      iv_node_key    = iv_node_key
                            IMPORTING et_changed_key = DATA(lt_key_newly_created_instance) ).

    " No newly-created instances at all: Return all keys
    IF lt_key_newly_created_instance IS INITIAL.
      rt_key = it_all_keys.
      RETURN.
    ENDIF.

    " There are some newly-created instances. We will get all the messages and check whether there are any messages for those new instances
    io_message->get_messages( IMPORTING et_message = DATA(lt_message) ).

    DATA(lt_message_for_node) = VALUE /bobf/t_frw_message_k( FOR ls_message IN lt_message WHERE ( node_key = iv_node_key ) ( ls_message ) ).

    DATA(lt_key_newly_creatd_wo_message) = FILTER /bobf/t_frw_key( lt_key_newly_created_instance EXCEPT IN lt_message_for_node USING KEY key WHERE key = key ).

    rt_key = FILTER #( it_all_keys EXCEPT IN lt_key_newly_creatd_wo_message USING KEY key_sort WHERE key = key ).

  ENDMETHOD.


  METHOD get_cleanup_mode.
    rv_cleanup_mode = mv_cleanup_mode.
  ENDMETHOD.


 METHOD GET_CONTENT_DESCRIPTION.

   DATA: lo_conf_bopf          TYPE REF TO /BOBF/IF_FRW_SERVICE_LAYER,
         lo_message            TYPE REF TO /BOBF/IF_FRW_MESSAGE, "#EC NEEDED
         ls_key                TYPE /BOBF/S_FRW_KEY,
         lt_key                TYPE /BOBF/T_FRW_KEY,
         lt_act                TYPE /BOBF/T_CONF_ACT_LIST,
         ls_act                TYPE /BOBF/S_CONF_ACT_LIST,
         lt_assoc              TYPE /BOBF/T_CONF_ASSOC,
         ls_assoc              TYPE /BOBF/S_CONF_ASSOC,
         lt_det                TYPE /BOBF/T_CONF_DET_LIST,
         ls_det                TYPE /BOBF/S_CONF_DET_LIST,
         lt_val                TYPE /BOBF/T_CONF_VAL_LIST,
         ls_val                TYPE /BOBF/S_CONF_VAL_LIST,
         lt_query              TYPE /BOBF/T_CONF_QUERY,
         ls_query              TYPE /BOBF/S_CONF_QUERY,
         lt_node               TYPE /BOBF/T_CONF_NODE,
         ls_node               TYPE /BOBF/S_CONF_NODE,
         lt_vset               TYPE /BOBF/T_CONF_VALUE_SET,
         ls_vset               TYPE /BOBF/S_CONF_VALUE_SET,
         lt_bo                 TYPE /BOBF/T_CONF_BO,        "#EC NEEDED
         lt_obj                TYPE /BOBF/T_CONF_OBJ,       "#EC NEEDED
         lx_root               TYPE REF TO cx_root.


   TRY.
       lo_conf_bopf = /BOBF/CL_FRW_FACTORY=>GET_BOPF( iv_bo_key = /BOBF/IF_CONF_OBJ_C=>SC_BO_KEY ).
     CATCH cx_root INTO lx_root.                         "#EC CATCH_ALL
       set_application_error( lx_root ).
   ENDTRY.

*  first retrieve root node to trigger loading of configuration BO
   ls_key-key = mo_conf->ms_obj-bo_key.
   APPEND ls_key TO lt_key.

   lo_conf_bopf->retrieve(
     EXPORTING
       iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-ROOT
       it_key      = lt_key
     IMPORTING
       et_data     = lt_bo
       eo_message  = lo_message ).

   lo_conf_bopf->retrieve_by_association(
     EXPORTING
       iv_node_key    = /BOBF/IF_CONF_OBJ_C=>SC_NODE-ROOT
       it_key         = lt_key
       iv_association = /BOBF/IF_CONF_OBJ_C=>SC_ASSOCIATION-ROOT-TO_ACTIVE_VERSION
       iv_fill_data   = abap_true
     IMPORTING
       et_data        = lt_obj
       eo_message     = lo_message ).

   CLEAR lt_key.

   ls_key-key = iv_key.
   APPEND ls_key TO lt_key.

   IF iv_act = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-ACTION
         it_key      = lt_key
       IMPORTING
         et_data     = lt_act
         eo_message  = lo_message ).

     READ TABLE lt_act INTO ls_act INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_act-act_name.
     ENDIF.

   ELSEIF iv_assoc = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-ASSOCIATION
         it_key      = lt_key
       IMPORTING
         et_data     = lt_assoc
         eo_message  = lo_message ).

     READ TABLE lt_assoc INTO ls_assoc INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_assoc-assoc_name.
     ENDIF.

   ELSEIF iv_det = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-DETERMINATION
         it_key      = lt_key
       IMPORTING
         et_data     = lt_det
         eo_message  = lo_message ).

     READ TABLE lt_det INTO ls_det INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_det-det_name.
     ENDIF.

   ELSEIF iv_val = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-VALIDATION
         it_key      = lt_key
       IMPORTING
         et_data     = lt_val
         eo_message  = lo_message ).

     READ TABLE lt_val INTO ls_val INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_val-val_name.
     ENDIF.

   ELSEIF iv_query = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-QUERY
         it_key      = lt_key
       IMPORTING
         et_data     = lt_query
         eo_message  = lo_message ).

     READ TABLE lt_query INTO ls_query INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_query-query_name.
     ENDIF.

   ELSEIF iv_node = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-NODE
         it_key      = lt_key
       IMPORTING
         et_data     = lt_node
         eo_message  = lo_message ).

     READ TABLE lt_node INTO ls_node INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_node-node_name.
     ENDIF.

   ELSEIF iv_vset = abap_true.
     lo_conf_bopf->retrieve(
       EXPORTING
         iv_node_key = /BOBF/IF_CONF_OBJ_C=>SC_NODE-VALUE_SET
         it_key      = lt_key
       IMPORTING
         et_data     = lt_vset
         eo_message  = lo_message ).

     READ TABLE lt_vset INTO ls_vset INDEX 1.
     IF sy-subrc = 0.
       ev_content_description = ls_vset-vset_name.
     ENDIF.


   ENDIF.

 ENDMETHOD.


METHOD get_delegation.

  DATA: ls_delegation   TYPE /bobf/s_frw_delegation,
        lo_int_access   TYPE REF TO /bobf/cl_frw_int_access,
        lt_node         TYPE /bobf/t_confro_node.

  FIELD-SYMBOLS: <ls_node> TYPE /bobf/s_confro_node.

  READ TABLE mt_delegation
    WITH KEY node_key = iv_node_key
    INTO ls_delegation.

  IF sy-subrc = 0.
*   delegation class found
    eo_delegation = ls_delegation-delegation.
  ELSE.
*   get instance of delegation class
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( iv_node_key = iv_node_key ).
    ENDIF.

    CALL METHOD (mo_conf->ms_last_node-delegation_class)=>/bobf/if_frw_delegation~get_instance
      EXPORTING
        iv_host_bo_key = mo_conf->ms_obj-bo_key
        iv_node_key    = mo_conf->ms_last_node-delegation_root_node_key
        io_conf        = mo_conf
      IMPORTING
        eo_delegation  = eo_delegation.

    mo_conf->get_node_tab( IMPORTING et_node = lt_node ).
    ls_delegation-delegation = eo_delegation.
    LOOP AT lt_node ASSIGNING <ls_node>
      WHERE delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key. "#EC CI_SORTSEQ
      ls_delegation-node_key   = <ls_node>-node_key.
      INSERT ls_delegation INTO TABLE mt_delegation.
    ENDLOOP.
    APPEND eo_delegation TO mt_delegation2.

  ENDIF.

  IF eo_delegation IS NOT BOUND.
*   no delegatio class found
    set_application_error( ).
  ENDIF.

* check delegation read access class
  IF mo_delegation_read IS NOT BOUND.
    /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf            = me
        io_conf            = mo_conf
        io_buffer          = mo_buffer    " Interface to the Data Layer
      RECEIVING
        eo_internal_access = lo_int_access
    ).

    lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
    lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
    lo_int_access->set_context( iv_read_allowed = abap_true ).

    mo_delegation_read = lo_int_access.
  ENDIF.

ENDMETHOD.


  METHOD get_direct_access.
    IF mo_direct_access IS NOT BOUND.
      mo_direct_access = NEW /bobf/cl_frw_direct_access( io_conf = mo_conf  io_buffer = mo_buffer ).
    ENDIF.
    ro_direct_access = mo_direct_access.
  ENDMETHOD.


  METHOD get_enqueue_scope.
    rv_enqueue_scope = mv_enqueue_scope.
  ENDMETHOD.


 METHOD get_loadable_node.

   DATA: lt_start_node        TYPE /bobf/t_frw_node,
         lt_node              TYPE /bobf/t_frw_node,
         ls_node              TYPE /bobf/s_frw_node,
         ls_node2             TYPE /bobf/s_frw_node,
         lv_node              TYPE /bobf/obm_node_key,
         lt_target            TYPE /bobf/t_frw_key,
         lt_key               TYPE /bobf/t_frw_key,
         ls_key               TYPE /bobf/s_frw_key,
         ls_assoc_parent_node TYPE /bobf/s_confro_assoc,
         ls_nodeconf          TYPE /bobf/s_confro_node,
         ls_load_do           TYPE ts_load_do,
         lo_message           TYPE REF TO /bobf/if_frw_message,
         ls_node_link         TYPE /bobf/s_frw_node_key_link,
         lv_all_lockgroups    TYPE boole_d,
         lt_key_link          TYPE /bobf/t_frw_key_link,
         ls_key_link          TYPE /bobf/s_frw_key_link,
         lt_failed_node       TYPE /bobf/t_frw_node,
         lx_root              TYPE REF TO cx_root.

   FIELD-SYMBOLS: <ls_load_do>  TYPE ts_load_do.

   CLEAR: et_node,
          et_node_link,
          et_failed_node,
          eo_message.

*  ____________________________________________________________________ *
*  find next loadable node
   LOOP AT it_node INTO ls_node.
     ls_key-key = ls_node-key.
     APPEND ls_key TO lt_key.

     ls_node_link-source_node = ls_node-node.
     ls_node_link-source_key  = ls_node-key.
     ls_node_link-target_node = ls_node-node.
     ls_node_link-target_key  = ls_node-key.
     INSERT ls_node_link INTO TABLE et_node_link.

     AT END OF node.
       lv_node = ls_node-node.
       DO.
*        jump up the tree until a loadable node is found
         IF mo_conf->ms_last_node-node_key = lv_node.
           ls_nodeconf = mo_conf->ms_last_node.
         ELSE.
           mo_conf->get_node(
             EXPORTING iv_node_key = lv_node
             IMPORTING es_node     = ls_nodeconf ).
           IF ls_nodeconf IS INITIAL.
             ASSERT ID /bobf/frw CONDITION 0 = 1.          "#EC BOOL_OK
             RETURN.
           ENDIF.
         ENDIF.

         IF ls_nodeconf-loadable = abap_true.
*          found the node -> leave the loop
           map_to_node(
             EXPORTING
               iv_node_key = lv_node
               it_key      = lt_key
             IMPORTING
               et_node     = lt_node ).
           INSERT LINES OF lt_node INTO TABLE et_node.
           EXIT.

         ELSEIF ls_nodeconf-key_inherited = abap_true.
*          node has same NodeID as parent node
           IF et_node_link IS REQUESTED.
             LOOP AT et_node_link INTO ls_node_link
               WHERE target_node = lv_node.
               DELETE et_node_link.
               ls_node_link-target_node = ls_nodeconf-parent_node_key.
               INSERT ls_node_link INTO TABLE et_node_link.
             ENDLOOP.
           ENDIF.
           lv_node = ls_nodeconf-parent_node_key.

         ELSEIF ls_nodeconf-delegation_class IS NOT INITIAL.
*          node is delegated
           READ TABLE ct_load_do ASSIGNING <ls_load_do>
             WITH KEY delegation_root_node_key = ls_nodeconf-delegation_root_node_key.
           IF sy-subrc <> 0.
             ls_load_do-delegation_root_node_key = ls_nodeconf-delegation_root_node_key.
             CLEAR ls_load_do-node.
             INSERT ls_load_do INTO TABLE ct_load_do ASSIGNING <ls_load_do>.
           ENDIF.
           INSERT LINES OF lt_node INTO TABLE <ls_load_do>-node.
           EXIT.

         ELSE.
*          get parent NodeIDs
           mo_conf->get_assoc(
             EXPORTING
               iv_node_key  = lv_node
               iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
             IMPORTING
               es_assoc     = ls_assoc_parent_node ).

           IF ls_assoc_parent_node IS NOT INITIAL.
*            jump to the parent node (check buffer first)
             IF ls_assoc_parent_node-source_node->transient                = abap_false AND
                 ls_assoc_parent_node-source_node->optimized_buffer_access = abap_false.
               do_loading(
                  EXPORTING
                    iv_node_key       = lv_node
                    it_key            = lt_key
                    iv_check_buf      = abap_true
                    iv_reload         = abap_false
                    iv_load_data      = abap_false
                    iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
                    io_change         = io_change
                  IMPORTING
                    eo_message        = lo_message
                    et_failed         = lt_failed_node ).

               collect_messages( EXPORTING io_message = lo_message
                                 CHANGING  co_message = eo_message ).

               LOOP AT lt_failed_node INTO ls_node.
                 DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
                 INSERT ls_node INTO TABLE et_failed_node.
               ENDLOOP.

             ENDIF.

             IF lt_key IS NOT INITIAL.
               TRY.
                   mo_buffer->retrieve_by_association(
                     EXPORTING
                       iv_association     = ls_assoc_parent_node-assoc_key
                       iv_node_key        = lv_node
                       it_key             = lt_key
                       iv_state           = /bobf/if_conf_c=>sc_state_current
                       io_change          = io_change
                       iv_fill_failed_key = abap_false
                     IMPORTING
                       et_target_key      = lt_target
                       et_key_link        = lt_key_link ).
                 CATCH cx_root INTO lx_root.             "#EC CATCH_ALL
                   set_application_error( lx_root ).
               ENDTRY.

               ASSERT ID /bobf/frw_error CONDITION
                  /bobf/cl_tool_assert=>is_key_link_matching(
                      it_key_link   = lt_key_link
                      it_key        = lt_key
                      it_target_key = lt_target ) = abap_true.
             ENDIF.

             IF lt_target IS INITIAL.
*              no parent node found -> no keys can be loaded
               LOOP AT lt_node INTO ls_node2.
                 READ TABLE et_node_link INTO ls_node_link WITH KEY
                    target_node = ls_node2-node
                    target_key  = ls_node2-key.
                 ls_node2-node = ls_node_link-source_node.
                 ls_node2-key  = ls_node_link-source_key.
                 INSERT ls_node2 INTO TABLE et_failed_node.
               ENDLOOP.
               EXIT.
             ENDIF.

             LOOP AT lt_key_link INTO ls_key_link.
               LOOP AT et_node_link INTO ls_node_link WHERE
                   target_node = lv_node AND
                   target_key  = ls_key_link-source_key.
                 DELETE et_node_link.
                 ls_node_link-target_node = ls_assoc_parent_node-target_node_key.
                 ls_node_link-target_key = ls_key_link-target_key.
                 INSERT ls_node_link INTO TABLE et_node_link.
               ENDLOOP.
             ENDLOOP.

             lv_node = ls_assoc_parent_node-target_node_key.
             lt_key  = lt_target.
           ELSE.
*            no assoc to parent found
             set_application_error( ).
           ENDIF.
         ENDIF.
       ENDDO.
       CLEAR lt_key.
     ENDAT.

   ENDLOOP.
   DELETE ADJACENT DUPLICATES FROM et_node.

*  ____________________________________________________________________ *
*  find next all loadable subnodes of et_node
   IF iv_load_subtree  <> /bobf/if_frw_c=>sc_load_no_subtree.
*     IF iv_load_subtree = /bobf/if_frw_c=>sc_load_whole_subtree.
     lv_all_lockgroups = abap_true.
*     ENDIF.
     lt_start_node = et_node.
     CLEAR lt_key.
     LOOP AT lt_start_node INTO ls_node.
       ls_key-key = ls_node-key.
       APPEND ls_key TO lt_key.

       AT END OF node.
         get_loadable_subnode(
           EXPORTING
             iv_node_key       = ls_node-node
             it_key            = lt_key
             iv_all_lockgroups = lv_all_lockgroups
           IMPORTING
             et_node           = lt_node
             eo_message        = lo_message
           CHANGING
             ct_load_do        = ct_load_do ).

         collect_messages( EXPORTING io_message = lo_message
                           CHANGING  co_message = eo_message ).

         INSERT LINES OF lt_node INTO TABLE et_node.
         CLEAR lt_key.

       ENDAT.
     ENDLOOP.
     DELETE ADJACENT DUPLICATES FROM et_node.
   ENDIF.

 ENDMETHOD.


 METHOD get_loadable_subnode.

*  recursive method to find all loadable subnodes

   DATA: lt_new_key TYPE /bobf/t_frw_key,
         lt_node    TYPE /bobf/t_frw_node,
         ls_node    TYPE /bobf/s_frw_node,
         ls_key     TYPE /bobf/s_frw_key,
         lt_assoc2  TYPE /bobf/t_confro_assoc2,
         ls_assoc2  TYPE /bobf/s_confro_assoc2,
         ls_load_do TYPE ts_load_do,
         lo_message TYPE REF TO /bobf/if_frw_message.

   FIELD-SYMBOLS: <ls_load_do>  TYPE ts_load_do.

   CLEAR:
     eo_message,
     et_node.

*  am I loadable? -> mark nodes as "to load"
   IF mo_conf->ms_last_node-node_key <> iv_node_key.
     mo_conf->get_node( iv_node_key = iv_node_key ).
   ENDIF.

   IF iv_all_lockgroups = abap_false.
*    stop if loadable group equals lockable group
     CHECK mo_conf->ms_last_node-loadgroup_eq_lockgroup = abap_false.

*    stop at lockable node
     IF mo_conf->ms_last_node-lockable = abap_true AND
        iv_recursive_call              = abap_true.
       RETURN.
     ENDIF.
   ENDIF.

*  stop at delegated node
   IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
     READ TABLE ct_load_do ASSIGNING <ls_load_do>
       WITH KEY delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
     IF sy-subrc <> 0.
       ls_load_do-delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
       CLEAR ls_load_do-node.
       INSERT ls_load_do INTO TABLE ct_load_do ASSIGNING <ls_load_do>.
     ENDIF.

     ls_node-node = iv_node_key.
     LOOP AT it_key INTO ls_key.
       ls_node-key = ls_key-key.
       INSERT ls_node INTO TABLE <ls_load_do>-node.
     ENDLOOP.
     RETURN.
   ENDIF.

   IF mo_conf->ms_last_node-loadable = abap_true.
     map_to_node(
       EXPORTING
         iv_node_key = iv_node_key
         it_key      = it_key
       IMPORTING
         et_node     = et_node ).
   ENDIF.

*  stop if no loadable subnodes exist
   IF mo_conf->ms_last_node-loadable_subnodes = abap_false.
     RETURN.
   ENDIF.

*  find all compositions
   mo_conf->get_assoc_tab( IMPORTING et_comp = lt_assoc2 ).
   LOOP AT lt_assoc2 INTO ls_assoc2 WHERE
       source_node_key = iv_node_key
*      these framework nodes are not loadable by definition
       AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_lock
       AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_property
       AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_message
*      AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_object
       AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_status
       AND target_node->node_type <> /bobf/if_conf_c=>sc_node_type_qrtn
       AND target_node->transient = abap_false.

*    check for delegated nodes if it was touched already
*    (currently the only use case for loading delegation nodes is a cache invalidation)
     IF ls_assoc2-assoc_cat = /bobf/if_conf_c=>sc_assoccat_object.
       READ TABLE mt_delegation WITH KEY node_key = ls_assoc2-target_node_key TRANSPORTING NO FIELDS.
       IF sy-subrc <> 0.
         CONTINUE.
       ENDIF.
     ENDIF.

*    find keys of target nodes
     retrieve_by_association(
       EXPORTING
         iv_node_key    = iv_node_key
         it_key         = it_key
         iv_association = ls_assoc2-assoc_key
         iv_state       = /bobf/if_conf_c=>sc_state_current
         iv_buffer_only = abap_true
       IMPORTING
         et_target_key  = lt_new_key
         eo_message     = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

*    call me recursively
     IF lt_new_key IS NOT INITIAL.
       get_loadable_subnode(
         EXPORTING
           iv_node_key       = ls_assoc2-target_node_key
           it_key            = lt_new_key
           iv_recursive_call = abap_true
           iv_all_lockgroups = iv_all_lockgroups
         IMPORTING
           et_node           = lt_node
           eo_message        = lo_message
         CHANGING
           ct_load_do        = ct_load_do ).

       INSERT LINES OF lt_node INTO TABLE et_node.
       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).
     ENDIF.
   ENDLOOP.

 ENDMETHOD.


 METHOD get_lockable_node.

   DATA: lt_node              TYPE          /bobf/t_frw_node,
         lt_failed_node       TYPE          /bobf/t_frw_node,
         ls_node              TYPE          /bobf/s_frw_node,
         ls_node_result       TYPE          /bobf/s_frw_node,
         lv_node              TYPE          /bobf/obm_node_key,
         lt_target            TYPE          /bobf/t_frw_key,
         lt_key               TYPE          /bobf/t_frw_key,
         lt_key_root          TYPE          /bobf/t_frw_key,
         lt_failed_key        TYPE          /bobf/t_frw_key,
         ls_key               TYPE          /bobf/s_frw_key,
         ls_assoc_parent_node TYPE          /bobf/s_confro_assoc,
         ls_nodeconf          TYPE          /bobf/s_confro_node,
         lo_change            TYPE REF TO   /bobf/if_frw_change,
         lo_delegation        TYPE REF TO   /bobf/if_frw_delegation,
         lo_message           TYPE REF TO   /bobf/if_frw_message,
         lt_node_link         TYPE TABLE OF /bobf/s_frw_node_key_link,
         ls_node_link         TYPE          /bobf/s_frw_node_key_link,
         lt_key_link          TYPE          /bobf/t_frw_key_link,
         ls_key_link          TYPE          /bobf/s_frw_key_link,
         lt_loaded_node       TYPE          /bobf/t_frw_node,
         lx_root              TYPE REF TO   cx_root.

   CLEAR:
       et_node,
       et_node_link,
       et_failed_node,
       et_loaded_node,
       eo_message.

*  ___________________________________________________________________________ *
*  if there is only one locking group defined in the whole BO (defined on ROOT node)
   IF mo_conf->ms_obj-lock_only_root = abap_true.
     LOOP AT it_node INTO ls_node.
       ls_key-key = ls_node-key.
       APPEND ls_key TO lt_key.
       AT END OF node.
         IF ls_node-node = mo_conf->ms_obj-root_node_key.
*          I'm already the root node
           LOOP AT lt_key INTO ls_key.
             ls_node_result-node     = ls_node-node.
             ls_node_result-key      = ls_key-key.
             INSERT ls_node_result INTO TABLE et_node.
             ls_node_link-source_node = ls_node-node.
             ls_node_link-source_key  = ls_key-key.
             ls_node_link-target_node = mo_conf->ms_obj-root_node_key.
             ls_node_link-target_key  = ls_key-key.
             INSERT ls_node_link INTO TABLE et_node_link.
           ENDLOOP.
         ELSE.
*          I'm a subnode
           get_root_key(
             EXPORTING
               iv_node_key    = ls_node-node
               it_key         = lt_key
             IMPORTING
               et_loaded_node = et_loaded_node
               et_failed_key  = lt_failed_key
               et_target_key  = lt_key_root
               et_key_link    = lt_key_link ).
           DATA lt_key_root_before TYPE /bobf/t_frw_key.
           DATA lt_key_root_link_before TYPE /bobf/t_frw_key_link.
           DATA lt_loaded_node_before TYPE /bobf/t_frw_node.

           IF lt_failed_key IS NOT INITIAL.
             " try again with before image
             lt_key = lt_failed_key.
             get_root_key(
              EXPORTING
                iv_node_key     = ls_node-node
                it_key          = lt_key
                iv_before_image = abap_true
              IMPORTING
                et_loaded_node = lt_loaded_node_before
                et_failed_key  = lt_failed_key
                et_target_key  = lt_key_root_before
                et_key_link    = lt_key_root_link_before ).
             INSERT LINES OF lt_loaded_node_before INTO TABLE et_loaded_node.
             INSERT LINES OF lt_key_root_before INTO TABLE lt_key_root.
             INSERT LINES OF lt_key_root_link_before INTO TABLE lt_key_link.
           ENDIF.

           ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_key_link_matching(
                  it_key        = lt_key
                  it_key_link   = lt_key_link
                  it_target_key = lt_key_root ) = abap_true.

           LOOP AT lt_failed_key INTO ls_key.
             ls_node-key = ls_key-key.
             INSERT ls_node INTO TABLE et_failed_node.
           ENDLOOP.
           LOOP AT lt_key_link INTO ls_key_link.
             ls_node_link-source_node = ls_node-node.
             ls_node_link-source_key  = ls_key_link-source_key.
             ls_node_link-target_node = mo_conf->ms_obj-root_node_key.
             ls_node_link-target_key  = ls_key_link-target_key.
             INSERT ls_node_link INTO TABLE et_node_link.
           ENDLOOP.
           LOOP AT lt_key_root INTO ls_key.
             ls_node_result-node = mo_conf->ms_obj-root_node_key.
             ls_node_result-key  = ls_key-key.
             INSERT ls_node_result INTO TABLE et_node.
           ENDLOOP.
         ENDIF.
         CLEAR lt_key.
       ENDAT.
     ENDLOOP.

     DELETE ADJACENT DUPLICATES FROM et_node.
     " quit !
     RETURN.
   ENDIF.

*  ___________________________________________________________________________ *
*  if there are more than one locking group in the BO defined
   IF io_change IS BOUND.
     lo_change = io_change.
   ELSE.
     CREATE OBJECT lo_change TYPE /bobf/cl_frw_change.
   ENDIF.

   " loop at each node instance, for which the corresponding instance of its locking node shall be retrieved
   LOOP AT it_node INTO ls_node.

     " built LT_KEY which will be IT_KEY in the upcoming RBA TO_PARENT
     ls_key-key = ls_node-key.
     APPEND ls_key TO lt_key.

     " ET_NODE_LINK is filled from start and will be updated in each iteration with the result of the TO_PARENT RBA
     ls_node_link-source_node = ls_node-node.
     ls_node_link-source_key  = ls_node-key.
     ls_node_link-target_node = ls_node-node.
     ls_node_link-target_key  = ls_node-key.
     INSERT ls_node_link INTO TABLE et_node_link.

     AT END OF node.

       " all instances of a ceratain node are now packaged
       lv_node = ls_node-node.

       " loop TO_PARENT until we reach the common locking node for those instances
       DO.
         " get configuration of current node
         IF mo_conf->ms_last_node-node_key = lv_node.
           ls_nodeconf = mo_conf->ms_last_node.
         ELSE.
           mo_conf->get_node(
              EXPORTING iv_node_key = lv_node
              IMPORTING es_node     = ls_nodeconf ).
           IF ls_nodeconf IS INITIAL.
             ASSERT ID /bobf/frw CONDITION 0 = 1.          "#EC BOOL_OK
             RETURN.
           ENDIF.
         ENDIF.

         " if we reached the locking node, quit
         IF ls_nodeconf-lockable = abap_true.

           " update the et_node
           map_to_node(
             EXPORTING
               iv_node_key = lv_node
               it_key      = lt_key
             IMPORTING
               et_node     = lt_node ).
           INSERT LINES OF lt_node INTO TABLE et_node.
           EXIT.

         ELSEIF ls_nodeconf-key_inherited = abap_true.
           " if the current node uses the same keys than its subnode,
           " we do not need to execute the RBA TO_PARENT - we can take directly take over that keys

           " update the et_node_link result table
           IF et_node_link IS REQUESTED.
             LOOP AT et_node_link INTO ls_node_link
               WHERE target_node = lv_node.
               DELETE et_node_link.
               ls_node_link-target_node = ls_nodeconf-parent_node_key.
               APPEND ls_node_link TO lt_node_link.
             ENDLOOP.
             INSERT LINES OF lt_node_link INTO TABLE et_node_link.
             CLEAR lt_node_link.
           ENDIF.
           lv_node = ls_nodeconf-parent_node_key.

         ELSEIF ls_nodeconf-delegation_class IS NOT INITIAL.
           " we reached a delegation node - consult the delegation class
           TRY.
               lo_delegation = get_delegation( lv_node ).
               DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
               lo_delegation->get_host_node_key(
                 EXPORTING
                   iv_node_key         = lv_node
                   it_key              = lt_key
                   iv_state            = /bobf/if_conf_c=>sc_state_current
                   io_read             = mo_delegation_read
                 IMPORTING
                   et_failed_key       = lt_failed_key
                   et_key_link         = lt_key_link
                   et_target_key       = lt_target
                   ev_host_node_key    = ls_assoc_parent_node-target_node_key ).
               /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
             CATCH cx_root INTO lx_root.                 "#EC CATCH_ALL
               set_application_error( lx_root ).
           ENDTRY.

           ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_link_matching(
                it_key_link   = lt_key_link
                it_key        = lt_key
                it_target_key = lt_target ) = abap_true.

           " update et_node_link
           IF lt_target IS INITIAL.
             " no parent node found -> no keys ca be loaded -> virtually not possible
             DELETE et_node_link USING KEY source_node WHERE source_node = ls_node-node.
             EXIT.
           ENDIF.
           IF et_node_link IS REQUESTED.
             LOOP AT lt_key_link INTO ls_key_link.
               LOOP AT et_node_link INTO ls_node_link
                 WHERE target_node = lv_node
                   AND target_key  = ls_key_link-source_key.
                 DELETE et_node_link.
                 ls_node_link-target_node = ls_assoc_parent_node-target_node_key.
                 ls_node_link-target_key  = ls_key_link-target_key.
                 APPEND ls_node_link TO lt_node_link.
               ENDLOOP.
             ENDLOOP.
             INSERT LINES OF lt_node_link INTO TABLE et_node_link.
             CLEAR lt_node_link.
           ENDIF.

           " prepare lv_node and lt_key for the next iteration
           lv_node = ls_assoc_parent_node-target_node_key.
           lt_key  = lt_target.

         ELSEIF ls_nodeconf-parent_node_key IS INITIAL.
           " exit as ROOT node is reached (only node without parent node)
           " this will always finally be reached
           CLEAR lt_key.
           EXIT.

         ELSE.

           " common case: current node is not lockable, thus execute TO_PARENT association

           " get TO_PARENT association configuration
           mo_conf->get_assoc(
             EXPORTING
               iv_node_key  = lv_node
               iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
             IMPORTING
               es_assoc     = ls_assoc_parent_node ).

           IF ls_assoc_parent_node IS NOT INITIAL.

             IF ls_assoc_parent_node-source_node->optimized_buffer_access = abap_false.
               " non-optimized buffer access

               " load the source keys and fill them into et_loaded_node (this is also an existence check)
               do_loading(
                  EXPORTING
                    iv_node_key     = lv_node
                    it_key          = lt_key
                    iv_check_buf    = abap_true
                    iv_reload       = abap_false
                    iv_load_data    = abap_false
                    iv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree
                    io_change       = lo_change
                  IMPORTING
                    et_loaded_node  = lt_loaded_node
                    et_failed       = lt_failed_node
                    eo_message      = lo_message ).
               collect_messages( EXPORTING io_message = lo_message
                                 CHANGING  co_message = eo_message ).

               " append loaded nodes to et_loaded_node
               IF lt_loaded_node  IS NOT INITIAL AND
                   et_loaded_node IS REQUESTED.
                 IF et_loaded_node IS NOT INITIAL.
                   INSERT LINES OF lt_loaded_node INTO TABLE et_loaded_node.
                 ELSE.
                   et_loaded_node = lt_loaded_node.
                 ENDIF.
               ENDIF.

               " remove the failed instance keys from lt_key (so they are excluded in the next iteration)
               LOOP AT lt_failed_node INTO ls_node.
                 DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
               ENDLOOP.

               TRY.
                   " navigate TO_PARENT: try also database and before image,
                   " if the parent node was deleted in the current transaction

                   " put result into LT_TARGET, LT_FAILED_KEY, LT_KEY_LINK
                   DATA lt_key_tmp TYPE /bobf/t_frw_key.
                   DATA lt_target_tmp TYPE /bobf/t_frw_key.
                   DATA lt_key_link_tmp TYPE /bobf/t_frw_key_link.
                   DATA lv_state TYPE /bobf/conf_state.

                   lt_key_tmp = lt_key.
                   CLEAR: lt_target, lt_key_link.

                   DO 3 TIMES.
                     CLEAR: lt_target_tmp, lt_key_link_tmp.
                     CASE sy-index.
                       WHEN 1.
                         lv_state = /bobf/if_conf_c=>sc_state_current.
                       WHEN 2.
                         lv_state = /bobf/if_conf_c=>sc_state_database.
                       WHEN 3.
                         lv_state = /bobf/if_conf_c=>sc_state_before_modification.
                     ENDCASE.
                     mo_buffer->retrieve_by_association(
                        EXPORTING
                          iv_association     = ls_assoc_parent_node-assoc_key
                          iv_node_key        = lv_node
                          it_key             = lt_key_tmp
                          iv_state           = lv_state
                          iv_fill_failed_key = abap_true
                          iv_buffer_only     = abap_true
                        IMPORTING
                          et_failed_key      = lt_failed_key
                          et_target_key      = lt_target_tmp
                          et_key_link        = lt_key_link_tmp ).
                     INSERT LINES OF lt_target_tmp   INTO TABLE lt_target.
                     INSERT LINES OF lt_key_link_tmp INTO TABLE lt_key_link.
                     IF lt_failed_key IS INITIAL.
                       EXIT. " all instances found
                     ELSE.
                       lt_key_tmp = lt_failed_key.
                     ENDIF.
                   ENDDO.


                 CATCH cx_root INTO lx_root.             "#EC CATCH_ALL
                   set_application_error( lx_root ).
               ENDTRY.

             ELSE.
               " optimized buffer access
               TRY.

                   " navigate TO_PARENT: try also database and before image,
                   " if the parent node was deleted in the current transaction

                   " put result into LT_TARGET, LT_FAILED_KEY, LT_KEY_LINK
                   lt_key_tmp = lt_key.
                   CLEAR: lt_target, lt_key_link.

                   DO 3 TIMES.
                     CLEAR: lt_target_tmp, lt_key_link_tmp.

                     CASE sy-index.
                       WHEN 1.
                         lv_state = /bobf/if_conf_c=>sc_state_current.
                       WHEN 2.
                         lv_state = /bobf/if_conf_c=>sc_state_database.
                       WHEN 3.
                         lv_state = /bobf/if_conf_c=>sc_state_before_modification.
                     ENDCASE.

                     mo_buffer->retrieve_by_association(
                       EXPORTING
                         iv_association     = ls_assoc_parent_node-assoc_key
                         iv_node_key        = lv_node
                         it_key             = lt_key_tmp
                         iv_state           = lv_state
                         io_change          = lo_change
                         iv_fill_failed_key = abap_true
                         iv_buffer_only     = abap_false
                       IMPORTING
                         et_failed_key      = lt_failed_key
                         et_target_key      = lt_target_tmp
                         et_key_link        = lt_key_link_tmp ).

                     INSERT LINES OF lt_target_tmp   INTO TABLE lt_target.
                     INSERT LINES OF lt_key_link_tmp INTO TABLE lt_key_link.
                     IF lt_failed_key IS INITIAL.
                       EXIT. " all instances found
                     ELSE.
                       lt_key_tmp = lt_failed_key.
                     ENDIF.
                   ENDDO.


                 CATCH cx_root INTO lx_root.             "#EC CATCH_ALL
                   set_application_error( lx_root ).
               ENDTRY.
             ENDIF.

             ASSERT ID /bobf/frw_error CONDITION
                /bobf/cl_tool_assert=>is_key_link_matching(
                    it_key_link   = lt_key_link
                    it_key        = lt_key
                    it_target_key = lt_target ) = abap_true.

             " add failed nodes to ET_FAILED_NODE, remove failed instance from ET_NODE_LINK
             LOOP AT lt_failed_node INTO ls_node.
               LOOP AT et_node_link INTO ls_node_link
                 WHERE target_node = lv_node
                   AND target_key  = ls_node-key.
                 DELETE et_node_link.
                 ls_node-node = ls_node_link-source_node.
                 ls_node-key  = ls_node_link-source_key.
                 INSERT ls_node INTO TABLE et_failed_node.
               ENDLOOP.
             ENDLOOP.
             LOOP AT lt_failed_key INTO ls_key.
               LOOP AT et_node_link INTO ls_node_link
                 WHERE target_node = lv_node
                   AND target_key  = ls_key-key.
                 DELETE et_node_link.
                 ls_node-node = ls_node_link-source_node.
                 ls_node-key  = ls_node_link-source_key.
                 INSERT ls_node INTO TABLE et_failed_node.
               ENDLOOP.
             ENDLOOP.

             " update the link information in ET_KEY_LINK by the help of the current RBA result
             LOOP AT lt_key_link INTO ls_key_link.
               LOOP AT et_node_link INTO ls_node_link
                 WHERE target_node = lv_node
                   AND target_key  = ls_key_link-source_key.
                 DELETE et_node_link.
                 ls_node_link-target_node = ls_assoc_parent_node-target_node_key.
                 ls_node_link-target_key  = ls_key_link-target_key.
                 APPEND ls_node_link TO lt_node_link.
               ENDLOOP.
             ENDLOOP.
             INSERT LINES OF lt_node_link INTO TABLE et_node_link.
             CLEAR lt_node_link.
             IF lt_target IS INITIAL.
               " no parent node found -> no keys ca be loaded -> virtually not possible
               DELETE et_node_link USING KEY source_node WHERE source_node = ls_node-node.
               EXIT.
             ENDIF.

             " set the node and keys for the RBA for the next iteration
             lv_node = ls_assoc_parent_node-target_node_key.
             lt_key  = lt_target.
           ELSE.
             " no association to parent node found
             set_application_error( ).
           ENDIF.
         ENDIF.
       ENDDO.
       CLEAR lt_key.
     ENDAT.

   ENDLOOP.

   after_loading(
     EXPORTING
       io_change      = lo_change
       iv_load_state  = /bobf/if_conf_c=>sc_state_current
     IMPORTING
       et_loaded_node = et_loaded_node
       eo_message     = lo_message ).

   collect_messages( EXPORTING io_message = lo_message
                     CHANGING  co_message = eo_message ).
   DELETE ADJACENT DUPLICATES FROM et_node.

 ENDMETHOD.


METHOD get_node_cat.

  DATA: lt_nodecat    TYPE /bobf/t_frw_node_cat,
        lt_failed_key TYPE /bobf/t_frw_key,
        lt_key        TYPE /bobf/t_frw_key,
        lo_message    TYPE REF TO /bobf/if_frw_message.

  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

  CLEAR:
    et_nodecat,
    et_failed_key,
    eo_message.

  IF iv_node_key = mv_nodecat_node_key AND
     it_key      = mt_nodecat_key.
    et_nodecat = mt_nodecat.
    RETURN.
  ENDIF.
  mv_nodecat_node_key = iv_node_key.
  mt_nodecat_key      = it_key.

*  check current state at first
  retrieve(
    EXPORTING
      iv_node_key    = iv_node_key
      it_key         = it_key
      iv_state       = iv_current_state
      iv_fill_data   = abap_false
    IMPORTING
      et_node_cat    = et_nodecat
      et_failed_key  = lt_failed_key
      eo_message     = lo_message ).

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = it_key
          it_key_subset = lt_failed_key ) = abap_true.

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

  mt_nodecat = et_nodecat.
  CHECK lt_failed_key IS NOT INITIAL.
  lt_key = lt_failed_key.

*  check last state
  CHECK iv_last_state <> iv_current_state.
  retrieve(
    EXPORTING
      iv_node_key    = iv_node_key
      it_key         = lt_key
      iv_state       = iv_last_state
      iv_fill_data   = abap_false
    IMPORTING
      et_node_cat   = lt_nodecat
      et_failed_key = lt_failed_key
      eo_message     = lo_message ).

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = lt_key
          it_key_subset = lt_failed_key ) = abap_true.

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).
  INSERT LINES OF lt_nodecat INTO TABLE et_nodecat.
  mt_nodecat = et_nodecat.
  CHECK lt_failed_key IS NOT INITIAL.
  lt_key = lt_failed_key.

*  check database state
  CHECK iv_last_state <> /bobf/if_conf_c=>sc_state_database.
  retrieve(
    EXPORTING
      iv_node_key    = iv_node_key
      it_key         = lt_key
      iv_state       = /bobf/if_conf_c=>sc_state_database
      iv_fill_data   = abap_false
    IMPORTING
      et_node_cat    = lt_nodecat
      et_failed_key  = et_failed_key
      eo_message     = lo_message ).

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = lt_key
          it_key_subset = et_failed_key ) = abap_true.

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).
  INSERT LINES OF lt_nodecat INTO TABLE et_nodecat.
  mt_nodecat = et_nodecat.

ENDMETHOD.


METHOD get_relevant_groups.

  DATA: lt_groupconf         TYPE /bobf/t_confro_group,
        ls_groupconf         TYPE /bobf/s_confro_group,
        ls_assocconf         TYPE /bobf/s_confro_assoc,
        ls_nodeconf          TYPE /bobf/s_confro_node,
        lt_val_list          TYPE /bobf/t_confro_val_list,
        ls_val_list          TYPE /bobf/s_confro_val_list,
        ls_val_trigger       TYPE /bobf/s_confro_val_trigger,
        lt_group             TYPE /bobf/t_frw_group,
        ls_group             TYPE /bobf/s_frw_group,

        ls_change_mode       TYPE /bobf/s_confro_chg_mode,
        ls_change_mode_group TYPE /bobf/s_confro_chg_mode,
        lt_key               TYPE /bobf/t_frw_key,
        lt_key_parent        TYPE /bobf/t_frw_key,
        lt_key_parent2       TYPE /bobf/t_frw_key,
        lt_failed_key        TYPE /bobf/t_frw_key,
        lt_target_key        TYPE /bobf/t_frw_key,
        lt_trigger_key       TYPE /bobf/t_frw_key,
        ls_key               TYPE /bobf/s_frw_key,
        ls_val_key           TYPE /bobf/s_frw_key,
        lv_state_before_used TYPE boole_d,
        lv_node_key          TYPE /bobf/obm_node_key,
        lv_group_node_key    TYPE /bobf/obm_node_key,
        lo_change            TYPE REF TO /bobf/cl_frw_change,
        lo_message           TYPE REF TO /bobf/if_frw_message.


  CLEAR: et_group_2_way,
         et_group_3_way,
         et_group_no_status,
         et_validations.

  CLEAR eo_message.

  CHECK io_change IS BOUND.
  lo_change ?= io_change.
  mo_conf->get_group_tab( IMPORTING et_group = lt_groupconf ).
  ls_change_mode_group-check  = abap_true.
  ls_change_mode_group-create = abap_true.

  LOOP AT lt_groupconf INTO ls_groupconf
    WHERE group_cat = /bobf/if_conf_c=>sc_group_cat_consistency.
    CLEAR: ls_change_mode, lt_group, ls_group.
    ls_group-group_key = ls_groupconf-group_key.

*   filter groups on status nodes
    IF ls_groupconf-node_key IS NOT INITIAL AND
       ( iv_processing_mode EQ /bobf/if_frw_c=>sc_mode_finalize         OR
         iv_processing_mode EQ /bobf/if_frw_c=>sc_mode_modify           OR
         iv_processing_mode EQ /bobf/if_frw_c=>sc_mode_check_before_save ).
      mo_conf->get_node(
        EXPORTING
          iv_node_key  = ls_groupconf-node_key
        IMPORTING
          es_node      = ls_nodeconf ).
      IF ls_nodeconf           IS NOT INITIAL                      AND
         ls_nodeconf-node_type EQ /bobf/if_conf_c=>sc_node_type_status.
*       skip this for status nodes!
        CONTINUE.
      ENDIF.
    ENDIF.

*   filter groups and set default status values
    CASE iv_processing_mode.
      WHEN /bobf/if_frw_c=>sc_mode_check_and_determine.
*       all groups
        ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.

      WHEN /bobf/if_frw_c=>sc_mode_finalize.
*       only 2-way + 3-way only pending
        CHECK ls_groupconf-sta_var IS BOUND AND (
              ls_groupconf-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary OR
              ls_groupconf-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_ternary ).
        ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.

      WHEN /bobf/if_frw_c=>sc_mode_modify.
*       only 2-way immediately + 3-way to pending
        CHECK ls_groupconf-sta_var IS BOUND AND (
              ls_groupconf-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary AND
              ls_groupconf-check_immediate      = abap_true OR
              ls_groupconf-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_ternary ).
        IF ls_groupconf-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary.
          ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.
        ELSE.
          ls_group-status_value = /bobf/if_frw_c=>sc_status_pending.
        ENDIF.

      WHEN /bobf/if_frw_c=>sc_mode_check_before_save.
*       only groups without any status
        CHECK ls_groupconf-sta_var_key IS INITIAL.
        ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.

    ENDCASE.

*   determine the node the group belongs to
    IF ls_groupconf-node_key IS NOT INITIAL.
      lv_group_node_key = ls_groupconf-node_key.
    ELSE.
      lv_group_node_key = mo_conf->ms_obj-root_node_key.
    ENDIF.

*   add groups nodes itself (create scenario)
    get_validation_trigger( EXPORTING iv_processing_mode = iv_processing_mode
                                      is_change_mode     = ls_change_mode_group
                                      iv_node_key        = lv_group_node_key
                                      io_change          = lo_change
                                      iv_state_current   = iv_state_current
                                      iv_state_before    = iv_state_before
                            IMPORTING et_key             = lt_key ).

    LOOP AT lt_key INTO ls_key.
      ls_group-key = ls_key-key.
      INSERT ls_group INTO TABLE lt_group.
    ENDLOOP.

*   loop at all validations assigned to this group first and then to all trigger nodes of that validations
*   if the trigger fits navigate to the validation node and then to the group node
    IF lt_val_list IS INITIAL.
      mo_conf->get_validation( IMPORTING et_val_list = lt_val_list ).
      SORT lt_val_list.
    ENDIF.

    LOOP AT ls_groupconf-val_keys->* INTO ls_val_key.
      READ TABLE lt_val_list INTO ls_val_list BINARY SEARCH
        WITH KEY val_key = ls_val_key-key.
      CHECK sy-subrc = 0.

      CLEAR lt_key.
      LOOP AT ls_val_list-val_trigger->* INTO ls_val_trigger.
        CLEAR ls_change_mode.
        IF iv_processing_mode = /bobf/if_frw_c=>sc_mode_check_and_determine.
          ls_change_mode-check = abap_true. " ls_val_trigger-check.
        ELSE.
          ls_change_mode-create = abap_true. "ls_val_trigger-create.
          ls_change_mode-update = abap_true. "ls_val_trigger-update.
          ls_change_mode-delete = abap_true. "ls_val_trigger-delete.
*         do not trigger on delete if the trigger is the group node
          IF ls_val_trigger-node_key = lv_group_node_key.
            ls_change_mode-delete = abap_false.
          ENDIF.
        ENDIF.

        get_validation_trigger( EXPORTING iv_processing_mode = iv_processing_mode
                                          is_change_mode     = ls_change_mode
                                          iv_node_key        = ls_val_trigger-node_key
                                          io_change          = lo_change
                                          iv_state_current   = iv_state_current
                                          iv_state_before    = iv_state_before
                                IMPORTING et_key             = lt_trigger_key ).
        CHECK lt_trigger_key IS NOT INITIAL.

*       navigate to validation node
        IF ls_val_trigger-assoc IS BOUND.
          retrieve_by_association(
            EXPORTING
              iv_node_key        = ls_val_trigger-assoc->source_node_key
              it_key             = lt_trigger_key
              iv_association     = ls_val_trigger-assoc->assoc_key
              iv_state           = iv_state_current
              iv_fill_failed_key = abap_true
            IMPORTING
              eo_message         = lo_message
              et_target_key      = lt_target_key
              et_failed_key      = lt_failed_key ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          APPEND LINES OF lt_target_key TO lt_key.

          IF lt_failed_key IS NOT INITIAL AND ls_change_mode-delete = abap_true.
            lv_state_before_used = abap_true.
            retrieve_by_association(
              EXPORTING
                iv_node_key    = ls_val_trigger-assoc->source_node_key
                it_key         = lt_failed_key
                iv_association = ls_val_trigger-assoc->assoc_key
                iv_state       = iv_state_before
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_target_key ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
            APPEND LINES OF lt_target_key TO lt_key.
          ENDIF.
        ELSE.
          APPEND LINES OF lt_trigger_key TO lt_key.
        ENDIF.

      ENDLOOP. " val trigger

      CHECK lt_key IS NOT INITIAL.
      SORT lt_key.
      DELETE ADJACENT DUPLICATES FROM lt_key. " keys of validation node
      lv_node_key = ls_val_list-node_key.

*     navigate from validation node to group node
      DO.
        IF lv_node_key = lv_group_node_key.
          LOOP AT lt_key INTO ls_key.
            ls_group-key = ls_key-key.
            INSERT ls_group INTO TABLE lt_group.
          ENDLOOP.
          EXIT.
        ENDIF.

*       navigate TO_PARENT
        mo_conf->get_assoc(
          EXPORTING
            iv_node_key  = lv_node_key
            iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
          IMPORTING
            es_assoc     = ls_assocconf ).
        IF ls_assocconf IS INITIAL.
*         no association to parent found
          set_application_error( ).
        ENDIF.

        retrieve_by_association(
          EXPORTING
            iv_node_key        = ls_assocconf-source_node_key
            it_key             = lt_key
            iv_association     = ls_assocconf-assoc_key
            iv_state           = iv_state_current
            iv_fill_failed_key = abap_true
          IMPORTING
            eo_message         = lo_message
            et_target_key      = lt_key_parent
            et_failed_key      = lt_failed_key ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        lt_key      = lt_key_parent.
        lv_node_key = ls_assocconf-target_node_key.

        IF lt_failed_key IS NOT INITIAL.
          lv_state_before_used = abap_true.
          retrieve_by_association(
            EXPORTING
              iv_node_key    = ls_assocconf-source_node_key
              it_key         = lt_failed_key
              iv_association = ls_assocconf-assoc_key
              iv_state       = iv_state_before
            IMPORTING
              eo_message     = lo_message
              et_target_key  = lt_key_parent2 ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
          APPEND LINES OF lt_key_parent2 TO lt_key.
        ENDIF.
      ENDDO.
    ENDLOOP. " validations

*   check existence of group nodes within state current, otherwise no status needs to be calculated
    IF lv_state_before_used = abap_true.
      CLEAR lt_key.
      LOOP AT lt_group INTO ls_group.
        ls_key-key = ls_group-key.
        APPEND ls_key TO lt_key.
      ENDLOOP.

      retrieve(
        EXPORTING
          iv_node_key             = lv_group_node_key
          it_key                  = lt_key
          iv_state                = iv_state_current
          iv_fill_data            = abap_false
        IMPORTING
          eo_message              = lo_message
          et_failed_key           = lt_failed_key ).

      LOOP AT lt_failed_key INTO ls_key.
        DELETE lt_group
          WHERE group_key = ls_groupconf-group_key
            AND key       = ls_key-key.
      ENDLOOP.
      lv_state_before_used = abap_false.
    ENDIF.

    CHECK lt_group IS NOT INITIAL.

*   do not add validations of 3-way groups that are set to pending here
    IF iv_processing_mode <> /bobf/if_frw_c=>sc_mode_modify OR
       ls_groupconf-sta_var->sta_var_cat <> /bobf/if_conf_c=>sc_sta_cat_consist_ternary.
      APPEND LINES OF ls_groupconf-val_keys->* TO et_validations.
    ENDIF.

*   add result to the right exporting table
    IF ls_groupconf-sta_var IS BOUND.
      IF ls_groupconf-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary.
        INSERT LINES OF lt_group INTO TABLE et_group_2_way.
      ELSE.
        INSERT LINES OF lt_group INTO TABLE et_group_3_way.
      ENDIF.
    ELSE.
      INSERT LINES OF lt_group INTO TABLE et_group_no_status.
    ENDIF.
  ENDLOOP.

  IF et_validations IS NOT INITIAL.
    SORT et_validations.
    DELETE ADJACENT DUPLICATES FROM et_validations.
  ENDIF.

ENDMETHOD.


 METHOD get_root_key.

   DATA: lv_state         TYPE /bobf/conf_state,
         lv_node          TYPE /bobf/obm_node_key,
         ls_key           TYPE /bobf/s_frw_key,
         ls_key_link      TYPE /bobf/s_frw_key_link,
         lo_delegation    TYPE REF TO /bobf/if_frw_delegation,
         lo_change        TYPE REF TO /bobf/if_frw_change,
         lx_root          TYPE REF TO cx_root.


   CLEAR: et_key_link,
          et_failed_key,
          et_target_key,
          et_loaded_node.

   IF iv_before_image           = abap_true AND
       mv_modifying_transaction = abap_true.
     lv_state = /bobf/if_conf_c=>sc_state_database.
   ELSE.
     lv_state = /bobf/if_conf_c=>sc_state_current.
   ENDIF.

   IF mo_conf->ms_last_node-node_key <> iv_node_key.
     mo_conf->get_node( iv_node_key = iv_node_key ).
   ENDIF.

   IF mo_conf->ms_last_node-delegation_class IS INITIAL.

*  ____________________________________________________________________ *
*    retrieve data from buffer
     IF mo_conf->ms_last_node-transient = abap_false.
       lo_change = /bobf/cl_frw_factory=>get_change( ).
     ENDIF.

*    get root key of the parent node if key inherited and not loadable
     IF mo_conf->ms_last_node-key_inherited = abap_true  AND
        mo_conf->ms_last_node-loadable      = abap_false AND
        mo_conf->ms_last_node-transient     = abap_false.
       lv_node = mo_conf->ms_last_node-parent_node_key.
     ELSE.
       lv_node = iv_node_key.
     ENDIF.

     TRY.
         mo_buffer->get_root_key(
          EXPORTING
            iv_node_key   = lv_node
            it_key        = it_key
            iv_state      = lv_state
            io_change     = lo_change
          IMPORTING
            et_key_link   = et_key_link
            et_failed_key = et_failed_key
            et_target_key = et_target_key ).
       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.

     IF lo_change                  IS BOUND AND
        lo_change->has_changes( ) = abap_true.
       after_loading(
         EXPORTING
           io_change      = lo_change
           iv_load_state  = lv_state
         IMPORTING
           et_loaded_node = et_loaded_node ).
     ENDIF.

   ELSE.
*  ____________________________________________________________________ *
*    delegate call
     TRY.
         lo_delegation = get_delegation( iv_node_key ).
         DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
         lo_delegation->get_root_key(
           EXPORTING
            iv_node_key         = iv_node_key
            it_key              = it_key
            iv_state            = lv_state
            io_read             = mo_delegation_read
          IMPORTING
            et_key_link         = et_key_link
            et_failed_key       = et_failed_key ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

       CATCH cx_root INTO lx_root.                       "#EC CATCH_ALL
         set_application_error( lx_root ).
     ENDTRY.

     IF et_target_key IS REQUESTED.
       CLEAR et_target_key.
       LOOP AT et_key_link INTO ls_key_link.
         ls_key-key = ls_key_link-target_key.
         APPEND ls_key TO et_target_key.
       ENDLOOP.
       SORT et_target_key.
       DELETE ADJACENT DUPLICATES FROM et_target_key.
     ENDIF.
   ENDIF.

   ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>is_key_subset(
           it_key_set    = it_key
           it_key_subset = et_failed_key ) = abap_true.
   ASSERT ID /bobf/frw_error CONDITION
      /bobf/cl_tool_assert=>is_key_link_matching(
          it_key_link = et_key_link
          it_key      = it_key ) = abap_true.

 ENDMETHOD.


METHOD get_root_key_modify.

  DATA: lt_node       TYPE /bobf/t_frw_node,
        ls_node       TYPE /bobf/s_frw_node,
        lt_node2      TYPE /bobf/t_frw_node,
        lt_key        TYPE /bobf/t_frw_key,
        lt_tmp_key    TYPE /bobf/t_frw_key,
        ls_key        TYPE /bobf/s_frw_key,
        lt_key_link   TYPE /bobf/t_frw_key_link,
        ls_key_link   TYPE /bobf/s_frw_key_link,
        lt_node_link  TYPE /bobf/t_frw_node_key_link,
        ls_node_link  TYPE /bobf/s_frw_node_key_link,
        ls_mod        TYPE /bobf/s_frw_modification,
        lo_message    TYPE REF TO /bobf/if_frw_message,
        lo_delegation TYPE REF TO /bobf/if_frw_delegation,
        lx_root       TYPE REF TO cx_root.

  FIELD-SYMBOLS: <ls_mod> TYPE /bobf/s_frw_modification.

  CLEAR:
      et_key,
      et_key_link,
      eo_message.

  lt_node = it_node.

* search also in modify table first
  LOOP AT ct_mod ASSIGNING <ls_mod>.
    IF <ls_mod>-root_key IS NOT INITIAL.              " root key already known
      DELETE lt_node
        WHERE node = <ls_mod>-node
          AND key  = <ls_mod>-key.
      IF sy-subrc = 0.
        ls_key-key = <ls_mod>-root_key.
        APPEND ls_key TO et_key.
        ls_key_link-source_key = <ls_mod>-key.
        ls_key_link-target_key = <ls_mod>-root_key.
        IF et_key_link IS REQUESTED.
          INSERT ls_key_link INTO TABLE et_key_link.
        ENDIF.
      ENDIF.
      CONTINUE.
    ENDIF.
    IF <ls_mod>-node = mo_conf->ms_obj-root_node_key. " root key in modify table
      <ls_mod>-root_key = <ls_mod>-key.
      DELETE lt_node
        WHERE node = <ls_mod>-node
          AND key  = <ls_mod>-key.
      IF sy-subrc = 0.
        ls_key-key = <ls_mod>-root_key.
        APPEND ls_key TO et_key.
        ls_key_link-source_key = <ls_mod>-key.
        ls_key_link-target_key = <ls_mod>-root_key.
        IF et_key_link IS REQUESTED.
          INSERT ls_key_link INTO TABLE et_key_link.
        ENDIF.
      ENDIF.
      CONTINUE.
    ENDIF.

    IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_create.
*     search for created parent
      READ TABLE ct_mod INTO ls_mod
        TRANSPORTING root_key
        WITH KEY change
        COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                   node        = <ls_mod>-source_node
                   key         = <ls_mod>-source_key.
      IF sy-subrc <> 0. " parent already in the buffer
        ls_node-node = <ls_mod>-source_node.
        ls_node-key  = <ls_mod>-source_key.
        INSERT ls_node INTO TABLE lt_node2.
*        IF et_key_link IS REQUESTED.
*          ls_key_link-source_key = <ls_mod>-key.
*          ls_key_link-target_key = <ls_mod>-source_key.
*          INSERT ls_key_link INTO TABLE lt_key_link2.
*        ENDIF.
      ELSEIF ls_mod-root_key IS NOT INITIAL.
        <ls_mod>-root_key = ls_mod-root_key.
        DELETE lt_node
          WHERE node = <ls_mod>-node
            AND key  = <ls_mod>-key.
        IF sy-subrc = 0.
          ls_key-key = <ls_mod>-root_key.
          APPEND ls_key TO et_key.
          IF et_key_link IS REQUESTED.
            ls_key_link-source_key = <ls_mod>-key.
            ls_key_link-target_key = <ls_mod>-root_key.
            INSERT ls_key_link INTO TABLE et_key_link.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE.
*     update or delete
      READ TABLE lt_node TRANSPORTING NO FIELDS
        WITH KEY node = <ls_mod>-node
                 key  = <ls_mod>-key.
      IF sy-subrc = 0. " add to table if requested
        ls_node-node = <ls_mod>-node.
        ls_node-key  = <ls_mod>-key.
        INSERT ls_node INTO TABLE lt_node2.
      ENDIF.
    ENDIF.
  ENDLOOP.

* get root keys
  LOOP AT lt_node2 INTO ls_node.
    ls_key-key = ls_node-key.
    APPEND ls_key TO lt_key.
    AT END OF node.
      TRY.
          mo_buffer->get_root_key(
            EXPORTING
              iv_node_key   = ls_node-node
              it_key        = lt_key
              iv_state      = iv_state
              io_change     = io_change
            IMPORTING
              et_key_link   = lt_key_link ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      after_loading(
        EXPORTING
          io_change         = io_change
          iv_load_state     = iv_state
        IMPORTING
          eo_message        = eo_message ).

      LOOP AT lt_key_link INTO ls_key_link.
        ls_mod-root_key = ls_key_link-target_key.
*       check updates
        MODIFY ct_mod FROM ls_mod USING KEY change TRANSPORTING root_key
          WHERE change_mode = /bobf/if_frw_c=>sc_modify_update
            AND node        = ls_node-node
            AND key         = ls_key_link-source_key.
        IF sy-subrc = 0.
          DELETE lt_node
            WHERE node = ls_node-node
              AND key  = ls_key_link-source_key.
          IF sy-subrc = 0.
            ls_key-key = ls_key_link-target_key.
            APPEND ls_key TO et_key.
            IF et_key_link IS REQUESTED.
              INSERT ls_key_link INTO TABLE et_key_link.
            ENDIF.
          ENDIF.
*          CONTINUE.
        ENDIF.
*       check deletes
        MODIFY ct_mod FROM ls_mod USING KEY change TRANSPORTING root_key
          WHERE change_mode = /bobf/if_frw_c=>sc_modify_delete
            AND node        = ls_node-node
            AND key         = ls_key_link-source_key.
        IF sy-subrc = 0.
          DELETE lt_node
            WHERE node = ls_node-node
              AND key  = ls_key_link-source_key.
          IF sy-subrc = 0.
            ls_key-key = ls_key_link-target_key.
            APPEND ls_key TO et_key.
            INSERT ls_key_link INTO TABLE et_key_link.
          ENDIF.
*          CONTINUE.
        ENDIF.
*       mark creates
        ls_node_link-source_node = mo_conf->ms_obj-root_node_key.
        ls_node_link-source_key  = ls_key_link-target_key. " root_key
        ls_node_link-target_node = ls_node-node.
        ls_node_link-target_key  = ls_key_link-source_key.
        INSERT ls_node_link INTO TABLE lt_node_link.
      ENDLOOP.
      CLEAR lt_key.
    ENDAT.
  ENDLOOP.

* write root key into modification table
  IF lt_node2 IS NOT INITIAL.
    LOOP AT ct_mod ASSIGNING <ls_mod> USING KEY change
      WHERE change_mode = /bobf/if_frw_c=>sc_modify_create.

      READ TABLE ct_mod INTO ls_mod
        TRANSPORTING root_key
        WITH KEY change
        COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                   node        = <ls_mod>-source_node
                   key         = <ls_mod>-source_key.
      IF sy-subrc = 0.  " source also newly created
        <ls_mod>-root_key = ls_mod-root_key. " take root of source
      ELSE.             " source already created
        READ TABLE lt_node_link INTO ls_node_link
          WITH KEY target_node = <ls_mod>-source_node
                   target_key  = <ls_mod>-source_key.
        IF sy-subrc = 0.
          <ls_mod>-root_key = ls_node_link-source_key.
        ENDIF.
      ENDIF.
      DELETE lt_node
        WHERE node = <ls_mod>-node
          AND key  = <ls_mod>-key.
      IF sy-subrc = 0.
        ls_key-key = <ls_mod>-root_key.
        APPEND ls_key TO et_key.
        IF et_key_link IS REQUESTED.
          ls_key_link-source_key = <ls_mod>-key.
          ls_key_link-target_key = <ls_mod>-root_key.
          INSERT ls_key_link INTO TABLE et_key_link.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.

* get rest of root keys (not existing in modification table)
  LOOP AT lt_node INTO ls_node.
    ls_key-key = ls_node-key.
    APPEND ls_key TO lt_key.
    AT END OF node.
      IF ls_node-node = mo_conf->ms_obj-root_node_key.
        lt_tmp_key = lt_key.
      ELSE.

        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.

        IF mo_conf->ms_last_node-delegation_class IS INITIAL.
          TRY.
              IF et_key_link IS REQUESTED.
                mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node-node
                    it_key        = lt_key
                    iv_state      = iv_state
                    io_change     = io_change
                  IMPORTING
                    et_key_link   = lt_key_link
                    et_target_key = lt_tmp_key ).
                INSERT LINES OF lt_key_link INTO TABLE et_key_link.
              ELSE.
                mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node-node
                    it_key        = lt_key
                    iv_state      = iv_state
                    io_change     = io_change
                  IMPORTING
                    et_target_key = lt_tmp_key ).
              ENDIF.
            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          after_loading(
            EXPORTING
              io_change         = io_change
              iv_load_state     = iv_state
            IMPORTING
              eo_message        = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

        ELSE.
          TRY.
              lo_delegation = get_delegation( ls_node-node ).
              DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
              lo_delegation->get_root_key(
                EXPORTING
                 iv_node_key   = ls_node-node
                 it_key        = lt_key
                 iv_state      = iv_state
                 io_read       = mo_delegation_read
               IMPORTING
                 et_key_link   = lt_key_link ).
              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          IF et_key_link IS REQUESTED.
            INSERT LINES OF lt_key_link INTO TABLE et_key_link.
          ENDIF.

          IF et_key IS REQUESTED.
            LOOP AT lt_key_link INTO ls_key_link.
              ls_key-key = ls_key_link-target_key.
              APPEND ls_key TO lt_tmp_key.
            ENDLOOP.
            SORT lt_tmp_key.
            DELETE ADJACENT DUPLICATES FROM lt_tmp_key.
          ENDIF.
        ENDIF.
      ENDIF.

      APPEND LINES OF lt_tmp_key TO et_key.
      CLEAR lt_key.
    ENDAT.
  ENDLOOP.

  SORT et_key.
  DELETE ADJACENT DUPLICATES FROM et_key.
  DELETE ADJACENT DUPLICATES FROM et_key_link.

ENDMETHOD.


  METHOD get_state_for_read.

    DATA(ls_rba_cross_bo_states) = /bobf/cl_frw_authority_context=>get_rba_cross_bo_states( ).

    rv_state = COND #(
      WHEN iv_before_image = abap_true AND mv_modifying_transaction = abap_true THEN
        COND #(
          WHEN ls_rba_cross_bo_states-bo_key = mo_conf->ms_obj-bo_key  THEN ls_rba_cross_bo_states-before_state
          ELSE /bobf/if_conf_c=>sc_state_database )
      ELSE
        COND #(
          WHEN ls_rba_cross_bo_states-bo_key = mo_conf->ms_obj-bo_key THEN ls_rba_cross_bo_states-current_state
          ELSE /bobf/if_conf_c=>sc_state_current )
    ).

  ENDMETHOD.


 METHOD get_subnodes.

*  recursive method to navigate to almost all all subnodes
*  all combinations of STOP indicators are valid

   DATA: lt_new_key     TYPE        /bobf/t_frw_key,
         lt_node        TYPE        /bobf/t_frw_node,
         lt_path        TYPE        /bobf/t_frw_key2,
         lv_node_key    TYPE        /bobf/obm_node_key,
         ls_node        TYPE        /bobf/s_confro_node,
         lt_assoc2      TYPE        /bobf/t_confro_assoc2,
         ls_assoc2      TYPE        /bobf/s_confro_assoc2,
         lv_buffer_only TYPE        boole_d,
         lo_message     TYPE REF TO /bobf/if_frw_message.

   CLEAR: eo_message.

* ___________________________________________________________________________ *
*  determine path from IV_NODE_KEY to all IT_NODE_KEY if not yet done
   IF it_node_key IS NOT INITIAL AND
      ct_node_keys_on_path IS INITIAL.

     LOOP AT it_node_key INTO lv_node_key.
       IF lv_node_key = iv_node_key.
         APPEND lv_node_key TO ct_node_keys_on_path.
         CONTINUE.
       ENDIF.

       DO.
         APPEND lv_node_key TO lt_path.
         mo_conf->get_node( iv_node_key = lv_node_key ).
         lv_node_key = mo_conf->ms_last_node-parent_node_key.

         IF lv_node_key IS INITIAL. " node is not in subtree of iv_node_key -> skip path
           EXIT.
         ENDIF.

         IF lv_node_key = iv_node_key. " path completed -> add nodes to overall list
           APPEND lv_node_key TO lt_path.
           APPEND LINES OF lt_path TO ct_node_keys_on_path.
           EXIT.
         ENDIF.
       ENDDO.
       CLEAR lt_path.
     ENDLOOP.

     SORT ct_node_keys_on_path.
     DELETE ADJACENT DUPLICATES FROM ct_node_keys_on_path.
   ENDIF.

* ___________________________________________________________________________ *
*  read this node
   IF mo_conf->ms_last_node-node_key <> iv_node_key.
     mo_conf->get_node( iv_node_key = iv_node_key ).
   ENDIF.
   ls_node = mo_conf->ms_last_node.

* ___________________________________________________________________________ *
*  add this node to result tables
   IF iv_return_only_loadable      = abap_false AND iv_return_only_lockable = abap_false OR
      iv_return_only_loadable      = abap_true  AND ls_node-loadable        = abap_true  OR
      iv_return_only_lockable      = abap_true  AND ls_node-lockable        = abap_true  OR
      iv_return_only_check_trigger = abap_true  AND ls_node-check_trigger   = abap_true.

     IF it_node_key IS INITIAL.
       map_to_node(
         EXPORTING
           iv_node_key = iv_node_key
           it_key      = it_key
         IMPORTING
           et_node     = lt_node ).
     ELSE.
       READ TABLE it_node_key TRANSPORTING NO FIELDS
         WITH KEY key_sort COMPONENTS table_line = iv_node_key.
       IF sy-subrc = 0.
         map_to_node(
           EXPORTING
             iv_node_key = iv_node_key
             it_key      = it_key
           IMPORTING
             et_node     = lt_node ).
       ENDIF.
     ENDIF.

     IF lt_node IS NOT INITIAL.
       IF ls_node-delegation_class IS INITIAL.
         INSERT LINES OF lt_node INTO TABLE ct_host_node.
       ELSEIF iv_node_key = ls_node-delegation_root_node_key.
         INSERT LINES OF lt_node INTO TABLE ct_delegation_root_node.
       ELSE.
         INSERT LINES OF lt_node INTO TABLE ct_delegation_subtree.
       ENDIF.
     ENDIF.
   ENDIF.

* ___________________________________________________________________________ *
*  loop all compositions
   mo_conf->get_assoc_tab( IMPORTING et_comp = lt_assoc2 ).
   LOOP AT lt_assoc2 INTO ls_assoc2
     WHERE source_node_key = iv_node_key.
*    these framework nodes are not evaluated by definition
     CHECK ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_lock
       AND ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_property
       AND ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_message
       AND ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_status
       AND ls_assoc2-target_node->node_type <> /bobf/if_conf_c=>sc_node_type_qrtn.

*    check static stop condition
     IF iv_stop_at_loadable           = abap_true  AND ls_assoc2-target_node->loadable  = abap_true           OR
        iv_stop_at_lockable           = abap_true  AND ls_assoc2-target_node->lockable  = abap_true           OR
        iv_stop_at_delegation_root    = abap_true  AND ls_assoc2-target_node->delegation_class IS NOT INITIAL OR
        iv_stop_at_delegation_subtree = abap_true  AND ls_node-delegation_class IS NOT INITIAL                OR
        iv_return_transient_nodes     = gc_transient_node_ctrl-none AND ls_assoc2-target_node->transient = abap_true OR
        iv_return_only_check_trigger  = abap_true  AND ls_node-check_trigger_subnodes   = abap_false.
       CONTINUE.
     ENDIF.

*    check dynamic stop condition -> whether the target node is part of the path to be followed
     IF ct_node_keys_on_path IS NOT INITIAL.
       READ TABLE ct_node_keys_on_path TRANSPORTING NO FIELDS
         WITH KEY key_sort COMPONENTS table_line = ls_assoc2-target_node_key.
       IF sy-subrc <> 0.
         CONTINUE.
       ENDIF.
     ENDIF.

*    navigate to child node
     lv_buffer_only = iv_buffer_only.
     IF ls_assoc2-target_node->transient = abap_true AND
       iv_return_transient_nodes = gc_transient_node_ctrl-return_transient_only_buffered.
       " do not create any new transient node instances through determinations
       lv_buffer_only = abap_true.
     ENDIF.
     retrieve_by_association(
       EXPORTING
         iv_node_key    = iv_node_key
         it_key         = it_key
         iv_association = ls_assoc2-assoc_key
         iv_state       = /bobf/if_conf_c=>sc_state_current
         iv_buffer_only = lv_buffer_only
       IMPORTING
         et_target_key  = lt_new_key
         eo_message     = lo_message ).

     collect_messages( EXPORTING io_message = lo_message
                       CHANGING  co_message = eo_message ).

*    call me recursively
     IF lt_new_key IS NOT INITIAL.
       get_subnodes(
         EXPORTING
           iv_node_key                   = ls_assoc2-target_node_key
           it_key                        = lt_new_key
           it_node_key                   = it_node_key
           iv_stop_at_loadable           = iv_stop_at_loadable
           iv_stop_at_lockable           = iv_stop_at_lockable
           iv_stop_at_delegation_root    = iv_stop_at_delegation_root
           iv_stop_at_delegation_subtree = iv_stop_at_delegation_subtree
           iv_return_only_loadable       = iv_return_only_loadable
           iv_return_only_lockable       = iv_return_only_lockable
           iv_return_transient_nodes     = iv_return_transient_nodes
           iv_return_only_check_trigger  = iv_return_only_check_trigger
           iv_buffer_only                = iv_buffer_only
         IMPORTING
           eo_message                    = lo_message
         CHANGING
           ct_host_node                  = ct_host_node
           ct_delegation_root_node       = ct_delegation_root_node
           ct_delegation_subtree         = ct_delegation_subtree
           ct_node_keys_on_path          = ct_node_keys_on_path ).
       collect_messages( EXPORTING io_message = lo_message
                         CHANGING  co_message = eo_message ).
       CLEAR lt_new_key.
     ENDIF.
   ENDLOOP.

 ENDMETHOD.


  METHOD get_validation_trigger.

    DATA:
      lv_no_draft    TYPE abap_bool VALUE abap_false,
      lv_no_active   TYPE abap_bool VALUE abap_false,
      lv_clear_stack TYPE abap_bool VALUE abap_false.

    CLEAR et_key.

    " Check if we need to filter the triggers by draft/active:

    IF mo_conf->ms_obj-smart_validations = abap_true.

      CASE iv_processing_mode.

        WHEN /bobf/if_frw_c=>sc_mode_check_and_determine.
          " No restriction. All validations should be triggered

        WHEN /bobf/if_frw_c=>sc_mode_finalize.
          " During finalize, only status groups are executed.
          " With smart validations, we currently only support one specific status: the draft consistency status.
          " This status shall not be evaluated during finalize.
          " It will be checked before draft activation, at the latest.
          RETURN.

        WHEN /bobf/if_frw_c=>sc_mode_modify.
          " (Note that during modify, only status groups with binary status values are
          "  executed. This currently is not a use case for CDS-based BOs.)
          IF /bobf/cl_tra_transaction_mgr=>is_session_stateless( ).
            " After modify, only draft-validations shall be executed.
            " Others will be executed on Check Before Save.
            lv_no_active = abap_true.
          ENDIF.

        WHEN /bobf/if_frw_c=>sc_mode_check_before_save.

          " Draft instances must never prevent save --> they should not trigger consistency groups
          lv_no_draft = abap_true.

      ENDCASE.

    ENDIF.


    " get the triggers from the change object:
    io_change->get_trigger( EXPORTING iv_node_key    = iv_node_key
                                      is_change_mode = is_change_mode
                                      iv_exectime    = /bobf/if_conf_c=>sc_time_after_modify
                            IMPORTING et_changed_key = et_key ).


    " filter triggers by draft/active, if required:
    IF lv_no_draft = abap_true OR lv_no_active = abap_true.
      " separate_keys might need an internal access object...
      IF mt_access_stack IS INITIAL.
        ASSERT iv_state_before IS NOT INITIAL AND iv_state_current IS NOT INITIAL. "consumer fault: have to provide states if no int_access is on stack
        lv_clear_stack = abap_true.
        DATA(lo_int_access) = /bobf/cl_frw_int_access=>new_instance( io_bopf   = me
                                                                     io_conf   = mo_conf
                                                                     io_buffer = mo_buffer
                                                                     io_change = io_change ).
        lo_int_access->set_last_state( iv_state_before ).
        lo_int_access->set_current_state( iv_state_current ).
        lo_int_access->set_context( iv_read_allowed = abap_true ).
        INSERT lo_int_access INTO mt_access_stack INDEX 1.
      ENDIF.
    ENDIF.

    IF lv_no_draft = abap_true.
      /bobf/cl_lib_draft_active=>get_instance( mo_conf->ms_obj-bo_key
                              )->separate_keys( EXPORTING iv_node_key   = iv_node_key
                                                          it_key        = et_key
                                                IMPORTING et_active_key = DATA(lt_active_key) ).
      et_key = lt_active_key.

    ELSEIF lv_no_active = abap_true.
      /bobf/cl_lib_draft_active=>get_instance( mo_conf->ms_obj-bo_key
                              )->separate_keys( EXPORTING iv_node_key   = iv_node_key
                                                          it_key        = et_key
                                                IMPORTING et_draft_key = DATA(lt_draft_key) ).
      et_key = lt_draft_key.

    ENDIF.

    IF lv_clear_stack = abap_true.
      lo_int_access->invalidate( ).
      CLEAR mt_access_stack.
    ENDIF.

  ENDMETHOD.


  METHOD lib_enqueue_context_pop.

    CHECK mo_conf->supports_feature( /bobf/if_conf_c=>sc_feature-draft_refactored_lib ).

    /bobf/cl_lib_enqueue_context=>pop( ).

  ENDMETHOD.


  METHOD lib_enqueue_context_push_keys.

    DATA:
      lt_root_key TYPE /bobf/t_frw_key.

    CHECK mo_conf->supports_feature( /bobf/if_conf_c=>sc_feature-draft_refactored_lib ).

    IF iv_node_key = mo_conf->ms_obj-root_node_key.
      lt_root_key = it_key.
    ELSE.
      get_root_key( EXPORTING iv_node_key   = iv_node_key
                              it_key        = it_key
                    IMPORTING et_target_key = lt_root_key
                              et_failed_key = DATA(lt_key_no_root) ).
      IF lt_key_no_root IS NOT INITIAL.
        " try again with before_image:
        get_root_key( EXPORTING iv_node_key     = iv_node_key
                                it_key          = lt_key_no_root
                                iv_before_image = abap_true
                      IMPORTING et_target_key   = DATA(lt_root_key_before_img) ).
        INSERT LINES OF lt_root_key_before_img INTO TABLE lt_root_key.
        SORT lt_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_root_key.
      ENDIF.
    ENDIF.
    /bobf/cl_lib_draft_active=>get_instance( mo_conf->ms_obj-bo_key
                            )->separate_keys( EXPORTING iv_node_key  = mo_conf->ms_obj-root_node_key
                                                        it_key       = lt_root_key
                                              IMPORTING et_draft_key = DATA(lt_draft_key) ).

    /bobf/cl_lib_enqueue_context=>push( iv_entity_name = mo_conf->ms_obj-bo_name
                                        it_draft_key   = lt_draft_key ).

  ENDMETHOD.


  METHOD lock.

    DATA lv_generic TYPE boole_d.
    DATA lt_lock    TYPE /bobf/t_frw_node.

    CHECK
      iv_edit_mode            <> /bobf/if_conf_c=>sc_edit_read_only AND
      iv_within_loading       = abap_false AND
      mo_conf->ms_obj-no_lock = abap_false AND
      it_lock                 IS NOT INITIAL.

*   If only ROOT is lockable no generic lock is needed for these nodes.
    lv_generic = boolc( iv_generic = abap_true AND mo_conf->ms_obj-lock_only_root = abap_false ).

    mo_lock_manager->lock(
      EXPORTING
        iv_edit_mode                  = iv_edit_mode
        it_node                       = it_lock
        io_change                     = io_change
        iv_generic                    = lv_generic
        it_node_locked_for_delete     = it_locked_for_delete
      IMPORTING
        eo_message                    = DATA(lo_message)
        et_lockable_node_newly_locked = DATA(lt_node_reload)
        et_node_not_locked            = DATA(lt_failed)
      CHANGING
        ct_mod                        = ct_mod ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_node_subset(
            it_node_set    = it_lock
            it_node_subset = lt_failed ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = co_message ).

    INSERT LINES OF lt_failed INTO TABLE ct_failed_lock.

    IF lt_node_reload IS NOT INITIAL.
      do_loading(
        EXPORTING
          it_node           = lt_node_reload
          iv_reload         = abap_true
          iv_check_buf      = abap_false
          iv_within_loading = iv_within_loading
          iv_loading_node_key = iv_loading_node_key
          iv_edit_mode        = iv_edit_mode
          io_change         = io_change
          iv_load_data      = COND #(
                                WHEN lv_generic = abap_true  THEN abap_false "for generic locking do existence check only
                                WHEN lv_generic = abap_false THEN abap_true )
          iv_load_subtree   = COND #(
                                WHEN lv_generic = abap_true  THEN /bobf/if_frw_c=>sc_load_whole_subtree "for generic locking the whole substructure is relevant
                                WHEN lv_generic = abap_false THEN /bobf/if_frw_c=>sc_load_own_lockgroup )
        IMPORTING
          eo_message        = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = co_message ).
    ENDIF.

  ENDMETHOD.


 METHOD MAP_TO_NODE.

   DATA: ls_key  TYPE /BOBF/S_FRW_KEY,
         ls_node TYPE /BOBF/S_FRW_NODE.

   CLEAR et_node.
   ls_node-node = iv_node_key.
   LOOP AT it_key INTO ls_key.
     ls_node-key = ls_key-key.
     INSERT ls_node INTO TABLE et_node.
   ENDLOOP.

 ENDMETHOD.


  METHOD needs_notify_keyload.
    "This method checks whether keyload needs to be notified and thus influences
    "execution of after loading determinations

    rv_notify_keyload = abap_false.
    ev_transient_fields_requested = iv_has_transient_elements.

    IF it_requested_attributes IS NOT INITIAL AND
       ir_load_attribute_tab IS BOUND AND
       ir_load_attribute_tab->* IS NOT INITIAL.

      rv_notify_keyload = abap_true.
      ev_transient_fields_requested = abap_false.

      LOOP AT ir_load_attribute_tab->* ASSIGNING FIELD-SYMBOL(<lv_load_attribute>).
        READ TABLE it_requested_attributes TRANSPORTING NO FIELDS
          WITH KEY table_line = <lv_load_attribute>.
        IF sy-subrc = 0.
          rv_notify_keyload = abap_false.
          ev_transient_fields_requested = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

    ENDIF.

    IF iv_has_auth_determ = abap_true."authority determinations need to be executed anyway
      ev_transient_fields_requested = abap_true.
    ENDIF.

  ENDMETHOD.


METHOD notify_association_changes.
  " Method was removed with corrective measure 0020751259 0000027772 2017
  ASSERT 1 = 0.
ENDMETHOD.


METHOD notify_association_changes_cu.

  DATA:
    lt_change         TYPE /bobf/t_frw_change,
    lt_key_for_rba    TYPE /bobf/t_frw_key,
    lt_content_change TYPE /bobf/t_frw_change_content,
    lt_key_create     TYPE /bobf/t_frw_key,
    lt_key_update     TYPE /bobf/t_frw_key,
    ls_assoc          TYPE /bobf/s_confro_assoc,
    lt_assoc_chg_trig TYPE /bobf/t_confro_assoc_chg_trig.

  CHECK mv_no_content_changes = abap_false.
  CHECK mo_conf->ms_obj-notify_association_changes  = abap_true.
  CHECK mo_conf->ms_obj-assoc_change_notifs_by_bopf = abap_true.
  CHECK io_change IS BOUND.

  CLEAR eo_message.

  " Get changes: table is sorted by node_key, key, change_mode, external, failed, det_processed, val_processed
  io_change->get( IMPORTING et_change = lt_change ).

  LOOP AT lt_change ASSIGNING FIELD-SYMBOL(<ls_change>).

    AT NEW node_key.
      mo_conf->get_node( <ls_change>-node_key ).
      CLEAR:
        lt_key_create,
        lt_key_update.
    ENDAT.

    CHECK <ls_change>-external = abap_true AND
          <ls_change>-failed   = abap_false AND
          mo_conf->ms_last_node-assoc_change_notifs_by_bopf = abap_true.

    " Sort keys in changes into CREATE, UPDATE
    CASE <ls_change>-change_mode.
      WHEN /bobf/if_frw_c=>sc_modify_create.
        APPEND VALUE #( key = <ls_change>-key ) TO lt_key_create.
      WHEN /bobf/if_frw_c=>sc_modify_update.
        APPEND VALUE #( key = <ls_change>-key ) TO lt_key_update.
    ENDCASE.

    " Process all changes for one node
    AT END OF node_key.

      " Store combination of initial/non-initial CREATE/UPDATE key tables
      DATA(lo_key_table_selector) = lcla_key_table_selector=>create_instance_cu( it_key_create = lt_key_create
                                                                                       it_key_update = lt_key_update ).
      CHECK lo_key_table_selector IS BOUND.

      " Get triggers of associations for the current node
      mo_conf->get_assoc_change( EXPORTING iv_node_key                   = <ls_change>-node_key
                                 IMPORTING et_association_change_trigger = lt_assoc_chg_trig ).

      " Process each association (trigger) individually
      LOOP AT lt_assoc_chg_trig ASSIGNING FIELD-SYMBOL(<ls_assoc_chg_trig>) WHERE create = abap_true
                                                                            OR    update = abap_true. "#EC CI_SORTSEQ

        " Get configuration of the association which belongs to the current association trigger
        mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_assoc_chg_trig>-assoc_key
                            IMPORTING es_assoc     = ls_assoc ).
        CHECK ls_assoc-change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.

        IF <ls_assoc_chg_trig>-resolve_assoc_key IS NOT INITIAL.
          " Incoming association (CREATE, UPDATE): content change notifications are raised for
          " instances that are targets of the association with key <ls_assoc_chg_trig>-resolve_assoc_key

          " Determine source keys for RETRIEVE_BY_ASSOCIATION call from CREATE/UPDATE key tables
          " and triggers of the current association
          lo_key_table_selector->get_key_combination( EXPORTING iv_create = <ls_assoc_chg_trig>-create
                                                                iv_update = <ls_assoc_chg_trig>-update
                                                                iv_delete = <ls_assoc_chg_trig>-delete
                                                      IMPORTING et_key    = lt_key_for_rba ).
          CHECK lt_key_for_rba IS NOT INITIAL.

          " Perform RBA and add content change notifications for its targets
          add_notifs_for_resolve_assoc( EXPORTING it_source_key        = lt_key_for_rba
                                                  ir_assoc             = REF #( ls_assoc )
                                                  iv_resolve_assoc_key = <ls_assoc_chg_trig>-resolve_assoc_key
                                                  iv_state             = /bobf/if_conf_c=>sc_state_current
                                        CHANGING  co_message           = eo_message
                                                  ct_content_change    = lt_content_change
          ).
        ELSE.
          " Outgoing association: only UPDATE

          IF <ls_assoc_chg_trig>-update = abap_true AND
             lt_key_update IS NOT INITIAL.

            lt_content_change = VALUE #( BASE lt_content_change
                                         FOR wa_key IN lt_key_update
                                             ( key         = wa_key-key
                                               content_key = <ls_assoc_chg_trig>-assoc_key
                                               node_key    = <ls_change>-node_key
                                               change_mode = /bobf/if_frw_c=>sc_modify_association ) ).
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDAT.

  ENDLOOP.

  io_change->add( it_content_change = lt_content_change ).

ENDMETHOD.


METHOD notify_association_changes_d.

  DATA:
    lt_change         TYPE /bobf/t_frw_change,
    lt_content_change TYPE /bobf/t_frw_change_content,
    lt_key_delete     TYPE /bobf/t_frw_key,
    ls_assoc          TYPE /bobf/s_confro_assoc,
    lt_assoc_chg_trig TYPE /bobf/t_confro_assoc_chg_trig.

  CHECK mv_no_content_changes = abap_false.
  CHECK mo_conf->ms_obj-notify_association_changes  = abap_true.
  CHECK mo_conf->ms_obj-assoc_change_notifs_by_bopf = abap_true.
  CHECK io_change IS BOUND.

  CLEAR eo_message.

  " Get changes: table is sorted by node_key, key, change_mode, external, failed, det_processed, val_processed
  io_change->get( IMPORTING et_change = lt_change ).

  LOOP AT lt_change ASSIGNING FIELD-SYMBOL(<ls_change>).

    AT NEW node_key.
      mo_conf->get_node( <ls_change>-node_key ).
      CLEAR lt_key_delete.
    ENDAT.

    CHECK <ls_change>-change_mode = /bobf/if_frw_c=>sc_modify_delete AND
          <ls_change>-external    = abap_true AND
          <ls_change>-failed      = abap_false AND
          mo_conf->ms_last_node-assoc_change_notifs_by_bopf = abap_true.

    APPEND VALUE #( key = <ls_change>-key ) TO lt_key_delete.

    " Process all changes for one node
    AT END OF node_key.
      CHECK lt_key_delete IS NOT INITIAL.

      " Get triggers of associations for the current node
      mo_conf->get_assoc_change( EXPORTING iv_node_key                   = <ls_change>-node_key
                                 IMPORTING et_association_change_trigger = lt_assoc_chg_trig ).

      " Process each association (trigger) individually
      LOOP AT lt_assoc_chg_trig ASSIGNING FIELD-SYMBOL(<ls_assoc_chg_trig>) WHERE delete = abap_true
                                                                            AND   resolve_assoc_key IS NOT INITIAL. "#EC CI_SORTSEQ
        " Only incoming associations: content change notifications are raised for instances
        " that are targets of the association with key <ls_assoc_chg_trig>-resolve_assoc_key

        " Get configuration of the association which belongs to the current association trigger
        mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_assoc_chg_trig>-assoc_key
                            IMPORTING es_assoc     = ls_assoc ).
        CHECK ls_assoc-change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.

        " Perform RBA and add content change notifications for its targets
        add_notifs_for_resolve_assoc( EXPORTING it_source_key        = lt_key_delete
                                                ir_assoc             = REF #( ls_assoc )
                                                iv_resolve_assoc_key = <ls_assoc_chg_trig>-resolve_assoc_key
                                                iv_state             = iv_last_state
                                      CHANGING  co_message           = eo_message
                                                ct_content_change    = lt_content_change ).
      ENDLOOP.
    ENDAT.
  ENDLOOP.

  io_change->add( it_content_change = lt_content_change ).

ENDMETHOD.


METHOD notify_association_changes_do.

  DATA:
    lt_change         TYPE /bobf/t_frw_change,
    lv_process_node   TYPE abap_bool,
    lt_key_for_rba    TYPE /bobf/t_frw_key,
    lt_content_change TYPE /bobf/t_frw_change_content,
    lt_key_create     TYPE /bobf/t_frw_key,
    lt_key_update     TYPE /bobf/t_frw_key,
    lt_key_delete     TYPE /bobf/t_frw_key,
    ls_assoc          TYPE /bobf/s_confro_assoc,
    lt_assoc_chg_trig TYPE /bobf/t_confro_assoc_chg_trig.

  CHECK mv_no_content_changes = abap_false.
  CHECK mo_conf->ms_obj-notify_association_changes  = abap_true.
  CHECK mo_conf->ms_obj-assoc_change_notifs_by_bopf = abap_true.
  CHECK io_change IS BOUND.

  CLEAR eo_message.

  " Get changes: table is sorted by node_key, key, change_mode, external, failed, det_processed, val_processed
  io_change->get( IMPORTING et_change = lt_change ).

  LOOP AT lt_change ASSIGNING FIELD-SYMBOL(<ls_change>).

    AT NEW node_key.
      " Get node configuration and determine if changes for that node need to be processed
      mo_conf->get_node( <ls_change>-node_key ).
      IF mo_conf->ms_last_node-assoc_change_notifs_by_bopf = abap_true AND
         mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
        lv_process_node = abap_true.
      ELSE.
        lv_process_node = abap_false.
      ENDIF.
      CLEAR:
        lt_key_create,
        lt_key_update,
        lt_key_delete.
    ENDAT.

    CHECK <ls_change>-external = abap_true AND
          <ls_change>-failed   = abap_false AND
          lv_process_node      = abap_true.

    " Sort keys in changes into CREATE, UPDATE, DELETE
    CASE <ls_change>-change_mode.
      WHEN /bobf/if_frw_c=>sc_modify_create.
        APPEND VALUE #( key = <ls_change>-key ) TO lt_key_create.
      WHEN /bobf/if_frw_c=>sc_modify_update.
        APPEND VALUE #( key = <ls_change>-key ) TO lt_key_update.
      WHEN /bobf/if_frw_c=>sc_modify_delete.
        APPEND VALUE #( key = <ls_change>-key ) TO lt_key_delete.
    ENDCASE.

    " Process all changes for one node
    AT END OF node_key.

      " Store combination of initial/non-initial CREATE/UPDATE/DELETE key tables
      DATA(lo_key_table_selector) = lcla_key_table_selector=>create_instance( it_key_create = lt_key_create
                                                                                    it_key_update = lt_key_update
                                                                                    it_key_delete = lt_key_delete ).
      CHECK lo_key_table_selector IS BOUND.

      " Get triggers of associations for the current node
      mo_conf->get_assoc_change( EXPORTING iv_node_key                   = <ls_change>-node_key
                                 IMPORTING et_association_change_trigger = lt_assoc_chg_trig ).

      " Process each association (trigger) individually
      LOOP AT lt_assoc_chg_trig ASSIGNING FIELD-SYMBOL(<ls_assoc_chg_trig>).

        " Get configuration of the association which belongs to the current association trigger
        mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_assoc_chg_trig>-assoc_key
                            IMPORTING es_assoc     = ls_assoc ).
        CHECK ls_assoc-change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.

        IF <ls_assoc_chg_trig>-resolve_assoc_key IS NOT INITIAL.
          " Incoming association (CREATE, UPDATE, DELETE): content change notifications are raised for
          " instances that are targets of the association with key <ls_assoc_chg_trig>-resolve_assoc_key

          " Determine source keys for RETRIEVE_BY_ASSOCIATION call from CREATE/UPDATE/DELETE key tables
          " and triggers of the current association
          lo_key_table_selector->get_key_combination( EXPORTING iv_create = <ls_assoc_chg_trig>-create
                                                                iv_update = <ls_assoc_chg_trig>-update
                                                                iv_delete = <ls_assoc_chg_trig>-delete
                                                      IMPORTING et_key    = lt_key_for_rba ).
          CHECK lt_key_for_rba IS NOT INITIAL.

          " Perform RBA and add content change notifications for its targets
          add_notifs_for_resolve_assoc( EXPORTING it_source_key        = lt_key_for_rba
                                                  ir_assoc             = REF #( ls_assoc )
                                                  iv_resolve_assoc_key = <ls_assoc_chg_trig>-resolve_assoc_key
                                                  iv_state             = iv_state
                                        CHANGING  co_message           = eo_message
                                                  ct_content_change    = lt_content_change
          ).
        ELSE.
          " Outgoing association: only UPDATE

          IF <ls_assoc_chg_trig>-update = abap_true AND
             lt_key_update IS NOT INITIAL.

            lt_content_change = VALUE #( BASE lt_content_change
                                         FOR wa_key IN lt_key_update
                                             ( key         = wa_key-key
                                               content_key = <ls_assoc_chg_trig>-assoc_key
                                               node_key    = <ls_change>-node_key
                                               change_mode = /bobf/if_frw_c=>sc_modify_association ) ).
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDAT.

  ENDLOOP.

  io_change->add( it_content_change = lt_content_change ).

ENDMETHOD.


  METHOD notify_nodes_read_cache_enable.

*   This method enables nodes registered as "non caching" to be cached from now on.
    CHECK it_node_key IS NOT INITIAL.
    CHECK mo_non_cache_reg->/bobf/if_tra_non_cache_reg~has_non_cached_nodes( ).

    mo_conf->get_node_tab(
      IMPORTING
        et_node = DATA(lt_node)
    ).

    DATA(lt_node_loadgroup) = /bobf/cl_confrt_assist=>get_nodes_of_same_loadgroup(
      EXPORTING
        it_node_key = it_node_key
        it_node_all = lt_node
    ).

    mo_non_cache_reg->enable_read_cache_for_nodes( it_node_key = lt_node_loadgroup ).

  ENDMETHOD.


METHOD notify_property_changes.

  DATA: lt_change          TYPE /bobf/t_frw_change,
        ls_change          TYPE /bobf/s_frw_change,
        lt_property_change TYPE /bobf/t_frw_change_content,
        ls_property_change TYPE /bobf/s_frw_change_content,
        lt_target_key      TYPE /bobf/t_frw_key,
        lt_failed_key      TYPE /bobf/t_frw_key,
        lt_create          TYPE /bobf/t_frw_key,
        lt_update          TYPE /bobf/t_frw_key,
        lt_delete          TYPE /bobf/t_frw_key,
        lt_lock            TYPE /bobf/t_frw_key,
        ls_key             TYPE /bobf/s_frw_key,
        lt_node            TYPE /bobf/t_frw_node,
        lt_node_do_root    TYPE /bobf/t_frw_node,
        lt_node_do_subtree TYPE /bobf/t_frw_node,
        ls_node            TYPE /bobf/s_frw_node,
        lt_pct             TYPE /bobf/t_confro_prop_chg_trig,
        ls_pct             TYPE /bobf/s_confro_prop_chg_trig,
        lo_message         TYPE REF TO /bobf/if_frw_message.

  CLEAR eo_message.

  CHECK mo_conf->ms_obj-notify_property_changes = abap_true.
  CHECK mv_no_content_changes = abap_false.

* only done if any retrieve properties has been performed before
  CHECK mt_node_properties_requested IS NOT INITIAL.

  CHECK io_change IS BOUND.
  io_change->get( IMPORTING et_change = lt_change ).
  CHECK lt_change IS NOT INITIAL.

  LOOP AT lt_change INTO ls_change.

    AT NEW node_key.
      READ TABLE mt_node_properties_requested TRANSPORTING NO FIELDS
        WITH KEY key_sort COMPONENTS table_line = ls_change-node_key.
      IF sy-subrc = 0.
        mo_conf->get_property_change(
          EXPORTING iv_node_key                = ls_change-node_key
          IMPORTING et_property_change_trigger = lt_pct ).
      ELSE.
        CLEAR lt_pct.
      ENDIF.
    ENDAT.

    IF ls_change-failed   = abap_false AND
       ls_change-external = abap_true.

      IF iv_delete = abap_false OR
         ls_change-change_mode = /bobf/if_frw_c=>sc_modify_delete.

        " in case of IV_DELETE, only delete property change notifications must be returned
        ls_key-key = ls_change-key.
        CASE ls_change-change_mode.
          WHEN /bobf/if_frw_c=>sc_modify_create.
            APPEND ls_key TO lt_create.
          WHEN /bobf/if_frw_c=>sc_modify_update.
            APPEND ls_key TO lt_update.
          WHEN /bobf/if_frw_c=>sc_modify_delete.
            APPEND ls_key TO lt_delete.
          WHEN /bobf/if_frw_c=>sc_modify_lock.
            APPEND ls_key TO lt_lock.
        ENDCASE.

      ENDIF.
    ENDIF.

    AT END OF node_key.
* ___________________________________________________________________________ *
*     create property changes for created instances
      IF lt_create IS NOT INITIAL.
        LOOP AT lt_pct INTO ls_pct.
          CHECK ls_pct-create = abap_true
            AND ls_pct-assoc_key IS NOT INITIAL.
          IF mo_conf->ms_last_assoc-assoc_key <> ls_pct-assoc_key.
            mo_conf->get_assoc( iv_assoc_key = ls_pct-assoc_key ).
          ENDIF.
          ls_property_change-node_key    = mo_conf->ms_last_assoc-target_node_key.
          ls_property_change-change_mode = ls_pct-change_mode.

          retrieve_by_association(
            EXPORTING
              iv_node_key    = mo_conf->ms_last_assoc-source_node_key
              it_key         = lt_create
              iv_association = ls_pct-assoc_key
              iv_state       = /bobf/if_conf_c=>sc_state_current
            IMPORTING
              eo_message     = lo_message
              et_target_key  = lt_target_key ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_target_key INTO ls_key.
            ls_property_change-key = ls_key-key.
            APPEND ls_property_change TO lt_property_change.
          ENDLOOP.
        ENDLOOP.
        CLEAR lt_create.
      ENDIF.
* ___________________________________________________________________________ *
*     create property changes for updated instances
      IF lt_update IS NOT INITIAL.
        LOOP AT lt_pct INTO ls_pct.
          CHECK ls_pct-update = abap_true.

          IF ls_pct-assoc_key IS INITIAL.
            LOOP AT lt_update INTO ls_key.
              ls_property_change-node_key    = ls_change-node_key.
              ls_property_change-key         = ls_key-key.
              ls_property_change-change_mode = ls_pct-change_mode.
              APPEND ls_property_change TO lt_property_change.
            ENDLOOP.
            CONTINUE.
          ENDIF.

          IF mo_conf->ms_last_assoc-assoc_key <> ls_pct-assoc_key.
            mo_conf->get_assoc( iv_assoc_key = ls_pct-assoc_key ).
          ENDIF.
          ls_property_change-node_key    = mo_conf->ms_last_assoc-target_node_key.
          ls_property_change-change_mode = ls_pct-change_mode.

          retrieve_by_association(
            EXPORTING
              iv_node_key    = mo_conf->ms_last_assoc-source_node_key
              it_key         = lt_update
              iv_association = ls_pct-assoc_key
              iv_state       = /bobf/if_conf_c=>sc_state_current
            IMPORTING
              eo_message     = lo_message
              et_target_key  = lt_target_key ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_target_key INTO ls_key.
            ls_property_change-key = ls_key-key.
            APPEND ls_property_change TO lt_property_change.
          ENDLOOP.
        ENDLOOP.
        CLEAR lt_update.
      ENDIF.
* ___________________________________________________________________________ *
*     create property changes for deleted instances
      IF lt_delete IS NOT INITIAL AND iv_last_state IS NOT INITIAL.
        LOOP AT lt_pct INTO ls_pct.
          CHECK ls_pct-delete = abap_true
            AND ls_pct-assoc_key IS NOT INITIAL.
          IF mo_conf->ms_last_assoc-assoc_key <> ls_pct-assoc_key.
            mo_conf->get_assoc( iv_assoc_key = ls_pct-assoc_key ).
          ENDIF.
          ls_property_change-node_key    = mo_conf->ms_last_assoc-target_node_key.
          ls_property_change-change_mode = ls_pct-change_mode.

          retrieve_by_association(
            EXPORTING
              iv_node_key    = mo_conf->ms_last_assoc-source_node_key
              it_key         = lt_delete
              iv_association = ls_pct-assoc_key
              iv_state       = iv_last_state
            IMPORTING
              eo_message     = lo_message
              et_target_key  = lt_target_key ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_target_key INTO ls_key.
            ls_property_change-key = ls_key-key.
            APPEND ls_property_change TO lt_property_change.
          ENDLOOP.
        ENDLOOP.
        CLEAR lt_delete.
      ENDIF.
* ___________________________________________________________________________ *
*     create property changes for lock changes
      IF lt_lock IS NOT INITIAL.
*       perform existence check for locked node
        retrieve(
          EXPORTING
            iv_node_key             = ls_change-node_key
            it_key                  = lt_lock
            iv_state                = /bobf/if_conf_c=>sc_state_current
            iv_fill_data            = abap_false
            iv_buffer_only          = abap_true
          IMPORTING
            et_failed_key           = lt_failed_key ).

        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_lock WHERE key = ls_key-key.
        ENDLOOP.

*       set property change for all subnodes
        CLEAR: lt_node,
               lt_node_do_root,
               lt_node_do_subtree.

        get_subnodes(
          EXPORTING
            iv_node_key                = ls_change-node_key
            it_key                     = lt_lock
            it_node_key                = mt_node_properties_requested
            iv_stop_at_lockable        = abap_true
            iv_buffer_only             = abap_false
          IMPORTING
            eo_message                 = lo_message
          CHANGING
            ct_host_node               = lt_node
            ct_delegation_root_node    = lt_node_do_root
            ct_delegation_subtree      = lt_node_do_subtree ).

*       set property change for all nodes
        LOOP AT lt_node INTO ls_node.
          ls_property_change-node_key    = ls_node-node.
          ls_property_change-key         = ls_node-key.
          ls_property_change-change_mode = /bobf/if_frw_c=>sc_modify_property_node.
          APPEND ls_property_change TO lt_property_change.
        ENDLOOP.

        LOOP AT lt_node_do_root INTO ls_node.
          ls_property_change-node_key    = ls_node-node.
          ls_property_change-key         = ls_node-key.
          ls_property_change-change_mode = /bobf/if_frw_c=>sc_modify_property_node.
          APPEND ls_property_change TO lt_property_change.
        ENDLOOP.

        LOOP AT lt_node_do_subtree INTO ls_node.
          ls_property_change-node_key    = ls_node-node.
          ls_property_change-key         = ls_node-key.
          ls_property_change-change_mode = /bobf/if_frw_c=>sc_modify_property_node.
          APPEND ls_property_change TO lt_property_change.
        ENDLOOP.

        CLEAR lt_lock.
      ENDIF.
    ENDAT.
  ENDLOOP.


* ___________________________________________________________________________ *
* write property changes
  IF lt_property_change IS NOT INITIAL.
    io_change->add( it_content_change = lt_property_change ).
  ENDIF.

ENDMETHOD.


  METHOD PREPARE_NOTIFICATIONS_F_EXPORT.
    " Get association sources
    DATA(lt_association_source) = io_change->get_n_drop_association_sources( ).
    " Create association change notifications and add content changes
    io_change->/bobf/if_frw_change~add( it_content_change = convert_asc_src_to_cont_change( lt_association_source ) ).
    " Prepare for export
    io_change->prepare_for_export( ).
  ENDMETHOD.


METHOD RAISE_NOTIFY_CHANGES.

  DATA: lo_change_cl   TYPE REF TO /BOBF/CL_FRW_CHANGE,
        lo_change      TYPE REF TO /BOBF/IF_FRW_CHANGE,
        lo_change_temp TYPE REF TO /BOBF/IF_FRW_CHANGE,
        lo_int_access  TYPE REF TO /BOBF/CL_FRW_INT_ACCESS.

* Get changes for early notification
  IF io_change IS SUPPLIED.
*   Notify only supplied change object
    lo_change_cl ?= io_change.
    lo_change = lo_change_cl->export_changes_for_notify( ).
  endif.

  if iv_notify_entire_stack = abap_true.
*   Notify entire access stack
    LOOP AT mt_access_stack INTO lo_int_access.
      IF lo_int_access->mo_change IS BOUND.
        lo_change_cl ?= lo_int_access->mo_change.
        lo_change_temp = lo_change_cl->export_changes_for_notify( ).
        IF lo_change IS NOT BOUND.
          lo_change = lo_change_temp.
        ELSE.
          lo_change->merge( lo_change_temp ).
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.
  CHECK lo_change IS BOUND.

* And prepare them for exporting.
  lo_change_cl ?= lo_change.
  prepare_notifications_f_export( lo_change_cl ).
* Enrich properties also with association and property change
* notifications as they won't be created later on anymore
  notify_association_changes_cu( lo_change_cl ).
  notify_property_changes( lo_change_cl ).
  lo_change_cl->delete_duplicate_notifications( ).

  RAISE EVENT /BOBF/IF_FRW_SERVICE_LAYER~NOTIFY_CHANGES
    EXPORTING io_change = lo_change.

ENDMETHOD.


  METHOD remove_durable_messages.
    DATA lt_key_to_delete TYPE /bobf/t_frw_key.
    CHECK /bobf/cl_frw_message_factory=>use_durable_message( ) = abap_true.

    io_change->get_changes( EXPORTING iv_change_mode = /bobf/if_frw_c=>sc_modify_delete
                            IMPORTING et_changed_node = DATA(lt_deleted_node) ).

    LOOP AT lt_deleted_node ASSIGNING FIELD-SYMBOL(<ls_deleted_node>)
      GROUP BY ( node = <ls_deleted_node>-node ) INTO DATA(lt_node_group).
      lt_key_to_delete = VALUE #( FOR node_key_and_key IN GROUP lt_node_group ( key = node_key_and_key-key ) ).
      DATA(lo_delete_msg_container) = /bobf/cl_frw_message_factory=>create_container( ).
      CAST /bobf/cl_frw_durable_message( lo_delete_msg_container )->set_context(
          is_context = VALUE #( bo_key         = mo_conf->ms_obj-bo_key
                                node_key       = lt_node_group-node )
                                it_key_deleted = lt_key_to_delete ).
      collect_messages( EXPORTING io_message = lo_delete_msg_container
                        CHANGING co_message = co_message ).
    ENDLOOP.

  ENDMETHOD.


METHOD reset_draft_consistency_status.

*  DATA ls_node_inst_key TYPE /bobf/s_frw_key.
*  DATA lt_root_key_collection TYPE /bobf/t_frw_key.
*  DATA lr_node_table_type   TYPE REF TO data.
*  DATA ls_consistency_node TYPE ty_dra_consistency_failed_node.
*  DATA lt_consistency_node TYPE tt_dra_consistency_failed_node.
*  DATA ls_modification  type /bobf/s_frw_modification.
*  DATA lt_modification  type /bobf/t_frw_modification.
*  DATA lx_root TYPE REF TO cx_root.
*  DATA lr_root_data type REF TO data.
*
*  FIELD-SYMBOLS <ls_root_data> TYPE DATA.
*  FIELD-SYMBOLS <lv_consistency_status> TYPE data.
*
*  DATA(ls_root_node_conf) = mo_conf->get_root_node( ).
*
*  CREATE DATA lr_root_data type (ls_root_node_conf-data_type).
*  ASSIGN lr_root_data->* to <ls_root_data>.
*  ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_cons_status of STRUCTURE <ls_root_data> to <lv_consistency_status>.
*  IF sy-subrc IS NOT INITIAL.
*    " The root node doesn't has the consistency status field -> nothing to do
*    RETURN.
*  ENDIF.
*
*  LOOP AT it_create INTO DATA(ls_create).
*      READ TABLE lt_consistency_node ASSIGNING FIELD-SYMBOL(<ls_consistency_node>) WITH KEY node_key = ls_create-node.
*
*      IF sy-subrc = 0.
*        APPEND VALUE #( key = ls_create-key )  TO <ls_consistency_node>-keys.
*      ELSE.
*        APPEND VALUE #( node_key = ls_create-node keys = value #( ( key = ls_create-key ) ) ) to lt_consistency_node.
*      ENDIF.
*  ENDLOOP.
*
*  LOOP AT it_update INTO DATA(ls_update).
*    IF line_exists( ls_update-changed_fields[ table_line = /bobf/if_conf_c=>sc_attribute_name_cons_status ] ).
*      " The consistency status is explicitly set. We don't want to reset the value in this case
*      CONTINUE.
*    ENDIF.
*
*    READ TABLE lt_consistency_node ASSIGNING <ls_consistency_node> WITH KEY node_key = ls_update-node.
*
*    IF sy-subrc = 0.
*      APPEND VALUE #( key = ls_update-key )  TO <ls_consistency_node>-keys.
*    ELSE.
*      APPEND VALUE #( node_key = ls_update-node keys = value #( ( key = ls_update-key ) ) ) to lt_consistency_node.
*    ENDIF.
*
*  ENDLOOP.

*  LOOP AT lt_consistency_node INTO ls_consistency_node.
*    get_root_key( EXPORTING iv_node_key     = ls_consistency_node-node_key
*                            it_key          = ls_consistency_node-keys
*                  IMPORTING et_target_key   = DATA(lt_root_key) ).
*
*    INSERT LINES OF lt_root_key INTO TABLE lt_root_key_collection.
*  ENDLOOP.
*
*  SORT lt_root_key_collection.
*  DELETE ADJACENT DUPLICATES FROM lt_root_key_collection.

*  FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
*
*  io_change->get_changes( IMPORTING et_change = DATA(lt_change) ).
*
*  DATA(ls_root_node) = mo_conf->get_root_node( ).
*
*  CREATE DATA lr_node_table_type TYPE (ls_root_node-data_table_type).
*  ASSIGN lr_node_table_type->* TO <lt_data>.
*
*  LOOP AT lt_change INTO DATA(ls_change).
*    IF ls_change-change_mode = /bobf/if_frw_c=>sc_modify_create OR
*       ls_change-change_mode = /bobf/if_frw_c=>sc_modify_update.
*
*      ls_node_inst_key-key = ls_change-key.
*
*      READ TABLE lt_consistency_node ASSIGNING FIELD-SYMBOL(<ls_consistency_node>)
*                      WITH KEY node_key = ls_change-node_key.
*
*      IF sy-subrc = 0.
*        APPEND ls_node_inst_key TO <ls_consistency_node>-keys.
*      ELSE.
*        ls_consistency_node-node_key = ls_change-node_key.
*        APPEND ls_node_inst_key TO ls_consistency_node-keys.
*        APPEND ls_consistency_node TO lt_consistency_node.
*      ENDIF.
*    ENDIF.
*  ENDLOOP.
*
*  LOOP AT lt_consistency_node INTO ls_consistency_node.
*    get_root_key( EXPORTING iv_node_key     = ls_consistency_node-node_key
*                            it_key          = ls_consistency_node-keys
*                  IMPORTING et_target_key   = DATA(lt_root_key) ).
*
*    INSERT LINES OF lt_root_key INTO TABLE lt_root_key_collection.
*  ENDLOOP.
*
*  SORT lt_root_key_collection.
*  DELETE ADJACENT DUPLICATES FROM lt_root_key_collection.
*
*  TRY.
*    mo_buffer->retrieve( EXPORTING iv_node_key       = ls_root_node-node_key
*                                   it_key            = lt_root_key_collection
*                                   iv_state          = /bobf/if_conf_c=>sc_state_current
*                                   iv_fill_data      = abap_true
*                         IMPORTING et_data           = <lt_data> ).
*  CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
*    set_application_error( lx_root ).
*  ENDTRY.
*
*  LOOP AT <lt_data> ASSIGNING FIELD-SYMBOL(<ls_data>).
*    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_consistency_stat OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_consistency_status>).
*    IF sy-subrc <> 0.
*      EXIT.
*    ENDIF.
*
*    <lv_consistency_status> = /bobf/if_frw_c=>sc_status_pending.
*
*    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_key OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_key>).
*
*    APPEND VALUE #( node           = ls_root_node-node_key
*                    key            = <lv_key>
*                    root_key       = <lv_key>
*                    change_mode    = /bobf/if_frw_c=>sc_modify_update
*                    data           = REF #( <ls_data> )
*                    changed_fields = VALUE /bobf/t_frw_name( ( CONV #( /bobf/if_conf_c=>sc_attribute_consistency_stat ) ) ) )
*          TO lt_modification.
*  ENDLOOP.
*
*  TRY.
*    mo_buffer->modify( it_modification   = lt_modification
*                       iv_state          = /bobf/if_conf_c=>sc_state_current
*                       iv_only_transient = abap_false
*                       io_change         = io_change ).
*  CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
*    set_application_error( lx_root ).
*  ENDTRY.
ENDMETHOD.


METHOD restrict_property.
* delete not required property data

  DATA:
   ls_property_data         TYPE /bobf/s_frw_property_d,
   lv_where                 TYPE string,
   lt_where                 TYPE STANDARD TABLE OF string,
   lv_cat(3)                TYPE c,
   lv_apo                   TYPE char1  VALUE '''',         "#EC NOTEXT
   lv_open                  TYPE char1  VALUE '(',          "#EC NOTEXT
   lv_close                 TYPE char1  VALUE ')',          "#EC NOTEXT
   lv_content(13)           TYPE c      VALUE 'CONTENT_CAT =', "#EC NOTEXT
   lv_and(3)                TYPE c      VALUE 'AND',        "#EC NOTEXT
   lv_or(2)                 TYPE c      VALUE 'OR',         "#EC NOTEXT
   lv_initial               TYPE char30 VALUE 'ATTRIBUTE_NAME = SPACE', "#EC NOTEXT
   lv_notinitial            TYPE char30 VALUE 'ATTRIBUTE_NAME > SPACE'. "#EC NOTEXT

  IF ct_property_data IS NOT INITIAL.

*   build WHERE condition
    IF it_action IS INITIAL.
      CLEAR lv_where.
      CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_act lv_apo INTO lv_cat.
      IF iv_action_property           = abap_false AND
         iv_action_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_action_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_action_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
        INTO lv_where SEPARATED BY space.
      ENDIF.
      IF lv_where IS NOT INITIAL.
        APPEND lv_where TO lt_where.
      ENDIF.
    ELSE.
      " restrict static action properties to the desired actions (IT_ACTION)
      LOOP AT ct_property_data INTO ls_property_data WHERE content_cat = /bobf/if_conf_c=>sc_content_act.
        READ TABLE it_action WITH TABLE KEY key_sort COMPONENTS table_line = ls_property_data-content_key TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          DELETE ct_property_data.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF it_assoc IS INITIAL.
      CLEAR lv_where.
      CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_ass lv_apo INTO lv_cat.
      IF iv_assoc_property           = abap_false AND
         iv_assoc_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_assoc_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_assoc_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
        INTO lv_where SEPARATED BY space.
      ENDIF.
      IF lv_where IS NOT INITIAL.
        IF lt_where IS NOT INITIAL.
          APPEND lv_or TO lt_where.
        ENDIF.
        APPEND lv_where TO lt_where.
      ENDIF.
    ELSE.
      " restrict static association properties to the desired association (IT_ASSOC)
      LOOP AT ct_property_data INTO ls_property_data WHERE content_cat = /bobf/if_conf_c=>sc_content_ass.
        READ TABLE it_assoc WITH TABLE KEY key_sort COMPONENTS table_line = ls_property_data-content_key TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          DELETE ct_property_data.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF it_node_attribute IS INITIAL.
      CLEAR lv_where.
      CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_nod lv_apo INTO lv_cat.
      IF iv_node_property           = abap_false AND
         iv_node_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_node_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
         INTO lv_where SEPARATED BY space.
      ELSEIF iv_node_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
        INTO lv_where SEPARATED BY space.
      ENDIF.
      IF lv_where IS NOT INITIAL.
        IF lt_where IS NOT INITIAL.
          APPEND lv_or TO lt_where.
        ENDIF.
        APPEND lv_where TO lt_where.
      ENDIF.
    ELSE.
      " restrict static node attribute properties to the desired node attributes (IT_NODE_ATTRIBUTE)
      LOOP AT ct_property_data INTO ls_property_data WHERE content_cat = /bobf/if_conf_c=>sc_content_nod.
        IF ls_property_data-attribute_name IS NOT INITIAL.
          " only if it s node attribute property (not a node property)...
          READ TABLE it_node_attribute WITH KEY table_line = ls_property_data-attribute_name TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            DELETE ct_property_data.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF it_query IS INITIAL.
      CLEAR lv_where.
      CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_qry lv_apo INTO lv_cat.
      IF iv_query_property           = abap_false AND
         iv_query_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_query_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
        INTO lv_where SEPARATED BY space.
      ELSEIF iv_query_attribute_property = abap_false.
        CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
        INTO lv_where SEPARATED BY space.
      ENDIF.
      IF lv_where IS NOT INITIAL.
        IF lt_where IS NOT INITIAL.
          APPEND lv_or TO lt_where.
        ENDIF.
        APPEND lv_where TO lt_where.
      ENDIF.
    ELSE.
      " restrict static node query properties to the desired queries (IT_QUERY)
      LOOP AT ct_property_data INTO ls_property_data WHERE content_cat = /bobf/if_conf_c=>sc_content_qry.
        READ TABLE it_query WITH TABLE KEY key_sort COMPONENTS table_line = ls_property_data-content_key TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          DELETE ct_property_data.
        ENDIF.
      ENDLOOP.
    ENDIF.

*   execute one dynamic DELETE WHERE
    IF lt_where IS NOT INITIAL.
      DELETE ct_property_data WHERE (lt_where).
    ENDIF.

  ENDIF.

ENDMETHOD.


METHOD retrieve.

  DATA: ls_nodeconf          TYPE /bobf/s_confro_node,
        lt_node              TYPE /bobf/t_frw_node,
        ls_node              TYPE /bobf/s_frw_node,
        lt_node_not_locked   TYPE /bobf/t_frw_node,
        lt_node_newly_locked TYPE /bobf/t_frw_node,
        lt_failed_node       TYPE /bobf/t_frw_node,
        lt_failed_det        TYPE /bobf/t_frw_node,
        lt_failed_key        TYPE /bobf/t_frw_key,
        lt_key               TYPE /bobf/t_frw_key,
        ls_key               TYPE /bobf/s_frw_key,
        lt_key_retrieve      TYPE /bobf/t_frw_key,
        lv_notify_keyload    TYPE boole_d,
        lv_load_subtree      TYPE /bobf/frw_load_subtree,
        lv_attribute         TYPE string,
        lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
        lo_message           TYPE REF TO /bobf/if_frw_message,
        lx_root              TYPE REF TO cx_root.


  BREAK-POINT ID /bobf/frw.
  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

  CLEAR: eo_change,
         eo_message,
         et_failed_key,
         et_data,
         et_node_cat.

  IF mo_conf->ms_last_node-node_key = iv_node_key.
    ls_nodeconf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
      EXPORTING iv_node_key = iv_node_key
      IMPORTING es_node     = ls_nodeconf ).
  ENDIF.

  lt_key_retrieve = it_key.

* ____________________________________________________________________ *
*   check for request attributes
  needs_notify_keyload(
      EXPORTING
        it_requested_attributes       = it_requested_attributes
        ir_load_attribute_tab         = ls_nodeconf-det_load_attributes
        iv_has_transient_elements     = ls_nodeconf-has_trans_fields
        iv_has_auth_determ            = ls_nodeconf-has_auth_determ
      IMPORTING
        ev_transient_fields_requested = DATA(lv_transient_fields_requested)
      RECEIVING
        rv_notify_keyload             = lv_notify_keyload
  ).

  "with retrieval of transient fields, caching is required
  IF lv_transient_fields_requested = abap_true.
    notify_nodes_read_cache_enable( it_node_key =  value #( ( key = iv_node_key ) ) ).
  ENDIF.
* ____________________________________________________________________ *
* check for reload
  IF iv_invalidate_cache = abap_true                           OR
     ( iv_edit_mode          <> /bobf/if_conf_c=>sc_edit_read_only AND
     mo_conf->ms_obj-no_lock = abap_false ).
*    potential reload required
    map_to_node(
      EXPORTING
        iv_node_key = iv_node_key
        it_key      = lt_key_retrieve
      IMPORTING
        et_node     = lt_node ).

    eo_change = /bobf/cl_frw_factory=>get_change( ).

* ____________________________________________________________________ *
*   check locks & lock if necessary
    IF iv_edit_mode             <> /bobf/if_conf_c=>sc_edit_read_only AND
        mo_conf->ms_obj-no_lock = abap_false.
*     lock requested nodes
      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode                  = iv_edit_mode
          it_node                       = lt_node
          io_change                     = eo_change
          iv_generic                    = abap_false
        IMPORTING
          et_failed_node                = lt_failed_node
          et_lockable_node_newly_locked = lt_node_newly_locked
          et_node_not_locked            = lt_node_not_locked
          eo_message                    = lo_message ).

    ELSEIF iv_invalidate_cache  = abap_true AND
        mo_conf->ms_obj-no_lock = abap_false.
*     check locking on requested nodes
      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode       = /bobf/if_conf_c=>sc_edit_optimistic
          iv_check_only      = abap_true
          it_node            = lt_node
          io_change          = eo_change
          iv_generic         = abap_false
        IMPORTING
          et_failed_node     = lt_failed_node
          et_node_not_locked = lt_node_not_locked
          eo_message         = lo_message ).

    ELSEIF iv_invalidate_cache = abap_true.
      lt_node_not_locked = lt_node.
    ENDIF.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    LOOP AT lt_failed_node INTO ls_node.
      DELETE lt_key_retrieve USING KEY key_sort WHERE key = ls_node-key.
    ENDLOOP.

    IF lt_node_newly_locked IS NOT INITIAL.
*     reload lock groups of newly locked lockable nodes
      do_loading(
        EXPORTING
          it_node           = lt_node_newly_locked
          iv_check_buf      = abap_false
          iv_reload         = abap_true
          iv_within_loading = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
          iv_load_data      = iv_fill_data
          iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
          iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
          io_change         = eo_change
          iv_notify_keyload = lv_notify_keyload
        IMPORTING
          eo_message        = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    IF iv_invalidate_cache = abap_true AND
        lt_node_not_locked IS NOT INITIAL.
      IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_do AND
         iv_node_key = mo_conf->ms_obj-root_node_key.
        lv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup.
      ELSE.
        lv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree.
      ENDIF.
*     reload not locked nodes
      do_loading(
        EXPORTING
          it_node           = lt_node_not_locked
          iv_check_buf      = abap_false
          iv_reload         = abap_true
          iv_within_loading = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
          iv_load_data      = iv_fill_data
          iv_load_subtree   = lv_load_subtree
          iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
          io_change         = eo_change
        IMPORTING
          eo_message        = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* delegate call
  IF ls_nodeconf-delegation_class IS NOT INITIAL.

    IF eo_change IS NOT BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.
    TRY.
        lo_delegation = get_delegation( iv_node_key ).
        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        lo_delegation->retrieve(
          EXPORTING
            iv_node_key             = iv_node_key
            it_key                  = lt_key_retrieve
            iv_state                = iv_state
            iv_fill_data            = iv_fill_data
            it_requested_attributes = it_requested_attributes
            iv_invalidate_cache     = iv_invalidate_cache
            iv_edit_mode            = iv_edit_mode
            io_read                 = mo_delegation_read
            io_change               = eo_change
          IMPORTING
            eo_message              = lo_message
            et_data                 = et_data
            et_failed_key           = et_failed_key ).
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = lt_key_retrieve
            it_key_subset = lt_failed_key ) = abap_true.
    ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

  ELSE.

* ____________________________________________________________________ *
*   retrieve data from buffer
    IF ls_nodeconf-optimized_buffer_access = abap_true  AND
       ls_nodeconf-transient               = abap_false AND
       iv_buffer_only                      = abap_false.

      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

      TRY.
          IF et_node_cat IS REQUESTED.
            mo_buffer->retrieve(
              EXPORTING
                iv_node_key       = iv_node_key
                it_key            = lt_key_retrieve
                iv_state          = iv_state
                iv_fill_data      = iv_fill_data
                iv_buffer_only    = abap_false
                io_change         = eo_change
                iv_notify_keyload = lv_notify_keyload
              IMPORTING
                et_data           = et_data
                et_failed_key     = et_failed_key
                et_node_cat       = et_node_cat ).
          ELSE.
            mo_buffer->retrieve(
              EXPORTING
                iv_node_key       = iv_node_key
                it_key            = lt_key_retrieve
                iv_state          = iv_state
                iv_fill_data      = iv_fill_data
                iv_buffer_only    = abap_false
                io_change         = eo_change
                iv_notify_keyload = lv_notify_keyload
              IMPORTING
                et_data           = et_data
                et_failed_key     = et_failed_key ).
          ENDIF.

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key_retrieve
              it_key_subset = et_failed_key ) = abap_true.

      after_loading(
        EXPORTING
          io_change         = eo_change
          iv_within_loading = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
          iv_load_state     = iv_state
        IMPORTING
          eo_message        = lo_message
          et_failed_node    = lt_failed_det ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*     check for changes on requested node
      eo_change->get_changes(
        EXPORTING
          iv_node_key    = iv_node_key
          iv_change_mode = /bobf/if_frw_c=>sc_modify
        IMPORTING
          et_changed_key = lt_key ).

*     check for failed determinations after loading on that node and other nodes due to authority determinations
      IF lt_failed_det IS NOT INITIAL OR
         lt_key        IS NOT INITIAL.
*        retrieve data from buffer again (if changed after loading)
        TRY.
            IF et_node_cat IS REQUESTED.
              mo_buffer->retrieve(
               EXPORTING
                 iv_node_key       = iv_node_key
                 it_key            = lt_key_retrieve
                 iv_state          = iv_state
                 iv_fill_data      = iv_fill_data
                 iv_buffer_only    = abap_true
               IMPORTING
                 et_data           = et_data
                 et_failed_key     = et_failed_key
                 et_node_cat       = et_node_cat ).
            ELSE.
              mo_buffer->retrieve(
                EXPORTING
                  iv_node_key       = iv_node_key
                  it_key            = lt_key_retrieve
                  iv_state          = iv_state
                  iv_fill_data      = iv_fill_data
                  iv_buffer_only    = abap_true
                IMPORTING
                  et_data           = et_data
                  et_failed_key     = et_failed_key ).
            ENDIF.
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.

    ELSE.
*     default buffer access
      TRY.
          IF et_node_cat IS REQUESTED.
            mo_buffer->retrieve(
              EXPORTING
                iv_node_key       = iv_node_key
                it_key            = lt_key_retrieve
                iv_state          = iv_state
                iv_fill_data      = iv_fill_data
                iv_buffer_only    = abap_true
              IMPORTING
                et_data           = et_data
                et_failed_key     = lt_failed_key
                et_node_cat       = et_node_cat ).
          ELSE.
            mo_buffer->retrieve(
               EXPORTING
                 iv_node_key       = iv_node_key
                 it_key            = lt_key_retrieve
                 iv_state          = iv_state
                 iv_fill_data      = iv_fill_data
                 iv_buffer_only    = abap_true
               IMPORTING
                 et_data           = et_data
                 et_failed_key     = lt_failed_key ).
          ENDIF.
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key_retrieve
              it_key_subset = lt_failed_key ) = abap_true.

      IF lt_failed_key IS NOT INITIAL AND
         ( ls_nodeconf-transient = abap_true  AND iv_within_retrieve = abap_false OR
           ls_nodeconf-transient = abap_false AND iv_buffer_only     = abap_false ).
*         in case not all key were found

        IF ls_nodeconf-transient = abap_false AND
           iv_buffer_only        = abap_false.
*         persistent node
          do_loading(
            EXPORTING
              iv_node_key       = iv_node_key
              it_key            = lt_failed_key
              iv_check_buf      = abap_false
              iv_load_data      = iv_fill_data
              iv_notify_keyload = lv_notify_keyload
              iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
              io_change         = eo_change
            IMPORTING
              eo_message        = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

        ELSE.
*         transient node
          do_determinations_retrieve(
            EXPORTING
              iv_node_key       = iv_node_key
              it_key            = lt_failed_key
              iv_state          = iv_state
              iv_within_loading = iv_within_loading
                iv_loading_node_key = iv_loading_node_key
            IMPORTING
              eo_message        = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

*       try again
        TRY.
            IF et_node_cat IS REQUESTED.
              mo_buffer->retrieve(
                EXPORTING
                  iv_node_key    = iv_node_key
                  it_key         = lt_key_retrieve
                  iv_state       = iv_state
                  iv_fill_data   = iv_fill_data
                  iv_buffer_only = abap_true
                IMPORTING
                  et_data        = et_data
                  et_failed_key  = et_failed_key
                  et_node_cat    = et_node_cat ).
            ELSE.
              mo_buffer->retrieve(
                EXPORTING
                  iv_node_key    = iv_node_key
                  it_key         = lt_key_retrieve
                  iv_state       = iv_state
                  iv_fill_data   = iv_fill_data
                  iv_buffer_only = abap_true
                IMPORTING
                  et_data        = et_data
                  et_failed_key  = et_failed_key ).
            ENDIF.
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key_retrieve
                it_key_subset = et_failed_key ) = abap_true.

      ELSE.
        et_failed_key = lt_failed_key.
      ENDIF.
    ENDIF.
  ENDIF.

  LOOP AT lt_failed_node INTO ls_node.
    ls_key-key = ls_node-key.
    APPEND ls_key TO et_failed_key.
  ENDLOOP.

ENDMETHOD.


METHOD retrieve_by_association.

  DATA: ls_assoc             TYPE        /bobf/s_confro_assoc,
        lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
        ls_assoc_class       TYPE        ty_association,
        ls_key_link          TYPE        /bobf/s_frw_key_link,
        lt_failed_key        TYPE        /bobf/t_frw_key,
        lt_target_key        TYPE        /bobf/t_frw_key,
        lt_key               TYPE        /bobf/t_frw_key,
        ls_key               TYPE        /bobf/s_frw_key,
        ls_node              TYPE        /bobf/s_frw_node,
        ls_node_2            TYPE        /bobf/s_frw_node,
        lt_node              TYPE        /bobf/t_frw_node,
        lt_node_reload       TYPE        /bobf/t_frw_node,
        lt_node_not_locked   TYPE        /bobf/t_frw_node,
        lt_node_not_locked_2 TYPE        /bobf/t_frw_node,
        lt_node_loaded       TYPE        /bobf/t_frw_node,
        lt_node_loaded_2     TYPE        /bobf/t_frw_node,
        lt_failed_node       TYPE        /bobf/t_frw_node,
        lt_failed_node_2     TYPE        /bobf/t_frw_node,
        ls_context           TYPE        /bobf/s_frw_ctx_assoc,
        ls_context_det       TYPE        /bobf/s_frw_ctx_det,
        lx_root              TYPE REF TO cx_root,
        lo_int_access        TYPE REF TO /bobf/cl_frw_int_access,
        lx_frw               TYPE REF TO /bobf/cx_frw_core,
        lv_content_cat       TYPE        string,
        lt_nodecat           TYPE        /bobf/t_frw_node_cat,
        ls_nodecat           TYPE        /bobf/s_frw_node_cat,
        lv_valid             TYPE        i,
        lv_lock_required     TYPE        boole_d,
        lv_fill_failed_key   TYPE        boole_d,
        lv_fill_data         TYPE        boole_d,
        lv_notify_keyload    TYPE        boole_d,
        lv_load_data         TYPE        boole_d,
        lv_attribute         TYPE        string,
        lo_message           TYPE REF TO /bobf/if_frw_message,
        lo_message_int       TYPE REF TO /bobf/cl_frw_message,
        ls_runtime_context   TYPE        /bobf/s_frw_runtime_context,
        lv_content_name      TYPE        /bobf/obm_name,
        lv_class             TYPE        seoclsname,
        lv_application_info  TYPE        string,
        lo_change            TYPE REF TO /bobf/if_frw_change.


  ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

  CLEAR: eo_change,
         eo_message,
         et_data,
         et_key_link,
         et_target_key,
         et_failed_key.

  CHECK it_key IS NOT INITIAL.

* read configuration
  IF mo_conf->ms_last_assoc-assoc_key = iv_association.
    ls_assoc = mo_conf->ms_last_assoc.
  ELSE.
    mo_conf->get_assoc(
      EXPORTING iv_assoc_key = iv_association
      IMPORTING es_assoc     = ls_assoc ).
  ENDIF.

  ASSERT ID /bobf/frw CONDITION iv_node_key = ls_assoc-source_node_key.

* the target node is not part of this objects (X-BO?)
  IF ls_assoc-target_node_key IS INITIAL.
    set_application_error( ).
  ENDIF.

  lt_key             = it_key.
  lv_fill_failed_key = iv_fill_failed_key.

* check for requested attributes
  needs_notify_keyload(
    EXPORTING
      it_requested_attributes       = it_requested_attributes
      ir_load_attribute_tab         = ls_assoc-target_node->det_load_attributes
      iv_has_transient_elements     = ls_assoc-target_node->has_trans_fields
      iv_has_auth_determ            = ls_assoc-target_node->has_auth_determ
    IMPORTING
      ev_transient_fields_requested = DATA(lv_transient_fields_requested)
    RECEIVING
      rv_notify_keyload             = lv_notify_keyload
  ).

  "transient fields requires caching of the data
  IF lv_transient_fields_requested = abap_true.
    notify_nodes_read_cache_enable( it_node_key = value #( ( key = ls_assoc-target_node_key ) ) ).
  ENDIF.
* ____________________________________________________________________ *
* lock and reload source node
  IF iv_invalidate_cache              =  abap_true                          OR
      ( iv_edit_mode                  <> /bobf/if_conf_c=>sc_edit_read_only AND
*      ls_assoc-target_node->transient =  abap_false                         AND
      mo_conf->ms_obj-no_lock         =  abap_false ).
*    potential reload required
    map_to_node(
      EXPORTING
        iv_node_key = iv_node_key
        it_key      = it_key
      IMPORTING
        et_node     = lt_node ).

    IF iv_edit_mode        <> /bobf/if_conf_c=>sc_edit_read_only AND
        ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_xbo.
      lv_lock_required = abap_true.
    ENDIF.

    IF lv_lock_required                    = abap_true AND
        ls_assoc-target_locked_with_source = abap_true.
*     lock source nodes
      eo_change = /bobf/cl_frw_factory=>get_change( ).
      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode                  = iv_edit_mode
          it_node                       = lt_node
          io_change                     = eo_change
          iv_generic                    = abap_false
        IMPORTING
          et_failed_node                = lt_failed_node
          et_node_not_locked            = lt_node_not_locked
          et_lockable_node_newly_locked = lt_node_reload
          et_loaded_node                = lt_node_loaded
          eo_message                    = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*     reload successfully locked locking groups
      IF lt_node_reload IS NOT INITIAL.
        IF ls_assoc-source_data_required = abap_true.
          lv_load_data = abap_true.
        ELSE.
          lv_load_data = iv_fill_data.
        ENDIF.

        do_loading(
          EXPORTING
            it_node           = lt_node_reload
            iv_check_buf      = abap_false
            iv_reload         = abap_true
            iv_within_loading = iv_within_loading
              iv_loading_node_key = iv_loading_node_key
            iv_load_data      = lv_load_data
            iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
            iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
            io_change         = eo_change
          IMPORTING
            et_failed         = lt_failed_node_2
            eo_message        = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      IF lt_failed_node_2 IS NOT INITIAL.
        IF lt_failed_node IS NOT INITIAL.
          INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
        ELSE.
          lt_failed_node = lt_failed_node_2.
        ENDIF.
      ENDIF.

    ELSEIF ( lv_lock_required              = abap_true    AND
        ls_assoc-target_locked_with_source = abap_false ) OR
        iv_invalidate_cache                = abap_true.
*     check locking of source nodes
      eo_change = /bobf/cl_frw_factory=>get_change( ).
      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode       = /bobf/if_conf_c=>sc_edit_optimistic
          iv_check_only      = abap_true
          it_node            = lt_node
          io_change          = eo_change
          iv_generic         = abap_false
        IMPORTING
          et_failed_node     = lt_failed_node
          et_node_not_locked = lt_node_not_locked
          et_loaded_node     = lt_node_loaded
          eo_message         = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    IF lt_node_not_locked                  IS NOT INITIAL AND
        ( iv_invalidate_cache              = abap_true    OR
        ls_assoc-target_locked_with_source = abap_false ) AND
        ( ls_assoc-source_node->delegation_class IS INITIAL OR
          ls_assoc-target_node->delegation_class IS INITIAL ).
*     reload not locked nodes (if required)
      IF ls_assoc-source_data_required = abap_true.
        lv_load_data = abap_true.
      ELSEIF ls_assoc-target_loaded_with_source = abap_true.
        lv_load_data = iv_fill_data.
      ELSE.
        lv_load_data = abap_false.
      ENDIF.

      do_loading(
        EXPORTING
          iv_node_key_unique = iv_node_key
          it_node            = lt_node_not_locked
          it_node_no_reload  = lt_node_loaded
          iv_check_buf       = abap_false
          iv_reload          = abap_true
          iv_within_loading  = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
          iv_load_data       = lv_load_data
          iv_load_subtree    = /bobf/if_frw_c=>sc_load_no_subtree
          iv_edit_mode       = /bobf/if_conf_c=>sc_edit_read_only
          io_change          = eo_change
        IMPORTING
          et_failed          = lt_failed_node_2
          eo_message         = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_failed_node_2 IS NOT INITIAL.
        IF lt_failed_node IS NOT INITIAL.
          INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
        ELSE.
          lt_failed_node = lt_failed_node_2.
        ENDIF.
      ENDIF.
    ENDIF.

    LOOP AT lt_failed_node INTO ls_node.
      DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
      IF iv_fill_failed_key = abap_true.
        ls_key-key = ls_node-key.
        APPEND ls_key TO et_failed_key.
      ENDIF.
    ENDLOOP.

    CLEAR:
        lt_node_reload,
        lt_node_loaded,
        lt_failed_node,
        lt_failed_node_2.
  ENDIF.

* ____________________________________________________________________ *
* check if source nodes are in buffer / load object part / reload buffer
  IF iv_buffer_only                                   = abap_false  AND
      ls_assoc-source_node->delegation_class          IS INITIAL    AND
      ( ls_assoc-assoc_class                          IS INITIAL    OR
      iv_ask_buffer                                   = abap_true ) AND
      ( ls_assoc-source_node->optimized_buffer_access = abap_false  OR
      ls_assoc-target_node->optimized_buffer_access   = abap_false ).

    IF ls_assoc-source_data_required = abap_true.
      lv_load_data = abap_true.
    ELSEIF ls_assoc-target_loaded_with_source = abap_true AND
        iv_fill_data                          = abap_true.
      lv_load_data = abap_true.
    ELSE.
      lv_load_data = abap_false.
    ENDIF.

    IF eo_change IS NOT BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

    do_loading(
      EXPORTING
        iv_node_key       = iv_node_key
        it_key            = lt_key
        iv_check_buf      = abap_true
        iv_reload         = abap_false
        iv_load_data      = lv_load_data
        iv_notify_keyload = abap_true
        iv_within_loading = iv_within_loading
          iv_loading_node_key = iv_loading_node_key
        iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
        io_change         = eo_change
      IMPORTING
        et_failed         = lt_failed_node
        eo_message        = lo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_node_subset(
            iv_node_set    = iv_node_key
            it_key_set     = lt_key
            it_node_subset = lt_failed_node ) =  abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

* not removing faileds from lt_key leads to a superfluous DB access
    LOOP AT lt_failed_node INTO ls_node.
      DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
      IF iv_fill_failed_key = abap_true.
        ls_key-key = ls_node-key.
        APPEND ls_key TO et_failed_key.
      ENDIF.
    ENDLOOP.
  ENDIF.

*  ____________________________________________________________________ *
*  filter keys regarding their node category
  IF ls_assoc-node_cat->* IS NOT INITIAL.
    CLEAR lt_nodecat.
    retrieve(
      EXPORTING
        iv_node_key    = iv_node_key
        it_key         = lt_key
        iv_state       = iv_state
        iv_fill_data   = abap_false
        iv_buffer_only = iv_buffer_only
      IMPORTING
        et_node_cat    = lt_nodecat
        et_failed_key  = lt_failed_key
        eo_message     = lo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = lt_key
            it_key_subset = lt_failed_key ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    ASSERT ID /bobf/frw CONDITION lines( lt_nodecat ) + lines( lt_failed_key ) = lines( lt_key ).

    IF iv_fill_failed_key = abap_true.
      APPEND LINES OF lt_failed_key TO et_failed_key.
    ENDIF.

    lv_fill_failed_key = abap_false.

    LOOP AT lt_failed_key INTO ls_key.
      DELETE lt_key USING KEY key_sort WHERE key = ls_key-key.
    ENDLOOP.

    LOOP AT lt_nodecat INTO ls_nodecat.
*     check if node category is valid
      AT NEW node_cat_key.
        READ TABLE ls_assoc-node_cat->*
          WITH KEY node_cat_key = ls_nodecat-node_cat_key
          TRANSPORTING NO FIELDS.
        lv_valid = sy-subrc.
      ENDAT.
      ls_key-key = ls_nodecat-key.
      IF lv_valid <> 0.
*        association is disabled for node category
*          => do not search for associated nodes
*        important note: do not fill failed keys as the source key is ok
        DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
      ENDIF.
    ENDLOOP.
  ENDIF.


*  ____________________________________________________________________ *
*  perform determination before retrieve of target node
  IF ls_assoc-target_node->transient = abap_true                         AND
     iv_with_det_before_retrieve     = abap_true                         AND
     lt_key IS NOT INITIAL.

    "filter out invalid source keys; for internal nodes the retrieve is not executed
    "in case failed keys are not requested due to performance optimization
    IF lv_fill_failed_key = abap_true OR
      ( ls_assoc-source_node->node_type <> /bobf/if_conf_c=>sc_node_type_lock AND
        ls_assoc-source_node->node_type <> /bobf/if_conf_c=>sc_node_type_message AND
        ls_assoc-source_node->node_type <> /bobf/if_conf_c=>sc_node_type_property ).

      retrieve(
        EXPORTING
          iv_node_key    = iv_node_key
          it_key         = lt_key
          iv_state       = iv_state
          iv_fill_data   = abap_false
        IMPORTING
          et_failed_key  = lt_failed_key
          eo_message     = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      lv_fill_failed_key = abap_false.
      LOOP AT lt_failed_key INTO ls_key.
        DELETE lt_key USING KEY key_sort WHERE key = ls_key-key.
      ENDLOOP.
      APPEND LINES OF lt_failed_key TO et_failed_key.
    ENDIF.

    IF lt_key IS NOT INITIAL AND
       NOT iv_buffer_only = abap_true.

      do_determinations_retrieve(
        EXPORTING
          iv_assoc_key           = iv_association
          it_key                 = lt_key
          is_parameters          = is_parameters
          it_filtered_attributes = it_filtered_attributes
          iv_state               = iv_state
          iv_within_loading      = iv_within_loading
            iv_loading_node_key    = iv_loading_node_key
        IMPORTING
          eo_message             = lo_message
          et_failed_key          = lt_failed_key ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key
              it_key_subset = lt_failed_key ) = abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF iv_fill_failed_key = abap_true.
        APPEND LINES OF lt_failed_key TO et_failed_key.
      ENDIF.

      LOOP AT lt_failed_key INTO ls_key.
        DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
      ENDLOOP.

    ENDIF.
  ENDIF.

* ____________________________________________________________________ *
* resolve assoication
  IF lt_key IS NOT INITIAL.
    IF eo_change IS NOT BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

* ____________________________________________________________________ *
*   call external association implementation
    IF ls_assoc-assoc_class IS NOT INITIAL AND
      iv_ask_buffer = abap_false.
      ls_context-bo_key        = mo_conf->ms_obj-bo_key.
      ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
      ls_context-node_key      = ls_assoc-source_node_key.
      ls_context-assoc_key     = ls_assoc-assoc_key.

      IF iv_before_image IS SUPPLIED.
        ls_context-before_image = iv_before_image.
      ELSEIF iv_state = /bobf/if_conf_c=>sc_state_database.
        ls_context-before_image = abap_true.
      ELSE.
        ls_context-before_image = abap_false.
      ENDIF.

*     create internal access object for associations
      /bobf/cl_frw_int_access=>new_instance(
        EXPORTING
          io_bopf            = me
          io_conf            = mo_conf
          io_buffer          = mo_buffer
          io_change          = eo_change
        RECEIVING
          eo_internal_access = lo_int_access
      ).
      lo_int_access->set_last_state(    iv_last_state    = iv_state ).
      lo_int_access->set_current_state( iv_current_state = iv_state ).

*     Intentional missing of assert: retrieve_by_association could be called within det or val loop with not valid
*     access object in access stack
      INSERT lo_int_access INTO mt_access_stack INDEX 1.

*     get assoc class
      READ TABLE mt_association
         WITH TABLE KEY assoc_key = ls_assoc-assoc_key
         INTO ls_assoc_class.
      IF sy-subrc <> 0.
        ls_assoc_class-assoc_key = ls_assoc-assoc_key.
        TRY.
            CREATE OBJECT ls_assoc_class-class TYPE (ls_assoc-assoc_class).
          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_assoc = abap_true
              iv_key = ls_assoc-assoc_key ).
            lv_content_cat = TEXT-001.
            CREATE OBJECT lx_frw
              EXPORTING
                previous        = lx_root
                textid          = /bobf/cx_frw_core=>sc_no_instance
                mv_classname    = ls_assoc-assoc_class
                mv_content_cat  = lv_content_cat
                mv_content_name = lv_content_name.
            set_configuration_error( lx_frw ).
        ENDTRY.

        INSERT ls_assoc_class INTO TABLE mt_association.
      ENDIF.

      IF iv_within_loading = abap_true.
        ls_context_det-exectime = /bobf/if_conf_c=>sc_time_after_loading.
      ENDIF.

      lo_int_access->set_context(
         is_association      = ls_context
         is_determination    = ls_context_det
         iv_read_allowed     = abap_true
         iv_read_buffer_only = iv_buffer_only
         iv_invalidate_cache = iv_invalidate_cache
          iv_within_loading   = iv_within_loading
          iv_loading_node_key = iv_loading_node_key ).

      TRY.
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          ls_assoc_class-class->resolve(
            EXPORTING
              is_ctx                 = ls_context
              it_key                 = lt_key
              io_read                = lo_int_access
              is_parameters          = is_parameters
              it_filtered_attributes = it_filtered_attributes
              iv_invalidate_cache    = iv_invalidate_cache
            IMPORTING
              et_key_link            = et_key_link
              et_failed_key          = lt_failed_key
              eo_message             = lo_message ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_key
                  it_key_subset = lt_failed_key ) = abap_true.
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_key_link_matching(
                 it_key        = lt_key
                 it_key_link   = et_key_link ) = abap_true.
          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ) =  abap_true.

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_assoc = abap_true
            iv_key = ls_assoc-assoc_key ).
          lv_content_cat = TEXT-001.
          lv_class = ls_assoc-assoc_class.
          lcl_error_text_provider=>get_text_impl_class_error(
           EXPORTING
             iv_content_cat      = /bobf/if_conf_c=>sc_content_ass
             iv_content_key      = ls_assoc-assoc_key
             iv_node_key         = iv_node_key
             iv_content_name     = lv_content_name
             iv_content_class    = lv_class
             iv_method_name      = 'RESOLVE'
             io_configuration    = mo_conf
           RECEIVING
             rv_application_info = lv_application_info
         ).
          CREATE OBJECT lx_frw
            EXPORTING
              textid                     = /bobf/cx_frw_core=>sc_content_exception
              previous                   = lx_root
              mv_method_name             = 'RESOLVE'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_application_error( lx_frw ).
      ENDTRY.
      lo_int_access->invalidate( ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.

      APPEND LINES OF lt_failed_key TO et_failed_key.

*     set context
      create_durable_msg_container(  CHANGING co_message = lo_message ).
      IF lo_message IS BOUND.
        lo_message_int ?= lo_message.
        ls_runtime_context-bo_key      = mo_conf->ms_obj-bo_key.
        ls_runtime_context-node_key    = iv_node_key.
        ls_runtime_context-assoc_key   = iv_association.
        ls_runtime_context-consistency = abap_false.
        lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key ).
      ENDIF.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF et_target_key IS REQUESTED OR
         iv_fill_data = abap_true.
        LOOP AT et_key_link INTO ls_key_link.
          ls_key-key = ls_key_link-target_key.
          APPEND ls_key TO et_target_key.
        ENDLOOP.
        SORT et_target_key.
        DELETE ADJACENT DUPLICATES FROM et_target_key.
      ENDIF.

* ____________________________________________________________________ *
*   ask own buffer
    ELSEIF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source AND
           ls_assoc-source_node->delegation_class IS INITIAL OR
           ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target AND
           ls_assoc-target_node->delegation_class IS INITIAL.

      IF ls_assoc-target_node->transient               = abap_false AND
         ls_assoc-target_node->optimized_buffer_access = abap_false.
        lv_fill_data = abap_false.
      ELSE.
        lv_fill_data = iv_fill_data.
      ENDIF.

      TRY.
          mo_buffer->retrieve_by_association(
             EXPORTING
               iv_node_key            = iv_node_key
               it_key                 = lt_key
               iv_association         = iv_association
               is_parameters          = is_parameters
               it_filtered_attributes = it_filtered_attributes
               iv_state               = iv_state
               iv_buffer_only         = iv_buffer_only
               iv_fill_data           = lv_fill_data
               io_change              = eo_change
               iv_fill_failed_key     = lv_fill_failed_key
               iv_notify_keyload      = lv_notify_keyload
               iv_invalidate_cache    = iv_invalidate_cache
             IMPORTING
               et_key_link            = et_key_link
               et_data                = et_data
               et_failed_key          = lt_failed_key
               et_target_key          = et_target_key ).
        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key
              it_key_subset = lt_failed_key ) = abap_true.
      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_link_matching(
             it_key        = lt_key
             it_key_link   = et_key_link
             it_target_key = et_target_key ) = abap_true.

*     do det after loading and state handling
      after_loading(
        EXPORTING
          io_change         = eo_change
          iv_within_loading = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
          iv_load_state     = iv_state
        IMPORTING
          eo_message        = lo_message
          et_loaded_node    = lt_node_loaded
          et_failed_node    = lt_failed_node ).

      LOOP AT lt_failed_node ASSIGNING FIELD-SYMBOL(<ls_failed_node>) WHERE node = ls_assoc-target_node_key.
        DELETE TABLE et_target_key WITH TABLE KEY key = <ls_failed_node>-key.
        IF iv_fill_data = abap_true.
          READ TABLE et_data WITH KEY (/bobf/if_conf_c=>sc_attribute_name_key) = <ls_failed_node>-key TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            DELETE et_data INDEX sy-tabix.
          ENDIF.
        ENDIF.
        DELETE TABLE et_key_link WITH TABLE KEY target_key COMPONENTS target_key = <ls_failed_node>-key.
      ENDLOOP.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*     check for changes on requested target node
      eo_change->get_changes(
        EXPORTING
          iv_node_key     = ls_assoc-target_node_key
          iv_change_mode  = /bobf/if_frw_c=>sc_modify
        IMPORTING
          et_changed_key  = lt_target_key ).

*     check for updates during determination after loading on target node
      IF lt_target_key IS NOT INITIAL.
*       read target data again -> done at the end of the method
        CLEAR et_data.
      ENDIF.

      IF iv_fill_failed_key = abap_true.
        APPEND LINES OF lt_failed_key TO et_failed_key.
      ENDIF.

* ____________________________________________________________________ *
*   ask delegation class
    ELSE.
      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

      TRY.
          IF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.
            lo_delegation = get_delegation( iv_node_key ).
          ELSE.
            lo_delegation = get_delegation( ls_assoc-target_node_key ).
          ENDIF.
          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->retrieve_by_association(
            EXPORTING
              iv_node_key                   = iv_node_key
              it_key                        = lt_key
              iv_association                = iv_association
              is_parameters                 = is_parameters
              it_filtered_attributes        = it_filtered_attributes
              iv_fill_data                  = iv_fill_data
              it_requested_attributes       = it_requested_attributes
              iv_state                      = iv_state
              iv_invalidate_cache           = iv_invalidate_cache
              iv_buffer_sufficient_hint     = iv_buffer_only
              iv_edit_mode                  = iv_edit_mode
              io_change                     = eo_change
            IMPORTING
              eo_message                    = lo_message
              et_data                       = et_data
              et_failed_key                 = lt_failed_key
              et_key_link                   = et_key_link ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        CATCH cx_root INTO lx_root.                      "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key
              it_key_subset = lt_failed_key ) = abap_true.
      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_link_matching(
             it_key        = lt_key
             it_key_link   = et_key_link ) = abap_true.
      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF iv_fill_failed_key = abap_true AND
          lt_failed_key     IS NOT INITIAL.
        IF et_failed_key IS NOT INITIAL.
          APPEND LINES OF lt_failed_key TO et_failed_key.
        ELSE.
          et_failed_key = lt_failed_key.
        ENDIF.
      ENDIF.

*     fill target key if not done yet
      IF et_target_key   IS REQUESTED AND
         et_key_link     IS NOT INITIAL.
        LOOP AT et_key_link INTO ls_key_link.
          ls_key-key = ls_key_link-target_key.
          APPEND ls_key TO et_target_key.
        ENDLOOP.
        SORT et_target_key.
        DELETE ADJACENT DUPLICATES FROM et_target_key.
      ENDIF.
    ENDIF.

  ENDIF.

  CLEAR lt_failed_node.

* ____________________________________________________________________ *
* lock and reload target node
  IF ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_xbo AND
     ls_assoc-target_node->transient = abap_false.
    IF ( lv_lock_required    = abap_true OR
       iv_invalidate_cache = abap_true ) AND
       eo_change           IS NOT BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

*   lock target nodes
    IF lv_lock_required                   = abap_true AND
       ls_assoc-target_locked_with_source = abap_false.
      map_to_node(
        EXPORTING
          iv_node_key = ls_assoc-target_node_key
          it_key      = et_target_key
        IMPORTING
          et_node     = lt_node ).

      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode                  = iv_edit_mode
          it_node                       = lt_node
          io_change                     = eo_change
          iv_generic                    = abap_false
        IMPORTING
          et_failed_node                = lt_failed_node
          et_lockable_node_newly_locked = lt_node_reload
          et_node_not_locked            = lt_node_not_locked
          et_loaded_node                = lt_node_loaded_2
          eo_message                    = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_node_loaded_2 IS NOT INITIAL AND
          iv_invalidate_cache = abap_true.
        IF lt_node_loaded IS INITIAL.
          lt_node_loaded = lt_node_loaded_2.
        ELSE.
          INSERT LINES OF lt_node_loaded_2 INTO TABLE lt_node_loaded.
          DELETE ADJACENT DUPLICATES FROM lt_node_loaded.
        ENDIF.
      ENDIF.

*     reload successfully locked locking groups
      IF lt_node_reload IS NOT INITIAL.
        do_loading(
          EXPORTING
            it_node           = lt_node_reload
            iv_check_buf      = abap_false
            iv_reload         = abap_true
            iv_load_data      = abap_false
            iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
            iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
            io_change         = eo_change
          IMPORTING
            eo_message        = lo_message
            et_failed         = lt_failed_node_2 ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        CLEAR et_data.

        IF lt_failed_node_2 IS NOT INITIAL.
          IF lt_failed_node IS INITIAL.
            lt_failed_node = lt_failed_node_2.
          ELSE.
            INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
          ENDIF.
        ENDIF.
      ENDIF.

*   determine nodes belonging to not locked source nodes
    ELSEIF ls_assoc-target_locked_with_source = abap_true  AND
        ls_assoc-target_loaded_with_source    = abap_false AND
        iv_invalidate_cache                   = abap_true.
      ls_node_2-node = ls_assoc-target_node_key.
      LOOP AT lt_node_not_locked INTO ls_node.
        LOOP AT et_key_link INTO ls_key_link WHERE
            source_key = ls_node-key.
          ls_node_2-key = ls_key_link-target_key.
          INSERT ls_node_2 INTO TABLE lt_node_not_locked_2.
        ENDLOOP.
      ENDLOOP.
      lt_node_not_locked = lt_node_not_locked_2.

*   check locks of target nodes
    ELSEIF lv_lock_required                = abap_false AND
        iv_invalidate_cache                = abap_true  AND
        ls_assoc-target_locked_with_source = abap_false.
      map_to_node(
        EXPORTING
          iv_node_key = ls_assoc-target_node_key
          it_key      = et_target_key
        IMPORTING
          et_node     = lt_node ).

      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode       = /bobf/if_conf_c=>sc_edit_optimistic
          iv_check_only      = abap_true
          it_node            = lt_node
          io_change          = eo_change
          iv_generic         = abap_false
        IMPORTING
          et_failed_node     = lt_failed_node
          et_node_not_locked = lt_node_not_locked
          eo_message         = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

    ELSE.
      CLEAR lt_node_not_locked.
    ENDIF.


*   reload
    IF lt_node_not_locked   IS NOT INITIAL AND
       iv_invalidate_cache = abap_true.
      do_loading(
        EXPORTING
          iv_node_key_unique = ls_assoc-target_node_key
          it_node            = lt_node_not_locked
          it_node_no_reload  = lt_node_loaded
          iv_check_buf       = abap_false
          iv_reload          = abap_true
          iv_load_data       = iv_fill_data
          iv_load_subtree    = /bobf/if_frw_c=>sc_load_no_subtree
          iv_edit_mode       = /bobf/if_conf_c=>sc_edit_read_only
          io_change          = eo_change
          iv_notify_keyload  = lv_notify_keyload
        IMPORTING
          et_failed          = lt_failed_node_2
          eo_message         = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      CLEAR et_data.

      IF lt_failed_node_2 IS NOT INITIAL.
        IF lt_failed_node IS INITIAL.
          lt_failed_node = lt_failed_node_2.
        ELSE.
          INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
        ENDIF.
      ENDIF.
    ENDIF.

*   update exporting parameters
    LOOP AT lt_failed_node INTO ls_node.
      DELETE et_target_key USING KEY key_sort WHERE key = ls_node-key.
      READ TABLE et_key_link INTO ls_key_link WITH KEY target_key
        COMPONENTS target_key = ls_node-key.
      CHECK sy-subrc = 0.
      DELETE et_key_link INDEX sy-tabix USING KEY target_key.
    ENDLOOP.
  ENDIF.

* ____________________________________________________________________ *
* retrieve target node
  IF iv_fill_data = abap_true     AND
     et_target_key IS NOT INITIAL AND
     et_data       IS INITIAL.

    retrieve(
      EXPORTING
        iv_node_key             = ls_assoc-target_node_key
        it_key                  = et_target_key
        iv_state                = iv_state
        iv_fill_data            = iv_fill_data
        iv_within_loading       = iv_within_loading
          iv_loading_node_key     = iv_loading_node_key
        it_requested_attributes = it_requested_attributes
      IMPORTING
        et_failed_key           = lt_failed_key
        et_data                 = et_data
        eo_message              = lo_message
        eo_change               = lo_change ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = et_target_key
            it_key_subset = lt_failed_key ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF lo_change IS BOUND.
      IF eo_change IS NOT BOUND.
        eo_change = lo_change.
      ELSE.
        eo_change->merge( lo_change ).
      ENDIF.
    ENDIF.

*   update failed keys
    LOOP AT lt_failed_key INTO ls_key.
      LOOP AT et_key_link INTO ls_key_link USING KEY target_key WHERE target_key = ls_key-key.
        DELETE et_key_link USING KEY loop_key.
      ENDLOOP.
      DELETE et_target_key USING KEY key_sort WHERE key = ls_key-key.
    ENDLOOP.

    " do det after loading and state handling
    IF eo_change IS BOUND.

      after_loading(
        EXPORTING
          io_change         = eo_change
          iv_within_loading = iv_within_loading
            iv_loading_node_key = iv_loading_node_key
          iv_load_state     = iv_state
        IMPORTING
          eo_message        = lo_message
          et_loaded_node    = lt_node_loaded
          et_failed_node    = lt_failed_node ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      " update exporting parameters
      LOOP AT lt_failed_node INTO ls_node.
        DELETE et_target_key USING KEY key_sort WHERE key = ls_node-key.
        READ TABLE et_key_link INTO ls_key_link WITH KEY target_key
          COMPONENTS target_key = ls_node-key.
        CHECK sy-subrc = 0.
        DELETE et_key_link INDEX sy-tabix USING KEY target_key.
      ENDLOOP.

    ENDIF.

  ENDIF.

ENDMETHOD.


METHOD retrieve_subtree_property.

  DATA: ls_nodeconf             TYPE /bobf/s_confro_node,
        lv_node_key             TYPE /bobf/obm_node_key,
        lt_assoc                TYPE /bobf/t_confro_assoc,
        ls_assoc                TYPE /bobf/s_confro_assoc,
        lt_key                  TYPE /bobf/t_frw_key,
        lt_key_link             TYPE /bobf/t_frw_key_link,
        lt_key_link2            TYPE /bobf/t_frw_key_link,
        lt_key_link3            TYPE /bobf/t_frw_key_link,
        ls_key_link             TYPE /bobf/s_frw_key_link,
        ls_key_link2            TYPE /bobf/s_frw_key_link,
        lt_target_key           TYPE /bobf/t_frw_key,
        lv_recursion            TYPE boole_d,
        ls_property_parameter   TYPE /bobf/s_frw_c_property,
        ls_property_parameter_r TYPE REF TO /bobf/s_frw_c_property,
        lt_property             TYPE /bobf/t_frw_property_k,
        lt_property_own         TYPE /bobf/t_frw_property_k,
        ls_property             TYPE /bobf/s_frw_property_k,
        lv_parent_key           TYPE /bobf/conf_key,
        lo_message              TYPE REF TO /bobf/if_frw_message.

  CLEAR: et_property, eo_message.

  IF mo_conf->ms_last_node-node_key = iv_node_key.
    ls_nodeconf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
       EXPORTING iv_node_key = iv_node_key
       IMPORTING es_node     = ls_nodeconf ).
  ENDIF.

  ASSERT ID /bobf/frw CONDITION ls_nodeconf-subtree_property = abap_true
                             OR ls_nodeconf-subtree_property_node_key IS NOT INITIAL.

* determine next relevant node for subtree properties
  IF ls_nodeconf-subtree_property_node_key = mo_conf->ms_obj-root_node_key.
*   root node -> navigate to root node
    lv_recursion = abap_true.
    lv_node_key = mo_conf->ms_obj-root_node_key.

    get_root_key(
      EXPORTING
        iv_node_key         = iv_node_key
        it_key              = it_key
      IMPORTING
        et_key_link         = lt_key_link
        et_target_key       = lt_key ).

*   build key link
    IF it_key_link IS NOT INITIAL.
      lt_key_link2 = lt_key_link.
      CLEAR lt_key_link.
      LOOP AT it_key_link INTO ls_key_link.
        READ TABLE lt_key_link2 INTO ls_key_link2
          WITH KEY source_key = ls_key_link-target_key.
        ASSERT ID /bobf/frw CONDITION sy-subrc = 0.
        IF sy-subrc = 0.
          ls_key_link-target_key = ls_key_link2-target_key.
          INSERT ls_key_link INTO TABLE lt_key_link.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSEIF ls_nodeconf-subtree_property_node_key IS NOT INITIAL.
*   some parent node and not root -> navigate to relevant parent node
    lv_recursion = abap_true.
    lv_node_key = iv_node_key.
    lt_key      = it_key.
    lt_key_link = it_key_link.

    DO.
      mo_conf->get_assoc(
        EXPORTING
          iv_node_key  = lv_node_key
          iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
        IMPORTING
          es_assoc     = ls_assoc ).
      IF ls_assoc IS INITIAL.
*       problem in model
        ASSERT ID /bobf/frw_error CONDITION 0 = 1.         "#EC BOOL_OK
        lv_recursion = abap_false.
        EXIT.
      ENDIF.

      retrieve_by_association(
        EXPORTING
          iv_node_key          = lv_node_key
          it_key               = lt_key
          iv_association       = ls_assoc-assoc_key
          iv_state             = iv_state
        IMPORTING
          et_key_link          = lt_key_link2
          et_target_key        = lt_target_key
          eo_message           = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      ASSERT ID /bobf/frw_error CONDITION
         /bobf/cl_tool_assert=>is_key_link_matching(
             it_key_link   = lt_key_link2
             it_key        = lt_key
             it_target_key = lt_target_key ) = abap_true.

      lv_node_key = ls_assoc-target_node_key.
      lt_key      = lt_target_key.

*     build key link
      IF lt_key_link IS INITIAL.
        lt_key_link = lt_key_link2.
      ELSE.
        lt_key_link3 = lt_key_link.
        CLEAR lt_key_link.
        LOOP AT lt_key_link3 INTO ls_key_link.
          READ TABLE lt_key_link2 INTO ls_key_link2
            WITH KEY source_key = ls_key_link-target_key.
          ASSERT ID /bobf/frw CONDITION sy-subrc = 0.
          IF sy-subrc = 0.
            ls_key_link-target_key = ls_key_link2-target_key.
            INSERT ls_key_link INTO TABLE lt_key_link.
          ENDIF.
        ENDLOOP.
      ENDIF.

*     relevant node reached
      IF ls_assoc-target_node_key = ls_nodeconf-subtree_property_node_key.
        EXIT.
      ENDIF.
    ENDDO.
  ENDIF.

* start recursion to determine subtree properties
  IF lv_recursion = abap_true.
    retrieve_subtree_property(
      EXPORTING
        iv_node_key = lv_node_key
        it_key      = lt_key
        it_key_link = lt_key_link
        iv_state    = iv_state
      IMPORTING
        et_property = lt_property
        eo_message  = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
  ENDIF.

* retrieve subtree properties
  IF ls_nodeconf-subtree_property = abap_true.
*   get association to property node
    mo_conf->get_assoc(
     EXPORTING
       iv_node_key   = iv_node_key
       iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_property
       iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
     IMPORTING
       es_assoc      = ls_assoc ).
    IF ls_assoc IS INITIAL.
*     no property node defined
      ASSERT ID /bobf/frw CONDITION 0 = 1.                 "#EC BOOL_OK
      ASSERT ID /bobf/frw_error CONDITION
         /bobf/cl_tool_assert=>access_stack_stack_check(
             it_access_stack = mt_access_stack ) = abap_true.
    ELSE.
*     determine subtree properties
      CLEAR ls_property_parameter.
      ls_property_parameter-all_subtree_property = abap_true.
      GET REFERENCE OF ls_property_parameter INTO ls_property_parameter_r.

      retrieve_by_association(
        EXPORTING
          iv_node_key                 = iv_node_key
          it_key                      = it_key
          iv_association              = ls_assoc-assoc_key
          is_parameters               = ls_property_parameter_r
          iv_state                    = iv_state
          iv_buffer_only              = abap_false
          iv_fill_data                = abap_true
          iv_fill_failed_key          = abap_true
          iv_with_det_before_retrieve = iv_determine_property
        IMPORTING
          et_data                     = lt_property_own
          eo_message                  = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.
  ENDIF.

* calculate specific properties and link properties to origin node
  IF iv_resolve_property = abap_true.
    IF iv_assoc_property = abap_true OR it_assoc IS NOT INITIAL.
      mo_conf->get_assoc_tab( IMPORTING et_assoc = lt_assoc ).
    ENDIF.
    APPEND LINES OF lt_property_own TO lt_property.

    LOOP AT lt_property INTO ls_property.
*     check for subtree property
      IF ls_property-content_cat <> /bobf/if_conf_c=>sc_content_subtree.
*       only subtree properties should be calculated and returned!
        ASSERT ID /bobf/frw_error CONDITION 0 = 1.         "#EC BOOL_OK
        CONTINUE.
      ENDIF.
*     set node properties
      IF ls_property-property_name = /bobf/if_conf_c=>sc_property_name_update_enable OR
         ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable.

        IF iv_node_property = abap_true.
          ls_property-content_cat   = /bobf/if_conf_c=>sc_content_nod.
          ls_property-content_key   = iv_node_key.
          IF it_key_link IS INITIAL.
            ls_property-key = /bobf/cl_frw_factory=>get_new_transient_key( ).
            INSERT ls_property INTO TABLE et_property.
          ELSE.
            lv_parent_key             = ls_property-parent_key.
            LOOP AT lt_key_link INTO ls_key_link USING KEY target_key
              WHERE target_key = lv_parent_key.
              ls_property-parent_key  = ls_key_link-source_key.
              ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
              INSERT ls_property INTO TABLE et_property.
            ENDLOOP.
          ENDIF.
        ENDIF.

*     set association property
      ELSEIF ls_property-property_name = /bobf/if_conf_c=>sc_property_name_create_enable.

        IF ( iv_assoc_property = abap_true OR it_assoc IS NOT INITIAL ).
          ls_property-content_cat = /bobf/if_conf_c=>sc_content_ass.

          IF it_assoc IS INITIAL.
*           all association properties
            lv_parent_key = ls_property-parent_key.
            LOOP AT lt_assoc INTO ls_assoc USING KEY key2 WHERE source_node_key = iv_node_key.
              CHECK ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_root
                AND ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent.
              IF it_key_link IS INITIAL.
                ls_property-content_key = ls_assoc-assoc_key.
                ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                INSERT ls_property INTO TABLE et_property.
              ELSE.
                LOOP AT lt_key_link INTO ls_key_link USING KEY target_key
                  WHERE target_key = lv_parent_key.
                  ls_property-parent_key  = ls_key_link-source_key.
                  ls_property-content_key = ls_assoc-assoc_key.
                  ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                  INSERT ls_property INTO TABLE et_property.
                ENDLOOP.
              ENDIF.
            ENDLOOP.
          ELSE.
*           only selected associations
            LOOP AT lt_assoc INTO ls_assoc USING KEY key2
              WHERE source_node_key = iv_node_key.
              READ TABLE it_assoc TRANSPORTING NO FIELDS
                WITH KEY key_sort COMPONENTS table_line = ls_assoc-assoc_key.
              CHECK sy-subrc = 0.
              IF it_key_link IS INITIAL.
                ls_property-content_key = ls_assoc-assoc_key.
                ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                INSERT ls_property INTO TABLE et_property.
              ELSE.
                lv_parent_key = ls_property-parent_key.
                LOOP AT lt_key_link INTO ls_key_link USING KEY target_key
                  WHERE target_key = lv_parent_key.
                  ls_property-parent_key  = ls_key_link-source_key.
                  ls_property-content_key = ls_assoc-assoc_key.
                  ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                  INSERT ls_property INTO TABLE et_property.
                ENDLOOP.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ELSE.
*       unknown property name used with subtree
        ASSERT ID /bobf/frw_error CONDITION 0 = 1.         "#EC BOOL_OK
      ENDIF.
    ENDLOOP.
  ELSE.
    et_property = lt_property.
    IF it_key_link IS INITIAL.
      APPEND LINES OF lt_property_own TO et_property.
    ELSE.
      LOOP AT lt_property_own INTO ls_property.
        lv_parent_key = ls_property-parent_key.
        LOOP AT it_key_link INTO ls_key_link USING KEY target_key
          WHERE target_key = lv_parent_key.
          ls_property-parent_key = ls_key_link-source_key.
          ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
          INSERT ls_property INTO TABLE et_property.
        ENDLOOP.
      ENDLOOP.
    ENDIF.
  ENDIF.

ENDMETHOD.


 METHOD set_application_error.

   DATA:
     lx_previous                TYPE REF TO cx_root,        "#EC NEEDED
     lv_previous_text           TYPE        string,         "#EC NEEDED
     lx_pre_previous            TYPE REF TO cx_root,        "#EC NEEDED
     lv_pre_previous_text       TYPE        string,         "#EC NEEDED
     lv_prev_progname           TYPE        syrepid,        "#EC NEEDED
     lv_prev_inclname           TYPE        syrepid,        "#EC NEEDED
     lv_prev_line               TYPE        i,              "#EC NEEDED
     lv_pre_prev_progname       TYPE        syrepid,        "#EC NEEDED
     lv_pre_prev_inclname       TYPE        syrepid,        "#EC NEEDED
     lv_pre_prev_line           TYPE        i,              "#EC NEEDED
     lo_exception               TYPE REF TO cx_root,        "#EC NEEDED
     lo_exception_bopf          TYPE REF TO /bobf/cx_frw,   "#EC NEEDED
     lv_application_information TYPE        string.         "#EC NEEDED

   FIELD-SYMBOLS:
     <lv_application_information> TYPE string.              "#EC NEEDED

   ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.              "#EC BOOL_OK
   mv_application_error = abap_true.

   " get application information (if there is one defined)
   " earliest application information wins
   lo_exception = io_exception.
   WHILE lo_exception IS BOUND.
     TRY.
         lo_exception_bopf ?= lo_exception.
       CATCH cx_sy_move_cast_error.
         IF lo_exception->previous IS BOUND.
           lo_exception = lo_exception->previous.
         ELSE.
           EXIT.
         ENDIF.
         CONTINUE.
     ENDTRY.
     ASSIGN lo_exception_bopf->('MV_APPLICATION_INFORMATION') TO <lv_application_information>.
     IF sy-subrc = 0 AND <lv_application_information> IS NOT INITIAL.
       lv_application_information = <lv_application_information>.
     ENDIF.
     IF lo_exception->previous IS BOUND.
       lo_exception = lo_exception->previous.
     ELSE.
       EXIT.
     ENDIF.
   ENDWHILE.

   IF io_exception IS BOUND AND io_exception->previous IS BOUND.
     lx_previous = io_exception->previous.
     lv_previous_text = lx_previous->get_text( ).
     lx_previous->get_source_position(
      IMPORTING
        program_name = lv_prev_progname
        include_name = lv_prev_inclname
        source_line  = lv_prev_line ).
     IF lx_previous->previous IS BOUND.
       lx_pre_previous = lx_previous->previous.
       lv_pre_previous_text = lx_pre_previous->get_text( ).
       lx_previous->get_source_position(
        IMPORTING
          program_name = lv_pre_prev_progname
          include_name = lv_pre_prev_inclname
          source_line  = lv_pre_prev_line ).
     ENDIF.
   ENDIF.

   DATA lx_frw_fatal TYPE REF TO /bobf/cx_frw_fatal.
   CREATE OBJECT lx_frw_fatal
     EXPORTING
       textid                  = /bobf/cx_frw_fatal=>sc_application_error
       previous                = io_exception
       mv_bo_name              = mo_conf->ms_obj-bo_name
       mv_proxy_bo_name        = mo_conf->ms_obj-bo_esr_name
       application_information = lv_application_information.

   lx_frw_fatal->message_type_x( ).

 ENDMETHOD.


 METHOD set_configuration_error.

   DATA:
     lx_previous           TYPE REF TO cx_root,
     lv_previous_text      TYPE        string,              "#EC NEEDED
     lx_pre_previous       TYPE REF TO cx_root,             "#EC NEEDED
     lv_pre_previous_text  TYPE        string,              "#EC NEEDED
     lv_prev_progname      TYPE        syrepid,             "#EC NEEDED
     lv_prev_inclname      TYPE        syrepid,             "#EC NEEDED
     lv_prev_line          TYPE        i,                   "#EC NEEDED
     lv_pre_prev_progname  TYPE        syrepid,             "#EC NEEDED
     lv_pre_prev_inclname  TYPE        syrepid,             "#EC NEEDED
     lv_pre_prev_line      TYPE        i.                   "#EC NEEDED


   ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.              "#EC BOOL_OK
   mv_configuration_error = abap_true.

   IF io_exception IS BOUND AND io_exception->previous IS BOUND.
     lx_previous = io_exception->previous.
     lv_previous_text = lx_previous->get_text( ).
     lx_previous->get_source_position(
      IMPORTING
        program_name = lv_prev_progname
        include_name = lv_prev_inclname
        source_line  = lv_prev_line ).
     IF lx_previous->previous IS BOUND.
       lx_pre_previous = lx_previous->previous.
       lv_pre_previous_text = lx_pre_previous->get_text( ).
       lx_previous->get_source_position(
        IMPORTING
          program_name = lv_pre_prev_progname
          include_name = lv_pre_prev_inclname
          source_line  = lv_pre_prev_line ).
     ENDIF.
   ENDIF.

   DATA lx_frw_fatal TYPE REF TO /bobf/cx_frw_fatal.
   CREATE OBJECT lx_frw_fatal
     EXPORTING
       textid           = /bobf/cx_frw_fatal=>sc_configuration_error
       previous         = io_exception
       mv_bo_name       = mo_conf->ms_obj-bo_name
       mv_proxy_bo_name = mo_conf->ms_obj-bo_esr_name.

   lx_frw_fatal->message_type_x( ).

 ENDMETHOD.


METHOD set_consistency_status.

  DATA: ls_group        TYPE /bobf/s_frw_group,
        lt_consistency  TYPE /bobf/t_frw_consistency,
        ls_consistency  TYPE /bobf/s_frw_consistency,
        lo_int_access   TYPE REF TO /bobf/cl_frw_int_access,
        lv_content_cat  TYPE string,
        lo_message      TYPE REF TO /bobf/if_frw_message,
        lo_msg_dummy    TYPE REF TO /bobf/if_frw_message,   "#EC NEEDED
        lo_change_dummy TYPE REF TO /bobf/if_frw_change,    "#EC NEEDED
        lx_frw          TYPE REF TO /bobf/cx_frw_core,
        lx_root         TYPE REF TO cx_root.

  CLEAR eo_message.

* ___________________________________________________________________________ *
* convert tables
  CHECK it_group IS NOT INITIAL.
  LOOP AT it_group INTO ls_group.
    IF ls_group-group_key <> mo_conf->ms_last_group-group_key.
      mo_conf->get_group( iv_group_key = ls_group-group_key ).
    ENDIF.

    ls_consistency-node_key        = mo_conf->ms_last_group-node_key.
    ls_consistency-key             = ls_group-key.
    ls_consistency-act_key         = mo_conf->ms_last_group-act_key.
    ls_consistency-sta_var_key     = mo_conf->ms_last_group-sta_var_key.
    ls_consistency-consistent      = ls_group-status_value.
    ls_consistency-status_variable = mo_conf->ms_last_group-sta_var->sta_var_esr_name.
    APPEND ls_consistency TO lt_consistency.
  ENDLOOP.

* ___________________________________________________________________________ *
* write status to status adapter
  /bobf/cl_frw_int_access=>new_instance(
    EXPORTING
      io_bopf            =  me   " Framework Main Class
      io_conf            =  mo_conf
      io_buffer          =  mo_buffer
      io_change          =  io_change
   RECEIVING
      eo_internal_access =  lo_int_access
  ).
  lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).
  lo_int_access->set_last_state(    iv_last_state = /bobf/if_conf_c=>sc_state_current ).
  lo_int_access->set_context(
    EXPORTING
      iv_read_allowed   = abap_true
      iv_modify_allowed = abap_true ).

  ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
  INSERT lo_int_access INTO mt_access_stack INDEX 1.

* get status adapter
  IF mo_sam IS NOT BOUND.
    TRY.
        CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
          EXPORTING
            iv_bo_key = mo_conf->ms_obj-bo_key.

      CATCH cx_sy_create_object_error INTO lx_root.
        lv_content_cat = TEXT-004.
        CREATE OBJECT lx_frw
          EXPORTING
            previous       = lx_root
            textid         = /bobf/cx_frw_core=>sc_no_instance
            mv_classname   = mo_conf->ms_obj-status_class
            mv_content_cat = lv_content_cat.
        set_application_error( lx_frw ).
    ENDTRY.
    ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
  ENDIF.

  TRY.
      DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
      mo_sam->set_consistency_status(
        EXPORTING
          it_consistency = lt_consistency
          io_read        = lo_int_access
          io_modify      = lo_int_access
        IMPORTING
          eo_message     = lo_message ).
      /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      set_application_error( lx_root ).
  ENDTRY.

  collect_messages( EXPORTING io_message = lo_message
                    CHANGING  co_message = eo_message ).

* check for undone modifications and flush
  IF lo_int_access->mt_modification IS NOT INITIAL.
    lo_int_access->end_modify(
      EXPORTING
        iv_check_for_failed = abap_false ).
  ENDIF.
  collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                    CHANGING  co_message = eo_message ).
  lo_int_access->invalidate( ).

  ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
  DELETE mt_access_stack INDEX 1.

ENDMETHOD.


METHOD set_draft_consistency_status.

*  DATA ls_node_inst_key TYPE /bobf/s_frw_key.
*  DATA lr_node_table_type   TYPE REF TO data.
*  DATA lt_inconsistent_root_key TYPE SORTED TABLE OF /bobf/s_frw_key WITH NON-UNIQUE KEY key.
*  DATA lt_root_key_collection TYPE /bobf/t_frw_key.
*  DATA ls_consistency_node TYPE ty_dra_consistency_failed_node.
*  DATA lt_consistency_node TYPE tt_dra_consistency_failed_node.
*  DATA lt_modification  type /bobf/t_frw_modification.
*  DATA lx_root TYPE REF TO cx_root.
*  DATA lr_root_data type REF TO data.
*
*  FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
*  FIELD-SYMBOLS <ls_root_data> TYPE DATA.
*  FIELD-SYMBOLS <lv_consistency_status> TYPE data.
*
*
*  DATA(ls_root_node_conf) = mo_conf->get_root_node( ).
*
*  CREATE DATA lr_root_data type (ls_root_node_conf-data_type).
*  ASSIGN lr_root_data->* to <ls_root_data>.
*  ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_cons_status of STRUCTURE <ls_root_data> to <lv_consistency_status>.
*  IF sy-subrc IS NOT INITIAL.
*    " The root node doesn't has the consistency status field -> nothing to do
*    RETURN.
*  ENDIF.
*
*
*  mo_conf->get_validation( IMPORTING et_val_list = DATA(lt_val_list) ).
*
*  " Set the inconsistent for validation failed instance. Set the inconsistency on the root instance
*  LOOP AT it_failed_val INTO DATA(ls_failed_val).
*    READ TABLE lt_val_list INTO DATA(ls_validation) WITH KEY val_key = ls_failed_val-val_key.
*
*    ls_node_inst_key-key = ls_failed_val-key.
*
*    READ TABLE lt_consistency_node ASSIGNING FIELD-SYMBOL(<ls_consistency_node>) WITH KEY node_key = ls_validation-node_key.
*
*    IF sy-subrc = 0.
*      APPEND ls_node_inst_key TO <ls_consistency_node>-keys.
*    ELSE.
*      ls_consistency_node-node_key = ls_validation-node_key.
*      APPEND ls_node_inst_key TO ls_consistency_node-keys.
*      APPEND ls_consistency_node TO lt_consistency_node.
*    ENDIF.
*  ENDLOOP.
*
*  LOOP AT lt_consistency_node INTO ls_consistency_node.
*    " TODO: Does this work also for root keys?
*    get_root_key( EXPORTING iv_node_key     = ls_consistency_node-node_key
*                            it_key          = ls_consistency_node-keys
*                  IMPORTING et_target_key   = DATA(lt_root_key) ).
*
*    INSERT LINES OF lt_root_key INTO TABLE lt_root_key_collection.
*  ENDLOOP.
*
*  SORT lt_root_key_collection.
*  DELETE ADJACENT DUPLICATES FROM lt_root_key_collection.
*
*  LOOP AT lt_root_key_collection into DATA(ls_inconsistent_root).
*    CREATE DATA lr_root_data type (ls_root_node_conf-data_type).
*    ASSIGN lr_root_data->* to <ls_root_data>.
*    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_cons_status of STRUCTURE <ls_root_data> to <lv_consistency_status>.
*    <lv_consistency_status> = /bobf/if_frw_c=>sc_status_inconsistent.
*    APPEND VALUE #( node           = ls_root_node_conf-node_key
*                    key            = ls_inconsistent_root-key
*                    change_mode    = /bobf/if_frw_c=>sc_modify_update
*                    data           = lr_root_data
*                    changed_fields = VALUE /bobf/t_frw_name( ( CONV #( /bobf/if_conf_c=>sc_attribute_name_cons_status ) ) ) )
*      TO lt_modification.
*
*      APPEND ls_inconsistent_root to lt_inconsistent_root_key.
*  ENDLOOP.
*
*  " Set as consistent for the remaining root instance
*  CLEAR lt_root_key.
*  get_root_key( EXPORTING iv_node_key     = iv_node_key
*                          it_key          = it_key
*                IMPORTING et_target_key   = lt_root_key ).
*
*  lt_root_key = FILTER #( lt_root_key EXCEPT IN lt_inconsistent_root_key WHERE key = key ).
*  <lv_consistency_status> = /bobf/if_frw_c=>sc_status_consistent.
*  LOOP AT lt_root_key into data(ls_root_key).
*    CREATE DATA lr_root_data type (ls_root_node_conf-data_type).
*    ASSIGN lr_root_data->* to <ls_root_data>.
*    ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_cons_status of STRUCTURE <ls_root_data> to <lv_consistency_status>.
*    <lv_consistency_status> = /bobf/if_frw_c=>sc_status_consistent.
*    APPEND VALUE #( node           = ls_root_node_conf-node_key
*                    key            = ls_root_key-key
*                    root_key       = ls_root_key-key
*                    change_mode    = /bobf/if_frw_c=>sc_modify_update
*                    data           = lr_root_data
*                    changed_fields = VALUE /bobf/t_frw_name( ( CONV #( /bobf/if_conf_c=>sc_attribute_name_cons_status ) ) ) )
*          TO lt_modification.
*  ENDLOOP.
*
*  " Do the modification
*  do_modify(
*    EXPORTING
*      it_modification    = lt_modification
*      iv_internal_modify = ABAP_true
*      iv_within_loading  = ABAP_FALSE    " TODO: Correct?
*      iv_within_retrieve = ABAP_FALSE    " TODO: Correct?
*      iv_state           = /BOBF/IF_CONF_C=>SC_STATE_CURRENT
*    IMPORTING
*      eo_message         = DATA(lo_message)
*      eo_change          = DATA(lo_change) ).

  "TODO: What do we do with lo_message and lo_change?

ENDMETHOD.


METHOD set_node_category.

  DATA: ls_nodeconf          TYPE /bobf/s_confro_node,
        ls_node_class        TYPE ty_node,
        lt_key               TYPE /bobf/t_frw_key,
        ls_key               TYPE /bobf/s_frw_key,
        lt_node              TYPE /bobf/t_frw_node,
        ls_node              TYPE /bobf/s_frw_node,
        ls_node_failed       TYPE /bobf/s_frw_node,
        ls_context           TYPE /bobf/s_frw_ctx_node,
        lt_node_category     TYPE /bobf/t_frw_node_cat,
        ls_node_category     TYPE /bobf/s_frw_node_cat,
        lt_modification      TYPE /bobf/t_frw_modification,
        ls_modification      TYPE /bobf/s_frw_modification,
        lv_content_cat       TYPE string,
        lv_content_name      TYPE /bobf/obm_name,
        lo_change            TYPE REF TO /bobf/if_frw_change,
        lo_int_access        TYPE REF TO /bobf/cl_frw_int_access,
        lx_frw               TYPE REF TO /bobf/cx_frw_core,
        lx_root              TYPE REF TO cx_root,
        lv_class             TYPE seoclsname,
        lv_application_info  TYPE string.


  CLEAR et_failed.

  LOOP AT it_node INTO ls_node.
    ls_key-key = ls_node-key.
    APPEND ls_key TO lt_key.

    AT END OF node.
*     read node and call node class if available
      IF mo_conf->ms_last_node-node_key = ls_node-node.
        ls_nodeconf = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_node-node
          IMPORTING es_node     = ls_nodeconf ).
      ENDIF.

      IF ls_nodeconf-node_class IS NOT INITIAL.
        TRY.
*           get node class
            READ TABLE mt_node
               WITH TABLE KEY node_key = ls_nodeconf-node_key
               INTO ls_node_class.
            IF sy-subrc <> 0.
              ls_node_class-node_key = ls_nodeconf-node_key.
              CREATE OBJECT ls_node_class-class TYPE (ls_nodeconf-node_class).
              INSERT ls_node_class INTO TABLE mt_node.
            ENDIF.

            IF lo_int_access IS NOT BOUND.
              /bobf/cl_frw_int_access=>new_instance(
                EXPORTING
                  io_bopf            = me
                  io_conf            = mo_conf
                  io_buffer          = mo_buffer    " Interface to the Data Layer
                RECEIVING
                  eo_internal_access = lo_int_access
              ).
              lo_int_access->set_current_state( /bobf/if_conf_c=>sc_state_current ).
            ENDIF.
            ls_context-bo_key        = mo_conf->ms_obj-bo_key.
            ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
            ls_context-node_key      = ls_nodeconf-node_key.
            lo_int_access->set_context( iv_read_allowed   = abap_true
                                        iv_modify_allowed = abap_false ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_node_class-class->set_node_category(
              EXPORTING
                is_ctx                       = ls_context
                it_key                       = lt_key
                io_read                      = lo_int_access
              IMPORTING
                et_node_category             = lt_node_category ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          CATCH cx_sy_dyn_call_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_node = abap_true
              iv_key  = ls_nodeconf-node_key ).
            lv_content_cat = text-006.
            CREATE OBJECT lx_frw
              EXPORTING
                textid          = /bobf/cx_frw_core=>sc_no_instance
                previous        = lx_root
                mv_method_name  = 'SET_NODE_CATEGORY'
                mv_content_name = lv_content_name
                mv_content_cat  = lv_content_cat.
            set_configuration_error( lx_frw ).

          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            lv_content_name = get_content_description(
              iv_node = abap_true
              iv_key  = ls_nodeconf-node_key ).
            lv_content_cat = text-006.
            lv_class = ls_nodeconf-node_class.
            lcl_error_text_provider=>get_text_impl_class_error(
              EXPORTING
                iv_content_cat      = /bobf/if_conf_c=>sc_content_nod
                iv_content_key      = ls_nodeconf-node_key
                iv_node_key         = ls_nodeconf-node_key
                iv_content_name     = lv_content_name
                iv_content_class    = lv_class
                iv_method_name      = 'SET_NODE_CATEGORY'
                io_configuration    = mo_conf
              RECEIVING
                rv_application_info = lv_application_info
            ).
            CREATE OBJECT lx_frw
              EXPORTING
                textid                     = /bobf/cx_frw_core=>sc_content_exception
                previous                   = lx_root
                mv_method_name             = 'SET_NODE_CATEGORY'
                mv_content_name            = lv_content_name
                mv_content_cat             = lv_content_cat
                mv_application_information = lv_application_info.
            set_application_error( lx_frw ).
        ENDTRY.

        lo_int_access->invalidate( ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.

*       write node categories into the buffer
        SORT lt_key.
        LOOP AT lt_node_category INTO ls_node_category.
          READ TABLE lt_key BINARY SEARCH TRANSPORTING NO FIELDS
            WITH KEY key = ls_node_category-key.
          IF sy-subrc <> 0.
*           node category determination returned a key that was not given in
            set_application_error( ).
          ENDIF.
          IF ls_node_category-node_cat_key IS NOT INITIAL.
            DELETE lt_key INDEX sy-tabix.
            ls_modification-node        = ls_nodeconf-node_key.
            ls_modification-key         = ls_node_category-key.
            ls_modification-change_mode = /bobf/if_frw_c=>sc_modify_set_node_category.
            ls_modification-node_cat    = ls_node_category-node_cat_key.
            APPEND ls_modification TO lt_modification.
          ENDIF.
        ENDLOOP.
*       add failed entries for keys that where not returned
        ls_node_failed-node = ls_node-node.
        LOOP AT lt_key INTO ls_key.
          ls_node_failed-key = ls_key-key.
          INSERT ls_node_failed INTO TABLE et_failed.
        ENDLOOP.

      ELSE.
*       no implementation available -> mark all instances as failed
        ls_node_failed-node = ls_node-node.
        LOOP AT lt_key INTO ls_key.
          ls_node_failed-key = ls_key-key.
          INSERT ls_node_failed INTO TABLE et_failed.
        ENDLOOP.
      ENDIF.

      CLEAR lt_key.

      "in case of internal access, it is expected that no errors occur here,
      "otherwise it is a programming error
      IF NOT et_failed IS INITIAL AND iv_internal_modify = abap_true.
        CREATE OBJECT lx_frw
          EXPORTING
            mv_application_information =
                lcl_error_text_provider=>get_text_node_cat_not_found(
                  iv_node_key      = ls_node-node
                  io_configuration = mo_conf ).

        set_application_error( lx_frw ).

      ENDIF.

    ENDAT.

  ENDLOOP.

* perform modifications in the buffer
  IF lt_modification IS NOT INITIAL.

    lo_change = /bobf/cl_frw_factory=>get_change( ).

    TRY.
        mo_buffer->modify(
          EXPORTING
            it_modification   = lt_modification
            io_change         = lo_change
            iv_state          = /bobf/if_conf_c=>sc_state_current
            iv_only_transient = abap_false
          IMPORTING
            eo_message        = eo_message ).

      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDIF.

ENDMETHOD.


  METHOD type_check.

    DATA lr_exp TYPE REF TO data.
    DATA lr_act TYPE REF TO data.
    DATA lv_exp_type TYPE c LENGTH 1.
    DATA lv_act_type TYPE c LENGTH 1.
    DATA lv_exp_components TYPE i.
    DATA lv_act_components TYPE i.
    DATA lx_frw_core TYPE REF TO /bobf/cx_frw_core.

    FIELD-SYMBOLS <ls_exp> TYPE any.
    FIELD-SYMBOLS <ls_act> TYPE any.

    CHECK gv_system_client_role <> 'P' ##NO_TEXT. "Don't perform check in productive client

    CREATE DATA lr_exp TYPE (iv_expected_line_type).
    CREATE DATA lr_act LIKE LINE OF it_data.
    ASSIGN lr_exp->* TO <ls_exp>.
    ASSIGN lr_act->* TO <ls_act>.
    DESCRIBE FIELD <ls_exp> TYPE lv_exp_type COMPONENTS lv_exp_components.
    DESCRIBE FIELD <ls_act> TYPE lv_act_type COMPONENTS lv_act_components.

    IF lv_exp_type <> lv_act_type OR lv_exp_components <> lv_act_components.
      CREATE OBJECT lx_frw_core
        EXPORTING
          textid         = /bobf/cx_frw_core=>sc_wrong_type_passed
          mv_bo_name     = mo_conf->ms_obj-bo_name
          mv_method_name = conv #( iv_service_name )
          mv_parameter   = iv_parameter_name
          mv_type        = cl_abap_typedescr=>describe_by_data( it_data )->get_relative_name( ).
      set_application_error(
          io_exception = lx_frw_core
      ).
    ENDIF.

  ENDMETHOD.


  METHOD unlock_lockable_nodes.
    DATA: lt_nodes_to_unlock TYPE /bobf/t_frw_node,
          ls_conf_node       TYPE /bobf/s_confro_node,
          ls_frw_node        TYPE /bobf/s_frw_node,
          lo_change          TYPE REF TO /bobf/if_frw_change,
          lo_message         TYPE REF TO /bobf/if_frw_message.

    LOOP AT it_nodes INTO ls_frw_node.
      AT NEW node.
        mo_conf->get_node( EXPORTING iv_node_key = ls_frw_node-node
                           IMPORTING es_node     = ls_conf_node ).
      ENDAT.
      IF ls_conf_node-lockable = abap_true.
        INSERT ls_frw_node INTO TABLE lt_nodes_to_unlock.
      ENDIF.
    ENDLOOP.

    lo_change = /bobf/cl_frw_factory=>get_change( ).
    mo_lock_manager->unlock( EXPORTING it_node    = lt_nodes_to_unlock
                                       iv_generic = abap_true
                                       io_change  = lo_change
                             IMPORTING eo_message = lo_message ).
  ENDMETHOD.


  METHOD val_time_to_processing_mode.

    rv_processing_mode = SWITCH #( iv_val_time
                                   WHEN /bobf/if_conf_c=>sc_val_time_check OR
                                        /bobf/if_conf_c=>sc_val_time_check_and_determ  THEN /bobf/if_frw_c=>sc_mode_check_and_determine
                                   WHEN /bobf/if_conf_c=>sc_val_time_check_before_save THEN /bobf/if_frw_c=>sc_mode_check_before_save
                                   WHEN /bobf/if_conf_c=>sc_val_time_finalize          THEN /bobf/if_frw_c=>sc_mode_finalize
                                   ELSE                                                     /bobf/if_frw_c=>sc_mode_modify ).

  ENDMETHOD.
ENDCLASS.