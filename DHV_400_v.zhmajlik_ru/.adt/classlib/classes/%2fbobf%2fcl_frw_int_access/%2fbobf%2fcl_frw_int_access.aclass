class /BOBF/CL_FRW_INT_ACCESS definition
  public
  create public

  global friends /BOBF/CL_FRW
                 /BOBF/CL_FRW_AUTHORITY_HANDLER
                 /BOBF/CL_LIB_AUTHORITY_CHECK
                 /BOBF/CL_LIB_DURABLE_LOCK_MNGR
                 /BOBF/CL_TOOL_ASSERT
                 /BOBF/CL_TOOL_AUNIT_ACTION_TDC
                 /BOBF/CL_TOOL_DEBUG_ADDON
                 /BOBF/CL_TOOL_FRW_TOOLBOX .

public section.

  interfaces /BOBF/IF_FRW_MODIFY .
  interfaces /BOBF/IF_FRW_READ .
  interfaces /BOBF/IF_FRW_CHECK .
  interfaces /BOBF/IF_FRW_QUERY .

  class-methods NEW_INSTANCE
    importing
      !IO_BOPF type ref to /BOBF/CL_FRW
      !IO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION
      !IO_BUFFER type ref to /BOBF/IF_FRW_BUFFER
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional
      !IV_CLASS_NAME type SEOCLSNAME default '/BOBF/CL_FRW_INT_ACCESS'
    returning
      value(EO_INTERNAL_ACCESS) type ref to /BOBF/CL_FRW_INT_ACCESS .
      "! Returns the instance on the top of the access stack of IO_BOPF.<br/>
      "! May dump if no such instance exists.  Consumers should know what they are doing.
  class-methods CURRENT_INSTANCE
    importing
      !IO_BOPF type ref to /BOBF/CL_FRW
    returning
      value(RO_INSTANCE) type ref to /BOBF/CL_FRW_INT_ACCESS .
  methods CONSTRUCTOR
    importing
      !IO_BOPF type ref to /BOBF/CL_FRW
      !IO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION
      !IO_BUFFER type ref to /BOBF/IF_FRW_BUFFER
      !IO_CHANGE type ref to /BOBF/IF_FRW_CHANGE optional .
protected section.

  types:
    BEGIN OF ty_modification_ctx,
        act_key   TYPE /bobf/act_key,
        det_key   TYPE /bobf/det_key,
        assoc_key TYPE /bobf/obm_assoc_key,
        query_key TYPE /bobf/obm_query_key,
      END OF ty_modification_ctx .
  types:
    tt_modification_ctx TYPE STANDARD TABLE OF ty_modification_ctx WITH EMPTY KEY .

*"* protected components of class /BOBF/CL_FRW_INT_ACCESS
*"* do not include other source files here!!!
  data MO_BOPF type ref to /BOBF/CL_FRW .
  data MO_BUFFER type ref to /BOBF/IF_FRW_BUFFER .
  data MO_CHANGE type ref to /BOBF/IF_FRW_CHANGE .
  data MO_CONF type ref to /BOBF/IF_FRW_CONFIGURATION .
  data MO_LOCAL_CHANGE type ref to /BOBF/IF_FRW_CHANGE .
  data MO_LOCAL_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE .
  data MS_ASSOCIATION type /BOBF/S_FRW_CTX_ASSOC .
  data MT_MODIFICATION type /BOBF/T_FRW_MODIFICATION .
  data MT_MODIFICATION_BOPF type /BOBF/T_FRW_MODIFICATION .
  data MV_CURRENT_STATE type /BOBF/CONF_STATE .
  data MV_EDIT_MODE type /BOBF/CONF_EDIT_MODE .
  data MV_INVALIDATE_CACHE type BOOLE_D .
  data MV_LAST_STATE type /BOBF/CONF_STATE .
  data MV_VALID_IF_CHECK type BOOLE_D .
  data MV_VALID_IF_MODIFY type BOOLE_D .
  data MV_VALID_IF_QUERY type BOOLE_D .
  data MV_VALID_IF_READ type BOOLE_D .
  data MV_WITHIN_LOADING type BOOLE_D .
  data MV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY .
  data MV_WITHIN_RETRIEVE type BOOLE_D .
  data MR_ADDON_REFERENCE type ref to /BOBF/CL_FRW_INT_ACCESS .

  methods END_MODIFY
    importing
      !IV_PROCESS_IMMEDIATELY type BOOLE_D default ABAP_FALSE
      !IV_CHECK_FOR_FAILED type BOOLE_D default ABAP_TRUE
    exporting
      !EO_CHANGE type ref to /BOBF/IF_FRW_CHANGE .
  methods INVALIDATE
    exporting
      !ET_MOD type /BOBF/T_FRW_MODIFICATION .
  methods NOTIFY_CHANGE_INTERNAL
    importing
      !IV_NODE_KEY type /BOBF/OBM_NODE_KEY
      !IV_KEY type /BOBF/CONF_KEY optional
      !IT_KEY type /BOBF/T_FRW_KEY optional
      !IV_CHANGE_MODE type /BOBF/CONF_CHANGE_MODE default /BOBF/IF_FRW_C=>SC_MODIFY_UPDATE .
  methods SET_CONTEXT
    importing
      !IS_ACTION type /BOBF/S_FRW_CTX_ACT optional
      !IS_ASSOCIATION type /BOBF/S_FRW_CTX_ASSOC optional
      !IS_DETERMINATION type /BOBF/S_FRW_CTX_DET optional
      !IS_VALIDATION type /BOBF/S_FRW_CTX_VAL optional
      !IS_QUERY type /BOBF/S_FRW_CTX_QUERY optional
      !IV_READ_ALLOWED type BOOLE_D default ABAP_FALSE
      !IV_MODIFY_ALLOWED type BOOLE_D default ABAP_FALSE
      !IV_CHECK_ALLOWED type BOOLE_D default ABAP_FALSE
      !IV_QUERY_ALLOWED type BOOLE_D default ABAP_FALSE
      !IV_PROCESS_IMMEDIATELY_ALLOWED type BOOLE_D default ABAP_FALSE
      !IT_MOD type /BOBF/T_FRW_MODIFICATION optional
      !IV_READ_BUFFER_ONLY type BOOLE_D default ABAP_FALSE
      !IV_INVALIDATE_CACHE type BOOLE_D default ABAP_FALSE
      !IV_LOADING_NODE_KEY type /BOBF/OBM_NODE_KEY optional
      !IV_WITHIN_LOADING type BOOLE_D default ABAP_FALSE
      !IV_WITHIN_RETRIEVE type BOOLE_D default ABAP_FALSE .
  methods SET_CURRENT_STATE
    importing
      !IV_CURRENT_STATE type /BOBF/CONF_STATE .
  methods SET_EDIT_MODE
    importing
      !IV_EDIT_MODE type /BOBF/CONF_EDIT_MODE .
  methods SET_LAST_STATE
    importing
      !IV_LAST_STATE type /BOBF/CONF_STATE .
  methods CLEAR_MODIFICATIONS .
  methods COPY_MODIFICATIONS_FROM
    importing
      !IO_OTHER type ref to /BOBF/CL_FRW_INT_ACCESS .
private section.

*"* private components of class /BOBF/CL_FRW_INT_ACCESS
*"* do not include other source files here!!!
  aliases MV_PROCESS_IMMEDIATELY_ALLOWED
    for /BOBF/IF_FRW_MODIFY~MV_PROCESS_IMMEDIATELY_ALLOWED .
  aliases CREATE
    for /BOBF/IF_FRW_MODIFY~CREATE .
  aliases DELETE
    for /BOBF/IF_FRW_MODIFY~DELETE .
  aliases DO_ACTION
    for /BOBF/IF_FRW_MODIFY~DO_ACTION .
  aliases GET_ROOT_KEY
    for /BOBF/IF_FRW_READ~GET_ROOT_KEY .
  aliases RETRIEVE
    for /BOBF/IF_FRW_READ~RETRIEVE .
  aliases RETRIEVE_BY_ASSOCIATION
    for /BOBF/IF_FRW_READ~RETRIEVE_BY_ASSOCIATION .
  aliases UPDATE
    for /BOBF/IF_FRW_MODIFY~UPDATE .

  types:
    BEGIN OF ty_modification_ctx_validity.
        INCLUDE TYPE ty_modification_ctx.
    TYPES:
        valid_to TYPE syst-tabix,
      END OF ty_modification_ctx_validity .

  data MS_ACTION type /BOBF/S_FRW_CTX_ACT .
  data MS_DETERMINATION type /BOBF/S_FRW_CTX_DET .
  data MS_QUERY type /BOBF/S_FRW_CTX_QUERY .
  data MS_VALIDATION type /BOBF/S_FRW_CTX_VAL .
  data MV_PROCESSING_END_MODIFY type BOOLE_D .
  data MV_READ_BUFFER_ONLY type BOOLE_D .
  data MS_MODIFICATION_CTX type TY_MODIFICATION_CTX_VALIDITY .
  data:
    mt_modification_ctx TYPE STANDARD TABLE OF ty_modification_ctx_validity WITH EMPTY KEY .

  methods FLUSH_CHANGES
    returning
      value(EV_NO_ERROR) type BOOLE_D .
  methods CHANGE_USAGE_RESTRICTION
    importing
      !IV_CHECK_ALLOWED type ABAP_BOOL
    exporting
      !EV_PREVIOUS_CHECK_ALLOWED type ABAP_BOOL .
  methods RAISE_FAILED_CHANGE
    importing
      !IS_FAILED_CHANGE type /BOBF/S_FRW_CHANGE
      !IO_MESSAGE type ref to /BOBF/IF_FRW_MESSAGE
    raising
      /BOBF/CX_FRW_INT_ACCESS .
  methods SET_KEYS_FOR_CREATE_MODIFICTNS .
  methods UPDATE_MODIFICATION_CTX .
  methods DELETE_MODIFICATION
    importing
      value(IV_TABIX) type SYST-TABIX .
  methods GET_MODIFICATION_CTX
    importing
      !IV_NODE type /BOBF/OBM_NODE_KEY
      !IV_KEY type /BOBF/CONF_KEY
      !IV_CHANGE_MODE type /BOBF/CONF_CHANGE_MODE
    returning
      value(RESULT) type TT_MODIFICATION_CTX .
ENDCLASS.



CLASS /BOBF/CL_FRW_INT_ACCESS IMPLEMENTATION.


method /BOBF/IF_FRW_CHECK~CHECK_AND_DETERMINE.

  IF mv_valid_if_check = abap_false.
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

* we assume that this can only be called within the action-prepare!
  ASSERT ID /BOBF/FRW CONDITION mt_modification IS INITIAL.

  mo_bopf->check_and_determine(
    EXPORTING
      iv_node_key    = iv_node_key
      it_key         = it_key
      iv_check_scope = iv_check_scope
    IMPORTING
      eo_change      = eo_change
      eo_message     = eo_message ).

  mo_change->merge( eo_change ).

endmethod.


method /BOBF/IF_FRW_MODIFY~CREATE.

  DATA: ls_mod            TYPE /BOBF/S_FRW_MODIFICATION.
  FIELD-SYMBOLS:
    <ls_data>     TYPE any,
    <ls_mod_data> TYPE any.


  ASSERT ID /BOBF/FRW_ERROR CONDITION iv_node IS NOT INITIAL.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  ASSERT ID /BOBF/FRW_ERROR CONDITION /BOBF/CL_TOOL_ASSERT=>CREATE_CONSISTENT(
      io_conf        = mo_conf
      iv_node        = iv_node
      iv_key         = iv_key
      iv_source_node = iv_source_node_key
      iv_source_key  = iv_source_key
      iv_assoc_key   = iv_assoc_key ) = abap_true.

  ASSERT ID /BOBF/FRW_ERROR CONDITION /BOBF/CL_TOOL_ASSERT=>NEW_PROPERTIES_CONSISTENT(
      iv_node       = iv_node
      iv_parent_key = iv_source_key
      is_data       = is_data
      io_conf       = mo_conf
      io_bopf       = mo_bopf ) = abap_true.

* ____________________________________________________________________ *
* set key
  IF iv_key IS INITIAL.
    IF mo_conf->ms_last_node-node_key <> iv_node.
      mo_conf->get_node( iv_node_key = iv_node ).
    ENDIF.

    IF mo_conf->ms_last_node-key_inherited = abap_true.
      ASSERT ID /BOBF/FRW_ERROR CONDITION mo_conf->ms_last_node-parent_node_key = iv_source_node_key.
      ev_key = iv_source_key.
    ELSEIF mo_conf->ms_last_node-transient = abap_false.
      ev_key = /BOBF/CL_FRW_FACTORY=>GET_NEW_KEY( ).
    ELSE.
      ev_key = /BOBF/CL_FRW_FACTORY=>GET_NEW_TRANSIENT_KEY( ).
    ENDIF.
  ELSE.
    ev_key = iv_key.
  ENDIF.

* ____________________________________________________________________ *
* create modification entry
  ls_mod-node           = iv_node.
  ls_mod-node_cat       = iv_node_cat.
  ls_mod-key            = ev_key.
  ls_mod-change_mode    = /BOBF/IF_FRW_C=>SC_MODIFY_CREATE.
  ls_mod-changed_fields = it_changed_fields.
  IF is_data IS BOUND.
    ASSIGN is_data->* TO <ls_data>.
    IF sy-subrc = 0.
      CREATE DATA ls_mod-data LIKE <ls_data>.
      ASSIGN ls_mod-data->* TO <ls_mod_data>.
      <ls_mod_data>    = <ls_data>.
    ENDIF.
  ENDIF.
  ls_mod-association    = iv_assoc_key.
  ls_mod-source_node    = iv_source_node_key.
  ls_mod-source_key     = iv_source_key.
  ls_mod-root_key       = iv_root_key.
  APPEND ls_mod TO mt_modification.

  ASSERT ID /BOBF/FRW_FLUSH CONDITION flush_changes( ) = abap_true.

endmethod.


METHOD /bobf/if_frw_modify~delete.

  DATA: ls_mod             TYPE /bobf/s_frw_modification,
        ls_key             TYPE /bobf/s_frw_key.

  ASSERT ID /bobf/frw_error CONDITION iv_node IS NOT INITIAL.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  ls_mod-node        = iv_node.
  ls_mod-root_key    = iv_root_key.
  ls_mod-change_mode = /bobf/if_frw_c=>sc_modify_delete.

* ____________________________________________________________________ *
*   create modification entry
  IF iv_key IS NOT INITIAL.
    ls_mod-key         = iv_key.

    READ TABLE mt_modification WITH KEY change
     COMPONENTS node        = ls_mod-node
                change_mode = /bobf/if_frw_c=>sc_modify_create
                key         = ls_mod-key
     TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      end_modify( ).
    ELSE.
      READ TABLE mt_modification WITH KEY change
        COMPONENTS node        = ls_mod-node
                   change_mode = /bobf/if_frw_c=>sc_modify_update
                   key         = ls_mod-key
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        end_modify( ).
      ENDIF.
    ENDIF.
    APPEND ls_mod TO mt_modification.
  ENDIF.

  LOOP AT it_key INTO ls_key.
    ls_mod-key         = ls_key-key.

    READ TABLE mt_modification WITH KEY change
      COMPONENTS node        = ls_mod-node
                 change_mode = /bobf/if_frw_c=>sc_modify_create
                 key         = ls_mod-key
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
        delete_modification( sy-tabix ).
    ELSE.
      READ TABLE mt_modification WITH KEY change
        COMPONENTS node        = ls_mod-node
                   change_mode = /bobf/if_frw_c=>sc_modify_update
                   key         = ls_mod-key
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
          delete_modification( sy-tabix ).
      ENDIF.
      ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>modification_no_duplicate(
          it_modification     = mt_modification
          is_modification_new = ls_mod ) = abap_true.
      APPEND ls_mod TO mt_modification.
    ENDIF.
  ENDLOOP.

  ASSERT ID /bobf/frw_flush CONDITION flush_changes( ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_modify~do_action.

  DATA: ls_action      TYPE /bobf/s_frw_action.

  ASSERT ID /bobf/frw_error CONDITION iv_act_key IS NOT INITIAL.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

* ____________________________________________________________________ *
* check for modifications to flush
  IF mt_modification IS NOT INITIAL.
    end_modify( ).
  ENDIF.

* ____________________________________________________________________ *
* call framework for action
  ls_action-act_key         = iv_act_key.
  ls_action-key             = it_key.
  ls_action-parameters      = is_parameters.

  mo_bopf->do_action(
    EXPORTING
      is_action               = ls_action
      iv_with_detval          = abap_false
      iv_internal_call        = abap_true
      iv_within_loading       = mv_within_loading
      iv_loading_node_key     = mv_loading_node_key
    IMPORTING
      eo_message              = eo_message
      eo_change               = eo_change
      et_failed_key           = et_failed_key
      ev_static_action_failed = ev_static_action_failed
      et_data                 = et_data ).

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = ls_action-key
          it_key_subset = et_failed_key ) = abap_true.

  mo_change->merge( eo_change ).

ENDMETHOD.


METHOD /bobf/if_frw_modify~do_modify.

  CHECK it_modification IS NOT INITIAL.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  APPEND LINES OF it_modification TO mt_modification.

  ASSERT ID /bobf/frw_flush CONDITION flush_changes( ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_modify~end_modify.

  DATA lv_check_for_failed TYPE boole_d.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  CLEAR: eo_change,
         eo_message.

  IF eo_change IS REQUESTED AND eo_message IS REQUESTED.
    lv_check_for_failed = abap_false.
  ELSE.
    lv_check_for_failed = abap_true.
  ENDIF.

  IF mt_modification         IS NOT INITIAL OR
      iv_process_immediately = abap_true.
    end_modify( iv_process_immediately = iv_process_immediately
                iv_check_for_failed    = lv_check_for_failed ).
  ENDIF.

  IF mo_local_change IS BOUND.
    eo_change = /bobf/cl_frw_factory=>get_change( ).
    eo_change->merge( mo_local_change ).
    CLEAR mo_local_change.
  ENDIF.

  IF mo_local_message IS BOUND AND eo_message IS REQUESTED.
    eo_message = /bobf/cl_frw_factory=>get_message( ).
    eo_message->add( mo_local_message ).
    CLEAR mo_local_message.
  ENDIF.

ENDMETHOD.


METHOD /bobf/if_frw_modify~notify_association_change.

  ASSERT ID /bobf/frw_error
    CONDITION iv_node_key  IS NOT INITIAL
          AND ( iv_key     IS NOT INITIAL OR it_key IS NOT INITIAL )
          AND iv_assoc_key IS NOT INITIAL.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  mo_change->add_content_change(
      iv_change_mode = /bobf/if_frw_c=>sc_modify_association
      iv_node_key    = iv_node_key
      iv_key         = iv_key
      it_key         = it_key
      iv_content_key = iv_assoc_key ).

ENDMETHOD.


METHOD /bobf/if_frw_modify~notify_change.

  ASSERT ID /bobf/frw_error
    CONDITION iv_node_key IS NOT INITIAL
          AND ( iv_key IS NOT INITIAL OR it_key IS NOT INITIAL ).

  notify_change_internal(
    iv_node_key    = iv_node_key
    iv_change_mode = iv_change_mode
    iv_key         = iv_key
    it_key         = it_key ).

ENDMETHOD.


method /BOBF/IF_FRW_MODIFY~NOTIFY_PROPERTY_CHANGE.

  ASSERT ID /BOBF/FRW_ERROR
    CONDITION iv_node_key IS NOT INITIAL
          AND ( iv_key IS NOT INITIAL OR it_key IS NOT INITIAL ).

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  CHECK iv_node_changed           = abap_true
     OR iv_association_changed    = abap_true
     OR iv_node_attribute_changed = abap_true
     OR iv_action_changed         = abap_true.

  IF iv_node_changed = abap_true.
    mo_change->add_content_change(
      iv_node_key    = iv_node_key
      iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_NODE
      iv_key         = iv_key
      it_key         = it_key ).
  ENDIF.

  IF iv_node_attribute_changed = abap_true.
    mo_change->add_content_change(
      iv_node_key    = iv_node_key
      iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_NODE_ATTR
      iv_key         = iv_key
      it_key         = it_key ).
  ENDIF.

  IF iv_association_changed = abap_true.
    mo_change->add_content_change(
      iv_node_key    = iv_node_key
      iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_ASSOCIATION
      iv_key         = iv_key
      it_key         = it_key ).
  ENDIF.

  IF iv_action_changed = abap_true.
    mo_change->add_content_change(
      iv_node_key    = iv_node_key
      iv_change_mode = /BOBF/IF_FRW_C=>SC_MODIFY_PROPERTY_ACTION
      iv_key         = iv_key
      it_key         = it_key ).
  ENDIF.

endmethod.


METHOD /bobf/if_frw_modify~update.

  DATA: ls_mod            TYPE /bobf/s_frw_modification.
  FIELD-SYMBOLS:
    <ls_data>         TYPE any,
    <ls_mod_data>     TYPE any.

  ASSERT ID /bobf/frw_error
    CONDITION iv_node IS NOT INITIAL
          AND iv_key  IS NOT INITIAL
          AND is_data IS BOUND.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>new_properties_consistent(
      iv_node       = iv_node
      is_data       = is_data
      io_conf       = mo_conf
      io_bopf       = mo_bopf ) = abap_true.

* ____________________________________________________________________ *
* create modification entry
  ls_mod-node           = iv_node.
  ls_mod-key            = iv_key.
  ls_mod-root_key       = iv_root_key.
  ls_mod-change_mode    = /bobf/if_frw_c=>sc_modify_update.
  ASSIGN is_data->* TO <ls_data>.
  IF sy-subrc = 0.
    CREATE DATA ls_mod-data LIKE <ls_data>.
    ASSIGN ls_mod-data->* TO <ls_mod_data>.
    <ls_mod_data>       = <ls_data>.
  ENDIF.

  ls_mod-changed_fields = it_changed_fields.

  ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>modification_no_duplicate(
      it_modification     = mt_modification
      is_modification_new = ls_mod ) = abap_true.

  APPEND ls_mod TO mt_modification.

  ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>do_key_not_deleted(
      iv_node_key       = iv_node
      iv_key            = iv_key
      is_data           = is_data
      it_changed_fields = it_changed_fields
      io_buffer         = mo_buffer
      io_conf           = mo_conf
      iv_current_state  = mv_current_state ) = abap_true.

  ASSERT ID /bobf/frw_flush CONDITION flush_changes( ) EQ abap_true.

ENDMETHOD.


method /bobf/if_frw_query~query.

  data: ls_query           type /bobf/s_confro_query,
        ls_node            type /bobf/s_confro_node,
        lo_int_access      type ref to /bobf/cl_frw_int_access,
        lo_delegation      type ref to /bobf/if_frw_delegation,
        lo_query           type ref to /bobf/if_frw_query,
        ls_context         type /bobf/s_frw_ctx_query,
        lv_content_cat     type string,
        lv_content_name    type /bobf/obm_name,
        lx_frw             type ref to /bobf/cx_frw_core,
        lx_root            type ref to cx_root.

  break-point id /bobf/frw.
  assert id /bobf/frw condition eo_message is requested.
  clear: eo_message,
         es_query_info,
         et_data.

  if mv_valid_if_query = abap_false.
    assert id /bobf/frw_error condition 0 = 1.
    mo_bopf->set_application_error( ).
  endif.

  mo_conf->get_query(
    exporting iv_query_key = is_ctx-query_key
    importing es_query     = ls_query ).

  try.
      if ls_query-query_class is initial or
         ms_query-query_key = is_ctx-query_key.

*        check for delegation
        if mo_conf->ms_last_node-node_key = ls_query-node_key.
          ls_node = mo_conf->ms_last_node.
        else.
          mo_conf->get_node(
            exporting iv_node_key = ls_query-node_key
            importing es_node     = ls_node ).
        endif.

        if ls_node-delegation_class is not initial.
*          ask delegation
          try.
              lo_delegation = mo_bopf->get_delegation( ls_query-node_key ).
              lo_delegation->query(
                exporting
                  iv_query_key             = is_ctx-query_key
                  it_filter_key            = it_filter_key
                  it_selection_parameters  = it_selection_parameters
                  is_query_options         = is_query_options
                  iv_fill_data             = iv_fill_data
                  it_requested_attributes  = it_requested_attributes
               importing
                  et_key                   = et_key
                  eo_message               = eo_message
                  es_query_info            = es_query_info
                  et_data                  = et_data ).
            catch cx_root into lx_root.                  "#EC CATCH_ALL
              mo_bopf->set_application_error( lx_root ).
          endtry.
        else.
*          ask buffer
          mo_buffer->query(
            exporting
              iv_node_key             = ls_query-node_key
              iv_query_key            = is_ctx-query_key
              it_filter_key           = it_filter_key
              it_selection_parameters = it_selection_parameters
              io_query_authorities    = io_query_authorities
              is_query_options        = is_query_options
            importing
              et_key                  = et_key
              es_query_info           = es_query_info ).
        endif.

      else.
*        call query implementation
        ls_context = is_ctx.
        ls_context-node_key = ls_query-node_key.

*        create query class
        create object lo_query type (ls_query-query_class).

*        get internal access class
        lo_int_access = /bobf/cl_frw_int_access=>new_instance(
          exporting
            io_bopf   = mo_bopf
            io_conf   = mo_conf
            io_buffer = mo_buffer
            io_change = mo_change
        ).

        lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
        lo_int_access->set_context(
           is_query         = ls_context
           iv_read_allowed  = abap_true
           iv_query_allowed = abap_true
           iv_modify_allowed = abap_true ).

        lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_read_only ).

        insert lo_int_access into mo_bopf->mt_access_stack index 1.

        lo_query->query(
          exporting
            is_ctx                  = ls_context
            it_filter_key           = it_filter_key
            it_selection_parameters = it_selection_parameters
            is_query_options        = is_query_options
            io_query                = lo_int_access
            io_read                 = lo_int_access
            io_modify               = lo_int_access
            iv_fill_data            = iv_fill_data
            it_requested_attributes = it_requested_attributes
          importing
            et_key                  = et_key
            eo_message              = eo_message
            es_query_info           = es_query_info
            et_data                 = et_data ).

        if lo_int_access->mt_modification is not initial.
          lo_int_access->end_modify( ).
        endif.

        delete mo_bopf->mt_access_stack index 1.

        lo_int_access->invalidate( ).
      endif.

    catch cx_sy_dyn_call_error into lx_root.
      lv_content_name = mo_bopf->get_content_description(
        iv_query = abap_true
        iv_key   = is_ctx-query_key ).
      lv_content_cat = text-001.
      create object lx_frw
        exporting
          textid          = /bobf/cx_frw_core=>sc_no_instance
          previous        = lx_root
          mv_method_name  = 'QUERY'
          mv_content_name = lv_content_name
          mv_content_cat  = lv_content_cat.
      mo_bopf->set_configuration_error( lx_frw ).

    catch cx_root into lx_root.                          "#EC CATCH_ALL
      lv_content_name = mo_bopf->get_content_description(
        iv_query = abap_true
        iv_key   = is_ctx-query_key ).
      lv_content_cat = text-001.
      create object lx_frw
        exporting
          textid          = /bobf/cx_frw_core=>sc_content_exception
          previous        = lx_root
          mv_method_name  = 'QUERY'
          mv_content_name = lv_content_name
          mv_content_cat  = lv_content_cat.
      mo_bopf->set_application_error( lx_frw ).
  endtry.

endmethod.


method /BOBF/IF_FRW_QUERY~RETRIEVE_DEFAULT_PARAM.

  DATA: ls_query           TYPE /BOBF/S_CONFRO_QUERY,
        ls_node            TYPE /BOBF/S_CONFRO_NODE,
        lo_query           TYPE REF TO /BOBF/IF_FRW_QUERY,
        lo_delegation      TYPE REF TO /BOBF/IF_FRW_DELEGATION,
        lv_content_cat     TYPE string,
        lv_content_name    TYPE /BOBF/OBM_NAME,
        lx_frw             TYPE REF TO /BOBF/CX_FRW_CORE,
        lx_root            TYPE REF TO cx_root.

  BREAK-POINT ID /BOBF/FRW.


  IF mv_valid_if_query = abap_false.
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  mo_conf->get_query(
    EXPORTING iv_query_key = is_ctx-query_key
    IMPORTING es_query     = ls_query ).

  TRY.
      IF ls_query-query_class IS INITIAL OR
         ms_query-query_key = is_ctx-query_key.
*       check for delegation
        IF mo_conf->ms_last_node-node_key = ls_query-node_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_query-node_key
            IMPORTING es_node     = ls_node ).
        ENDIF.

        IF ls_node-delegation_class IS NOT INITIAL.
*         ask delegation
          TRY.
              lo_delegation = mo_bopf->get_delegation( ls_query-node_key ).
              lo_delegation->retrieve_default_query_param(
                EXPORTING
                  iv_query_key            = is_ctx-query_key
                CHANGING
                  ct_selection_parameters = ct_selection_parameters ).

            CATCH cx_root INTO lx_root.                  "#EC CATCH_ALL
              mo_bopf->set_application_error( lx_root ).
          ENDTRY.
        ELSE.
*         no implementation available -> no default
          RETURN.
        ENDIF.

      ELSE.
*       create query class
        CREATE OBJECT lo_query TYPE (ls_query-query_class).

        lo_query->retrieve_default_param(
          EXPORTING
            is_ctx                  = is_ctx
          CHANGING
            ct_selection_parameters = ct_selection_parameters ).

      ENDIF.

    CATCH cx_sy_dyn_call_error INTO lx_root.
      lv_content_name = mo_bopf->get_content_description(
        iv_query = abap_true
        iv_key   = is_ctx-query_key ).
      lv_content_cat = text-001.
      CREATE OBJECT lx_frw
        EXPORTING
          textid          = /BOBF/CX_FRW_CORE=>SC_NO_INSTANCE
          previous        = lx_root
          mv_method_name  = 'RETRIEVE_DEFAULT_PARAM'
          mv_content_name = lv_content_name
          mv_content_cat  = lv_content_cat.
      mo_bopf->set_configuration_error( lx_frw ).

    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      lv_content_name = mo_bopf->get_content_description(
        iv_query = abap_true
        iv_key   = is_ctx-query_key ).
      lv_content_cat = text-001.
      CREATE OBJECT lx_frw
        EXPORTING
          textid          = /BOBF/CX_FRW_CORE=>SC_CONTENT_EXCEPTION
          previous        = lx_root
          mv_method_name  = 'RETRIEVE_DEFAULT_PARAM'
          mv_content_name = lv_content_name
          mv_content_cat  = lv_content_cat.
      mo_bopf->set_application_error( lx_frw ).
  ENDTRY.

endmethod.


METHOD /bobf/if_frw_read~compare.

  TYPES:
    BEGIN OF ty_temp_key,
      source_node_key        TYPE /bobf/conf_key,
      source_key             TYPE /bobf/t_frw_key,
      target_node_key        TYPE /bobf/conf_key,
      target_key             TYPE /bobf/t_frw_key,
      association            TYPE /bobf/conf_key,
      loaded                 TYPE boole_d,
      delegation_target_node TYPE boole_d,
    END OF ty_temp_key.

  DATA:
    lv_completed               TYPE        boole_d,
    lv_current_source_node_key TYPE        /bobf/conf_key,
    lt_current_source_key      TYPE        /bobf/t_frw_key,
    lv_node                    TYPE        /bobf/conf_key,
    ls_composition             TYPE        /bobf/s_confro_assoc2,
    lt_composition             TYPE        /bobf/t_confro_assoc2,
    ls_delegation_node         TYPE        /bobf/s_confro_node,
    lt_delegation_node         TYPE        /bobf/t_confro_node,
    lv_subtree                 TYPE        boole_d,
    ls_conf_node               TYPE        /bobf/s_confro_node,
    lt_conf_node               TYPE        /bobf/t_confro_node,
    ls_temp                    TYPE        ty_temp_key,
    lt_do_change               TYPE        /bobf/t_frw_change,
    lt_current_key             TYPE        /bobf/t_frw_key,
    lo_do_change               TYPE REF TO /bobf/if_frw_change,
    lo_delegation              TYPE REF TO /bobf/if_frw_delegation,
    lx_root                    TYPE REF TO cx_root,
    lo_change                  TYPE REF TO /bobf/cl_frw_change,
    lt_temp                    TYPE STANDARD TABLE OF ty_temp_key.

  FIELD-SYMBOLS:
    <ls_do_change> TYPE /bobf/s_frw_change,
    <ls_temp>      TYPE ty_temp_key,
    <ls_tmp_temp>  TYPE ty_temp_key.

  CLEAR eo_change.

  IF mv_valid_if_read = abap_false.
    " wrong instance of IO_READ used
    " (might happen if IO_READ was buffered in implementing class)
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  " check before retrieve
  " (as no before image allowed here, a comparison is not allowed)
  ASSERT ID /bobf/frw_error CONDITION mv_within_retrieve = abap_false.

  " check scope
  " (comparing the whole BO instance including all substructures is only allowed for root node instances)
  IF   iv_scope = /bobf/if_frw_c=>sc_scope_substructure
    OR iv_scope = /bobf/if_frw_c=>sc_scope_substructure_with_do.
    lv_subtree = abap_true.
    IF iv_node_key <> mo_conf->ms_obj-root_node_key.
      ASSERT ID /bobf/frw_error CONDITION 0 = 1.
      RETURN.
    ENDIF.
  ENDIF.


  " create a new change object
  eo_change = /bobf/cl_frw_factory=>get_change( ).

  " if we haven't changed something yet, the result of the comparison is empty
  CHECK mo_bopf->mv_modifying_transaction = abap_true.

  " prepare change object if also attribute changes shall be tracked
  " (this is not the default as this costs performance is not always necessary)
  IF iv_fill_attributes = abap_true.
    lo_change ?= eo_change.
    lo_change->set_attributes_requested( abap_true ).
  ENDIF.

  " compare the buffer state
  TRY.
      mo_buffer->compare_states(
        iv_node_key      = iv_node_key
        it_key           = it_key
        iv_state_current = mv_current_state
        iv_state_before  = mv_last_state
        iv_incl_subtree  = lv_subtree
        io_change        = eo_change ).
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      mo_bopf->set_application_error( lx_root ).
  ENDTRY.

  " collect relevant DOs
  " (either the node in scope local is a DO representation node or the scope is substructure - than we need all the DOs)
  IF iv_scope = /bobf/if_frw_c=>sc_scope_substructure_with_do.

    " get node configuration - check DO changes only if substructure on root instance is chosen other modes are not supported yet
    mo_conf->get_node(
      EXPORTING
        iv_node_key = iv_node_key
      IMPORTING
        es_node     = ls_conf_node ).
    IF ls_conf_node-parent_node_key IS NOT INITIAL.
      RETURN.
    ENDIF.

    " take only the delegation nodes (leading from the current host BO to DOs)
    mo_conf->get_node_tab( IMPORTING et_node = lt_conf_node ).
    DELETE lt_conf_node WHERE delegation_class IS INITIAL.
    LOOP AT lt_conf_node INTO ls_conf_node.
      IF ls_conf_node-delegation_root_node_key NE ls_conf_node-node_key.
        DELETE lt_conf_node.
      ENDIF.
    ENDLOOP.
    lt_delegation_node = lt_conf_node.
    IF lt_delegation_node IS INITIAL.
      RETURN.
    ENDIF.

    " detect all necessary associations leading from the DO delegation node
    " to the ROOT node of the current host BO
    mo_conf->get_assoc_tab( IMPORTING et_comp = lt_composition ).
    LOOP AT lt_delegation_node INTO ls_delegation_node.
      READ TABLE lt_composition INTO ls_composition WITH KEY target_key COMPONENTS target_node_key = ls_delegation_node-node_key.
      IF sy-subrc = 0.
        CLEAR ls_temp.
        ls_temp-target_node_key        = ls_composition-target_node_key.
        ls_temp-source_node_key        = ls_composition-source_node_key.
        ls_temp-association            = ls_composition-assoc_key.
        ls_temp-delegation_target_node = abap_true.
        INSERT ls_temp INTO TABLE lt_temp.
        WHILE ls_composition-source_node_key <> iv_node_key.
          " continue climbing up to the current host BO root node
          READ TABLE lt_composition INTO ls_composition WITH KEY target_key COMPONENTS target_node_key = ls_composition-source_node_key.
          IF sy-subrc = 0.
            CLEAR ls_temp.
            ls_temp-target_node_key        = ls_composition-target_node_key.
            ls_temp-source_node_key        = ls_composition-source_node_key.
            ls_temp-association            = ls_composition-assoc_key.
            ls_temp-delegation_target_node = abap_false.
            INSERT ls_temp INTO TABLE lt_temp.
          ENDIF.
        ENDWHILE.
      ENDIF.
    ENDLOOP.

    " retrieve all instances of the detected instances
    lv_current_source_node_key = iv_node_key.
    lt_current_key             = it_key.
    READ TABLE lt_temp ASSIGNING <ls_tmp_temp> WITH KEY source_node_key = iv_node_key.
    IF sy-subrc = 0.
      <ls_tmp_temp>-source_key = it_key.
    ENDIF.
    WHILE lv_completed = abap_false.

      " process all compositions leading from the current source node
      LOOP AT lt_temp ASSIGNING <ls_temp> WHERE source_node_key = lv_current_source_node_key AND loaded = abap_false.
        IF sy-subrc = 0.
          " RBA on the current RBA
          <ls_temp>-source_key = lt_current_key.
          mo_bopf->retrieve_by_association(
            EXPORTING
              iv_node_key    = <ls_temp>-source_node_key
              it_key         = lt_current_key
              iv_state       = /bobf/if_conf_c=>sc_state_current
              iv_association = <ls_temp>-association
              iv_fill_data   = abap_false
            IMPORTING
              et_target_key  = <ls_temp>-target_key ).
          " mark the composition as processed
          <ls_temp>-loaded = abap_true.
        ENDIF.
      ENDLOOP.

      " choose next current source node
      READ TABLE lt_temp WITH KEY loaded = abap_false TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        LOOP AT lt_temp ASSIGNING <ls_temp> WHERE loaded = abap_false.
          " take a non-yet-processed composition which leads from a node, for which we have already retrieved the instances
          READ TABLE lt_temp ASSIGNING <ls_tmp_temp> WITH KEY loaded = abap_true target_node_key = <ls_temp>-source_node_key.
          IF sy-subrc = 0.
            lv_current_source_node_key = <ls_temp>-source_node_key.
            lt_current_key = <ls_tmp_temp>-target_key.
          ENDIF.
        ENDLOOP.
      ELSE.
        lv_completed = abap_true.
      ENDIF.
    ENDWHILE.

    " forward the compare call the relevant DOs
    LOOP AT lt_delegation_node INTO ls_conf_node.
      IF ls_conf_node-delegation_class IS NOT INITIAL.
        TRY.
            lo_delegation = mo_bopf->get_delegation( ls_conf_node-node_key ).
            " get node key via mapping
            mo_conf->get_content_key_mapping(
              EXPORTING
                iv_content_cat      = /bobf/if_conf_c=>sc_content_nod
                iv_host_content_key = ls_conf_node-node_key
              RECEIVING
                ev_content_key      = lv_node ).
            " get the corresponding keys
            READ TABLE lt_temp WITH KEY target_node_key = ls_conf_node-node_key delegation_target_node = abap_true INTO ls_temp.
            IF sy-subrc = 0.
              " delegate compare
              lo_delegation->compare(
                EXPORTING
                  iv_node_key        = lv_node
                  it_key             = ls_temp-target_key
                  iv_fill_attributes = iv_fill_attributes
                  iv_current_state   = mv_current_state
                  iv_last_state      = mv_last_state
                  iv_scope           = /bobf/if_frw_c=>sc_scope_substructure_with_do
                IMPORTING
                  eo_change          = lo_do_change ).
              " map node key contained in the lo_do_change object as the host view is expected
              " (as the result refers to the whole BO instance, only the host view is possible - otherwise multiple included DOs would have a naming conflict)
              lo_do_change->get( IMPORTING et_change = lt_do_change ).
              LOOP AT lt_do_change ASSIGNING <ls_do_change>.
                mo_conf->get_content_key_mapping(
                  EXPORTING
                    iv_content_cat      = /bobf/if_conf_c=>sc_content_nod
                    iv_do_content_key   = <ls_do_change>-node_key
                    iv_do_root_node_key = ls_conf_node-node_key
                  RECEIVING
                    ev_content_key      = <ls_do_change>-node_key ).
              ENDLOOP.
              " add changes of the DO to changes of the Host
              IF lt_do_change IS NOT INITIAL.
                eo_change->add( EXPORTING it_change = lt_do_change ).
              ENDIF.
            ENDIF.
          CATCH cx_root INTO lx_root.                    "#EC CATCH_ALL
            mo_bopf->set_application_error( lx_root ).
        ENDTRY.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDMETHOD.


method /BOBF/IF_FRW_READ~CONVERT_ALTERN_KEY.

  DATA: lv_state           TYPE /BOBF/CONF_STATE,
        lv_fill_target_key TYPE boole_d.

  CLEAR: et_result,
         et_key.

  IF mv_valid_if_read = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

* check before retrieve - no before image allowed here
  ASSERT ID /BOBF/FRW_ERROR
    CONDITION NOT ( mv_within_retrieve = abap_true
                AND iv_before_image           = abap_true ).

* get state
  IF mo_bopf->mv_modifying_transaction = abap_true.
    IF iv_before_image = abap_true.
      lv_state = mv_last_state.
    ELSE.
      lv_state = mv_current_state.
    ENDIF.
  ELSE.
    lv_state = /BOBF/IF_CONF_C=>SC_STATE_CURRENT.
  ENDIF.

  IF lv_state = /BOBF/IF_CONF_C=>SC_STATE_CURRENT AND
     mt_modification IS NOT INITIAL.
*   check for modifications to flush
    end_modify( ).
  ENDIF.

  IF et_key IS REQUESTED.
    lv_fill_target_key = abap_true.
  ELSE.
    lv_fill_target_key = abap_false.
  ENDIF.

  mo_bopf->convert_altern_key(
    EXPORTING
      iv_node_key          = iv_node_key
      iv_altkey_key        = iv_altkey_key
      iv_target_altkey_key = iv_target_altkey_key
      it_key               = it_key
      iv_state             = lv_state
      iv_invalidate_cache  = iv_invalidate_cache
      iv_check_existence   = abap_true
      iv_fill_target_key   = lv_fill_target_key
    IMPORTING
      et_result            = et_result
      et_key               = et_key ).

endmethod.


METHOD /bobf/if_frw_read~get_root_key.

  DATA: lv_state           TYPE /bobf/conf_state,
        ls_key_link        TYPE /bobf/s_frw_key_link,
        ls_key             TYPE /bobf/s_frw_key,
        ls_node            TYPE /bobf/s_frw_node,
        lt_node            TYPE /bobf/t_frw_node,
        ls_node_conf       TYPE /bobf/s_confro_node,
        lo_delegation      TYPE REF TO /bobf/if_frw_delegation,
        lo_change          TYPE REF TO /bobf/if_frw_change,
        lx_root            TYPE REF TO cx_root.

  CLEAR: et_target_key,
         et_key_link,
         et_failed_key.

  IF mv_valid_if_read = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

* check before retrieve - no before image allowed here
  ASSERT ID /bobf/frw_error
    CONDITION NOT ( mv_within_retrieve = abap_true
                AND iv_before_image           = abap_true ).

* get state
  IF mo_bopf->mv_modifying_transaction = abap_true.
    IF iv_before_image = abap_true.
      lv_state = mv_last_state.
    ELSE.
      lv_state = mv_current_state.
    ENDIF.
  ELSE.
    lv_state = /bobf/if_conf_c=>sc_state_current.
  ENDIF.

  IF lv_state = /bobf/if_conf_c=>sc_state_current AND
     mt_modification IS NOT INITIAL.
*   check for modifications to flush
    end_modify( ).
  ENDIF.

  IF mo_conf->ms_last_node-node_key = iv_node.
    ls_node_conf = mo_conf->ms_last_node.
  ELSE.
    mo_conf->get_node(
      EXPORTING iv_node_key = iv_node
      IMPORTING es_node     = ls_node_conf ).
  ENDIF.


  IF ls_node_conf-delegation_class IS NOT INITIAL.
*   delegate call
    TRY.
        lo_delegation = mo_bopf->get_delegation( iv_node ).
        lo_delegation->get_root_key(
          EXPORTING
            iv_node_key         = iv_node
            it_key              = it_key
            iv_state            = lv_state
            io_read             = me
          IMPORTING
            et_key_link         = et_key_link
            et_failed_key       = et_failed_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        mo_bopf->set_application_error( lx_root ).
    ENDTRY.

  ELSE.
*   local call

    lo_change = /bobf/cl_frw_factory=>get_change( ).

    TRY.
        IF ls_node_conf-node_type = /bobf/if_conf_c=>sc_node_type_status.
*         for status node get root key of the parent node
          mo_buffer->get_root_key(
           EXPORTING
             iv_node_key   = ls_node_conf-parent_node_key
             it_key        = it_key
             iv_state      = lv_state
             io_change     = lo_change
           IMPORTING
             et_key_link   = et_key_link
             et_failed_key = et_failed_key ).
        ELSE.
          mo_buffer->get_root_key(
           EXPORTING
             iv_node_key   = iv_node
             it_key        = it_key
             iv_state      = lv_state
             io_change     = lo_change
           IMPORTING
             et_key_link   = et_key_link
             et_failed_key = et_failed_key ).
        ENDIF.
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        mo_bopf->set_application_error( lx_root ).
    ENDTRY.

    mo_bopf->after_loading(
      EXPORTING
        io_change     = lo_change
        iv_load_state = lv_state ).

    IF mo_change IS BOUND.
      mo_change->merge( lo_change ).
    ELSE.
      mo_change = lo_change.
    ENDIF.

  ENDIF.

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = it_key
          it_key_subset = et_failed_key ) = abap_true.

* fill target keys
  IF et_target_key IS REQUESTED AND
     et_key_link   IS NOT INITIAL.
    LOOP AT et_key_link INTO ls_key_link.
      ls_key-key = ls_key_link-target_key.
      APPEND ls_key TO et_target_key.
    ENDLOOP.
    SORT et_target_key.
    DELETE ADJACENT DUPLICATES FROM et_target_key.
  ENDIF.

ENDMETHOD.


METHOD /bobf/if_frw_read~retrieve.

  DATA: lv_state               TYPE /bobf/conf_state,
        lv_within_retrieve     TYPE boole_d,
        lo_change              TYPE REF TO /bobf/if_frw_change,
        lv_invalidate_cache    TYPE boole_d.

  BREAK-POINT ID /bobf/frw.

  ASSERT ID /bobf/frw_error
    CONDITION et_data IS REQUESTED
           OR iv_fill_data = abap_false.

  CLEAR:
      et_failed_key,
      et_node_cat,
      et_data.

  CHECK it_key IS NOT INITIAL.

  IF mv_valid_if_read = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  IF iv_fill_data = abap_true.
    IF mo_conf->ms_last_node-node_key <> iv_node.
      mo_conf->get_node(
        EXPORTING
          iv_node_key = iv_node ).
    ENDIF.
    mo_bopf->type_check( iv_expected_line_type = mo_conf->ms_last_node-data_type
                         iv_service_name       = 'Retrieve'
                         iv_parameter_name     = 'ET_DATA'
                         it_data               = et_data ) ##no_text.
  ENDIF.

** check before retrieve - no before image allowed here
*  ASSERT ID /bopf/frw_error
*    CONDITION NOT ( ms_determination-exectime = /bopf/if_conf_c=>sc_time_before_retrieve
*                AND iv_before_image           = abap_true ).

* check for after loading
  IF mv_within_loading = abap_true AND
     iv_before_image   = abap_true.
    et_failed_key = it_key.
    RETURN.
  ENDIF.

* get state and flush changes
  IF mo_bopf->mv_modifying_transaction = abap_true.
    IF iv_before_image = abap_true.
      lv_state = mv_last_state.
    ELSE.
      lv_state = mv_current_state.
    ENDIF.
  ELSE.
    lv_state = /bobf/if_conf_c=>sc_state_current.
  ENDIF.

  IF lv_state = /bobf/if_conf_c=>sc_state_current AND
     mt_modification IS NOT INITIAL.
*   check for modifications to flush
    end_modify( ).
  ENDIF.

* control the determination before retrieve
  IF mv_within_retrieve = abap_true.
    IF ms_association-assoc_key IS NOT INITIAL.
      IF mo_conf->ms_last_assoc-assoc_key <> ms_association-assoc_key.
        mo_conf->get_assoc( iv_assoc_key  = ms_association-assoc_key ).
      ENDIF.
      IF mo_conf->ms_last_assoc-target_node_key = iv_node.
        lv_within_retrieve = abap_true.
      ENDIF.
    ELSEIF ms_determination-node_key = iv_node.
      lv_within_retrieve = abap_true.
    ENDIF.
  ENDIF.

  IF iv_before_image = abap_true.
    lv_invalidate_cache = abap_false.
  ELSE.
    lv_invalidate_cache = mv_invalidate_cache.
  ENDIF.

* read data
  mo_bopf->retrieve(
    EXPORTING
      iv_node_key             = iv_node
      it_key                  = it_key
      iv_state                = lv_state
      iv_invalidate_cache     = lv_invalidate_cache
      iv_fill_data            = iv_fill_data
      it_requested_attributes = it_requested_attributes
      iv_edit_mode            = /bobf/if_conf_c=>sc_edit_read_only
      iv_within_loading       = mv_within_loading
        iv_loading_node_key     = mv_loading_node_key
      iv_within_retrieve      = lv_within_retrieve
      iv_buffer_only          = mv_read_buffer_only
    IMPORTING
      eo_message              = eo_message
      et_data                 = et_data
      et_failed_key           = et_failed_key
      et_node_cat             = et_node_cat
      eo_change               = lo_change ).

  IF mo_change IS BOUND.
    mo_change->merge( lo_change ).
  ELSE.
    mo_change = lo_change.
  ENDIF.

  ASSERT ID /bobf/frw CONDITION
      /bobf/cl_tool_assert=>is_key_subset(
          it_key_set    = it_key
          it_key_subset = et_failed_key ) = abap_true.

ENDMETHOD.


METHOD /bobf/if_frw_read~retrieve_by_association.

  DATA: lv_state            TYPE /bobf/conf_state,
        lv_requested_state  TYPE /bobf/conf_state,
        ls_target_key       TYPE /bobf/s_frw_key,
        ls_key_link         TYPE /bobf/s_frw_key_link,
        ls_key              TYPE /bobf/s_frw_key,
        ls_mod              TYPE /bobf/s_frw_modification,
        lv_ask_buffer       TYPE boole_d,
        lv_det_retrieve     TYPE boole_d,
        lv_fill_failed_key  TYPE boole_d,
        lo_delegation       TYPE REF TO /bobf/if_frw_delegation,
        lo_change           TYPE REF TO /bobf/if_frw_change,
        lx_root             TYPE REF TO cx_root,
        lv_invalidate_cache TYPE boole_d.

  ASSERT ID /bobf/frw_error
    CONDITION et_data IS REQUESTED
           OR iv_fill_data = abap_false.

  CLEAR: eo_message,
         et_data,
         et_key_link,
         et_target_key,
         et_failed_key.

  IF mv_valid_if_read = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /bobf/frw_error CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  CHECK it_key IS NOT INITIAL.

  IF et_failed_key IS REQUESTED.
    lv_fill_failed_key = abap_true.
  ENDIF.

* check for after loading
  IF mv_within_loading = abap_true AND
     iv_before_image   = abap_true.
    et_failed_key = it_key.
    RETURN.
  ENDIF.

* get state
  IF mo_bopf->mv_modifying_transaction = abap_true.
    IF iv_before_image = abap_true.
      lv_state = mv_last_state.
    ELSE.
      lv_state = mv_current_state.
    ENDIF.
  ELSE.
    lv_state = /bobf/if_conf_c=>sc_state_current.
  ENDIF.

  IF lv_state = /bobf/if_conf_c=>sc_state_current AND
     mt_modification IS NOT INITIAL.
*   check for modifications to flush
    end_modify( ).
  ENDIF.

  IF mo_conf->ms_last_assoc-assoc_key <> iv_association.
    mo_conf->get_assoc( iv_assoc_key = iv_association ).
  ENDIF.

  IF iv_fill_data = abap_true.
    DATA lv_target_node_data_type TYPE string.
    IF mo_conf->ms_last_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_xbo.
      " xBO association...
      TRY.
        DATA lo_ref_bo_conf TYPE REF TO /bobf/if_frw_configuration.
        lo_ref_bo_conf = /bobf/cl_frw_factory=>get_configuration( iv_bo_key = mo_conf->ms_last_assoc-target_node->ref_bo_key ).
        DATA ls_ref_node_conf TYPE /bobf/s_confro_node.
        lo_ref_bo_conf->get_node( EXPORTING iv_node_key = mo_conf->ms_last_assoc-target_node->ref_node_key
                                  IMPORTING es_node     = ls_ref_node_conf ).
        CATCH /bobf/cx_frw.
          " ignore...
      ENDTRY.
      lv_target_node_data_type = ls_ref_node_conf-data_type.
    ELSE.
      " inner BO association...
      lv_target_node_data_type = mo_conf->ms_last_assoc-target_node->data_type.
    ENDIF.
    mo_bopf->type_check(
      EXPORTING
        iv_expected_line_type = lv_target_node_data_type
        iv_service_name       = 'RetrieveByAssociation'
        iv_parameter_name     = 'ET_DATA'
        it_data               = et_data
    ).
  ENDIF.

  IF iv_before_image = abap_true.
    lv_invalidate_cache = abap_false.
  ELSE.
    lv_invalidate_cache = mv_invalidate_cache.
  ENDIF.

* ____________________________________________________________________ *
  IF mo_conf->ms_last_assoc-source_node->delegation_class IS NOT INITIAL AND
     mo_conf->ms_last_assoc-target_node->delegation_class IS NOT INITIAL.
*   delegate call
    TRY.
        lo_delegation = mo_bopf->get_delegation( iv_node ).
        lo_delegation->retrieve_by_association(
          EXPORTING
            iv_node_key                 = iv_node
            it_key                      = it_key
            iv_association              = iv_association
            is_parameters               = is_parameters
            it_filtered_attributes      = it_filtered_attributes
            iv_fill_data                = iv_fill_data
            it_requested_attributes     = it_requested_attributes
            iv_state                    = lv_state
            iv_invalidate_cache         = lv_invalidate_cache
            iv_edit_mode                = /bobf/if_conf_c=>sc_edit_read_only
            io_change                   = mo_change
          IMPORTING
            eo_message                  = eo_message
            et_data                     = et_data
            et_key_link                 = et_key_link
            et_failed_key               = et_failed_key ).
      CATCH cx_root INTO lx_root.                        "#EC CATCH_ALL
        mo_bopf->set_application_error( lx_root ).
    ENDTRY.

*   fill et_target_key
    IF et_target_key IS REQUESTED AND
       et_target_key IS INITIAL AND
       et_key_link IS NOT INITIAL.
      LOOP AT et_key_link INTO ls_key_link.
        ls_target_key-key = ls_key_link-target_key.
        APPEND ls_target_key TO et_target_key.
      ENDLOOP.
      SORT et_target_key.
      DELETE ADJACENT DUPLICATES FROM et_target_key.
    ENDIF.

  ELSE.
*   local call
* ____________________________________________________________________ *
*   ignore association class if this class is already executed
    IF ms_association-assoc_key = iv_association.
      IF ms_determination-det_key IS INITIAL.
*       I'm called by an association class
        lv_ask_buffer   = abap_true.
*       Do not execute determinations before retrieve for this association
*       as we are either inside one or the relevant det. before retrieve was
*       already executed by the FW
        lv_det_retrieve = abap_false.
      ELSE.
*       I'm called by a determination class before retrieve
        lv_ask_buffer   = abap_false.
        lv_det_retrieve = abap_false.
      ENDIF.
    ELSE.
      lv_det_retrieve = abap_true.
    ENDIF.

* ____________________________________________________________________ *
*   retrieve data
    mo_bopf->retrieve_by_association(
      EXPORTING
        iv_node_key                 = iv_node
        it_key                      = it_key
        iv_association              = iv_association
        is_parameters               = is_parameters
        it_filtered_attributes      = it_filtered_attributes
        iv_state                    = lv_state
        iv_before_image             = iv_before_image
        iv_invalidate_cache         = lv_invalidate_cache
        iv_ask_buffer               = lv_ask_buffer
        iv_buffer_only              = mv_read_buffer_only
        iv_fill_failed_key          = lv_fill_failed_key
        iv_fill_data                = iv_fill_data
        it_requested_attributes     = it_requested_attributes
        iv_within_loading           = mv_within_loading
          iv_loading_node_key         = mv_loading_node_key
        iv_with_det_before_retrieve = lv_det_retrieve
      IMPORTING
        eo_message                  = eo_message
        et_data                     = et_data
        et_key_link                 = et_key_link
        et_target_key               = et_target_key
        eo_change                   = lo_change
        et_failed_key               = et_failed_key ).

    IF mo_change IS BOUND.
      mo_change->merge( lo_change ).
    ELSE.
      mo_change = lo_change.
    ENDIF.
  ENDIF.

ENDMETHOD.


  METHOD change_usage_restriction.
    ev_previous_check_allowed = mv_valid_if_check.
    mv_valid_if_check = iv_check_allowed.
  ENDMETHOD.


  METHOD clear_modifications.
    CLEAR mt_modification.
    CLEAR mt_modification_ctx.
  ENDMETHOD.


METHOD CONSTRUCTOR.

  mo_bopf   = io_bopf.
  mo_conf   = io_conf.
  mo_buffer = io_buffer.
  mo_change = io_change.

ENDMETHOD.


  METHOD copy_modifications_from.
    mt_modification     = io_other->mt_modification.
    mt_modification_ctx = io_other->mt_modification_ctx.
  ENDMETHOD.


METHOD current_instance.
  ro_instance = VALUE #( io_bopf->mt_access_stack[ 1 ] OPTIONAL ).
ENDMETHOD.


  METHOD delete_modification.
    DELETE mt_modification INDEX iv_tabix USING KEY change.
    LOOP AT mt_modification_ctx ASSIGNING FIELD-SYMBOL(<mod_ctx>) WHERE valid_to >= iv_tabix.
      SUBTRACT 1 FROM <mod_ctx>-valid_to.
    ENDLOOP.
  ENDMETHOD.


METHOD end_modify.
    DATA:
      lv_within_retrieve TYPE boole_d,
      lo_message         TYPE REF TO /bobf/if_frw_message,
      lo_change_cl       TYPE REF TO /bobf/cl_frw_change,
      lo_int_access      TYPE REF TO /bobf/cl_frw_int_access,
      lo_me              TYPE REF TO /bobf/cl_frw_int_access.
    FIELD-SYMBOLS <ls_change> TYPE /bobf/s_frw_change.

  CLEAR eo_change.

  CHECK mv_processing_end_modify = abap_false.

  mv_processing_end_modify = abap_true.

    IF mr_addon_reference IS BOUND.
    lo_me = mr_addon_reference.
  ELSE.
    lo_me = me.
  ENDIF.

* Flush internal access instances that are lower in access stack
  READ TABLE mo_bopf->mt_access_stack WITH KEY table_line = lo_me TRANSPORTING NO FIELDS.
  ASSERT sy-subrc = 0.
  IF sy-subrc = 0.
      DATA(lv_index) = sy-tabix.
      lv_index = lv_index + 1.
      READ TABLE mo_bopf->mt_access_stack INDEX lv_index INTO lo_int_access.
      IF sy-subrc = 0.
        lo_int_access->end_modify( iv_process_immediately = iv_process_immediately ).
    ENDIF.
  ENDIF.

  IF mt_modification IS NOT INITIAL.
      IF mv_within_retrieve = abap_true
        OR ms_query-query_key IS NOT INITIAL.
      lv_within_retrieve = abap_true.
    ENDIF.

*   do modify
      set_keys_for_create_modifictns( ).
      mo_bopf->do_modify(
      EXPORTING
        it_modification        = mt_modification
        iv_within_loading      = mv_within_loading
          iv_loading_node_key = mv_loading_node_key
          iv_within_retrieve = lv_within_retrieve
        iv_internal_modify     = abap_true
        iv_assoc_key           = ms_association-assoc_key
        iv_act_key             = ms_action-act_key
        iv_det_key             = ms_determination-det_key
        iv_edit_mode           = mv_edit_mode
        iv_state               = mv_current_state
      IMPORTING
        eo_message             = lo_message
          eo_change          = DATA(lo_change) ).

      IF lo_change IS BOUND.
        " Check for failing internal modifications
      IF iv_check_for_failed = abap_true.
        lo_change_cl ?= lo_change.
        IF lo_change_cl->has_failed_changes( ) = abap_true.
            " Raise a fatal exception if a failing internal modification would go unnoticed
            lo_change_cl->get_changes( EXPORTING iv_failed = abap_true
                                       IMPORTING et_change = DATA(lt_failed_change) ).
            raise_failed_change( is_failed_change = lt_failed_change[ 1 ]
                                 io_message       = lo_message ).
        ENDIF.
      ENDIF.

*     Get changes for notification before merging changes into eo_change and mo_change (prevent duplicate notification)
        IF  iv_process_immediately = abap_true
        AND mo_conf->ms_obj-objcat <> /bobf/if_conf_c=>sc_objcat_do.
          lo_change_cl ?= lo_change.
          DATA(lo_change_to_notify) = lo_change_cl->export_changes_for_notify( ).
          mo_bopf->raise_notify_changes( io_change              = lo_change_to_notify
            iv_notify_entire_stack = abap_true ).
      ENDIF.

      IF mo_local_change IS BOUND.
        mo_local_change->merge( lo_change ).
      ELSE.
        mo_local_change ?= lo_change.
      ENDIF.

      IF mv_within_loading = abap_true.
          lo_change->get_changes( EXPORTING iv_change_mode  = /bobf/if_frw_c=>sc_modify_create
                                  IMPORTING et_changed_node = DATA(lt_node_change) ).
          mo_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                                 it_node        = lt_node_change ).
          lo_change->get_changes( EXPORTING iv_change_mode  = /bobf/if_frw_c=>sc_modify_load
                                  IMPORTING et_changed_node = lt_node_change ).
          mo_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                                 it_node        = lt_node_change ).
          lo_change->get_changes( EXPORTING iv_change_mode  = /bobf/if_frw_c=>sc_modify_update
                                  IMPORTING et_changed_node = lt_node_change ).
          mo_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify
                    it_node         = lt_node_change ).
      ELSE.
        mo_change->merge( lo_change ).
      ENDIF.
    ENDIF.

    IF lo_message IS BOUND.
      IF mo_local_message IS BOUND.
        mo_local_message->add( lo_message ).
      ELSE.
        mo_local_message = lo_message.
      ENDIF.
    ENDIF.

    eo_change = lo_change.

      clear_modifications( ).
  ENDIF.

    lo_change_cl ?= mo_change.

    IF  iv_process_immediately         = abap_true
    AND mv_process_immediately_allowed = abap_true
    AND lo_change_cl IS BOUND
    AND lo_change_cl->has_unprocessed_changes( iv_det_processed = abap_false
                                               iv_val_processed = abap_false ).
    mo_bopf->do_detval( EXPORTING io_change                  = mo_change
                                  iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_after_modify
                        IMPORTING eo_message                 = lo_message ).
    " If there are no changes from the Modifications then simply take over all changes from det_val round
    IF lo_change IS BOUND.
      " After collecting all change objects in mo_change
      " Compare it to before detval change object to get the change objects only from detval
        mo_change->get_changes( IMPORTING et_change = DATA(lt_changes) ).
        lo_change->get_changes( IMPORTING et_change = DATA(lt_changes_before) ).

      LOOP AT lt_changes ASSIGNING <ls_change>.
        READ TABLE lt_changes_before WITH TABLE KEY key1 COMPONENTS
          node_key      = <ls_change>-node_key
          key           = <ls_change>-key
          change_mode   = <ls_change>-change_mode
          TRANSPORTING NO FIELDS.
        IF sy-subrc IS NOT INITIAL.
            eo_change->add_change( iv_change_mode = <ls_change>-change_mode
                                   iv_node_key    = <ls_change>-node_key
                                   iv_key         = <ls_change>-key ).
        ENDIF.
      ENDLOOP.
    ELSE.
      eo_change = mo_change.
    ENDIF.

      IF lo_message IS BOUND.
      IF mo_local_message IS NOT BOUND.
        mo_local_message = lo_message.
      ELSE.
        mo_local_message->add( lo_message ).
      ENDIF.
    ENDIF.

      lo_change_cl->set_processed( iv_det_processed = abap_true
                                   iv_val_processed = abap_true ).

    IF eo_change IS BOUND.
      lo_change_cl ?= eo_change.
      lo_change_cl->set_processed( iv_det_processed = abap_true
                                   iv_val_processed = abap_true ).
    ENDIF.
  ENDIF.

  IF iv_process_immediately = abap_true
   AND mo_conf->ms_obj-objcat NE /bobf/if_conf_c=>sc_objcat_do.
      mo_bopf->raise_notify_changes( iv_notify_entire_stack = abap_true ).
  ENDIF.

  mv_processing_end_modify = abap_false.
ENDMETHOD.


METHOD FLUSH_CHANGES.

  DATA lx_root TYPE REF TO cx_root.

  ev_no_error = abap_true.

  TRY.
      end_modify( ).
    CATCH cx_root INTO lx_root.                          "#EC CATCH_ALL
      ev_no_error = abap_false.
      mo_bopf->set_application_error( lx_root ).
  ENDTRY.

ENDMETHOD.


  METHOD get_modification_ctx.
    update_modification_ctx( ).
    LOOP AT mt_modification TRANSPORTING NO FIELDS WHERE node        = iv_node
                                                     AND key         = iv_key
                                                     AND change_mode = iv_change_mode ##primkey.
      DATA(lv_tabix_of_mod) = sy-tabix.

      " find the context in which the modification has been created:
      LOOP AT mt_modification_ctx ASSIGNING FIELD-SYMBOL(<mod_ctx>)
                                  WHERE valid_to >= lv_tabix_of_mod. "#EC CI_STDSEQ
        result = VALUE #( BASE result ( CORRESPONDING #( <mod_ctx> ) ) ).
        EXIT. " first match is the one we are looking for
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.


METHOD INVALIDATE.

  CLEAR mo_local_message.

* if assert fails here: RESET_CONTEXT on accessor class in the preceeding content method missing
  ASSERT ID /BOBF/FRW_ERROR CONDITION /BOBF/CL_TOOL_ASSERT=>INT_ACC_NO_LONGER_USED(
      io_int_access = me
      io_conf       = mo_conf )
      = abap_true.

  mv_valid_if_check              = abap_false.
  mv_valid_if_read               = abap_false.
  mv_valid_if_modify             = abap_false.
  mv_valid_if_query              = abap_false.
  mv_process_immediately_allowed = abap_false.
  mv_invalidate_cache            = abap_false.

  et_mod = mt_modification_bopf.

ENDMETHOD.


METHOD NEW_INSTANCE.

  DATA lv_int_access_addon_active TYPE boole_d.

  CREATE OBJECT eo_internal_access TYPE (iv_class_name)
    EXPORTING
      io_bopf   = io_bopf
      io_conf   = io_conf
      io_buffer = io_buffer
      io_change = io_change.

  /bobf/cl_frw_addon=>addon_active(
    EXPORTING iv_bo_key     = io_conf->ms_obj-bo_key
    IMPORTING ev_int_access = lv_int_access_addon_active ).

  " addon replacement
  IF lv_int_access_addon_active = abap_true.
    /bobf/cl_frw_addon=>adjust_internal_access(
      EXPORTING iv_bo_key = io_conf->ms_obj-bo_key
      CHANGING  co_internal_access = eo_internal_access ).
  ENDIF.

ENDMETHOD.


METHOD NOTIFY_CHANGE_INTERNAL.

  DATA: lo_change      TYPE REF TO /BOBF/CL_FRW_CHANGE,
        lv_external    TYPE boole_d.

  IF mv_valid_if_modify = abap_false.
*   internal read object is not valid -> wrong instance used
    ASSERT ID /BOBF/FRW_ERROR CONDITION 0 = 1.
    mo_bopf->set_application_error( ).
  ENDIF.

  lo_change  ?= mo_change.
  lv_external = lo_change->mv_external.
  lo_change->trace_external_changes( abap_true ).

  mo_change->add_change(
    iv_change_mode = iv_change_mode
    iv_node_key    = iv_node_key
    iv_key         = iv_key
    it_key         = it_key ).

  lo_change->trace_external_changes( lv_external ).

ENDMETHOD.


  METHOD raise_failed_change.
    DATA: lx_previous TYPE REF TO cx_root.

    " search for a message that corresponds to the failed change:
    IF io_message IS BOUND.
      io_message->get( IMPORTING et_message = DATA(lt_message) ).
      LOOP AT lt_message ASSIGNING FIELD-SYMBOL(<ls_message>).
        IF  <ls_message>->ms_origin_location-node_key = is_failed_change-node_key
        AND <ls_message>->ms_origin_location-key      = is_failed_change-key
        AND <ls_message>->severity CA 'WEA'. " Warning, Error, or Abend
          lx_previous = <ls_message>.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.

    " determine the context(s) in which the failed operation was initiated:
    LOOP AT get_modification_ctx( iv_node        = is_failed_change-node_key
                                  iv_key         = is_failed_change-key
                                  iv_change_mode = is_failed_change-change_mode )
         ASSIGNING FIELD-SYMBOL(<originating_ctx>).
      lx_previous = /bobf/cl_tool_application_err=>create_runtime_error( mo_conf
                                                )->set_previous( lx_previous
                                                )->set_context( <originating_ctx>
                                                )->set_responsible_by_context(
                                                )->set_textid( /bobf/cx_frw_core=>sc_origin_of_failed_modify
                                                )->create_exception_for_chaining( ).
    ENDLOOP.

    " raise the exception:
    mo_conf->get_node( EXPORTING iv_node_key = is_failed_change-node_key
                       IMPORTING es_node     = DATA(ls_failed_node) ).
    DATA(lx_int) = NEW /bobf/cx_frw_int_access( textid      = /bobf/cx_frw_int_access=>failed_change_during_end_modif
                                                previous    = lx_previous
                                                bo_name     = mo_conf->ms_obj-bo_name
                                                node_name   = ls_failed_node-node_name
                                                key         = is_failed_change-key
                                                change_mode = is_failed_change-change_mode ).
    RAISE EXCEPTION lx_int.
  ENDMETHOD.


METHOD SET_CONTEXT.

  mv_within_loading              = iv_within_loading.
    mv_loading_node_key            = iv_loading_node_key.
  mv_within_retrieve             = iv_within_retrieve.


  ms_action                      = is_action.
  ms_association                 = is_association.
  ms_determination               = is_determination.
  ms_validation                  = is_validation.
  ms_query                       = is_query.

  update_modification_ctx( ). " add a possibly missing entry
  ms_modification_ctx = VALUE #( act_key   = is_action-act_key
                                 assoc_key = is_association-assoc_key
                                 det_key   = is_determination-det_key
                                 query_key = is_query-query_key ).

  mv_valid_if_read               = iv_read_allowed.
  mv_valid_if_modify             = iv_modify_allowed.
  mv_valid_if_check              = iv_check_allowed.
* mv_valid_if_query              = iv_query_allowed.
  mv_valid_if_query              = abap_true.

  mv_process_immediately_allowed = iv_process_immediately_allowed.

  mt_modification_bopf           = it_mod.

  mv_read_buffer_only            = iv_read_buffer_only.

  mv_invalidate_cache            = iv_invalidate_cache.

ENDMETHOD.


METHOD SET_CURRENT_STATE.

  mv_current_state = iv_current_state.

ENDMETHOD.


METHOD SET_EDIT_MODE.

  mv_edit_mode = iv_edit_mode.

ENDMETHOD.


  METHOD set_keys_for_create_modifictns.
    LOOP AT mt_modification ASSIGNING FIELD-SYMBOL(<mod>) WHERE change_mode = /bobf/if_frw_c=>sc_modify_create
                                                            AND key IS INITIAL ##PRIMKEY.
      <mod>-key = /bobf/cl_frw_factory=>get_new_key( ).
    ENDLOOP.
  ENDMETHOD.


METHOD SET_LAST_STATE.

  mv_last_state = iv_last_state.

ENDMETHOD.


  METHOD update_modification_ctx.
    IF mt_modification IS NOT INITIAL.
      ms_modification_ctx-valid_to = lines( mt_modification ).
      IF mt_modification_ctx IS INITIAL.
        APPEND ms_modification_ctx TO mt_modification_ctx.
      ELSE.
        IF ms_modification_ctx-valid_to > mt_modification_ctx[ lines( mt_modification_ctx ) ]-valid_to.
          APPEND ms_modification_ctx TO mt_modification_ctx.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.