class CL_FAA_DC_SEGMENTS_720 definition
  public
  create public

  global friends CL_FAA_DC_ENGINE_CALL
                 CL_FAA_DC_ENGINE_CALL_720 .

public section.

  interfaces IF_FAA_DC_SEGMENTS_720 .
  interfaces IF_FAA_DC_SEGMENTS_720_C .

  aliases GC_AMOUNT_TYPE
    for IF_FAA_DC_SEGMENTS_720_C~GC_AMOUNT_TYPE .
  aliases GC_AREA_VALUE_SIGN
    for IF_FAA_DC_SEGMENTS_720_C~GC_AREA_VALUE_SIGN .
  aliases GC_BASEVALUE
    for IF_FAA_DC_SEGMENTS_720_C~GC_BASEVALUE .
  aliases GC_CHANGEOVER_METH_AT_END
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_AT_END .
  aliases GC_CHANGEOVER_METH_COUNTRY
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_COUNTRY .
  aliases GC_CHANGEOVER_METH_CUSTOMER
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_CUSTOMER .
  aliases GC_CHANGEOVER_METH_DEPR
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_DEPR .
  aliases GC_CHANGEOVER_METH_IN_UL
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_IN_UL .
  aliases GC_CHANGEOVER_METH_NBV
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_NBV .
  aliases GC_CHANGEOVER_METH_NONE
    for IF_FAA_DC_SEGMENTS_720_C~GC_CHANGEOVER_METH_NONE .
  aliases GC_CLASSIFICATION
    for IF_FAA_DC_SEGMENTS_720_C~GC_CLASSIFICATION .
  aliases GC_DATE
    for IF_FAA_DC_SEGMENTS_720_C~GC_DATE .
  aliases GC_MESSAGE_ID
    for IF_FAA_DC_SEGMENTS_720_C~GC_MESSAGE_ID .
  aliases GC_PERCENT
    for IF_FAA_DC_SEGMENTS_720_C~GC_PERCENT .
  aliases GC_PERIOD_GROUP
    for IF_FAA_DC_SEGMENTS_720_C~GC_PERIOD_GROUP .
  aliases GC_PROCESS
    for IF_FAA_DC_SEGMENTS_720_C~GC_PROCESS .
  aliases GC_ROUNDING_METHOD
    for IF_FAA_DC_SEGMENTS_720_C~GC_ROUNDING_METHOD .
  aliases GC_SCRAPVALUE
    for IF_FAA_DC_SEGMENTS_720_C~GC_SCRAPVALUE .
  aliases GC_SETTING_HALFMONTH
    for IF_FAA_DC_SEGMENTS_720_C~GC_SETTING_HALFMONTH .
  aliases GC_STEP
    for IF_FAA_DC_SEGMENTS_720_C~GC_STEP .
  aliases GC_USELIFE_REDUCTION_IND
    for IF_FAA_DC_SEGMENTS_720_C~GC_USELIFE_REDUCTION_IND .
  aliases MO_PREVIOUS
    for IF_FAA_DC_SEGMENTS_720~MO_PREVIOUS .
  aliases MO_START
    for IF_FAA_DC_SEGMENTS_720~MO_START .
  aliases MS_ASSET_DATA
    for IF_FAA_DC_SEGMENTS_720~MS_ASSET_DATA .
  aliases MS_PROC_DATA
    for IF_FAA_DC_SEGMENTS_720~MS_PROC_DATA .
  aliases MS_TRANSACTION_CNTRL
    for IF_FAA_DC_SEGMENTS_720~MS_TRANSACTION_CNTRL .
  aliases MTS_AREA
    for IF_FAA_DC_SEGMENTS_720~MTS_AREA .
  aliases MTS_CALCAMOUNT
    for IF_FAA_DC_SEGMENTS_720~MTS_CALCAMOUNT .
  aliases MTS_CALCDATA
    for IF_FAA_DC_SEGMENTS_720~MTS_CALCDATA .
  aliases MTS_CALCORDER
    for IF_FAA_DC_SEGMENTS_720~MTS_CALCORDER .
  aliases MTS_HLPSEG
    for IF_FAA_DC_SEGMENTS_720~MTS_HLPSEG .
  aliases MTS_PLANVALUE
    for IF_FAA_DC_SEGMENTS_720~MTS_PLANVALUE .
  aliases MT_AREASIGN
    for IF_FAA_DC_SEGMENTS_720~MT_AREASIGN .
  aliases MT_PARAMETER
    for IF_FAA_DC_SEGMENTS_720~MT_PARAMETER .
  aliases MT_PERIOD
    for IF_FAA_DC_SEGMENTS_720~MT_PERIOD .
  aliases MT_ROUNDING
    for IF_FAA_DC_SEGMENTS_720~MT_ROUNDING .
  aliases MT_SUMSEG
    for IF_FAA_DC_SEGMENTS_720~MT_SUMSEG .
  aliases MT_SYMSG
    for IF_FAA_DC_SEGMENTS_720~MT_SYMSG .
  aliases MT_TIMESEG
    for IF_FAA_DC_SEGMENTS_720~MT_TIMESEG .
  aliases MT_TRANSACTION
    for IF_FAA_DC_SEGMENTS_720~MT_TRANSACTION .
  aliases MT_TRANSACTION_POST
    for IF_FAA_DC_SEGMENTS_720~MT_TRANSACTION_POST .
  aliases MT_VIRTAREA
    for IF_FAA_DC_SEGMENTS_720~MT_VIRTAREA .
  aliases MT_YEARSEG
    for IF_FAA_DC_SEGMENTS_720~MT_YEARSEG .
  aliases CHECK_BADI_IS_ACTIVE
    for IF_FAA_DC_SEGMENTS_720~CHECK_BADI_IS_ACTIVE .
  aliases PERFORM_CALC_WITH_IMPLICIT_CF
    for IF_FAA_DC_SEGMENTS_720~PERFORM_CALC_WITH_IMPLICIT_CF .
  aliases PERFORM_STEP_PROCESSING
    for IF_FAA_DC_SEGMENTS_720~PERFORM_STEP_PROCESSING .
  aliases TY_O_DC_CALC_HANDLE
    for IF_FAA_DC_SEGMENTS_720~TY_O_DC_CALC_HANDLE .
  aliases TY_O_DC_MESSAGE_HANDLE
    for IF_FAA_DC_SEGMENTS_720~TY_O_DC_MESSAGE_HANDLE .
  aliases TY_O_INDEXSERIES_HANDLE
    for IF_FAA_DC_SEGMENTS_720~TY_O_INDEXSERIES_HANDLE .
  aliases TY_SX_EE_EDATA
    for IF_FAA_DC_SEGMENTS_720~TY_SX_EE_EDATA .
  aliases TY_SX_EE_IDATA
    for IF_FAA_DC_SEGMENTS_720~TY_SX_EE_IDATA .
  aliases TY_S_AREA
    for IF_FAA_DC_SEGMENTS_720~TY_S_AREA .
  aliases TY_S_AREAREF
    for IF_FAA_DC_SEGMENTS_720~TY_S_AREAREF .
  aliases TY_S_AREASIGN
    for IF_FAA_DC_SEGMENTS_720~TY_S_AREASIGN .
  aliases TY_S_ASSET_DATA
    for IF_FAA_DC_SEGMENTS_720~TY_S_ASSET_DATA .
  aliases TY_S_CALCAMOUNT
    for IF_FAA_DC_SEGMENTS_720~TY_S_CALCAMOUNT .
  aliases TY_S_CALCDATA
    for IF_FAA_DC_SEGMENTS_720~TY_S_CALCDATA .
  aliases TY_S_CALCORDER
    for IF_FAA_DC_SEGMENTS_720~TY_S_CALCORDER .
  aliases TY_S_DEPRAREA
    for IF_FAA_DC_SEGMENTS_720~TY_S_DEPRAREA .
  aliases TY_S_DEPRKEY
    for IF_FAA_DC_SEGMENTS_720~TY_S_DEPRKEY .
  aliases TY_S_DUEVALUE
    for IF_FAA_DC_SEGMENTS_720~TY_S_DUEVALUE .
  aliases TY_S_EE_CURRENCY
    for IF_FAA_DC_SEGMENTS_720~TY_S_EE_CURRENCY .
  aliases TY_S_EE_ERROR
    for IF_FAA_DC_SEGMENTS_720~TY_S_EE_ERROR .
  aliases TY_S_HLPSEG
    for IF_FAA_DC_SEGMENTS_720~TY_S_HLPSEG .
  aliases TY_S_INDEXSERIES
    for IF_FAA_DC_SEGMENTS_720~TY_S_INDEXSERIES .
  aliases TY_S_PARAMETER
    for IF_FAA_DC_SEGMENTS_720~TY_S_PARAMETER .
  aliases TY_S_PERIOD
    for IF_FAA_DC_SEGMENTS_720~TY_S_PERIOD .
  aliases TY_S_PLANVALUE
    for IF_FAA_DC_SEGMENTS_720~TY_S_PLANVALUE .
  aliases TY_S_PROCESSING_INFO
    for IF_FAA_DC_SEGMENTS_720~TY_S_PROCESSING_INFO .
  aliases TY_S_PROC_DATA
    for IF_FAA_DC_SEGMENTS_720~TY_S_PROC_DATA .
  aliases TY_S_ROUNDING
    for IF_FAA_DC_SEGMENTS_720~TY_S_ROUNDING .
  aliases TY_S_SUMSEG
    for IF_FAA_DC_SEGMENTS_720~TY_S_SUMSEG .
  aliases TY_S_SYMSG
    for IF_FAA_DC_SEGMENTS_720~TY_S_SYMSG .
  aliases TY_S_TIMESEG
    for IF_FAA_DC_SEGMENTS_720~TY_S_TIMESEG .
  aliases TY_S_TRANSACTION
    for IF_FAA_DC_SEGMENTS_720~TY_S_TRANSACTION .
  aliases TY_S_VALUE
    for IF_FAA_DC_SEGMENTS_720~TY_S_VALUE .
  aliases TY_S_VIRTAREA
    for IF_FAA_DC_SEGMENTS_720~TY_S_VIRTAREA .
  aliases TY_S_YEARSEG
    for IF_FAA_DC_SEGMENTS_720~TY_S_YEARSEG .
  aliases TY_TS_CALCAMOUNT
    for IF_FAA_DC_SEGMENTS_720~TY_TS_CALCAMOUNT .
  aliases TY_TS_CALCDATA
    for IF_FAA_DC_SEGMENTS_720~TY_TS_CALCDATA .
  aliases TY_TS_CALCORDER
    for IF_FAA_DC_SEGMENTS_720~TY_TS_CALCORDER .
  aliases TY_TS_DEPRKEY_PERIOD_DETERMIN
    for IF_FAA_DC_SEGMENTS_720~TY_TS_DEPRKEY_PERIOD_DETERMIN .
  aliases TY_TS_DEPRKEY_PHASE
    for IF_FAA_DC_SEGMENTS_720~TY_TS_DEPRKEY_PHASE .
  aliases TY_TS_HLPSEG
    for IF_FAA_DC_SEGMENTS_720~TY_TS_HLPSEG .
  aliases TY_T_AREA
    for IF_FAA_DC_SEGMENTS_720~TY_T_AREA .
  aliases TY_T_AREASIGN
    for IF_FAA_DC_SEGMENTS_720~TY_T_AREASIGN .
  aliases TY_T_PARAMETER
    for IF_FAA_DC_SEGMENTS_720~TY_T_PARAMETER .
  aliases TY_T_PERIOD
    for IF_FAA_DC_SEGMENTS_720~TY_T_PERIOD .
*  aliases TY_T_POSTVALUE
*    for IF_FAA_DC_SEGMENTS_720~TY_T_POSTVALUE .
  aliases TY_T_ROUNDING
    for IF_FAA_DC_SEGMENTS_720~TY_T_ROUNDING .
  aliases TY_T_SUMSEG
    for IF_FAA_DC_SEGMENTS_720~TY_T_SUMSEG .
  aliases TY_T_SYMSG
    for IF_FAA_DC_SEGMENTS_720~TY_T_SYMSG .
  aliases TY_T_TIMESEG
    for IF_FAA_DC_SEGMENTS_720~TY_T_TIMESEG .
  aliases TY_T_TRANSACTION
    for IF_FAA_DC_SEGMENTS_720~TY_T_TRANSACTION .
  aliases TY_T_YEARSEG
    for IF_FAA_DC_SEGMENTS_720~TY_T_YEARSEG .

  class-data GO_BADI_COUNTRY type ref to IF_EX_FAA_DC_COUNTRY read-only .
  class-data GO_BADI_CUSTOMER type ref to IF_EX_FAA_DC_CUSTOMER read-only .

  class-methods CLASS_CONSTRUCTOR .
  methods CREATE_MESSAGE_FROM_SYST
    changing
      !CO_MESSAGE_HANDLE type TY_O_DC_MESSAGE_HANDLE optional
    raising
      CM_FAA_T100_DC_720 .
protected section.

  methods ADJUST_PROP_VALUES_ON_MINVAL
    importing
      !IS_CALCAMOUNT type TY_S_CALCAMOUNT
      !IS_YEARSEG type TY_S_YEARSEG
      !IS_SUMSEG type TY_S_SUMSEG
      !IS_AREASIGN type TY_S_AREASIGN
      !IS_AREA type TY_S_AREA
    changing
      !CS_TRANSACTION type TY_S_TRANSACTION
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods ADJUST_USEFUL_LIFE
    importing
      !IS_HLPSEG type TY_S_HLPSEG
    changing
      !CS_PERIOD type TY_S_PERIOD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_AREA_SIGNS
    importing
      !IO_AREAREF type TY_S_HLPSEG-AREAREF
      !ID_NEG_VALUES type TY_S_HLPSEG-NEG_VALUES
    exporting
      !ES_AREASIGN type TY_S_AREASIGN .
  methods GET_BASE_DATE_AND_YR_AND_PRD
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !ID_DETERMINATION_RULE type NUM1
      !ID_BASE_RULE type CHAR1
    exporting
      !ED_BASE_DATE type DATS
      !ED_BASE_PRD type NUMC3
      !ED_BASE_YR type NUMC4
      !ED_BASE_FYR type NUMC4
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_CALC_INFO_FOR_AMOUNT_TYPE
    importing
      !IS_DEPR_PARAM type TY_S_DEPRAREA-DEPR_PARAM
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_CALC_YR_AND_PER_4_TRNSCTN
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IV_PER_CTRL_GROUP type TABWG-PERGRP
      !IV_VALUE_DATE type BZDAT
    exporting
      !EV_FISCAL_YEAR type FAA_DC_START_YR
      !EV_CALCULATION_PERIOD type FAA_DC_START_PRD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_CALC_YR_AND_PER_FROM_DATE
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IV_PER_CTRL_GROUP type TABWG-PERGRP
      !IV_VALUE_DATE type BZDAT
    exporting
      !EV_FISCAL_YEAR type FAA_DC_START_YR
      !EV_CALCULATION_PERIOD type FAA_DC_START_PRD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_DATA_FROM_BADI
    changing
      !CS_HLPSEG type FAA_DC_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_DATA_FROM_PRIOR_YEAR
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_DEPR_PARAM
    importing
      !IS_DEPR_PARAM type TY_S_DEPRAREA-DEPR_PARAM
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_EXPIRED_LIFE_FOR_INTERVAL
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_NETBOOK_VALUE
    importing
      !IS_CALCAMOUNT type TY_S_CALCAMOUNT optional
      !IS_YEARSEG type TY_S_YEARSEG optional
      !IS_SUMSEG type TY_S_SUMSEG optional
      !IS_AREASIGN type TY_S_AREASIGN optional
      !IS_AREA type TY_S_AREA optional
    returning
      value(RV_NETBOOK_VALUE) type TY_S_YEARSEG-CUM-APC
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_PHASE_AND_DEPRKEY_CONFIG
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_PRCNTG_ON_UNITS_OF_PROD
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IS_PARAMETER type TY_S_PARAMETER
      !ID_FISC_YEAR type TY_S_HLPSEG-FYEAR
      !ID_PERIOD_FROM type TY_S_HLPSEG-PERIOD_FROM
      !ID_PERIOD_TO type TY_S_HLPSEG-PERIOD_FROM
    exporting
      !ED_PERCENTAGE type TY_S_PARAMETER-PERCENT_STATED
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_REPL_PARAM
    changing
      !CS_HLPSEG type FAA_DC_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_SHIFTED_PERIOD_FROM_AND_TO
    importing
      !ID_DETERMINATION_RULE type NUM1
      !ID_BASE_DATE type DATS
      !IS_HLPSEG type TY_S_HLPSEG
      !ID_BASE_PRD type NUMC3
      !ID_BASE_FYR type NUMC4
    changing
      !CD_PERIOD_TO type INT2
      !CD_PERIOD_FROM type INT2
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods PREPARE_BADI_CALL
    changing
      value(CO_DC_SEGMENT_HANDLE) type FAA_DC_SEGMENT_HANDLE .
  methods SET_ASSET_DATA
    importing
      !IS_ASSET_DATA type TY_S_ASSET_DATA
      !IS_TRANSACTION_POST type TY_S_TRANSACTION optional
      !IT_TRANSACTION_POST type TY_T_TRANSACTION optional .
  methods SET_PROCESS_CONTROL_DATA
    importing
      !IS_PROCESS_CONTROL_DATA type TY_S_PROC_DATA
      !ITS_AREA type TY_T_AREA
      !IO_PREVIOUS type ref to OBJECT .
  methods _AREASIGN_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _CALCAMOUNT_CREATE
    exceptions
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _CALCORDER_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _CALCORDER_CREATE
    exceptions
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_CO_YR_AND_PRD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_DEACT_DATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_EXP_LIFE_SEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_LAST_RET_DATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_AT_UL_END
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_IN_MAX_PRDS
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_ALIGNMENT
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_COV_KEY
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_DIGITAL
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_MLM
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_MLM_DAT
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_TIMESEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PARAMETER_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PARAMETER_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PERIOD_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PLANVALUE_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720
      CM_FAA_T100 .
  methods _PROPVALUE_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _ROUNDING_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _ROUNDING_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _SUMSEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TIMESEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TIMESEG_CREATE_MISSING
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADD_ON_POSTCAP
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADD_ON_POSTING
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADD_ON_RETIREMENT
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADJST_ON_REVERSAL
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_CREATE_FROM_DB
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _VALUES_CALCULATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _VALUES_CHECK_ON_POSTING
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _VIRTAREA_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _YEARSEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
private section.
ENDCLASS.



CLASS CL_FAA_DC_SEGMENTS_720 IMPLEMENTATION.


METHOD adjust_prop_values_on_minval.
*=======================================================================
* On partial retirement system has to insure that minval rules ar not hurt
* therfore the calculated proportional values may need to be adjusted
* to st√≠ck to the rules
* The adjustment is performed by the following rules:
* - first adjust values of structure CUR
* - then  adjust values of structure PREV_CUR
* - at last adjust values of structure PREV_PREV
* - within each structure adjustment sequence is:
*   ordinary depr., special depr., unplanned depr., reserves
*=======================================================================

* DEFINITIONS
  FIELD-SYMBOLS <ls_value1>    TYPE ty_s_value.
  FIELD-SYMBOLS <ls_value2>    TYPE ty_s_value.

  FIELD-SYMBOLS <lv_value1>    TYPE ty_s_value-apc.
  FIELD-SYMBOLS <lv_value2>    TYPE ty_s_value-apc.

  CONSTANTS lc_sign_minus      TYPE c VALUE '-'.

  DATA ls_parameter            TYPE ty_s_parameter.
  DATA ls_transaction	         TYPE ty_s_transaction.

  DATA lv_nbv_before_ret       TYPE ty_s_yearseg-cum-apc.
  DATA lv_nbv_after_ret        TYPE ty_s_yearseg-cum-apc.
  DATA lv_nbv_of_ret           TYPE ty_s_yearseg-cum-apc.
  DATA lv_adjustment           TYPE ty_s_yearseg-cum-apc.
  DATA lv_minval               TYPE ty_s_yearseg-cum-apc.
  DATA lv_index                TYPE int1.

  DATA lv_repl_value           TYPE ty_s_calcdata-amount.
  DATA lv_minval_float         TYPE ty_s_calcdata-amount.
  DATA lv_minval_memo          TYPE ty_s_parameter-minval_memo.

* BODY

* calculate netbook value based on the base values for prop. value calc.
  lv_nbv_before_ret = get_netbook_value(
                        EXPORTING
                          is_calcamount  = is_calcamount
                          is_yearseg     = is_yearseg
                          is_sumseg      = is_sumseg
                          is_areasign    = is_areasign
                          is_area        = is_area ).

* calculate netbook value of the actual retirement
  lv_nbv_of_ret     = cs_transaction-cur-apc
                    + cs_transaction-cur-downp
                    + cs_transaction-cur-invs
                    + cs_transaction-cur-revl
                    + cs_transaction-cur-revl_d
                    + cs_transaction-cur-depr_o
                    + cs_transaction-cur-depr_s
                    + cs_transaction-cur-depr_u
                    + cs_transaction-cur-resv

                    + cs_transaction-prev_cur-apc
                    + cs_transaction-prev_cur-downp
*                    + cs_transaction-prev_cur-invs
                    + cs_transaction-prev_cur-revl
                    + cs_transaction-prev_cur-revl_d
                    + cs_transaction-prev_cur-depr_o
                    + cs_transaction-prev_cur-depr_s
                    + cs_transaction-prev_cur-depr_u
                    + cs_transaction-prev_cur-resv

                    + cs_transaction-prev_prev-apc
                    + cs_transaction-prev_prev-downp
*                    + is_sumseg-prev_prev-invs
                    + cs_transaction-prev_prev-revl
                    + cs_transaction-prev_prev-revl_d
                    + cs_transaction-prev_prev-depr_o
                    + cs_transaction-prev_prev-depr_s
                    + cs_transaction-prev_prev-depr_u
                    + cs_transaction-prev_prev-resv.

* get netbook value including retirement
  lv_nbv_after_ret = lv_nbv_before_ret + lv_nbv_of_ret.

* get cut off value to be considered
  READ TABLE mt_parameter INTO ls_parameter
      WITH KEY area      = is_area-depr_area.

  ASSERT sy-subrc = 0.

  CLEAR lv_minval.
  IF mo_start->ms_asset_data-ignore_memval EQ abap_false.
    ls_parameter-minval_memo = is_area-arearef->msx_areadef-memo_value.
  ENDIF.

* calculate replacement value as base for scrap value
  lv_repl_value   =
*         "cumulated, posted, proportional values at fiscal year start
                      is_yearseg-cum-apc
                    + is_yearseg-cum-downp
                    + is_yearseg-cum-invs
                    + is_yearseg-cum-revl
                    + is_yearseg-cum-resv

*         "current year calculated and posted values
                    + is_sumseg-cur-apc
                    + is_sumseg-cur-downp
                    + is_sumseg-cur-invs
                    + is_sumseg-cur-revl
                    + is_sumseg-cur-resv

                    + is_sumseg-prev_cur-apc
                    + is_sumseg-prev_cur-downp
                    + is_sumseg-prev_cur-invs
                    + is_sumseg-prev_cur-revl
                    + is_sumseg-prev_cur-resv

                    + is_sumseg-prev_prev-apc
                    + is_sumseg-prev_prev-downp
                    + is_sumseg-prev_prev-invs
                    + is_sumseg-prev_prev-revl
                    + is_sumseg-prev_prev-resv

                    + is_calcamount-total-revl

*         "posted values from current transaction
                    + cs_transaction-prev_prev-apc
                    + cs_transaction-cur-apc
                    + cs_transaction-prev_prev-revl
                    + cs_transaction-prev_cur-revl
                    + cs_transaction-cur-revl.

  CALL METHOD cl_faa_ee=>_calc_min_value
    EXPORTING
      id_replvalue = lv_repl_value
      id_repl_prev = lv_repl_value
      it_parameter = ls_parameter
    IMPORTING
      ed_minvalue  = lv_minval_float.

  CALL METHOD cl_faa_ee=>_round_value
    EXPORTING
      id_place    = ls_parameter-minval_rndplace
      id_decimals = ls_parameter-minval_rnddecim
      id_method   = ls_parameter-minval_rndmethod
    CHANGING
      cd_value    = lv_minval_float.

  IF is_areasign-apc  = '0' AND
     is_areasign-invs = '-'.
    lv_minval_memo = - ls_parameter-minval_memo.
  ELSE.
    lv_minval_memo = ls_parameter-minval_memo.
  ENDIF.

  IF abs( lv_minval_memo ) > abs( lv_minval_float ).
    lv_minval_float = lv_minval_memo.
  ENDIF.

  lv_minval = lv_minval_float.

* minval not hurt => process next valuation view
  IF abs( lv_nbv_after_ret ) >= abs( lv_minval ).
    RETURN.
  ENDIF.

* minval already passed pefore retirement => process next valuation view
  IF abs( lv_nbv_before_ret ) < abs( lv_minval ).
    RETURN.
  ENDIF.

* netbook value of retirement zero => process next valuation view
  IF abs( lv_nbv_of_ret ) < 0.
    RETURN.
  ENDIF.

* determine adjustment amount if zero => process next valuation view
  lv_adjustment = lv_nbv_after_ret - lv_minval.

  IF abs( lv_adjustment ) = 0.
    RETURN.
  ENDIF.

* get maximum amounts for possible adjustments
  ls_transaction-cur-depr_o       = cs_transaction-cur-depr_o
                                + is_sumseg-cur-depr_o
                                + is_calcamount-total-depr_o
                                - is_calcamount-prev-depr_o.
  ls_transaction-cur-depr_s       = cs_transaction-cur-depr_s
                                + is_sumseg-cur-depr_s
                                + is_calcamount-total-depr_s
                                - is_calcamount-prev-depr_s.
  ls_transaction-cur-depr_u       = cs_transaction-cur-depr_u
                                + is_sumseg-cur-depr_u.
  ls_transaction-cur-resv         = cs_transaction-cur-resv
                                + is_sumseg-cur-resv.
  ls_transaction-prev_cur-depr_o  = cs_transaction-prev_cur-depr_o
                                + is_sumseg-prev_cur-depr_o
                                + is_yearseg-cum-depr_o.
  ls_transaction-prev_cur-depr_s  = cs_transaction-prev_cur-depr_s
                                + is_sumseg-prev_cur-depr_s
                                + is_yearseg-cum-depr_s.
  ls_transaction-prev_cur-depr_u  = cs_transaction-prev_cur-depr_u
                                + is_sumseg-prev_cur-depr_u.
  ls_transaction-prev_cur-resv    = cs_transaction-prev_cur-resv
                                + is_sumseg-prev_cur-resv.
  ls_transaction-prev_prev-depr_o = cs_transaction-prev_prev-depr_o
                                + is_sumseg-prev_prev-depr_o
                                + is_yearseg-cum-depr_o.
  ls_transaction-prev_prev-depr_s = cs_transaction-prev_prev-depr_s
                                + is_sumseg-prev_prev-depr_s
                                + is_yearseg-cum-depr_s.
  ls_transaction-prev_prev-depr_u = cs_transaction-prev_prev-depr_u
                                + is_sumseg-prev_prev-depr_u.
  ls_transaction-prev_prev-resv   = cs_transaction-prev_prev-resv
                                + is_sumseg-prev_prev-resv.

  DO 3 TIMES.

    CASE sy-index.
      WHEN 1.
        ASSIGN ls_transaction-cur         TO <ls_value1>.
        ASSIGN cs_transaction-cur       TO <ls_value2>.
      WHEN 2.
        ASSIGN ls_transaction-prev_cur    TO <ls_value1>.
        ASSIGN cs_transaction-prev_cur  TO <ls_value2>.
      WHEN 3.
        ASSIGN ls_transaction-prev_prev   TO <ls_value1>.
        ASSIGN cs_transaction-prev_prev TO <ls_value2>.
    ENDCASE.

    DO 4 TIMES.
      lv_index = sy-index + 3.

      ASSIGN COMPONENT lv_index OF STRUCTURE <ls_value1> TO <lv_value1>.
      CHECK <lv_value1> <> 0.
      ASSIGN COMPONENT lv_index OF STRUCTURE <ls_value2> TO <lv_value2>.

      IF is_areasign-sign = lc_sign_minus.
        <lv_value2>       =  0 - <lv_value2>.
        <lv_value1>       =  0 - <lv_value1>.
        lv_adjustment     =  0 - lv_adjustment.
      ENDIF.

      IF <lv_value2> > 0.
        IF lv_adjustment < 0.
          IF <lv_value1> > lv_adjustment.
            <lv_value2>   = <lv_value2> - <lv_value1>.
            lv_adjustment = lv_adjustment - <lv_value1>.
          ELSE.
            <lv_value2>   = <lv_value2> - lv_adjustment.
            lv_adjustment = 0.
          ENDIF.
        ELSE.
          IF <lv_value2> > lv_adjustment.
            <lv_value2>   = <lv_value2> - lv_adjustment.
            lv_adjustment = 0.
          ELSE.
            lv_adjustment = lv_adjustment - <lv_value2>.
            <lv_value2>   = 0.
          ENDIF.
        ENDIF.
      ENDIF.

* For negative areas change sign
      IF is_areasign-sign = lc_sign_minus.
        <lv_value2>       =  0 - <lv_value2>.
        <lv_value1>       =  0 - <lv_value1>.
        lv_adjustment     =  0 - lv_adjustment.
      ENDIF.

* leave if nothing left to adjust
      CHECK lv_adjustment EQ 0.
      EXIT.
    ENDDO.
  ENDDO.

* POSTCONDITION
  "none
ENDMETHOD.


  METHOD ADJUST_USEFUL_LIFE.

    DATA lv_last_day_of_calc   TYPE dats.
    DATA lv_last_day_of_yr     TYPE dats  VALUE '00001231'. ##VALUE_OK
    DATA lv_periods            TYPE numc3.
    DATA lv_periods_in_fyr     TYPE numc3.
    DATA lv_periods_reduced    TYPE int4.
    DATA lv_periods_covered    TYPE int4.
    DATA lv_fyear              TYPE numc4.
    DATA lv_useful_life_yrs    TYPE int4.
    DATA lv_useful_life_prds   TYPE int4.

* set flag if expired life is to be calculated from change over year
    CASE is_hlpseg-keyref->ms_settings-uselife_reduce.
      WHEN abap_true.

        CASE is_hlpseg-use_days.

*// daily calculation
          WHEN abap_true.

* determine end date of depreciation calculation with correct year assignment
            lv_last_day_of_calc = is_hlpseg-start_date.
            lv_useful_life_yrs  = is_hlpseg-useful_life_yrs.
            lv_useful_life_prds = is_hlpseg-useful_life_prds.

            CALL FUNCTION 'FIMA_DATE_CREATE'
              EXPORTING
                i_date   = is_hlpseg-start_date
                i_years  = lv_useful_life_yrs
                i_months = lv_useful_life_prds
              IMPORTING
                e_date   = lv_last_day_of_calc.

            lv_last_day_of_calc = lv_last_day_of_calc - 1.

            IF lv_last_day_of_calc+4(4) = lv_last_day_of_yr+4(4) OR
               lv_last_day_of_calc+0(4) = is_hlpseg-start_yr.

              cs_period-useful_life = is_hlpseg-useful_life.
              RETURN.
            ENDIF.

* check if useful life has to end in depreciation start year due to reduction
            lv_last_day_of_calc+0(4) = lv_last_day_of_calc+0(4) - 1.

            IF lv_last_day_of_calc+0(4) <= is_hlpseg-start_yr.
              lv_last_day_of_yr+0(4) = is_hlpseg-start_yr.
              cs_period-useful_life  = lv_last_day_of_yr - is_hlpseg-start_date + 1.
              RETURN.
            ENDIF.

* adjustment of useful life is required if enddate is in a future year and not last day of the year
* determine days covered within last year of useful life by ignoring leap years
* thus we adjust the years to (any) none leap years
            lv_last_day_of_calc+4(4) = lv_last_day_of_yr+4(4).

            cs_period-useful_life    = ( lv_last_day_of_calc+0(4) - is_hlpseg-start_yr ) * 365.

            lv_last_day_of_yr+0(4)   = is_hlpseg-start_yr.

            cs_period-useful_life    = cs_period-useful_life
                                     + ( lv_last_day_of_yr - is_hlpseg-start_date + 1 ).

* if depr. starts before first of March in leap year just adjust regard 365 periods for calc.
            IF is_hlpseg-periods          = 366 AND
               is_hlpseg-start_date+4(2) <= '02'.

              cs_period-useful_life = cs_period-useful_life - 1.
            ENDIF.


*// period based calculation
          WHEN OTHERS.

* determine periods coverd within start year
            lv_periods_in_fyr  = is_hlpseg-periods     - is_hlpseg-start_prd  + 1.

* determine count of periods left excluding start year
            lv_periods_reduced = is_hlpseg-useful_life - lv_periods_in_fyr.

            IF lv_periods_reduced <= 0.
              cs_period-useful_life = is_hlpseg-useful_life.
              RETURN.
            ENDIF.

* useful life ends within year that succeeds start year => take periods in start year as UL
            IF lv_periods_reduced < is_hlpseg-periods.
              cs_period-useful_life = lv_periods_in_fyr.
              RETURN.
            ENDIF.

* determine count of overhanging periods in last year of useful life
            lv_periods_reduced    = lv_periods_reduced MOD is_hlpseg-periods.

            cs_period-useful_life = is_hlpseg-useful_life - lv_periods_reduced.

            RETURN.
        ENDCASE.

* special logic required if there were shortened fiscal years in the past
      WHEN gc_uselife_reduction_ind-shortyear_reduction.

* determine remaining useful life
        cs_period-useful_life = is_hlpseg-useful_life - is_hlpseg-exp_life.

* no adjustment required if useful life ends within second year of usage
        IF cs_period-useful_life <= is_hlpseg-periods AND
           cs_period-exp_life    <= is_hlpseg-periods.

          cs_period-useful_life = is_hlpseg-useful_life.

          EXIT.
* adjust useful life in that way that remaining useful life covers just whole years
        ELSE.
          cs_period-useful_life = is_hlpseg-useful_life - ( cs_period-useful_life MOD is_hlpseg-periods ).
        ENDIF.

        CHECK is_hlpseg-arearef->if_faa_cfg_leadobj~msx_settings-has_short_fyear <> space.

        lv_fyear = is_hlpseg-start_yr + 1.
        CHECK is_hlpseg-fyear > lv_fyear.

        WHILE lv_fyear < is_hlpseg-fyear.
          CALL METHOD is_hlpseg-arearef->if_faa_cfg_leadobj~get_number_of_periods
            EXPORTING
              id_fisc_year        = lv_fyear
            IMPORTING
              ed_periods          = lv_periods
              ed_periods_short_fy = lv_periods_in_fyr.

          lv_fyear = lv_fyear + 1.

          CHECK lv_periods_in_fyr < lv_periods .
          CHECK lv_periods_in_fyr > 0 .

          lv_periods_reduced  = lv_periods_reduced + lv_periods  - lv_periods_in_fyr.
          lv_periods_covered  = lv_periods_covered + lv_periods_in_fyr.
        ENDWHILE.

        cs_period-useful_life = is_hlpseg-useful_life - ( is_hlpseg-exp_life + lv_periods_reduced ).

        CHECK is_hlpseg-changeover_yr IS INITIAL.
        cs_period-useful_life = cs_period-useful_life + lv_periods_covered.
    ENDCASE.
  ENDMETHOD.


  METHOD class_constructor.
    CHECK cl_faa_tdc_activation=>get_tdc_active( ) = abap_false.

* check if there is any active BADI implementation for country specific issues
    CALL METHOD cl_exithandler=>get_instance
      EXPORTING
        exit_name              = 'FAA_DC_COUNTRY'
        null_instance_accepted = abap_true
      CHANGING
        instance               = go_badi_country.

* check if there is any active BADI implementation for customer specific issues
* if system is managed on premise
    IF cl_cos_utilities=>is_s4h_on_premise( ) = abap_true.
      CALL METHOD cl_exithandler=>get_instance
        EXPORTING
          exit_name              = 'FAA_DC_CUSTOMER'
          null_instance_accepted = abap_true
        CHANGING
          instance               = go_badi_customer.
    ENDIF.
  ENDMETHOD.


METHOD create_message_from_syst.
  DATA lo_message_handle      TYPE ty_o_dc_message_handle.

  DATA ls_rounding            TYPE ty_s_rounding.
  DATA ls_textid              LIKE if_t100_message=>t100key.
  DATA ls_symsg               TYPE symsg.

  DATA lv_depr_area           TYPE ty_s_area-depr_area.
  DATA lv_minvalue_float      TYPE f.

  MOVE-CORRESPONDING syst TO ls_symsg.

  CASE ls_symsg-msgno(1).
    WHEN 0.
      IF sy-msgno <> 087.                                   "2223258
        ls_symsg-msgno = 698.
      ENDIF.

* exchange first digit of message number by 6, digits 2 and 3 correspond to Messageid AA
    WHEN 1.
      ls_symsg-msgno(1) = 6.
  ENDCASE.

  CASE ls_symsg-msgno.

* check if write up posting related with ord. depr. causes error message
    WHEN 624
      OR 625.

      IF ms_transaction_cntrl-classification EQ gc_classification-write_up.
        ls_symsg-msgno = 634.
      ENDIF.

* check if write up posting related with spec. depr. causes error message
    WHEN 626
      OR 627.
      IF ms_transaction_cntrl-classification EQ gc_classification-write_up.
        ls_symsg-msgno = 635.
      ENDIF.

*   invalid transaction typ used on manual revaluation => adjust content of MSGV1 to provide the asset number
    WHEN 629.                                               "2345009
      CLEAR       ls_symsg-msgv1.
      CONCATENATE ms_asset_data-asset_main_number '-' ms_asset_data-asset_sub_number INTO ls_symsg-msgv1.

*   Error message 632 for scrap value needs minimum value
    WHEN 632.
      lv_depr_area = sy-msgv1.
      READ TABLE mt_rounding INTO ls_rounding
        WITH KEY area = lv_depr_area.

      IF sy-subrc NE 0.
        CLEAR ls_rounding.
      ENDIF.

      lv_minvalue_float = syst-msgv1.
      WRITE lv_minvalue_float TO syst-msgv1 LEFT-JUSTIFIED EXPONENT 0 DECIMALS ls_rounding-place.

    WHEN 660.
      IF ms_transaction_cntrl-classification EQ gc_classification-depreciation.
        ls_symsg-msgno = 590.
      ENDIF.
  ENDCASE.

  ls_textid-msgid = gc_message_id.
  ls_textid-msgno = ls_symsg-msgno.
  ls_textid-attr1 = 'MV_SY_MSGV1'.
  ls_textid-attr2 = 'MV_SY_MSGV2'.
  ls_textid-attr3 = 'MV_SY_MSGV3'.
  ls_textid-attr4 = 'MV_SY_MSGV4'.

  CREATE OBJECT lo_message_handle
    EXPORTING
      textid               = ls_textid
      severity             = cm_faa_t100=>co_severity_error
      mv_bukrs             = ms_proc_data-company_code
      mv_ledger_group      = ms_proc_data-ledger_group
      mv_fisc_year         = ms_proc_data-fyear
      mv_asset_main_number = ms_asset_data-asset_main_number
      mv_asset_sub_number  = ms_asset_data-asset_sub_number
      mv_sy_msgv1          = ls_symsg-msgv1
      mv_sy_msgv2          = ls_symsg-msgv2
      mv_sy_msgv3          = ls_symsg-msgv3
      mv_sy_msgv4          = ls_symsg-msgv4.

  IF co_message_handle IS BOUND.
    CALL METHOD co_message_handle->add_detail_message_reference
      EXPORTING
        io_message = lo_message_handle.
  ELSE.
    co_message_handle = lo_message_handle.
    IF co_message_handle IS NOT REQUESTED.
      RAISE EXCEPTION lo_message_handle.
    ENDIF.
  ENDIF.
ENDMETHOD.


  METHOD GET_AREA_SIGNS.
    es_areasign-area   = io_arearef->md_deprarea.
    es_areasign-apc    = io_arearef->msx_areadef-sign_apc.
    es_areasign-nbv    = io_arearef->msx_areadef-sign_nbv.
    es_areasign-invs   = io_arearef->msx_areadef-sign_invest.
    es_areasign-resv   = io_arearef->msx_areadef-sign_reserve.
    es_areasign-depr_o = io_arearef->msx_areadef-sign_depr_o.
    es_areasign-depr_s = io_arearef->msx_areadef-sign_depr_s.
    es_areasign-depr_u = io_arearef->msx_areadef-sign_depr_u.
    es_areasign-revl   = io_arearef->msx_areadef-sign_revl_apc.
    es_areasign-intr   = io_arearef->msx_areadef-sign_interest.
    es_areasign-revl_d = io_arearef->msx_areadef-sign_revl_depr.

* define overall sign for area
    es_areasign-sign  = id_neg_values.

    CASE es_areasign-sign.
      WHEN abap_true.
        es_areasign-sign = gc_area_value_sign-any.
      WHEN ' '.
        es_areasign-sign = gc_area_value_sign-positive.
    ENDCASE.

    IF es_areasign-apc  = gc_area_value_sign-negative   OR
     ( es_areasign-apc  = gc_area_value_sign-none       AND
       es_areasign-invs = gc_area_value_sign-negative ) OR
     ( es_areasign-apc  = gc_area_value_sign-none       AND
       es_areasign-resv = gc_area_value_sign-negative ).

      IF es_areasign-sign = gc_area_value_sign-positive.
        es_areasign-sign = gc_area_value_sign-negative.
      ENDIF.
    ENDIF.

    IF io_arearef->msx_areadef-calc_sequence+1(1) = gc_amount_type-ordn.
      es_areasign-depr_o_first = abap_true.
    ELSE.                             "
      CLEAR es_areasign-depr_o_first.
    ENDIF.
  ENDMETHOD.


  METHOD GET_BASE_DATE_AND_YR_AND_PRD.
    FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

    CLEAR ed_base_date.
    CLEAR ed_base_prd.
    CLEAR ed_base_fyr.

* determine validity year to be used for table access
    CASE id_base_rule.

* base date is activation date
      WHEN 1.
        ed_base_date = is_hlpseg-cap_date.

        IF ed_base_date IS INITIAL.
          ed_base_date = is_hlpseg-initial_acq.
        ENDIF.

        CALL METHOD is_hlpseg-arearef->get_period_and_year
          EXPORTING
            id_date      = ed_base_date
          IMPORTING
            ed_period    = ed_base_prd
            ed_fisc_year = ed_base_fyr.

* base date is depreciation start date
      WHEN 2.
        ed_base_date  = is_hlpseg-start_date.
        ed_base_prd   = is_hlpseg-start_prd.
        ed_base_fyr    = is_hlpseg-start_yr.

        IF is_hlpseg-amount_type = GC_amount_type-spec.
          READ TABLE mts_hlpseg ASSIGNING <ls_hlpseg>
                WITH KEY fyear       = is_hlpseg-fyear
                         area        = is_hlpseg-area
                         amount_type = GC_amount_type-ordn.

          IF sy-subrc = 0.
            ed_base_date  = <ls_hlpseg>-start_date.
            ed_base_prd   = <ls_hlpseg>-start_prd.
            ed_base_fyr    = <ls_hlpseg>-start_yr.
          ENDIF.
        ENDIF.

* base date is start date of sepcial depreciation
      WHEN 3.
        ed_base_date  = is_hlpseg-start_date.
        ed_base_prd   = is_hlpseg-start_prd.
        ed_base_fyr    = is_hlpseg-start_yr.

* base date is start date ordinary depreciation
        IF is_hlpseg-amount_type = GC_amount_type-ordn.
          READ TABLE mts_hlpseg ASSIGNING <ls_hlpseg>
                WITH KEY fyear       = is_hlpseg-fyear
                         area        = is_hlpseg-area
                         amount_type = GC_amount_type-spec.

          IF sy-subrc = 0.
            ed_base_date  = <ls_hlpseg>-start_date.
            ed_base_prd   = <ls_hlpseg>-start_prd.
            ed_base_fyr    = <ls_hlpseg>-start_yr.
          ENDIF.
        ENDIF.

* base date activation date of AuC
      WHEN 4.
        ed_base_date = is_hlpseg-orig_acq_date
  .
        IF ed_base_date IS INITIAL.
          ed_base_date = is_hlpseg-cap_date.
        ENDIF.

        CALL METHOD is_hlpseg-arearef->get_period_and_year
          EXPORTING
            id_date      = ed_base_date
          IMPORTING
            ed_period    = ed_base_prd
            ed_fisc_year = ed_base_fyr.

* use change over year
      WHEN 5.
        CHECK NOT is_hlpseg-changeover_yr IS INITIAL.

        ed_base_prd = is_hlpseg-changeover_prd.
        ed_base_fyr  = is_hlpseg-changeover_yr.

        IF ed_base_prd IS INITIAL.
          ed_base_prd = 1.
        ENDIF.
        CALL METHOD is_hlpseg-arearef->if_faa_cfg_leadobj~get_first_day_in_period
          EXPORTING
            id_fisc_year = ed_base_fyr
            id_period    = ed_base_prd
          IMPORTING
            ed_first_day = ed_base_date.
    ENDCASE.

* determine year for table access
    CASE id_determination_rule.
      WHEN 1.
*<<<<< start of insertion note 1473873 >>>>>*
        CALL METHOD is_hlpseg-arearef->if_faa_cfg_leadobj~get_first_day_in_period
          EXPORTING
            id_fisc_year = ed_base_fyr
            id_period    = ed_base_prd
          IMPORTING
            ed_first_day = ed_base_date.
*<<<<< end of insertion note 1473873 >>>>>*

        ed_base_yr = ed_base_date(4).
      WHEN 2.
        ed_base_yr = ed_base_date(4).
      WHEN 3.
        ed_base_yr = ed_base_fyr.
    ENDCASE.

  ENDMETHOD.


  METHOD GET_CALC_INFO_FOR_AMOUNT_TYPE.

    DATA lt_area                  TYPE ty_t_area.

    DATA ls_transaction           TYPE ty_s_transaction.    "2227480
    DATA ls_hlpseg                TYPE ty_s_hlpseg.

    DATA lv_periodcontrol         TYPE pergrp_d.
    DATA lv_first_day             TYPE dats.
    DATA lv_periods               TYPE ty_s_hlpseg-periods.

    DATA lv_fyear                 TYPE numc4.
    DATA lv_last_day_start_yr     TYPE ty_s_hlpseg-start_date.
    DATA lv_exp_life_start_yr     TYPE ty_s_hlpseg-exp_life.

    DATA lo_processing_handle     LIKE me.
    DATA lo_previous              LIKE me.

* leave if both depreciation start date and capitalization date are initial
    IF cs_hlpseg-start_date IS INITIAL AND
       cs_hlpseg-cap_date   IS INITIAL.
      RETURN.
    ENDIF.

* determine depreciation start date from capitalization date
    IF cs_hlpseg-start_date IS INITIAL.
      IF cs_hlpseg-use_days EQ abap_true.
        cs_hlpseg-start_date = cs_hlpseg-cap_date.

      ELSE.
        IF ms_transaction_cntrl IS INITIAL.
          lv_periodcontrol = gc_period_group-acquisition.
        ELSE.
          READ TABLE mt_transaction_post INTO ls_transaction "2227480
           WITH KEY area = cs_hlpseg-area.
          IF sy-subrc = 0.
            lv_periodcontrol = ls_transaction-periodcontrol.
          ELSE.
            lv_periodcontrol = ms_transaction_cntrl-periodcontrol.
          ENDIF.
        ENDIF.

        CALL METHOD get_calc_yr_and_per_from_date
          EXPORTING
            is_hlpseg             = cs_hlpseg
            iv_per_ctrl_group     = lv_periodcontrol
            iv_value_date         = cs_hlpseg-cap_date
          IMPORTING
            ev_fiscal_year        = cs_hlpseg-start_yr
            ev_calculation_period = cs_hlpseg-start_prd.

* Adjust start year and period if period determined is behind fiscal year end
        IF cs_hlpseg-start_yr  = cs_hlpseg-fyear AND
           cs_hlpseg-start_prd > cs_hlpseg-periods_short_fy.
          cs_hlpseg-start_prd = 1.
          cs_hlpseg-start_yr  = cs_hlpseg-start_yr + 1.
        ENDIF.

* get start period if start year is prior fiscal year
        IF cs_hlpseg-start_yr  < cs_hlpseg-fyear.
          CALL METHOD cs_hlpseg-arearef->if_faa_cfg_leadobj~get_number_of_periods
            EXPORTING
              id_fisc_year        = cs_hlpseg-start_yr
            IMPORTING
              ed_periods_short_fy = lv_periods.

          IF cs_hlpseg-start_prd > lv_periods.
            cs_hlpseg-start_prd = 1.
            cs_hlpseg-start_yr  = cs_hlpseg-start_yr + 1.
          ENDIF.
        ENDIF.

* get start date
        CALL METHOD cs_hlpseg-arearef->if_faa_cfg_leadobj~get_first_day_in_period
          EXPORTING
            id_fisc_year = cs_hlpseg-start_yr
            id_period    = cs_hlpseg-start_prd
          IMPORTING
            ed_first_day = cs_hlpseg-start_date.
      ENDIF.
    ENDIF.

* determine depreciation start year and period
    IF cs_hlpseg-start_prd IS INITIAL.
      CALL METHOD cs_hlpseg-arearef->get_period_and_year
        EXPORTING
          id_date      = cs_hlpseg-start_date
        IMPORTING
          ed_period    = cs_hlpseg-start_prd
          ed_fisc_year = cs_hlpseg-start_yr.

* on daily calc. determine start period using first day of start year
      IF cs_hlpseg-use_days EQ abap_true.
        CALL METHOD cs_hlpseg-arearef->if_faa_cfg_leadobj~get_first_day_in_year
          EXPORTING
            id_fisc_year = cs_hlpseg-start_yr
          RECEIVING
            rd_first_day = lv_first_day.

        cs_hlpseg-start_prd = cs_hlpseg-start_date - lv_first_day + 1.
      ENDIF.
    ENDIF.

********************************************************************
* takeover expired useful life from asset master
********************************************************************
    CHECK ms_proc_data-step <> gc_step-dc_int_calc_exp_life_cz.
    IF cs_hlpseg-use_days IS INITIAL.
      lv_periods  = cs_hlpseg-periods.
    ELSE.
      lv_periods  = 365.
    ENDIF.

    CASE cs_hlpseg-amount_type.
      WHEN gc_amount_type-ordn.
        cs_hlpseg-exp_life   = is_depr_param-exp_ulife_yrs
                             * lv_periods
                             + is_depr_param-exp_ulife_prds.

      WHEN gc_amount_type-spec.
        cs_hlpseg-exp_life   = is_depr_param-exp_ulife_sdep_yrs
                             * lv_periods
                             + is_depr_param-exp_ulife_sdep_prds.

      WHEN gc_amount_type-intr.
        cs_hlpseg-exp_life    = is_depr_param-exp_ulife_yrs
                              * lv_periods
                              + is_depr_param-exp_ulife_prds.
    ENDCASE.

********************************************************************
* calculate expired useful life from cap. date but only
* when no shutdown needs to be considered.
********************************************************************
    IF cs_hlpseg-start_date LT cs_hlpseg-first_day_in_yr AND
       cs_hlpseg-start_date NE gc_date-no_date        AND
       cs_hlpseg-exp_life   EQ 0.

* check if shut down periods are to be regarded
      IF cs_hlpseg-keyref->ms_settings-regard_shutdown = abap_true.

        LOOP AT mo_start->ms_asset_data-ts_depr_param TRANSPORTING NO FIELDS
          WHERE depr_area   = cs_hlpseg-area                "#EC *
            AND from_date   < is_depr_param-from_date
            AND is_shutdown = abap_true.
          EXIT.
        ENDLOOP.

* asset has been shut down before actual time interval = > no calculation
        IF sy-subrc = 0.
          RETURN.
        ENDIF.

* asset is shut down for actual time interval = > no calculation
        IF is_depr_param-is_shutdown  = abap_true.
          RETURN.
        ENDIF.
      ENDIF.

* perform simplified calculation of expired useful life
      IF cs_hlpseg-use_days IS INITIAL.
        cs_hlpseg-exp_life = cs_hlpseg-fyear    - cs_hlpseg-start_yr  - 1.
        cs_hlpseg-exp_life = cs_hlpseg-exp_life * cs_hlpseg-periods.
        cs_hlpseg-exp_life = cs_hlpseg-exp_life + cs_hlpseg-periods
                                                - cs_hlpseg-start_prd + 1.
      ELSE.

* get last day of start year and calculate expired days in the start year
        CALL METHOD cs_hlpseg-arearef->if_faa_cfg_leadobj~get_last_day_in_year
          EXPORTING
            id_fisc_year = cs_hlpseg-start_yr
          RECEIVING
            rd_last_day  = lv_last_day_start_yr.

        lv_exp_life_start_yr = lv_last_day_start_yr - cs_hlpseg-start_date + 1.

* correct for a leap year because a whole leap year
* added 365 days to the planned useful life
        IF lv_exp_life_start_yr = 366.
          lv_exp_life_start_yr = 365.
        ENDIF.

        cs_hlpseg-exp_life = lv_exp_life_start_yr
                           + ( cs_hlpseg-fyear - cs_hlpseg-start_yr - 1 ) * lv_periods.

      ENDIF.
    ENDIF.

********************************************************************
* calculate expired useful life from changeover year
********************************************************************
    IF cs_hlpseg-use_exp_life_new EQ abap_true.
      IF cs_hlpseg-changeover_yr LT cs_hlpseg-fyear AND
         cs_hlpseg-changeover_yr IS NOT INITIAL.

        lv_fyear    = cs_hlpseg-changeover_yr.
        lt_area     = mts_area.

        DELETE lt_area
         WHERE depr_area <> cs_hlpseg-area.

        WHILE lv_fyear <= cs_hlpseg-fyear.
          CREATE OBJECT lo_processing_handle.
          lo_processing_handle->mo_previous        = lo_previous.
*         lo_processing_handle->mo_start           = lo_previous->mo_start.
* mo_start is always the same                                      "2301034
          lo_processing_handle->mo_start           = me->mo_start. "2301034
          lo_processing_handle->mts_area           = lt_area.
          lo_processing_handle->ms_proc_data       = ms_proc_data.
          lo_processing_handle->ms_proc_data-step  = gc_step-dc_int_calc_exp_life_cz.
          lo_processing_handle->ms_proc_data-fyear = lv_fyear. "2273009

          CALL METHOD lo_processing_handle->_hlpseg_create.
          CALL METHOD lo_processing_handle->_hlpseg_split_at_ul_end.
          CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
          lo_previous = lo_processing_handle.
          lv_fyear = lv_fyear + 1.
        ENDWHILE.

* take over calculated expired life new starting at changeover year
        READ TABLE lo_processing_handle->mts_hlpseg  INTO ls_hlpseg
          WITH KEY amount_type  = cs_hlpseg-amount_type.    "2273009

        ASSERT sy-subrc = 0.

*       cs_hlpseg-exp_life_new = ls_hlpseg-exp_life_new.    "2301034
        cs_hlpseg-exp_life_new = ls_hlpseg-exp_life.        "2301034
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD get_calc_yr_and_per_4_trnsctn.
*=======================================================================
* get calculation period and year for value date of transaction  "new with note 2189388
*=======================================================================
* PRECONDITION
    "none

* DEFINITIONS
    FIELD-SYMBOLS <lv_check_date>    TYPE dats.

    DATA ls_period_cntrl             TYPE ty_s_deprkey-period_control.
    DATA lv_per_ctrl_group           TYPE tabwg-pergrp.

* BODY
    CLEAR ev_calculation_period.
    CLEAR ev_fiscal_year.

* get calculation period and year for value date of transaction according to settings
    IF is_hlpseg-use_days = abap_true.
      ev_calculation_period = iv_value_date - is_hlpseg-first_day_in_yr + 1.
      ev_fiscal_year        = is_hlpseg-fyear.
    ELSE.

* adjust period control group of acquisition posting if applicable
      lv_per_ctrl_group = iv_per_ctrl_group.

      IF lv_per_ctrl_group = gc_period_group-acquisition.

        DO 2 TIMES.
          IF sy-index = 1.
            ASSIGN is_hlpseg-start_date  TO <lv_check_date>.
          ELSE.
            ASSIGN is_hlpseg-initial_acq TO <lv_check_date>.
          ENDIF.

          CHECK <lv_check_date> < is_hlpseg-first_day_in_yr.
          lv_per_ctrl_group = gc_period_group-postcap.
          EXIT.
        ENDDO.
      ENDIF.

* get calculation period and year accoding to settings
      CALL METHOD get_calc_yr_and_per_from_date
        EXPORTING
          is_hlpseg             = is_hlpseg
          iv_per_ctrl_group     = lv_per_ctrl_group
          iv_value_date         = iv_value_date
        IMPORTING
          ev_fiscal_year        = ev_fiscal_year
          ev_calculation_period = ev_calculation_period.
    ENDIF.

***************************************************************************
* perform adjustment of calc. year and period if neccessary
***************************************************************************

*--------------------------------------------------------------------------*
* perform adjustment if transactions is before the calc. start year
*--------------------------------------------------------------------------*
* calculation starts earliest at calculation start year and period
    IF ev_fiscal_year < is_hlpseg-start_yr.
      ev_calculation_period = is_hlpseg-start_prd.
      ev_fiscal_year        = is_hlpseg-start_yr.
    ENDIF.

*--------------------------------------------------------------------------*
* perform adjustment if transactions is in the calc. start year
*--------------------------------------------------------------------------*
    IF ev_fiscal_year = is_hlpseg-start_yr.

* consideration of transaction starts earliest with start period
      IF ev_calculation_period < is_hlpseg-start_prd.
        ev_calculation_period = is_hlpseg-start_prd.

* perform adjustment of calculation period if it is after the start period
      ELSE.
        CASE iv_per_ctrl_group.

* acquisitions in start year are to be assigned to start period if not denied by depr. key settings
          WHEN gc_period_group-acquisition.
            CLEAR ls_period_cntrl.

            LOOP AT is_hlpseg-keyref->mts_period_control INTO ls_period_cntrl "#EC CI_SORTSEQ
              WHERE valid_to_fyear  >= is_hlpseg-fyear
                AND prd_cntrl_group  = iv_per_ctrl_group.
              EXIT.
            ENDLOOP.

            IF ls_period_cntrl-prd_cntrl_valdat = abap_false.
              ev_calculation_period = is_hlpseg-start_prd.
              ev_fiscal_year        = is_hlpseg-start_yr.
            ENDIF.

* on daily calculation retirement/transfer/Revalutaion is to be shifted to next year if
* value date equals to the last day of the fixcal year to insure the whole year is regarded
          WHEN gc_period_group-transfer
            OR gc_period_group-retirement
            OR gc_period_group-revaluation.

            IF is_hlpseg-last_day_in_yr = iv_value_date AND
               is_hlpseg-use_days        = abap_true.

              ev_fiscal_year = ev_fiscal_year + 1.
            ENDIF.
        ENDCASE.
      ENDIF.
    ENDIF.

*--------------------------------------------------------------------------*
* perform adjustment if transactions is after the calc. start year
*--------------------------------------------------------------------------*
    IF ev_fiscal_year > is_hlpseg-start_yr.
      CASE iv_per_ctrl_group.
        WHEN gc_period_group-acquisition.

* on daily calculation retirement/transfer/Revalutaion is to be shifted to next year if
* value date equals to the last day of the fixcal year to insure the whole year is regarded
        WHEN gc_period_group-transfer
          OR gc_period_group-retirement
          OR gc_period_group-revaluation.

          IF is_hlpseg-last_day_in_yr = iv_value_date AND
            is_hlpseg-use_days        = abap_true.

            ev_fiscal_year = ev_fiscal_year + 1.
          ENDIF.
      ENDCASE.
    ENDIF.

* POSTCONDITION
    "none
  ENDMETHOD.


  METHOD GET_CALC_YR_AND_PER_FROM_DATE.
* method is completely reworked with note 2189388
*=======================================================================
* determination of calc. period and year for value date according
* to given period control group
*=======================================================================
* PRECONDITION
    CLEAR ev_calculation_period.
    CLEAR ev_fiscal_year.

* DEFINITIONS
    FIELD-SYMBOLS <lts_period_det>   TYPE ty_ts_deprkey_period_determin.
    FIELD-SYMBOLS <lv_check_date>    TYPE dats.

    DATA ls_period_cntrl             TYPE ty_s_deprkey-period_control.
    DATA ls_period_det               TYPE ty_s_deprkey-period_determin.

*    DATA lv_first_day_in_fyr         TYPE dats.
    DATA lv_midmonth                 TYPE abap_bool.
    DATA lv_message                  TYPE string.
    DATA lv_calculation_period       TYPE faa_dc_start_prd.  "< 2535113

    DATA: BEGIN OF ls_date,
            year  TYPE numc4,
            month TYPE numc2,
            day   TYPE numc2,
          END   OF ls_date.

* BODY

* get period control for transaction assignment
    LOOP AT is_hlpseg-keyref->mts_period_control INTO ls_period_cntrl "#EC CI_SORTSEQ
      WHERE valid_to_fyear GE is_hlpseg-fyear
        AND prd_cntrl_group EQ iv_per_ctrl_group.

      EXIT.
    ENDLOOP.

    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_fatal_exception.
    ENDIF.

* <<< begin of insertion - note 2535113 >>>
*   determine fiscal year of value date and period which may be changed
*   later on
*   set default value using the capitalisation date provided by caller
*   period is determined applying the valid period controls
*   A possible shift to the next fiscal year due to the determination
*   of period 13 will be done in the calling method.
    CALL METHOD is_hlpseg-arearef->get_period_and_year
      EXPORTING
        id_date      = iv_value_date
      IMPORTING
        ed_period    = lv_calculation_period
        ed_fisc_year = ev_fiscal_year.
* <<< end of insertion - note 2535113 >>>

* determine whether half month rule to be applied
    CALL METHOD is_hlpseg-arearef->if_faa_cfg_leadobj~is_active
      EXPORTING
        id_setting = gc_setting_halfmonth
      RECEIVING
        rb_active  = lv_midmonth.

* determine assigned calculation period for transaction
    IF ls_period_cntrl-use_common_rules EQ abap_false.
      ls_date = iv_value_date.

      IF is_hlpseg-keyref->ms_settings-prd_detrm_per_yr IS INITIAL.
        CLEAR ls_date-year.
      ENDIF.

      ASSIGN is_hlpseg-arearef->mts_period_determine->* TO <lts_period_det>.

      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE cx_fatal_exception.
      ENDIF.

      READ TABLE <lts_period_det> INTO ls_period_det
            WITH KEY prd_control_key  = ls_period_cntrl-prd_control_key
                     date_year   = ls_date-year
                     date_month  = ls_date-month
                     date_day    = ls_date-day
                     BINARY SEARCH.

      CASE sy-subrc.
        WHEN 0.

        WHEN 4.
          READ TABLE <lts_period_det> INTO ls_period_det INDEX sy-tabix.
        WHEN 8.
          CLEAR ls_period_det.
      ENDCASE.

      IF ls_period_det-prd_control_key EQ ls_period_cntrl-prd_control_key AND
         ls_period_det-date_year       EQ ls_date-year.

*        ev_fiscal_year        = is_hlpseg-fyear.            "< 2535113
        ev_calculation_period = ls_period_det-period + 1.

* consider that calculation uses 24 periods
        IF NOT lv_midmonth IS INITIAL.
          ev_calculation_period = ls_period_det-period * 2 + 1.
        ENDIF.

* consider half month assignment request for transaction
        IF NOT ls_period_det-use_half_months IS INITIAL.
          ev_calculation_period = ev_calculation_period - 1.
        ENDIF.

* raise error message if calc. period determination not possible
      ELSE.
        syst-msgv3+0(1) = is_hlpseg-amount_type.
        syst-msgv3+1(1) = is_hlpseg-phase.
        MESSAGE e613(aa) WITH ls_period_cntrl-prd_control_key iv_value_date syst-msgv3 INTO lv_message.

        CALL METHOD create_message_from_syst.
      ENDIF.
    ELSE.
      ev_calculation_period = lv_calculation_period.        "<<< 2535113
    ENDIF.

* POSTCONDITION
    "none
  ENDMETHOD.


  METHOD GET_DATA_FROM_BADI.

    DATA lo_segment_handle TYPE faa_dc_segment_handle.

    DATA ls_hlpseg         LIKE cs_hlpseg.                  "2270486
    DATA lv_modulo         TYPE i.
    DATA lv_message        TYPE string.

    ls_hlpseg = cs_hlpseg.                                  "2270486

     me->prepare_badi_call( changing co_DC_segment_handle = lo_segment_handle ).

*--------------------------------------------------------------------------------
* call Country specific BADI methods
*--------------------------------------------------------------------------------
    IF go_badi_country IS BOUND.
      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_country->define_use_of_max_periods
          EXPORTING
            flt_val            = cs_hlpseg-arearef->if_faa_cfg_leadobj~msx_settings-country
            io_handle          = lo_segment_handle
            is_hlpseg          = cs_hlpseg
          CHANGING
            cb_use_max_periods = cs_hlpseg-use_max_periods
          EXCEPTIONS
            error_occurred     = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-use_max_periods = abap_true.
          cs_hlpseg-range_length = 1.
        ENDIF.
      ENDIF.

      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_country->define_segment_length
          EXPORTING
            flt_val           = cs_hlpseg-arearef->if_faa_cfg_leadobj~msx_settings-country
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_segment_length = cs_hlpseg-range_length
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-range_length > 0.
          lv_modulo  = cs_hlpseg-periods MOD cs_hlpseg-range_length.
        ENDIF.

        IF lv_modulo IS NOT INITIAL.
          CLEAR cs_hlpseg-range_length.

          MESSAGE e678(aa) WITH 'FAA_DC_CUNTRY' 'DEFINE_SEGMENT_LENGTH' INTO lv_message.
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.

* get country sepcific change over information
      IF cs_hlpseg-keyref->ms_settings-changeover_meth CA gc_changeover_meth_country AND
         cs_hlpseg-changeover_yr                       IS INITIAL.
        CALL METHOD go_badi_country->define_changeover_yr
          EXPORTING
            flt_val          = cs_hlpseg-arearef->if_faa_cfg_leadobj~msx_settings-country
            io_handle        = lo_segment_handle
            is_hlpseg        = cs_hlpseg
          CHANGING
            cd_changeover_yr = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred   = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        CALL METHOD go_badi_country->define_changeover_yr_and_prd
          EXPORTING
            flt_val           = cs_hlpseg-arearef->if_faa_cfg_leadobj~msx_settings-country
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_changeover_prd = cs_hlpseg-changeover_prd
            cd_changeover_yr  = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.
    ENDIF.

*--------------------------------------------------------------------------------
* call Customer specific BADI methods
*--------------------------------------------------------------------------------
    IF go_badi_customer IS BOUND.
      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_customer->define_use_of_max_periods
          EXPORTING
            io_handle          = lo_segment_handle
            is_hlpseg          = cs_hlpseg
          CHANGING
            cb_use_max_periods = cs_hlpseg-use_max_periods
          EXCEPTIONS
            error_occurred     = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-use_max_periods = abap_true.
          cs_hlpseg-range_length = 1.
        ENDIF.
      ENDIF.

      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_customer->define_segment_length
          EXPORTING
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_segment_length = cs_hlpseg-range_length
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-range_length > 0.
          lv_modulo  = cs_hlpseg-periods MOD cs_hlpseg-range_length.
        ENDIF.

        IF lv_modulo IS NOT INITIAL.
          CLEAR cs_hlpseg-range_length.

          MESSAGE e678(aa) WITH 'FAA_DC_CUSTOMER' 'DEFINE_SEGMENT_LENGTH' INTO lv_message.
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.

* get customer sepcific change over information
      IF cs_hlpseg-keyref->ms_settings-changeover_meth CA gc_changeover_meth_customer AND
         cs_hlpseg-changeover_yr                       IS INITIAL.
        CALL METHOD go_badi_customer->define_changeover_yr
          EXPORTING
            io_handle        = lo_segment_handle
            is_hlpseg        = cs_hlpseg
          CHANGING
            cd_changeover_yr = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred   = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        CALL METHOD go_badi_customer->define_changeover_yr_and_prd
          EXPORTING
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_changeover_prd = cs_hlpseg-changeover_prd
            cd_changeover_yr  = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.
    ENDIF.

* get settings for depr. calc for phase 2
    CHECK go_badi_country  IS BOUND
       OR go_badi_customer IS BOUND.


    CHECK cs_hlpseg-changeover_yr <= cs_hlpseg-fyear
      and cs_hlpseg-changeover_yr >  0.

    CHECK ls_hlpseg-changeover_yr =  0.                     "2270486

    CALL METHOD get_phase_and_deprkey_config
      CHANGING
        cs_hlpseg = cs_hlpseg.

  ENDMETHOD.


  METHOD GET_DATA_FROM_PRIOR_YEAR.
*DEFINITIONS
    FIELD-SYMBOLS <ls_hlpseg>        TYPE ty_S_hlpseg.
    DATA ls_reduction                TYPE ty_s_deprarea-short_fyear.
    DATA ls_hlpseg                   TYPE ty_S_hlpseg.
    DATA lv_exp_life                 TYPE ty_S_hlpseg-periods.

* BODY
********************************************************************
* get expired useful life from prior year period intervals
********************************************************************
    LOOP AT mo_previous->mts_hlpseg ASSIGNING <ls_hlpseg>
      WHERE area        = cs_hlpseg-area
        AND amount_type = cs_hlpseg-amount_type.

      ls_hlpseg   = <ls_hlpseg>.
      lv_exp_life = lv_exp_life + <ls_hlpseg>-exp_life_seg.
    ENDLOOP.

    CHECK sy-subrc EQ 0.

* ignore leap years on determination of expired life because of compatibility to old AFAR
    IF cs_hlpseg-use_days EQ abap_true.
      IF lv_exp_life = 366.
        lv_exp_life = 365.
      ENDIF.
    ENDIF.

* get settings related with shortened fiscal year
    IF ls_hlpseg-is_shortfiscyear EQ abap_true.
      READ TABLE cs_hlpseg-arearef->mts_short_fy_reduction INTO ls_reduction
        WITH KEY short_fisc_year = cs_hlpseg-fyear.

      IF sy-subrc <> 0.
        CLEAR ls_reduction.
      ENDIF.

      CASE cs_hlpseg-amount_type.
        WHEN GC_amount_type-ordn.
          cs_hlpseg-regard_short_yr = ls_reduction-reduce_depr_o.
        WHEN GC_amount_type-spec.
          cs_hlpseg-regard_short_yr = ls_reduction-reduce_depr_s.
      ENDCASE.

* setting of depreciation key wins
      IF ls_hlpseg-keyref->ms_settings-no_reduction EQ abap_true.
        cs_hlpseg-regard_short_yr = abap_false.
      ENDIF.

* in case depreciation was not reduced in a shortened year
* expired life has to be corrected to the whole year
      IF cs_hlpseg-regard_short_yr  = abap_false.
        lv_exp_life = lv_exp_life * ls_hlpseg-periods / ls_hlpseg-periods_short_fy.
      ENDIF.
    ENDIF.

    cs_hlpseg-exp_life = ls_hlpseg-exp_life + lv_exp_life.

    IF NOT <ls_hlpseg>-use_exp_life_new IS INITIAL.
      cs_hlpseg-exp_life_new = ls_hlpseg-exp_life_new + lv_exp_life. "2322410
    ENDIF.

* get depreciation start and change over information
    cs_hlpseg-start_date      = ls_hlpseg-start_date.
    cs_hlpseg-start_yr        = ls_hlpseg-start_yr.
    cs_hlpseg-start_prd       = ls_hlpseg-start_prd.

    cs_hlpseg-changeover_yr   = ls_hlpseg-changeover_yr.
    cs_hlpseg-changeover_prd  = ls_hlpseg-changeover_prd.
  ENDMETHOD.


  METHOD GET_DEPR_PARAM.
    DATA lt_phase                 TYPE ty_ts_deprkey_phase.
    DATA ls_amount_types          TYPE ty_s_hlpseg-amount_types.
    DATA ls_deprkey_key           TYPE ty_s_deprkey-key.
    .

    DATA ls_phase                 TYPE ty_s_deprkey-phase.
    DATA lv_calc_seq              TYPE char4. "##NEEDED
    DATA lv_alignment_ind         TYPE int2.
    DATA lv_message               TYPE string.

    cs_hlpseg-depr_key         = is_depr_param-depr_key.
    cs_hlpseg-changeover_yr    = is_depr_param-changeover_yr.
    cs_hlpseg-changeover_prd   = is_depr_param-changeover_prd.
    cs_hlpseg-scrapvalue       = is_depr_param-scrapvalue.
    cs_hlpseg-scrapvalue_prctg = is_depr_param-scrapvalue_prctg.
    cs_hlpseg-var_dep_portion  = is_depr_param-var_depr_portion.
    cs_hlpseg-neg_values       = is_depr_param-neg_values.
    cs_hlpseg-shift_fact       = is_depr_param-shift_fact.
    cs_hlpseg-is_shutdown      = is_depr_param-is_shutdown.
    cs_hlpseg-invsupport_key   = is_depr_param-invsupport_key.
    cs_hlpseg-to_date_of_tddp  = is_depr_param-to_date.
    cs_hlpseg-use_days         = is_depr_param-use_days.

* get useful life in fiscal periods
    cs_hlpseg-useful_life      = is_depr_param-ulife_yrs
                               * cs_hlpseg-periods
                               + is_depr_param-ulife_prds.

* periods of useful life are month on halmonth related calculation => add twice
    IF cs_hlpseg-arearef->if_faa_cfg_leadobj~is_active( gc_setting_halfmonth ) = abap_true.
      cs_hlpseg-useful_life    = cs_hlpseg-useful_life
                               + is_depr_param-ulife_prds.
    ENDIF.

* get base settings of depr. key to determine if calc. on daily base to be performed
    ls_deprkey_key-depr_key = cs_hlpseg-depr_key.
    cs_hlpseg-keyref       ?= cf_faa_cfg_deprkey=>find(
                               id_leadobj_value = cs_hlpseg-arearef->if_faa_cfg_leadobj~md_leadobj
                               id_deprkey_key   = ls_deprkey_key
                               id_deprarea      = cs_hlpseg-arearef->md_deprarea ).
    cs_hlpseg-use_days      = cs_hlpseg-keyref->ms_settings-calc_per_day.
    CLEAR cs_hlpseg-keyref.

* get useful life in days
    IF NOT cs_hlpseg-use_days IS INITIAL.
      cs_hlpseg-useful_life_prds = is_depr_param-ulife_prds.
      cs_hlpseg-useful_life_yrs  = is_depr_param-ulife_yrs.

      cs_hlpseg-useful_life      = is_depr_param-ulife_yrs  * 365
                                 + is_depr_param-ulife_prds * 365 / 12.

      cs_hlpseg-periods_short_fy = cs_hlpseg-last_day_in_yr - cs_hlpseg-first_day_in_yr + 1.
      cs_hlpseg-period_to        = cs_hlpseg-last_day_in_yr - cs_hlpseg-first_day_in_yr + 1.
      cs_hlpseg-periods          = cs_hlpseg-last_day_in_yr - cs_hlpseg-first_day_in_yr + 1.

      IF NOT cs_hlpseg-is_shortfiscyear IS INITIAL.
        cs_hlpseg-periods = 365.
      ENDIF.

*   for daily depreciation check, that leap year calculates with 366 days useful life
      IF cs_hlpseg-useful_life = 365 AND
         cs_hlpseg-periods     = 366.

        cs_hlpseg-useful_life = 366.
      ENDIF.
    ENDIF.

* mark segment if group asset is assigned
    IF NOT is_depr_param-grp_asset IS INITIAL.
      cs_hlpseg-grp_asset_assgnd =  abap_true.
    ENDIF.

* note if replacment value calculation is required
    cs_hlpseg-rplcmntval_index = is_depr_param-rplcmntval_index.
    cs_hlpseg-age_index        = is_depr_param-age_index.

* note if inflation calculation is required
    IF NOT cs_hlpseg-calc_inflation IS INITIAL.
      cs_hlpseg-revaltn_key     = is_depr_param-revaltn_key.
    ENDIF.

    CALL METHOD cf_faa_cfg_deprkey=>get_phases
      EXPORTING
        id_leadobj_value = cs_hlpseg-arearef->if_faa_cfg_leadobj~md_leadobj
        id_deprkey       = cs_hlpseg-depr_key
        id_deprarea      = cs_hlpseg-arearef->md_deprarea
      IMPORTING
        et_phase         = lt_phase.

    ls_amount_types = cs_hlpseg-amount_types.

    LOOP AT lt_phase INTO ls_phase.
      AT NEW amount_type.
        CASE ls_phase-amount_type.
          WHEN gc_amount_type-ordn.
            cs_hlpseg-calc_seq_ordn = 50.

* determine calculation sequence for ordinary depreciation
            lv_calc_seq = cs_hlpseg-arearef->msx_areadef-calc_sequence.
            SHIFT lv_calc_seq UP TO gc_amount_type-ordn.
            SHIFT lv_calc_seq UP TO gc_amount_type-spec.

            IF sy-subrc <> 0.
              cs_hlpseg-calc_seq_ordn = 60.
            ENDIF.

          WHEN gc_amount_type-spec.
            cs_hlpseg-calc_seq_spec = 60.

* determine calculation sequence for special dereciation
            lv_calc_seq = cs_hlpseg-arearef->msx_areadef-calc_sequence.
            SHIFT lv_calc_seq UP TO gc_amount_type-ordn.
            SHIFT lv_calc_seq UP TO gc_amount_type-spec.

            IF sy-subrc <> 0.
              cs_hlpseg-calc_seq_spec = 50.
            ENDIF.

          WHEN gc_amount_type-intr.
            cs_hlpseg-calc_seq_intr = 80.
        ENDCASE.
      ENDAT.
    ENDLOOP.

    IF cs_hlpseg-arearef->msx_areadef-sign_depr_o EQ gc_area_value_sign-none.
      cs_hlpseg-calc_seq_ordn = 0.
    ENDIF.

    IF cs_hlpseg-arearef->msx_areadef-sign_depr_s EQ gc_area_value_sign-none.
      cs_hlpseg-calc_seq_spec = 0.
    ENDIF.

    IF cs_hlpseg-arearef->msx_areadef-sign_interest EQ gc_area_value_sign-none.
      cs_hlpseg-calc_seq_intr = 0.
    ENDIF.

    IF cs_hlpseg-amount_types = 0.                          "2223525
      READ TABLE lt_phase INTO ls_phase INDEX 1.
      CASE ls_phase-amount_type.
        WHEN gc_amount_type-ordn.
          cs_hlpseg-calc_seq_ordn = 50.
        WHEN gc_amount_type-spec.
          cs_hlpseg-calc_seq_spec = 60.
        WHEN gc_amount_type-intr.
          cs_hlpseg-calc_seq_intr = 80.
      ENDCASE.
    ENDIF.

* deviation on amount types to be calculated are not allowed within one fiscal year
    IF ls_amount_types <> cs_hlpseg-amount_types AND ls_amount_types IS NOT INITIAL.
      MESSAGE e591(aa) INTO lv_message.
      CALL METHOD create_message_from_syst.
    ENDIF.

    lv_alignment_ind = cs_hlpseg-calc_seq_ordn
                     + cs_hlpseg-calc_seq_spec
                     + cs_hlpseg-calc_seq_intr.
    IF lv_alignment_ind > 80.
      cs_hlpseg-use_alignment = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD GET_EXPIRED_LIFE_FOR_INTERVAL.
    DATA lv_var_dep_portion TYPE ty_S_hlpseg-amount_factor.

    cs_hlpseg-exp_life_seg = 0.

    CHECK cs_hlpseg-phase > 0.

* calculate expireing useful life w/O regarding usage
    cs_hlpseg-exp_life_seg   = cs_hlpseg-period_to
                             - cs_hlpseg-period_from + 1.

* recognize variable portion of depreciation on ordinary depreciation
    CHECK cs_hlpseg-amount_type                          =  gc_amount_type-ordn.
    CHECK cs_hlpseg-keyref->ms_settings-percent_key      <> gc_percent-key_n.
    CHECK cs_hlpseg-grp_asset_assgnd                     =  abap_false.

    check cs_hlpseg-keyref->ms_settings-regard_shutdown  IS not INITIAL
       or cs_hlpseg-keyref->ms_settings-shiftfactor_rule <> '2'.
    CHECK cs_hlpseg-var_dep_portion                      IS NOT INITIAL
       OR cs_hlpseg-is_shutdown                          IS NOT INITIAL.

* if shut down indicator isn't set => multi shift factor to be regarded
    IF cs_hlpseg-is_shutdown IS INITIAL.
      CASE cs_hlpseg-keyref->ms_settings-shiftfactor_rule.

* adjust depereciation & expired useful life
        WHEN ' '.
          cs_hlpseg-usage_impact_ind = 3.

* adjust depereciation only
        WHEN '1'.
          cs_hlpseg-usage_impact_ind = 7.
      ENDCASE.

* shut down indicator is set => no calc. of exp. life & depreciation
    ELSE.
      IF cs_hlpseg-keyref->ms_settings-regard_shutdown = abap_true.
        cs_hlpseg-usage_impact_ind   = 1.
      ENDIF.
    ENDIF.

    CASE cs_hlpseg-usage_impact_ind.

* usage not to be regarded at all, if any
      WHEN 0.

* there is no expired life to be calc. on shut down periods
      WHEN  1.
        cs_hlpseg-exp_life_seg = 0.

* adjust expired life variable portion of depreciation
* is already recognized in CS_HLPSEG-AMOUNT_FACTOR
      WHEN  3.
        lv_var_dep_portion      = cs_hlpseg-var_dep_portion / 100.
        cs_hlpseg-amount_factor =  1
                                - lv_var_dep_portion
                                + lv_var_dep_portion
                                * cs_hlpseg-shift_fact.

        cs_hlpseg-exp_life_seg = cs_hlpseg-exp_life_seg
                               * cs_hlpseg-amount_factor.

* prepare adjustment of deprecation
      WHEN  7.
        lv_var_dep_portion      = cs_hlpseg-var_dep_portion / 100.
        cs_hlpseg-amount_factor =  1
                                - lv_var_dep_portion
                                + lv_var_dep_portion
                                * cs_hlpseg-shift_fact.
    ENDCASE.
  ENDMETHOD.


METHOD get_netbook_value.
*=======================================================================
* calculate netbook value
*=======================================================================

* DEFINITIONS
* BODY

  rv_netbook_value  = rv_netbook_value
                    + is_sumseg-cur-apc
                    + is_sumseg-cur-downp
                    + is_sumseg-cur-invs
                    + is_sumseg-cur-revl
                    + is_sumseg-cur-revl_d
                    + is_sumseg-cur-depr_o
                    + is_sumseg-cur-depr_s
                    + is_sumseg-cur-depr_u
                    + is_sumseg-cur-resv

                    + is_sumseg-prev_cur-apc
                    + is_sumseg-prev_cur-downp
                    + is_sumseg-prev_cur-invs
                    + is_sumseg-prev_cur-revl
                    + is_sumseg-prev_cur-revl_d
                    + is_sumseg-prev_cur-depr_o
                    + is_sumseg-prev_cur-depr_s
                    + is_sumseg-prev_cur-depr_u
                    + is_sumseg-prev_cur-resv

                    + is_sumseg-prev_prev-apc
                    + is_sumseg-prev_prev-downp
                    + is_sumseg-prev_prev-invs
                    + is_sumseg-prev_prev-revl
                    + is_sumseg-prev_prev-revl_d
                    + is_sumseg-prev_prev-depr_o
                    + is_sumseg-prev_prev-depr_s
                    + is_sumseg-prev_prev-depr_u
                    + is_sumseg-prev_prev-resv

                    + is_yearseg-cum-apc
                    + is_yearseg-cum-downp
                    + is_yearseg-cum-invs
                    + is_yearseg-cum-revl
                    + is_yearseg-cum-revl_d
                    + is_yearseg-cum-depr_o
                    + is_yearseg-cum-depr_s
                    + is_yearseg-cum-depr_u
                    + is_yearseg-cum-resv

                    + is_calcamount-total-revl
                    + is_calcamount-total-revl_d
                    + is_calcamount-total-depr_o
                    + is_calcamount-total-depr_s.

* POSTCONDITION
  "none
ENDMETHOD.


  METHOD get_phase_and_deprkey_config.
*-----------------------------------------------------------
* Reworked with note 2483403
*-----------------------------------------------------------
* Comparing results will be handled in _HLPSEG_GET_CO_YR_AND_PRD
*-----------------------------------------------------------

* PRECONDITION

* DEFINITION
    DATA ls_deprkey_key           TYPE        ty_s_deprkey-key.
    DATA lo_instance              TYPE REF TO object.

* BODY
    CALL METHOD cf_faa_cfg_deprkey=>get_phases
      EXPORTING
        id_leadobj_value = cs_hlpseg-arearef->if_faa_cfg_leadobj~md_leadobj
        id_deprkey       = cs_hlpseg-depr_key
        id_deprarea      = cs_hlpseg-arearef->md_deprarea
      IMPORTING
        et_phase         = DATA(lt_phase).

    DELETE lt_phase WHERE amount_type <> cs_hlpseg-amount_type.

    ls_deprkey_key-depr_key    = cs_hlpseg-depr_key.
    ls_deprkey_key-amount_type = cs_hlpseg-amount_type.

* determine phase
    CASE lines( lt_phase ).
      WHEN 1. " phase 1
        ls_deprkey_key-phase = 1.

      WHEN 2. " phase 1 / phase 2
        IF cs_hlpseg-is_behind_ul EQ abap_true  AND  lt_phase[ phase = 1 ]-changeover_meth CA gc_changeover_meth_at_end.
          ls_deprkey_key-phase = 2.
        ELSEIF cs_hlpseg-changeover_yr IS NOT INITIAL
           AND ( ( cs_hlpseg-fyear > cs_hlpseg-changeover_yr ) OR
                 ( cs_hlpseg-fyear = cs_hlpseg-changeover_yr  AND  cs_hlpseg-period_from >= cs_hlpseg-changeover_prd ) )
           AND lt_phase[ phase = 1 ]-changeover_meth CA gc_changeover_meth_in_ul.
          ls_deprkey_key-phase = 2.
        ELSE.
          ls_deprkey_key-phase = 1.
        ENDIF.

      WHEN 3. " phase 1 / phase 2 / phase 3
        IF cs_hlpseg-is_behind_ul EQ abap_true.
          IF lt_phase[ phase = 2 ]-changeover_meth CA gc_changeover_meth_at_end.
            ls_deprkey_key-phase = 3.
          ELSE.
            ASSERT 1 = 0. "this is not allowed
          ENDIF.
        ELSEIF cs_hlpseg-changeover_yr IS NOT INITIAL
           AND ( ( cs_hlpseg-fyear > cs_hlpseg-changeover_yr ) OR
                 ( cs_hlpseg-fyear = cs_hlpseg-changeover_yr  AND  cs_hlpseg-period_from >= cs_hlpseg-changeover_prd ) )
           AND lt_phase[ phase = 1 ]-changeover_meth CA gc_changeover_meth_in_ul.
          ls_deprkey_key-phase = 2.
        ELSE.
          ls_deprkey_key-phase = 1.
        ENDIF.

      WHEN OTHERS.
        ASSERT 1 = 0.

    ENDCASE.

* instance still the right one
    IF cs_hlpseg-keyref IS BOUND AND cs_hlpseg-keyref->ms_settings-phase EQ ls_deprkey_key-phase.
      RETURN.
    ENDIF.

    lo_instance = cf_faa_cfg_deprkey=>find(
                    id_leadobj_value = cs_hlpseg-arearef->if_faa_cfg_leadobj~ms_leadobj_key-orgunit
                    id_deprkey_key   = ls_deprkey_key
                    id_deprarea      = cs_hlpseg-arearef->md_deprarea ).

    cs_hlpseg-keyref ?= lo_instance.
    cs_hlpseg-phase   = ls_deprkey_key-phase.

* set flag if expired life is to be calculated from change over year
    IF cs_hlpseg-keyref->ms_settings-percent_key = gc_percent-key_c OR
       cs_hlpseg-keyref->ms_settings-percent_key = gc_percent-key_k OR
       cs_hlpseg-keyref->ms_settings-percent_key = gc_percent-key_u.
      cs_hlpseg-use_exp_life_new = abap_true.
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD GET_PRCNTG_ON_UNITS_OF_PROD .
    FIELD-SYMBOLS <ls_prod_unit> TYPE ty_s_deprkey-prod_units.

    DATA lv_percentage           TYPE float.
    DATA lv_nbv_depr             TYPE boolean.

    CLEAR ed_percentage.

    IF is_parameter-baseval_key EQ GC_basevalue-key_20 OR
       is_parameter-baseval_key EQ GC_basevalue-key_21 OR
       is_parameter-baseval_key EQ GC_basevalue-key_22 OR
       is_parameter-baseval_key EQ GC_basevalue-key_23 OR
       is_parameter-baseval_key EQ GC_basevalue-key_24 OR
       is_parameter-baseval_key EQ GC_basevalue-key_25 OR
       is_parameter-baseval_key EQ GC_basevalue-key_27.

      ed_percentage = 1.
      lv_nbv_depr   = abap_true.
    ENDIF.

    LOOP AT is_hlpseg-keyref->mts_prod_unit ASSIGNING <ls_prod_unit>
      WHERE  validity_yr  EQ      is_hlpseg-fyear
        AND  validity_prd BETWEEN id_period_from  AND id_period_to.


      CASE is_hlpseg-keyref->ms_settings-percent_key.
        WHEN GC_percent-key_s.
          lv_percentage = <ls_prod_unit>-planned_for_prd / <ls_prod_unit>-planned_total.

        WHEN GC_percent-key_t.

          IF <ls_prod_unit>-planned_total GT <ls_prod_unit>-sum_planned_prd.
            lv_percentage = <ls_prod_unit>-planned_for_prd
                          / ( <ls_prod_unit>-planned_total - <ls_prod_unit>-sum_planned_prd ).
          ELSE.
            lv_percentage = 0.
          ENDIF.
      ENDCASE.

      IF lv_nbv_depr EQ abap_true.
        ed_percentage = ed_percentage * ( 1 - lv_percentage ).
      ELSE.
        ed_percentage = ed_percentage +  lv_percentage.
      ENDIF.
    ENDLOOP.

    IF lv_nbv_depr EQ abap_true.
      ed_percentage = 1 - ed_percentage.
    ENDIF.
  ENDMETHOD.


  METHOD GET_REPL_PARAM.
    DATA lo_instance          TYPE REF TO object.
    DATA lo_indexhandle       TYPE ty_o_indexseries_handle.

    DATA ls_key               TYPE ty_s_indexseries-key.
    DATA ls_percentage        TYPE ty_s_indexseries-percentage.

    DATA lv_index_year        TYPE numc4.
    DATA lv_base_percentage   TYPE ty_s_indexseries-percentage-index_percentage.
    DATA lv_index_percentage  TYPE ty_s_indexseries-percentage-index_percentage.
    DATA lb_simulation_mode   TYPE boolean.

    CASE cs_hlpseg-amount_type.
      WHEN GC_amount_type-rage.
        ls_key-calc_index = cs_hlpseg-age_index.
      WHEN GC_amount_type-repl.
        ls_key-calc_index = cs_hlpseg-rplcmntval_index.
    ENDCASE.

    CALL METHOD cf_faa_cfg_indexseries=>find
      EXPORTING
        id_leadobj_value   = cs_hlpseg-arearef->if_faa_cfg_leadobj~md_leadobj
        id_index_type      = cs_hlpseg-amount_type
        is_indexseries_key = ls_key
      RECEIVING
        ro_instance        = lo_instance.

    lo_indexhandle ?= lo_instance.

* initialize help fields
    lv_base_percentage  = 100.
    lv_index_percentage = 0.
    lb_simulation_mode  = space.

    CASE cs_hlpseg-amount_type.

* get base percentage on WBIND, determine year for access
      WHEN GC_amount_type-repl.
        lv_index_year = cs_hlpseg-fyear - 1.

        IF NOT lo_indexhandle->ms_settings-calc_historic IS INITIAL.
          lv_index_year = cs_hlpseg-initial_acq_yr.
        ENDIF.

        READ TABLE lo_indexhandle->mt_percentage INTO ls_percentage
              WITH KEY index_year = lv_index_year.

        IF sy-subrc = 0.
          IF NOT ls_percentage IS INITIAL.
            lv_base_percentage = ls_percentage-index_percentage.
          ENDIF.
        ENDIF.

        lv_index_year = cs_hlpseg-fyear.

* determine year for access on ALIND
      WHEN GC_amount_type-rage.
        lv_index_year = cs_hlpseg-fyear - cs_hlpseg-initial_acq_yr.
    ENDCASE.

* get actual percentage
    READ TABLE lo_indexhandle->mt_percentage INTO ls_percentage
          WITH KEY index_year = lv_index_year.

* percentage found => take it over
    IF sy-subrc = 0 AND ls_percentage-index_percentage <> 0.
      lv_index_percentage = ls_percentage-index_percentage.

* no percentage found => get percentage for simulation if any
    ELSE.
      lb_simulation_mode = abap_true.

      IF lo_indexhandle->ms_settings-simulation_index IS INITIAL.

        CLEAR lv_index_year.

        READ TABLE lo_indexhandle->mt_percentage INTO ls_percentage
              WITH KEY index_year = lv_index_year.

        IF sy-subrc = 0.
          lv_index_percentage = ls_percentage-index_percentage.
        ENDIF.

* get simulation percentage
      ELSE.
        lv_index_percentage = lo_indexhandle->ms_settings-simulation_index.
        lv_base_percentage  = 100.
      ENDIF.
    ENDIF.

* calculate percentage for replacment value calculation
    cs_hlpseg-percent_stated = lv_index_percentage / lv_base_percentage.

* set baseval and percentage indicator
    IF lo_indexhandle->ms_settings-calc_historic IS INITIAL.
*    cs_hlpseg-baseval_key  = GC_basevalue-key_03.
      cs_hlpseg-baseval_key  = GC_basevalue-key_06.      "note_1786621
      cs_hlpseg-percent_key  = GC_percent-key_r1.
    ELSE.
*    cs_hlpseg-baseval_key  = GC_basevalue-key_01.
      cs_hlpseg-baseval_key  = GC_basevalue-key_14.      "note_1786621

      IF NOT lb_simulation_mode IS INITIAL.                 "<964625
        cs_hlpseg-percent_key = GC_percent-key_r1.
      ELSE.
        cs_hlpseg-percent_key = GC_percent-key_r2.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD GET_SHIFTED_PERIOD_FROM_AND_TO.

    DATA lv_periods     TYPE int4.
    DATA lv_period_from TYPE numc3.
    DATA lv_fyear_from  TYPE numc4.
    DATA lv_period_to   TYPE numc3.
    DATA lv_fyear_to    TYPE numc4.
    DATA lv_date        TYPE dats.

    CASE id_determination_rule.

* calendar year related determination
      WHEN 1
        OR 2.

* determine from which fiscal year and period entry is valid
        lv_periods   = id_base_date+0(4) * 12 + id_base_date+4(2) + cd_period_from - 1.

        lv_date      = id_base_date.

        lv_date+0(4) = ( lv_periods DIV 12 ).
        lv_date+4(2) = ( lv_periods MOD 12 ).

*     check on leap day 29.02.
        IF lv_date+4(4) = gc_date-feb_29+4(4).
          lv_date+4(4)  = gc_date-march_01+4(4).
          SUBTRACT 1 FROM lv_date.
        ENDIF.

        IF lv_date+4(2) = 0.
          lv_date+4(2) = 12.
          lv_date+0(4) = lv_date+0(4) - 1.
        ENDIF.

* entry is valid from the beginning of the fiscal year
        IF lv_date = is_hlpseg-first_day_in_yr.                "< 2449030
          cd_period_from = 000.
        ELSE.

* entry is not valid at all
          IF lv_date > is_hlpseg-last_day_in_yr.               "< 2449030
            cd_period_from = 999.
            EXIT.
          ENDIF.
        ENDIF.

* validity of entry starts within the fiscal year => get start period
        IF lv_date >= is_hlpseg-first_day_in_yr AND            "< 2449030
           lv_date <= is_hlpseg-last_day_in_yr.                "< 2449030

          IF id_determination_rule = 1.

* without daily depreciation
            CALL METHOD is_hlpseg-arearef->get_period_and_year
              EXPORTING
                id_date      = lv_date
              IMPORTING
                ed_period    = lv_period_from
                ed_fisc_year = lv_fyear_from.

            cd_period_from = lv_period_from.

          ELSE.

* with daily depreciation
            cd_period_from = lv_date - is_hlpseg-first_day_in_yr + 1.

          ENDIF. "id_determination_rule = 1

        ENDIF.

* determine up to which fiscal year and period entry is valid
        lv_periods   = id_base_date+0(4) * 12 + id_base_date+4(2) + cd_period_to.

        lv_date      = id_base_date.

        lv_date+0(4) = ( lv_periods DIV 12 ).
        lv_date+4(2) = ( lv_periods MOD 12 ).

*     check on leap day 29.02.
        IF lv_date+4(4) = gc_date-feb_29+4(4).
          lv_date+4(4)  = gc_date-march_01+4(4).
          SUBTRACT 1 FROM lv_date.
        ENDIF.

        IF lv_date+4(2) = 0.
          lv_date+4(2)  = 12.
          lv_date+0(4)  = lv_date+0(4) - 1.
        ENDIF.

        lv_date         =   lv_date - 1.

* entry is not valid at all
        IF lv_date < is_hlpseg-first_day_in_yr.                "< 2449030
          cd_period_to = 000.

* entry is valid until the end of the fiscal year
        ELSE.
          IF lv_date > is_hlpseg-last_day_in_yr.               "< 2449030
            cd_period_to = 999.
          ENDIF.
        ENDIF.

* validity of entry ends within the fiscal year => get end period
        IF lv_date >= is_hlpseg-first_day_in_yr AND            "< 2449030
           lv_date <= is_hlpseg-last_day_in_yr.                "< 2449030

          IF id_determination_rule = 1.

* without daily depreciation
            CALL METHOD is_hlpseg-arearef->get_period_and_year
              EXPORTING
                id_date      = lv_date
              IMPORTING
                ed_period    = lv_period_to
                ed_fisc_year = lv_fyear_to.

            cd_period_to = lv_period_to.

          ELSE.

* with daily depreciation
            cd_period_to = lv_date - is_hlpseg-first_day_in_yr + 1.

          ENDIF. "id_determination_rule = 1

        ENDIF.

* fiscal year related determination
      WHEN 3.

* determine from which fiscal year and period entry is valid
        lv_periods    =  id_base_prd + cd_period_from - 1.

        lv_fyear_from  = ( lv_periods DIV is_hlpseg-periods ) + id_base_fyr.
        cd_period_from = ( lv_periods MOD is_hlpseg-periods ).

* determine up to which fiscal year and period entry is valid
        lv_periods     = id_base_prd + cd_period_to - 1.

        lv_fyear_to    = ( lv_periods DIV is_hlpseg-periods ) + id_base_fyr.
        cd_period_to   = ( lv_periods MOD is_hlpseg-periods ).

* adjust period from if starting before or ending behind actual fiscal year
        IF lv_fyear_from < is_hlpseg-fyear.
          cd_period_from = 000.
        ENDIF.

        IF lv_fyear_from > is_hlpseg-fyear.
          cd_period_from = 999.
        ENDIF.

* adjust period to if starting before or ending behind actual fiscal year
        IF lv_fyear_to < is_hlpseg-fyear.
          cd_period_to = 000.
        ENDIF.

        IF lv_fyear_to > is_hlpseg-fyear.
          cd_period_to = 999.
        ENDIF.
    ENDCASE.
  ENDMETHOD.


  METHOD if_faa_dc_segments_720~check_badi_is_active.
    CHECK go_badi_customer IS BOUND
       OR go_badi_country  IS BOUND.

    rv_badi_is_active = abap_true.

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~perform_calc_with_implicit_cf.
    DATA lo_dc_calc_handle   TYPE ty_o_dc_calc_handle.
    DATA lo_dc_calc_previous TYPE ty_o_dc_calc_handle.

    DATA ls_proc_data        TYPE ty_s_proc_data.

    ls_proc_data-process           = is_processing_info-process.
    ls_proc_data-step              = is_processing_info-step.
    ls_proc_data-fyear             = is_processing_info-fyear.
    ls_proc_data-period_offset     = is_processing_info-period_offset. "2372072

    ls_proc_data-leadobj_instance ?= is_processing_info-leadobj_instance.
    ls_proc_data-company_code      = ls_proc_data-leadobj_instance->ms_leadobj_key-orgunit.
    ls_proc_data-ledger_group      = ls_proc_data-leadobj_instance->ms_leadobj_key-ldgrp_gl.
    ls_proc_data-country           = ls_proc_data-leadobj_instance->msx_settings-country.

    ls_proc_data-last_open_fyear   = ls_proc_data-leadobj_instance->get_max_open_fy( ).
*    ls_proc_data-first_open_fyear  = is_processing_info-fyear.

* avoid endless loop
    ASSERT is_processing_info-fyear <= is_processing_info-fyear_to. "2182406

    DO.
      CREATE OBJECT lo_dc_calc_handle.
      IF lo_dc_calc_previous IS INITIAL.
        CALL METHOD lo_dc_calc_handle->set_asset_data
          EXPORTING
            is_asset_data = is_asset_data.
      ENDIF.

      ls_proc_data-first_day_in_fyr = ls_proc_data-leadobj_instance->get_first_day_in_year( id_fisc_year = ls_proc_data-fyear ).
      ls_proc_data-last_day_in_fyr  = ls_proc_data-leadobj_instance->get_last_day_in_year( id_fisc_year = ls_proc_data-fyear ).

      " Begin of changes note 2464842
      " Adjust PERIOD_OFFSET for last year to be calculated on reporting request
      IF ls_proc_data-fyear = is_processing_info-fyear_to AND is_processing_info-period_offset_last_yr IS NOT INITIAL.
        ls_proc_data-period_offset = is_processing_info-period_offset_last_yr.
      ENDIF.
      " End of changes note 2464842

      lo_dc_calc_handle->set_process_control_data(
                          is_process_control_data = ls_proc_data
                          its_area                = is_processing_info-t_area
                          io_previous             = lo_dc_calc_previous ).

      IF ls_proc_data-step = gc_step-dc_int_perform_carry_forward.
        CALL METHOD lo_dc_calc_handle->_yearseg_create.
        CALL METHOD lo_dc_calc_handle->_transaction_create_from_db.
        CALL METHOD lo_dc_calc_handle->_hlpseg_create.
        CALL METHOD lo_dc_calc_handle->_hlpseg_get_exp_life_seg.
        CALL METHOD lo_dc_calc_handle->_sumseg_create.
        CALL METHOD lo_dc_calc_handle->_calcamount_create."2193614
      ELSE.
        CALL METHOD perform_step_processing
        EXPORTING
          id_process = ls_proc_data-process
          id_step    = ls_proc_data-step
          io_handle  = lo_dc_calc_handle.
      ENDIF.

      IF ls_proc_data-step = gc_step-dc_720_ldt_check_request. "2163196
        EXIT.
      ENDIF.

      IF ls_proc_data-fyear = is_processing_info-fyear_to.
        EXIT.
      ENDIF.

      lo_dc_calc_previous = lo_dc_calc_handle.
      ls_proc_data-fyear  = ls_proc_data-fyear + 1.

      IF is_processing_info-calc_only_exp_ulife EQ abap_false. "2592709
        ls_proc_data-step = gc_step-dc_720_recalculation.   "   2592709
      ENDIF.                                                "   2592709

*     IF is_asset_data-deact_date IS INITIAL.               "2372072"2592709
*       ls_proc_data-step = gc_step-dc_720_recalculation.           "2592709
*     ENDIF.                                                "2372072"2592709

** adjust PERIOD_OFFSET for last year to be calculated on reporting request
*      IF ls_proc_data-fyear = is_processing_info-fyear_to AND is_processing_info-period_offset_last_yr IS NOT INITIAL. "2372072
*        ls_proc_data-period_offset = is_processing_info-period_offset_last_yr.
*      ENDIF.                                                "2372072
    ENDDO.

    ro_dc_calc_handle = lo_dc_calc_handle.
  ENDMETHOD.


  METHOD IF_FAA_DC_SEGMENTS_720~PERFORM_STEP_PROCESSING.
    FIELD-SYMBOLS <ls_tfaa_pc_ps>    TYPE tfaa_pc_ps.
    FIELD-SYMBOLS <ls_tfaa_pc_sm>    TYPE tfaa_pc_sm.

    DATA lo_process_handle           TYPE REF TO cl_faa_process_mngr.

    CALL METHOD cl_faa_process_mngr=>find
      EXPORTING
        id_comp     = id_comp
        id_process  = id_process
        id_step     = id_step
        id_procmode = id_procmode
      RECEIVING
        ro_handle   = lo_process_handle.

    LOOP AT lo_process_handle->mt_subprocess ASSIGNING <ls_tfaa_pc_ps>.
      LOOP AT lo_process_handle->mt_method ASSIGNING <ls_tfaa_pc_sm>
        WHERE subprocess = <ls_tfaa_pc_ps>-subprocess.

        CALL METHOD io_handle->(<ls_tfaa_pc_sm>-method).
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.


  METHOD prepare_badi_call.

* get segment handle that is used as importing parameter for BaDI calls
    IF co_dc_segment_handle IS NOT BOUND.
      CREATE OBJECT co_dc_segment_handle.
    ENDIF.

    co_dc_segment_handle->mo_assetdata  ?= mo_start->ms_asset_data-object_instance.
    co_dc_segment_handle->mts_hlpseg     = mts_hlpseg.
    co_dc_segment_handle->mts_hlpseg     = mts_hlpseg.
    co_dc_segment_handle->mt_timeseg     = mt_timeseg.
    co_dc_segment_handle->mt_yearseg     = mt_yearseg.
    co_dc_segment_handle->mt_sumseg      = mt_sumseg.
    co_dc_segment_handle->mt_transaction = mt_transaction.
    co_dc_segment_handle->mt_parameter   = mt_parameter.
    co_dc_segment_handle->mt_period      = mt_period.
    co_dc_segment_handle->mt_rounding    = mt_rounding.
    co_dc_segment_handle->mt_areasign    = mt_areasign.
    co_dc_segment_handle->mt_virtarea    = mt_virtarea.
    co_dc_segment_handle->mo_leadobj     = ms_proc_data-leadobj_instance.
    co_dc_segment_handle->mt_transaction_post = mt_transaction_post. "2236564
    co_dc_segment_handle->md_process          = ms_proc_data-process. "2236564
    co_dc_segment_handle->md_step             = ms_proc_data-step. "2236564
    co_dc_segment_handle->md_fyear            = ms_proc_data-fyear. "2236564

* provide transactions of all calculated years to BAdI
    DATA lo_previous TYPE ty_o_dc_calc_handle.              "2342035

    CHECK ms_proc_data-step = gc_step-dc_720_transaction_reversal
       or ms_proc_data-step = gc_step-dc_720_transaction_posting
       or ms_proc_data-step = gc_step-dc_720_recalculation.

    lo_previous = mo_previous.
    WHILE lo_previous IS BOUND.
      APPEND LINES OF mo_previous->mt_transaction_post TO co_dc_segment_handle->mt_transaction_post.
      APPEND LINES OF mo_previous->mt_transaction      TO co_dc_segment_handle->mt_transaction.
      lo_previous = lo_previous->mo_previous.
    ENDWHILE.                                               "2342035

  ENDMETHOD.


  METHOD SET_ASSET_DATA.
    ms_asset_data        = is_asset_data.
    ms_transaction_cntrl = is_asset_data-s_transaction_cntrl.
    mt_transaction_post  = is_asset_data-t_transaction_post.
  ENDMETHOD.


  METHOD SET_PROCESS_CONTROL_DATA.
    ms_proc_data        = is_process_control_data.
    mts_area            = its_area.
    mo_previous        ?= io_previous.

* ensure that year independant data and asset data are just kept
* on first instance created to save memory
    IF mo_previous IS BOUND.
      mo_start = mo_previous->mo_start.
    ELSE.
      mo_start = me.
    ENDIF.
  ENDMETHOD.


METHOD _AREASIGN_CREATE.
  FIELD-SYMBOLS <ls_virtarea>    TYPE if_faa_dc_segments_720=>ty_s_virtarea.
  FIELD-SYMBOLS <ls_areasign>    TYPE ty_s_areasign.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_arearef>     TYPE ty_s_arearef.
  FIELD-SYMBOLS <ls_area>        TYPE ty_s_area.

  DATA ls_areasign               TYPE ty_s_areasign.

* get definitions for companycode and depr. areas
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
    AT NEW area.
      CALL METHOD get_area_signs
        EXPORTING
          io_arearef    = <ls_hlpseg>-arearef
          id_neg_values = <ls_hlpseg>-neg_values
        IMPORTING
          es_areasign   = ls_areasign.
      APPEND ls_areasign TO mt_areasign.
    ENDAT.
  ENDLOOP.

* get settings for derived areas
  READ TABLE mts_area ASSIGNING <ls_area> INDEX 1.

  LOOP AT mt_virtarea ASSIGNING <ls_virtarea>.
    AT NEW virt_area.
      CLEAR ls_areasign.
      READ TABLE <ls_area>-arearef->if_faa_cfg_leadobj~mts_arearef ASSIGNING <ls_arearef>
        WITH KEY key_depr_area COMPONENTS depr_area = <ls_virtarea>-virt_area.

      CALL METHOD get_area_signs
        EXPORTING
          io_arearef    = <ls_arearef>-depr_area_ref
          id_neg_values = gc_area_value_sign-positive
        IMPORTING
          es_areasign   = ls_areasign.
    ENDAT.

    READ TABLE mt_areasign ASSIGNING <ls_areasign>
      WITH KEY area  = <ls_virtarea>-real_area.

    IF <ls_areasign>-sign <> gc_area_value_sign-positive.
      ls_areasign-sign = <ls_areasign>-sign.
    ENDIF.

    AT END OF virt_area.
      APPEND ls_areasign TO mt_areasign.
    ENDAT.
  ENDLOOP.

ENDMETHOD.


METHOD _calcamount_create.

  DATA ls_calcamount LIKE LINE OF mts_calcamount.

  LOOP AT ms_asset_data-t_calc_values ASSIGNING FIELD-SYMBOL(<ls_calc_values>)
    WHERE fyear = ms_proc_data-fyear.
    ls_calcamount-fyear     = <ls_calc_values>-fyear.
    ls_calcamount-area      = <ls_calc_values>-area.
    ls_calcamount-curr_type = <ls_calc_values>-curr_type.
    ls_calcamount-total     = <ls_calc_values>-cum.
    INSERT ls_calcamount INTO TABLE mts_calcamount.         "2347861
  ENDLOOP.

ENDMETHOD.


  method _CALCORDER_CALL_BADI.
*
  endmethod.


METHOD _CALCORDER_CREATE.
  FIELD-SYMBOLS <ls_arearef>    TYPE if_faa_dc_segments_720=>ty_s_arearef.
  FIELD-SYMBOLS <ls_virtarea>   TYPE ty_s_virtarea.
  FIELD-SYMBOLS <ls_area>       TYPE ty_s_area.
  FIELD-SYMBOLS <ls_hlpseg>     TYPE ty_s_hlpseg.

  DATA lt_calcorder             TYPE STANDARD TABLE OF ty_s_calcorder.

  DATA ls_calcorder             TYPE ty_s_calcorder.
  DATA ls_virtarea              TYPE ty_s_virtarea.
  DATA ls_seqno                 TYPE ty_s_calcorder-seqno.

  DATA lv_entry_4_virt_area     TYPE boolean.
*
*  DATA: BEGIN OF ls_seqno,
*          fyear       TYPE numc4,
*          virt_area   TYPE numc4,
*          area        TYPE numc4,
*          period_from TYPE numc3,
*          sort_ind    TYPE numc2.
*  DATA:  END OF ls_seqno.

* check if processing required at all
  CHECK NOT mt_parameter[] IS INITIAL.


  READ TABLE mts_area ASSIGNING <ls_area> INDEX 1.
* <<<<  create CALCORDER for all real areas following the rules: >>>>*
* 1. first calculate all real areas without virtual area assignment
*
* 2. second for real areas with virtual area assignment
*    the sequence is given by the first assigned virtual area
* 3. after all assigned real areas calculate virtual area

  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.

* determine wether area is assigned to virtual area
    AT NEW area.
      READ TABLE mt_virtarea INTO ls_virtarea
            WITH KEY real_area = <ls_hlpseg>-area.

      IF sy-subrc <> 0.
        lv_entry_4_virt_area = abap_false.

        CLEAR ls_virtarea.

      ELSE.
        lv_entry_4_virt_area = abap_true.
      ENDIF.
    ENDAT.

* avoid call of calculation engine on retirement request dated to the beginning of the fiscal year
* and for areas which area assigned to group assets
    CHECK <ls_hlpseg>-grp_asset_assgnd IS INITIAL.
    CHECK <ls_hlpseg>-period_to        >  000.

* determine sequence number of CALCORDER entry to be created
    CLEAR ls_seqno.

    ls_seqno-virt_area       =  ls_virtarea-virt_area.
    ls_seqno-base_area       = <ls_hlpseg>-area.
    ls_seqno-period_from     = <ls_hlpseg>-period_from.
    ls_seqno-sort_ind        = <ls_hlpseg>-sort_indicator.

* create CALCORDER entry
    CLEAR ls_calcorder.

    ls_calcorder-seqno       = ls_seqno.
    ls_calcorder-fyear       = <ls_hlpseg>-fyear.
    ls_calcorder-area        = <ls_hlpseg>-area.
    ls_calcorder-amount_type = <ls_hlpseg>-amount_type.
    ls_calcorder-period_to   = <ls_hlpseg>-period_to.

    IF ls_virtarea IS NOT INITIAL.
      ls_calcorder-is_dependant = abap_true.
    ENDIF.

    APPEND ls_calcorder TO lt_calcorder.

* create entries for all virtual areas but for amount_types
* N,S,Z and I only and just for one of them
    CHECK lv_entry_4_virt_area    = abap_true.

    CHECK <ls_hlpseg>-amount_type = gc_amount_type-ordn
       OR <ls_hlpseg>-amount_type = gc_amount_type-spec
       OR <ls_hlpseg>-amount_type = gc_amount_type-intr
       OR <ls_hlpseg>-amount_type = gc_amount_type-infl.

    LOOP AT mt_virtarea ASSIGNING <ls_virtarea>
      WHERE real_area = <ls_hlpseg>-area.

      READ TABLE <ls_area>-arearef->if_faa_cfg_leadobj~mts_arearef ASSIGNING <ls_arearef>
        WITH KEY key_depr_area COMPONENTS depr_area = <ls_virtarea>-virt_area.

* check if there is already an appropriate entry for the virtual area
      IF <ls_arearef>-depr_area_ref->msx_areadef-area_usage_ind = '2'.
        READ TABLE lt_calcorder TRANSPORTING NO FIELDS
              WITH KEY area      = <ls_virtarea>-virt_area
                       period_to = 366.
      ELSE.
        READ TABLE lt_calcorder TRANSPORTING NO FIELDS
              WITH KEY area      = <ls_virtarea>-virt_area
                       period_to = <ls_hlpseg>-period_to.
      ENDIF.                                                              "

      CHECK sy-subrc <> 0.

* determine sequence number of CALCORDER entry to be created
      ls_seqno-virt_area           = <ls_virtarea>-virt_area.
      ls_seqno-base_area           = <ls_virtarea>-virt_area.
      ls_seqno-period_from         = <ls_hlpseg>-period_from.
      ls_seqno-sort_ind            = 99.

* create CALCORDER entry
      CLEAR ls_calcorder.

      ls_calcorder-seqno           = ls_seqno.
      ls_calcorder-fyear           = <ls_hlpseg>-fyear.
      ls_calcorder-area            = <ls_virtarea>-virt_area.
      ls_calcorder-period_to       = <ls_hlpseg>-period_to.
      ls_calcorder-is_dependant    = abap_true.
      ls_calcorder-is_virtual_area = abap_true.

* create CALCORDER entries for each period interval if base areas
* use the same count of calculation periods this is true id area_usage_ind <> '2'.
* on different numbers of periods to be calc. for the base areas we create just
* one single entry for our vitual area to force value adjustment by the end of year
      IF <ls_arearef>-depr_area_ref->msx_areadef-area_usage_ind = '2'.
        IF <ls_hlpseg>-period_to = <ls_hlpseg>-periods.
          ls_seqno-period_from   = 366.
          ls_calcorder-seqno     = ls_seqno.
          ls_calcorder-period_to = 366.

        ELSE.
          CONTINUE.
        ENDIF.
      ENDIF.

      APPEND ls_calcorder TO lt_calcorder.
    ENDLOOP.

* insure CALCORDER is created just for one amount type of an area if several areas are to be calculated
    AT END OF amount_type.
      lv_entry_4_virt_area = abap_false.
    ENDAT.
  ENDLOOP.

  SORT lt_calcorder BY seqno.

  mts_calcorder[] = lt_calcorder[].

ENDMETHOD.


METHOD _hlpseg_create.
*******************************************************************
* - Take over fixed asset master data
* - create intervals from time dependant parameter for each amount type
*   => determine calculation start date if applicable
*   => determine calculation phase and get settings of depr. key for phase
*   => determine expired useful life in periods
*   => perform split on calculation start period if applicable
*      - one entry with PERIOD_TO   = START_PERIOD - 1 and PHASE = 0
*      - one entry with PERIOD_from = START_PERIOD adn original PERIOD_TO
*   => perform split on changeover period if applicable
*
* - calculate expired useful life from changeover year if applicable
*   => create from first entry for area an entry for revaluation calcualtion
*      if we are not in the year of first acquisition per revaluation type
*
* - on implicit carry forward take over data from prior year
*   => depreciation start date, capitalization date
*   => change over year and period
*   => add on prior year calculated expired life for period intervals
*******************************************************************

  FIELD-SYMBOLS <ls_hlpseg>     TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_area>       TYPE ty_s_area.
  FIELD-SYMBOLS <lv_calc_seq>   TYPE ty_s_hlpseg-amount_types-calc_seq_ordn.

  DATA ls_depr_param            TYPE ty_s_deprarea-depr_param.
  DATA ls_hlpseg_split          TYPE ty_s_hlpseg.
  DATA ls_hlpseg_repl           TYPE ty_s_hlpseg.
  DATA ls_hlpseg                TYPE ty_s_hlpseg.

  DATA lv_split_on_co_prd       TYPE abap_bool.

* determine areas and amount types to be calculated
  LOOP AT mo_start->ms_asset_data-ts_depr_param INTO ls_depr_param
    WHERE to_date   >= ms_proc_data-first_day_in_fyr
      AND from_date <= ms_proc_data-last_day_in_fyr.

* get instance of depreciation area configuration
    READ TABLE mts_area ASSIGNING <ls_area>
      WITH KEY depr_area = ls_depr_param-depr_area.
    CHECK sy-subrc = 0.

    CLEAR ls_hlpseg_split.
    CLEAR ls_hlpseg.

    ls_hlpseg-fyear            = ms_proc_data-fyear.
    ls_hlpseg-first_day_in_yr  = ms_proc_data-first_day_in_fyr.
    ls_hlpseg-last_day_in_yr   = ms_proc_data-last_day_in_fyr.
    ls_hlpseg-arearef          = <ls_area>-arearef.
    ls_hlpseg-area             = <ls_area>-depr_area.

* get count of periods, determine max. "to period" within actual fiscal year
    CALL METHOD ls_hlpseg-arearef->if_faa_cfg_leadobj~get_number_of_periods
      EXPORTING
        id_fisc_year        = ls_hlpseg-fyear
      IMPORTING
        ed_periods          = ls_hlpseg-periods
        ed_periods_short_fy = ls_hlpseg-periods_short_fy.

* determine if fiscal year is a shortened one
    IF ls_hlpseg-periods_short_fy <> ls_hlpseg-periods.
      ls_hlpseg-is_shortfiscyear = abap_true.
    ENDIF.

* On calculation of sub-sequent fiscal year
* get amount type indepedent data from prior year processing
    IF mo_previous IS BOUND.
      READ TABLE mo_previous->mts_hlpseg ASSIGNING <ls_hlpseg>
               WITH KEY fyear       = mo_previous->ms_proc_data-fyear
                        area        = ls_hlpseg-area.
      ASSERT sy-subrc EQ 0.

      ls_hlpseg-ignore_memval   = <ls_hlpseg>-ignore_memval. "2160869
      ls_hlpseg-assetclass      = <ls_hlpseg>-assetclass.   "2160869
      ls_hlpseg-cap_date        = <ls_hlpseg>-cap_date.
      ls_hlpseg-initial_acq     = <ls_hlpseg>-initial_acq.
      ls_hlpseg-initial_acq_yr  = <ls_hlpseg>-initial_acq_yr.
      ls_hlpseg-initial_acq_prd = <ls_hlpseg>-initial_acq_prd.
      ls_hlpseg-last_ret_date   = <ls_hlpseg>-last_ret_date.
      ls_hlpseg-deact_date      = <ls_hlpseg>-deact_date.

* On calculation of first fiscal year take over data from asset master
    ELSE.
      ls_hlpseg-ignore_memval    = mo_start->ms_asset_data-ignore_memval.
      ls_hlpseg-assetclass       = mo_start->ms_asset_data-assetclass.
      ls_hlpseg-cap_date         = mo_start->ms_asset_data-cap_date.
      ls_hlpseg-initial_acq      = mo_start->ms_asset_data-initial_acq.
      ls_hlpseg-initial_acq_yr   = mo_start->ms_asset_data-initial_acq_yr.
      ls_hlpseg-initial_acq_prd  = mo_start->ms_asset_data-initial_acq_prd.
      ls_hlpseg-last_ret_date    = mo_start->ms_asset_data-last_ret_date.
    ENDIF.

* fill HLPSEG from depreciation parameter
    CALL METHOD get_depr_param
      EXPORTING
        is_depr_param = ls_depr_param
      CHANGING
        cs_hlpseg     = ls_hlpseg.

* determine start period of interval, from date is adjusted to first day of calc. period on ANLZ merge in CL_FAA_DC_ENGINE_CALL "2274717
    IF ls_depr_param-from_date <= ms_proc_data-first_day_in_fyr.
      ls_hlpseg-period_from = 1.
      CLEAR ls_hlpseg_repl.
    ELSE.
      IF ls_hlpseg-use_days EQ abap_false.
        CALL METHOD ls_hlpseg-arearef->get_period_and_year
          EXPORTING
            id_date   = ls_depr_param-from_date
          IMPORTING
            ed_period = ls_hlpseg-period_from.
      ELSE.
        ls_hlpseg-period_from = ls_depr_param-from_date - ls_hlpseg-first_day_in_yr + 1.
      ENDIF.
    ENDIF."2209564 "2239263 "2274717

* determine end period of interval, to date is adjusted to last day of calc. period on ANLZ merge in CL_FAA_DC_ENGINE_CALL "2274717
    IF ls_depr_param-to_date >= ms_proc_data-last_day_in_fyr.
      ls_hlpseg-period_to = ls_hlpseg-periods_short_fy.
    ELSE.
      IF ls_hlpseg-use_days EQ abap_false.
        CALL METHOD ls_hlpseg-arearef->get_period_and_year
          EXPORTING
            id_date   = ls_depr_param-to_date
          IMPORTING
            ed_period = ls_hlpseg-period_to.
      ELSE.
        ls_hlpseg-period_to = ls_depr_param-to_date - ls_hlpseg-first_day_in_yr + 1.
      ENDIF.
    ENDIF. "2209564 "2239263 "2274717

*******************************************************************
* create entry per amount type to be calculated
*******************************************************************
    DO 3 TIMES.
      ASSIGN COMPONENT sy-index OF STRUCTURE ls_hlpseg-amount_types TO <lv_calc_seq>.
      CHECK <lv_calc_seq> > 0.
      CLEAR ls_hlpseg-start_prd.
      CLEAR ls_hlpseg-start_yr.
      CLEAR ls_hlpseg-keyref.

      CASE sy-index.
        WHEN 1.
          ls_hlpseg-start_date     = ls_depr_param-odepr_start_date.
          ls_hlpseg-amount_type    = gc_amount_type-ordn.
          ls_hlpseg-sort_indicator = ls_hlpseg-calc_seq_ordn.
        WHEN 2.
          ls_hlpseg-start_date     = ls_depr_param-sdepr_start_date.
          ls_hlpseg-amount_type    = gc_amount_type-spec.
          ls_hlpseg-sort_indicator = ls_hlpseg-calc_seq_spec.
        WHEN 3.
          ls_hlpseg-start_date     = ls_depr_param-intr_start_date.
          ls_hlpseg-amount_type    = gc_amount_type-intr.
          ls_hlpseg-sort_indicator = ls_hlpseg-calc_seq_intr.

          " special case: due to customizing of T093-VZZINS = '0' in prior years date was'nt set "2342928
          IF ls_hlpseg-start_date IS INITIAL AND ls_depr_param-odepr_start_date IS NOT INITIAL.
            ls_hlpseg-start_date = ls_depr_param-odepr_start_date.
          ENDIF.
      ENDCASE.

* On calculataion of sub-sequent fiscal year
* get amount type depedent data from prior year processing
      IF mo_previous IS BOUND.
        CALL METHOD get_data_from_prior_year
          CHANGING
            cs_hlpseg = ls_hlpseg.

* determine wether useful life has already expired to ensure correct phase determination 2270486 "2442066
        IF ls_hlpseg-exp_life >= ls_hlpseg-useful_life.
          ls_hlpseg-is_behind_ul = abap_true.
        ENDIF.
      ENDIF.

* get phase and depr key settings for period interval4
      CALL METHOD get_phase_and_deprkey_config
        CHANGING
          cs_hlpseg = ls_hlpseg.

* determine calc start date/year/period and expired life for first year to calc
      IF mo_previous IS NOT BOUND.
        CALL METHOD get_calc_info_for_amount_type
          EXPORTING
            is_depr_param = ls_depr_param
          CHANGING
            cs_hlpseg     = ls_hlpseg.
      ENDIF.

* adjust PHASE to "no calculation" if calculations start date is initial.
      IF ls_hlpseg-start_date IS INITIAL.                   "2345009
        ls_hlpseg-phase = 0.
      ENDIF.

* get interval length and changeover year/period from BAdI implementation
      IF go_badi_customer IS BOUND OR go_badi_country IS BOUND.
        CALL METHOD get_data_from_badi
          CHANGING
            cs_hlpseg = ls_hlpseg.

        IF ls_hlpseg-range_length > 0.
          ms_proc_data-split_on_badi = abap_true.
        ENDIF.
      ENDIF.

* note if check for change over within useful life to be performed
      CASE ls_hlpseg-keyref->ms_settings-changeover_meth.
        WHEN gc_changeover_meth_depr-rule_1
          OR gc_changeover_meth_depr-rule_6
          OR gc_changeover_meth_depr-rule_9.
          ms_proc_data-co_on_depr      = abap_true.
        WHEN gc_changeover_meth_nbv-rule_2
          OR gc_changeover_meth_nbv-rule_3
          OR gc_changeover_meth_nbv-rule_4
          OR gc_changeover_meth_nbv-rule_7.
          ms_proc_data-co_on_nbv        = abap_true.
        WHEN gc_changeover_meth_depr-rule_a.
          ms_proc_data-co_on_depr       = abap_true.
          ms_proc_data-co_no_co_yr_set  = abap_true.
        WHEN gc_changeover_meth_nbv-rule_b.
          ms_proc_data-co_on_nbv        = abap_true.
          ms_proc_data-co_no_co_yr_set  = abap_true.
        WHEN gc_changeover_meth_country.
          ms_proc_data-co_country_badi  = abap_true.
        WHEN gc_changeover_meth_customer.
          ms_proc_data-co_customer_badi = abap_true.
      ENDCASE.

* check if split on change over period to be performed
      IF ls_hlpseg-changeover_yr = ls_hlpseg-fyear.
        IF ls_hlpseg-changeover_prd > 1.
          lv_split_on_co_prd = abap_true.
        ENDIF.
      ENDIF.

* just add interval if we are not in the start year
      IF ls_hlpseg-start_yr <> ls_hlpseg-fyear.

        IF ls_hlpseg-start_yr > ls_hlpseg-fyear.
          ls_hlpseg-phase = 0.
        ENDIF.

        APPEND ls_hlpseg TO mts_hlpseg.

* perform interval split on calculation start period if required
      ELSE.
        IF ls_hlpseg-start_prd > ls_hlpseg-period_from AND
           ls_hlpseg-start_prd <= ls_hlpseg-period_to.

          ls_hlpseg_split             = ls_hlpseg.
          ls_hlpseg_split-phase       = 0.
          ls_hlpseg_split-period_from = ls_hlpseg-period_from.
          ls_hlpseg_split-period_to   = ls_hlpseg-start_prd - 1.

          APPEND ls_hlpseg_split TO mts_hlpseg.

          ls_hlpseg_split-phase       = ls_hlpseg-phase.
          ls_hlpseg_split-period_from = ls_hlpseg-start_prd.
          ls_hlpseg_split-period_to   = ls_hlpseg-period_to.

          APPEND ls_hlpseg_split TO mts_hlpseg.

* just add interval
        ELSE.
          IF ls_hlpseg-start_prd > ls_hlpseg-period_to.     "2274717
            ls_hlpseg-phase = 0.
          ENDIF.
          APPEND ls_hlpseg TO mts_hlpseg.
        ENDIF.
      ENDIF.

* note data of first entry created for area to create entry for replacement value calculation
      CHECK ls_hlpseg-rplcmntval_index IS NOT INITIAL
         OR ls_hlpseg-age_index        IS NOT INITIAL.

      CHECK ls_hlpseg-initial_acq_yr   <  ms_proc_data-fyear.
      CHECK ls_hlpseg_repl             IS INITIAL.
      ls_hlpseg_repl = ls_hlpseg.
    ENDDO.

* finally add one whole year intervall for replacement value calculation
* if applicable
    CHECK ls_hlpseg_repl IS NOT INITIAL.
    CHECK ls_depr_param-to_date >= ms_proc_data-last_day_in_fyr. "2209564
    CLEAR ls_hlpseg.

    ls_hlpseg-fyear          = ls_hlpseg_repl-fyear.
    ls_hlpseg-area           = ls_hlpseg_repl-area.
    ls_hlpseg-arearef        = ls_hlpseg_repl-arearef.
    ls_hlpseg-keyref         = ls_hlpseg_repl-keyref.
    ls_hlpseg-periods        = ls_hlpseg_repl-periods.
    ls_hlpseg-period_to      = ls_hlpseg_repl-periods_short_fy.
    ls_hlpseg-period_from    =  1.
    ls_hlpseg-exp_life       = ls_hlpseg_repl-exp_life.
    ls_hlpseg-exp_life_seg   = ls_hlpseg_repl-periods.
    ls_hlpseg-phase          = 1.
    ls_hlpseg-initial_acq_yr = ls_hlpseg_repl-initial_acq_yr.
    ls_hlpseg-start_yr       = ls_hlpseg_repl-initial_acq_yr + 1.
    ls_hlpseg-start_prd      = 1.
    ls_hlpseg-neg_values     = ls_hlpseg_repl-neg_values.
    ls_hlpseg-use_days       = ls_hlpseg_repl-use_days.
    ls_hlpseg-amount_types   = ls_hlpseg_repl-amount_types.
    ls_hlpseg-ignore_memval  = ls_hlpseg_repl-ignore_memval. "> 2447530
    ls_hlpseg-to_date_of_tddp = if_faa_master_constants=>gc_max_date. "< 2530841
    ls_hlpseg-assetclass     = ls_hlpseg_repl-assetclass.   "> 2447530
    ls_hlpseg-cap_date       = ls_hlpseg_repl-cap_date.     "> 2447530
    ls_hlpseg-periods_short_fy = ls_hlpseg_repl-periods_short_fy. "2453872
    ls_hlpseg-first_day_in_yr  = ls_hlpseg_repl-first_day_in_yr. "2453872

* get parameter for calculation of replacement value
    IF ls_hlpseg_repl-rplcmntval_index IS NOT INITIAL.
      ls_hlpseg-sort_indicator   = 20.
      ls_hlpseg-amount_type      = gc_amount_type-repl.
      ls_hlpseg-rplcmntval_index = ls_hlpseg_repl-rplcmntval_index.

      CALL METHOD get_repl_param
        CHANGING
          cs_hlpseg = ls_hlpseg.

      APPEND ls_hlpseg TO mts_hlpseg.
    ENDIF.

* get parameter for calculation of replacement value using age index
    IF ls_hlpseg_repl-age_index IS NOT INITIAL.
      ls_hlpseg-sort_indicator = 10.
      ls_hlpseg-amount_type    = gc_amount_type-rage.
      ls_hlpseg-age_index      = ls_hlpseg_repl-age_index.

      CALL METHOD get_repl_param
        CHANGING
          cs_hlpseg = ls_hlpseg.

      APPEND ls_hlpseg TO mts_hlpseg.
    ENDIF.
  ENDLOOP.

* perform split on change over period if applicable/get appropriate phase
* for interval for which changeover is to be regarded
  IF lv_split_on_co_prd = abap_true.
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
      WHERE changeover_yr   = ms_proc_data-fyear
        AND changeover_prd  > 1
        AND phase           = 1.

      IF <ls_hlpseg>-changeover_prd <= <ls_hlpseg>-period_to AND
         <ls_hlpseg>-changeover_prd >  <ls_hlpseg>-period_from.

        ls_hlpseg_split             = <ls_hlpseg>.
        <ls_hlpseg>-period_to       = ls_hlpseg_split-changeover_prd - 1.
        ls_hlpseg_split-period_from = ls_hlpseg_split-changeover_prd.

* get phase and depr key settings for period interval
        CALL METHOD get_phase_and_deprkey_config
          CHANGING
            cs_hlpseg = ls_hlpseg_split.
        APPEND ls_hlpseg_split TO mts_hlpseg.
      ENDIF.

      IF <ls_hlpseg>-changeover_prd <= <ls_hlpseg>-period_from.
        CALL METHOD get_phase_and_deprkey_config
          CHANGING
            cs_hlpseg = <ls_hlpseg>.
      ENDIF.
    ENDLOOP.
  ENDIF.

  SORT mts_hlpseg.
ENDMETHOD.


METHOD _hlpseg_get_co_yr_and_prd.
*=======================================================================
* perform changeover according changeover rule to be applied
*=======================================================================
  CHECK ms_transaction_cntrl-set_changeover_y = abap_true
     or ms_proc_data-co_on_depr               = abap_true
     OR ms_proc_data-co_on_nbv                = abap_true.

  CHECK ms_transaction_cntrl-classification <> gc_classification-transfer_ret
    AND ms_transaction_cntrl-classification <> gc_classification-retirement.

  FIELD-SYMBOLS <ls_calcamount1>    TYPE ty_s_calcamount.
  FIELD-SYMBOLS <ls_calcamount2>    TYPE ty_s_calcamount.
  FIELD-SYMBOLS <ls_calcdata1>      TYPE ty_s_calcdata.
  FIELD-SYMBOLS <ls_calcdata2>      TYPE ty_s_calcdata.
  FIELD-SYMBOLS <ls_yearseg1>       TYPE ty_s_yearseg.
  FIELD-SYMBOLS <ls_hlpseg>         TYPE ty_s_hlpseg.

  DATA lo_processing_handle         LIKE me.
  DATA lo_processing_handle_phase_1 LIKE me.
  DATA lo_processing_handle_phase_2 LIKE me.

  DATA ls_deprkey_key               TYPE ty_s_deprkey-key.  "2318954
  DATA ls_hlpseg                    TYPE ty_s_hlpseg.

  DATA lv_sum_depr1                 TYPE f.
  DATA lv_sum_depr2                 TYPE f.
  DATA lv_changeover_value          TYPE f.
  DATA lv_sum_apc                   TYPE f.
  DATA lv_nbv                       TYPE f.
  DATA lv_lin_depr_proz             TYPE decfloat34.        "2520616

*=============================================================================
* set changover year from posting year for all areas for which no
* other changeover method is to be applied
*=============================================================================
  IF ms_transaction_cntrl-set_changeover_y EQ abap_true.
    ls_hlpseg-changeover_yr = ms_transaction_cntrl-fyear.

    MODIFY mts_hlpseg
      FROM ls_hlpseg TRANSPORTING changeover_yr
     WHERE changeover_yr                       < ms_transaction_cntrl-fyear
       AND keyref->ms_settings-changeover_meth = gc_changeover_meth_none-rule_0
       AND grp_asset_assgnd                    = abap_false.
  ENDIF.

*=============================================================================
* perform depreciation calculation for phase 1 and if applicaple for phase 2
*=============================================================================
  CREATE OBJECT lo_processing_handle_phase_1.

* take over phase independant data
  lo_processing_handle_phase_1->mo_previous       = me.
  lo_processing_handle_phase_1->mo_start          = mo_start.
  lo_processing_handle_phase_1->ms_proc_data      = ms_proc_data.
  lo_processing_handle_phase_1->mts_area          = mts_area.
  lo_processing_handle_phase_1->mt_areasign       = mt_areasign. "2189388
  lo_processing_handle_phase_1->mt_rounding       = mt_rounding. "2189388
  lo_processing_handle_phase_1->mt_yearseg        = mt_yearseg.
  lo_processing_handle_phase_1->mt_transaction    = mt_transaction.

  lo_processing_handle_phase_1->ms_proc_data-step = gc_step-dc_int_calc_co_rules.

* prepare calculation of the relevant areas and amount types for change over check
  lo_processing_handle_phase_1->mts_hlpseg        = mts_hlpseg.

  DELETE lo_processing_handle_phase_1->mts_hlpseg
   WHERE keyref->ms_settings-changeover_meth NA gc_changeover_meth_in_ul
      OR changeover_yr                       IS NOT INITIAL
      OR grp_asset_assgnd                    EQ abap_true
      OR is_behind_ul                        EQ abap_true
      OR amount_Type                         eQ gc_amount_type-rage "2318954
      OR amount_Type                         eQ gc_amount_type-repl "2318954
      OR start_yr                            GT ms_proc_data-fyear.

  IF ms_proc_data-co_on_depr EQ abap_true.
    LOOP AT lo_processing_handle_phase_1->mts_hlpseg INTO ls_hlpseg
     WHERE keyref->ms_settings-changeover_meth CA gc_changeover_meth_depr.
      IF lo_processing_handle_phase_2 IS INITIAL.
        CREATE OBJECT lo_processing_handle_phase_2.

        lo_processing_handle_phase_2->ms_proc_data-step = lo_processing_handle_phase_1->ms_proc_data-step.
        lo_processing_handle_phase_2->mo_previous       = lo_processing_handle_phase_1->mo_previous.
        lo_processing_handle_phase_2->mo_start          = lo_processing_handle_phase_1->mo_start.
        lo_processing_handle_phase_2->ms_proc_data      = lo_processing_handle_phase_1->ms_proc_data.
        lo_processing_handle_phase_2->mts_area          = lo_processing_handle_phase_1->mts_area.
        lo_processing_handle_phase_2->mt_areasign       = lo_processing_handle_phase_1->mt_areasign. "2189388
        lo_processing_handle_phase_2->mt_rounding       = lo_processing_handle_phase_1->mt_rounding. "2189388
        lo_processing_handle_phase_2->mt_yearseg        = lo_processing_handle_phase_1->mt_yearseg.
        lo_processing_handle_phase_2->mt_transaction    = lo_processing_handle_phase_1->mt_transaction.
      ENDIF.

      IF ls_hlpseg-phase = 1.                               "2318954
        ls_hlpseg-phase = 2.

        ls_deprkey_key-depr_key    = ls_hlpseg-depr_key.
        ls_deprkey_key-amount_type = ls_hlpseg-amount_type.
        ls_deprkey_key-phase       = ls_hlpseg-phase.

        CALL METHOD cf_faa_cfg_deprkey=>find
          EXPORTING
            id_leadobj_value = ls_hlpseg-arearef->if_faa_cfg_leadobj~ms_leadobj_key-orgunit
            id_deprkey_key   = ls_deprkey_key
            id_deprarea      = ls_hlpseg-arearef->md_deprarea
          RECEIVING
            ro_instance      = DATA(lo_instance).
        ls_hlpseg-keyref ?= lo_instance.
      ENDIF.
      APPEND ls_hlpseg TO lo_processing_handle_phase_2->mts_hlpseg.
    ENDLOOP.
  ENDIF.

  DO 2 TIMES.
    CASE sy-index.
      WHEN 1.
        lo_processing_handle = lo_processing_handle_phase_1.
      WHEN 2.
        CHECK lo_processing_handle_phase_2 IS BOUND.
        lo_processing_handle = lo_processing_handle_phase_2.
    ENDCASE.

    CALL METHOD lo_processing_handle->_hlpseg_split_at_ul_end.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_mlm.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_mlm_dat.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_cov_key.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_digital.
    CALL METHOD lo_processing_handle->_hlpseg_split_in_max_prds.
    CALL METHOD lo_processing_handle->_timeseg_create.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_timeseg.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_alignment.
    CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
    CALL METHOD lo_processing_handle->_timeseg_create_missing.
    CALL METHOD lo_processing_handle->_parameter_create.
    CALL METHOD lo_processing_handle->_parameter_call_badi.
    CALL METHOD lo_processing_handle->_period_create.
    CALL METHOD lo_processing_handle->_sumseg_create.
    CALL METHOD lo_processing_handle->_calcorder_create.

    TRY.                                                    "2175078
        CALL METHOD lo_processing_handle->_values_calculate.
      CATCH cm_faa_t100.
        CLEAR lo_processing_handle_phase_2.
    ENDTRY.
  ENDDO.

*=============================================================================
* Perform changeover checks
*=============================================================================
  LOOP AT lo_processing_handle_phase_1->mts_hlpseg ASSIGNING <ls_hlpseg>.
    AT NEW amount_type.
      CLEAR ls_hlpseg.
    ENDAT.

*    CHECK <ls_hlpseg>-is_behind_ul EQ abap_false.           "2404517
    CLEAR lv_changeover_value.

*=============================================================================
* Perform changeover on netbook value rule
*=============================================================================
    CASE <ls_hlpseg>-keyref->ms_settings-changeover_meth.
      WHEN gc_changeover_meth_nbv-rule_2
        OR gc_changeover_meth_nbv-rule_3
        OR gc_changeover_meth_nbv-rule_4
        OR gc_changeover_meth_nbv-rule_7
        OR gc_changeover_meth_nbv-rule_b.

* check netbook value at start of fiscal year, if change over is not required on period interval level
*        IF <ls_hlpseg>-keyref->ms_settings-changeover_meth <> gc_changeover_meth_nbv-rule_4. "2404517
*          IF <ls_hlpseg>-period_from > 1.                   "2404517
*            CONTINUE.                                       "2404517
*          ENDIF.                                            "2404517

          READ TABLE lo_processing_handle_phase_1->mt_yearseg ASSIGNING <ls_yearseg1>
            WITH KEY area  = <ls_hlpseg>-area.

          lv_sum_apc = <ls_yearseg1>-cum-apc
                     + <ls_yearseg1>-cum-invs
                     + <ls_yearseg1>-cum-downp
                     + <ls_yearseg1>-cum-resv.
          lv_nbv     = lv_sum_apc
                     + <ls_yearseg1>-cum-depr_o
                     + <ls_yearseg1>-cum-depr_s
                     + <ls_yearseg1>-cum-depr_u.
*        ENDIF.                                              "2404517

        " begin of changes note 2513963
        IF ls_hlpseg-changeover_yr IS INITIAL.
          CASE <ls_hlpseg>-keyref->ms_settings-changeover_meth.

* change over if NBV is lower than change over percentage
            WHEN gc_changeover_meth_nbv-rule_2.
              lv_changeover_value = lv_sum_apc
                                * <ls_hlpseg>-keyref->ms_settings-changeover_perc
                                / 100.

* change over if NBV is lower/equal than change over percentage
            WHEN gc_changeover_meth_nbv-rule_7.
              IF lv_sum_apc NE 0.                             "2418398
                lv_lin_depr_proz = lv_nbv / lv_sum_apc * 100. "2520616
              ENDIF.                                        "2418398

              IF lv_lin_depr_proz <= <ls_hlpseg>-keyref->ms_settings-changeover_perc.
                lv_changeover_value = lv_sum_apc * <ls_hlpseg>-keyref->ms_settings-changeover_perc / 100.
              ENDIF.

* change over if NBV lower than change over amount defined for area
            WHEN gc_changeover_meth_nbv-rule_3.
              lv_changeover_value = <ls_hlpseg>-arearef->msx_areadef-depr_changevalue.

* change over if NBV lower than calculated straight line depreciation, check per interval
            WHEN gc_changeover_meth_nbv-rule_4.
*              READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1> INDEX sy-tabix. "note_2568462
              READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1>  "note_2568462
                WITH KEY fyear       = <ls_hlpseg>-fyear
                         area        = <ls_hlpseg>-area
                         amount_type = <ls_hlpseg>-amount_type
                         period_to   = <ls_hlpseg>-period_to.

              lv_sum_apc = <ls_calcdata1>-sum_apc.
              lv_nbv     = <ls_calcdata1>-netvalue - <ls_calcdata1>-amount.
              IF <ls_hlpseg>-useful_life IS NOT INITIAL.
                lv_changeover_value = lv_sum_apc / <ls_hlpseg>-useful_life.
              ENDIF.

              " Avoid changeover if condition is not met
              IF NOT ( ( lv_nbv LT lv_changeover_value AND lv_sum_apc GT 0  OR
                         lv_nbv GT lv_changeover_value AND lv_sum_apc LT 0 ) AND
                       lv_nbv  NE 0 ).
                CLEAR: lv_sum_apc, lv_nbv, lv_changeover_value.
              ENDIF.
          ENDCASE.

          "lv_changeover_value = abs( lv_changeover_value ).

* check netbook value at start of fiscal year only, if change over is not required on period interval level
          IF ( lv_sum_apc GT 0 AND lv_nbv LT lv_changeover_value ) OR
             ( lv_sum_apc LT 0 AND lv_nbv GT lv_changeover_value ).
            ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear.

            IF <ls_hlpseg>-use_max_periods EQ abap_true AND
               <ls_hlpseg>-period_from     GT 1.            "2404517
              ls_hlpseg-changeover_prd = <ls_hlpseg>-period_to.
            ENDIF.
          ENDIF.
        ENDIF.
        " end of changes note 2513963

*=============================================================================
* Perform changeover if straight line depreciation is higher
*=============================================================================
      WHEN gc_changeover_meth_depr-rule_1
        OR gc_changeover_meth_depr-rule_6
        OR gc_changeover_meth_depr-rule_9
        OR gc_changeover_meth_depr-rule_a.

* perform comparison of calculated amounts only if phase 2 was calculated w/o errors
        CHECK lo_processing_handle_phase_2 IS BOUND.        "2175078

* perform check based on depreciation calculated for whole year and set changeover year
        IF <ls_hlpseg>-period_from = 1.
          READ TABLE lo_processing_handle_phase_1->mts_calcamount ASSIGNING <ls_calcamount1>
            WITH KEY area  = <ls_hlpseg>-area.

          READ TABLE lo_processing_handle_phase_2->mts_calcamount ASSIGNING <ls_calcamount2>
            WITH KEY area = <ls_hlpseg>-area.

          CASE <ls_hlpseg>-amount_type.
            WHEN gc_amount_type-ordn.
              lv_sum_depr1 = abs( <ls_calcamount1>-total-depr_o ).
              lv_sum_depr2 = abs( <ls_calcamount2>-total-depr_o ).
            WHEN gc_amount_type-spec.
              lv_sum_depr1 = abs( <ls_calcamount1>-total-depr_s ).
              lv_sum_depr2 = abs( <ls_calcamount2>-total-depr_s ).
          ENDCASE.

          IF lv_sum_depr2 > lv_sum_depr1.
            CASE <ls_hlpseg>-keyref->ms_settings-changeover_meth.
              WHEN gc_changeover_meth_depr-rule_1
                OR gc_changeover_meth_depr-rule_a.

                ls_hlpseg-changeover_yr  = <ls_hlpseg>-fyear.

              WHEN gc_changeover_meth_depr-rule_6.

                ls_hlpseg-changeover_yr  = <ls_hlpseg>-fyear + 1.

              WHEN gc_changeover_meth_depr-rule_9.

                IF <ls_hlpseg>-start_yr < <ls_hlpseg>-fyear.
                  ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear.
                ELSE.
                  ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear + 1.
                ENDIF.
            ENDCASE.
          ENDIF.
        ENDIF.

* get changeover period
        IF <ls_hlpseg>-use_max_periods EQ abap_true         AND
           ls_hlpseg-changeover_yr     EQ <ls_hlpseg>-fyear AND
           ls_hlpseg-changeover_prd    IS INITIAL.

          READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1> "note_2568462
              WITH KEY fyear       = <ls_hlpseg>-fyear
                     area        = <ls_hlpseg>-area
                     amount_type = <ls_hlpseg>-amount_type
                     period_to   = <ls_hlpseg>-period_to.

          READ TABLE lo_processing_handle_phase_2->mts_calcdata ASSIGNING <ls_calcdata2>
            WITH KEY fyear       = <ls_hlpseg>-fyear
                     area        = <ls_hlpseg>-area
                     amount_type = <ls_hlpseg>-amount_type
                     period_to   = <ls_hlpseg>-period_to.

          lv_sum_depr1 = lv_sum_depr1 - abs( <ls_calcdata1>-amount ).
          lv_sum_depr2 = lv_sum_depr2 - abs( <ls_calcdata2>-amount ).
          IF lv_sum_depr2 > lv_sum_depr1.
            ls_hlpseg-changeover_prd = <ls_calcdata2>-period_to.
          ENDIF.
        ENDIF.
    ENDCASE.

* provide dper. key settings for phase 2 in MTS_HLPSEG if changeover to be performed
    AT END OF amount_type.
      CHECK ls_hlpseg-changeover_yr IS NOT INITIAL.

* set changeover year and period for all intervalls, if to be stored
      IF <ls_hlpseg>-keyref->ms_settings-changeover_meth NE gc_changeover_meth_depr-rule_a AND
       <ls_hlpseg>-keyref->ms_settings-changeover_meth NE gc_changeover_meth_nbv-rule_b.
        MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING changeover_prd changeover_yr
         WHERE area        = <ls_hlpseg>-area
           AND amount_type = <ls_hlpseg>-amount_type.
      ENDIF.

      ls_hlpseg-amount_type  = <ls_hlpseg>-amount_type.     "Begin of 2483403
      ls_hlpseg-depr_key     = <ls_hlpseg>-depr_key.
      ls_hlpseg-phase        = <ls_hlpseg>-phase.
      ls_hlpseg-arearef      = <ls_hlpseg>-arearef.
      ls_hlpseg-keyref       = <ls_hlpseg>-keyref.
      ls_hlpseg-fyear        = <ls_hlpseg>-fyear.
      ls_hlpseg-period_from  = <ls_hlpseg>-period_from.
      ls_hlpseg-is_behind_ul = <ls_hlpseg>-is_behind_ul.    "End of 2483403

      CALL METHOD get_phase_and_deprkey_config
        CHANGING
          cs_hlpseg = ls_hlpseg.

      MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING phase keyref
       WHERE area         = <ls_hlpseg>-area
         AND amount_type  = <ls_hlpseg>-amount_type
         AND period_from >= ls_hlpseg-changeover_prd
         AND phase        = 1.
    ENDAT.
  ENDLOOP.

ENDMETHOD.


METHOD _HLPSEG_GET_DEACT_DATE.
*=======================================================================
* 1. set/reset deactivation date on retirement posting or reversal
*    of a retirement posting
*=======================================================================
* PRECONDITION
  CHECK ms_transaction_cntrl-classification  EQ gc_classification-retirement
     OR ms_transaction_cntrl-classification  EQ gc_classification-transfer_ret.

* DEFINITIONS
  FIELD-SYMBOLS <ls_yearseg>     TYPE ty_s_yearseg.
  FIELD-SYMBOLS <ls_sumseg>      TYPE ty_s_sumseg.

  DATA ls_calcamount             TYPE ty_s_calcamount.      "2206110

  DATA ls_hlpseg                  TYPE ty_S_hlpseg.

  DATA lv_apc                     TYPE ty_S_value-apc.
  DATA lv_nbv                     TYPE ty_S_value-apc.

*// on reversal clear deactivation date
  IF  ms_transaction_cntrl-is_reversal = abap_true.
    CLEAR ls_hlpseg-deact_date.

* set deactivation date if all valuation view sum up to zero
  ELSE.

    " avoid deactivation of asset on retiremen type = 2 (8 is 2 but scrapping) "2422399
    LOOP AT mts_area TRANSPORTING NO FIELDS                 "2422399
      WHERE retirement_type = '2'
         OR retirement_type = '8'.
      IF sy-subrc = 0.
        RETURN.
      ENDIF.
    ENDLOOP.                                                "2422399

    ls_hlpseg-deact_date = ms_transaction_cntrl-value_date.

    LOOP AT mt_yearseg ASSIGNING <ls_yearseg>.              "2206110
      READ TABLE mts_calcamount INTO ls_calcamount          "2206110
            WITH KEY fyear = <ls_yearseg>-fyear
                     area  = <ls_yearseg>-area.
      IF sy-subrc <> 0.
        CLEAR ls_calcamount.
      ENDIF.

      READ TABLE mt_sumseg ASSIGNING <ls_sumseg>
            WITH KEY fyear = <ls_yearseg>-fyear             "2206110
                     area  = <ls_yearseg>-area.

      lv_apc = 0
             + ls_calcamount-total-revl

             + <ls_yearseg>-cum-apc
             + <ls_yearseg>-cum-revl

             + <ls_sumseg>-prev_prev-apc
             + <ls_sumseg>-prev_prev-revl

             + <ls_sumseg>-prev_cur-apc
             + <ls_sumseg>-prev_cur-revl

             + <ls_sumseg>-cur-apc
             + <ls_sumseg>-cur-revl.

      lv_nbv = lv_apc.

      lv_nbv = lv_nbv
             + ls_calcamount-total-revl_d
             + ls_calcamount-total-depr_o
             + ls_calcamount-total-depr_s

             + <ls_yearseg>-cum-invs
             + <ls_yearseg>-cum-revl_d
             + <ls_yearseg>-cum-depr_o
             + <ls_yearseg>-cum-depr_s
             + <ls_yearseg>-cum-depr_u
             + <ls_yearseg>-cum-resv
             + <ls_yearseg>-cum-downp                       "2344748


             + <ls_sumseg>-prev_prev-invs
             + <ls_sumseg>-prev_prev-revl_d
             + <ls_sumseg>-prev_prev-depr_o
             + <ls_sumseg>-prev_prev-depr_s
             + <ls_sumseg>-prev_prev-depr_u
             + <ls_sumseg>-prev_prev-resv
             + <ls_sumseg>-prev_prev-downp                  "2344748

             + <ls_sumseg>-prev_cur-invs
             + <ls_sumseg>-prev_cur-revl_d
             + <ls_sumseg>-prev_cur-depr_o
             + <ls_sumseg>-prev_cur-depr_s
             + <ls_sumseg>-prev_cur-depr_u
             + <ls_sumseg>-prev_cur-resv
             + <ls_sumseg>-prev_cur-downp                   "2344748

             + <ls_sumseg>-cur-invs
             + <ls_sumseg>-cur-revl_d
             + <ls_sumseg>-cur-depr_o
             + <ls_sumseg>-cur-depr_s
             + <ls_sumseg>-cur-depr_u
             + <ls_sumseg>-cur-resv
             + <ls_sumseg>-cur-downp.                       "2344748

* leave loop if values of valuation view do not sum up to zero
      CHECK lv_apc <> 0
         OR lv_nbv <> 0.

      CLEAR ls_hlpseg-deact_date.
      EXIT.                                           "<<<<<< EXIT LOOP
    ENDLOOP.
  ENDIF.

* modify date of last retirement of alle entries in attribute table HLPSEG
  MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING deact_date
   WHERE fyear = ms_proc_data-fyear.

* POSTCONDITION
  "none

ENDMETHOD.


METHOD _HLPSEG_GET_EXP_LIFE_SEG.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_S_hlpseg.

* calc. the expired useful life throughout each segment & get usage ind.
* this information is used for creation of PERIOD and PARAMETER
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
    CALL METHOD get_expired_life_for_interval
      CHANGING
        cs_hlpseg = <ls_hlpseg>.
  ENDLOOP.
ENDMETHOD.


METHOD _HLPSEG_GET_LAST_RET_DATE.

*=======================================================================
* 1. adjust date of last retirement on retirement posting or reversal
*    of a retirement posting
*=======================================================================
* PRECONDITION
  CHECK ms_transaction_cntrl-classification  EQ gc_classification-retirement
     OR ms_transaction_cntrl-classification  EQ gc_classification-transfer_ret.

* DEFINITIONS
  DATA lt_transaction             TYPE faa_dc_t_transaction.
  DATA ls_transaction             TYPE ty_S_transaction.
  DATA ls_hlpseg                  TYPE ty_S_hlpseg.

* Retirement posting adjust last retirement date from actual value date
  IF  ms_transaction_cntrl-is_reversal = abap_false.
    ls_hlpseg-last_ret_date = ms_transaction_cntrl-value_date.

* set last retirement date from value date of prior retirement on reversal
* or clear it if there is none
  ELSE.

    lt_transaction = mt_transaction.

    DELETE lt_transaction
     WHERE classification <> gc_classification-retirement
       AND classification <> gc_classification-transfer_ret.

    DELETE lt_transaction                                   "2226481
     WHERE seqno_reversed IS NOT INITIAL.

    SORT lt_transaction DESCENDING BY value_date.

    READ TABLE lt_transaction INTO ls_transaction INDEX 1.
    IF sy-subrc EQ 0.
      ls_hlpseg-last_ret_date = ls_transaction-value_date.
    ELSE.
      CLEAR ls_hlpseg-last_ret_date.
    ENDIF.
  ENDIF.

* modify date of last retirement of alle entries in attribute table HLPSEG
  MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING last_ret_date
   WHERE fyear = MS_PROC_DATA-fyear.

* POSTCONDITION
  "none

ENDMETHOD.


METHOD _hlpseg_split_at_ul_end.

  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

  DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

  DATA ls_hlpseg                 TYPE ty_s_hlpseg.

  DATA lv_period_to_before_split TYPE faa_dc_period_to.
  DATA lv_decision_indicator     TYPE i.
  DATA lv_exp_life_sum_prev      TYPE float.
  DATA lv_exp_life_sum           TYPE float.
  DATA lv_period_to_int          TYPE i.                     "> 2458203
  DATA lv_end_date               TYPE d.
  DATA lv_days                   TYPE p.

  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.

* initialize all split relevant local fields on new amount type
    AT NEW amount_type.
      lv_exp_life_sum_prev  = <ls_hlpseg>-exp_life.
      lv_exp_life_sum       = <ls_hlpseg>-exp_life.

      IF <ls_hlpseg>-use_exp_life_new = abap_true.
        lv_exp_life_sum_prev  = <ls_hlpseg>-exp_life_new.
        lv_exp_life_sum       = <ls_hlpseg>-exp_life_new.
      ENDIF.
    ENDAT.

* no processing if interval is already marked to be behind useful life
    CHECK <ls_hlpseg>-is_behind_ul                         = abap_false.
    CHECK <ls_hlpseg>-amount_type                         NA 'AC'.

* get next phase if we are already behind useful life at fiscal year start "2442066
    IF <ls_hlpseg>-use_exp_life_new = abap_true.            "2442066
      IF <ls_hlpseg>-exp_life_new >= <ls_hlpseg>-useful_life.
        <ls_hlpseg>-is_behind_ul = abap_true.
      ENDIF.
    ELSE.
      IF <ls_hlpseg>-exp_life >= <ls_hlpseg>-useful_life.
        <ls_hlpseg>-is_behind_ul = abap_true.
      ENDIF.
    ENDIF.

    IF  <ls_hlpseg>-is_behind_ul = abap_true.
      CALL METHOD get_phase_and_deprkey_config
        CHANGING
          cs_hlpseg = <ls_hlpseg>.
    ENDIF.                                                  "2442066

    CHECK <ls_hlpseg>-keyref->ms_settings-changeover_meth <> gc_changeover_meth_at_end-rule_d. "2442066

* calculate the expired useful life of actual period interval
    CALL METHOD get_expired_life_for_interval
      CHANGING
        cs_hlpseg = <ls_hlpseg>.

* get complete expired useful life including the actual interval
    lv_exp_life_sum = lv_exp_life_sum + <ls_hlpseg>-exp_life_seg.

* set decision indicator how to process the actual perod interval
    CLEAR lv_decision_indicator.

* interval is completely within useful life
    IF lv_exp_life_sum <= <ls_hlpseg>-useful_life.
      lv_decision_indicator = 1.
    ENDIF.

* interval is to be split as useful life ends within/with the interval
    IF lv_exp_life_sum > <ls_hlpseg>-useful_life.
      lv_decision_indicator = 3.
    ENDIF.

* no split if just one period covered within period interval
    IF <ls_hlpseg>-period_from = <ls_hlpseg>-period_to.
      lv_decision_indicator = 7.
    ENDIF.

* interval is completely behind, split was performed on previous interval
    IF lv_exp_life_sum_prev >= <ls_hlpseg>-useful_life.
      lv_decision_indicator = 15.
    ENDIF.

* useful life is to be adjusted for calculation if passed, no split
    IF <ls_hlpseg>-keyref->ms_settings-calc_real_life = abap_true.
      lv_decision_indicator = 31.
    ENDIF.

    lv_exp_life_sum_prev = lv_exp_life_sum.

* perfrom processing according decision indicator
* 01 = interval is completely within useful life
* 03 = useful life ends within/with the interval => split
* 07 = interval covers just one period no split
* 15 = interval is completely behind useful life
* 31 = special treatment in _PERIOD_CREATE requested due to depr.key settings
    CASE lv_decision_indicator.

* nothing to be done with this period interval
      WHEN 01
        OR 07
        OR 31.

        CONTINUE.

* preform split
      WHEN 03.
        ls_hlpseg           = <ls_hlpseg>.

        IF <ls_hlpseg>-use_days IS INITIAL.

          ls_hlpseg-period_to = ls_hlpseg-period_from.

          lv_exp_life_sum     = lv_exp_life_sum - <ls_hlpseg>-exp_life_seg.

          WHILE ls_hlpseg-period_to < <ls_hlpseg>-period_to.

* get expiring life for one calculation period
            IF sy-index = 1.
              CALL METHOD get_expired_life_for_interval
                CHANGING
                  cs_hlpseg = ls_hlpseg.
            ENDIF.

* get expired useful life including actual calculation period
            lv_exp_life_sum = lv_exp_life_sum + ls_hlpseg-exp_life_seg.

* complete expired useful life exceeds useful life => LEAVE and perform split
            IF lv_exp_life_sum   >= <ls_hlpseg>-useful_life.
              EXIT.

            ELSE.
              ls_hlpseg-period_to = ls_hlpseg-period_to  + 1.
            ENDIF.
          ENDWHILE.

* insure correct setting of decision indicator on next period interval
          lv_exp_life_sum  = lv_exp_life_sum_prev.

* no split required as end of usefule life is reached with the complete interval
          IF ls_hlpseg-period_to = <ls_hlpseg>-period_to.
            CONTINUE.
          ENDIF.

* on depreciation to the day the number of days in the last year
* has to be calculated precisely
        ELSE.

* logic to consider leap years correctly
          lv_end_date          = <ls_hlpseg>-start_date.
          lv_end_date+0(4)    = lv_end_date+0(4) + <ls_hlpseg>-useful_life_yrs.

          IF lv_end_date+4(4) = gc_date-feb_29+4(4).
            lv_end_date+4(4)  = gc_date-march_01+4(4).
            lv_end_date       = lv_end_date - 1.
          ENDIF.

          lv_days             = <ls_hlpseg>-useful_life_prds * 365 / 12.
          lv_end_date         = lv_end_date + lv_days - 1.

*         if last day of useful life is in prior year split is already done
*         further split is wrong.
          IF lv_end_date >= <ls_hlpseg>-first_day_in_yr.                     "2270486
            lv_period_to_int = lv_end_date - <ls_hlpseg>-first_day_in_yr + 1."< 2458203
            IF lv_period_to_int <= <ls_hlpseg>-periods.                      "< 2458203
              ls_hlpseg-period_to = lv_end_date - <ls_hlpseg>-first_day_in_yr + 1.
            ENDIF.                                                           "< 2458203
          ENDIF.

* no split required
          IF ls_hlpseg-period_to >= <ls_hlpseg>-period_to OR
             ls_hlpseg-period_to <  <ls_hlpseg>-period_from.

            CONTINUE.
          ENDIF.
        ENDIF.

* perform interval split by changing PERIOD_TO of the original interval and
* changing PERIOD_FROM of the new interval to appended
        lv_period_to_before_split = <ls_hlpseg>-period_to.

        <ls_hlpseg>-period_to     = ls_hlpseg-period_to.

        ls_hlpseg-period_from     = ls_hlpseg-period_to + 1.
        ls_hlpseg-period_to       = lv_period_to_before_split.

* interval is completely behind useful life, correct phase has to be defined
      WHEN 15.
        ls_hlpseg = <ls_hlpseg>.
    ENDCASE.

* mark intervals as behind useful life and get appropriate phase
    ls_hlpseg-is_behind_ul = abap_true.

    CALL METHOD get_phase_and_deprkey_config
      CHANGING
        cs_hlpseg = ls_hlpseg.

* append new interval/change actual one according decision indicator
    CASE lv_decision_indicator.

* new interval is to be created due to splitting
      WHEN 3.
        APPEND ls_hlpseg TO lt_hlpseg.

* interval is completely behind useful life, correct phase was to be defined
      WHEN 15.
        <ls_hlpseg> = ls_hlpseg.
    ENDCASE.
  ENDLOOP.

  CHECK NOT lt_hlpseg[] IS INITIAL.
  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT mts_hlpseg.
ENDMETHOD.                    "change


METHOD _HLPSEG_SPLIT_IN_MAX_PRDS .
  CHECK ms_proc_data-split_on_badi = abap_true.

  FIELD-SYMBOLS <ls_hlpseg>       TYPE ty_S_hlpseg.

  DATA lt_hlpseg                  TYPE ty_ts_hlpseg.

  DATA ls_hlpseg                  TYPE ty_S_hlpseg.

* split interval considering max. count of periods defined
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
    WHERE range_length IS not INITIAL.

    ls_hlpseg           = <ls_hlpseg>.

    DO.
      ls_hlpseg-period_to = sy-index * ls_hlpseg-range_length.

      IF ls_hlpseg-period_to >= <ls_hlpseg>-period_to.
        EXIT.
      ENDIF.

      CHECK  ls_hlpseg-period_to >= ls_hlpseg-period_from.

      APPEND ls_hlpseg TO lt_hlpseg.

      ls_hlpseg-period_from  = ls_hlpseg-period_to + 1.

* adjust from period of actual interval
      IF ls_hlpseg-period_from <= <ls_hlpseg>-period_to.
        <ls_hlpseg>-period_from  = ls_hlpseg-period_from.
      ELSE.
        <ls_hlpseg>-period_from  = ls_hlpseg-period_to.
      ENDIF.
    ENDDO.
  ENDLOOP.

* take over intervals created due to split
  CHECK NOT lt_hlpseg[] IS INITIAL.

  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT mts_hlpseg.

ENDMETHOD.


METHOD _hlpseg_split_on_alignment .
************************************************************
*  completely reworked with note "2423741
************************************************************
* example:
*                                                    ( 46 42 )
*                                                    ( 46 43 )
*                                                    ( 46 44 )
*                ( 46 42 )                           ( 46 45 )
*                ( 46 43 )                           ( 47 42 )
*                ( 47 43 )                           ( 47 43 )
*  mt_virtarea = ( 47 44 )  -> lt_virtarea_aligned = ( 47 44 )
*                ( 48 44 )                           ( 47 45 )
*                ( 48 45 )                           ( 48 42 )
*                                                    ( 48 43 )
*                                                    ( 48 44 )
*                                                    ( 48 45 )
*
************************************************************

  FIELD-SYMBOLS <ls_hlpseg>       TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_arearef>      TYPE ty_s_arearef.
  FIELD-SYMBOLS <ls_virtarea>     TYPE faa_ee_s_virtarea.

  DATA lt_virtarea                TYPE faa_ee_t_virtarea.
  DATA lt_virtarea_aligned        TYPE faa_ee_t_virtarea.
  DATA lt_virtarea_tmp            TYPE SORTED TABLE OF faa_ee_s_virtarea WITH UNIQUE KEY virt_area real_area.
  DATA lt_period_to               TYPE SORTED TABLE OF faa_ee_s_period   WITH UNIQUE KEY area period_to.
  DATA ls_period_to               TYPE                 faa_ee_s_period.
  DATA lt_hlpseg                  TYPE ty_ts_hlpseg.
  DATA ls_hlpseg                  TYPE ty_s_hlpseg.
  DATA lv_count                   TYPE i.

* prepare alignment of period intervals of amount types S/Z/N within one area
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
    WHERE use_alignment IS NOT INITIAL
      AND amount_type   CA gc_amount_type+2(3).
    ls_period_to-area      = <ls_hlpseg>-area.
    ls_period_to-period_to = <ls_hlpseg>-period_to.
    INSERT ls_period_to INTO TABLE lt_period_to.
  ENDLOOP.

* clean up virtual areas - i.e. maybe reduce entries of mt_virtarea to lt_virtarea_relevant
  lt_virtarea = mt_virtarea.
  LOOP AT lt_virtarea ASSIGNING <ls_virtarea>.
*   No 'Sonderpostenanpassung Frankreich'
    READ TABLE ms_proc_data-leadobj_instance->mts_arearef ASSIGNING <ls_arearef>
       WITH KEY key_depr_area COMPONENTS depr_area = <ls_virtarea>-virt_area.
    IF <ls_arearef>-depr_area_ref->msx_areadef-area_usage_ind = '2'.
      DELETE lt_virtarea WHERE virt_area = <ls_virtarea>-virt_area.
      CONTINUE.
    ENDIF.
*   real area has to in HLP_SEG
    READ TABLE mts_hlpseg TRANSPORTING NO FIELDS
       WITH KEY area = <ls_virtarea>-real_area.
    IF sy-subrc IS NOT INITIAL.
      DELETE lt_virtarea WHERE virt_area = <ls_virtarea>-virt_area.
      CONTINUE.
    ENDIF.
  ENDLOOP.

* I. prepare alignment:
* note: if a base area is assinged to multiple virt. areas
*       the alignment has to be done cross over all assigned base areas
* I.a. Starting criteria for while loop
  INSERT LINES OF lt_virtarea INTO TABLE lt_virtarea_tmp.
  lt_virtarea_aligned = lt_virtarea_tmp.

  DATA(lb_insert_successful) = abap_true.
  WHILE lb_insert_successful = abap_true.
    lb_insert_successful = abap_false.
    LOOP AT lt_virtarea_aligned INTO DATA(ls_virtarea_aligned).
      LOOP AT lt_virtarea ASSIGNING <ls_virtarea>
        WHERE real_area EQ ls_virtarea_aligned-real_area.

        LOOP AT lt_virtarea INTO DATA(ls_virtarea_tmp)
          WHERE virt_area EQ <ls_virtarea>-virt_area.

          ls_virtarea_tmp-virt_area = ls_virtarea_aligned-virt_area.
          INSERT ls_virtarea_tmp INTO TABLE lt_virtarea_tmp.

          IF sy-subrc = 0. lb_insert_successful = abap_true. ENDIF.
        ENDLOOP.
      ENDLOOP.
    ENDLOOP.
* The alignment table will maybe enlarged
    lt_virtarea_aligned = lt_virtarea_tmp.
  ENDWHILE.

* II. get split information
  LOOP AT lt_virtarea_aligned INTO ls_virtarea_aligned.
    LOOP AT lt_virtarea_aligned ASSIGNING FIELD-SYMBOL(<ls_virtarea_aligned>)
      WHERE virt_area = ls_virtarea_aligned-virt_area.
      LOOP AT me->mts_hlpseg ASSIGNING <ls_hlpseg>
        WHERE area = <ls_virtarea_aligned>-real_area.
        ls_period_to-area      = ls_virtarea_aligned-real_area.
        ls_period_to-period_to = <ls_hlpseg>-period_to.
        INSERT ls_period_to INTO TABLE lt_period_to.
      ENDLOOP.
    ENDLOOP.
  ENDLOOP.

* III. perform interval split
  LOOP AT me->mts_hlpseg ASSIGNING <ls_hlpseg>.
    CHECK <ls_hlpseg>-period_from <> <ls_hlpseg>-period_to.

    LOOP AT lt_period_to INTO ls_period_to
      WHERE area       = <ls_hlpseg>-area
        AND period_to >= <ls_hlpseg>-period_from
        AND period_to <  <ls_hlpseg>-period_to.

      ls_hlpseg           = <ls_hlpseg>.
      ls_hlpseg-period_to = ls_period_to-period_to.

      APPEND ls_hlpseg TO lt_hlpseg.

      <ls_hlpseg>-period_from = ls_period_to-period_to + 1.
    ENDLOOP.
  ENDLOOP.

  CHECK lt_hlpseg[] IS NOT INITIAL.
  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT mts_hlpseg.

ENDMETHOD.


METHOD _HLPSEG_SPLIT_ON_COV_KEY.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_minval>      TYPE ty_s_deprkey-minval.

  DATA lo_keyref                 TYPE ty_s_hlpseg-keyref.

  DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

  DATA ls_minval                 TYPE ty_s_deprkey-minval.
  DATA ls_hlpseg                 TYPE ty_s_hlpseg.

  DATA lv_determination_rule     TYPE num1.
  DATA lv_valid_to_fyr           TYPE numc4.
  DATA lv_valid_to_yr            TYPE numc4.

  DATA lv_tabix_first            TYPE int4.
  DATA lv_tabix_valid            TYPE int4.

  DATA lv_base_date              TYPE dats.
  DATA lv_base_prd               TYPE numc3.
  DATA lv_base_fyr               TYPE numc4.
  DATA lv_base_yr                TYPE numc4.
  DATA lv_message                TYPE string.

* determine index of valid cut of value table entry for each period interval
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
    WHERE NOT keyref->mts_minval[] IS INITIAL
      AND NOT phase                =  0.

* check if more than one level assigned, if not => note index & leave loop
* if yes => determine valid entry for each period interval
    DESCRIBE TABLE  <ls_hlpseg>-keyref->mts_minval LINES sy-tfill.

    IF sy-tfill = 1.
      READ TABLE <ls_hlpseg>-keyref->mts_minval ASSIGNING <ls_minval> INDEX 1.

      IF <ls_minval>-validity_yrs = 999.
        <ls_hlpseg>-cutof_value_indx = 1.
        CONTINUE.
      ENDIF.
    ENDIF.

* get determination rule to be used for determination of expired periods at fiscal year start
* at new area/depr.key/phase determine -> valid to year for table access
*                                      -> expired periods up to year start
    IF lo_keyref <> <ls_hlpseg>-keyref.

      IF <ls_hlpseg>-use_days IS INITIAL.
        lv_determination_rule = 1.
      ELSE.
        lv_determination_rule = 2.
      ENDIF.

* determine base date for validity check of multi levels and already expired periods on fiscal year start
      CALL METHOD get_base_date_and_yr_and_prd
        EXPORTING
          is_hlpseg             = <ls_hlpseg>
          id_determination_rule = lv_determination_rule
          id_base_rule          = <ls_hlpseg>-keyref->ms_settings-minval_rule
        IMPORTING
          ed_base_date          = lv_base_date
          ed_base_prd           = lv_base_prd
          ed_base_yr            = lv_base_yr.


* prepare determination of expired periods up to actual year
      CHECK NOT lv_base_date IS INITIAL.

* determine first valid entry regarding the base year
      CLEAR lv_valid_to_fyr.
      CLEAR lv_valid_to_yr.

      LOOP AT <ls_hlpseg>-keyref->mts_minval ASSIGNING <ls_minval>
        WHERE valid_to_fyear GE <ls_hlpseg>-fyear
          AND valid_to_year  GE lv_base_yr.

        lv_valid_to_fyr = <ls_minval>-valid_to_fyear.
        lv_valid_to_yr  = <ls_minval>-valid_to_year.
        lv_tabix_first  = sy-tabix - 1.

        EXIT.
      ENDLOOP.

      IF sy-subrc <> 0.
        MESSAGE e608(aa) WITH <ls_hlpseg>-depr_key lv_base_fyr INTO lv_message.
        me->create_message_from_syst( ).
      ENDIF.
    ENDIF.

* note index of first valid entry regarding the validity year
    CHECK NOT lv_valid_to_yr IS INITIAL.

    ls_minval = <ls_minval>.

    CALL METHOD get_shifted_period_from_and_to
      EXPORTING
        id_determination_rule = lv_determination_rule
        id_base_date          = lv_base_date
        id_base_prd           = lv_base_prd
        id_base_fyr           = lv_base_yr
        is_hlpseg             = <ls_hlpseg>
      CHANGING
        cd_period_from        = ls_minval-period_from
        cd_period_to          = ls_minval-period_to.

* perform segment split if validity starts within segment
    IF ls_minval-period_from >  <ls_hlpseg>-period_from AND
       ls_minval-period_from <= <ls_hlpseg>-period_to.

      ls_hlpseg                  = <ls_hlpseg>.
      ls_hlpseg-period_to        = ls_minval-period_from - 1.

      APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of first valid entry
      <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.
    ENDIF.

* get start index of appropriate entries
    lv_tabix_valid = lv_tabix_first.

* get index of appropriate entry
    LOOP AT <ls_hlpseg>-keyref->mts_minval ASSIGNING <ls_minval>
      WHERE valid_to_fyear = lv_valid_to_fyr
        AND valid_to_year  = lv_valid_to_yr.

      <ls_hlpseg>-cutof_value_indx = sy-tabix.

      lv_tabix_valid = lv_tabix_valid + 1.

      ls_minval = <ls_minval>.

      CALL METHOD get_shifted_period_from_and_to
        EXPORTING
          id_determination_rule = lv_determination_rule
          id_base_date          = lv_base_date
          id_base_prd           = lv_base_prd
          id_base_fyr           = lv_base_fyr
          is_hlpseg             = <ls_hlpseg>
        CHANGING
          cd_period_from        = ls_minval-period_from
          cd_period_to          = ls_minval-period_to.

      IF ls_minval-period_from IS INITIAL AND
         ls_minval-period_to   IS INITIAL.
        CONTINUE.
      ENDIF.                                                      "

      IF <ls_hlpseg>-period_from > ls_minval-period_to.
        CONTINUE.
      ENDIF.

      IF <ls_hlpseg>-period_to <= ls_minval-period_to.

        <ls_hlpseg>-cutof_value_indx = lv_tabix_valid.

        EXIT.
      ENDIF.

* entry valid for whole segment => note index, leave loop
      IF <ls_hlpseg>-period_from >= ls_minval-period_from AND
         <ls_hlpseg>-period_to   <= ls_minval-period_to.

        <ls_hlpseg>-cutof_value_indx = lv_tabix_valid.

        EXIT.
      ENDIF.

* segment split to be performed as entry is just valid for part of segment
      ls_hlpseg                  = <ls_hlpseg>.

      ls_hlpseg-period_to        = ls_minval-period_to.
      ls_hlpseg-cutof_value_indx = lv_tabix_valid.

      APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of next valid entry
      <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.
    ENDLOOP.
  ENDLOOP.

* take over segments created due to split
  CHECK NOT lt_hlpseg[] IS INITIAL.

  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT   mts_hlpseg.
ENDMETHOD.


METHOD _HLPSEG_SPLIT_ON_DIGITAL.
  FIELD-SYMBOLS <ls_hlpseg>    TYPE ty_S_hlpseg.

  DATA lt_hlpseg               TYPE ty_ts_hlpseg.
  DATA ls_hlpseg               TYPE ty_S_hlpseg.
  DATA lv_covered_prds         TYPE i.
  DATA lv_expired_prds         TYPE i.
  DATA lv_actual_year          TYPE i.
  DATA lv_expired_years        TYPE i.
  DATA lv_periods              TYPE i.
  DATA lb_perform_split        TYPE c.

* check if segement split to be performed on sum of the digits method
  READ TABLE mts_hlpseg TRANSPORTING NO FIELDS
     WITH KEY keyref->ms_settings-percent_key = GC_percent-key_a.

  CHECK sy-subrc = 0.

* to insure that "AT NEW" works correctly just regard affected segments
  lt_hlpseg[] = mts_hlpseg[].

  DELETE lt_hlpseg
   WHERE keyref->ms_settings-percent_key  <> GC_percent-key_a.

  DELETE mts_hlpseg
    WHERE keyref->ms_settings-percent_key  = GC_percent-key_a.

* split segments if there is more than one period covered within
  LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>.
    AT NEW amount_type.
      lv_expired_years = <ls_hlpseg>-exp_life DIV <ls_hlpseg>-periods.
      lv_expired_prds  = <ls_hlpseg>-exp_life.
      lb_perform_split = abap_true.
    ENDAT.

* insure that spilt is just done on first segment in new UL year
    CHECK NOT lb_perform_split IS INITIAL.

    lv_expired_prds = lv_expired_prds + <ls_hlpseg>-exp_life_seg.

* get year of useful life covered by segment
    lv_actual_year  = lv_expired_prds DIV <ls_hlpseg>-periods.

* perfrom split on first segment of new year of useful life
    CHECK lv_actual_year <> lv_expired_years.
    CLEAR lb_perform_split.

* no split required if segment covers just one period
    CHECK  <ls_hlpseg>-period_to <> <ls_hlpseg>-period_from.

* get count of periods which belong already to new year of useful life
    lv_periods = lv_expired_prds MOD <ls_hlpseg>-periods.

* determine periods which belong to previous year of useful life
    lv_periods = <ls_hlpseg>-exp_life_seg - lv_periods.

* determine count of periods covered by segment
    lv_covered_prds = <ls_hlpseg>-period_to
                    - <ls_hlpseg>-period_from + 1.

    ls_hlpseg = <ls_hlpseg>.

* perfrom segment split
    DO lv_covered_prds TIMES.
      CALL METHOD get_expired_life_for_interval
        CHANGING
          cs_hlpseg = ls_hlpseg.

* get expired life regarding actual "to period"
      ls_hlpseg-period_to = ls_hlpseg-period_from + sy-index - 1.

      CALL METHOD get_expired_life_for_interval
        CHANGING
          cs_hlpseg = ls_hlpseg.

* segment split is to be performed if exp. periods exceed remaining
* periods of previous fiscal year
      CHECK ls_hlpseg-exp_life_seg > lv_periods.

* first create segment with new final "to period".
      ls_hlpseg-period_to = ls_hlpseg-period_from + sy-index - 2.

      CALL METHOD get_expired_life_for_interval
        CHANGING
          cs_hlpseg = ls_hlpseg.

      APPEND ls_hlpseg TO mts_hlpseg.

* second create segment with new "from period".
      ls_hlpseg-period_from  = ls_hlpseg-period_to + 1.
      ls_hlpseg-period_to    = <ls_hlpseg>-period_to.

      CALL METHOD get_expired_life_for_interval
        CHANGING
          cs_hlpseg = ls_hlpseg.

      APPEND ls_hlpseg TO mts_hlpseg.

* delete original segment
      DELETE lt_hlpseg.
      EXIT.
    ENDDO.
  ENDLOOP.

* take over segments not affected by split
  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT mts_hlpseg.
ENDMETHOD.


METHOD _HLPSEG_SPLIT_ON_MLM.
  FIELD-SYMBOLS <ls_multilevl>   TYPE ty_s_deprkey-multilevel.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

  DATA lo_keyref                 TYPE ty_s_hlpseg-keyref.

  DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

  DATA ls_multilevl              TYPE ty_s_deprkey-multilevel.
  DATA ls_hlpseg                 TYPE ty_s_hlpseg.

  DATA lv_determination_rule     TYPE num1.
  DATA lv_valid_to_yr            TYPE numc4.

  DATA lv_tabix_first            TYPE int4.
  DATA lv_tabix_valid            TYPE int4.
  DATA lv_message                TYPE string.

  DATA lv_base_date              TYPE dats.
  DATA lv_base_prd               TYPE numc3.
  DATA lv_base_fyr               TYPE numc4.
  DATA lv_base_yr                TYPE numc4.

* get appropriate multi level entry for each period interval, if needed perform interval split
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
    WHERE keyref->ms_settings-multi_level_date EQ space
      AND phase                                <> 0.

* check if more than one level assigned, if not => note index & leave loop
* if yes => determine valid entry for each period interval
    DESCRIBE TABLE  <ls_hlpseg>-keyref->mts_multilevel LINES sy-tfill.

    IF sy-tfill = 1.
      READ TABLE <ls_hlpseg>-keyref->mts_multilevel ASSIGNING <ls_multilevl> INDEX 1.

      IF <ls_multilevl>-validity_yrs = 999.
        <ls_hlpseg>-multi_level_indx = 1.
        CONTINUE.
      ENDIF.
    ENDIF.

* at new area/depr.key/phase determine -> valid to year for table access
*                                      -> expired periods up to year start
    IF lo_keyref <> <ls_hlpseg>-keyref.

* get determination rule to be used for determination of expired periods at fiscal year start
      IF <ls_hlpseg>-keyref->ms_settings-use_fiscal_year IS INITIAL.
        IF <ls_hlpseg>-use_days IS INITIAL.
          lv_determination_rule = 1.
        ELSE.
          lv_determination_rule = 2.
        ENDIF.

* fiscal year based determination required
      ELSE.
        lv_determination_rule = 3.
      ENDIF.

* determine base date, period and fiscal year for validity check of multi levels
      CALL METHOD get_base_date_and_yr_and_prd
        EXPORTING
          is_hlpseg             = <ls_hlpseg>
          id_determination_rule = lv_determination_rule
          id_base_rule          = <ls_hlpseg>-keyref->ms_settings-multi_level_rule
        IMPORTING
          ed_base_date          = lv_base_date
          ed_base_prd           = lv_base_prd
          ed_base_fyr           = lv_base_fyr
          ed_base_yr            = lv_base_yr.

* prepare determination of expired periods up to actual year
      CHECK NOT lv_base_date IS INITIAL.

* determine first valid entry regarding the base year
      CLEAR lv_valid_to_yr.

      READ TABLE <ls_hlpseg>-keyref->mts_multilevel ASSIGNING <ls_multilevl>
            WITH KEY valid_to_date = gc_date-no_date
                     valid_to_yr   = lv_base_yr.

      CASE sy-subrc.
        WHEN 0.
          lv_valid_to_yr = <ls_multilevl>-valid_to_yr.

        WHEN 4.
          READ TABLE <ls_hlpseg>-keyref->mts_multilevel ASSIGNING <ls_multilevl> INDEX sy-tabix.
          lv_valid_to_yr = <ls_multilevl>-valid_to_yr.

        WHEN 8.
          MESSAGE e651(aa) WITH <ls_hlpseg>-depr_key <ls_hlpseg>-phase lv_base_yr INTO lv_message.
          me->create_message_from_syst( ).
      ENDCASE.

* note index of first valid entry regarding the validity year
      lv_tabix_first = sy-tabix - 1.
    ENDIF.

* determine numer of expired periods for from and to period of interval
    CHECK NOT lv_valid_to_yr IS INITIAL.

    ls_multilevl = <ls_multilevl>.

*      IF lv_determination_rule = 2.
    CALL METHOD get_shifted_period_from_and_to
      EXPORTING
        id_determination_rule = lv_determination_rule
        id_base_date          = lv_base_date
        id_base_prd           = lv_base_prd
        id_base_fyr           = lv_base_fyr
        is_hlpseg             = <ls_hlpseg>
      CHANGING
        cd_period_from        = ls_multilevl-period_from
        cd_period_to          = ls_multilevl-period_to.

* perform segment split if validity starts within segment
    IF ls_multilevl-period_from >  <ls_hlpseg>-period_from AND
       ls_multilevl-period_from <= <ls_hlpseg>-period_to.

      ls_hlpseg                  = <ls_hlpseg>.
      ls_hlpseg-period_to        = ls_multilevl-period_from - 1.

      APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of first valid entry
      <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.
    ENDIF.

* get start index of appropriate entries
    lv_tabix_valid = lv_tabix_first.

    "
* determine valid entry for each period interval
* if needed segment split is performed considering the valid to period of the valid entry
    DO.
      LOOP AT <ls_hlpseg>-keyref->mts_multilevel ASSIGNING <ls_multilevl>
         WHERE valid_to_yr = lv_valid_to_yr.

        lv_tabix_valid = lv_tabix_valid + 1.

        ls_multilevl = <ls_multilevl>.

        CALL METHOD get_shifted_period_from_and_to
          EXPORTING
            id_determination_rule = lv_determination_rule
            id_base_date          = lv_base_date
            id_base_prd           = lv_base_prd
            id_base_fyr           = lv_base_fyr
            is_hlpseg             = <ls_hlpseg>
          CHANGING
            cd_period_from        = ls_multilevl-period_from
            cd_period_to          = ls_multilevl-period_to.

        IF  ls_multilevl-period_from IS INITIAL AND
            ls_multilevl-period_to   IS INITIAL.
          CONTINUE.
        ENDIF.

        IF <ls_hlpseg>-period_from > ls_multilevl-period_to.
          CONTINUE.
        ENDIF.

        IF <ls_hlpseg>-period_to <= ls_multilevl-period_to.

          <ls_hlpseg>-multi_level_indx = lv_tabix_valid.

          EXIT.
        ENDIF.

* entry valid for whole segment => note index, leave loop
        IF <ls_hlpseg>-period_from >= ls_multilevl-period_from AND
           <ls_hlpseg>-period_to   <= ls_multilevl-period_to.

          <ls_hlpseg>-multi_level_indx = lv_tabix_valid.

          EXIT.
        ENDIF.

* segment split to be performed as entry is just valid for part of segment
        ls_hlpseg                  = <ls_hlpseg>.

        ls_hlpseg-period_to        = ls_multilevl-period_to.
        ls_hlpseg-multi_level_indx = lv_tabix_valid.

        APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of next valid entry
        <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.

      ENDLOOP.

*<<<<< start of insertion note 1467704 >>>>>*
      IF  <ls_hlpseg>-multi_level_indx > 0.
        EXIT.
      ENDIF.

      IF lv_tabix_valid = lines( <ls_hlpseg>-keyref->mts_multilevel ).
        EXIT.
      ENDIF.

      sy-tabix = lv_tabix_valid + 1.

      READ TABLE <ls_hlpseg>-keyref->mts_multilevel ASSIGNING <ls_multilevl> INDEX sy-tabix.
      lv_valid_to_yr = <ls_multilevl>-valid_to_yr.

    ENDDO.
  ENDLOOP.

* take over new intervalls created due to split
  CHECK NOT lt_hlpseg[] IS INITIAL.

  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT mts_hlpseg.
ENDMETHOD.


METHOD _HLPSEG_SPLIT_ON_MLM_DAT .
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_S_hlpseg.
  FIELD-SYMBOLS <ls_multilevl>   TYPE ty_s_deprkey-multilevel.
  DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

  DATA ls_hlpseg                 TYPE ty_S_hlpseg.

  DATA lv_date_from              TYPE dats.
  DATA lv_date_to                TYPE dats.
  DATA lv_tabix                  TYPE sytabix.

* get appropriate index of multi level if mor than one level within period interval split segment
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
   WHERE NOT keyref->ms_settings-multi_level_date EQ space
     AND NOT period_To                            IS INITIAL
     AND NOT phase                                EQ 0
     AND NOT phase                                GT 3.

* determine covered date interval of period interval
    IF <ls_hlpseg>-use_days IS INITIAL.
      CALL METHOD <ls_hlpseg>-arearef->if_faa_cfg_leadobj~get_first_day_in_period
        EXPORTING
          id_fisc_year = <ls_hlpseg>-fyear
          id_period    = <ls_hlpseg>-period_from
        IMPORTING
          ed_first_day = lv_date_from.

      CALL METHOD <ls_hlpseg>-arearef->if_faa_cfg_leadobj~get_last_day_in_period
        EXPORTING
          id_fisc_year = <ls_hlpseg>-fyear
          id_period    = <ls_hlpseg>-period_to
        IMPORTING
          ed_last_day  = lv_date_to.
    ELSE.
      lv_date_from = <ls_hlpseg>-first_day_in_yr + <ls_hlpseg>-period_from - 1.
      lv_date_to   = <ls_hlpseg>-first_day_in_yr + <ls_hlpseg>-period_to   - 1.
    ENDIF.

* get appropriate level(s)
    LOOP AT <ls_hlpseg>-keyref->mts_multilevel ASSIGNING <ls_multilevl>.
      CHECK <ls_multilevl>-valid_to_date > lv_date_from.
      lv_tabix = sy-tabix.

* level is valid for complete segment as validity date is behind period
      IF lv_date_to <= <ls_multilevl>-valid_to_date.

        <ls_hlpseg>-multi_level_indx = lv_tabix.
        EXIT.
      ENDIF.

* level is valid only for part of actual segment => perform split
      IF lv_date_to > <ls_multilevl>-valid_to_date.
        ls_hlpseg = <ls_hlpseg>.

        IF <ls_hlpseg>-use_days IS INITIAL.
          CALL METHOD <ls_hlpseg>-arearef->get_period_and_year
            EXPORTING
              id_date   = <ls_multilevl>-valid_to_date
            IMPORTING
              ed_period = ls_hlpseg-period_to.

        ELSE.
          ls_hlpseg-period_to = <ls_multilevl>-valid_to_date - ls_hlpseg-first_day_in_yr + 1.
        ENDIF.

* level is valid for complete segment accord. to period determination
        IF ls_hlpseg-period_to = <ls_hlpseg>-period_to.
          <ls_hlpseg>-multi_level_indx = lv_tabix.
          EXIT.
        ENDIF.

* perform segment split
        ls_hlpseg-multi_level_indx = lv_tabix.

        APPEND ls_hlpseg TO lt_hlpseg.

* adjust from period of actual segment due to split
        <ls_hlpseg>-period_from = ls_hlpseg-period_to + 1.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

* take over segments created due to split
  CHECK NOT lt_hlpseg[] IS INITIAL.

  APPEND LINES OF lt_hlpseg TO mts_hlpseg.

  SORT mts_hlpseg.
ENDMETHOD.


METHOD _HLPSEG_SPLIT_ON_TIMESEG.
  CHECK NOT mt_timeseg[] IS INITIAL.

  FIELD-SYMBOLS <ls_hlpseg>    TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_timeseg>   TYPE ty_s_timeseg.

  DATA ls_hlpseg               TYPE ty_s_hlpseg.

* perform split if there are TIMESEGs w. PERIOD_TO within ex. intervals
  LOOP AT mt_timeseg[] ASSIGNING <ls_timeseg>.
    CHECK <ls_timeseg>-curr_type = space.

* check if PERIOD_TO lies within an interval covered in HLPSEG
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
        WHERE area         = <ls_timeseg>-area
          AND amount_type  = <ls_timeseg>-amount_type
          AND period_to    > <ls_timeseg>-period_to
          AND period_from <= <ls_timeseg>-period_to.

* perform segment split
      ls_hlpseg           = <ls_hlpseg>.
      ls_hlpseg-period_to = <ls_timeseg>-period_to.

      APPEND ls_hlpseg TO mts_hlpseg.

* adjust from period of actual segment
      <ls_hlpseg>-period_from  = <ls_timeseg>-period_to + 1.

      EXIT.
    ENDLOOP.
  ENDLOOP.

  SORT mts_hlpseg.

ENDMETHOD.


  METHOD _parameter_call_badi.
    CHECK go_badi_customer IS BOUND
       OR go_badi_country  IS BOUND.

    FIELD-SYMBOLS <ls_parameter>   TYPE ty_s_parameter.
    FIELD-SYMBOLS <ls_area>        TYPE ty_s_area.

    DATA lo_segment_handle         TYPE faa_dc_segment_handle.
    DATA lt_parameter              TYPE ty_t_parameter.
    DATA ls_parameter              TYPE ty_s_parameter.
    DATA ls_hlpseg       TYPE faa_dc_s_hlpseg.

* CHECK if PROCESSING required AT all
    CHECK mt_parameter IS NOT INITIAL.

    READ TABLE mts_hlpseg INTO ls_hlpseg INDEX 1.

    me->prepare_badi_call( CHANGING co_dc_segment_handle = lo_segment_handle ).

    READ TABLE mts_area INDEX 1 ASSIGNING <ls_area>.

* call country specific BADI for change of PARAMETER data
    IF go_badi_country IS BOUND.
      CALL METHOD go_badi_country->set_parameter
        EXPORTING
          flt_val        = <ls_area>-arearef->if_faa_cfg_leadobj~msx_settings-country
          io_handle      = lo_segment_handle
          it_parameter   = mt_parameter
          its_hlpseg     = mts_hlpseg
        CHANGING
          ct_parameter   = lt_parameter
        EXCEPTIONS
          error_occurred = 4.

      IF sy-subrc <> 0.                                     "2244188
        CALL METHOD create_message_from_syst.
      ENDIF.

* take over changes
      LOOP AT lt_parameter INTO ls_parameter.
        READ TABLE mt_parameter ASSIGNING <ls_parameter>
              WITH KEY fyear       = ls_parameter-fyear
                       area        = ls_parameter-area
                       amount_type = ls_parameter-amount_type
                       period_to   = ls_parameter-period_to.

        CHECK sy-subrc = 0.
        <ls_parameter>-baseval_factor   = ls_parameter-baseval_factor.
        <ls_parameter>-baseval_key      = ls_parameter-baseval_key.
        <ls_parameter>-baseval_fact_add = ls_parameter-baseval_fact_add.
        <ls_parameter>-baseval_stated   = ls_parameter-baseval_stated.
        <ls_parameter>-percent_stated   = ls_parameter-percent_stated.
        <ls_parameter>-percent_factor   = ls_parameter-percent_factor.
        <ls_parameter>-percent_key      = ls_parameter-percent_key.
        <ls_parameter>-amount_factor    = ls_parameter-amount_factor.
        <ls_parameter>-minval_percent   = ls_parameter-minval_percent.
        <ls_parameter>-minval_stated    = ls_parameter-minval_stated.
        <ls_parameter>-minval_tolerance = ls_parameter-minval_tolerance.
        <ls_parameter>-minval_rndmethod = ls_parameter-minval_rndmethod.
        <ls_parameter>-minval_rndplace  = ls_parameter-minval_rndplace.
        <ls_parameter>-minval_rnddecim  = ls_parameter-minval_rnddecim.
        <ls_parameter>-minval_key       = ls_parameter-minval_key.
        <ls_parameter>-minval_perc_add  = ls_parameter-minval_perc_add.
        <ls_parameter>-minval_stated_add = ls_parameter-minval_stated_add.
        <ls_parameter>-rounding_off     = ls_parameter-rounding_off.
        <ls_parameter>-check_amount     = ls_parameter-check_amount.
      ENDLOOP.
    ENDIF.

* call customer specific BADI for change of PARAMETER data
    IF go_badi_customer  IS BOUND.
      CALL METHOD go_badi_customer->set_parameter
        EXPORTING
          io_handle      = lo_segment_handle
          it_parameter   = mt_parameter
          its_hlpseg     = mts_hlpseg
        CHANGING
          ct_parameter   = lt_parameter
        EXCEPTIONS
          error_occurred = 4.

      IF sy-subrc <> 0.                                     "2244188
        CALL METHOD create_message_from_syst.
      ENDIF.

* take over changes
      LOOP AT lt_parameter INTO ls_parameter.
        READ TABLE mt_parameter ASSIGNING <ls_parameter>
              WITH KEY fyear       = ls_parameter-fyear
                       area        = ls_parameter-area
                       amount_type = ls_parameter-amount_type
                       period_to   = ls_parameter-period_to.

        CHECK sy-subrc = 0.
        <ls_parameter>-baseval_factor   = ls_parameter-baseval_factor.
        <ls_parameter>-baseval_key      = ls_parameter-baseval_key.
        <ls_parameter>-baseval_fact_add = ls_parameter-baseval_fact_add.
        <ls_parameter>-baseval_stated   = ls_parameter-baseval_stated.
        <ls_parameter>-percent_stated   = ls_parameter-percent_stated.
        <ls_parameter>-percent_factor   = ls_parameter-percent_factor.
        <ls_parameter>-percent_key      = ls_parameter-percent_key.
        <ls_parameter>-amount_factor    = ls_parameter-amount_factor.
        <ls_parameter>-minval_percent   = ls_parameter-minval_percent.
        <ls_parameter>-minval_stated    = ls_parameter-minval_stated.
        <ls_parameter>-minval_tolerance = ls_parameter-minval_tolerance.
        <ls_parameter>-minval_rndmethod = ls_parameter-minval_rndmethod.
        <ls_parameter>-minval_rndplace  = ls_parameter-minval_rndplace.
        <ls_parameter>-minval_rnddecim  = ls_parameter-minval_rnddecim.
        <ls_parameter>-minval_key       = ls_parameter-minval_key.
        <ls_parameter>-minval_perc_add  = ls_parameter-minval_perc_add.
        <ls_parameter>-minval_stated_add = ls_parameter-minval_stated_add.
        <ls_parameter>-rounding_off     = ls_parameter-rounding_off.
        <ls_parameter>-check_amount     = ls_parameter-check_amount.
      ENDLOOP.

* call BaDI implementation to get leasing parameters "2368005
      CLEAR lt_parameter.
      CALL METHOD go_badi_customer->provide_parameter_4_lease_calc
        EXPORTING
          io_handle      = me
          it_parameter   = mt_parameter
          its_hlpseg     = mts_hlpseg
        CHANGING
          ct_parameter   = lt_parameter
        EXCEPTIONS
          error_occurred = 4.

      IF sy-subrc <> 0.
        CALL METHOD create_message_from_syst.
      ENDIF.

* take over changes
      LOOP AT lt_parameter INTO ls_parameter.
        READ TABLE mt_parameter ASSIGNING <ls_parameter>
              WITH KEY fyear       = ls_parameter-fyear
                       area        = ls_parameter-area
                       amount_type = ls_parameter-amount_type
                       period_to   = ls_parameter-period_to.

        CHECK sy-subrc = 0.
        <ls_parameter>-leas_paymt_cycle = ls_parameter-leas_paymt_cycle.
        <ls_parameter>-leas_no_payments = ls_parameter-leas_no_payments.
        <ls_parameter>-leas_intrst_rate = ls_parameter-leas_intrst_rate.
        <ls_parameter>-leas_per_payment = ls_parameter-leas_per_payment.
        <ls_parameter>-leas_adv_payment = ls_parameter-leas_adv_payment.
      ENDLOOP.                                              "2368005
    ENDIF.
  ENDMETHOD.


METHOD _PARAMETER_CREATE.
  FIELD-SYMBOLS <ls_rounding>    TYPE ty_s_deprarea-rounding.
  FIELD-SYMBOLS <ls_multilevl>   TYPE ty_s_deprkey-multilevel.
  FIELD-SYMBOLS <ls_maxamount>   TYPE ty_s_deprkey-maxamount.
  FIELD-SYMBOLS <ls_minval>      TYPE ty_s_deprkey-minval.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_S_hlpseg.
  FIELD-SYMBOLS <lo_keyref>      TYPE ty_S_hlpseg-keyref.

  DATA ls_param                  TYPE ty_S_parameter.

  CHECK mt_parameter[] IS INITIAL.

* create table PARAMETER from HLPSEG
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.

* fill key fields of PARAMETER
    CLEAR ls_param.
    ls_param-fyear       = <ls_hlpseg>-fyear.
    ls_param-area        = <ls_hlpseg>-area.
    ls_param-amount_type = <ls_hlpseg>-amount_type.
    ls_param-period_to   = <ls_hlpseg>-period_to.

* set default value of calculation factors to 1.0
    ls_param-baseval_factor = 1.
    ls_param-percent_factor = 1.

    ls_param-use_days        = <ls_hlpseg>-use_days.
    ls_param-baseval_key     = <ls_hlpseg>-baseval_key.
    ls_param-base_add_key    = <ls_hlpseg>-base_add_key.
    ls_param-percent_key     = <ls_hlpseg>-percent_key.
    ls_param-percent_stated  = <ls_hlpseg>-percent_stated.
* set lease data
    ls_param-leas_paymt_cycle = <ls_hlpseg>-leas_paymt_cycle.
    ls_param-leas_no_payments = <ls_hlpseg>-leas_no_payments.
    ls_param-leas_intrst_rate = <ls_hlpseg>-leas_intrst_rate.
    ls_param-leas_per_payment = <ls_hlpseg>-leas_per_payment.
    ls_param-leas_adv_payment = <ls_hlpseg>-leas_adv_payment.

* on amount types A & C & I just take over the parameters for calc. from HLPSEG
    CASE <ls_hlpseg>-amount_type.
      WHEN GC_amount_type-infl
        OR GC_amount_type-rage
        OR GC_amount_type-repl.

        APPEND ls_param TO mt_parameter.
        CONTINUE.

* on amount types N & S & Z no calculation if there was a customizing error
      WHEN GC_amount_type-ordn
        OR GC_amount_type-spec
        OR GC_amount_type-intr.

        IF <ls_hlpseg>-keyref IS NOT BOUND.
          APPEND ls_param TO mt_parameter.
          CONTINUE.
        ENDIF.

      WHEN OTHERS.
        APPEND ls_param TO mt_parameter.
        CONTINUE.
    ENDCASE.

* create initial segment if group asset is assigned for area
    IF NOT <ls_hlpseg>-grp_asset_assgnd IS INITIAL.
      APPEND ls_param TO mt_parameter.
      CONTINUE.
    ENDIF.

* segment before start period
    IF <ls_hlpseg>-phase = 0.
      APPEND ls_param TO mt_parameter.
      CONTINUE.
    ENDIF.

* no multi level entry assigne => leave to avoid dump
    IF <ls_hlpseg>-multi_level_indx = 0.
      APPEND ls_param TO mt_parameter.
      CONTINUE.
    ENDIF.

* get calculation parameters from configuration
    CHECK  <ls_hlpseg>-keyref IS BOUND.
    ASSIGN <ls_hlpseg>-keyref TO <lo_keyref>.

* check if depreciation to be calculated after end of useful life
    IF <ls_hlpseg>-is_behind_ul = abap_true.
      IF <lo_keyref>->ms_settings-calc_after_end IS INITIAL.

        APPEND ls_param TO mt_parameter.
        CONTINUE.
      ENDIF.
    ENDIF.

* get appropriate multi level percentage
    READ TABLE <lo_keyref>->mts_multilevel
     ASSIGNING <ls_multilevl>
         INDEX <ls_hlpseg>-multi_level_indx.

    ls_param-baseval_key = <ls_multilevl>-basevalue_key.

* get paramter according to dedicated base value keys
    CASE ls_param-baseval_key.

* get max base value (luxury cars)
      WHEN GC_basevalue-key_05.
        CALL METHOD <lo_keyref>->get_max_basevalue
          EXPORTING
            id_assetclass  = <ls_hlpseg>-assetclass
            id_valid_to    = <ls_hlpseg>-cap_date
          RECEIVING
            rd_baseval_max = ls_param-baseval_max.

* asset individual basevalue reduction percentage is delivered by BADI
      WHEN GC_basevalue-key_28.

* Real Estate Leasing
      WHEN faacc_basevalue_key-29. "note_2297363
        DATA: lo_assetdata TYPE faa_dc_assetdata_handle.
        lo_assetdata ?= me->mo_start->ms_asset_data-object_instance.
        CALL METHOD cl_faa_dc_segments_services=>get_leasing_depreciation
          EXPORTING
            io_assetdata      = lo_assetdata
            is_hlpseg         = <ls_hlpseg>
          CHANGING
            cd_baseval_stated = ls_param-baseval_stated.
            .

* special treatment of acq. from transfer is done in method _TIMESEG_CREATE
      WHEN GC_basevalue-key_40.
    ENDCASE.

    ls_param-baseval_factor =  ls_param-baseval_factor
                            - <ls_multilevl>-baseval_reductn / 100.

    IF ls_param-baseval_factor < 0.
      ls_param-baseval_factor = 0.
    ENDIF.

* get depreciation percentage if stated
    ls_param-percent_key = <lo_keyref>->ms_settings-percent_key.

    CASE ls_param-percent_key.
      WHEN GC_percent-key_p.
        ls_param-percent_stated = <ls_multilevl>-percentage_rate
                                / 100.
      WHEN GC_percent-key_g.
        ls_param-percent_stated = <ls_multilevl>-percentage_rate
                                / 100.
      WHEN GC_percent-key_d.
        IF NOT <ls_multilevl>-use_remain_life IS INITIAL.
          ls_param-percent_key = GC_percent-key_r.
        ENDIF.

* get percentage from units of production
      WHEN GC_percent-key_s
        OR GC_percent-key_t.
        CALL METHOD get_prcntg_on_units_of_prod
          EXPORTING
            is_parameter   = ls_param
            is_hlpseg      = <ls_hlpseg>
            id_fisc_year   = <ls_hlpseg>-fyear
            id_period_from = <ls_hlpseg>-period_from
            id_period_to   = <ls_hlpseg>-period_to
          IMPORTING
            ed_percentage  = ls_param-percent_stated.

* Do not round in case of complete depreciation, otherwise net book value will remain on asset
      WHEN GC_percent-key_v.
        IF ls_param-baseval_factor EQ 1.
          ls_param-rounding_off = abap_true.
        ENDIF.
    ENDCASE.

* Provide stated percentage from multilevel method for BAdI implementations
    IF ( ls_param-percent_key BETWEEN GC_percent-key_x AND
                                      GC_percent-key_z    ) OR
       ( ls_param-percent_key BETWEEN GC_percent-key_1 AND
                                      GC_percent-key_9    ).
      ls_param-percent_stated = <ls_multilevl>-percentage_rate
                              / 100.
    ENDIF.

* get maximum and minimum percentage
    ls_param-percent_max = <lo_keyref>->ms_settings-percent_max
                         / 100.
    ls_param-percent_min = <lo_keyref>->ms_settings-percent_min
                         / 100.

* get multiplication factor if any
    IF <lo_keyref>->ms_settings-percent_factor > 0.
      ls_param-percent_factor = <lo_keyref>->ms_settings-percent_factor.
    ENDIF.

    IF ls_param-percent_factor < 0.
      ls_param-percent_factor = 0.
    ENDIF.

* get decimal places for rounding of percentage
    ls_param-percent_round = <lo_keyref>->ms_settings-percent_round.

    ls_param-amount_factor = 1.

* get factor to be applied on calculated depr. considering the usage
    CASE <ls_hlpseg>-usage_impact_ind.

* usage not to be regarded at all, if any
      WHEN 0.

* no calculation of depreciation as time interval is shut down
      WHEN 1.
        ls_param-amount_factor = 0.

* is already covered within AMOUNT_FACTOR
      WHEN 3
        OR 7 .
        ls_param-amount_factor = <ls_hlpseg>-amount_factor.
    ENDCASE.

* correct negative amount factor as this is not possible
    IF ls_param-amount_factor < 0.
      ls_param-amount_factor = 0.
    ENDIF.

* get maximum amount of depr. for year or in total
    LOOP AT <ls_hlpseg>-keyref->mts_maxamount ASSIGNING <ls_maxamount>
      WHERE valid_to_date >= <ls_hlpseg>-last_day_in_yr
*       AND currency       = <ls_hlpseg>-currency.                      "< del 1048448
        AND currency       = <ls_hlpseg>-arearef->msx_areadef-currency. "< ins 1048448
      ls_param-amount_max      = <ls_maxamount>-amount_max.
      ls_param-use_year_amount = <lo_keyref>->ms_settings-use_year_amount.
      EXIT.
    ENDLOOP.

* get indicator if ordinary depr./interest to be calculated at all
    CASE ls_param-amount_type.
      WHEN GC_amount_type-ordn.
        ls_param-skip_amount = <lo_keyref>->ms_settings-no_depr_o.

      WHEN GC_amount_type-intr.
        ls_param-skip_amount = <lo_keyref>->ms_settings-no_interest.
    ENDCASE.

* takeover scrap value / scrap value percentage
    ls_param-minval_percent  = <ls_hlpseg>-scrapvalue_prctg / 100.

    IF ls_param-minval_percent IS INITIAL.
      ls_param-minval_stated   = <ls_hlpseg>-scrapvalue.
    ENDIF.

* get maximum amout of scrap value and memo value
    IF <ls_hlpseg>-ignore_memval IS INITIAL.
      ls_param-minval_memo  = <ls_hlpseg>-arearef->msx_areadef-memo_value.
    ENDIF.

* get cut off value if any assigned
    IF ls_param-minval_percent = 0 AND
       ls_param-minval_stated  = 0.
      IF NOT <ls_hlpseg>-cutof_value_indx IS INITIAL.
        READ TABLE <lo_keyref>->mts_minval ASSIGNING <ls_minval>
             INDEX <ls_hlpseg>-cutof_value_indx.

        ls_param-minval_percent = <ls_minval>-min_value_percnt / 100.
      ENDIF.
    ENDIF.

* get add. parameters for minimum value consideration
    IF ls_param-minval_percent <> 0 OR
       ls_param-minval_stated  <> 0.

      IF <ls_hlpseg>-amount_type = GC_amount_type-ordn OR
         <ls_hlpseg>-amount_type = GC_amount_type-spec.

* set rounding parameters for calculated minimum value
        READ TABLE <ls_hlpseg>-arearef->mt_rounding ASSIGNING <ls_rounding>
              WITH KEY amount_type = <ls_hlpseg>-amount_type.

        CASE <ls_rounding>-base_value.

* always round down if net value is to be rounded
          WHEN 'V'.
            ls_param-minval_rndmethod = '2'.
            ls_param-minval_rnddecim  = <ls_rounding>-round_by.
            ls_param-minval_rndplace  =  2.

* perform rounding in the same way as on depreciation
          WHEN 'A'.

* normal case: no rounding of currency decimals
            ls_param-minval_rndmethod = '0'.
            ls_param-minval_rnddecim  =  0.
            ls_param-minval_rndplace  =  2.

* special case: currency without decimals (Japan) and
* depreciation is to be rounded down -> rounding min.value up
            IF <ls_rounding>-rounding_method = '2' AND
               <ls_rounding>-round_by        = '0'.

              ls_param-minval_rndmethod = '1'.
            ENDIF.
        ENDCASE.

* get indicator, if minimum value is to be subtracted from base value
        CASE <ls_hlpseg>-keyref->ms_settings-scrapvalue_rule.
          WHEN GC_scrapvalue-rule_0.
            ls_param-subtract_minval = <ls_hlpseg>-keyref->ms_settings-use_min_value.

          WHEN GC_scrapvalue-rule_1.
            ls_param-subtract_minval = abap_true.

          WHEN GC_scrapvalue-rule_2.
            ls_param-subtract_minval = space.

          WHEN GC_scrapvalue-rule_3.
            ls_param-minval_percent  = 0.
            ls_param-minval_stated   = 0.
            ls_param-subtract_minval = space.
        ENDCASE.
      ENDIF.
    ENDIF.

* set indicator if net value can be negative
    IF <ls_hlpseg>-arearef->msx_areadef-sign_apc     <> GC_area_value_sign-none     OR
     ( <ls_hlpseg>-arearef->msx_areadef-sign_invest  <> GC_area_value_sign-negative AND
       <ls_hlpseg>-arearef->msx_areadef-sign_reserve <> GC_area_value_sign-negative  ). "

      IF <ls_hlpseg>-keyref->ms_settings-calc_below_zero <> space                          AND
         <ls_hlpseg>-arearef->msx_areadef-sign_nbv       <> GC_area_value_sign-positive AND
         <ls_hlpseg>-arearef->msx_areadef-sign_nbv       <> GC_area_value_sign-none.

        ls_param-no_minval = abap_true.
      ENDIF.

* ignore area sign rule for nbv on interest calculation
      IF <ls_hlpseg>-keyref->ms_settings-calc_below_zero <> space                          AND
         <ls_hlpseg>-amount_type                         EQ GC_amount_type-intr.

        ls_param-no_minval = abap_true.
      ENDIF.
    ENDIF.

    APPEND ls_param TO mt_parameter.
  ENDLOOP.
ENDMETHOD.


METHOD _PERIOD_CREATE.
  FIELD-SYMBOLS <ls_weighting>  TYPE ty_s_deprkey-period_weighting.
  FIELD-SYMBOLS <ls_reduction>  TYPE ty_s_deprarea-short_fyear.
  FIELD-SYMBOLS <ls_hlpseg>     TYPE ty_S_hlpseg.

  DATA lt_weighting             TYPE TABLE OF ty_s_deprkey-period_weighting.
  DATA ls_period                TYPE ty_S_period.

  DATA lv_periods               TYPE numc4.
  DATA lv_period                TYPE ty_S_period-useful_life.
  DATA lv_fyear                 TYPE numc4.

* check if processing required at all
  CHECK NOT mt_parameter[] IS INITIAL.

* get definitions for companycode and depr. areas
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
    CLEAR ls_period.

    AT NEW area.
      CLEAR lv_fyear.

* get settings related with shortened fiscal year
      IF NOT <ls_hlpseg>-is_shortfiscyear IS INITIAL.
        READ TABLE <ls_hlpseg>-arearef->mts_short_fy_reduction ASSIGNING <ls_reduction>
              WITH KEY short_fisc_year = <ls_hlpseg>-fyear.
      ENDIF.
    ENDAT.

* fill key fields of PERIOD
    ls_period-fyear          = <ls_hlpseg>-fyear.
    ls_period-area           = <ls_hlpseg>-area.
    ls_period-amount_type    = <ls_hlpseg>-amount_type.
    ls_period-period_to      = <ls_hlpseg>-period_to.

    ls_period-useful_life    = <ls_hlpseg>-useful_life.

    ls_period-changeover_yr  = <ls_hlpseg>-changeover_yr.
    ls_period-changeover_prd = <ls_hlpseg>-changeover_prd.

    ls_period-exp_life_seg   = <ls_hlpseg>-exp_life_seg.
    ls_period-exp_life_new   = <ls_hlpseg>-exp_life_new.
    ls_period-exp_life       = <ls_hlpseg>-exp_life.

* determine periods within segment and year to be used for value calculation
    ls_period-peryear             = <ls_hlpseg>-periods.
    ls_period-peryear_weighted    = <ls_hlpseg>-periods.
    ls_period-perseg_weighted     = <ls_hlpseg>-period_to
                                  - <ls_hlpseg>-period_from + 1.

    CALL METHOD <ls_hlpseg>-arearef->if_faa_cfg_leadobj~is_active
      EXPORTING
        id_setting = gc_setting_halfmonth
      RECEIVING
        rb_active  = ls_period-use_halfperiods.

* skip to next segment for other amount types than interest and depreciation
    IF <ls_hlpseg>-keyref IS NOT BOUND.
      APPEND ls_period TO mt_period.
      CONTINUE.
    ENDIF.

    IF <ls_hlpseg>-amount_type <> GC_amount_type-ordn AND
       <ls_hlpseg>-amount_type <> GC_amount_type-spec AND
       <ls_hlpseg>-amount_type <> GC_amount_type-intr.

      APPEND ls_period TO mt_period.
      CONTINUE.
    ENDIF.

*   If end of useful life within the current fiscal year, and curb function
*   (calculate from effective life) is checked, then the period useful life
*   will be calculated from the formula "expired useful life + 1 fiscal year".
*   Increase usefule life for appropriate calculation in last year of useful
*   life or after end of life
    lv_period = <ls_hlpseg>-exp_life + <ls_hlpseg>-periods.
    IF NOT <ls_hlpseg>-keyref->ms_settings-calc_real_life IS INITIAL AND
       NOT <ls_hlpseg>-keyref->ms_settings-calc_after_end IS INITIAL AND
       <ls_hlpseg>-useful_life <= lv_period.
*      ls_period-useful_life =   <ls_hlpseg>-periods
*                            * ( <ls_hlpseg>-fyear
*                            -   <ls_hlpseg>-start_yr + 1 ).
      ls_period-useful_life =   lv_period.
    ENDIF.
    CLEAR lv_period.

* adjust useful life according French rule -> if calc. starts within the fiscal year
*                                          -> if shortened fiscal years in the past
    IF NOT <ls_hlpseg>-keyref->ms_settings-uselife_reduce IS INITIAL.
      CALL METHOD adjust_useful_life
        EXPORTING
          is_hlpseg = <ls_hlpseg>
        CHANGING
          cs_period = ls_period.
    ENDIF.

    IF ls_period-peryear_weighted > ls_period-useful_life.
      ls_period-peryear_weighted  = ls_period-useful_life.
    ENDIF.

* determine wether shortened fiscal year has influence on calculation
    IF NOT <ls_hlpseg>-is_shortfiscyear IS INITIAL.
      ls_period-short_yr_prds = <ls_hlpseg>-periods_short_fy.

      IF <ls_reduction> IS ASSIGNED.
        CASE <ls_hlpseg>-amount_type.
          WHEN GC_amount_type-ordn.
            IF <ls_reduction>-reduce_depr_o IS INITIAL.
              ls_period-ignore_short_yr = abap_true.
            ENDIF.

          WHEN GC_amount_type-spec.
            IF <ls_reduction>-reduce_depr_s IS INITIAL.
              ls_period-ignore_short_yr = abap_true.
            ENDIF.

          WHEN GC_amount_type-intr.
            IF <ls_reduction>-reduce_interest IS INITIAL.
              ls_period-ignore_short_yr = abap_true.
            ENDIF.

          WHEN GC_amount_type-rage
            OR GC_amount_type-repl.

            IF <ls_reduction>-reduce_revl IS INITIAL.
              ls_period-ignore_short_yr = abap_true.
            ENDIF.
        ENDCASE.

* in case reduction was not specified => no reduction
      ELSE.
        ls_period-ignore_short_yr = abap_true.
      ENDIF.

* setting of depreciation key wins
      IF NOT <ls_hlpseg>-keyref->ms_settings-no_reduction IS INITIAL.
        ls_period-ignore_short_yr = <ls_hlpseg>-keyref->ms_settings-no_reduction.
      ENDIF.
    ENDIF.

    IF ls_period-ignore_short_yr = abap_true.
      lv_periods = <ls_hlpseg>-periods_short_fy.
    ELSE.
      lv_periods = <ls_hlpseg>-periods.
    ENDIF.

* consider period weighting for each period coverd within the interval
    IF NOT <ls_hlpseg>-arearef->msx_areadef-use_weighting IS INITIAL AND
       <ls_hlpseg>-use_days IS INITIAL.
      CLEAR ls_period-peryear_weighted.
      CLEAR ls_period-perseg_weighted.

* get valid due year if period weighting to be considered
      IF lv_fyear IS INITIAL.
        READ TABLE <ls_hlpseg>-keyref->mts_period_weighting
         ASSIGNING <ls_weighting>
              WITH KEY valid_to_fyear = <ls_hlpseg>-fyear
            BINARY SEARCH.

        CASE sy-subrc.
          WHEN 0.
            lv_fyear = <ls_weighting>-valid_to_fyear.

          WHEN 4.
            READ TABLE <ls_hlpseg>-keyref->mts_period_weighting
             ASSIGNING <ls_weighting> INDEX sy-tabix.

            lv_fyear = <ls_weighting>-valid_to_fyear.

          WHEN 8.
            lv_fyear = 9999.
        ENDCASE.
      ENDIF.

* get number of periods to be regarded within actual fiscal year
      LOOP AT  <ls_hlpseg>-keyref->mts_period_weighting ASSIGNING <ls_weighting>
        WHERE valid_to_fyear = lv_fyear.

        IF <ls_weighting>-valid_to_period <= lv_periods.
          ls_period-peryear_weighted = ls_period-peryear_weighted
                                     + <ls_weighting>-factor.
        ENDIF.

        IF <ls_weighting>-valid_to_period >= <ls_hlpseg>-period_from AND
                    <ls_weighting>-valid_to_period <= <ls_hlpseg>-period_to.

          ls_period-perseg_weighted  = ls_period-perseg_weighted
                                     + <ls_weighting>-factor.
        ENDIF.
      ENDLOOP.

* provide sum of weeks covered within useful life starting with start period
* if usefule life is less than a year
      IF <ls_hlpseg>-useful_life < <ls_hlpseg>-periods AND
         <ls_hlpseg>-phase       > 0.

        lv_fyear = <ls_hlpseg>-start_yr + 1.

        IF <ls_hlpseg>-fyear = <ls_hlpseg>-start_yr OR
           <ls_hlpseg>-fyear =  lv_fyear .

          lt_weighting[] = <ls_hlpseg>-keyref->mts_period_weighting.

          DELETE lt_weighting
           WHERE valid_to_fyear < <ls_hlpseg>-start_yr.

* delete periods before start period if there are entries for start year
          DELETE lt_weighting
           WHERE valid_to_period < <ls_hlpseg>-start_prd
             AND valid_to_fyear  = <ls_hlpseg>-start_yr.

* delete periods that have not to be considered on summation if no entries
* exist explicitly for start year
          READ TABLE lt_weighting ASSIGNING <ls_weighting> INDEX 1.
          lv_fyear = <ls_weighting>-valid_to_fyear.

          lv_periods = <ls_hlpseg>-periods - <ls_hlpseg>-useful_life.

          IF <ls_hlpseg>-start_prd > lv_periods AND
             <ls_hlpseg>-start_yr  < lv_fyear.

            lv_period = <ls_hlpseg>-start_prd - 1.

            DO lv_periods TIMES.
              DELETE lt_weighting
               WHERE valid_to_period = lv_period
                 AND valid_to_fyear  = lv_fyear.

              lv_period = lv_period - 1.
            ENDDO.
          ENDIF.

* get sum of weeks covered within useful life
          CLEAR ls_period-peryear_weighted.

          LOOP AT lt_weighting ASSIGNING <ls_weighting> FROM 1 TO <ls_hlpseg>-useful_life.

            ls_period-peryear_weighted = ls_period-peryear_weighted
                                       + <ls_weighting>-factor.
          ENDLOOP.
        ENDIF.
      ENDIF.
    ENDIF.

    APPEND ls_period TO mt_period.
  ENDLOOP.
ENDMETHOD.


  METHOD _planvalue_create.
*=======================================================================
* Perform calculation of values to be posted by depreciation run
* This is done by calculating period by period backwards and
* determine the delta between the prior period and the actual period
*=======================================================================
    CHECK mts_calcamount IS NOT INITIAL.

* DEFINITIONS
    FIELD-SYMBOLS <ls_hlpseg>       TYPE ty_s_hlpseg.

    DATA lo_processing_handle       LIKE me.
    DATA lo_cfg_leadobj_erp         TYPE REF TO if_faa_cfg_leadobj_erp.

    DATA lt_calcamount_prev         TYPE ty_ts_calcamount.

    DATA ls_calcamount_prev         TYPE ty_s_calcamount.
    DATA ls_calcamount              TYPE ty_s_calcamount.
    DATA ls_planvalue               TYPE ty_s_planvalue.
    DATA ls_hlpseg                  TYPE ty_s_hlpseg.

    DATA lv_last_day_of_fiscper     TYPE dats.
    DATA lv_period_from             TYPE ty_s_hlpseg-period_to.
    DATA lv_period_to               TYPE ty_s_hlpseg-period_to.
    DATA lv_periods                 TYPE ty_s_hlpseg-period_to.
    DATA lv_fiscper                 TYPE poper.

* BODY
* get date of first acquisition for creation of due value adjustments
    CHECK  ms_asset_data-initial_acq <= ms_proc_data-last_day_in_fyr.

    lo_cfg_leadobj_erp ?= ms_proc_data-leadobj_instance.
    CREATE OBJECT lo_processing_handle.

* take over posting date independant data
    lo_processing_handle->mo_start          = mo_start.
    lo_processing_handle->ms_asset_data     = ms_asset_data.
    lo_processing_handle->ms_proc_data      = ms_proc_data.
    lo_processing_handle->mts_area          = mts_area.
    lo_processing_handle->mt_yearseg        = mt_yearseg.
    lo_processing_handle->mt_rounding       = mt_rounding.
    lo_processing_handle->mt_areasign       = mt_areasign.
    lo_processing_handle->mt_virtarea       = mt_virtarea.
    lo_processing_handle->mt_transaction    = mt_transaction.

* create posting date dependant attribute tables for consistency check
    lo_processing_handle->ms_proc_data-step = gc_step-dc_int_calc_plan_values.

* get count of fiscal periods to be regarded
    CALL METHOD lo_cfg_leadobj_erp->if_faa_cfg_leadobj~get_number_of_periods
      EXPORTING
        id_fisc_year        = ms_proc_data-fyear
      IMPORTING
        ed_periods_short_fy = lv_periods.

* determine first period up to which values are to be calculated
    lv_fiscper = lv_periods - ms_proc_data-period_offset.   "2372072

*<<<<< start of changes from note 2357678 prerequisite is note 2297667 >>>>>*
* determine periods to be calculated backwards in year of acquisition
      DATA(lv_date) = ms_asset_data-cap_date.
      IF lv_date IS INITIAL.
        lv_date = ms_asset_data-initial_acq.
      ENDIF.

      IF lv_date >= ms_proc_data-first_day_in_fyr AND
         lv_date <= ms_proc_data-last_day_in_fyr.
        CALL METHOD lo_cfg_leadobj_erp->get_period_and_year
          EXPORTING
            id_date   = lv_date
          IMPORTING
            ed_period = lv_period_from.

        lv_periods = lv_periods - lv_period_from + 1.
      ENDIF.
*<<<<< start of changes from note 2357678 >>>>>*

* take over whole year amounts for determination of the panned amounts of
* the highest period to be regarded
    lt_calcamount_prev = mts_calcamount.

*<<<<< start of changes from note 2372072 >>>>>*
    DATA lv_remaining_prds  TYPE ty_s_hlpseg-period_to.
    IF lv_periods <= ms_proc_data-period_offset.
      lv_periods = 1.
    ELSE.
      lv_remaining_prds = lv_periods MOD ms_proc_data-period_offset.
      lv_periods        = lv_periods DIV ms_proc_data-period_offset.
      IF lv_remaining_prds <> 0.
        lv_periods = lv_periods + 1.
      ENDIF.
    ENDIF.
*<<<<< end of changes from note 2372072 >>>>>*

    DO lv_periods TIMES.

* as we calc. the periods packwards (11, 10, ..) values for the first period
* are provided on the last leap ( SY-INDEX = 1 ) within lt_calcamount_prev
* thus nothing has to be reduced so we just clear the amounts in MTS_CALCAMOUNT
      IF sy-index = lv_periods.
        CLEAR ls_calcamount-total.
        MODIFY lo_processing_handle->mts_calcamount FROM ls_calcamount TRANSPORTING total
         WHERE fyear = ms_proc_data-fyear.

* trigger value calculation up to actual period
      ELSE.
        CALL METHOD lo_cfg_leadobj_erp->if_faa_cfg_leadobj~get_last_day_in_period
          EXPORTING
            id_fisc_year = ms_proc_data-fyear
            id_period    = lv_fiscper
          IMPORTING
            ed_last_day  = lv_last_day_of_fiscper.

* delete transactions that are not assigned to actual period
        DELETE lo_processing_handle->mt_transaction
         WHERE posting_date > lv_last_day_of_fiscper
            OR value_date   > lv_last_day_of_fiscper.

        CLEAR lo_processing_handle->mts_hlpseg.
        CLEAR lo_processing_handle->mts_calcorder.
        CLEAR lo_processing_handle->mts_calcamount.
        CLEAR lo_processing_handle->mts_calcdata.

        CLEAR lo_processing_handle->mt_sumseg.
        CLEAR lo_processing_handle->mt_timeseg.
        CLEAR lo_processing_handle->mt_parameter.
        CLEAR lo_processing_handle->mt_period.

* provide HLPSEG with intervals up to the calc. period assigned
* to the last day of the posting period
        LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
          AT NEW area.
            IF <ls_hlpseg>-use_days = abap_false.
              CALL METHOD <ls_hlpseg>-arearef->get_period_and_year
                EXPORTING
                  id_date   = lv_last_day_of_fiscper
                IMPORTING
                  ed_period = lv_period_to.
            ELSE.
              lv_period_to = lv_last_day_of_fiscper - <ls_hlpseg>-first_day_in_yr + 1.
            ENDIF.
          ENDAT.

*         CHECK <ls_hlpseg>-start_yr    <= ms_proc_data-fyear.    "2424416
*         CHECK <ls_hlpseg>-amount_type <> gc_amount_type-repl.   "2530841
*         CHECK <ls_hlpseg>-amount_type <> gc_amount_type-rage.   "2530841

* do not consider intervals behind LV_PERIOD_TO
          IF <ls_hlpseg>-period_from > lv_period_to.
            CONTINUE.
          ENDIF.

          ls_hlpseg = <ls_hlpseg>.

* adjust PERIOD_TO of the interval if it ends behind
          IF <ls_hlpseg>-amount_type <> gc_amount_type-rage AND "2530841
             <ls_hlpseg>-amount_type <> gc_amount_type-repl. "2530841
            IF ls_hlpseg-period_to > lv_period_to.
              ls_hlpseg-period_to = lv_period_to.
            ENDIF.
          ENDIF."2530841

          APPEND ls_hlpseg TO lo_processing_handle->mts_hlpseg.
        ENDLOOP.

        CALL METHOD lo_processing_handle->_timeseg_create.
        CALL METHOD lo_processing_handle->_hlpseg_split_on_timeseg.
*        CALL METHOD lo_processing_handle->_hlpseg_split_on_alignment. "2222309
        CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
        CALL METHOD lo_processing_handle->_timeseg_create_missing.
        CALL METHOD lo_processing_handle->_parameter_create.
        CALL METHOD lo_processing_handle->_parameter_call_badi.
        CALL METHOD lo_processing_handle->_period_create.
        CALL METHOD lo_processing_handle->_sumseg_create.
        CALL METHOD lo_processing_handle->_calcorder_create.
        CALL METHOD lo_processing_handle->_values_calculate.
      ENDIF.

      LOOP AT lt_calcamount_prev INTO ls_calcamount_prev.
        READ TABLE lo_processing_handle->mts_calcamount INTO ls_calcamount
           WITH KEY area = ls_calcamount_prev-area.

        IF sy-subrc <> 0.
          CLEAR ls_calcamount.
        ENDIF.

        CLEAR ls_planvalue.

        ls_planvalue-fyear  = ls_calcamount_prev-fyear.
        ls_planvalue-area   = ls_calcamount_prev-area.
        ls_planvalue-period = lv_fiscper + ms_proc_data-period_offset. "2372072
        ls_planvalue-movcat = if_faa_posting_constants=>gc_classification-depreciation_run. "2224952

        ls_planvalue-slalittype = '07205'.
        ls_planvalue-amount     = ls_calcamount_prev-total-depr_o - ls_calcamount-total-depr_o.
        APPEND ls_planvalue TO mts_planvalue.

        ls_planvalue-slalittype = '07206'.
        ls_planvalue-amount     = ls_calcamount_prev-total-depr_s - ls_calcamount-total-depr_s.
        APPEND ls_planvalue TO mts_planvalue.

        IF ls_calcamount_prev-total-intr <> 0 OR            "2209564
           ls_calcamount-total-intr      <> 0.

          ls_planvalue-slalittype = '07209'.
          ls_planvalue-amount     = ls_calcamount_prev-total-intr   - ls_calcamount-total-intr.
          APPEND ls_planvalue TO mts_planvalue.
        ENDIF.

* consider revaluation of APC and depreciation is just calculated on a yearly base
        IF sy-index = 1.
          ls_planvalue-period = lv_fiscper + ms_proc_data-period_offset. "2372072.

          IF ls_calcamount_prev-total-revl <> 0.

            ls_planvalue-slalittype = '07203'.
            ls_planvalue-amount     = ls_calcamount_prev-total-revl.
            APPEND ls_planvalue TO mts_planvalue.
          ENDIF.

          IF ls_calcamount_prev-total-revl_d <> 0.
            ls_planvalue-slalittype = '07204'.
            ls_planvalue-amount     = ls_calcamount_prev-total-revl_d.
            APPEND ls_planvalue TO mts_planvalue.
          ENDIF.
        ENDIF.
      ENDLOOP.

* get next period up to which values are to be calculated
* and note the values calculate up to the actual period for delta
* calculation on the next leap
      lv_fiscper = lv_fiscper - ms_proc_data-period_offset. "2372072
      lt_calcamount_prev = lo_processing_handle->mts_calcamount.
    ENDDO.

* eliminate SLALITTYPES that have not been calculated as we can not check for amount = 0
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      AT NEW area.
        IF <ls_hlpseg>-calc_seq_ordn IS INITIAL.
          DELETE mts_planvalue
           WHERE area = <ls_hlpseg>-area
             AND slalittype = '07205'.
        ENDIF.
        IF <ls_hlpseg>-calc_seq_spec IS INITIAL.
          DELETE mts_planvalue
           WHERE area = <ls_hlpseg>-area
             AND slalittype = '07206'.
        ENDIF.
      ENDAT.

      AT NEW amount_type.                                   "2224952
        IF <ls_hlpseg>-keyref->ms_settings-percent_key = if_faa_dc_segments_720_c=>gc_percent-key_n.
          CASE <ls_hlpseg>-amount_type.
            WHEN gc_amount_type-ordn.
              IF <ls_hlpseg>-calc_seq_spec > 0.
                DELETE mts_planvalue
                 WHERE area       = <ls_hlpseg>-area
                   AND slalittype = '07205'.
              ENDIF.

            WHEN gc_amount_type-spec.
              IF <ls_hlpseg>-calc_seq_ordn > 0.
                DELETE mts_planvalue
                 WHERE area       = <ls_hlpseg>-area
                   AND slalittype = '07206'.
              ENDIF.
          ENDCASE.
        ENDIF.
      ENDAT.
    ENDLOOP.

    SORT mts_planvalue BY area period slalittype.

* POSTCONDITION
*  none
  ENDMETHOD.


  METHOD _PROPVALUE_CALL_BADI.
*
  ENDMETHOD.


  METHOD _ROUNDING_CALL_BADI.
    CHECK go_badi_customer IS BOUND
       OR go_badi_country  IS BOUND.

    FIELD-SYMBOLS <ls_rounding>      TYPE ty_s_rounding.
    FIELD-SYMBOLS <ls_area>          TYPE ty_s_area.

    DATA lo_segment_handle            TYPE faa_dc_segment_handle.
    DATA ls_rounding                  TYPE ty_s_rounding.

    READ TABLE mts_area INDEX 1 ASSIGNING <ls_area>.

    LOOP AT mt_rounding ASSIGNING <ls_rounding>.
      ls_rounding = <ls_rounding>.

* call country BADIs for change of rounding settings
      IF go_badi_country IS BOUND.
        CALL METHOD go_badi_country->change_rounding
          EXPORTING
            flt_val     = <ls_area>-arearef->if_faa_cfg_leadobj~msx_settings-country
            io_handle   = lo_segment_handle
          CHANGING
            cs_rounding    = ls_rounding
          EXCEPTIONS
            error_occurred = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.

      <ls_rounding>-decimals = ls_rounding-decimals.
      <ls_rounding>-method   = ls_rounding-method.
      <ls_rounding>-value    = ls_rounding-value.
      <ls_rounding>-place    = ls_rounding-place.

* call customer BADIs for change of rounding settings
      IF go_badi_customer IS BOUND.
        CALL METHOD go_badi_customer->change_rounding
          EXPORTING
            io_handle   = lo_segment_handle
          CHANGING
            cs_rounding    = ls_rounding
          EXCEPTIONS
            error_occurred = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        <ls_rounding>-decimals = ls_rounding-decimals.
        <ls_rounding>-method   = ls_rounding-method.
        <ls_rounding>-value    = ls_rounding-value.
        <ls_rounding>-place    = ls_rounding-place.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


METHOD _ROUNDING_CREATE.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_S_hlpseg.
  FIELD-SYMBOLS <ls_rounding>    type ty_S_DEPRAREA-ROUNDING.

  DATA ls_rounding               TYPE ty_S_rounding.

* VALUE    value to be rounded: V - net value, A - amount
* METHOD   rounding method: 0 - nearest whole, 1 - up, 2 - down
* PLACE    number of places for shifting the point before rounding
* DECIMALS number of places to be rounded

* get definitions for companycode and depr. areas
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
    AT NEW amount_type.

      CLEAR ls_rounding.

      ls_rounding-area        =  <ls_hlpseg>-area.
      ls_rounding-amount_type =  <ls_hlpseg>-amount_type.
      ls_rounding-place       = 2.

      READ TABLE  <ls_hlpseg>-arearef->mt_rounding ASSIGNING <ls_rounding>
            WITH KEY amount_type = <ls_hlpseg>-amount_type.

      ls_rounding-value       = <ls_rounding>-base_value.
      ls_rounding-method      = <ls_rounding>-rounding_method.
      ls_rounding-decimals    = <ls_rounding>-round_by.

      APPEND ls_rounding TO mt_rounding.
    ENDAT.
  ENDLOOP.
ENDMETHOD.


METHOD _SUMSEG_CREATE.
  FIELD-SYMBOLS <ls_transaction>        TYPE ty_s_transaction.
  FIELD-SYMBOLS <ls_hlpseg>             TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_timeseg>            TYPE ty_s_timeseg.
  FIELD-SYMBOLS <ls_sumseg>             TYPE ty_s_sumseg.
  FIELD-SYMBOLS <lv_transaction_amount> TYPE ty_s_transaction-cur-apc.
  FIELD-SYMBOLS <lv_sumseg_amount>      TYPE ty_s_sumseg-cur-apc.

  DATA ls_sumseg                        TYPE ty_s_sumseg.
  DATA lv_first_amount_type             TYPE ty_s_timeseg-amount_type.

  IF ms_proc_data-step = gc_step-dc_int_calc_plan_values.   "2160063
* create SUMSEG from TIMESEG that is limited to current required PERIOD_TO
* to avoid errors due to calculation period assignment of transactions e.g. retirements
    LOOP AT me->mt_timeseg ASSIGNING <ls_timeseg>.
      AT NEW area.
        CLEAR ls_sumseg.
        ls_sumseg-fyear      = <ls_timeseg>-fyear.
        ls_sumseg-area       = <ls_timeseg>-area.
        ls_sumseg-curr_type  = <ls_timeseg>-curr_type.
        lv_first_amount_type = <ls_timeseg>-amount_type.
      ENDAT.

      CHECK lv_first_amount_type = <ls_timeseg>-amount_type.

      ls_sumseg-prev_prev = <ls_timeseg>-prev_prev.
      ls_sumseg-prev_cur  = <ls_timeseg>-prev_cur.
      ls_sumseg-cur       = <ls_timeseg>-cur.

      COLLECT ls_sumseg INTO me->mt_sumseg.
    ENDLOOP.

  ELSE.
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
    AT END OF area.
      INSERT INITIAL LINE INTO mt_sumseg ASSIGNING <ls_sumseg> INDEX 1.
      <ls_sumseg>-fyear     = <ls_hlpseg>-fyear.
      <ls_sumseg>-area      = <ls_hlpseg>-area.
*        ls_sumseg-curr_type = <ls_hlpseg>-curr_type.
      <ls_sumseg>-period_to = <ls_hlpseg>-period_to.

      LOOP AT mt_transaction ASSIGNING <ls_transaction>
        WHERE area = <ls_hlpseg>-area.
          DO 11 TIMES.                                      "H2193614
          IF <ls_transaction>-cur IS NOT INITIAL.
            ASSIGN COMPONENT sy-index OF STRUCTURE <ls_transaction>-cur       TO <lv_transaction_amount>.
            ASSIGN COMPONENT sy-index OF STRUCTURE <ls_sumseg>-cur            TO <lv_sumseg_amount>.
            <lv_sumseg_amount> = <lv_sumseg_amount> + <lv_transaction_amount>.
          ENDIF.

          IF <ls_transaction>-prev_cur IS NOT INITIAL.
            ASSIGN COMPONENT sy-index OF STRUCTURE <ls_transaction>-prev_cur  TO <lv_transaction_amount>.
            ASSIGN COMPONENT sy-index OF STRUCTURE <ls_sumseg>-prev_cur       TO <lv_sumseg_amount>.
            <lv_sumseg_amount> = <lv_sumseg_amount> + <lv_transaction_amount>.
          ENDIF.

          IF <ls_transaction>-prev_prev IS NOT INITIAL.
            ASSIGN COMPONENT sy-index OF STRUCTURE <ls_transaction>-prev_prev TO <lv_transaction_amount>.
            ASSIGN COMPONENT sy-index OF STRUCTURE <ls_sumseg>-prev_prev      TO <lv_sumseg_amount>.
            <lv_sumseg_amount> = <lv_sumseg_amount> + <lv_transaction_amount>.
          ENDIF.
        ENDDO.

        IF <ls_transaction>-check_amount IS NOT INITIAL  OR
           " Special check on complete retirement in CL_FAA_EE
           <ls_transaction>-classification = if_faa_posting_constants=>gc_classification-retirement  OR  "2530208
           <ls_transaction>-classification = if_faa_posting_constants=>gc_classification-transfer_ret.   "2530208.
          <ls_sumseg>-check_amount = abap_true.
        ENDIF.
      ENDLOOP.
    ENDAT.
  ENDLOOP.
    SORT mt_sumseg.
  ENDIF.

ENDMETHOD.


METHOD _timeseg_create.

  CHECK mt_transaction IS NOT INITIAL.

  FIELD-SYMBOLS <ls_transaction> TYPE ty_s_transaction.
  FIELD-SYMBOLS <ls_timeseg>     TYPE ty_s_timeseg.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

  DATA lt_transaction            TYPE ty_t_transaction.     "2226481
  DATA lt_timeseg                TYPE ty_t_timeseg.
  DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

  DATA ls_timeseg                TYPE ty_s_timeseg.
  DATA ls_hlpseg                 TYPE ty_s_hlpseg.
  DATA ls_amount_types           TYPE char3.

  DATA lv_fiscal_year            TYPE numc4.
  DATA lv_calculation_period     TYPE numc3.
  DATA lv_message                TYPE string.               "2329644

* check if TIMSEG has to be created at all
  LOOP AT mts_hlpseg TRANSPORTING NO FIELDS
    WHERE keyref->ms_settings-percent_key <> gc_percent-key_n
      AND amount_type                     CA gc_amount_type+2(3) "2189388
      AND grp_asset_assgnd                =  abap_false.  "just needed for parallel Calc with checks
    EXIT.
  ENDLOOP.

  CHECK sy-subrc = 0.

  IF ms_proc_data-step = gc_step-dc_int_calc_co_rules.
    lt_hlpseg[] = mo_previous->mts_hlpseg[].
  ELSE.
    lt_hlpseg[] = mts_hlpseg[].
  ENDIF.

  lt_transaction = mt_transaction.                          "2226481

* avoid interval split on reversed items if both items the reversing and reversed one
* are provided in MT_TRANSACTION as otherwise calculation differences on NBV related calc. may occur
  LOOP AT lt_transaction ASSIGNING <ls_transaction>.
    IF <ls_transaction>-seqno_reversed IS NOT INITIAL AND
       <ls_transaction>-seqno_reversed <> '99999'.          "2343306
      READ TABLE mt_transaction TRANSPORTING NO FIELDS
        WITH KEY area  = <ls_transaction>-area
                 seqno          = <ls_transaction>-seqno_reversed
                 seqno_reversed = <ls_transaction>-seqno.   "2329644
      IF sy-subrc = 0.
        DELETE lt_transaction.
        CONTINUE.

* insure that on whole year related calculation both items reversing and reversed exist
      ELSE.                                                 "2329644
        IF ms_proc_data-step <> gc_step-dc_int_calc_plan_values.
          MESSAGE e524(aa) WITH <ls_transaction>-seqno INTO DATA(lv_msg). "2347067
          me->create_message_from_syst( ).
        ENDIF.
      ENDIF.
    ENDIF.

    ls_amount_types = gc_amount_type+2(3)."amount types to be considered => NSZ

    LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>
       WHERE area             = <ls_transaction>-area
         AND to_date_of_tddp >= <ls_transaction>-value_date
         AND amount_type     CA gc_amount_type+2(3).

* ensure lowest interval is used and each amount type is just processed once
      CHECK   <ls_hlpseg>-amount_type CA ls_amount_types.
      REPLACE <ls_hlpseg>-amount_type IN ls_amount_types WITH space.

      CLEAR ls_timeseg.

      CALL METHOD get_calc_yr_and_per_4_trnsctn "2189388
        EXPORTING
          is_hlpseg             = <ls_hlpseg>
          iv_per_ctrl_group     = <ls_transaction>-periodcontrol
          iv_value_date         = <ls_transaction>-value_date
        IMPORTING
          ev_fiscal_year        = lv_fiscal_year
          ev_calculation_period = lv_calculation_period.

      CHECK lv_fiscal_year         = ms_proc_data-fyear.
      CHECK lv_calculation_period <= <ls_hlpseg>-periods_short_fy.

      ls_timeseg-fyear       = <ls_hlpseg>-fyear.
      ls_timeseg-area        = <ls_hlpseg>-area.
      ls_timeseg-amount_type = <ls_hlpseg>-amount_type.
      ls_timeseg-period_to   = lv_calculation_period.

      MOVE-CORRESPONDING <ls_transaction> TO ls_timeseg.

      COLLECT ls_timeseg INTO lt_timeseg.
    ENDLOOP.
  ENDLOOP.

* as lt_timeseg contains in PERIOD_TO the periods with assigned transactions
* there is the need for a period interval within local table LT_HLPSEG
* that starts with HLPSEG-PERIOD_FROM = TIMESEG-PERIOD_TO for later determination
* of final PERIOD_TO within attribute table MT_TIMESEG
* if temp. timeseg is behind highest period interval it is not to be regarded for calculation
  SORT lt_timeseg.

  lt_hlpseg[] = mts_hlpseg[].

* perform period interval split if needed regarding temporary TIMESEGs
  LOOP AT lt_timeseg ASSIGNING <ls_timeseg>.
    LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>
      WHERE fyear       EQ <ls_timeseg>-fyear
        AND area        EQ <ls_timeseg>-area
        AND amount_type EQ <ls_timeseg>-amount_type
        AND period_from LT <ls_timeseg>-period_to
        AND period_to   GE <ls_timeseg>-period_to.

* create new period interval ending with the period before the calc. period of the assigned movements
      ls_hlpseg               = <ls_hlpseg>.
      ls_hlpseg-period_to     = <ls_timeseg>-period_to - 1.

      CHECK ls_hlpseg-period_to > 0.

      APPEND ls_hlpseg TO lt_hlpseg.

* adjust start period of actual interval to the calc. period of the assigned movements
      <ls_hlpseg>-period_from = <ls_timeseg>-period_to.
    ENDLOOP.
  ENDLOOP.

* perpare determination of correct PERIOD_TO for TIMESEG
  SORT lt_timeseg.
  SORT lt_hlpseg.

  DELETE ADJACENT DUPLICATES FROM lt_hlpseg COMPARING area amount_type period_from.

* determine correct PERIOD_TO for all TIMESEGs
  LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>
    WHERE amount_type CA gc_amount_type+2(3). "2189388

* perform PERIOD_TO adjustment for corresponding TIMESEG
    READ TABLE lt_timeseg INTO ls_timeseg
          WITH KEY fyear       = <ls_hlpseg>-fyear
                   area        = <ls_hlpseg>-area
                   amount_type = <ls_hlpseg>-amount_type
                   period_to   = <ls_hlpseg>-period_from.
    IF sy-subrc = 0.
      ls_timeseg-period_to = <ls_hlpseg>-period_to.

      APPEND ls_timeseg TO mt_timeseg.

* no movement assigned to period interval of HLPSEG => create appropriate initial entry
    ELSE.
      CLEAR ls_timeseg.

      ls_timeseg-amount_type = <ls_hlpseg>-amount_type.
      ls_timeseg-period_to   = <ls_hlpseg>-period_to.
      ls_timeseg-fyear       = <ls_hlpseg>-fyear.
      ls_timeseg-area        = <ls_hlpseg>-area.

      APPEND ls_timeseg TO mt_timeseg.
    ENDIF.
  ENDLOOP.

  SORT mt_timeseg.

* POSTCONDITION
  "none
ENDMETHOD.


METHOD _TIMESEG_CREATE_MISSING.
  FIELD-SYMBOLS <ls_timeseg>   TYPE ty_S_timeseg.
  FIELD-SYMBOLS <ls_hlpseg>    TYPE ty_S_hlpseg.
  DATA ls_timeseg              TYPE ty_S_timeseg.

* create timeseg completely from HLPSEG, if empty
  IF mt_timeseg[] IS INITIAL.
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      ls_timeseg-fyear        = <ls_hlpseg>-fyear.
      ls_timeseg-area         = <ls_hlpseg>-area.
      ls_timeseg-amount_type  = <ls_hlpseg>-amount_type.
      ls_timeseg-period_to    = <ls_hlpseg>-period_to.
      APPEND ls_timeseg TO mt_timeseg.
    ENDLOOP.

* create missing entries
  ELSE.
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      READ TABLE mt_timeseg TRANSPORTING NO FIELDS
            WITH KEY fyear       = <ls_hlpseg>-fyear
                     area        = <ls_hlpseg>-area
                     amount_type = <ls_hlpseg>-amount_type
                     period_to   = <ls_hlpseg>-period_to BINARY SEARCH.

* create entries analog HLPSEG if to
      CASE sy-subrc.

* segments are in sync, nothing to do
        WHEN 0.
          CONTINUE.

        WHEN 4.
          READ TABLE mt_timeseg ASSIGNING <ls_timeseg> INDEX sy-tabix.

* same area and amount type => create new one with values and clear values in actual one
          IF <ls_timeseg>-fyear        = <ls_hlpseg>-fyear AND
             <ls_timeseg>-area         = <ls_hlpseg>-area AND
             <ls_timeseg>-amount_type  = <ls_hlpseg>-amount_type.

* create TIMESEG with values for actual period interval
            ls_timeseg            = <ls_timeseg>.
            ls_timeseg-period_to  = <ls_hlpseg>-period_to.

            INSERT ls_timeseg INTO mt_timeseg INDEX sy-tabix.

* clear values as alread covered now by newly created TIMESEG
            CLEAR <ls_timeseg>-prev_prev.
            CLEAR <ls_timeseg>-prev_cur.
            CLEAR <ls_timeseg>-cur.

* different area or amount type => create initial one
          ELSE.
            CLEAR ls_timeseg.

            ls_timeseg-fyear        = <ls_hlpseg>-fyear.
            ls_timeseg-area         = <ls_hlpseg>-area.
            ls_timeseg-amount_type  = <ls_hlpseg>-amount_type.
            ls_timeseg-period_to    = <ls_hlpseg>-period_to.

            INSERT ls_timeseg INTO mt_timeseg INDEX sy-tabix.
          ENDIF.

* no more segments at all => create initial one
        WHEN 8.
          CLEAR ls_timeseg.

          ls_timeseg-fyear        = <ls_hlpseg>-fyear.
          ls_timeseg-area         = <ls_hlpseg>-area.
          ls_timeseg-amount_type  = <ls_hlpseg>-amount_type.
          ls_timeseg-period_to    = <ls_hlpseg>-period_to.

          APPEND ls_timeseg TO mt_timeseg.
      ENDCASE.
    ENDLOOP.
  ENDIF.
ENDMETHOD.


METHOD _transaction_add_on_postcap.
*=======================================================================
* calculate missed depreciaitons due to missed activation on asset
* => trigger depreciation caldulation starting with the fiscal year
*    assigned to the original value/posting date of the expense posting
*    up to the actual posting year
*=======================================================================
* precondition
  CHECK ms_transaction_cntrl-no_prop_val_calc EQ abap_false.
  CHECK ms_transaction_cntrl-classification   EQ gc_classification-post_capitalization.

  FIELD-SYMBOLS <ls_depr_param>            TYPE ty_s_deprarea-depr_param.
  FIELD-SYMBOLS <ls_yearseg>               TYPE ty_s_yearseg.
  FIELD-SYMBOLS <ls_area>                  TYPE ty_s_area.

  DATA lo_processing_handle                LIKE me.
  DATA lo_dc_calc_handle                   TYPE REF TO object.

  DATA ls_transaction                      TYPE ty_s_transaction.
  DATA ls_procinfo                         TYPE ty_s_processing_info.
  DATA ls_asset_data                       TYPE ty_s_asset_data.
  DATA ls_cum_values                       TYPE ty_s_yearseg.

  READ TABLE mts_area ASSIGNING <ls_area> INDEX 1.

  CALL METHOD <ls_area>-arearef->get_period_and_year
    EXPORTING
      id_date      = ms_transaction_cntrl-value_date_orig
    IMPORTING
      ed_fisc_year = ls_procinfo-fyear.

  ls_procinfo-process           = ms_proc_data-process.
  ls_procinfo-step              = gc_step-dc_720_recalculation.
  ls_procinfo-fyear_to          = ms_proc_data-fyear.
  ls_procinfo-period_offset     = ms_proc_data-period_offset. "2372072
  ls_procinfo-leadobj_instance  = ms_proc_data-leadobj_instance.
  ls_procinfo-t_area[]          = mts_area[].

  ls_asset_data                 = ms_asset_data.
  CLEAR ls_asset_data-t_cum_values.

* provide expired usefule life for the first year to be calculated
  LOOP AT mts_area ASSIGNING <ls_area>.
    LOOP AT ls_asset_data-ts_depr_param ASSIGNING <ls_depr_param>
     WHERE depr_area = <ls_area>-depr_area.
      <ls_depr_param>-exp_ulife_yrs       = <ls_area>-exp_ulife_yrs.
      <ls_depr_param>-exp_ulife_prds      = <ls_area>-exp_ulife_prds.
      <ls_depr_param>-exp_ulife_sdep_yrs  = <ls_area>-exp_ulife_sdep_yrs.
      <ls_depr_param>-exp_ulife_sdep_prds = <ls_area>-exp_ulife_sdep_prds.
      <ls_depr_param>-depr_units          = <ls_area>-depr_units .
    ENDLOOP.

* provide initial cumulated values for fiscal year of original value date
    CLEAR ls_cum_values.
    ls_cum_values-fyear = ls_procinfo-fyear.
    ls_cum_values-area  = <ls_area>-depr_area.
    APPEND ls_cum_values TO ls_asset_data-t_cum_values.
  ENDLOOP.

* provide faked acquisition transaction for the first year to trigger backlog calc. up to now
  CLEAR ls_asset_data-t_transaction.

  LOOP AT mt_transaction_post INTO ls_transaction.
    ls_transaction-fyear          = ls_procinfo-fyear.
    ls_transaction-posting_date   = ms_transaction_cntrl-value_date_orig.
    ls_transaction-value_date     = ms_transaction_cntrl-value_date_orig.
    ls_transaction-periodcontrol  = gc_period_group-acquisition.
    ls_transaction-classification = gc_classification-acquisition.
    CLEAR ls_transaction-cur.
    ls_transaction-cur-apc        = ls_transaction-prev_prev-apc.
    CLEAR ls_transaction-prev_cur.
    CLEAR ls_transaction-prev_prev.
    APPEND ls_transaction TO ls_asset_data-t_transaction.
  ENDLOOP.

  CALL METHOD perform_calc_with_implicit_cf
    EXPORTING
      is_processing_info = ls_procinfo
      is_asset_data      = ls_asset_data
    RECEIVING
      ro_dc_calc_handle  = lo_dc_calc_handle.

  lo_processing_handle ?= lo_dc_calc_handle.

  ls_transaction-cntrl = ms_transaction_cntrl.

  CLEAR mt_transaction_post.

  LOOP AT lo_processing_handle->mt_yearseg ASSIGNING <ls_yearseg>.
    CLEAR ls_transaction-prev_prev.
    CLEAR ls_transaction-prev_cur.
    CLEAR ls_transaction-cur.
    ls_transaction-fyear            = ms_transaction_cntrl-fyear.
    ls_transaction-area             = <ls_yearseg>-area.
    ls_transaction-prev_prev-apc    = <ls_yearseg>-cum-apc.
    ls_transaction-prev_prev-depr_o = <ls_yearseg>-cum-depr_o.
    ls_transaction-prev_prev-depr_s = <ls_yearseg>-cum-depr_s.
    ls_transaction-prev_prev-revl   = <ls_yearseg>-cum-revl.
    ls_transaction-prev_prev-revl_d = <ls_yearseg>-cum-revl_d.

    APPEND ls_transaction TO mt_transaction_post.
  ENDLOOP.

  APPEND LINES OF  mt_transaction_post TO  mt_transaction.
* POSTCONDITION

ENDMETHOD.


METHOD _TRANSACTION_ADD_ON_POSTING.

* exclude subsequent revenue/retirement costs as not relevant for depreciation calculation
  CHECK ms_transaction_cntrl-classification <> 'A8'.
  CHECK ms_transaction_cntrl-classification <> 'B8'.

* exclude transactions of type take over of legacy acumulated values as they are covered in YEARSEG
  CHECK ms_transaction_cntrl-classification <> 'E7'.
  CHECK ms_transaction_cntrl-classification <> 'C7'.
  CHECK ms_transaction_cntrl-classification <> '77'.        "2252940
  CHECK ms_transaction_cntrl-classification <> '87'.        "2252940
  CHECK ms_transaction_cntrl-classification <> '97'.        "2252940
  CHECK ms_transaction_cntrl-classification <> '06'.        "2226481

* ensure that we take over overwritten values on retirement and post. cap.
  IF ms_transaction_cntrl-classification EQ gc_classification-retirement   OR
     ms_transaction_cntrl-classification EQ gc_classification-transfer_ret OR
     ms_transaction_cntrl-classification EQ gc_classification-post_capitalization.
    CHECK ms_transaction_cntrl-no_prop_val_calc EQ abap_true.
  ENDIF.

  APPEND LINES OF mt_transaction_post TO mt_transaction.

ENDMETHOD.


METHOD _transaction_add_on_retirement.
  CHECK ms_transaction_cntrl-no_prop_val_calc EQ abap_false.
  CHECK ms_transaction_cntrl-classification   EQ gc_classification-retirement
     OR ms_transaction_cntrl-classification   EQ gc_classification-transfer_ret.

  FIELD-SYMBOLS <ls_hlpseg>                TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_area>                  TYPE ty_s_area.
  FIELD-SYMBOLS <ls_areasign>              TYPE ty_s_areasign.
  FIELD-SYMBOLS <ls_yearseg>               TYPE ty_s_yearseg.

  FIELD-SYMBOLS <lv_prop_amount>           TYPE any.
  FIELD-SYMBOLS <lv_percentage>            TYPE proz_abgwe.

  DATA lo_processing_handle                LIKE me.
  DATA lt_area                             TYPE TABLE OF ty_s_area.

  DATA ls_transaction                      TYPE ty_s_transaction.
  DATA ls_sumseg                           TYPE ty_s_sumseg.
  DATA ls_hlpseg                           TYPE ty_s_hlpseg.
  DATA ls_calcamount                       TYPE ty_s_calcamount.
  DATA ls_area                             TYPE ty_s_area.

  DATA lv_fiscal_year                      TYPE ty_s_hlpseg-fyear. "##NEEDED
  DATA lv_period_to                        TYPE ty_s_hlpseg-period_to.
  DATA lv_prop_amount                      TYPE nafav.
  DATA lv_base_amount                      TYPE ty_s_value-apc.
  DATA lv_ret_amount                       TYPE ty_s_value-apc.
  DATA lv_base_sign                        TYPE i.
  DATA lv_ret_sign                         TYPE i.
  DATA lv_message                          TYPE string.

*=======================================================================
* prepare and perform value calculation up to value date of retirement
*=======================================================================
  CREATE OBJECT lo_processing_handle.

* take over posting date independant data
  lo_processing_handle->ms_proc_data   = ms_proc_data.
  lo_processing_handle->mo_start       = mo_start.
  lo_processing_handle->mts_area       = mts_area.
  lo_processing_handle->mt_yearseg     = mt_yearseg.
  lo_processing_handle->mt_areasign    = mt_areasign.
  lo_processing_handle->mt_rounding    = mt_rounding.
  lo_processing_handle->mt_virtarea    = mt_virtarea.

* adjust/create value date dependant attribute tables for consistency check
  lo_processing_handle->ms_proc_data-step = gc_step-dc_int_retirement_request.

* Limit HLPSEG to calculation period assigned to value date
  LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
    AT NEW amount_type.

*<<<<< start of changes due to note 2377026 >>>>>*
      LOOP AT mts_hlpseg ASSIGNING FIELD-SYMBOL(<ls_hlpseg_get_period>)
        WHERE area             = <ls_hlpseg>-area
          AND to_date_of_tddp >= ms_transaction_cntrl-value_date
          AND amount_type      = <ls_hlpseg>-amount_type.

        CALL METHOD get_calc_yr_and_per_4_trnsctn
          EXPORTING
            is_hlpseg             = <ls_hlpseg_get_period>
            iv_per_ctrl_group     = ms_transaction_cntrl-periodcontrol
            iv_value_date         = ms_transaction_cntrl-value_date
          IMPORTING
            ev_fiscal_year        = lv_fiscal_year
            ev_calculation_period = lv_period_to.
        EXIT.
      ENDLOOP.
*<<<<< end  of changes due to note 2377026 >>>>>*

      READ TABLE mts_area ASSIGNING <ls_area>               "2422399
        WITH KEY depr_area = <ls_hlpseg>-area.
      IF <ls_area>-retirement_type = 2.
        lv_period_to = <ls_hlpseg>-periods_short_fy + 1.
      ENDIF.                                                "2422399
    ENDAT.

* do not consider intervals behind LV_PERIOD_TO
    CHECK <ls_hlpseg>-period_from <= lv_period_to.

    ls_hlpseg = <ls_hlpseg>.

* adjust PERIOD_TO of the interval if it ends behind
    IF ls_hlpseg-amount_type NA 'AC'.
      IF lv_fiscal_year = <ls_hlpseg>-fyear.                "2245022
        IF ls_hlpseg-period_to >= lv_period_to.
          ls_hlpseg-period_to = lv_period_to - 1.

          IF ls_hlpseg-period_to = 0.
            ls_hlpseg-period_from = 0.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

* intervals with period from > adjusted PERIOD_TO are not to be considered
    IF ls_hlpseg-period_from > ls_hlpseg-period_to.
      CONTINUE.
    ENDIF.

    APPEND ls_hlpseg TO lo_processing_handle->mts_hlpseg.
  ENDLOOP.

* eliminate transactions with a posting date or value date behind the actual one
  lo_processing_handle->mt_transaction = mt_transaction.

  DELETE lo_processing_handle->mt_transaction
   WHERE posting_date > ms_transaction_cntrl-posting_date
      OR value_date   > ms_transaction_cntrl-value_date.

  CALL METHOD lo_processing_handle->_timeseg_create.
  CALL METHOD lo_processing_handle->_hlpseg_split_on_timeseg.
  CALL METHOD lo_processing_handle->_hlpseg_split_on_alignment.
  CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
  CALL METHOD lo_processing_handle->_timeseg_create_missing.
  CALL METHOD lo_processing_handle->_parameter_create.
  CALL METHOD lo_processing_handle->_parameter_call_badi.
  CALL METHOD lo_processing_handle->_period_create.
  CALL METHOD lo_processing_handle->_sumseg_create.
  CALL METHOD lo_processing_handle->_calcorder_create.
  CALL METHOD lo_processing_handle->_values_calculate.

*=======================================================================
* perform proportional value calculation
* consider that there might be no entry in table MTS_CALCAMOUNT if:
* - area is assigned to a group asset
* - no automatic calculation due to depreciation method
* - retirement posting is assigned to period 1 => HLPSEG-PERIO_TO = 0
*=======================================================================

* determine areas which area to be regarded on proportional value calculation to ensure "2310804
* correct processing on check if asset should be deactivated on ledger group level
  IF lines( mts_area ) = lines( mt_transaction_post ).      "2310804
    lt_area =  mts_area.
  ELSE.
    LOOP AT mt_transaction_post INTO ls_transaction.
      READ TABLE mts_area ASSIGNING <ls_area>
        WITH KEY depr_area = ls_transaction-area.
      CHECK sy-subrc = 0.
      APPEND <ls_area> TO lt_area.
    ENDLOOP.
  ENDIF.                                                    "2310804

  SORT lt_area BY sort_sequence ASCENDING is_base_area DESCENDING.

  CLEAR mt_transaction_post.

  LOOP AT lt_area ASSIGNING <ls_area>.

    READ TABLE mt_areasign ASSIGNING <ls_areasign>
      WITH KEY area  = <ls_area>-depr_area.
    ASSERT sy-subrc EQ 0.

    READ TABLE mt_yearseg ASSIGNING <ls_yearseg>
        WITH KEY area  = <ls_area>-depr_area.
    ASSERT sy-subrc EQ 0.

    READ TABLE lo_processing_handle->mt_sumseg INTO ls_sumseg
          WITH KEY area  = <ls_area>-depr_area.
    IF sy-subrc <> 0.
      CLEAR ls_sumseg.
    ENDIF.

    READ TABLE lo_processing_handle->mts_calcamount INTO ls_calcamount
          WITH KEY area  = <ls_area>-depr_area.

    IF sy-subrc <> 0.
      CLEAR ls_calcamount.
    ENDIF.

* determine percentage to be applied for all areas on partial retirement
    IF <ls_area>-is_base_area = abap_true.
      ls_area = <ls_area>.

      lv_ret_sign = -1.                                     "2246557

* on prior year related partial retirement
      IF ls_area-prev_prev_apc <> 0.
        ASSIGN ls_area-prev_prev_percent TO <lv_percentage>.

        lv_ret_amount   = abs( <ls_area>-prev_prev_apc ).

        IF <ls_areasign>-apc <> gc_area_value_sign-none.
          lv_base_amount = abs( <ls_yearseg>-cum-apc  + ls_sumseg-prev_prev-apc  "2385808
                              + <ls_yearseg>-cum-revl + ls_sumseg-prev_prev-revl    "<<< SPC_1607618
                                                      + ls_sumseg-prev_cur-revl ).  "<<< SPC_1607618
*                              + <ls_yearseg>-cum-invs + ls_sumseg-prev_prev-invs )."2385808

* on retirement simulation by settlement include prior year doen payments to avoid error 416
* if the amount of the down payments are greater than the APC amount
          IF ls_area-retirement_type = 9.
            lv_base_amount = abs( <ls_yearseg>-cum-apc  + ls_sumseg-prev_prev-apc
                                + <ls_yearseg>-cum-revl + ls_sumseg-prev_prev-revl   "<<< SPC_1607618
                                                        + ls_sumseg-prev_cur-revl    "<<< SPC_1607618
*                                + <ls_yearseg>-cum-invs + ls_sumseg-prev_prev-invs "2385808
                                + <ls_yearseg>-cum-downp ).

            IF sign( <ls_yearseg>-cum-apc   + ls_sumseg-prev_prev-apc  + <ls_yearseg>-cum-downp ) < 0. "2225791 "2385808
*                     <ls_yearseg>-cum-invs  + ls_sumseg-prev_prev-invs + <ls_yearseg>-cum-downp ) < 0. "2225791 "2385808
              lv_ret_sign = 1.
            ENDIF.
          ENDIF.
        ELSE.
          IF <ls_areasign>-invs <> gc_area_value_sign-none.
            lv_base_amount = abs( <ls_yearseg>-cum-invs + ls_sumseg-prev_prev-invs ).
          ENDIF.

          IF <ls_areasign>-revl <> gc_area_value_sign-none.
            lv_base_amount = abs( <ls_yearseg>-cum-revl + ls_sumseg-prev_prev-revl ).
          ENDIF.
        ENDIF.

        IF lv_base_amount LT lv_ret_amount.
          IF <ls_area>-retirement_type <> 9 OR <ls_areasign>-sign <> gc_area_value_sign-any. "2221483
            MESSAGE e316(aa) INTO lv_message.
          ENDIF.
        ENDIF.

        IF lv_ret_amount  <> 0 AND
           lv_base_amount EQ 0.
          IF <ls_area>-retirement_type <> 9 OR <ls_areasign>-sign <> gc_area_value_sign-any. "2270371
            MESSAGE e416(aa) INTO lv_message.
          ENDIF.
        ENDIF.

        IF lv_ret_amount    <> 0 AND
           lv_base_amount   <> 0 AND
           lv_message       IS INITIAL.
*         <lv_percentage> = lv_ret_amount * 100 / lv_base_amount. "2225791 "2246557 "2488588
          DATA(lv_percentage) = lv_ret_amount * 100 / lv_base_amount. "Begin of 2488588
          IF lv_percentage LE 100.
            <lv_percentage> = lv_percentage.
          ELSE.
            <lv_percentage> = 100.
          ENDIF.                                                      "End of 2488588
        ENDIF.
      ENDIF.

* on current year related partial retirement
      IF ls_area-cur_apc <> 0.
        ASSIGN ls_area-cur_percent TO <lv_percentage>.

        lv_ret_amount   = abs( <ls_area>-cur_apc ).

        IF <ls_areasign>-apc <> gc_area_value_sign-none.
          lv_base_amount = abs( ls_sumseg-cur-apc  "+ ls_sumseg-cur-invs )."2385808
                              + ls_sumseg-cur-revl ).                      "<<< SPC_1607618
* on retirement simulation by settlement include current year down payments to avoid error 417
* if the amount of the down payments are greater than the APC amount
          IF <ls_area>-retirement_type = 9.                 "H2081775
            lv_base_amount = abs( ls_sumseg-cur-apc "+ "ls_sumseg-cur-invs "2385808
                                + ls_sumseg-cur-downp
                                + ls_sumseg-cur-revl ). "<<< SPC_1607618
          ENDIF.

        ELSE.
          IF <ls_areasign>-invs <> gc_area_value_sign-none.
            lv_base_amount = abs( ls_sumseg-cur-invs ).
          ENDIF.

          IF <ls_areasign>-revl <> gc_area_value_sign-none.
            lv_base_amount = abs( ls_sumseg-cur-revl ).
          ENDIF.
        ENDIF.

        IF lv_base_amount LT lv_ret_amount.
          IF <ls_area>-retirement_type <> 9 OR <ls_areasign>-sign <> gc_area_value_sign-any. "2221483
            MESSAGE e317(aa) INTO lv_message.
          ENDIF.
        ENDIF.

        IF lv_ret_amount  <> 0 AND
           lv_base_amount EQ 0.
          IF <ls_area>-retirement_type <> 9 OR <ls_areasign>-sign <> gc_area_value_sign-any. "2270371
            MESSAGE e417(aa) INTO lv_message.
          ENDIF.
        ENDIF.

        IF lv_ret_amount    <> 0 AND
           lv_base_amount   <> 0 AND
           lv_message       IS INITIAL.
*         <lv_percentage> = lv_ret_amount * 100 / lv_base_amount. "2225791 "2246557 "2488588
          lv_percentage = lv_ret_amount * 100 / lv_base_amount. "Begin of 2488588
          IF lv_percentage LE 100.
            <lv_percentage> = lv_percentage.
          ELSE.
            <lv_percentage> = 100.
          ENDIF.                                                "End of 2488588
        ENDIF.
      ENDIF.
    ENDIF.

* EXIT Loop on error if amount entered is too high
    IF lv_message IS NOT INITIAL.
      WRITE <ls_yearseg>-area TO syst-msgv1.
      WRITE lv_base_amount    TO syst-msgv2 LEFT-JUSTIFIED DECIMALS <ls_area>-arearef->msx_areadef-curr_decimals.
      me->create_message_from_syst( ).
    ENDIF.


* calculate proportional values
    CLEAR ls_transaction.

    ls_transaction-cntrl     = ms_transaction_cntrl.
    ls_transaction-area      = <ls_yearseg>-area.

* calculate base amounts related to previous fisc. year for proportional value calc.
    IF ls_area-prev_prev_percent <> 0 OR <ls_area>-retirement_type = 2. "2422399
      ls_transaction-prev_cur-invs    = ls_sumseg-prev_cur-invs.
      ls_transaction-prev_cur-revl    = ls_sumseg-prev_cur-revl       + ls_calcamount-prev-revl.
      ls_transaction-prev_cur-revl_d  = ls_sumseg-prev_cur-revl_d     + ls_calcamount-prev-revl_d.
      ls_transaction-prev_cur-depr_o  = ls_sumseg-prev_cur-depr_o     + ls_calcamount-prev-depr_o.
      ls_transaction-prev_cur-depr_s  = ls_sumseg-prev_cur-depr_s     + ls_calcamount-prev-depr_s.
      ls_transaction-prev_cur-depr_u  = ls_sumseg-prev_cur-depr_u.
      ls_transaction-prev_cur-resv    = ls_sumseg-prev_cur-resv.
      ls_transaction-prev_cur-downp   = ls_sumseg-prev_cur-downp.

      ls_transaction-prev_prev-apc    = <ls_yearseg>-cum-apc          + ls_sumseg-prev_prev-apc.
      ls_transaction-prev_prev-invs   = <ls_yearseg>-cum-invs         + ls_sumseg-prev_prev-invs.
      ls_transaction-prev_prev-revl   = <ls_yearseg>-cum-revl         + ls_sumseg-prev_prev-revl.
      ls_transaction-prev_prev-revl_d = <ls_yearseg>-cum-revl_d       + ls_sumseg-prev_prev-revl_d.
      ls_transaction-prev_prev-depr_o = <ls_yearseg>-cum-depr_o       + ls_sumseg-prev_prev-depr_o.
      ls_transaction-prev_prev-depr_s = <ls_yearseg>-cum-depr_s       + ls_sumseg-prev_prev-depr_s.
      ls_transaction-prev_prev-depr_u = <ls_yearseg>-cum-depr_u       + ls_sumseg-prev_prev-depr_u.
      ls_transaction-prev_prev-resv   = <ls_yearseg>-cum-resv     + ls_sumseg-prev_prev-resv.
      ls_transaction-prev_prev-downp  = <ls_yearseg>-cum-downp    + ls_sumseg-prev_prev-downp.
    ENDIF.

* calculate base amounts related to actual fisc. year for proportional value calc.
    IF ls_area-cur_percent <> 0 OR <ls_area>-retirement_type = 2. "2422399
      ls_transaction-cur-apc    = ls_sumseg-cur-apc.
      ls_transaction-cur-invs   = ls_sumseg-cur-invs    + ls_calcamount-total-invs.
      ls_transaction-cur-revl   = ls_sumseg-cur-revl    + ls_calcamount-total-revl   - ls_calcamount-prev-revl.
      ls_transaction-cur-revl_d = ls_sumseg-cur-revl_d  + ls_calcamount-total-revl_d - ls_calcamount-prev-revl_d.
      ls_transaction-cur-depr_o = ls_sumseg-cur-depr_o  + ls_calcamount-total-depr_o - ls_calcamount-prev-depr_o.
      ls_transaction-cur-depr_s = ls_sumseg-cur-depr_s  + ls_calcamount-total-depr_s - ls_calcamount-prev-depr_s.
      ls_transaction-cur-depr_u = ls_sumseg-cur-depr_u  + ls_calcamount-total-depr_u.
      ls_transaction-cur-resv   = ls_sumseg-cur-resv    + ls_calcamount-total-resv.
      ls_transaction-cur-downp  = ls_sumseg-cur-downp   + ls_calcamount-total-downp.
    ENDIF.

    CASE <ls_area>-retirement_type.                         "2422399

* simulate complete retirement on retirement type 2 to provide nbv at the end of the year
      WHEN 2.
        ls_transaction-periodcontrol = gc_period_group-endofyear.

        DATA(ls_area_hlp)         = ls_area.
        ls_area-prev_prev_percent = 100.
        ls_area-cur_percent       = 100.

* nothing to be retired at all on scrapping with retirement type 2 which is changed to 8 to provide
* the information that this is no sale and shift the transaction to end of year to avoid interval splitting
      WHEN 8.
        ls_transaction-periodcontrol = gc_period_group-endofyear.

* if asset is an asset under construction (Retirement type = 9) which has down payments  "2344748
* those have to be regarded on retirement simulation but not on final settlement
      WHEN 9.

        IF <ls_area>-prev_prev_apc <> 0  OR
           <ls_area>-cur_apc       <> 0.

          ls_transaction-prev_prev-downp = 0.
          ls_transaction-cur-downp       = 0.
        ENDIF.

* for all other retirements down payments have not to be regarded at all
      WHEN OTHERS.
        ls_transaction-prev_prev-downp = 0.
        ls_transaction-cur-downp       = 0.
    ENDCASE.                                                "2422399

* perform proportional value calculation
    DO 10 TIMES.

      ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-prev_cur TO <lv_prop_amount>.

* if area is assigned to a group asset no depreciation is to be considered
      IF <ls_area>-grp_asset_assgnd = abap_true.
        IF sy-index < 3 OR sy-index > 8.
        ELSE.
          <lv_prop_amount> = 0.
        ENDIF.
      ENDIF.

* calculate proportional amount
      IF <lv_prop_amount> <> 0.
        <lv_prop_amount> =   <lv_prop_amount> * ls_area-prev_prev_percent * lv_ret_sign / 100. "2246557
        lv_prop_amount   =   <lv_prop_amount>.
        <lv_prop_amount> =    lv_prop_amount.
      ENDIF.

      ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-prev_prev TO <lv_prop_amount>.
      IF <lv_prop_amount> <> 0.
        <lv_prop_amount> =   <lv_prop_amount> * ls_area-prev_prev_percent * lv_ret_sign / 100. "2246557
        lv_prop_amount   =   <lv_prop_amount>.
        <lv_prop_amount> =    lv_prop_amount.
      ENDIF.

      ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-cur TO <lv_prop_amount>.
      IF <lv_prop_amount> <> 0.
        <lv_prop_amount> =   <lv_prop_amount> * ls_area-cur_percent * lv_ret_sign / 100. "2246557
        lv_prop_amount   =   <lv_prop_amount>.
        <lv_prop_amount> =    lv_prop_amount.
      ENDIF.

      IF sy-index = 1 AND <ls_area>-retirement_type = 9.    "2246557
        IF <ls_area>-prev_prev_apc <> 0  OR
           <ls_area>-cur_apc       <> 0.
          ls_transaction-prev_prev-apc = <ls_area>-prev_prev_apc.
          ls_transaction-cur-apc       = <ls_area>-cur_apc.
        ENDIF.
      ENDIF.

* on special retirmemen type 2 note APC amount in special field and leave DO
*      CHECK sy-index                   = 1.                 "2193614 "2422399
*      CHECK <ls_area>-retirement_type  = 2.
*      CHECK <ls_area>-grp_asset_assgnd = abap_false.
*
*      ls_transaction-prev_prev-apc_ret_ia = ls_transaction-prev_prev-apc.
*      ls_transaction-cur-apc_ret_ia       = ls_transaction-cur-apc. "2193614
*      EXIT.
    ENDDO.

* put back calculated percentage for proportional value calculation for next area  "2422399
* and get statistical APC
    CASE <ls_area>-retirement_type.
      WHEN 2.                                               "2422399
        ls_area = ls_area_hlp.

        lv_prop_amount                      = ls_transaction-prev_prev-apc * ls_area-prev_prev_percent / 100.
        ls_transaction-prev_prev-apc_ret_ia = lv_prop_amount.

        lv_prop_amount                      = ls_transaction-cur-apc       * ls_area-cur_percent / 100.
        ls_transaction-cur-apc_ret_ia       = lv_prop_amount.

* scrapping with retirement type 2 => clear all values, as nothing is to be retired
      WHEN 8.
        lv_prop_amount                      = ls_transaction-prev_prev-apc.
        CLEAR ls_transaction-prev_prev.
        CLEAR ls_transaction-prev_cur.
        ls_transaction-prev_prev-apc_ret_ia = lv_prop_amount.

        lv_prop_amount                      = ls_transaction-cur-apc.
        CLEAR ls_transaction-cur.
        ls_transaction-cur-apc_ret_ia       = lv_prop_amount.
    ENDCASE.                                                "2422399

* perform value adjustment on partial retirement if residual value is to be regarded
    IF ls_area-prev_prev_percent IS INITIAL
    OR ls_area-cur_percent       IS INITIAL.

      CALL METHOD lo_processing_handle->adjust_prop_values_on_minval
        EXPORTING
          is_calcamount  = ls_calcamount
          is_yearseg     = <ls_yearseg>
          is_sumseg      = ls_sumseg
          is_areasign    = <ls_areasign>
          is_area        = <ls_area>
        CHANGING
          cs_transaction = ls_transaction.
    ENDIF.

    APPEND ls_transaction TO mt_transaction_post.
    APPEND ls_transaction TO mt_transaction.
  ENDLOOP.
ENDMETHOD.


METHOD _TRANSACTION_ADJST_ON_REVERSAL.
*=======================================================================
* remove reversed items to avoid interval splits that could lead to
* rounding issues on depreciation calculation
*=======================================================================
* exclude subsequent revenue/retirement costs as not relevant for depreciation calculation
  CHECK ms_transaction_cntrl-classification <> 'A8'.
  CHECK ms_transaction_cntrl-classification <> 'B8'.

*  DATA ls_transaction             TYPE ty_S_transaction. "2226481
*
*  LOOP AT mt_transaction_post INTO ls_transaction.
*    DELETE mt_transaction
*     WHERE fyear = ls_transaction-fyear
*       AND area  = ls_transaction-area
*       AND seqno = ls_transaction-seqno_reversed.
*  ENDLOOP.

* exclude transactions of type take over of legacy acumulated values as they are covered in YEARSEG
  CHECK ms_transaction_cntrl-classification <> 'E7'.        "2252940
  CHECK ms_transaction_cntrl-classification <> 'C7'.
  CHECK ms_transaction_cntrl-classification <> '77'.
  CHECK ms_transaction_cntrl-classification <> '87'.
  CHECK ms_transaction_cntrl-classification <> '97'.

* we need to regard all postings, to ensure correct planvalue creation
* special logic to avoid interval splitting is moved to _TIMESEG_CREATE
  APPEND LINES OF mt_transaction_post TO mt_transaction.

ENDMETHOD.


METHOD _TRANSACTION_CREATE_FROM_DB.

  mt_transaction = mo_start->ms_asset_data-t_transaction.

  DELETE mt_transaction
   WHERE fyear          <> ms_proc_data-fyear
      or classification EQ 'A8'
      or classification EQ 'B8'
      OR classification EQ 'E7'
      OR classification EQ 'C7'
      OR classification EQ '77'                             "2252940
      OR classification EQ '87'                             "2252940
      OR classification EQ '97'                             "2252940
      OR classification EQ '06'.
*      or SEQNO_REVERSED is not INITIAL."2226481

ENDMETHOD.


METHOD _values_calculate.
  FIELD-SYMBOLS <ls_sumseg>   TYPE ty_s_sumseg.

  DATA lsx_idata              TYPE ty_sx_ee_idata.
  DATA lsx_edata              TYPE ty_sx_ee_edata.

  DATA ls_currency            TYPE ty_s_ee_currency.
  DATA ls_sumseg              TYPE ty_s_sumseg.
  DATA ls_error               TYPE ty_s_ee_error.
  DATA lv_message             TYPE string.
  DATA lo_message_handle      TYPE ty_o_dc_message_handle.

* check if processing required at all
  CHECK NOT mts_calcorder[] IS INITIAL.

* provide created segments to Evaluation Engine
  lsx_idata-country         =  ms_proc_data-country.

* as AREASIGN and VIRTAREA do not change they are just created
  lsx_idata-t_rounding      =  mt_rounding.                 "2189388
  lsx_idata-t_areasign      =  mt_areasign.
  lsx_idata-t_virtarea      =  mt_virtarea.
  lsx_idata-ts_calcorder    =  mts_calcorder.
  lsx_idata-t_yearseg       =  mt_yearseg.
  lsx_idata-t_timeseg       =  mt_timeseg.
  lsx_idata-t_sumseg        =  mt_sumseg.
  lsx_idata-t_period        =  mt_period.
  lsx_idata-t_parameter     =  mt_parameter.

* create table with used currency types.
  LOOP AT mt_sumseg ASSIGNING <ls_sumseg>.
    ls_currency-area      = <ls_sumseg>-area.
    ls_currency-curr_type = <ls_sumseg>-curr_type.
    APPEND ls_currency TO lsx_idata-ts_currency.
  ENDLOOP.

* call Evaluation Engine to calculate amounts
  CALL METHOD cl_faa_ee=>evaluate_amounts
    EXPORTING
      isx_idata = lsx_idata
    IMPORTING
      esx_edata = lsx_edata.

  mts_calcdata[]   = lsx_edata-ts_calcdata.
  mts_calcamount[] = lsx_edata-ts_calcamount.

* put error messages to message table
  LOOP AT lsx_edata-ts_error INTO ls_error.
    IF ls_error-var_01 IS INITIAL.
      ls_error-var_01 = ls_error-area.
    ENDIF.

    MESSAGE ID 'AA' TYPE 'E' NUMBER  ls_error-error_number
       WITH ls_error-var_01 ls_error-var_02 ls_error-var_03 ls_error-var_04
       INTO lv_message.

    CALL METHOD me->create_message_from_syst
      CHANGING
        co_message_handle = lo_message_handle.
  ENDLOOP.

  IF lo_message_handle IS BOUND.
    RAISE EXCEPTION lo_message_handle.
  ENDIF.
ENDMETHOD.


METHOD _values_check_on_posting.
  CHECK ms_transaction_cntrl-classification <> gc_classification-writeup_gain_loss. "2422399

  IF  ms_transaction_cntrl-no_prop_val_calc = abap_false.   "2231678
    CHECK ms_transaction_cntrl-classification <> gc_classification-retirement.
    CHECK ms_transaction_cntrl-classification <> gc_classification-transfer_ret.
    CHECK ms_transaction_cntrl-classification <> gc_classification-transfer_acq.
  ENDIF.

  CHECK ms_transaction_cntrl-classification <> gc_classification-down_payment.

  FIELD-SYMBOLS <ls_transaction>   TYPE ty_s_transaction.
  FIELD-SYMBOLS <ls_hlpseg>        TYPE ty_s_hlpseg.

  DATA lo_processing_handle        LIKE me.
  DATA lo_invsupport_handle        TYPE faa_dc_cfg_invsupport_handle.

  DATA lt_sumseg                   TYPE ty_t_sumseg.

  DATA ls_invsupport_key           TYPE faa_s_investment_support_key.
  DATA ls_yearseg                  TYPE ty_s_yearseg.
  DATA ls_timeseg                  TYPE ty_s_timeseg.
  DATA ls_sumseg                   TYPE ty_s_sumseg.

  DATA lv_max_amount               TYPE ty_s_yearseg-cum-apc.
  DATA lv_inv_amount               TYPE ty_s_yearseg-cum-apc.
  DATA lv_message                  TYPE string.

*----------------------------------------------------------------------------------*
* perform posting type independant check that relation to prior/current year is correct
*----------------------------------------------------------------------------------*
  CREATE OBJECT lo_processing_handle.

* take over posting date independant data
  lo_processing_handle->mo_start             = mo_start.
  lo_processing_handle->ms_proc_data         = ms_proc_data.
  lo_processing_handle->ms_asset_data        = ms_asset_data.
  lo_processing_handle->ms_transaction_cntrl = ms_transaction_cntrl.
  lo_processing_handle->mts_area             = mts_area.
  lo_processing_handle->mts_hlpseg           = mts_hlpseg.
  lo_processing_handle->mt_parameter         = mt_parameter.
* lo_processing_handle->mt_virtarea          = mt_virtarea.  "2189388
  lo_processing_handle->mt_areasign          = mt_areasign. "2189388
  lo_processing_handle->mt_rounding          = mt_rounding. "2189388
  lo_processing_handle->mt_period            = mt_period.
  lo_processing_handle->mt_yearseg           = mt_yearseg.
  lo_processing_handle->mt_timeseg           = mt_timeseg.
  lo_processing_handle->mt_sumseg            = mt_sumseg.

  lo_processing_handle->ms_proc_data-step    = gc_step-dc_int_check_py_cy_assignmnt.

  CLEAR lo_processing_handle->mo_start->mt_virtarea.

  IF ms_transaction_cntrl-is_current_yr EQ abap_true.
    MODIFY lo_processing_handle->mt_yearseg FROM ls_yearseg TRANSPORTING cum
     WHERE fyear = ms_transaction_cntrl-fyear.

    MODIFY lo_processing_handle->mt_sumseg FROM ls_sumseg TRANSPORTING prev_prev prev_cur
     WHERE fyear = ms_transaction_cntrl-fyear.

    MODIFY lo_processing_handle->mt_timeseg FROM ls_timeseg TRANSPORTING prev_prev prev_cur
     WHERE fyear = ms_transaction_cntrl-fyear.

  ELSE.
    MODIFY lo_processing_handle->mt_sumseg FROM ls_sumseg TRANSPORTING cur
     WHERE fyear = ms_transaction_cntrl-fyear.

    MODIFY lo_processing_handle->mt_timeseg FROM ls_timeseg TRANSPORTING cur
     WHERE fyear = ms_transaction_cntrl-fyear.
  ENDIF.

  CALL METHOD lo_processing_handle->_calcorder_create.
  CALL METHOD lo_processing_handle->_values_calculate.

*----------------------------------------------------------------------------------*
* perform dedicated checks on manual depreciation posting, write-up and
* investment support
*----------------------------------------------------------------------------------*
  CASE ms_transaction_cntrl-classification.

* check if manual depreciation posting is allowed
    WHEN gc_classification-depreciation.
      LOOP AT mt_transaction_post ASSIGNING <ls_transaction>.
        IF <ls_transaction>-prev_prev-depr_o <> 0 OR
           <ls_transaction>-prev_cur-depr_o  <> 0 OR
           <ls_transaction>-cur-depr_o       <> 0.

          READ TABLE mts_hlpseg  ASSIGNING <ls_hlpseg>
                WITH KEY fyear       = <ls_transaction>-fyear
                         area        = <ls_transaction>-area
                         amount_type = gc_amount_type-ordn.
          IF sy-subrc                                    = 0                AND
            <ls_hlpseg>-keyref->ms_settings-percent_key <> gc_percent-key_n AND
            <ls_hlpseg>-grp_asset_assgnd                 =  abap_false.

            MESSAGE e633(aa) WITH  <ls_hlpseg>-depr_key INTO lv_message.
            me->create_message_from_syst( ).
          ENDIF.
        ENDIF.

        IF <ls_transaction>-prev_prev-depr_s <> 0 OR
           <ls_transaction>-prev_cur-depr_s  <> 0 OR
           <ls_transaction>-cur-depr_s       <> 0.

          READ TABLE mts_hlpseg  ASSIGNING <ls_hlpseg>
                WITH KEY fyear       = <ls_transaction>-fyear
                         area        = <ls_transaction>-area
                         amount_type = gc_amount_type-spec.
          IF sy-subrc                                    = 0                AND
            <ls_hlpseg>-keyref->ms_settings-percent_key <> gc_percent-key_n AND
            <ls_hlpseg>-grp_asset_assgnd                 =  abap_false.
            MESSAGE e633(aa) WITH  <ls_hlpseg>-depr_key INTO lv_message.
            me->create_message_from_syst( ).
          ENDIF.
        ENDIF.
      ENDLOOP.

* check if write-up posting is allowed
    WHEN gc_classification-write_up.
      "-> Note 2351790: Everything is allowed for Write-Up
*      LOOP AT mt_transaction_post ASSIGNING <ls_transaction>
*        WHERE prev_prev-depr_o <> 0
*           OR prev_prev-depr_s <> 0
*           OR prev_prev-depr_u <> 0
*           OR prev_prev-resv   <> 0.
*
*        READ TABLE mt_yearseg  INTO ls_yearseg
*              WITH KEY fyear = <ls_transaction>-fyear
*                       area  = <ls_transaction>-area.
*        ASSERT sy-subrc = 0.
*
*        IF <ls_transaction>-prev_prev-depr_o <> 0.
*          ls_yearseg-cum-depr_o = ls_yearseg-cum-depr_o + <ls_transaction>-prev_prev-depr_o.
*          IF sign( ls_yearseg-cum-depr_o ) = sign( <ls_transaction>-prev_prev-depr_o ).
*            MESSAGE e634(aa) WITH ls_yearseg-area INTO lv_message.
*            me->create_message_from_syst( ).
*          ENDIF.
*        ENDIF.
*
*        IF <ls_transaction>-prev_prev-depr_s <> 0.
*          ls_yearseg-cum-depr_s = ls_yearseg-cum-depr_s + <ls_transaction>-prev_prev-depr_s.
*          IF sign( ls_yearseg-cum-depr_s ) = sign( <ls_transaction>-prev_prev-depr_s ).
*            MESSAGE e635(aa) WITH ls_yearseg-area INTO lv_message.
*            me->create_message_from_syst( ).
*          ENDIF.
*        ENDIF.
*
*        IF <ls_transaction>-prev_prev-depr_u <> 0.
*          ls_yearseg-cum-depr_u = ls_yearseg-cum-depr_u + <ls_transaction>-prev_prev-depr_u.
*          IF sign( ls_yearseg-cum-depr_u ) = sign( <ls_transaction>-prev_prev-depr_u ).
*            MESSAGE e636(aa) WITH ls_yearseg-area INTO lv_message.
*            me->create_message_from_syst( ).
*          ENDIF.
*        ENDIF.
*
*        IF <ls_transaction>-prev_prev-resv <> 0.
*          ls_yearseg-cum-resv = ls_yearseg-cum-resv + <ls_transaction>-prev_prev-resv.
*          IF sign( ls_yearseg-cum-resv ) = sign( <ls_transaction>-prev_prev-resv ).
*            MESSAGE e637(aa) WITH ls_yearseg-area INTO lv_message.
*            me->create_message_from_syst( ).
*          ENDIF.
*        ENDIF.
*      ENDLOOP.

* check max amount of investment support is not hurt
* - get sum of all investment supports for base area and in SUMSEG
* - get sum of all investment supports for area to carry the investment support in SUMSEG
* - plus the sum of APC of the base area for checking purposes
    WHEN gc_classification-inv_support.
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
        AT NEW area.
          CHECK  <ls_hlpseg>-invsupport_key IS NOT INITIAL.
          ls_invsupport_key = <ls_hlpseg>-invsupport_key.
          lo_invsupport_handle ?= cf_faa_cfg_investment_support=>find(
            EXPORTING
              id_leadobj_value  = <ls_hlpseg>-arearef->if_faa_cfg_leadobj~md_leadobj
              id_invsupport_key = ls_invsupport_key ).

* determine APC amounts of base area's for check and ensure that each base area is
* just considered once and note APC amounts of base area for investment support area
          LOOP AT mt_sumseg INTO ls_sumseg
            WHERE area = lo_invsupport_handle->mo_base_area->md_deprarea.

            READ TABLE lt_sumseg TRANSPORTING NO FIELDS
              WITH KEY area = ls_sumseg-area.

            IF sy-subrc <> 0.                               "2217313
              COLLECT ls_sumseg INTO lt_sumseg.
            ENDIF.                                          "2217313

* note APC amounts of base area from SUMSEG for investment support area
            IF lo_invsupport_handle->mo_invsupport_area->md_deprarea <> lo_invsupport_handle->mo_base_area->md_deprarea.
              ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->md_deprarea.
              COLLECT ls_sumseg INTO lt_sumseg.
            ENDIF.

            READ TABLE mt_yearseg INTO ls_yearseg
              WITH KEY area = lo_invsupport_handle->mo_base_area->md_deprarea.
            ASSERT sy-subrc = 0.

            CLEAR ls_sumseg-prev_cur.
            CLEAR ls_sumseg-cur.
            ls_sumseg-area      = ls_yearseg-area.
            ls_sumseg-prev_prev = ls_yearseg-cum.
            COLLECT ls_sumseg INTO lt_sumseg.

* note APC amount of base area from YEARSEG for investment support area
            IF lo_invsupport_handle->mo_invsupport_area->md_deprarea <> lo_invsupport_handle->mo_base_area->md_deprarea.
              ls_sumseg-area  = lo_invsupport_handle->mo_invsupport_area->md_deprarea.
              COLLECT ls_sumseg INTO lt_sumseg.
            ENDIF.
          ENDLOOP.

* determine sum of investment supports for investment support area and base area
          IF lo_invsupport_handle->mo_invsupport_area->msx_areadef-posting_type <> '0'. "2217313
            LOOP AT mt_sumseg INTO ls_sumseg
              WHERE area =  lo_invsupport_handle->mo_invsupport_area->md_deprarea
                AND area <> lo_invsupport_handle->mo_base_area->md_deprarea.

              COLLECT ls_sumseg INTO lt_sumseg.

* check if base area exists on asset to avoid error on pure investment support assets
              READ TABLE mt_yearseg TRANSPORTING NO FIELDS
                WITH KEY area = lo_invsupport_handle->mo_base_area->md_deprarea.

              CHECK sy-subrc = 0.
              ls_sumseg-area = lo_invsupport_handle->mo_base_area->md_deprarea.
              COLLECT ls_sumseg INTO lt_sumseg.
            ENDLOOP.
          ENDIF.                                            "2217313
        ENDAT.
      ENDLOOP.

* perform check
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
        AT NEW area.
          CHECK  <ls_hlpseg>-invsupport_key IS NOT INITIAL.
          ls_invsupport_key = <ls_hlpseg>-invsupport_key.
          lo_invsupport_handle ?= cf_faa_cfg_investment_support=>find(
            EXPORTING
              id_leadobj_value  = <ls_hlpseg>-arearef->if_faa_cfg_leadobj~md_leadobj
              id_invsupport_key = ls_invsupport_key ).

* determine maximum available APC amount and sum of investment support
          LOOP AT lt_sumseg INTO ls_sumseg
            WHERE area = lo_invsupport_handle->mo_base_area->md_deprarea
               OR area = lo_invsupport_handle->mo_invsupport_area->md_deprarea.

            DO 2 TIMES.
              CASE sy-index.
                WHEN 1.
                  lv_max_amount = ls_sumseg-prev_prev-apc.
                  lv_inv_amount = ls_sumseg-prev_prev-invs + ls_sumseg-prev_cur-invs.
                WHEN 2.
                  lv_max_amount = ls_sumseg-cur-apc.
                  lv_inv_amount = ls_sumseg-cur-invs.
              ENDCASE.

* consider settings of investment support measure
              IF ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->md_deprarea.
                IF lo_invsupport_handle->ms_settings-max_percentage IS NOT INITIAL.
                  lv_max_amount = lv_max_amount * lo_invsupport_handle->ms_settings-max_percentage / 100.
                ENDIF.

* if max amount defined and percentage => max amount wins
                IF lo_invsupport_handle->ms_settings-max_amount IS NOT INITIAL.
                  lv_max_amount = lo_invsupport_handle->ms_settings-max_amount.
                  lv_inv_amount = ls_sumseg-prev_prev-invs + ls_sumseg-prev_cur-invs + ls_sumseg-cur-invs.
                ENDIF.
              ENDIF.

              lv_max_amount = abs( lv_max_amount ).
              lv_inv_amount = abs( lv_inv_amount ).

* raise error message if (sum of) investment support exceeds the allowed maximum amount
              CHECK lv_inv_amount > lv_max_amount.

              CASE sy-index.
                WHEN 1.
                  IF ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->md_deprarea.
                    MESSAGE e789(aa) WITH ls_sumseg-area INTO lv_message.
                    me->create_message_from_syst( ).
                  ELSE.
                    MESSAGE e661(aa) WITH ls_sumseg-area INTO lv_message.
                    me->create_message_from_syst( ).
                  ENDIF.
                WHEN 2.
                  IF ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->md_deprarea.
                    MESSAGE e788(aa) WITH ls_sumseg-area INTO lv_message.
                    me->create_message_from_syst( ).
                  ELSE.
                    MESSAGE e661(aa) WITH ls_sumseg-area INTO lv_message.
                    me->create_message_from_syst( ).
                  ENDIF.
              ENDCASE.
            ENDDO.
          ENDLOOP.
        ENDAT.
      ENDLOOP.


* check revaluation is posted with correct transaction type and goes only to valid areas "2319261
    WHEN gc_classification-reval_manual_acq                 "2319261
      OR gc_classification-reval_o_depr
      OR gc_classification-revaluation.

      LOOP AT mt_transaction_post ASSIGNING <ls_transaction>
        WHERE prev_prev IS NOT INITIAL
           OR prev_cur  IS NOT INITIAL
           OR cur       IS NOT INITIAL.

* get depreciation are to check against
        READ TABLE ms_proc_data-leadobj_instance->mts_arearef ASSIGNING FIELD-SYMBOL(<ls_arearef>)
          WITH KEY key_depr_area COMPONENTS depr_area = <ls_transaction>-area. "<2351790

* if area posted to just carries revaluations get leading area of ledger group to check against
        IF <ls_arearef>-depr_area_ref->msx_areadef-sign_apc = '0'.
          READ TABLE ms_proc_data-leadobj_instance->mts_arearef ASSIGNING <ls_arearef> INDEX 1.
        ENDIF.

        READ TABLE mt_yearseg INTO ls_yearseg
          WITH KEY area = <ls_arearef>-depr_area.

        READ TABLE mt_sumseg INTO ls_sumseg
          WITH KEY area = <ls_arearef>-depr_area.

        IF sy-subrc <> 0.
          CLEAR ls_sumseg.
        ENDIF.

        ls_sumseg-prev_prev-apc    = ls_sumseg-prev_prev-apc    + ls_yearseg-cum-apc.
        ls_sumseg-prev_prev-depr_o = ls_sumseg-prev_prev-depr_o + ls_sumseg-prev_cur-depr_o + ls_yearseg-cum-depr_o.

        DO 1 TIMES.

* check that values are provided in correct amount fields
        IF <ls_transaction>-prev_prev IS NOT INITIAL.
          MESSAGE e679(aa) WITH ls_yearseg-area INTO lv_message.
          EXIT.
        ENDIF.

* if area is posted to it may not calc. replacement value
          LOOP AT mts_hlpseg TRANSPORTING NO FIELDS
            WHERE area = <ls_transaction>-area
              AND amount_type CA gc_amount_type(2).
          ENDLOOP.

* check correct transaction type used
          IF sy-subrc = 0.
            MESSAGE e628(aa) WITH ls_sumseg-area INTO lv_message.
            EXIT.
          ENDIF.

          IF ls_sumseg-prev_cur-revl <> 0 AND ls_sumseg-prev_prev-apc = 0.
            MESSAGE e629(aa) WITH ls_yearseg-area INTO lv_message.
            EXIT.
          ENDIF.

          IF ls_sumseg-cur-revl <> 0 AND ls_sumseg-cur-apc = 0.
            MESSAGE e629(aa) WITH ls_yearseg-area INTO lv_message.
            EXIT.
          ENDIF.

          IF ls_sumseg-prev_cur-revl_d <> 0 AND ls_sumseg-prev_prev-apc = 0. "2356024
            MESSAGE e629(aa) WITH ls_sumseg-area INTO lv_message.
            EXIT.
          ENDIF.

          IF ls_sumseg-cur-revl_d <> 0 AND ls_sumseg-cur-apc = 0. "2356024
            MESSAGE e629(aa) WITH ls_sumseg-area INTO lv_message.
            EXIT.
          ENDIF.
        ENDDO.

        IF lv_message IS NOT INITIAL.
          me->create_message_from_syst( ).
          RETURN.
        ENDIF.
      ENDLOOP.
  ENDCASE.

ENDMETHOD.


  METHOD _virtarea_create. "completely re-worked with note 2473643
    DATA ls_virt                    TYPE if_faa_dc_segments_720=>ty_s_virtarea.

    LOOP AT ms_proc_data-leadobj_instance->mts_arearef ASSIGNING FIELD-SYMBOL(<ls_arearef>).

* insure that only real virtual areas (which may influence depr.) are considered
      CHECK <ls_arearef>-depr_area_ref->is_real_area( )                                                               EQ space.
      CHECK <ls_arearef>-depr_area_ref->if_faa_cfg_leadobj~is_active( id_setting = faabc_setting-reporting_deprarea ) EQ abap_false.
      CHECK <ls_arearef>-depr_area_ref->msx_areadef-area_usage_ind                                                    NE 1.

      LOOP AT <ls_arearef>-depr_area_ref->msx_areadef-derive_tab ASSIGNING FIELD-SYMBOL(<ls_virtarea>).

* insure that virtual area is only calc. when all base areas exist
        READ TABLE mts_hlpseg ASSIGNING FIELD-SYMBOL(<ls_hlpseg>)
              WITH KEY area  = <ls_virtarea>-depr_area_ref->md_deprarea.

        IF sy-subrc <> 0.
          DELETE me->mt_virtarea
           WHERE virt_area = <ls_arearef>-depr_area.
          EXIT.
        ENDIF.

* ensure that all assigned base areas have the same count of calculation periods
        AT FIRST.
          DATA(lv_periods) = <ls_hlpseg>-periods_short_fy.
        ENDAT.

        IF lv_periods NE <ls_hlpseg>-periods_short_fy.
          MESSAGE e087(aa) INTO DATA(lv_message) WITH <ls_hlpseg>-area.
          me->create_message_from_syst( ).
        ENDIF.

        ls_virt-real_area = <ls_virtarea>-depr_area_ref->md_deprarea.

        ls_virt-virt_area = <ls_arearef>-depr_area.

        ls_virt-prop_part = <ls_virtarea>-proportion.

        IF <ls_virtarea>-sign = if_faa_dc_segments_720_c=>gc_area_value_sign-negative.
          ls_virt-prop_part = - <ls_virtarea>-proportion.
        ENDIF.

*     Insert adjustment areas as the first entry for each virtual area
        IF <ls_virtarea>-depr_area_ref->md_deprarea EQ <ls_arearef>-depr_area_ref->msx_areadef-adjustment_area.
          READ TABLE me->mt_virtarea WITH KEY virt_area = <ls_arearef>-depr_area_ref->md_deprarea TRANSPORTING NO FIELDS.

          IF sy-subrc = 0.
            INSERT ls_virt INTO me->mt_virtarea INDEX sy-tabix.
          ELSE.
            APPEND ls_virt TO me->mt_virtarea.
          ENDIF.
        ELSE.
          APPEND ls_virt TO me->mt_virtarea.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.


METHOD _yearseg_create.
  FIELD-SYMBOLS <ls_calcamount>     TYPE ty_s_calcamount.
  FIELD-SYMBOLS <ls_yearseg>        TYPE ty_s_yearseg.
  FIELD-SYMBOLS <ls_sumseg>         TYPE ty_s_sumseg.

* create YEARSEG for first fiscal year to be calculated
  IF mo_previous IS INITIAL.
    mt_yearseg = ms_asset_data-t_cum_values.

* create YEARSEG for sub-sequent fiscal year to be calculated
  ELSE.
    mt_yearseg[] = mo_previous->mt_yearseg[].

    LOOP AT mt_yearseg ASSIGNING <ls_yearseg>.
      <ls_yearseg>-fyear       = <ls_yearseg>-fyear + 1.
      READ TABLE mo_previous->mts_calcamount ASSIGNING <ls_calcamount>
            WITH KEY area = <ls_yearseg>-area.

      IF sy-subrc = 0.
        <ls_yearseg>-cum-revl   = <ls_yearseg>-cum-revl   + <ls_calcamount>-total-revl.
        <ls_yearseg>-cum-depr_o = <ls_yearseg>-cum-depr_o + <ls_calcamount>-total-depr_o.
        <ls_yearseg>-cum-depr_s = <ls_yearseg>-cum-depr_s + <ls_calcamount>-total-depr_s.
        <ls_yearseg>-cum-depr_u = <ls_yearseg>-cum-depr_u + <ls_calcamount>-total-depr_u.
        <ls_yearseg>-cum-resv   = <ls_yearseg>-cum-resv   + <ls_calcamount>-total-resv.
        <ls_yearseg>-cum-intr   = <ls_yearseg>-cum-intr   + <ls_calcamount>-total-intr.
        <ls_yearseg>-cum-revl_d = <ls_yearseg>-cum-revl_d + <ls_calcamount>-total-revl_d.
      ENDIF.

      READ TABLE mo_previous->mt_sumseg ASSIGNING <ls_sumseg>
          WITH KEY area = <ls_yearseg>-area.

      IF sy-subrc = 0.
        <ls_yearseg>-cum-apc    = <ls_yearseg>-cum-apc
                                + <ls_sumseg>-cur-apc
                                + <ls_sumseg>-prev_prev-apc.

        <ls_yearseg>-cum-downp  = <ls_yearseg>-cum-downp
                                + <ls_sumseg>-cur-downp
                                + <ls_sumseg>-prev_prev-downp.

        <ls_yearseg>-cum-invs   = <ls_yearseg>-cum-invs
                                + <ls_sumseg>-cur-invs
                                + <ls_sumseg>-prev_prev-invs.

        <ls_yearseg>-cum-revl   = <ls_yearseg>-cum-revl
                                + <ls_sumseg>-cur-revl
                                + <ls_sumseg>-prev_prev-revl
                                + <ls_sumseg>-prev_cur-revl.

        <ls_yearseg>-cum-revl_d = <ls_yearseg>-cum-revl_d
                                + <ls_sumseg>-cur-revl_d
                                + <ls_sumseg>-prev_prev-revl_d
                                + <ls_sumseg>-prev_cur-revl_d.

        <ls_yearseg>-cum-depr_o = <ls_yearseg>-cum-depr_o
                                + <ls_sumseg>-cur-depr_o
                                + <ls_sumseg>-prev_prev-depr_o
                                + <ls_sumseg>-prev_cur-depr_o.

        <ls_yearseg>-cum-depr_s = <ls_yearseg>-cum-depr_s
                                + <ls_sumseg>-cur-depr_s
                                + <ls_sumseg>-prev_prev-depr_s
                                + <ls_sumseg>-prev_cur-depr_s.

        <ls_yearseg>-cum-depr_u = <ls_yearseg>-cum-depr_u
                                + <ls_sumseg>-cur-depr_u
                                + <ls_sumseg>-prev_prev-depr_u
                                + <ls_sumseg>-prev_cur-depr_u.

        <ls_yearseg>-cum-resv   = <ls_yearseg>-cum-resv
                                + <ls_sumseg>-cur-resv
                                + <ls_sumseg>-prev_prev-resv
                                + <ls_sumseg>-prev_cur-resv.

        <ls_yearseg>-cum-apc_ret_ia = <ls_yearseg>-cum-apc_ret_ia "2193614
                                    + <ls_sumseg>-cur-apc_ret_ia
                                    + <ls_sumseg>-prev_prev-apc_ret_ia.
      ENDIF.
    ENDLOOP.

  ENDIF.
ENDMETHOD.
ENDCLASS.