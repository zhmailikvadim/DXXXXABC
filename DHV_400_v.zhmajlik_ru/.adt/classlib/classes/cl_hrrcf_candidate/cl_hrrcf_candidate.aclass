class CL_HRRCF_CANDIDATE definition
  public
  inheriting from CL_HRRCF_SIMPLE_MAIN_OBJECT
  final
  create public

  global friends CL_HRRCF_DELETE_MANAGER
                 CL_HRRCF_SIMPLE_MAIN_OBJECT .

public section.

  constants MY_CLASSNAME type RCF_CLASSNAME value 'CL_HRRCF_CANDIDATE'. "#EC NOTEXT
  data PERSONID type PERSONID read-only .
  data CENTRALDATAPERSON type BAPIBUS1006_CENTRAL_PERSON read-only .
  data CENTRALDATA type BAPIBUS1006_CENTRAL read-only .
  data PARTNER type BU_PARTNER read-only .
  data USER type SYUNAME read-only .
  data EMPLOYEEID type PERNR_D read-only .
  constants MY_OTYPE type OTYPE value 'NA'. "#EC NOTEXT

  methods CHANGE_CP_US_NAME
    importing
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  class CL_HRRCF_CANDIDATE_ADMIN_BL definition load .
  methods GET_EMPLOYEE_ID
    importing
      !IV_ASSURE_ACTIVE_PERNR type BOOLE_D default CL_HRRCF_CANDIDATE_ADMIN_BL=>SV_ASSURE_ACTIVE_PERNR_BY_DFLT
    returning
      value(RV_EMPLOYEE_ID) type PERNR_D .
  methods GET_EMPLOYEE_IDS
    importing
      !IV_KEYDATE type DATUM default SY-DATUM
    exporting
      !ET_ACTIVE_ID type RCF_T_PERNR
      !ET_INACTIVE_ID type RCF_T_PERNR
      !EV_LATEST_ACTIVE_ID type PERNR_D
      !EV_LATEST_INACTIVE_ID type PERNR_D
      !EV_EARLIEST_ACTIVE_ID type PERNR_D
      !EV_EARLIEST_INACTIVE_ID type PERNR_D
    raising
      CX_HRRCF .
  methods ADD_ROLE_TO_BUPA
    importing
      !BUSINESSPARTNER type BU_PARTNER
      !BUSINESSPARTNERROLE type BU_ROLE
    exporting
      !RETURN type BAPIRET2_T .
  methods ASSIGN_APPLICATION
    importing
      !APPLICATION type ref to CL_HRRCF_CANDIDATE_APPLICATION
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods ASSIGN_CANDIDACY
    importing
      !CANDIDACY type ref to CL_HRRCF_CANDIDACY
    raising
      CX_HRRCF .
  methods ASSIGN_EMPLOYEE
    importing
      !EMPLOYEEID type HROBJID
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods ASSIGN_TG
    importing
      !TALENT_GROUP type ref to CL_HRRCF_TG
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods ASSIGN_USER
    importing
      !USERID type XUBNAME
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods CHANGE_EMAIL
    importing
      !E_MAIL type AD_SMTPADR
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  methods CHANGE_PERSONAL_DATA
    importing
      !CENTRALDATAPERSON type BAPIBUS1006_CENTRAL_PERSON optional
      !CENTRALDATA type BAPIBUS1006_CENTRAL optional
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  methods CHANGE_USER_ROLE
    importing
      !ROLE type RCF_ROLE
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF_CUSTOMIZING .
  methods COPY_BP_DATA
    importing
      !PARTNER type BU_PARTNER
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CREATE
    importing
      !CENTRALDATAPERSON type BAPIBUS1006_CENTRAL_PERSON
      !CENTRALDATA type BAPIBUS1006_CENTRAL
      !PERSONID type PERSONID optional
      !EMAIL type RCF_S_EMAILDATA_BP optional
      !PARTNER type BU_PARTNER optional
      !EMPLOYEEID type HROBJID optional
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !CANDIDATE type ref to CL_HRRCF_CANDIDATE
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF .
  methods DELETE_EMAIL_REFERENCE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  methods DELIMIT_EMPLOYEE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods EXCHANGE_CP_WITH_HR
    importing
      !EMPLOYEEID type HROBJID
      !PARTNERID type BU_PARTNER optional
    raising
      CX_HRRCF .
  class-methods GET
    importing
      !PERSONID type HROBJID optional
      !PARTNER type BU_PARTNER optional
      !USER type SYUNAME optional
      !ALIAS type BAPIALIAS optional
      !ID type HROBJID optional
      !EMPLOYEEID type HROBJID optional
    exporting
      !CANDIDATE type ref to CL_HRRCF_CANDIDATE
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods GET_APPLICATIONS
    exporting
      !APPLICATION_LIST type RCF_T_APPLICATION
    raising
      CX_HRRCF .
  methods GET_ASSIGNED_JOB_FAMILIES
    importing
      !IV_LANGU type LANGU
    exporting
      !ET_JOB_FAMILIES type RCF_T_JOB_FAMILY_POTENTIAL
    raising
      CX_HRRCF .
  methods GET_CANDIDACY
    exporting
      !CANDIDACY_LIST type RCF_T_CANDIDACY
    raising
      CX_HRRCF .
  methods GET_CANDIDATE_STATUS
    importing
      !P_DATE type DATS default SY-DATUM
      !P_LANGU type SY-LANGU default SY-LANGU
    exporting
      !P_STATUS type RCF_CAND_STATUS
      !P_STATUS_TXT type DDTEXT
    raising
      CX_HRRCF .
  methods GET_CAND_ALIAS
    returning
      value(PS_ALIAS) type BAPIALIAS .
  methods GET_CAND_DESCRIPTION
    exporting
      !CAND_DESCRIPTION type BU_DESCRIP
    raising
      CX_HRRCF .
  methods GET_CAND_RESUME_FOR_AUDIT
    importing
      !P_DATE type DATS default SY-DATUM
      !P_LANGUAGE type SPRAS default SY-LANGU
    exporting
      !PS_CAND_RESUME type RCF_S_CAND_RESUME_AUDIT
    raising
      CX_HRRCF .
  methods GET_CURRENT_BP_DATA
    importing
      !P_PARTNER type BU_PARTNER
    exporting
      !PT_EMAIL type RCF_T_EMAILDATA_BP
      !PT_FAX type RCF_T_FAXDATA_BP
      !PT_TELEFONE type RCF_T_TELEFONDATA_BP
      !PT_ADDRESS type RCF_T_ADDRESSDATA_BP
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods GET_NOTES
    exporting
      !ET_NOTES type RCF_T_CAND_NOTES .
  methods GET_PERSONID_EXTERNAL
    returning
      value(R_PERSONID_EXTERNAL) type PERSONID_EXT_ABA .
  methods GET_PERSONNEL_ASSIGNMENTS
    returning
      value(ET_PERSONNEL_ASSIGNMENTS) type RCF_T_PERNR .
  methods GET_TG
    exporting
      !TG_LIST type RCF_T_TG
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods GET_TG_WITH_PERIOD
    exporting
      !TG_LIST type RCF_T_TG_WITH_PERIOD
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods INSERT_NOTE
    importing
      !IV_NOTE type STRING
    raising
      CX_HRRCF .
  class-methods INSTANTIATE_CANDIDATES
    importing
      !PT_IBUPARTNER type RCF_T_BU_PARTNER
    exporting
      !PT_EBUPARTNER type RCF_T_BU_PARTNER .
  class-methods IS_CANDIDATE
    importing
      !PARTNER type BU_PARTNER
    returning
      value(IS_CANDIDATE) type BOOLE_D
    raising
      CX_HRRCF .
  methods IS_DEREGISTERED
    returning
      value(P_DEREGISTERED) type BOOLE_D
    raising
      CX_HRRCF .
  methods IS_EMPLOYEE
    returning
      value(RETURN) type BOOLE_D .
  class-methods IS_INACTIVE_EMPLOYEE
    importing
      !P_HROBJECT type HROBJECT
    returning
      value(P_IS_INACTIVE) type BOOLE_D
    raising
      CX_HRRCF .
  methods LEGAL_CHECK_BEFORE_DELETE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods LOCK_SYSTEM_USER
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF_RFC_COMMUNICATION .
  methods NEW_PASSWORD_REQUESTED
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  methods REMOVE_ROLE_FROM_BUPA
    importing
      !BUSINESSPARTNER type BU_PARTNER
      !BUSINESSPARTNERROLE type BU_ROLE
    exporting
      !RETURN type BAPIRET2_T .
  methods NEW_VERIF_MAIL_REQUESTED
    importing
      !IV_APPL_EXISTS type BOOLE_D
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  methods SEND_NEW_PASSWORD
    importing
      !ACTIVITY_TYPE type RCF_ACT_TYPE
    raising
      CX_HRRCF .
  methods SEND_NEW_VERIF_MAIL
    importing
      !IV_ACTIVITY_TYPE type RCF_ACT_TYPE
    raising
      CX_HRRCF .
  methods UPDATE_EREC_US_FOR_IT0105_US
    importing
      !IT_1001_CP_US type P1001TAB
      !IV_EREC_GEN_USER type XUBNAME
    exporting
      !EV_USER type XUBNAME
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods UPDATE_EREC_US_FOR_IT5585_US
    importing
      !IT_1001_CP_US type P1001TAB
      !IV_EREC_GEN_USER type XUBNAME
      !IS_IT5585_USER type P1001
    exporting
      !EV_USER type XUBNAME
    raising
      CX_HRRCF_INFOTYPE_OPERATION .

  methods DELETE
    redefinition .
protected section.

  methods CHECK_BEFORE_DELETE
    redefinition .
  methods ON_BUFFER_REFRESH
    redefinition .
private section.

*"* private components of class CL_HRRCF_CANDIDATE
*"* do not include other source files here!!!
  data GT_EMPLOYEEID type RCF_T_PERNR .
  data PERSONID_EXTERNAL type PERSONID_EXT_ABA .
  class-data LOCAL_DIRECTORY type RCF_T_CANDIDATE .
  class-data NAMCOUNTRY type BAPIBUS1006_CENTRAL_PERSON-NAMCOUNTRY .
  class-data NAMEFORMAT type BAPIBUS1006_CENTRAL_PERSON-NAMEFORMAT .
  class-data NAMEFORMAT_READ type BOOLE_D .
  class-data LOCAL_DIR_CE_SUPPL type RCF_T_EMPL_PERS .

  class-methods FILL_OBJECT_BUFFER_CP
    importing
      !PT_1000 type RCF_T_HROBJECT .
  class-methods FILL_OBJECT_BUFFER_NA
    importing
      !PT_1000 type RCF_T_HROBJECT .
  methods GET_ALL_COMM_CHANNELS
    exporting
      !P_ADDR_CHANNEL type RCF_COMM_CHANNEL
      !P_TEL_CHANNEL type RCF_COMM_CHANNEL
      !P_FAX_CHANNEL type RCF_COMM_CHANNEL
      !P_EMAIL_CHANNEL type RCF_COMM_CHANNEL
    raising
      CX_HRRCF .
  methods GET_BUPA_PARTNERID
    importing
      !PS_IHROBJECT type HROBJECT
    returning
      value(PV_PARTNERID) type BU_PARTNER .
  methods GET_OLD_COMM_DATA
    importing
      !PT_5110 type RCF_T_CONTACT_RULES
      !P_PARTNER type BU_PARTNER
    exporting
      !PT_EMAIL type RCF_T_EMAILDATA_BP
      !PT_FAX type RCF_T_FAXDATA_BP
      !PT_TELEFONE type RCF_T_TELEFONDATA_BP
      !PT_ADDRESS type RCF_T_ADDRESSDATA_BP
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods SET_BP_ATTRIBUTES_INTERNAL
    importing
      !PARTNER type BU_PARTNER
    raising
      CX_HRRCF_MAINTAIN_OBJECT .
  methods SET_OBJECT_IDS_INTERNAL
    importing
      !PERSONID type PERSONID
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF_INFOTYPE_OPERATION .
  methods SET_PARTNER_ID
    importing
      !PERSONID type PERSONID
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF_INFOTYPE_OPERATION .
  methods SET_PERSONID_EXTERNAL
    importing
      !I_PERSONID type PERSONID
      !I_EMPLOYEEID type PERNR_D
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
ENDCLASS.



CLASS CL_HRRCF_CANDIDATE IMPLEMENTATION.


METHOD add_role_to_bupa.
****************************************************
* Method Copy of FUBA BAPI_BUPA_ROLE_ADD************
****************************************************

  DATA:
    lt_return     TYPE STANDARD TABLE OF bapiret2,
    lt_return2    TYPE STANDARD TABLE OF bapiret2, "WAR2088465
    ls_return     TYPE bapiret2.

  CALL FUNCTION 'BUPA_ROLE_EXISTENCE_CHECK_2'    "WAR2088465
    EXPORTING
      IV_PARTNER                   = businesspartner
*     IV_PARTNER_GUID              =
*     IV_PARTNERROLECATEGORY       =
*     IV_X_ALL_PARTNERROLES        = ' '
      IV_PARTNERROLE               = businesspartnerrole
*     IV_DIFFTYPEVALUE             =
*     IV_DATE                      = SY-DATLO
    TABLES
      ET_RETURN                    = lt_return2.

  IF cl_hrrcf_simple_main_object=>luw_mode EQ true. "{WGY2088465
*------ Vorgangsprüfung ------------------------------------------------
    CALL FUNCTION 'BUPA_ACT_ANALYZE_FOR_BAPI'
      EXPORTING
        iv_bp_number = businesspartner
        iv_activity  = 'CHAN'
      TABLES
        ct_results   = lt_return.

*------ Internen Funktionsbaustein aufrufen, wenn Rückgabe aus ---------
*------ Vorgangsprüfung weder Messagetyp E od. A               ---------
    LOOP AT lt_return TRANSPORTING NO FIELDS WHERE type CA 'AE'  .
      EXIT.
    ENDLOOP.

    IF sy-subrc NE 0 AND                         "}WGY2088465
       NOT lt_return2[] IS INITIAL.              "WAR2088465
      CALL FUNCTION 'BUPA_ROLE_ADD_2'
        EXPORTING
          iv_partner       = businesspartner
          iv_partnerrole   = businesspartnerrole
          iv_x_save        = space
        TABLES
          et_return        = return.
    ENDIF.

  ELSEIF NOT lt_return2[] IS INITIAL.            "WAR2088465
    CALL FUNCTION 'BAPI_BUPA_ROLE_ADD'           "WGY2088465
      EXPORTING
        businesspartner     = businesspartner
        businesspartnerrole = businesspartnerrole
      TABLES
        return              = return.
  ENDIF.

*------ Ergebnis der Vergangsprüfung an Return-Parameter anhängen ------
  LOOP AT lt_return INTO ls_return.
    COLLECT ls_return INTO return.
  ENDLOOP.

ENDMETHOD.


METHOD ASSIGN_APPLICATION .

  CONSTANTS c_rsign TYPE p1001-rsign VALUE 'A'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '651'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA l_plvar TYPE plvar.

  DATA ls_return TYPE bapiret2.

  IF NOT application IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = me->hrobject-plvar.
    ls_relation-otype = me->hrobject-otype.
    ls_relation-objid = me->hrobject-objid.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = c_rsign.
    ls_relation-relat = c_relat.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
    ls_relation-sclas = application->hrobject-otype.
    ls_relation-sobid = application->id.
    APPEND ls_relation TO lt_relation.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
        authy               = space
      TABLES
        innnn               = lt_relation
      EXCEPTIONS
        no_authorization    = 0
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_insert
          hrobject = me->hrobject
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.
  ENDIF.

  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


method ASSIGN_CANDIDACY .

  CONSTANTS c_rsign TYPE p1001-rsign VALUE 'A'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '656'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA l_plvar TYPE plvar.

  DATA ls_return TYPE bapiret2.

  IF NOT candidacy IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = me->hrobject-plvar.
    ls_relation-otype = me->hrobject-otype.
    ls_relation-objid = me->hrobject-objid.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = c_rsign.
    ls_relation-relat = c_relat.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
    ls_relation-sclas = candidacy->hrobject-otype.
    ls_relation-sobid = candidacy->id.
    APPEND ls_relation TO lt_relation.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
        authy               = space
      TABLES
        innnn               = lt_relation
      EXCEPTIONS
        no_authorization    = 0
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_insert
          hrobject = me->hrobject
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

  ENDIF.

  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

endmethod.


METHOD assign_employee .
* Idea:
*   Read P--CP-relation of provided employeeid
*   If one entry exist check if me->personid is the same CP-ID
*   If no relation exists create a new one
* Remark: The correction should avoid splits in HRP1001 regarding P--CP

  CONSTANTS c_rsign_b      TYPE rsign  VALUE 'B'.
  CONSTANTS c_relat        TYPE relat  VALUE '209'.
  CONSTANTS c_sclas_p      TYPE sclas  VALUE 'P'.
  CONSTANTS c_sclas_cp     TYPE sclas  VALUE 'CP'.
  CONSTANTS c_check_subtyp TYPE subtyp VALUE 'A209'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA: l_plvar TYPE plvar,
        l_commit_flg TYPE hrrhap-commit_flg.

  DATA ls_return TYPE bapiret2.
  DATA lt_return TYPE TABLE OF bapiret2.

  DATA: lv_dummy_message   TYPE string.                     "#EC NEEDED

* role for employees
  DATA employee_role TYPE bu_role.

  IF NOT employeeid IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    CALL FUNCTION 'RH_READ_INFTY'
      EXPORTING
        authority            = space
        infty                = '1001'
        istat                = '1'
        subty                = c_check_subtyp
        plvar                = l_plvar
        otype                = c_sclas_p
        objid                = employeeid
      TABLES
        innnn                = lt_relation
      EXCEPTIONS
        all_infty_with_subty = 1
        nothing_found        = 0
        no_objects           = 3
        wrong_condition      = 4
        OTHERS               = 5.
    IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
          hrobject = me->hrobject
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    DELETE lt_relation WHERE sclas NE c_sclas_cp.
    IF NOT lt_relation IS INITIAL.
      READ TABLE lt_relation INTO ls_relation INDEX 1.
      IF NOT me->personid EQ ls_relation-sobid.

        "Mitarbeiternummer &1 ist bereits einem anderen Kandidaten zugeordnet
        MESSAGE e045(hrrcf0001) WITH employeeid            "MELN1488605
                                     me->id
                                     ls_relation-sobid
                                INTO lv_dummy_message.

        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>different_central_person
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3.

      ELSE.
*       No action necessary, since candidate and employee are assigned to the
*       same personid and the relation CP--P already exists on DB
      ENDIF.
    ELSE.
*     No P--CP-relation on DB ==> create one
      CLEAR ls_relation.
      ls_relation-mandt = sy-mandt.
      ls_relation-plvar = l_plvar.
      ls_relation-otype = c_sclas_cp.
      ls_relation-objid = me->personid.
      ls_relation-infty = '1001'.
      ls_relation-istat = '1'.
      ls_relation-rsign = c_rsign_b.
      ls_relation-relat = c_relat.
      ls_relation-begda = sy-datum.
      ls_relation-endda = if_hrrcf_constants~high_date."'99991231'.
      ls_relation-sclas = c_sclas_p.
      ls_relation-sobid = employeeid.
      APPEND ls_relation TO lt_relation.

* Added a check for external commit work
      IF external_commit IS INITIAL.
        l_commit_flg = 'X'.
      ELSE.
        l_commit_flg = ' '.
      ENDIF.

      CALL FUNCTION 'RH_INSERT_INFTY'
        EXPORTING
          vtask               = 'D'
          authy               = space
          commit_flg          = l_commit_flg
        TABLES
          innnn               = lt_relation
        EXCEPTIONS
          no_authorization    = 0
          error_during_insert = 2
          repid_form_initial  = 3
          corr_exit           = 4
          begda_greater_endda = 5
          OTHERS              = 6.
      IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.
      ENDIF.
    ENDIF.

    IF me->employeeid CO ' 0'.
      CALL FUNCTION 'BP_BUPA_GETEMPLOYEEROLE'
        IMPORTING
          ev_employeerole = employee_role.
*   tell BUPA that HR is calling
      CALL FUNCTION 'BUPA_CALL_BY_HR'
        EXPORTING
          iv_call_by_hr = 'X'.
*       Add employee role
**     FUBA BAPI_BUPA_ROLE_ADD has benn remplaced by *****
**     method ADD_ROLE_TO_BUPA  becouse it was not *******
**     possible to pass the value EXTERNAL_COMMIT*********
**********************************************************
      CALL METHOD me->add_role_to_bupa           "WAR1495307,1566689
        EXPORTING
          businesspartner     = me->partner
          businesspartnerrole = employee_role
        IMPORTING                                "WAR1566689
          return              = lt_return.       "WAR1566689
*      CALL FUNCTION 'BAPI_BUPA_ROLE_ADD'         "1228153
*        EXPORTING
*          businesspartner     = me->partner
*          businesspartnerrole = employee_role.
*--- do not care on any business partner lock -------------------------
      IF NOT me->partner IS INITIAL.
        CALL FUNCTION 'BUPA_DEQUEUE'
          EXPORTING
            iv_partner = me->partner
          TABLES
            et_return  = lt_return.
        CLEAR lt_return.
      ENDIF.
      IF NOT external_commit = true.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'  "XDP
          EXPORTING                              "neccessary because of
            wait          = 'X'.                 "User and business partner
      ENDIF.
    ENDIF.
    me->employeeid = employeeid.
  ENDIF.

  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD assign_tg.

  CONSTANTS c_rsign TYPE p1001-rsign VALUE 'A'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '658'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA l_plvar TYPE plvar.

  DATA ls_return TYPE bapiret2.

  DATA lo_exception TYPE REF TO cx_hrrcf .

  IF NOT talent_group IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = me->hrobject-plvar.
    ls_relation-otype = me->hrobject-otype.
    ls_relation-objid = me->hrobject-objid.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = c_rsign.
    ls_relation-relat = c_relat.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
    ls_relation-sclas = talent_group->hrobject-otype.
    ls_relation-sobid = talent_group->id.
    APPEND ls_relation TO lt_relation.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
        authy               = space
      TABLES
        innnn               = lt_relation
      EXCEPTIONS
        no_authorization    = 0
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_insert
          hrobject = me->hrobject
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

  ENDIF.

  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

* Insert into change pointer table for SP
  TRY.
      CALL METHOD cl_hrrcf_spt_change_pointer=>insert_change_pointer
        EXPORTING
          hrobject = me->hrobject.
    CATCH cx_hrrcf INTO lo_exception.
*     we write the log and continue the program logic
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.
ENDMETHOD.


METHOD assign_user .

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE p1001.
  DATA ls_record   TYPE wplog.
  DATA l_plvar     TYPE plvar.

  IF NOT userid IS INITIAL.
***********************************************
* User zuordnen

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = l_plvar.
    ls_relation-otype = 'CP'.
    ls_relation-objid =  me->personid.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = 'B'.
    ls_relation-relat = '208'.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
    ls_relation-sclas = 'US'.
    ls_relation-sobid = userid.
    APPEND ls_relation TO lt_relation.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
        commit_flg          = space              "WAR1540502
        authy               = space
      TABLES
        innnn               = lt_relation
      EXCEPTIONS                           "force short dump
        no_authorization    = 1
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    IF NOT sy-subrc = 0.
      CALL METHOD cl_hrrcf_infotype=>pnnnn_to_wplog
        EXPORTING
          pnnnn = ls_relation
        IMPORTING
          wplog = ls_record.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_insert
          hrobject = me->hrobject
          infotype = ls_record
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    me->user = userid.

  ENDIF.
  IF external_commit EQ false.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
  ENDIF.

  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


method CHANGE_CP_US_NAME.                        "WAR2324710

  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lt_return    TYPE TABLE OF bapiret2.
  DATA lt_p1000     TYPE TABLE OF p1000.
  DATA ls_p1000     LIKE LINE OF lt_p1000.
  DATA ls_p1000_2   LIKE LINE OF lt_p1000.
  DATA lt_obj       TYPE RCF_T_HROBJECT.
  DATA ls_obj       LIKE LINE OF lt_obj.
  DATA ls_address   TYPE bapiaddr3.
  DATA ls_address_2 TYPE bapiaddr3.
  DATA ls_address_x TYPE bapiaddr3x.
  DATA ls_return    TYPE bapiret2.
  DATA lv_plvar     TYPE plvar.

  CLEAR return.

  TRY .

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = lv_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

*   adjust CP (SHORT, STEXT)
    CLEAR: lt_p1000,  lt_obj[].
    ls_obj-plvar = lv_plvar.
    ls_obj-otype = 'CP'.
    ls_obj-objid = me->personid.
    APPEND ls_obj TO lt_obj.

    CALL FUNCTION 'RH_READ_INFTY_1000'
      EXPORTING
        AUTHORITY              = space
        WITH_STRU_AUTH         = space
        BEGDA                  = sy-datum
        ENDDA                  = sy-datum
      TABLES
        i1000                  = lt_p1000
        OBJECTS                = lt_obj
      EXCEPTIONS
        NOTHING_FOUND          = 1
        WRONG_CONDITION        = 2
        WRONG_PARAMETERS       = 3
        OTHERS                 = 4.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

    READ TABLE lt_p1000 INTO ls_p1000 INDEX 1.
    CONCATENATE me->centraldataperson-firstname
                me->centraldataperson-lastname
           INTO ls_p1000_2-stext
      SEPARATED BY space.
    IF ls_p1000-stext NE ls_p1000_2-stext OR
       ls_p1000-short NE me->centraldataperson-lastname.
      ls_p1000-stext = ls_p1000_2-stext.
      ls_p1000-short = me->centraldataperson-lastname.
      CLEAR lt_p1000.
      APPEND ls_p1000 TO lt_p1000.

      CALL FUNCTION 'RH_UPDATE_INFTY'
        EXPORTING
          vtask                     = 'D'
          commit_flg                = space
          AUTHY                     = space
        TABLES
          innnn                     = lt_p1000
        EXCEPTIONS
          ERROR_DURING_UPDATE       = 1
          NO_AUTHORIZATION          = 2
          REPID_FORM_INITIAL        = 3
          CORR_EXIT                 = 4
          OTHERS                    = 5.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.
    ENDIF.

*   adjust user name
    IF NOT me->user IS INITIAL.

      CALL FUNCTION 'BAPI_USER_EXISTENCE_CHECK'
        EXPORTING
          username = me->user
        IMPORTING
          return   = ls_return.

      IF ls_return-number = '088'.          "MSGNO 088 -> User exists

        CLEAR: ls_address, ls_address_2.

        CALL FUNCTION 'BAPI_USER_GET_DETAIL'
          EXPORTING
            username             = me->user
          IMPORTING
            ADDRESS              = ls_address_2
          TABLES
            return               = lt_return.

        DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
        IF NOT lt_return IS INITIAL.
          APPEND LINES OF lt_return TO return.
          CLEAR lt_return.
        ENDIF.

        MOVE-CORRESPONDING me->centraldataperson TO ls_address.
        ls_address-birth_name = me->centraldataperson-birthname.

        IF ls_address_2-title_p    NE ls_address-title_p    OR
           ls_address_2-firstname  NE ls_address-firstname  OR
           ls_address_2-lastname   NE ls_address-lastname   OR
           ls_address_2-birth_name NE ls_address-birth_name OR
           ls_address_2-middlename NE ls_address-middlename OR
           ls_address_2-secondname NE ls_address-secondname OR
           ls_address_2-title_aca1 NE ls_address-title_aca1 OR
           ls_address_2-title_aca2 NE ls_address-title_aca2 OR
           ls_address_2-prefix1    NE ls_address-prefix1    OR
           ls_address_2-prefix2    NE ls_address-prefix2    OR
           ls_address_2-title_sppl NE ls_address-title_sppl OR
           ls_address_2-nickname   NE ls_address-nickname   OR
           ls_address_2-initials   NE ls_address-initials   OR
           ls_address_2-nameformat NE ls_address-nameformat OR
           ls_address_2-namcountry NE ls_address-namcountry.

          ls_address_x-title_p    = true.
          ls_address_x-firstname  = true.
          ls_address_x-lastname   = true.
          ls_address_x-birth_name = true.
          ls_address_x-middlename = true.
          ls_address_x-secondname = true.
          ls_address_x-title_aca1 = true.
          ls_address_x-title_aca2 = true.
          ls_address_x-prefix1    = true.
          ls_address_x-prefix2    = true.
          ls_address_x-title_sppl = true.
          ls_address_x-nickname   = true.
          ls_address_x-initials   = true.
          ls_address_x-nameformat = true.
          ls_address_x-namcountry = true.

          CALL FUNCTION 'BAPI_USER_CHANGE'
            EXPORTING
              username                = me->user
              ADDRESS                 = ls_address
              ADDRESSX                = ls_address_x
            TABLES
              return                  = lt_return.

          DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
          IF NOT lt_return IS INITIAL.
            APPEND LINES OF lt_return TO return.
            CLEAR lt_return.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

  CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          previous = lo_exception.

  ENDTRY.

endmethod.


METHOD change_email .

  DATA lt_e_mail  TYPE TABLE OF bapiadsmtp.
  DATA ls_e_mail  TYPE bapiadsmtp.
  DATA lt_e_mail_x  TYPE TABLE OF bapiadsmtx.
  DATA ls_e_mail_x  TYPE bapiadsmtx.

  DATA ls_email TYPE ad_smtpadr.  "Candidate E-mail
  DATA ls_maildata TYPE rcf_s_emaildata_bp .

  DATA lo_exception TYPE REF TO cx_hrrcf .
  DATA lo_bas TYPE REF TO cl_hrrcf_address_service .
  DATA ls_emaildata TYPE rcf_s_emaildata_bp .

*     Get the address service instance
  TRY.
      CALL METHOD cl_hrrcf_address_service=>get_instance
        EXPORTING
          businesspartner = me->partner
        IMPORTING
          instance        = lo_bas
          return          = return.

      CHECK return IS INITIAL.
      CHECK lo_bas IS NOT INITIAL.

*     Get the preferrd contact data for the candidate
      CALL METHOD lo_bas->get_preferred_contact_data
        IMPORTING
          emaildata = ls_maildata.
      IF ls_maildata IS NOT INITIAL.
        MOVE ls_maildata-e_mail TO ls_email.
      ENDIF.

      IF lo_bas->e_maildata IS INITIAL .
        IF ls_email IS INITIAL .
*         add contact data
*          move '02' to ls_emaildata-channel .      "official e-mail
          MOVE e_mail TO ls_emaildata-e_mail .
          CALL METHOD lo_bas->add_contact_data
            EXPORTING
              external_commit = external_commit
            IMPORTING
              return          = return
            CHANGING
              emaildata       = ls_emaildata.
        ENDIF .
      ELSE .
        READ TABLE lo_bas->e_maildata WITH KEY std_no = 'X'
                                      INTO ls_emaildata .
        IF sy-subrc = 0 .
          IF e_mail IS INITIAL .
*           delete contact data
            CALL METHOD lo_bas->delete_contact_data
              EXPORTING
                emaildata       = ls_emaildata
                external_commit = external_commit
              IMPORTING
                return          = return.
          ELSE .
*          updata contact data
            MOVE e_mail TO ls_emaildata-e_mail .
            CALL METHOD lo_bas->update_contact_data
              EXPORTING
                external_commit = external_commit
              IMPORTING
                return          = return
              CHANGING
                emaildata       = ls_emaildata.
          ENDIF .
        ENDIF .
      ENDIF .

      DELETE return WHERE type NE 'E' AND type NE 'A'.

    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
           previous = lo_exception.
  ENDTRY.

* Set my BP attributes
  CALL METHOD me->set_bp_attributes_internal
    EXPORTING
      partner = me->partner.

ENDMETHOD.


METHOD change_personal_data .

  DATA is_person_changed      TYPE boole_d VALUE false.
  DATA lv_bu_partner          TYPE bu_partner.
  DATA ls_centraldata_x       TYPE bapibus1006_central_x.
  DATA ls_centraldataperson_x TYPE bapibus1006_central_person_x.
  DATA lt_e_maildata_x        TYPE TABLE OF bapiadsmtx.
  DATA ls_e_maildata_x        TYPE bapiadsmtx.
  DATA ls_return              TYPE bapiret2.
  DATA lt_return              TYPE TABLE OF bapiret2.
  DATA lo_exception           TYPE REF TO cx_hrrcf.
  DATA lv_t77s0               TYPE t77s0.
  DATA ls_centraldataperson   TYPE bapibus1006_central_person.
  DATA: lo_cand_info          TYPE REF TO cl_hrrcf_candidate_info.
  DATA lt_p1000               TYPE TABLE OF p1000.  "WAR2318486
  DATA ls_p1000               LIKE LINE OF lt_p1000."WAR2318486
  DATA lt_obj                 TYPE RCF_T_HROBJECT.  "WAR2318486
  DATA ls_obj                 LIKE LINE OF lt_obj.  "WAR2318486
  DATA ls_address             TYPE bapiaddr3.       "WAR2318486
  DATA ls_address_x           TYPE bapiaddr3x.      "WAR2318486
  DATA lv_plvar               TYPE plvar.           "WAR2318486

*  IF NOT centraldataperson IS INITIAL.
  IF centraldataperson IS SUPPLIED .

    IF nameformat_read = false.
      nameformat_read = true.
*   get standard nameformat from Customizing T77S0
      SELECT SINGLE * FROM t77s0 INTO lv_t77s0
             WHERE    grpid  = 'RECFA'
               AND    semid  = 'BPNAM'.
      IF sy-subrc = 0.
        nameformat = lv_t77s0-gsval.
      ENDIF.
*   get standard country for nameformat from Customizing T77S0
      CLEAR lv_t77s0.
      SELECT SINGLE * FROM t77s0 INTO lv_t77s0
             WHERE    grpid  = 'RECFA'
               AND    semid  = 'BPCOU'.
      IF sy-subrc = 0.
        namcountry = lv_t77s0-gsval.
      ENDIF.
    ENDIF.

    is_person_changed = true.

    ls_centraldataperson_x-firstname                      = true.
    ls_centraldataperson_x-lastname                       = true.
    ls_centraldataperson_x-birthname                      = true.
    ls_centraldataperson_x-middlename                     = true.
    ls_centraldataperson_x-secondname                     = true.
    ls_centraldataperson_x-title_aca1                     = true.
    ls_centraldataperson_x-title_aca2                     = true.
    ls_centraldataperson_x-title_sppl                     = true.
    ls_centraldataperson_x-prefix1                        = true.
    ls_centraldataperson_x-prefix2                        = true.
    ls_centraldataperson_x-nickname                       = true.
    ls_centraldataperson_x-initials                       = true.
    ls_centraldataperson_x-nameformat                     = true.
    ls_centraldataperson_x-namcountry                     = true.
    ls_centraldataperson_x-namcountryiso                  = true.
    ls_centraldataperson_x-sex                            = true.
    ls_centraldataperson_x-birthplace                     = true.
    ls_centraldataperson_x-birthdate                      = true.
    ls_centraldataperson_x-deathdate                      = true.
    ls_centraldataperson_x-maritalstatus                  = true.
    ls_centraldataperson_x-correspondlanguage             = true.
    ls_centraldataperson_x-correspondlanguageiso          = true.

  ENDIF.

*  IF NOT centraldata IS INITIAL.
  IF centraldata IS SUPPLIED .

    is_person_changed = true.

    ls_centraldata_x-searchterm1                    = true.
    ls_centraldata_x-searchterm2                    = true.
    ls_centraldata_x-partnertype                    = true.
    ls_centraldata_x-authorizationgroup             = true.
    ls_centraldata_x-partnerlanguage                = true.
    ls_centraldata_x-partnerlanguageiso             = true.
    ls_centraldata_x-dataorigintype                 = true.
    ls_centraldata_x-centralarchivingflag           = true.
    ls_centraldata_x-centralblock                   = true.
    ls_centraldata_x-title_key                      = true.
    ls_centraldata_x-contactallowance               = true.
    ls_centraldata_x-partnerexternal                = true.
    ls_centraldata_x-titleletter                    = true.

  ENDIF.

  IF is_person_changed = true.

    ls_centraldataperson = centraldataperson.
    IF ls_centraldataperson-namcountry IS INITIAL.
      ls_centraldataperson-nameformat = nameformat.
      ls_centraldataperson-namcountry = namcountry.
    ENDIF.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'       "{WAR2318486
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = lv_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

*   adjust CP (SHORT, STEXT)
    CLEAR: lt_p1000,  lt_obj[].
    ls_obj-plvar = lv_plvar.
    ls_obj-otype = 'CP'.
    ls_obj-objid = me->personid.
    APPEND ls_obj TO lt_obj.

    CALL FUNCTION 'RH_READ_INFTY_1000'
      EXPORTING
        AUTHORITY              = space
        WITH_STRU_AUTH         = space
        BEGDA                  = sy-datum
        ENDDA                  = sy-datum
      TABLES
        i1000                  = lt_p1000
        OBJECTS                = lt_obj
      EXCEPTIONS
        NOTHING_FOUND          = 1
        WRONG_CONDITION        = 2
        WRONG_PARAMETERS       = 3
        OTHERS                 = 4.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

    READ TABLE lt_p1000 INTO ls_p1000 INDEX 1.
    CONCATENATE ls_centraldataperson-firstname
                ls_centraldataperson-lastname
           INTO ls_p1000-stext
      SEPARATED BY space.
    ls_p1000-short = ls_centraldataperson-lastname.
    TRANSLATE ls_p1000-short TO UPPER CASE.                "#EC TRANSLANG
    CLEAR lt_p1000.
    APPEND ls_p1000 TO lt_p1000.

    CALL FUNCTION 'RH_UPDATE_INFTY'
      EXPORTING
        vtask                     = 'D'
        commit_flg                = space
        AUTHY                     = space
      TABLES
        innnn                     = lt_p1000
      EXCEPTIONS
        ERROR_DURING_UPDATE       = 1
        NO_AUTHORIZATION          = 2
        REPID_FORM_INITIAL        = 3
        CORR_EXIT                 = 4
        OTHERS                    = 5.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_update
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

*   adjust user name
    CALL FUNCTION 'BAPI_USER_GET_DETAIL'
      EXPORTING
        username             = me->user
      IMPORTING
        ADDRESS              = ls_address
      TABLES
        return               = lt_return.

    DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
    IF NOT lt_return IS INITIAL.
      APPEND LINES OF lt_return TO return.
      CLEAR lt_return.
    ENDIF.

    MOVE-CORRESPONDING ls_centraldataperson TO ls_address.
    ls_address-birth_name = ls_centraldataperson-birthname.
    ls_address_x-firstname  = 'X'.
    ls_address_x-lastname   = 'X'.
    ls_address_x-birth_name = 'X'.
    ls_address_x-middlename = 'X'.
    ls_address_x-secondname = 'X'.
    ls_address_x-fullname   = 'X'.
    ls_address_x-title_aca1 = 'X'.
    ls_address_x-title_aca2 = 'X'.
    ls_address_x-prefix1    = 'X'.
    ls_address_x-prefix2    = 'X'.
    ls_address_x-title_sppl = 'X'.
    ls_address_x-nickname   = 'X'.
    ls_address_x-initials   = 'X'.
    ls_address_x-nameformat = 'X'.
    ls_address_x-namcountry = 'X'.

    CALL FUNCTION 'BAPI_USER_CHANGE'
      EXPORTING
        username                = me->user
        ADDRESS                 = ls_address
        ADDRESSX                = ls_address_x
      TABLES
        return                  = lt_return.

    DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
    IF NOT lt_return IS INITIAL.
      APPEND LINES OF lt_return TO return.
      CLEAR lt_return.
    ENDIF.                                       "}WAR2318486

    IF external_commit = true OR                        "MELN1690866
       cl_hrrcf_simple_main_object=>luw_mode EQ true.
      CALL FUNCTION 'BUPA_CENTRAL_CHANGE'
        EXPORTING
          iv_partner       = me->partner
          is_data          = centraldata
          is_data_person   = ls_centraldataperson
          is_data_x        = ls_centraldata_x
          is_data_person_x = ls_centraldataperson_x
          iv_x_save        = space
        TABLES
          et_return        = return.

    ELSE.
      CALL FUNCTION 'BAPI_BUPA_CENTRAL_CHANGE'
      EXPORTING
        businesspartner     = me->partner
        centraldata         = centraldata
        centraldata_x       = ls_centraldata_x
        centraldataperson   = ls_centraldataperson
        centraldataperson_x = ls_centraldataperson_x
      TABLES
        return              = return.
    ENDIF.

*--- do not care on any business partner lock -------------------------
    IF NOT me->partner IS INITIAL.
      CALL FUNCTION 'BUPA_DEQUEUE'
        EXPORTING
          iv_partner = me->partner
        TABLES
          et_return  = lt_return.
      CLEAR lt_return.
    ENDIF.
*-begin error handling BAPI_BUPA_CREATE_FROM_DATA ---------------------
    IF NOT return IS INITIAL.
      DELETE return WHERE type NE 'E' AND type NE 'A'. "No W or S
*  fatal error
      READ TABLE return WITH KEY type = 'A'
        INTO ls_return.
      IF sy-subrc = 0.
        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
            textid         = cx_hrrcf_maintain_object=>business_partner_not_changed
            message_type = ls_return-type
            message_class = ls_return-id
            message_number = ls_return-number
            message_par1 = ls_return-message_v1
            message_par2 = ls_return-message_v2
            message_par3 = ls_return-message_v3
            message_par4 = ls_return-message_v4.
      ENDIF.
*  user error
      READ TABLE return WITH KEY type = 'E'
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        EXIT.  "change control flow
      ENDIF.
    ENDIF.
*-end   error handling BAPI_BUPA_CREATE_FROM_DATA ---------------------

  ENDIF.

* if SWITCH is turned on update the HRP5102's Last_updated_by and Last_updated_on fields
  IF ( return IS INITIAL ) AND
     ( cl_hrrcf_switch_check=>hrerc_sfws_ui_ses_01( ) EQ abap_true ).

    TRY.

        CALL METHOD cl_hrrcf_candidate_info=>get_instance
          EXPORTING
            hrobject = me->hrobject
          IMPORTING
            instance = lo_cand_info.

        CALL METHOD lo_cand_info->update_of_profile
          IMPORTING
            return = return.

      CATCH cx_hrrcf INTO lo_exception.
*       we write the log and continue the program logic
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).
    ENDTRY.

  ENDIF.

  IF external_commit EQ false.                   "WAR1540502
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.
  ENDIF.                                         "WAR1540502

  CALL METHOD me->set_bp_attributes_internal
    EXPORTING
      partner = me->partner.

  TRY.
      CALL METHOD cl_hrrcf_spt_change_pointer=>insert_change_pointer
        EXPORTING
          external_commit = external_commit            "N2075675
          hrobject = me->hrobject.
      .
    CATCH cx_hrrcf INTO lo_exception.
* we write the log and continue the program logic
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.

ENDMETHOD.                    "


METHOD change_user_role .
*Author: SGS
*This method changes the currently assigned User role to Internal User
*or to an external user

  DATA : ls_ref_user  TYPE bapirefus,
         ls_refuserx  TYPE BAPIREFUSX ,
         lt_return    TYPE bapirettab,
         ls_return    TYPE bapiret2,
         ls_role      TYPE t77rcf_role .

  CHECK me->user IS NOT INITIAL .

*   Get the reference user for the corresp 'role'.
  CALL METHOD cl_hrrcf_t77rcf_role=>get_role
    EXPORTING
      role        = role
    IMPORTING
      t77rcf_role = ls_role.

  ls_ref_user-ref_user = ls_role-refus.
  ls_refuserx-ref_user = 'X' .

  CALL FUNCTION 'BAPI_USER_CHANGE'
    EXPORTING
      username  = me->user
      ref_user  = ls_ref_user
      ref_userx = ls_refuserx
    TABLES
      return    = lt_return.

* Delete success messages
  DELETE lt_return WHERE type NE 'A' AND type NE 'E'.

* Exception handling
  IF lt_return IS NOT INITIAL.
    READ TABLE lt_return INTO ls_return WITH KEY type = 'A'.
    IF sy-subrc EQ 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid = cx_hrrcf_maintain_object=>user_not_changed
          hrobject = me->hrobject
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.

    READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.

    IF sy-subrc EQ 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid = cx_hrrcf_maintain_object=>user_not_changed
          hrobject = me->hrobject
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD check_before_delete .

  DATA : lt_appl_list TYPE rcf_t_application,
         lt_cdcy_list TYPE rcf_t_candidacy,
         lo_application TYPE REF TO cl_hrrcf_candidate_application,
         lo_candidacy TYPE REF TO cl_hrrcf_candidacy,
         lv_appl_status TYPE rcf_application_status,
         lv_cdcy_status TYPE rcf_candidacy_status ,
         ls_return TYPE bapiret2 ,
         p_text TYPE string ,
         lv_msg_par1 TYPE sy-msgv1 .

  CLEAR return . REFRESH return .

*Check if all the applications belonging to this Object are closed,
*that is, they are not in statuses 'In Process' or 'to be hired'

  CALL METHOD me->get_applications
    IMPORTING
      application_list = lt_appl_list.

  LOOP AT lt_appl_list INTO lo_application.
    CALL METHOD lo_application->get_application_status
      IMPORTING
        p_status = lv_appl_status.
    IF lv_appl_status EQ '1' OR
       lv_appl_status EQ '4' .
*     Raise error message and return
      IF 1 EQ 0.
        MESSAGE e063(hrrcf0002) WITH lv_msg_par1.
*       Candidate cannot be deleted due to an open &1
      ENDIF.

      p_text = cl_hrrcf_services_general=>get_otr_text(
'paoc_rcf_ui/application' ).

      MOVE p_text TO lv_msg_par1 .
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = 063
          par1   = lv_msg_par1
        IMPORTING
          return = ls_return.
      APPEND ls_return TO return.
    ENDIF .
  ENDLOOP .

  CHECK return IS INITIAL.
*Check if all the candidacies belonging to this object are closed, that
*is, they are not in statuses 'In Process' or 'to be hired'

  CALL METHOD me->get_candidacy
    IMPORTING
      candidacy_list = lt_cdcy_list.

  LOOP AT lt_cdcy_list INTO lo_candidacy .
    CALL METHOD lo_candidacy->get_candidacy_status
      IMPORTING
        p_status = lv_cdcy_status.
    IF lv_cdcy_status EQ '0' OR
       lv_cdcy_status EQ '3' OR
       lv_cdcy_status EQ '5'.
*     Raise error message and return
      IF 1 EQ 0.
        MESSAGE e063(hrrcf0002) WITH lv_msg_par1.
*       Candidate cannot be deleted due to an open &1
      ENDIF.

      CLEAR p_text .
      CLEAR lv_msg_par1 .
      p_text = cl_hrrcf_services_general=>get_otr_text(
'paoc_rcf_ui/cdcy_id' ).

      MOVE p_text TO lv_msg_par1 .
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = 063
          par1   = lv_msg_par1
        IMPORTING
          return = ls_return.
      APPEND ls_return TO return.
    ENDIF .
  ENDLOOP .

ENDMETHOD.


METHOD copy_bp_data .

*  DATA lo_exception   TYPE REF TO   cx_hrrcf .

  DATA lt_addrnum     TYPE TABLE OF bapibus1006_addresses_int .
  DATA lt_addressdata TYPE TABLE OF rcf_s_addressdata_bp .
  DATA lt_telefone TYPE  rcf_t_telefondata_bp  .
  DATA lt_fax TYPE rcf_t_faxdata_bp .
  DATA lt_email TYPE rcf_t_emaildata_bp .

  DATA lt_address_old TYPE TABLE OF rcf_s_addressdata_bp .
  DATA lt_telefone_old TYPE rcf_t_telefondata_bp  .
  DATA lt_fax_old TYPE rcf_t_faxdata_bp .
  DATA lt_email_old TYPE rcf_t_emaildata_bp .

  DATA ls_address_old TYPE rcf_s_addressdata_bp .
  DATA ls_telefone_old TYPE rcf_s_telefondata_bp  .
  DATA ls_fax_old TYPE rcf_s_faxdata_bp .
  DATA ls_email_old TYPE rcf_s_emaildata_bp .

  DATA lo_contact_rules TYPE REF TO cl_hrrcf_contact_rules .
  DATA lo_bas TYPE REF TO cl_hrrcf_address_service .

  DATA ls_p5110       TYPE          p5110 .
  DATA lt_5110        TYPE rcf_t_contact_rules.
  DATA ls_addrnum     TYPE          bapibus1006_addresses_int .
  DATA ls_addressdata TYPE          rcf_s_addressdata_bp .
  DATA ls_address     TYPE          bapibus1006_address .
  DATA lt_address     TYPE TABLE OF bapibus1006_address .
  DATA ls_return      TYPE          bapiret2.
  DATA remove_std_address TYPE boole_d .
  DATA remove_std_telefone TYPE boole_d .
  DATA remove_std_fax TYPE boole_d .
  DATA remove_std_email TYPE boole_d .
  DATA lv_addressguid    TYPE          but020-guid .

* Get the address and communication data stored in the BP if any

  CALL METHOD me->get_current_bp_data
    EXPORTING
      p_partner   = me->partner
    IMPORTING
      pt_email    = lt_email
      pt_fax      = lt_fax
      pt_telefone = lt_telefone
      pt_address  = lt_addressdata
      return      = return.

* Check if there is address
  IF NOT lt_address IS INITIAL .
    remove_std_address = true .
  ENDIF .

* Check if there is telefone
  IF NOT lt_telefone IS INITIAL .
    remove_std_telefone = true .
  ENDIF .

* Check if there is fax
  IF NOT lt_fax IS INITIAL .
    remove_std_fax = true .
  ENDIF .

* Check if there is email
  IF NOT lt_email IS INITIAL .
    remove_std_email = true .
  ENDIF .

* For the candidate in question get the business partner data
  CALL METHOD cl_hrrcf_contact_rules=>get_instance
    EXPORTING
      hrobject = me->hrobject
    IMPORTING
      instance = lo_contact_rules.

  CALL METHOD lo_contact_rules->get_records_by_date
    IMPORTING
      infotype_records = lt_5110.

  CALL METHOD me->get_old_comm_data
    EXPORTING
      pt_5110     = lt_5110
      p_partner   = partner
    IMPORTING
      pt_email    = lt_email_old
      pt_fax      = lt_fax_old
      pt_telefone = lt_telefone_old
      pt_address  = lt_address_old
      return      = return.

* Append the address and communication data
  IF remove_std_address EQ true .
    READ TABLE lt_address_old INTO ls_address_old
                              WITH KEY standardaddress = 'X'
                              TRANSPORTING ALL FIELDS .

    IF sy-subrc = 0 .
      MOVE space TO ls_address_old-standardaddress .
      MODIFY lt_address_old FROM ls_address_old INDEX sy-tabix .
    ENDIF .

  ENDIF .

  LOOP AT lt_address_old INTO ls_address_old .
    APPEND ls_address_old TO lt_address .
  ENDLOOP .

  IF remove_std_telefone EQ true .
    READ TABLE lt_telefone_old INTO ls_telefone_old
                              WITH KEY std_no = 'X'
                              TRANSPORTING ALL FIELDS .

    IF sy-subrc = 0 .
      MOVE space TO ls_telefone_old-std_no .
      MODIFY lt_telefone_old FROM ls_telefone_old INDEX sy-tabix .
    ENDIF .
  ENDIF .

  LOOP AT lt_telefone_old INTO ls_telefone_old .
    APPEND ls_telefone_old TO lt_telefone .
  ENDLOOP .

  IF remove_std_fax EQ true .
    READ TABLE lt_fax_old INTO ls_fax_old
                              WITH KEY std_no = 'X'
                              TRANSPORTING ALL FIELDS .

    IF sy-subrc = 0 .
      MOVE space TO ls_fax_old-std_no .
      MODIFY lt_fax_old FROM ls_fax_old INDEX sy-tabix .
    ENDIF .
  ENDIF .

  LOOP AT lt_fax_old INTO ls_fax_old .
    APPEND ls_fax_old TO lt_fax .
  ENDLOOP .

  IF remove_std_email EQ true .
    READ TABLE lt_email_old INTO ls_email_old
                              WITH KEY std_no = 'X'
                              TRANSPORTING ALL FIELDS .

    IF sy-subrc = 0 .
      MOVE space TO ls_email_old-std_no .
      MODIFY lt_email_old FROM ls_email_old INDEX sy-tabix .
    ENDIF .
  ENDIF .

  LOOP AT lt_email_old INTO ls_email_old .
    APPEND ls_email_old TO lt_email .
  ENDLOOP .

* Delete the IT 5110 data
  LOOP AT lt_5110 INTO ls_p5110 .
    CALL METHOD lo_contact_rules->delete_record
      IMPORTING
        return          = return
      CHANGING
        infotype_record = ls_p5110.
  ENDLOOP .

* Add all communication data
* get address service
  CALL METHOD cl_hrrcf_address_service=>get_instance
    EXPORTING
      businesspartner = me->partner
    IMPORTING
      instance        = lo_bas.

* Add addressdata
  SORT lt_address DESCENDING BY standardaddress.
  LOOP AT lt_address INTO ls_address_old.
    CALL METHOD lo_bas->add_contact_data
      IMPORTING
        return      = return
      CHANGING
        addressdata = ls_address_old.
  ENDLOOP .

* Add Telefonedata
  SORT lt_telefone DESCENDING BY std_no.
  LOOP AT lt_telefone INTO ls_telefone_old.
    CALL METHOD lo_bas->add_contact_data
      IMPORTING
        return      = return
      CHANGING
        telefondata = ls_telefone_old.
  ENDLOOP .

* Add emaildata
  SORT lt_email   DESCENDING BY std_no.
  LOOP AT lt_email INTO ls_email_old.
    CALL METHOD lo_bas->add_contact_data
      IMPORTING
        return    = return
      CHANGING
        emaildata = ls_email_old.
  ENDLOOP .

ENDMETHOD.


METHOD create .
* XLV: (20050603)
*      The switch EXTERNAL_COMMIT was introduced since this method runs
*      in an integrated system as part of a BAdI during PA30/PA40.
*      In this constellation we must not set a COMMIT WORK since this
*      would break the LUW
*      The switch is available also in other cases, but not tested.
*      The assumption is that User and BP creation would fail and also
*      the workflow events

  DATA lv_bu_partner   TYPE bu_partner.
  DATA ls_person       TYPE hrperson_s.
  DATA ls_hrobjbupa    TYPE hrobjbupas.

  DATA lv_name         TYPE stext.
  DATA lv_candidate_id TYPE hrobjid.

  DATA l_plvar         TYPE plvar.

  DATA lt_object    TYPE TABLE OF p1000.
  DATA ls_object    TYPE p1000.
  DATA ls_hrobject  TYPE hrobject.
  DATA lv_es_person TYPE hrperson_s.

  DATA lt_relation  TYPE TABLE OF p1001.
  DATA ls_relation  TYPE p1001.

  DATA lt_return    TYPE TABLE OF bapiret2.
  DATA ls_return    TYPE          bapiret2.

  DATA ls_emaildata TYPE rcf_s_emaildata_bp .

  DATA lo_instance  TYPE REF TO cl_hrrcf_simple_main_object.
  DATA lo_bas       TYPE REF TO cl_hrrcf_address_service .
  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA lv_commit_work TYPE boole_d.   " Note number 799720

  DATA lv_t77s0      TYPE t77s0.
  DATA ls_centraldataperson TYPE bapibus1006_central_person.

  DATA lv_no_commit  TYPE bapi_ncomt.

  IF external_commit = true.
    lv_no_commit = 'X'.
  ELSE.
    lv_no_commit = ' '.
  ENDIF.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = l_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

  IF nameformat_read = false.
    nameformat_read = true.
* get standard nameformat from Customizing T77S0
    SELECT SINGLE * FROM t77s0 INTO lv_t77s0
           WHERE    grpid  = 'RECFA'
             AND    semid  = 'BPNAM'.
    IF sy-subrc = 0.
      nameformat = lv_t77s0-gsval.
    ENDIF.
* get standard country for nameformat from Customizing T77S0
    CLEAR lv_t77s0.
    SELECT SINGLE * FROM t77s0 INTO lv_t77s0
           WHERE    grpid  = 'RECFA'
             AND    semid  = 'BPCOU'.
    IF sy-subrc = 0.
      namcountry = lv_t77s0-gsval.
    ENDIF.
  ENDIF.

  ls_centraldataperson = centraldataperson.
  IF ls_centraldataperson-namcountry IS INITIAL.
    ls_centraldataperson-nameformat = nameformat.
    ls_centraldataperson-namcountry = namcountry.
  ENDIF.

*-- Get ISO-language   'CG
  IF NOT ls_centraldataperson-correspondlanguage    IS INITIAL AND
         ls_centraldataperson-correspondlanguageiso IS INITIAL.

    CALL FUNCTION 'LANGUAGE_CODE_SAP_TO_ISO'
      EXPORTING
        sap_code  = ls_centraldataperson-correspondlanguage
      IMPORTING
        iso_code  = ls_centraldataperson-correspondlanguageiso
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc NE 0.
      CLEAR ls_centraldataperson-correspondlanguageiso.
    ENDIF.

  ENDIF.

  IF personid CO ' 0'.

    CALL FUNCTION 'BAPI_BUPA_CREATE_FROM_DATA'
      EXPORTING
        partnercategory        = '1' "Person
        centraldata            = centraldata
        centraldataperson      = ls_centraldataperson
        accept_error           = 'X' "Regional structure
        duplicate_message_type = 'W' "Duplication check
      IMPORTING
        businesspartner        = lv_bu_partner
      TABLES
        return                 = return.

*--- do not care on any business partner lock -------------------------
    IF NOT lv_bu_partner IS INITIAL.
      CALL FUNCTION 'BUPA_DEQUEUE'
        EXPORTING
          iv_partner = lv_bu_partner
        TABLES
          et_return  = lt_return.
      CLEAR lt_return.
    ENDIF.
*-begin error handling BAPI_BUPA_CREATE_FROM_DATA ---------------------
    IF NOT return IS INITIAL.
      DELETE return WHERE type NE 'E' AND type NE 'A'. "No W or S
*  fatal error
      READ TABLE return WITH KEY type = 'A'
        INTO ls_return.
      IF sy-subrc = 0.
        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
            textid =
              cx_hrrcf_maintain_object=>business_partner_not_created
            message_type = ls_return-type
            message_class = ls_return-id
            message_number = ls_return-number
            message_par1 = ls_return-message_v1
            message_par2 = ls_return-message_v2
            message_par3 = ls_return-message_v3
            message_par4 = ls_return-message_v4.
      ENDIF.
*  user error
      READ TABLE return WITH KEY type = 'E'
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        EXIT.  "change control flow
      ENDIF.
    ENDIF.
*-end   error handling BAPI_BUPA_CREATE_FROM_DATA ---------------------

    IF NOT external_commit = true.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'  "XDP
        EXPORTING                              "neccessary because of
          wait          = 'X'.                 "User and bsiness partner
    ENDIF.

    CALL FUNCTION 'BUPA_NUMBERS_GET'
      EXPORTING
        iv_partner      = lv_bu_partner
      IMPORTING
        ev_partner_guid = ls_hrobjbupa-bupaguid.

    ls_hrobjbupa-otype = 'CP'.

    CALL FUNCTION 'RH_GET_NEXT_NUMBER'
      EXPORTING
        ext_number                 = ls_hrobjbupa-objid  "#EC dom_equal
        otype                      = ls_hrobjbupa-otype
        plvar                      = l_plvar
      IMPORTING
        number                     = ls_hrobjbupa-objid  "#EC dom_equal
      EXCEPTIONS
        invalid_action             = 1
        number_must_be_zero        = 2
        invalid_object             = 3
        no_external_interval_found = 4
        no_internal_interval_found = 5
        invalid_number             = 6
        no_more_numbers_available  = 7
        OTHERS                     = 8.
    IF NOT sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid =
            cx_hrrcf_maintain_object=>hr_number_range
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    ls_person-personid = ls_hrobjbupa-objid.
    CONCATENATE centraldataperson-firstname
                centraldataperson-lastname
       INTO     ls_person-name
       SEPARATED BY space.

    CALL FUNCTION 'HR_CENTRALPERSON_INSERT'
      EXPORTING
        is_person         = ls_person
        iv_begindate      = low_date             "WAR1587730
        iv_no_commit      = lv_no_commit "space
        iv_asynchron      = space
        iv_with_authority = space
      EXCEPTIONS
        no_authorization  = 0
        invalid_data      = 2
        OTHERS            = 3.
    IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_insert
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    CALL FUNCTION 'HR_OBJECTBUPA_INSERT'
      EXPORTING
        is_hrobjbupa      = ls_hrobjbupa
*     IV_BEGINDATE      = SY-DATUM
        iv_no_commit      = lv_no_commit "space
        iv_asynchron      = space
        iv_with_authority = space
    EXCEPTIONS
      no_authorization        = 1
      invalid_data            = 2
      OTHERS                  = 3.
    IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_insert
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

  ELSE.                                      "personid is not initial

    ls_hrobjbupa-otype = 'CP'.
    ls_hrobjbupa-objid = personid.
    ls_person-personid = ls_hrobjbupa-objid.

    CALL FUNCTION 'HR_CENTRALPERSON_GET'
      EXPORTING
        iv_person_id = personid
      IMPORTING
        es_person    = lv_es_person.

    IF lv_es_person IS INITIAL.
* CP is not known -> create a CP using supplied persionid

      ls_person-personid = personid.
      CONCATENATE centraldataperson-firstname
                  centraldataperson-lastname
         INTO     ls_person-name
         SEPARATED BY space.

      CALL FUNCTION 'HR_CENTRALPERSON_INSERT'
        EXPORTING
          is_person         = ls_person
          iv_begindate      = low_date           "WAR1587730
          iv_no_commit      = lv_no_commit "space
          iv_asynchron      = space
          iv_with_authority = space
        EXCEPTIONS
          no_authorization  = 0
          invalid_data      = 2
          OTHERS            = 3.
      IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.
      ENDIF.
    ENDIF.

* in case an integrated ERP System a Bupa should exist and should the ID
* should be supplied

    IF partner CO ' 0'.

* no BP supplied create one and assign it
      CALL FUNCTION 'BAPI_BUPA_CREATE_FROM_DATA'
        EXPORTING
          partnercategory        = '1' "Person
          centraldata            = centraldata
          centraldataperson      = centraldataperson
          accept_error           = 'X' "Regional structure
          duplicate_message_type = 'W' "Duplication check
        IMPORTING
          businesspartner        = lv_bu_partner
        TABLES
          return                 = return.

*--- do not care on any business partner lock -------------------------
      IF NOT lv_bu_partner IS INITIAL.
        CALL FUNCTION 'BUPA_DEQUEUE'
          EXPORTING
            iv_partner = lv_bu_partner
          TABLES
            et_return  = lt_return.
        CLEAR lt_return.
      ENDIF.
*-begin error handling BAPI_BUPA_CREATE_FROM_DATA ---------------------
      IF NOT return IS INITIAL.
        DELETE return WHERE type NE 'E' AND type NE 'A'. "No W or S
*  fatal error
        READ TABLE return WITH KEY type = 'A'
          INTO ls_return.
        IF sy-subrc = 0.
          RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
            EXPORTING
              textid =
                cx_hrrcf_maintain_object=>business_partner_not_created
              message_type = ls_return-type
              message_class = ls_return-id
              message_number = ls_return-number
              message_par1 = ls_return-message_v1
              message_par2 = ls_return-message_v2
              message_par3 = ls_return-message_v3
              message_par4 = ls_return-message_v4.
        ENDIF.
*  user error
        READ TABLE return WITH KEY type = 'E'
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          EXIT.  "change control flow
        ENDIF.
      ENDIF.
*-end   error handling BAPI_BUPA_CREATE_FROM_DATA ---------------------

      IF NOT external_commit = true.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'  "XDP
           EXPORTING                              "neccessary because of
          wait          = 'X'.                 "User and bsiness partner
      ENDIF.

      CALL FUNCTION 'BUPA_NUMBERS_GET'
        EXPORTING
          iv_partner      = lv_bu_partner
        IMPORTING
          ev_partner_guid = ls_hrobjbupa-bupaguid.

      CALL FUNCTION 'HR_OBJECTBUPA_INSERT'
        EXPORTING
          is_hrobjbupa      = ls_hrobjbupa
*     IV_BEGINDATE      = SY-DATUM
          iv_no_commit      = lv_no_commit "space
          iv_asynchron      = space
          iv_with_authority = space
      EXCEPTIONS
        no_authorization        = 1
        invalid_data            = 2
        OTHERS                  = 3.
      IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.
      ENDIF.

    ENDIF.

  ENDIF.

  lv_name = centraldataperson-fullname.

* Added the check on commit -> note number 799720
  IF external_commit IS INITIAL.                 "WAR1540502
    lv_commit_work = 'X'.
  ELSE.
    lv_commit_work = space.
  ENDIF.
* end of the addition for note 799720

  TRY.
      CALL METHOD cl_hrrcf_simple_main_object=>create_internal
        EXPORTING
          name        = lv_name
          otype       = my_otype
          classname   = my_classname
          commit_work = lv_commit_work      "note number 799720
        IMPORTING
          instance    = lo_instance
          return      = return.

    CATCH cx_hrrcf INTO lo_exception.

      CLEAR candidate.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

  candidate ?= lo_instance.
  CHECK NOT candidate IS INITIAL.

  ls_relation-mandt = sy-mandt.
  ls_relation-plvar = l_plvar.
  ls_relation-otype = 'CP'.
  ls_relation-objid = ls_person-personid.
  ls_relation-infty = '1001'.
  ls_relation-istat = '1'.
  ls_relation-rsign = 'B'.
  ls_relation-relat = '650'.
  ls_relation-begda = sy-datum.
  ls_relation-endda = '99991231'.
  ls_relation-sclas = my_otype.
  ls_relation-sobid = candidate->id.
  APPEND ls_relation TO lt_relation.

  CALL FUNCTION 'RH_INSERT_INFTY'
    EXPORTING
      vtask               = 'D'
      authy               = space
      commit_flg          = lv_commit_work       "WAR1540502
    TABLES
      innnn               = lt_relation
    EXCEPTIONS
      no_authorization    = 1
      error_during_insert = 2
      repid_form_initial  = 3
      corr_exit           = 4
      begda_greater_endda = 5
      OTHERS              = 6.

  IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_insert
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ENDIF.

* Assign employee to the created candidate -> note 799720

  IF employeeid IS NOT INITIAL.
    CHECK ls_person-personid CN ' 0'.
    candidate->personid = ls_person-personid .

    IF partner IS INITIAL.
      TRY.
          CALL METHOD candidate->set_partner_id
            EXPORTING
              personid = ls_person-personid.

        CATCH cx_hrrcf INTO lo_exception.

          IF NOT candidate IS INITIAL.
            cl_hrrcf_candidate=>deregister_instance( candidate ).
            CLEAR candidate.
          ENDIF.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
               previous = lo_exception.
      ENDTRY.
    ELSE.
      candidate->partner = partner.
    ENDIF.

    CALL METHOD candidate->assign_employee
      EXPORTING
        employeeid      = employeeid
        external_commit = external_commit.
  ENDIF.

  IF NOT external_commit = true.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'  "XDP
      EXPORTING                              "neccessary because of
        wait          = 'X'.                 "User and bsiness partner
  ENDIF.

* ID is determined -> set attributes
  TRY.
      CALL METHOD candidate->set_object_ids_internal
        EXPORTING
          personid = ls_person-personid.

    CATCH cx_hrrcf INTO lo_exception.

      IF NOT candidate IS INITIAL.
        cl_hrrcf_candidate=>deregister_instance( candidate ).
        CLEAR candidate.
      ENDIF.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

  TRY.
      CALL METHOD candidate->set_bp_attributes_internal
        EXPORTING
          partner = candidate->partner.

    CATCH cx_hrrcf INTO lo_exception.

      IF NOT candidate IS INITIAL.
        cl_hrrcf_candidate=>deregister_instance( candidate ).
        CLEAR candidate.
      ENDIF.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

* Begin change for e-recruiting 1.0
* Check if emaildata is supplied and then add it to BP and Infotype 5110
  IF NOT email IS INITIAL .
    TRY.
        CALL METHOD cl_hrrcf_address_service=>get_instance
          EXPORTING
            businesspartner = candidate->partner
          IMPORTING
            instance        = lo_bas
            return          = return.

        CHECK lo_bas IS NOT INITIAL .

        CHECK email-e_mail IS NOT INITIAL .
*        MOVE email TO ls_emaildata-e_mail .
*        MOVE '01' TO ls_emaildata-channel .

        MOVE email TO ls_emaildata .

        CALL METHOD lo_bas->add_contact_data
          EXPORTING
            external_commit = external_commit
          IMPORTING
            return          = return
          CHANGING
            emaildata       = ls_emaildata.

      CATCH cx_hrrcf INTO lo_exception.

        IF NOT candidate IS INITIAL.
          cl_hrrcf_candidate=>deregister_instance( candidate ).
          CLEAR candidate.
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.

    ENDTRY.
  ENDIF .
* End change for e-recruiting 1.0

*  TRY.
*      CALL METHOD cl_hrrcf_spt_change_pointer=>insert_change_pointer
*        EXPORTING
*          hrobject        = candidate->hrobject
*          external_commit = external_commit.
*
*    CATCH cx_hrrcf INTO lo_exception.
** we write the log and continue the program logic
*      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
*        EXPORTING
*          ex = lo_exception.
*  ENDTRY.

ENDMETHOD.                    "


METHOD delete .

  DATA:
    ls_object   TYPE          p1000,
    lt_object   TYPE TABLE OF p1000,
    ls_hrobject TYPE          hrobject.

  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA ls_return TYPE bapiret2.
  DATA lt_return TYPE bapirettab .

  DATA: lv_use_wd_ui        TYPE boole_d,
        lv_use_bl_system    TYPE boole_d,
        lv_rfc_dest         TYPE rfcdest.

  CLEAR return . REFRESH return .

  CALL FUNCTION 'RH_DELETE_OBJECT'
    EXPORTING
     plvar                              = me->hrobject-plvar
     otype                              = 'CP'
     objid                              = me->personid
     vtask                              = 'D'
*   ORDER_FLG                          = 'X'
*   COMMIT_FLG                         = 'X'
     authy                              = space
*   CONFIRM                            = ' '
*   DELETE_1205_WFDID                  = 'X'
*   DELETE_USER_PROFILES               = 'X'
*   DELETE_DEPENDENTS                  = 'X'
*   KEEP_LUPD                          =
*   WORKF_ACTV                         = 'X'
*   NO_EXCEPT_FOREIGN_DATA             = ' '
* IMPORTING
*   CONFIRM_EXIT                       =
* TABLES
*   DEL_OBJECTS                        =
*   ILFCODE                            =
   EXCEPTIONS
     error_during_delete                = 1
     no_authorization                   = 2
     corr_exit                          = 3
     buffer_upd_with_foreign_data       = 4
     OTHERS                             = 5.
  CASE sy-subrc .

    WHEN '0' .              "Success
      " Delete notes associated with this candidate
      CALL METHOD cl_hrrcf_t77rcf_candnotes=>delete_by_cand
        EXPORTING
          is_candt = hrobject.

    WHEN '2' .

      IF 1 EQ 0.
        MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
      ENDIF.

      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = '5A'
          number = 278
        IMPORTING
          return = ls_return.
      APPEND ls_return TO return.

    WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_maintain_object=>error_during_delete
          hrobject     = ls_hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

  ENDCASE .

* Delete all related cluster entries
* Here data from the personalisation class would be deleted for
* this user
  CALL METHOD cl_pers_service=>user_delete
    EXPORTING
      p_uname                = me->user
    EXCEPTIONS
      user_does_not_exist    = 1
      access_class_not_found = 3
      OTHERS                 = 4.
  IF sy-subrc <> 0.
    MESSAGE e121(hrrcf0001) WITH 'CL_PERS_SERVICE'
                                 'USER_DELETE'.

*An error occurred while deleting data
    TRY.

        RAISE EXCEPTION TYPE cx_hrrcf_personalization
              EXPORTING
                textid =
                    cx_hrrcf_personalization=>cx_per_del_data
                message_type   = 'E'
                message_class  = 'HRRCF0001'
                message_number = '121'
                message_par1   = 'CL_PERS_SERVICE'
                message_par2   = 'USER_DELETE'.

      CATCH cx_hrrcf_personalization INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
             previous = lo_exception.
    ENDTRY .
  ENDIF.


* Delete user data
  CHECK return IS INITIAL .

  CALL FUNCTION 'BAPI_USER_DELETE'
    EXPORTING
      username = me->user
    TABLES
      return   = lt_return.

  DELETE lt_return WHERE type NE 'A' OR type NE 'E' .
  APPEND LINES OF lt_return TO return .

* Delete user on frontend system (if distributed candidate scenario)
  lv_use_wd_ui = cl_hrrcf_services_general=>check_usage_wd_ui( ).
  IF lv_use_wd_ui IS NOT INITIAL.
    lv_rfc_dest = cl_hrrcf_services_general=>get_ui_destination( ).
    IF lv_rfc_dest IS NOT INITIAL AND
       lv_rfc_dest NE 'NONE'.
      CALL FUNCTION 'BAPI_USER_DELETE'
        DESTINATION lv_rfc_dest
        EXPORTING
          username = me->user
        TABLES
          return   = lt_return.
      DELETE lt_return WHERE type NE 'A' OR type NE 'E' .
      APPEND LINES OF lt_return TO return .
    ENDIF.
  ENDIF.

  TRY.
*--   Delete redundant data storage
      CALL METHOD cl_hrrcf_t77rcf_rd_trm=>delete
        EXPORTING
          is_hrobject = me->hrobject.

      CALL METHOD super->delete
        IMPORTING
          return = lt_return.
      APPEND LINES OF lt_return TO return .
    CATCH cx_hrrcf_maintain_object INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
           previous = lo_exception.

    CATCH cx_hrrcf_infotype_operation INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
           previous = lo_exception.

  ENDTRY.


ENDMETHOD.


METHOD delete_email_reference .

  DATA lo_exception TYPE REF TO cx_hrrcf .
  DATA lo_bas TYPE REF TO cl_hrrcf_address_service .

*     Get the address service instance
  TRY.

      CALL METHOD cl_hrrcf_address_service=>get_instance
        EXPORTING
          businesspartner = me->partner
        IMPORTING
          instance        = lo_bas
          return          = return.

      CHECK return IS INITIAL .

      IF lo_bas IS NOT INITIAL.
        CALL METHOD lo_bas->delete_contact_data_from_infty
          IMPORTING
            return = return.
      ENDIF.

      DELETE return WHERE type NE 'E' AND type NE 'A'.

    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
           previous = lo_exception.
  ENDTRY.

* Set my BP attributes

  CALL METHOD me->set_bp_attributes_internal
    EXPORTING
      partner = me->partner.

ENDMETHOD.


METHOD delimit_employee .

  CONSTANTS c_subty TYPE plog-subty VALUE 'A209'.
  CONSTANTS c_sclas TYPE p1001-sclas VALUE 'P'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA lt_object TYPE TABLE OF hrobject.
  DATA l_plvar TYPE plvar.
*  DATA l_objid TYPE plog-objid.

  DATA delimitdate TYPE  sydatum.
  DATA lt_delimt_record TYPE TABLE OF p1001.

*  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA ls_return TYPE bapiret2.

  delimitdate = sy-datum - 1.

  IF NOT me->employeeid IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    CALL FUNCTION 'RH_READ_INFTY'
      EXPORTING
        authority            = space
        infty                = '1001'
        istat                = '1'
        subty                = c_subty
        plvar                = l_plvar
        otype                = c_sclas
        objid                = me->employeeid
      TABLES
        innnn                = lt_relation
      EXCEPTIONS
        all_infty_with_subty = 1
        nothing_found        = 0
        no_objects           = 3
        wrong_condition      = 4
        OTHERS               = 5.

    IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
          hrobject = me->hrobject
*       INFOTYPE =
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LT delimitdate
                 AND objid = me->employeeid.
      APPEND ls_relation TO lt_delimt_record.
    ENDLOOP.
    IF sy-subrc = 0.
      CALL FUNCTION 'RH_CUT_INFTY'
        EXPORTING
          vtask              = 'D'
          gdate              = delimitdate
          histo              = space
        TABLES
          innnn              = lt_delimt_record
        EXCEPTIONS
          error_during_cut   = 1
          no_authorization   = 2
          gdate_before_begda = 3
          cut_of_timco_one   = 4
          corr_exit          = 5
          OTHERS             = 6.
      CASE sy-subrc .

        WHEN '0' .                "Success

          clear me->employeeid.

          RAISE EVENT rcf_relationship_changed
            EXPORTING
              hrobject = me->hrobject.

        WHEN '2' .

          IF 1 EQ 0.
            MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
          ENDIF.

          CALL FUNCTION 'BALW_BAPIRETURN_GET2'
            EXPORTING
              type   = 'E'
              cl     = '5A'
              number = 278
            IMPORTING
              return = ls_return.
          APPEND ls_return TO return.

        WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
          RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
            EXPORTING
              textid = cx_hrrcf_infotype_operation=>error_during_update
              hrobject = me->hrobject
              message_type = sy-msgty
              message_class = sy-msgid
              message_number = sy-msgno
              message_par1 = sy-msgv1
              message_par2 = sy-msgv2
              message_par3 = sy-msgv3
              message_par4 = sy-msgv4.

      ENDCASE .
    ENDIF.


    REFRESH lt_delimt_record.
    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda GE delimitdate
                 AND objid = me->employeeid.
      APPEND ls_relation TO lt_delimt_record.
    ENDLOOP.
    IF sy-subrc = 0.
      CALL FUNCTION 'RH_DELETE_INFTY'
        EXPORTING
          vtask               = 'D'
        TABLES
          innnn               = lt_delimt_record
        EXCEPTIONS
          error_during_delete = 1
          no_authorization    = 2
          delete_first_record = 3
          corr_exit           = 4
          OTHERS              = 5.
      CASE sy-subrc .

        WHEN '0' .                "Success
          clear me->employeeid.
          RAISE EVENT rcf_relationship_changed
            EXPORTING
              hrobject = me->hrobject.

        WHEN '2' .

          IF 1 EQ 0.
            MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
          ENDIF.

          CALL FUNCTION 'BALW_BAPIRETURN_GET2'
            EXPORTING
              type   = 'E'
              cl     = '5A'
              number = 278
            IMPORTING
              return = ls_return.
          APPEND ls_return TO return.

        WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
          RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
            EXPORTING
              textid = cx_hrrcf_infotype_operation=>error_during_update
              hrobject = me->hrobject
              message_type = sy-msgty
              message_class = sy-msgid
              message_number = sy-msgno
              message_par1 = sy-msgv1
              message_par2 = sy-msgv2
              message_par3 = sy-msgv3
              message_par4 = sy-msgv4.

      ENDCASE .

    ENDIF.
  ENDIF.

*  clear me->employeeid.
*
*  RAISE EVENT rcf_relationship_changed
*    EXPORTING
*      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD exchange_cp_with_hr .
* This method is called when an external candidate is hired and the
* data transfer (PA48 or XI to HRADMIN) is used. After the hiring is
* finished, FM HR_RCF_ASSIGN_EE_TO_CANDIDATE is called, which tells
* us, that the data of the external candidate has been used to create
* a certain personal number
* We must distinguish two cases:
* 1. The candidate is hired in the future. HR creates P, CP and a
*  relation between those objects. Since  the hiring date isn't
*  reached the external candidate will not be changed, but the
*  information about P--NA-relation is stored in table T77RCF_EMPL_CAND
*  BP will be created (and assigned to CP) when the hiring date is
*  reached, using report HRALXSYNC. In BAdI HRSYNC_P, method
*  DO_POST_PROCESSING we must call this method to assign the NA-object
*  to the new CP, to delete the old CP and deactivate the old user
* 2. The candidate is hired in the past. According to our
*  BAdI-implementation the new P has an candidate assigned via CP.
*  Now we must delete the new candidate, assign the old candidate
*  to the new CP...
* The only difference between 1 and 2 is that in case 2 we must delete
* the new candidate
**********************************************************************
*
  CONSTANTS:

    c_infty_1001        TYPE          infotyp VALUE '1001',
    c_relat_p_cp        TYPE          subtyp  VALUE 'A209',
    c_sclas_p           TYPE          sclas   VALUE 'P',
    c_sclas_cp          TYPE          sclas   VALUE 'CP',
    c_sclas_na          TYPE          sclas   VALUE 'NA',
    c_sclas_us          TYPE          sclas   VALUE 'US',
    c_sclas_bp          TYPE          sclas   VALUE 'BP'.
*
  DATA:
    lv_plvar            TYPE          plvar,
    lv_cp_hr            TYPE          objektid,
    lv_na_hr            TYPE          objektid,
    lv_bp_hr            TYPE          bu_partner,
    lv_us_hr            TYPE          syuname,
    lv_user_old         TYPE          syuname,
    lv_lines            TYPE          i,
*
    ls_relation         TYPE          p1001,
    ls_hrobject         TYPE          hrobject,
*
    lt_relation         TYPE TABLE OF p1001,
    lt_ret              TYPE TABLE OF bapiret2,
    lt_hrobject         TYPE TABLE OF hrobject,
*
    lo_ex               TYPE REF TO   cx_hrrcf,
*
    lv_bp_old            TYPE         bu_partner,
    ls_centraldata_old   TYPE         bapibus1006_central,
    ls_centraldata_x_old TYPE         bapibus1006_central_x.
*
  FIELD-SYMBOLS:
    <p1001>             TYPE          p1001,
    <ls_return>         TYPE          bapiret2.
*
* Process this method only if luw_mode is set, i.e. we are sure that
* DB-updates are done via PD-buffer and in EREC-context
  IF cl_hrrcf_simple_main_object=>luw_mode EQ false.
    RETURN.
  ENDIF.

* Do nothing if employee ID is initial
  IF employeeid IS INITIAL.
    RETURN.
  ENDIF.
*
  TRY.
* Get active plan variant
      lv_plvar = cl_hrrcf_general_bl=>get_plvar( ).
*
* 1. We know the CP of the external candidate: me->personid
*
* 2. Get the P-CP-relation of new PERNR to determine the new CP
      CALL FUNCTION 'RH_READ_INFTY_1001'
        EXPORTING
          authority        = space
          with_stru_auth   = space
          plvar            = lv_plvar
          otype            = c_sclas_p
          objid            = employeeid
          istat            = '1'
*         EXTEND           = 'X'
          subty            = c_relat_p_cp
*         BEGDA            = '19000101'
*         ENDDA            = '99991231'
*         CONDITION        = '00000'
*         SORT             = 'X'
*         with_ev          = ' '
*         ADATA            = 'X'
*         AUTH_SOBID       = ' '
        TABLES
          i1001            = lt_relation
*         OBJECTS          =
        EXCEPTIONS
          nothing_found    = 1
          wrong_condition  = 2
          wrong_parameters = 3
          OTHERS           = 4.
*
      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
*           hrobject       = me->hrobject
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.
*
      DELETE lt_relation WHERE sclas NE c_sclas_cp.
      READ TABLE lt_relation INDEX 1 ASSIGNING <p1001>.
      IF sy-subrc IS INITIAL.
        MOVE <p1001>-sobid TO lv_cp_hr.
      ENDIF .
*
* 3. Determine the new NA via the CP-NA-relation
      CLEAR lt_relation.
*
      CALL FUNCTION 'RH_READ_INFTY_1001'
        EXPORTING
          authority        = space
          with_stru_auth   = space
          plvar            = lv_plvar
          otype            = c_sclas_cp
          objid            = lv_cp_hr
          istat            = '1'
*         EXTEND           = 'X'
*         SUBTY            = ' '
*         BEGDA            = '19000101'
*         ENDDA            = '99991231'
*         CONDITION        = '00000'
*         SORT             = 'X'
          with_ev          = 'X'
*         ADATA            = 'X'
*         AUTH_SOBID       = ' '
        TABLES
          i1001            = lt_relation
*         OBJECTS          =
        EXCEPTIONS
          nothing_found    = 1
          wrong_condition  = 2
          wrong_parameters = 3
          OTHERS           = 4.
*
      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
*           hrobject       = me->hrobject
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.
*
* Derive US, BP and NA
      DELETE lt_relation
        WHERE
          sclas NE c_sclas_bp AND
          sclas NE c_sclas_us AND
          sclas NE c_sclas_na.
*
      LOOP AT lt_relation ASSIGNING <p1001>.
        CASE <p1001>-sclas.
          WHEN c_sclas_us.
            lv_us_hr = <p1001>-sobid.
          WHEN c_sclas_bp.
            lv_bp_hr = <p1001>-sobid.
          WHEN c_sclas_na.
            lv_na_hr = <p1001>-sobid.
        ENDCASE.
      ENDLOOP.
*
* At least BP must exist for new PERNR, otherwise we must not assign
* the external candidate to this CP. However, it seems that HRALXSYNC writes CP-BP-realtion later to DB
*      IF lv_bp_hr IS INITIAL.
*        RAISE EXCEPTION TYPE cx_hrrcf.
*      ENDIF.
*
* 4. Get all relations of old CP and check, if only
*    three (BP, US, NA) exist. Otherwise we should stop processing
      CLEAR lt_relation.
*
      CALL FUNCTION 'RH_READ_INFTY_1001'
        EXPORTING
          authority        = space
          with_stru_auth   = space
          plvar            = lv_plvar
          otype            = c_sclas_cp
          objid            = me->personid
          istat            = '1'
*         EXTEND           = 'X'
*         SUBTY            = ' '
*         BEGDA            = '19000101'
*         ENDDA            = '99991231'
*         CONDITION        = '00000'
*         SORT             = 'X'
*         with_ev          = 'X'
*         ADATA            = 'X'
*         AUTH_SOBID       = ' '
        TABLES
          i1001            = lt_relation
*         OBJECTS          =
        EXCEPTIONS
          nothing_found    = 1
          wrong_condition  = 2
          wrong_parameters = 3
          OTHERS           = 4.
*
      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
*           hrobject       = me->hrobject
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.
*
      DELETE lt_relation
        WHERE
          sclas EQ c_sclas_bp OR
          sclas EQ c_sclas_us OR
          sclas EQ c_sclas_na.

      IF NOT lt_relation IS INITIAL.
*  Preliminary, should not occur
        RAISE EXCEPTION TYPE cx_hrrcf.
      ENDIF.
*
* 5. Delete the old CP, which includes the deletion of the relations
      ls_hrobject-plvar = lv_plvar.
      ls_hrobject-otype = c_sclas_cp.
      ls_hrobject-objid = me->personid.
      APPEND ls_hrobject TO lt_hrobject.
*
* 6. Delete the new candidate if exist (including NA-CP-relation)
      IF NOT lv_na_hr IS INITIAL.
        ls_hrobject-plvar = lv_plvar.
        ls_hrobject-otype = c_sclas_na.
        ls_hrobject-objid = lv_na_hr.
        APPEND ls_hrobject TO lt_hrobject.
      ENDIF.
*
* Call FM to delete old CP and new NA, if exists
      CALL FUNCTION 'RH_DELETE_OBJECT'
        EXPORTING
*          plvar                              = lv_plvar
*          otype                              = c_sclas_cp
*          objid                              = me->personid
          vtask                              = 'B'
*          ORDER_FLG                          = 'X'
*          COMMIT_FLG                         = 'X'
*          AUTHY                              = 'X'
*          CONFIRM                            = ' '
*          DELETE_1205_WFDID                  = 'X'
*          DELETE_USER_PROFILES               = 'X'
*          DELETE_DEPENDENTS                  = 'X'
*          KEEP_LUPD                          =
*          WORKF_ACTV                         = 'X'
*          NO_EXCEPT_FOREIGN_DATA             = ' '
*        IMPORTING
*          CONFIRM_EXIT                       =
        TABLES
          del_objects                        = lt_hrobject
*          ILFCODE                            =
       EXCEPTIONS
         error_during_delete                = 1
         no_authorization                   = 2
         corr_exit                          = 3
         buffer_upd_with_foreign_data       = 4
         OTHERS                             = 5 .
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_delete
*           hrobject       = me->hrobject
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.
*
* 7. Insert new NA-CP-relation
      CLEAR lt_relation.
      ls_relation-mandt = sy-mandt.
      ls_relation-plvar = lv_plvar.
      ls_relation-otype = c_sclas_na.
      ls_relation-objid = me->id.
      ls_relation-infty = c_infty_1001.
      ls_relation-istat = '1'.
      ls_relation-rsign = 'A'.
      ls_relation-relat = '650'.
      ls_relation-begda = sy-datum.
      ls_relation-endda = high_date. "'99991231'.
      ls_relation-sclas = c_sclas_cp.
      ls_relation-sobid = lv_cp_hr.
      APPEND ls_relation TO lt_relation.
*
      CALL FUNCTION 'RH_INSERT_INFTY'
        EXPORTING
          vtask               = 'B'
*         commit_flg          = space "We must avoid COMMIT WORK
*         AUTHY               = 'X'
        TABLES
          innnn               = lt_relation
        EXCEPTIONS
          no_authorization    = 1
          error_during_insert = 2
          repid_form_initial  = 3
          corr_exit           = 4
          begda_greater_endda = 5
          OTHERS              = 6.

      CASE sy-subrc.
        WHEN 0.
*         Change the internal attribute of Candidate
* We have two opportunities: We can either use the existing method
* me->set_object_ids_internal to set the attributes or do it directly.
* Since we wrote the data only to the buffer we might enhance the
* method regarding data retrieval
* We must keep in mind that also the employee-instance needs to be
* updated
          CALL METHOD me->set_object_ids_internal           "WGY1646829
            EXPORTING
              personid = lv_cp_hr.
          lv_user_old     = me->user.
          lv_bp_old       = me->partner.                   "MELN1704908
          ls_centraldata_old = me->centraldata.
          me->personid    = lv_cp_hr.
          IF partnerid IS SUPPLIED.
            me->partner   = partnerid.
          ELSE.
            me->partner     = lv_bp_hr.
          ENDIF.
          me->user        = lv_us_hr.
*          me->id         =                "No change
          me->employeeid = employeeid.
**************************************************************
* Open issue: Is it worth to fill the attributes central_data
*             centraldataperson from BP?
*             Do we need an update of the instance of the
*             employee, since candiate reference may have changed,
*             candidate id, BP,... has changed
**************************************************************
*
* Since we write to the PD-buffer and not to DB we must not clear
* the E-Recruiting buffer. Especially the EVENT RCF_BUFFER_REFRESH
* clears local_directory and instance_directory
*          RAISE EVENT rcf_relationship_changed
*            EXPORTING
*              hrobject = me->hrobject.
*          RAISE EVENT rcf_buffer_refresh.

        WHEN OTHERS.
          RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
            EXPORTING
              textid         = cx_hrrcf_infotype_operation=>error_during_insert
              message_type   = sy-msgty
              message_class  = sy-msgid
              message_number = sy-msgno
              message_par1   = sy-msgv1
              message_par2   = sy-msgv2
              message_par3   = sy-msgv3
              message_par4   = sy-msgv4.
      ENDCASE.
*
* 8. Deactivate user of external candidate
      IF NOT lv_user_old IS INITIAL.
        CALL FUNCTION 'BAPI_USER_LOCK'
          EXPORTING
            username = lv_user_old
          TABLES
            return   = lt_ret.
      ENDIF.
*
* 9. Archive BP of the external candidate
      ls_centraldata_old-centralarchivingflag   = true.
      ls_centraldata_x_old-centralarchivingflag = true.

      CALL FUNCTION 'BUPA_CENTRAL_CHANGE'                  "MELN1704908
        EXPORTING
          iv_partner = lv_bp_old
          is_data    = ls_centraldata_old
          is_data_x  = ls_centraldata_x_old
          iv_x_save  = space
        TABLES
          et_return  = lt_ret.

      DELETE lt_ret WHERE type NE 'E' AND type NE 'A'. "No W or S
      READ TABLE lt_ret ASSIGNING <ls_return> INDEX 1.
      IF sy-subrc = 0.
        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
            textid         = cx_hrrcf_maintain_object=>business_partner_not_changed
            message_type   = <ls_return>-type
            message_class  = <ls_return>-id
            message_number = <ls_return>-number
            message_par1   = <ls_return>-message_v1
            message_par2   = <ls_return>-message_v2
            message_par3   = <ls_return>-message_v3
            message_par4   = <ls_return>-message_v4.
      ENDIF.


    CATCH cx_hrrcf INTO lo_ex .
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_ex.
  ENDTRY.
*
ENDMETHOD.


method FILL_OBJECT_BUFFER_CP.
  DATA:
    lt_1001     TYPE STANDARD TABLE OF p1001,
    lt_cond     TYPE hrtb_cond,
    ls_cond     TYPE hrcond,
    lv_partner  TYPE bu_partner,
    lt_partner  TYPE bu_partner_t,
    lt_user     TYPE rcf_t_ususers,
    ls_user     TYPE ususers,
    lt_partner_package TYPE rcf_t_bu_partner_package.
  FIELD-SYMBOLS:
    <ls_1001> TYPE p1001.
*
  IF pt_1000 IS INITIAL.
    RETURN.
  ENDIF.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1000
    EXPORTING
      pt_i1000 = pt_1000.

* Read B008 to S
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'B008'.
  APPEND ls_cond
      TO lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'S'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1001
    EXPORTING
      pt_i1000 = pt_1000
      pt_icond = lt_cond.

* Read B209 to P
  CLEAR lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'B209'.
  APPEND ls_cond
      TO lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'P'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1001
    EXPORTING
      pt_i1000 = pt_1000
      pt_icond = lt_cond.

* Read B650 to NA
  CLEAR lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'B650'.
  APPEND ls_cond
      TO lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'NA'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1001
    EXPORTING
      pt_i1000 = pt_1000
      pt_icond = lt_cond.

* Read B208 to US
  CLEAR lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'B208'.
  APPEND ls_cond
      TO lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'US'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1001
    EXPORTING
      pt_i1000 = pt_1000
      pt_icond = lt_cond
    IMPORTING
      pt_e1001 = lt_1001.

  LOOP AT lt_1001
        ASSIGNING <ls_1001>.

    ls_user-bname = <ls_1001>-sobid.
    APPEND ls_user
        TO lt_user.

  ENDLOOP.

* Read B207 to BP
  CLEAR lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'B207'.
  APPEND ls_cond
      TO lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'BP'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1001
    EXPORTING
      pt_i1000 = pt_1000
      pt_icond = lt_cond
    IMPORTING
      pt_e1001 = lt_1001.

  LOOP AT lt_1001
        ASSIGNING <ls_1001>.

    lv_partner = <ls_1001>-sobid.
    APPEND lv_partner
        TO lt_partner.
    IF sy-tabix >= 1000.
      APPEND lt_partner
          TO lt_partner_package.
      CLEAR lt_partner[].
    ENDIF.
  ENDLOOP.
  IF NOT ( lt_partner[] IS INITIAL ).
    APPEND lt_partner
        TO lt_partner_package.
  ENDIF.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_bupa
    EXPORTING
      pt_ipartner_package = lt_partner_package.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_user
    EXPORTING
      pt_iuser = lt_user.

endmethod.


method FILL_OBJECT_BUFFER_NA.
  DATA:
      lt_1001     TYPE STANDARD TABLE OF p1001,
      lt_cp       TYPE rcf_t_hrobject,
      ls_hrobject TYPE hrobject,
      lt_cond     TYPE hrtb_cond,
      ls_cond     TYPE hrcond.

  FIELD-SYMBOLS:
    <ls_1001> TYPE p1001.


  IF pt_1000 IS INITIAL.
    RETURN.
  ENDIF.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1000
    EXPORTING
      pt_i1000 = pt_1000.

* Get NA->CP relationship
  CLEAR lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'CP'.
  APPEND ls_cond
      TO lt_cond.

  CLEAR ls_cond.
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  CLEAR ls_cond-high.
  ls_cond-low = 'A650'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>fill_object_buffer_1001
    EXPORTING
      pt_i1000 = pt_1000
      pt_icond = lt_cond
    IMPORTING
      pt_e1001 = lt_1001.

  LOOP AT lt_1001
       ASSIGNING <ls_1001>.
    ls_hrobject-plvar = <ls_1001>-plvar.
    ls_hrobject-otype = <ls_1001>-sclas.
    ls_hrobject-objid = <ls_1001>-sobid.
    APPEND ls_hrobject
        TO lt_cp.
  ENDLOOP.

  CALL METHOD fill_object_buffer_cp
    EXPORTING
      pt_1000 = lt_cp.

endmethod.


METHOD get .
*
*  One of the import parameters has to be filled.
*
*  The parameters are analyzed in the following sequenze:
*  a) PERSONID
*  b) ID -> PERSONID
*  c) Alias   -> User -> PERSONID
*  d) User    -> PERSONID
*  e) Partner -> PERSONID
*
*  With the ID all other attributes are collected
*  and the object will be created

  DATA l_id TYPE personid.

  DATA l_plvar TYPE plvar.

  DATA l_na_cp     TYPE subtyp VALUE 'A650'.
  DATA l_cp_na     TYPE subtyp VALUE 'B650'.
  DATA l_p_cp      TYPE subtyp VALUE 'A209'.
  DATA l_us_cp     TYPE subtyp VALUE 'A208'.
  DATA l_bp_cp     TYPE subtyp VALUE 'A207'.

  DATA ls_relation TYPE p1001.
  DATA ls_object   TYPE hrobject.
  DATA ls_hrsobid  TYPE hrsobid.
  DATA lt_relation TYPE TABLE OF p1001.
  DATA lt_object   TYPE TABLE OF hrobject.
  DATA ls_hri1001  TYPE hri1001.
  DATA lt_hri1001  TYPE hri1001_tab.

  DATA l_user TYPE xubname.
  DATA l_alias TYPE bapialias.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA local_directory_line TYPE REF TO cl_hrrcf_candidate.

  DATA ls_local_dir_ce_suppl TYPE rcf_s_empl_pers.

  DATA message_par1 TYPE sy-msgv1.

  DATA es_person TYPE hrperson_s.

  DATA lv_msgv1_otype TYPE sy-msgv1.
  DATA lv_msgv2_objid TYPE sy-msgv2.
  DATA:
    lv_subrc TYPE sysubrc.

  CLEAR candidate.

****************************************************
  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = l_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

****************************************************
* check local directory first

  IF NOT personid IS INITIAL.
    lv_msgv1_otype = 'CP'.
    lv_msgv2_objid = personid.
    SORT  local_directory BY table_line->personid.          "N 2293580
    READ TABLE local_directory INTO local_directory_line
                               WITH KEY table_line->personid = personid
                               BINARY SEARCH.               "N 2293580
    IF sy-subrc EQ 0.
      l_id = local_directory_line->personid.
    ENDIF.
  ELSEIF NOT id         IS INITIAL.
    lv_msgv1_otype = 'NA'.
    lv_msgv2_objid = id.
    SORT  local_directory BY table_line->id.                "N 2293580
    READ TABLE local_directory INTO local_directory_line
                               WITH KEY table_line->id = id
                               BINARY SEARCH.               "N 2293580
    IF sy-subrc EQ 0.
      l_id = local_directory_line->personid.
    ENDIF.
  ELSEIF NOT employeeid IS INITIAL.
    lv_msgv1_otype = 'P '.
    lv_msgv2_objid = employeeid.
*   consider CE case.
    IF cl_hrrcf_system_check=>is_ce_enabled = false.
      SORT  local_directory BY table_line->employeeid.      "N 2293580
      READ TABLE local_directory INTO local_directory_line
                      WITH KEY table_line->employeeid = employeeid
                      BINARY SEARCH.                        "N 2293580
      IF sy-subrc EQ 0.
        l_id = local_directory_line->personid.
      ENDIF.
    ELSE.
*     CE case: find related personid and read via this personid
      SORT  local_dir_ce_suppl BY employeeid.               "N 2293580
      READ TABLE local_dir_ce_suppl INTO ls_local_dir_ce_suppl
                     WITH KEY employeeid = employeeid
                     BINARY SEARCH.                         "N 2293580
      IF sy-subrc = 0.
        SORT  local_directory BY table_line->personid.      "N 2293580
        READ TABLE local_directory INTO local_directory_line
                WITH KEY table_line->personid = ls_local_dir_ce_suppl-personid
                BINARY SEARCH.                              "N 2293580
        IF sy-subrc EQ 0.
          l_id = local_directory_line->personid.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSEIF NOT user       IS INITIAL.
    lv_msgv1_otype = 'US'.
    lv_msgv2_objid = user.
    SORT  local_directory BY table_line->user.              "N 2293580
    READ TABLE local_directory INTO local_directory_line
                               WITH KEY table_line->user = user
                               BINARY SEARCH.               "N 2293580
    IF sy-subrc EQ 0.
      l_id = local_directory_line->personid.
    ENDIF.
  ELSEIF NOT alias      IS INITIAL.
    lv_msgv1_otype = 'Alias'.                               "#EC NOTEXT
    lv_msgv2_objid = alias.

    l_alias = alias.

    TRANSLATE l_alias TO UPPER CASE.                     "#EC TRANSLANG

    CALL FUNCTION 'SUSR_USER_BNAME_FROM_ALIAS'
      EXPORTING
        alias          = l_alias
      IMPORTING
        bname          = l_user
      EXCEPTIONS
        no_bname_found = 0
        OTHERS         = 0.
    IF NOT ( l_user IS INITIAL ).
      SORT  local_directory BY table_line->user.            "N 2293580
      READ TABLE local_directory INTO local_directory_line
                             WITH KEY table_line->user = l_user
                             BINARY SEARCH.                 "N 2293580
      IF sy-subrc EQ 0.
        l_id = local_directory_line->personid.
      ENDIF.
    ENDIF.
  ELSEIF NOT partner    IS INITIAL.
    lv_msgv1_otype = 'BP'.
    lv_msgv2_objid = partner.
    SORT  local_directory BY table_line->partner.           "N 2293580
    READ TABLE local_directory INTO local_directory_line
                               WITH KEY table_line->partner = partner
                               BINARY SEARCH.               "N 2293580
    IF sy-subrc EQ 0.
      l_id = local_directory_line->personid.
    ENDIF.
  ENDIF.

  IF l_id IS INITIAL. "read from db
****************************************************
* object has to be instanciated

    IF NOT personid IS INITIAL.
* a) person id is given
      CALL FUNCTION 'HR_CENTRALPERSON_GET'
        EXPORTING
          iv_person_id = personid
        IMPORTING
          es_person    = es_person.
      l_id = es_person-personid.

    ELSEIF NOT id IS INITIAL.

      ls_object-plvar = l_plvar.
      ls_object-otype = 'NA'.
      ls_object-objid = id.

      CALL METHOD cl_hrrcf_object_buffer=>read_relationship
        EXPORTING
          pv_isubty    = l_na_cp
          ps_ihrobject = ls_object
        IMPORTING
          pt_erelation = lt_relation
          pv_esubrc    = lv_subrc.

      IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.

      READ TABLE lt_relation
           INTO  ls_relation
           WITH KEY sclas = 'CP'.
      IF sy-subrc = 0.

        l_id = ls_relation-sobid.

      ENDIF.

    ELSEIF NOT employeeid IS INITIAL.

      ls_object-plvar = l_plvar.
      ls_object-otype = 'P'.
      ls_object-objid = employeeid.

      CALL METHOD cl_hrrcf_object_buffer=>read_relationship
        EXPORTING
          pv_isubty    = l_p_cp
          pv_iwith_ev  = 'X'
          ps_ihrobject = ls_object
        IMPORTING
          pt_erelation = lt_relation
          pv_esubrc    = lv_subrc.

      IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.

      READ TABLE lt_relation
           INTO  ls_relation
           WITH KEY sclas = 'CP'.
      IF sy-subrc = 0.

        l_id = ls_relation-sobid.

      ENDIF.

    ELSEIF   ( NOT alias IS INITIAL )
          OR ( NOT user IS INITIAL  ).
* b) c) alias or user is given

      IF NOT alias IS INITIAL.
* b)  alias is given
        l_alias = alias.

        TRANSLATE l_alias TO UPPER CASE.                 "#EC TRANSLANG

        CALL FUNCTION 'SUSR_USER_BNAME_FROM_ALIAS'
          EXPORTING
            alias          = l_alias
          IMPORTING
            bname          = l_user
          EXCEPTIONS
            no_bname_found = 0
            OTHERS         = 0.
*XDP User does not have to exist
      ELSE.

        l_user = user.

        TRANSLATE l_user TO UPPER CASE.                  "#EC TRANSLANG

        CALL FUNCTION 'SUSR_USER_ALIAS_GET'
          EXPORTING
            user_name           = l_user
          IMPORTING
            alias               = l_alias
          EXCEPTIONS
            user_name_not_exist = 0
            OTHERS              = 0.
*XDP User does not have to exist
      ENDIF.

* c)  user is determined

      IF NOT l_user IS INITIAL.
        ls_hrsobid-plvar = l_plvar.
        ls_hrsobid-otype = 'US'.
        ls_hrsobid-sobid = l_user.

        CALL METHOD cl_hrrcf_object_buffer=>read_relationship
          EXPORTING
            pv_isubty   = l_us_cp
            ps_ihrsobid = ls_hrsobid
          IMPORTING
            pt_ehri1001 = lt_hri1001
            pv_esubrc   = lv_subrc.
        IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
          RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
            EXPORTING
              textid         = cx_hrrcf_infotype_operation=>error_during_read
              message_type   = sy-msgty
              message_class  = sy-msgid
              message_number = sy-msgno
              message_par1   = sy-msgv1
              message_par2   = sy-msgv2
              message_par3   = sy-msgv3
              message_par4   = sy-msgv4.
        ENDIF.

        READ TABLE lt_hri1001
             INTO  ls_hri1001
             WITH KEY sclas = 'CP'.
        IF sy-subrc = 0.

          l_id = ls_hri1001-sobid.

        ENDIF.
      ENDIF.

    ELSEIF NOT partner IS INITIAL.
* d) partner is given
      ls_hrsobid-plvar = l_plvar.
      ls_hrsobid-otype = 'BP'.
      ls_hrsobid-sobid = partner.

      CALL METHOD cl_hrrcf_object_buffer=>read_relationship
        EXPORTING
          pv_isubty   = l_bp_cp
          ps_ihrsobid = ls_hrsobid
        IMPORTING
          pt_ehri1001 = lt_hri1001
          pv_esubrc   = lv_subrc.
      IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.

      READ TABLE lt_hri1001
           INTO  ls_hri1001
           WITH KEY sclas = 'CP'.
      IF sy-subrc = 0.

        l_id = ls_hri1001-sobid.

      ENDIF.

    ENDIF.

  ENDIF. "read from db

  IF l_id IS INITIAL.
    IF 1 EQ 2.
      MESSAGE e009(hrrcf0001) WITH lv_msgv1_otype lv_msgv2_objid.
*   Zu &1 &2 wird kein Kandidat gefunden
    ENDIF.

    RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
      EXPORTING
        textid         = cx_hrrcf_maintain_object=>central_person_not_exist
        message_type   = 'E'
        message_class  = msgcl_admin
        message_number = '009'
        message_par1   = lv_msgv1_otype
        message_par2   = lv_msgv2_objid.
  ENDIF.

  IF NOT local_directory_line IS BOUND.

    REFRESH lt_relation.
    ls_object-plvar = l_plvar.
    ls_object-otype = 'CP'.
    ls_object-objid = l_id.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = l_cp_na
        ps_ihrobject = ls_object
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid         = cx_hrrcf_infotype_operation=>error_during_read
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

    READ TABLE lt_relation
         INTO  ls_relation
         WITH KEY sclas = 'NA'.
    IF sy-subrc = 0.

      ls_object-plvar = ls_relation-plvar.
      ls_object-otype = ls_relation-sclas.
      ls_object-objid = ls_relation-sobid.

    ELSE.
* XLV: For further processing we must not use the CP
      CLEAR ls_object.

    ENDIF.

* get instance from directory or create new instance
    TRY.
        DATA lo_instance TYPE REF TO cl_hrrcf_simple_main_object.
        CALL METHOD cl_hrrcf_candidate=>get_internal
          EXPORTING
            classname = my_classname
            id        = ls_object-objid
            otype     = my_otype
          IMPORTING
            instance  = lo_instance.
      CATCH cx_hrrcf INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            previous = lo_exception.

    ENDTRY.

    candidate ?= lo_instance.

  ELSE.

    candidate = local_directory_line.

  ENDIF.

  IF candidate->personid IS INITIAL. "only candidate itself created

* ID is determined -> set attributes
    TRY.
        CALL METHOD candidate->set_object_ids_internal
          EXPORTING
            personid = l_id.

      CATCH cx_hrrcf INTO lo_exception.

        IF NOT candidate IS INITIAL.
          cl_hrrcf_candidate=>deregister_instance( candidate ).
          CLEAR candidate.
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            previous = lo_exception.

    ENDTRY.
    TRY.
        CALL METHOD candidate->set_bp_attributes_internal
          EXPORTING
            partner = candidate->partner.

      CATCH cx_hrrcf INTO lo_exception.

        IF NOT candidate IS INITIAL.
          cl_hrrcf_candidate=>deregister_instance( candidate ).
          CLEAR candidate.
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            previous = lo_exception.

    ENDTRY.
  ENDIF.

  IF candidate->partner IS INITIAL .

    TRY.
        CALL METHOD candidate->set_object_ids_internal
          EXPORTING
            personid = l_id.

      CATCH cx_hrrcf INTO lo_exception.

        IF NOT candidate IS INITIAL.
          cl_hrrcf_candidate=>deregister_instance( candidate ).
          CLEAR candidate.
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            previous = lo_exception.

    ENDTRY.

    IF candidate->centraldataperson-fullname IS INITIAL .
      TRY.
          CALL METHOD candidate->set_bp_attributes_internal
            EXPORTING
              partner = candidate->partner.

        CATCH cx_hrrcf INTO lo_exception.

          IF NOT candidate IS INITIAL.
            cl_hrrcf_candidate=>deregister_instance( candidate ).
            CLEAR candidate.
          ENDIF.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
              previous = lo_exception.

      ENDTRY.
    ENDIF .

  ENDIF.

ENDMETHOD.                    "


METHOD get_all_comm_channels.

  DATA lt_channel_list TYPE rcf_t_channel_list .
  DATA ls_channel TYPE rcf_s_channel_list .
  DATA lo_ex TYPE REF TO cx_hrrcf .

  TRY .
      CALL METHOD cl_hrrcf_general_bl=>get_comm_channel_list
        EXPORTING
          p_comm_type     = '0000'
        IMPORTING
          pt_channel_list = lt_channel_list.

      READ TABLE lt_channel_list INDEX 1 INTO ls_channel.
      IF sy-subrc EQ 0 .
        MOVE ls_channel-channel TO p_addr_channel.
      ENDIF .

      CALL METHOD cl_hrrcf_general_bl=>get_comm_channel_list
        EXPORTING
          p_comm_type     = '0001'
        IMPORTING
          pt_channel_list = lt_channel_list.


      READ TABLE lt_channel_list INDEX 1 INTO ls_channel.
      IF sy-subrc EQ 0 .
        MOVE ls_channel-channel TO p_tel_channel.
      ENDIF .

      CALL METHOD cl_hrrcf_general_bl=>get_comm_channel_list
        EXPORTING
          p_comm_type     = '0002'
        IMPORTING
          pt_channel_list = lt_channel_list.


      READ TABLE lt_channel_list INDEX 1 INTO ls_channel.
      IF sy-subrc EQ 0 .
        MOVE ls_channel-channel TO p_fax_channel.
      ENDIF .

      CALL METHOD cl_hrrcf_general_bl=>get_comm_channel_list
        EXPORTING
          p_comm_type     = '0003'
        IMPORTING
          pt_channel_list = lt_channel_list.


      READ TABLE lt_channel_list INDEX 1 INTO ls_channel.
      IF sy-subrc EQ 0 .
        MOVE ls_channel-channel TO p_email_channel.
      ENDIF .


    CATCH cx_hrrcf INTO lo_ex .
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_ex .
  ENDTRY .
ENDMETHOD.


METHOD get_applications .

  CONSTANTS c_subty TYPE plog-subty VALUE 'A651'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '651'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA l_objid     TYPE plog-objid.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA lo_application TYPE REF TO cl_hrrcf_candidate_application.
  DATA:
    lv_subrc TYPE sysubrc.
*

  CLEAR application_list.

*Check whether records for the  relationshiptype exists in buffer


  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = application_list.

* if no recprds exist, read from database

  IF application_list IS INITIAL.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = c_subty
        ps_ihrobject = me->hrobject
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
          hrobject = me->hrobject
*       INFOTYPE =
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.
      TRY.

          l_objid = ls_relation-sobid.

          CALL METHOD cl_hrrcf_candidate_application=>get
            EXPORTING
              id          = l_objid
            IMPORTING
              application = lo_application.

          APPEND lo_application TO application_list.

        CATCH cx_hrrcf INTO lo_exception.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
               previous = lo_exception.

      ENDTRY.
    ENDLOOP.

*register records in the buffer

    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = application_list.


  ENDIF.

ENDMETHOD.


METHOD get_assigned_job_families.

  CONSTANTS:
     c_subty TYPE plog-subty VALUE 'A451',
     c_relat TYPE p1001-relat VALUE '451'.

  DATA:
     lt_hri1001 TYPE TABLE OF hri1001,
     ls_hri1001 TYPE hri1001,
     ls_job_family_potential TYPE rcf_s_job_family_potential,
     ls_return TYPE bapiret2,
     ls_jf_level TYPE ptm_s_jf_level,
     lv_stext	TYPE stext,
     lv_count	TYPE rating,
     lv_exc_obj TYPE sy-msgv1,
     lt_proficiencies	TYPE hrpd_profc_tab,
     ls_proficiency TYPE hrpe_profc.

* Call FM HRTM_JF_IT1001_READ_451 to retrieve the HR objects of the job families the candidate is assigned to from infotype HRP1001
  CALL FUNCTION 'HRTM_JF_IT1001_READ_451'
    EXPORTING
      plvar     = me->hrobject-plvar
      otype     = 'P'
      objid     = me->employeeid
      subty     = c_subty
    IMPORTING
      t_hri1001 = lt_hri1001
      s_return  = ls_return.

  IF ls_return IS INITIAL.
    LOOP AT lt_hri1001 INTO ls_hri1001.

      ls_job_family_potential-job_family-plvar = ls_hri1001-plvar.
      ls_job_family_potential-job_family-otype = ls_hri1001-sclas.
      ls_job_family_potential-job_family-objid = ls_hri1001-sobid.
      ls_job_family_potential-begda = ls_hri1001-begda.
      ls_job_family_potential-endda = ls_hri1001-endda.

*	Call function module RH_READ_OBJECT to retrieve the name of the job family
      CALL FUNCTION 'RH_READ_OBJECT'
        EXPORTING
          plvar     = me->hrobject-plvar
          otype     = ls_job_family_potential-job_family-otype
          objid     = ls_job_family_potential-job_family-objid
          langu     = iv_langu
        IMPORTING
          stext     = ls_job_family_potential-job_family_name
        EXCEPTIONS
          not_found = 1
          OTHERS    = 2.
      IF sy-subrc <> 0.
        IF 1 EQ 2.
          MESSAGE e036(hrrcf0001) WITH '&'.                 "#EC *
*   Fehlerhaftes HR-Objekt hat den Schlüssel &1
        ENDIF.

        CONCATENATE ls_hri1001-plvar ls_hri1001-sclas ls_hri1001-sobid
          INTO lv_exc_obj.

        RAISE EXCEPTION TYPE cx_hrrcf_search_ses
          EXPORTING
            textid = cx_hrrcf_search_ses=>cx_hrrcf_search_ses
            message_type = 'E'
            message_class = 'HRRCF0001'
            message_number = '036'
            message_par1 = lv_exc_obj.

      ENDIF.

* Call method READ_VALID_RECORD of class CL_HRTM_T77TM_JF_LEVEL to retrieve the ID of the valid job family scale
      CALL METHOD cl_hrtm_t77tm_jf_level=>read_valid_record
        EXPORTING
          pv_date     = sy-datum
        IMPORTING
          ps_jf_level = ls_jf_level.

*	Call function 'RHPG_SCALE_READ' to retrieve the proficiencies of the scale (= job family levels)
      CALL FUNCTION 'RHPG_SCALE_READ'
        EXPORTING
          langu           = iv_langu
          scale_id        = ls_jf_level-scale_id
        IMPORTING
          stext           = lv_stext
        TABLES
          proficiency     = lt_proficiencies
        EXCEPTIONS
          scale_not_found = 1
          no_authority    = 2
          OTHERS          = 3.
      IF sy-subrc <> 0.
        IF 1 EQ 2.
          MESSAGE e127(hrrcf0001).
        ENDIF.
*   Ausprägungsskala konnte nicht gelesen werden
        RAISE EXCEPTION TYPE cx_hrrcf_cec
          EXPORTING
            message_type = 'E'
            message_class = msgcl_admin
            message_number = '127'.
      ENDIF.

*	Determine the ID and the name of the proficiency (= job family level) the candidate is assigned to.
      ls_job_family_potential-job_family_level = ls_hri1001-adata.

      READ TABLE lt_proficiencies
      WITH KEY rating = ls_job_family_potential-job_family_level
      INTO ls_proficiency.

      ls_job_family_potential-job_family_level_name = ls_proficiency-pstext.
      ls_job_family_potential-scale = ls_jf_level-scale_id.

      APPEND ls_job_family_potential TO et_job_families.
    ENDLOOP.
  ENDIF.
ENDMETHOD.


METHOD GET_BUPA_PARTNERID.
  DATA:
    lv_partnerid  TYPE bu_partner,
    ls_relation   TYPE p1001,
    lt_relation   TYPE TABLE OF p1001,
    lv_subrc      TYPE sysubrc.
*
  CLEAR pv_partnerid.

  CALL METHOD cl_hrrcf_object_buffer=>read_relationship
    EXPORTING
      pv_isubty    = 'B207'
      pv_iwith_ev  = 'X'
      ps_ihrobject = ps_ihrobject
    IMPORTING
      pt_erelation = lt_relation
      pv_esubrc    = lv_subrc.

  IF lv_subrc <> 0.
    RETURN.
  ENDIF.

  READ TABLE lt_relation
       INTO  ls_relation
       INDEX 1.
  IF sy-subrc = 0.
    pv_partnerid = ls_relation-sobid.
  ENDIF.

ENDMETHOD.


METHOD get_candidacy .

  CONSTANTS c_subty TYPE plog-subty VALUE 'A656'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '656'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA l_objid TYPE plog-objid.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA lo_candidacy TYPE REF TO cl_hrrcf_candidacy.
  DATA:
    lv_subrc TYPE sysubrc.
*

  CLEAR candidacy_list.

*Check whether records for the  relationshiptype exists in buffer


  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = candidacy_list.


* if no recprds exist, read from database

  IF candidacy_list IS INITIAL.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = c_subty
        ps_ihrobject = me->hrobject
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc NE 0.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
          hrobject = me->hrobject
*       INFOTYPE =
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.
      TRY.

          l_objid = ls_relation-sobid.

          CALL METHOD cl_hrrcf_candidacy=>get
            EXPORTING
              id        = l_objid
            IMPORTING
              candidacy = lo_candidacy.

          APPEND lo_candidacy TO candidacy_list.

        CATCH cx_hrrcf INTO lo_exception.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
               previous = lo_exception.

      ENDTRY.
    ENDLOOP.

* register records in the buffer

    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = candidacy_list.


  ENDIF.

* only needed for compatibility to old release with missing NA->NE assignments
  DATA lt_application TYPE rcf_t_application.
  DATA lo_application TYPE REF TO cl_hrrcf_candidate_application.
  TRY.
      CALL METHOD me->get_applications
        IMPORTING
          application_list = lt_application.

      LOOP AT lt_application INTO lo_application.
        IF lo_application IS BOUND.

          DATA lt_candidacy TYPE rcf_t_candidacy.
          CALL METHOD lo_application->get_candidacies
            IMPORTING
              candidacy_list = lt_candidacy.

          LOOP AT lt_candidacy INTO lo_candidacy.
            IF lo_candidacy IS BOUND.

              READ TABLE candidacy_list TRANSPORTING NO FIELDS
                WITH KEY table_line->hrobject-objid = lo_candidacy->hrobject-objid.
              IF sy-subrc NE 0.

                APPEND lo_candidacy TO candidacy_list.

              ENDIF.

            ENDIF.
          ENDLOOP.

        ENDIF.
      ENDLOOP.

    CATCH cx_hrrcf .
* no reaction
  ENDTRY.

ENDMETHOD.


METHOD get_candidate_status .
* Author: Joachim Gross
* SGS 08022002

  DATA: lo_cand TYPE REF TO cl_hrrcf_candidate_info.
  DATA: lt_cand TYPE TABLE OF p5102, ls_cand TYPE p5102.
  DATA: lo_exception TYPE REF TO cx_hrrcf.

  DATA lt_cand_txt TYPE rcf_t_cand_info_text .
  DATA ls_cand_txt TYPE rcf_s_cand_info_text .

  TRY.
      CALL METHOD cl_hrrcf_candidate_info=>get_instance
        EXPORTING
          hrobject = me->hrobject
        IMPORTING
          instance = lo_cand.

      IF p_status_txt IS SUPPLIED .

        CALL METHOD lo_cand->get_records_by_date_with_text
          EXPORTING
            p_date         = p_date
            p_language     = p_langu
          IMPORTING
            pt_cand_info_t = lt_cand_txt.

        READ TABLE lt_cand_txt INDEX 1 INTO ls_cand_txt.

        IF sy-subrc IS NOT INITIAL.
          IF 1 = 2.                      "Only for where used list
            MESSAGE e073(hrrcf0001) WITH 'CANDIDATE'.
          ENDIF.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
              message_type = 'E'
              message_class = 'HRRCF0001'
              message_number = 073
              message_par1   = 'CANDIDATE' .

        ENDIF.

        p_status = ls_cand_txt-status.
        p_status_txt = ls_cand_txt-status_txt .

      ELSE .

        CALL METHOD lo_cand->get_records_by_date
          EXPORTING
            date             = p_date
          IMPORTING
            infotype_records = lt_cand.
        READ TABLE lt_cand INDEX 1 INTO ls_cand.
        IF sy-subrc IS NOT INITIAL.
          IF 1 = 2.                  "Only for where used list
            MESSAGE e073(hrrcf0001) WITH 'CANDIDATE'.
          ENDIF.
          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
              message_type = 'E'
              message_class = 'HRRCF0001'
              message_number = 073
              message_par1   = 'CANDIDATE' .
        ENDIF .
        p_status = ls_cand-status.
      ENDIF .
    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_exception
          hrobject = me->hrobject.
  ENDTRY.

ENDMETHOD.                    "GET_CANDIDATE_STATUS


METHOD get_cand_alias .
  DATA:
    lt_return TYPE bapirettab,
    lv_user   TYPE syuname.
*

  CLEAR ps_alias.

  IF me->user IS INITIAL.
    RETURN.
  ENDIF.

  lv_user = me->user.

  TRANSLATE lv_user TO UPPER CASE.                       "#EC TRANSLANG

  CALL FUNCTION 'SUSR_USER_ALIAS_GET'
    EXPORTING
      user_name           = lv_user
    IMPORTING
      alias               = ps_alias
    EXCEPTIONS
      user_name_not_exist = 0
      OTHERS              = 0.

ENDMETHOD.


METHOD get_cand_description .

  DATA : lt_return TYPE bapirettab ,
         ls_return TYPE bapiret2 .

  CALL FUNCTION 'BUPA_DESCRIPTION_GET'
    EXPORTING
      iv_partner     = me->partner
    IMPORTING
      ev_description = cand_description
    TABLES
      et_return      = lt_return.

  IF NOT lt_return IS INITIAL.
    DELETE lt_return WHERE type NE 'E' AND type NE 'A'. "No W or S
    READ TABLE lt_return WITH KEY type = 'A'
      INTO ls_return.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
    READ TABLE lt_return WITH KEY type = 'E'
      INTO ls_return.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD get_cand_resume_for_audit.

* Author: HGB

  DATA: lo_exception    TYPE REF TO cx_hrrcf,
        lo_attachments  TYPE REF TO cl_hrrcf_attachments,
        lo_cand_prev_bl TYPE REF TO cl_hrrcf_candidate_preview_bl.

  CLEAR ps_cand_resume.

  TRY.
*     Get BL facade for Candidate Data Overview
      CALL METHOD cl_hrrcf_candidate_preview_bl=>get_instance
        IMPORTING
          RESULT = lo_cand_prev_bl.

*     Get candidate's résumé for Audit Trail
      CALL METHOD lo_cand_prev_bl->get_cand_resume_for_audit
        EXPORTING
          ps_cand_hrobject = me->hrobject
          p_date           = p_date
          p_language       = p_language
        IMPORTING
          ps_cand_resume   = ps_cand_resume.

*     Copy attachments to save them for Audit Trail
      CALL METHOD cl_hrrcf_attachments=>get_instance
        EXPORTING
          hrobject = me->hrobject
        IMPORTING
          instance = lo_attachments.

      CALL METHOD lo_attachments->update_records_for_audit_trail
        CHANGING
          pt_attachments = ps_cand_resume-attachments.

    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_exception
          hrobject = me->hrobject.
  ENDTRY.

ENDMETHOD.


METHOD get_current_bp_data.

*  DATA lo_exception   TYPE REF TO   cx_hrrcf .

  DATA lt_addrnum     TYPE TABLE OF bapibus1006_addresses_int .
  DATA lt_addressdata TYPE TABLE OF rcf_s_addressdata_bp .

  DATA ls_addrnum     TYPE          bapibus1006_addresses_int .
  DATA ls_addressdata TYPE          rcf_s_addressdata_bp .
  DATA ls_address     TYPE          bapibus1006_address .
  DATA ls_return      TYPE          bapiret2.
  DATA lv_addressguid    TYPE          but020-guid .
  DATA lt_telefondata TYPE TABLE OF rcf_s_telefondata_bp .
  DATA ls_telefondata TYPE          rcf_s_telefondata_bp .
  DATA lt_telefon     TYPE TABLE OF bapiadtel .
  DATA ls_telefon     TYPE          bapiadtel .

  DATA lt_faxdata     TYPE TABLE OF rcf_s_faxdata_bp .
  DATA ls_faxdata     TYPE          rcf_s_faxdata_bp .
  DATA lt_fax         TYPE TABLE OF bapiadfax .
  DATA ls_fax         TYPE          bapiadfax .

  DATA lt_emaildata   TYPE TABLE OF rcf_s_emaildata_bp .
  DATA ls_emaildata   TYPE          rcf_s_emaildata_bp .
  DATA lt_email       TYPE TABLE OF bapiadsmtp .
  DATA ls_email       TYPE          bapiadsmtp .
  DATA lt_comrem      TYPE TABLE OF bapicomrem .
  DATA ls_comrem      TYPE          bapicomrem .

  DATA lv_addr_channel TYPE rcf_comm_channel .
  DATA lv_tel_channel TYPE rcf_comm_channel.
  DATA lv_fax_channel TYPE rcf_comm_channel.
  DATA lv_email_channel TYPE rcf_comm_channel.

  CALL METHOD me->get_all_comm_channels
    IMPORTING
      p_addr_channel  = lv_addr_channel
      p_tel_channel   = lv_tel_channel
      p_fax_channel   = lv_fax_channel
      p_email_channel = lv_email_channel.

  CLEAR : pt_address ,
          pt_telefone ,
          pt_fax,
          pt_email .
*   Get all the address numbers from the Businesspartner
  CALL FUNCTION 'BUPA_ADDRESSES_GET'
    EXPORTING
      iv_partner   = p_partner
    TABLES
      et_addresses = lt_addrnum
      et_return    = return.
  DELETE return WHERE type NE 'E' AND type NE 'A'.     "No W or S
  IF NOT return IS INITIAL .
*     fatal error
    READ TABLE return WITH KEY type = 'A'
                              INTO ls_return.
    IF sy-subrc EQ 0 .
      RAISE EXCEPTION TYPE cx_hrrcf_address_service
        EXPORTING
          textid =
             cx_hrrcf_address_service=>cx_hrrcf_address_service
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF .
*     User error
    READ TABLE return WITH KEY type = 'E'
                          TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      EXIT.  "change control flow
    ENDIF.
  ENDIF .

  LOOP AT lt_addrnum INTO ls_addrnum .
    CLEAR ls_address .
*     For every address number get the addressdata
    MOVE ls_addrnum-addrguid TO lv_addressguid .
    CALL FUNCTION 'BAPI_BUPA_ADDRESS_GETDETAIL'
      EXPORTING
        businesspartner = p_partner
        addressguid     = lv_addressguid
      IMPORTING
        addressdata     = ls_address
      TABLES
        return          = return.
    DELETE return WHERE type NE 'E' AND type NE 'A'. "No W or S
    IF NOT return IS INITIAL .
*       fatal error
      READ TABLE return WITH KEY type = 'A'
                                        INTO ls_return.
      IF sy-subrc EQ 0 .
        RAISE EXCEPTION TYPE cx_hrrcf_address_service
          EXPORTING
            textid =
             cx_hrrcf_address_service=>cx_hrrcf_address_service
            message_type = ls_return-type
            message_class = ls_return-id
            message_number = ls_return-number
            message_par1 = ls_return-message_v1
            message_par2 = ls_return-message_v2
            message_par3 = ls_return-message_v3
            message_par4 = ls_return-message_v4.
      ENDIF .
*       User error
      READ TABLE return WITH KEY type = 'E'
                           TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        EXIT.  "change control flow
      ENDIF.
    ENDIF .
    MOVE ls_addrnum-addrnumber TO ls_addressdata-addrnr .
    MOVE lv_addr_channel TO ls_addressdata-channel .
    MOVE-CORRESPONDING ls_address TO ls_addressdata .
    APPEND ls_addressdata TO pt_address .
  ENDLOOP .

  CALL FUNCTION 'BAPI_BUPA_CENTRAL_GETDETAIL'
    EXPORTING
      businesspartner              = p_partner
    TABLES
      telefondatanonaddress        = lt_telefon
      faxdatanonaddress            = lt_fax
      e_maildatanonaddress         = lt_email
      communicationnotesnonaddress = lt_comrem
      return                       = return.

  APPEND LINES OF return TO return .

  DELETE return WHERE type NE 'E' AND type NE 'A'.     "No W or S
  IF NOT return IS INITIAL.
*   fatal error
    READ TABLE return WITH KEY type = 'A'
                              INTO ls_return.
    IF sy-subrc EQ 0 .
      RAISE EXCEPTION TYPE cx_hrrcf_address_service
        EXPORTING
          textid =
             cx_hrrcf_address_service=>cx_hrrcf_address_service
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF .
*   User error
    READ TABLE return WITH KEY type = 'E'
                          TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      EXIT.  "change control flow
    ENDIF.
  ENDIF .

* Process telefon data
  LOOP AT lt_telefon INTO ls_telefon .
    MOVE-CORRESPONDING ls_telefon TO ls_telefondata .
    MOVE lv_tel_channel TO ls_telefondata-channel .
    APPEND ls_telefondata TO pt_telefone .
  ENDLOOP .

* Process Fax data
  LOOP AT lt_fax INTO ls_fax .
    MOVE-CORRESPONDING ls_fax TO ls_faxdata .
    MOVE lv_fax_channel TO ls_faxdata-channel .
    APPEND ls_faxdata TO pt_fax .
  ENDLOOP .

* Process e-mail data
  LOOP AT lt_email INTO ls_email .
    MOVE-CORRESPONDING ls_email TO ls_emaildata .
    MOVE lv_email_channel TO ls_emaildata-channel .
    APPEND ls_emaildata TO pt_email .
  ENDLOOP .

ENDMETHOD.


method GET_EMPLOYEE_ID.
  DATA lx TYPE REF TO cx_hrrcf.
  "WG/N2202046
  IF iv_assure_active_pernr = abap_false.
    rv_employee_id = employeeid.
  ELSE.
    TRY.
        get_employee_ids(
           IMPORTING
             ev_latest_active_id = employeeid ).
      CATCH cx_hrrcf INTO lx.
        "rv_employee_id = employeeid.
        cl_hrrcf_exception_handler=>write_exception_log( lx ).
    ENDTRY.
  ENDIF.

ENDMETHOD.


METHOD get_employee_ids.

  "WG/N2202046
*
* This methods determines the latest active
* employee id of a candidate
* (examples:
*   - CE-case: there might exist several ID's,
*   - global employees
*   - ... )
  DATA ltr_stat2_active TYPE RANGE OF p5580-stat2.
  DATA lsr_stat2 LIKE LINE OF ltr_stat2_active.

  DATA lc_cp_p      TYPE subtyp VALUE 'B209'.
  DATA lc_func_hr_read_infotype TYPE funcname VALUE 'HR_READ_INFOTYPE'.
  DATA lo_exception    TYPE REF TO cx_hrrcf.
  DATA ls_object TYPE hrobject.
  DATA lv_subrc  TYPE sy-subrc.
  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation LIKE LINE OF lt_relation.
  DATA lx TYPE REF TO cx_hrrcf.

  DATA lt_employee_id  TYPE TABLE OF pernr_d.
  DATA lt_id_active   TYPE TABLE OF pernr_d.
  DATA lt_id_inactive TYPE TABLE OF pernr_d.
  DATA lv_active_lines TYPE sy-tabix.
  DATA lv_inactive_lines TYPE sy-tabix.


  DATA lrt_pnnnn TYPE REF TO data.
  DATA lrs_pnnnn TYPE REF TO data.
  FIELD-SYMBOLS <pnnnnt> TYPE STANDARD TABLE .
  FIELD-SYMBOLS <pnnnn>  TYPE ANY.



  DATA: BEGIN OF ls_empl_stat_info ,
           pernr TYPE hrobject-objid,
           stat2 TYPE p5580-stat2,
           begda TYPE begda,
           endda TYPE endda,
        END OF ls_empl_stat_info.

  DATA lt_empl_stat_info LIKE STANDARD TABLE OF ls_empl_stat_info.
  "WITH UNIQUE KEY stat2 begda pernr.

  "preparation
  lsr_stat2-sign = 'I'.
  lsr_stat2-option = 'EQ'.
  lsr_stat2-low = '3'.
  INSERT lsr_stat2 INTO TABLE ltr_stat2_active .

  IF is_employee( ) = abap_false.
    "should be checked before calling this service
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read.
  ELSE.
    "2. find active ID's
    "2.1 read determining data

    "in the following we use the list of personnel assignemnts
    "(CP -1001/286-> P) and join this with the activiation
    "status of 0000/5580
    "(different approach would be to forget about this data and only read
    "from 5580 to find the 'relavant' PERNR)

    "currently, reading at the key-date is sufficient, since
    "in E-rec the selection date is always the sy-datum (???)
    IF iv_keydate = sy-datum .
      lt_employee_id = get_personnel_assignments( ).
    ELSE.
      "just for the case it is called with a key date different
      "from the system date: get hold of the cp->p relations
      ls_object-plvar = hrobject-plvar.
      ls_object-otype = 'CP'.
      ls_object-objid = personid.

      cl_hrrcf_object_buffer=>read_relationship(
        EXPORTING
          pv_isubty    = lc_cp_p
          pv_iwith_ev  = 'X'
          ps_ihrobject = ls_object
          pv_ibegda    = iv_keydate
          pv_iendda    = iv_keydate
        IMPORTING
          pt_erelation = lt_relation
          pv_esubrc    = lv_subrc ).

      IF lv_subrc <> 0.
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
        CREATE OBJECT lx
          TYPE
            cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_read
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

        cl_hrrcf_exception_handler=>write_exception_log( lx ).

      ENDIF.

      SORT lt_relation BY begda.
      LOOP AT lt_relation INTO ls_relation
        WHERE sclas = 'P'.
        ls_empl_stat_info-pernr = ls_relation-sobid.
        INSERT ls_empl_stat_info-pernr INTO TABLE lt_employee_id.
      ENDLOOP.
    ENDIF.

    CASE cl_hrrcf_system_check=>is_standalone.
      WHEN abap_false.
        "non-stand-alone case: SAP_HRRXX is available!
        "PA-repository objects do exist!
        "pa-infotypes are updated by ALE-distribution
        CREATE DATA lrs_pnnnn TYPE ('P0000').
        ASSIGN lrs_pnnnn->* TO <pnnnn>.
        CREATE DATA lrt_pnnnn LIKE TABLE OF <pnnnn>.
        ASSIGN lrt_pnnnn->* TO <pnnnnt>.

        LOOP AT lt_employee_id INTO ls_empl_stat_info-pernr.
          CLEAR <pnnnnt>.
          CALL FUNCTION lc_func_hr_read_infotype            "#EC EXISTS
            EXPORTING
              pernr           = ls_empl_stat_info-pernr
              infty           = '0000'
              begda           =  iv_keydate
              endda           =  iv_keydate
            TABLES
              infty_tab       = <pnnnnt>
            EXCEPTIONS
              infty_not_found = 1
              OTHERS          = 2.

          IF sy-subrc <> 0.
            CREATE OBJECT lx
              TYPE
                cx_hrrcf_infotype_operation
              EXPORTING
                textid = cx_hrrcf_infotype_operation=>error_during_read
                message_type = sy-msgty
                message_class = sy-msgid
                message_number = sy-msgno
                message_par1 = sy-msgv1
                message_par2 = sy-msgv2
                message_par3 = sy-msgv3
                message_par4 = sy-msgv4.

            cl_hrrcf_exception_handler=>write_exception_log( lx ).
          ELSE.
            LOOP AT <pnnnnt> ASSIGNING <pnnnn>.
              MOVE-CORRESPONDING <pnnnn> TO ls_empl_stat_info.
              READ TABLE lt_employee_id TRANSPORTING NO FIELDS
               WITH KEY table_line = ls_empl_stat_info-pernr.
              IF sy-subrc = 0.
                INSERT ls_empl_stat_info INTO TABLE lt_empl_stat_info.
              ELSE.
                "inconsistency?
                RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
                  EXPORTING
                    textid = cx_hrrcf_infotype_operation=>error_during_read.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDLOOP.
      WHEN abap_true.
        "standalone case:
        "PA-repository is not available
        "ALE maintains 5580 instead of 0000
        CREATE DATA lrs_pnnnn TYPE ('P5580').
        ASSIGN lrs_pnnnn->* TO <pnnnn>.
        CREATE DATA lrt_pnnnn LIKE TABLE OF <pnnnn>.
        ASSIGN lrt_pnnnn->* TO <pnnnnt>.

        "read status-entries for central person
        CALL FUNCTION 'RH_READ_INFTY'
          EXPORTING
            infty         = '5580'
            istat         = '1'
            plvar         = hrobject-plvar
            otype         = 'CP'
            objid         = personid
            begda         = iv_keydate
            endda         = iv_keydate
          TABLES
            innnn         = <pnnnnt>
          EXCEPTIONS
            nothing_found = 1
            OTHERS        = 2.

        IF sy-subrc <> 0 .
**          CREATE OBJECT lx         "N_2448992
**            TYPE
**              cx_hrrcf_infotype_operation
**            EXPORTING
**              textid = cx_hrrcf_infotype_operation=>error_during_read
**              message_type = sy-msgty
**              message_class = sy-msgid
**              message_number = sy-msgno
**              message_par1 = sy-msgv1
**              message_par2 = sy-msgv2
**              message_par3 = sy-msgv3
**              message_par4 = sy-msgv4.
**          cl_hrrcf_exception_handler=>write_exception_log( lx ).
        ELSE.
          LOOP AT <pnnnnt> ASSIGNING <pnnnn>.
            MOVE-CORRESPONDING <pnnnn> TO ls_empl_stat_info.
            READ TABLE lt_employee_id TRANSPORTING NO FIELDS
             WITH KEY table_line = ls_empl_stat_info-pernr.
            IF sy-subrc = 0.
              INSERT ls_empl_stat_info INTO TABLE lt_empl_stat_info.
            ELSE.
              "inconsistency?
              RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
                EXPORTING
                  textid = cx_hrrcf_infotype_operation=>error_during_read.
            ENDIF.
          ENDLOOP.
        ENDIF.
    ENDCASE.

    "Fallback: in case there is neither 5580 nor 0000 (should not occur in a real system,
    "in a test environment it might, however) everything is regarded active
    IF lt_empl_stat_info IS INITIAL.
      LOOP AT lt_employee_id INTO ls_empl_stat_info-pernr.
        ls_empl_stat_info-stat2 = '3'.
        ls_empl_stat_info-begda = ls_empl_stat_info-endda = iv_keydate.
        INSERT ls_empl_stat_info INTO TABLE lt_empl_stat_info.
      ENDLOOP.
    ENDIF.


    "3. evaluate records in order to find THE active PERNR
    "a) keep only active records, but only if there
    "   are any: if not, return the latest inactive employee-id
    " that could go into a BAdi laterm if required
    CLEAR: ev_latest_active_id,
           ev_earliest_active_id,
           ev_latest_inactive_id,
           ev_earliest_inactive_id,
           et_active_id,
           et_inactive_id.

    SORT lt_empl_stat_info BY
                         begda DESCENDING
                         pernr DESCENDING.

    "separation into active inactive
    "respecting the date and pernr order
    LOOP AT lt_empl_stat_info INTO ls_empl_stat_info.
      IF ls_empl_stat_info-stat2 IN ltr_stat2_active.
        APPEND ls_empl_stat_info-pernr TO lt_id_active.
      ELSE.
        APPEND ls_empl_stat_info-pernr TO lt_id_inactive.
      ENDIF.
    ENDLOOP.

    lv_active_lines = LINES( lt_id_active ).
    lv_inactive_lines = LINES( lt_id_inactive ).

    READ TABLE lt_id_inactive:
       INDEX 1 INTO ev_latest_inactive_id,
       INDEX lv_inactive_lines INTO ev_earliest_inactive_id.

    READ TABLE lt_id_active:
       INDEX 1 INTO ev_latest_active_id,
       INDEX lv_inactive_lines INTO ev_earliest_active_id.

    SORT:
      lt_id_active, lt_id_inactive.
    DELETE ADJACENT DUPLICATES FROM:
      lt_id_active, lt_id_inactive.

    INSERT LINES OF:
        lt_id_active INTO TABLE et_active_id,
        lt_id_inactive INTO TABLE et_inactive_id.

  ENDIF.
ENDMETHOD.


METHOD get_notes.
  CALL METHOD cl_hrrcf_t77rcf_candnotes=>read_by_cand
    EXPORTING
      is_candt = hrobject
    IMPORTING
      et_notes = et_notes.
ENDMETHOD.


METHOD GET_OLD_COMM_DATA .

  TYPES :
    BEGIN OF address_struc,
      channel TYPE rcf_comm_channel,
      addrnr TYPE ad_addrnum,
      cons_number TYPE ad_consnum,
      available TYPE rcf_comm_available,
    END OF address_struc .

*  DATA lo_exception   TYPE REF TO   cx_hrrcf .

  DATA lt_addrnum     TYPE TABLE OF bapibus1006_addresses_int .
  DATA lt_addressdata TYPE TABLE OF rcf_s_addressdata_bp .

  DATA ls_p5110       TYPE          p5110 .
  DATA ls_addrnum     TYPE          bapibus1006_addresses_int .
  DATA ls_addressdata TYPE          rcf_s_addressdata_bp .
  DATA ls_address     TYPE          bapibus1006_address .
  DATA ls_return      TYPE          bapiret2.
  DATA lv_addressguid    TYPE          but020-guid .
  DATA lt_telefondata TYPE TABLE OF rcf_s_telefondata_bp .
  DATA ls_telefondata TYPE          rcf_s_telefondata_bp .
  DATA lt_telefon     TYPE TABLE OF bapiadtel .
  DATA ls_telefon     TYPE          bapiadtel .

  DATA lt_faxdata     TYPE TABLE OF rcf_s_faxdata_bp .
  DATA ls_faxdata     TYPE          rcf_s_faxdata_bp .
  DATA lt_fax         TYPE TABLE OF bapiadfax .
  DATA ls_fax         TYPE          bapiadfax .

  DATA lt_emaildata   TYPE TABLE OF rcf_s_emaildata_bp .
  DATA ls_emaildata   TYPE          rcf_s_emaildata_bp .
  DATA lt_email       TYPE TABLE OF bapiadsmtp .
  DATA ls_email       TYPE          bapiadsmtp .
  DATA lt_comrem      TYPE TABLE OF bapicomrem .
  DATA ls_comrem      TYPE          bapicomrem .

  DATA infty_struc    TYPE          address_struc .

  CLEAR : pt_address ,
          pt_telefone ,
          pt_fax,
          pt_email .

* Process other communication types
  CHECK pt_5110 IS NOT INITIAL .

  READ TABLE pt_5110 WITH KEY subty = '0000'
                           TRANSPORTING NO FIELDS .
  IF sy-subrc EQ 0 .
*   Get all the address numbers from the Businesspartner
    CALL FUNCTION 'BUPA_ADDRESSES_GET'
      EXPORTING
        iv_partner   = p_partner
      TABLES
        et_addresses = lt_addrnum
        et_return    = return.
    DELETE return WHERE type NE 'E' AND type NE 'A'.     "No W or S
    IF NOT return IS INITIAL .
*     fatal error
      READ TABLE return WITH KEY type = 'A'
                                INTO ls_return.
      IF sy-subrc EQ 0 .
        RAISE EXCEPTION TYPE cx_hrrcf_address_service
          EXPORTING
            textid =
               cx_hrrcf_address_service=>cx_hrrcf_address_service
            message_type = ls_return-type
            message_class = ls_return-id
            message_number = ls_return-number
            message_par1 = ls_return-message_v1
            message_par2 = ls_return-message_v2
            message_par3 = ls_return-message_v3
            message_par4 = ls_return-message_v4.
      ENDIF .
*     User error
      READ TABLE return WITH KEY type = 'E'
                            TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        EXIT.  "change control flow
      ENDIF.
    ENDIF .

    LOOP AT lt_addrnum INTO ls_addrnum .
      CLEAR ls_address .
*     For every address number get the addressdata
      MOVE ls_addrnum-addrguid TO lv_addressguid .
      CALL FUNCTION 'BAPI_BUPA_ADDRESS_GETDETAIL'
        EXPORTING
          businesspartner = p_partner
          addressguid     = lv_addressguid
        IMPORTING
          addressdata     = ls_address
        TABLES
          return          = return.
      DELETE return WHERE type NE 'E' AND type NE 'A'. "No W or S
      IF NOT return IS INITIAL .
*       fatal error
        READ TABLE return WITH KEY type = 'A'
                                          INTO ls_return.
        IF sy-subrc EQ 0 .
          RAISE EXCEPTION TYPE cx_hrrcf_address_service
            EXPORTING
              textid =
               cx_hrrcf_address_service=>cx_hrrcf_address_service
              message_type = ls_return-type
              message_class = ls_return-id
              message_number = ls_return-number
              message_par1 = ls_return-message_v1
              message_par2 = ls_return-message_v2
              message_par3 = ls_return-message_v3
              message_par4 = ls_return-message_v4.
        ENDIF .
*       User error
        READ TABLE return WITH KEY type = 'E'
                             TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          EXIT.  "change control flow
        ENDIF.
      ENDIF .
      READ TABLE pt_5110 INTO ls_p5110 WITH KEY subty =
                                            '0000' .
      MOVE ls_addrnum-addrnumber TO ls_addressdata-addrnr .
      MOVE-CORRESPONDING ls_address TO ls_addressdata .
      CLEAR infty_struc .
      DO 10 TIMES : VARYING infty_struc-addrnr
                    FROM ls_p5110-addrnumber01 NEXT
                    ls_p5110-addrnumber02
                    VARYING infty_struc-channel
                    FROM ls_p5110-channel01 NEXT
                    ls_p5110-channel02
                    VARYING infty_struc-cons_number
                    FROM ls_p5110-consnumber01 NEXT
                    ls_p5110-consnumber02
                    VARYING infty_struc-available
                    FROM ls_p5110-available01 NEXT
                    ls_p5110-available02 .
        IF ls_addrnum-addrnumber EQ infty_struc-addrnr .
          MOVE infty_struc-channel TO ls_addressdata-channel .
          MOVE infty_struc-available TO
                    ls_addressdata-availability .
          APPEND ls_addressdata TO lt_addressdata .
          EXIT .
        ENDIF .
      ENDDO .
    ENDLOOP .
*   move data to the attributes
    MOVE lt_addressdata TO pt_address .
  ENDIF .

  CALL FUNCTION 'BAPI_BUPA_CENTRAL_GETDETAIL'
    EXPORTING
      businesspartner              = p_partner
    TABLES
      telefondatanonaddress        = lt_telefon
      faxdatanonaddress            = lt_fax
      e_maildatanonaddress         = lt_email
      communicationnotesnonaddress = lt_comrem
      return                       = return.

  APPEND LINES OF return TO return .

  DELETE return WHERE type NE 'E' AND type NE 'A'.     "No W or S
  IF NOT return IS INITIAL.
*   fatal error
    READ TABLE return WITH KEY type = 'A'
                              INTO ls_return.
    IF sy-subrc EQ 0 .
      RAISE EXCEPTION TYPE cx_hrrcf_address_service
        EXPORTING
          textid =
             cx_hrrcf_address_service=>cx_hrrcf_address_service
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF .
*   User error
    READ TABLE return WITH KEY type = 'E'
                          TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      EXIT.  "change control flow
    ENDIF.
  ENDIF .
* Process telefon data
  READ TABLE pt_5110 INTO ls_p5110 WITH KEY subty = '0001' .
  IF sy-subrc EQ 0 .
    LOOP AT lt_telefon INTO ls_telefon .
      MOVE-CORRESPONDING ls_telefon TO ls_telefondata .
      CLEAR infty_struc .
      DO 10 TIMES : VARYING infty_struc-addrnr
                    FROM ls_p5110-addrnumber01 NEXT
                    ls_p5110-addrnumber02
                    VARYING infty_struc-channel
                    FROM ls_p5110-channel01 NEXT
                    ls_p5110-channel02
                    VARYING infty_struc-cons_number
                    FROM ls_p5110-consnumber01 NEXT
                    ls_p5110-consnumber02
                    VARYING infty_struc-available
                    FROM ls_p5110-available01 NEXT
                    ls_p5110-available02 .
        IF ls_telefon-consnumber EQ infty_struc-cons_number .
          MOVE infty_struc-channel TO ls_telefondata-channel .
          MOVE infty_struc-available TO ls_telefondata-availability .
          APPEND ls_telefondata TO lt_telefondata .
          EXIT .
        ENDIF .
      ENDDO .
    ENDLOOP .
    MOVE lt_telefondata TO pt_telefone .
  ENDIF .

* Process Fax data
  READ TABLE pt_5110 INTO ls_p5110 WITH KEY subty = '0002' .
  IF sy-subrc EQ  0 .
    LOOP AT lt_fax INTO ls_fax .
      MOVE-CORRESPONDING ls_fax TO ls_faxdata .
      CLEAR infty_struc .
      DO 10 TIMES : VARYING infty_struc-addrnr
                    FROM ls_p5110-addrnumber01 NEXT
                    ls_p5110-addrnumber02
                    VARYING infty_struc-channel
                    FROM ls_p5110-channel01 NEXT
                    ls_p5110-channel02
                    VARYING infty_struc-cons_number
                    FROM ls_p5110-consnumber01 NEXT
                    ls_p5110-consnumber02
                    VARYING infty_struc-available
                    FROM ls_p5110-available01 NEXT
                    ls_p5110-available02 .
        IF ls_fax-consnumber EQ infty_struc-cons_number .
          MOVE infty_struc-channel TO ls_faxdata-channel .
          MOVE infty_struc-available TO ls_faxdata-availability .
          APPEND ls_faxdata TO lt_faxdata .
          EXIT .
        ENDIF .
      ENDDO .
    ENDLOOP .
    MOVE lt_faxdata TO pt_fax .
  ENDIF .

* Process e-mail data
  READ TABLE pt_5110 INTO ls_p5110 WITH KEY subty = '0003' .
  IF sy-subrc EQ 0 .
    LOOP AT lt_email INTO ls_email .
      MOVE-CORRESPONDING ls_email TO ls_emaildata .
      CLEAR infty_struc .
*     Communication notes addition to be implimented
      DO 10 TIMES : VARYING infty_struc-addrnr
                    FROM ls_p5110-addrnumber01 NEXT
                    ls_p5110-addrnumber02
                    VARYING infty_struc-channel
                    FROM ls_p5110-channel01 NEXT
                    ls_p5110-channel02
                    VARYING infty_struc-cons_number
                    FROM ls_p5110-consnumber01 NEXT
                    ls_p5110-consnumber02
                    VARYING infty_struc-available
                    FROM ls_p5110-available01 NEXT
                    ls_p5110-available02 .
        IF ls_email-consnumber EQ infty_struc-cons_number .
          MOVE infty_struc-channel TO ls_emaildata-channel .
          MOVE infty_struc-available TO ls_emaildata-availability .
          APPEND ls_emaildata TO lt_emaildata .
          EXIT .
        ENDIF .
      ENDDO .
    ENDLOOP .
    MOVE lt_emaildata TO pt_email .
  ENDIF .

ENDMETHOD.


method GET_PERSONID_EXTERNAL.
   r_personid_external = personid_external.
endmethod.


METHOD get_personnel_assignments.

  et_personnel_assignments[] = gt_employeeid[].

ENDMETHOD.


METHOD get_tg.
*
  CONSTANTS c_subty TYPE plog-subty VALUE 'A658'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '658'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA l_objid TYPE plog-objid.

  DATA lo_exception TYPE REF TO cx_hrrcf.

*  DATA lo_object TYPE REF TO object.
  DATA lo_tg TYPE REF TO cl_hrrcf_tg.
  DATA:
    lv_subrc TYPE sysubrc.
*

  CLEAR tg_list.

*Check whether records for the  relationshiptype exists in buffer

  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = tg_list.


* if no recprds exist, read from database

  IF tg_list IS INITIAL.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = c_subty
        ps_ihrobject = me->hrobject
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc NE 0.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
          hrobject = me->hrobject
*       INFOTYPE =
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.
      TRY.

          l_objid = ls_relation-sobid.

          CALL METHOD cl_hrrcf_tg=>get
            EXPORTING
              id          = l_objid
            IMPORTING
              talentgroup = lo_tg.

          APPEND lo_tg TO tg_list.

        CATCH cx_hrrcf INTO lo_exception.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
               previous = lo_exception.

      ENDTRY.
    ENDLOOP.

* register records in the buffer

    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = tg_list.

  ENDIF.

ENDMETHOD.


METHOD get_tg_with_period.
*
  CONSTANTS c_subty TYPE plog-subty VALUE 'A658'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '658'.
*
  DATA lt_relation  TYPE TABLE OF p1001.
  DATA ls_relation  TYPE          p1001.
  DATA l_objid      TYPE plog-objid.
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA ls_tg        TYPE rcf_s_tg_with_period.
  DATA lv_subrc TYPE sysubrc.
*
  CLEAR tg_list.
*Check whether records for the  relationshiptype exists in buffer
  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = tg_list.
* if no records exist, read from database
  IF tg_list IS INITIAL.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = c_subty
        ps_ihrobject = me->hrobject
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc NE 0.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
          hrobject = me->hrobject
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.
      TRY.
          l_objid = ls_relation-sobid.
          ls_tg-begda = ls_relation-begda.
          ls_tg-endda = ls_relation-endda.
          ls_tg-assigned_by = ls_relation-uname.

          CALL METHOD cl_hrrcf_tg=>get
            EXPORTING
              id          = l_objid
            IMPORTING
              talentgroup = ls_tg-talentgroup.
          APPEND ls_tg TO tg_list.
          CLEAR ls_tg.
        CATCH cx_hrrcf INTO lo_exception.
          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
               previous = lo_exception.
      ENDTRY.
    ENDLOOP.
* register records in the buffer
    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = tg_list.
  ENDIF.

ENDMETHOD.


METHOD insert_note.
  CALL METHOD cl_hrrcf_t77rcf_candnotes=>insert
    EXPORTING
      is_candt = hrobject
      iv_note  = iv_note.
ENDMETHOD.


METHOD instantiate_candidates.
  TYPES:
    BEGIN OF ty_sort,
          lastname  TYPE bu_namep_f,
          firstname TYPE bu_namep_f,
          partner   TYPE bu_partner,
    END OF ty_sort.

  DATA:
    lt_sort       TYPE TABLE OF ty_sort,
    ls_sort       TYPE          ty_sort,
    lv_plvar      TYPE plvar,
    lt_p1001      TYPE TABLE OF p1001,
    ls_object     TYPE hrobject,
    lt_object     TYPE TABLE OF hrobject,
    ls_hrsobid    TYPE hrsobid,
    lt_hrsobid    TYPE hrtb_sobid,
    lt_hri1001    TYPE hri1001_tab,
    ls_partner    TYPE bu_partner,
    lo_candidate  TYPE REF TO cl_hrrcf_candidate.

  FIELD-SYMBOLS:
    <ls_sort>     TYPE ty_sort,
    <ls_partner>  TYPE bu_partner,
    <ls_hri1001>  TYPE hri1001,
    <ls_p1001>    TYPE p1001,
    <ls_object>   TYPE hrobject.

  CONSTANTS:
    c_cp_na       TYPE subtyp VALUE 'B650',
    c_bp_cp       TYPE subtyp VALUE 'A207'.

  CLEAR pt_ebupartner.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = lv_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

* get central person for the business partner

  LOOP AT pt_ibupartner
       ASSIGNING <ls_partner>.
    ls_hrsobid-plvar = lv_plvar.
    ls_hrsobid-otype = 'BP'.
    ls_hrsobid-sobid = <ls_partner>.
    APPEND ls_hrsobid
        TO lt_hrsobid.
  ENDLOOP.

  CALL FUNCTION 'RH_READ_INFTY_1001_EXT'
   EXPORTING
      authority             = ' '
      with_stru_auth        = ' '
      istat                 = '1'
*     EXTEND                = 'X'
      subty                 = c_bp_cp
      begda                 = low_date
      endda                 = high_date
*     CONDITION             = '00000'
      sort                  = ' '
*     WITH_EV_FOR_INT       = ' '
*     WITH_EV_FOR_EXT       = 'X'
*     ADATA                 = 'X'
*     KEEP_VARYF            = ' '
*     AUTH_SOBID            = ' '
    TABLES
      i1001                 = lt_hri1001
      OBJECTS               = lt_hrsobid
   EXCEPTIONS
     nothing_found         = 1
     wrong_condition       = 2
     OTHERS                = 3.
  IF sy-subrc <> 0.
    EXIT.
  ENDIF.

  LOOP AT lt_hri1001
       ASSIGNING <ls_hri1001>.
    ls_object-plvar = <ls_hri1001>-plvar.
    ls_object-otype = <ls_hri1001>-sclas.
    ls_object-objid = <ls_hri1001>-sobid.
    APPEND ls_object
        TO lt_object.
  ENDLOOP.

* get candidate for the central person from 1001 relation
  CALL FUNCTION 'RH_READ_INFTY_1001'
   EXPORTING
      authority              = ' '
      with_stru_auth         = ' '
      istat                  = '1'
*     EXTEND                 = 'X'
      subty                  = c_cp_na
      begda                  = low_date
      endda                  = high_date
*     CONDITION              = '00000'
      sort                   = ' '
      with_ev                = ' '
*     ADATA                  = 'X'
*     AUTH_SOBID             = ' '
    TABLES
      i1001                  = lt_p1001
      OBJECTS                = lt_object
   EXCEPTIONS
      nothing_found          = 1
      wrong_condition        = 2
      wrong_parameters       = 3
      OTHERS                 = 4.
  IF sy-subrc <> 0.
    EXIT.
  ENDIF.

  SORT lt_p1001
    BY objid.

  CLEAR lt_object[].
* Determine the BPs which have a candidate assigned via CP
  LOOP AT        lt_hri1001
       ASSIGNING <ls_hri1001>. "BP->CP
IF <ls_hri1001>-BEGDA LE sy-datum AND <ls_hri1001>-ENDDA GE sy-datum.

    READ TABLE     lt_p1001 "CP->NA
         WITH KEY  objid =  <ls_hri1001>-sobid              "#EC *
         ASSIGNING <ls_p1001>
         BINARY SEARCH.
    IF sy-subrc = 0.
      ls_object-plvar = <ls_p1001>-plvar.
      ls_object-otype = <ls_p1001>-sclas.
      ls_object-objid = <ls_p1001>-sobid.
      APPEND ls_object
          TO lt_object.  "NA
    ENDIF.
ENDIF.
  ENDLOOP.

  CALL METHOD cl_hrrcf_candidate=>fill_object_buffer_na
    EXPORTING
      pt_1000 = lt_object.

* Instantiate candidates with NA-objid. Using the partner id is
* more time consuming.
  LOOP AT lt_object
       ASSIGNING <ls_object>.
    TRY.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = <ls_object>-objid
          IMPORTING
            candidate = lo_candidate.
        ls_sort-lastname  = lo_candidate->centraldataperson-lastname.
        ls_sort-firstname = lo_candidate->centraldataperson-firstname.
        ls_sort-partner   = lo_candidate->partner.
        APPEND ls_sort
            TO lt_sort.
      CATCH cx_hrrcf .                                  "#EC NO_HANDLER
    ENDTRY.
  ENDLOOP.

  SORT lt_sort AS TEXT.
  LOOP AT        lt_sort
       ASSIGNING <ls_sort>.
    APPEND <ls_sort>-partner
        TO pt_ebupartner.
  ENDLOOP.

  CALL METHOD cl_hrrcf_object_buffer=>refresh_object_buffer.

ENDMETHOD.


METHOD is_candidate .
  DATA l_plvar TYPE plvar.
  DATA l_id        TYPE personid.
  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE p1001.
  DATA ls_object   TYPE hrobject.
  DATA ls_hrsobid  TYPE hrsobid.
  DATA ls_hri1001  TYPE hri1001.
  DATA lt_hri1001  TYPE hri1001_tab.
  DATA lv_subrc    TYPE sysubrc.


  CONSTANTS: c_cp_na     TYPE subtyp VALUE 'B650',
             c_bp_cp     TYPE subtyp VALUE 'A207'.

  is_candidate = false.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = l_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

* get central person for the business partner
  ls_hrsobid-plvar = l_plvar.
  ls_hrsobid-otype = 'BP'.
  ls_hrsobid-sobid = partner.

  CALL METHOD cl_hrrcf_object_buffer=>read_relationship
    EXPORTING
      pv_isubty   = c_bp_cp
      ps_ihrsobid = ls_hrsobid
    IMPORTING
      pt_ehri1001 = lt_hri1001
      pv_esubrc   = lv_subrc.
  IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ENDIF.

  READ TABLE lt_hri1001
       INTO  ls_hri1001
       WITH KEY sclas = 'CP'.
  IF sy-subrc = 0.

    l_id = ls_hri1001-sobid.

  ENDIF.

* get candidate for the central person from 1001 relation
  CHECK NOT l_id IS INITIAL.

  REFRESH lt_relation.
  ls_object-plvar = l_plvar.
  ls_object-otype = 'CP'.
  ls_object-objid = l_id.

  CALL METHOD cl_hrrcf_object_buffer=>read_relationship
    EXPORTING
      pv_isubty    = c_cp_na
      ps_ihrobject = ls_object
    IMPORTING
      pt_erelation = lt_relation
      pv_esubrc    = lv_subrc.

  IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ENDIF.

  CLEAR ls_object.
  READ TABLE lt_relation
       INTO  ls_relation
       WITH KEY sclas = 'NA'.
  IF sy-subrc = 0.
    IF NOT ( ls_relation-sobid  IS INITIAL ).
      is_candidate = true.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD is_deregistered .

  DATA: lo_cand TYPE REF TO cl_hrrcf_candidate_info.
  DATA: lt_cand TYPE TABLE OF p5102, ls_cand TYPE p5102.
  DATA: lo_exception TYPE REF TO cx_hrrcf.

  TRY.
      CALL METHOD cl_hrrcf_candidate_info=>get_instance
        EXPORTING
          hrobject = me->hrobject
        IMPORTING
          instance = lo_cand.

      CALL METHOD lo_cand->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_cand.

      READ TABLE lt_cand INDEX 1 INTO ls_cand.

      IF sy-subrc IS NOT INITIAL.
        IF 1 = 2.                  "Only for where used list
          MESSAGE e073(hrrcf0001) WITH 'CANDIDATE'.
        ENDIF.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            message_type = 'E'
            message_class = 'HRRCF0001'
            message_number = 073
            message_par1   = 'CANDIDATE' .
      ENDIF .

      IF ls_cand-deregistered = true .
        p_deregistered = true .
      ELSE .
        p_deregistered = false .
      ENDIF .

    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_exception
          hrobject = me->hrobject.
  ENDTRY.

ENDMETHOD.                    "GET_CANDIDATE_STATUS


METHOD is_employee.

* Author: Detlef
* Additions: BM, HGB

  DATA lo_ex TYPE REF TO cx_hrrcf.

  return = false.

* Check if employeeid exists
  CHECK me->employeeid CN ' 0'.

* If employeeid exists, check whether employee is active
  TRY.

  IF cl_hrrcf_candidate=>is_inactive_employee( me->hrobject ) EQ false.
    return = true.
  ENDIF.

  CATCH cx_hrrcf INTO lo_ex.
    cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
  ENDTRY.

ENDMETHOD.


METHOD is_inactive_employee.
*Author:BM

  DATA: lo_cand TYPE REF TO cl_hrrcf_candidate_info.
  DATA: lt_cand TYPE TABLE OF p5102, ls_cand TYPE p5102.
  DATA: lo_exception TYPE REF TO cx_hrrcf.


  TRY.
      CALL METHOD cl_hrrcf_candidate_info=>get_instance
        EXPORTING
          hrobject = p_hrobject
        IMPORTING
          instance = lo_cand.

      CALL METHOD lo_cand->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_cand.

      READ TABLE lt_cand INDEX 1 INTO ls_cand.

      IF sy-subrc IS NOT INITIAL.
        IF 1 = 2.                  "Only for where used list
          MESSAGE e073(hrrcf0001) WITH 'CANDIDATE'.
        ENDIF.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            message_type = 'E'
            message_class = 'HRRCF0001'
            message_number = 073
            message_par1   = 'CANDIDATE' .
      ENDIF .

      IF ls_cand-is_inactive = true .
        p_is_inactive = true .
      ELSE .
        p_is_inactive = false .
      ENDIF .

    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_exception
          hrobject = p_hrobject.
  ENDTRY.

ENDMETHOD.


METHOD LEGAL_CHECK_BEFORE_DELETE.

  DATA: lt_cdcy_list    TYPE rcf_t_candidacy.
  DATA: lo_candidacy    TYPE REF TO cl_hrrcf_candidacy.
  DATA: lo_cdcy_bl      TYPE REF TO cl_hrrcf_candidacy_bl.
  DATA: ls_return       TYPE bapiret2.
  DATA: lv_ret_date     TYPE dats.

  CALL METHOD me->get_candidacy
    IMPORTING
      candidacy_list = lt_cdcy_list.

  CALL METHOD cl_hrrcf_candidacy_bl=>get_instance
    RECEIVING
      return = lo_cdcy_bl.

  LOOP AT lt_cdcy_list INTO lo_candidacy.
    CALL METHOD lo_cdcy_bl->get_requi_retention_date
      EXPORTING
        ps_cdcy_hrobject = lo_candidacy->hrobject
      IMPORTING
        p_ret_date       = lv_ret_date.

    IF lv_ret_date GE sy-datum.
      CLEAR ls_return.
      IF 1 EQ 0.
        MESSAGE e111(hrrcf0002).
*     End of retention period not yet reached
      ENDIF.
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = '111'
        IMPORTING
          return = ls_return.
      APPEND ls_return TO return.
    ENDIF.
  ENDLOOP.
ENDMETHOD.


method lock_system_user .
* Author: VSD
* Change Logon Data
  data:
        ls_bapialias              type bapialias,
        ls_bapialiasx             type bapialiasx,
        ls_logondata              type bapilogond,
        ls_logondatax             type bapilogonx,
        lt_return1                type bapirettab,
        lt_return                 type bapirettab,
        ls_return                 type bapiret2,
        lv_message(80)            type c,
        lv_ui_dest                type rfcdest,
        lv_use_bl_system          type boole_d,
        lv_is_employee            type boole_d,
        lv_central_system_logsys  type logsys.

* ask for destination to ui server
  lv_ui_dest = cl_hrrcf_services_general=>get_ui_destination( ).

  lv_is_employee = me->is_employee( ).
  if lv_is_employee eq 'X'.
    lv_use_bl_system = cl_hrrcf_services_general=>get_system_for_int_cand( ).
    if lv_use_bl_system eq 'X'.
      lv_ui_dest = 'NONE'.
    endif.
  endif.

* Delete Alias.
  ls_bapialiasx-bapialias = 'X'.
**following code is commented for note 2328040, changing the validity-to date to past date is not allowed anymore!!see note1124634
** Change User Validity                                 - N2328040
*  ls_logondata-gltgv  = sy-datum - 1.
*  ls_logondata-gltgb  = sy-datum - 1.
*  ls_logondatax-gltgv = 'X'.
*  ls_logondatax-gltgb = 'X'.

**************************************************************
* Special handling for separate UI server
* First update user on UI server -> then update user on BL server
**************************************************************
  if lv_ui_dest ne 'NONE'.
* Change user data
    call function 'BAPI_USER_CHANGE'
      destination lv_ui_dest
      exporting
        username              = me->user
        logondata             = ls_logondata
        logondatax            = ls_logondatax
        alias                 = ls_bapialias
        aliasx                = ls_bapialiasx
      tables
        return                = lt_return1
      exceptions
        system_failure        = 1  message lv_message
        communication_failure = 2  message lv_message.

    if sy-subrc <> 0.
*   problem with rfc connection
      case sy-subrc.
        when 1.
          raise exception type cx_hrrcf_rfc_communication
            exporting textid = 'CX_HRRCF_RFC_SYSTEM_FAILURE'.
        when 2.
          raise exception type cx_hrrcf_rfc_communication
            exporting textid = 'CX_HRRCF_RFC_COMM_FAILURE'.
      endcase.
    endif.

* Delete success messages
    delete lt_return1 where type ne 'A' and type ne 'E'.

* Lock the User
    call function 'BAPI_USER_LOCK'
      destination lv_ui_dest
      exporting
        username              = me->user
      tables
        return                = lt_return
      exceptions
        system_failure        = 1  message lv_message
        communication_failure = 2  message lv_message.

    if sy-subrc <> 0.
*   problem with rfc connection
      case sy-subrc.
        when 1.
          raise exception type cx_hrrcf_rfc_communication
            exporting textid = 'CX_HRRCF_RFC_SYSTEM_FAILURE'.
        when 2.
          raise exception type cx_hrrcf_rfc_communication
            exporting textid = 'CX_HRRCF_RFC_COMM_FAILURE'.
      endcase.
    endif.

* Delete success messages
    delete lt_return where type ne 'A' and type ne 'E'.
* Append remaining messages to the RETURN table.
    loop at lt_return into ls_return.
      append ls_return to lt_return1.
    endloop.
* Exception handling
    if lt_return1 is not initial.
      read table lt_return1 into ls_return with key type = 'A'.
      if sy-subrc eq 0.
        raise exception type cx_hrrcf_maintain_object
          exporting
            textid = cx_hrrcf_maintain_object=>user_not_changed
            hrobject = me->hrobject
            message_type = ls_return-type
            message_class = ls_return-id
            message_number = ls_return-number
            message_par1 = ls_return-message_v1
            message_par2 = ls_return-message_v2
            message_par3 = ls_return-message_v3
            message_par4 = ls_return-message_v4.
      endif.

      read table lt_return1 into ls_return with key type = 'E'.

      if sy-subrc eq 0.
        raise exception type cx_hrrcf_maintain_object
          exporting
            textid = cx_hrrcf_maintain_object=>user_not_changed
            hrobject = me->hrobject
            message_type = ls_return-type
            message_class = ls_return-id
            message_number = ls_return-number
            message_par1 = ls_return-message_v1
            message_par2 = ls_return-message_v2
            message_par3 = ls_return-message_v3
            message_par4 = ls_return-message_v4.
      endif.
    endif.
  endif.
***************************************************************************
* End special handling for separate UI server
***************************************************************************

***************************************************************************
* Special handling in CUA landscape
***************************************************************************
* check CUA is active?
* child system in central user administration?
  call function 'SUSR_ZBV_CHECK_IF_ACTIVE'
    exceptions
      active        = 1
      not_active    = 2
      invalid_model = 3
      others        = 4.
  if sy-subrc = 1.
*...CUA is active
    call function 'SUSR_ZBV_CENTRALSYSTEM_CHECK'
      importing
        central_system_logsys    = lv_central_system_logsys
      exceptions
        duplicate_central_system = 1
        new_system               = 2
        not_central              = 3
        others                   = 4.
    if sy-subrc = 0 or sy-subrc = 3.                                "INS NOTE 0001388283
* Change user data
     call function 'BAPI_USER_CHANGE'
     destination lv_central_system_logsys
       exporting
         username   = me->user
         logondata  = ls_logondata
         logondatax = ls_logondatax
         alias      = ls_bapialias
         aliasx     = ls_bapialiasx
       tables
         return     = lt_return1.
     if sy-subrc EQ 0.
* Lock the User
       call function 'BAPI_USER_LOCK'
       destination lv_central_system_logsys
        exporting
         username = me->user
        tables
         return   = lt_return.
      endif.
    endif.
  endif.

* Delete success messages
  delete lt_return1 where type ne 'A' and type ne 'E'.
* Delete success messages
  delete lt_return where type ne 'A' and type ne 'E'.
*  Append remaining messages to the RETURN table.
  loop at lt_return into ls_return.
    append ls_return to lt_return1.
  endloop.
* Exception handling
  if lt_return1 is not initial.
    read table lt_return1 into ls_return with key type = 'A'.
    if sy-subrc eq 0.
      raise exception type cx_hrrcf_maintain_object
        exporting
          textid = cx_hrrcf_maintain_object=>user_not_changed
          hrobject = me->hrobject
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4
          .
    endif.

    read table lt_return1 into ls_return with key type = 'E'.

    if sy-subrc eq 0.
      raise exception type cx_hrrcf_maintain_object
        exporting
          textid = cx_hrrcf_maintain_object=>user_not_changed
          hrobject = me->hrobject
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4
          .
    endif.
  endif.
**************************************************************************
* End of special handling in CUA landscape
**************************************************************************

* Change user data
  call function 'BAPI_USER_CHANGE'
    exporting
      username   = me->user
      logondata  = ls_logondata
      logondatax = ls_logondatax
      alias      = ls_bapialias
      aliasx     = ls_bapialiasx
    tables
      return     = lt_return1.

* Delete success messages
  delete lt_return1 where type ne 'A' and type ne 'E'.

* Lock the User
  call function 'BAPI_USER_LOCK'
    exporting
      username = me->user
    tables
      return   = lt_return.

* Delete success messages
  delete lt_return where type ne 'A' and type ne 'E'.
* Append remaining messages to the RETURN table.
  loop at lt_return into ls_return.
    append ls_return to lt_return1.
  endloop.
* Exception handling
  if lt_return1 is not initial.
    read table lt_return1 into ls_return with key type = 'A'.
    if sy-subrc eq 0.
      raise exception type cx_hrrcf_maintain_object
        exporting
          textid = cx_hrrcf_maintain_object=>user_not_changed
          hrobject = me->hrobject
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4
          .
    endif.

    read table lt_return1 into ls_return with key type = 'E'.

    if sy-subrc eq 0.
      raise exception type cx_hrrcf_maintain_object
        exporting
          textid = cx_hrrcf_maintain_object=>user_not_changed
          hrobject = me->hrobject
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4
          .
    endif.
  endif.



endmethod.


METHOD new_password_requested .
* author Detlef

* Fire workflow event
* object erc_cand
* event  new_password_requested


  DATA: lv_objkey TYPE sweinstcou-objkey,	"Object key
        l_event TYPE swedumevid-evtid.	"Event id

*Declare WF container

  swc_container lt_evt_container.
  	
*Initialize WF container

  swc_create_container lt_evt_container.

*Fill the HR object key

  MOVE me->hrobject TO lv_objkey.

*Fill the Event container with the event parameters

* swc_set_element lt_evt_container 'XDP-Attribute?' me->hrobject.

  CALL FUNCTION 'SWE_EVENT_CREATE'
    EXPORTING
      objtype           = 'ERC_CAND'
      objkey            = lv_objkey
      event             = 'NewPasswordRequested'
    IMPORTING
      event_id          = l_event
    TABLES
      event_container   = lt_evt_container
    EXCEPTIONS
      objtype_not_found = 1
      OTHERS            = 2.
  IF sy-subrc <> 0.

    RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
      EXPORTING
        textid =
          cx_hrrcf_maintain_object=>business_object_repository
        hrobject = me->hrobject
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.

  ENDIF.

  COMMIT WORK.

ENDMETHOD.


METHOD new_verif_mail_requested.
* This method triggers the workflow event NewVerificationRequested of Business Object ERC_CAND
  DATA: lv_objkey TYPE sweinstcou-objkey,  "Object key
        l_event TYPE swedumevid-evtid.  "Event id

* Declare WF container
  swc_container lt_evt_container.

* Initialize WF container
  swc_create_container lt_evt_container.

* Fill the HR object key
  MOVE me->hrobject TO lv_objkey.

* Fill the Event container with the event parameters
  CALL FUNCTION 'SWE_EVENT_CREATE'
    EXPORTING
      objtype           = 'ERC_CAND'
      objkey            = lv_objkey
      event             = 'NewVerificationRequested'
    IMPORTING
      event_id          = l_event
    TABLES
      event_container   = lt_evt_container
    EXCEPTIONS
      objtype_not_found = 1
      OTHERS            = 2.

  IF sy-subrc <> 0.

    RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
      EXPORTING
        textid =
          cx_hrrcf_maintain_object=>business_object_repository
        hrobject = me->hrobject
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.

  ENDIF.

  COMMIT WORK.

ENDMETHOD.


METHOD on_buffer_refresh .
  CALL METHOD super->on_buffer_refresh.
  CLEAR local_directory.
  CLEAR local_dir_ce_suppl.
ENDMETHOD.


METHOD remove_role_from_bupa.                    "WAR2088465

  DATA:
    lt_return     TYPE STANDARD TABLE OF bapiret2,
    lt_return2    TYPE STANDARD TABLE OF bapiret2,
    ls_return     TYPE bapiret2.

  CALL FUNCTION 'BUPA_ROLE_EXISTENCE_CHECK_2'
    EXPORTING
      IV_PARTNER                   = businesspartner
*     IV_PARTNER_GUID              =
*     IV_PARTNERROLECATEGORY       =
*     IV_X_ALL_PARTNERROLES        = ' '
      IV_PARTNERROLE               = businesspartnerrole
*     IV_DIFFTYPEVALUE             =
*     IV_DATE                      = SY-DATLO
    TABLES
      ET_RETURN                    = lt_return2.

  IF cl_hrrcf_simple_main_object=>luw_mode EQ true.
*------ Vorgangsprüfung ------------------------------------------------
      CALL FUNCTION 'BUPA_ACT_ANALYZE_FOR_BAPI'
        EXPORTING
          iv_bp_number = businesspartner
          iv_activity  = 'CHAN'
        TABLES
          ct_results   = lt_return.

*------ Internen Funktionsbaustein aufrufen, wenn Rückgabe aus ---------
*------ Vorgangsprüfung weder Messagetyp E od. A               ---------
    LOOP AT lt_return TRANSPORTING NO FIELDS WHERE type CA 'AE'  .
      EXIT.
    ENDLOOP.

    IF sy-subrc NE 0 AND
       lt_return2[] IS INITIAL.
      CALL FUNCTION 'BUPA_ROLE_REMOVE'
        EXPORTING
          iv_partner       = businesspartner
          iv_partnerrole   = businesspartnerrole
          iv_x_save        = space
        TABLES
          ET_RETURN        = return.

    ENDIF.
  ELSEIF lt_return2[] IS INITIAL.
    CALL FUNCTION 'BAPI_BUPA_ROLE_REMOVE'
        EXPORTING
        businesspartner     = businesspartner
        businesspartnerrole = businesspartnerrole
      TABLES
        return              = return.
  ENDIF.

*------ Ergebnis der Vergangsprüfung an Return-Parameter anhängen ------
  LOOP AT lt_return INTO ls_return.
    COLLECT ls_return INTO return.
  ENDLOOP.
ENDMETHOD.


METHOD send_new_password .
* author Detlef
*
  DATA lo_abstract_activity_rec TYPE REF TO cl_hrrcf_abstract_activity_rec.
  DATA lo_act_correspond_record TYPE REF TO cl_hrrcf_act_correspond_record.
  DATA oref TYPE REF TO cx_root.

  CALL METHOD cl_hrrcf_activity_factory=>create_activity_by_type
    EXPORTING
      act_type = ACTIVITY_TYPE
      hrobject = me->hrobject
    IMPORTING
      activity = lo_abstract_activity_rec.

  TRY.
      lo_act_correspond_record ?= lo_abstract_activity_rec.
    CATCH cx_root INTO oref.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          textid   = cx_hrrcf=>cx_hrrcf
          previous = oref
          hrobject = me->hrobject.

  ENDTRY.

  CALL METHOD lo_act_correspond_record->process_document
    EXPORTING
      channel = 'E_MAIL'.

ENDMETHOD.


METHOD send_new_verif_mail.

  DATA lo_abstract_activity_rec TYPE REF TO cl_hrrcf_abstract_activity_rec.
  DATA lo_act_correspond_record TYPE REF TO cl_hrrcf_act_correspond_record.
  DATA oref TYPE REF TO cx_root.

  cl_hrrcf_activity_factory=>create_activity_by_type(
    EXPORTING
      act_type = iv_activity_type
      hrobject = me->hrobject
    IMPORTING
      activity = lo_abstract_activity_rec ).

  TRY.
      lo_act_correspond_record ?= lo_abstract_activity_rec.
    CATCH cx_root INTO oref.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          textid   = cx_hrrcf=>cx_hrrcf
          previous = oref
          hrobject = me->hrobject.
  ENDTRY.

  lo_act_correspond_record->process_document( channel = 'E_MAIL' ).

ENDMETHOD.


METHOD set_bp_attributes_internal .

  DATA lt_return TYPE TABLE OF bapiret2.
  DATA ls_return TYPE          bapiret2.
  DATA:
    lt_data        TYPE TABLE OF bapibus1006_central_td,
    lt_data_person TYPE TABLE OF bapibus1006_central_person_td,
    ls_data        TYPE bapibus1006_central_td,
    ls_data_person TYPE bapibus1006_central_person_td.

  CHECK NOT partner IS INITIAL.

  me->partner = partner.

  CALL FUNCTION 'BUPA_CENTRAL_GETLIST' "Note 888574
    EXPORTING
      iv_partner     = me->partner
      iv_valid_from  = sy-datum
      iv_valid_to    = sy-datum
    TABLES
      et_data        = lt_data
      et_data_person = lt_data_person
      et_return      = lt_return.

  IF NOT lt_return IS INITIAL.
    DELETE lt_return WHERE type NE 'E' AND type NE 'A'. "No W or S
    READ TABLE lt_return WITH KEY type = 'A'
      INTO ls_return.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid =
            cx_hrrcf_maintain_object=>business_partner_not_created
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
    READ TABLE lt_return WITH KEY type = 'E'
      INTO ls_return.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid =
            cx_hrrcf_maintain_object=>business_partner_not_created
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
  ENDIF.
*
  READ TABLE lt_data
       INDEX 1
       INTO ls_data.
  MOVE-CORRESPONDING ls_data
                  TO me->centraldata.
*
  READ TABLE lt_data_person
       INDEX 1
       INTO  ls_data_person.
  MOVE-CORRESPONDING ls_data_person
                  TO me->centraldataperson.

ENDMETHOD.                    "


METHOD set_object_ids_internal .

  DATA l_cp_us     TYPE subtyp VALUE 'B208'.
  DATA l_cp_p      TYPE subtyp VALUE 'B209'.
  DATA l_cp_na     TYPE subtyp VALUE 'B650'.

  DATA ls_relation TYPE p1001.
  DATA ls_object   TYPE hrobject.
  DATA lt_relation TYPE TABLE OF p1001.
  DATA lt_object   TYPE TABLE OF hrobject.

  DATA l_plvar TYPE plvar.

  DATA lt_return TYPE TABLE OF bapiret2.
  DATA ls_return TYPE          bapiret2.

  DATA local_directory_line TYPE REF TO cl_hrrcf_candidate.

  DATA ls_local_dir_ce_suppl TYPE rcf_s_empl_pers.

  DATA lv_tabix TYPE sytabix.
  DATA lv_subrc TYPE sysubrc.
  DATA lv_pernr TYPE pernr_d.

  DATA lv_read_1001_cp_us TYPE boole_d VALUE true.


  CHECK personid CN ' 0'.
  me->personid = personid.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = l_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

  IF me->partner IS INITIAL.

    ls_object-plvar = l_plvar.
    ls_object-otype = 'CP'.
    ls_object-objid = personid.

    me->partner = get_bupa_partnerid( ps_ihrobject = ls_object ).

    CALL FUNCTION 'BUPA_EXISTENCE_CHECK'
      EXPORTING
        iv_partner = me->partner
      TABLES
        et_return  = lt_return.
    IF NOT lt_return IS INITIAL.
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'. "No W or S
      READ TABLE lt_return WITH KEY type = 'A'
        INTO ls_return.
      IF sy-subrc = 0.
        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
            textid         = cx_hrrcf_maintain_object=>business_partner_not_created
            message_type   = ls_return-type
            message_class  = ls_return-id
            message_number = ls_return-number
            message_par1   = ls_return-message_v1
            message_par2   = ls_return-message_v2
            message_par3   = ls_return-message_v3
            message_par4   = ls_return-message_v4.
      ENDIF.
      READ TABLE lt_return WITH KEY type = 'E'
        INTO ls_return.
      IF sy-subrc = 0.
        RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
          EXPORTING
            textid         = cx_hrrcf_maintain_object=>business_partner_not_created
            message_type   = ls_return-type
            message_class  = ls_return-id
            message_number = ls_return-number
            message_par1   = ls_return-message_v1
            message_par2   = ls_return-message_v2
            message_par3   = ls_return-message_v3
            message_par4   = ls_return-message_v4.
      ENDIF.
    ENDIF.
  ENDIF.

  IF me->id IS INITIAL.

    ls_object-plvar = l_plvar.
    ls_object-otype = 'CP'.
    ls_object-objid = personid.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = l_cp_na
        ps_ihrobject = ls_object
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid         = cx_hrrcf_infotype_operation=>error_during_read
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

    READ TABLE lt_relation
         INTO  ls_relation
         WITH KEY sclas = 'NA'.
    IF sy-subrc = 0.

      me->id = ls_relation-sobid.

    ENDIF.

  ENDIF.

  IF me->employeeid IS INITIAL OR
     me->gt_employeeid IS INITIAL.

    ls_object-plvar = l_plvar.
    ls_object-otype = 'CP'.
    ls_object-objid = personid.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = l_cp_p
        pv_iwith_ev  = 'X'
        ps_ihrobject = ls_object
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid         = cx_hrrcf_infotype_operation=>error_during_read
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

* Add the Employees PERNRs to the internal table attribute *********
* GT_EMPLOYEEID, and set the attribute EMPLOYEEID with the oldest***
* PERNR of the empoyee**********************************************
********************************************************************

    SORT lt_relation BY begda.
    LOOP AT lt_relation INTO ls_relation
      WHERE sclas = 'P'.
      lv_pernr = ls_relation-sobid.
      IF sy-tabix = 1.  "First Loop, Oldest PERNR
        me->employeeid = lv_pernr.
      ENDIF.

      INSERT lv_pernr INTO TABLE gt_employeeid. "Insert is used becouse gt_employeeid is a Sorted table
    ENDLOOP.

  ENDIF.

  IF me->user IS INITIAL.
*     Only for Integrated system ***************************
*     Read the user from IT0105 ****************************
************************************************************
    IF cl_hrrcf_system_check=>is_standalone = false.       "MELN1566478

      lv_read_1001_cp_us = false.

      TRY.
          CALL METHOD cl_hrrcf_erp_convert_p_2_cand=>determine_user_ext_ce
            EXPORTING
              it_personnel_assignments = gt_employeeid
            IMPORTING
              ev_user                  = me->user.

        CATCH cx_hrrcf_infotype_operation .
*         When no IT0000 exist, meand that the candidate
*         is an external candidate, and then the user needs
*         to be readed from the IT1001
          lv_read_1001_cp_us = true.
      ENDTRY.
    ENDIF.

    IF lv_read_1001_cp_us = true.
*     For Stand alone system and external candidates********
*     Read the user from IT1001 relation CP->US*************
************************************************************
      ls_object-plvar = l_plvar.
      ls_object-otype = 'CP'.
      ls_object-objid = personid.

      CALL METHOD cl_hrrcf_object_buffer=>read_relationship
        EXPORTING
          pv_isubty    = l_cp_us
          pv_iwith_ev  = 'X'
          ps_ihrobject = ls_object
        IMPORTING
          pt_erelation = lt_relation
          pv_esubrc    = lv_subrc.

      IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid         = cx_hrrcf_infotype_operation=>error_during_read
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      ENDIF.

      READ TABLE lt_relation
           INTO  ls_relation
           WITH KEY sclas = 'US'.
      IF sy-subrc = 0.
        me->user = ls_relation-sobid.
      ENDIF.
    ENDIF.
  ENDIF.

  me->hrobject-plvar = l_plvar.
  me->hrobject-otype = 'NA'.
  me->hrobject-objid = me->id.
  SORT local_directory BY table_line->id.                   "N 2293580
  READ TABLE local_directory INTO local_directory_line
                             WITH KEY table_line->id = me->id
                             BINARY SEARCH.                 "N 2293580
  IF sy-subrc NE 0.
    local_directory_line = me.
    APPEND local_directory_line TO local_directory.
  ENDIF.

*   consider CE case.
  IF cl_hrrcf_system_check=>is_ce_enabled = true.
    CALL METHOD me->set_personid_external
      EXPORTING
        i_personid   = personid
        i_employeeid = me->employeeid.
    ls_local_dir_ce_suppl-personid = me->personid.
    LOOP AT gt_employeeid INTO ls_local_dir_ce_suppl-employeeid.
      APPEND ls_local_dir_ce_suppl TO local_dir_ce_suppl.
    ENDLOOP.
  ENDIF.

ENDMETHOD.                    "


METHOD set_partner_id.

  DATA lv_bu_partner  TYPE bu_partner.

  DATA lt_return TYPE TABLE OF bapiret2.
  DATA ls_return TYPE          bapiret2.
  DATA:
    ls_object TYPE hrobject,
    lv_plvar  TYPE plvar.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = lv_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

  ls_object-plvar = lv_plvar.
  ls_object-otype = 'CP'.
  ls_object-objid = personid.

  lv_bu_partner = get_bupa_partnerid( ps_ihrobject = ls_object ).

  CALL FUNCTION 'BUPA_EXISTENCE_CHECK'
    EXPORTING
      iv_partner = lv_bu_partner
    TABLES
      et_return  = lt_return.
  IF NOT lt_return IS INITIAL.
    DELETE lt_return WHERE type NE 'E' AND type NE 'A'. "No W or S
    READ TABLE lt_return WITH KEY type = 'A'
      INTO ls_return.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid =
            cx_hrrcf_maintain_object=>business_partner_not_created
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
    READ TABLE lt_return WITH KEY type = 'E'
      INTO ls_return.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid =
            cx_hrrcf_maintain_object=>business_partner_not_created
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF.
  ENDIF.

  me->partner = lv_bu_partner.

ENDMETHOD.


METHOD set_personid_external.

  CONSTANTS hr_read_infotype TYPE rs38l_fnam VALUE 'HR_READ_INFOTYPE'.
  DATA: lt_p5588         TYPE TABLE OF p5588,
        ls_p5588         TYPE p5588,
        lv_plvar         TYPE objec-plvar.

  DATA: ls_hrobject         TYPE hrobject,
        lr_infty_record_tab TYPE REF TO data,
        lr_infty_record     TYPE REF TO data.

  FIELD-SYMBOLS: <lt_infty_record> TYPE STANDARD TABLE,
                 <ls_infty_record> TYPE ANY,
                 <l_personid_external> TYPE personid_ext_aba.

* retrieve external personid only in case of ce
  CHECK cl_hrrcf_system_check=>is_ce_enabled = true.

  IF cl_hrrcf_system_check=>is_standalone = true.
*  get external personId from infotype 5588
*  pre-condition: it has to be distributed via ALE!
    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = lv_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    CALL FUNCTION 'RH_READ_INFTY'
      EXPORTING
        authority            = space
        infty                = '5588'
        istat                = '1'
        plvar                = lv_plvar
        otype                = 'CP'
        objid                = i_personid
      TABLES
        innnn                = lt_p5588
      EXCEPTIONS
        all_infty_with_subty = 1
        nothing_found        = 0
        no_objects           = 3
        wrong_condition      = 4
        OTHERS               = 5.

    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

*  external personid must exist exactly once!
    READ TABLE lt_p5588 INTO ls_p5588 INDEX 1.
    me->personid_external = ls_p5588-personid_ext.
  ELSE.
*  get external personId from infotype 0709
    CREATE DATA lr_infty_record_tab TYPE ('PRELP_TAB').
    ASSIGN lr_infty_record_tab->* TO <lt_infty_record>.
*
    CREATE DATA lr_infty_record TYPE ('P0709').
    ASSIGN lr_infty_record->* TO <ls_infty_record>.

    CLEAR <ls_infty_record>.
    CLEAR <lt_infty_record>.
*
    CALL FUNCTION hr_read_infotype                          "#EC EXISTS
      EXPORTING
        pernr           = i_employeeid
        infty           = '0709'
      TABLES
        infty_tab       = <lt_infty_record>
      EXCEPTIONS
        infty_not_found = 1
        OTHERS          = 2.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE CX_HRRCF_INFOTYPE_OPERATION
         EXPORTING
          hrobject = ls_hrobject
          infotype = <ls_infty_record>
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4      .
    ENDIF.

*  external personid must exist exactly once!
    LOOP AT <lt_infty_record> INTO <ls_infty_record>.
      ASSIGN COMPONENT 'PERSONID_EXT' OF STRUCTURE <ls_infty_record>
          TO <l_personid_external>.
      me->personid_external = <l_personid_external>.
      EXIT.
    ENDLOOP.

  ENDIF.

ENDMETHOD.


METHOD update_erec_us_for_it0105_us.

  DATA:
  lt_relation                   TYPE TABLE OF p1001,
  ls_relation                   TYPE p1001,
  lt_delte_erec_user_from_1001  TYPE TABLE OF p1001,
  lt_update_it105_user_validity TYPE TABLE OF p1001,
  lt_return                     TYPE TABLE OF bapiret2,
  ls_return                     TYPE bapiret2.

  lt_relation[] = it_1001_cp_us[].

  LOOP AT lt_relation   INTO ls_relation
     WHERE sclas = 'US' AND
           sobid = iv_erec_gen_user.

    APPEND ls_relation TO lt_delte_erec_user_from_1001. "Enter the ERec user in a deletion table

    DELETE lt_relation. " The Erec user is deleted from the table
  ENDLOOP.

* Now as no ERec user is in the table lt_"relation" I read the user**
* with the Higher ENDDA***********************************************
**********************************************************************
  SORT lt_relation BY endda DESCENDING.
  READ TABLE lt_relation INDEX 1
    INTO ls_relation.

  IF sy-subrc = 0.
    APPEND ls_relation TO lt_delte_erec_user_from_1001. "This user is deleted too
  ENDIF.
*   Delete E-Recruitment USER from IT10001
******************************************************
  CALL FUNCTION 'RH_DELETE_INFTY'
    EXPORTING
      vtask               = 'D'
    TABLES
      innnn               = lt_delte_erec_user_from_1001
    EXCEPTIONS
      error_during_delete = 1
      no_authorization    = 2
      delete_first_record = 3
      corr_exit           = 4
      OTHERS              = 5.

  IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid         = cx_hrrcf_infotype_operation=>error_during_delete
        message_type   = sy-msgty
        message_class  = sy-msgid
        message_number = sy-msgno
        message_par1   = sy-msgv1
        message_par2   = sy-msgv2
        message_par3   = sy-msgv3
        message_par4   = sy-msgv4.
  ENDIF.

* Actually delete the EREC user
**********************************************************************
  CALL FUNCTION 'BAPI_USER_DELETE'                         "MELN1725050
    EXPORTING
      username = iv_erec_gen_user
    TABLES
      return   = lt_return.

* error handling
  IF NOT lt_return IS INITIAL.
    DELETE lt_return WHERE type NE 'E' AND
                           type NE 'A'. "No W or S

    LOOP AT lt_return INTO ls_return.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid         = cx_hrrcf=>cx_hrrcf
          message_type   = ls_return-type
          message_class  = ls_return-id
          message_number = ls_return-number
          message_par1   = ls_return-message_v1
          message_par2   = ls_return-message_v2
          message_par3   = ls_return-message_v3
          message_par4   = ls_return-message_v4.
    ENDLOOP.
  ENDIF.

* Now i Exnted the validity of the IT105 user with the Higher ENDDA
**********************************************************************
  ls_relation-endda = high_date.
  APPEND ls_relation TO lt_update_it105_user_validity.
  ev_user = ls_relation-sobid.

  me->user = ev_user.                                      "MELN1725050

* Ans insert it again in the IT105
**********************************************************************
  CALL FUNCTION 'RH_INSERT_INFTY'
    EXPORTING
      vtask               = 'D'
      authy               = space
    TABLES
      innnn               = lt_update_it105_user_validity
    EXCEPTIONS                           "force short dump
      no_authorization    = 1
      error_during_insert = 2
      repid_form_initial  = 3
      corr_exit           = 4
      begda_greater_endda = 5
      OTHERS              = 6.

  IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid         = cx_hrrcf_infotype_operation=>error_during_insert
        message_type   = sy-msgty
        message_class  = sy-msgid
        message_number = sy-msgno
        message_par1   = sy-msgv1
        message_par2   = sy-msgv2
        message_par3   = sy-msgv3
        message_par4   = sy-msgv4.
  ENDIF.

ENDMETHOD.


METHOD update_erec_us_for_it5585_us.

  DATA:
    lt_relation                   TYPE TABLE OF p1001,
    ls_relation                   TYPE p1001,
    lt_delte_erec_user_from_1001  TYPE TABLE OF p1001,
    lt_update_it5585_user         TYPE TABLE OF p1001,
    lt_return                     TYPE TABLE OF bapiret2,
    ls_return                     TYPE bapiret2.

  lt_relation[] = it_1001_cp_us[].

  LOOP AT lt_relation   INTO ls_relation
     WHERE sclas = 'US' AND
           sobid = iv_erec_gen_user.

    APPEND ls_relation TO lt_delte_erec_user_from_1001. "Enter the ERec user in a deletion table

    DELETE lt_relation. " The Erec user is deleted from the table
  ENDLOOP.
  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

* Delete E-Recruitment USER from IT10001
******************************************************
  CALL FUNCTION 'RH_DELETE_INFTY'
    EXPORTING
      vtask               = 'D'
    TABLES
      innnn               = lt_delte_erec_user_from_1001
    EXCEPTIONS
      error_during_delete = 1
      no_authorization    = 2
      delete_first_record = 3
      corr_exit           = 4
      OTHERS              = 5.

  IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid         = cx_hrrcf_infotype_operation=>error_during_delete
        message_type   = sy-msgty
        message_class  = sy-msgid
        message_number = sy-msgno
        message_par1   = sy-msgv1
        message_par2   = sy-msgv2
        message_par3   = sy-msgv3
        message_par4   = sy-msgv4.
  ENDIF.

* Actually delete the EREC user
**********************************************************************
  CALL FUNCTION 'BAPI_USER_DELETE'                         "MELN1725050
    EXPORTING
      username = iv_erec_gen_user
    TABLES
      return   = lt_return.

* error handling
  IF NOT lt_return IS INITIAL.
    DELETE lt_return WHERE type NE 'E' AND
                           type NE 'A'. "No W or S

    LOOP AT lt_return INTO ls_return.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid         = cx_hrrcf=>cx_hrrcf
          message_type   = ls_return-type
          message_class  = ls_return-id
          message_number = ls_return-number
          message_par1   = ls_return-message_v1
          message_par2   = ls_return-message_v2
          message_par3   = ls_return-message_v3
          message_par4   = ls_return-message_v4.
    ENDLOOP.
  ENDIF.

* Add the user of the IT5585
**********************************************************************
  APPEND is_it5585_user TO lt_update_it5585_user .
  ev_user = is_it5585_user-sobid.

  me->user = ev_user.                                      "MELN1725050

* Ans insert it again in the IT105
**********************************************************************
  CALL FUNCTION 'RH_INSERT_INFTY'
    EXPORTING
      vtask               = 'D'
      authy               = space
    TABLES
      innnn               = lt_update_it5585_user
    EXCEPTIONS                           "force short dump
      no_authorization    = 1
      error_during_insert = 2
      repid_form_initial  = 3
      corr_exit           = 4
      begda_greater_endda = 5
      OTHERS              = 6.

  IF NOT sy-subrc = 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid         = cx_hrrcf_infotype_operation=>error_during_insert
        message_type   = sy-msgty
        message_class  = sy-msgid
        message_number = sy-msgno
        message_par1   = sy-msgv1
        message_par2   = sy-msgv2
        message_par3   = sy-msgv3
        message_par4   = sy-msgv4.
  ENDIF.

ENDMETHOD.
ENDCLASS.