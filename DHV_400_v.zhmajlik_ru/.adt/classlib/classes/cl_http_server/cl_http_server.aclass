class CL_HTTP_SERVER definition
  public
  create protected .

public section.

  interfaces IF_HTTP_SERVER .

  aliases AUTHENTICATION_METHOD
    for IF_HTTP_SERVER~AUTHENTICATION_METHOD .
  aliases AUTHENTICATION_PROVIDER
    for IF_HTTP_SERVER~AUTHENTICATION_PROVIDER .
  aliases AUTHMETHOD_ASSERTION
    for IF_HTTP_SERVER~AUTHMETHOD_ASSERTION .
  aliases AUTHMETHOD_BASIC
    for IF_HTTP_SERVER~AUTHMETHOD_BASIC .
  aliases AUTHMETHOD_CERTIFICATE
    for IF_HTTP_SERVER~AUTHMETHOD_CERTIFICATE .
  aliases AUTHMETHOD_FIELD
    for IF_HTTP_SERVER~AUTHMETHOD_FIELD .
  aliases AUTHMETHOD_NONE
    for IF_HTTP_SERVER~AUTHMETHOD_NONE .
  aliases AUTHMETHOD_RECORDER
    for IF_HTTP_SERVER~AUTHMETHOD_RECORDER .
  aliases AUTHMETHOD_SAML
    for IF_HTTP_SERVER~AUTHMETHOD_SAML .
  aliases AUTHMETHOD_SAP
    for IF_HTTP_SERVER~AUTHMETHOD_SAP .
  aliases AUTHMETHOD_SECURITY_SESSION
    for IF_HTTP_SERVER~AUTHMETHOD_SECURITY_SESSION .
  aliases AUTHMETHOD_SERVICE
    for IF_HTTP_SERVER~AUTHMETHOD_SERVICE .
  aliases AUTHMETHOD_SPNEGO
    for IF_HTTP_SERVER~AUTHMETHOD_SPNEGO .
  aliases AUTHMETHOD_SSO
    for IF_HTTP_SERVER~AUTHMETHOD_SSO .
  aliases AUTHPROVIDER_ICF
    for IF_HTTP_SERVER~AUTHPROVIDER_ICF .
  aliases AUTHPROVIDER_OAUTH
    for IF_HTTP_SERVER~AUTHPROVIDER_OAUTH .
  aliases AUTHPROVIDER_SECURITY_SESSION
    for IF_HTTP_SERVER~AUTHPROVIDER_SECURITY_SESSION .
  aliases AUTHPROVIDER_WS_SECURITY
    for IF_HTTP_SERVER~AUTHPROVIDER_WS_SECURITY .
  aliases CO_COMMUNICATION_ERROR_RECEIVE
    for IF_HTTP_SERVER~CO_COMMUNICATION_ERROR_RECEIVE .
  aliases CO_COMMUNICATION_ERROR_SEND
    for IF_HTTP_SERVER~CO_COMMUNICATION_ERROR_SEND .
  aliases CO_COMPRESS_BASED_ON_MIME_TYPE
    for IF_HTTP_SERVER~CO_COMPRESS_BASED_ON_MIME_TYPE .
  aliases CO_COMPRESS_DISABLED
    for IF_HTTP_SERVER~CO_COMPRESS_DISABLED .
  aliases CO_COMPRESS_IN_ALL_CASES
    for IF_HTTP_SERVER~CO_COMPRESS_IN_ALL_CASES .
  aliases CO_DISABLED
    for IF_HTTP_SERVER~CO_DISABLED .
  aliases CO_ENABLED
    for IF_HTTP_SERVER~CO_ENABLED .
  aliases CO_PAGE_ERROR_TYPE
    for IF_HTTP_SERVER~CO_PAGE_ERROR_TYPE .
  aliases CO_PAGE_LOGOFF_TYPE
    for IF_HTTP_SERVER~CO_PAGE_LOGOFF_TYPE .
  aliases CO_PAGE_PROCESSING_FAILED
    for IF_HTTP_SERVER~CO_PAGE_PROCESSING_FAILED .
  aliases CO_REDIRECT_STATUS_301
    for IF_HTTP_SERVER~CO_REDIRECT_STATUS_301 .
  aliases CO_REDIRECT_STATUS_302
    for IF_HTTP_SERVER~CO_REDIRECT_STATUS_302 .
  aliases CO_REDIRECT_STATUS_302_OR_307
    for IF_HTTP_SERVER~CO_REDIRECT_STATUS_302_OR_307 .
  aliases CO_RESPONSE_PAGE_OPTION
    for IF_HTTP_SERVER~CO_RESPONSE_PAGE_OPTION .
  aliases CO_RESPONSE_REDIRECT_OPTION
    for IF_HTTP_SERVER~CO_RESPONSE_REDIRECT_OPTION .
  aliases CO_SESSION_TIMEOUT
    for IF_HTTP_SERVER~CO_SESSION_TIMEOUT .
  aliases C_AUTHENTICATED
    for IF_HTTP_SERVER~AUTHENTICATED .
  aliases EXTERNAL_SESSION_ID
    for IF_HTTP_SERVER~EXTERNAL_SESSION_ID .
  aliases REQUEST
    for IF_HTTP_SERVER~REQUEST .
  aliases RESPONSE
    for IF_HTTP_SERVER~RESPONSE .
  aliases SERVICE_COMPRESSION_FLAG
    for IF_HTTP_SERVER~SERVICE_COMPRESSION_FLAG .
  aliases SESSION_ID
    for IF_HTTP_SERVER~SESSION_ID .
  aliases SESSION_TIMEOUT
    for IF_HTTP_SERVER~SESSION_TIMEOUT .
  aliases SSL_ACTIVE
    for IF_HTTP_SERVER~SSL_ACTIVE .
  aliases STATEFUL
    for IF_HTTP_SERVER~STATEFUL .
  aliases TRANSACTIONAL
    for IF_HTTP_SERVER~TRANSACTIONAL .
  aliases VERSION
    for IF_HTTP_SERVER~VERSION .
  aliases APPEND_FIELD_URL
    for IF_HTTP_SERVER~APPEND_FIELD_URL .
  aliases CREATE_ABS_URL
    for IF_HTTP_SERVER~CREATE_ABS_URL .
  aliases CREATE_REL_URL
    for IF_HTTP_SERVER~CREATE_REL_URL .
  aliases DECODE_BASE64
    for IF_HTTP_SERVER~DECODE_BASE64 .
  aliases ENABLE_FOREIGN_SESSION_ACCESS
    for IF_HTTP_SERVER~ENABLE_FOREIGN_SESSION_ACCESS .
  aliases ENCODE_BASE64
    for IF_HTTP_SERVER~ENCODE_BASE64 .
  aliases ESCAPE_HTML
    for IF_HTTP_SERVER~ESCAPE_HTML .
  aliases ESCAPE_URL
    for IF_HTTP_SERVER~ESCAPE_URL .
  aliases GET_EXTENSION_INFO
    for IF_HTTP_SERVER~GET_EXTENSION_INFO .
  aliases GET_EXTENSION_URL
    for IF_HTTP_SERVER~GET_EXTENSION_URL .
  aliases GET_LAST_ERROR
    for IF_HTTP_SERVER~GET_LAST_ERROR .
  aliases GET_LOCATION
    for IF_HTTP_SERVER~GET_LOCATION .
  aliases GET_LOCATION_EXCEPTION
    for IF_HTTP_SERVER~GET_LOCATION_EXCEPTION .
  aliases GET_XSRF_TOKEN
    for IF_HTTP_SERVER~GET_XSRF_TOKEN .
  aliases LOGOFF
    for IF_HTTP_SERVER~LOGOFF .
  aliases SEND_PAGE
    for IF_HTTP_SERVER~SEND_PAGE .
  aliases SET_COMPRESSION
    for IF_HTTP_SERVER~SET_COMPRESSION .
  aliases SET_PAGE
    for IF_HTTP_SERVER~SET_PAGE .
  aliases SET_SESSION_STATEFUL
    for IF_HTTP_SERVER~SET_SESSION_STATEFUL .
  aliases SET_SESSION_STATEFUL_VIA_URL
    for IF_HTTP_SERVER~SET_SESSION_STATEFUL_VIA_URL .
  aliases UNESCAPE_URL
    for IF_HTTP_SERVER~UNESCAPE_URL .
  aliases VALIDATE_XSRF_TOKEN
    for IF_HTTP_SERVER~VALIDATE_XSRF_TOKEN .
  aliases EVENTKIND_CONTEXT_TERMINATION
    for IF_HTTP_SERVER~EVENTKIND_CONTEXT_TERMINATION .

  class-data CO_FORM_FIELD type STRING .
  class-data CO_FORM_FIELD_B64 type STRING .
  constants CO_SEND_PAGE_ERROR type I value 4 ##NO_TEXT.
  constants CO_SERVERTYPE_NET type C value '1' ##NO_TEXT.
  constants CO_SERVERTYPE_PAR type C value '2' ##NO_TEXT.
  constants C_ABAP_VERSION type I value 1 ##NO_TEXT.
  class-data C_ACCEPT_REMOTE_PROFILE_LEVEL type I .
  class-data C_ACCEPT_REMOTE_RECORDER_LEVEL type I .
  class-data C_ACCEPT_REMOTE_TRACE_LEVEL type I .
  class-data C_CALLER_IP type RFCIPV6ADDR read-only .
  class-data C_COMPRESSION_SUPPORTED type I .
  class-data C_CONTEXT_POOLING_ENABLED type I .
  class-data C_COUNTER type I read-only .
  class-data C_DEBUGGING_POSSIBLE type CHAR1 .
  class-data C_DEBUGID type CHAR64 read-only .
  class-data C_ICF_OPTIONS type CHAR64 .
  class-data C_KERNEL_VERSION type I read-only .
  class-data C_LAST_MESSAGE_ID type SYSUUID_C .
  class-data C_MYSAPSSO2_AVAILABLE type I read-only .
  data C_ROOT_MESSAGE_ID type SYSUUID_C read-only .
  class-data C_RUNTIME_MEMORY_DISABLED type C .
  class-data C_SAP_TRACE type I .
  class-data C_SCOPE_MESSAGE_ID type SYSUUID_C .
  class-data C_SCOPE_MESSAGE_NR type SYINDEX .
  class-data C_SHARED_MEMORY_CACHE_OFF type I read-only .
  class-data C_STATEFUL_COOKIES type TIHTTPCKI .
  class-data C_STATISTIC_STATE type I .
  class-data C_TRACE_FORCE type I .
  class-data C_VIRTUAL_HOST type I .
  data M_AUTH_TRACE_ACTIVE type C .
  data M_CONNECTION_ERROR type IOPROP .
  data M_COUNTER type I .
  data M_EXTENSION_CONTAINER type XSTRING read-only .
  data M_LAST_PAGE type IHTTP_SERVICE_PAGE .
  data M_MYSAPSSO2_CREATED type I read-only .
  data M_OBJECT_ID type SYSUUID_C read-only .
  data M_PARENT_MESSAGE_ID type SYSUUID_C read-only .
  data M_PROTOCOL_VERSION type STRING read-only .
  data M_REQUEST_BODY_LENGTH type I read-only .
  data M_REQUEST_HEADER_LENGTH type I read-only .
  data M_RUNTIME_MEMORY_ID type ICF_SRTFD .
  data M_SERVER_TYPE type C read-only .
  data M_TIMER type ref to IF_ABAP_RUNTIME .
  class-data M_TOTAL_TIME type F .
  class-data PUBLIC_SERVICE type I .
  data M_AUTHENTICATION_TIME type F read-only .

  class-methods AUTHORIZATION
    importing
      !SERVICE type ICFSERVICE
      !URL type STRING
      !PATH_INFO type STRING .
  class-methods CLASS_CONSTRUCTOR .
  class-methods EXECUTE_REQUEST_FROM_MEMORY
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !RUNTIME_MEMORY type IHTTP_RUNTIME_MEMORY
    exporting
      !FLOW_RC type I
      value(TIMEOUT) type ICFTIME
      !SEND_PAGE_RC type I
    exceptions
      ICF_NO_AUTHORITY .
  class-methods EXECUTE_REQUEST
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVTBL type ICFSERVTBL
      !FIRSTALIAS type ICFALIAS
      !URLSUFFIX type STRING optional
    exporting
      !FLOW_RC type I
      value(TIMEOUT) type ICFTIME
      !SEND_PAGE_RC type I
    changing
      !RUNTIME_MEMORY type IHTTP_RUNTIME_MEMORY
    exceptions
      ICF_NO_AUTHORITY .
  class-methods INSTALL_ERROR_TEMPLATE
    importing
      !KIND500 type ICFERRKIND optional
      !HEADER_GUID type SOTR_CONC optional
      !BODY_GUID type SOTR_CONC optional
      !REDIRECT type ICFREDURL optional
      !REDIRECT_CODE type C optional
      !KINDLPAG type ICFERRKIND optional
      !LAST_PAGE_HEADER_GUID type SOTR_CONC optional
      !LAST_PAGE_BODY_GUID type SOTR_CONC optional
      !LAST_PAGE_REDIRECT type ICFREDURL optional
      !LAST_PAGE_REDIRECT_CODE type C optional
      !KINDNFPAG type C optional
      !SESSION_NOT_FOUND_HEADER_GUID type SOTR_CONC optional
      !SESSION_NOT_FOUND_BODY_GUID type SOTR_CONC optional
      !SESSION_NOT_FOUND_REDIRECT type ICFREDURL optional
      !SESSION_NOT_FOUND_REDIRECT_COD type C optional
    exceptions
      INSTALLATION_ERROR .
  class-methods SERVER_CACHE_INVALIDATE
    importing
      !ID type STRING
      !TYPE type I default 1
      !SCOPE type I default 1 .
  class-methods SERVER_CACHE_INVALIDATE_ALL
    importing
      !SCOPE type I default 1 .
  class-methods SERVER_CACHE_INVALIDATE_LIST
    importing
      !LIST type ICM_INVALETAB
      !SCOPE type I default 1 .
  class-methods SERVER_CACHE_UPLOAD
    importing
      !URL type STRING
      !RESPONSE type ref to IF_HTTP_RESPONSE
      !SCOPE type I default IHTTP_INV_LOCAL
      value(VIRTUAL_HOST) type I default IHTTP_VHOST_FROMREQ .
  class-methods STATISTIC_BEGIN
    importing
      !TAG type CHAR64 .
  class-methods STATISTIC_END
    importing
      !TAG type CHAR64 .
  class-methods TRACE
    importing
      !LINE type C .
  class-methods _APPEND_STRING_TO_XSTRING
    importing
      !SOURCE type STRING
    changing
      !DEST type XSTRING .
  class-methods _APPEND_XSTRING_TO_STRING
    importing
      !SOURCE type XSTRING
    changing
      !DEST type STRING .
  methods AUTHENTICATION
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVTBL type ICFSERVTBL
      !SERVICE type ICFLOGIN .
  methods CLEAR .
  methods CONSTRUCTOR .
  methods DEBUGGING
    importing
      !FORCE type I default 0 .
  methods RECEIVE_REQUEST
    returning
      value(RC) type I .
  methods SEND_RESPONSE
    importing
      !WEBSERVICE_RESPONSE type ABAP_BOOL default ABAP_FALSE
      !WEBSERVICE_AUTHENTICATION type ABAP_BOOL default ABAP_FALSE
    returning
      value(RC) type I .
  methods TIMEOUT
    importing
      !TIME type I .
  class-methods RETRIEVE_CERTIFICATE
    exporting
      !DOCUMENT type XSTRING
    exceptions
      NO_CERTIFICATE_AVAILABLE .
  class-methods SET_ENTITY_MESSAGE
    importing
      !ENTITY_OBJECT type ref to CL_HTTP_ENTITY
      !MESSAGE_OBJECT type %_C_POINTER .
  methods RECORDER
    importing
      !EXPIRATION_DAY type LIFEDAY optional
      !EXPIRATION_TIME type SYUZEIT optional
      !ICFATTRIB_ENTRY type ICFATTRIB optional
    changing
      !COMPONENT type I default 0
    exceptions
      DISABLE_RECORDING .
  methods SEND_RECORDER_CALLER_ID .
  methods RAISE_EVENT
    importing
      !REASON type I .
  methods GET_RESPONSE_MESSAGE
    returning
      value(MESSAGE_OBJECT) type %_C_POINTER .
  methods SEND_SERVICE_NOT_FOUND
    importing
      !STATUS_CODE type STRING
      !STATUS_REASON type STRING
      !PAGE_ATTRIBUTES type IHTTP_SERVICE_PAGE .
  methods SET_SERVICE_EXTENSIONS
    importing
      !RUNTIME_ATTRIBUTES type IHTTP_RUNTIME_MEMORY .
  methods GET_SERVICE_EXTENSION
    importing
      !KIND type I default IHTTP_ICFSERVICE_EXTENSION_ITS
    exporting
      !CONFIGURATION type STRING
    exceptions
      ERROR_DURING_PROCESSING
      KIND_IS_NOT_SUPPORTED .
  methods DELETE_SSO_COOKIE_AT_CLIENT .
protected section.

  class-data C_ENABLE_RECORDING type I .
*"* protected components of class CL_HTTP_SERVER
*"* do not include other source files here!!!
  class-data C_ACCEPT_SSO2_TICKET type I .
  class-data C_ACTION type I .
  class-data C_CERTIFICATE_AVAILABLE type I .
  class-data C_INSTANCE_ID type CHAR64 .
  class-data C_LAST_ERROR type I .
  class-data C_LOGIN_IS_DONE type CHAR1 .
  class-data C_PROTOCOL type I .
  class-data C_SAP_R3AUTH type STRING .
  class-data C_STATEFUL_REF type I .
  class-data C_SYSTEM_DBG type CHAR1 .
  class-data C_TRACE type I .
  class-data L_TRACE type STRING .
  data M_CALLED_BY_RFC type I .
  data M_EXE_TIME type F .
  data M_ICFRECORDER type ICFRECORDER .
  type-pools IHTTP .
  data M_ICFRECORDER_FIELDS type IHTTP_RECORDER_FIELDS .
  data M_LAST_ERROR type I .
  data M_NAME type STRING .
  data M_REQ_DATA type XSTRING .
  data M_RESP_DATA type XSTRING .
  class-data STATISTIC_TABLE type ICF_STAT .
  class-data STATISTIC_WA type ICFSTAT .
  data M_SSO_COOKIE type STRING .
  data M_AUTHORIZATION_TIME type F .
  constants CO_ERROR_PAGE_EPP_CONTEXT_ID type ICFCHAR4 value '-X:'. "#EC NOTEXT
  constants CO_ERROR_PAGE_EPP_TID type ICFCHAR4 value '-x:'. "#EC NOTEXT
  data M_SECURITY_SESSION_COOKIE type STRING .
  class-data C_USER_RECHECK type I .
  data M_PATH_TRANSLATED type STRING .
  type-pools ABAP .
  data C_SECURITY_SESSION_ACTIVE type ABAP_BOOL .
  data M_LOGOFF type I .

  class-methods REMOVE_EXTENSION_ENTRIES
    importing
      !SERVER_NAME type STRING .
  methods REFRESH_RESPONSE
    exceptions
      ACTION_FAILED .
  methods REPLACE_PAGE_TOKEN
    importing
      !SET_FFIELD_NAME type C default ''
    changing
      !PAGE type STRING .
  methods DEFAULT_NOT_FOUND_PAGE
    importing
      !STATUS_CODE type STRING
      !STATUS_REASON type STRING .
  methods DEFAULT_LAST_PAGE .
  methods CHECK_COMPRESSION
    exceptions
      COMPRESSION_NOT_POSSIBLE .
  class-methods GET_EPP_CONTEXT_IDS
    exporting
      !ROOT_CONTEXT_ID type EPP_ROOT_CONTEXT_ID
      !CONNECTION_ID type EPP_CONNECTION_ID
      !CONNECTION_COUNTER type EPP_CONNECTION_COUNTER
      !TRANSACTION_ID type EPP_TRANSACTION_ID
    exceptions
      EPP_ERROR .
private section.

*"* private components of class CL_HTTP_SERVER
*"* do not include other source files here!!!
  class-data C_BODYDBSTR type STRING .
  class-data C_HEADERDBSTR type STRING .
  class-data C_IHTTP_UTILITY type ref to IF_HTTP_UTILITY .
  class-data HTTP_EXT_INSTANCES type IHTTP_EXT_INSTANCES .
  data M_GUI_ATTACHED type I .
  class-data C_HTTPONLY_FLAG type I .
  class-data C_IS_SHOW_SERVER_HEADER type STRING .
  class-data C_IS_SERVER_HEADER type STRING .
  data M_UCON_RUNTIME type ref to IF_UCON_RUNTIME .
  data M_ICF_RUNTIME type ref to IF_ICF_RUNTIME .

  class-methods SET_GUI_SCRIPT_HDR_FIELDS
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVTBL type ICFSERVTBL
    exporting
      !GUI_SCRIPT_NAME type STRING
      !GUI_SCRIPT_NAME_EXPANDED type STRING
    exceptions
      INTERNAL_ERROR .
  class-methods SET_PATH_SEGMENTS_TO_HANDLER
    importing
      !ICF_NAME type ICFNAME
      !ICFPARGUID type ICFPARGUID
      !PATH_SEG_TO_PRE_HANDLER type STRING
    returning
      value(PATH_SEG_TO_CURR_HANDLER) type STRING .
ENDCLASS.



CLASS CL_HTTP_SERVER IMPLEMENTATION.


method authentication .
  include: icftreetop.
*  INCLUDE PERFINCL.
*  DATA: SERVER_OBJ TYPE REF TO CL_HTTP_SERVER.
*  DATA: SERV_WA  TYPE  ICFHANDLST.
*  DATA: CONTEXT_POOLING_STRATEGY TYPE I.
*
*" Debugging ===================
*    DATA: L_FIRSALIAS TYPE ICFALIAS.
*    DATA: C_DBG(64) TYPE C,
*          C_SYSTEM_DBG TYPE I VALUE 1.
**    DATA: DEBUG_URL TYPE STRING.
**    CLEAR: SERV_WA, L_FIRSALIAS.
**    SERVER_OBJ ?= SERVER.
**    DEBUG_URL = '/%_ADMIN'.
**    CALL METHOD SERVER_OBJ->OPTIONS
**       EXPORTING
**        SERVICE    = SERV_WA-SERVICE
**        FIRSTALIAS = L_FIRSALIAS
**        PATH       = DEBUG_URL.
**    CALL METHOD SERVER_OBJ->DEBUGGING( ).
**    c_dbg = '00040000399125D024AE7A26E10000000A11447B'.
**    call 'ICF_DISPATCH' id 'HTTP' field 'd'
**                        id 'CONTEXT_ID' field c_dbg
**                        id  'SystemDebug' field c_system_dbg.
*
*"==========================
*
*  PF_M_OPEN C_STATISTIC_STATE 'AuthInside'.
* " call method cl_http_server=>trace( 'Authentication' ).
*  SERVER_OBJ ?= SERVER.
** user already successfully authenticated?
*
*  IF NOT AUTHENTICATED IS INITIAL.
*    EXIT.
*  ENDIF.
*
*  DATA: PATH TYPE  STRING.
*  DATA: "service  type  icfservice,
*        LANGU           TYPE SYLANGU,
*        LOGIN_COMPLETE  TYPE SY-DEBUG,
*        DIALOG_USER_TYPE TYPE SY-DEBUG.
*
** local call (in same context) ?
*  IF C_LOCAL         = 1 AND
*     C_LOGIN_IS_DONE = 'Y'.
*        C_AUTHENTICATED = 1.
*        AUTHENTICATED   = 1.
*     EXIT.
*  ENDIF.
** conntext pooling via basic auth. is active
*  IF C_LOGIN_IS_DONE = 'Y' AND
*     C_ACTION        = 4. "TH_PLUGIN_FIRST_READ_LOGGED_ON = 4
*    PF_M_CLOSE C_STATISTIC_STATE 'AuthInside'.
*    C_AUTHENTICATED = 1.
*    AUTHENTICATED   = 1.
*
*" Adjasment of pooled context in terms of language
*    LANGU =
*       SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'SAP-Language' ).
*    IF LANGU IS INITIAL.
*      LANGU = SERVICE-ICF_LANGU.
*    ENDIF.
*    IF SY-LANGU <> LANGU.
*      SET LOCALE LANGUAGE LANGU.
*      SET LANGUAGE LANGU.
*    ENDIF.
*
*    EXIT.
*  ENDIF.
*
** is this an authentication request?
*  DATA: PASSWORD     TYPE CHAR8,
*        PASSWORD_SCR TYPE IMCCHAR32,
*        CLIENT       TYPE SYMANDT,
*        USERNAME     TYPE SYUNAME,
*        SUBRC        TYPE SYSUBRC,
*        AUTHSTRING   TYPE STRING,
*        SSO          TYPE STRING.
*
*      DATA: SSO_IMPORT TYPE STRING,
*            SSO_EXPORT TYPE STRING.
*      CALL METHOD SERVER->REQUEST->GET_COOKIE
*           EXPORTING
*             NAME    = 'mysapsso2' " 'MYSAPSSO2'
*         "    path    = '/'
*           IMPORTING
*             VALUE   = SSO_IMPORT.
*         "    domain  = domain
*         "    expires = expires
*         "    secure  = secure.
*
** prepare logon data, based on ICF service entries
*  PF_M_OPEN C_STATISTIC_STATE 'Header Fields'.
*  AUTHSTRING =
*         SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'authorization' ).
*
*  SSO  = SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'SAP-SSO' ).
*
*  IF AUTHSTRING IS INITIAL.
*    USERNAME =
*        SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'SAP-User' ).
*    PASSWORD =
*        SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'SAP-Password' ).
*  ENDIF.
*
*  CLIENT =
*        SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'SAP-Client' ).
*  LANGU =
*       SERVER->REQUEST->GET_HEADER_FIELD( NAME = 'SAP-Language' ).
*  PF_M_CLOSE C_STATISTIC_STATE 'Header Fields'.
*
*  PUBLIC_SERVICE = 0.
*  PF_M_OPEN C_STATISTIC_STATE 'ICFFields'.
*
*  IF SERVICE-ICFPARGUID = ICFPUBLICSERVICE.
*     PUBLIC_SERVICE = 1.
*  ENDIF.
*  PF_M_CLOSE C_STATISTIC_STATE 'ICFFields'.
*
*  IF NOT AUTHSTRING     IS INITIAL OR
*     NOT SSO_IMPORT     IS INITIAL OR
*   ( NOT USERNAME IS INITIAL AND NOT PASSWORD IS INITIAL ) OR
*   ( NOT SERVICE-ICF_USER   IS INITIAL AND
*     NOT SERVICE-ICF_PASSWD IS INITIAL ).
*
** and authstring(5) eq 'Basic'.
*    DATA: BASIC           TYPE STRING,
*          ENC_BASICCOOKIE TYPE STRING,
*          DEC_BASICCOOKIE TYPE STRING,
*          CONTEXT_POOLING TYPE STRING.
** invalidate autorization field
*   IF NOT AUTHSTRING IS INITIAL.
*     SERVER->REQUEST->SET_HEADER_FIELD( NAME = 'authorization'
*                                        VALUE = BASIC ).
*   ENDIF.
*   IF NOT PASSWORD IS INITIAL.
*     SERVER->REQUEST->SET_HEADER_FIELD( NAME = 'password'
*                                        VALUE = BASIC ).
*   ENDIF.
**   if not sso_import is initial.
**      call method server->request->set_cookie
**           exporting
**             name    = 'mysapsso2'
**             value   = basic.
**  endif.
*
*" Logon via basic authorization header field
*  IF NOT AUTHSTRING IS INITIAL AND
*       ( USERNAME IS INITIAL OR PASSWORD IS INITIAL ).
*
**   extract username and password
*      SPLIT AUTHSTRING AT ' ' INTO BASIC ENC_BASICCOOKIE.
*      PF_M_OPEN C_STATISTIC_STATE 'Base64'.
*      CALL 'ICT_DISPATCH' ID 'did'    FIELD 'base64_unescape'
*                          ID 'source' FIELD ENC_BASICCOOKIE
*                          ID 'dest'   FIELD DEC_BASICCOOKIE.
*      PF_M_CLOSE C_STATISTIC_STATE 'Base64'.
*
*      SPLIT DEC_BASICCOOKIE AT ':' INTO USERNAME PASSWORD.
*
*" Context pooling strategy
*      IF NOT USERNAME IS INITIAL AND
*         NOT PASSWORD IS INITIAL AND
*         CLIENT       IS INITIAL AND
*         LANGU        IS INITIAL.
*       CONTEXT_POOLING = ENC_BASICCOOKIE.
*       CONTEXT_POOLING_STRATEGY = 1.
*     ENDIF.
*   ENDIF.
*   ENDIF.
**   try login
*"    if sy-subrc = 0.
*
*      IF USERNAME IS INITIAL.
*        USERNAME = SERVICE-ICF_USER.
*      ENDIF.
*
*      IF PASSWORD IS INITIAL.
*        PASSWORD_SCR = SERVICE-ICF_PASSWD.
*      ENDIF.
*
*      IF CLIENT IS INITIAL.
*        CLIENT = SERVICE-ICF_MANDT.
*      ENDIF.
*
*      IF LANGU IS INITIAL.
*        LANGU = SERVICE-ICF_LANGU.
*      ENDIF.
*
*"      call method cl_http_server=>trace( username ).
*
*      PF_M_OPEN C_STATISTIC_STATE 'Logon'.
*      IF NOT SSO_IMPORT IS INITIAL.
*        CALL FUNCTION 'HTTP_AUTHENTICATE'
*             EXPORTING
*                  CLIENT            = CLIENT
*                  USERNAME          = USERNAME
*                  PASSWORD          = PASSWORD
*                  LANGUAGE          = LANGU
*                  SSO_IMPORT        = SSO_IMPORT
*             IMPORTING
*                  SUBRC             = SUBRC
*                  SSO_EXPORT        = SSO_EXPORT
*             EXCEPTIONS
*                  INVALID_PARAMETER = 1
*                  OTHERS            = 2.
*             IF SY-SUBRC = 0 AND SUBRC = 0 AND NOT SSO IS INITIAL.
*" Context pooling strategy
*               CONTEXT_POOLING_STRATEGY = 2.
*               CONTEXT_POOLING = SSO_IMPORT.
*             ENDIF.
**             elseif ( subrc <> 0  and password_scr is initial ).
**                  call function 'HTTP_AUTHENTICATE'
**                   exporting
**                      client            = client
**                      username          = username
**                      password          = password
**                      language          = langu
**                   importing
**                      subrc             = subrc
**                      sso_export        = sso_export
**                   exceptions
**                      invalid_parameter = 1
**                   others            = 2.
**           endif.
*      ELSEIF NOT PASSWORD_SCR IS INITIAL.
*" Default logon data for service
*      CALL FUNCTION 'HTTP_AUTHENTICATE'
*           EXPORTING
*                CLIENT            = CLIENT
*                USERNAME          = USERNAME
*                LANGUAGE          = LANGU
*                PASSWORD_ENCR     = PASSWORD_SCR  " PASSWORD =
*           IMPORTING
*                SUBRC             = SUBRC
*           EXCEPTIONS
*                INVALID_PARAMETER = 1
*                OTHERS            = 2.
*        IF SY-SUBRC = 0.
*          SY-UNAME = USERNAME.
*          C_AUTHENTICATED = 1.
*          AUTHENTICATED   = 1.
*          EXIT. "no context pooing
*        ENDIF.
*      ELSE.
*         CALL METHOD SERVER->REQUEST->GET_COOKIE
*            EXPORTING
*             NAME    = C_SAP_R3AUTH
*           IMPORTING
*              VALUE   = SSO_IMPORT.
*
*        IF SSO_IMPORT IS INITIAL.
*         CALL FUNCTION 'HTTP_AUTHENTICATE'
*             EXPORTING
*                  CLIENT            = CLIENT
*                  USERNAME          = USERNAME
*                  PASSWORD          = PASSWORD
*                  LANGUAGE          = LANGU
*             IMPORTING
*                  SUBRC             = SUBRC
*                  SSO_EXPORT        = SSO_EXPORT
*             EXCEPTIONS
*                  INVALID_PARAMETER = 1
*                  OTHERS            = 2.
*          IF SY-SUBRC = 0 AND SUBRC = 0 AND NOT SSO IS INITIAL.
*" Context pooling strategy
*               CONTEXT_POOLING_STRATEGY = 2.
*               CONTEXT_POOLING = SSO_EXPORT.
*          ENDIF.
*          ELSE.
*            DATA: SESSION TYPE XSTRING.
*              SESSION = SSO_IMPORT.
*              CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
*                        ID 'RFCLogon' FIELD 'X'
**                        id 'TimeStamp' field TimeStamp
*"                        id 'CIP' field cip
*"                        id 'CHost' field chost
*"                        id 'CServer' field cserver
*                         ID 'SessionID' FIELD SESSION.
*               IF SY-SUBRC = 0.
*                 SY-UNAME = USERNAME.
*                 C_AUTHENTICATED = 1.
*                 AUTHENTICATED   = 1.
*" Context pooling strategy kann bei RFC-Verschl. nie funktionieren
*" Da der Key sich dauerend #ndert
*"               context_pooling_strategy = 2.
*"               context_pooling = sso_import.
*               SUBRC = 0.
*              EXIT. " no context-pooling ?
*              ENDIF.
*          ENDIF.
*
**        call function 'HTTP_AUTHENTICATE'
**             exporting
**                  client            = client
**                  username          = username
**                  password_encr     = password_scr
**                  language          = langu
**             importing
**                  subrc             = subrc
**                  sso_export        = sso_export
**             exceptions
**                  invalid_parameter = 1
**                  others            = 2.
*      ENDIF.
*
**     login succeeded?
*      IF SY-SUBRC = 0 AND SUBRC = 0.
*        C_AUTHENTICATED = 1.
*        AUTHENTICATED   = 1.
*
*        IF NOT SSO_EXPORT IS INITIAL AND NOT SSO IS INITIAL.
*          DATA: DOMAIN TYPE STRING,
*                DUMMY TYPE STRING,
*                LEN TYPE I.
*           DOMAIN =
*             SERVER->REQUEST->GET_HEADER_FIELD( 'user-agent' ).
*           IF NOT DOMAIN IS INITIAL.
*             LEN = STRLEN( DOMAIN ).
*             IF LEN > 4 AND
*               DOMAIN CS 'MSIE' OR DOMAIN CS 'msie'.
*               DOMAIN =
*                 SERVER->REQUEST->GET_HEADER_FIELD( '~server_name' ).
*               SPLIT DOMAIN AT '.' INTO DUMMY DOMAIN.
*             ELSE. "Netscape
*               DOMAIN =
*                 SERVER->REQUEST->GET_HEADER_FIELD( '~server_name' ).
*               SPLIT DOMAIN AT '.' INTO DUMMY DOMAIN.
*               CONCATENATE '.' DOMAIN INTO DOMAIN.
*             ENDIF.
*           ENDIF.
*          PATH = '/'.
*          CALL METHOD SERVER->RESPONSE->SET_COOKIE
*            EXPORTING
*                     NAME    = 'MYSAPSSO2'
*                     PATH    = PATH
*                     VALUE   = SSO_EXPORT
*                     DOMAIN  = DOMAIN.
*             "       expires = ''.
*             "       secure  = secure.
*        ENDIF.
*
*        PF_M_CLOSE C_STATISTIC_STATE 'Logon'.
** insert user account for context pooling
*        IF NOT CONTEXT_POOLING IS INITIAL.
* "         call 'ICF_DISPATCH' id 'HTTP'       field 'X'
* "            id 'SetContextPooling' field context_pooling_strategy.
* "
*          CALL 'ICF_DISPATCH' ID 'HTTP'       FIELD 'x'
*                              ID 'SetContext' FIELD CONTEXT_POOLING.
*
*
*        ENDIF.
*        PF_M_CLOSE C_STATISTIC_STATE 'AuthInside'.
*        EXIT.
*      ENDIF.
*"    endif.
* " else.
**    username =
**       server->request->get_header_field( name = 'SAP-User' ).
**    if not username is initial.
**                                       " R/3 logon
**      client =
**        server->request->get_header_field( name = 'SAP-Client' ).
**                                       "   client = authstring.
**      password_scr =
**       server->request->get_header_field( name = 'SAP-Auth' ).
**      langu =
**       server->request->get_header_field( name = 'SAP-Language' ).
**      call function 'HTTP_AUTHENTICATE'
**           exporting
**                client            = client
**                username          = username
**                language          = langu
**                password_encr     = password_scr  " PASSWORD =
**           importing
**                subrc             = subrc
**           exceptions
**                invalid_parameter = 1
**                others            = 2.
**      if sy-subrc = 0.
**        sy-uname = username.
**        c_authenticated = 1.
**        authenticated   = 1.
**        exit.
**      endif.
**    else.
**      username = server->request->get_form_field( 'sap-user' ).
**      if not username is initial.
**                                       " R/3 logon
**        authstring =
**          server->request->get_form_field( name = 'sap-client' ).
**        client = authstring.
**        password =
**         server->request->get_form_field( name = 'sap-auth' ).
**        langu =
**         server->request->get_form_field( name = 'sap-language' ).
**        call function 'HTTP_AUTHENTICATE'
**             exporting
**                  client            = client
**                  username          = username
**                  language          = langu
**                  password          = password
**             importing
**                  subrc             = subrc  " PASSWORD_ENCR =
**             exceptions
**                  invalid_parameter = 1
**                  others            = 2.
**        if sy-subrc = 0.
**          sy-uname = username.
**          c_authenticated = 1.
**          authenticated   = 1.
**          exit.
**        endif.
**      else. " session ticket
**         call method server->request->get_cookie
**            exporting
**             name    = 'sap-session'
**           importing
**              value   = sso_import.
**          if not sso_import is initial.
**            data: session type xstring.
**              session = sso_import.
**              call 'ICF_DISPATCH' id 'HTTP'     field 'L'
**                        id 'RFCLogon' field 'X'
***                        id 'TimeStamp' field TimeStamp
**"                        id 'CIP' field cip
**"                        id 'CHost' field chost
**"                        id 'CServer' field cserver
**                         id 'SessionID' field session.
**               if sy-subrc = 0.
**                 sy-uname = username.
**                 c_authenticated = 1.
**                 authenticated   = 1.
**                 exit.
**               endif.
**          endif.
**      endif.
**
**    endif.
*
**  endif.
  data: authstring   type string.
* no authentication check for public services
  if service-PUBLICFLAG = 'X'.
    public_service = 1.
  endif.

  if public_service = 0.
* otherwise prompt for username and password
    data: realm     type string,
          challenge type string,
          msg       type string,
          client    type symandt.

    realm = sy-sysid.
    concatenate 'Basic realm="SAP R/3 [' realm ']"' "#EC NOTEXT
                       into challenge.

    if authstring is initial.
      msg = 'Please provide username and password'. "#EC NOTEXT
    else.
      msg = 'Login failed! Please try again.'. "#EC NOTEXT
    endif.
    data: sap type string.

    sap = sy-sysid.
    call method server->response->set_header_field
      EXPORTING
        name  = 'SAP-System' "#EC NOTEXT
        value = sap.

    call method server->response->set_status(
            code = 401
            reason = 'Unauthorized' ). "#EC NOTEXT
    call method server->response->set_header_field(
            name = 'WWW-Authenticate' "#EC NOTEXT
            value = challenge ).

    call 'C_SAPGPARAM' id 'NAME'  field 'login/system_client'
                         id 'VALUE' field client.
    challenge = client.
    call method server->response->set_header_field(
            name = 'SAP-Client' "#EC NOTEXT
            value = challenge ).

    call method server->response->set_cdata( data = msg ).

  endif.
endmethod.                    "


method authorization .
* ...
" no authority checks for public services
*  if public_service = 1.
*     exit.
*  endif.

  pf_m_open c_statistic_state 'A:Authorization'. "#EC NOTEXT
  if not service-icf_auth is initial.
    authority-check object 'S_ICF'
                    id 'ICF_FIELD' field 'SERVICE'
                    id 'ICF_VALUE' field service-icf_auth.
    if sy-subrc <> 0.
      case service-icf_authrc.
* error vs. abort message
        when 0.                                             "0
          message e101(sr) with sy-uname sy-mandt
                                         service-icf_auth url.
        when 1.
          message a101(sr) with sy-uname sy-mandt
                                         service-icf_auth url.
        when 2.
          message x101(sr) with sy-uname sy-mandt
                                         service-icf_auth url.
        when others.                                        "0
          message e101(sr) with sy-uname sy-mandt
                                         service-icf_auth url.
      endcase.
    endif.
  endif.
  pf_m_close c_statistic_state 'A:Authorization'. "#EC NOTEXT
endmethod.


METHOD check_compression.

  DATA: encoding    TYPE string,
        protocol    TYPE string,
        l_last_err  TYPE c.
*
* compression only if
* a) client protocol >=  HTTP/1.1
* a) client can decode gzip documents ('accept-encoding')
* b) running plattform support this feature
*

  IF c_compression_supported = co_disabled.
    c_last_error = 1.
*    raise compression_not_possible.
    l_last_err = c_last_error.
    MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
          l_last_err RAISING compression_not_possible.
  ENDIF.

  protocol =
     request->get_header_field(
                          name = '~server_protocol' ).      "#EC NOTEXT
  SPLIT protocol AT '/' INTO encoding protocol.
  IF protocol < '1.1'.
    c_last_error = 2.
*    raise compression_not_possible.
    l_last_err = c_last_error.
    MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
          l_last_err RAISING compression_not_possible.
  ENDIF.

  encoding =
     request->get_header_field(
                          name = 'accept-encoding' ).       "#EC NOTEXT
  IF NOT encoding IS INITIAL.
    FIND 'gzip' IN encoding. " respecting case.
    IF sy-subrc <> 0.
      c_last_error = 4.
*      raise compression_not_possible.
      l_last_err = c_last_error.
      MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
            l_last_err RAISING compression_not_possible.
    ENDIF.
  ELSE.
    c_last_error = 3. "accept-encoding not available
*    raise compression_not_possible.
    l_last_err = c_last_error.
    MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
          l_last_err RAISING compression_not_possible.
  ENDIF.

* We have found that compression fails once complete URL length > 259 bytes.
* This complete length must protocol, host, port, etc.
* See note 796354
  DATA: agent            TYPE i,
        url              TYPE string,
        host             TYPE string,
        length           TYPE i,
        version          TYPE i,
        patch_level_info TYPE string.

  DATA: l_exp        TYPE string,
        l_cache_cntl TYPE string,
        l_pragma     TYPE string.

  TYPES:
        type_line TYPE c LENGTH 255.

  DATA: l_itab         TYPE TABLE OF type_line,
        l_pointer      TYPE i,
        l_do_compress  TYPE boolean VALUE abap_false.

  CONSTANTS: co_sec_vers    TYPE c LENGTH 2 VALUE 'SV',
             co_sec_vers_nr TYPE c LENGTH 3 VALUE 'SV1'.

  FIELD-SYMBOLS <fs_line> TYPE type_line.

  l_exp        = response->get_header_field( if_http_header_fields=>expires ).
  l_pragma     = response->get_header_field( if_http_header_fields=>pragma ).
  l_cache_cntl = response->get_header_field( if_http_header_fields=>cache_control ).

* Error only occurs when response is actually cached, see also note 996604
  IF NOT ( l_exp = '0'
        OR l_pragma CS `no-cache`
        OR l_cache_cntl CS `no-cache` ).

    request->get_user_agent( IMPORTING user_agent_type    = agent
                                       user_agent_version = version ).

    patch_level_info = request->get_header_field( if_http_header_fields=>user_agent ).

    IF agent = ihttp_user_agent_ie.
      url  = request->get_header_field( if_http_header_fields_sap=>request_uri ).
      host = request->get_header_field( if_http_header_fields=>host ).
      " includes host + port
      length = strlen( url ) + strlen( host ) + 10.
      " protocol(max5)=http|https + "://" (==3) + fudge factor (==3)

      IF length > 259.
        IF version < 600.
          l_do_compress = abap_false. "do not compress
        ELSEIF version > 600. "do compress
          l_do_compress = abap_true.
        ELSEIF version = 600. "do compress if SV1 exists

          SPLIT patch_level_info AT ';' INTO TABLE l_itab.

          LOOP AT l_itab ASSIGNING <fs_line> FROM l_pointer.

            WHILE <fs_line> IS NOT INITIAL AND
                  <fs_line>(1) EQ space.
              SHIFT <fs_line> LEFT.
            ENDWHILE.

            IF   <fs_line>(3) EQ co_sec_vers_nr OR
               ( <fs_line>(2) EQ co_sec_vers    AND
                 <fs_line>+2(1) >= 1 ).
              l_do_compress = abap_true. "IE with SV1 patch; do compress
              EXIT.
            ELSE.
              l_pointer = l_pointer + 1.
            ENDIF.

          ENDLOOP.
        ENDIF.

        IF l_do_compress EQ abap_false. "do not compress
          c_last_error = 5.
          l_last_err = c_last_error.
          MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
                l_last_err RAISING compression_not_possible.
*          raise compression_not_possible.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDIF.

ENDMETHOD.


method class_constructor .
  data: c_ecode                      type i,
        l_shared_memory_cache_off(4) type c.

* initially the user is not authenticated
  c_authenticated       = co_disabled.
  authentication_method = authmethod_none.

  c_trace_force         = 0.
* debugging is not active
  clear: c_debugid, c_system_dbg.
   c_mysapsso2_available = -1.
* by default we operate stateless
   stateful      = 0.

* by default we operate none transactional
  transactional = 0.

* -- set constant parameters
  co_form_field_b64 = 'sap-ffield_b64'.
  co_form_field     = 'sap-ffield'.

* -- set version number
  version = '1.0'.

* session id
  session_id = '<undefined>'.
  data: contextid(256) type c. "thfb_context_id.
  c_context_pooling_enabled = -1.

  call 'ICF_DISPATCH' id 'HTTP' field 'e'
                 id 'DebuggingPossible' field c_debugging_possible
                 id 'Login'     field c_login_is_done
                 id 'Action'    field c_action
                 id 'Statistic' field c_statistic_state
                 id 'ContextID' field contextid
                 id 'Trace'     field c_trace
                 id 'Protocol'  field c_protocol
*                id 'R3AuthPooling' field r3authpooling
                 id 'CPoolingActive' field  c_context_pooling_enabled
                 id 'ContextType'    field  authentication_method
                 id 'KernelVersion'  field c_kernel_version
                 id 'ABAPVersion'    field c_abap_version
                 id 'VirtualServer'  field c_virtual_host
                 id 'CallerIP' field c_caller_ip
                 id 'CertificateAvailable'
                                   field c_certificate_available
                 id 'AcceptSSO2Ticket'
                                   field c_accept_sso2_ticket
                 id 'AcceptRemoteTraceLevel'
                                   field c_accept_remote_trace_level
                 id 'AcceptRemoteProfileLevel'
                                   field c_accept_remote_profile_level
                 id 'AcceptRemoteRecorderLevel'
                                   field c_accept_remote_recorder_level
                 id 'InstanceID'   field c_instance_id
                 id 'ICFOptions'   field c_icf_options
                 id 'SharedMemoryCacheOff'
                                   field l_shared_memory_cache_off
                 id 'set_HTTPonly_flag_on_cookies'
                                   field c_httponly_flag
                 id 'UserRecheck' field c_user_recheck
                 id 'IsShowServerHeader' field c_is_show_server_header
                 id 'IsServerHeader'     field c_is_server_header.

 if l_shared_memory_cache_off is not initial and
    l_shared_memory_cache_off <> 'N'.
   if l_shared_memory_cache_off = 'Y'.
     c_shared_memory_cache_off = 3.
   else.
     c_shared_memory_cache_off = l_shared_memory_cache_off.
   endif.
 endif.

* -- update prootocol type (TH_PLUGIN_PROTOCOL_HTTPS = 2)
 if c_protocol = 2.
   ssl_active = co_enabled.
 else.
   ssl_active = co_disabled.
 endif.

 system-call ict
  did
    ihttp_scid_compress_supported
  parameters
    c_ecode.                    " < return code
 if c_ecode = 0 and
    sy-subrc = 0.
   c_compression_supported = co_enabled.
 else.
   c_compression_supported = co_disabled.
 endif.

 if c_context_pooling_enabled = -1.
   data: cpooling(10) type c.
   call 'C_SAPGPARAM'
        id    'NAME'
        field 'rdisp/plugin_server_pooling'
        id    'VALUE'
        field  cpooling.
  if cpooling = 'ON'.
    c_context_pooling_enabled = 1.
  else.
    c_context_pooling_enabled = 0.
  endif.
 endif.

 data: http_utility type ref to cl_http_utility.
 create object http_utility.
 c_ihttp_utility = http_utility.


*
*    data: contextid type thfb_w3c_context_id.
*    call function 'TH_GET_W3C_CONTEXT_ID'
*         importing
*              w3_context_id = contextid.

  session_id   = contextid.
  c_sap_r3auth = 'SAP-R3Auth'. "#EC NOTEXT

*  call 'C_SAPGPARAM'
*       id    'NAME'
*       field 'rdisp/plugin_server_pooling'
*       id    'VALUE'
*       field  c_context_pooling_enabled.

*  call 'C_SAPGPARAM'
*       id    'NAME'
*       field 'login/create_sso2_ticket'
*       id    'VALUE'
*       field  c_create_sso.
*
*  call 'C_SAPGPARAM'
*       id    'NAME'
*       field 'accept_sso2_ticket'
*       id    'VALUE'
*       field  c_accept_sso.
*
* temporarily during switch to system-calls
*
*data: profile_name(60)  type c value 'http/systemcall',
*      profile_value(60) type c.
*
*call 'C_SAPGPARAM' id 'NAME'  field profile_name
*                   id 'VALUE' field profile_value.
*if profile_value = '1'.
*  _system_call = 1.
*else.
*  _system_call = 0.
*endif.


endmethod.


method CLEAR .
" reset debugging indicator
 clear c_debugid.

endmethod.


method constructor .

* Messung mit hoher Auflösung
  m_timer = cl_abap_runtime=>create_hr_timer( ).

  stateful = co_disabled.

* create a request object
  data: http_request type ref to cl_http_request.
  public_service = 0.
  create object http_request.
  request = http_request.

*
* the request objects gets their associated c msg from receive_request
*

* create a response object
  data: http_response type ref to cl_http_response.

  create object http_response.
  response = http_response.
*
* the response object gets their associated c msg here and
* in receive_request for stateful communication
*
  data: c_msg type %_c_pointer.

  system-call ict
    did
      ihttp_scid_create_message
    parameters
      2                              " > message type (2 = resp)
      c_msg                          " < c handle
      m_last_error.                  " < return code

  http_response->set_c_msg( c_msg ).

  http_response->if_http_response~set_status(
    code = 200 reason = 'OK'
  ).


endmethod.


METHOD debugging .
* -- taskhandler statistic macros
*  include: perfinterval.
  DATA: l_icfattrib TYPE icfattrib .
  DATA: subrc(4)    TYPE c.
  DATA: l_debuguser TYPE syuname.
  DATA: l_rfcdest   TYPE rfcdest.
  DATA: l_rfcsi     TYPE rfcsi.
  DATA: l_trace     TYPE string.
  DATA: l_remote_debug_key TYPE user_key VALUE space.
  DATA: l_remote_debug_key_len TYPE i VALUE 0.
  DATA: l_terminal_id TYPE sysuuid_c32 VALUE space.
  DATA: l_error          TYPE REF TO cx_epp_error.
  DATA: l_epp_abap TYPE REF TO if_epp_system_section.
  DATA: l_error_text TYPE string.
  DATA: l_is_tid_attach TYPE sap_bool.
  DATA: l_debugger_attach TYPE c.

  IF c_sap_trace >= 1.
    CONCATENATE 'Dbg possible:' c_debugging_possible        "#EC NOTEXT
       INTO l_trace.

    CALL METHOD request->set_header_field
      EXPORTING
        name  = 'SAP-Debug-Trace'                           "#EC NOTEXT
        value = l_trace.
  ENDIF.

*
* debugid (session id to attach SAPGUI) is already read from DB
*
*  DATA: l_systemwide TYPE abap_bool.
*  CALL METHOD cl_system_wide_debugging=>check
*    IMPORTING
*      is_set = l_systemwide.

  CHECK c_debugging_possible = 'Y'.

* debugging method was already processed for this request in ICF
  IF force = 0.
    CHECK c_debugid IS INITIAL.
  ENDIF.

  pf_m_open c_statistic_state 'A:Debugging Option'.           "#EC NOTEXT


* to overcome case sensitivity of host name -> normalization of name
* translate l_rfcdest to upper case. "#EC TRANSLANG

  IF c_sap_trace >= 1.
    CALL FUNCTION 'RFC_SYSTEM_INFO'
      IMPORTING
        rfcsi_export = l_rfcsi.
    l_rfcdest = l_rfcsi-rfcdest.
    CONCATENATE l_trace ', CIPAddr:' c_caller_ip INTO l_trace. "#EC NOTEXT
    CONCATENATE l_trace ', Server:' l_rfcdest INTO l_trace. "#EC NOTEXT
    CONCATENATE l_trace ', WhoAmI:' sy-uname INTO l_trace.  "#EC NOTEXT
    CONCATENATE l_trace ', CClient:' sy-mandt INTO l_trace. "#EC NOTEXT
    CALL METHOD request->set_header_field
      EXPORTING
        name  = 'SAP-Debug-Trace'                           "#EC NOTEXT
        value = l_trace.
  ENDIF.

  CALL METHOD cl_icf_cross_tools=>launch_debugger
    EXPORTING
      i_request    = request
      i_trace      = c_sap_trace
      i_caller_ip  = space "c_caller_ip
    IMPORTING
      e_debug_id   = c_debugid
      e_system_dbg = c_system_dbg.


** Extract terminal ID from EPP (if possible).
*  TRY.
*      l_epp_abap = cl_epp_system_factory=>get_section( if_epp_abap_trouble_shooting=>co_trouble_shooting_section  ).
*      IF l_epp_abap IS NOT INITIAL.
*        l_terminal_id = l_epp_abap->get_item_by_key_as_uuid( if_epp_abap_trouble_shooting=>co_terminal_id_item ).
*      ENDIF.
*    CATCH cx_epp_error INTO l_error.
*      l_terminal_id = space.
*      l_error_text = l_error->get_text( ).
*      IF c_sap_trace >= 1.
*        CONCATENATE 'Terminal-ID could not be extracted from EPP, error text: '
*          l_error_text INTO l_trace.                        "#EC NOTEXT
*        CALL METHOD request->set_header_field
*          EXPORTING
*            name  = 'SAP-Debug-Trace'                       "#EC NOTEXT
*            value = l_trace.
*      ENDIF.
*  ENDTRY.
**  IF sy-uname = 'KRAEMER'.
**    l_terminal_id = '1324'.
**  ENDIF.
*
*  CALL FUNCTION 'HTTP_READ_DEBUG'
*    EXPORTING
*      caller_ip            = c_caller_ip
*      terminal_id          = l_terminal_id
*    IMPORTING
*      icfattrib_exp        = l_icfattrib
*      subrc                = subrc
*      remote_debug_key     = l_remote_debug_key
*      remote_debug_key_len = l_remote_debug_key_len
*      is_tid_attach        = l_is_tid_attach.
*
*  IF l_is_tid_attach = abap_true.
*    l_debugger_attach = 'X'.
*  ENDIF.
*
*  c_debugid    = l_icfattrib-debugid.
*  c_system_dbg = l_icfattrib-systdebug.
*  l_debuguser  = l_icfattrib-cusername.
*
*  IF c_sap_trace >= 1.
*    CONCATENATE l_trace ', Subrc:' subrc INTO l_trace.      "#EC NOTEXT
*    CONCATENATE l_trace ', DbgId:'                          "#EC NOTEXT
*                         l_icfattrib-debugid INTO l_trace.
*    CALL METHOD request->set_header_field
*      EXPORTING
*        name  = 'SAP-Debug-Trace'                           "#EC NOTEXT
*        value = l_trace.
*
*  ENDIF.
*
*  IF NOT c_debugid IS INITIAL.
**    IF sy-uname = 'KRAEMER'.
*    CALL 'ICF_DISPATCH' ID 'HTTP'         FIELD 'd'
*                        ID 'CONTEXT_ID'   FIELD c_debugid
*                        ID 'User'         FIELD l_debuguser
*                        ID 'SystemDebug'  FIELD c_system_dbg
*                        ID 'REMOTE_DEBUG_KEY' FIELD l_remote_debug_key
*                        ID 'REMOTE_DEBUG_KEY_LEN' FIELD l_remote_debug_key_len
*                        ID 'DebuggerAttach' FIELD l_debugger_attach.
**    ELSE.
**      CALL 'ICF_DISPATCH' ID 'HTTP'         FIELD 'd'
**                          ID 'CONTEXT_ID'   FIELD c_debugid
**                          ID 'User'         FIELD l_debuguser
**                          ID 'SystemDebug'  FIELD c_system_dbg.
**    ENDIF.
**   system-call plugin id 'METHOD' value 'D'. "Debugging
*  ENDIF.
  pf_m_close c_statistic_state 'A:Debugging Option'.          "#EC NOTEXT
ENDMETHOD.


METHOD default_last_page.
  DATA: uri           TYPE string.
  DATA: note          TYPE string.
  DATA: l_note        TYPE string.
  DATA: l_date(20)    TYPE c.
  DATA: l_time(20)    TYPE c.
*data: iso_langu(2) type c.
  DATA: recommendation TYPE string.
  DATA: reason         TYPE string.
  DATA: content        TYPE string.
  DATA: start_appl_codepage TYPE cpcodepage,
        http_codepage_name  TYPE string.

*uri = request->get_header_field( '~path_translated' ).
  uri = create_abs_url( ).

*
* XSS- Attacken verhindern (z. B. /sap/bc/<script><ok></script>/echo)
*

* Use new ABAP XSS Escaping library (see sap note 1644634)
*uri = cl_http_utility=>escape_html( uri ).
  uri = escape( val    = uri
                format = cl_abap_format=>e_xss_ml ).

* -- reason
* Sie wurden durch die Ausführung des URLs &1 abgemeldet.
  reason = 'Sie haben sich aus dem System abgemeldet.'(v03).
  REPLACE '&1' WITH uri INTO reason.

* -- system
* Sie wurden durch die Ausführung des URLs &1 abgemeldet.
*note =
*  'Die Aktion wurde durch den Aufruf der URL &1 durchgeführt.'(V02).
*replace '&1' with uri into note.

  WRITE: sy-datum TO l_date.
  WRITE: sy-uzeit TO l_time.
* Die Abmeldung wurde am &1 um &2 im System &3 ausgeführt.
  l_note = 'Die Abmeldung fand am &1 um &2 Systemzeit statt.'(v01).
  REPLACE '&1' WITH l_date INTO l_note.
  REPLACE '&2' WITH l_time INTO l_note.
*replace '&3' with sy-sysid into l_note.

*concatenate '<ul><li>' l_note '</li><li>' note '</li></ul>' into note
  CONCATENATE '<ul><li>' l_note '</li></ul>' note INTO note
  SEPARATED
  BY space.

  CONCATENATE
   '<!DOCTYPE html PUBLIC '                                 "#EC NOTEXT
           '"-//W3C//DTD HTML 4.01'                         "#EC NOTEXT
           'Transitional//EN'                               "#EC NOTEXT
           '">'
  '<html>'
    '<head>'
      '<title>Logon Error Message</title>'
      '<META http-equiv="Content-Type" content="text/html; '
      'charset=UTF-8">'
      '<style type="text/css">'
        'body { font-family:tahoma,helvetica,sans-serif;color:#'
  '333333;background-color:#FFFFFF; }'
  'td { font-family:tahoma,helvetica,sans-serif;font-size:70%;color:'
  '#333333; }'
  'h1 { font-family:tahoma,helvetica,sans-serif;font-size:160%;font-'
  'weight:bold;margin-top:15px;margin-bottom:3px;color:#003366; }'
  'h2 { font-family:verdana,helvetica,sans-serif;font-'
  'size:120%;font-style:italic;font-weight:bold;margin-top:6px;margin-'
  'bottom:6px;color:#999900; }'
  'p { font-family:tahoma,helvetica,sans-serif;color:#333333;margin-'
  'top:4px;margin-bottom:4px; }'
  'ul { font-family:tahoma,helvetica,sans-serif;color:#333333;list-'
  'style-type:square;margin-top:8px;margin-bottom:8px; }'
  'li { font-family:tahoma,helvetica,sans-serif;color:#'
  '33333;margin-top:4px; }'
  '.emphasize { color:#333333;background-'
  'color:#C8E3FF;padding:5px;}'
  '.note { color:#CC6600; }'                                "#EC NOTEXT
  'a { font-family:tahoma,helvetica,sans-serif;text-'
  'decoration:underline;color:#336699; }'
  'a:visited { color:#001166; }'
  'a:hover { text-decoration:none; }'
  '</style>'
  '</head>'
  '<body>'
  '<table cellpadding="0" cellspacing="0" border="0" width="100%">'
  '<tr>'
  '<td>'

*'<h1>Error Message - User Authentication Error</h1><br>'
  '<h1>'
  'Abmeldung'(b01)
  '</h1><br>'

*'<h2>What happened?</h2>'
  '<h2>'
  'Was ist passiert ?'(a02)
  '</h2>'

  '<p>'
*'You have entered the URL  '
  reason

*'. However, a valid user ID and password is required.'

  '</p>'
  '</td>'
  '</tr>'
  '<tr>'
  '<td>&nbsp;</td>'
  '</tr>'
  '<tr>'
  '<td class="emphasize">'

*'<strong>Note</strong>'
  '<strong>'
  'Hinweis'(h01)
  '</strong>'
  '<br>'
*'If you have maintained your e-mail address in the SAP'
*'Service Marketplace you can  use this as an alternative '
*'to your user ID.'
  note
*
*'</td>'
*'</tr>'
*'<tr>'
*'<td>'
*'<p>'
*"recommendation
*'</ul>'
**
  '</td></tr><tr></tr><tr><td><p></ul>'
  '<br/><p class="note">'
* errorcode
  '</p><p>'
  ' HTTP 200 - OK'                                          "#EC NOTEXT
  '<br><p>'
  ' Ihr SAP Internet Communication Framework Team'(i01)
  '</p>'
  '</td>'
  '</tr>'
  '</table>'
  '</body>'
  '</html>'
  INTO content.

* in unicode system conversion to utf-8
  IF cl_abap_char_utilities=>charsize = 1.
    CALL FUNCTION 'SCP_GET_CODEPAGE_NUMBER'
      EXPORTING
        database_also       = 'X'
      IMPORTING
        start_appl_codepage = start_appl_codepage
      EXCEPTIONS
        internal_error      = 1
        OTHERS              = 2.

    IF sy-subrc = 0 AND start_appl_codepage IS NOT INITIAL.
      CALL FUNCTION 'SCP_GET_HTTP_NAME'
        EXPORTING
          sap_codepage     = start_appl_codepage
        IMPORTING
          name             = http_codepage_name
        EXCEPTIONS
          name_unknown     = 1
          invalid_codepage = 2
          OTHERS           = 3.
      IF sy-subrc <> 0.
        CLEAR http_codepage_name.
      ENDIF.
    ENDIF.
  ENDIF.

  IF http_codepage_name IS INITIAL.
    DATA: xdata TYPE xstring.
    DATA: cvto_utf8 TYPE REF TO cl_abap_conv_out_ce.

    CALL METHOD response->set_header_field
      EXPORTING
        name  = 'content-type'                              "#EC NOTEXT
        value = 'text/html; charset=utf-8'.                 "#EC NOTEXT

    cvto_utf8   = cl_abap_conv_out_ce=>create( encoding = 'UTF-8' ).
    cvto_utf8->write( data = content ).

    xdata = cvto_utf8->get_buffer( ).
    response->set_data( data = xdata ).
  ELSE.
    CONCATENATE 'text/html; charset='                       "#EC NOTEXT
      http_codepage_name INTO http_codepage_name.
    CALL METHOD response->set_header_field
      EXPORTING
        name  = 'content-type'                              "#EC NOTEXT
        value = http_codepage_name.
    response->set_cdata( data = content ).
  ENDIF.

ENDMETHOD.


METHOD default_not_found_page .
  DATA: uri           TYPE string.
  DATA: note          TYPE string.
  DATA: l_note        TYPE string.
  DATA: l_vhost       TYPE string.
*data: iso_langu(2)  type c.
  DATA: recommendation TYPE string.
  DATA: l_reason       TYPE string.
  DATA: content        TYPE string.
  DATA: start_appl_codepage TYPE cpcodepage,
        http_codepage_name  TYPE string.
  DATA: l_http_code         TYPE string.
  DATA: l_status_code       TYPE i.
  DATA: l_status_value      TYPE string.
  DATA: errorcode           TYPE string.
  DATA: l_rfcsi             TYPE rfcsi.
  DATA: l_rfcdest           TYPE rfcdest.
  DATA: l_dummy             TYPE string.
  DATA: l_detailed_errors(5) TYPE c.

  DATA: lv_rid  TYPE epp_root_context_id,
        lv_cid  TYPE epp_connection_id,
        lv_ccnt TYPE epp_connection_counter,
        lv_tid  TYPE epp_transaction_id.


*
* security response 2992810/2005: restricted system information
*
  CALL 'C_SAPGPARAM'
       ID    'NAME'
       FIELD 'is/HTTP/show_detailed_errors'
       ID    'VALUE'
       FIELD l_detailed_errors.                           "#EC CI_CCALL

  IF l_detailed_errors = 'false' OR
     l_detailed_errors ='FALSE'  OR
     l_detailed_errors = '0'.
    l_reason = text-r01.
    REPLACE '&1' WITH '' INTO l_reason.

    recommendation = text-r04.
    CONCATENATE 'HTTP' status_code '-' status_reason        "#EC NOTEXT
              INTO l_http_code SEPARATED BY space.

    note = text-r02.
    REPLACE '&1' WITH '' INTO note.
    CONCATENATE '<b>' status_code '</b>' INTO l_status_value.
    REPLACE '&2' WITH l_status_value  INTO note.
    CONCATENATE '<b>' status_reason '</b>' INTO l_status_value.
    REPLACE '&3' WITH l_status_value INTO note.


  ELSE.
*   set language 'D'.
    CALL FUNCTION 'RFC_SYSTEM_INFO'
      IMPORTING
        rfcsi_export = l_rfcsi.
    l_rfcdest = l_rfcsi-rfcdest.

*   uri = request->get_header_field( '~path_translated' ).
    uri = create_abs_url( ).

*
*   XSS- Attacken verhindern (z. B. /sap/bc/<script><ok></script>/echo)
*
* Use new ABAP XSS Escaping library (see sap note 1644634)
*    uri = cl_http_utility=>escape_html( uri ).
    uri = escape( val    = uri
                  format = cl_abap_format=>e_xss_ml ).

*   -- reason
*   Der Aufruf der URL &1 wurde aufgrund nicht verfügbarer
*   Service abgebrochen.
    l_reason = text-r01.
    REPLACE '&1' WITH uri INTO l_reason.

*   -- system
*   Abbruch trat auf dem System &1 und mit Fehlercode &2
*   und dem Grund &3 auf.
    note = text-r02.
    REPLACE '&1' WITH sy-sysid INTO note.
    CONCATENATE '<b>' status_code '</b>' INTO l_status_value.
    REPLACE '&2' WITH l_status_value  INTO note.
    CONCATENATE '<b>' status_reason '</b>' INTO l_status_value.
    REPLACE '&3' WITH l_status_value INTO note.
*   Der ausgewählte virtualle Host war &1.

*    shift l_vhost RIGHT DELETING TRAILING SPACE.
    l_note = text-r03.
    l_vhost = c_virtual_host.
    REPLACE '&1' WITH l_vhost INTO l_note.

    l_dummy = request->get_header_field( 'sap-icfreason' ). "#EC NOTEXT
    IF l_dummy IS INITIAL.
      CONCATENATE '<ul><li>' note '</li><li>'
                l_note '</li></ul>' INTO note
                SEPARATED BY space.
    ELSE.
      CONCATENATE '<ul><li>' note
                  '</li><li>' l_dummy
                  '</li><li>' l_note
                  '</li></ul>' INTO note
                SEPARATED BY space.
    ENDIF.

    CONCATENATE 'HTTP' status_code '-' status_reason        "#EC NOTEXT
              INTO l_http_code SEPARATED BY space.

*   -- recommendation
*   Überprüfen Sie die Angabe über den Mandanten, Benutzer und das
*   Passwort auf Tippfehler.
    recommendation = text-r04.
    uri = request->get_header_field( '~path_translated' ).
*
*   XSS- Attacken verhindern (z. B. /sap/bc/<script><ok></script>/echo)
*
*    uri = cl_http_utility=>escape_html( uri ).
    uri = escape( val    = uri
                  format = cl_abap_format=>e_xss_ml ).

    l_dummy = text-r05.
    REPLACE '&1' WITH uri INTO l_dummy.

    CONCATENATE '<ul><li>' recommendation
*   Falls es sich um eine gültige URL handelt, überprüfen Sie bitte,
*   ob der Service &1 in der Transaction SICF aktiv ist.
      '</li><li>' l_dummy '</li>'
*   Falls Sie noch über keine Benutzerkennung verfügen,
*   so wenden Sie sich an Ihren Systemadministrator.
      '</li><li>' text-r10 '</li></ul>'
        INTO recommendation SEPARATED BY space.

*     -- errorcode
    errorcode = 'Fehlercode:'(f01).
    IF ssl_active = co_enabled.
      CONCATENATE errorcode 'ICF-NF-https' INTO errorcode   "#EC NOTEXT
        SEPARATED BY space.
    ELSE.
      CONCATENATE errorcode 'ICF-NF-http' INTO errorcode    "#EC NOTEXT
        SEPARATED BY space.
    ENDIF.
    CONDENSE l_vhost.
    errorcode = |{ errorcode }-i{ l_rfcdest }-v{ l_vhost }-d{ sy-datum }-t{ sy-uzeit }-s{ status_code }-r{ status_reason }|.

*    CONCATENATE errorcode "'-c:' sy-mandt
*                          "'-u:' sy-uname
*                          "'-l:' sy-langu
*                          '-i:' l_rfcdest
*                          '-v:' l_vhost
*                          '-d:' sy-datum
*                          '-t:' sy-uzeit
*                          '-s:' status_code
*                          '-r:' status_reason
*                          INTO errorcode.

    CALL METHOD get_epp_context_ids
      IMPORTING
        root_context_id    = lv_rid
        connection_id      = lv_cid
        connection_counter = lv_ccnt
        transaction_id     = lv_tid
      EXCEPTIONS
        epp_error          = 1.


    IF sy-subrc = 0.
      errorcode = |{ errorcode }{ co_error_page_epp_context_id }{ lv_rid }_{ lv_cid }_{ lv_ccnt }|.
* And TransactionId
      errorcode = |{ errorcode }{ co_error_page_epp_tid }{ lv_tid }|.

    ENDIF.
*    CONDENSE errorcode NO-GAPS.
  ENDIF.

  CONCATENATE
    '<!DOCTYPE html PUBLIC '                                "#EC NOTEXT
            '"-//W3C//DTD HTML 4.01'                        "#EC NOTEXT
            'Transitional//EN'                              "#EC NOTEXT
            '">'
  '<html>'
    '<head>'
      '<title>Logon Error Message</title>'
      '<META http-equiv="Content-Type" content="text/html; '
      'charset=UTF-8">'
      '<style type="text/css">'
        'body { font-family:tahoma,helvetica,sans-serif;color:#'
  '333333;background-color:#FFFFFF; }'
  'td { font-family:tahoma,helvetica,sans-serif;font-size:70%;color:'
  '#333333; }'
  'h1 { font-family:tahoma,helvetica,sans-serif;font-size:160%;font-'
  'weight:bold;margin-top:15px;margin-bottom:3px;color:#003366; }'
  'h2 { font-family:verdana,helvetica,sans-serif;font-'
  'size:120%;font-style:italic;font-weight:bold;margin-top:6px;margin-'
  'bottom:6px;color:#999900; }'
  'p { font-family:tahoma,helvetica,sans-serif;color:#333333;margin-'
  'top:4px;margin-bottom:4px; }'
  'ul { font-family:tahoma,helvetica,sans-serif;color:#333333;list-'
  'style-type:square;margin-top:8px;margin-bottom:8px; }'
  'li { font-family:tahoma,helvetica,sans-serif;color:#'
  '33333;margin-top:4px; }'
  '.emphasize { color:#333333;background-'
  'color:#C8E3FF;padding:5px;}'
  '.note { color:#CC6600; }'                                "#EC NOTEXT
  'a { font-family:tahoma,helvetica,sans-serif;text-'
  'decoration:underline;color:#336699; }'
  'a:visited { color:#001166; }'
  'a:hover { text-decoration:none; }'
  '</style>'
  '</head>'
  '<body>'
  '<table cellpadding="0" cellspacing="0" border="0" width="100%">'
  '<tr>'
  '<td>'

* '<h1>Error Message - User Authentication Error</h1><br>'
  '<h1>'
  'Service nicht erreichbar'(n01)
  '</h1><br>'

* '<h2>What happened?</h2>'
  '<h2>'
  'Was ist passiert ?'(a02)
  '</h2>'

  '<p>'
* 'You have entered the URL  '
  l_reason
  '</p>'
  '</td>'
  '</tr>'
  '<tr>'
  '<td>&nbsp;</td>'
  '</tr>'
  '<tr>'
  '<td class="emphasize">'

* '<strong>Note</strong>'
  '<strong>'
  'Hinweis'(h01)
  '</strong>'

  '<br>'
* 'If you have maintained your e-mail address in the SAP'
* 'Service Marketplace you can  use this as an alternative '
* 'to your user ID.'
  note

  '</td>'
  '</tr>'
  '<tr>'
  '<td>&nbsp;</td>'
  '</tr>'
  '<tr>'
  '<td>'
  '<p>'
* ' &nbsp;'
* '</p>'
* *'<h2>What can you do?</h2>'
  '<h2>'
  'Was können Sie tun ?'(a05)
  '</h2>'
  recommendation
  '</ul>'

  '<br/><p class="note">'
    errorcode
  '</p>'
  '<br/><p>'
  l_http_code
  '<br><p>'
  ' Ihr SAP Internet Communication Framework Team'(i01)
  '</p>'
  '</td>'
  '</tr>'
  '</table>'
  '</body>'
  '</html>'
  INTO content.

  l_status_code = status_code.
  response->set_status( code   = l_status_code
                        reason = status_reason ).


* in unicode system conversion to utf-8
  IF cl_abap_char_utilities=>charsize = 1.
    CALL FUNCTION 'SCP_GET_CODEPAGE_NUMBER'
      EXPORTING
        database_also       = 'X'
      IMPORTING
        start_appl_codepage = start_appl_codepage
      EXCEPTIONS
        internal_error      = 1
        OTHERS              = 2.

    IF sy-subrc = 0 AND start_appl_codepage IS NOT INITIAL.
      CALL FUNCTION 'SCP_GET_HTTP_NAME'
        EXPORTING
          sap_codepage     = start_appl_codepage
        IMPORTING
          name             = http_codepage_name
        EXCEPTIONS
          name_unknown     = 1
          invalid_codepage = 2
          OTHERS           = 3.
      IF sy-subrc <> 0.
        CLEAR http_codepage_name.
      ENDIF.
    ENDIF.
  ENDIF.

  IF http_codepage_name IS INITIAL.
    DATA: xdata TYPE xstring.
    DATA: cvto_utf8 TYPE REF TO cl_abap_conv_out_ce.

    CALL METHOD response->set_header_field
      EXPORTING
        name  = 'content-type'                              "#EC NOTEXT
        value = 'text/html; charset=utf-8'.                 "#EC NOTEXT

    cvto_utf8   = cl_abap_conv_out_ce=>create( encoding = 'UTF-8' ).
    cvto_utf8->write( data = content ).

    xdata = cvto_utf8->get_buffer( ).
    response->set_data( data = xdata ).
  ELSE.
    CONCATENATE 'text/html; charset='                       "#EC NOTEXT
      http_codepage_name INTO http_codepage_name.
    CALL METHOD response->set_header_field
      EXPORTING
        name  = 'content-type'                              "#EC NOTEXT
        value = http_codepage_name.
    response->set_cdata( data = content ).
  ENDIF.

ENDMETHOD.


method DELETE_SSO_COOKIE_AT_CLIENT.
endmethod.


METHOD execute_request.
* -- taskhandler statistic macros
*  include: perfinterval.

  DATA: serv_wa   TYPE  icfhandlst,
        handlerwa TYPE  icfhandler,
        dummy_str TYPE string.
  DATA: memory_hdl_wa TYPE ihttp_rmemory_icfhandlst.
  DATA: memory_applied_for_service TYPE c.

  DATA: request_done  TYPE i VALUE 0.
*  data: ext_error     type ref to cl_http_ext_http_error.
  DATA: server_obj    TYPE REF TO cl_http_server.
  DATA: path_trans   TYPE string,
*        path_info     type string,
*        service_info  type string,
        curr_reg     TYPE ihttp_ext_instance,
        ext_inst     TYPE ihttp_ext_instance,
        ext_inst_idx TYPE sy-tabix VALUE -1,
        extension    TYPE REF TO if_http_extension.
  DATA: header_field  TYPE ihttpnvp.
  DATA: icfrec_field  TYPE ihttp_recorder_field.
  DATA: icfrec_index  TYPE sytabix.
  DATA: stime TYPE i,
        etime TYPE i.

  DATA: tag TYPE char64.
  DATA: l_exception TYPE REF TO cx_icf_do_not_catch.
  DATA: dummy            TYPE string.

  DATA: len   TYPE i.
  DATA: subrc TYPE sysubrc.

  DATA: exp_flag    TYPE i,
        exp_aliguid TYPE icfaliguid,
        exp_rest    TYPE string,
        index       TYPE sy-tabix,
        readindex   TYPE sy-tabix,
        exp_wa      TYPE icfhandlst.
  DATA: sytabix(4) TYPE c.
  DATA: its_attributes_already_set TYPE i.

  DATA: l_gui_script_name TYPE string.
  DATA: l_gui_script_name_expanded TYPE string.

  DATA: l_auth_scope_check_passed TYPE abap_bool VALUE abap_false.
  DATA: lr_oauth2_consumer TYPE REF TO if_oauth2_consumer.

  server_obj ?= server.

*****
  DATA: l_req_uri              TYPE string,
        l_service_path         TYPE string,
        l_first_url_path       TYPE string, "for url rewritting case
        l_pre                  TYPE string,
        l_post                 TYPE string,
        l_service_path_save    TYPE string,
        l_exp_script_name_save TYPE string,
        l_len                  TYPE i.

  DATA: l_exp_script_name_lower_case TYPE string,
        l_string_lower_case          TYPE string,
        l_string_compare             TYPE string,
        l_strlen                     TYPE i.

  l_req_uri = server->request->get_header_field(
          if_http_header_fields_sap=>request_uri ).

* Remove URL part
  CALL FUNCTION 'SWLWP_URI_PARSE'
    EXPORTING
      uri      = l_req_uri
    IMPORTING
      abs_path = l_service_path "request uri without url-part & query parameters
    EXCEPTIONS
      OTHERS   = 0.

****

  pf_m_open c_statistic_state 'A:Path Translated'.          "#EC NOTEXT
  path_trans = server->request->get_header_field(
                      if_http_header_fields_sap=>path_translated ).
  pf_m_close c_statistic_state 'A:Path Translated'.         "#EC NOTEXT

  IF path_trans IS INITIAL.
    path_trans = '/'.
  ENDIF.
*  orig_url = path_trans.

*  call method server_obj->debugging( ).

* -- case 1
* is this a request to a virtual host with alias to a service ?
* e. g. path_trans = '/' or '/default.htm'
* in case of path_trans = '/default.htm' is urlsuffix = default.htm.
* --
*  if not urlsuffix is initial.
*    concatenate '/' urlsuffix into dummy.
*  endif.
*  if path_trans = '/' or
*     path_trans = dummy.
** this request is an alias an hence this refernces to an expanded URL
*    exp_flag = 1.
** icf_redir attributes contains "/default_host/<internal_service>"
*    read table servtbl index 1 into serv_wa
*                        transporting service-orig_name
*                                     service-icfaltnme_orig
*                                     service-icfaltnme
*                                     service-icfnodguid
*                                     service-icf_redir.
** elimination of "/default_host"
*    split serv_wa-service-icf_redir+1(*)
*                                 at '/' into dummy exp_rest.
** expanded string contains the referenced service path
*    concatenate '/' exp_rest into exp_rest.
*
** set orig_script_name properly
*    orig_script_name = '/'.
*  endif. "end of case 1

*-- case 2
* is this a request to external alias ?
* e. g. path_trans = '/host1 with reference to '/sap/bc/echo'
* --
*  if firstalias-icfalias is not initial.
** this request is an alias and hence this refernces to an expanded URL
*    exp_flag = 1.
*    split firstalias-icf_redir+1(*) at '/' into dummy exp_rest.
*    concatenate '/' exp_rest into exp_rest.
** save the original referenced service string
*    orig_script_name = firstalias-icfalias.
*  endif. "end of case 2
*

* init of ~remote_addr
*  if not c_caller_ip is initial.
*     dummy_str = c_caller_ip.
*     call method server->request->set_header_field(
*          name  = if_http_header_fields_sap=>remote_addr
*          value = dummy_str ).
*  endif.
*  clear dummy_str.
*
** init of ~uri_scheme_expanded
*  if ssl_active = co_enabled.
*   server->request->set_header_field(
*                 name  = if_http_header_fields_sap=>uri_scheme_expanded
*                 value = 'https' ).
*  else.
*   server->request->set_header_field(
*                 name  = if_http_header_fields_sap=>uri_scheme_expanded
*                 value = 'http' ).
*  endif.

* init of ~sap_accessibility
  IF runtime_memory-actlogin-accessibility  = 'Y'.
    server->request->set_header_field(
                name  = if_http_header_fields_sap=>accessibility
                value = '1' ).
  ELSEIF runtime_memory-actlogin-accessibility  = 'N'.
    server->request->set_header_field(
                name  = if_http_header_fields_sap=>accessibility
                value = '0' ).
  ENDIF.

* set URLSUFFIX for frameworks, e.g. WebDynpro, BSP, APC to determine, whether the service
* in the SICF tree is available or not
  IF urlsuffix IS NOT INITIAL.
    DATA: lv_urlsuffix TYPE string.
    CONCATENATE '/' urlsuffix INTO lv_urlsuffix.
    server->request->set_header_field(
              name  = if_http_header_fields_sap=>unidentified_path_segments
              value = lv_urlsuffix ).
  ELSE.
    server->request->set_header_field(
      name  = if_http_header_fields_sap=>unidentified_path_segments
      value = lv_urlsuffix ).
  ENDIF.

*
* inserting of internal header fields in ICF recorder
*
  IF NOT server_obj->m_icfrecorder IS INITIAL AND
     c_enable_recording >= ihttp_record_response_status.
    icfrec_index = icfrec_index + 1.
    icfrec_field-range = ihttp_recorder_field_range_exe.
    icfrec_field-index = icfrec_index.
    icfrec_field-name  = '~remote_addr'.
    icfrec_field-value = c_caller_ip.
    APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
    IF ssl_active = co_enabled.
      icfrec_field-name  = '~uri_scheme_expanded'.
      icfrec_field-value = 'https'.
      APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
    ELSE.
      icfrec_field-name  = '~uri_scheme_expanded'.
      icfrec_field-value = 'http'.
      APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
    ENDIF.
  ENDIF.

  pf_m_open c_statistic_state 'A:Service List'.             "#EC NOTEXT
* evaluate debugging/tracing attributes and executing handler

* set virtual host number for application
  dummy = c_virtual_host.
  server->request->set_header_field( name  = if_http_header_fields_sap=>virtual_host_number
                                     value = dummy ).

  LOOP AT servtbl INTO serv_wa.
* use alternative long icf name if available
    IF serv_wa-service-icfaltnme IS INITIAL.
      tag = serv_wa-service-icf_name.
    ELSE.
      tag = serv_wa-service-icfaltnme.
    ENDIF.

    CONCATENATE 'A:Options: ' tag INTO tag.                 "#EC NOTEXT
    pf_m_open c_statistic_state tag.


* -- timeout/auto logout active ?
    IF NOT serv_wa-service-icf_time IS INITIAL.
      timeout = serv_wa-service-icf_time.
      server->session_timeout = serv_wa-service-icf_time.
    ENDIF.

    IF NOT serv_wa-service-icf_auth IS INITIAL.
* authorization time for statistic
      stime = server_obj->m_timer->get_runtime( ).

      CALL METHOD server_obj->authorization
        EXPORTING
          service   = serv_wa-service
          url       = path_trans "orig_script_name
          path_info = '/'. "orig_path_info.

* authorization time for statistic
      etime = server_obj->m_timer->get_runtime( ).
      server_obj->m_authorization_time =
               server_obj->m_authorization_time + ( etime - stime ).
    ENDIF.

    pf_m_close c_statistic_state tag.
    IF  serv_wa-handlertbl IS INITIAL.
* -- save relevant service entries for shared buffer
      IF c_runtime_memory_disabled     IS INITIAL AND
         ( NOT serv_wa-service-icf_time IS INITIAL OR
           NOT serv_wa-service-icf_auth IS INITIAL ).
        CLEAR memory_hdl_wa.
        memory_hdl_wa-icfhandlst = serv_wa.
* orig_script_name
        memory_hdl_wa-script_name =
                         serv_wa-pathfields-orig_script_name.
        APPEND memory_hdl_wa TO runtime_memory-servtbl.
      ENDIF.
* -- without handler continue processing service list
      CONTINUE.
    ENDIF.

* -- append serve_wa once per serivce into runtime_memory
    CLEAR memory_applied_for_service.
    pf_m_open c_statistic_state 'A:Handler List'.           "#EC NOTEXT
    LOOP AT serv_wa-handlertbl INTO handlerwa.
      curr_reg-extension = handlerwa-icfhandler.

*   request completely handled?
      IF NOT request_done IS INITIAL.
        EXIT.                          "stop searching for a handler
      ENDIF.

* -- construct exp_path_translated
*    concatenate exp_script_name exp_path_info
*                             into exp_path_translated.

*   now we know the extension, so set script_name and path_info
*   accordingly
*
      pf_m_open c_statistic_state 'A:Set Header'.           "#EC NOTEXT

      IF l_service_path NS '(' AND l_service_path NS ')' . "pattern for url rewritting (first round trip)
        IF l_service_path CS serv_wa-pathfields-orig_script_name.
* No alternative Alias name (e.g. /myecho) has been used
          IF serv_wa-pathfields-orig_script_name NE l_service_path.
            FIND FIRST OCCURRENCE OF serv_wa-pathfields-orig_script_name IN l_service_path
                     IN CHARACTER MODE IGNORING CASE
                     MATCH LENGTH l_len.
            IF sy-subrc EQ 0.
              serv_wa-pathfields-orig_script_name = l_service_path(l_len).
            ENDIF.
          ENDIF.
        ELSE.
* alternative Alias name (e.g. /myecho) has been used
          FIND FIRST OCCURRENCE OF serv_wa-pathfields-orig_script_name IN l_service_path
                   IN CHARACTER MODE IGNORING CASE
                   MATCH LENGTH l_len.
          IF sy-subrc EQ 0.
            serv_wa-pathfields-orig_script_name = l_service_path(l_len).
          ENDIF.
        ENDIF.
      ELSE. "pattern for url rewritting (NOT first round trip)
* remove url writting part from url and check the script name
        SPLIT l_service_path AT '(' INTO l_first_url_path l_post. "l_first_url_path includes /sap
        SPLIT l_post AT ')' INTO l_pre l_post.
        CONCATENATE l_first_url_path l_post INTO l_service_path.  "service path without url rewritting
* Now check for URL preserving
        IF l_service_path CS serv_wa-pathfields-orig_script_name.
* No alternative Alias name (e.g. /myecho) has been used
          IF serv_wa-pathfields-orig_script_name NE l_service_path.
            FIND FIRST OCCURRENCE OF serv_wa-pathfields-orig_script_name IN l_service_path
                     IN CHARACTER MODE IGNORING CASE
                     MATCH LENGTH l_len.
            IF sy-subrc EQ 0.
              serv_wa-pathfields-orig_script_name = l_service_path(l_len).
            ENDIF.
          ENDIF.
        ELSE.
* alternative Alias name (e.g. /myecho) has been used
          FIND FIRST OCCURRENCE OF serv_wa-pathfields-orig_script_name IN l_service_path
                   IN CHARACTER MODE IGNORING CASE
                   MATCH LENGTH l_len.
          IF sy-subrc EQ 0.
            serv_wa-pathfields-orig_script_name = l_service_path(l_len).
          ENDIF.
        ENDIF.
      ENDIF.
* orig_script_name
      CALL METHOD server->request->set_header_field(
          name  = '~SCRIPT_NAME'
          value = serv_wa-pathfields-orig_script_name ).
* orig_path_info
      CALL METHOD server->request->set_header_field(
          name  = '~PATH_INFO'
          value = serv_wa-pathfields-orig_path_info ).
**********************
      l_exp_script_name_lower_case = serv_wa-pathfields-exp_script_name.
      TRANSLATE l_exp_script_name_lower_case TO LOWER CASE.

      l_string_lower_case = l_service_path.
      TRANSLATE l_string_lower_case TO LOWER CASE.

      l_strlen = strlen( serv_wa-pathfields-exp_script_name ).
      IF l_service_path CS serv_wa-pathfields-exp_script_name AND
        strlen( l_service_path ) GE l_strlen AND
        l_exp_script_name_lower_case EQ l_string_lower_case(l_strlen).
* No alternative Alias name (/myecho) has been used
        IF serv_wa-pathfields-exp_script_name NE l_service_path.
          FIND FIRST OCCURRENCE OF serv_wa-pathfields-exp_script_name IN l_service_path
                   IN CHARACTER MODE IGNORING CASE
                   MATCH LENGTH l_len.
          IF sy-subrc EQ 0.
            serv_wa-pathfields-exp_script_name = l_service_path(l_len).
          ENDIF.
        ENDIF.
      ELSE.
* alternative Alias name has been used
        IF NOT l_service_path_save IS INITIAL. "several service handler; as of second handler
          IF l_service_path_save(1) NE '/'.
            CONCATENATE '/' l_service_path_save INTO l_service_path_save.
          ENDIF.

          l_exp_script_name_lower_case = serv_wa-pathfields-exp_script_name.
          TRANSLATE l_exp_script_name_lower_case TO LOWER CASE.

          CONCATENATE l_exp_script_name_save l_service_path_save INTO l_string_lower_case.
          TRANSLATE l_string_lower_case TO LOWER CASE.

          IF l_string_lower_case NE l_exp_script_name_lower_case.
            FIND FIRST OCCURRENCE OF l_service_path_save IN l_service_path
                     IN CHARACTER MODE IGNORING CASE
                     MATCH OFFSET l_len.
            IF sy-subrc EQ 0.
              l_len = l_len + 1. "without pedding "/"
              set_path_segments_to_handler(
                EXPORTING
                  icf_name                 = handlerwa-icf_name
                  icfparguid               = handlerwa-icfparguid
                  path_seg_to_pre_handler  = l_exp_script_name_save
                RECEIVING
                  path_seg_to_curr_handler = l_post ).
              CONCATENATE l_exp_script_name_save l_post INTO serv_wa-pathfields-exp_script_name.
            ENDIF.
          ELSE. "service_path is equal to serv_wa-pathfields-exp_script_name, but maybe service_path is case sensitive
* Donot change serv_wa-pathfields-exp_script_name in case they are equal!
            CONCATENATE l_exp_script_name_save l_service_path_save INTO l_string_compare.
            IF serv_wa-pathfields-exp_script_name NE l_string_compare.
              FIND FIRST OCCURRENCE OF l_service_path_save IN l_service_path
                       IN CHARACTER MODE IGNORING CASE
                       MATCH OFFSET l_len.
              IF sy-subrc EQ 0.
                l_len = l_len + 1. "without pedding "/"
                set_path_segments_to_handler(
                  EXPORTING
                    icf_name                 = handlerwa-icf_name
                    icfparguid               = handlerwa-icfparguid
                    path_seg_to_pre_handler  = l_exp_script_name_save
                  RECEIVING
                    path_seg_to_curr_handler = l_post ).
                CONCATENATE l_exp_script_name_save l_post INTO serv_wa-pathfields-exp_script_name.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

* exp_script_name
      CALL METHOD server->request->set_header_field(
          name  = '~SCRIPT_NAME_EXPANDED'
          value = serv_wa-pathfields-exp_script_name ).
      l_exp_script_name_save = serv_wa-pathfields-exp_script_name. "save the info about previous service handler
      l_service_path_save    = serv_wa-pathfields-exp_path_info.

* exp_path_info
      CALL METHOD server->request->set_header_field(
          name  = '~PATH_INFO_EXPANDED'
          value = serv_wa-pathfields-exp_path_info ).
* exp_path_translated
      CONCATENATE serv_wa-pathfields-exp_script_name serv_wa-pathfields-exp_path_info
                  INTO serv_wa-pathfields-exp_path_translated.
      CALL METHOD server->request->set_header_field(
          name  = '~PATH_TRANSLATED_EXPANDED'
          value = serv_wa-pathfields-exp_path_translated ).
* GUI_HEADER_HANDLER_FIELD
      CALL METHOD server->request->set_header_field(
          name  = '~GUI_HEADER_HANDLER_FIELD'
          value = serv_wa-pathfields-exp_script_name ).
* /bg

* -- trace entry for ~PATH_TRANSLATED_EXPANDED
      IF NOT c_sap_trace IS INITIAL.
        ADD 1 TO sytabix.
        CONCATENATE dummy_str sytabix
           '~SCRIPT_NAME:' serv_wa-pathfields-orig_script_name
           '~PATH_INFO:' serv_wa-pathfields-orig_path_info
           '~SCRIPT_NAME_EXPANDED:' serv_wa-pathfields-exp_script_name
           '~PATH_INFO_EXPANDED:' serv_wa-pathfields-exp_path_info
           '~PATH_TRANSLATED_EXPANDED'
                        serv_wa-pathfields-exp_path_translated
           INTO dummy_str SEPARATED BY space.
        server->request->set_header_field( name = 'sap-path-info'
                                   value = dummy_str ).
      ENDIF.

      pf_m_close c_statistic_state  'A:Set Header'.         "#EC NOTEXT

*     next registered extension found; instantiated already?
      READ TABLE http_ext_instances INTO ext_inst
             WITH KEY server_name  = server_obj->m_name
                      url          = serv_wa-pathfields-orig_script_name
                      virtual_host = c_virtual_host
                      extension    = curr_reg-extension.
      subrc = sy-subrc.

*
* inserting of internal header fields in ICF recorder
*
      IF NOT server_obj->m_icfrecorder IS INITIAL AND
         c_enable_recording >= ihttp_record_response_status.
        icfrec_index       = icfrec_index + 1.
        icfrec_field-range = ihttp_recorder_field_range_exe.
        icfrec_field-index = icfrec_index.
        icfrec_field-name  = '~SCRIPT_NAME'.
        icfrec_field-value = serv_wa-pathfields-orig_script_name.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.

        icfrec_field-name  = '~PATH_INFO'.
        icfrec_field-value = serv_wa-pathfields-orig_path_info.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.

        icfrec_field-name  = '~SCRIPT_NAME_EXPANDED'.
        icfrec_field-value = serv_wa-pathfields-exp_script_name.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.

        icfrec_field-name  = '~PATH_INFO_EXPANDED'.
        icfrec_field-value = serv_wa-pathfields-exp_path_info.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.

        icfrec_field-name  = '~PATH_TRANSLATED_EXPANDED'.
        icfrec_field-value = serv_wa-pathfields-exp_path_translated.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.

* register called service handler (extension)
        IF subrc = 0 AND NOT ext_inst-extension IS INITIAL.
          icfrec_field-name  = ihttp_recorder_field_name_ext.
          icfrec_field-value = ext_inst-extension.
        ELSE.
          icfrec_field-name  = ihttp_recorder_field_name_ext.
          icfrec_field-value = curr_reg-extension.
        ENDIF.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
      ENDIF.


*
* exectuion of service handler (extension)
*
      IF subrc = 0 AND NOT ext_inst-extension IS INITIAL.
        ext_inst_idx = sy-tabix.
*       handler already instantiated
        extension = ext_inst-refpointer.
      ELSE.
*       instantiate new handler
        ext_inst_idx = -1.
        TRY.
            pf_m_open c_statistic_state 'A:Create'.         "#EC NOTEXT
            CREATE OBJECT extension TYPE (curr_reg-extension).
            pf_m_close c_statistic_state 'A:Create'.        "#EC NOTEXT
          CATCH cx_root.                                "#EC NO_HANDLER
        ENDTRY.
        IF sy-subrc <> 0.
          request_done = 1.
          EXIT.
        ENDIF.
      ENDIF.

*
*       start of ITS-Plugin only, if the session does not contain any
*       GUI connection (e. g. stateful session)
*       stop external SAPGUI debugging, if it was activated before
*
*       Special logic for ITS: If their more as one Handler in
*       a URL and the first is not the ITS Handler the ITS
*       will be initalized to early. For that we set two new
*       header fields for this situation. ITS checked this fields
*       later
*
      DATA: its_servtbl TYPE icfservtbl.
      its_servtbl[] = servtbl[].

      CALL METHOD cl_http_server=>set_gui_script_hdr_fields
        EXPORTING
          server                   = server_obj
          servtbl                  = its_servtbl
        IMPORTING
          gui_script_name          = l_gui_script_name
          gui_script_name_expanded = l_gui_script_name_expanded
        EXCEPTIONS
          internal_error           = 1
          OTHERS                   = 2.
      IF sy-subrc <> 0.
        MESSAGE e000(sr) WITH
             'Fehler bei der Einstellung zu GUI-Anbindung'(g01).
      ENDIF.


* -- save relevant service entries for shared buffer
      IF c_runtime_memory_disabled IS INITIAL AND
         memory_applied_for_service IS INITIAL.
        CLEAR memory_hdl_wa.
        memory_hdl_wa-icfhandlst  = serv_wa.
        memory_hdl_wa-script_name = serv_wa-pathfields-orig_script_name.
        header_field-name  = '~SCRIPT_NAME'.
        header_field-value = serv_wa-pathfields-orig_script_name.
        APPEND header_field TO memory_hdl_wa-header_fields.

        header_field-name  = '~PATH_INFO'.
        header_field-value = serv_wa-pathfields-orig_path_info.
        APPEND header_field TO memory_hdl_wa-header_fields.

        header_field-name  = '~SCRIPT_NAME_EXPANDED'.
        header_field-value = serv_wa-pathfields-exp_script_name.
        APPEND header_field TO memory_hdl_wa-header_fields.

        header_field-name  = '~PATH_INFO_EXPANDED'.
        header_field-value = serv_wa-pathfields-exp_path_info.
        APPEND header_field TO memory_hdl_wa-header_fields.

        IF l_gui_script_name IS NOT INITIAL.
          header_field-name  = '~GUI_SCRIPT_NAME'.
          header_field-value = l_gui_script_name.
          APPEND header_field TO memory_hdl_wa-header_fields.
        ENDIF.

        IF l_gui_script_name_expanded IS NOT INITIAL.
          header_field-name  = '~GUI_SCRIPT_NAME_EXPANDED'.
          header_field-value = l_gui_script_name_expanded.
          APPEND header_field TO memory_hdl_wa-header_fields.
        ENDIF.

        header_field-name  = '~PATH_TRANSLATED_EXPANDED'.
        header_field-value = serv_wa-pathfields-exp_path_translated.
        APPEND header_field TO memory_hdl_wa-header_fields.
        APPEND memory_hdl_wa TO runtime_memory-servtbl.



* serv_wa already add only once into the runtime_memory
        memory_applied_for_service  = 1.
      ENDIF.

*
*     attach Gui only after logon and with first request and
*     after ~..._expanded fields for itsplugin are set
*
      IF runtime_memory-actlogin-icfguilnk    = 'Y' AND
         server_obj->m_gui_attached           = 0.

        DATA: l_message       TYPE string.
        DATA: l_configuration TYPE string.
        DATA: l_reauth_required TYPE i.
        DATA: l_server_net_obj TYPE REF TO cl_http_server_net.
        DATA: l_root_error TYPE REF TO cx_root.



        IF runtime_memory-actlogin-icf_custstr IS NOT INITIAL.
          CALL METHOD server_obj->get_service_extension
            EXPORTING
              kind                    = ihttp_icfservice_extension_its
            IMPORTING
              configuration           = l_configuration
            EXCEPTIONS
              kind_is_not_supported   = 1
              error_during_processing = 2
              OTHERS                  = 3.
          IF sy-subrc <> 0.
            MESSAGE e000(sr) WITH
               'Fehler bei der Einstellung zu GUI-Anbindung'(g01).
          ENDIF.
        ENDIF.
        pf_m_open c_statistic_state 'A:Attach Gui'.         "#EC NOTEXT
*
* Check whether according the system settings a reathentication in case of stateful communication (ITS)
* services is necessary (0 = nein, 1 = classic reauth (SSO check), 2 = security session
*
        IF server_obj->m_server_type = co_servertype_net.
          TRY.
              l_server_net_obj ?= server_obj.
              l_reauth_required = l_server_net_obj->reauthentication_required( service = runtime_memory-actlogin ).

            CATCH cx_root INTO l_root_error.
              l_message = l_root_error->get_text( ).
              MESSAGE e000(sr) WITH l_message.
          ENDTRY.
        ENDIF.

        CALL FUNCTION 'ICF_ATTACH_ITS_PLUGIN'
          EXPORTING
            export_urlsessionid           = 'X'
            configuration                 = l_configuration
            reauth_required               = l_reauth_required
          EXCEPTIONS
            icf_no_plugin_session         = 1
            icf_no_message_object         = 2
            icf_its_session_failed        = 3
            icf_plugin_status_failed      = 4
            icf_url_session_id_failed     = 5
            icf_its_plugin_not_supported  = 6
            icf_diag_session_failed       = 7
            icf_its_plugin_already_active = 8
            icf_no_dialog_user            = 9
            OTHERS                        = 100.
        subrc = sy-subrc.
        CASE subrc.
          WHEN 0 OR 8. "o.k. or icf_its_plugin_already_active
            "O.K.
          WHEN 1.
            l_message = 'ICF_NO_PLUGIN_SESSION'.
          WHEN 2.
            l_message = 'ICF_NO_MESSAGE_OBJECT'.
          WHEN 3.
            l_message = 'ICF_ITS_SESSION_FAILED'.
          WHEN 4.
            l_message = 'ICF_SET_PLUGIN_STATUS_FAILED'.
          WHEN 5.
            l_message = 'ICF_URL_SESSION_ID_FAILED'.
          WHEN 6.
            l_message = 'ICF_ITS_PLUGIN_NOT_SUPPORTED'.
          WHEN 7.
            l_message = 'ICF_DIAG_SESSION_FAILED'.
          WHEN 9.
            l_message = 'ICF_NO_DIALOG_USER'.
          WHEN OTHERS.
            l_message = 'FAILED ?'.
        ENDCASE.
        IF subrc <> 0 AND
           subrc <> 8.
          IF subrc = 9.
*       Bitte mit einem Dialogbenutzer anmelden
            MESSAGE e156(00).
          ELSE.
            MESSAGE e058(shttp) WITH l_message.
          ENDIF.
        ENDIF.

*     restart of debugging after ITS GUI attachment
        IF server_obj->c_debugid IS NOT INITIAL.
          CALL METHOD server_obj->debugging( force = 1 ).
        ENDIF.
*     avoid multiple execution of attach gui during first request
        server_obj->m_gui_attached = 1.
        pf_m_close c_statistic_state 'A:Attach Gui'.        "#EC NOTEXT
      ENDIF.

*
* setting of GUI response related atrributes in kernel,
* e. g. SSO cookie, compression and session timeout
*
      IF its_attributes_already_set  = 0       AND
         server_obj->m_gui_attached  = 1       AND
         ( server_obj->session_timeout IS NOT INITIAL OR
           server_obj->m_mysapsso2_created    = 2     OR
           runtime_memory-actlogin-compr_flag = 'Y'   OR
           server_obj->m_security_session_cookie IS NOT INITIAL ).
        DATA: l_session_timeout TYPE i.
        DATA: l_compression     TYPE i.
        DATA: l_sso_cookie      TYPE string.

        l_session_timeout = server_obj->session_timeout.

* value -1 for kernel as indicator for no compression setting
        l_compression = -1.

* is compression option set and this can be supported by SAP Web AS
        IF runtime_memory-actlogin-compr_flag = 'Y'.
          CALL METHOD server_obj->check_compression
            EXCEPTIONS
              compression_not_possible = 1.
          IF sy-subrc = 0.
            l_compression = co_compress_based_on_mime_type.
          ENDIF.
        ENDIF.

*
* mysapsso2 is created and should be set
*
        IF server_obj->m_sso_cookie IS NOT INITIAL AND
           server_obj->m_mysapsso2_created = 2.
          l_sso_cookie = server_obj->m_sso_cookie.
        ENDIF.

* set these attributes for ITS reponse and related session
        CALL 'ICF_DISPATCH' ID 'HTTP'  FIELD 'I'
          ID 'SSOCookie'       FIELD l_sso_cookie
          ID 'Compression'     FIELD l_compression
          ID 'SessionTimeout'  FIELD l_session_timeout
          ID 'SecSessionCookie' FIELD server_obj->m_security_session_cookie.

* release sso data
        FREE l_sso_cookie.
      ENDIF.
* evaluation of GUI options only once per request
      its_attributes_already_set = 1.

* -- cashing of ICF environment into shared buffer for ITS services
      IF server_obj->m_runtime_memory_id IS NOT INITIAL       AND
         cl_http_server=>c_runtime_memory_disabled IS INITIAL AND
         runtime_memory-actlogin-icfguilnk   = 'Y'            AND
         curr_reg-extension                  = 'CL_HTTP_EXT_ITS'.
        pf_m_open c_statistic_state
             'A:Export ITS to Shared Buffer'.               "#EC NOTEXT
        EXPORT memory = runtime_memory
               TO SHARED BUFFER icfmemory(ic)               "#EC *
               ID server_obj->m_runtime_memory_id.
        pf_m_close c_statistic_state
             'A:Export ITS to Shared Buffer'.               "#EC NOTEXT
      ENDIF.

* -- OAuth Scope Check
      IF server_obj->authentication_provider = authprovider_oauth AND
         l_auth_scope_check_passed = abap_false.
        IF curr_reg-extension <> cl_oauth2_s_resource_server=>get_handler_name( ).
*         handler is not OAuth2 whitelisted - prevent execution (handle_request)
          CONTINUE.
        ELSE.
          DATA: lx_root             TYPE REF TO cx_root,
                lx_oauth2_exception TYPE REF TO cx_oauth2_exception.

          TRY.
              lr_oauth2_consumer ?= extension.
            CATCH cx_root INTO lx_root.
              TRY.
                  cx_oauth2_exception=>create_and_raise( EXPORTING i_previous  = lx_root
                                                                   i_trace_msg = | White-listed ICF handler { curr_reg-extension } does not implement OAuth2 Consumer Interface (IF_OAUTH2_CONSUMER). |
                                                                   i_textid    = cx_oauth2_exception=>cx_oauth2_consumer_int_missing ).
                CATCH cx_oauth2_exception INTO lx_oauth2_exception.
                  cl_oauth2_s_resource_server=>render_error_response( lx_oauth2_exception ).
                  RETURN.
              ENDTRY.
          ENDTRY.

          TRY.
              l_auth_scope_check_passed = cl_oauth2_s_resource_server=>check_scope( lr_oauth2_consumer ).
            CATCH cx_root INTO lx_root.
              l_auth_scope_check_passed = abap_false.
          ENDTRY.
          IF l_auth_scope_check_passed = abap_false.
            cl_oauth2_s_resource_server=>render_error_response( ).
            RETURN.
          ENDIF.
        ENDIF.
      ENDIF.

* -- server statistic: execution time of handler
      stime = server_obj->m_timer->get_runtime( ).

      pf_m_open c_statistic_state 'A:Handle Request'.       "#EC NOTEXT
      TRY.
* -- for send_page method, check whether page was available
          CLEAR: server_obj->m_connection_error, send_page_rc.
          CALL METHOD extension->handle_request( server = server ).

        CATCH cx_icf_do_not_catch INTO l_exception.
* -- release context
          stateful = if_http_server=>co_disabled.
* -- adjust the transactional logic
          flow_rc = extension->flow_rc.
* -- is during processing of send_page error occured ?
          server_obj->m_connection_error =
                      l_exception->m_connection_error.
          send_page_rc = 1.
          pf_m_close c_statistic_state 'A:Handle Request'.  "#EC NOTEXT
          RETURN.
      ENDTRY.
      pf_m_close c_statistic_state 'A:Handle Request'.      "#EC NOTEXT

* -- server statistic: execution time of handler
      etime = server_obj->m_timer->get_runtime( ).
      server_obj->m_exe_time =
              server_obj->m_exe_time + ( etime - stime ).

*
* evaluation of lifetime_rc: reuse of extension objects based on
*                            virtual host number, script name and the
*                            extension id
*
      IF server->stateful = 1.
        IF ext_inst_idx = -1 AND
           extension->lifetime_rc = if_http_extension=>co_lifetime_keep.
* keep executed extension object for reuse in subsequent requests
          ext_inst-extension    = curr_reg-extension.
          ext_inst-refpointer   = extension.
          ext_inst-url          = serv_wa-pathfields-orig_script_name.
          ext_inst-server_name  = server_obj->m_name.
          ext_inst-virtual_host = c_virtual_host.
          INSERT ext_inst INTO http_ext_instances INDEX 1.
        ELSEIF ext_inst_idx > 0 AND
        extension->lifetime_rc = if_http_extension=>co_lifetime_destroy.
* remove executed extension object
          DELETE http_ext_instances INDEX ext_inst_idx.
        ENDIF.
      ENDIF.

*     continue with additional extensions that might match?
      flow_rc = extension->flow_rc.
      CASE extension->flow_rc.
        WHEN if_http_extension=>co_flow_error.
          request_done = 1.            " done with all extensions
          EXIT.
        WHEN if_http_extension=>co_flow_ok.
          request_done = 1.            " done with all extensions
          EXIT.
        WHEN if_http_extension=>co_flow_ok_others_mand.
          CLEAR extension.
      ENDCASE.

    ENDLOOP.
    pf_m_close c_statistic_state 'A:Handler List'.
  ENDLOOP.
  pf_m_close c_statistic_state 'A:Service List'.

*
* no extension registered for url? -> error response!
*
  IF extension IS INITIAL.
    DATA: l_page_attributes TYPE ihttp_service_page.
    DATA: l_status_code   TYPE string,
          l_status_reason TYPE string.
* Not Found page attributes:
    l_page_attributes-kind    = runtime_memory-actlogin-kindnfpag.
    l_page_attributes-header  =
                      runtime_memory-actlogin-hdrotrnfpag.
    l_page_attributes-body    =
                      runtime_memory-actlogin-bodotrnfpag.
    l_page_attributes-redirect =
                      runtime_memory-actlogin-urlnfpag.
    l_status_code   = '404'.
    l_status_reason = 'No Extension Found'.                 "#EC NOTEXT
*    create object ext_error
*      exporting code = 404 reason = 'No Extension Found'. "#EC NOTEXT
*
*    call method ext_error->handle_request
*      exporting
*        server = server.

* avoid XSS via header field sap-icfreason by setting of SSL/X509 for a
* root service (e.g. /sap or external alias /test)
* and sending the header field sap-icfreason including java script to
* an unknown service behind the root service
* (e.g. /sap/xx or with external alias /test/xx)
    server->request->delete_header_field_secure( name  = 'sap-icfreason' ). "#EC NOTEXT

    server_obj->send_service_not_found(
                         status_code   = l_status_code
                         status_reason = l_status_reason
                         page_attributes = l_page_attributes ).

* do not save errorneous entries in shared buffer
    c_runtime_memory_disabled = 'X'.
    ROLLBACK WORK.
  ENDIF.
ENDMETHOD.


METHOD execute_request_from_memory .
* -- taskhandler statistic macros
*  include: perfinterval.

  DATA: serv_wa    TYPE  ihttp_rmemory_icfhandlst, "icfhandlst,
        handlerwa  TYPE  icfhandler,
        dummy_str  TYPE string.
  DATA: request_done  TYPE i VALUE 0.
*  data: ext_error     type ref to cl_http_ext_http_error.
  DATA: server_obj    TYPE REF TO cl_http_server.
  DATA: curr_reg      TYPE ihttp_ext_instance,
        ext_inst      TYPE ihttp_ext_instance,
        ext_inst_idx  TYPE sy-tabix VALUE -1,
        extension     TYPE REF TO if_http_extension.
  DATA: header_field  TYPE ihttpnvp.

  DATA: stime TYPE i,
        etime TYPE i.

  DATA: tag            TYPE char64.
  DATA: sytabix(4)     TYPE c.
  DATA: l_exception    TYPE REF TO cx_icf_do_not_catch.
  DATA: icfrec_field   TYPE ihttp_recorder_field.
  DATA: icfrec_index   TYPE sytabix.
  DATA: subrc          TYPE sysubrc.
* data: m_gui_attached type i.
  DATA: its_attributes_already_set TYPE i.

  server_obj ?= server.

*  pf_m_open c_statistic_state 'Path Translated'.  "#EC NOTEXT
*  path_trans = server->request->get_header_field( '~PATH_TRANSLATED' ).
*  pf_m_close c_statistic_state 'Path Translated'. "#EC NOTEXT

* init of ~remote_addr
*  if not c_caller_ip is initial.
*     dummy_str = c_caller_ip.
*     call method server->request->set_header_field(
*          name  = if_http_header_fields_sap=>remote_addr
*          value = dummy_str ).
*  endif.

* init of ~uri_scheme_expanded
*  if ssl_active = co_enabled.
*   server->request->set_header_field(
*                 name  = if_http_header_fields_sap=>uri_scheme_expanded
*                 value = 'https' ).
*  else.
*   server->request->set_header_field(
*                 name  = if_http_header_fields_sap=>uri_scheme_expanded
*                 value = 'http' ).
*  endif.

* init of ~sap_accessibility
  IF runtime_memory-actlogin-accessibility  = 'Y'.
    server->request->set_header_field(
                name  = if_http_header_fields_sap=>accessibility
                value = '1' ).
  ELSEIF runtime_memory-actlogin-accessibility  = 'N'.
    server->request->set_header_field(
                name  = if_http_header_fields_sap=>accessibility
                value = '0' ).
  ENDIF.

  CLEAR dummy_str.

*
* inserting of internal header fields in ICF recorder
*
  IF NOT server_obj->m_icfrecorder IS INITIAL AND
     c_enable_recording >= ihttp_record_response_status.
    icfrec_index = icfrec_index + 1.
    icfrec_field-range = ihttp_recorder_field_range_exe.
    icfrec_field-index = icfrec_index.
    icfrec_field-name  = '~remote_addr'.
    icfrec_field-value = c_caller_ip.
    APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
    IF ssl_active = co_enabled.
      icfrec_field-name  = '~uri_scheme_expanded'.
      icfrec_field-value = 'https'.
      APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
    ELSE.
      icfrec_field-name  = '~uri_scheme_expanded'.
      icfrec_field-value = 'http'.
      APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
    ENDIF.
  ENDIF.

* set URLSUFFIX for frameworks, e.g. WebDynpro, BSP, APC to determine, whether the service is
* in the SICF tree available or not
  IF runtime_memory-urlsuffix IS NOT INITIAL.
    DATA: lv_urlsuffix TYPE string.
    CONCATENATE '/' runtime_memory-urlsuffix INTO lv_urlsuffix.
    server->request->set_header_field(
              name  = if_http_header_fields_sap=>unidentified_path_segments
              value = lv_urlsuffix ).
  ELSE.
    server->request->set_header_field(
      name  = if_http_header_fields_sap=>unidentified_path_segments
      value = lv_urlsuffix ).
  ENDIF.

*  call method server_obj->debugging( ).

  pf_m_open c_statistic_state 'A:Service List'.               "#EC NOTEXT
* evaluate debugging/tracing attributes and executing handler

* set virtual host number for application
  dummy_str = c_virtual_host.
  server->request->set_header_field( name  = IF_HTTP_HEADER_FIELDS_SAP=>VIRTUAL_HOST_NUMBER
                                     value = dummy_str ).

  LOOP AT runtime_memory-servtbl INTO serv_wa.

    tag = serv_wa-icfhandlst-service-icf_name.
    CONCATENATE 'A:Options: ' tag INTO tag.                   "#EC NOTEXT
    pf_m_open c_statistic_state tag.

* -- timeout/auto logout active ?
    IF NOT serv_wa-icfhandlst-service-icf_time IS INITIAL.
      timeout = serv_wa-icfhandlst-service-icf_time.
      server->session_timeout = serv_wa-icfhandlst-service-icf_time.
    ENDIF.

    IF NOT serv_wa-icfhandlst-service-icf_auth IS INITIAL.
      READ TABLE serv_wa-header_fields WITH KEY name = '~PATH_INFO'
                                            INTO header_field.
      IF sy-subrc <> 0.
        CLEAR header_field.
      ENDIF.

* authorization time for statistic
      stime = server_obj->m_timer->get_runtime( ).

      CALL METHOD server_obj->authorization
        EXPORTING
          service   = serv_wa-icfhandlst-service
          url       = serv_wa-script_name
          path_info = header_field-value.

* authorization time for statistic
      etime = server_obj->m_timer->get_runtime( ).
      server_obj->m_authorization_time =
               server_obj->m_authorization_time + ( etime - stime ).
    ENDIF.

    pf_m_close c_statistic_state tag.
    IF  serv_wa-icfhandlst-handlertbl IS INITIAL.
* -- without handler continue processing service list
      CONTINUE.
    ENDIF.

    pf_m_open c_statistic_state 'A:Handler List'.             "#EC NOTEXT

    LOOP AT serv_wa-icfhandlst-handlertbl INTO handlerwa.
      curr_reg-extension = handlerwa-icfhandler.

*   request completely handled?
      IF NOT request_done IS INITIAL.
        EXIT.                          "stop searching for a handler
      ENDIF.

*   now we know the extension, so set script_name and path_info
*   accordingly
*
      pf_m_open c_statistic_state 'A:Set Header'.             "#EC NOTEXT

      CALL METHOD server->request->set_header_fields(
        serv_wa-header_fields ).

* -- trace entry for ~PATH_TRANSLATED_EXPANDED
      IF NOT c_sap_trace IS INITIAL.
        ADD 1 TO sytabix.
        CONCATENATE dummy_str sytabix
             INTO dummy_str SEPARATED BY space.
        LOOP AT serv_wa-header_fields INTO header_field.
          CONCATENATE dummy_str
             header_field-name':' header_field-value
             INTO dummy_str SEPARATED BY space.
        ENDLOOP.
        server->request->set_header_field( name = 'sap-path-info'
                                   value = dummy_str ).
      ENDIF.

      pf_m_close c_statistic_state  'A:Set Header'.           "#EC NOTEXT

*     next registered extension found; instantiated already?
      READ TABLE http_ext_instances INTO ext_inst
         WITH KEY server_name  = server_obj->m_name
                  url          = serv_wa-script_name
                  virtual_host = c_virtual_host
                  extension    = curr_reg-extension.
      subrc = sy-subrc.

*
* inserting of internal header fields in ICF recorder
*
      IF NOT server_obj->m_icfrecorder IS INITIAL AND
         c_enable_recording >= ihttp_record_response_status.
        icfrec_index = icfrec_index + 1.
        icfrec_field-range = ihttp_recorder_field_range_exe.
        icfrec_field-index = icfrec_index.
        LOOP AT serv_wa-header_fields INTO header_field.
          icfrec_field-name  = header_field-name.
          icfrec_field-value = header_field-value.
          APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
        ENDLOOP.
* register called service handler (extension)
        IF subrc = 0 AND NOT ext_inst-extension IS INITIAL.
          icfrec_field-name  = ihttp_recorder_field_name_ext.
          icfrec_field-value = ext_inst-extension.
        ELSE.
          icfrec_field-name  = ihttp_recorder_field_name_ext.
          icfrec_field-value = curr_reg-extension.
        ENDIF.
        APPEND icfrec_field TO server_obj->m_icfrecorder_fields.
      ENDIF.

*
* exectuion of service handler (extension)
*
      IF subrc = 0 AND NOT ext_inst-extension IS INITIAL.
        ext_inst_idx = sy-tabix.
*       handler already instantiated
        extension = ext_inst-refpointer.
      ELSE.
*       instantiate new handler
        ext_inst_idx = -1.
        TRY.
            pf_m_open c_statistic_state 'A:Create'.           "#EC NOTEXT
            CREATE OBJECT extension TYPE (curr_reg-extension).
            pf_m_close c_statistic_state 'A:Create'.          "#EC NOTEXT
          CATCH cx_root.                                "#EC NO_HANDLER
        ENDTRY.
        IF sy-subrc <> 0.
          request_done = 1.
          EXIT.
        ENDIF.
      ENDIF.

*
*     attach Gui only after logon and with first request and
*     after ~..._expanded fields for itsplugin are set
*
      IF runtime_memory-actlogin-icfguilnk    = 'Y' AND
         server_obj->m_gui_attached           = 0.

        DATA: l_message       TYPE string.
        DATA: l_configuration TYPE string.
        DATA: l_reauth_required TYPE i.
        DATA: l_server_net_obj TYPE REF TO cl_http_server_net.
        DATA: l_root_error TYPE REF TO cx_root.

        IF runtime_memory-actlogin-icf_custstr IS NOT INITIAL.
          CALL METHOD server_obj->get_service_extension
            EXPORTING
              kind                    = ihttp_icfservice_extension_its
            IMPORTING
              configuration           = l_configuration
            EXCEPTIONS
              kind_is_not_supported   = 1
              error_during_processing = 2
              OTHERS                  = 3.
          IF sy-subrc <> 0.
            MESSAGE e000(sr) WITH
               'Fehler bei der Einstellung zu GUI-Anbindung'(g01).
          ENDIF.
        ENDIF.
        pf_m_open c_statistic_state 'A:Attach Gui'.           "#EC NOTEXT
*
*       start of ITS-Plugin only, if the session does not contain any
*       GUI connection (e. g. stateful session)
*       stop external SAPGUI debugging, if it was activated before
*

*
* Check whether according the system settings a reathentication in case of stateful communication (ITS)
* services is necessary (0 = nein, 1 = classic reauth (SSO check), 2 = security session
*
       IF server_obj->m_server_type = co_servertype_net.
          TRY.
              l_server_net_obj ?= server_obj.
              l_reauth_required = l_server_net_obj->reauthentication_required( service = runtime_memory-actlogin ).

            CATCH cx_root INTO l_root_error.
              l_message = l_root_error->get_text( ).
              MESSAGE e000(sr) WITH l_message.
          ENDTRY.
        ENDIF.

        CALL FUNCTION 'ICF_ATTACH_ITS_PLUGIN'
          EXPORTING
            export_urlsessionid           = 'X'
            configuration                 = l_configuration
            reauth_required               = l_reauth_required
          EXCEPTIONS
            icf_no_plugin_session         = 1
            icf_no_message_object         = 2
            icf_its_session_failed        = 3
            icf_plugin_status_failed      = 4
            icf_url_session_id_failed     = 5
            icf_its_plugin_not_supported  = 6
            icf_diag_session_failed       = 7
            icf_its_plugin_already_active = 8
            icf_no_dialog_user            = 9
            OTHERS                        = 100.
        subrc = sy-subrc.
        CASE subrc.
          WHEN 0 OR 8. "o.k. or icf_its_plugin_already_active
            "O.K.
          WHEN 1.
            l_message = 'ICF_NO_PLUGIN_SESSION'.
          WHEN 2.
            l_message = 'ICF_NO_MESSAGE_OBJECT'.
          WHEN 3.
            l_message = 'ICF_ITS_SESSION_FAILED'.
          WHEN 4.
            l_message = 'ICF_SET_PLUGIN_STATUS_FAILED'.
          WHEN 5.
            l_message = 'ICF_URL_SESSION_ID_FAILED'.
          WHEN 6.
            l_message = 'ICF_ITS_PLUGIN_NOT_SUPPORTED'.
          WHEN 7.
            l_message = 'ICF_DIAG_SESSION_FAILED'.
          WHEN 9.
            l_message = 'ICF_NO_DIALOG_USER'.
          WHEN OTHERS.
            l_message = 'FAILED ?'.
        ENDCASE.
        IF subrc <> 0 AND
           subrc <> 8.
          IF subrc = 9.
*       Bitte mit einem Dialogbenutzer anmelden
            MESSAGE e156(00).
          ELSE.
            MESSAGE e058(shttp) WITH l_message.
          ENDIF.
        ENDIF.

*     restart of debugging after ITS GUI attachment
        IF server_obj->c_debugid IS NOT INITIAL.
          CALL METHOD server_obj->debugging( force = 1 ).
        ENDIF.
*     avoid multiple execution of attach gui during first request
        server_obj->m_gui_attached = 1.
        pf_m_close c_statistic_state 'A:Attach Gui'.          "#EC NOTEXT
      ENDIF.


*
* setting of GUI response related atrributes in kernel,
* e. g. SSO cookie, compression and session timeout
*
      IF its_attributes_already_set  = 0       AND
         server_obj->m_gui_attached  = 1       AND
         ( server_obj->session_timeout IS NOT INITIAL OR
           server_obj->m_mysapsso2_created    = 2     OR
           runtime_memory-actlogin-compr_flag = 'Y'   OR
           server_obj->m_security_session_cookie IS NOT INITIAL ).
        DATA: l_session_timeout TYPE i.
        DATA: l_compression     TYPE i.
        DATA: l_sso_cookie      TYPE string.

        l_session_timeout = server_obj->session_timeout.

* value -1 for kernel as indicator for no compression setting
        l_compression = -1.

* is compression option set and this can be supported by SAP Web AS
        IF runtime_memory-actlogin-compr_flag = 'Y'.
          CALL METHOD server_obj->check_compression
            EXCEPTIONS
              compression_not_possible = 1.
          IF sy-subrc = 0.
            l_compression = co_compress_based_on_mime_type.
          ENDIF.
        ENDIF.

*
* mysapsso2 is created and should be set
*
        IF server_obj->m_sso_cookie IS NOT INITIAL AND
           server_obj->m_mysapsso2_created = 2.
          l_sso_cookie = server_obj->m_sso_cookie.
        ENDIF.

* set these attributes for ITS reponse and related session
        CALL 'ICF_DISPATCH' ID 'HTTP'  FIELD 'I'
          ID 'SSOCookie'       FIELD l_sso_cookie
          ID 'Compression'     FIELD l_compression
          ID 'SessionTimeout'  FIELD l_session_timeout
          ID 'SecSessionCookie' FIELD server_obj->m_security_session_cookie.

* release sso data
        FREE l_sso_cookie.
      ENDIF.
* evaluation of GUI options only once per request
      its_attributes_already_set = 1.

* -- server statistic: execution time of handler
      stime = server_obj->m_timer->get_runtime( ).

      pf_m_open c_statistic_state 'A:Handle Request'.         "#EC NOTEXT
      TRY.
* -- for send_page method, check whether page was available
          CLEAR: server_obj->m_connection_error, send_page_rc.
          CALL METHOD extension->handle_request( server = server ).

        CATCH cx_icf_do_not_catch INTO l_exception.
* -- release context
          stateful = if_http_server=>co_disabled.
* -- adjust the transactional logic
          flow_rc = extension->flow_rc.
* -- is during processing of send_page error occured ?
          server_obj->m_connection_error =
                      l_exception->m_connection_error.
          pf_m_close c_statistic_state 'A:Handle Request'.    "#EC NOTEXT
          send_page_rc = 1.
          RETURN.
      ENDTRY.
      pf_m_close c_statistic_state 'A:Handle Request'.        "#EC NOTEXT

* -- server statistic: execution time of handler
      etime = server_obj->m_timer->get_runtime( ).
      server_obj->m_exe_time =
             server_obj->m_exe_time + ( etime - stime ).

*
* evaluation of lifetime_rc: reuse of extension objects based on
*                            virtual host number, script name and the
*                            extension id
*
      IF server->stateful = 1.
        IF ext_inst_idx = -1 AND
           extension->lifetime_rc = if_http_extension=>co_lifetime_keep.
* keep executed extension object for reuse in subsequent requests
          ext_inst-extension    = curr_reg-extension.
          ext_inst-refpointer   = extension.
          ext_inst-url          = serv_wa-script_name.
          ext_inst-server_name  = server_obj->m_name.
          ext_inst-virtual_host = c_virtual_host.
          INSERT ext_inst INTO http_ext_instances INDEX 1.
        ELSEIF ext_inst_idx > 0 AND
        extension->lifetime_rc = if_http_extension=>co_lifetime_destroy.
* remove executed extension object
          DELETE http_ext_instances INDEX ext_inst_idx.
        ENDIF.
      ENDIF.

*     continue with additional extensions that might match?
      flow_rc = extension->flow_rc.
      CASE extension->flow_rc.
        WHEN if_http_extension=>co_flow_error.
          request_done = 1.            " done with all extensions
          EXIT.
        WHEN if_http_extension=>co_flow_ok.
          request_done = 1.            " done with all extensions
          EXIT.
        WHEN if_http_extension=>co_flow_ok_others_mand.
          CLEAR extension.
      ENDCASE.

    ENDLOOP.
    pf_m_close c_statistic_state 'A:Handler List'.
  ENDLOOP.

  pf_m_close c_statistic_state 'A:Service List'.

*
* no extension registered for url? -> error response!
*
  IF extension IS INITIAL.
    DATA: l_page_attributes TYPE ihttp_service_page.
    DATA: l_status_code     TYPE string,
          l_status_reason   TYPE string.
* Not Found page attributes:
    l_page_attributes-kind = runtime_memory-actlogin-kindnfpag.
    l_page_attributes-header =
                      runtime_memory-actlogin-hdrotrnfpag.
    l_page_attributes-body =
                      runtime_memory-actlogin-bodotrnfpag.
    l_page_attributes-redirect =
                      runtime_memory-actlogin-urlnfpag.
    l_status_code   = '404'.
    l_status_reason = 'No Extension Found'.                 "#EC NOTEXT
*    create object ext_error
*      exporting code = 404 reason = 'No Extension Found'. "#EC NOTEXT
*
*    call method ext_error->handle_request
*      exporting
*        server = server.

* avoid XSS via header field sap-icfreason by setting of SSL/X509 for a
* root service (e.g. /sap or external alias /test)
* and sending the header field sap-icfreason including java script to
* an unknown service behind the root service
* (e.g. /sap/xx or with external alias /test/xx)
    server->request->delete_header_field_secure( name  = 'sap-icfreason' ). "#EC NOTEXT

    server_obj->send_service_not_found(
                         status_code   = l_status_code
                         status_reason = l_status_reason
                         page_attributes = l_page_attributes ).

*    create object ext_error
*      exporting code = 404 reason = 'No Extension Found'. "#EC NOTEXT
*
*    call method ext_error->handle_request
*      exporting
*        server = server.
    ROLLBACK WORK.
  ENDIF.
ENDMETHOD.


METHOD get_epp_context_ids.
  DATA: l_epp_global TYPE REF TO if_epp_global_section.
*
* determination of the EPP root context id, connection id and connection counter for
* error documents processed in ABAP, e.g. logon failed
*
  TRY.
      l_epp_global = cl_epp_global_factory=>get_section( ).

    CATCH cx_epp_error.
      RAISE epp_error.
  ENDTRY.

  TRY.
      root_context_id    = l_epp_global->get_root_context_id_as_uuid( ).
      connection_id      = l_epp_global->get_connection_id_as_uuid( ).
      connection_counter = l_epp_global->get_connection_counter( ).
      IF transaction_id IS REQUESTED.
        transaction_id     = l_epp_global->get_transaction_id( ).
      ENDIF.

    CATCH cx_epp_error.
      RAISE epp_error.
  ENDTRY.
ENDMETHOD.


method get_response_message.
  data: l_entity type ref to cl_http_entity.

  l_entity ?= response.
  message_object = l_entity->m_c_msg.
endmethod.


method get_service_extension .
  data: l_extensions    type ihttp_icfservice_extensions,
       l_extension     type ihttp_icfservice_extension.


  if kind <> ihttp_icfservice_extension_its and
    kind <> ihttp_icfservice_extension_bsp  and
    kind <> ihttp_icfservice_extension_sam.
    raise kind_is_not_supported.
  endif.

  clear configuration.

  if m_extension_container is not initial.
     call function 'ICF_SERVICE_EXTENSION'
       exporting
         action                  = ihttp_icfservice_action_unpack
*        from_extensions         =
       importing
          to_extensions          = l_extensions
       changing
          icfservice_container   = m_extension_container
       exceptions
          icf_action_not_supported            = 1
          icf_incomplete_information          = 3
          icf_invalid_service_container       = 4
          others                              = 5.
      if sy-subrc <> 0.
        raise error_during_processing.
      endif.
      read table l_extensions into l_extension with key kind = kind.
      if sy-subrc = 0.
        configuration = l_extension-content.
      endif.
  endif.
endmethod.


METHOD if_http_server~append_field_url.

  DATA: escaped TYPE string.
  CLEAR c_last_error.

  IF url CA '?'.
    CONCATENATE url '&' INTO url.
  ELSE.
    CONCATENATE url '?' INTO url.
  ENDIF.

* Use new ABAP XSS Escaping library (see sap note 1644634)
*  escaped = escape_url( name ).
  escaped = escape( val    = name
                    format = cl_abap_format=>e_xss_url ).
  CONCATENATE url escaped '=' INTO url.

*  escaped = escape_url( value ).
  escaped = escape( val    = value
                    format = cl_abap_format=>e_xss_url ).
  CONCATENATE url escaped INTO url.

ENDMETHOD.


method IF_HTTP_SERVER~CREATE_ABS_URL.

  data: temp_path like path,
        help      type string.

  clear c_last_error.

* -- protocol
  if protocol is initial.
* --  setting of ~URI_SCHEME
    if ssl_active = co_enabled.
      help = 'https'.
    else.
      help = 'http'.
    endif.
  else.
    help = protocol.
  endif.
  concatenate help '://' into url.

* -- host
  if host is initial.
    help = request->get_header_field( '~SERVER_NAME' ).
  else.
    help = host.
  endif.
  concatenate url help into url.

* -- port
  if port is initial.
    help = request->get_header_field( '~SERVER_PORT' ).
  else.
    help = port.
  endif.
  if not help is initial.
    concatenate url ':' help into url.
  endif.

* -- path
  if path is initial.
    help = request->get_header_field( '~PATH_TRANSLATED' ).
  else.
    help = path.
  endif.

  if not help is initial.
    temp_path = help.

    if help(1) = '/'.
      temp_path = help+1.
    endif.

    concatenate url '/' temp_path into url.
  endif.

  if not querystring is initial.
    concatenate url '?' querystring into url.
  endif.

endmethod.


method if_http_server~create_rel_url.

  data: _path like path.
  clear c_last_error.

  if not path is initial.
    _path = path.

    if path(1) = '/'.
      _path = path+1.
    else.
      _path = path.
    endif.

    concatenate url '/' _path into url.

  endif.

  if not querystring is initial.
    concatenate url '?' querystring into url.
  endif.

endmethod.


method IF_HTTP_SERVER~DECODE_BASE64.

  system-call ict
    did
      ihttp_scid_base64_unescape
    parameters
      encoded                            " >
      decoded                            " <
      c_last_error.                        " < return code

endmethod.


method IF_HTTP_SERVER~ENABLE_FOREIGN_SESSION_ACCESS.
endmethod.


method IF_HTTP_SERVER~ENCODE_BASE64.

  system-call ict
    did
      ihttp_scid_base64_escape
    parameters
      unencoded                          " >
      encoded                            " <
      c_last_error.                        " < return code

endmethod.


method if_http_server~escape_html.

  system-call ict
    did
      ihttp_scid_html_escape
    parameters
      unescaped                          " >
      escaped                            " <
      c_last_error.                        " < return code

endmethod.


method IF_HTTP_SERVER~ESCAPE_URL.

  system-call ict
    did
      ihttp_scid_url_escape
    parameters
      unescaped                          " >
      escaped                            " <
      c_last_error.                        " < return code

endmethod.


method IF_HTTP_SERVER~GET_EXTENSION_INFO.

* this method makes a reverse lookup of all URLs for which
* the given HTTP extension class is registered in the system.
* This might be used by applications (e.g. Dev.Env) to generated
* appropriate request URLs for testing etc.

  data: handlerclass type seoclsname.
  clear c_last_error.

  handlerclass = extension_class.
  translate handlerclass to upper case.               "#EC SYNTCHAR

  call function 'HTTP_GET_URL2'
    exporting  handlerclass = handlerclass
    importing  urllist      = urls
    exceptions http_not_enabled = 1.
  if sy-subrc <> 0.
    return.
  endif.

endmethod.


method IF_HTTP_SERVER~GET_EXTENSION_URL.

* this method makes a reverse lookup of all URLs for which
* the given HTTP extension class is registered in the system.
* This might be used by applications (e.g. Dev.Env) to generated
* appropriate request URLs for testing etc.

  data: handlerclass type seoclsname.
  clear c_last_error.

  handlerclass = extension_class.

  call function 'HTTP_GET_URL'
    exporting handlerclass = handlerclass
    importing urllist      = urls.

endmethod.


METHOD if_http_server~get_icf_runtime.

  IF m_icf_runtime IS NOT BOUND.
    CREATE OBJECT m_icf_runtime TYPE cl_icf_runtime.
  ENDIF.

  icf_rt = m_icf_runtime.

ENDMETHOD.


method IF_HTTP_SERVER~GET_LAST_ERROR.

  rc = C_LAST_ERROR.

endmethod.                    "


METHOD if_http_server~get_location .

* Recommended is at all times to call this method **WITHOUT** protocol
* been set. Then the correct default configured protocol can be pulled
* from the table!
*
* Support for this specific method: OSS queue BC-BSP, route Brian or Uwe
*
  DATA ticket_value TYPE c LENGTH 4.
  CLEAR c_last_error.

  CALL METHOD if_http_server~get_location_exception
    EXPORTING
      protocol     = protocol
      application  = application
      for_domain   = for_domain
      server       = server
    IMPORTING
      host         = host
      port         = port
      out_protocol = out_protocol
      vh_switch    = vh_switch
    RECEIVING
      url_part     = url_part.

  IF host IS NOT INITIAL AND port IS NOT INITIAL.
    RETURN.
  ENDIF.

* If not protocol is specified, we see if the server object gives us the answer. Here
* we do not worry about access-point headers from Web Dispatcher, as the above
* get_location_exception would have done that. We also do not consider the case
* of protocol switch over a proxy, as this can only be evaluated if the HTTPURLLOC
* table is filled, which again means above call completed the job. Here we have
* the vanilla case: what protocol is currently active.

  IF use_ticket_protocol = abap_true.
    CALL 'C_SAPGPARAM'                                    "#EC CI_CCALL
      ID 'NAME'  FIELD 'login/ticket_only_by_https'
      ID 'VALUE' FIELD ticket_value.
  ENDIF.

  IF ticket_value = '1' AND protocol IS INITIAL.
    out_protocol = 'https'.

  ELSEIF protocol IS INITIAL AND server IS BOUND.
    IF server->ssl_active IS INITIAL.
      out_protocol = 'http'.                                "#EC NOTEXT
    ELSE.
      out_protocol = 'https'.                               "#EC NOTEXT
    ENDIF.
  ELSE.
    out_protocol = protocol.
    TRANSLATE out_protocol TO LOWER CASE.
  ENDIF.

* If we get here, then no exception entry. Return the default host & port name for this protocol.
  IF out_protocol IS NOT INITIAL.

    INCLUDE tskhincl.
    DATA: l_index_protocol TYPE sy-index.
    CASE out_protocol.
      WHEN 'http'.  l_index_protocol = th_plugin_protocol_http.
      WHEN 'https'. l_index_protocol = th_plugin_protocol_https.
      WHEN 'smpt'.  l_index_protocol = th_plugin_protocol_smtp.
      WHEN 'ftp'.   l_index_protocol = th_plugin_protocol_ftp.
    ENDCASE.

    CALL FUNCTION 'TH_GET_VIRT_HOST_DATA'
      EXPORTING
        protocol       = l_index_protocol
        virt_idx       = 0
      IMPORTING
        hostname       = host
        port           = port
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    IF sy-subrc <> 0. " happens only in extreme cases
      c_last_error = 1100 + sy-subrc.
    ENDIF.

  ELSE.

    CALL FUNCTION 'TH_GET_VIRT_HOST_DATA'
      EXPORTING
        protocol = th_plugin_protocol_http
        virt_idx = 0
      IMPORTING
        hostname = host
        port     = port
      EXCEPTIONS
        OTHERS   = 99.
    IF sy-subrc IS INITIAL.
      out_protocol = 'http'.
    ELSE.
      CALL FUNCTION 'TH_GET_VIRT_HOST_DATA'
        EXPORTING
          protocol = th_plugin_protocol_https
          virt_idx = 0
        IMPORTING
          hostname = host
          port     = port
        EXCEPTIONS
          OTHERS   = 99.
      IF sy-subrc IS INITIAL.
        out_protocol = 'https'.
      ELSE.
        c_last_error = 1100 + sy-subrc.
      ENDIF.
    ENDIF.

  ENDIF.

  url_part  = out_protocol && '://' && host && ':' && port.
  vh_switch = vh_switch.

ENDMETHOD.


METHOD if_http_server~get_location_exception .

* Recommended is at all times to call this method **WITHOUT** protocol
* been set. Then the correct default configured protocol can be pulled
* from the table!
*
* Support for this specific method: OSS queue BC-BSP, route Brian or Uwe
*
  CONSTANTS: co_gen_dfl TYPE c LENGTH 128 VALUE 'DEFAULT_VHOST_APPLICATIONS_DEFAULT_HOST'.

  DATA host_header     TYPE string.
  DATA ap_header       TYPE string.
  DATA ap_header_parts TYPE string_table.
  DATA ap_header_part  TYPE string.
  DATA ap_protocol     TYPE string.
  DATA ap_port         TYPE string.
  DATA ticket_value    TYPE c LENGTH 4.

**************** Changed by D026759 ******************
* For Admin Vhost

  DATA: l_service_name TYPE icfname,
        l_icfparguid   TYPE icfparguid,
        l_is_adm_srv   TYPE abap_bool.

  DATA: lt_httpurlloc   TYPE STANDARD TABLE OF httpurlloc,
        lt_urlloc_tmp   TYPE STANDARD TABLE OF httpurlloc,
        ls_httpurlloc   TYPE httpurlloc,
        lt_icfsrv4admin TYPE STANDARD TABLE OF icfsrv4admin,
        ls_icfsrv4admin TYPE icfsrv4admin,
        l_len           TYPE i.

  DATA: lt_httpurlloc_save  TYPE STANDARD TABLE OF httpurlloc,
        lt_gen_dfl_srv_save TYPE STANDARD TABLE OF httpurlloc.

  DATA: l_appl              TYPE c LENGTH 128.
  DATA: l_admvh             TYPE icfname, "Admin Vhost
        l_admvhnr           TYPE i,
        l_vh_from_rt        TYPE icfname.
  DATA: l_gen_admvh         TYPE c LENGTH 128. "Generic Name for Admin Vhost in HTTPURLLOC
  DATA: l_gen_dflvh         TYPE c LENGTH 128. "Generic Name for Default Vhost in HTTPURLLOC
  DATA: l_dflvh             TYPE icfname, "Default_host
        l_dflvhnr           TYPE i.
  DATA: l_icfactive         TYPE icfactive.
  DATA: l_vh_orig_kind      TYPE c. "D = Default_host; O = Others; A = Admin_host

  DATA: ls_gen_dfl_srv_save TYPE httpurlloc.
  DATA: l_specific_entry    TYPE abap_bool.

  DATA: lt_str              TYPE string_table,
        l_srv_path          TYPE icfrequest_path,
        l_path_trans        TYPE icfrequest_path.

  DATA: l_vhnr_orig_n       TYPE n,
        l_dummy             TYPE string.

  DATA: l_host              TYPE string.

  DATA: lt_urlloc_attr      TYPE urlloc_attr_tab.

  DATA: server_obj          TYPE REF TO cl_http_server_net.
  DATA: l_exit_flag         TYPE abap_bool VALUE abap_false.

*   Loop over table, and try to match one line as fast as possible
  FIELD-SYMBOLS: <httpurlloc>    TYPE httpurlloc.
  FIELD-SYMBOLS <fs_segment>     TYPE string.
  FIELD-SYMBOLS <fs_urlloc_attr> TYPE urlloc_attr_str.
********************************************************
  CLEAR url_part.
  vh_switch = abap_undefined.

  IF server IS BOUND.
    TRY.
        server_obj ?= server.
      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    host_header = server->request->get_header_field( if_http_header_fields=>host ).
    IF host_header CA ':'.
      DATA: service TYPE string. "#EC NEEDED  "Service ist here Port Number of ICM"
      SPLIT host_header AT ':' INTO host_header service.
    ENDIF.
  ENDIF.

  IF use_ticket_protocol = abap_true.
    CALL 'C_SAPGPARAM'                                    "#EC CI_CCALL
      ID 'NAME'  FIELD 'login/ticket_only_by_https'
      ID 'VALUE' FIELD ticket_value.
  ENDIF.

  IF ticket_value = '1' AND protocol IS INITIAL.
    out_protocol = 'HTTPS'.
  ELSEIF protocol IS INITIAL AND server IS BOUND.
* determine the access protocol to WebDispatcher, in case of protocol switch, e.g. https to http
    out_protocol = server->request->get_header_field( if_http_header_fields_sap=>client_protocol ).
    IF out_protocol IS INITIAL.
      " Alternativly get the current protocol
      IF server->ssl_active IS NOT INITIAL.
        out_protocol = 'HTTPS'.                             "#EC NOTEXT
      ELSE.
        out_protocol = 'HTTP'.                              "#EC NOTEXT
      ENDIF.
    ELSE.
      TRANSLATE out_protocol TO UPPER CASE.
    ENDIF.
  ELSE.
    out_protocol = protocol.
    TRANSLATE out_protocol TO UPPER CASE.                   "#EC NOTEXT
  ENDIF.

  IF out_protocol IS NOT INITIAL.
    IF host_header IS NOT INITIAL.
      ap_header = server->request->get_header_field( if_http_header_fields_sap=>wdisp_access_point ).
      IF ap_header IS NOT INITIAL.
        CONDENSE ap_header NO-GAPS.
        TRANSLATE ap_header TO UPPER CASE.                  "#EC
        SPLIT ap_header AT ',' INTO TABLE ap_header_parts.
        LOOP AT ap_header_parts INTO ap_header_part.
          SPLIT ap_header_part AT '=' INTO ap_protocol ap_port.
          IF ap_protocol = out_protocol.
            ASSERT ap_port CO '0123456789'.
            host        = host_header.
            port        = ap_port.
            l_exit_flag = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF l_exit_flag EQ abap_true.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    SELECT * FROM httpurlloc INTO TABLE lt_httpurlloc WHERE protocol = out_protocol.
  ELSE.
    SELECT * FROM httpurlloc INTO TABLE lt_httpurlloc.
  ENDIF.

****************************************************
* VH_Switch handling
  IF server IS BOUND.
    l_vhnr_orig_n = server->request->get_header_field( if_http_header_fields_sap=>virtual_host_number ).
    IF l_vhnr_orig_n EQ 0.
      l_vh_orig_kind = 'D'. "Default_host
    ELSE.

      CALL METHOD cl_admin_service_processing=>get_expected_httpurlloc_entry
        IMPORTING
          ev_exp_entry   = l_gen_admvh
          ev_vhost       = l_admvh
          ev_vhost_nr    = l_admvhnr
          et_urlloc_attr = lt_urlloc_attr.

      IF NOT l_admvh IS INITIAL.
        IF l_vhnr_orig_n EQ l_admvhnr.
          l_vh_orig_kind = 'A'. "Admin_host
        ELSE.
          l_vh_orig_kind = 'O'. "Other Vhost than default and Admin one
        ENDIF.
      ENDIF.
    ENDIF.
*  ELSE.
    " no server object or runtime cache is disabled
    " no info about switch vhost can be found
*    VH_SWITCH = abap_undefined.
  ENDIF.

***********************************************************************************************
* Start analysis of HTTPURLLOC table entries to determine the Host, Port & Protocol from there
***********************************************************************************************

  SORT lt_httpurlloc BY sort_key.
* Only if we have mathing lines, we do the lookup
  IF sy-subrc = 0 AND lines( lt_httpurlloc ) > 0.

*   In the table, we store information in upper case, so translate input.
    TRANSLATE application TO UPPER CASE.                    "#EC
    TRANSLATE for_domain  TO UPPER CASE.                    "#EC

    CLEAR: l_is_adm_srv.

* Prepare for check for service path
*********************
* Remove slash at the end of service path, if necessary
    IF NOT application IS INITIAL.
      l_appl = application.
      IF l_appl EQ '/'.
        CLEAR: host, port, out_protocol.
        RETURN. "exit this method
      ELSE.
        l_len = strlen( l_appl ) - 1.

        IF l_appl+l_len(1) EQ '/'.
          l_appl = l_appl(l_len).
        ENDIF.
      ENDIF.

      IF l_gen_admvh IS INITIAL.
        "Retrieve HTTPURLLOC entry for generic Admin Vhost
        CALL METHOD cl_admin_service_processing=>get_expected_httpurlloc_entry
          IMPORTING
            ev_exp_entry = l_gen_admvh
            ev_vhost     = l_admvh
            ev_vhost_nr  = l_admvhnr.
      ENDIF.

      IF l_gen_admvh EQ application.
* No check for Admin ICF Service is necessary
* It is an Admin ICF Service
* (example: Generic Admin ICF Services of WebService Application)
        IF out_protocol IS NOT INITIAL.
          READ TABLE lt_httpurlloc WITH KEY applicatn = l_gen_admvh
                                            protocol  = out_protocol
                                   INTO ls_httpurlloc.
          IF sy-subrc EQ 0.
            IF ls_httpurlloc-host IS INITIAL.
              CLEAR: host, port, out_protocol.
              RETURN. "exit this method
            ENDIF.
* Determine the output values
            host         = ls_httpurlloc-host.
            port         = ls_httpurlloc-port.
            out_protocol = ls_httpurlloc-protocol.

            IF l_admvhnr EQ l_vhnr_orig_n.
              vh_switch = abap_false.
            ELSE.
              "Switch to Admin Vhost
              vh_switch = abap_true.
            ENDIF.

            TRANSLATE out_protocol TO LOWER CASE.
            url_part = out_protocol && '://' && host && ':' && port.
            RETURN. "exit this method
          ELSE.
            RETURN. "exit this method
          ENDIF.
        ELSE.
* out_protocol is initial
          READ TABLE lt_httpurlloc WITH KEY applicatn = l_gen_admvh
                                   INTO ls_httpurlloc.
          IF sy-subrc EQ 0.
* Take the first entry in HTTPURLLOC
* Recommendation:
* use HTTPS for Admin Services and enter
* Reverse Proxy config in HTTPURLLOC
            IF ls_httpurlloc-host IS INITIAL.
              CLEAR: host, port, out_protocol.
              RETURN. "exit this method
            ENDIF.
* Determine the output values
            host         = ls_httpurlloc-host.
            port         = ls_httpurlloc-port.
            out_protocol = ls_httpurlloc-protocol.

            IF l_admvhnr EQ l_vhnr_orig_n.
              vh_switch = abap_false.
            ELSE.
              "Switch to Admin Vhost
              vh_switch = abap_true.
            ENDIF.

            TRANSLATE out_protocol TO LOWER CASE.
            url_part = out_protocol && '://' && host && ':' && port.
            RETURN. "exit this method
          ELSE.
            RETURN. "exit this method
          ENDIF.
        ENDIF.
      ELSE. "Application is not the same like generic Admin_vhost Pattern in HTTPURLLOC

* check for generic default_host entry in HTTPURLLOC
        CALL METHOD cl_admin_service_processing=>get_expected_httpurloc_4_dfl
          IMPORTING
            ev_exp_entry = l_gen_dflvh
            ev_vhost     = l_dflvh
            ev_vhost_nr  = l_dflvhnr.

        IF l_gen_dflvh EQ application.
* No further check is necessary
* It is an default host (classic) ICF Service
* (example: Generic classical ICF Services of WebService Application)
          IF out_protocol IS NOT INITIAL.
            READ TABLE lt_httpurlloc WITH KEY applicatn = l_gen_dflvh
                                              protocol  = out_protocol
                                     INTO ls_httpurlloc.
            IF sy-subrc EQ 0.
              IF ls_httpurlloc-host IS INITIAL.
                CLEAR: host, port, out_protocol.
                RETURN. "exit this method
              ENDIF.
* Determine the output values
              host         = ls_httpurlloc-host.
              port         = ls_httpurlloc-port.
              out_protocol = ls_httpurlloc-protocol.

              IF l_dflvhnr EQ l_vhnr_orig_n.
                vh_switch = abap_false.
              ELSE.
                "Switch to Default host
                vh_switch = abap_true.
              ENDIF.

              TRANSLATE out_protocol TO LOWER CASE.
              url_part = out_protocol && '://' && host && ':' && port.
              RETURN. "exit this method
            ELSE.
              RETURN. "exit this method
            ENDIF.
          ELSE.
* out_protocol is initial
            READ TABLE lt_httpurlloc WITH KEY applicatn = l_gen_dflvh
                                              protocol  = out_protocol
                                     INTO ls_httpurlloc.
            IF sy-subrc EQ 0.
* Take the first entry in HTTPURLLOC
* Recommendation:
* use HTTPS for Admin Services and enter
* Reverse Proxy config in HTTPURLLOC
              IF ls_httpurlloc-host IS INITIAL.
                CLEAR: host, port, out_protocol.
                RETURN. "exit this method
              ENDIF.
* Determine the output values
              host         = ls_httpurlloc-host.
              port         = ls_httpurlloc-port.
              out_protocol = ls_httpurlloc-protocol.

              IF l_dflvhnr EQ l_vhnr_orig_n.
                vh_switch = abap_false.
              ELSE.
                "Switch to Default host
                vh_switch = abap_true.
              ENDIF.

              TRANSLATE out_protocol TO LOWER CASE.
              url_part = out_protocol && '://' && host && ':' && port.
              RETURN. "exit this method
            ELSE.
              RETURN. "exit this method
            ENDIF.
          ENDIF.
        ELSE.

* Other Applications, which have registered itself as
* Admin ICF Service

* 1) Check whether Admin Vhost is configured in system
          IF l_admvh IS INITIAL.
            l_is_adm_srv = abap_false.
          ELSE. " sy-subrc EQ 0.
** Admin Vhost exists (Pre-Requisite for further check)

* 2) Does the importing parameter application
*    belongs to an admin icf service?

* Check whether persisted service path in Admin ICF Service
*      contains the importing parameter application
            l_srv_path = l_appl.
            CALL METHOD cl_admin_service_processing=>is_admin_by_service_path
              EXPORTING
                iv_service_path = l_srv_path
              IMPORTING
                ev_admin_flag   = l_is_adm_srv
                ev_service_name = ls_icfsrv4admin-service_name
                ev_icfparguid   = ls_icfsrv4admin-icfparguid.

            IF l_is_adm_srv = abap_true.
* 3) Is Reassignment status of ICF Service in DEFAULT_HOST inactive?
*    If yes, then it is a real Admin ICF Service
*    Using this test, we can determine whether we took the right
*    ICF Service with right icfparguid and service name

              SELECT SINGLE icfactive FROM icfservloc INTO l_icfactive
                WHERE icf_name   = ls_icfsrv4admin-service_name AND
                      icfparguid = ls_icfsrv4admin-icfparguid.
              IF l_icfactive IS INITIAL. "Reassignment status for Admin Service is inactive

* 4) Check whether it exists a generic entry in HTTPURLLOC
*    for Admin ICF Services (see format of variable l_gen_admvh)
                IF out_protocol IS NOT INITIAL.
                  READ TABLE lt_httpurlloc WITH KEY applicatn = l_gen_admvh
                                                    protocol  = out_protocol
                                           INTO ls_httpurlloc.
                  IF sy-subrc EQ 0.
                    IF ls_httpurlloc-host IS INITIAL.
                      CLEAR: host, port, out_protocol.
                      RETURN. "exit this method
                    ENDIF.
* Determine the output values
                    host         = ls_httpurlloc-host.
                    port         = ls_httpurlloc-port.
                    out_protocol = ls_httpurlloc-protocol.

                    IF l_admvhnr EQ l_vhnr_orig_n.
                      vh_switch = abap_false.
                    ELSE.
                      "Switch to Admin Vhost
                      vh_switch = abap_true.
                    ENDIF.

                    TRANSLATE out_protocol TO LOWER CASE.
                    url_part = out_protocol && '://' && host && ':' && port.
                    RETURN. "exit this method
                  ELSE.
                    CLEAR l_is_adm_srv.
                  ENDIF.
                ELSE.
                  READ TABLE lt_httpurlloc WITH KEY applicatn = l_gen_admvh
                                           INTO ls_httpurlloc.
                  IF sy-subrc EQ 0.
                    IF ls_httpurlloc-host IS INITIAL.
                      CLEAR: host, port, out_protocol.
                      RETURN. "exit this method
                    ENDIF.
* Determine the output values
                    host         = ls_httpurlloc-host.
                    port         = ls_httpurlloc-port.
                    out_protocol = ls_httpurlloc-protocol.

                    IF l_admvhnr EQ l_vhnr_orig_n.
                      vh_switch = abap_false.
                    ELSE.
                      "Switch to Admin Vhost
                      vh_switch = abap_true.
                    ENDIF.

                    TRANSLATE out_protocol TO LOWER CASE.
                    url_part = out_protocol && '://' && host && ':' && port.
                    RETURN. "exit this method
                  ELSE.
                    CLEAR l_is_adm_srv.
                  ENDIF.
                ENDIF.
              ELSE. "Reassignment status for Admin Service is active
                CLEAR l_is_adm_srv.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
*    ELSE. "Importing Parameter "Application" is initial
    ENDIF.

    IF l_is_adm_srv IS INITIAL.

* Distiguish among three scenarios:
* 1) It does not exist any Admin Vhost / Admin Services and it exists only classical one
* 2) It exists admin vhost but the above four checks has shown that we have to use
*    the classical one (because an admin service is active in default host and admin vhost --> Test Phase)
* 3) Application wants to switch from Admin Service to classical one on default_host

* Check whether it exists generic default host entry in HTTPURLLOC
      IF l_gen_dflvh IS INITIAL.
        "Find it out
        CALL METHOD cl_admin_service_processing=>get_expected_httpurloc_4_dfl
          IMPORTING
            ev_exp_entry = l_gen_dflvh.
      ENDIF.
      IF NOT lt_httpurlloc IS INITIAL.
        LOOP AT lt_httpurlloc ASSIGNING <httpurlloc>
             WHERE applicatn = l_gen_dflvh.
          APPEND <httpurlloc> TO lt_urlloc_tmp. "pickup generic default_host entries if it exists
        ENDLOOP.

        lt_gen_dfl_srv_save = lt_urlloc_tmp. "

        IF lt_urlloc_tmp IS INITIAL. "no generic default_host exists
* Takeover the customer setting without generic admin vhost

* Remove the generic entries for Admin Vhost from ITAB in HTTPURLLOC
          CLEAR lt_httpurlloc_save.
          lt_httpurlloc_save = lt_httpurlloc.
          LOOP AT lt_httpurlloc_save INTO ls_httpurlloc
                                     WHERE applicatn = l_gen_admvh.
            DELETE TABLE lt_httpurlloc FROM ls_httpurlloc.
          ENDLOOP.

        ELSE. "it exists generic default_host
*          IF l_vh_orig_kind EQ 'O' OR "others (not default_host and not Admin vhost)
*             l_vh_orig_kind EQ 'A' OR
*             l_vh_orig_kind IS INITIAL. "l_vh_orig_kind EQ space, if server_obj is not bound
          IF l_vh_orig_kind NE 'D'.
* a)
* Remove the generic entries for Admin Vhost from ITAB in HTTPURLLOC
            CLEAR lt_httpurlloc_save.

            IF l_gen_admvh IS INITIAL.
              "get l_gen_admvh
              CALL METHOD cl_admin_service_processing=>get_expected_httpurlloc_entry
                IMPORTING
                  ev_exp_entry = l_gen_admvh.
            ENDIF.

            lt_httpurlloc_save = lt_httpurlloc.
            LOOP AT lt_httpurlloc_save INTO ls_httpurlloc
                                       WHERE applicatn = l_gen_admvh.
              DELETE TABLE lt_httpurlloc FROM ls_httpurlloc.
            ENDLOOP.

            IF lines( lt_httpurlloc ) GT 1.
* b)
* Remove the generic entries for Default Vhost from ITAB in HTTPURLLOC
* So we will have the list of not generic entries in HTPURLLOC (specific list)
              IF lines( lt_urlloc_tmp ) GT 0.
                LOOP AT lt_urlloc_tmp ASSIGNING <httpurlloc>.
                  DELETE lt_httpurlloc WHERE applicatn = <httpurlloc>-applicatn AND
                                             protocol  = <httpurlloc>-protocol.
                ENDLOOP.
              ENDIF.
            ELSEIF lines( lt_httpurlloc ) EQ 1.

              READ TABLE lt_httpurlloc INTO ls_httpurlloc INDEX 1.
              IF lines( lt_urlloc_tmp ) GT 0.
                READ TABLE lt_urlloc_tmp WITH KEY sort_key   = ls_httpurlloc-sort_key
                                                  applicatn  = ls_httpurlloc-applicatn
                                                  protocol   = ls_httpurlloc-protocol
                                                  TRANSPORTING NO FIELDS.
                IF sy-subrc EQ 0. "It exists only generic default host entry
* Determine the output values
                  host         = ls_httpurlloc-host.
                  port         = ls_httpurlloc-port.
                  out_protocol = ls_httpurlloc-protocol.

                  TRANSLATE out_protocol TO LOWER CASE.
                  url_part = out_protocol && '://' && host && ':' && port.
                  RETURN.
*                ELSE. "No generic Default Host exists (the entry is an specific one)
                ENDIF.
              ENDIF.
            ENDIF.

          ELSEIF l_vh_orig_kind EQ 'D'. "Default_host

            IF lines( lt_httpurlloc ) EQ 1.
              READ TABLE lt_httpurlloc INTO ls_httpurlloc INDEX 1.
              IF lines( lt_urlloc_tmp ) GT 0.
                READ TABLE lt_urlloc_tmp WITH KEY sort_key   = ls_httpurlloc-sort_key
                                                  applicatn  = ls_httpurlloc-applicatn
                                                  protocol   = ls_httpurlloc-protocol
                                         TRANSPORTING NO FIELDS.
                IF sy-subrc EQ 0. "It exists only generic default host entry
* Determine the output values
                  host         = ls_httpurlloc-host.
                  port         = ls_httpurlloc-port.
                  out_protocol = ls_httpurlloc-protocol.

                  TRANSLATE out_protocol TO LOWER CASE.
                  url_part = out_protocol && '://' && host && ':' && port.
                  RETURN.
*                ELSE. "No generic Default Host exists (the entry is an specific one)
                ENDIF.
              ENDIF.

* Remove the generic entries for Default Vhost from ITAB in HTTPURLLOC
* So we will have the list of not generic entries in HTPURLLOC (specific list)
            ELSE. "It exists specific entry in HTTPURLLOC
              IF lines( lt_urlloc_tmp ) GT 0.
                LOOP AT lt_urlloc_tmp ASSIGNING <httpurlloc>.
                  DELETE lt_httpurlloc WHERE applicatn = <httpurlloc>-applicatn AND
                                             protocol  = <httpurlloc>-protocol.
                ENDLOOP.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
      IF l_vh_orig_kind EQ 'A'.
        "Switch from Admin Vhost to Default Host (case 3) or case 2
        vh_switch = abap_true.
      ELSEIF l_vh_orig_kind EQ 'D'.  "Case 1 or case 2
        "No Switch
        vh_switch = abap_false.
      ENDIF.
    ENDIF.

* Check for existing specific entries (not generic one!)
    LOOP AT lt_httpurlloc ASSIGNING <httpurlloc>.

      l_specific_entry = abap_true.

*     If specified, match string against (possible wildcard '*' in) table.
* See SAP Note 1951685
      CHECK ( application IS INITIAL AND <httpurlloc>-applicatn IS INITIAL ) OR application CP <httpurlloc>-applicatn.
      CHECK for_domain  IS INITIAL OR <httpurlloc>-for_domain IS INITIAL OR for_domain  CP <httpurlloc>-for_domain.
      CHECK host_header IS INITIAL OR host_header CP <httpurlloc>-host.

*     If host is initial, no exception should be used
      IF <httpurlloc>-host IS INITIAL.
        CLEAR: host, port, out_protocol.
        RETURN.
      ENDIF.

      host         = <httpurlloc>-host.
      port         = <httpurlloc>-port.
      out_protocol = <httpurlloc>-protocol.

      TRANSLATE out_protocol TO LOWER CASE.
      url_part = out_protocol && '://' && host && ':' && port.
      RETURN.
    ENDLOOP.
  ENDIF.

  IF l_specific_entry EQ abap_true.
* Take the generic default entry if no specific entry has been matched
    IF NOT protocol IS INITIAL.
      READ TABLE lt_gen_dfl_srv_save WITH KEY applicatn  = co_gen_dfl
                                              protocol   = protocol
                                          INTO ls_gen_dfl_srv_save.
    ELSE.
      READ TABLE lt_gen_dfl_srv_save INDEX 1
                                     INTO ls_gen_dfl_srv_save.
    ENDIF.

    IF NOT ls_gen_dfl_srv_save IS INITIAL.
      host         = ls_gen_dfl_srv_save-host.
      port         = ls_gen_dfl_srv_save-port.
      out_protocol = ls_gen_dfl_srv_save-protocol.

      TRANSLATE out_protocol TO LOWER CASE.
      url_part = out_protocol && '://' && host && ':' && port.
    ELSE.
      CLEAR: host, port, out_protocol.
    ENDIF.
  ELSE.
* If we get here, then no exception entry.
    CLEAR: host, port, out_protocol.
  ENDIF.

ENDMETHOD.


method IF_HTTP_SERVER~GET_UCON_RUNTIME.

  IF m_ucon_runtime IS NOT BOUND.
    CREATE OBJECT m_ucon_runtime TYPE cl_ucon_runtime.
  ENDIF.

  ucon_rt = m_ucon_runtime.

endmethod.


METHOD if_http_server~get_xsrf_token.
ENDMETHOD.


METHOD if_http_server~logoff.
ENDMETHOD.


method if_http_server~send_page.
endmethod.


method IF_HTTP_SERVER~SET_COMPRESSION .
endmethod.


method IF_HTTP_SERVER~SET_PAGE.
endmethod.


method if_http_server~set_session_stateful.
  data: l_path type string.
  data: l_domain type string.
  data: l_cookie type ihttpcki.
  data: l_entries type i.
  data: l_secure_id type i.

  clear c_last_error.
  if path is initial.
*   -- set path to path prefix
    l_path = request->get_header_field( '~script_name' ). "#EC NOTEXT
    if l_path is initial.
      l_path = '/'. "#EC NOTEXT
    endif.
  else.
    l_path = path.
  endif.

*   -- set domain
* date: 24.04.2007 MA
* use RFC 2109 specification
*  (http://www.ietf.org/rfc/rfc2109.txt)
* instead of netscape specification
*  (http://wp.netscape.com/newsref/std/cookie_spec.html)
* for setting of cookies on host
*  l_domain = request->get_header_field( '~server_name' ). "#EC NOTEXT
  clear l_domain.

  if stateful = co_disabled.

*   -- release user context
    me->stateful = co_disabled.

* -- deleting existinig session cookies at client
    describe table c_stateful_cookies lines l_entries.
    if l_entries > 0.
      loop at c_stateful_cookies into l_cookie.
        call method response->delete_cookie_at_client
          exporting
            name   = 'sap-contextid' "#EC NOTEXT
            path   = l_cookie-path
            domain = l_cookie-xdomain.
      endloop.
      refresh c_stateful_cookies.
    endif.

    c_last_error = response->get_last_error( ).
    c_last_error = 500 + c_last_error.

  elseif stateful = co_enabled.
*   -- keep user context
*   -- host MUST contain domain part, otherwise IE never send the cookie
*    find '.' in l_domain.
*    if sy-subrc <> 0.
** - do not specfiy the domain as pure hostname
*     clear l_domain.
*    endif.

    me->stateful = co_enabled.

*
* by a switch to stateless we have to delete all genertaed stateful cookies at the client
*
    read table c_stateful_cookies
            transporting no fields with key path = l_path.
    if sy-subrc <> 0.
* -- remeber the session cookies for deleting
      l_cookie-name     = 'sap-contextid'.
      l_cookie-xdomain  = l_domain.
      l_cookie-path     = l_path.
      append l_cookie to c_stateful_cookies.
    else.
* -- entry already exists/set at the client
      exit.
    endif.

*  -- set the session cookie at the client side
* set Httponly-Attribute
    case c_httponly_flag.
      when '0' or '1'.
         l_secure_id = 16.
      when others.
         l_secure_id = 0.
    endcase.

    call method response->set_cookie
      exporting
        name    = 'sap-contextid' "#EC NOTEXT
        value   = session_id
        path    = l_path
        domain  = l_domain
        secure  = l_secure_id.

   c_last_error = response->get_last_error( ).
   c_last_error = 500 + c_last_error.

  else.
   c_last_error = 501.
  endif.

endmethod.


method if_http_server~set_session_stateful_via_url.
  class cl_http_utility definition load.
  data: l_rewrite_url type string.
  clear c_last_error.

  if stateful = co_disabled.
    data: l_cookie type ihttpcki.

*     -- release user context
    me->stateful = co_disabled.

*   -- deleting existinig session cookies at client
    loop at c_stateful_cookies into l_cookie.
       call method response->delete_cookie_at_client
         exporting
           name   = 'sap-contextid' "#EC NOTEXT
           path   = l_cookie-path
           domain = l_cookie-xdomain.
    endloop.
    c_last_error = response->get_last_error( ).
    c_last_error = 500 + c_last_error.

  else.
    data: tbl type tihttpnvp,
          wa  type ihttpnvp.

*     -- keep user context
    me->stateful = co_enabled.

    if rewrite_url is initial.
*     -- set path to path prefix
      l_rewrite_url =
         request->get_header_field( '~script_name' ). "#EC NOTEXT
      if l_rewrite_url is initial.
        l_rewrite_url = '/'. "#EC NOTEXT
      endif.
    else.
      l_rewrite_url = rewrite_url.
    endif.
    if external_session_id is initial.
        wa-name = 's'.
        wa-value = session_id.
    else.
        wa-name = 'e'.
        wa-value = external_session_id.
    endif.
    append wa to tbl.

    rewrite_url = cl_http_utility=>rewrite_url(
                            fields = tbl
                            url    = l_rewrite_url ).

  endif.

endmethod.


method IF_HTTP_SERVER~UNESCAPE_URL.

  system-call ict
    did
      ihttp_scid_url_unescape
    parameters
      escaped                            " >
      unescaped                          " <
      c_last_error.                        " < return code

endmethod.


method IF_HTTP_SERVER~VALIDATE_XSRF_TOKEN.
endmethod.


METHOD install_error_template .
  DATA: last_page_status TYPE i,
        error_page_status   TYPE i.

* -- status: 0 = 302,1 = 301, 2 = 302/307
  last_page_status = last_page_redirect_code.

* -- status: 0 = 302,1 = 301, 2 = 302/307
  error_page_status = redirect_code.

* lastpage: no redirect and no header and body pages available
  IF kindlpag              IS INITIAL AND
     last_page_header_guid IS INITIAL AND
     last_page_body_guid   IS INITIAL.
* no last page avilabale
    IF kind500 IS INITIAL. "no redirect active
      IF NOT header_guid IS INITIAL AND
         NOT body_guid   IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                       ID 'HeaderTemplateGUID'  FIELD header_guid
                       ID 'HeaderTemplateDBStr' FIELD c_headerdbstr
                       ID 'BodyTemplateGUID'    FIELD body_guid
                       ID 'BodyTemplateDBStr'   FIELD c_bodydbstr.
      ELSEIF NOT body_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                       ID 'BodyTemplateGUID'    FIELD body_guid
                       ID 'BodyTemplateDBStr'   FIELD c_bodydbstr.
      ELSEIF NOT header_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                   ID 'HeaderTemplateGUID'  FIELD header_guid
                   ID 'HeaderTemplateDBStr' FIELD c_headerdbstr.
      ENDIF.
    ELSEIF NOT redirect IS INITIAL.
      CALL 'ICF_DISPATCH' ID 'HTTP'  FIELD 'R'
        ID 'RedirectTemplate'   FIELD redirect
        ID 'RedirectStatus'     FIELD error_page_status.
    ENDIF.
  ELSEIF kindlpag IS INITIAL.
* last page as header and/or body available
    IF kind500 IS INITIAL. "no redirect active
      IF NOT header_guid IS INITIAL AND
         NOT body_guid   IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                       ID 'HeaderTemplateGUID'  FIELD header_guid
                       ID 'HeaderTemplateDBStr' FIELD c_headerdbstr
                       ID 'BodyTemplateGUID'    FIELD body_guid
                       ID 'BodyTemplateDBStr'   FIELD c_bodydbstr
         ID 'LastPageHeaderGUID' FIELD last_page_header_guid
         ID 'LastPageBodyGUID'   FIELD last_page_body_guid.
      ELSEIF NOT body_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                       ID 'BodyTemplateGUID'    FIELD body_guid
                       ID 'BodyTemplateDBStr'   FIELD c_bodydbstr
         ID 'LastPageHeaderGUID' FIELD last_page_header_guid
         ID 'LastPageBodyGUID'   FIELD last_page_body_guid.
      ELSEIF NOT header_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                   ID 'HeaderTemplateGUID'  FIELD header_guid
                   ID 'HeaderTemplateDBStr' FIELD c_headerdbstr
         ID 'LastPageHeaderGUID' FIELD last_page_header_guid
         ID 'LastPageBodyGUID'   FIELD last_page_body_guid.
      ELSE.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
             ID 'LastPageHeaderGUID' FIELD last_page_header_guid
             ID 'LastPageBodyGUID'   FIELD last_page_body_guid.
      ENDIF.
    ELSEIF NOT redirect IS INITIAL.
      CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
       ID 'RedirectTemplate'   FIELD redirect
       ID 'RedirectStatus'     FIELD error_page_status
       ID 'LastPageHeaderGUID' FIELD last_page_header_guid
       ID 'LastPageBodyGUID'   FIELD last_page_body_guid.
    ELSE.
      CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
         ID 'LastPageHeaderGUID' FIELD last_page_header_guid
         ID 'LastPageBodyGUID'   FIELD last_page_body_guid.
    ENDIF.
  ELSEIF NOT last_page_redirect IS INITIAL.
* last page as redirect available
    IF kind500 IS INITIAL. "500 message: no redirect active
      IF NOT header_guid IS INITIAL AND
         NOT body_guid   IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
                       ID 'HeaderTemplateGUID'  FIELD header_guid
                       ID 'HeaderTemplateDBStr' FIELD c_headerdbstr
                       ID 'BodyTemplateGUID'    FIELD body_guid
                       ID 'BodyTemplateDBStr'   FIELD c_bodydbstr
           ID 'LastPageRedirect'    FIELD last_page_redirect
           ID 'LastPageRedirectStatus'
                                    FIELD last_page_status.
      ELSEIF NOT body_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
             ID 'BodyTemplateGUID'    FIELD body_guid
             ID 'BodyTemplateDBStr'   FIELD c_bodydbstr
             ID 'LastPageRedirect'    FIELD last_page_redirect.
      ELSEIF NOT header_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
            ID 'HeaderTemplateGUID'  FIELD header_guid
            ID 'HeaderTemplateDBStr' FIELD c_headerdbstr
            ID 'LastPageRedirect'    FIELD last_page_redirect
            ID 'LastPageRedirectStatus'
                                     FIELD last_page_status.
      ELSEIF NOT last_page_redirect IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
            ID 'LastPageRedirect'   FIELD last_page_redirect
            ID 'LastPageRedirectStatus'
                                    FIELD last_page_status.
      ENDIF.
    ELSEIF NOT redirect IS INITIAL.
      CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
        ID 'RedirectTemplate'       FIELD redirect
        ID 'RedirectStatus'         FIELD error_page_status
        ID 'LastPageRedirect'       FIELD last_page_redirect
        ID 'LastPageRedirectStatus' FIELD last_page_status.
    ELSEIF NOT last_page_redirect IS INITIAL.
      CALL 'ICF_DISPATCH' ID 'HTTP'   FIELD 'R'
          ID 'LastPageRedirect'       FIELD last_page_redirect
          ID 'LastPageRedirectStatus' FIELD last_page_status.
    ENDIF.
  ENDIF.

* Installation of Service/Session Not Found
  IF session_not_found_header_guid IS NOT INITIAL OR
     session_not_found_body_guid   IS NOT INITIAL OR
     session_not_found_redirect    IS NOT INITIAL.
    IF kindnfpag IS INITIAL.
* Installation of NotFound haeder or body pages
      IF NOT session_not_found_header_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
              ID 'NotFoundHeaderGUID'  FIELD session_not_found_header_guid.
      ENDIF.

      IF NOT session_not_found_body_guid IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
              ID 'NotFoundBodyGUID'  FIELD session_not_found_body_guid.
      ENDIF.
    ELSE.
* Installation of NotFound redirect
      IF NOT session_not_found_redirect IS INITIAL AND
         NOT session_not_found_redirect_cod IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
            ID 'NotFoundRedirect'   FIELD session_not_found_redirect
            ID 'NotFoundRedirectStatus'
                                    FIELD session_not_found_redirect_cod.
      ELSEIF NOT session_not_found_redirect IS INITIAL.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
            ID 'NotFoundRedirect'   FIELD session_not_found_redirect.
      ENDIF.
    ENDIF.
  ENDIF.

  IF sy-subrc <> 0.
    RAISE installation_error.
  ENDIF.
ENDMETHOD.


method RAISE_EVENT.
endmethod.


METHOD receive_request .

* to be redefined in subclass

*
* clear the execution time for kernel statistic, as this value is valid for
* a request/response phase and must not be accumulated in case of stateful communication
* for the whole request/response phases (as it is with call time in kernel).
*
  CLEAR m_exe_time.

  rc = 0.
ENDMETHOD.


method recorder .
  data: l_rfcsi       type rfcsi.

  data: m_username    type string, "#EC NEEDED
        m_client      type string, "#EC NEEDED
        m_language    type string. "#EC NEEDED
  data: expire_time   type syuzeit.
  data: expire_date   type sydatum.
  data: expire_seconds(8) type p.
  data: sap_recorder  type string.
  data: dummy         type string.
  data: caller_system type sysysid. "#EC NEEDED
  data: remote_guid   type icfrecoder_uuid.
* calculation of expiration time
  data: l_date type sydatum.
  data: l_time type syuzeit.
  data: l_value(8)  type p.
  data: l_day(8)    type p.
  data: expiration_days type i.
  data: expire_timestamp type timestampl.
  data: present_timestamp type timestampl.
  data: icfrec_field  type ihttp_recorder_field.
  data: index         type i.

* -- record request with setting of caller cookie
  if component > ihttp_record_with_cookie.
    component = component - ihttp_record_with_cookie.
  endif.

*-- record request or authentication
  if ( component >= ihttp_record_request_status and
                                                c_authenticated = 0 ) or
     ( component = ihttp_record_failed_auth and c_authenticated = 1 ) or
     ( component < ihttp_record_failed_auth ) or
     ( component >= ihttp_record_last_possibility ).
    clear m_icfrecorder.
    raise disable_recording.
  endif.

* -- record request with setting/accepting of caller cookie
  sap_recorder =
     request->get_header_field( ihttp_c_sap_recorder_sid ).
  if sap_recorder is initial.
    request->get_cookie( exporting name  = ihttp_c_sap_recorder_sid
                         importing value = sap_recorder ).
  endif.
* -- syntax: ,c=<sysid>-<caller_id>-<message_id>-<message_nr>,<x>=...
  if sap_recorder cs ','.
    data: sap_recorder_entries type table of string.
    split sap_recorder at ',' into table sap_recorder_entries.
    loop at sap_recorder_entries into sap_recorder.
      if sap_recorder is not initial.
        if sap_recorder(2) = 'c='.
          sap_recorder = sap_recorder+2(*).
          split sap_recorder at '%-' into
            caller_system c_scope_message_id remote_guid dummy.
          c_scope_message_nr = dummy.
        elseif sap_recorder(2) = 'o='.
* -- ,o=<owner_server>-<owner_client>-<owner_user>
          sap_recorder = sap_recorder+2(*).
          split sap_recorder at '%-' into
            m_icfrecorder-owner_server
            m_icfrecorder-owner_client
            m_icfrecorder-owner_user
            dummy.
        endif.
      endif.
    endloop.
  endif.

  if c_scope_message_id is initial.
    call function 'ICF_CREATE_GUID'
     importing
          id = c_scope_message_id.
    c_scope_message_nr = 0.
  endif.

* -- increment the number for scope message nr for the indexing of request orders
  c_scope_message_nr = c_scope_message_nr + 1.

* -- sending of sap-recoder cookie as message_id-message_nr
  m_icfrecorder-scope_messageid = c_scope_message_id.
  m_icfrecorder-scope_messagenr = c_scope_message_nr.
* -- partner message id
  m_icfrecorder-caller_messageid = remote_guid.

  m_icfrecorder-trace_level = component.
  c_enable_recording = component.

*   my predecessor message
  m_icfrecorder-parent_messageid = c_last_message_id.

* message type 'I' for ICF/Internal
  m_icfrecorder-message_type = 'I'.

* protocol all the activity done on this record
  m_icfrecorder-protocol_action = 'X'.

*   my system id
  m_icfrecorder-system_id    = sy-sysid.
  call function 'ICF_CREATE_GUID'
       importing
            id = c_last_message_id.
  m_icfrecorder-message_id    = c_last_message_id.
  m_parent_message_id         = c_last_message_id.

*   my root message id
  if c_root_message_id is initial.
    c_root_message_id  = m_icfrecorder-message_id.
  endif.
  m_icfrecorder-root_messageid = c_root_message_id.

* inheritance of root message id to client side
  if cl_icf_recorder=>c_root_message_id is initial.
     cl_icf_recorder=>c_root_message_id = c_root_message_id.
* parent message id of client objects
     cl_icf_recorder=>c_last_message_id = c_last_message_id.
  endif.
* successod/predessor message id and number (called caller_message*)
  cl_icf_recorder=>c_scope_message_id = c_scope_message_id.
* client increases its caller message number
  cl_icf_recorder=>c_scope_message_nr = c_scope_message_nr.

* interpretation of c_message_id in http client as m_parent_message_id
  cl_icf_recorder=>c_last_message_id = c_last_message_id.
  case component.
    when ihttp_record_request_status.
      cl_icf_recorder=>c_enable_client_recording = ihttp_record_crequest_status.
    when ihttp_record_request.
      cl_icf_recorder=>c_enable_client_recording = ihttp_record_crequest.
    when ihttp_record_response_status.
      cl_icf_recorder=>c_enable_client_recording =
                                   ihttp_record_cresponse_status.
    when ihttp_record_response.
      cl_icf_recorder=>c_enable_client_recording = ihttp_record_cresponse.
  endcase.

* create once per object it's obkject id
  if m_object_id is initial.
    m_object_id   = m_icfrecorder-message_id.
  endif.
  m_icfrecorder-object_id = m_object_id.

  m_icfrecorder-object_counter = m_counter.

**   present statistic information
   call function 'RFC_SYSTEM_INFO'
    importing
      rfcsi_export            = l_rfcsi.
   m_icfrecorder-logon_server = l_rfcsi-rfcdest.
   m_icfrecorder-logon_client = sy-mandt.
   m_icfrecorder-logon_user   = sy-uname.
   m_icfrecorder-logon_language  = sy-langu.

* get owner data, SICF settings have precedence
  if ( m_icfrecorder-owner_user is initial )
  and not ( icfattrib_entry-cusername is initial ).
    m_icfrecorder-owner_server = icfattrib_entry-server.
    m_icfrecorder-owner_client = icfattrib_entry-client.
    m_icfrecorder-owner_user   = icfattrib_entry-cusername.
  endif.
* if there's no SICF setting, then take the runtime information
  if ( m_icfrecorder-owner_user is initial )
  and not ( cl_icf_recorder=>c_owner_user is initial ).
    m_icfrecorder-owner_server = cl_icf_recorder=>c_owner_server.
    m_icfrecorder-owner_client = cl_icf_recorder=>c_owner_client.
    m_icfrecorder-owner_user = cl_icf_recorder=>c_owner_user.
  endif.

   get time stamp field m_icfrecorder-logon_timestamp.

* inheritance of icfattrib to client side, if did not happen before
  if cl_icf_recorder=>c_icfattrib is initial.
    cl_icf_recorder=>c_icfattrib = icfattrib_entry.
  endif.
* inheritance of owner data to client side
  if ( cl_icf_recorder=>c_owner_user is initial )
  and not ( m_icfrecorder-owner_user is initial ).
    cl_icf_recorder=>c_owner_server = m_icfrecorder-owner_server.
    cl_icf_recorder=>c_owner_client = m_icfrecorder-owner_client.
    cl_icf_recorder=>c_owner_user = m_icfrecorder-owner_user.
  endif.

* request connection parameters
   if ssl_active = co_enabled.
     m_icfrecorder-request_protocol = ihttp_recorder_protocol_https.
   else.
     m_icfrecorder-request_protocol = ihttp_recorder_protocol_http.
   endif.
   m_icfrecorder-request_host =
           request->get_header_field( '~server_name' ).
   m_icfrecorder-request_port =
           request->get_header_field( '~server_port' ).

   m_icfrecorder-reference_tstamp = m_icfrecorder-logon_timestamp.

* -- user-agent
   m_icfrecorder-partner_type = request->get_header_field( 'user-agent' ).

*-- expireation time of this record
   if not expiration_day is initial or
      not expiration_time is initial.
     expire_seconds = ( expiration_day * 86400 ) + expiration_time.
   else.
     select single expire_timestamp
                       from icfrecorder into expire_timestamp
                       where message_id   = ihttp_recorder_exp_msgid and
                             message_type = ihttp_recorder_exp_mstype.
     if sy-subrc = 0.
       convert time stamp expire_timestamp
                  time zone ihttp_c_timezone_utc
                  into date l_date time l_time.
*    number of days
       l_day = l_date.
       l_value = ihttp_recorder_exp_date_basis.
*    date in relation to icfrecorder_exp_date_basis
       expiration_days = l_day - l_value.
       expire_seconds = ( expiration_days * 86400 ) + l_time.
     else.
       expire_seconds = ( ihttp_recorder_def_exp_day * 86400 ) +
                        ihttp_recorder_def_exp_time.
     endif.
   endif.

   get time stamp field present_timestamp.

   m_icfrecorder-expire_timestamp = cl_abap_tstmp=>add(
                                      tstmp = present_timestamp
                                      secs  = expire_seconds ).

   m_icfrecorder-request_path =
       request->get_header_field( '~path_translated' ).
* -- for SICFRECORDER transaction and DB select statements
   translate m_icfrecorder-request_path to lower case. "#EC TRANSLANG

*-- record request or authentication
   if component = ihttp_record_failed_auth and
      c_authenticated    = 0.
      data: status_field(4) type x.
      status_field = m_icfrecorder-status.
      set bit ihttp_recorder_status_logon of status_field.
      m_icfrecorder-status = status_field.
* -- Logon_failed-Feld als Logon kennzeichnen
      m_icfrecorder-logon_failed = 'X'.
* -- register original client (if exists)
        if cl_http_server_net=>c_client is initial.
          call 'C_SAPGPARAM'
               id 'NAME'  field 'login/system_client'
               id 'VALUE' field cl_http_server_net=>c_client.
        endif.
        m_icfrecorder-logon_client = cl_http_server_net=>c_client.
        if m_icfrecorder-logon_client is initial.
         m_icfrecorder-logon_client = sy-mandt.
        endif.
* -- register original user (if exists)
        if not cl_http_server_net=>c_user is initial.
          m_icfrecorder-logon_user = cl_http_server_net=>c_user.
          translate m_icfrecorder-logon_user
                      to upper case .  "#EC SYNTCHAR

        endif.
   elseif component >= ihttp_record_request.
* -- security relevant fields are already removed after authentication
     m_icfrecorder-request = request->get_raw_message( ).
   endif.

* virtual host choice
   m_icfrecorder-request_vhost = c_virtual_host.

* stateful session
   if stateful = co_enabled.
     m_icfrecorder-stateful = 'X'.
   endif.

   index = 1.
   icfrec_field-range = ihttp_recorder_field_range_sol.
   if m_request_body_length > 0.
     icfrec_field-index = index.
     icfrec_field-name  = 'REQUEST_BODY_LENGTH'.
     icfrec_field-value = m_request_body_length.
     append icfrec_field to m_icfrecorder_fields.
     add 1 to index.
   endif.

   if m_request_header_length > 0.
     icfrec_field-index = index.
     icfrec_field-name  = 'REQUEST_HEADER_LENGTH'.
     icfrec_field-value = m_request_header_length.
     append icfrec_field to m_icfrecorder_fields.
     add 1 to index.
   endif.

   if m_icfrecorder-request is not initial.
     icfrec_field-index = index.
     icfrec_field-name  = 'DATABASE_REQUEST_LENGTH'.
     icfrec_field-value = xstrlen( m_icfrecorder-request ).
     append icfrec_field to m_icfrecorder_fields.
     add 1 to index.
   endif.

   m_username               = sy-uname.
   m_client                 = sy-mandt.
   m_language               = sy-langu.


endmethod.


method refresh_response.
  data: c_msg type %_c_pointer.
  data: http_response type ref to cl_http_response.
  data: m_last_error type i.

  system-call ict
    did
      ihttp_scid_create_message
    parameters
      2                              " > message type (2 = resp)
      c_msg                          " < c handle
      m_last_error.                  " < return code

  if m_last_error <> 0.
    raise action_failed.
  endif.

  http_response ?= response.
  http_response->set_c_msg( c_msg ).
endmethod.


method remove_extension_entries.
  if not server_name is initial.
*   remove registered extension associated with to this server object
    delete http_ext_instances where server_name = server_name.
  endif.
endmethod.


METHOD replace_page_token.
  DATA: itab TYPE TABLE OF string,
         form TYPE string,
         rest TYPE string,
         token TYPE string.
  DATA: l_fields TYPE tihttpnvp.

  CLASS cl_http_utility DEFINITION LOAD.

  IF page CS '<%=SY'.
    REPLACE ALL OCCURRENCES OF '<%=SYUNAME%>'
             IN page WITH sy-uname.

    REPLACE ALL OCCURRENCES OF '<%=SYMANDT%>'
             IN page WITH sy-mandt.

    REPLACE ALL OCCURRENCES OF '<%=SYLANGU%>'
           IN page WITH sy-langu.

    REPLACE ALL OCCURRENCES OF '<%=SYHOST%>'
           IN page WITH sy-host.
    REPLACE ALL OCCURRENCES OF '<%=SYSYSID%>'
           IN page WITH sy-sysid.
    REPLACE ALL OCCURRENCES OF '<%=SYOPSYS%>'
           IN page WITH sy-opsys.
    REPLACE ALL OCCURRENCES OF '<%=SSYDBSYS%>'
           IN page WITH sy-dbsys.
    REPLACE ALL OCCURRENCES OF '<%=SYSAPRL%>'
           IN page WITH sy-saprl.
    REPLACE ALL OCCURRENCES OF '<%=SYDATUM%>'
           IN page WITH sy-datum.
    REPLACE ALL OCCURRENCES OF '<%=SYUZEIT%>'
           IN page WITH sy-uzeit.
    REPLACE ALL OCCURRENCES OF '<%=SYMSGV1%>'
           IN page WITH sy-msgv1.
    REPLACE ALL OCCURRENCES OF '<%=SYMSGV2%>'
           IN page WITH sy-msgv2.
    REPLACE ALL OCCURRENCES OF '<%=SYMSGV3%>'
           IN page WITH sy-msgv3.
    REPLACE ALL OCCURRENCES OF '<%=SYMSGV4%>'
           IN page WITH sy-msgv4.
    REPLACE ALL OCCURRENCES OF '<%=SYREPID%>'
           IN page WITH sy-repid.
    REPLACE ALL OCCURRENCES OF '<%=SYTCODE%>'
           IN page WITH sy-tcode.
    REPLACE ALL OCCURRENCES OF '<%=SYXPROG%>'
           IN page WITH sy-xprog.
    REPLACE ALL OCCURRENCES OF '<%=SYXFORM%>'
           IN page WITH sy-xform.
  ENDIF.

  IF page CS '<%=PATHTRANS%>'.
    form = request->get_header_field( '~path_translated' ).
* --
* escaping of path_translated, for escapping of special character
*  such as & (refering to Bernhard Braun), if these are part of path
* note: url escaping must be done only in cases where '<%=PATHTRANS%>'
*       is in the query string and as form field
* --
    IF set_ffield_name IS SUPPLIED.
      DATA: prefix  TYPE string,                            "#EC NEEDED
            postfix TYPE string.
      IF page CS '?'.
        SPLIT page AT '?' INTO prefix postfix.
        IF postfix CS '<%=PATHTRANS%>'.
* Use new ABAP XSS Escaping library (see sap note 1644634)
*          form = cl_http_utility=>escape_url( unescaped = form ).
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_url ).
        ENDIF.
      ENDIF.
    ENDIF.

    REPLACE ALL OCCURRENCES OF '<%=PATHTRANS%>'
           IN page WITH form.
  ENDIF.

* --
* Appending form fields to the document, for redirect and parameter
* set_ffield_name <> space with name sap-ffield_b64
* --
  IF page CS '<%=FORMFIELD' OR
     NOT set_ffield_name IS INITIAL.
* --
*  delete sap-client, sap-user and sap-client, to avoid
*  duplicate settings of form fields in path, becauso of multiple
*  redirects with <%=FORMFIELD%> or <%=FORMFIELD_B64%>
* --
    request->delete_form_field( name = 'SAP-Client' ).      "#EC NOTEXT
    request->delete_form_field(
                name = 'SAP-User' ).                        "#EC NOTEXT
    request->delete_form_field(
                name = 'SAP-Language' ).                    "#EC NOTEXT

    CALL METHOD request->get_form_fields
      CHANGING
        fields = l_fields.

    IF page CS '<%=FORMFIELD%>' OR
       set_ffield_name = '1'.

* -- plain text + URL escaping
      form = cl_http_utility=>fields_to_string(
            fields  = l_fields
            encode  = 0 ).

* -- serialization in URL or body (see PREPARE_OTR_DOCUMENT method)
      IF set_ffield_name IS SUPPLIED.
* -- serialization in URL
*        form = cl_http_utility=>escape_url(
*        unescaped  = form ).
        form = escape( val    = form
                       format = cl_abap_format=>e_xss_url ).
      ELSE.
* -- serialization in body
*        form = cl_http_utility=>escape_html(
*        unescaped  = form ).
        form = escape( val    = form
                       format = cl_abap_format=>e_xss_ml ).
      ENDIF.

* -- set form field name in document as plain text
      IF page CS '<%=FORMFIELD%>'.
        REPLACE ALL OCCURRENCES OF '<%=FORMFIELD%>'
               IN page WITH form.
      ENDIF.

* -- set form field name for redirect as plain text
      IF set_ffield_name = '1'.
        IF page CS '?'.
          CONCATENATE page '&' cl_http_server=>co_form_field '='
                   form INTO page.
        ELSE.
          CONCATENATE page '?' cl_http_server=>co_form_field '='
                   form INTO page.
        ENDIF.
      ENDIF.
    ENDIF.

    IF page CS '<%=FORMFIELD_B64%>' OR
       set_ffield_name = '2'.
* -- base 64 encoded for redirect (set_form_field_name) or token
      form = cl_http_utility=>fields_to_string(
         fields  = l_fields
         encode  = 1 ).

* -- set form field name in document as plain text
      IF page CS '<%=FORMFIELD_B64%>'.
        REPLACE ALL OCCURRENCES OF '<%=FORMFIELD_B64%>'
            IN page WITH form.
      ENDIF.

* -- set form field name for redirect with base64 encoding
      IF set_ffield_name = '2'.
        IF page CS '?'.
          CONCATENATE page '&' cl_http_server=>co_form_field_b64 '='
                   form INTO page.
        ELSE.
          CONCATENATE page '?' cl_http_server=>co_form_field_b64 '='
                   form INTO page.
        ENDIF.
      ENDIF.
    ENDIF.

* -- set EPP info in document as plain text
    IF page CS '<%=EPP_'.
      DATA: lv_rid     TYPE epp_root_context_id,
            lv_cid     TYPE epp_connection_id,
            lv_ccnt    TYPE epp_connection_counter,
            lv_tid     TYPE epp_transaction_id,
            lv_epp_hlp TYPE string.
      CALL METHOD get_epp_context_ids
        IMPORTING
          root_context_id    = lv_rid
          connection_id      = lv_cid
          connection_counter = lv_ccnt
          transaction_id     = lv_tid
        EXCEPTIONS
          epp_error          = 1.

      IF page CS '<%=EPP_CTX%>'.
        lv_epp_hlp = |{ lv_rid }_{ lv_cid }_{ lv_ccnt }|.
        REPLACE ALL OCCURRENCES OF '<%=EPP_CTX%>' IN page WITH lv_epp_hlp.
      ENDIF.

      IF page CS '<%=EPP_RID%>'.
        REPLACE ALL OCCURRENCES OF '<%=EPP_RID%>' IN page WITH lv_rid.
      ENDIF.

      IF page CS '<%=EPP_CID%>'.
        REPLACE ALL OCCURRENCES OF '<%=EPP_CID%>' IN page WITH lv_cid.
      ENDIF.

      IF page CS '<%=EPP_CCNT%>'.
        lv_epp_hlp = lv_ccnt.
        REPLACE ALL OCCURRENCES OF '<%=EPP_CCNT%>' IN page WITH lv_epp_hlp.
      ENDIF.

      IF page CS '<%=EPP_TID%>'.
        REPLACE ALL OCCURRENCES OF '<%=EPP_TID%>' IN page WITH lv_tid.
      ENDIF.
    ENDIF.


  ENDIF.

* -- Appending content page to the document
  IF page CS '<%=CDATA%>'.
    form = request->get_cdata( ).
    REPLACE ALL OCCURRENCES OF '<%=CDATA%>' IN page WITH form.
  ENDIF.

  IF page CS '<%=FORM_'.
    SPLIT page AT '<%=FORM_' INTO TABLE itab.
    LOOP AT itab INTO form.
      IF form CS '%>'.
        SPLIT form  AT '%>' INTO token rest.
        form = request->get_form_field( name = token ).
        CONCATENATE '<%=FORM_' token '%>' INTO rest.
        REPLACE ALL OCCURRENCES OF rest IN page WITH form.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF page CS '<%=HEADER_'.
    SPLIT page AT '<%=HEADER_' INTO TABLE itab.
    LOOP AT itab INTO form.
      IF form CS '%>'.
        SPLIT form  AT '%>' INTO token rest.
        form = request->get_header_field( name = token ).
        CONCATENATE '<%=HEADER_' token '%>' INTO rest.
        REPLACE ALL OCCURRENCES OF rest IN page WITH form.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDMETHOD.


method RETRIEVE_CERTIFICATE .

  call 'ICF_DISPATCH' id 'HTTP' field 'c'
     id 'SslCertificate'  field document.
  if sy-subrc <> 0.
* -- subrc = 101, 102: no http server context
* -- subrc = 103: no certificate available
* -- subrc = 104: system call used unapropriately
* -- subrc = 201: Taskhandler error -> no certificate available
* -- subrc = 105: Memory mangement problems
      raise no_certificate_available.
  endif.

endmethod.


method send_recorder_caller_id.
*
* -- sending of caller message id/nr to find the associated
* -- request and response recorder entries
*
  if not c_enable_recording is initial and
     not c_scope_message_id is initial.
     data: domain             type string.
     data: user_agent_type    type i,
           user_agent_version type i. "#EC NEEDED
     data: message_id         type string.
     data: sap_recorder_entries type table of string.
     data: sap_recorder       type string.
     data: l_rec_owner        type string.
     data: l_rec_message_nr   type string.
     Data: l_secure_id        type i.

* send sap-recorder cookie as message_id"-"message_nr
* use client message nr, in case of processing of
* next message is the successor
* client caller message number = present server message number + 1
     if cl_icf_recorder=>c_scope_message_nr > c_scope_message_nr.
* if client requests has been done, adopt the message nr sequence
       c_scope_message_nr = cl_icf_recorder=>c_scope_message_nr.
     endif.
     message_id = c_scope_message_nr.
* -- ,c=<sysid>-<caller_id>-<message_id>-<message_nr>
     concatenate ',c='
                 sy-sysid            '%-'
                 c_scope_message_id '%-'
                 space               '%-'
                 message_id
                 into l_rec_message_nr.

     concatenate',o='
                 m_icfrecorder-owner_server '%-'
                 m_icfrecorder-owner_client '%-'
                 m_icfrecorder-owner_user
                 into l_rec_owner.

     concatenate l_rec_message_nr l_rec_owner into message_id.

     condense message_id no-gaps.
     request->get_user_agent( importing
                              user_agent_type = user_agent_type
                              user_agent_version = user_agent_version ).
     if user_agent_type = 3.
* client request from SAP Web Application Server
       response->set_header_field( name = ihttp_c_sap_recorder_sid
                                   value = message_id ).
     else.
       data: dummy type string.
* client request from browser
       domain = request->get_header_field( '~server_name' ).
       if domain cs '.'.
         split domain at '.' into dummy domain.
       endif.

       if user_agent_type = 1.
          concatenate '.' domain into domain.
       endif.

* append/replace own entry into exisiting recorder_entries
       request->get_cookie( exporting name  = ihttp_c_sap_recorder_sid
                            importing value = sap_recorder ).
       if sap_recorder is initial.
        dummy = message_id.
       else.
         clear dummy.
         split sap_recorder at ',' into table sap_recorder_entries.
         loop at sap_recorder_entries into sap_recorder.
          if sap_recorder is not initial.
             if sap_recorder(2) = 'c='.
* overwrite ",c=<sysid>-<caller_id>-<message_id>-<message_nr>"
               concatenate dummy l_rec_message_nr into dummy.
              else.
               concatenate dummy ',' sap_recorder into dummy.
             endif.
          endif.
         endloop.
       endif.

* set Httponly-Attribute
       case c_httponly_flag.
         when '0' or '1'.
           l_secure_id = 16.
         when others.
           l_secure_id = 0.
       endcase.

       response->set_cookie( name   = ihttp_c_sap_recorder_sid
                             path   = '/'
                             value  = dummy
                             domain = domain
                             secure = l_secure_id ).
     endif.
  endif.
endmethod.


METHOD send_response .
  DATA: etime    TYPE i.
  DATA: dummy    TYPE string.
  DATA: myinfo   TYPE string.
  DATA: l_client TYPE string.

*
* delete sap-contextid at the client side, if this exits before
*
  IF stateful = if_http_server~co_disabled AND
     stateful <> c_stateful_ref.
    CALL METHOD response->delete_cookie_at_client( name = 'sap-contextid' ).
    set_session_stateful( stateful = if_http_server~co_disabled ).
  ENDIF.

* -- send server version
*
* Security Issue: The haeder field server should be customizable and can be decided by customer
*                 in which form this header should be specified and set.
*
* Remark (meeting with O. Luik):
* es war damals die Absprache mit den AS Java Kollegen, daß der server-Header so aussehen sollte:
* server: $(is/server_name) $(is/server_version) [/ <Komponente> <Komponentenversion>]
* Der AS Java antwortet (mit der Defaultkonfiguration) im BIN mit diesem Header:
* server: SAP NetWeaver Application Server 7.20 / AS Java 7.11
* Bei responses vom ICM (z.B. Fehlerseiten) wir der Header so gesetzt:
* server: SAP NetWeaver Application Server 7.20 / ICM 7.20
*
* Wenn Der wert der Profilparameter is/HTTP/show_server_header = true (<> false) so wird server header gesetzt.
* Wenn is/HTTP/server_header keinen Wert hat, wird ICF spezifischer Wert gesetzt, ansonsten, der Text, der in Profil is/HTTP/server_header
* gesetzt ist.
*

  IF c_is_show_server_header IS INITIAL OR
     c_is_show_server_header = 'true'.
    IF c_is_server_header IS INITIAL.
      CONCATENATE 'SAP NetWeaver Application Server / ABAP' sy-saprl INTO myinfo SEPARATED BY space. "#EC NOTEXT
    ELSE.
      myinfo = c_is_server_header.
    ENDIF.
  ENDIF.
  IF myinfo IS NOT INITIAL.
    CALL METHOD response->set_header_field(
        name  = 'server'                                      "#EC NOTEXT
        value = myinfo ).
  ENDIF.

*
* In case of logoff the cookie sap-usercontext will be removed, therefore no
* setting of the cookie is necessary
*
  IF m_logoff IS INITIAL.
* serialize user context information out to client if necessary
    l_client = cl_http_server_net=>c_client. "client which has been determined from authentication method
* Method serialize will update the client attribute in class
* cl_http_user_context
    cl_http_user_context=>serialize( response = response
                                     client   = l_client ).
  ENDIF.

*
* -- sending of caller message id/nr to find the associated
* -- request and response recorder entries
*
  IF NOT c_enable_recording IS INITIAL AND
     NOT c_scope_message_id IS INITIAL.
    send_recorder_caller_id( ).
  ENDIF.


*
* Do not transfer any proprietary header fields in context of a webservice response
*
  IF webservice_response = abap_false.
* -- statistic
    IF c_accept_remote_profile_level > 0.
      DATA: t_time TYPE string.
      DATA: e_time TYPE string.

* -- server statistic: execution of request [start read, start write]
      etime = m_timer->get_runtime( ).
*   get run time field etime.

      m_total_time = ( etime - m_total_time ) / 1000.
      e_time = m_exe_time / 1000.
      t_time = m_total_time.

* -- does any entries exists in sap-statistic (done by ICMAN)
      dummy = response->get_header_field( name = 'sap-statistic' ).
      IF dummy IS INITIAL.
        CONCATENATE 'e=' e_time ',t=' t_time INTO dummy.
      ELSE.
        CONCATENATE dummy ',e=' e_time ',t=' t_time INTO dummy.
      ENDIF.

      response->set_header_field( name = 'sap-statistic'
                                  value = dummy ).
    ENDIF.
  ENDIF.

*  dummy = request->get_header_field( ihttp_c_sap_recorder ).
*  if dummy is not initial and
*     stateful = if_http_server~co_enabled.
*     response->set_header_field( name = ihttp_c_sap_recorder
*                                 value = session_id ).
*  endif.

* to be redefined in subclass

ENDMETHOD.


method send_service_not_found.
  data: rc        type i.
  data: _entity   type ref to cl_http_entity,
        c_msg     type %_c_pointer,
        conn_name type string.
  data: l_redirect type string.


  _entity  ?= response.
  c_msg     = _entity->m_c_msg.
  conn_name = 'Me'.


* do not send the page directly since post processing
* steps in cl_http_server_net->send_response method
* are necessary (e. g. deleting of session cookies)

  if page_attributes  is initial or
     ( page_attributes-kind     is initial and
       page_attributes-header   is initial and
       page_attributes-body     is initial ) or
     ( page_attributes-kind     is not initial and
       page_attributes-redirect is initial ).
     default_not_found_page( status_code   = status_code
                             status_reason = status_reason ).
  elseif page_attributes-kind is initial.
* -- read OTR body template
    system-call plugin
        id 'HTTP'       value 'SendPageAndReturn' "#EC NOTEXT
        id 'Name'       value conn_name
        id 'NoSend'     value 'Y'
        id 'LastPageHeaderGUID' value page_attributes-header
        id 'LastPageBodyGUID'   value page_attributes-body
        id 'MessageOut' value c_msg
        id 'RC'         value rc.
  else.
      l_redirect = page_attributes-redirect.
      system-call plugin
        id 'HTTP'       value 'SendPageAndReturn' "#EC NOTEXT
        id 'Name'       value conn_name
        id 'NoSend'     value 'Y'
        id 'RedirectTemplate' value l_redirect
        id 'MessageOut'       value c_msg
        id 'RC'               value rc.
  endif.

endmethod.


method server_cache_invalidate .

  clear c_last_error.
  call function 'ICM_CACHE_INVALIDATE_ONE'
    exporting
      name    = id
      coption = type
      global  = scope
    exceptions icm_op_failed       = 1
               icm_get_serv_failed = 2
               icm_no_http_service = 3
               others              = 4.
  if sy-subrc <> 0.
    " life is hard
    c_last_error = 1000 + sy-subrc.
  endif.

endmethod.


method server_cache_invalidate_all .

  clear c_last_error.
  call function 'ICM_CACHE_INVALIDATE_ALL'
    exporting
      global  = scope
    exceptions icm_op_failed       = 1
               icm_get_serv_failed = 2
               icm_no_http_service = 3
               others              = 4.
  if sy-subrc <> 0.
    " life is hard
     c_last_error = 1000 + sy-subrc.
  endif.

endmethod.


method SERVER_CACHE_INVALIDATE_LIST .

  clear c_last_error.
  call function 'ICM_CACHE_INVALIDATE_ENTRIES'
    exporting
      entries = list
      global  = scope
    exceptions icm_op_failed       = 1
               icm_get_serv_failed = 2
               icm_no_http_service = 3
               others              = 4.
  if sy-subrc <> 0.
    " life is hard
    c_last_error = 1000 + sy-subrc.
  endif.

endmethod.


method SERVER_CACHE_UPLOAD .

  DATA: cache_data TYPE XSTRING.

  clear c_last_error.
  cache_data = response->to_xstring( ).

  IF virtual_host IS NOT SUPPLIED.
*   default virtual host number ( 0 ) is used if a specific cache is not addressed
*   by specifing host and port of the virtual host within the url parameter
    CALL FUNCTION 'ICM_CACHE_UPLOAD'
    EXPORTING
      URL                       = URL
      DATA                      = cache_data
      GLOBAL                    = scope
    EXCEPTIONS
      ICM_OP_FAILED             = 1
      ICM_GET_SERV_FAILED       = 2
      ICM_NO_HTTP_SERVICE       = 3
      OTHERS                    = 4.
  ELSE.
*   use the specified virtual host or take default virtual host from request
    IF virtual_host EQ IHTTP_VHOST_FROMREQ.
      virtual_host = c_virtual_host.
    ENDIF.

    CALL FUNCTION 'ICM_CACHE_UPLOAD'
      EXPORTING
        URL                       = URL
        DATA                      = cache_data
        GLOBAL                    = scope
        VIRT_HOST_IDX             = virtual_host
      EXCEPTIONS
        ICM_OP_FAILED             = 1
        ICM_GET_SERV_FAILED       = 2
        ICM_NO_HTTP_SERVICE       = 3
        OTHERS                    = 4.
  ENDIF.

  IF SY-SUBRC <> 0.
    c_last_error = 1000 + sy-subrc.  " life is hard
  ENDIF.

endmethod.


method set_entity_message.
   entity_object->set_c_msg( message_object ).
endmethod.


METHOD set_gui_script_hdr_fields.

  DATA:itab_servtbl    TYPE icfservtbl.
  DATA:wa_servtbl      TYPE icfhandlst.
  DATA:line            TYPE i.
  DATA:wa_handler      TYPE icfhandler.
  DATA:its_flag(1)     TYPE c value abap_false.

  clear gui_script_name.
  clear gui_script_name_expanded.

  LOOP AT servtbl INTO wa_servtbl
                  WHERE pathfields-exp_script_name IS NOT INITIAL.
    APPEND wa_servtbl TO itab_servtbl.
  ENDLOOP.

  TRY .
      DESCRIBE TABLE itab_servtbl LINES line.

      IF line > 1.
* check if GUI enabled
        READ TABLE itab_servtbl INDEX line INTO wa_servtbl.

        IF  wa_servtbl-service-icfguilnk EQ 'Y'.

* check if a handler of ITS 'CL_HTTP_EST_ITS' integrated
* Set Headerfields
          LOOP AT wa_servtbl-handlertbl INTO wa_handler.
            IF wa_handler-icfhandler EQ 'CL_HTTP_EXT_ITS'.
             its_flag = abap_true.
            ENDIF.
          ENDLOOP.

          IF its_flag EQ abap_true.
            server->request->set_header_field(
               name ='~gui_script_name'
               value = wa_servtbl-pathfields-orig_script_name ).

            server->request->set_header_field(
                 name  = '~gui_script_name_expanded'
                 value = wa_servtbl-pathfields-exp_script_name ).
* fill out parameter.
            gui_script_name =
                       wa_servtbl-pathfields-orig_script_name.
            gui_script_name_expanded =
                       wa_servtbl-pathfields-exp_script_name.
          ENDIF.

        ENDIF.
      ENDIF.

    CATCH cx_root.
      RAISE  internal_error.
  ENDTRY.

ENDMETHOD.


METHOD set_path_segments_to_handler.

  DATA: l_len          TYPE i.
  DATA: l_service_path TYPE icfrequest_path.
  DATA: l_result_str   TYPE string.

  CLEAR path_seg_to_curr_handler.

  TRY.
      cl_admin_service_processing=>get_service_path(
        EXPORTING
          iv_service_name             =  icf_name  " Name of a Service in Internet Communication Framework
          iv_icfparguid               =  icfparguid   " GUID of Parent Node
        IMPORTING
          ev_service_path             =  l_service_path ).  " Path of ICF Request
    CATCH cx_admin_service_processing ##NO_HANDLER.
      RETURN.
  ENDTRY.

* Double Check
  FIND FIRST OCCURRENCE OF path_seg_to_pre_handler IN l_service_path
           IN CHARACTER MODE IGNORING CASE
           MATCH LENGTH l_len.
  IF sy-subrc EQ 0.
    l_result_str = l_service_path+l_len(*).
  ELSE.
    RETURN.
  ENDIF.

  path_seg_to_curr_handler = l_result_str.

ENDMETHOD.


method set_service_extensions .
  if runtime_attributes-actlogin-icf_custstr is not initial.
    m_extension_container = runtime_attributes-actlogin-icf_custstr.
  endif.
endmethod.


method statistic_begin .
* ...
    if c_statistic_state <> 0.
      call function 'PF_OPEN_INTERVAL'
        exporting key = tag.
    endif.
endmethod.


method STATISTIC_END .
* ...
 " data: time type i.
 "   read table statistic_table with key tag = tag into statistic_wa.
 "   if sy-subrc = 0.
 "    get run time field time.
 "    statistic_wa-time = time - statistic_wa-time.
 "    modify table statistic_table from statistic_wa.
 "   endif.
    if c_statistic_state <> 0.
      call function 'PF_CLOSE_INTERVAL'
        exporting key = tag.
    endif.
endmethod.


method TIMEOUT .
* ...
" set timeout for auto logout of this session
     call 'RFCControl' id 'CODE' field 't'
                       id 'HTTP' field 'l'
                       id 'Timeout' field time.

endmethod.


method trace .
* ...
if cl_http_server=>c_trace       = 1 or
   cl_http_server=>c_trace_force = 1.
      clear l_trace.
  "   concatenate 'HTTP Application[' sy-uzeit ']' "#EC NOTEXT
      concatenate 'HTTP Application> '             "#EC NOTEXT
                                     line into l_trace
                                     separated by space.
      call 'ICF_DISPATCH' id 'HTTP' field 'T'
                          id 'Trace' field l_trace.
                     "     id 'Force' field c_trace_force.
endif.
endmethod.


method _APPEND_STRING_TO_XSTRING .

  call 'ICT_DISPATCH' id 'did'    field 'append_string_to_xstring'
                      id 'source' field source
                      id 'dest'   field dest.

endmethod.


method _APPEND_XSTRING_TO_STRING .

  call 'ICT_DISPATCH' id 'did'    field 'append_xstring_to_string'
                      id 'source' field source
                      id 'dest'   field dest.

endmethod.
ENDCLASS.