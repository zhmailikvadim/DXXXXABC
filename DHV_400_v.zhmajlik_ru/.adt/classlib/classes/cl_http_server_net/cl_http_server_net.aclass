class CL_HTTP_SERVER_NET definition
  public
  inheriting from CL_HTTP_SERVER
  final
  create public

  global friends CL_APC_MANAGER
                 CL_AUTHENTICATION_PROVIDER
                 CL_HTTP_SERVER .

public section.
  class CL_HTTP_USER_CONTEXT definition load .

  aliases AUTHMETHOD_OAUTH
    for IF_HTTP_SERVER~AUTHMETHOD_OAUTH .

  class-data CO_SSOLIST type STRING value 'sap-ssolist' ##NO_TEXT.
  class-data C_AUTHENTICATION_METHOD_POOL type I .
  class-data C_CLIENT type SYMANDT read-only .
  class-data C_ICFX_LOGIN_IN_PROCESSING type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  class-data C_LANGU type SYLANGU read-only .
  data C_SAPRC type SYSUBRC read-only .
  data C_SUBRC type SYSUBRC read-only .
  data M_COMPRESSION_DONE type ABAP_BOOL read-only .
  data M_SEC_SESSION_RESTRICTIONS type NO_SESSION_MANAGEMENT read-only value SPACE ##NO_TEXT.
  data M_SEND_RESPONSE_RETURN_CALLED type ABAP_BOOL read-only .
  class-data POOLED_SESSION type I .

  methods CONSTRUCTOR .
  methods DELETE_SECURITY_FIELDS .
  methods CREATE_ENTITY_OBJECTS .
  methods REAUTHENTICATION
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVTBL type ICFSERVTBL
      !SERVICE type ICFLOGIN
      !EXPECTED_USER_ID type SYUNAME optional
    exporting
      !SAME_USER_ACCOUNT type ABAP_BOOL .
  methods REAUTHENTICATION_SEC_SESSION
    importing
      !SECURITY_SESSION_ID type STRING optional
    returning
      value(VALIDITY_SEC_SESSION) type ABAP_BOOL .
  methods REAUTHENTICATION_REQUIRED
    importing
      !SERVICE type ICFLOGIN
    returning
      value(REQUIRED_TYPE) type I .
  methods SET_LOGIN_STRUCTURE
    importing
      !SERVICE type ICFLOGIN .
  methods REAUTHENTICATION_ACCESS_TOKEN
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVTBL type ICFSERVTBL
      !SERVICE type ICFLOGIN
      !SESSION_ACCESS_TOKEN type STRING
    exporting
      !ACCESS_GRANTED type ABAP_BOOL .
  methods CONFIRM_USERSWITCH
    returning
      value(SECURITY_SESSION_CREATED) type ABAP_BOOL
    exceptions
      ILLEGAL_CALLER .

  methods AUTHENTICATION
    redefinition .
  methods DELETE_SSO_COOKIE_AT_CLIENT
    redefinition .
  methods IF_HTTP_SERVER~ENABLE_FOREIGN_SESSION_ACCESS
    redefinition .
  methods IF_HTTP_SERVER~GET_XSRF_TOKEN
    redefinition .
  methods IF_HTTP_SERVER~LOGOFF
    redefinition .
  methods IF_HTTP_SERVER~SEND_PAGE
    redefinition .
  methods IF_HTTP_SERVER~SET_COMPRESSION
    redefinition .
  methods IF_HTTP_SERVER~SET_PAGE
    redefinition .
  methods IF_HTTP_SERVER~VALIDATE_XSRF_TOKEN
    redefinition .
  methods RAISE_EVENT
    redefinition .
  methods RECEIVE_REQUEST
    redefinition .
  methods RECORDER
    redefinition .
  methods SEND_RESPONSE
    redefinition .
protected section.

  class-methods READ_OTR_DOCUMENT
    importing
      !GUID type SOTR_CONC
    exporting
      !DOCUMENT type STRING
    exceptions
      DOCUMENT_NOT_FOUND .
private section.

  types:
    logon_order_table TYPE STANDARD TABLE OF string .
  types:
    BEGIN OF gt_session_access_reg_entry,
        session_access_token  TYPE string, "Zugriffs-Token f√ºr die Stateful-Session
        url_path              TYPE string, "URL-Pfad (als Blatt-Service) in der Transaktion SICF
        user_id               TYPE syuname,
        one_time_access_token TYPE abap_bool,
        marked_for_deletion   TYPE abap_bool,  "note 1658516
        END OF gt_session_access_reg_entry .

  data M_ACCESS_POLICY_SENT type SAP_BOOL value ABAP_FALSE ##NO_TEXT.
  constants CO_CCTOKEN_REJECT type CHAR4 value ';c=' ##NO_TEXT.
  constants CO_INVALID_TOKEN_REJECT type CHAR4 value ';x=' ##NO_TEXT.
  constants CO_SPNEGO_REQUESTED_COOKIE type STRING value 'SPNegoTokenRequested' ##NO_TEXT.
  constants CO_SPNEGO_TOKEN_REJECT type CHAR4 value ';s=' ##NO_TEXT.
  constants CO_SSOTOKEN_REJECT type CHAR4 value ';r=' ##NO_TEXT.
  class-data C_DELETE_SSO2_COOKIE type I .
  class-data C_SECOND_LANGU type SYLANGU .
  data:
    c_session_access_registry  TYPE SORTED TABLE OF gt_session_access_reg_entry WITH UNIQUE KEY session_access_token .
  class-data C_USER type SYUNAME .
  class-data HTTP_EXT_INSTANCES type IHTTP_EXT_INSTANCES .
  data M_ACTLOGIN type ICFLOGIN .
  data M_CONNECTION_ID type SYSUUID_C .
  data M_DEL_SECURITY_FIELDS_CALLED type ABAP_BOOL .
  data M_LAST_PAGE_ALREADY_PROCESSED type ABAP_BOOL .
  data M_RECORDER_FAILED_LOGON type ICFRECODER_LOGON .
  data M_SECURITY_SESSION_ACTIVE type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data M_SECURITY_SESSION_CREATED type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data M_SEC_SESSION_PENDING_LOCAL type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data M_SEC_SESSION_PENDING_TRUSTED type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data M_SEND_PAGE_IS_CALLED type ABAP_BOOL .
  data M_TRACE type STRING .
  data M_WS_SECURITY_LOGON_DONE type ABAP_BOOL .
  data M_XSRF_COOKIE_CREATED type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data M_XSRF_COOKIE_VALUE type STRING .
  data M_XSRF_TOKEN_COPY type STRING .
  data M_XSRF_TOKEN_FROM_SEC_CONTEXT type SECURITY_CONTEXT_XSRF_TOKEN .

  methods PROTOCOL_XSRF_DETECTION .
  methods WS_SECURITY_AUTHN_RESULT
    importing
      !AUTHENTICATION_METHOD type I
      !AUTHENTICATION_SUCCEEDED type ABAP_BOOL
    exceptions
      LOGON_NOT_COMPLETED
      INFORMATION_MISMATCH .
  class-methods CREATE_LOGIN_XSRF_TOKEN
    exporting
      !COOKIE_VALUE type STRING
      !FORMFIELD_VALUE type STRING
    exceptions
      INTERNAL_ERROR
      SECSTORE_ERROR .
  class-methods VALIDATE_LOGIN_XSRF_TOKEN
    importing
      !COOKIE_VALUE type STRING
      !FORMFIELD_VALUE type STRING
    returning
      value(RESULT) type ABAP_BOOL
    exceptions
      INTERNAL_ERROR
      SECSTORE_ERROR .
  methods GET_SEC_SESSION_ID_FROM_COOKIE
    returning
      value(SEC_SESSION_ID) type STRING .
  methods SET_SECURITY_SESSION_COOKIE .
  methods GET_CLIENT
    importing
      !SERVICE type ICFLOGIN .
  class-methods LOGON_TRACE
    importing
      !REQUEST type ref to IF_HTTP_REQUEST
      !METHOD type I
      !SAPRC type C
      !SUBRC type C
    changing
      !TRACE type STRING .
  methods GET_XSRF_COOKIE
    returning
      value(XSRF_COOKIE) type STRING .
  class-methods REPLACE_LOGON_TOKEN
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SET_FFIELD_NAME type C default ''
    changing
      !DATA type STRING .
  methods SET_XSRF_COOKIE .
  class-methods SECURITY_REQUEST
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVICE type ICFLOGIN
      !REPLY_CLIENT type SYMANDT .
  methods BASIC_AUTHENTICATION_SCREEN
    importing
      !AUTHSTRING type STRING
      !SERVER type ref to IF_HTTP_SERVER
      !SERVICE type ICFLOGIN
      !REPLY_CLIENT type SYMANDT
      !DATA type STRING
      !NO_BASIC_AUTHENTICATION type I .
  class-methods PREPARE_OTR_DOCUMENT
    importing
      !SERVER type ref to IF_HTTP_SERVER
      !SERVICE type ICFLOGIN
      !LOGON_ORDER type LOGORDER
      !FORCE_LOGIN type ABAP_BOOL default ABAP_FALSE
      !WEBGUI type ABAP_BOOL default ABAP_FALSE
    changing
      !MY_TRACE type STRING
      !OTR_DOCUMENT_SENT type I .
  class-methods CHECK_ACCEPT_LANGUAGE
    changing
      !ACCEPT_LANGUAGE type STRING .
  methods FAILED_LOGON_PAGE
    returning
      value(CONTENT) type STRING .
  methods FILL_AUTHENTICATION_METHODS
    importing
      !SUBRC type SYSUBRC
      !SAPRC type SYSUBRC
      value(LAST_AUTHENTICATION_METHOD) type I optional .
  methods SET_CORE_AUTHENTICATE
    importing
      !USERNAME type SYUNAME optional
      !PASSWORD type XUBCODE optional
      !PASSWORD_ENCR type C optional
      !SSO_IMPORT type STRING optional
      !CCERTIFICATE type I default 0
      !IS_ASSERTION_TICKET type ABAP_BOOL default ABAP_FALSE
      !SPNEGO_TOKEN type STRING optional
      !REQUESTED_AUTHMETHOD type SECURITY_SESSION_AUTHN_METHOD optional
      !DO_NOT_CREATE_SECURITY_SESSION type ABAP_BOOL default ABAP_FALSE
      !SECURITY_SESSION_REAUTH type ABAP_BOOL default ABAP_FALSE
      !SECURITY_SESSION_USER type XUBNAME optional
      !SECURITY_SESSION_CONTEXT type SECURITY_CONTEXT_ID optional
    exporting
      !SUBRC type SYSUBRC
      !SAPRC type SYSUBRC
      !SSO_EXPORT type STRING
    exceptions
      INVALID_PARAMETER .
  methods CREATE_SEC_SESS_4_PENDING_REQ .
  methods PROCEED_LOGOFF .
  methods AUTHENTICATION_SEC_SESSION
    importing
      !MANDATORY_CERTIFICATE_LOGON type ABAP_BOOL
      !LOGON_ORDER_TAB type LOGON_ORDER_TABLE
    exporting
      !RESULT type ABAP_BOOL
      !PW_STATE type I
      !SECURITY_SESSION_USER type XUBNAME
      !SECURITY_SESSION_CONTEXT type SECURITY_CONTEXT_ID
      !XSRF_TOKEN type SECURITY_CONTEXT_XSRF_TOKEN .
  methods DELETE_SECURITY_SESSION_COOKIE .
  methods SEND_LAST_PAGE
    returning
      value(SEND_RC) type I .
  methods GET_LANGU
    importing
      !SERVICE type ICFLOGIN
      !SERVER type ref to IF_HTTP_SERVER .
  methods SET_NO_CACHE .
  methods GET_SESSION_ACCESS_REG_ENTRY
    importing
      !SESSION_ACCESS_TOKEN type STRING
    exporting
      !REGISTRY_ENTRY type GT_SESSION_ACCESS_REG_ENTRY
    exceptions
      SESSION_ACCESS_TOKEN_NOT_FOUND .
  methods DELETE_XSRF_COOKIE .
  methods SEND_WEBSOCKET_HANDSHAKE
    exporting
      !E_ATRA_ACTIVATED type I
      !E_ATRA_VARIANT_USER type USERNAME
      !E_ATRA_VARIANT_NAME type SE30VAR
      !E_ATRA_RESOLUTION type RS38TCLOCK
      !E_ATRA_SINGLEREC type ATRA_SINGLEREC
    exceptions
      HTTP_COMMUNICATION_FAILED
      HTTP_PROCESSING_FAILED .
  methods TRIGGER_XHR_LOGON_VIA_IFRAME .
  methods FINALIZE_XHR_LOGON_VIA_IFRAME .
  methods GET_XHR_LOGON_REALM
    importing
      !CLIENT type SYMANDT
    returning
      value(REALM) type STRING .
  methods IS_SSO2_TICKET_AVAILABLE
    importing
      !SERVER type ref to IF_HTTP_SERVER
    exporting
      !SSO_IMPORT type STRING
      !SSOLIST type STRING
      !SSOLIST_B64 type STRING
      !SERVER_TOKEN type STRING
      !MYSERVER type RFCDEST
      !DO_NOT_USE_SSO2_TICKET type I
      !HEADER_SSO_AVAILABLE type ABAP_BOOL .
ENDCLASS.



CLASS CL_HTTP_SERVER_NET IMPLEMENTATION.


METHOD authentication.
  INCLUDE: icftreetop.
  DATA: server_obj TYPE REF TO cl_http_server.
  DATA: my_trace TYPE string.
  DATA: subrc_c(4) TYPE c,
        saprc_c(4) TYPE c.

*logon xsrf for Change Password - Start
  DATA: lv_xsrf_formfield TYPE string.
*logon xsrf for Change Password - END

  DATA: subrc   TYPE sysubrc,
        saprc   TYPE sysubrc,
        l_subrc TYPE sysubrc.

  DATA: basic_user   TYPE syuname,
        basic_passwd TYPE xubcode.
  DATA: service_user   TYPE syuname,
        service_passwd TYPE icfpasswd.
  DATA: field_user   TYPE syuname,
        field_passwd TYPE xubcode.
  DATA: l_login_not_complete TYPE c.

  DATA: sso_import      TYPE string,
        r3_auth         TYPE string,
        logon_by_ff     TYPE i VALUE 0,
        context_pooling TYPE string.
  DATA: alias TYPE bapialias.
  DATA: alias_trace TYPE string.                            "#EC NEEDED
  DATA: otr_document_sent TYPE i VALUE 0.
  DATA: l_alias_mapping_failed TYPE abap_bool VALUE abap_false.

  CONSTANTS: alias_userid_get TYPE x VALUE 3.

* -- logon by mandatory sevice
  DATA: logon_by_mservice  TYPE i VALUE 0.
  DATA: logon_order_table  TYPE logon_order_table.
  DATA: logon_order        TYPE logorder.
  DATA: logon_method       TYPE icflogkey.

* -- evalaution of header field 'Authorization' (Basic Authentication, OAuth2, ...)
  DATA: authstring   TYPE string,
        username_str TYPE string,
        password_str TYPE string,
        keyword      TYPE string,
        value        TYPE string.

* -- evaluation of SSO2 cookie
  DATA: ssolist_b64 TYPE string,
        ssolist     TYPE string.
  DATA: do_not_use_sso2_ticket TYPE i.
  DATA: do_not_use_c_certificate TYPE abap_bool VALUE abap_false.
  DATA: l_rfcsi  TYPE rfcsi,
        myserver TYPE rfcdest.

  DATA: l_hash160       TYPE hash160.
  DATA: no_basic_authentication TYPE i VALUE 0.
  DATA: l_saml_ticket   TYPE string.

* logon time for statistic
  DATA: stime TYPE i,
        etime TYPE i.

  DATA: l_configuration TYPE string.

  DATA: l_user      TYPE syuname,
        l_password  TYPE xubcode,
        l_isolangu  TYPE laiso,
        l_ssoticket TYPE string.

* -- does my server belongs to rejected list ?
  DATA: server_token TYPE string.

  DATA: l_is_webgui TYPE abap_bool VALUE abap_false.

  DATA: l_auth_method TYPE security_session_authn_method.

  FIELD-SYMBOLS <l_serv_wa> TYPE icfhandlst.

  DATA: header_sso_available   TYPE abap_bool.
  DATA: l_pw_state             TYPE i.
  DATA: l_mandatory_certificate_logon  TYPE abap_bool,
        l_sec_session_logon_successful TYPE abap_bool VALUE abap_false,
        l_sec_session_and_pub_service  TYPE abap_bool VALUE abap_false.
  DATA: l_security_session_user TYPE xubname.
  DATA: l_security_session_context TYPE security_context_id.
  DATA: l_security_session_reauth TYPE abap_bool      VALUE abap_false.
  DATA: l_do_not_create_sec_session    TYPE abap_bool VALUE abap_false.

  DATA: l_session_cookie_name  TYPE string.
  DATA: l_trace TYPE string.
  DATA: use_https TYPE abap_bool VALUE abap_false.
  DATA: l_saml_active      TYPE abap_bool.
  DATA: l_spnego_active    TYPE abap_bool.
  DATA: l_timestamp        TYPE timestamp.
  DATA: l_spnego_cookie    TYPE string.
  DATA: do_not_use_spnego  TYPE abap_bool VALUE abap_false.

  DATA: l_oauth_applicable TYPE abap_bool VALUE abap_false.
  DATA: lt_handler_list    TYPE icfhandtbl.

* Note 1371778 Trotz zu langem Username erfolgreiche Anmeldung
* Check the length of the user, alias user and the password¬¥, before a logon take place with these information
  DATA: lv_usr_length  TYPE i.
  DATA: max_usr_length TYPE i VALUE 12.
  DATA: lv_user_strg   TYPE string.
  DATA: lv_alias_length  TYPE i.
  DATA: max_alias_length TYPE i VALUE 40.
  DATA: lv_alias_strg    TYPE string.
  DATA: lv_passwd_length  TYPE i.
  DATA: max_passwd_length TYPE i VALUE 40.
  DATA: lv_passwd_strg    TYPE string.
  DATA: trcline           TYPE c LENGTH 80.
  DATA: lv_xsrf_cookie    TYPE string.
  DATA: lv_login_xsrf_id  TYPE string.
  DATA: lv_xsrf_field     TYPE string.
  DATA: lv_xsrf_active    TYPE abap_bool.
  DATA: lv_xsrf_check_result TYPE abap_bool VALUE abap_true.
  DATA: login_complete     TYPE answer.
  DATA: spnego_token       TYPE string.
  DATA: saml_message       TYPE string.
  DATA: l_first_call       TYPE abap_bool.

* XHR Client
  DATA: l_xhr_client       TYPE abap_bool VALUE abap_false.

***************** ICF Trace Macro Declaration**********************

  DATA: trcstr      TYPE string,
        trcstr_orig TYPE string,
        subtxt      TYPE c LENGTH 105,
        subtxt_long TYPE c LENGTH 1000,
        split_str   TYPE abap_bool,
        trc_len     TYPE i,
        trc_index   TYPE i,
        trc_offset  TYPE i.

  CONSTANTS: co_str   TYPE i VALUE 103,
             co_space TYPE string VALUE 'SPACE'.

  DATA: l_c_login_params TYPE icfsyslogparams.

  CONSTANTS c_assertion_ticket_dc_chk TYPE x VALUE 11.
  DATA assert_ticket_dc_chk_enabled TYPE abap_bool VALUE abap_false.
  DATA l_icf_value(2) TYPE c.


***************** Definition of ICf Trace Macros *****************
* Author: D026759
* there are three categories for ICF trace Macros
* 1) Information                                    ----> add_icf_trc `[Info]; `
* 2) Important Properties of Authentication Method  ----> add_icf_trc `[Prop]; `
* 3) Message Raising Information                    ----> add_icf_trc `[Msg]; `

******************************************************************

******************************************************************
******************************************************************
*              ** Info for important properties **               *
******************************************************************
*  Authentication Value shows the value of c_authenticated attr. *
*  Authentication Values: 0  ; not yet logged on                 *
*                         1  ; successfully logged on            *
*                         -1 ; PW initial or expired             *
******************************************************************
* Authentication Provider: 1 ; AUTHPROVIDER_ICF                  *
*                          2 ; AUTHPROVIDER_WS_SECURITY          *
*                          3 ; AUTHPROVIDER_SECURITY_SESSION     *
******************************************************************
* Authentication Method:   0 ; AUTHMETHOD_NONE                   *
*                          1 ; AUTHMETHOD_BASIC                  *
*                          2 ; AUTHMETHOD_SSO                    *
*                          3 ; AUTHMETHOD_SAP                    *
*                          4 ; AUTHMETHOD_SERVICE                *
*                          5 ; AUTHMETHOD_SAML                   *
*                          6 ; AUTHMETHOD_FIELD                  *
*                          7 ; AUTHMETHOD_CERTIFICATE            *
*                          8 ; AUTHMETHOD_RECORDER               *
*                          9 ; AUTHMETHOD_ASSERTION              *
*                         10 ; AUTHMETHOD_SECURITY_SESSION       *
******************************************************************

  pf_m_open c_statistic_state 'A:Authenticate Inside'.      "#EC NOTEXT

*  icf_trc 'Authentication'. "#EC NOTEXT
  server_obj ?= server.

  add_icf_trc `[Prop]; Method Name: ` 'CL_HTTP_SERVER_NET->AUTHENTICATION'. "#EC NOTEXT

* reordering of the default logon methods for A1S customer
  IF service-logorder IS INITIAL.
    logon_order =
    'AUTH_FIELD,AUTH_CERT,AUTH_SSO,AUTH_ASSERT,AUTH_BASIC,' &
    'AUTH_SAP,AUTH_SPNEGO,AUTH_SAML,AUTH_SERVI'.
  ELSE.
    logon_order = service-logorder.
  ENDIF.

  add_icf_trc `[Prop]; logon order: ` logon_order.          "#EC NOTEXT

********************************************************************
* SAP Note 2046990
* Begin
* determination of public services
*
  public_service = 0.
  IF service-publicflag = 'X'.
    public_service = 1.
  ENDIF.

* get user context from cookie in request in case we need it for get_client
  cl_http_user_context=>instantiate( request = request ).

** Determination of language

* Begin
  get_langu( service = service
             server  = server ).

  add_icf_trc `[Prop]; Current language value: ` c_langu.   "#EC NOTEXT

*+++++++++++++++++++++++++++++++++++++++++++++++++++*
* determination of client
*
* Start: For the security session (NGSSO project) we need the client in order to check
* whether the security session is activbated for this client or not
* We determine the client (c_client) in the get_client method
* Remark: We must hinder the resetting of c_client
  get_client( service = service ).

  add_icf_trc `[Prop]; Current client value: ` c_client.    "#EC NOTEXT
*+++++++++++++++++++++++++++++++++++++++++++++++++++*
* End
* SAP Note 2046990
*
************************************************************************
* For some ICF services (e.g. ABAP Push Channel (APC), OData, etc.)
* the creation of Security Sessions and SAP Logon Tickets is not desired (partial restriction).
*
* Some ICF services (e.g. SOAP Web Services) even want to disable the usage of
* existing Security Sessions (full restriction).
*
* The desired ICF runtime behavior is denoted in the ICF service configuration (inheritance possible)
  m_sec_session_restrictions = service-no_session_management.
  IF m_sec_session_restrictions = 'X'. "legacy value (used in 7.40 SP 2)
    m_sec_session_restrictions = 'F'.
  ENDIF.

*
* initialization of SERVICE_COMPRESSION_FLAG for BW
*
  IF service-compr_flag = 'X'.
    service_compression_flag = co_enabled.
  ELSE.
    service_compression_flag = co_disabled.
  ENDIF.

* Is SSL set to mandatory for the service
  IF service-protsec = 'S'.
    use_https = abap_true.
    add_icf_trc `[Prop]; Security Requirement flag in ICF service: ` use_https. "#EC NOTEXT
  ENDIF.

  IF ssl_active = co_enabled.
    m_recorder_failed_logon-ssl_availabale = co_enabled.
  ENDIF.

*
* Remark: Per default the ICF runtime is the authentication provider
*
  authentication_provider = authprovider_icf.

* NGSSO project:
* In case of WS security logon the callback method CL_AUTHENTICATION_PROVIDER=>WS_SECURITY_AUTHN_RESULT
* has to be called by WS runtime (usually from within the method CL_WSSE_CONTEXT->AUTHENTICATE)
* Attribute M_WS_SECURITY_LOGON_DONE is checked in SEND_REPONSE method again for check reason
  m_ws_security_logon_done = abap_false.

* is Webgui (/sap/bc/gui/sap/its/webgui) service active ?
* in that case ICFX uses stateful session with URL-rewriting when
* form-field based authentication is maintained
* furthermore no SSO ticket should be set in response
* Supplement (26.04.2007/20.05.2007): This feature should be available/provided to all
*                          ITS services. This is GUI link is active and ITS handler is in place
* Note: It was planned (by Uwe Klinger) in case of webgui to use the sap-contextid as formfield
*       instead of URL rewriting ! (but this is not yet verified and implemented)
*
  IF service-icfguilnk = 'Y' AND service-logorder = 'AUTH_FIELD'.
    LOOP AT servtbl[] ASSIGNING <l_serv_wa> WHERE handlertbl IS NOT INITIAL.
      READ TABLE <l_serv_wa>-handlertbl TRANSPORTING NO FIELDS WITH KEY icfhandler = 'CL_HTTP_EXT_ITS'.
      IF sy-subrc = 0.
        l_is_webgui = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

* SAP Note 1977537
* XHR Client
  IF if_http_header_fields=>xmlhttprequest EQ server_obj->request->get_header_field( if_http_header_fields=>x_requested_with ).
*   Currently, only one single method ('iframe') is supported, thus no negotiation is required:
*   The server will always propose to use 'iframe' and the client can decide to accept or to refuse the offer.
*   Once we support multiple methods, we need to parse the header field value and react accordingly.
*   Potentially we might return status code 406 (Not Acceptable) in case of a mismatch, then.
    IF server_obj->request->get_header_field( if_http_header_fields=>x_xhr_logon ) CS 'accept'.
      l_xhr_client = abap_true.
    ENDIF.
    add_icf_trc `[Prop]; l_xhr_client value: ` l_xhr_client. "#EC NOTEXT
  ENDIF.
***

* is authencation already done (e. g. in stateful context)
*
  IF c_icfx_login_in_processing = abap_true.
    c_authenticated = 1.
    add_icf_trc `[Info]; System Login is in Processing ` `Calling of 'Get Service Extension'`. "#EC NOTEXT

    CALL METHOD server_obj->get_service_extension
      EXPORTING
        kind                    = ihttp_icfservice_extension_bsp
      IMPORTING
        configuration           = l_configuration
      EXCEPTIONS
        kind_is_not_supported   = 1
        error_during_processing = 2
        OTHERS                  = 3.
    IF sy-subrc <> 0.
      add_icf_trc `[Msg]; Error at 'Get Service Extension' ` 'Error in system logon configuration.'. "#EC NOTEXT
    ENDIF.

    add_icf_trc `[Info]; Calling of: ` 'on_icf_call method'. "#EC NOTEXT
* processing of expired logon account
    CALL METHOD cl_icf_system_login=>on_icf_call
      EXPORTING
        ii_server                = server
        iv_login_methods         = logon_order
        is_alias                 = service-aliaslogin
        accessibility            = service-accessibility
        mandatory_service_client = service-oblmandt
        service_client           = service-icf_mandt
        mandatory_service_langu  = service-obllangu
        service_langu            = service-icf_langu
        mandatory_ssl            = use_https
        configuration            = l_configuration
        webgui                   = l_is_webgui
*       security_session_created = m_security_session_created
      IMPORTING
        login_in_processing      = c_icfx_login_in_processing.
* login completed is required for the following cases:
* login should only be done via form fields withou basic
* authentiaction and MYSAPSSO procedure
* In order to support this feature by ICFX a statful
* communication is established which is after a
* successful processing of login procedure is reset by ICFX to stateless
* and all the self defined parameters
* (e. g. 'sap-system-login') are also removed from the
* application request, after a stateful redirect.
    IF c_icfx_login_in_processing = abap_true.
* processing of subsequent ICFX screens, e. g. password change
      CLEAR c_authenticated.
*  write the trace before exit authentication method
      l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
      add_icf_trc `[Prop]; ` l_trace.                       "#EC NOTEXT
* End
      add_icf_trc `[Info]; 'Return' after ` 'on_icf_call method'. "#EC NOTEXT

      RETURN.
    ENDIF.
  ENDIF.

  IF c_authenticated = 1.
* -- delete security relevant fields first after the ESID handling in HTTP_DISPTCH_REQUEST
*   delete_security_fields( ).
    pf_m_close c_statistic_state 'A:Authenticate Inside'.   "#EC NOTEXT
*  write the trace before exit authentication method
    l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
    add_icf_trc `[Prop]; ` l_trace.                         "#EC NOTEXT
* End
    add_icf_trc `[Info]; 'Return' after ` 'already authenticated session'. "#EC NOTEXT
    RETURN.
  ENDIF.

*
* conntext pooling is active, thus reuse authenticated context
*
  IF c_login_is_done = 'Y' AND
  c_action        = 4. "TH_PLUGIN_FIRST_READ_LOGGED_ON = 4
    pf_m_close c_statistic_state 'A:Authenticate Inside'.   "#EC NOTEXT
    c_authenticated = 1.

* -- update authentication method (authentication_method is set)
    pooled_session = co_enabled.

    get_langu( service = service
               server  = server ).

* -- delete security relevant fields
    delete_security_fields( ).
    EXIT.
  ENDIF.

*-------------------------------------------------------
* check security level defined at service
*
  IF ( service-protsec = 'S' AND c_protocol <>  2 ) OR
  ( service-protsec = 'X' AND c_certificate_available <> 1 ).

    l_trace = | Used Secure Protocol = { service-protsec } AND Certificate Availibility = { c_certificate_available } |.
    add_icf_trc `[Prop]; ` l_trace.                         "#EC NOTEXT

* -- output of otr documents, if availbale
    CALL METHOD prepare_otr_document
      EXPORTING
        server            = server
        service           = service
        logon_order       = logon_order
        webgui            = l_is_webgui
      CHANGING
        my_trace          = my_trace
        otr_document_sent = otr_document_sent.

    IF otr_document_sent IS INITIAL.
      CALL METHOD security_request
        EXPORTING
          server       = server
          reply_client = c_client
          service      = service.
    ENDIF.

*   write the trace before exit authentication method
    l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
    add_icf_trc `[Prop]; ` l_trace.                         "#EC NOTEXT
* End
    add_icf_trc `[Info]; 'Exit' after ` 'security_request method'. "#EC NOTEXT
    EXIT.
  ENDIF.

*-------------------------------------------------------
*
* regular logon mechanism
*

* -- protocol logon procedure for recorder
  m_recorder_failed_logon-version = 0.

  r3_auth = server->request->get_header_field( name = ihttp_c_sap_recorder_aut ).
  IF NOT r3_auth IS INITIAL.
    DATA: recorder_logon TYPE ihttp_recorder_logon.
    DATA: icflogon     TYPE xstring.

* -- update authentication method
    authentication_method = authmethod_recorder.

    add_icf_trc `[Prop]; (Logon via ICF Recorder); Authentication Method: ` authentication_method. "#EC NOTEXT

    server->request->delete_header_field_secure( name = ihttp_c_sap_recorder_aut ).
    server->request->delete_form_field_secure( name = ihttp_c_sap_recorder ).

    icflogon =  r3_auth.
    IMPORT recorder_logon TO recorder_logon FROM DATA BUFFER icflogon.

    IF recorder_logon-version = 1.
      DATA: logon_password TYPE xubcode.
      logon_password = recorder_logon-logon_password.
* -- logon via user and password
      CALL FUNCTION 'HTTP_AUTHENTICATE'
        EXPORTING
          client            = recorder_logon-logon_client
          username          = recorder_logon-logon_username
          language          = recorder_logon-logon_language
          password          = logon_password
        IMPORTING
          subrc             = subrc
          saprc             = saprc
        EXCEPTIONS
          invalid_parameter = 1
          OTHERS            = 2.
      IF sy-subrc = 0 AND subrc = 0.
        c_authenticated = 1.
        delete_security_fields( ).
*  write the trace before exit authentication method
        l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
        add_icf_trc `[Prop]; ` l_trace.                     "#EC NOTEXT
* End
        add_icf_trc `[Info]; 'Exit' after: ` 'At Playback of ICF Recorder Logon Request via user & pw'. "#EC NOTEXT
        EXIT.
      ELSE.
        subrc_c = subrc.
        saprc_c = saprc.
      ENDIF.
      fill_authentication_methods( subrc = subrc
                                   saprc = saprc ).
    ELSE.
      CALL 'ICF_DISPATCH'
      ID 'HTTP'     FIELD 'L'
      ID 'RFCLogon' FIELD 'X'
      ID 'SessionID' FIELD recorder_logon-logon_ticket.
      IF sy-subrc = 0.
        c_authenticated = 1.
        subrc = 0.
        CLEAR context_pooling.
        fill_authentication_methods( subrc = subrc
                                     saprc = 0 ).
        delete_security_fields( ).
*  write the trace before exit authentication method
        l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
        add_icf_trc `[Prop]; ` l_trace.                     "#EC NOTEXT
* End
        add_icf_trc `[Info]; 'Exit' after: ` 'At Playback Phase of ICF Recorder Logon Request via Logon Ticket'. "#EC NOTEXT
        EXIT.
      ELSE.
        fill_authentication_methods( subrc = sy-subrc
                                     saprc = 0 ).
      ENDIF.
    ENDIF.

* -- no authentication check for public services
    IF ( c_authenticated = 0 OR c_authenticated = -1 ) AND
         public_service  = 0.

      CALL METHOD prepare_otr_document
        EXPORTING
          server            = server
          service           = service
          logon_order       = logon_order
          webgui            = l_is_webgui
        CHANGING
          my_trace          = my_trace
          otr_document_sent = otr_document_sent.

      IF otr_document_sent IS INITIAL.
        CALL METHOD basic_authentication_screen
          EXPORTING
            authstring              = authstring
            server                  = server
            reply_client            = c_client
            service                 = service
            data                    = my_trace
            no_basic_authentication = no_basic_authentication.
      ENDIF.
*  write the trace before exit authentication method
      l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
      add_icf_trc `[Prop]; ` l_trace.                       "#EC NOTEXT
* End
      add_icf_trc `[Info]; 'Exit' after: ` 'Sending of Basic Auth. Screen for a public service'. "#EC NOTEXT
      EXIT.
    ENDIF.
  ENDIF.

* prepare logon data, based on ICF service entries

*-- use mandatory user and password fields,
*-- only if the user and password are maintained
  IF service-obluser IS NOT INITIAL AND service-oblpasswd IS NOT INITIAL.
    logon_by_mservice = 1.
  ENDIF.

* Requirement of NGSSO project for Webservice requests:
* - In case of Webservice processing do not transfer any MYSAPSSO2 cookie with the Webservice response and
*   furthermore do not establish any security session
* - In case of message based authentication in context of Webservice the message based logon will be dons by
*   Webservice framework. That means that no ICF authentication should be processed and the Webservice will
*   first initiate the logon and immediately after the logon exceution via a call back method provided by
*   ICF framework the result and the type of the logon trial will be passed to the ICF runtime. Furthermore
*   ICF runtime should remove all relevant logon data included in the request before passing the request to the
*   Webservice runtime for post procssing, i.e. processing of message based authentication.
*
* Is security session active ?
* Remark: No security session management in case of Webservice requests and defacto 'PUBLIC' services.
*         Furthermore in case of a Webservice message based authentication ICF logon should not be called !
*
* Remark:
* In case of active security session managment and (de facto) public services the only classic logon
* which is supported is the mandatory service logon.
*

  pf_m_open c_statistic_state 'A:Check Security Session Managment'. "#EC NOTEXT
  add_icf_trc `[Prop]; Value for c_client: ` c_client.      "#EC NOTEXT

  IF service-icf_esi_flag IS NOT INITIAL.
*   SOAP Web Services -> full restrictions
    m_sec_session_restrictions = 'F'. "full restrictions: neither create nor use existing security sessions
  ENDIF.

  IF m_sec_session_restrictions = 'F'.
    m_security_session_active = abap_false.
  ELSE.
    m_security_session_active = cl_http_security_session_icf=>session_management_is_active( c_client ).
    IF m_sec_session_restrictions = 'P'.
      l_do_not_create_sec_session = abap_true. "partial restrictions: do not create new security sessions
    ENDIF.
  ENDIF.

  pf_m_close c_statistic_state 'A:Check Security Session Managment'. "#EC NOTEXT

  add_icf_trc `[Prop]; Value for flag sec_session_restrictions: ` m_sec_session_restrictions. "#EC NOTEXT

*  LOG-POINT ID icf_runtime SUBKEY m_log_subkey FIELDS
*          compute_log_subkey( )
*          sy-uname
*          sy-mandt
*          cl_abap_aab_utilities=>store_char_message( TEXT     = | client { c_client } { m_recorder_failed_logon-client_method }|
*                                                      category = cl_abap_aab_utilities=>category_info ).

* Determine the security session cookie, if the security session management is active for the logon client
* Important: this is also required for the public(!) logoff service,
*            thus it has to happen before(!) handling of public services
  IF m_security_session_active = abap_true.
* determine m_security_session_cookie
    m_security_session_cookie = get_sec_session_id_from_cookie( ).
* do not send received security session cookie
    m_security_session_created = abap_false.
  ENDIF.

  IF c_sap_trace IS NOT INITIAL.
    l_trace = | security sesssion FOR CLIENT { c_client } = { m_security_session_active } |.
    add_icf_trc `[Prop]; ` l_trace.

    l_trace = | PUBLIC service = { public_service } AND mandatory logon BY service = { logon_by_mservice } |.
    add_icf_trc `[Prop]; ` l_trace.
  ENDIF.

*
* Handling of public services
*
  IF service-publicflag = 'X'.
*
* logon for a public service is required in the following cases (also because of debugging):
* - security session is active: logon with mandatory service user must be processed
* - security session is inactive: classic ICF logon procedure must be processed
*                                 for all possible procedures
*
    IF NOT m_security_session_active IS INITIAL AND logon_by_mservice = 0.
**** SAP Note 2046990 ******
* Begin
*****************************************
*  is sso2 ticket available ?
      CALL METHOD is_sso2_ticket_available
        EXPORTING
          server = server.
*****************************************
** -- delete security relevant fields
      delete_security_fields( ).
      RETURN.
    ENDIF.
* End
  ENDIF.
***************************NEW ******************************
** SAP Note 2046990
** Begin
**
** -- determination of logon order
*
  IF service-logorder IS INITIAL.
    logon_order =
    'AUTH_FIELD,AUTH_CERT,AUTH_SSO,AUTH_ASSERT,AUTH_BASIC,' &
    'AUTH_SAP,AUTH_SPNEGO,AUTH_SAML,AUTH_SERVI'.
    IF service-fallthru IS INITIAL.
* only one trial
      APPEND logon_method TO logon_order_table.
    ELSE.
      SPLIT logon_order AT ',' INTO TABLE logon_order_table[].
    ENDIF.
  ELSE.
    logon_order = service-logorder.
    FIND 'AUTH_BASIC' IN logon_order.
    IF sy-subrc <> 0.
* basic authentication should be prevented
      no_basic_authentication = 1.
    ENDIF.
    FIND 'AUTH_SSO' in logon_order.
    IF sy-subrc = 0.
      FIND 'AUTH_ASSERT' in logon_order.
      IF sy-subrc <> 0.
        REPLACE 'AUTH_SSO' IN logon_order WITH 'AUTH_SSO,AUTH_ASSERT'.
        add_icf_trc `[Prop]; new logon order: ` logon_order.          "#EC NOTEXT
      ENDIF.
    ENDIF.
    SPLIT logon_order AT ',' INTO TABLE logon_order_table.
  ENDIF.

* Check whether a logon via pure security session id/cookie can be handled
* Remark: If a security session cookie is available an explicit logon is not necessary anymore
*         as soon as a logon with one of the requested logon method for this service has
*        already been done.
* No security session logon for Webservices and "public" services.
* Services with a mandatory logon data belong to this category.

  add_icf_trc `[Info]; Value of security_session_cookie is: ` m_security_session_cookie. "#EC NOTEXT

  IF m_security_session_cookie IS NOT INITIAL AND
    public_service           = 0 AND
    logon_by_mservice        = 0.

* requested logon via client certificate
    IF service-protsec       = 'X' OR
       service-login_process = 'C'.
      l_mandatory_certificate_logon = abap_true.
    ELSE.
      l_mandatory_certificate_logon = abap_false.

      IF service-logorder IS INITIAL.
        SPLIT logon_order AT ',' INTO TABLE logon_order_table[].
      ENDIF.
    ENDIF.

    CALL METHOD authentication_sec_session
      EXPORTING
        mandatory_certificate_logon = l_mandatory_certificate_logon
        logon_order_tab             = logon_order_table[]
      IMPORTING
        security_session_user       = l_security_session_user
        security_session_context    = l_security_session_context
        result                      = l_sec_session_logon_successful
        pw_state                    = l_pw_state
        xsrf_token                  = m_xsrf_token_from_sec_context.
*
*   Allow Security Session ID cookie to be overwritten (recreated) if contained
*   Security Sesssion ID is invalid. This can happen after the session
*   has timed-out or after the session has been terminated by an admin.
*   A proper logoff should delete the cookie (might fail in case of different hostnames).
*
    add_icf_trc `[Info]; Value of session_logon_successful: ` l_sec_session_logon_successful.
    IF l_sec_session_logon_successful = abap_false.
*     authentication or reauthentication is required
*     in both cases a new sessionID will be created
*     Security Session ID cookie needs to be overwritten (recreated)
      CLEAR m_security_session_cookie.

      IF l_security_session_user IS NOT INITIAL.
*       case: Session is valid but authentication requirements demanded
*             by the ICF service is not covered by the authentication methods
*             provided by the Security Session (previously performed authentications).
*             -> reauthentication required (for the user to whom the sessions belongs)
*                for the requested authentication method (REQUESTED_AUTHMETHOD)

        add_icf_trc `[Info]; Value of security_session_user: ` l_security_session_user.
        l_security_session_reauth = abap_true.
      ENDIF.
    ENDIF.

    IF c_sap_trace IS NOT INITIAL.
      CALL METHOD request->set_header_field
        EXPORTING
          name  = 'Sec-Logon-Trace'                         "#EC NOTEXT
          value = m_trace.
    ENDIF.
  ENDIF.
*
** SAP Note 2046990
** End

***************************NEW****************************
* SAP Note 2046990
* Begin
*
* Start SPNEGO  -> is SPNEGO active
*
  IF ( m_security_session_active EQ abap_true AND
       l_sec_session_logon_successful = abap_false ) OR
   ( service-icf_esi_flag IS NOT INITIAL AND service-logorder CS 'AUTH_SPNEGO' ).
* SAP Note 2046990
* End
*
*   check SPNego & SAML2 only if sec session Management is active
    l_spnego_active = cl_spnego_runtime=>is_applicable( i_http_request = request i_client = c_client ).

* START check SSOLIST for SPNEGO
    IF l_spnego_active = abap_true.
      CALL METHOD server->request->get_cookie
        EXPORTING
          name  = co_ssolist
        IMPORTING
          value = ssolist_b64.

      IF NOT ssolist_b64 IS INITIAL.
*   my instance id
        ssolist = decode_base64( ssolist_b64 ).

        IF NOT c_instance_id IS INITIAL.
          myserver = c_instance_id.
        ELSE.
          CALL FUNCTION 'RFC_SYSTEM_INFO'
            IMPORTING
              rfcsi_export          = l_rfcsi
            EXCEPTIONS
              communication_failure = 1
              system_failure        = 2
              OTHERS                = 3.
          IF sy-subrc = 0.
            myserver = l_rfcsi-rfcdest.
          ENDIF.
        ENDIF.
        IF NOT ssolist IS INITIAL.
          CONCATENATE co_spnego_token_reject
          myserver '_' c_client
          INTO server_token.
*   -- first cheap test: does ssolist contains this instance ?
          IF ssolist CS server_token.
            do_not_use_spnego = abap_true.
            add_icf_trc `[Msg]: ssolist` '-> do_not_use_spnego'.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE.
      "l_spnego_active = ABAP_FALSE

      l_trace = 'SPNego is inactive !'.                     "#EC NOTEXT
      add_icf_trc `[Msg]: CL_SPNEGO_RUNTIME=>IS_APPLICABLE` l_trace.
    ENDIF.
  ENDIF.
*
* END check SSOLIST for SPNEGO
*

*
* SAML 20 and  1.1 -> is SAML active or not.
*
  pf_m_open c_statistic_state 'A:Check SAML'.               "#EC NOTEXT

* SAP Note 2046990
* Begin
  IF ( l_sec_session_logon_successful = abap_false AND
       l_xhr_client EQ abap_false ).
* SAP Note 2046990
* End
    l_saml_active = cl_icf_saml_login=>is_saml_applicable( io_server = me
                                                           if_client = c_client ).
  ENDIF.

  pf_m_close c_statistic_state 'A:Check SAML'.              "#EC NOTEXT

*************************************************************************
* Determination of user and password
* Begin

*-- use mandatory user and password fields,
*-- only if the user and password are maintained
  IF logon_by_mservice = 1.
    service_user   = service-obluser.
    service_passwd = service-oblpasswd.

    CONCATENATE m_recorder_failed_logon-user_method
    ihttp_recorder_user_oblig
    INTO m_recorder_failed_logon-user_method.

    CONCATENATE m_recorder_failed_logon-password_method
    ihttp_recorder_passwd_oblig
    INTO m_recorder_failed_logon-password_method.

    add_icf_trc `[Prop]; Password Method by Mandatory Service: ` m_recorder_failed_logon-password_method. "#EC NOTEXT
  ENDIF.

* -- client certificate avaliable
  IF c_certificate_available = 1.
    CONCATENATE m_recorder_failed_logon-tickets
    ihttp_recorder_x509_ticket
    INTO m_recorder_failed_logon-tickets.

    add_icf_trc `[Prop]; Logon Ticket when Client Cert. available: ` m_recorder_failed_logon-tickets. "#EC NOTEXT
  ENDIF.

* -- sso2 and saml ticket avaliable
  pf_m_open c_statistic_state 'A:SSO2/SAML ticket available'. "#EC NOTEXT

  IF logon_by_mservice IS INITIAL.
* SAP Note 2046990
* Begin
    CALL METHOD is_sso2_ticket_available
      EXPORTING
        server                 = server
      IMPORTING
        sso_import             = sso_import
        ssolist                = ssolist
        ssolist_b64            = ssolist_b64
        server_token           = server_token
        myserver               = myserver
        do_not_use_sso2_ticket = do_not_use_sso2_ticket
        header_sso_available   = header_sso_available.

    add_icf_trc `[Prop]; header_sso_available: ` header_sso_available. "#EC NOTEXT
* SAP Note 2046990
* End

* check the content of ssolist for rejected client certificates
    IF c_certificate_available = 1 AND NOT ssolist IS INITIAL.
* create client certificate reject pattern (string with ;c=)
      CONCATENATE co_cctoken_reject myserver '_' c_client INTO server_token.

* -- first cheap test: does ssolist contains this instance ?
      IF ssolist CS server_token.
* mark the certificate as not applicable
        do_not_use_c_certificate = abap_true.
        add_icf_trc `[Msg]: ` 'do_not_use_c_certificate'.   "#EC NOTEXT
        CONCATENATE m_recorder_failed_logon-tickets
        ihttp_recorder_ssorej_ticket
        INTO m_recorder_failed_logon-tickets.
        add_icf_trc `[Prop]; (Check ssolist for rejected Client Cert.); Logon Tickets: ` m_recorder_failed_logon-tickets. "#EC NOTEXT
      ENDIF.
    ENDIF.

* check the content of ssolist for rejected SAML assertions
    l_saml_ticket = request->get_form_field_cs( name = cl_icf_saml_config=>artifact_name ).
    IF l_saml_ticket IS NOT INITIAL.
      CONCATENATE m_recorder_failed_logon-tickets
      ihttp_recorder_saml_ticket
      INTO m_recorder_failed_logon-tickets.
      add_icf_trc `[Prop]; SAML Logon Tickets: ` m_recorder_failed_logon-tickets. "#EC NOTEXT
    ENDIF.
  ENDIF.

  IF logon_by_mservice IS INITIAL.
    field_user = lv_user_strg =
    server->request->get_header_field(
    name = 'sap-user' ).                                    "#EC NOTEXT
    IF field_user IS INITIAL.
      field_user = lv_user_strg =
      server->request->get_form_field(
      name = 'sap-user' ).                                  "#EC NOTEXT

      IF NOT field_user IS INITIAL.
        CONCATENATE m_recorder_failed_logon-user_method
        ihttp_recorder_user_ffield
        INTO m_recorder_failed_logon-user_method.
        add_icf_trc `[Prop]; (Check User by form field); User Method: ` m_recorder_failed_logon-user_method. "#EC NOTEXT
      ENDIF.
    ELSE.
      CONCATENATE m_recorder_failed_logon-user_method
      ihttp_recorder_user_hfield
      INTO m_recorder_failed_logon-user_method.
      add_icf_trc `[Prop]; (Check User by header field); User Method: ` m_recorder_failed_logon-user_method. "#EC NOTEXT
    ENDIF.

*   -- check alias name for user name
    IF field_user IS INITIAL.
      alias = lv_alias_strg =
      server->request->get_header_field(
      name = 'sap-alias' ).                                 "#EC NOTEXT
      IF alias IS INITIAL.
        alias = lv_alias_strg =
        server->request->get_form_field(
        name = 'sap-alias' ).                               "#EC NOTEXT
        IF NOT alias IS INITIAL.
          CONCATENATE m_recorder_failed_logon-user_method
          ihttp_recorder_auser_ffield
          INTO m_recorder_failed_logon-user_method.
          add_icf_trc `[Prop]; (Check Alias Name by form field); User Method: ` m_recorder_failed_logon-user_method. "#EC NOTEXT
        ENDIF.
      ELSE.
        CONCATENATE m_recorder_failed_logon-user_method
        ihttp_recorder_auser_hfield
        INTO m_recorder_failed_logon-user_method.
        add_icf_trc `[Prop]; (Check Alias Name by header field); User Method: ` m_recorder_failed_logon-user_method. "#EC NOTEXT
      ENDIF.

      IF NOT alias IS INITIAL.
        lv_alias_length = strlen( lv_alias_strg ).
        IF  lv_alias_length > max_alias_length.
          subrc_c = 1001.
          add_icf_trc `[Msg]; Aliasname too large: ` lv_alias_strg. "#EC NOTEXT
        ELSE.
*     -- map alias to user
          TRANSLATE alias TO UPPER CASE.                 "#EC TRANSLANG
          " Do not use 'SUSR_USER_BNAME_FROM_ALIAS'
*          select single * from usrefus client specified into l_usrefus
*              where mandt      = c_client and
*                    useralias  = alias.
          CALL 'LOGIN_INFO' ID 'OPCODE' FIELD alias_userid_get
          ID 'CLIENT' FIELD c_client
          ID 'ALIAS'  FIELD alias
          ID 'USERID' FIELD field_user.
          subrc_c = sy-subrc.
          add_icf_trc `[Prop]; Return Code of Get UserID by Client & Alias Name: ` subrc_c. "#EC NOTEXT
        ENDIF.

* if no user mapping to the alias user exists forward this info to system logon (if necessary).                                                                                ENDIF.
        IF field_user IS INITIAL.
          l_alias_mapping_failed = abap_true.
          add_icf_trc `[Msg]; Alias Mapping Failed: ` l_alias_mapping_failed. "#EC NOTEXT
        ENDIF.

        m_recorder_failed_logon-alias_user_check = subrc_c.
        IF subrc_c <> 0 AND
        NOT c_sap_trace IS INITIAL.
          CONCATENATE '<B>Alias: </B>' alias                "#EC NOTEXT
          ', <B>Client: </B>' c_client                      "#EC NOTEXT
          ', <B>Subrc: </B>' subrc_c                        "#EC NOTEXT
          INTO alias_trace SEPARATED BY space.
        ENDIF.
*       c_user = l_usrefus-bname.
      ENDIF.
    ENDIF.
  ENDIF.

  IF logon_by_mservice IS INITIAL.
    field_passwd = lv_passwd_strg =
    server->request->get_header_field( name = 'sap-password' ).

    IF field_passwd IS INITIAL.
      field_passwd = lv_passwd_strg =
      server->request->get_form_field( name = 'sap-password' ).

      IF NOT field_passwd IS INITIAL.
        CONCATENATE m_recorder_failed_logon-password_method
        ihttp_recorder_passwd_ffield
        INTO m_recorder_failed_logon-password_method.
        add_icf_trc `[Prop]; (Check PW by form field); PW Method: ` m_recorder_failed_logon-password_method. "#EC NOTEXT
      ENDIF.
    ELSE.
      CONCATENATE m_recorder_failed_logon-password_method
      ihttp_recorder_passwd_hfield
      INTO m_recorder_failed_logon-password_method.
      add_icf_trc `[Prop]; (Check PW by header field); PW Method: ` m_recorder_failed_logon-password_method. "#EC NOTEXT
    ENDIF.
  ENDIF.

  IF NOT field_user    IS INITIAL AND
     NOT field_passwd  IS INITIAL AND
     logon_by_mservice IS INITIAL.
    logon_by_ff = 1. "logon by form/header fields
  ENDIF.

  pf_m_close c_statistic_state 'A:SSO2/SAML ticket available'. "#EC NOTEXT

  IF logon_by_mservice IS INITIAL.
*     authstring is initial and
*     sso_import is initial.
* -- R3->R3 logon strategy
    r3_auth = server->request->get_header_field( name = c_sap_r3auth ).
    IF NOT r3_auth IS INITIAL.
      CONCATENATE m_recorder_failed_logon-tickets
      ihttp_recorder_r3auth_ticket
      INTO m_recorder_failed_logon-tickets.
*       set bit ihttp_recorder_r3auth_ticket of
*                    m_recorder_failed_logon-tickets.
      add_icf_trc `[Prop]; RFC Logon Tickets: ` m_recorder_failed_logon-tickets. "#EC NOTEXT
    ENDIF.

  ENDIF.

* -- basic authentication available
  IF logon_by_mservice IS INITIAL.
    authstring = server->request->get_header_field( name = 'authorization' ).

    IF NOT authstring IS INITIAL.
*   -- split into KEYWORD (upper-case) and VALUE (case-sensitive)
      CLEAR: keyword, value.
      SHIFT authstring LEFT DELETING LEADING space.
      SPLIT authstring AT space INTO keyword value.
      SHIFT value LEFT DELETING LEADING space.
      keyword = to_upper( keyword ).
      IF value IS NOT INITIAL.

        IF keyword = 'BEARER'.
*    --  OAuth Access Token (Bearer) received
          CONCATENATE m_recorder_failed_logon-tickets
          ihttp_recorder_oauth2_ticket
          INTO m_recorder_failed_logon-tickets.
          LOOP AT servtbl[] ASSIGNING <l_serv_wa> WHERE handlertbl IS NOT INITIAL.
            INSERT LINES OF <l_serv_wa>-handlertbl INTO TABLE lt_handler_list.
          ENDLOOP.
          l_oauth_applicable = cl_oauth2_s_resource_server=>is_applicable( lt_handler_list ).
          add_icf_trc `[Prop]; OAuth Applicable: ` l_oauth_applicable. "#EC NOTEXT
        ELSEIF keyword = 'NEGOTIATE'.
*    -- NEGOTIATE value have to transfer to security interface
          spnego_token = value.
          "          add_icf_trc `[Prop]; SPNego Token: ` Spnego_token. "#EC NOTEXT
        ELSEIF keyword = 'SAML2.0'.
*    -- SAML2.0 value for header based SAML 2.0 authentication
          saml_message = value.
        ELSEIF keyword = 'BASIC'.
*    --  Basic Authentication received
          CONCATENATE m_recorder_failed_logon-tickets
          ihttp_recorder_bauth_ticket
          INTO m_recorder_failed_logon-tickets.

          CALL METHOD server->request->get_authorization
            IMPORTING
              username = username_str
              password = password_str.

          basic_passwd = password_str.
          IF NOT basic_passwd IS INITIAL.
            CONCATENATE m_recorder_failed_logon-password_method
            ihttp_recorder_passwd_bauth
            INTO m_recorder_failed_logon-password_method.
          ENDIF.

          IF service-aliaslogin IS INITIAL.
            basic_user = username_str.
            IF NOT basic_user IS INITIAL.
              CONCATENATE m_recorder_failed_logon-user_method
              ihttp_recorder_user_bauth
              INTO m_recorder_failed_logon-user_method.
              add_icf_trc `[Prop]; (Basic Authentication available); User Method: ` m_recorder_failed_logon-user_method. "#EC NOTEXT
            ENDIF.

          ELSE.
*      -- map alias to user
            alias = username_str.
            add_icf_trc `[Prop]; (Basic Authentication available); Alias Name: ` username_str. "#EC NOTEXT
            IF NOT alias IS INITIAL.
              CONCATENATE m_recorder_failed_logon-user_method
              ihttp_recorder_auser_bauth
              INTO m_recorder_failed_logon-user_method.
            ENDIF.

            TRANSLATE alias TO UPPER CASE.               "#EC TRANSLANG
            " Do not use 'SUSR_USER_BNAME_FROM_ALIAS'
*            select single * from usrefus client specified into l_usrefus
*                where mandt      = c_client and
*                      useralias  = alias.
            CALL 'LOGIN_INFO' ID 'OPCODE' FIELD alias_userid_get
            ID 'CLIENT' FIELD c_client
            ID 'ALIAS'  FIELD alias
            ID 'USERID' FIELD basic_user.
*             add_icf_trc `[Prop]; Return Code of Get UserID by Client & Alias Name: ` sy-subrc. "#EC NOTEXT
            IF sy-subrc <> 0 AND
            NOT c_sap_trace IS INITIAL.
              subrc_c = sy-subrc.
              m_recorder_failed_logon-alias_user_check = subrc_c.

              CONCATENATE '<B>Alias: </B>' alias            "#EC NOTEXT
              ', <B>Client: </B>' c_client                  "#EC NOTEXT
              ', <B>Retcode: </B>' subrc_c                  "#EC NOTEXT
              INTO alias_trace SEPARATED BY space.
            ENDIF.
*             c_user = l_usrefus-bname.
          ENDIF. "alias / userID
        ENDIF. "keyword handling (BEARER / BASIC)
      ELSE.
        add_icf_trc `[Prop]; Value of authstring: ` 'INITIAL'. "#EC NOTEXT
      ENDIF. "value not initial
    ENDIF. "authstring not initial
  ENDIF. "logon_by_mservice initial

* -- use service fileds as last default values, if mandatory not used
  IF logon_by_mservice IS INITIAL.
*    if c_user is initial.
    service_user = service-icf_user.
    IF NOT service_user IS INITIAL.
      CONCATENATE m_recorder_failed_logon-user_method
      ihttp_recorder_user_service
      INTO m_recorder_failed_logon-user_method.
      add_icf_trc `[Prop]; (Service User available from Imp. Parameter); User Method: ` m_recorder_failed_logon-user_method. "#EC NOTEXT
*      endif.
    ENDIF.

*    if password is initial.
    service_passwd = service-icf_passwd.
    IF NOT service_passwd IS INITIAL.
      CONCATENATE m_recorder_failed_logon-password_method
      ihttp_recorder_passwd_service
      INTO m_recorder_failed_logon-password_method.
    ENDIF.
*    endif.
  ENDIF.
*
* Determination of user and password
* End
*
***************************************************************************************
  pf_m_open c_statistic_state 'A:Logon'.                    "#EC NOTEXT

* Logon using OAuth Access Token (received via "Authorization: Bearer" header field)
  IF l_oauth_applicable = abap_true.
    authentication_method   = authmethod_oauth.
    authentication_provider = authprovider_oauth.
    CALL METHOD cl_oauth2_s_resource_server=>validate_bearer
      EXPORTING
        i_http_server = server
        i_client      = c_client
        i_language    = c_langu
      IMPORTING
        e_auth_rc     = c_subrc
        e_pwdstate    = c_saprc.

    IF c_subrc = 0.
      c_authenticated = 1.
      c_user = cl_abap_syst=>get_user_name( ).
    ELSE.
      cl_oauth2_s_resource_server=>render_error_response( ).
    ENDIF.
    m_recorder_failed_logon-logon_subrc = c_subrc.
    m_recorder_failed_logon-logon_saprc = c_saprc.
    fill_authentication_methods( subrc = c_subrc
    saprc = c_saprc ).
    delete_security_fields( ).
    RETURN. "Other credentials should not be evaluated
  ENDIF.

  IF c_mysapsso2_available = -1.
    CALL METHOD server->request->get_cookie
      EXPORTING
        name  = 'MYSAPSSO2'
      IMPORTING
        value = sso_import.
    IF sso_import IS INITIAL.
      c_mysapsso2_available = 0.
      add_icf_trc `[Info]; ` 'Authentication: SSO2 cookie not available'. "#EC NOTEXT
*      icf_trc 'Authentication: SSO2 cookie not available'.
    ELSE.
      c_mysapsso2_available = 1.
*      icf_trc 'Authentication: SSO2 cookie is available'.
      add_icf_trc `[Info]; ` 'Authentication: SSO2 cookie is available'. "#EC NOTEXT
    ENDIF.
  ENDIF.
*
* -- determination of logon order
*
* fulfill logon procedure
*

*
* Remark: delete security relevant fields, but first after all necessary logon
* information are determined
*
  delete_security_fields( ).
*
* do not create security session in case of web service requests
*
*  DATA: l_sec_session_required TYPE abap_bool VALUE abap_true.
*  IF service-icf_esi_flag IS NOT INITIAL.
*    l_sec_session_required = abap_false.
*  ENDIF.

*
* logon order: 1 -- logon by mandatory service user account
*

* sum up logon time for statistic
  stime = server_obj->m_timer->get_runtime( ).

  IF l_sec_session_logon_successful = abap_true.
*
* In case of a logon by security session management we only differentiate between two methods:
* 1) Mandatory logon via X509 certificate
* 2) Security session logon, i.e. one of the provided ICF logon procedures.
*
    authentication_provider = authprovider_security_session.
    IF l_mandatory_certificate_logon = abap_true.
      authentication_method = authmethod_certificate.
    ELSE.
      authentication_method = authmethod_security_session.
    ENDIF.

    add_icf_trc `[Prop]; (X.509 Cert./Sec. Session Logon); Auth. Method: ` authentication_method. "#EC NOTEXT

    l_auth_method         = authmethod_security_session.

    c_user                = cl_abap_syst=>get_user_name( ).
    c_subrc = 0.
    c_saprc = l_pw_state.
    subrc = 0.
    c_authenticated = 1.
  ELSEIF m_security_session_active = abap_true AND
  ( public_service = 1 OR logon_by_mservice =  1 ).
*
* No security session management for "public" services. The only supported (ICF/classic)
* logon in this context is a mandatory logon, i.e. logon with configured identity.
*
    l_sec_session_and_pub_service = abap_true.

    IF logon_by_mservice =  1."mandatory logon, i.e. logon with configured identity
* -- update authentication method
      authentication_method = authmethod_service.
      add_icf_trc `[Prop]; (Public/Mandatory Service); Auth. Method: ` authentication_method. "#EC NOTEXT
      c_user                = service_user.
      l_auth_method         = authmethod_service.
*
*     Remark: Do not add the logon method user/password to the security session list in case
*             of manadtory service logon. Those services (mandatory services with maintained logon data)
*             are seen/handled as public services
*
      CALL METHOD me->set_core_authenticate
        EXPORTING
          username                       = service_user
          password_encr                  = service_passwd
          requested_authmethod           = l_auth_method
          do_not_create_security_session = abap_true
        IMPORTING
          subrc                          = subrc
          saprc                          = saprc
        EXCEPTIONS
          invalid_parameter              = 1
          OTHERS                         = 2.

      l_subrc = sy-subrc.
*     assign logon return codes for system/bsp logon
      c_subrc = subrc.
      c_saprc = saprc.
      IF l_subrc = 0 AND subrc = 0.
        c_authenticated = 1.
*     -- no context pooing and sso with service
        CLEAR context_pooling.
*             exit.
      ELSE.
*     basic authentication should be prevented
        no_basic_authentication = 1.
      ENDIF.
      fill_authentication_methods( subrc = subrc
                                   saprc = saprc ).
    ENDIF.

  ELSEIF logon_by_mservice = 1."mandatory logon, i.e. logon with configured identity
* -- update authentication method
    authentication_method = authmethod_service.
    add_icf_trc `[Prop]; (Mandatory Service); Auth. Method: ` authentication_method. "#EC NOTEXT
    c_user                = service_user.
    l_auth_method         = authmethod_service.
*
* Remark: Do not add the logon method user/password to the security session list in case
*         of manadtory service logon. Those services (mandatory services with maintained logon data)
*         are seen/handled as public services
*
    CALL METHOD me->set_core_authenticate
      EXPORTING
        username                       = service_user
        password_encr                  = service_passwd
        requested_authmethod           = l_auth_method
        do_not_create_security_session = abap_true
      IMPORTING
        subrc                          = subrc
        saprc                          = saprc
      EXCEPTIONS
        invalid_parameter              = 1
        OTHERS                         = 2.

    l_subrc = sy-subrc.
* assign logon return codes for system/bsp logon
    c_subrc = subrc.
    c_saprc = saprc.
    IF l_subrc = 0 AND subrc = 0.
      c_authenticated = 1.
* -- no context pooing and sso with service
      CLEAR context_pooling.
*         exit.
    ELSE.
* basic authentication should be prevented
      no_basic_authentication = 1.
    ENDIF.
    fill_authentication_methods( subrc = subrc
                                 saprc = saprc ).

*
* logon order: 2 -- logon by mandatory client certificate
*
  ELSEIF ( ( service-protsec = 'X' OR service-login_process = 'C' ) AND
             l_alias_mapping_failed = abap_false ).
*   -- update authentication method
    authentication_method = authmethod_certificate.
    add_icf_trc `[Prop]; (Mandatory Client Certificate); Auth. Method: ` authentication_method. "#EC NOTEXT
    l_auth_method         = cl_http_security_session_icf=>co_authnmethod_x509cert.

* -- default user = space, but can be overwriten by external fields
    c_user = field_user.

    IF c_certificate_available = 1. "AND
      "c_protocol =  2. "TH_PLUGIN_PROTOCOL_HTTPS

* check if user length fit¬¥s into the sy-uname and is not larger as expected
      lv_usr_length = strlen( lv_user_strg ).
      IF  lv_usr_length > max_usr_length.
        subrc = 1001. saprc = 0.
        add_icf_trc `[Msg]; Following User Name too large: ` lv_user_strg. "#EC NOTEXT
*        CALL METHOD cl_http_server=>trace( trcline ).
        l_subrc = subrc.
*   assign logon return codes for system/bsp logon
        c_subrc = subrc.
        c_saprc = saprc.
      ELSE.
        CALL METHOD me->set_core_authenticate
          EXPORTING
            username                       = field_user   "optional (provided by http client)
            ccertificate                   = c_certificate_available
            requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_x509cert
            security_session_reauth        = l_security_session_reauth
            security_session_user          = l_security_session_user
            security_session_context       = l_security_session_context
            do_not_create_security_session = l_do_not_create_sec_session
          IMPORTING
            subrc                          = subrc
            sso_export                     = m_sso_cookie
            saprc                          = saprc
          EXCEPTIONS
            invalid_parameter              = 1
            OTHERS                         = 2.

        l_subrc = sy-subrc.
*   assign logon return codes for system/bsp logon
        c_subrc = subrc.
        c_saprc = saprc.

        IF l_subrc = 0 AND subrc = 0.
          c_authenticated = 1.

*   -- ? no context pooing and sso with certificates, because of SSL
          IF m_sso_cookie IS INITIAL.
            CLEAR context_pooling.
*              exit.
          ELSE.
            IF NOT c_context_pooling_enabled IS INITIAL.
              context_pooling = m_sso_cookie.
              c_authentication_method_pool = authmethod_certificate.
            ENDIF.
          ENDIF.
        ELSE.
*   basic authentication should be prevented
          no_basic_authentication = 1.
        ENDIF.
        fill_authentication_methods( subrc = subrc
                                     saprc = saprc ).
      ENDIF.
    ELSE.
* -- trace
      subrc = c_certificate_available + 100.
      saprc = c_protocol + 100.
* basic authentication should be prevented
      no_basic_authentication = 1.
      fill_authentication_methods( subrc = subrc
                                   saprc = saprc ).
    ENDIF.
  ENDIF.

* execution of logon procedure due the logon order
* if the user specified a internet user (sap-alias) and the mapping failed, we should not continue
* with logon methods containing SAP Standard user names e.g. certificates, sso cookie etc.
  IF authentication_provider = authprovider_icf AND
     authentication_method = authmethod_none    AND
     l_alias_mapping_failed = abap_false        AND
     l_sec_session_and_pub_service = abap_false.    "no public service with active session management

    add_icf_trc `[Prop]; Flag for 'Use all Logon Procedures': ` service-fallthru. "#EC NOTEXT

    "Check if required kernel function for assertion ticket dc handling is available.
    CALL 'LOGIN_INFO' ID 'OPCODE' FIELD c_assertion_ticket_dc_chk. "#EC CI_CCALL
    IF sy-subrc = 0.
      assert_ticket_dc_chk_enabled = abap_true.
      trcline = 'assert_ticket_dc_chk_enabled is true.'. "#EC NOTEXT
      cl_http_server=>trace( line = trcline ).
    ENDIF.

    LOOP AT logon_order_table INTO logon_method.
      add_icf_trc `[Info]; (LOOP AT logon_order_table); logon_method:` logon_method . "#EC NOTEXT
*
* logon order: 3 -- logon by form/header fields
*
      IF ( logon_method IS INITIAL OR logon_method = 'AUTH_FIELD' )
      AND logon_by_ff = 1.
* -- update authentication method
        authentication_method = authmethod_field.
        add_icf_trc `[Prop]; (Logon by Form Field); Auth. Method: ` authentication_method. "#EC NOTEXT
        l_auth_method         = authmethod_field.
        c_user                = field_user.
* Login XSRF Check - Conditions:
* 1) logon via user and password (form/header fields sap-password and sap-user / sap-alias)
* 2) "system logon" is maintained for the service (UI oriented service !)
*
* The "system logon" sets XSRF (Cross-Site Request Forgery) tokens as cookie and as form field.
* If and only if both XSRF tokens are available and validated successfully, a logon can be processed,
* otherwise (i.e. one of the token is missing or token validation failed) sap-password should not be evaluated,
* and we treat this as failed logon attempt (resulting in the "system logon" being processed).
*

* XSRF logon check only and only if the XSRF logon option is active in system logon configuration
        IF  service-syslog401 = 'X'. "system logon maintained
          lv_xsrf_check_result = abap_false.

          CALL METHOD server_obj->get_service_extension
            EXPORTING
              kind                    = ihttp_icfservice_extension_bsp
            IMPORTING
              configuration           = l_configuration
            EXCEPTIONS
              kind_is_not_supported   = 1
              error_during_processing = 2
              OTHERS                  = 3.
          IF sy-subrc <> 0.
*            MESSAGE s000(sr) WITH
*               'Fehler bei der Systemanmeldung-Konfiguration.'(h02).
            add_icf_trc `[Msg]; Error at 'Get Service Extension' ` 'Error in system logon configuration.'.
          ENDIF.

          lv_xsrf_active = cl_icf_system_login=>is_xsrf_logon_active( login_configuration = l_configuration ).

          IF lv_xsrf_active = abap_true.
            add_icf_trc `[Prop]; Status of XSRF Logon Option for system logon config: ` lv_xsrf_active. "#EC NOTEXT

* Remark: As several SAP systems could be run on the same host therefore XSRF cookie has to contain at least system id
* to avoid ambiguities. The cookie is set for the host. Furthermore XSRF form field id does not contain system id.
            CONCATENATE if_http_form_fields_sap=>sap_login_xsrf '_ ' sy-sysid INTO lv_login_xsrf_id.
            CALL METHOD server->request->get_cookie
              EXPORTING
                name  = lv_login_xsrf_id
              IMPORTING
                value = lv_xsrf_cookie.

            IF lv_xsrf_cookie IS NOT INITIAL.
              add_icf_trc `[Prop]; XSRF Cookie: ` lv_xsrf_cookie. "#EC NOTEXT
* remove the XSRF as soon as possible after validation
* Remark: use never ~path_translated for cookie since the ;-fields are filtered out of the ~path and this lead that the
* IE do not resend the XSRF-Logon cookie for the path (this issue is observed in Business Client) !

              CALL METHOD response->delete_cookie_at_client
                EXPORTING
                  name = lv_login_xsrf_id
                  "See SAP Note 1934153
                  path = '/'.
*                  path = server->request->get_header_field( '~path' ).

* check can take place, as XSRF cookie has been provided.
* Remark: In contrast to the XSRF cookie id the XSRF form field id does not contain system id.
              lv_xsrf_field = server->request->get_form_field( if_http_form_fields_sap=>sap_login_xsrf  ).

              CALL METHOD validate_login_xsrf_token
                EXPORTING
                  cookie_value    = lv_xsrf_cookie
                  formfield_value = lv_xsrf_field
                RECEIVING
                  result          = lv_xsrf_check_result
                EXCEPTIONS
                  internal_error  = 1
                  secstore_error  = 2
                  OTHERS          = 3.

              IF sy-subrc = 0 AND lv_xsrf_check_result = abap_true.
                lv_xsrf_check_result = abap_true.
              ELSE.
                lv_xsrf_check_result = abap_false.
*                MESSAGE 'XSRF check has failed !' TYPE 'S'."#EC NOTEXT
                add_icf_trc `[Msg]; Error at 'validate_login_xsrf_token: '` 'XSRF check has failed !'. "#EC NOTEXT

* Attention: c_saprc = 3001 and 3002 are used in system logon (cl_icf_system_login=>on_icf_call) to raise
* a dedicated error message for error handling in case of failed XSRF.
                c_subrc = 3002.
                c_saprc = 0.
              ENDIF.
            ELSE.
              lv_xsrf_check_result = abap_false.
              add_icf_trc `[Msg]; Get Cookie from HTTP Request; ` 'XSRF cookie missing !'. "#EC NOTEXT

*              MESSAGE 'XSRF cookie missing !' TYPE 'S'.     "#EC NOTEXT
* Attention: c_saprc = 3001 and 3002 are used in system logon (cl_icf_system_login=>on_icf_call) to raise
* a dedicated error message for error handling in case of failed XSRF.
              c_subrc = 3001.
              c_saprc = 0.
            ENDIF.
          ELSE.
            lv_xsrf_check_result = abap_true.
          ENDIF.
        ENDIF.

        IF lv_xsrf_check_result = abap_true.
* check if user and password lengths fit into the sy-uname and password field and are not larger as expected
          lv_usr_length = strlen( lv_user_strg ).
          lv_passwd_length = strlen( lv_passwd_strg ).

          IF  lv_usr_length > max_usr_length.
            subrc = 1001. saprc = 0.
*            concatenate 'Username too large:' lv_user_strg into trcline separated by ' '. "#EC NOTEXT
*            CALL METHOD cl_http_server=>trace( trcline ).
            add_icf_trc `[Msg]; Following User Name too large: ` lv_user_strg. "#EC NOTEXT

            l_subrc = subrc.
* assign logon return codes for system/bsp logon
            c_subrc = subrc.
            c_saprc = saprc.
          ELSEIF lv_passwd_length > max_passwd_length.
            subrc = 1001. saprc = 0.
*            trcline = 'Password too large'.                 "#EC NOTEXT
*            CALL METHOD cl_http_server=>trace( trcline ).
            add_icf_trc `[Msg]; ` 'Password too large'.     "#EC NOTEXT
            l_subrc = subrc.
* assign logon return codes for system/bsp logon
            c_subrc = subrc.
            c_saprc = saprc.
            fill_authentication_methods( subrc = subrc
            saprc = saprc ).

          ELSE.
            CALL METHOD me->set_core_authenticate
              EXPORTING
                username                       = field_user
                password                       = field_passwd
                requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_password
                security_session_reauth        = l_security_session_reauth
                security_session_user          = l_security_session_user
                security_session_context       = l_security_session_context
                do_not_create_security_session = l_do_not_create_sec_session
              IMPORTING
                subrc                          = subrc
                saprc                          = saprc
                sso_export                     = m_sso_cookie
              EXCEPTIONS
                invalid_parameter              = 1
                OTHERS                         = 2.

            l_subrc = sy-subrc.
*   assign logon return codes for system/bsp logon
            c_subrc = subrc.
            c_saprc = saprc.
            IF l_subrc = 0 AND subrc = 0.
              c_authenticated = 1.

*   -- context pooling by SSO, if available
              IF NOT c_context_pooling_enabled IS INITIAL.
                context_pooling = m_sso_cookie.
                c_authentication_method_pool = authmethod_sso.
              ENDIF.
*   -- Tracing
            ENDIF.
            fill_authentication_methods( subrc = subrc
                                         saprc = saprc ).
          ENDIF.
        ENDIF.
*
* logon order: 4 (former order 7) -- logon by client certificate
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_CERT' )
      AND c_certificate_available  = 1
      AND do_not_use_c_certificate = abap_false.

        "AND c_protocol              = 2. "TH_PLUGIN_PROTOCOL_HTTPS.
*   -- update authentication method
        authentication_method = authmethod_certificate.
        add_icf_trc `[Prop]; (Logon by Client Certificate); Auth. Method: ` authentication_method. "#EC NOTEXT

        l_auth_method         = authmethod_certificate.
* -- default user = space, but can be overwriten by external fields
        c_user = field_user.

        lv_usr_length = strlen( lv_user_strg ).
        IF  lv_usr_length > max_usr_length.
          subrc = 1001. saprc = 0.
*          concatenate 'Username too large:' lv_user_strg into trcline separated by ' '. "#EC NOTEXT
*          CALL METHOD cl_http_server=>trace( trcline ).
          add_icf_trc `[Msg]; Following User Name too large: ` lv_user_strg. "#EC NOTEXT

          l_subrc = subrc.
*   assign logon return codes for system/bsp logon
          c_subrc = subrc.
          c_saprc = saprc.
        ELSE.
          CALL METHOD me->set_core_authenticate
            EXPORTING
              username                       = field_user   "optional (provided by http client)
              ccertificate                   = c_certificate_available
              requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_x509cert
              security_session_reauth        = l_security_session_reauth
              security_session_user          = l_security_session_user
              security_session_context       = l_security_session_context
              do_not_create_security_session = l_do_not_create_sec_session
            IMPORTING
              subrc                          = subrc
              sso_export                     = m_sso_cookie
              saprc                          = saprc
            EXCEPTIONS
              invalid_parameter              = 1
              OTHERS                         = 2.

          l_subrc = sy-subrc.
*   assign logon return codes for system/bsp logon
          c_subrc = subrc.
          c_saprc = saprc.
          IF l_subrc = 0 AND subrc = 0.
            c_authenticated = 1.

*   -- ? no context pooing and sso with certificates, because of SSL
            IF m_sso_cookie IS INITIAL.
              CLEAR context_pooling.
*            exit.
            ELSE.
              IF NOT c_context_pooling_enabled IS INITIAL.
                context_pooling = m_sso_cookie.
                c_authentication_method_pool = authmethod_certificate.
              ENDIF.
            ENDIF.
          ELSE.
            IF NOT c_instance_id IS INITIAL.
              myserver = c_instance_id.
*             translate myserver to lower case.  "#EC TRANSLANG
            ELSE.
              CALL FUNCTION 'RFC_SYSTEM_INFO'
                IMPORTING
                  rfcsi_export          = l_rfcsi
                EXCEPTIONS
                  communication_failure = 1
                  system_failure        = 2
                  OTHERS                = 3.
              IF sy-subrc = 0.
                myserver = l_rfcsi-rfcdest.
*               translate myserver to lower case.  "#EC TRANSLANG
              ENDIF.
            ENDIF.

*   -- client has value depenedent reject list
            IF NOT ssolist IS INITIAL.
              CONCATENATE ssolist co_cctoken_reject
              myserver '_' c_client
              INTO ssolist.
            ELSE.
              CONCATENATE co_cctoken_reject
              myserver '_' c_client
              INTO ssolist.
            ENDIF.
            add_icf_trc `[Prop]; (Logon by Client Certificate); SSO List: ` ssolist. "#EC NOTEXT
*   -- add my instance to negative list
            ssolist_b64 = encode_base64( ssolist ).
            CALL FUNCTION 'HTTP_SET_SSOLIST_COOKIE'
              EXPORTING
                server = server
                list   = ssolist_b64.
          ENDIF.
          fill_authentication_methods( subrc = subrc
                                       saprc = saprc ).
        ENDIF.
*
* logon order: 5.1/5.2 (former order 4) -- Logon by SSO Logon ticket or Securiyt Session ID
* --   --  before basic auth. because of USER_SWITCH
* Added AND header_sso_available = abap_false. Now only SSO2-Cookie (header_sso_available = abap_false)
* will go to this piece of coding. Tickets which go along with header-field "MYSAPSSO" then will
* go thru the next ELSEIF (header_sso_available = abap_true)

      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SSO' )
      AND NOT sso_import IS INITIAL AND (
      ( header_sso_available = abap_false AND assert_ticket_dc_chk_enabled = abap_true ) OR
       assert_ticket_dc_chk_enabled = abap_false ).

* -- update authentication method
        authentication_method = authmethod_sso.
        "add_icf_trc `[Prop]; (Logon by SSO Logon ticket); Auth. Method: ` authentication_method. "#EC NOTEXT
        trcline = 'Logon by SSO Logon ticket...'. "#EC NOTEXT
        cl_http_server=>trace( line = trcline ).
        l_auth_method         = authmethod_sso.
*      icf_trc 'Authentication: authentication method is SSO'. "EC_NOTEXT

        CALL METHOD me->set_core_authenticate
          EXPORTING
            sso_import                     = sso_import
            requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_logonticket
            security_session_reauth        = l_security_session_reauth
            security_session_user          = l_security_session_user
            security_session_context       = l_security_session_context
            do_not_create_security_session = l_do_not_create_sec_session
          IMPORTING
            subrc                          = subrc
            saprc                          = saprc
          EXCEPTIONS
            invalid_parameter              = 1
            OTHERS                         = 2.

        l_subrc = sy-subrc.
* assign logon return codes for system/bsp logon
        c_subrc = subrc.
        c_saprc = saprc.
        IF l_subrc = 0 AND subrc = 0 .
*         icf_trc 'Authentication: sso authentication successful'.
          c_authenticated = 1.
* --  context pooling strategy and SSO
          IF NOT c_context_pooling_enabled IS INITIAL.
            context_pooling = sso_import.
            c_authentication_method_pool = authmethod_sso.
          ENDIF.
        ELSE.
*          icf_trc 'Authentication: sso ticket not accepted'.  "EC_NOTEXT
          " --- Check for expired SSO ticket ---
          IF l_subrc = 0 AND c_subrc = 24 AND c_saprc = 0.
            " --- Expired Ticket, delete expired ticket.
            CALL FUNCTION 'HTTP_DELETE_SSO2_COOKIE'
              EXPORTING
                server = server.
*            icf_trc 'Authentication: expired sso ticket deleted'. "EC_NOTEXT
          ELSE.
*   -- delete sso ticket at client side
*         c_delete_sso2_cookie = 1.
*          call function 'HTTP_DELETE_SSO2_COOKIE'
*                exporting
*                   server        = server.

*   -- add my instance to ssolist list ?
            IF myserver IS INITIAL.
*   my instance id
              IF NOT c_instance_id IS INITIAL.
                myserver = c_instance_id.
*             translate myserver to lower case.  "#EC TRANSLANG
              ELSE.
                CALL FUNCTION 'RFC_SYSTEM_INFO'
                  IMPORTING
                    rfcsi_export          = l_rfcsi
                  EXCEPTIONS
                    communication_failure = 1
                    system_failure        = 2
                    OTHERS                = 3.
                IF sy-subrc = 0.
                  myserver = l_rfcsi-rfcdest.
*               translate myserver to lower case.  "#EC TRANSLANG
                ENDIF.
              ENDIF.
            ENDIF.

*   -- create SSO2 hash value
            CLEAR l_hash160.
            CALL FUNCTION 'CALCULATE_HASH_FOR_CHAR'
              EXPORTING
                alg            = 'SHA1'
                data           = sso_import
              IMPORTING
                hash           = l_hash160
              EXCEPTIONS
                unknown_alg    = 1
                param_error    = 2
                internal_error = 3
                OTHERS         = 4.
            IF sy-subrc <> 0.
*   -- entry without hash value
              CLEAR l_hash160.
            ENDIF.

*   -- client and has value depenedent reject list
            IF NOT ssolist IS INITIAL.
              CONCATENATE ssolist co_ssotoken_reject
              myserver '_' c_client '_' l_hash160
              INTO ssolist.
            ELSE.
              CONCATENATE co_ssotoken_reject
              myserver '_' c_client '_' l_hash160
              INTO ssolist.
            ENDIF.
            add_icf_trc `[Prop]; Logon by SSO Logon ticket); SSO List: ` ssolist. "#EC NOTEXT
*   -- add my instance to negative list
            ssolist_b64 = encode_base64( ssolist ).
            CALL FUNCTION 'HTTP_SET_SSOLIST_COOKIE'
              EXPORTING
                server = server
                list   = ssolist_b64.

          ENDIF.
        ENDIF.
        fill_authentication_methods( subrc = subrc
                                     saprc = saprc ).
*
* logon order: 6 (new logon type introduced in 7.20 on the 26.08.2008) -- Logon by AUTH_ASSERT - SAP Assertion Ticket
* --   --  before basic auth. because of USER_SWITCH
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_ASSERT' )
      AND NOT sso_import IS INITIAL AND header_sso_available = abap_true.

*
* we categorize a SSO ticket in two types:
* SAP logon ticket: SSO ticket is transfered via cookie
* SAP assertion ticket: SSO ticket is transfered via header field.
* A logon via assertion is only initiated, if and only if the SSO ticket is received via header field.
* A logon via SSO is triggerd for both types, SAP logon ticket as well as SAP assertion ticket.
* Attention: An SSO ticket received via header filed could stil be an assirtion ticket,
* since in SM59 (in 712 releases) and in the earliere releases (e.g. 640) also SAP logon
* tickets are tranfered via header field.
*
* -- update authentication method
        authentication_method = authmethod_assertion.   " logon via assertion ticket
        "add_icf_trc `[Prop]; (Logon by Assertion Ticket); Auth. Method: ` authentication_method. "#EC NOTEXT
        trcline = 'Logon by Assertion Ticket...'. "#EC NOTEXT
        cl_http_server=>trace( line = trcline ).
        l_auth_method         = authmethod_assertion.
        CALL METHOD me->set_core_authenticate
          EXPORTING
            sso_import                     = sso_import
            is_assertion_ticket            = abap_true
            requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_assertionticket
            security_session_reauth        = l_security_session_reauth
            security_session_user          = l_security_session_user
            security_session_context       = l_security_session_context
            do_not_create_security_session = l_do_not_create_sec_session
          IMPORTING
            subrc                          = subrc
            saprc                          = saprc
          EXCEPTIONS
            invalid_parameter              = 1
            OTHERS                         = 2.

        l_subrc = sy-subrc.
* assign logon return codes for system/bsp logon
        c_subrc = subrc.
        c_saprc = saprc.
        IF l_subrc = 0 AND subrc = 0 .
          c_authenticated = 1.
* --  context pooling strategy and SSO
          IF NOT c_context_pooling_enabled IS INITIAL.
            context_pooling = sso_import.
            c_authentication_method_pool = authmethod_sso.
          ENDIF.
        ELSE.
* -- delete sso ticket at client side
*       c_delete_sso2_cookie = 1.
*        call function 'HTTP_DELETE_SSO2_COOKIE'
*              exporting
*                 server        = server.

* -- add my instance to ssolist list ?
          IF myserver IS INITIAL.
* my instance id
            IF NOT c_instance_id IS INITIAL.
              myserver = c_instance_id.
*           translate myserver to lower case.  "#EC TRANSLANG
            ELSE.
              CALL FUNCTION 'RFC_SYSTEM_INFO'
                IMPORTING
                  rfcsi_export          = l_rfcsi
                EXCEPTIONS
                  communication_failure = 1
                  system_failure        = 2
                  OTHERS                = 3.
              IF sy-subrc = 0.
                myserver = l_rfcsi-rfcdest.
*             translate myserver to lower case.  "#EC TRANSLANG
              ENDIF.
            ENDIF.
          ENDIF.

* -- create SSO2 hash value
          CLEAR l_hash160.
          CALL FUNCTION 'CALCULATE_HASH_FOR_CHAR'
            EXPORTING
              alg            = 'SHA1'
              data           = sso_import
            IMPORTING
              hash           = l_hash160
            EXCEPTIONS
              unknown_alg    = 1
              param_error    = 2
              internal_error = 3
              OTHERS         = 4.
          IF sy-subrc <> 0.
* -- entry without hash value
            CLEAR l_hash160.
          ENDIF.

* -- client and has value depenedent reject list
          IF NOT ssolist IS INITIAL.
            CONCATENATE ssolist co_ssotoken_reject
            myserver '_' c_client '_' l_hash160
            INTO ssolist.
          ELSE.
            CONCATENATE co_ssotoken_reject
            myserver '_' c_client '_' l_hash160
            INTO ssolist.
          ENDIF.
          add_icf_trc `[Prop]; (Logon by Assertion Ticket); SSO List: ` ssolist. "#EC NOTEXT

* -- add my instance to negative list
          ssolist_b64 = encode_base64( ssolist ).
          CALL FUNCTION 'HTTP_SET_SSOLIST_COOKIE'
            EXPORTING
              server = server
              list   = ssolist_b64.

        ENDIF.
        fill_authentication_methods( subrc = subrc
                                     saprc = saprc ).
*
* logon order: 6 (former 5. Moved by introduction SSO_ASSERT) -- logon by Basic authorization field
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_BASIC' )
      AND NOT basic_user IS INITIAL
      AND NOT basic_passwd IS INITIAL.
* -- update authentication method
        authentication_method = authmethod_basic.
        add_icf_trc `[Prop]; (Logon by Basic Authentication); Auth. Method: ` authentication_method. "#EC NOTEXT
        l_auth_method         = authmethod_basic.
        c_user                = basic_user.

* check if user and password lengths fit into the sy-uname and password field and are not larger as expected
        lv_usr_length = strlen( username_str ).
        lv_passwd_length = strlen( password_str ).
        IF ( service-aliaslogin IS INITIAL AND lv_usr_length > max_usr_length ) OR
        ( service-aliaslogin IS NOT INITIAL AND lv_usr_length > max_alias_length ).
          subrc = 1001. saprc = 0.
*          concatenate 'Username too large:' lv_user_strg into trcline separated by ' '. "#EC NOTEXT
*          CALL METHOD cl_http_server=>trace( trcline ).
          add_icf_trc `[Msg]; Following User Name too large: ` lv_user_strg. "#EC NOTEXT
          l_subrc = subrc.
* assign logon return codes for system/bsp logon
          c_subrc = subrc.
          c_saprc = saprc.
        ELSEIF lv_passwd_length > max_passwd_length.
          subrc = 1001. saprc = 0.
*          trcline = 'Password too large'.                   "#EC NOTEXT
*          CALL METHOD cl_http_server=>trace( trcline ).
          add_icf_trc `[Msg]; ` 'Password too large'.       "#EC NOTEXT
          l_subrc = subrc.
* assign logon return codes for system/bsp logon
          c_subrc = subrc.
          c_saprc = saprc.
        ELSE.
          CALL METHOD me->set_core_authenticate
            EXPORTING
              username                       = basic_user
              password                       = basic_passwd
              requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_password
              security_session_reauth        = l_security_session_reauth
              security_session_user          = l_security_session_user
              security_session_context       = l_security_session_context
              do_not_create_security_session = l_do_not_create_sec_session
            IMPORTING
              subrc                          = subrc
              saprc                          = saprc
              sso_export                     = m_sso_cookie
            EXCEPTIONS
              invalid_parameter              = 1
              OTHERS                         = 2.

          l_subrc = sy-subrc.
*   assign logon return codes for system/bsp logon
          c_subrc = subrc.
          c_saprc = saprc.
          IF l_subrc = 0 AND subrc = 0.
            c_authenticated = 1.
*   -- prefer pooling with sso, if login/accept_sso2_ticket = 1, otherwise
*   -- use Basic authentication as pooling,
*   -- since for user switch SSO2 is used. If no SSO2 exists -> than use
*   -- context pooling with 'Basic' token
            IF NOT c_context_pooling_enabled IS INITIAL.
              IF m_sso_cookie IS INITIAL.
                context_pooling = authstring.
                c_authentication_method_pool = authmethod_basic.
              ELSE.
*     Coontext pooling never by Basic authentication !!!

*               data: active type c,
*                     i_active type i.
*               call 'C_SAPGPARAM'
*                    id 'NAME' field 'login/accept_sso2_ticket'
*                    id 'VALUE' field active.
*               if sy-subrc <> 0.
*                  active = '0'.
*               endif.
*               i_active = active.
                IF c_accept_sso2_ticket > 0.
                  context_pooling = m_sso_cookie.
                  c_authentication_method_pool = authmethod_sso.
                ELSE.
                  context_pooling = authstring.
                  c_authentication_method_pool = authmethod_basic.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
          fill_authentication_methods( subrc = saprc
                                       saprc = subrc ).
        ENDIF.
*
* logon order: 7 (former 6. Moved by introduction SSO_ASSERT) -- logon by R3Auth field
* --   -- R/3-R/3 communication based on RFC procedure
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SAP' )
      AND NOT r3_auth IS INITIAL.

        DATA: r3_auth_x TYPE xstring.
        DATA: l_sso TYPE c LENGTH 4096."I.e. SSO2_LOGON_TICKET_SIZE_CHAR in absignon.h
        DATA: l_length TYPE i VALUE 4096.
        DATA: l_trusted TYPE string.
        DATA: l_security_session_localauth TYPE security_session_authn_method.
        r3_auth_x = r3_auth.
* -- update authentication method
        authentication_method = authmethod_sap.
        add_icf_trc `[Prop]; (Logon by SAP Authentication); Auth. Method: ` authentication_method. "#EC NOTEXT
        CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
        ID 'RFCLogon' FIELD 'X'
*                          id 'TimeStamp' field TimeStamp
*                          id 'CIP' field cip
*                          id 'CHost' field chost
*                          id 'CServer' field cserver
        ID 'SessionID' FIELD r3_auth_x
        ID 'SSO2_EXPORT' FIELD l_sso
        ID 'SSO2_LENGTH' FIELD l_length
        ID 'Trusted'     FIELD l_trusted.
        subrc = sy-subrc.
* assign logon return codes for system/bsp logon
        c_subrc = 0.
        c_saprc = 0.
        IF subrc = 0.
          c_authenticated = 1.
          IF l_trusted IS INITIAL.
            l_security_session_localauth  = cl_http_security_session_icf=>co_authnmethod_localhttpcall.
            IF l_do_not_create_sec_session = abap_false AND m_security_session_active = abap_true.
              m_sec_session_pending_local   = abap_true. "note 1962529, part 2
            ENDIF.
          ELSE.
            l_security_session_localauth  = cl_http_security_session_icf=>co_authnmethod_trustedsystem.
            IF l_do_not_create_sec_session = abap_false AND m_security_session_active = abap_true.
              m_sec_session_pending_trusted = abap_true. "note 1962529, part 2
            ENDIF.
          ENDIF.

          CALL METHOD me->set_core_authenticate
            EXPORTING
              requested_authmethod           = l_security_session_localauth "R3Auth
              security_session_reauth        = l_security_session_reauth
              security_session_user          = l_security_session_user
              security_session_context       = l_security_session_context
              do_not_create_security_session = abap_true "note 1962529
            EXCEPTIONS
              invalid_parameter              = 1
              OTHERS                         = 2.

* Create and transfer SSO ticket to caller SAP Web AS for later reauthentication in case of
* stateful communication
          IF l_length > 0 AND l_length < 4096.
            m_sso_cookie = l_sso(l_length).
          ELSE.
            m_sso_cookie = l_sso.
          ENDIF.
* Context pooling strategy kann bei RFC-Verschl. nie funktionieren
* Da der Key sich zeitabhaengig aendert
*         context_pooling = sso_import.
          subrc = 0.
* -- no context pooing and sso with service
          CLEAR context_pooling.
*         exit.
        ENDIF.
        fill_authentication_methods( subrc = subrc
                                     saprc = 0 ).
*
* logon order: 8 -- logon by SPNEGO
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SPNEGO' )
      AND  l_spnego_active   = abap_true
      AND  do_not_use_spnego = abap_false.

        IF spnego_token IS INITIAL.
          add_icf_trc `[Info];` '(Logon by SPNEGO, 1st request)' . "#EC NOTEXT
          "1st request: prevent requesting SPnego token multiple times (loop)
          CALL METHOD server->request->get_cookie
            EXPORTING
              name  = co_spnego_requested_cookie
            IMPORTING
              value = l_spnego_cookie.

          IF l_spnego_cookie IS INITIAL.
            "memorize that SPNego token was requested (setting cookie)
            GET TIME STAMP FIELD l_timestamp.

            "set HTTPonly and secure attribute SAP note 2387204
            DATA: lv_onlyhttps_spn  TYPE c LENGTH 4.
            DATA: lv_subrc_spn      TYPE sysubrc.
            DATA: lv_secure_spn     TYPE i.

            CALL 'C_SAPGPARAM'
              ID 'NAME' FIELD 'login/ticket_only_by_https'
              ID 'VALUE' FIELD lv_onlyhttps_spn.
            lv_subrc_spn = sy-subrc.
            "per default set HTTPonly flag for SPNegoTokenRequested cookie
            IF  lv_subrc_spn  =  0  AND  lv_onlyhttps_spn  =  '1'.
              lv_secure_spn  =  17.
            ELSE.
              lv_secure_spn  =  16.
            ENDIF.

            CALL METHOD server->response->set_cookie
              EXPORTING
                name  = co_spnego_requested_cookie
                value = |{ l_timestamp TIMESTAMP = SPACE }|
                path  = '/'
                secure = lv_secure_spn.
            "sending out http response (requesting SPNego token)
            add_icf_trc `[Info]; ` 'Request SPNego Token (1st response)'. "#EC NOTEXT
            CALL METHOD cl_spnego_runtime=>render_token_request
              EXPORTING
                i_http_server = server.
*         delete_security_fields( ).
*         send_response(  ).
*         return.
          ENDIF.
        ELSE.
          "2nd request: validate SPNego token
          authentication_method = authmethod_spnego.
          add_icf_trc `[Prop]; (Logon by SPNEGO, 2nd request); Auth. Method: ` authentication_method. "#EC NOTEXT

          "delete 'SPNego was requested' cookie (no longer required)
          CALL METHOD response->delete_cookie_at_client
            EXPORTING
              name = co_spnego_requested_cookie
              path = '/'.

          "validate SPNego token, create /update security session
          CALL METHOD me->set_core_authenticate
            EXPORTING
              spnego_token                   = spnego_token
              requested_authmethod           = cl_http_security_session_icf=>co_authnmethod_spnego
              security_session_reauth        = l_security_session_reauth
              security_session_user          = l_security_session_user
              security_session_context       = l_security_session_context
              do_not_create_security_session = l_do_not_create_sec_session
            IMPORTING
              subrc                          = subrc "logon return code (0 = o.k.)
              saprc                          = saprc "password status flag (type XUPWDSTATE)
              sso_export                     = m_sso_cookie "note 2044027
            EXCEPTIONS
              invalid_parameter              = 1
              OTHERS                         = 2.

          IF sy-subrc = 0 AND subrc = 0.
            "SPNego logon succeeded
            c_authenticated = 1.
            IF m_security_session_active = abap_true AND
            m_security_session_cookie IS NOT INITIAL.
              add_icf_trc `[Info]; ` 'Security Session is created'. "#EC NOTEXT
              m_security_session_created = abap_true.
            ENDIF.
          ELSE.
            "SPNego logon failed -> set ssolist for Spnego
            IF NOT c_instance_id IS INITIAL.
              myserver = c_instance_id.
            ELSE.
              CALL FUNCTION 'RFC_SYSTEM_INFO'
                IMPORTING
                  rfcsi_export          = l_rfcsi
                EXCEPTIONS
                  communication_failure = 1
                  system_failure        = 2
                  OTHERS                = 3.
              IF sy-subrc = 0.
                myserver = l_rfcsi-rfcdest.
              ENDIF.
            ENDIF.

            IF NOT ssolist IS INITIAL.
              CONCATENATE ssolist co_spnego_token_reject
              myserver '_' c_client
              INTO ssolist.
            ELSE.
              CONCATENATE co_spnego_token_reject
              myserver '_' c_client
              INTO ssolist.
            ENDIF.
            ssolist_b64 = encode_base64( ssolist ).
            CALL FUNCTION 'HTTP_SET_SSOLIST_COOKIE'
              EXPORTING
                server = server
                list   = ssolist_b64.
          ENDIF.

          "assign logon return codes for system/bsp logon
          c_subrc = subrc.
          c_saprc = saprc.
          fill_authentication_methods( subrc = subrc
                                       saprc = saprc ).
        ENDIF.
*
* logon order: 9 -- logon by SAML
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SAML' )
      AND  l_saml_active = abap_true.

* -- load SAML configuration, if available
        CALL METHOD server_obj->get_service_extension
          EXPORTING
            kind                    = ihttp_icfservice_extension_sam
          IMPORTING
            configuration           = l_configuration
          EXCEPTIONS
            kind_is_not_supported   = 1
            error_during_processing = 2
            OTHERS                  = 3.

*     If SAML configuration cannot be read successfully, the
*     logon must be terminated. We must not proceed with
*     default configuration, because this is a security risk
*     (default configuration has more lax security settings
*     as the customer specific configuration might have).
        IF sy-subrc <> 0.
          add_icf_trc `[Msg]; Error at 'Get Service Extension' ` 'Error in SAML configuration.'. "#EC NOTEXT
        ENDIF.

        CLEAR context_pooling.

        CALL METHOD cl_icf_saml_login=>process_logon
          EXPORTING
            server              = server
            client              = c_client
            language            = c_langu
            configuration       = l_configuration
            login_methods       = logon_order
            if_message          = saml_message
          IMPORTING
            auth_rc             = subrc
            pwdstate            = saprc
            sso2_ticket         = m_sso_cookie
            security_session_id = m_security_session_cookie
          EXCEPTIONS
            is_not_applicable   = 1
            error_occured       = 2
            OTHERS              = 3.

        IF sy-subrc <> 1. " SAML is applicable
* -- update authentication method
          authentication_method = authmethod_saml.
          add_icf_trc `[Prop]; (Logon by SAML); Auth. Method: ` authentication_method. "#EC NOTEXT

* -- set authentication result for ICF
          l_subrc = sy-subrc.
          c_subrc = subrc.
          c_saprc = saprc.
          IF l_subrc = 0 AND subrc = 0.
*   is logon successfully fulfilled ?
            CALL FUNCTION 'RFC_LOGON_INFO'
              IMPORTING
                rfc_login_complete = login_complete
              EXCEPTIONS
                OTHERS             = 1.                     "#EC *
            IF login_complete = 'Y'.
              c_authenticated = 1.
              IF m_security_session_active = abap_true AND
              m_security_session_cookie IS NOT INITIAL.
                m_security_session_created = abap_true.
                add_icf_trc `[Info]; ` 'Security Session is created'. "#EC NOTEXT
              ENDIF.
            ENDIF.
          ENDIF.
*   assign logon return codes for system/bsp logon
          fill_authentication_methods( subrc = subrc
                                       saprc = saprc ).
        ENDIF.
*
* logon order: 10 -- logon by service user account
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SERVI' )
      AND NOT service_passwd IS INITIAL.

* -- update authentication method
        authentication_method = authmethod_service.
        add_icf_trc `[Prop]; (Logon by Service User); Auth. Method: ` authentication_method. "#EC NOTEXT

        l_auth_method         = authmethod_service.
        c_user                = service_user.

        CALL METHOD me->set_core_authenticate
          EXPORTING
            username                       = service_user
            password_encr                  = service_passwd
            requested_authmethod           = l_auth_method
            do_not_create_security_session = abap_true
          IMPORTING
            subrc                          = subrc
            saprc                          = saprc
          EXCEPTIONS
            invalid_parameter              = 1
            OTHERS                         = 2.

        l_subrc = sy-subrc.
* assign logon return codes for system/bsp logon
        c_subrc = subrc.
        c_saprc = saprc.
        IF l_subrc = 0 AND subrc = 0.
          c_authenticated = 1.
* -- no context pooing and sso with service
          CLEAR context_pooling.
*         exit.
        ENDIF.
        fill_authentication_methods( subrc = subrc
                                     saprc = saprc ).
      ENDIF.

* logon time for statistic
      etime = server_obj->m_timer->get_runtime( ).
      m_authentication_time = m_authentication_time + ( etime - stime ).

*
* execution of logon procedure
*
      IF authentication_method <> authmethod_none.
        IF service-fallthru IS INITIAL.
*   check of one possible method
          EXIT.
        ELSEIF c_authenticated = 1.
*   check of all possible methods, until successful logon, if happen
          EXIT.
        ENDIF.
      ENDIF.

    ENDLOOP.
  ENDIF.

  IF authentication_method = authmethod_none.
* if no user mapping to alias user found transfer the logon control to system logon (if ncessary),
* with the appropriate information (see customer message 502988/2007). Do so as if the
* logon is failed with the proper return codes.
    add_icf_trc `[Prop]; (Logon by Authentication Method None); Auth. Method: ` authentication_method. "#EC NOTEXT

    IF l_alias_mapping_failed = abap_true and field_passwd is not initial.
      c_subrc = 1.
      c_saprc = -2.
    ENDIF.

* additional logon procedure ????
    subrc = 99.
    fill_authentication_methods( subrc = subrc
                                 saprc = saprc ).
  ENDIF.

*
* -- login succeeded -> set SSO2 in cookie and context pooling part
*
  m_recorder_failed_logon-logon_subrc = subrc.
  m_recorder_failed_logon-logon_saprc = saprc.
  IF ssl_active = co_enabled.
    m_recorder_failed_logon-ssl_availabale = co_enabled.
  ENDIF.

*
* common criteria certification:
* avoid successful login execution for initial/expired passwords in case
* of system/BSP logon procedure
*
  IF c_saprc         > 0   AND
  c_authenticated = 1.
    DATA: l_reject_login TYPE i VALUE 0.
*
* reject login for expired/initial users for the following cases:
* 1. requests for BSP logon page resides in ICF public path
* 2. requests for regular services with maintained system/BSP logon page
*
    add_icf_trc `[Info]; Starting of: ` 'Handling of successful login execution for initial/expired passwords'. "#EC NOTEXT

    IF public_service = 1.
      DATA: l_path_trans TYPE string.
      l_path_trans =
      server->request->get_header_field( '~path_translated' ).
      IF l_path_trans = '/sap/public/bsp/sap/system/login.htm' OR
      l_path_trans = '/sap/public/bsp/sap/system/changepw.htm'.
        l_reject_login = 1.
        l_trace = | VALUE OF PUBLIC Service = { public_service } AND VALUE OF REJECT Login = { l_reject_login } |.
        add_icf_trc `[Prop]; ` l_trace.                     "#EC NOTEXT
      ENDIF.
    ELSEIF service-kind401 = 'Y' OR
    ( service-kind401 = 'X' AND
    ( service-url401 = '/sap/public/bsp/sap/system/login.htm' OR
    service-url401 = '/sap/public/bsp/sap/system/changepw.htm' ) ).
* for old BSP logon proceed with redirect
      l_reject_login = 1.
      l_trace = | VALUE OF service-kind401 = { service-kind401 } AND VALUE OF REJECT Login = { l_reject_login } |.
      add_icf_trc `[Prop]; ` l_trace.                       "#EC NOTEXT
    ELSE. " In case of system logon page is not configured.
      CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'icf/reject_expired_passwd'
                         ID 'VALUE' FIELD l_icf_value.
      IF l_icf_value = 1.
        c_authenticated = 0.
      ENDIF.
    ENDIF.

    IF l_reject_login = 1.
*logon xsrf for Change Password - Start
*Set logon xsrf cookie for Change Password screen
*Change Password screen is an unauthenticated request
*it is authenticated with old password but for that to happen
*it has to provide a logon xsrf cookie first
*for the request to provide logon xsrf cookie, it has to be set first :-)
*here we set it

      DATA: lv_onlyhttps      TYPE c LENGTH 4.
      DATA: lv_subrc          TYPE sysubrc.
      DATA: lv_secure         TYPE i.

*Note 1929188 - Start
* lv_xsrf_active is not set if this code block is not reached via form fields authentication
* example: when users login via basic authentication with initial password, the code flow
* will reach this place with lv_xsrf_active not set

      CALL METHOD server_obj->get_service_extension
        EXPORTING
          kind                    = ihttp_icfservice_extension_bsp
        IMPORTING
          configuration           = l_configuration
        EXCEPTIONS
          kind_is_not_supported   = 1
          error_during_processing = 2
          OTHERS                  = 3.
      IF sy-subrc <> 0.
*          MESSAGE s000(sr) WITH
*          'Fehler bei der Systemanmeldung-Konfiguration.'(h02).
        add_icf_trc `[Msg]; Error at 'Get Service Extension' ` 'Error in system logon configuration.'.
      ENDIF.

      lv_xsrf_active = cl_icf_system_login=>is_xsrf_logon_active( login_configuration = l_configuration ).

*Note 1929188 - End

* XSRF logon check only and only if the XSRF logon option is active in system logon configuration
      IF lv_xsrf_active = abap_true.
        CALL METHOD create_login_xsrf_token
          IMPORTING
            cookie_value    = lv_xsrf_cookie
            formfield_value = lv_xsrf_formfield
          EXCEPTIONS
            internal_error  = 1
            secstore_error  = 2
            OTHERS          = 3.

        IF sy-subrc <> 0 OR lv_xsrf_cookie IS INITIAL OR lv_xsrf_formfield IS INITIAL.
          MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.

        CALL 'C_SAPGPARAM'
        ID 'NAME' FIELD 'login/ticket_only_by_https'
        ID 'VALUE' FIELD lv_onlyhttps.
        lv_subrc = sy-subrc.

* per default set HTTPonly flag for XSRF logon cookie
        IF lv_subrc = 0 AND lv_onlyhttps = '1'.
          lv_secure = 17.
        ELSE.
          lv_secure = 16.
        ENDIF.

* Remark: As several SAP systems could be run on the same hostz therefore XSRF cookie has to contain at least system id
* to avoid ambiguities. The cookie is set for the host.
        CONCATENATE if_http_form_fields_sap=>sap_login_xsrf '_ ' sy-sysid INTO lv_login_xsrf_id.
* Remark: use never ~path_translated for cookie since the ;-fields are filtered out of the ~path and this lead that the
* IE do not resend the XSRF-Logon cookie for the path (this issue is observed in Business Client) !

        CALL METHOD server->response->set_cookie
          EXPORTING
            name   = lv_login_xsrf_id
            value  = lv_xsrf_cookie
            "See SAP Note 1934153
            path   = '/'
*           path   = server->request->get_header_field( '~path' )
            secure = lv_secure.

      ENDIF.
*logon xsrf for Change Password - End
      c_authenticated = -1.
      authentication_method = authmethod_none.
      add_icf_trc `[Prop]; (Logon by Authentication Method None); Auth. Method: ` authentication_method. "#EC NOTEXT
* do not send SSO cookie
      FREE m_sso_cookie.
    ENDIF.
  ENDIF.

  IF c_authenticated =  1 OR
  c_authenticated = -1.

    IF ( c_authenticated        = 1  )         AND
    ( do_not_use_sso2_ticket IS INITIAL )   AND
    ( NOT m_sso_cookie IS INITIAL )         AND
    ( c_mysapsso2_available <> 1 ).
*  -- set sso2 cookie and delete sap-ssolist, if exists
*  -- Bemerkung: wenn der host keine domain hat, dann wird der host
*  --- als domain gesetz in 'HTTP_SET_SSO2_COOKIE'
*          call function 'HTTP_SET_SSO2_COOKIE'
*             exporting
*               server        = server
*               sso2          = m_sso_cookie.

*  -- mysapsso2 is created and set (info for system logon)
      server_obj->m_mysapsso2_created = 2.
    ELSEIF NOT m_sso_cookie IS INITIAL.
*  -- mysapsso2 is created, but not set (info for system logon)
      server_obj->m_mysapsso2_created = 1.
    ENDIF.
*
* is Webgui (/sap/bc/gui/sap/its/webgui) service active ?
* in that case ICFX uses stateful session with URL-rewriting when
* form-field based authentication is maintained
* furthermore no SSO ticket should be set in response
* Supplement (26.04.2007/20.05.2007): This feature should be available/provided to all
*                          ITS services. This is GUI link is active and ITS handler is in place
*
    IF l_is_webgui = abap_true.
      CLEAR m_sso_cookie.
      do_not_use_sso2_ticket = 1.
*     m_mysapsso2_created = -2.
    ENDIF.

    IF NOT c_sap_trace IS INITIAL.
      subrc_c = subrc.
      saprc_c = saprc.
      CALL METHOD logon_trace
        EXPORTING
          request = server->request
          method  = authentication_method
          subrc   = subrc_c
          saprc   = saprc_c
        CHANGING
          trace   = my_trace.
    ENDIF.

* -- system login execution for initial/expired passwords
    IF service-syslog401 = 'X'.
      add_icf_trc `[Info]; Starting of: ` 'System Login Execution for initial/expired Passwords'. "#EC NOTEXT
* -- should system login be processed again (e. g. for password changes)
      l_login_not_complete = request->get_form_field( name = 'sap-system-login' ). "#EC NOTEXT
      IF l_login_not_complete IS NOT INITIAL OR c_saprc GT 0.
        add_icf_trc `[Info]; Calling of: ` 'Get Service Extension'. "#EC NOTEXT
* -- load system logon configuration, if available
*          if service-syslogin = 'Y'.
        CALL METHOD server_obj->get_service_extension
          EXPORTING
            kind                    = ihttp_icfservice_extension_bsp
          IMPORTING
            configuration           = l_configuration
          EXCEPTIONS
            kind_is_not_supported   = 1
            error_during_processing = 2
            OTHERS                  = 3.
        IF sy-subrc <> 0.
          add_icf_trc `[Msg]; Error at 'Get Service Extension' ` 'Error in system logon configuration.'. "#EC NOTEXT
        ENDIF.
*          endif.

* processing of expired logon account
        CALL METHOD cl_icf_system_login=>on_icf_call
          EXPORTING
            ii_server                = server
            iv_login_methods         = logon_order
            is_alias                 = service-aliaslogin
            accessibility            = service-accessibility
            mandatory_service_client = service-oblmandt
            service_client           = service-icf_mandt
            mandatory_service_langu  = service-obllangu
            service_langu            = service-icf_langu
            mandatory_ssl            = use_https
            configuration            = l_configuration
            webgui                   = l_is_webgui
*logon xsrf for Change Password - Start
            xsrf_field_value         = lv_xsrf_formfield
*logon xsrf for Change Password - End
            security_session_created = m_security_session_created
          IMPORTING
            change_user              = l_user
            change_password          = l_password
            change_language          = l_isolangu
            login_in_processing      = c_icfx_login_in_processing.
* login completed is required for the following cases:
* login should only be done via form fields withou basisc
* authentiaction and MYSAPSSO procedure
* In order to support this feature by ICFX a statful communication is
* established which is after a
* successful processing of login procedure is reset by ICFX to stateless
* and all the self defined parameters
* (e. g. 'sap-system-login') are also removed from the application
* request, after a stateful redirect.

*     -- force to remain in system_login processing
        IF l_user      IS NOT INITIAL AND
           l_password  IS NOT INITIAL.

          CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
            EXPORTING
              auth_method = 'P'
              userid      = l_user
              password    = l_password
              language    = l_isolangu
            IMPORTING
              ticket      = l_ssoticket
            EXCEPTIONS
              OTHERS      = 1.

          IF sy-subrc = 0.
*   after system logon no application has to be processed
*   response contains a redirection to the appliaction page
*   we are stil in 'failed authentication' mode
*   set mysapsso2, if was not available before
            IF l_ssoticket IS NOT INITIAL AND
               do_not_use_sso2_ticket IS INITIAL AND
               c_mysapsso2_available <> 1.
              CALL FUNCTION 'HTTP_SET_SSO2_COOKIE'
                EXPORTING
                  server = server
                  sso2   = l_ssoticket.
            ENDIF.
          ENDIF.
        ENDIF.

        IF c_icfx_login_in_processing = abap_true.
          CLEAR c_authenticated.
          l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
          add_icf_trc `[Prop]; ` l_trace.                   "#EC NOTEXT
          add_icf_trc `[Info]; 'Return' after ` 'on_icf_call method'. "#EC NOTEXT
          RETURN.
        ENDIF.
      ELSEIF m_security_session_created = abap_true AND l_security_session_reauth = abap_false.
        add_icf_trc `[Info]; Calling of: ` 'a new security session created'. "#EC NOTEXT
        add_icf_trc `[Info]; Calling of: ` 'Get Service Extension'. "#EC NOTEXT
        data: l_exiting_sessions.
        try.
          if cl_http_security_session_icf=>list_concurrent_own_sessions( ) is not initial.
            l_exiting_sessions = abap_true.
          endif.
        catch cx_http_security_session.
*          assert 1 = 2.
        endtry.
* -- load system logon configuration, if available
*          if service-syslogin = 'Y'.
        CALL METHOD server_obj->get_service_extension
          EXPORTING
            kind                    = ihttp_icfservice_extension_bsp
          IMPORTING
            configuration           = l_configuration
          EXCEPTIONS
            kind_is_not_supported   = 1
            error_during_processing = 2
            OTHERS                  = 3.
        IF sy-subrc <> 0.
          add_icf_trc `[Msg]; Error at 'Get Service Extension' ` 'Error in system logon configuration.'. "#EC NOTEXT
        ENDIF.
*          endif.
        IF l_configuration IS INITIAL.
          l_c_login_params = cl_icf_system_login=>get_global_params( ).
        ELSE.
          l_c_login_params = l_configuration.
        ENDIF.

        IF l_exiting_sessions = abap_true and
           l_c_login_params-check_session = abap_true AND
           l_c_login_params-check_session_sys_wide = abap_true.
* processing multiple logon check for non form based login
          CALL METHOD cl_icf_system_login=>on_icf_call
            EXPORTING
              ii_server                = server
              iv_login_methods         = logon_order
              is_alias                 = service-aliaslogin
              accessibility            = service-accessibility
              mandatory_service_client = service-oblmandt
              service_client           = service-icf_mandt
              mandatory_service_langu  = service-obllangu
              service_langu            = service-icf_langu
              mandatory_ssl            = use_https
              configuration            = l_configuration
              webgui                   = l_is_webgui
*  logon xsrf for Change Password - Start
              xsrf_field_value         = lv_xsrf_formfield
*  logon xsrf for Change Password - End
              security_session_created = m_security_session_created
            IMPORTING
              change_user              = l_user
              change_password          = l_password
              change_language          = l_isolangu
              login_in_processing      = c_icfx_login_in_processing.
*   login completed is required for the following cases:
*   login should only be done via form fields withou basisc
*   authentiaction and MYSAPSSO procedure
*   In order to support this feature by ICFX a statful communication is
*   established which is after a
*   successful processing of login procedure is reset by ICFX to stateless
*   and all the self defined parameters
*   (e. g. 'sap-system-login') are also removed from the application
*   request, after a stateful redirect.

*       -- force to remain in system_login processing
          IF l_user      IS NOT INITIAL AND
             l_password  IS NOT INITIAL.

            CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
              EXPORTING
                auth_method = 'P'
                userid      = l_user
                password    = l_password
                language    = l_isolangu
              IMPORTING
                ticket      = l_ssoticket
              EXCEPTIONS
                OTHERS      = 1.
            IF sy-subrc = 0.
*     after system logon no application has to be processed
*     response contains a redirection to the appliaction page
*     we are stil in 'failed authentication' mode
*     set mysapsso2, if was not available before
              IF l_ssoticket IS NOT INITIAL        AND
              do_not_use_sso2_ticket IS INITIAL AND
              c_mysapsso2_available <> 1.
                CALL FUNCTION 'HTTP_SET_SSO2_COOKIE'
                  EXPORTING
                    server = server
                    sso2   = l_ssoticket.
              ENDIF.
            ENDIF.
          ENDIF.

          IF c_icfx_login_in_processing = abap_true.
            CLEAR c_authenticated.
            l_trace = | Authentication VALUE = { c_authenticated } AND Authentication Provider = { authentication_provider } |.
            add_icf_trc `[Prop]; ` l_trace.                 "#EC NOTEXT
            add_icf_trc `[Info]; 'Return' after ` 'on_icf_call method'. "#EC NOTEXT
            RETURN.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

* -- leave authentication and do not process logon pages
    IF c_authenticated = 1.
      pf_m_close c_statistic_state 'A:Logon'.               "#EC NOTEXT
      pf_m_close c_statistic_state 'A:Authenticate Inside'. "#EC NOTEXT

* Logon was successful
      IF NOT request->get_form_field( 'xhr-logon' ) IS INITIAL.
        finalize_xhr_logon_via_iframe( ).  "never returns!
      ENDIF.
      RETURN.
    ENDIF.
  ENDIF.

  pf_m_close c_statistic_state 'A:Logon'.                   "#EC NOTEXT

* -- no authentication check for public services
  IF ( c_authenticated = 0 OR c_authenticated = -1 ) AND
       public_service  = 0.

*
* set language for failed logon page
*
    DATA: l_error   TYPE rststype-sel_ok,
          l_warning TYPE rststype-sel_ok,
          l_notes   TYPE TABLE OF abaptext.

* is the prposed langauge an installed and acceptable langauge ?
    CALL FUNCTION 'SCP_CHECK_LANGUAGE'
      EXPORTING
        langu   = c_langu
*       DETAILS = ' '
      IMPORTING
        error   = l_error
        warning = l_warning
      TABLES
        notes   = l_notes.

    IF l_error   IS INITIAL AND
       l_warning IS INITIAL.
      SET LOCALE LANGUAGE c_langu.
      SET LANGUAGE c_langu.
    ENDIF.

    "logon failed for XHR client
    IF l_xhr_client = abap_true.
      trigger_xhr_logon_via_iframe( ).
      RETURN.
    ENDIF.

    CALL METHOD prepare_otr_document
      EXPORTING
        server            = server
        service           = service
        logon_order       = logon_order
        webgui            = l_is_webgui
      CHANGING
        my_trace          = my_trace
        otr_document_sent = otr_document_sent.

*
* -- fall back: basic authentiaction, if possible
*
    IF otr_document_sent IS INITIAL.

*
* in the following logon cases generation a logon poup for
* basic authentication should be prevented
* - no basic authentication is allowed
* - logon based on obligatory service user account
*
      IF ( logon_order IS NOT INITIAL AND
      logon_order NS 'AUTH_BASIC' ) OR
      logon_by_mservice = 1.
        no_basic_authentication = 1.
      ENDIF.
      add_icf_trc `[Info]; ` 'Sending Basic Authentication Screen'. "#EC NOTEXT

      CALL METHOD basic_authentication_screen
        EXPORTING
          authstring              = authstring
          server                  = server
          reply_client            = c_client
          service                 = service
          data                    = my_trace
          no_basic_authentication = no_basic_authentication.
    ENDIF.
  ENDIF.

  pf_m_close c_statistic_state 'A:Authenticate Inside'.     "#EC NOTEXT

ENDMETHOD.                    "authentication


METHOD authentication_sec_session.
  DATA: l_local_authn_method_list TYPE authentication_method_list,
        l_requested_method             TYPE security_session_authn_method.

  DATA: l_security_session_authn   TYPE abap_bool VALUE abap_false.
  DATA: l_trusted                  TYPE abap_bool VALUE abap_false.
  DATA: l_sec_error TYPE REF TO cx_http_security_session.
  DATA: l_text TYPE string.
  DATA: l_error_text TYPE string.

  FIELD-SYMBOLS: <l_logon_method>  TYPE string.
*
* Logon methodas available in CL_HTTP_SECURITY_SESSION_ICF
* 1	Kennwort                     : CO_LOCALAUTH_PASSWORD
* 2	X.509-Benutzerzertifikat     : CO_LOCALAUTH_X509CERT
* 3	SAP Anmeldeticket            : CO_LOCALAUTH_LOGONTICKET
* 4	SAP Assertionticket          : CO_LOCALAUTH_ASSERTIONTICKET
* 5	SAP Trusted-System           : CO_LOCALAUTH_TRUSTEDSYSTEM
* 6	interner HTTP-Aufruf (gleiches System) : CO_LOCALAUTH_LOCALHTTPCALL
* 7	SAML Browser Artefakt        : CO_LOCALAUTH_SAMLBROWSERART
*
  CLEAR: security_session_user, xsrf_token.
  result = abap_false.
  pw_state = 0.

  TRY.
      CALL METHOD cl_http_security_session_icf=>check_security_session_id
        EXPORTING
          session_id = m_security_session_cookie
          client     = c_client
        IMPORTING
          userid     = security_session_user
          context_id = security_session_context
          xsrf_token = xsrf_token.                "performance optimization

    CATCH cx_http_security_session INTO l_sec_error.
      IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
        l_error_text = l_sec_error->get_text( ).
        MESSAGE l_error_text TYPE 'E'.
      ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
        l_error_text = l_sec_error->get_text( ).
        MESSAGE l_error_text TYPE 'E'.
      ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_normal_error.
        IF c_sap_trace IS INITIAL.
          m_trace = |{ m_trace } CHECK_SEC_SESSION:NORMAL_ERROR|.
        ENDIF.
*        l_text = l_sec_error->get_text( ).
**        message e000(sr) with l_text.
        " Logon failed and can happend, i.e. result = abap_false, try with ICF logon
        RETURN.
      ENDIF.
  ENDTRY.

  IF security_session_user IS INITIAL OR security_session_context IS INITIAL.
    IF c_sap_trace IS INITIAL.
      m_trace = |{ m_trace } SEC_SESSION_EMPTY:TRUE|.
    ENDIF.
    "   result = abap_false.
    "   pw_state = 0.
    RETURN.
  ENDIF.

  IF mandatory_certificate_logon = abap_true.
    TRY.
        CALL METHOD cl_http_security_session_icf=>check_security_session_authn
          EXPORTING
            context_id           = security_session_context
            requested_authmethod = cl_http_security_session_icf=>co_authnmethod_x509cert
            client               = c_client
            language             = c_langu
            server               = me
          IMPORTING
            pwdstate             = pw_state
            result               = l_security_session_authn.

        IF l_security_session_authn = abap_true.
          result = abap_true.
          RETURN.
        ENDIF.

      CATCH cx_http_security_session INTO l_sec_error.
        IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
          l_error_text = l_sec_error->get_text( ).
          MESSAGE l_error_text TYPE 'E'.
        ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
          l_error_text = l_sec_error->get_text( ).
          MESSAGE l_error_text TYPE 'E'.
        ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_normal_error.
*          " Logon failed and can happend, i.e. result = abap_false, try with ICF logon
          RETURN.
        ENDIF.
    ENDTRY.
  ELSE.

* Composition of the logon method table, according to security naming
    LOOP AT logon_order_tab[] ASSIGNING <l_logon_method>.
      CASE <l_logon_method>.
        WHEN 'AUTH_FIELD'.
          INSERT cl_http_security_session_icf=>co_authnmethod_password INTO TABLE l_local_authn_method_list.
        WHEN  'AUTH_CERT'.
          INSERT cl_http_security_session_icf=>co_authnmethod_x509cert INTO TABLE l_local_authn_method_list.
        WHEN  'AUTH_SSO'.
          INSERT cl_http_security_session_icf=>co_authnmethod_logonticket INTO TABLE l_local_authn_method_list.
        WHEN  'AUTH_ASSERT'.
          INSERT cl_http_security_session_icf=>co_authnmethod_assertionticket INTO TABLE l_local_authn_method_list.
        WHEN  'AUTH_BASIC'.
          INSERT cl_http_security_session_icf=>co_authnmethod_password INTO TABLE l_local_authn_method_list.
        WHEN 'AUTH_SAP'.
          IF l_trusted = abap_true.
            INSERT cl_http_security_session_icf=>co_authnmethod_trustedsystem INTO TABLE l_local_authn_method_list.
          ELSE.
            INSERT cl_http_security_session_icf=>co_authnmethod_localhttpcall INTO TABLE l_local_authn_method_list.
          ENDIF.
        WHEN 'AUTH_SPNEGO'.
          INSERT cl_http_security_session_icf=>co_authnmethod_spnego INTO TABLE l_local_authn_method_list.
        WHEN 'AUTH_SAML'.
          INSERT cl_http_security_session_icf=>co_authnmethod_saml INTO TABLE l_local_authn_method_list.
*       WHEN 'AUTH_SERVI'.
*         intentionally: do not create Security Session for logon data retrieved from the ICF service configuration!
*         INSERT cl_http_security_session_icf=>co_authnmethod_password INTO TABLE l_local_authn_method_list.
      ENDCASE.
    ENDLOOP.

    TRY.
        CALL METHOD cl_http_security_session_icf=>check_security_session_authnl
          EXPORTING
            context_id            = security_session_context
            requested_authmethods = l_local_authn_method_list
            client                = c_client
            language              = c_langu
            server                = me
          IMPORTING
            pwdstate              = pw_state
            result                = l_security_session_authn.

        IF l_security_session_authn = abap_true.
          result = abap_true.
          RETURN.
        ENDIF.

      CATCH cx_http_security_session INTO l_sec_error.
        IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
          l_error_text = l_sec_error->get_text( ).
          MESSAGE l_error_text TYPE 'E'.
        ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
          l_error_text = l_sec_error->get_text( ).
          MESSAGE l_error_text TYPE 'E'.
        ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_normal_error.
          " Logon failed and can happend, i.e. result = abap_false, try with ICF logon
          RETURN.
        ENDIF.
    ENDTRY.

  ENDIF.


ENDMETHOD.


METHOD basic_authentication_screen .
  DATA: realm             TYPE string,
        challenge         TYPE string,
        msg               TYPE string.
  DATA: l_user_agent_type TYPE i.
*   adjustment of pooled context in terms of language
*   RABAX: TEXTENV_INVALID, CX_SY_LOCALIZATION_ERROR

** use logon language for error message
*    if sy-langu <> c_langu    and
*       not c_langu is initial.
*       and
*       authentication_method = 0.
*      data: l_error        type rststype-sel_ok,
*            l_warning      type rststype-sel_ok,
*            l_notes        type table of abaptext.
*
** is the prposed langauge an installed and acceptable langauge ?
*      call function 'SCP_CHECK_LANGUAGE'
*        exporting
*           langu         = c_langu
**          DETAILS       = ' '
*        importing
*          error         = l_error
*          warning       = l_warning
*        tables
*          notes         = l_notes.
*
*        if l_error   is initial and
*           l_warning is initial.
*          set locale language c_langu.
*          set language c_langu.
*        endif.
*    endif.
  IF c_subrc = 120."The value must be sync with the constant CO_SUBRC_SERVER_STOPPED of class cl_icf_system_login
* -- login/server_logon_restriction = 2
    MESSAGE I810(00) INTO realm.
    CALL METHOD server->response->set_status(
      code = 400
      reason = 'Bad Request' ). "#EC NOTEXT
    msg = '<html><body><H1>400 Bad Request</H1>'.           "#EC NOTEXT

    CONCATENATE msg
         '<BR />' realm '<BR />'
    INTO msg SEPARATED BY space.
    MESSAGE I416(ICF_SYSTEM_LOGIN) INTO realm.
    CONCATENATE msg
         '<BR />' realm '<BR />'
    INTO msg SEPARATED BY space.
    CALL METHOD server->response->set_cdata( data = msg ).
    RETURN.
  ELSEIF c_subrc = 121."The value must be sync with the constant CO_SUBRC_SERVER_PRIVILEGED of class cl_icf_system_login
* -- login/server_logon_restriction = 1
    MESSAGE I811(00) INTO realm.
    CALL METHOD server->response->set_status(
      code = 400
      reason = 'Bad Request' ). "#EC NOTEXT
    msg = '<html><body><H1>400 Bad Request</H1>'.           "#EC NOTEXT

    CONCATENATE msg
         '<BR />' realm '<BR />'
    INTO msg SEPARATED BY space.
    MESSAGE I416(ICF_SYSTEM_LOGIN) INTO realm.
    CONCATENATE msg
         '<BR />' realm '<BR />'
    INTO msg SEPARATED BY space.
    CALL METHOD server->response->set_cdata( data = msg ).
    RETURN.
  ENDIF.

  IF reply_client IS INITIAL.
    CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'login/system_client'
                       ID 'VALUE' FIELD  reply_client.
  ENDIF.

  IF c_delete_sso2_cookie IS INITIAL.
*      realm = sy-sysid.
* Auf Anregung von Wolfgang Janzen wird Mandant in realm aufgenommen (Datum: 21. Maerz 2007)
* provide a logical system related realm
    CONCATENATE sy-sysid '/' reply_client INTO realm.       "#EC NOTEXT
    CONCATENATE 'Basic realm="SAP NetWeaver Application Server [' realm ']"'
         INTO challenge.                                    "#EC NOTEXT

*      if authstring is initial.
*        if service-aliaslogin is initial.
*          msg = 'Bitte √ºbergeben Sie Benutzer und Password'(e01).
**   'Please provide user name and password'. "#EC NOTEXT
*        else.
*          msg = 'Anmeldung misslungen! Versuchen Sie es nochmal'(e02).
**   'Please provide alias name and password'. "#EC NOTEXT
*        endif.
*      else.
*        msg = 'Login failed! Please try again.'. "#EC NOTEXT
*      endif.
* Neue Anmelde-Seite
    msg = failed_logon_page( ).

    IF service-aliaslogin IS INITIAL.
      CONCATENATE
        'Basic realm="SAP NetWeaver Application Server ['   "#EC NOTEXT
        realm  ']"' INTO challenge.                         "#EC NOTEXT
    ELSE.
      CONCATENATE
       'Basic realm="SAP NetWeaver Application Server ['    "#EC NOTEXT
        realm '][alias]"' INTO challenge.                   "#EC NOTEXT

    ENDIF.

    DATA: http_codepage_name  TYPE string.

* in unicode system conversion to utf-8
    IF cl_abap_char_utilities=>charsize = 1.
      CALL METHOD cl_http_utility=>get_logon_charset
        IMPORTING
          id                = http_codepage_name
        EXCEPTIONS
          charset_not_found = 1
          OTHERS            = 2.
      IF sy-subrc <> 0.
        CLEAR http_codepage_name.
      ENDIF.
    ENDIF.

    IF http_codepage_name IS INITIAL.
      CALL METHOD server->response->set_header_field
        EXPORTING
          name  = 'content-type'                            "#EC NOTEXT
          value = 'text/html; charset=utf-8'.               "#EC NOTEXT
    ELSE.
      CONCATENATE 'text/html; charset='                     "#EC NOTEXT
        http_codepage_name INTO http_codepage_name.
      CALL METHOD server->response->set_header_field
        EXPORTING
          name  = 'content-type'                            "#EC NOTEXT
          value = http_codepage_name.
    ENDIF.

    DATA: sap TYPE string.
    sap = sy-sysid.

    CALL METHOD server->response->set_header_field
      EXPORTING
        name  = 'SAP-System'                                "#EC NOTEXT
        value = sap.

    CALL METHOD server->response->set_status(
      code = 401
      reason = 'Unauthorized' ). "#EC NOTEXT

    IF no_basic_authentication IS INITIAL.
      CALL METHOD server->response->set_header_field(
          name   = 'WWW-Authenticate'                       "#EC NOTEXT
          value  = challenge ).
    ENDIF.

    challenge = reply_client.

* transfer of sap-client only in case of SAP as client
    CALL METHOD server->request->get_user_agent
      IMPORTING
        user_agent_type = l_user_agent_type.
    IF l_user_agent_type = ihttp_user_agent_sapwebapp.
      CALL METHOD server->response->set_header_field(
          name   = 'SAP-Client'                             "#EC NOTEXT
          value  = challenge ).
    ENDIF.

*     concatenate msg data into msg.
  ELSE.
* -- received SSO2 cookie is not accepted
    CALL METHOD server->response->set_status(
      code = 400
      reason = 'Bad Request' ). "#EC NOTEXT
    msg = '<html><body><H1>400 Bad Request</H1>'.           "#EC NOTEXT

    CONCATENATE msg text-e11
         '<BR />' text-e12 '<BR />'
         '<BR />' text-e13 '<BR />'
    INTO msg SEPARATED BY space.
  ENDIF.

  CALL METHOD server->response->set_cdata( data = msg ).

ENDMETHOD.


method check_accept_language .
* -- evaluation of accept-language
  data: l_error        type rststype-sel_ok,
        l_warning      type rststype-sel_ok,
        l_notes        type table of abaptext,
        l_langu        type t002-spras,
        l_accept_tbl   type table of string,
        dummy  type string."#EC NEEDED

    if not accept_language is initial.

*-- evaluate all installed languages as accept-language
      split accept_language at ',' into table l_accept_tbl.

      loop at l_accept_tbl into accept_language.
* -- filter language options followed by '-' or ';'
        split accept_language at ';' into accept_language dummy.

* --- allow functionality for French-Canadian
        translate accept_language to upper case.
        IF accept_language eq 'FR-CA'.
          accept_language = '3F'.
        Else.
          split accept_language at '-' into accept_language dummy.
        endif.

*Note 1970892 - zh-TW - Start
*        split accept_language at '-' into accept_language dummy.
*Note 1970892 - zh-TW - End

* ---   chinese: simplified (ZH) or traditional (ZF) ? See Note 1423005
        if accept_language eq 'ZH' or accept_language eq 'zh'.
          translate dummy to upper case.
          if dummy eq 'HK' or dummy eq 'TW' or dummy eq 'MO'.
            accept_language = 'ZF'.
          endif.
        endif.

        if not accept_language is initial.
          call function 'CONVERSION_EXIT_ISOLA_INPUT'
            exporting
              input  = accept_language
            importing
              output = l_langu
            exceptions
              others = 1.

          if sy-subrc = 0.
            call function 'SCP_CHECK_LANGUAGE'
               exporting
                 langu         = l_langu
*                DETAILS       = ' '
              importing
                error         = l_error
                warning       = l_warning
              tables
                notes         = l_notes.

            if l_error   is initial and
               l_warning is initial.
               exit.
            else.
              clear: accept_language.
            endif.
          else.
            clear: accept_language.
          endif.
        endif.
      endloop.
    endif.

endmethod.


METHOD confirm_userswitch.
  DATA: l_sessionid TYPE security_session_id,
        l_callstack TYPE sys_callst,
        l_caller    TYPE sys_calls.

*===========================================================*
*   Errors caused by this method should be reported under   *
*   message component BC-SEC-LGN (instead of BC-MID-ICF)!   *
*===========================================================*

* set default result
  security_session_created = abap_false.

* check whether Security Session Management is active for the current client (SY-MANDT)
  IF abap_false = cl_http_security_session_icf=>session_management_is_active( ).
    RETURN.
  ENDIF.

* check on the caller of this method (for technical reasons it is declared as PUBLIC although it's RESTRICTED)
  CALL FUNCTION 'SYSTEM_CALLSTACK'
    EXPORTING
      max_level    = 3
    IMPORTING
      et_callstack = l_callstack.

  READ TABLE l_callstack INDEX 2 INTO l_caller.
  IF sy-subrc <> 0 OR l_caller-progname  <> 'SAPLHTTP_RUNTIME'
                   OR l_caller-eventtype <> 'FUNC'
                   OR l_caller-eventname <> 'HTTP_CONFIRM_USERSWITCH'.
    RAISE illegal_caller.
  ENDIF.
  READ TABLE l_callstack INDEX 3 INTO l_caller.
  IF sy-subrc <> 0 OR l_caller-progname  <> 'SAPLSU_INTERNETUSER'
                   OR l_caller-eventtype <> 'FUNC'
                   OR l_caller-eventname <> 'SUSR_INTERNET_USERSWITCH'.
    RAISE illegal_caller.
  ENDIF.

* create Security Session (notice: SUSR_INTERNET_USERSWITCH only supports password authentication)
  TRY.
      l_sessionid = cl_http_security_session_icf=>create_session_after_localauth( cl_http_security_session_icf=>co_authnmethod_password ).
    CATCH cx_http_security_session.
      RETURN.
  ENDTRY.

* set security session id cookie (later SEND_RESPONSE will call SET_SECURITY_SESSION_COOKIE)
  m_security_session_cookie = l_sessionid.
  m_security_session_created = abap_true.

* update authentication method (memorize that a password authentication took place)
  authentication_provider = authprovider_icf.
  authentication_method   = authmethod_field.

* signal "success" to the caller (HTTP_CONFIRM_USERSWITCH) which will then decide not to set cookie MYSAPSSO2
  security_session_created = abap_true.

ENDMETHOD.


METHOD constructor.
  CALL METHOD super->constructor.
  m_server_type                 = co_servertype_net.
  m_send_page_is_called         = abap_false.
  m_last_page_already_processed = abap_false.
  m_del_security_fields_called  = abap_false.
ENDMETHOD.


method CREATE_ENTITY_OBJECTS.
  data: http_response type ref to cl_http_response.
  data: http_request  type ref to cl_http_request.
  data: c_msg         type %_c_pointer.

  create object http_response.
  response = http_response.
*
* the response object gets their associated c msg here and
* in receive_request for timeout handler (FM 'HTTP_RAISE_EVENT')
*
  system-call ict
    did
      ihttp_scid_create_message
    parameters
      2                              " > message type (2 = resp)
      c_msg                          " < c handle
      m_last_error.                  " < return code

  http_response->set_c_msg( c_msg ).

  create object http_request.
  request = http_request.
*
* the request object gets their associated c msg here and
* in receive_request for timeout handler (FM 'HTTP_RAISE_EVENT')
*

  system-call ict
    did
      ihttp_scid_create_message
    parameters
      1                              " > message type (1 = req)
      c_msg                          " < c handle
      m_last_error.                  " < return code

  http_request->set_c_msg( c_msg ).

endmethod.


METHOD create_login_xsrf_token.
*------------------------------------------------------------------------------------
*  This method is in the responsibility of the Security Development team.
*  Use message component BC-SEC-LGN to report problems.
*  Author:   D021767
*  Date:     2011-04-27
*------------------------------------------------------------------------------------

  DATA: l_timestamp_x TYPE timestamp,
        l_timestamp   TYPE string,
        l_random_x    TYPE xstring,
        l_random      TYPE string,
        l_hmac_b64    TYPE hash512_base_64.

  GET TIME STAMP FIELD l_timestamp_x.
  l_timestamp = l_timestamp_x.

  CALL FUNCTION 'GENERATE_SEC_RANDOM'
*   EXPORTING
*     LENGTH               = 16
    IMPORTING
      random               = l_random_x
   EXCEPTIONS
     invalid_length       = 1
     no_memory            = 2
     internal_error       = 3
     OTHERS               = 4.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
      RAISING internal_error.
  ENDIF.

  CALL FUNCTION 'SSFC_BASE64_ENCODE'
    EXPORTING
      bindata                  = l_random_x
*     BINLENG                  =
    IMPORTING
      b64data                  = l_random  "ALPHABET_UC_BASE64
    EXCEPTIONS
      ssf_krn_error            = 1
      ssf_krn_noop             = 2
      ssf_krn_nomemory         = 3
      ssf_krn_opinv            = 4
      ssf_krn_input_data_error = 5
      ssf_krn_invalid_par      = 6
      ssf_krn_invalid_parlen   = 7
      OTHERS                   = 8.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
      RAISING internal_error.
  ENDIF.

  TRANSLATE l_random USING '+-/_'. "ALPHABET_UC_BASE64URL
  CONCATENATE l_timestamp(14) l_random INTO cookie_value SEPARATED BY '-'.

  CALL FUNCTION 'CALCULATE_HMAC_FOR_CHAR'
    EXPORTING
*     ALG                          = 'SHA2'
      data                         = cookie_value
*     LENGTH                       = 0
      client_independent           = 'X'
*     RECORD_NUMBER                = '00'
*     KEY_MUST_EXIST               = ' '
    IMPORTING
*     HMAC                         =
*     HMACLEN                      =
*     HMACX                        =
*     HMACXLEN                     =
      hmacbase64                   = l_hmac_b64  "ALPHABET_UC_BASE64
*     HMACBASE64LEN                =
    EXCEPTIONS
      unknown_alg                  = 1
      param_length_error           = 2
      internal_error               = 3
      malloc_error                 = 4
      abap_caller_error            = 5
      base64_error                 = 6
      calc_hmac_error              = 7
      rsec_record_not_found        = 8
      rsec_record_access_denied    = 9
      rsec_secstore_access_denied  = 10
      rsec_error                   = 11
      param_missing                = 12
      rng_error                    = 13
      record_number_error          = 14
      rsec_system_data_changed     = 15
      rsec_system_data_changed_sid = 16
      OTHERS                       = 17.
  IF sy-subrc <> 0.
    IF sy-subrc > 7.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING secstore_error.
    ELSE.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING internal_error.
    ENDIF.
  ENDIF.

  TRANSLATE l_hmac_b64 USING '+-/_'. "ALPHABET_UC_BASE64URL
  formfield_value = l_hmac_b64.

ENDMETHOD.


METHOD create_sec_sess_4_pending_req .

* SAP Note 1962529
  DATA: l_security_session_localauth TYPE security_session_authn_method.
  DATA: l_sec_error TYPE REF TO cx_http_security_session.
  DATA: l_error_text               TYPE string.

  IF m_sec_session_pending_local = abap_true.
    l_security_session_localauth  = cl_http_security_session_icf=>co_authnmethod_localhttpcall.
    m_sec_session_pending_local   = abap_false. "try only once
  ELSE.
    l_security_session_localauth  = cl_http_security_session_icf=>co_authnmethod_trustedsystem.
    m_sec_session_pending_trusted = abap_false. "try only once
  ENDIF.

  CHECK: m_security_session_active = abap_true.

  TRY.
      CALL METHOD cl_http_security_session_icf=>create_session_after_localauth
        EXPORTING
          authentication_method = l_security_session_localauth
        IMPORTING
          xsrf_token            = m_xsrf_token_from_sec_context
        RECEIVING
          session_id            = m_security_session_cookie.
    CATCH cx_http_security_session INTO l_sec_error.
      IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
        l_error_text = l_sec_error->get_text( ).
        MESSAGE l_error_text TYPE 'E'.
      ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
        l_error_text = l_sec_error->get_text( ).
        MESSAGE l_error_text TYPE 'E'.
      ENDIF.
  ENDTRY.

  IF m_security_session_cookie IS NOT INITIAL.
    m_security_session_created = abap_true.
  ENDIF.

ENDMETHOD.


METHOD delete_security_fields.
*   data: rc type i.
* delete security relevant fields
  DATA: lt_session_cookie_names  TYPE tihttpcki.
  FIELD-SYMBOLS: <l_cookie> LIKE LINE OF lt_session_cookie_names.
  pf_m_open c_statistic_state 'A:Delete Security Fields'.     "#EC NOTEXT

*    rc =
*     cl_http_utility=>is_ict_system_call_implemented(
*                            ihttp_scid_del_ffield_secure ).
*    if rc = 0.
  request->delete_form_field_secure(
                         name = 'sap-password' ).           "#EC NOTEXT
  request->delete_form_field_secure(
                         name = '~password' ).              "#EC NOTEXT
  request->delete_header_field_secure(
                         name = 'sap-password' ).           "#EC NOTEXT
  request->delete_header_field_secure(
                         name = c_sap_r3auth ).             "#EC NOTEXT
**temp change Branimir
  request->delete_header_field_secure(
                         name = 'authorization' ).          "#EC NOTEXT
  request->delete_header_field_secure(
                         name = 'proxy-authorization' ).    "#EC NOTEXT
  request->delete_cookie_secure(
                         name = 'MYSAPSSO2' ).              "#EC NOTEXT
  request->delete_header_field_secure(
                         name = 'MYSAPSSO2' ).              "#EC NOTEXT
*    else.
*      request->delete_form_field(
*                             name = 'sap-password' ). "#EC NOTEXT
*      request->delete_header_field(
*                             name = 'sap-password' ). "#EC NOTEXT
*      request->delete_header_field(
*                             name = c_sap_r3auth ).  "#EC NOTEXT
*
*      request->delete_header_field(
*                             name = 'authorization' ). "#EC NOTEXT
*      request->delete_cookie(
*                             name = 'MYSAPSSO2' ). "#EC NOTEXT
*    endif.

  CALL METHOD request->if_http_entity~get_cookies
    CHANGING
      cookies = lt_session_cookie_names.
* All cookies with name 'SAP_SESSIONID_*' should be deleted from the HTTP request
* before passing control to the application
  LOOP AT lt_session_cookie_names ASSIGNING <l_cookie>.
    CHECK strlen( <l_cookie>-name ) GE 14.           " to avoid runtime error
    IF <l_cookie>-name(14) = 'SAP_SESSIONID_'.
      request->delete_cookie_secure( name = <l_cookie>-name ).
    ENDIF.
  ENDLOOP.

*
* Remark: This method is called in context of SAML 2.0 project and in the class
* CL_HTTP_EXT_SAML20
*
  m_del_security_fields_called = abap_true.
  pf_m_close c_statistic_state 'A:Delete Security Fields'.    "#EC NOTEXT
ENDMETHOD.


METHOD delete_security_session_cookie.

  DATA: agent  TYPE string,
        dummy  TYPE string,                                 "#EC NEEDED
        onlyhttps(4) TYPE c,
        onlytohost(4) TYPE c,
        len    TYPE i,
        secure TYPE i,
        ssolist_b64 TYPE string.
  DATA: l_subrc TYPE sy-subrc,
        httponly(4) type c.
  DATA: l_sec_session_name TYPE string.

  agent =  request->get_header_field( 'user-agent' ).


  CALL 'C_SAPGPARAM'
      ID 'NAME' FIELD 'login/ticket_only_by_https'
      ID 'VALUE' FIELD onlyhttps.
  l_subrc = sy-subrc.

* changes for HTTPonly_flag
  CALL 'C_SAPGPARAM'
     ID 'NAME' FIELD 'icf/set_HTTPonly_flag_on_cookies'
     ID 'VALUE' FIELD httponly.

  IF l_subrc = 0 AND onlyhttps = '1'.
    IF httponly EQ '0' OR httponly EQ '2'.
      secure = 17.
    ELSE.
      secure = 1.
    ENDIF.
  ELSE.
    IF httponly EQ '0' OR httponly EQ '2'.
      secure = 16.
    ELSE.
      secure = 0.
    ENDIF.
  ENDIF.
*
* Remark: Client specify cookie shou√∂d be deleted. Be careful that the client always determined by
* server object and not abap context, e.g. sy-mandt. As in case of /sap/public/bc/icf/logoff no
* regular logon has been proceed, therefore no sy-mandt is set accordingly.
*
  CALL METHOD cl_http_security_session_icf=>security_sessionid_cookie_name
    EXPORTING
      client      = c_client
    RECEIVING
      cookie_name = l_sec_session_name.


  CALL METHOD response->delete_cookie_at_client
    EXPORTING
      name = l_sec_session_name
      path = '/'.

ENDMETHOD.


METHOD delete_sso_cookie_at_client.
*CALL METHOD SUPER->DELETE_SSO_COOKIE_AT_CLIENT
*    .
  DATA: domain TYPE string,
        agent  TYPE string,
        dummy  TYPE string,                                 "#EC NEEDED
        onlytohost(2) TYPE c,
        len    TYPE i.

  domain = request->get_header_field( '~server_name' ).
  agent =  request->get_header_field( 'user-agent' ).

  CALL 'C_SAPGPARAM'
      ID 'NAME' FIELD 'login/ticket_only_to_host'
      ID 'VALUE' FIELD onlytohost.
  IF sy-subrc <> 0.
    onlytohost = '0'.
  ENDIF.

*
* date: 24.04.2007 MA
* use RFC 2109 specification
*  (http://www.ietf.org/rfc/rfc2109.txt)
* instead of netscape specification
*  (http://wp.netscape.com/newsref/std/cookie_spec.html)
* for setting of cookies on host
*
  IF onlytohost = '1'.
    CLEAR domain.
  ENDIF.

  IF domain CS '.' AND onlytohost <> '1'.
    len = strlen( agent ).
    IF len > 4 AND ( agent CS 'MSIE' OR agent CS 'msie' ).
      SPLIT domain AT '.' INTO dummy domain.
    ELSE. "Netscape
      SPLIT domain AT '.' INTO dummy domain.
      CONCATENATE '.' domain INTO domain.
    ENDIF.
  ENDIF.

  CALL METHOD response->delete_cookie_at_client
    EXPORTING
      name   = 'MYSAPSSO2'
      path   = '/'
      domain = domain.
  "    expires = ''.

*
* delete associated SSO list at the browser (client)
*
  CALL METHOD response->delete_cookie_at_client
    EXPORTING
      name = co_ssolist
      path = '/'.
  "      domain = domain.

*
* do not send SSO cookie in send_reponse method anymore
*
  FREE m_sso_cookie.

ENDMETHOD.


METHOD delete_xsrf_cookie.

  DATA: lv_xsrf_cookie_name TYPE string.

* Remarks:
* 1) As several SAP systems could be run on the same host therefore XSRF cookie has to contain at least system id
*    to avoid ambiguities. The cookie is set for the host.

* 2) Method DELETE_XSRF_COOKIE will be called after logoff so that using of sy-mandt does not
*    result in elemination of XSRF cookie in otehr SAP clients
  CONCATENATE if_http_form_fields_sap=>sap_xsrf '_' sy-sysid '_' c_client INTO lv_xsrf_cookie_name.

  CALL METHOD response->delete_cookie_at_client
    EXPORTING
      name = lv_xsrf_cookie_name
      path = '/'.

* Ensure that it will not be set, again
  CLEAR m_xsrf_cookie_value.
  m_xsrf_cookie_created = abap_false.

ENDMETHOD.


METHOD failed_logon_page.
  DATA: uri           TYPE string.
  DATA: note         TYPE string.
  DATA: note_1       TYPE string.
  DATA: iso_langu(2) TYPE c.
  DATA: recommendation TYPE string.
  DATA: reason         TYPE string.
  DATA: logon_subrc(4) TYPE c,                              "#EC NEEDED
        logon_saprc(4) TYPE c.                              "#EC NEEDED
  DATA: errorcode      TYPE string.

  DATA: l_sysid_escape  TYPE string.
  DATA: l_client_escape TYPE string.
  DATA: l_user_escape   TYPE string.
  DATA: l_langu_escape  TYPE string.
  DATA: l_show_detailed_errors(5) TYPE c,
        l_login_show_detailed_errors(4) TYPE c.

  call 'C_SAPGPARAM' id 'NAME'  field 'is/HTTP/show_detailed_errors'
                     id 'VALUE' field  l_show_detailed_errors.
  if sy-subrc = 0.
    translate l_show_detailed_errors to upper case.
  else.
    clear l_show_detailed_errors.
  endif.
*data: retcodes       type string.
*data: bitset         type i.
*data: num_list(16) type C.

*uri = request->get_header_field( '~path_translated' ).
  uri = create_abs_url( ).

*
* XSS- Attacken verhindern
* z.B. bei /sap/bc/<script>confirm("ok")</script>/echo
*
*  uri = cl_http_utility=>escape_html( uri ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
  uri = escape( val    = uri
                format = cl_abap_format=>e_xss_ml ).

  logon_subrc = m_recorder_failed_logon-logon_subrc.
  logon_saprc = m_recorder_failed_logon-logon_saprc.

* -- reason
* Die Ausf√ºhrung des URLs &1 wurde aufgrund fehlerhafter Anmeldedaten
* abgebrochen.
  reason = text-u01.
  REPLACE '&1' WITH uri INTO reason.

* -- begin note info
* -- iso language
  IF authentication_method <> authmethod_none.
    CALL FUNCTION 'CONVERSION_EXIT_ISOLA_OUTPUT'
      EXPORTING
        input  = cl_http_server_net=>c_langu
      IMPORTING
        output = iso_langu.
* avoid XSS based on langauge
    l_langu_escape = iso_langu.
*    l_langu_escape = cl_http_utility=>escape_html( l_langu_escape ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
    l_langu_escape = escape( val    = l_langu_escape
                             format = cl_abap_format=>e_xss_ml ).
  ENDIF.

* -- system
* Die Anmeldung wurde im System &1 ausgef√ºhrt.
  note = text-n01.

* avoid XSS based on logon fields
  l_sysid_escape = sy-sysid.
*  l_sysid_escape = cl_http_utility=>escape_html( l_sysid_escape ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
  l_sysid_escape = escape( val    = l_sysid_escape
                           format = cl_abap_format=>e_xss_ml ).

  REPLACE '&1' WITH l_sysid_escape INTO note.

*   -- errorcode
  errorcode = 'Fehlercode:'(f01).
  IF ssl_active = co_enabled.
    CONCATENATE errorcode 'ICF-LE-https' INTO errorcode     "#EC NOTEXT
      SEPARATED BY space.
  ELSE.
    CONCATENATE errorcode 'ICF-LE-http' INTO errorcode      "#EC NOTEXT
      SEPARATED BY space.
  ENDIF.

* -- authentication_method

* avoid XSS based on client field
  l_client_escape = cl_http_server_net=>c_client.
*  l_client_escape = cl_http_utility=>escape_html( l_client_escape ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
  l_client_escape = escape( val    = l_client_escape
                            format = cl_abap_format=>e_xss_ml ).

* avoid XSS based on user field
  l_user_escape = cl_http_server_net=>c_user.
*  l_user_escape = cl_http_utility=>escape_html( l_user_escape ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
  l_user_escape = escape( val    = l_user_escape
                          format = cl_abap_format=>e_xss_ml ).

  CASE authentication_method.
    WHEN authmethod_basic OR authmethod_field.
* -- note
* Die Anmeldung f√ºr den Mandanten &1 und den Benutzer &2
* und die Sprache &3 durchgef√ºhrt.
      note_1 = text-n11.

      REPLACE '&1' WITH l_client_escape INTO note_1.
      REPLACE '&2' WITH l_user_escape INTO note_1.
      REPLACE '&3' WITH l_langu_escape INTO note_1.

      CONCATENATE '<ul><li>'  note
                  '</li><li>' note_1 '</li></ul>'
                  INTO note SEPARATED BY space.

*   -- errorcode
*    if authentication_method = authmethod_basic.
*       concatenate errorcode 'a:basic-' into errorcode.
*    else.
*       concatenate errorcode 'a:field-' into errorcode.
*    endif.

* -- recommendation
* √úberpr√ºfen Sie die Angabe √ºber den Mandanten, Benutzer und das
* Passwort auf Tippfehler.
      recommendation = text-r01.

      CONCATENATE
      '<li>'
      recommendation
      '</li>'
      '<li>'
* Falls Sie noch √ºber keine Benutzerkennung verf√ºgen,
* so wenden Sie sich an Ihren Systemadministrator.
      text-r10
      '</li>'
      INTO recommendation
      SEPARATED BY space.

    WHEN authmethod_sso.
* -- note
* Die Anmeldung wurde f√ºr den Mandanten &1 und die
* Sprache &2 durchgef√ºhrt.
      note_1 = text-n12.


      REPLACE '&1' WITH l_client_escape INTO note_1.
      REPLACE '&2' WITH l_langu_escape INTO note_1.

      CONCATENATE '<ul><li>'  note
                  '</li><li>' note_1 '</li></ul>'
                  INTO note SEPARATED BY space.

*   -- errorcode
*     concatenate errorcode 'a:sso-' into errorcode.

* -- recommendation
* √úberpr√ºfen Sie die G√ºltigkeit Ihres SSO-Tickets f√ºr dieses System.
      recommendation = text-r20.

      CONCATENATE
      '<li>'
       recommendation
      '</li>'
      '<li>'
* Falls Sie noch √ºber keine Benutzerkennung verf√ºgen,
* so wenden Sie sich an Ihren Systemadministrator.
        text-r10
       '</li>'
      INTO recommendation
      SEPARATED BY space.

    WHEN authmethod_sap.
* -- note
* Die Anmeldung f√ºr den Mandanten &1 und den Benutzer &2
* und die Sprache &3 durchgef√ºhrt.
      note_1 = text-n11.

      REPLACE '&1' WITH l_client_escape INTO note_1.
      REPLACE '&2' WITH l_user_escape INTO note_1.
      REPLACE '&3' WITH l_langu_escape INTO note_1.

      CONCATENATE '<ul><li>'  note
                  '</li><li>' note_1 '</li></ul>'
                  INTO note SEPARATED BY space.

*   -- errorcode
*       concatenate errorcode 'a:sap-' into errorcode.

* -- recommendation
      CONCATENATE
      '<li>'
* Falls Sie noch √ºber keine Benutzerkennung verf√ºgen,
* so wenden Sie sich an Ihren Systemadministrator.
      text-r10
      '</li>'
      INTO recommendation
      SEPARATED BY space.

    WHEN authmethod_service.
* -- note
* Die Anmeldung f√ºr den Mandanten &1 und den Benutzer &2
* und die Sprache &3 durchgef√ºhrt.
      note_1 = text-n11.

      REPLACE '&1' WITH l_client_escape INTO note_1.
      REPLACE '&2' WITH l_user_escape INTO note_1.
      REPLACE '&3' WITH l_langu_escape INTO note_1.

      CONCATENATE '<ul><li>'  note
                  '</li><li>' note_1 '</li></ul>'
                  INTO note SEPARATED BY space.


*   -- errorcode
*    concatenate errorcode 'a:service-' into errorcode.

* -- recommendation
      CONCATENATE
      '<li>'
* Falls Sie noch √ºber keine Benutzerkennung verf√ºgen,
* so wenden Sie sich an Ihren Systemadministrator.
      text-r10
      '</li>'
      INTO recommendation
      SEPARATED BY space.

    WHEN authmethod_certificate.

* -- note
* Die Anmeldung wurde f√ºr den Mandanten &1 und die
* Sprache &2 durchgef√ºhrt.
      note_1 = text-n12.

      REPLACE '&1' WITH l_client_escape INTO note_1.
      REPLACE '&2' WITH l_langu_escape INTO note_1.

      CONCATENATE '<ul><li>'  note
                  '</li><li>' note_1 '</li></ul>'
                  INTO note SEPARATED BY space.

*   -- errorcode
*    concatenate errorcode 'a:certificate-' into errorcode.

* -- recommendation
* √úberpr√ºfen Sie die G√ºltigkeit Ihres Zertifikates f√ºr dieses System.
      recommendation = text-r21.

      CONCATENATE
      '<li>'
       recommendation
      '</li>'
      '<li>'
* Falls Sie noch √ºber keine Benutzerkennung verf√ºgen,
* so wenden Sie sich an Ihren Systemadministrator.
        text-r10
       '</li>'
      INTO recommendation
      SEPARATED BY space.

    WHEN authmethod_none.
      CONCATENATE note
    'Hierbei wurden keine Anmeldedaten bereitgestellt.'(m01)
    INTO note
    SEPARATED BY space.

*   -- errorcode
*    concatenate errorcode 'a:none-' into errorcode.

* -- recommendation
      CONCATENATE
      '<li>'
* Falls Sie noch √ºber keine Benutzerkennung verf√ºgen,
* so wenden Sie sich an Ihren Systemadministrator.
      text-r10
      '</li>'
      INTO recommendation
      SEPARATED BY space.

  ENDCASE.

* -- begin of errorcode
*get bit ihttp_recorder_bauth_ticket of
*      m_recorder_failed_logon-tickets into bitset.
*if bitset = 1.
**   -- errorcode
*  concatenate errorcode 't:bauth-' into errorcode.
*endif.
*
*get bit ihttp_recorder_sso_ticket of
*      m_recorder_failed_logon-tickets into bitset.
*if bitset = 1.
**   -- errorcode
*  concatenate errorcode 't:sso-' into errorcode.
*endif.
*
*get bit ihttp_recorder_ssorej_ticket of
*      m_recorder_failed_logon-tickets into bitset.
*if bitset = 1.
**   -- errorcode
*  concatenate errorcode 't:ssorej-' into errorcode.
*endif.
*
*get bit ihttp_recorder_r3auth_ticket of
*      m_recorder_failed_logon-tickets into bitset.
*if bitset = 1.
**   -- errorcode
*  concatenate errorcode 't:r3auth' into errorcode.
*endif.
*
*get bit ihttp_recorder_x509_ticket of
*      m_recorder_failed_logon-tickets into bitset.
*if bitset = 1.
**   -- errorcode
*  concatenate errorcode 't:x509-' into errorcode.
*endif.
  CONCATENATE errorcode
     ihttp_recorder_client_token c_client
     ihttp_recorder_langu_token  c_langu
     INTO errorcode.

  CONCATENATE errorcode
     m_recorder_failed_logon-authentication_methods
     INTO errorcode.

  CONCATENATE errorcode
              ihttp_recorder_tickets_token
              m_recorder_failed_logon-tickets
              ihttp_recorder_clients_token
              m_recorder_failed_logon-client_method
              ihttp_recorder_users_token
              m_recorder_failed_logon-user_method
              ihttp_recorder_passwds_token
              m_recorder_failed_logon-password_method
              ihttp_recorder_langus_token
              m_recorder_failed_logon-language_method
              INTO errorcode.

* -- client part
*if not cl_http_server_net=>c_client is initial.
*  concatenate errorcode 'c:' cl_http_server_net=>c_client
*     ';' m_recorder_failed_logon-client_method '-'
*     into errorcode.
*endif.

* -- user part
*if not cl_http_server_net=>c_user is initial.
*  num_list = m_recorder_failed_logon-user_method(16).
*  concatenate errorcode 'u:' cl_http_server_net=>c_user
*     ';' num_list '-'
*     into errorcode.
*endif.

* -- language method
*if not iso_langu is initial.
*  concatenate errorcode 'l:' iso_langu
*     ';' m_recorder_failed_logon-language_method '-'
*     into errorcode.
*endif.

* -- password method
*if not m_recorder_failed_logon-password_method is initial.
*  num_list = m_recorder_failed_logon-password_method(8).
*  concatenate errorcode 'p:'
*     ';' num_list '-'
*     into errorcode.
*endif.

* -- return codes
*if logon_subrc <> 0.
*  shift logon_subrc left deleting leading space.
*  concatenate errorcode '-subrc:' logon_subrc '-'
*   into errorcode.
*endif.
*if logon_saprc <> 0.
*  shift logon_saprc left deleting leading space.
*  concatenate errorcode 'saprc:' logon_saprc '-'
*     into errorcode.
*endif.

* -- alias user check
  IF NOT m_recorder_failed_logon-alias_user_check IS INITIAL.
    DATA: alias_user_check(4) TYPE c.
    alias_user_check = m_recorder_failed_logon-alias_user_check.
    SHIFT alias_user_check LEFT DELETING LEADING space.
    CONCATENATE errorcode 'aliasrc:' iso_langu
       alias_user_check '-'
       INTO errorcode.
  ENDIF.

* -- appending Extended Passport IDs, i.e. root context id, connection id and connection counter
  DATA: lv_rid  TYPE epp_root_context_id,
        lv_cid  TYPE epp_connection_id,
        lv_ccnt TYPE epp_connection_counter,
        lv_tid  type epp_transaction_id.

  CALL METHOD get_epp_context_ids
    IMPORTING
      root_context_id    = lv_rid
      connection_id      = lv_cid
      connection_counter = lv_ccnt
      transaction_id     = lv_tid
    EXCEPTIONS
      epp_error          = 1.
  if sy-subrc = 0.
    errorcode = |{ errorcode }{ cl_http_server=>CO_ERROR_PAGE_EPP_CONTEXT_ID }{ lv_rid }_{ lv_cid }_{ lv_ccnt }|.
* And TransactionId
    errorcode = |{ errorcode }{ cl_http_server=>CO_ERROR_PAGE_EPP_TID }{ lv_tid }|.
  endif.

* -- end of errorcode

  if l_show_detailed_errors = 'TRUE'.
    call 'C_SAPGPARAM' id 'NAME'  field 'login/show_detailed_errors'
                       id 'VALUE' field  l_login_show_detailed_errors.
    if l_login_show_detailed_errors = '0'."system default value is 1, no need to check sy-subrc
      clear errorcode.
    endif.

*   avoid XSS based on error code
*    errorcode = cl_http_utility=>escape_html( errorcode ).

*   Use new ABAP XSS Escaping library (see sap note 1644634)
    errorcode = escape( val    = errorcode
                        format = cl_abap_format=>e_xss_ml ).

*  note = m_recorder_failed_logon-client_method.
*  concatenate
*  'Die Anmeldung wurde im System' sy-sysid
*  ' und unter dem Mandanten' CL_HTTP_SERVER_NET=>C_CLIENT
*  ' und dem Benutzer' CL_HTTP_SERVER_NET=>C_USER
*  ' vorgenemmen'.
*  ' und unter dem Anmeldeverfahren' note
*  into note
*  separated by space.



    CONCATENATE
*   '<!DOCTYPE html PUBLIC '           "#EC NOTEXT
*           '"-//W3C//DTD HTML 4.01'   "#EC NOTEXT
*           'Transitional//EN'         "#EC NOTEXT
*           '">'
    '<html>'
      '<head>'
        '<title>Logon Error Message</title>'
        '<META http-equiv="Content-Type" content="text/html; '
        'charset=UTF-8">'
        '<style type="text/css">'
          'body { font-family:tahoma,helvetica,sans-serif;color:#'
    '333333;background-color:#FFFFFF; }'
    'td { font-family:tahoma,helvetica,sans-serif;font-size:70%;color:'
    '#333333; }'
    'h1 { font-family:tahoma,helvetica,sans-serif;font-size:160%;font-'
    'weight:bold;margin-top:15px;margin-bottom:3px;color:#003366; }'
    'h2 { font-family:verdana,helvetica,sans-serif;font-'
    'size:120%;font-style:italic;font-weight:bold;margin-top:6px;margin-'
    'bottom:6px;color:#999900; }'
    'p { font-family:tahoma,helvetica,sans-serif;color:#333333;margin-'
    'top:4px;margin-bottom:4px; }'
    'ul { font-family:tahoma,helvetica,sans-serif;color:#333333;list-'
    'style-type:square;margin-top:8px;margin-bottom:8px; }'
    'li { font-family:tahoma,helvetica,sans-serif;color:#'
    '33333;margin-top:4px; }'
    '.emphasize { color:#333333;background-'
    'color:#C8E3FF;padding:5px;}'
    '.note { color:#CC6600; }'                                "#EC NOTEXT
    'a { font-family:tahoma,helvetica,sans-serif;text-'
    'decoration:underline;color:#336699; }'
    'a:visited { color:#001166; }'
    'a:hover { text-decoration:none; }'
    '</style>'
    '</head>'
    '<body>'
    '<table cellpadding="0" cellspacing="0" border="0" width="100%">'
    '<tr>'
    '<td>'

*  '<h1>Error Message - User Authentication Error</h1><br>'
    '<h1>'
    'Anmeldung fehlgeschlagen'(a01)
    '</h1><br>'

*  '<h2>What happened?</h2>'
    '<h2>'
    'Was ist passiert ?'(a02)
    '</h2>'

    '<p>'
*  'You have entered the URL  '
    reason

*  '. However, a valid user ID and password is required.'

    '</p>'
    '</td>'
    '</tr>'
    '<tr>'
    '<td>&nbsp;</td>'
    '</tr>'
    '<tr>'
    '<td class="emphasize">'

*  '<strong>Note</strong>'
    '<strong>'
    'Hinweis'(b01)
    '</strong>'

    '<br>'
*  'If you have maintained your e-mail address in the SAP'
*  'Service Marketplace you can  use this as an alternative '
*  'to your user ID.'
    note


    '</td>'
    '</tr>'
    '<tr>'
    '<td>&nbsp;</td>'
    '</tr>'
    '<tr>'
    '<td>'
    '<p>'
    ' &nbsp;'
    '</p>'

*  '<h2>What can you do?</h2>'
    '<h2>'
    'Was k√∂nnen Sie tun ?'(a05)
    '</h2>'

    '<ul>'
*  '<li>If you have entered your SAP Service Marketplace user'
*  'ID (or e-mail address) and password, please check if you typed it'
*  'correctly.</li>'
*  '<li>If you already had a SAPNet user ID, enter this user ID'
*  'and the corresponding password to log on.<br>'
*  'This user ID is valid for the SAP Service Marketplace.'
*  '</li>'
*  '<li>If you do not have an user ID yet, and you are an SAP'
*  'customer or partner, you can request an user ID and password '
*  'from the'
*  'SAP system administrator at your company, or online at <a href="/'
*  '~sapidp/002006825000100141192000E/" target="_top">'
*  'http://service.sap.com</a>.'
*  '<p class="note">' &
*  'Error&nbsp;code: WEBSMP202-07-20021205143250-0300--'
*  '</p>'
*  '</li>'
    recommendation

    '</ul>'

    '</br><p class="note">'
*   errorcode
    errorcode
    '</p>'
    '</br><p>'
*  ' Sorry for any inconvenience.<br>'
    ' HTTP 401 - Unauthorized'                                "#EC NOTEXT
    '</br><p>'
    ' Ihr SAP Internet Communication Framework Team'(i01)
    '</p>'
    '</td>'
    '</tr>'
    '</table>'
    '</body>'
    '</html>'
    INTO content.
  else.
    CONCATENATE
*   '<!DOCTYPE html PUBLIC '           "#EC NOTEXT
*           '"-//W3C//DTD HTML 4.01'   "#EC NOTEXT
*           'Transitional//EN'         "#EC NOTEXT
*           '">'
    '<html>'
      '<head>'
        '<title>Logon Error Message</title>'
        '<META http-equiv="Content-Type" content="text/html; '
        'charset=UTF-8">'
        '<style type="text/css">'
          'body { font-family:tahoma,helvetica,sans-serif;color:#'
    '333333;background-color:#FFFFFF; }'
    'td { font-family:tahoma,helvetica,sans-serif;font-size:70%;color:'
    '#333333; }'
    'h1 { font-family:tahoma,helvetica,sans-serif;font-size:160%;font-'
    'weight:bold;margin-top:15px;margin-bottom:3px;color:#003366; }'
    'h2 { font-family:verdana,helvetica,sans-serif;font-'
    'size:120%;font-style:italic;font-weight:bold;margin-top:6px;margin-'
    'bottom:6px;color:#999900; }'
    'p { font-family:tahoma,helvetica,sans-serif;color:#333333;margin-'
    'top:4px;margin-bottom:4px; }'
    'ul { font-family:tahoma,helvetica,sans-serif;color:#333333;list-'
    'style-type:square;margin-top:8px;margin-bottom:8px; }'
    'li { font-family:tahoma,helvetica,sans-serif;color:#'
    '33333;margin-top:4px; }'
    '.emphasize { color:#333333;background-'
    'color:#C8E3FF;padding:5px;}'
    '.note { color:#CC6600; }'                                "#EC NOTEXT
    'a { font-family:tahoma,helvetica,sans-serif;text-'
    'decoration:underline;color:#336699; }'
    'a:visited { color:#001166; }'
    'a:hover { text-decoration:none; }'
    '</style>'
    '</head>'
    '<body>'
    '<table cellpadding="0" cellspacing="0" border="0" width="100%">'
    '<tr>'
    '<td>'

*  '<h1>Error Message - User Authentication Error</h1><br>'
    '<h1>'
    'Anmeldung fehlgeschlagen'(a01)
    '</h1>'

    '</td>'
    '</tr>'
    '</table>'
    '</body>'
    '</html>'
    INTO content.
  endif.


ENDMETHOD.


METHOD fill_authentication_methods .
  DATA: subrc_c(4) TYPE c,
        saprc_c(4) TYPE c.
  DATA: l_authmethod_c  TYPE c.

* processing of logon proceure only if icf recorder is active
  CHECK c_accept_remote_recorder_level > 0.

  subrc_c = subrc.
  saprc_c = saprc.
  IF last_authentication_method IS SUPPLIED.
    l_authmethod_c = last_authentication_method.
  ELSE.
    l_authmethod_c = authentication_method.
  ENDIF.
  IF saprc_c = 0.
    CONCATENATE m_recorder_failed_logon-authentication_methods
            ihttp_recorder_user_token c_user
            ihttp_recorder_auth_token l_authmethod_c
            ihttp_recorder_client_token c_client
            ihttp_recorder_langu_token c_langu
            ihttp_recorder_subrc_token subrc_c
            INTO m_recorder_failed_logon-authentication_methods.
  ELSE.
    CONCATENATE m_recorder_failed_logon-authentication_methods
            ihttp_recorder_user_token c_user
            ihttp_recorder_auth_token l_authmethod_c
            ihttp_recorder_client_token c_client
            ihttp_recorder_langu_token c_langu
            ihttp_recorder_subrc_token subrc_c
            ihttp_recorder_saprc_token saprc_c
            INTO m_recorder_failed_logon-authentication_methods.
  ENDIF.
  CONDENSE m_recorder_failed_logon-authentication_methods NO-GAPS.
ENDMETHOD.


METHOD finalize_xhr_logon_via_iframe.
*
*  This method should be called upon succesful logon if the form field 'xhr-logon' was received,
*  indicating a pending XMLHttpRequest logon / Security Session renewal
*   - Delete Security Fields
*   - Render XHR response (w/o calling ICF handler)
*   - Return status code 200
*   - Set Security Session ID (if new session was created) by calling SEND_RESPONSE
*   - System-Call 'Finalize'
*
* The http client (iframe) is supposed to notify the XHR client and to resubmit the request
* (with the Security Session ID cookie and the XHR header field). Only then the ICF handler
* will be called (due to the valid Security Session).

  DATA: l_codepage  TYPE string.
  DATA: l_realm     TYPE string.
  DATA: l_html      TYPE string.
  DATA: lr_entity   TYPE REF TO cl_http_entity.

  me->delete_security_fields( ). "SEND_RESPONSE checks that DELETE_SECURITY_FIELDS has been called before

  IF c_client IS INITIAL. "should never happen ..
    MESSAGE e101(shttp) WITH 'FINALIZE_XHR_LOGON_VIA_IFRAME' 'c_client IS INITIAL'. "#EC NOTEXT
    RETURN.
  ENDIF.

  IF c_authenticated IS INITIAL. "should never happen ...
    MESSAGE e101(shttp) WITH 'FINALIZE_XHR_LOGON_VIA_IFRAME' 'c_authenticated IS INITIAL'. "#EC NOTEXT
    RETURN.
  ENDIF.

* Set status code 200
  me->response->set_status( code   =  200
                            reason =  if_http_status=>reason_200 ).

* in unicode system conversion to utf-8
  IF cl_abap_char_utilities=>charsize = 1.
    CALL METHOD cl_http_utility=>get_logon_charset
      IMPORTING
        id                = l_codepage
      EXCEPTIONS
        charset_not_found = 1
        OTHERS            = 2.
    IF sy-subrc <> 0.
      CLEAR l_codepage.
    ENDIF.
  ENDIF.

  IF l_codepage IS INITIAL.
    l_codepage = 'utf-8'.                                                      "#EC NOTEXT
  ENDIF.
  CONCATENATE 'text/html; charset=' l_codepage INTO l_codepage.                "#EC NOTEXT

  me->response->set_header_field( name  = if_http_header_fields=>content_type  "'Content-Type'
                                  value = l_codepage ).

* Cache control
  me->response->set_header_field( name  = if_http_header_fields=>cache_control "'Cache-Control'
                                  value = 'no-cache, no-store' ).              "#EC NOTEXT

* HTML response (containing single JSON object)
  l_realm = get_xhr_logon_realm( c_client ).

  CONCATENATE '<html> <head> <title></title> <script>'
              'function notifyParent() {'
              'if (window.parent) {'
              'try {'
              ' var status = { xhrLogon: { type: "iframe", realm: "' l_realm '", status: 200 } };'
              ' window.parent.postMessage(JSON.stringify(status), "*");'
              '} catch (error) {}'
              '} } </script> </head>'
              '<body onload="notifyParent();"></body> </html>'
              INTO l_html RESPECTING BLANKS.                "#EC NOTEXT

  me->response->set_cdata( data = l_html ).

* Send out XHR response (w/o calling ICF handler)
  me->send_response(  ).  "important to set cookies (especially SAP_SESSIONID_<SID>_<client>)
  lr_entity ?= me->response.
  lr_entity->destroy( ).
  lr_entity ?= me->request.
  lr_entity->destroy( ).

  system-call plugin                                 "#EC CI_SYSTEMCALL
       id 'HTTP' value 'Finalize'.                          "#EC NOTEXT

*  Notice: this method will not return ...

ENDMETHOD.


method GET_CLIENT.
*
* determination of client
*
DATA: Secure_sesion_active type abap_bool.
DATA: secure_session_value type string.

*-- use mandatory client field
  if not service-oblmandt is initial.
    c_client = service-oblmandt.
    if not c_client is initial.
      m_recorder_failed_logon-client_method =
                ihttp_recorder_client_oblig.
    endif.
  else.
    c_client =
    request->get_header_field( name = 'sap-client' ).       "#EC NOTEXT

    if c_client is initial.
      c_client =
      request->get_form_field( name = 'sap-client' ).       "#EC NOTEXT

      if not c_client is initial.
        m_recorder_failed_logon-client_method =
              ihttp_recorder_client_ffield.
      endif.
    else.
      m_recorder_failed_logon-client_method =
               ihttp_recorder_client_hfield.
    endif.
  endif.

  if c_client is initial.
    c_client = cl_http_user_context=>client.
    if not c_client is initial.
      m_recorder_failed_logon-client_method =
              ihttp_recorder_client_context.
    endif.
  else.
*    update user context from explicit setting (form field)
    cl_http_user_context=>client = c_client.
  endif.

  if c_client is initial.
    c_client = service-icf_mandt.
    if not c_client is initial.
      m_recorder_failed_logon-client_method =
               ihttp_recorder_client_service.

    endif.

  endif.

*-- default client (necessary for alias user)
  if c_client is initial.
    call 'C_SAPGPARAM' id 'NAME'  field 'login/system_client'
                       id 'VALUE' field c_client.


    m_recorder_failed_logon-client_method =
                ihttp_recorder_client_server.
  endif.
endmethod.


METHOD get_langu.

* Determination of language

  DATA: langu_ext(2)  TYPE c,
        langu_ext_str TYPE string.
  DATA: l_accept_bit  TYPE xstring.
  DATA: l_error_text  TYPE c LENGTH 100.

*-- use mandatory language field
  IF NOT service-obllangu IS INITIAL.
    c_langu   = service-obllangu.
    langu_ext = service-obllangu.
    IF NOT langu_ext IS INITIAL.
      m_recorder_failed_logon-language_method = ihttp_recorder_langu_oblig.
    ENDIF.

* SAP Note 1876763
* failure handling
    CONCATENATE 'Value of Mandatory Language field: ' service-obllangu INTO l_error_text. "#EC NOTEXT
    CALL METHOD cl_http_server=>trace
      EXPORTING
        line = l_error_text.
*    MESSAGE s101(shttp) WITH 'Value of Mandatory Language field: ' service-obllangu. "#EC NOTEXT
  ELSE.
    langu_ext = server->request->get_header_field( name = 'sap-language' ).

    IF NOT langu_ext IS INITIAL.
      m_recorder_failed_logon-language_method = ihttp_recorder_langu_hfield.
    ENDIF.

    IF langu_ext  IS INITIAL.
      langu_ext = server->request->get_form_field( name = 'sap-language' ).

      IF NOT langu_ext IS INITIAL.
        m_recorder_failed_logon-language_method = ihttp_recorder_langu_ffield.
      ENDIF.
    ENDIF.

*-- update user context from explicit setting (form field)
    IF NOT langu_ext IS INITIAL.
** SAP Note 1770723
      cl_http_user_context=>iso_language = langu_ext.
    ENDIF.
  ENDIF.

  IF langu_ext IS INITIAL.
    langu_ext = cl_http_user_context=>iso_language.
    IF NOT langu_ext IS INITIAL.
      m_recorder_failed_logon-language_method = ihttp_recorder_langu_context.
    ENDIF.
  ENDIF.

*-- evaluate accept-language header field, as default language
  IF langu_ext IS INITIAL.
*Note 1970892 - zh-TW - Start
    langu_ext_str =
      server->request->get_header_field( name = 'accept-language' ). "#EC NOTEXT
    langu_ext = langu_ext_str.
*Note 1970892 - zh-TW - End
    IF NOT langu_ext IS INITIAL.
      m_recorder_failed_logon-language_method = ihttp_recorder_langu_accept.

* -- accept-language via bit options disabled ?
      l_accept_bit = service-icfbitmap.
      GET BIT 32 OF l_accept_bit INTO l_accept_bit.
      IF l_accept_bit = 0.
*Note 1970892 - zh-TW - Start
*        langu_ext_str = langu_ext.
*Note 1970892 - zh-TW - End
        CALL METHOD check_accept_language
          CHANGING
            accept_language = langu_ext_str.
*Note 1970892 - zh-TW - Start
        langu_ext = langu_ext_str.
*Note 1970892 - zh-TW - End

* SAP Note 1876763
* failure handling
        CONCATENATE 'Value of langu_ext Variable: ' langu_ext INTO l_error_text. "#EC NOTEXT
        CALL METHOD cl_http_server=>trace
          EXPORTING
            line = l_error_text.
*        MESSAGE s101(shttp) WITH 'Value of langu_ext Variable: ' langu_ext. "#EC NOTEXT
      ELSE.
* -- clear langu_ext for further processing of language
        CLEAR langu_ext.

* SAP Note 1876763
* failure handling
        l_error_text = 'Clear langu_ext variable for further processing'. "#EC NOTEXT
        CALL METHOD cl_http_server=>trace
          EXPORTING
            line = l_error_text.
*        MESSAGE s100(shttp) WITH 'Clear langu_ext variable for further processing'. "#EC NOTEXT
      ENDIF.
    ENDIF.
  ENDIF.

  IF langu_ext IS INITIAL.
    langu_ext = service-icf_langu.
    c_langu   = service-icf_langu. "bereits konvertierter ueberneh.

    IF NOT langu_ext IS INITIAL.
      m_recorder_failed_logon-language_method = ihttp_recorder_langu_service.
    ENDIF.
  ENDIF.

  IF NOT langu_ext IS INITIAL AND
         c_langu   IS INITIAL.
    CALL FUNCTION 'CONVERSION_EXIT_ISOLA_INPUT'
      EXPORTING
        input  = langu_ext
      IMPORTING
        output = c_langu
      EXCEPTIONS
        OTHERS = 0.
  ENDIF.

*-- default language -> logon procedure decides
*  if c_langu is initial.
*    call 'C_SAPGPARAM' id 'NAME'  field 'zcsa/system_language'
*                       id 'VALUE' field c_langu.
*  endif.
  IF c_langu IS INITIAL.
    m_recorder_failed_logon-language_method = ihttp_recorder_langu_server.
  ENDIF.

ENDMETHOD.


METHOD get_sec_session_id_from_cookie.
  DATA: lv_secure_session_cookie_name TYPE string.
*
*  Check if Secure Session Cookie is there
*  If there then get back the Secure Session ID
*

  CALL METHOD cl_http_security_session_icf=>security_sessionid_cookie_name
    EXPORTING
      client      = c_client
    RECEIVING
      cookie_name = lv_secure_session_cookie_name.


  CALL METHOD request->get_cookie
    EXPORTING
      name  = lv_secure_session_cookie_name
    IMPORTING
      value = sec_session_id.
ENDMETHOD.


METHOD GET_SESSION_ACCESS_REG_ENTRY.
* retrieve the registry entry based on the session access token
  READ TABLE C_SESSION_ACCESS_REGISTRY WITH TABLE KEY session_access_token = session_access_token INTO registry_entry.

  IF sy-subrc <> 0 OR registry_entry IS INITIAL.
    RAISE session_access_token_not_found.
  ENDIF.
ENDMETHOD.


METHOD get_xhr_logon_realm.

  DATA: l_realm TYPE string.

  CONCATENATE sy-sysid '/' client into l_realm.
  CONCATENATE 'SAP NetWeaver Application Server [' l_realm ']'
    INTO realm RESPECTING BLANKS.                           "#EC NOTEXT

ENDMETHOD.


method GET_XSRF_COOKIE.
  DATA: lv_xsrf_cookie_name  TYPE string.
* Remark: As several SAP systems could be run on the same host therefore XSRF cookie has to contain system id and client
* to avoid ambiguities. The cookie is set for the host. Furthermore XSRF form field id does not contain system id.
    CONCATENATE if_http_form_fields_sap=>sap_xsrf '_' sy-sysid '_' sy-mandt INTO lv_xsrf_cookie_name.
    CALL METHOD request->get_cookie
      EXPORTING
        name  = lv_xsrf_cookie_name
      IMPORTING
        value = xsrf_cookie.
endmethod.


METHOD if_http_server~enable_foreign_session_access.
*
* This method prepares access to an existing stateful HTTP session by a foreign user,
* that means a user that did not create this session. Given the foreign user id and
* the URL path to a terminating SICF service node, the method returns a session access
* token for the foreign user and registers the triplett of user id, URL path and session
* access token in table c_session_access_registry. Subsequently the foreign user can
* access the stateful HTTP session by supplying the session access token in the URL
* parameter sap-session_access_token. Access will be granted if the supplied session
* access token is registered, matches the user id and the registered URL path is
* prefix of the requested URL path.
*

* Diese Methode bereitet den Zugang zu einer zustandsbehafteten HTTP-Sitzung f√ºr einen
* Fremdbenutzer vor (d.h. einen Benutzer, der die HTTP-Sizung nicht angelegt hat). Zur
* gegebenen g√ºltigen Benutzerkennung und zum gegebenen URL-Pfad zu einem aktiven
* ICF-Blattknoten gibt die Methode ein generiertes Sitzungszugangstoken f√ºr den
* Fremdbenutzer zur√ºck und registriert das Triplett aus Userkennung, URL-Pfad und
* Sitzungszugangstoken in der HTTP-Sitzung.


  DATA: lv_registry_entry TYPE gt_session_access_reg_entry.
  DATA: lv_uuid           TYPE sysuuid_x16.
  DATA: lv_random         TYPE xstring.
  DATA: lv_icfactive      TYPE icfactive.
  DATA: lv_suffix         TYPE icfredurl.
  DATA: lv_leafnode       TYPE icfchar1.
  DATA: lv_field          TYPE ihttpnvp.
  DATA: lv_fields         TYPE tihttpnvp.
  DATA: lv_path           TYPE string.
  DATA: lv_path_prefix    TYPE string.
  DATA: lv_path_postfix   TYPE string.
  DATA: lv_uri_parameter  TYPE string.

* elimination of ;-parameters from path
  DATA: lv_items TYPE TABLE OF string.
  DATA: lv_helper TYPE string.
  DATA: lv_subpath TYPE string.
  FIELD-SYMBOLS <lv_item> TYPE string.

* note 1658516
  DATA: lv_xsrf_token_validated TYPE abap_bool.
  DATA: lv_security_context TYPE security_context.
  TYPES: BEGIN OF cookie_struct,
           token     TYPE security_context_xsrf_token,  "24 characters (128 bit, base64)
           timestamp TYPE tzntimestp,                   "14 characters (YYYYMMDDhhmmss)
           hmac_sha2(44) TYPE c,                        "44 characters (256 bit, base64)
         END OF cookie_struct.
  DATA: lv_cookie_struct TYPE cookie_struct.  "in total: 82 characters
  DATA: lv_hmac_feed     TYPE string,
        lv_hmac_result   TYPE hash512_base_64,
        lv_current_time  TYPE timestamp.


* check whether session is stateful
  IF stateful = co_disabled.
    RAISE session_is_not_stateful.
  ENDIF.

* check whether the user account exists
  IF user_id IS NOT INITIAL.
    CALL FUNCTION 'SUSR_USER_CHECK_EXISTENCE'
      EXPORTING
        user_name            = user_id
      EXCEPTIONS
        user_name_not_exists = 1
        OTHERS               = 2.

    IF sy-subrc <> 0.
      RAISE user_unknown.
    ENDIF.
  ENDIF.

* if url_path includes additional path or form paramaters so filter them out of the whole URL.
  CALL FUNCTION 'SWLWP_URI_PARSE'
    EXPORTING
      uri                 = url_path
      parse_authority     = 'X'
    IMPORTING
*     scheme              = l_scheme
*     AUTHORITY           =
*     USERINFO            =
*     HOSTPORT            =
*     host                = l_host
*     port                = l_port
      abs_path            = lv_path
*     rel_segment         = l_rel_segment
*     query               =
*     OPAQUE_PART         =
*     FRAGMENT            =
*     is_relative         = lv_uri_is_relative
*     HAS_NET_PATH        =
*     HAS_REL_PATH        =
*     HAS_EMPTY_AUTHORITY =
*     HAS_IPV4_HOST       =
    EXCEPTIONS
      uri_no_path         = 1
      OTHERS              = 2.

  IF sy-subrc = 0.
* remove rewriting info out of the path
    IF lv_path CS '(' AND lv_path CS ')'.
      SPLIT lv_path AT '(' INTO lv_path_prefix lv_path_postfix.
      SPLIT lv_path_postfix AT ')' INTO lv_uri_parameter lv_path_postfix.
      lv_path = |{ lv_path_prefix }{ lv_path_postfix }|.
    ENDIF.
  ELSE.
    RAISE url_path_is_not_supported.
  ENDIF.

* remove ; parameters, e.g. ;sap-ext-sid=<v> in /a;sap-ext-sid=<v>/c, from path
  IF lv_path CS ';'.
    SPLIT lv_path AT ';' INTO TABLE lv_items.
    CLEAR lv_path.
* remove all available ; fields
    LOOP AT lv_items ASSIGNING <lv_item>.
      IF <lv_item> CS '='.
        SPLIT <lv_item> AT '/' INTO lv_helper lv_subpath.
        IF lv_subpath IS NOT INITIAL.
         "add the subpaths without nam=value pairs
          CONCATENATE lv_path '/' lv_subpath INTO lv_path.
        ENDIF.
      ELSE.
       "add the subpaths without nam=value pairs
        CONCATENATE lv_path <lv_item> INTO lv_path.
      ENDIF.
    ENDLOOP.
  ENDIF.

  CALL METHOD cl_icf_tree=>is_service_last_node
    EXPORTING
      url               = lv_path
      hostnumber        = 0
    IMPORTING
      urlsuffix         = lv_suffix
*     icfnodguid        =
*     icf_name          =
*     int_alias         =
*     ext_alias         =
      icfactive         = lv_icfactive
      last_node_in_tree = lv_leafnode
*     icfaltnme         =
    EXCEPTIONS
      invalid_url       = 1
      invalid_service   = 2
      OTHERS            = 3.
  IF sy-subrc <> 0 OR lv_icfactive IS INITIAL OR lv_leafnode IS INITIAL.
    RAISE url_path_is_not_supported.
  ENDIF.

* create a session access token
  TRY.
      lv_uuid = cl_system_uuid=>create_uuid_x16_static( ).
    CATCH cx_uuid_error.
      RAISE internal_error.
  ENDTRY.

  CALL FUNCTION 'GENERATE_SEC_RANDOM'                "note 1410548
    EXPORTING
      length         = 16
    IMPORTING
      random         = lv_random
    EXCEPTIONS
      invalid_length = 1
      no_memory      = 2
      internal_error = 3
      OTHERS         = 4.
  IF sy-subrc <> 0.
    RAISE internal_error.
  ENDIF.

  CONCATENATE lv_random lv_uuid INTO lv_random IN BYTE MODE.
  lv_field-name = 'sst'. "security session token
  lv_field-value = lv_random.
  APPEND lv_field TO lv_fields.
*
* create a URL econform base64 value. This can be done via method fields_to_string
* and option (encode) value 5. √Åternatively, if this base64 option is not available a hex to string could
* also be used (e.g. for release 620)
*
  lv_registry_entry-session_access_token = cl_http_utility=>fields_to_string(
        fields = lv_fields
        encode = 5
        ).

* memorize session access token in task memory
  lv_registry_entry-url_path = lv_path.
  lv_registry_entry-user_id  = user_id.
  lv_registry_entry-one_time_access_token  = one_time_access_token.
  lv_registry_entry-marked_for_deletion    = abap_false. "note 1658516

  INSERT lv_registry_entry INTO TABLE c_session_access_registry.
  IF sy-subrc <> 0.
    RAISE internal_error.
  ENDIF.

  session_access_token = lv_registry_entry-session_access_token.


* Note 1658516: store a copy of the XSRF token (if available)
  IF m_xsrf_token_copy IS NOT INITIAL.
    CALL METHOD me->validate_xsrf_token
      EXPORTING
        token                    = m_xsrf_token_copy
      IMPORTING
        successful               = lv_xsrf_token_validated
      EXCEPTIONS
        token_not_found          = 1
        cookie_not_found         = 2
        internal_error           = 3
        called_by_public_service = 4
        OTHERS                   = 5.
    IF sy-subrc <> 0 OR abap_false = lv_xsrf_token_validated.
      CLEAR m_xsrf_token_copy.
    ELSE.
      RETURN. "nothing to do
    ENDIF.
  ENDIF.

* Try to retrieve the XSRF token from the Security Context (if exists)
  TRY.
      lv_security_context = cl_http_security_session_admin=>get_current_session_context( ).
    CATCH cx_http_security_session_admin .
  ENDTRY.
  IF lv_security_context-xsrf_token IS NOT INITIAL.
    m_xsrf_token_copy = lv_security_context-xsrf_token.
    RETURN. "that's all
  ENDIF.

* Fallback: retrieve XSRF token from XSRF cookie (if exists)
  IF m_xsrf_cookie_value IS INITIAL.
    m_xsrf_cookie_value = get_xsrf_cookie( ).
  ENDIF.
  IF m_xsrf_cookie_value IS NOT INITIAL.
*   parse cookie:  <token> <timestamp> <hmac>
    lv_cookie_struct = m_xsrf_cookie_value.
    m_xsrf_token_copy = lv_cookie_struct-token.
*   calculate HMAC value for comparison
    CONCATENATE m_xsrf_token_copy lv_cookie_struct-timestamp sy-uname INTO lv_hmac_feed.
    CALL FUNCTION 'CALCULATE_HMAC_FOR_CHAR'
      EXPORTING
        alg                          = 'SHA2'
        data                         = lv_hmac_feed
*       LENGTH                       = 0
*       CLIENT_INDEPENDENT           =
*       RECORD_NUMBER                = '00'
*       KEY_MUST_EXIST               = ' '
      IMPORTING
*       HMAC                         =
*       HMACLEN                      =
*       HMACX                        =
*       HMACXLEN                     =
        hmacbase64                   = lv_hmac_result  "ALPHABET_UC_BASE64
*       HMACBASE64LEN                =
      EXCEPTIONS
        unknown_alg                  = 1
        param_length_error           = 2
        internal_error               = 3
        malloc_error                 = 4
        abap_caller_error            = 5
        base64_error                 = 6
        calc_hmac_error              = 7
        rsec_record_not_found        = 8
        rsec_record_access_denied    = 9
        rsec_secstore_access_denied  = 10
        rsec_error                   = 11
        param_missing                = 12
        rng_error                    = 13
        record_number_error          = 14
        rsec_system_data_changed     = 15
        rsec_system_data_changed_sid = 16
        enqueue_set_failed           = 17
        enqueue_release_failed       = 18
        enqueue_internal_error       = 19
        OTHERS                       = 20.
    IF sy-subrc <> 0.
      CLEAR m_xsrf_token_copy.
      RETURN. "that's all
    ENDIF.

    TRANSLATE lv_hmac_result USING '+-/_'. "ALPHABET_UC_BASE64URL
*   HMAC value has to be identical ("same user" constraint)
    IF lv_cookie_struct-hmac_sha2 <> lv_hmac_result.
      CLEAR m_xsrf_token_copy.
      RETURN. "that's all
    ENDIF.

*   Time constraint check
    DATA: lv_created  TYPE timestamp,
          lv_timediff TYPE tzntstmpl.
    lv_created = lv_cookie_struct-timestamp.
    GET TIME STAMP FIELD lv_current_time.
    TRY.
        CALL METHOD cl_abap_tstmp=>subtract
          EXPORTING
            tstmp1 = lv_current_time
            tstmp2 = lv_created
          RECEIVING
            r_secs = lv_timediff.
      CATCH cx_parameter_invalid_range .
      CATCH cx_parameter_invalid_type .
    ENDTRY.

    IF lv_timediff >= 86400. "24h = 86400s
      CLEAR m_xsrf_token_copy.
      RETURN. "that's all
    ENDIF.

  ELSE.
    CLEAR m_xsrf_token_copy.
  ENDIF.

ENDMETHOD.


METHOD if_http_server~get_xsrf_token.
*------------------------------------------------------------------------------------
*  This method is in the responsibility of the Security Development team.
*  Use message component BC-SEC-LGN to report problems.
*  Author:   D021767
*  Date:     2011-04-27
*------------------------------------------------------------------------------------
  DATA: lv_security_context TYPE security_context.
  DATA: l_error_text        TYPE c LENGTH 100.

  CLEAR: token, lv_security_context.

* First check the precondition: session has to be personalized (no public services allowed)
  IF  c_authenticated <> 1 OR
    ( c_authenticated = 1 AND authentication_method = authmethod_service ).
    RAISE called_by_public_service.
  ENDIF.

* Note 1962529: create security session on demand (delayed) after R3AUTH authentication
  IF ( m_sec_session_pending_local = abap_true OR m_sec_session_pending_trusted = abap_true ).
* SAP Note 1876763
* failure handling
    CONCATENATE 'GET_XSRF_TOKEN calling' 'CREATE_SEC_SESS_4_PENDING_REQ' INTO l_error_text. "#EC NOTEXT
    CALL METHOD cl_http_server=>trace
      EXPORTING
        line = l_error_text.
*    MESSAGE s101(shttp) WITH 'GET_XSRF_TOKEN calling' 'CREATE_SEC_SESS_4_PENDING_REQ'.
    CALL METHOD me->create_sec_sess_4_pending_req( ).
  ENDIF.  "end of note 1962529

* Try to retrieve the XSRF token from the Security Context (if exists)
  token = m_xsrf_token_from_sec_context. "might be empty (performance optimization)
  IF token IS INITIAL.
    TRY.
        lv_security_context = cl_http_security_session_admin=>get_current_session_context( ).
        token = m_xsrf_token_from_sec_context = lv_security_context-xsrf_token.  "might still be empty
      CATCH cx_http_security_session_admin .
    ENDTRY.
  ENDIF.
  IF token IS NOT INITIAL.
    CLEAR m_xsrf_cookie_value.  "in case there has been one ...
    m_xsrf_cookie_created = abap_false.
    RETURN. "that's all (no XSRF cookie needs to be created)
  ENDIF.

* ------- The following actions are only required if system runs w/o activated Security Session Management -------

  DATA: lv_timestamp_x  TYPE timestamp,
        lv_timestamp    TYPE tzntimestp,
        lv_token_cookie TYPE string,
        lv_hmac_feed    TYPE string,
        lv_hmac_result  TYPE hash512_base_64,
        lv_random       TYPE xstring,
        lv_create_token TYPE abap_bool,
        lv_current_time TYPE timestamp.
  TYPES: BEGIN OF cookie_struct,
           token         TYPE security_context_xsrf_token,  "24 characters (128 bit, base64)
           timestamp     TYPE tzntimestp,                   "14 characters (YYYYMMDDhhmmss)
           hmac_sha2(44) TYPE c,                        "44 characters (256 bit, base64)
         END OF cookie_struct.
  DATA: lv_cookie_struct TYPE cookie_struct.  "in total: 82 characters
  DATA: lv_session_access_token  TYPE string.                       "note 1658516
  DATA: lv_registry_entry        TYPE gt_session_access_reg_entry.  "note 1658516

* If the XSRF token cannot be retrieved from the Security Context, the token and a XSRF cookie need to be created.
* But before creating the XSRF token it should be checked if a XSRF cookie already exists.
* A XSRF cookie could either result from a previous call of this method or it was received with the request.
  IF m_xsrf_cookie_value IS INITIAL.
    m_xsrf_cookie_value = get_xsrf_cookie( ).
  ENDIF.

  IF m_xsrf_cookie_value IS INITIAL.
    IF m_xsrf_token_copy IS INITIAL.
      lv_create_token = abap_true.
    ELSE.
*   Note 1658516: if a valid session access token was provided with the same request,
*                 then a copy of the XSRF token is retrieved from the task memory
*   (requirement: GET_XSRF_TOKEN was called prior to ENABLE_FOREIGN_SESSION_ACCESS)
      lv_session_access_token = request->get_form_field( name = if_http_form_fields_sap=>sap_session_access_token ).
      IF lv_session_access_token IS INITIAL.
        lv_create_token = abap_true.
      ELSE.
*   Notice: it is sufficient to ensure that the received session access token belongs
*           to this server context because the path contraint check was performed before
*           (in method REAUTHENTICATION_ACCESS_TOKEN)
        CALL METHOD get_session_access_reg_entry
          EXPORTING
            session_access_token           = lv_session_access_token
          IMPORTING
            registry_entry                 = lv_registry_entry
          EXCEPTIONS
            session_access_token_not_found = 1.
        IF sy-subrc <> 0.
          lv_create_token = abap_true.
        ELSE.
          token = m_xsrf_token_copy.
          lv_create_token = abap_false.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.
*   Retrieve XSRF token from XSRF cookie and check whether it is (still) valid
    lv_cookie_struct = m_xsrf_cookie_value.

*   calculate HMAC value for comparison
    CONCATENATE lv_cookie_struct-token lv_cookie_struct-timestamp sy-uname INTO lv_hmac_feed.

    CALL FUNCTION 'CALCULATE_HMAC_FOR_CHAR'
      EXPORTING
        alg                          = 'SHA2'
        data                         = lv_hmac_feed
*       LENGTH                       = 0
*       CLIENT_INDEPENDENT           =
*       RECORD_NUMBER                = '00'
*       KEY_MUST_EXIST               = ' '
      IMPORTING
*       HMAC                         =
*       HMACLEN                      =
*       HMACX                        =
*       HMACXLEN                     =
        hmacbase64                   = lv_hmac_result  "ALPHABET_UC_BASE64
*       HMACBASE64LEN                =
      EXCEPTIONS
        unknown_alg                  = 1
        param_length_error           = 2
        internal_error               = 3
        malloc_error                 = 4
        abap_caller_error            = 5
        base64_error                 = 6
        calc_hmac_error              = 7
        rsec_record_not_found        = 8
        rsec_record_access_denied    = 9
        rsec_secstore_access_denied  = 10
        rsec_error                   = 11
        param_missing                = 12
        rng_error                    = 13
        record_number_error          = 14
        rsec_system_data_changed     = 15
        rsec_system_data_changed_sid = 16
        enqueue_set_failed           = 17
        enqueue_release_failed       = 18
        enqueue_internal_error       = 19
        OTHERS                       = 20.
    IF sy-subrc <> 0.
      lv_create_token = abap_true.
    ELSE.
      TRANSLATE lv_hmac_result USING '+-/_'. "ALPHABET_UC_BASE64URL
*     HMAC value has to be identical ("same user" constraint)
      IF lv_cookie_struct-hmac_sha2 <> lv_hmac_result.
        lv_create_token = abap_true.
      ELSE.
*     Time constraint check
        DATA: lv_created  TYPE timestamp,
              lv_timediff TYPE tzntstmpl.
        lv_created = lv_cookie_struct-timestamp.
        GET TIME STAMP FIELD lv_current_time.
        TRY.
            CALL METHOD cl_abap_tstmp=>subtract
              EXPORTING
                tstmp1 = lv_current_time
                tstmp2 = lv_created
              RECEIVING
                r_secs = lv_timediff.
          CATCH cx_parameter_invalid_range .
          CATCH cx_parameter_invalid_type .
        ENDTRY.
        IF lv_timediff < 86400.            "24h = 86400s
          token = lv_cookie_struct-token.
        ELSE.
          lv_create_token = abap_true.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF. "XSRF cookie retrieved and (if possible) parsed to retrieve contained XSRF token


* Otherwise create XSRF token and XSRF cookie, now
  IF lv_create_token = abap_true.

    CALL FUNCTION 'GENERATE_SEC_RANDOM'
      EXPORTING
        length         = 16   "16 Bytes = 128 Bits
      IMPORTING
        random         = lv_random
      EXCEPTIONS
        invalid_length = 1
        no_memory      = 2
        internal_error = 3
        OTHERS         = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING internal_error.
    ENDIF.

    CALL FUNCTION 'SSFC_BASE64_ENCODE'
      EXPORTING
        bindata                  = lv_random
*       BINLENG                  =
      IMPORTING
        b64data                  = token  "ALPHABET_UC_BASE64
      EXCEPTIONS
        ssf_krn_error            = 1
        ssf_krn_noop             = 2
        ssf_krn_nomemory         = 3
        ssf_krn_opinv            = 4
        ssf_krn_input_data_error = 5
        ssf_krn_invalid_par      = 6
        ssf_krn_invalid_parlen   = 7
        OTHERS                   = 8.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING internal_error.
    ENDIF.
    TRANSLATE token USING '+-/_'. "ALPHABET_UC_BASE64URL

*   Create XSRF cookie (containing the XSRF token)
    GET TIME STAMP FIELD lv_timestamp_x.
    lv_timestamp = lv_timestamp_x.
    CONCATENATE token lv_timestamp sy-uname INTO lv_hmac_feed.

    CALL FUNCTION 'CALCULATE_HMAC_FOR_CHAR'
      EXPORTING
        alg                          = 'SHA2'
        data                         = lv_hmac_feed
*       LENGTH                       = 0
*       CLIENT_INDEPENDENT           =
*       RECORD_NUMBER                = '00'
*       KEY_MUST_EXIST               = ' '
      IMPORTING
*       HMAC                         =
*       HMACLEN                      =
*       HMACX                        =
*       HMACXLEN                     =
        hmacbase64                   = lv_hmac_result  "ALPHABET_UC_BASE64
*       HMACBASE64LEN                =
      EXCEPTIONS
        unknown_alg                  = 1
        param_length_error           = 2
        internal_error               = 3
        malloc_error                 = 4
        abap_caller_error            = 5
        base64_error                 = 6
        calc_hmac_error              = 7
        rsec_record_not_found        = 8
        rsec_record_access_denied    = 9
        rsec_secstore_access_denied  = 10
        rsec_error                   = 11
        param_missing                = 12
        rng_error                    = 13
        record_number_error          = 14
        rsec_system_data_changed     = 15
        rsec_system_data_changed_sid = 16
        enqueue_set_failed           = 17
        enqueue_release_failed       = 18
        enqueue_internal_error       = 19
        OTHERS                       = 20.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING internal_error.
    ENDIF.

    TRANSLATE lv_hmac_result USING '+-/_'. "ALPHABET_UC_BASE64URL
    CONCATENATE token lv_timestamp lv_hmac_result INTO lv_token_cookie.

*   Set XSRF cookie
    m_xsrf_cookie_value = lv_token_cookie.
    m_xsrf_cookie_created = abap_true.
  ENDIF.

ENDMETHOD.


METHOD if_http_server~logoff.
  DATA: l_sec_error TYPE REF TO cx_http_security_session.
  DATA: l_redirect_url    TYPE string,
        l_redirect        TYPE ICF_REDIRECT_URL.

** 1 ) set to stateles: processing in send_response/proceed_logoff
** 2) call terminate method from security with the original security session cookie: processing here
** 4) dete MYSAPSSO2 cookie, if required: processing in send_response/proceed_logoff
** b) if not portal context ( DSM )  -> delete Cookie (skiped): to be checed by application/caller
**   Do I run in portal or business client ?
**   request->get_form_field( name = if_http_form_fields_sap=>sap_ep_version ) is not initial.
**   request->get_form_field( name = cl_wdr_client_constants=>client_nwbc ) is not initial.
**

* Handle optional parameter REDIRECT_URL
*
* Process Whitelist Check for entry type '21' (ICF)
  l_redirect_url = redirect_url.
  redirect_whitelist_failed = abap_false.
  IF l_redirect_url IS NOT INITIAL.
    TRY.
        CALL METHOD cl_http_utility=>if_http_utility~check_http_whitelist
          EXPORTING
            entry_type    = '21'
            client        = c_client
            url           = l_redirect_url
            url_parm_name = 'redirectURL'.
      CATCH cx_http_whitelist.
        redirect_whitelist_failed = abap_true.
        clear l_redirect_url.  "but resume with logoff processing
    ENDTRY.
  ENDIF.

*
* Initiate security session logoff directly so that, if after logoff call an application error
* occur, e.g. an ABAP runtime error or messages of type E, A or X,  so that at least the
* the security session termination should be fulfilled (avoid memory leak in sense of
* orphan sessions).
* Remark: avoid calling terminate_security_session more than once, e.g. if appliaction calls logoff
*         more than once, since this lead to an exception in terminate_security_session
  IF m_logoff IS INITIAL.
    IF m_security_session_cookie IS NOT INITIAL.
      TRY.
          CALL METHOD cl_http_security_session_icf=>terminate_security_session
            EXPORTING
              session_id       = m_security_session_cookie
              client           = c_client
              server           = me
              propagate_logoff = propagate_logoff
              redirect_url     = l_redirect_url.

        CATCH cx_http_security_session INTO l_sec_error.
* transfer exception message into sy-msg* fields, the only required field is sy-msgty
          CALL METHOD cl_message_helper=>set_msg_vars_for_if_msg
            EXPORTING
              text = l_sec_error.

* Remark: If exception logoff_not_possible is not handled/caught by the caller so the error
* message with the provided error text is prcessed instead or an ABAP runtime error.
          MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING logoff_not_possible.

*          RAISE logoff_not_possible.
*          IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
*            MESSAGE e000(sr) WITH 'Abbau der Security Session mi√ülungen (Intern)!'(lg1).
*          ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
*            MESSAGE e000(sr) WITH 'Abbau der Security Session mi√ülungen (Program)!'(lg2).
*          ENDIF.
      ENDTRY.
    ENDIF.

* Is no application last page already registerd, so register the logoff page
* furthermore avoid the registration of logoff page more than once, if application calls logoff method
* several times
    IF m_last_page IS INITIAL.
** Register the logoff page SHTTP/LOGOFF_PAGE (001560AA0E0802DCA99465E2B20B08AB)
      DATA: lv_error_page TYPE icf_response_page.
      DATA: lv_response_page_type TYPE icf_page_type.

      lv_response_page_type    = co_page_logoff_type.
      lv_error_page-body       = '001560AA0E0802DCA99465E2B20B08AB'.
      CALL METHOD set_page
        EXPORTING
          response_page_type   = lv_response_page_type
          response_option      = co_response_page_option
          response_option_page = lv_error_page
        EXCEPTIONS
          invalid_parameter    = 1.

* Remark: m_send_page_is_called is used to indicate whether application has triggered send_page
* or want to send it's own response, e.g. html page
    ENDIF.
  ENDIF.

* redirect
  IF l_redirect_url IS NOT INITIAL.
    me->response->redirect( url = l_redirect_url ).

    l_redirect-status = '0'.           " ~CO_REDIRECT_STATUS_302
    l_redirect-url = l_redirect_url.
    CALL METHOD me->set_page
    EXPORTING
      RESPONSE_PAGE_TYPE      = '2'     "co_page_logoff_type
      RESPONSE_OPTION         = 'X'     "co_response_redirect_option
      response_option_redirect_url = l_redirect
    EXCEPTIONS
      others    = 1.
  ENDIF.

  IF delete_mysapsso2_cookie = abap_true.
    m_logoff = 2.
  ELSE.
    m_logoff = 1.
  ENDIF.

ENDMETHOD.


METHOD if_http_server~send_page.
  DATA: rc       TYPE i.
  DATA: l_exception TYPE REF TO cx_icf_do_not_catch.

  IF m_send_response_return_called = abap_true.
    message x000(sr) with 'Method SEND_RESPONSE_AND_RETURN already processed.'."#EC NOTEXT
  ENDIF.
*
* for the coordination of SEND_PAGE (to send an OTR last page) and LOGOFF methods, i.e. if LOGOFF is called
* before the method SEND_PAGE so transfer the OTR lastpage instead of application response page
*
  m_send_page_is_called = abap_true.

  CREATE OBJECT l_exception.

* -- refresh the original response object any how
  CALL METHOD refresh_response
    EXCEPTIONS
      OTHERS = 1.

** -- response protocol should be request protocol
  IF m_protocol_version IS NOT INITIAL.
    response->set_header_field( name  = '~server_protocol'
                                value = m_protocol_version ). "#EC NOTEXT
  ENDIF.

*  data: _entity type ref to cl_http_entity,
*        c_msg   type %_c_pointer,
*        conn_name type string.
*  _entity ?= response.
*  c_msg = _entity->m_c_msg.
*  conn_name = 'Me'.
*

*
*  set session to stateless
*
  CALL 'ICF_DISPATCH' ID 'HTTP'        FIELD 'K'
                      ID 'KeepContext' FIELD 'N'.
  set_session_stateful( stateful = co_disabled ).

*
** do not send the page directly since post processing
** steps in cl_http_server_net->send_response method
** are necessary (e. g. deleting of session cookies)
*
  IF m_last_page  IS INITIAL OR
     ( m_last_page-kind       IS INITIAL AND
       m_last_page-header     IS INITIAL AND
       m_last_page-body       IS INITIAL ) OR
     ( m_last_page-kind       IS NOT INITIAL AND
       m_last_page-redirect   IS INITIAL ).
    default_last_page( ).
  ELSEIF m_last_page_already_processed = abap_false.
* do not process last page twice, namled with hekp of both methods send_page and logoff
    send_last_page( ).
  ENDIF.



*  elseif m_last_page-kind is initial.
** -- read OTR body template
*    system-call plugin
*        id 'HTTP'               value 'SendPageAndReturn' "#EC NOTEXT
*        id 'Name'               value conn_name
*        id 'NoSend'             value 'Y'
*        id 'LastPageHeaderGUID' value m_last_page-header
*        id 'LastPageBodyGUID'   value m_last_page-body
*        id 'LogonTime'          value m_authentication_time
*        id 'LogonMethod'        value authentication_method
*        id 'AuthorizationTime'  value m_authorization_time
*        id 'ExecutionTime'      value m_exe_time
*        id 'MessageOut'         value c_msg
*        id 'RC'                 value rc.
*  else.
*      data: l_redirect type string.
*      data: status     type i. "#EC NEEDED
*      l_redirect = m_last_page-redirect.
*
** -- status: 0= 302,1 = 301, 2 = 302
*      status = m_last_page-redirect_code.
*
*      system-call plugin
*        id 'HTTP'  value 'SendPageAndReturn' "#EC NOTEXT
*        id 'Name'                       value conn_name
*        id 'NoSend'                     value 'Y'
*        id 'RedirectTemplate'           value l_redirect
*        id 'SendPageRedirectStatus'     value status
*        id 'LogonTime'                  value m_authentication_time
*        id 'LogonMethod'                value authentication_method
*        id 'AuthorizationTime'          value m_authorization_time
*        id 'ExecutionTime'              value m_exe_time
*        id 'MessageOut'                 value c_msg
*        id 'RC'                         value rc.
*  endif.


  l_exception->m_connection_error-ecode = rc.
  IF rc = 0 AND sy-subrc <> 0.
    l_exception->m_connection_error-ecode = sy-subrc.
  ENDIF.
  IF l_exception->m_connection_error-ecode <> 0.
    l_exception->m_connection_error-name = 'CO_PAGE_PROCESSING_FAILED'.
    CALL FUNCTION 'HTTP_GET_ERRORCODE'
      EXPORTING
        errorcode         = l_exception->m_connection_error-ecode
      IMPORTING
        errortext         = l_exception->m_connection_error-emessage
      EXCEPTIONS
        invalid_errorcode = 1
        OTHERS            = 2.                              "#EC *
  ENDIF.
* -- post processing steps

  RAISE EXCEPTION l_exception.
ENDMETHOD.


method if_http_server~set_compression .
*
* compression only if
* a) client protocol >=  HTTP/1.1
* a) client can decode gzip documents ('accept-encoding')
* b) running plattform support this feature
*

********************** C A U T I O N**************************
*
* Please consider that the method set_comression must be called
* after you set all of your HTTP-header-Fields in your applications.
*
* So please call as follow:
* 1) IF_HTTP_ENTITY~SET_HEADER_FIELD(s)
* 2) IF_HTTP_SERVER~SET_COMPRESSION
*
* In this case, we can give you gurantee that the
* used document will be compressed properly, if the prerequistite
* conditions are fulfilled

* Please consider the sap note #1233914 for more detail
* Findings (see note #1233914):
* Up to now set_compression method was executed bevor HTTP extensions, i.e. HTTP handler classes,
* has been initiated. This behaviour was necessary to allow application to execute
* set_method individually. Because of the extended checks for BSP/WedbDynpro specific response header fields
* it is now required to execute this method after complete execution of the application. This is the point where
* the response header fields are filled by the applications.
*
**************************************************************

  DATA: l_last_err TYPE c LENGTH 3.
*
* Compression is done in the application
*
  m_compression_done = abap_true.

  CALL METHOD check_compression
    EXCEPTIONS
      compression_not_possible = 1.

  IF sy-subrc = 0.
    DATA: _entity TYPE REF TO cl_http_entity,
         c_msg   TYPE %_c_pointer.

    _entity ?= response.
    c_msg = _entity->m_c_msg.

    SYSTEM-CALL ICT
     DID
       ihttp_scid_compress_data
     PARAMETERS
       c_msg                            " > c handle
       options                          " >
       c_last_error.                    " < return code

*      call method response->compress_when_serialized
*          exporting
*             options = options.
*      c_last_error = response->get_last_error( ).

    IF c_last_error <> 0.
* to recognize the error in ict layer
      c_last_error = c_last_error + 100.
      l_last_err = c_last_error.

* failure handling
     CALL METHOD cl_http_server=>trace
       EXPORTING
         line   = l_last_err.

*      raise compression_not_possible.
      MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
            l_last_err RAISING compression_not_possible.
    ENDIF.

  ELSE.
*    raise compression_not_possible.
    l_last_err = sy-msgv1.
* failure handling
     CALL METHOD cl_http_server=>trace
       EXPORTING
         line   = l_last_err.

    MESSAGE ID 'SR' TYPE 'S' NUMBER '000' WITH
            l_last_err RAISING compression_not_possible.

  ENDIF.

ENDMETHOD.


METHOD if_http_server~set_page.
  DATA: lv_document TYPE string.
* Procedure:
* 1st step: Check RESPONSE_PAGE_TYPE for valid error page types, i.e. CO_PAGE_ERROR_TYPE or CO_PAGE_LOGOFF_TYPE
* 2nd step: Check RESPONSE_OPTION for valid options, i.e. CO_RESPONSE_REDIRECT_OPTION or CO_RESPONSE_PAGE_OPTION
* 3rd step: Check the parameters RESPONSE_OPTION_PAGE and RESPONSE_OPTION_REDIRECT_URL according to the setting of
*           2nd step, i.e. setting of RESPONSE_OPTION
* 4th step: install/register the propsed page/url for runtime
*

  IF response_page_type = co_page_error_type.
* Registration of application error page
    IF response_option = co_response_page_option.
* registration of page header and/or body
      IF response_option_page-header IS INITIAL AND response_option_page-body IS INITIAL.
        RAISE invalid_parameter.
      ELSE.
* Does OTR document exist ?
        IF response_option_page-header IS NOT INITIAL.
          CALL METHOD me->read_otr_document
            EXPORTING
              guid               = response_option_page-header
            IMPORTING
              document           = lv_document
            EXCEPTIONS
              document_not_found = 1.
          IF sy-subrc <> 0.
            RAISE invalid_parameter.
          ENDIF.
        ENDIF.

        IF response_option_page-body IS NOT INITIAL.
          CALL METHOD me->read_otr_document
            EXPORTING
              guid               = response_option_page-body
            IMPORTING
              document           = lv_document
            EXCEPTIONS
              document_not_found = 1.
          IF sy-subrc <> 0.
            RAISE invalid_parameter.
          ENDIF.
        ENDIF.
        CALL 'ICF_DISPATCH' ID 'HTTP'  FIELD 'R'
               ID 'HeaderTemplateGUID' FIELD response_option_page-header
               ID 'BodyTemplateGUID'   FIELD response_option_page-body.
      ENDIF.
    ELSEIF response_option = co_response_redirect_option.
* Registration of redirect URL
      IF response_option_redirect_url-url IS INITIAL OR
         ( response_option_redirect_url-status <> co_redirect_status_301 AND
           response_option_redirect_url-status <> co_redirect_status_302 AND
           response_option_redirect_url-status <> co_redirect_status_302_or_307 ).
        RAISE invalid_parameter.
      ELSE.
        CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'R'
          ID 'RedirectTemplate'       FIELD response_option_redirect_url-url
          ID 'RedirectStatus'         FIELD response_option_redirect_url-status.
      ENDIF.
    ELSE.
      RAISE invalid_parameter.
    ENDIF.
  ELSEIF response_page_type = co_page_logoff_type.
* Registration of logoff page
    IF response_option = co_response_page_option.
* Registration of page header and/or body
      IF response_option_page-header IS INITIAL AND response_option_page-body IS INITIAL.
        RAISE invalid_parameter.
      ELSE.
* Does OTR document exist ?
        IF response_option_page-header IS NOT INITIAL.
          CALL METHOD me->read_otr_document
            EXPORTING
              guid               = response_option_page-header
            IMPORTING
              document           = lv_document
            EXCEPTIONS
              document_not_found = 1.
          IF sy-subrc <> 0.
            RAISE invalid_parameter.
          ENDIF.
        ENDIF.

        IF response_option_page-body IS NOT INITIAL.
          CALL METHOD me->read_otr_document
            EXPORTING
              guid               = response_option_page-body
            IMPORTING
              document           = lv_document
            EXCEPTIONS
              document_not_found = 1.
          IF sy-subrc <> 0.
            RAISE invalid_parameter.
          ENDIF.
        ENDIF.

        CALL 'ICF_DISPATCH' ID 'HTTP'  FIELD 'R'
               ID 'LastPageHeaderGUID' FIELD response_option_page-header
               ID 'LastPageBodyGUID'   FIELD response_option_page-body.
      ENDIF.
* Register the logoff page for a possible call of SEND_PAGE
      CLEAR m_last_page-kind.
      m_last_page-header = response_option_page-header.
      m_last_page-body   = response_option_page-body.

    ELSEIF response_option = co_response_redirect_option.
* Registration of redirect URL
      IF response_option_redirect_url-url IS INITIAL OR
         ( response_option_redirect_url-status <> co_redirect_status_301 AND
           response_option_redirect_url-status <> co_redirect_status_302 AND
           response_option_redirect_url-status <> co_redirect_status_302_or_307 ).
        RAISE invalid_parameter.
      ELSE.
        CALL 'ICF_DISPATCH' ID 'HTTP'  FIELD 'R'
          ID 'LastPageRedirect'        FIELD response_option_redirect_url-url
          ID 'LastPageRedirectStatus'  FIELD response_option_redirect_url-status.

* Register the logoff page for a possible call of SEND_PAGE
        m_last_page-kind = 'X'.
        m_last_page-redirect      = response_option_redirect_url-url.
        m_last_page-redirect_code = response_option_redirect_url-status.
      ENDIF.
    ELSE.
      RAISE invalid_parameter.
    ENDIF.
  ELSE.
    RAISE invalid_parameter.
  ENDIF.

ENDMETHOD.


METHOD if_http_server~validate_xsrf_token.
*------------------------------------------------------------------------------------
*  This method is in the responsibility of the Security Development team.
*  Use message component BC-SEC-LGN to report problems.
*  Author:   D021767
*  Date:     2011-04-27
*------------------------------------------------------------------------------------

  DATA: lv_xsrf_token            TYPE string.
  DATA: lv_security_context      TYPE security_context.
  DATA: lv_session_access_token  TYPE string.                       "note 1658516
  DATA: lv_registry_entry        TYPE gt_session_access_reg_entry.  "note 1658516

* First check the precondition: session has to be personalized (no public services allowed)
  IF  c_authenticated <> 1 OR
    ( c_authenticated = 1 AND authentication_method = authmethod_service ).
    RAISE called_by_public_service.
  ENDIF.

* If the application has not provided the token, we'll scan the http request for it (field with fixed name)
  IF token IS INITIAL.
    lv_xsrf_token = request->get_form_field( name = if_http_form_fields_sap=>sap_xsrf ).
  ELSE.
    lv_xsrf_token = token.
  ENDIF.
  IF lv_xsrf_token IS INITIAL.
    CALL METHOD protocol_xsrf_detection.
    RAISE token_not_found.
  ENDIF.

* Try to retrieve the XSRF token from the Security Context (if exists)
  IF m_xsrf_token_from_sec_context IS INITIAL. "might be empty (performance optimization)
    TRY.
        lv_security_context = cl_http_security_session_admin=>get_current_session_context( ).
        m_xsrf_token_from_sec_context = lv_security_context-xsrf_token. "might still be empty
      CATCH cx_http_security_session_admin .
    ENDTRY.
  ENDIF.
  IF m_xsrf_token_from_sec_context IS NOT INITIAL.
* Compare received token with token found in the Security Context
    successful = boolc( m_xsrf_token_from_sec_context = lv_xsrf_token ).
    IF successful = abap_false.
      CALL METHOD protocol_xsrf_detection.
    ENDIF.
    RETURN. "that's all
  ENDIF.
* ------- The following actions are only required if system runs w/o activated Security Session Management -------

* If Security Context does NOT contain a token (for comparison), we have to retrieve it from the XSRF cookie
  TYPES: BEGIN OF cookie_struct,
           token         TYPE security_context_xsrf_token,  "24 characters (128 bit, base64)
           timestamp     TYPE tzntimestp,                   "14 characters (YYYYMMDDhhmmss)
           hmac_sha2(44) TYPE c,                        "44 characters (256 bit, base64)
         END OF cookie_struct.
  DATA: lv_cookie_struct TYPE cookie_struct.  "in total: 82 characters
  DATA: lv_hmac_feed    TYPE string,
        lv_hmac_result  TYPE hash512_base_64,
        lv_current_time TYPE timestamp.

  m_xsrf_cookie_value = get_xsrf_cookie( ).
  IF m_xsrf_cookie_value IS INITIAL.
    IF m_xsrf_token_copy IS INITIAL.
      CALL METHOD protocol_xsrf_detection.
      RAISE cookie_not_found.
    ELSE.
*   Note 1658516: if a valid session access token was provided with the same request,
*                 then a copy of the XSRF token is retrieved from the task memory
*   (requirement: GET_XSRF_TOKEN was called prior to ENABLE_FOREIGN_SESSION_ACCESS)
      lv_session_access_token = request->get_form_field( name = if_http_form_fields_sap=>sap_session_access_token ).
      IF lv_session_access_token IS INITIAL.
        CALL METHOD protocol_xsrf_detection.
        RAISE cookie_not_found.
      ENDIF.

*   Notice: it is sufficient to ensure that the received session access token belongs
*           to this server context because the path contraint check was performed before
*           (in method REAUTHENTICATION_ACCESS_TOKEN)
      CALL METHOD get_session_access_reg_entry
        EXPORTING
          session_access_token           = lv_session_access_token
        IMPORTING
          registry_entry                 = lv_registry_entry
        EXCEPTIONS
          session_access_token_not_found = 1.
      IF sy-subrc <> 0.
        CALL METHOD protocol_xsrf_detection.
        RAISE cookie_not_found.
      ENDIF.

      successful = boolc( m_xsrf_token_copy = lv_xsrf_token ).
      IF successful = abap_false.
        CALL METHOD protocol_xsrf_detection.
      ENDIF.
      RETURN. "that's all
    ENDIF.
  ENDIF.

* parse cookie:  <token> <timestamp> <hmac>
  lv_cookie_struct = m_xsrf_cookie_value.

* calculate HMAC value for comparison
  CONCATENATE lv_xsrf_token lv_cookie_struct-timestamp sy-uname INTO lv_hmac_feed.

  CALL FUNCTION 'CALCULATE_HMAC_FOR_CHAR'
    EXPORTING
      alg                          = 'SHA2'
      data                         = lv_hmac_feed
*     LENGTH                       = 0
*     CLIENT_INDEPENDENT           =
*     RECORD_NUMBER                = '00'
*     KEY_MUST_EXIST               = ' '
    IMPORTING
*     HMAC                         =
*     HMACLEN                      =
*     HMACX                        =
*     HMACXLEN                     =
      hmacbase64                   = lv_hmac_result  "ALPHABET_UC_BASE64
*     HMACBASE64LEN                =
    EXCEPTIONS
      unknown_alg                  = 1
      param_length_error           = 2
      internal_error               = 3
      malloc_error                 = 4
      abap_caller_error            = 5
      base64_error                 = 6
      calc_hmac_error              = 7
      rsec_record_not_found        = 8
      rsec_record_access_denied    = 9
      rsec_secstore_access_denied  = 10
      rsec_error                   = 11
      param_missing                = 12
      rng_error                    = 13
      record_number_error          = 14
      rsec_system_data_changed     = 15
      rsec_system_data_changed_sid = 16
      enqueue_set_failed           = 17
      enqueue_release_failed       = 18
      enqueue_internal_error       = 19
      OTHERS                       = 20.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
      RAISING internal_error.
  ENDIF.

  TRANSLATE lv_hmac_result USING '+-/_'. "ALPHABET_UC_BASE64URL
* HMAC value has to be identical ("same user" constraint)
  IF lv_cookie_struct-hmac_sha2 <> lv_hmac_result.
    CALL METHOD protocol_xsrf_detection.
    successful = abap_false.
    RETURN.
  ENDIF.

* Time constraint check
  DATA: lv_created  TYPE timestamp,
        lv_timediff TYPE tzntstmpl.
  lv_created = lv_cookie_struct-timestamp.
  GET TIME STAMP FIELD lv_current_time.
  TRY.
      CALL METHOD cl_abap_tstmp=>subtract
        EXPORTING
          tstmp1 = lv_current_time
          tstmp2 = lv_created
        RECEIVING
          r_secs = lv_timediff.
    CATCH cx_parameter_invalid_range .
    CATCH cx_parameter_invalid_type .
  ENDTRY.

  successful = boolc( lv_timediff < 86400 ). "24h = 86400s
  IF successful = abap_false.
    CALL METHOD protocol_xsrf_detection.
  ENDIF.

ENDMETHOD.


METHOD is_sso2_ticket_available.

  DATA: l_header_sso_available   TYPE abap_bool.
  DATA: l_rfcsi                  TYPE rfcsi.
* -- does my server belongs to rejected list ?
  DATA: l_hash160                TYPE hash160.
  DATA: l_error_text             TYPE c LENGTH 100,
        l_mysapsso2_available    TYPE n VALUE 1, "l_mysapsso2 = 1 means mysapsso2 is available
        l_do_not_use_sso2_ticket TYPE n LENGTH 1.

*  is sso2 ticket avaliable ?
  CLEAR sso_import.
  CALL METHOD server->request->get_cookie
    EXPORTING
      name  = 'MYSAPSSO2'
    IMPORTING
      value = sso_import.

* -- logon via SSO header failed
  l_header_sso_available = abap_false.
  IF sso_import IS INITIAL.
    sso_import = request->get_header_field( name = 'MYSAPSSO2' ). "#EC NOTEXT
    IF NOT sso_import IS INITIAL. " mark that the sso2 ticket is taken from header filed. It is relevant for logon_method AUTH_ASSERT
      l_header_sso_available = abap_true.
    ENDIF.
  ENDIF.

* -- by executing of sso tickets, which has been deleted by ICT
* -- there will be a ticket with large amount of spaces
* -- in this case ticket has to be concidered as not available
* -- otherwise this leads to a core dump in logon procedure
  IF NOT sso_import IS INITIAL.
    SHIFT sso_import LEFT DELETING LEADING space.
  ENDIF.

* -- is sso2 acceptable ?
* since 710 the order of logon by client certificate has been changed. A logon via client certificate
* will be initiated before basic authentication. This changed behaviour would lead to looping of
* basci authentication popups, if a logon with a certificate failes. Therefore as a fall bach the ssoreject
* list has to be extended to overcome this issue.

* determination of ssolist, if available
  IF NOT sso_import IS INITIAL OR c_certificate_available = 1.
    CALL METHOD server->request->get_cookie
      EXPORTING
        name  = co_ssolist
      IMPORTING
        value = ssolist_b64.

    IF NOT ssolist_b64 IS INITIAL.
* my instance id
      ssolist = decode_base64( ssolist_b64 ).

      IF NOT c_instance_id IS INITIAL.
        myserver = c_instance_id.
      ELSE.
        CALL FUNCTION 'RFC_SYSTEM_INFO'
          IMPORTING
            rfcsi_export          = l_rfcsi
          EXCEPTIONS
            communication_failure = 1
            system_failure        = 2
            OTHERS                = 3.
        IF sy-subrc = 0.
          myserver = l_rfcsi-rfcdest.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

* check the content of ssolist for rejected MYSAPSSO2
  IF NOT sso_import IS INITIAL.
*       icf_trc 'Authentication: SSO2 is available'. "EC_NOTEXT
    c_mysapsso2_available = 1.
    CONCATENATE m_recorder_failed_logon-tickets
    ihttp_recorder_sso_ticket
    INTO m_recorder_failed_logon-tickets.

    IF NOT ssolist IS INITIAL.

      CONCATENATE co_ssotoken_reject
      myserver '_' c_client INTO server_token.
* -- first cheap test: does ssolist contains this instance ?
      IF ssolist CS server_token.
*   -- create SSO2 hash value
        CALL FUNCTION 'CALCULATE_HASH_FOR_CHAR'
          EXPORTING
            alg            = 'SHA1'
            data           = sso_import
          IMPORTING
            hash           = l_hash160
          EXCEPTIONS
            unknown_alg    = 1
            param_error    = 2
            internal_error = 3
            OTHERS         = 4.
        IF sy-subrc <> 0.
*   -- check entry without hash value
          CLEAR l_hash160.
        ENDIF.

* -- client and hash value depenedent reject list
        CONCATENATE server_token '_' l_hash160
        INTO server_token.
        IF ssolist CS server_token.
          l_do_not_use_sso2_ticket = do_not_use_sso2_ticket = 1.
* SAP Note 1876763
* failure handling
          CONCATENATE `Value of 'do_not_use_sso2_ticket': ` l_do_not_use_sso2_ticket INTO l_error_text. "#EC NOTEXT
          CALL METHOD cl_http_server=>trace
            EXPORTING
              line = l_error_text.
*          MESSAGE s101(shttp) WITH `Value of 'do_not_use_sso2_ticket': ` do_not_use_sso2_ticket. "#EC NOTEXT
          CLEAR sso_import.
          CONCATENATE m_recorder_failed_logon-tickets ihttp_recorder_ssorej_ticket INTO m_recorder_failed_logon-tickets.
* SAP Note 1876763
* failure handling
          CONCATENATE `(SSO Reject List); Logon Tickets: ` m_recorder_failed_logon-tickets INTO l_error_text. "#EC NOTEXT
          CALL METHOD cl_http_server=>trace
            EXPORTING
              line = l_error_text.
*          MESSAGE s101(shttp) WITH `(SSO Reject List); Logon Tickets: ` m_recorder_failed_logon-tickets. "#EC NOTEXT
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.
* SAP Note 1876763
    l_mysapsso2_available = c_mysapsso2_available = 0.
    CONCATENATE `Value of MYSAPSSO2 Availibility: ` l_mysapsso2_available INTO l_error_text. "#EC NOTEXT
* failure handling
    CALL METHOD cl_http_server=>trace
      EXPORTING
        line = l_error_text.
*    MESSAGE s101(shttp) WITH `Value of MYSAPSSO2 Availibility: ` c_mysapsso2_available.  "#EC NOTEXT
  ENDIF.

  header_sso_available = l_header_sso_available.

ENDMETHOD.


METHOD logon_trace .
  DATA: method_c TYPE string.
  DATA: l_trace  TYPE string.

  CASE method.
    WHEN authmethod_basic.
      method_c = 'AUTHMETHOD_BASIC'.                        "#EC NOTEXT
    WHEN authmethod_sso.
      method_c = 'AUTHMETHOD_SSO'.                          "#EC NOTEXT
    WHEN authmethod_sap.
      method_c = 'AUTHMETHOD_SAP'.                          "#EC NOTEXT
    WHEN authmethod_service.
      method_c = 'AUTHMETHOD_SERVICE'.                      "#EC NOTEXT
    WHEN authmethod_field.
      method_c = 'AUTHMETHOD_FIELD'.                        "#EC NOTEXT
    WHEN authmethod_certificate.
      method_c = 'AUTHMETHOD_CERTIFICATE'.                  "#EC NOTEXT
    WHEN authmethod_saml.
      method_c = 'AUTHMETHOD_SAML'.                         "#EC NOTEXT
    WHEN authmethod_assertion.
      method_c = 'AUTHMETHOD_ASSERTION'.                    "#EC NOTEXT
    WHEN authmethod_security_session.
      method_c = 'AUTHMETHOD_SECURITY_SESSION'.             "#EC NOTEXT
    WHEN OTHERS.
      method_c = 'AUTHMETHOD_NONE'.                         "#EC NOTEXT
  ENDCASE.

*   if c_sap_trace > 1.
*     concatenate  method_c ','
*                 'U:' user ','
*                 'C:' client ','
*                 'L:' langu ','
*                 into trace separated by space.
*     message e000(sr) with trace.
*   endif.

  IF c_authenticated = 0.
    CONCATENATE trace
               '<BR><b>User    :</b>' c_user                "#EC NOTEXT
               '<BR><b>Client  :</b>' c_client              "#EC NOTEXT
               '<BR><b>Language:</b>' c_langu               "#EC NOTEXT
               '<BR><b>Subrc   :</b>' subrc                 "#EC NOTEXT
               '<BR><b>Saprc   :</b>' saprc                 "#EC NOTEXT
               INTO trace  SEPARATED BY space.

    CONCATENATE trace '<BR><b>Method:  </b>'                "#EC NOTEXT
                 method_c INTO trace SEPARATED BY space.

    IF ssl_active = co_enabled.
      CONCATENATE  trace  '<BR><b>SSL: </b> Yes'            "#EC NOTEXT
                   INTO trace SEPARATED BY space.
    ELSE.
      CONCATENATE  trace  '<BR><b>SSL: </b> No'             "#EC NOTEXT
                   INTO trace SEPARATED BY space.
    ENDIF.

    IF pooled_session = co_enabled.
      CONCATENATE  trace '<BR><b> Pooled session: </b> Yes' "#EC NOTEXT
                   INTO trace SEPARATED BY space.
    ELSE.
      CONCATENATE  trace '<BR><b> Pooled session: </b> No'  "#EC NOTEXT
                   INTO trace SEPARATED BY space.
    ENDIF.

    method_c = request->get_header_field( '~path_translated' ).
    CONCATENATE trace '<BR><b>Path translated: </b>'        "#EC NOTEXT
                    method_c INTO trace SEPARATED BY space.

  ELSEIF c_sap_trace >= 1.
    CONCATENATE trace
              'User :' c_user                               "#EC NOTEXT
              'Client :' c_client                           "#EC NOTEXT
              'Language:' c_langu                           "#EC NOTEXT
              'Subrc   :' subrc                             "#EC NOTEXT
              'Saprc   :' saprc                             "#EC NOTEXT
              INTO l_trace  SEPARATED BY space.             "#EC NOTEXT

    CONCATENATE l_trace 'Method: '                          "#EC NOTEXT
                 method_c INTO l_trace SEPARATED BY space.

    IF ssl_active = co_enabled.
      CONCATENATE  l_trace  'SSL: Yes'                      "#EC NOTEXT
                   INTO l_trace SEPARATED BY space.
    ELSE.
      CONCATENATE  l_trace  'SSL: No'                       "#EC NOTEXT
                   INTO l_trace SEPARATED BY space.
    ENDIF.

    IF pooled_session = co_enabled.
      CONCATENATE  l_trace 'Pooled session: Yes'            "#EC NOTEXT
                   INTO l_trace SEPARATED BY space.
    ELSE.
      CONCATENATE  l_trace 'Pooled session: No'             "#EC NOTEXT
                   INTO l_trace SEPARATED BY space.
    ENDIF.

    CALL METHOD request->set_header_field
      EXPORTING
        name  = 'SAP-Logon-Trace' "#EC NOTEXT
        value = l_trace.
  ENDIF.

ENDMETHOD.


METHOD prepare_otr_document.
  DATA: l_dummy       TYPE string,
        l_code        TYPE i.
  DATA: redirect      TYPE string.
  DATA: use_https     TYPE abap_bool VALUE abap_false.

  IF service-kind401 IS INITIAL AND
     ( NOT service-hdrotr401 IS INITIAL OR
       NOT service-bodotr401 IS INITIAL ).
*-- read OTR body template
    IF NOT service-bodotr401 IS INITIAL.
      DATA: o_body TYPE string.
      CALL METHOD read_otr_document
        EXPORTING
          guid               = service-bodotr401
        IMPORTING
          document           = o_body
        EXCEPTIONS
          document_not_found = 1
          OTHERS             = 2.
      IF sy-subrc = 0.
*-- trace
        IF c_sap_trace >= 1.
          CONCATENATE my_trace
               '<BR><B>OTR Header: </B>'                    "#EC NOTEXT
               service-bodotr401 INTO my_trace.
        ENDIF.

*-- replace tokens
        CALL METHOD replace_logon_token
          EXPORTING
            server = server
          CHANGING
            data   = o_body.
        CALL METHOD server->response->set_cdata( data = o_body ).
*-- OTR document sent
        otr_document_sent = 1.
      ENDIF.
    ENDIF.

    IF NOT service-hdrotr401 IS INITIAL.
      DATA: o_header TYPE string.
*-- set header fields defined in OTR documents

      CALL METHOD read_otr_document
        EXPORTING
          guid               = service-hdrotr401
        IMPORTING
          document           = o_header
        EXCEPTIONS
          document_not_found = 1
          OTHERS             = 2.
      IF sy-subrc = 0.
        DATA: itab     TYPE TABLE OF string,
              l_name   TYPE string,
              l_value  TYPE string,
              l_header TYPE string.
        REPLACE ALL OCCURRENCES OF '<NO_TRANSLATION>'
                         IN o_header WITH space.
        REPLACE ALL OCCURRENCES OF '</NO_TRANSLATION>'
                         IN o_header WITH space.
        SPLIT o_header AT '</HEADER>' INTO TABLE itab.
*-- trace
        IF c_sap_trace >= 1.
          CONCATENATE my_trace '<BR><B>OTR Header: </B>'    "#EC NOTEXT
              service-hdrotr401 INTO my_trace.
        ENDIF.

        LOOP AT itab INTO l_header.
          IF l_header CS ':'.
            REPLACE '<HEADER>'  IN l_header WITH space.
            REPLACE '</HEADER>' IN l_header WITH space.
            SPLIT l_header AT ':' INTO l_name l_value.

* -- removing of generated spaces
            SHIFT l_name  LEFT  DELETING LEADING space.
            SHIFT l_value RIGHT DELETING TRAILING space.

*-- evaluation of <%=HEADER_...%> field as name part
            IF l_value CS '<%=HEADER_'.
              SPLIT l_value AT '<%=HEADER_' INTO l_header l_value.
              SPLIT l_value AT '%>' INTO l_value l_header.
              l_header = server->request->get_header_field(
                                                     l_value ).
*              concatenate l_value ':' l_header into l_value.
              l_value = l_header.
            ENDIF.

*-- evaluation of <%=STATUS_...%> field as name part
            IF l_name CS '<%=STATUS_'.
              SPLIT l_name AT '<%=STATUS_'  INTO l_name l_dummy.
              SPLIT l_dummy AT '%>'         INTO l_name l_dummy.
              l_code = l_name.
              CALL METHOD server->response->set_status(
                  code   = l_code
                  reason = l_value ).                     "#EC NOTEXT
*-- OTR document sent
              otr_document_sent = 1.
            ELSE.
*-- set header field in both cases, <%=HEADER and native version
              server->response->set_header_field( name  = l_name
                                                  value = l_value ).

            ENDIF.
*-- trace
            IF c_sap_trace >= 1.
              CONCATENATE my_trace
                           '<BR><B>Name: </B>' l_name       "#EC NOTEXT
                           ', <B>value: </B>' l_value       "#EC NOTEXT
                            INTO my_trace.
            ENDIF.

          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ELSEIF service-kind401 = 'X' AND
         NOT service-url401 IS INITIAL.
*-- redirect

    redirect = service-url401.
*-- replace tokens and append form fields, if necessary
    CALL METHOD replace_logon_token
      EXPORTING
        server          = server
        set_ffield_name = service-formflg401
      CHANGING
        data            = redirect.

    IF service-httpcde401 = 1.
* -- 301 Moved permantently (HTTP1/1)
      CALL METHOD server->response->redirect
        EXPORTING
          url                = redirect
          permanently        = 1
          explanation        = 'Moved permantently'         "#EC NOTEXT
          protocol_dependent = 0.
    ELSEIF service-httpcde401 = 2.
* -- 302 Temporary Redirect (HTTP1/0)
* -- 307 Temporary Redirect (HTTP1/1)
      DATA: explanation TYPE string.
      DATA: c_server    TYPE REF TO cl_http_server.
      c_server ?= server.
      IF c_server->m_protocol_version = 'HTTP/1.0'.
        explanation = 'Moved temporarily'.                  "#EC NOTEXT
      ELSE.
        explanation = 'Temporary Redirect'.                 "#EC NOTEXT
      ENDIF.

      CALL METHOD server->response->redirect
        EXPORTING
          url                = redirect
          explanation        = explanation
          protocol_dependent = 1.
    ELSE."Default: = 0 or initial
* -- 302 Temporary Redirect (HTTP1/0)
      CALL METHOD server->response->redirect
        EXPORTING
          url                = redirect
          explanation        = 'Moved temporarily'          "#EC NOTEXT
          protocol_dependent = 0.
    ENDIF.
*-- OTR document sent
    otr_document_sent = 1.
  ELSEIF service-syslog401       = 'X'.
    DATA: system_login_is_supported TYPE c.
*
* disable system login by deactivation of basic authentication and
* form fields logon
*
* -- determination of logon order
    IF service-logorder IS NOT INITIAL  AND
      service-logorder NS 'AUTH_BASIC' AND
      service-logorder NS 'AUTH_FIELD'.
      system_login_is_supported = 'X'.
    ENDIF.

    IF system_login_is_supported IS INITIAL.
      DATA: l_configuration TYPE string.
      DATA: server_obj TYPE REF TO cl_http_server.

      server_obj ?= server.
*    -- Systemanmeldung
* -- load system logon configuration, if available
*      if service-syslogin = 'Y'.
      CALL METHOD server_obj->get_service_extension
        EXPORTING
          kind                    = ihttp_icfservice_extension_bsp
        IMPORTING
          configuration           = l_configuration
        EXCEPTIONS
          kind_is_not_supported   = 1
          error_during_processing = 2
          OTHERS                  = 3.
      IF sy-subrc <> 0.
        MESSAGE s000(sr) WITH
           'Fehler bei der Systemanmeldung-Konfiguration.'(h02).
      ENDIF.
*      endif.

* is Webgui (/sap/bc/gui/sap/its/webgui) service active ?
* in that case ICFX uses stateful session with URL-rewriting when
* form-field based authentication is maintained
* furthermore no SSO ticket should be set in response
* Supplement (26.04.2007/20.05.2007): This feature should be available/provided to all
*                          ITS services. This is GUI link is active and ITS handler is in place

*     Is SSL set to mandatory for the service
      IF service-protsec = 'S'.
        use_https = abap_true.
      ENDIF.

* XSRF logon tokens (form field and cookie has to be set prior to system logon)
      DATA: lv_xsrf_formfield TYPE string,
            lv_xsrf_cookie    TYPE string.
      DATA: lv_login_xsrf_id  TYPE string.

      DATA: lv_onlyhttps TYPE c LENGTH 4,
            lv_secure    TYPE i,
            lv_subrc     TYPE sysubrc.

      DATA: lv_xsrf_active    TYPE abap_bool.

      lv_xsrf_active = cl_icf_system_login=>is_xsrf_logon_active( login_configuration = l_configuration ).

* XSRF logon check only and only if the XSRF logon option is active in system logon configuration
      IF lv_xsrf_active = abap_true.
        CALL METHOD create_login_xsrf_token
          IMPORTING
            cookie_value    = lv_xsrf_cookie
            formfield_value = lv_xsrf_formfield
          EXCEPTIONS
            internal_error  = 1
            secstore_error  = 2
            OTHERS          = 3.

        IF sy-subrc <> 0 OR lv_xsrf_cookie IS INITIAL OR lv_xsrf_formfield IS INITIAL.
          MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.

        CALL 'C_SAPGPARAM'
            ID 'NAME' FIELD 'login/ticket_only_by_https'
            ID 'VALUE' FIELD lv_onlyhttps.
        lv_subrc = sy-subrc.

* per default set HTTPonly flag for XSRF logon cookie
        IF lv_subrc = 0 AND lv_onlyhttps = '1'.
          lv_secure = 17.
        ELSE.
          lv_secure = 16.
        ENDIF.

* Remark: As several SAP systems could be run on the same hostz therefore XSRF cookie has to contain at least system id
* to avoid ambiguities. The cookie is set for the host.
        CONCATENATE if_http_form_fields_sap=>sap_login_xsrf '_ ' sy-sysid INTO lv_login_xsrf_id.
* Remark: use never ~path_translated for cookie since the ;-fields are filtered out of the ~path and this lead that the
* IE do not resend the XSRF-Logon cookie for the path (this issue is observed in Business Client) !

        CALL METHOD server->response->set_cookie
          EXPORTING
            name   = lv_login_xsrf_id
            value  = lv_xsrf_cookie
            "See SAP Note 1934153
            path   = '/'
*           path   = server->request->get_header_field( '~path' )
            secure = lv_secure.
      ENDIF.

      CALL METHOD cl_icf_system_login=>on_icf_call
        EXPORTING
          ii_server                = server
          iv_login_methods         = logon_order
          is_alias                 = service-aliaslogin
          accessibility            = service-accessibility
          mandatory_service_client = service-oblmandt
          service_client           = service-icf_mandt
          mandatory_service_langu  = service-obllangu
          service_langu            = service-icf_langu
          mandatory_ssl            = use_https
          configuration            = l_configuration
          webgui                   = webgui      "activation after ICFX import from B20
          xsrf_field_value         = lv_xsrf_formfield.
*          security_session_created = abap_false.
*         iv_force_login        = force_login.

*    -- OTR document sent
      otr_document_sent = 1.
    ENDIF.

  ENDIF.

ENDMETHOD.


METHOD proceed_logoff.
*  DATA: l_sec_error TYPE REF TO cx_http_security_session.
* 1 ) set to stateless
* 2) call terminate method from security with the original security session cookie
* 4) dete MYSAPSSO2 cookie, if required
* b) if not portal context ( DSM )  -> delete Cookie (skiped)
* Do I run in portal or business client ?
* request->get_form_field( name = if_http_form_fields_sap=>sap_ep_version ) is not initial.
* request->get_form_field( name = cl_wdr_client_constants=>client_nwbc ) is not initial.
*



*
* send logoff page
*
* Send last page and change the session state to stateless
  IF m_logoff > 0.
*
* Use m_send_page_is_called for coordination of SEND_PAGE (to send an OTR last page) with LOGOFF
* method. That meansif LOGOFF is called before the method SEND_PAGE so transfer the OTR last
* page instead of application response page
*

*
* Remark: m_send_page_is_called is used to indicate whether application has triggered send_page to
* sned a last page or want to send it's own response, e.g. html page whith logoff action
*
* In other words, if m_send_page_is_called  = abap_true means therefore SEND_PAGE method
* is already executed and withhin this method following steps/actions has been taken:
* - set session to stateless and delete the stateful cookies at client via
*   set_session_stateful( stateful = co_disabled ).
* - send last page either as default logoff (OTR: '001560AA0E0802DCA99465E2B20B08AB') page as it
*   is set in logoff method, or as this set by application as application specefic
*   last page via method SET_PAGE and this as OTR page or redirect URL
*
    IF  m_send_page_is_called  = abap_false.
*
*  set session to stateless
*
      IF stateful = if_http_server~co_enabled.
        CALL 'ICF_DISPATCH' ID 'HTTP'        FIELD 'K'
                            ID 'KeepContext' FIELD 'N'.
        set_session_stateful( stateful = co_disabled ).
      ENDIF.

    ELSE.
* When the logpff has been taken place via SEND_PAGE methode as this is with
* GET /sap/public/bc/icf/logoff avoid any browser caching the page. Since in that case any subsequent
* GET /sap/public/bc/icf/logoff is handled internally by brwoser cache and no explicit logoff
* (mistakenly) take place.
      set_no_cache( ).
    ENDIF.
  ENDIF.

* Remark: security session termination is done immediately in IF_HTTP_SERVER~LOGOFF
*
*    IF m_security_session_cookie IS NOT INITIAL.
*      TRY.
*          CALL METHOD cl_http_security_session_icf=>terminate_security_session
*            EXPORTING
*              session_id = m_security_session_cookie
*              client     = c_client
*              server     = me.
*        CATCH cx_http_security_session INTO l_sec_error.
*          IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
*            MESSAGE e000(sr) WITH 'Abbau der Security Session mi√ülungen (Intern)!'(lg1).
*          ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
*            MESSAGE e000(sr) WITH 'Abbau der Security Session mi√ülungen (Program)!'(lg2).
*          ENDIF.
*      ENDTRY.
*    ENDIF.
*
* Remark: Delete cookies after refresh_response() method, i.e. to ensure the setting on the same
* response object !
*


* remove user context information (sap-usercontext cookie) at client
  cl_http_user_context=>remove( response = response ).

  delete_security_session_cookie( ).

  delete_xsrf_cookie( ).
*
* delete MYSAPSSO2 and SAP-SSOLIST, if required
*
  IF m_logoff = 2 AND
     c_mysapsso2_available > 0.
    delete_sso_cookie_at_client( ).
  ENDIF.

* delete 'SPNego was requested' cookie (no longer required)
  CALL METHOD response->delete_cookie_at_client
    EXPORTING
      name = co_spnego_requested_cookie
      path = '/'.

ENDMETHOD.


  method PROTOCOL_XSRF_DETECTION.
    DATA: remote_addr type string,
          path        type string,
          var_data    type string,
          len         type i.

    remote_addr = request->get_header_field( '~remote_addr' ). "#EC NOTEXT
    path        = request->get_header_field( '~path' ).        "#EC NOTEXT

    CONCATENATE path '&' remote_addr INTO var_data.
    len = strlen( var_data ).
    IF len > 2044. "max len allowed for audit event is 2048
      len = len - 2044 + 3.
      CONCATENATE '...' var_data+len INTO var_data.
    ENDIF.
    CONCATENATE 'URL ' var_data INTO var_data RESPECTING BLANKS.

    TRY.
      CALL METHOD CL_SAL_SHM_ACCESS=>_CREATE_AUDIT_EVENTEX
        EXPORTING
          I_EVENT     = 'BUS'
          I_VARSTRING = var_data.
    CATCH CX_ROOT.
      "in case of error write with old method
      DATA: l_data type char64,
            l_key  type char3 value 'BUS'.

      CONCATENATE path '&' remote_addr INTO var_data.
      len = strlen( var_data ).
      IF len > 60. "max len allowed for old write method is 64
        len = len - 60 + 3.
        CONCATENATE '...' var_data+len INTO l_data.
      ELSE.
        l_data = var_data.
      ENDIF.
      CONCATENATE 'URL ' l_data INTO l_data RESPECTING BLANKS.

      CALL 'AUDIT_WRITE_ENTRY'     "EC CI_CALL
           ID 'TYP'  FIELD 'q'
           ID 'KEY'  FIELD l_key
           ID 'DATA' FIELD l_data.
    ENDTRY.
  endmethod.


METHOD raise_event.
* -- raise IF_HTTP_SERVER~EVENTKIND_HANDLE_TIMEOUT
* -- in FM 'HTTP_DISPATCH_EVENT'

**************************************************************************
* ABAP correction in SAP Note 1837014

  DATA: lr_tx_manager      TYPE REF TO if_os_transaction_manager,
        lr_tx              TYPE REF TO if_os_transaction.
  DATA: l_external_commit TYPE os_boolean.

* Perform "UNDO" for existing transaction objects
* before do explicit rollback
  lr_tx_manager = cl_os_system=>get_transaction_manager( ).
  IF lr_tx_manager IS BOUND.
    lr_tx = lr_tx_manager->get_top_transaction( ).
    "Recursive undo will be done
    IF lr_tx IS BOUND.
      lr_tx->get_modes( IMPORTING e_external_commit = l_external_commit ).
      IF l_external_commit = abap_false.
        lr_tx->undo( ).
      ENDIF.
    ENDIF.
  ENDIF.

* -- processing of explicit rollback before execution of event handler
  ROLLBACK WORK.

***** End of Correction in SAP Note 1837014******************************

* An event handling is only available for stateful communication
  IF stateful = if_http_server=>co_enabled.
    IF reason = co_communication_error_send    OR
       reason = co_communication_error_receive OR
       reason = co_session_timeout             OR
       reason = co_page_processing_failed.

      RAISE EVENT eventkind_context_termination
            EXPORTING reason     = reason
                      error_info = m_connection_error.

* --
* processing of explicit/implicit commit after execution
* of event handler and depending on transactional context
* --
      IF transactional = if_http_server=>co_enabled.
        COMMIT WORK.
      ELSE.
        CALL FUNCTION 'DB_COMMIT'.
      ENDIF.

    ENDIF.
  ENDIF.
* --
* set session to stateless for releasing session in
* HTTP_DISPATCH_REQUEST (only in case of network communication)
* --
  IF m_server_type = co_servertype_net.
* some traces for kernel
    MESSAGE s000(sr) WITH 'HTTP> Release context in RAISE_EVENT'. "#EC NOTEXT
    CALL 'ICF_DISPATCH' ID 'HTTP'        FIELD 'K'
                        ID 'KeepContext' FIELD 'N'.
  ENDIF.

*** FinalizeExt method is only relevant for network  of
*** communication version frame work, and not for local calls
*** this method does not return any more
***
**    system-call plugin
**             id 'HTTP' value 'FinalizeExt'. "#EC NOTEXT
ENDMETHOD.


METHOD read_otr_document .
  DATA: lv_sysubrc TYPE sy-subrc.
* -- OTR template
  IF NOT guid IS INITIAL.
*-- set body defined in OTR documents
    SYSTEM-CALL OTR GET_STRING_BY_GUID
      LANGUAGE c_langu ID guid
      TEXT INTO document.
    lv_sysubrc  = sy-subrc.
*-- 2end trial with sy-langu
    IF lv_sysubrc <> 0 AND c_langu <> sy-langu.
      SYSTEM-CALL OTR GET_STRING_BY_GUID
        LANGUAGE sy-langu ID guid
        TEXT INTO document.
      lv_sysubrc  = sy-subrc.
    ENDIF.
*-- 3rd trial with second langu
    IF lv_sysubrc <> 0.
      IF c_second_langu IS INITIAL.
        CALL 'C_SAPGPARAM'
         ID 'NAME'  FIELD 'zcsa/second_language'
         ID 'VALUE' FIELD c_second_langu.
      ENDIF.

      IF c_langu <> c_second_langu.
        SYSTEM-CALL OTR GET_STRING_BY_GUID
          LANGUAGE c_second_langu ID guid
          TEXT INTO document.
        lv_sysubrc  = sy-subrc.
      ENDIF.
    ENDIF.
    IF lv_sysubrc <> 0 AND document IS INITIAL.
      RAISE document_not_found.
    ENDIF.
  ELSE.
    RAISE document_not_found.
  ENDIF.

ENDMETHOD.


METHOD reauthentication.
*
* ESID: SecRes-243 - Session Fixation Vulnerability
*
* Assumption: ESID is always send in the following cases:
* - New session:
*   ESID without sap-context-id and without logon data => 401
*   ESID without sap-context-id and with invalid logon data => 401
*   ESID with sap-context-id => 40x response (error) code by ICMan
* - Existing (stateful) session:
*   ESID without sap-context-id and without logon data => 400
*   ESID without sap-context-id and with invalid logon data => 400
*   ESID without sap-context-id and with valid logon data for another
*               user account as the present one => 400
*   ESID with sap-context-id => ICMan dispatches the request to the associated session
*
* Note 1: ICMan handles all requests containing a sap-context-id, indepently
*         of the existence of an ESID in the request (i.e. requests with and without
*         ESID including sap-context-id)
*
* Note 2: The authentication check based only on user id and not client and user id
*         (refer to FB 'SUSR_CHECK_LOGON_DATA')
*

*
* Remark: A reauthentication for assetion ticket is not planned and supported, since
*        the assetion tickets are generally created and send at the connection set up phase
*        and not with subsequent calls
*
  INCLUDE: icftreetop.
  DATA: server_obj TYPE REF TO cl_http_server.
  DATA: subrc_c(4) TYPE c.

  DATA: subrc        TYPE sysubrc,
        saprc        TYPE sysubrc,
        l_subrc      TYPE sysubrc,
        authstring   TYPE string.

  DATA: basic_user           TYPE syuname,
        basic_passwd         TYPE xubcode.
  DATA: service_user         TYPE syuname,
        service_passwd       TYPE xubcode.
  DATA: field_user           TYPE syuname,
        field_passwd         TYPE xubcode.

  DATA: sso_import   TYPE string,
        r3_auth      TYPE string,
        logon_by_ff  TYPE i VALUE 0.
  DATA: alias TYPE bapialias.
  DATA: alias_trace TYPE string.                            "#EC NEEDED
* data: c_authentication_method_pool type i.
  CONSTANTS: alias_userid_get TYPE x VALUE 3.

* -- logon by mandatory sevice
  DATA: logon_by_mservice  TYPE i VALUE 0.
  DATA: logon_order_table  TYPE TABLE OF string.
  DATA: logon_order        TYPE logorder.
  DATA: logon_method       TYPE icflogkey.

* -- evaluation of SSO2 cookie
  DATA: ssolist_b64 TYPE string,
        ssolist TYPE string.
  DATA: do_not_use_sso2_ticket TYPE i.                      "#EC NEEDED
  DATA: l_rfcsi TYPE rfcsi,
        myserver TYPE rfcdest.
* data: l_usrefus type usrefus.

*  data: l_offset       type i.
  DATA: l_hash160       TYPE hash160.
  DATA: no_basic_authentication TYPE i VALUE 0.             "#EC NEEDED
  DATA: l_saml_ticket   TYPE string.

* logon time for statistic
  DATA: stime           TYPE i,
        etime           TYPE i.

  DATA: l_x509_x TYPE xstring,
        l_x509_c TYPE string.

  DATA: l_authentication_method TYPE i VALUE if_http_server=>authmethod_none.
  DATA: l_username              TYPE xubname.
  DATA: l_reauth_rc             TYPE i.
*  DATA: l_public_service        TYPE abap_bool.             "#EC NEEDED
*  DATA: l_same_user_account     TYPE abap_bool.
  DATA: lv_expected_user_id                TYPE syuname.
  DATA: server_token TYPE string.
  DATA: username_str TYPE string,
        password_str TYPE string.
  DATA: do_not_use_c_certificate TYPE abap_bool VALUE abap_false.

*
* No reuathentication is necessary, in following cases:
*1) Profile prameter icf/user_recheck = 0
*2) Profile prameter icf/user_recheck = 1 but in the service contains the setting icf_reauth_off = 'Y'
*

*  IF c_user_recheck = 0 OR
*     c_user_recheck = 1 AND service-icf_reauth_off = 'Y'.
*    RETURN.
*  ENDIF.
*
** present user name
  IF expected_user_id IS INITIAL.
    lv_expected_user_id = cl_abap_syst=>get_user_name( ).
  ELSE.
    lv_expected_user_id = expected_user_id.
  ENDIF.

**
** determination of public services and de-facto public services, i.e. services with maintained logon user as
** "required with logon data"
**
*
* determination of public services
*
*  public_service = 0.
*  IF service-publicflag = 'X'.
*    public_service = 1.
*  ENDIF.

*-- use mandatory user and password fields,
*-- only if the user and password are maintained
  IF service-obluser IS NOT INITIAL AND service-oblpasswd IS NOT INITIAL.
    logon_by_mservice = 1.
  ENDIF.



* Initialization of the user check
  same_user_account  = abap_false.

  l_reauth_rc  = 0. "0 initial, -1 = errorneous, 1 = successful

  pf_m_open c_statistic_state 'A:Reauthenticate Inside'.      "#EC NOTEXT
* call method cl_http_server=>trace( 'Authentication' ).
  server_obj ?= server.

  CLEAR c_user.

*-------------------------------------------------------
*
* regular logon mechanism
*

* -- protocol logon procedure for recorder
  m_recorder_failed_logon-version = 0.



* prepare logon data, based on ICF service entries
  pf_m_open c_statistic_state 'A:Header Fields'.              "#EC NOTEXT

*
* determination of user and password
*
*-- use mandatory user and password fields,
  IF logon_by_mservice = 1.
    service_user   = service-obluser.
    service_passwd = service-oblpasswd.
    CONCATENATE m_recorder_failed_logon-user_method
                ihttp_recorder_user_oblig
                INTO m_recorder_failed_logon-user_method.

    CONCATENATE m_recorder_failed_logon-password_method
                ihttp_recorder_passwd_oblig
                INTO m_recorder_failed_logon-password_method.
  ENDIF.

* -- client certificate avaliable
  IF c_certificate_available = 1.
    CONCATENATE m_recorder_failed_logon-tickets
               ihttp_recorder_x509_ticket
               INTO m_recorder_failed_logon-tickets.
*     set bit ihttp_recorder_x509_ticket of
*             m_recorder_failed_logon-tickets.
  ENDIF.

* -- sso2 and saml ticket avaliable
  IF logon_by_mservice IS INITIAL.
    CLEAR sso_import.
    CALL METHOD server->request->get_cookie
      EXPORTING
        name  = 'MYSAPSSO2'
      IMPORTING
        value = sso_import.

* -- logon via SSO header feild
    IF sso_import IS INITIAL.
      sso_import =
        request->get_header_field( name = 'MYSAPSSO2' ).    "#EC NOTEXT
    ENDIF.

* -- by executing of sso tickets, which has been deleted by ICT
* -- there will be a ticket with large amount of spaces
* -- in this case ticket has to be concidered as not available
* -- otherwise this leads to a core dump in logon procedure
    IF NOT sso_import IS INITIAL.
      SHIFT sso_import LEFT DELETING LEADING space.
    ENDIF.

* -- is sso2 acceptable ?
    IF NOT sso_import IS INITIAL.
      c_mysapsso2_available = 1.
      CONCATENATE m_recorder_failed_logon-tickets
               ihttp_recorder_sso_ticket
               INTO m_recorder_failed_logon-tickets.
*       set bit ihttp_recorder_sso_ticket of
*                  m_recorder_failed_logon-tickets.

      CALL METHOD server->request->get_cookie
        EXPORTING
          name  = co_ssolist
        IMPORTING
          value = ssolist_b64.

      IF NOT ssolist_b64 IS INITIAL.
* my instance id
        ssolist = decode_base64( ssolist_b64 ).

        IF NOT c_instance_id IS INITIAL.
          myserver = c_instance_id.
*           translate myserver to lower case.  "#EC TRANSLANG
        ELSE.
          CALL FUNCTION 'RFC_SYSTEM_INFO'
            IMPORTING
              rfcsi_export          = l_rfcsi
            EXCEPTIONS
              communication_failure = 1
              system_failure        = 2
              OTHERS                = 3.
          IF sy-subrc = 0.
            myserver = l_rfcsi-rfcdest.
*             translate myserver to lower case.  "#EC TRANSLANG
          ENDIF.
        ENDIF.
* -- does my server belongs to rejected list ?
        CONCATENATE co_ssotoken_reject
                    myserver '_' c_client
                    INTO server_token.
* -- first cheap test: does ssolist contains this instance ?
        IF ssolist CS server_token.
*   -- create SSO2 hash value
          CALL FUNCTION 'CALCULATE_HASH_FOR_CHAR'
            EXPORTING
              alg            = 'SHA1'
              data           = sso_import
            IMPORTING
              hash           = l_hash160
            EXCEPTIONS
              unknown_alg    = 1
              param_error    = 2
              internal_error = 3
              OTHERS         = 4.
          IF sy-subrc <> 0.
*   -- check entry without hash value
            CLEAR l_hash160.
          ENDIF.

* -- client and hash value depenedent reject list
          CONCATENATE server_token '_' l_hash160
                      INTO server_token.
          IF ssolist CS server_token.
            do_not_use_sso2_ticket = 1.
            CLEAR sso_import.
            CONCATENATE m_recorder_failed_logon-tickets
                 ihttp_recorder_ssorej_ticket
                 INTO m_recorder_failed_logon-tickets.
*             set bit ihttp_recorder_ssorej_ticket of
*                    m_recorder_failed_logon-tickets.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE.
      c_mysapsso2_available = 0.
    ENDIF.

* check the content of ssolist for rejected client certificates
    IF c_certificate_available = 1 AND
       NOT ssolist IS INITIAL.
* create client certificate reject pattern (string with ;c=)
      CONCATENATE co_cctoken_reject
                  myserver '_' c_client
                  INTO server_token.

* -- first cheap test: does ssolist contains this instance ?
      IF ssolist CS server_token.
* mark the certificate as not applicable
        do_not_use_c_certificate = abap_true.
        MESSAGE s000(sr) WITH 'do_not_use_c_certificate'. "#EC NOTEXT
        CONCATENATE m_recorder_failed_logon-tickets
           ihttp_recorder_ssorej_ticket
           INTO m_recorder_failed_logon-tickets.
      ENDIF.
    ENDIF.

    l_saml_ticket =
        request->get_form_field_cs(
          name = cl_icf_saml_config=>artifact_name ).

    IF l_saml_ticket IS NOT INITIAL.
      CONCATENATE m_recorder_failed_logon-tickets
               ihttp_recorder_saml_ticket
               INTO m_recorder_failed_logon-tickets.
    ENDIF.
  ENDIF.

  IF logon_by_mservice IS INITIAL.
    field_user =
         server->request->get_header_field(
                     name = 'sap-user' ).                   "#EC NOTEXT
    IF field_user IS INITIAL.
      field_user =
        server->request->get_form_field(
                     name = 'sap-user' ).                   "#EC NOTEXT

      IF NOT field_user IS INITIAL.
        CONCATENATE m_recorder_failed_logon-user_method
               ihttp_recorder_user_ffield
               INTO m_recorder_failed_logon-user_method.
      ENDIF.
    ELSE.
      CONCATENATE m_recorder_failed_logon-user_method
               ihttp_recorder_user_hfield
               INTO m_recorder_failed_logon-user_method.
    ENDIF.

*   -- check alias name for user name
    IF field_user IS INITIAL.
      alias =
          server->request->get_header_field(
                      name = 'sap-alias' ).                 "#EC NOTEXT
      IF alias IS INITIAL.
        alias =
          server->request->get_form_field(
                       name = 'sap-alias' ).                "#EC NOTEXT
        IF NOT alias IS INITIAL.
          CONCATENATE m_recorder_failed_logon-user_method
               ihttp_recorder_auser_ffield
               INTO m_recorder_failed_logon-user_method.
        ENDIF.
      ELSE.
        CONCATENATE m_recorder_failed_logon-user_method
               ihttp_recorder_auser_hfield
               INTO m_recorder_failed_logon-user_method.
      ENDIF.

      IF NOT alias IS INITIAL.
*   -- map alias to user
        TRANSLATE alias TO UPPER CASE.                   "#EC TRANSLANG
        " Do not use 'SUSR_USER_BNAME_FROM_ALIAS'
*        select single * from usrefus client specified into l_usrefus
*            where mandt      = c_client and
*                  useralias  = alias.
        CALL 'LOGIN_INFO' ID 'OPCODE' FIELD alias_userid_get
                  ID 'CLIENT' FIELD c_client
                  ID 'ALIAS'  FIELD alias
                  ID 'USERID' FIELD field_user.
        subrc_c = sy-subrc.
        m_recorder_failed_logon-alias_user_check = subrc_c.
      ENDIF.
    ENDIF.


    field_passwd =
        server->request->get_header_field( name = 'sap-password' ).

    IF field_passwd IS INITIAL.
      field_passwd =
        server->request->get_form_field( name = 'sap-password' ).

      IF NOT field_passwd IS INITIAL.
        CONCATENATE m_recorder_failed_logon-password_method
              ihttp_recorder_passwd_ffield
              INTO m_recorder_failed_logon-password_method.
      ENDIF.
    ELSE.
      CONCATENATE m_recorder_failed_logon-password_method
               ihttp_recorder_passwd_hfield
               INTO m_recorder_failed_logon-password_method.
    ENDIF.
  ENDIF.

  IF NOT field_user     IS INITIAL AND
     NOT field_passwd IS INITIAL AND
     logon_by_mservice  IS INITIAL.
    logon_by_ff = 1. "logon by form/header fields
  ENDIF.

  pf_m_close c_statistic_state 'A:Header Fields'.             "#EC NOTEXT

  IF logon_by_mservice IS INITIAL.
*     authstring is initial and
*     sso_import is initial.
* -- R3->R3 logon strategy
    r3_auth = server->request->get_header_field( name = c_sap_r3auth ).
    IF NOT r3_auth IS INITIAL.
      CONCATENATE m_recorder_failed_logon-tickets
               ihttp_recorder_r3auth_ticket
               INTO m_recorder_failed_logon-tickets.
*       set bit ihttp_recorder_r3auth_ticket of
*                    m_recorder_failed_logon-tickets.
    ENDIF.


* -- basic authentication available
    IF logon_by_mservice IS INITIAL.
      authstring =
            server->request->get_header_field( name = 'authorization' ).

      IF NOT authstring IS INITIAL.
        CONCATENATE m_recorder_failed_logon-tickets
                ihttp_recorder_bauth_ticket
                INTO m_recorder_failed_logon-tickets.

        CALL METHOD server->request->get_authorization
          IMPORTING
            username = username_str
            password = password_str.


        basic_passwd = password_str.
        IF NOT basic_passwd IS INITIAL.
          CONCATENATE m_recorder_failed_logon-password_method
                   ihttp_recorder_passwd_bauth
                   INTO m_recorder_failed_logon-password_method.
        ENDIF.

        IF service-aliaslogin IS INITIAL.
          basic_user = username_str.
          IF NOT basic_user IS INITIAL.
            CONCATENATE m_recorder_failed_logon-user_method
                   ihttp_recorder_user_bauth
                   INTO m_recorder_failed_logon-user_method.
          ENDIF.

        ELSE.
*   -- map alias to user
          alias = username_str.

          IF NOT alias IS INITIAL.
            CONCATENATE m_recorder_failed_logon-user_method
                  ihttp_recorder_auser_bauth
                  INTO m_recorder_failed_logon-user_method.
          ENDIF.

          TRANSLATE alias TO UPPER CASE.                 "#EC TRANSLANG
          " Do not use 'SUSR_USER_BNAME_FROM_ALIAS'
*        select single * from usrefus client specified into l_usrefus
*            where mandt      = c_client and
*                  useralias  = alias.
          CALL 'LOGIN_INFO' ID 'OPCODE' FIELD alias_userid_get
                    ID 'CLIENT' FIELD c_client
                    ID 'ALIAS'  FIELD alias
                    ID 'USERID' FIELD basic_user.
          IF sy-subrc <> 0 AND
             NOT c_sap_trace IS INITIAL.
            subrc_c = sy-subrc.
            m_recorder_failed_logon-alias_user_check = subrc_c.

            CONCATENATE '<B>Alias: </B>' alias              "#EC NOTEXT
                ', <B>Client: </B>' c_client                "#EC NOTEXT
                ', <B>Retcode: </B>' subrc_c                "#EC NOTEXT
                INTO alias_trace SEPARATED BY space.
          ENDIF.
*       c_user = l_usrefus-bname.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  IF logon_by_mservice IS INITIAL.
*    if c_user is initial.
* -- use service fileds as last default values, if mandatory not used
*    if c_user is initial.
    service_user = service-icf_user.
    IF NOT service_user IS INITIAL.
      CONCATENATE m_recorder_failed_logon-user_method
              ihttp_recorder_user_service
              INTO m_recorder_failed_logon-user_method.
*      endif.
    ENDIF.

*    if password is initial.
    service_passwd = service-icf_passwd.
    IF NOT service_passwd IS INITIAL.
      CONCATENATE m_recorder_failed_logon-password_method
              ihttp_recorder_passwd_service
              INTO m_recorder_failed_logon-password_method.
    ENDIF.
  ENDIF.

*
* SSL And X509 certificate available
*
  CALL METHOD cl_http_server=>retrieve_certificate
    IMPORTING
      document                 = l_x509_x
    EXCEPTIONS
      no_certificate_available = 1.
  IF sy-subrc <> 0.
    CLEAR l_x509_x.
  ENDIF.

  IF c_mysapsso2_available = -1.
    CALL METHOD server->request->get_cookie
      EXPORTING
        name  = 'MYSAPSSO2'
      IMPORTING
        value = sso_import.
    IF sso_import IS INITIAL.
      c_mysapsso2_available = 0.
    ELSE.
      c_mysapsso2_available = 1.
    ENDIF.
  ENDIF.

*
* -- determination of logon order
*
  IF service-logorder IS INITIAL.
*   default logon procedure
    logon_order =
            'AUTH_FIELD,AUTH_CERT,AUTH_SSO,AUTH_ASSERT,AUTH_BASIC,' &
            'AUTH_SAP,AUTH_SAML,AUTH_SERVI'.
    IF service-fallthru IS INITIAL.
* only one trial
      APPEND logon_method TO logon_order_table.
    ELSE.
      SPLIT logon_order AT ',' INTO TABLE logon_order_table.
    ENDIF.
  ELSE.
    logon_order = service-logorder.
    FIND 'AUTH_BASIC' IN service-logorder.
    IF sy-subrc <> 0.
* basic authentication should be prevented
      no_basic_authentication = 1.
    ENDIF.
    SPLIT service-logorder AT ',' INTO TABLE logon_order_table.
  ENDIF.

*
* fulfill logon procedure
*
*

*
* logon order: 1 -- logon by mandatory service user account
*
  IF logon_by_mservice = 1."mandatory logon, i.e. logon with configured identity
* -- update authentication method
* -- update authentication method
    l_authentication_method = authmethod_service.

* Was the original session logon with serivce user successful, and still the same user account ?
* In this no reauthentication necessary.
    IF service_user = lv_expected_user_id.
      l_subrc = 0.
      same_user_account = abap_true.
    ELSE.
      l_subrc = 25.
    ENDIF.

* -- reathentication successful fulfilled with service logon !
    l_reauth_rc = 1.

* assign logon return codes for system/bsp logon
    c_subrc = l_subrc.
    c_saprc = 9008.

    fill_authentication_methods( subrc = subrc
                                 saprc = saprc
                                 last_authentication_method = l_authentication_method ).
*
* logon order: 2 -- logon by mandatory client certificate
*
* sum up logon time for statistic
    stime = server_obj->m_timer->get_runtime( ).

*
* logon order: 2 -- logon by mandatory client certificate
*
  ELSEIF service-protsec       = 'X' OR
        service-login_process  = 'C'.

* -- default user = space, but can be overwriten by external fields
    c_user = field_user.

    IF l_x509_x IS NOT INITIAL.

      l_subrc = 0.

      IF l_subrc = 0.
*   -- update authentication method
        l_authentication_method = authmethod_certificate.
        CALL FUNCTION 'SSFC_BASE64_ENCODE'
          EXPORTING
            bindata                  = l_x509_x
*           BINLENG                  =
          IMPORTING
            b64data                  = l_x509_c
          EXCEPTIONS
            ssf_krn_error            = 1
            ssf_krn_noop             = 2
            ssf_krn_nomemory         = 3
            ssf_krn_opinv            = 4
            ssf_krn_input_data_error = 5
            ssf_krn_invalid_par      = 6
            ssf_krn_invalid_parlen   = 7
            OTHERS                   = 8.
        IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        ENDIF.

        CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
          EXPORTING
            auth_method                 = 'X'
            userid                      = field_user
            auth_data                   = l_x509_c
*           language                    =
*           USE_NEW_EXCEPTION           = 0
          IMPORTING
*           TICKET                      =
            user_id                     = l_username
*           PWDSTATE                    =
*           PWD_CHANGE_SSO              =
*           ALLOW_PWD_DELETION          =
          EXCEPTIONS
            user_or_password_incorrect  = 1
            user_locked                 = 2
            user_outside_validity       = 3
            user_requires_snc_logon     = 4
            password_attempts_limited   = 5
            password_logon_disabled     = 6
            user_has_no_password        = 7
            initialpassword_expired     = 8
            productive_password_expired = 9
            auth_method_requires_snc    = 10
            ticket_logon_disabled       = 11
            ticket_encoding_error       = 12
            ticket_issuer_not_verified  = 13
            ticket_issuer_not_trusted   = 14
            ticket_expired              = 15
            x509_logon_disabled         = 16
            x509_encoding_error         = 17
            no_userid_for_aliasname     = 18
            extid_logon_disabled        = 19
            no_mapping_found            = 20
            mapping_ambiguous           = 21
            internal_error              = 22
            auth_method_not_supported   = 23
            logon_data_incomplete       = 24
            OTHERS                      = 25.

        l_subrc = sy-subrc.
        IF ( l_subrc = 0 ).
          IF ( l_username = lv_expected_user_id ).
            same_user_account = abap_true.
          ENDIF.
* -- reathentication successful fulfilled
          l_reauth_rc = 1.
        ELSE.
* -- reathentication failed
          l_reauth_rc = -1.
* basic authentication should be prevented
          no_basic_authentication = 1.
        ENDIF.

* assign logon return codes for system/bsp logon
        c_subrc = l_subrc.
        c_saprc = 9002.

        fill_authentication_methods( subrc = c_subrc
                                     saprc = c_saprc
                                     last_authentication_method = l_authentication_method ).
      ELSE.
* -- trace
        c_subrc = c_certificate_available + 100.
        c_saprc = c_protocol + 100.
* basic authentication should be prevented
        no_basic_authentication = 1.
        fill_authentication_methods( subrc = c_subrc
                                     saprc = c_saprc
                                    last_authentication_method = l_authentication_method ).
      ENDIF.
    ENDIF.
  ENDIF.

* execution of logon procedure due the logon order
  IF l_authentication_method = authmethod_none.
    LOOP AT logon_order_table INTO logon_method.

*
* logon order: 3 -- logon by form/header fields
*
      IF ( logon_method IS INITIAL OR logon_method = 'AUTH_FIELD' )
         AND logon_by_ff = 1.
* -- update authentication method
        l_authentication_method = authmethod_field.

*       c_user                = field_user.

        CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
          EXPORTING
            auth_method                 = 'P'
            userid                      = field_user
            password                    = field_passwd
*           language                    =
*           USE_NEW_EXCEPTION           = 0
          IMPORTING
*           TICKET                      =
            user_id                     = l_username
*           PWDSTATE                    =
*           PWD_CHANGE_SSO              =
*           ALLOW_PWD_DELETION          =
          EXCEPTIONS
            user_or_password_incorrect  = 1
            user_locked                 = 2
            user_outside_validity       = 3
            user_requires_snc_logon     = 4
            password_attempts_limited   = 5
            password_logon_disabled     = 6
            user_has_no_password        = 7
            initialpassword_expired     = 8
            productive_password_expired = 9
            auth_method_requires_snc    = 10
            ticket_logon_disabled       = 11
            ticket_encoding_error       = 12
            ticket_issuer_not_verified  = 13
            ticket_issuer_not_trusted   = 14
            ticket_expired              = 15
            x509_logon_disabled         = 16
            x509_encoding_error         = 17
            no_userid_for_aliasname     = 18
            extid_logon_disabled        = 19
            no_mapping_found            = 20
            mapping_ambiguous           = 21
            internal_error              = 22
            auth_method_not_supported   = 23
            logon_data_incomplete       = 24
            OTHERS                      = 25.

        l_subrc = sy-subrc.

* assign logon return codes for system/bsp logon
        c_subrc = l_subrc.
        c_saprc = 9003.
        IF ( l_subrc = 0 ).
          IF ( l_username = lv_expected_user_id ).
            same_user_account = abap_true.
          ENDIF.
* -- reathentication successful fulfilled
          l_reauth_rc = 1.
        ELSE.
* -- reathentication failed
          l_reauth_rc = -1.
        ENDIF.

        fill_authentication_methods( subrc = c_subrc
                                     saprc = c_saprc
                                     last_authentication_method = l_authentication_method ).
*
* logon order: 4 (former order 7) -- logon by client certificate
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_CERT' )
           AND l_x509_x IS NOT INITIAL. "c_certificate_available = 1

        l_subrc = 0.

        IF l_subrc = 0.
*   -- update authentication method
          l_authentication_method = authmethod_certificate.

          CALL FUNCTION 'SSFC_BASE64_ENCODE'
            EXPORTING
              bindata                  = l_x509_x
*             BINLENG                  =
            IMPORTING
              b64data                  = l_x509_c
            EXCEPTIONS
              ssf_krn_error            = 1
              ssf_krn_noop             = 2
              ssf_krn_nomemory         = 3
              ssf_krn_opinv            = 4
              ssf_krn_input_data_error = 5
              ssf_krn_invalid_par      = 6
              ssf_krn_invalid_parlen   = 7
              OTHERS                   = 8.
          IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
          ENDIF.

          CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
            EXPORTING
              auth_method                 = 'X'
              userid                      = field_user
              auth_data                   = l_x509_c
*             language                    =
*             USE_NEW_EXCEPTION           = 0
            IMPORTING
*             TICKET                      =
              user_id                     = l_username
*             PWDSTATE                    =
*             PWD_CHANGE_SSO              =
*             ALLOW_PWD_DELETION          =
            EXCEPTIONS
              user_or_password_incorrect  = 1
              user_locked                 = 2
              user_outside_validity       = 3
              user_requires_snc_logon     = 4
              password_attempts_limited   = 5
              password_logon_disabled     = 6
              user_has_no_password        = 7
              initialpassword_expired     = 8
              productive_password_expired = 9
              auth_method_requires_snc    = 10
              ticket_logon_disabled       = 11
              ticket_encoding_error       = 12
              ticket_issuer_not_verified  = 13
              ticket_issuer_not_trusted   = 14
              ticket_expired              = 15
              x509_logon_disabled         = 16
              x509_encoding_error         = 17
              no_userid_for_aliasname     = 18
              extid_logon_disabled        = 19
              no_mapping_found            = 20
              mapping_ambiguous           = 21
              internal_error              = 22
              auth_method_not_supported   = 23
              logon_data_incomplete       = 24
              OTHERS                      = 25.
          l_subrc = sy-subrc.
          IF ( l_subrc = 0 ).
            IF ( l_username = lv_expected_user_id ).
              same_user_account = abap_true.
            ENDIF.
* -- reathentication successful fulfilled
            l_reauth_rc = 1.
          ELSE.
* -- reathentication failed
            l_reauth_rc = -1.
          ENDIF.
        ENDIF.

        c_subrc = l_subrc.
        c_saprc = 9007.
        fill_authentication_methods( subrc = c_subrc
                                     saprc = c_saprc
                                     last_authentication_method = l_authentication_method ).

*
* logon order: 5 (former order 4) -- Logon by SSO Logon ticket or Assertion Ticket
* --   --  before basic auth. because of USER_SWITCH
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SSO' OR logon_method = 'AUTH_ASSERT' )
            AND NOT sso_import IS INITIAL.
* -- update authentication method
        l_authentication_method = authmethod_sso.

        CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
          EXPORTING
            auth_method                 = 'T'
*           userid                      =
            auth_data                   = sso_import
*           language                    =
*           USE_NEW_EXCEPTION           = 0
          IMPORTING
*           TICKET                      =
            user_id                     = l_username
*           PWDSTATE                    =
*           PWD_CHANGE_SSO              =
*           ALLOW_PWD_DELETION          =
          EXCEPTIONS
            user_or_password_incorrect  = 1
            user_locked                 = 2
            user_outside_validity       = 3
            user_requires_snc_logon     = 4
            password_attempts_limited   = 5
            password_logon_disabled     = 6
            user_has_no_password        = 7
            initialpassword_expired     = 8
            productive_password_expired = 9
            auth_method_requires_snc    = 10
            ticket_logon_disabled       = 11
            ticket_encoding_error       = 12
            ticket_issuer_not_verified  = 13
            ticket_issuer_not_trusted   = 14
            ticket_expired              = 15
            x509_logon_disabled         = 16
            x509_encoding_error         = 17
            no_userid_for_aliasname     = 18
            extid_logon_disabled        = 19
            no_mapping_found            = 20
            mapping_ambiguous           = 21
            internal_error              = 22
            auth_method_not_supported   = 23
            logon_data_incomplete       = 24
            OTHERS                      = 25.

        IF ( sy-subrc = 0 ).
          IF ( l_username = lv_expected_user_id ).
            same_user_account = abap_true.
            l_subrc = 0.
          ENDIF.
* -- reathentication successful fulfilled
          l_reauth_rc = 1.
        ELSE.
* -- reathentication failed
          l_reauth_rc = -1.

          l_subrc = 26.
        ENDIF.

* assign logon return codes for system/bsp logon
        c_subrc = l_subrc.
        c_saprc = 9004.
        IF l_subrc = 0.
        ENDIF.
        fill_authentication_methods( subrc = c_subrc
                                     saprc = c_saprc
                                     last_authentication_method = l_authentication_method ).
*
* logon order: 6 (former 5) -- logon by Basic authorization field
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_BASIC' )
           AND NOT authstring IS INITIAL.
* -- update authentication method
        l_authentication_method = authmethod_basic.
        CALL FUNCTION 'SUSR_CHECK_LOGON_DATA'
          EXPORTING
            auth_method                 = 'P'
            userid                      = basic_user
            password                    = basic_passwd
*           language                    =
*           USE_NEW_EXCEPTION           = 0
          IMPORTING
*           TICKET                      =
            user_id                     = l_username
*           PWDSTATE                    =
*           PWD_CHANGE_SSO              =
*           ALLOW_PWD_DELETION          =
          EXCEPTIONS
            user_or_password_incorrect  = 1
            user_locked                 = 2
            user_outside_validity       = 3
            user_requires_snc_logon     = 4
            password_attempts_limited   = 5
            password_logon_disabled     = 6
            user_has_no_password        = 7
            initialpassword_expired     = 8
            productive_password_expired = 9
            auth_method_requires_snc    = 10
            ticket_logon_disabled       = 11
            ticket_encoding_error       = 12
            ticket_issuer_not_verified  = 13
            ticket_issuer_not_trusted   = 14
            ticket_expired              = 15
            x509_logon_disabled         = 16
            x509_encoding_error         = 17
            no_userid_for_aliasname     = 18
            extid_logon_disabled        = 19
            no_mapping_found            = 20
            mapping_ambiguous           = 21
            internal_error              = 22
            auth_method_not_supported   = 23
            logon_data_incomplete       = 24
            OTHERS                      = 25.

        l_subrc = sy-subrc.
        IF ( l_subrc = 0 ).
          IF ( l_username = lv_expected_user_id ).
            same_user_account = abap_true.
          ENDIF.
* -- reathentication successful fulfilled
          l_reauth_rc = 1.
        ELSE.
* -- reathentication failed
          l_reauth_rc = -1.
        ENDIF.
* assign logon return codes for system/bsp logon
        c_subrc = subrc.
        c_saprc = 9005.

        fill_authentication_methods( subrc = c_saprc
                                     saprc = c_subrc
                                     last_authentication_method = l_authentication_method ).
*
* logon order: 7 (former 6) -- logon by R3AUth field -> is not supported for reauthentication !
* --   -- R/3-R/3 communication based on RFC procedure
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SAP' )
           AND NOT r3_auth IS INITIAL.

*************************************************************************************************
* No validation is necessary for R3AUTH (Logon via RFC Logon Ticket) because RFC ticket will not
* send in next HTTP request (in case of stateful communication)
*************************************************************************************************
*
* no support for SAP authentication and ESID: Reject
*
* -- update authentication method
        l_authentication_method = authmethod_sap.

* -- reathentication failed
        l_reauth_rc = -1.

        same_user_account = abap_false.


* assign logon return codes for system/bsp logon
        c_subrc = 9006.
        c_saprc = 9006.

        fill_authentication_methods( subrc = c_subrc
                                     saprc = c_saprc
                                     last_authentication_method = l_authentication_method ).

*
* logon order: 8 -- logon by SAML -> is not supported for reauthentication !
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SAML' )
           AND NOT l_saml_ticket IS INITIAL.
*
* no support for SAML authentication and ESID: skip this method
*
* logon order: 9 -- logon by service user account
*
      ELSEIF ( logon_method IS INITIAL OR logon_method = 'AUTH_SERVI' )
           AND NOT service_passwd IS INITIAL.
* -- update authentication method
        l_authentication_method = authmethod_service.

* Was the original session logon with serivce user successful, and still the same user account ?
* In this no reauthentication necessary.
        IF service_user = lv_expected_user_id.
          l_subrc = 0.
          same_user_account = abap_true.
        ELSE.
          l_subrc = 25.
        ENDIF.

* -- reathentication successful fulfilled with service logon !
        l_reauth_rc = 1.

* assign logon return codes for system/bsp logon
        c_subrc = l_subrc.
        c_saprc = 9008.

        fill_authentication_methods( subrc = subrc
                                     saprc = saprc
                                     last_authentication_method = l_authentication_method ).
      ENDIF.

* logon time for statistic
      etime = server_obj->m_timer->get_runtime( ).
      m_authentication_time = m_authentication_time + ( etime - stime ).

*
* execution of logon procedure
*
      IF l_authentication_method <> authmethod_none.
        IF service-fallthru IS INITIAL.
*   check of one possible method
          EXIT.
        ELSEIF same_user_account = abap_true.
*   check of all possible methods, until successful logon, if happen
          EXIT.
        ENDIF.
      ENDIF.

    ENDLOOP.

  ENDIF.

  IF l_authentication_method = authmethod_none.
    subrc = 9009.
    fill_authentication_methods( subrc = subrc
                                 saprc = 9999
                                 last_authentication_method = l_authentication_method ).
  ENDIF.

*
* -- login succeeded -> set SSO2 in cookie and context pooling part
*
  m_recorder_failed_logon-logon_subrc = c_subrc.
  m_recorder_failed_logon-logon_saprc = c_saprc.
  IF ssl_active = co_enabled.
    m_recorder_failed_logon-ssl_availabale = co_enabled.
  ENDIF.


  pf_m_close c_statistic_state 'A:Reauthenticate Inside'.     "#EC NOTEXT


*  IF ( l_authentication_method = authmethod_none ) OR
*     ( l_reauth_rc             <> 0 ).
*
** send 400 Session not found
*    process_session_not_found = abap_true.
*  ENDIF.

ENDMETHOD.                    "authentication


METHOD reauthentication_access_token.
*
* A foreign user has access to a stateful HTTP session if he provides a registered session access
* token in URL parameter sap-session_access_token. Access is granted, if the user id is valid and
* matches the one in the registration entry and if the request URL path contains the URL path of
* the registration entry as a prefix. The registered URL path must be active and must be a
* terminating node in the ICF service tree that is maintained in transaction SICF.
* Registration of the session access token in the HTTP session is done in method
* IF_HTTP_SERVER~ENABLE_FOREIGN_SESSION_ACCESS.
*
  DATA: lv_url_path       TYPE string.
  DATA: lv_registry_entry TYPE gt_session_access_reg_entry.
  DATA: lv_reg_length     TYPE i.
  DATA: lv_path_length    TYPE i.

* Retrieve the registry entry for the received session access token
  CALL METHOD get_session_access_reg_entry
    EXPORTING
      session_access_token           = session_access_token
    IMPORTING
      registry_entry                 = lv_registry_entry
    EXCEPTIONS
      session_access_token_not_found = 1.

  IF sy-subrc <> 0.
* no registration -> no entrance ! and send 400 Session not found
    access_granted = abap_false.
    RETURN.
  ENDIF.

* after first try determine the value of one_time_access_token and if necessary remove
* the entry out of internal registry
  IF lv_registry_entry-one_time_access_token = abap_true.
    IF m_xsrf_token_copy IS INITIAL.
      DELETE c_session_access_registry WHERE session_access_token = session_access_token.
    ELSE.
      lv_registry_entry-marked_for_deletion = abap_true.        "note 1658516
      MODIFY c_session_access_registry FROM lv_registry_entry
        TRANSPORTING marked_for_deletion
        WHERE session_access_token = session_access_token.
        "postpone actual deletion (see method SEND_RESPONSE)
        "enabling repeated check in method VALIDATE_XSRF_TOKEN
    ENDIF.
  ENDIF.

* Constrains:
* 1) Check the url path with the registerd one for the deliverd value for sap-session_access_token
  lv_url_path = server->request->get_header_field( if_http_header_fields_sap=>path_translated ).
  lv_reg_length = strlen( lv_registry_entry-url_path ).
  lv_path_length = strlen( lv_url_path ).
* Accept only those URL path which fits to the registered URL, i.e. the registerd URL path is
* prefix of the requested path
  IF lv_reg_length > lv_path_length.
    access_granted = abap_false.
    RETURN.
  ELSEIF lv_url_path(lv_reg_length) <> lv_registry_entry-url_path.
* let the request be excuted !
    access_granted = abap_false.
    RETURN.
  ENDIF.

* 2) Check whether a user is maintained
*
* In case of deliver reauthentication data check either authentication data is matched to the
* present application session or to the maintined user id in associstion with received
* session access token
*
  IF lv_registry_entry-user_id IS INITIAL.
* let the request be excuted !
    access_granted = abap_true.
  ELSE.
* Initialization of the user check
    access_granted  = abap_false.
    reauthentication( EXPORTING
                          server  = server
                          servtbl = servtbl
                          service = service
                          expected_user_id = lv_registry_entry-user_id
                       IMPORTING
                          same_user_account          = access_granted ).
  ENDIF.
ENDMETHOD.                    "REAUTHENTICATION_ACCESS_TOKEN


METHOD reauthentication_required.
*
* No reuathentication is necessary, in following cases and only for classic logon and not in the context
* of the recently established security session management:
* 1) Profile prameter icf/user_recheck = 0
* 2) Profile prameter icf/user_recheck = 1 but in the service contains the setting icf_reauth_off = 'Y'
*
* Remark Changes to "3) The service is a PUBLIC service:"
*    Accessing an application state (sap-contextid, c_server->stateful = 1)
*    which is authenticated (c_server->c_authenticated = 1)
*    should not be possible without (re-)authentication - irregardless whether the current http request
*    is handled by a public service or not.
*
* Remark: In context of security session always a reauthentication is required/executed, i.e. REAUTHENTICATION_SEC_SESSION. In other words, with security session mangement
*         the reauthentication in case of secuty session cannot be disabled.
* On the call of HTTP_SHM_GET_HANDLER_LIST we check, if the handler is CL_SOAP_HTTP_EXTENSION and the flag actlogin-icf_esi_flag is initial, and it it so, then
* we mark this service as "old webservice" by setting actlogin-icf_esi_flag = 'Y' and actlogin-icf_reauth_off = 'Y'

* NO reauthentication required if
*    - the ORIGINAL http request (stateful) was public / run under service user (configured identity), and
*    - the CURRENT http request does NOT require CLIENT-provided credentials, i.e.
*           - public service, or
*           - service is (always) running under configured identity, or
*           - service could run under configured identity (credentials are provided in the ICF service configuration)
*

  IF c_authenticated = 1 AND
     authentication_provider = authprovider_icf  AND
     authentication_method   = authmethod_service AND
     ( service-publicflag = 'X' OR
        ( service-obluser IS NOT INITIAL AND service-oblpasswd IS NOT INITIAL ) OR
        ( service-icf_user IS NOT INITIAL AND service-icf_passwd IS NOT INITIAL )
      ).
    required_type = 0.
  ELSEIF m_security_session_active = abap_true AND
        ( ( m_sec_session_restrictions NE 'P' ) OR
          ( m_sec_session_restrictions = 'P' AND m_security_session_cookie IS NOT INITIAL ) ).
    required_type = 2."security session id cookie must be checked
  ELSEIF c_user_recheck = 0.
    required_type = 0.
  ELSEIF service-icf_reauth_off = 'Y'.
    required_type = 0.
  ELSE.
    required_type = 1."classic logon is active
  ENDIF.

ENDMETHOD.


METHOD reauthentication_sec_session.

*
* In case of stateful communication the only check to avoid a session hijacking based on the
* the deliverd security session cookie and the assicaited user account to this cookie. As far the associated user
* is the same as the ABAP context user account the application context can be reused. Otherwise a 400 response
* should be processed
* Remark: A reuthentication in case of sescurity session context ndsteful communication cannot be disabled
*
  DATA: l_security_session_value  TYPE string.
  DATA: l_security_session_cookie TYPE string.
  DATA: l_out_user              TYPE username.
  DATA: l_out_context           TYPE security_context_id.
*
* get cookie_name
* determ cookie and the value
* check user with determed user
*
  pf_m_open c_statistic_state 'A:Sec Reauthenticate Inside'.  "#EC NOTEXT
  IF security_session_id IS INITIAL.
    CALL METHOD cl_http_security_session_icf=>security_sessionid_cookie_name
      EXPORTING
        client      = cl_abap_syst=>get_client( )
      RECEIVING
        cookie_name = l_security_session_cookie.

    CALL METHOD request->get_cookie
      EXPORTING
        name  = l_security_session_cookie
      IMPORTING
        value = l_security_session_value.
  ELSE.
    l_security_session_value = security_session_id.
  ENDIF.

  TRY.
      CALL METHOD cl_http_security_session_icf=>check_security_session_id
        EXPORTING
          session_id = l_security_session_value
          client     = cl_abap_syst=>get_client( )
        IMPORTING
          userid     = l_out_user
          context_id = l_out_context.

    CATCH cx_http_security_session.                     "#EC NO_HANDLER
      CLEAR l_out_user.
  ENDTRY.
  IF l_out_user = cl_abap_syst=>get_user_name( ).
    validity_sec_session = abap_true.
  ELSE.
    validity_sec_session = abap_false.
  ENDIF.

  pf_m_close c_statistic_state 'A:Sec Reauthenticate Inside'. "#EC NOTEXT
ENDMETHOD.


METHOD receive_request.
  m_connection_error-name = 'Me'.

  DATA: _entity TYPE REF TO cl_http_entity,
        c_msg   TYPE %_c_pointer.

* Initialization of compression (has application used the
* SET_COMPRESSION method during its execution ?)
  m_compression_done = abap_false.

  super->receive_request( ).

* get reference info of stateful flag (used to compare against changes
* in statefulness afterwards -> set/delete context cookie only if any
* change occured
  c_stateful_ref = stateful.

*
* increment total number of executed requests requests for a session for
* e. g. read profile parameter with the next stateful call
* e, g. gui enabing is only allowed with the first call
*
*
  c_counter = c_counter + 1.

  CALL FUNCTION 'HTTP_READ_SC'
    IMPORTING
      c_msg         = c_msg
      connection_id = m_connection_id
    CHANGING
      connection    = m_connection_error.

*
* handling of enent IF_HTTP_SERVER~EVENTKIND_CONTEXT_TERMINATION
* depending on return code of HttpReceive in HTTP_DISAPTCH_REQUEST
*
  IF m_connection_error-ecode = 0.
    _entity ?= request.
    _entity->set_c_msg( c_msg ).

    _entity ?= response.
    SYSTEM-CALL ict
      did
        ihttp_scid_create_message
      PARAMETERS
        2                              " > message type (2 = resp)
        c_msg                          " < c handle
        m_last_error.                  " < return code

    _entity->set_c_msg( c_msg ).

*     This request/response objects together so that ICM can later decide to surpress GZIP
*     compression for specific types of URLs, etc. This works only with new kernel.
*     Relevant profile parameter: ict/exclude_compression
*    IF cl_http_utility=>is_ict_system_call_implemented(  ihttp_scid_set_request_message ) IS INITIAL.
    DATA: req_entity  TYPE REF TO cl_http_entity. req_entity  ?= request.
    DATA: resp_entity TYPE REF TO cl_http_entity. resp_entity ?= response.
    SYSTEM-CALL ict
      did
        ihttp_scid_set_request_message
      PARAMETERS
        resp_entity->m_c_msg         " > c_msg
        req_entity->m_c_msg          " > c_msg
        m_last_error.                " < unsigned int
*    ENDIF.

  ENDIF.

* Established for MI application view and debugger (in CL_MI_SEMANTIC_TREE_ICF)
  m_path_translated = request->get_header_field( '~path_translated' ).

  IF m_connection_error-ecode <> 0.
*    data: errortext type string.
*    if not connection-emessage is initial.
*      errortext = '-Fehlermeldung beim Empfang der Daten.'(er0).
*      concatenate connection-emessage errortext into errortext.
*    else.
*      data: nr type string.
*      nr = connection-ecode.
*      errortext = '-Fehlercode beim Empfang der Daten.'(er1).
*      concatenate nr errortext into errortext.
*    endif.
*
* suppress e message for event handling
*
*    message e000(sr) with errortext.
    IF m_connection_error-ecode <> 0.
      m_connection_error-name = 'CO_COMMUNICATION_ERROR_RECEIVE'.
      CALL FUNCTION 'HTTP_GET_ERRORCODE'
        EXPORTING
          errorcode         = m_connection_error-ecode
        IMPORTING
          errortext         = m_connection_error-emessage
        EXCEPTIONS
*         invalid_errorcode = 1
*         others            = 2.
          OTHERS            = 0.
    ENDIF.

    rc = m_connection_error-ecode.
    RETURN.
  ENDIF.

* header and body length of request after serialization
  CALL METHOD request->get_serialized_message_length
    IMPORTING
      body_length   = m_request_body_length
      header_length = m_request_header_length.

* bg: 04/04/2001: response protocol should be request protocol
  m_protocol_version =
    request->get_header_field( '~server_protocol' ).        "#EC NOTEXT
  IF m_protocol_version IS NOT INITIAL.
    response->set_header_field( name  = '~server_protocol'
                                value = m_protocol_version ). "#EC NOTEXT
  ENDIF.
*
* note: from 711 release the existence check for header field sap-passport and
*       the setting of passport take place in kernel
*
* --  set imported passport
*
*  data: x_passport type xstring,
*        m_passport type string,
*        m_version type string. "#EC NEEDED
*
*  m_passport =
*    request->get_header_field( name  = 'sap-passport' )."#EC NOTEXT
*  if not m_passport is initial.
*    if m_passport cs 'v='.
*      split m_passport at ',' into m_version m_passport.
*    endif.
*
*    x_passport = m_passport.
*    call function 'TH_SET_CLIENT_ID_FROM_NET_DATA'
*      exporting
*        network_data            = x_passport
**       DATA_LEN                =
*     exceptions
*       parameter_missing       = 1
*       internal_error          = 2
*       parameter_wrong         = 3
*       others                  = 4. "#EC *
*  endif.
*
*
* -- set external session id, only with the first request
*
  IF c_authenticated IS INITIAL.
    external_session_id = request->get_form_field( 'sap-ext-sid' ).
    IF external_session_id IS INITIAL.
      external_session_id = request->get_uri_parameter( 'e' ).
    ENDIF.
  ENDIF.

* -- clear last state of icfpersist
  IF NOT m_icfrecorder IS INITIAL.
    CLEAR m_icfrecorder.
  ENDIF.

* -- avoid execution of debugging method for the same request in ICF
  IF c_debugid IS NOT INITIAL.
    CLEAR c_debugid.
  ENDIF.

*
* Update debugging/tracing/profiling/recording states,
* for stateful sessions
* no update of parameter for the first request
* these values are already read in class constructur
*
  IF c_counter > 1.
    DATA: l_scheme TYPE string.
    CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'b'
      ID 'DebuggingPossible'
             FIELD c_debugging_possible
      ID 'AcceptRemoteTraceLevel'
             FIELD c_accept_remote_trace_level
      ID 'AcceptRemoteProfileLevel'
             FIELD c_accept_remote_profile_level
      ID 'AcceptRemoteRecorderLevel'
             FIELD c_accept_remote_recorder_level.

* evaluate actual protocol again (http/https), since BSP pages can
* switch during a stateful communication from http protocol to https
    l_scheme =
     request->get_header_field(
              if_http_header_fields_sap=>uri_scheme_expanded ).
    IF l_scheme IS INITIAL.
      CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'e'
        ID 'Protocol'  FIELD c_protocol.
*       -- update prootocol type (TH_PLUGIN_PROTOCOL_HTTPS = 2)
      IF c_protocol = 2.
        ssl_active = co_enabled.
      ELSE.
        ssl_active = co_disabled.
      ENDIF.
    ELSE.
      IF l_scheme = 'HTTPS'.
        ssl_active = co_enabled.
      ELSE.
        ssl_active = co_disabled.
      ENDIF.
    ENDIF.
  ENDIF.

* NGSSO project:
* In case of WS security logon the callback method CL_AUTHENTICATION_PROVIDER=>WS_SECURITY_AUTHN_RESULT
* has to be called by WS runtime (usually from within the method CL_WSSE_CONTEXT->AUTHENTICATE)
* Attribute M_WS_SECURITY_LOGON_DONE is checked in SEND_REPONSE method again for check reason
  m_ws_security_logon_done = abap_false.

ENDMETHOD.


method recorder .
*  data: ihttp_attribute  type ihttp_recorder_attribute.
*  data: ihttp_attributes type ihttp_recorder_attributes.
*  data: l_cookies        type tihttpcki.
*  data: l_cookie         type ihttpcki.

* -- no records for AUTHMETHOD_NONE
*    if component = ihttp_record_failed_auth and
*       authentication_method = 0.
*        raise disable_recording.
*    endif.

    call method super->recorder
       exporting
         expiration_day      = expiration_day
         expiration_time     = expiration_time
         icfattrib_entry     = icfattrib_entry
       changing
         component         = component
       exceptions
         disable_recording = 1.
    if sy-subrc = 1.
* replay of existing record entries -> do not record again
       c_enable_recording = 0.
       return.
    endif.

    c_enable_recording = component.

* message role is 'SE' for Server External
    m_icfrecorder-message_role = ihttp_recorder_role_sextern.

* authentication method
    m_icfrecorder-logon_method = authentication_method.

    if component = ihttp_record_failed_auth. " and
*       authentication_method <> 0.
* -- information about failed logon
      data: code   type i,
        reason type string, "#EC NEEDED
        ccode(8) type c.

      m_icfrecorder-response = response->to_xstring( ).
* set ~status_line
      call method response->get_status
         importing
           code   = code
           reason = reason.
      ccode = code.
      condense ccode.
      m_icfrecorder-response_status = ccode.
    endif.

    if component >= ihttp_record_request.
      data: option type i.
      if component = ihttp_record_request.
        option = 0.
      elseif component = ihttp_record_response_status.
        option = 1.
      elseif component >= ihttp_record_response.
        option = 2.
      endif.
*-- register MessageId in Kernel for error handling
      call 'ICF_DISPATCH' id 'HTTP' field 'r'
                    id 'MessageId' field m_icfrecorder-message_id
                    id 'Option'    field option.
    endif.

*
* add attributes
*
*    ihttp_attribute-type    = ihttp_recorder_attrib_version.
*    ihttp_attribute-version = 0.
*    append ihttp_attribute to ihttp_attributes.

* -- add logon entry into attributes
     if not m_recorder_failed_logon is initial.
*      ihttp_attribute-type    = ihttp_recorder_attrib_logon.
*      ihttp_attribute-version = 0.
*
*      export icflogon = m_recorder_failed_logon
*                  to data buffer ihttp_attribute-entry.
*      append ihttp_attribute to ihttp_attributes.
       call function 'ICF_RECORDER_ATTRIBUTES'
         exporting
            action                        = ihttp_icfservice_action_pack
*           from_entries                  = ihttp_attributes
            icfrecorder_failed_logon_imp  = m_recorder_failed_logon
*        IMPORTING
*           TO_ENTRIES                    =
         changing
            icfrecord_attributes          = m_icfrecorder-attributes
         exceptions
            icf_action_not_supported         = 1
            icf_no_authority                 = 2
            icf_incomplete_information       = 3
            icf_invalid_attributes           = 4
            others                           = 5."#EC *

*    export icfattributes = ihttp_attributes
*           to data buffer m_icfrecorder-attributes.
    endif.
* plausi check regarding existence of logon_client
    if m_icfrecorder-logon_client is initial.
       m_icfrecorder-logon_client = c_client.
    endif.

    insert icfrecorder client specified from m_icfrecorder.
    call function 'DB_COMMIT'.

endmethod.


METHOD replace_logon_token .
  DATA: itab     TYPE TABLE OF string,
        form     TYPE string,
        rest     TYPE string,
        token    TYPE string.
  DATA: l_fields TYPE tihttpnvp.
  DATA: prefix   TYPE string,                               "#EC NEEDED
        postfix  TYPE string.                               "#EC NEEDED
  DATA: l_do_not_html_escape TYPE i.

  CLASS cl_http_utility DEFINITION LOAD.

  IF data CS '<%=SY'.
    IF NOT c_user IS INITIAL.
      REPLACE ALL OCCURRENCES OF '<%=SYUNAME%>'
             IN data WITH c_user. "sy-uname.
    ELSE.
      REPLACE ALL OCCURRENCES OF '<%=SYUNAME%>'
             IN data WITH ''.
    ENDIF.

    IF NOT c_client IS INITIAL.
      REPLACE ALL OCCURRENCES OF '<%=SYMANDT%>'
             IN data WITH c_client. "sy-mandt.
    ELSE.
      REPLACE ALL OCCURRENCES OF '<%=SYMANDT%>'
             IN data WITH sy-mandt.
    ENDIF.

    IF c_langu IS INITIAL.
      CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'zcsa/system_language'
                         ID 'VALUE' FIELD c_langu.
    ENDIF.
    REPLACE ALL OCCURRENCES OF '<%=SYLANGU%>'
           IN data WITH c_langu.

    REPLACE ALL OCCURRENCES OF '<%=SYHOST%>'
           IN data WITH sy-host.
    REPLACE ALL OCCURRENCES OF '<%=SYSYSID%>'
           IN data WITH sy-sysid.
    REPLACE ALL OCCURRENCES OF '<%=SYOPSYS%>'
           IN data WITH sy-opsys.
    REPLACE ALL OCCURRENCES OF '<%=SSYDBSYS%>'
           IN data WITH sy-dbsys.
    REPLACE ALL OCCURRENCES OF '<%=SYSAPRL%>'
           IN data WITH sy-saprl.
    REPLACE ALL OCCURRENCES OF '<%=SYDATUM%>'
           IN data WITH sy-datum.
    REPLACE ALL OCCURRENCES OF '<%=SYUZEIT%>'
           IN data WITH sy-uzeit.
  ENDIF.

*
* XSS (Cross Server Scripting)-Attacken verhindern
* Das Problem kann durch Ersetzen von ICF-Scripts im HTML-Body wie
* <%=PATHTRANS%>, <%=ABS_URL%>, <%=FORM_xxx%> oder <%=HEADER_xxx%>
* entstehen.
*
  IF set_ffield_name IS NOT SUPPLIED.
* Ersetzen von Tokens in Body: Soll Abwaertskompatibilitaet
* bewahrt werden ?
    IF data CS '<%=NO_HTML_ESC%>'.
      l_do_not_html_escape = 1.
    ENDIF.

  ENDIF.

  IF data CS '<%=PATHTRANS%>'.
    form = server->request->get_header_field( '~path_translated' ).
* --
* escaping of path_translated, for escapping of special character
*  such as & (refering to Bernhard Braun), if these are part of path
* note: url escaping must be done only in cases where '<%=PATHTRANS%>'
*       is in the query string and as form field
* --
    IF set_ffield_name IS SUPPLIED.
      IF data CS '?'.
        SPLIT data AT '?' INTO prefix postfix.
        IF postfix CS '<%=PATHTRANS%>'.
*          form = cl_http_utility=>escape_url( unescaped = form ).
* Use new ABAP XSS Escaping library (see sap note 1644634)
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_url ).
        ENDIF.
      ENDIF.
    ELSEIF l_do_not_html_escape IS INITIAL.
*
* XSS-Attacken verhindern (z. B. /sap/bc/<script><ok></script>/echo)
*
*      form = cl_http_utility=>escape_html( form ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
      form = escape( val    = form
                     format = cl_abap_format=>e_xss_ml ).

    ENDIF.

    REPLACE ALL OCCURRENCES OF '<%=PATHTRANS%>'
           IN data WITH form.
  ENDIF.

  IF data CS '<%=ABS_URL%>'.
    form = server->create_abs_url( ).
* --
* escaping of absolut URL, for escapping of special character
*  such as & (refering to Bernhard Braun), if these are part of path
* note: url escaping must be done only in cases where '<%=ABS_URL%>'
*       is in the query string and as form field
* --
    IF set_ffield_name IS SUPPLIED.
      IF data CS '?'.
        SPLIT data AT '?' INTO prefix postfix.
        IF postfix CS '<%=ABS_URL%>'.
*          form = cl_http_utility=>escape_url( unescaped = form ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_url ).
        ENDIF.
      ENDIF.
    ELSEIF l_do_not_html_escape IS INITIAL.
*
* XSS-Attacken verhindern (z. B. /sap/bc/<script></script>/echo)
*
*      form = cl_http_utility=>escape_html( form ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
      form = escape( val    = form
                     format = cl_abap_format=>e_xss_ml ).

    ENDIF.

    REPLACE ALL OCCURRENCES OF '<%=ABS_URL%>'
           IN data WITH form.
  ENDIF.

  IF data CS '<%=INSTANCEID%>'.
    DATA: l_rfcsi TYPE rfcsi.
    CALL FUNCTION 'RFC_SYSTEM_INFO'
      IMPORTING
        rfcsi_export = l_rfcsi.

    form = l_rfcsi-rfcdest.
* --
* escaping of instace id or vhost, for escapping of special character
*  such as & (refering to Bernhard Braun), if these are part of path
* note: url escaping must be done only in cases where '<%=INSTANCEID%>'
*       is in the query string and as form field
* --
    IF set_ffield_name IS SUPPLIED.
      IF data CS '?'.
        SPLIT data AT '?' INTO prefix postfix.
        IF postfix CS '<%=INSTANCEID%>'.
*          form = cl_http_utility=>escape_url( unescaped = form ).
* Use new ABAP XSS Escaping library (see sap note 1644634)
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_url ).
        ENDIF.
      ENDIF.
    ENDIF.

    REPLACE ALL OCCURRENCES OF '<%=INSTANCEID%>'
           IN data WITH form.
  ENDIF.

  IF data CS '<%=VHOST%>'.
    form = cl_http_server=>c_virtual_host.
    CONDENSE form NO-GAPS.
* --
* escaping of virt host, for escapping of special character
*  such as & (refering to Bernhard Braun), if these are part of path
* note: url escaping must be done only in cases where '<%=VHOST%>'
*       is in the query string and as form field
* --
    IF set_ffield_name IS SUPPLIED.
      IF data CS '?'.
        SPLIT data AT '?' INTO prefix postfix.
        IF postfix CS '<%=VHOST%>'.
*          form = cl_http_utility=>escape_url( unescaped = form ).
* Use new ABAP XSS Escaping library (see sap note 1644634)
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_url ).
        ENDIF.
      ENDIF.
    ENDIF.

    REPLACE ALL OCCURRENCES OF '<%=VHOST%>'
           IN data WITH form.
  ENDIF.

* --
* Appending form fields to the document, for redirect and parameter
* set_ffield_name <> space with name sap-ffield_b64
* --
  IF data CS '<%=FORMFIELD' OR
     NOT set_ffield_name IS INITIAL.
* --
*  delete sap-client, sap-user and sap-client, to avoid
*  duplicate settings of form fields in path, becauso of multiple
*  redirects with <%=FORMFIELD%> or <%=FORMFIELD_B64%>
*  common criteria certification:
*   DO NOT delete sap-user, sap-client, sap-language for BSP/System
*   logon procedure for common criteria solution
* --
*    server->request->delete_form_field( name = 'SAP-Client' ).
*    server->request->delete_form_field(
*                name = 'SAP-User' ). "#EC NOTEXT
*    server->request->delete_form_field(
*                name = 'SAP-Language' ). "#EC NOTEXT

    CALL METHOD server->request->get_form_fields_cs
      CHANGING
        fields = l_fields.

    IF data CS '<%=FORMFIELD%>' OR
       set_ffield_name = '1'.

* -- plain text + URL escaping
      form = cl_http_utility=>fields_to_string(
            fields  = l_fields
            encode  = 0 ).

* -- serialization in URL or body (see PREPARE_OTR_DOCUMENT method)
      IF set_ffield_name IS SUPPLIED.
** -- serialization in URL
*        form = cl_http_utility=>escape_url(
*        unescaped  = form ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
        form = escape( val    = form
                       format = cl_abap_format=>e_xss_url ).
      ELSE.
** -- serialization in body
*        form = cl_http_utility=>escape_html(
*        unescaped  = form ).
* Use new ABAP XSS Escaping library (see sap note 1644634)
        form = escape( val    = form
                       format = cl_abap_format=>e_xss_ml ).
      ENDIF.

* -- set form field name in document as plain text
      IF data CS '<%=FORMFIELD%>'.
        REPLACE ALL OCCURRENCES OF '<%=FORMFIELD%>'
               IN data WITH form.
      ENDIF.

* -- set form field name for redirect as plain text
      IF set_ffield_name = '1'.
        IF data CS '?'.
          CONCATENATE data '&' cl_http_server=>co_form_field '='
                   form INTO data.
        ELSE.
          CONCATENATE data '?' cl_http_server=>co_form_field '='
                   form INTO data.
        ENDIF.
      ENDIF.
    ENDIF.

    IF data CS '<%=FORMFIELD_B64%>' OR
       set_ffield_name = '2'.
* -- base 64 encoded for redirect (set_form_field_name) or token
      form = cl_http_utility=>fields_to_string(
         fields  = l_fields
         encode  = 1 ).

* -- set form field name in document as plain text
      IF data CS '<%=FORMFIELD_B64%>'.
        REPLACE ALL OCCURRENCES OF '<%=FORMFIELD_B64%>'
            IN data WITH form.
      ENDIF.

* -- set form field name for redirect with base64 encoding
      IF set_ffield_name = '2'.
        IF data CS '?'.
          CONCATENATE data '&' cl_http_server=>co_form_field_b64 '='
                   form INTO data.
        ELSE.
          CONCATENATE data '?' cl_http_server=>co_form_field_b64 '='
                   form INTO data.
        ENDIF.
      ENDIF.
    ENDIF.


  ENDIF.

* -- Appending content Data to the document
  IF data CS '<%=CDATA%>'.
    form = server->request->get_cdata(  ).
    REPLACE ALL OCCURRENCES OF '<%=CDATA%>' IN data WITH form.
  ENDIF.

  IF data CS '<%=FORM_'.
    SPLIT data AT '<%=FORM_' INTO TABLE itab.
    LOOP AT itab INTO form.
      IF form CS '%>'.
        SPLIT form  AT '%>' INTO token rest.
        form = server->request->get_form_field( name = token ).

        IF set_ffield_name      IS NOT SUPPLIED AND
           l_do_not_html_escape IS INITIAL.
*
* XSS-Attacken verhindern (z. B. /sap/bc/<script></script>/echo)
*
*          form = cl_http_utility=>escape_html( form ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_ml ).
        ENDIF.

        CONCATENATE '<%=FORM_' token '%>' INTO rest.
        REPLACE ALL OCCURRENCES OF rest IN data WITH form.
      ENDIF.
    ENDLOOP.
  ENDIF.

  IF data CS '<%=HEADER_'.
    SPLIT data AT '<%=HEADER_' INTO TABLE itab.
    LOOP AT itab INTO form.
      IF form CS '%>'.
        SPLIT form  AT '%>' INTO token rest.
        form = server->request->get_header_field( name = token ).

        IF set_ffield_name      IS NOT SUPPLIED AND
           l_do_not_html_escape IS INITIAL.
*
* XSS-Attacken verhindern (z. B. /sap/bc/<script></script>/echo)
*
*          form = cl_http_utility=>escape_html( form ).

* Use new ABAP XSS Escaping library (see sap note 1644634)
          form = escape( val    = form
                         format = cl_abap_format=>e_xss_ml ).
        ENDIF.

        CONCATENATE '<%=HEADER_' token '%>' INTO rest.
        REPLACE ALL OCCURRENCES OF rest IN data WITH form.
      ENDIF.
    ENDLOOP.
  ENDIF.

* -- set EPP info in document as plain text
  IF data CS '<%=EPP_'.
    DATA: lv_rid     TYPE epp_root_context_id,
          lv_cid     TYPE epp_connection_id,
          lv_ccnt    TYPE epp_connection_counter,
          lv_tid     TYPE epp_transaction_id,
          lv_epp_hlp TYPE string.
    CALL METHOD get_epp_context_ids
      IMPORTING
        root_context_id    = lv_rid
        connection_id      = lv_cid
        connection_counter = lv_ccnt
        transaction_id     = lv_tid
      EXCEPTIONS
        epp_error          = 1.

    IF data CS '<%=EPP_CTX%>'.
      lv_epp_hlp = |{ lv_rid }_{ lv_cid }_{ lv_ccnt }|.
      REPLACE ALL OCCURRENCES OF '<%=EPP_CTX%>' IN data WITH lv_epp_hlp.
    ENDIF.

    IF data CS '<%=EPP_RID%>'.
      REPLACE ALL OCCURRENCES OF '<%=EPP_RID%>' IN data WITH lv_rid.
    ENDIF.

    IF data CS '<%=EPP_CID%>'.
      REPLACE ALL OCCURRENCES OF '<%=EPP_CID%>' IN data WITH lv_cid.
    ENDIF.

    IF data CS '<%=EPP_CCNT%>'.
      lv_epp_hlp = lv_ccnt.
      REPLACE ALL OCCURRENCES OF '<%=EPP_CCNT%>' IN data WITH lv_epp_hlp.
    ENDIF.

    IF data CS '<%=EPP_TID%>'.
      REPLACE ALL OCCURRENCES OF '<%=EPP_TID%>' IN data WITH lv_tid.
    ENDIF.
  ENDIF.

ENDMETHOD.


method SECURITY_REQUEST .
    data: challenge         type string,
          msg               type string.
    data: sap               type string.
    data: l_status_code     type string,
          l_status_reason   type string.
    data: l_page_attributes type ihttp_service_page.
    data: c_server          type ref to cl_http_server.
    data: l_user_agent_type type i.

    sap = sy-sysid.

    l_page_attributes-kind     = service-kindnfpag.
    l_page_attributes-header   = service-hdrotrnfpag.
    l_page_attributes-body     = service-bodotrnfpag.
    l_page_attributes-redirect = service-urlnfpag.

    l_status_code = '403'."#EC NOTEXT
    l_status_reason = 'Forbidden'.  "#EC NOTEXT
    if service-PROTSEC = 'S'.
* Dieser Service verlangt SSL-Kommunikation (https Protokoll).
        msg = text-s01.
* Service verlangt SSL-Kommunikation.
*      msg = 'This service requires Secure Socket Layer' &
*      ' communication (https protocol).'. "#EC NOTEXT
    else.
* Dieser Service verlangt Client-Zertifikat f√ºr die Anmeldeprozedur.
       msg = text-s02.
*      msg = 'This service requires client certificate' &
*      ' for authentication procedure.'. "#EC NOTEXT
    endif.
*   sy-msgv1 = msg.
    server->request->set_header_field(
        name  = 'sap-icfreason' "#EC NOTEXT
        value = msg ).

    call method server->response->set_header_field
      exporting name = 'SAP-System' "#EC NOTEXT
                value = sap.
    if reply_client is initial.
      call 'C_SAPGPARAM' id 'NAME'  field 'login/system_client'
                         id 'VALUE' field  reply_client.
    endif.
    challenge = reply_client.

* transfer of sap-client only in case of SAP as client
    call method server->request->get_user_agent
      importing
        user_agent_type    = l_user_agent_type.
    if l_user_agent_type = ihttp_user_agent_sapwebapp.
      call method server->response->set_header_field(
          name   = 'SAP-Client' "#EC NOTEXT
          value  = challenge ).
    endif.
*     call method server->response->set_status(
*        code   = 403
*        reason = 'Forbidden' ). "#EC NOTEXT
*
*   call method server->response->set_cdata( data = msg ).
    c_server ?= server.
    c_server->send_service_not_found(
                         status_code   = l_status_code
                         status_reason = l_status_reason
                         page_attributes = l_page_attributes ).

endmethod.


METHOD send_last_page.
  DATA: _entity TYPE REF TO cl_http_entity,
        c_msg   TYPE %_c_pointer,
        conn_name TYPE string.
*
* This method is called both in send_page and proceed_logoff
*
*
* In order to avoid the processing of the registerd last page several times by ICF, namely in
* in the method send_page and proceed_logoff (if logoff method is called) set the indicator
* M_LAST_PAGE_ALREADY_PROCESSED to true
*
  IF m_last_page_already_processed = abap_false.
    m_last_page_already_processed = abap_true.

    _entity ?= response.
    c_msg = _entity->m_c_msg.
    conn_name = 'Me'.

    IF m_last_page-kind IS INITIAL.
* -- read OTR body template
      SYSTEM-CALL plugin
          ID 'HTTP'               VALUE 'SendPageAndReturn' "#EC NOTEXT
          ID 'Name'               VALUE conn_name
          ID 'NoSend'             VALUE 'Y'
          ID 'LastPageHeaderGUID' VALUE m_last_page-header
          ID 'LastPageBodyGUID'   VALUE m_last_page-body
          ID 'LogonTime'          VALUE m_authentication_time
          ID 'LogonMethod'        VALUE authentication_method
          ID 'AuthorizationTime'  VALUE m_authorization_time
          ID 'ExecutionTime'      VALUE m_exe_time
          ID 'MessageOut'         VALUE c_msg
          ID 'RC'                 VALUE send_rc.
    ELSE.
      DATA: l_redirect TYPE string.
      DATA: status     TYPE i.                              "#EC NEEDED
      l_redirect = m_last_page-redirect.

* -- status: 0= 302,1 = 301, 2 = 302
      status = m_last_page-redirect_code.

      SYSTEM-CALL plugin
        ID 'HTTP'  VALUE 'SendPageAndReturn'                "#EC NOTEXT
        ID 'Name'                       VALUE conn_name
        ID 'NoSend'                     VALUE 'Y'
        ID 'RedirectTemplate'           VALUE l_redirect
        ID 'SendPageRedirectStatus'     VALUE STATUS
        ID 'LogonTime'                  VALUE m_authentication_time
        ID 'LogonMethod'                VALUE authentication_method
        ID 'AuthorizationTime'          VALUE m_authorization_time
        ID 'ExecutionTime'              VALUE m_exe_time
        ID 'MessageOut'                 VALUE c_msg
        ID 'RC'                         VALUE send_rc.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD send_response.
  DATA: _entity   TYPE REF TO cl_http_entity,
        c_msg     TYPE %_c_pointer,
        conn_name TYPE string.
  DATA: l_connection_error    TYPE ioprop.
  DATA: l_eventhandler_exists TYPE i.
  DATA: l_access_policy TYPE PFHTTP_SERVER_DEST_STATISTIC-DESTINATION_NAME.
*
* Remark SAML2.0: Removing of security/logon fields should only be avoided when the SAML2.0 logon is active. Becuase
* SAML2.0 logon procedure which is handeld by the class CL_HTTP_EXT_SAML20 needs those security fields (form fields) for
* successful processing of the protocol. Since the SAML2.0 handler is registerd and executed as a public service
* so the public flag is extended to value 2 to indentify this scenario. As soon as the public flag is set (=2) the execution
* of the method DELETE_SECURITY_FIELDS for deleting the security fields is avoided in ICF runtime. But it is required that this method
* has to be called by CL_HTTP_EXT_SAML20  before application gets control. In order to gurantee this behaviour additional
* checks with help of the instance attribute m_del_security_fields_called is done in the method send_response.
*
  IF m_del_security_fields_called = abap_false.
    MESSAGE e000(sr) WITH 'Die Sicherheitsfelder wurden nicht gel√∂scht'(s03).
  ENDIF.
  super->send_response( ).

*
* processing of response message in ICF recorder
*
  IF NOT m_icfrecorder IS INITIAL AND
     c_enable_recording >= ihttp_record_response_status.
    DATA: code          TYPE i,
          reason        TYPE string,
          ccode(8)      TYPE c,
          index         TYPE i,
          body_length   TYPE i,
          header_length TYPE i.
    DATA: icfrec_field  TYPE ihttp_recorder_field.

* should response message be serialized in ICFRECORDER
    IF c_enable_recording >= ihttp_record_response.
      DATA: l_cookie TYPE string.
      CALL METHOD response->get_cookie
        EXPORTING
          name  = 'MYSAPSSO2'
        IMPORTING
          value = l_cookie.
      IF l_cookie IS NOT INITIAL.
        response->delete_cookie_secure( name = 'MYSAPSSO2' ). "#EC NOTEXT
      ENDIF.

      m_icfrecorder-response = response->to_xstring( ).

      IF l_cookie IS NOT INITIAL.
        CALL FUNCTION 'HTTP_SET_SSO2_COOKIE'
          EXPORTING
            server = me
            sso2   = l_cookie.
      ENDIF.

*
* add processed internal header fields (~ fileds) as attributes
*
      CALL METHOD response->get_serialized_message_length
        IMPORTING
          body_length   = body_length
          header_length = header_length.

      LOOP AT m_icfrecorder_fields TRANSPORTING NO FIELDS
              WHERE range = ihttp_recorder_field_range_sol.
        ADD 1 TO index.
      ENDLOOP.
      ADD 1 TO index.

      icfrec_field-range = ihttp_recorder_field_range_sol.
      IF header_length > 0.
        icfrec_field-name  = 'RESPONSE_HEADER_LENGTH'.
        icfrec_field-value = header_length.
        APPEND icfrec_field TO m_icfrecorder_fields.
        ADD 1 TO index.
      ENDIF.

      IF body_length > 0.
        icfrec_field-index = index.
        icfrec_field-name  = 'RESPONSE_BODY_LENGTH'.
        icfrec_field-value = body_length.
        APPEND icfrec_field TO m_icfrecorder_fields.
        ADD 1 TO index.
      ENDIF.

      icfrec_field-index = index.
      icfrec_field-name  = 'DATABASE_RESPONSE_LENGTH'.
      icfrec_field-value = xstrlen( m_icfrecorder-response ).
      APPEND icfrec_field TO m_icfrecorder_fields.
      ADD 1 TO index.
    ENDIF.

    IF NOT m_icfrecorder_fields IS INITIAL.
      SORT m_icfrecorder_fields BY range index name.

      CALL FUNCTION 'ICF_RECORDER_ATTRIBUTES'
        EXPORTING
          action                     = ihttp_icfservice_action_pack
*         from_entries               = l_attributes
          icfrecorder_fields_imp     = m_icfrecorder_fields
*       IMPORTING
*         TO_ENTRIES                 =
        CHANGING
          icfrecord_attributes       = m_icfrecorder-attributes
        EXCEPTIONS
          icf_action_not_supported   = 1
          icf_no_authority           = 2
          icf_incomplete_information = 3
          icf_invalid_attributes     = 4
          OTHERS                     = 5.             "#EC *
    ENDIF.

* set ~status_line
    CALL METHOD response->get_status
      IMPORTING
        code   = code
        reason = reason.
    ccode = code.
    CONDENSE ccode NO-GAPS.
    m_icfrecorder-response_status = ccode.
    CONCATENATE m_icfrecorder-response_status reason INTO
             m_icfrecorder-response_status SEPARATED BY space.
    GET TIME STAMP FIELD m_icfrecorder-response_tstamp.
* stateful session
    IF stateful = co_enabled.
      m_icfrecorder-stateful = 'X'.
    ENDIF.

    MODIFY icfrecorder FROM m_icfrecorder.
    CALL FUNCTION 'DB_COMMIT'.
  ENDIF.

* NGSSO project:
* Message based authentication is done by WS Security and the callback routine
* CL_AUTHENTICATION_PROVIDER=>WS_SECURITY_AUTHN_RESULT has to be called by WS security after their
* logon has been processed. ICF runtime checked whether the callback has been processed before or not.
*
  IF webservice_authentication = abap_true AND
     m_ws_security_logon_done = abap_false.
    MESSAGE e000(sr) WITH 'WebService-Laufzeit arbeitet nicht korrekt.'(ws1).
  ENDIF.

* Note 1962529: create security session on demand (delayed) after R3AUTH authentication
  IF    stateful = co_enabled
    AND ( m_sec_session_pending_local = abap_true  OR m_sec_session_pending_trusted = abap_true ).

    MESSAGE s101(shttp) WITH 'SEND_RESPONSE calling' 'CREATE_SEC_SESS_4_PENDING_REQ'.
    CALL METHOD me->create_sec_sess_4_pending_req( ).
  ENDIF.  "end of note 1962529

*
* logoff should be done (this action deletes MYSAPSSO2) or mysapsso2 is created and should be set
*
  IF m_logoff > 0.
    proceed_logoff( ).

  ELSEIF webservice_response = abap_false  AND  "no SOAP web service
         m_sec_session_restrictions NE 'F' AND  "no full restriction
         m_sec_session_restrictions NE 'P'.     "no partial restriction
*
* Do not set any MYSAPSSO2 or Security Session cookies in context of a webservice response
* or when the creation of Security Sessions has been disabled on request (partial/full restrictions)

* --- Set cookie to transmit SAP Logon Ticket (MYSAPSSO2)
    IF m_sso_cookie IS NOT INITIAL.
      IF m_mysapsso2_created = 2.
        IF ( authentication_method = authmethod_sap AND stateful = co_disabled ).
* Remark: For the security issue, where in case of stateful communication an additional authentication token to the ICF runtime
* should be provided, we have extended the RFC (trusted) system logon method,i.e. destination NONE, in that way that also a
* SSO ticket will be created. But the SSO ticket should only be set, when it is necessary. That is when a
* RFC (trusted) logon take place and the session requires a stateful communication.
          " do nothing
        ELSE.
          CALL FUNCTION 'HTTP_SET_SSO2_COOKIE'
            EXPORTING
              server = me
              sso2   = m_sso_cookie.
        ENDIF.
      ENDIF.
*     release sso data after first response
      FREE m_sso_cookie.
    ENDIF.

* --- Set cookie to transmit Security Session ID (SAP_SESSIONID_<sid>_<client>)
    IF m_security_session_created = abap_true   AND
       m_security_session_cookie IS NOT INITIAL.
      set_security_session_cookie( ).
    ENDIF.
  ENDIF.

* If XSRF cookie is available then send it
  IF m_xsrf_cookie_created = abap_true AND
     m_xsrf_cookie_value IS NOT INITIAL.
    set_xsrf_cookie( ).
  ENDIF.

* Delete session access token(s) from task memory which are marked for deletion (note 1658516)
  IF m_xsrf_token_copy IS NOT INITIAL.
    DELETE c_session_access_registry WHERE marked_for_deletion = abap_true. "#EC CI_SORTSEQ
  ENDIF.

*
* handling of enent IF_HTTP_SERVER~EVENTKIND_CONTEXT_TERMINATION
* in stateful communication, if application has defined
* an event handler
* valid values in ABAP >= 0 oplus for Kernel -1 => old fashion execution
*
  IF stateful = co_enabled.
    SYSTEM-CALL EVENTS GET NUM_HANDLERS
      FOR if_http_server~eventkind_context_termination
      OF INST me INTO l_eventhandler_exists.
* in case of existing event handler, kernel must route
* session termination events an ICF event handler
  ENDIF.


  _entity ?= response.
  c_msg = _entity->m_c_msg.

* -- send response
  conn_name = 'Me'.

*
* with the version > 0 functionality of Send which contained sending
* and releasing the context in one step is divided into SendAndReturn
* plus Finalize steps
*
  IF m_connection_error IS NOT INITIAL.
*
* save last error state raised by send_page (send last page)
* for event handling of session_termination and
* its parameter error_info
*
    l_connection_error = m_connection_error.
  ENDIF.

  IF cl_http_server=>c_kernel_version > 0.
    IF m_access_policy_sent = abap_true.
      system-call plugin
          id 'HTTP'              value 'SendAndReturn'        "#EC NOTEXT
          id 'Name'              value conn_name
          id 'Stateful'          value stateful
          id 'LogonTime'         value m_authentication_time
          id 'LogonMethod'       value authentication_method
          id 'AuthorizationTime' value m_authorization_time
          id 'ExecutionTime'     value m_exe_time
          id 'EventHandlerExist' value l_eventhandler_exists
          id 'MessageOut'        value c_msg
          id 'RC'                value rc.
      ELSE.
        m_access_policy_sent = abap_true.
        l_access_policy = cl_http_security_session_admin=>get_current_access_policy( ). "might be empty
        system-call plugin
            id 'HTTP'              value 'SendAndReturn'        "#EC NOTEXT
            id 'Name'              value conn_name
            id 'Stateful'          value stateful
            id 'LogonTime'         value m_authentication_time
            id 'LogonMethod'       value authentication_method
            id 'AuthorizationTime' value m_authorization_time
            id 'ExecutionTime'     value m_exe_time
            id 'EventHandlerExist' value l_eventhandler_exists
            id 'MessageOut'        value c_msg
            id 'RC'                value rc
            id 'AccessPolicy'      value l_access_policy.
      ENDIF.
* Long jump
  ELSE.
    system-call plugin
        id 'HTTP'       value 'Send'                        "#EC NOTEXT
        id 'Name'       value conn_name
        id 'Stateful'   value stateful
        id 'MessageOut' value c_msg.
* Long jump
  ENDIF.

*
* cleanup session after error during send response
*
  IF rc      <> 0     AND
    stateful = co_enabled.
*
*  set session to stateless
*
    stateful = co_disabled.
    CALL 'ICF_DISPATCH' ID 'HTTP'        FIELD 'K'
                        ID 'KeepContext' FIELD 'N'.
  ENDIF.

*
* handling of enent IF_HTTP_SERVER~EVENTKIND_CONTEXT_TERMINATION
* depending on return code of HttpSendAndReturn
*
  IF rc <> 0.
    m_connection_error-ecode = rc.
  ELSE.
    m_connection_error-ecode = sy-subrc.
  ENDIF.
  IF m_connection_error-ecode <> 0.
    m_connection_error-name = 'CO_COMMUNICATION_ERROR_SEND'.
    CALL FUNCTION 'HTTP_GET_ERRORCODE'
      EXPORTING
        errorcode         = m_connection_error-ecode
      IMPORTING
        errortext         = m_connection_error-emessage
      EXCEPTIONS
        invalid_errorcode = 1
        OTHERS            = 2.                              "#EC *

  ENDIF.

  IF l_connection_error IS NOT INITIAL.
    IF m_connection_error-ecode = 0.
* keep last error info saved before, e. g. error info protocolled
* by send_page and for method raise_event
      m_connection_error = l_connection_error.
    ELSE.
* keep last error info saved before, e. g. error info protocolled
* by send_page and for method raise_event + send error
      CONCATENATE l_connection_error-name ','
                  m_connection_error-name INTO
                  m_connection_error-name.
      CONCATENATE l_connection_error-emessage ','
                  m_connection_error-emessage INTO
                  m_connection_error-emessage.
      m_connection_error-ecode = l_connection_error-ecode.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD send_websocket_handshake.
  DATA: lv_response        TYPE REF TO cl_http_response.
  DATA: l_last_err         TYPE c LENGTH 3.
  DATA: subrc              TYPE sysubrc.
  DATA: lt_callstack       TYPE abap_callstack.
  DATA: lc_websocket_class TYPE string VALUE 'CL_WEBSOCKET_SERVER===========CP'.
  DATA: lc_websocket_method TYPE string VALUE 'CONNECT'.
  DATA: lc_apc_ws_class    TYPE string VALUE 'CL_APC_MANAGER================CP'.
  DATA: lv_valid_call(1)   TYPE c.
  DATA: lo_atra_trace      TYPE REF TO if_atra_trace_internal.

  FIELD-SYMBOLS:
    <ls_callstack>         TYPE abap_callstack_line.

  CLEAR lv_valid_call.
* check the call stack for the valid use case. No other applications and frame are allowed to
* call this method until a decision is made how to integrate an asynchronous send in ICF and
* HTTP framework, respectively.

  CALL FUNCTION 'SYSTEM_CALLSTACK'
    IMPORTING
      callstack = lt_callstack.

  LOOP AT lt_callstack ASSIGNING <ls_callstack>.
    IF ( <ls_callstack>-mainprogram = lc_websocket_class AND
       <ls_callstack>-blockname     CS lc_websocket_method ) OR
       <ls_callstack>-mainprogram   CS lc_apc_ws_class.
      lv_valid_call = 'X'.
      EXIT.
    ENDIF.
  ENDLOOP.

* Send error in case of invalid call
  IF lv_valid_call NE 'X'.
    IF m_connection_error-emessage IS INITIAL.
      MESSAGE e000(sr) WITH m_connection_error-ecode RAISING http_communication_failed.
    ELSE.
      MESSAGE e000(sr) WITH m_connection_error-emessage RAISING http_communication_failed.
    ENDIF.
  ENDIF.

  IF m_send_response_return_called = abap_true.
    RAISE http_processing_failed.
  ENDIF.

  lv_response ?= response.

* activate compression if required
  IF m_compression_done = abap_true.
    CALL METHOD me->set_compression
      EXPORTING
        options = me->co_compress_based_on_mime_type
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc <> 0.
      l_last_err = sy-msgv1.
* failure handling
      CALL METHOD cl_http_server=>trace
        EXPORTING
          line = l_last_err.
    ENDIF.
  ENDIF.

* avoid sending of response via different method repeatedly
  m_send_response_return_called = abap_true.

* NGSSO project:
* Message based authentication is done by WS Security and the callback routine
* CL_AUTHENTICATION_PROVIDER=>WS_SECURITY_AUTHN_RESULT has to be called by WS security after their
* logon has been processed. ICF runtime checked whether the callback has been processed before or not.
* Furthermore in case of processing of Webservice request do not set the MYSAPSSO2 cookie into the response
*
  subrc = send_response( webservice_response       = abap_false
                         webservice_authentication = abap_false ).

  IF subrc  <> 0.
    IF m_connection_error-emessage IS INITIAL.
      MESSAGE e000(sr) WITH m_connection_error-ecode RAISING http_communication_failed.
    ELSE.
      MESSAGE e000(sr) WITH m_connection_error-emessage RAISING http_communication_failed.
    ENDIF.
  ENDIF.

  IF e_atra_activated IS REQUESTED.
    PERFORM get_atra_parameters IN PROGRAM saplhttp_runtime USING e_atra_activated
                                                                  lo_atra_trace
                                                                  e_atra_variant_user
                                                                  e_atra_variant_name
                                                                  e_atra_resolution
                                                                  e_atra_singlerec.
    " close the ATR trace for HTTP handshake phase
    IF e_atra_activated = 1.
      SET RUN TIME ANALYZER OFF.
      IF lo_atra_trace IS BOUND.
        TRY.
            lo_atra_trace->if_atra_trace~stop( ).
          CATCH cx_atra_trace INTO DATA(lx_atra).
            IF c_sap_trace IS NOT INITIAL.
              MESSAGE lx_atra->get_text( ) TYPE 'S'.        "#EC NOTEXT
            ENDIF.
        ENDTRY.
      ENDIF.
    ENDIF.
  ENDIF.
ENDMETHOD.


METHOD set_core_authenticate .
  DATA:    l_client      TYPE sy-mandt,
           l_username    TYPE sy-uname,
           l_password    TYPE xubcode,
           l_language    TYPE sy-langu,
           l_subrc       TYPE i,
           l_sso(4028)   TYPE c.

  DATA: l_session_cookie_value     TYPE string.
  DATA: l_session_cookie_name      TYPE string.
  DATA: l_security_session_user    TYPE username.
  DATA: l_security_session_context TYPE security_context_id.
  DATA: l_pwdstate                 TYPE xupwdstate.
* DATA: l_security_session_authn   TYPE abap_bool.
  DATA: l_sec_error TYPE REF TO cx_http_security_session.
  DATA: l_error_text               TYPE string.
  DATA: l_trace TYPE string.
  DATA: lv_certificate   TYPE xstring.
  DATA: lv_cert_accepted TYPE boolean.
  DATA: l_logon_by_username_password TYPE boolean.

*
* NGSSO
* 1 ) With each logon method, e.g. form field, basic authentication, sso, after a successful logon a security session context and id
* is generated. The security session id is than passed as cookie to the client (browser)
* 2 ) By subsequent call and availability of security session id/cookie the logon method, e.g. form field, basic authentication, sso,
* is chcked. If a logon with this metod and security session id has been done before nor explicit logon via system call
*  CALL 'ICF_DISPATCH'  must be done, otherwise a regular logon is initiated and this method is assigned to the list of logon methods
* associated to the session context id.
* This is with the activated security session mangement:
* First call:  l_security_session_create = 'C' and do a regular logon, e.g. with form field, and create the secuity session cookie
* Second call: l_security_session_create = 'U' only if the logon method is not equivalent to the first call, e.g. basic authenticaten
* Third call:
* 1 ) First Check

* In result of a successful reauthentication a new session will be created.
* If creation of security sessions is suppressed, this does not make sense.
  IF security_session_reauth = abap_true AND do_not_create_security_session = abap_true.
    l_error_text = 'Fehlerhafter Aufruf von SET_CORE_AUTHENTICATE'(ei0).
    l_error_text = |{ l_error_text } (1)|.
    MESSAGE l_error_text TYPE 'E'.
  ENDIF.

* If reauthentication is requested, it is mandatory to provide the username (as constraint).
  IF security_session_reauth = abap_true AND security_session_user IS INITIAL.
    l_error_text = 'Fehlerhafter Aufruf von SET_CORE_AUTHENTICATE'(ei0).
    l_error_text = |{ l_error_text } (2)|.
    MESSAGE l_error_text TYPE 'E'.
  ENDIF.

*
* In case of R3Authentication methods, the logon has been done before. Just establish the security session
*
  IF requested_authmethod <> cl_http_security_session_icf=>co_authnmethod_localhttpcall AND
     requested_authmethod <> cl_http_security_session_icf=>co_authnmethod_trustedsystem.

    CLEAR: subrc, saprc, sso_export.
* assign the rdetermined client and language info for logon
    l_client   = c_client.
    l_language = c_langu.

* perform authentication (as requested by the caller)
    IF password      IS INITIAL AND
       password_encr IS INITIAL AND
       sso_import    IS INITIAL AND
       ccertificate  IS INITIAL AND
       spnego_token  IS INITIAL.
      RAISE invalid_parameter.
    ENDIF.

    IF security_session_reauth = abap_true.
      l_username = security_session_user.
      l_trace = | Reauthentification{ username } -> { security_session_user }|.
      MESSAGE l_trace TYPE 'S'.
    ELSE.
      l_username = username.
    ENDIF.
    IF password_encr IS INITIAL.
      l_password = password.
    ENDIF.

    TRANSLATE l_username TO UPPER CASE.                  "#EC TRANSLANG

    IF ccertificate = 1.
*
* Due to revocation test first check the validity of a certificate and if this check is correct then
*     initiate the logon

      CALL METHOD cl_http_server=>retrieve_certificate
        IMPORTING
          document                 = lv_certificate
        EXCEPTIONS
          no_certificate_available = 1.
      IF sy-subrc = 0.
* Adjustment following function module according to SEC department (Klaus Kiefer)
        CALL FUNCTION 'STRUSTCRT_CHECK_CERTIFICATE'
          EXPORTING
            if_certificate  = lv_certificate
            if_profile      = 'SSL_SERVER'
            IF_CLIENT       = c_client
          IMPORTING
            ef_accepted     = lv_cert_accepted
          EXCEPTIONS
            OTHERS          = 1.
        IF sy-subrc = 0 AND lv_cert_accepted = 'X'.
          CALL 'ICF_DISPATCH' ID 'HTTP'        FIELD 'L'
                              ID 'CLIENT'      FIELD l_client
                              ID 'USER'        FIELD l_username
                              ID 'Certificate' FIELD 'X'
                              ID 'LANGUAGE'    FIELD l_language
                              ID 'SSO2_EXPORT' FIELD l_sso
                              ID 'RETURN_CODE' FIELD l_subrc.
        ELSE.
          l_trace = | STRUSTCRT_CHECK_CERTIFICATE ({ sy-subrc } & { lv_cert_accepted }) returns invalid certificate.|.
          MESSAGE l_trace TYPE 'S'.
*          add_icf_trc `[Prop]; ` l_trace.                       "#EC NOTEXT
          subrc = 1002.
        ENDIF.
      ELSE.
        l_trace = | Retrieve Certificate ({ sy-subrc }) returns no certificate avilable.|.
        MESSAGE l_trace TYPE 'S'.
*          add_icf_trc `[Prop]; ` l_trace.                       "#EC NOTEXT
        subrc = 1002.
      ENDIF.
    ELSEIF NOT sso_import IS INITIAL.
*
* we categorize a SSO ticket in two types:
* SAP logon ticket: SSO ticket is transfered via cookie
* SAP assertion ticket: SSO ticket is transfered via header field.
* A logon via assertion is only initiated, if and only if the SSO
* ticket is received via header field.
* A logon via SSO is triggerd for both types, SAP logon ticket as well
* as SAP assertion ticket.
* Attention: An SSO ticket received via header filed could
* stil be an assirtion ticket,
* since in SM59 (in 712 releases) and in the earliere releases
*(e.g. 640) also SAP logon
* tickets are tranfered via header field.
*
      l_sso = sso_import.

      IF security_session_reauth = abap_true.
*       logon with SAP logon ticket with username constraint
        IF is_assertion_ticket = abap_false.
          CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
                           ID 'CLIENT'      FIELD l_client
                           ID 'USER'        FIELD l_username
                           ID 'LANGUAGE'    FIELD l_language
                           ID 'SSO2_IMPORT' FIELD l_sso
                           ID 'RETURN_CODE' FIELD l_subrc.
        ELSE.
*       logon with SAP assertion ticket with username constraint
          CALL 'ICF_DISPATCH' ID 'HTTP'              FIELD 'L'
                            ID 'CLIENT'              FIELD l_client
                            ID 'USER'                FIELD l_username
                            ID 'LANGUAGE'            FIELD l_language
                            ID 'SSO2_IMPORT'         FIELD l_sso
                            ID 'IS_ASSERTION_TICKET' FIELD 'X'
                            ID 'RETURN_CODE' FIELD l_subrc.
        ENDIF.
      ELSE.
*       logon with SAP logon ticket without username constraint
        IF is_assertion_ticket = abap_false.
          CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
                           ID 'CLIENT'      FIELD l_client
                           ID 'LANGUAGE'    FIELD l_language
                           ID 'SSO2_IMPORT' FIELD l_sso
                           ID 'RETURN_CODE' FIELD l_subrc.
        ELSE.
*       logon with SAP assertion ticket without username constraint
          CALL 'ICF_DISPATCH' ID 'HTTP'              FIELD 'L'
                            ID 'CLIENT'              FIELD l_client
                            ID 'LANGUAGE'            FIELD l_language
                            ID 'SSO2_IMPORT'         FIELD l_sso
                            ID 'IS_ASSERTION_TICKET' FIELD 'X'
                            ID 'RETURN_CODE' FIELD l_subrc.
        ENDIF.
      ENDIF.

    ELSEIF NOT spnego_token IS INITIAL.
      TRY.
*       login with SPNego Token
        CALL METHOD CL_SPNEGO_RUNTIME=>AUTHENTICATE
          EXPORTING
"           I_HTTP_SERVER  = server
            I_SPNEGO_TOKEN = Spnego_token
            I_CLIENT       = l_client
            I_LANGUAGE     = l_language
          IMPORTING
            E_AUTH_RC      = subrc
            E_PWDSTATE     = saprc
            E_LOGON_TICKET = sso_export.   "note 2044027
        CATCH CX_PERSONALIZE_SESSION.
          clear saprc.
          subrc = 999. "LOGON_INTERNAL_ERROR (generic, see trace)
          l_trace = | CL_SPNEGO_RUNTIME=>AUTHENTICATE raised CX_PERSONALIZE_SESSION |.
          MESSAGE l_trace TYPE 'S'.
      ENDTRY.
*      l_trace = | CL_SPNEGO_RUNTIME=>AUTHENTICATE : ticket = { sso_export } |.
*      MESSAGE l_trace TYPE 'S'.
    ELSEIF password_encr IS INITIAL.

      IF security_session_reauth = abap_true AND username <> security_session_user.
*       logon with username and password, under the constraint of a given username
        subrc = 1001.
        l_trace = | User mismatch { username } <> { security_session_user }|.
        MESSAGE l_trace TYPE 'S'.
      ELSE.
*       logon with username and password
        l_logon_by_username_password = abap_true.
        IF sso_export IS REQUESTED.
          CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
                              ID 'CLIENT'   FIELD l_client
                              ID 'USER'     FIELD l_username
                              ID 'PASSWORD' FIELD l_password
                              ID 'LANGUAGE' FIELD l_language
                              ID 'SSO2_EXPORT' FIELD l_sso
                              ID 'RETURN_CODE' FIELD l_subrc.
        ELSE.
          CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
                              ID 'CLIENT'   FIELD l_client
                              ID 'USER'     FIELD l_username
                              ID 'PASSWORD' FIELD l_password
                              ID 'LANGUAGE' FIELD l_language
                              ID 'RETURN_CODE' FIELD l_subrc.
        ENDIF.
      ENDIF.

    ELSE.

      IF security_session_reauth = abap_true AND username <> security_session_user.
*       logon with username and password, under the constraint of a given username
        subrc = 1001.
        l_trace = | User mismatch { username } <> { security_session_user }|.
        MESSAGE l_trace TYPE 'S'.
      ELSE.
        CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'L'
                            ID 'CLIENT'   FIELD l_client
                            ID 'USER'     FIELD l_username
                            ID 'PASSWORDSCR' FIELD password_encr
                            ID 'LANGUAGE' FIELD l_language
                            ID 'RETURN_CODE' FIELD l_subrc.
      ENDIF.
    ENDIF.

    IF subrc IS INITIAL.
      subrc = sy-subrc.   "result of authentication
      IF subrc = 1001 AND l_subrc > 0 AND l_logon_by_username_password = abap_true
         AND authentication_method = authmethod_field.
        subrc = 0.
      ENDIF.
      if sso_export is initial. "note 2044027
        sso_export = l_sso.
      endif.
      saprc = l_subrc.    "password status flag (type XUPWDSTATE)
    ENDIF.
* ===========================

    IF subrc <> 0.
      RETURN.  "do NOT create / update security session
    ENDIF.
  ELSEIF c_authenticated = 0.
*   In case of R3Authentication methods, the logon should have been done before (and successful).
    l_error_text = 'Fehlerhafter Aufruf von SET_CORE_AUTHENTICATE'(ei0).
    l_error_text = |{ l_error_text } (3)|.
    MESSAGE l_error_text TYPE 'E'.
  ENDIF.

* In some cases, e.g. mandatory services with maintained logon data, or web services no security session
* managment activities must be inititiated.
  IF do_not_create_security_session = abap_false.
    IF m_security_session_active = abap_true.
* after a successful logon and an active security session manangement add the logon method to the security session context
      IF security_session_reauth = abap_false.
        TRY.
            CALL METHOD
              cl_http_security_session_icf=>create_session_after_localauth
              EXPORTING
                authentication_method = requested_authmethod
              IMPORTING
                xsrf_token            = m_xsrf_token_from_sec_context  "performance optimization
              RECEIVING
                session_id            = m_security_session_cookie.
          CATCH cx_http_security_session INTO l_sec_error.
            IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
              l_error_text = l_sec_error->get_text( ).
              MESSAGE l_error_text TYPE 'E'.
            ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
              l_error_text = l_sec_error->get_text( ).
              MESSAGE l_error_text TYPE 'E'.
            ENDIF.
        ENDTRY.


* by availabiuity of a security session context add the logon method to the list of security
* session logon methods
      ELSE.  "security_session_reauth = ABAP_TRUE.

        TRY.
            CALL METHOD
              cl_http_security_session_icf=>update_session_after_localauth
              EXPORTING
                current_context_id    = security_session_context
                authentication_method = requested_authmethod
              RECEIVING
                new_session_id        = m_security_session_cookie.
          CATCH cx_http_security_session INTO l_sec_error.
            IF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_runtime_error.
              l_error_text = l_sec_error->get_text( ).
              MESSAGE l_error_text TYPE 'E'.
*              MESSAGE e000(sr) WITH 'Erweiterung von Security Session mi√ülungen (Intern)!'(es3).
            ELSEIF l_sec_error->get_cause( ) = cx_http_security_session=>co_cause_program_error.
              l_error_text = l_sec_error->get_text( ).
              MESSAGE l_error_text TYPE 'E'.
*              MESSAGE e000(sr) WITH 'Erweiterung von Security Session mi√ülungen (Program)!'(es4).
            ENDIF.
        ENDTRY.
      ENDIF.

      IF m_security_session_cookie IS NOT INITIAL.
* Set the indicator for later transport of security session cookie in the method send_response
        m_security_session_created = abap_true.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


method SET_LOGIN_STRUCTURE.
  m_actlogin = service.
endmethod.


METHOD set_no_cache.
  DATA: lv_user_agent_type TYPE i.

* Issue: in case of GET /sap/public/bc/icf/logoff the response is cached in brwoser cach and
*        in intermediary. To hinder the browser to cache the logoff page we have to send cach-control
*        header fields. For Cache-control handilng see
*        http://www.w3.org/protocols/rfc2616/rfc2616-sec14.html#sec14.9 and
*        http://www.markhneedham.com/blog/2008/10/22/tomcat-no-caching-of-pages-for-firefox

* Safari and IE handle no-cache differently from firefox
  request->get_user_agent( IMPORTING user_agent_type = lv_user_agent_type ).
  IF lv_user_agent_type = 5. "user-agen = Firefox
    response->set_header_field( name  = 'Cache-control'     "#EC *
                                 value = 'no-store, no-cache' ). "#EC *
  ELSE.
    response->set_header_field( name  = 'Cache-control'     "#EC *
                                 value = 'no-cache' ).      "#EC *
  ENDIF.

* for all browser type, especially for HTTP/1.0
  CALL METHOD response->set_header_field(
    name = 'Pragma'                                         "#EC NOTEXT
    value = 'no-cache' ).                                   "#EC NOTEXT
  CALL METHOD response->set_header_field(
    name = 'Expires'                                        "#EC NOTEXT
    value = '0' ).                                          "#EC NOTEXT
ENDMETHOD.


METHOD set_security_session_cookie.

  DATA: agent  TYPE string,
        onlyhttps(4) TYPE c,
        onlytohost(4) TYPE c,
        secure TYPE i,
        ssolist_b64 TYPE string.
  DATA: l_subrc TYPE sy-subrc,
        httponly(4) TYPE c.

  IF m_security_session_cookie IS NOT INITIAL.
    agent =  request->get_header_field( 'user-agent' ).


    CALL 'C_SAPGPARAM'
        ID 'NAME' FIELD 'login/ticket_only_by_https'
        ID 'VALUE' FIELD onlyhttps.
    l_subrc = sy-subrc.

* changes for HTTPonly_flag
    CALL 'C_SAPGPARAM'
       ID 'NAME' FIELD 'icf/set_HTTPonly_flag_on_cookies'
       ID 'VALUE' FIELD httponly.

    IF l_subrc = 0 AND onlyhttps = '1'.
      IF httponly EQ '0' OR httponly EQ '2'.
        secure = 17.
      ELSE.
        secure = 1.
      ENDIF.
    ELSE.
      IF httponly EQ '0' OR httponly EQ '2'.
        secure = 16.
      ELSE.
        secure = 0.
      ENDIF.
    ENDIF.

*
* use RFC 2109 specification
*  (http://www.ietf.org/rfc/rfc2109.txt) instead
* of netscape specification
*  (http://wp.netscape.com/newsref/std/cookie_spec.html)
* for setting of cookies on host
*

* Setting of SSO only for server (in case of user switch) ?
    DATA: l_sec_session_name TYPE string.
    CALL METHOD
      cl_http_security_session_icf=>security_sessionid_cookie_name
      EXPORTING
        client      = cl_abap_syst=>get_client( )
      RECEIVING
        cookie_name = l_sec_session_name.


    CALL METHOD response->set_cookie
      EXPORTING
        name   = l_sec_session_name
        path   = '/'
        value  = m_security_session_cookie
        secure = secure.
* reinitialize the inidicator in case of stateful communication
    m_security_session_created = abap_false.
  ENDIF.
ENDMETHOD.


METHOD set_xsrf_cookie.
  DATA: lv_onlyhttps      TYPE c LENGTH 4,
        lv_secure         TYPE i,
        lv_subrc          type sysubrc.
  data: lv_xsrf_cookie_name type string.

  IF m_xsrf_cookie_value IS NOT INITIAL.
    CALL 'C_SAPGPARAM'
        ID 'NAME' FIELD 'login/ticket_only_by_https'
        ID 'VALUE' FIELD lv_onlyhttps.
    lv_subrc = sy-subrc.

* per default set HTTPonly flag for XSRF cookie
    IF lv_subrc = 0 AND lv_onlyhttps = '1'.
      lv_secure = 17.
    ELSE.
      lv_secure = 16.
    ENDIF.

* Remark: As several SAP systems could be run on the same hostz therefore XSRF cookie has to contain at least system id
* to avoid ambiguities. The cookie is set for the host.
    CONCATENATE if_http_form_fields_sap=>sap_xsrf '_' sy-sysid '_' sy-mandt INTO lv_xsrf_cookie_name.

    CALL METHOD response->set_cookie
      EXPORTING
        name   = lv_xsrf_cookie_name
        value  = m_xsrf_cookie_value
        path   = '/'
        secure = lv_secure.
  ENDIF.

  m_xsrf_cookie_created = abap_false.

ENDMETHOD.


METHOD trigger_xhr_logon_via_iframe.
*
*  This method should be called if a XMLHttpRequest (XHR) failed to logon
*  (indicator: http header field 'X-Requested-With: XMLHttpRequest received)
*
*   - Set http header 'X-XHR-Logon: accept="iframe", realm=...'
*     (IF_HTTP_HEADER_FIELDS=>X_XHR_LOGON)
*   - Return status code 403
*
* The XHR client is supposed to create an iframe and to resubmit the request
* (without the XHR header field but with the form field 'xhr-logon', instead).

  DATA: l_codepage  TYPE string.
  DATA: l_realm     TYPE string.
  DATA: l_challenge TYPE string.
  DATA: lr_entity   TYPE REF TO cl_http_entity.

  me->delete_security_fields( ).

  IF c_client IS INITIAL. "should never happen ..
    MESSAGE e101(shttp) WITH 'FINALIZE_XHR_LOGON_VIA_IFRAME' 'c_client IS INITIAL'. "#EC NOTEXT
    RETURN.
  ENDIF.

  me->response->set_status( code   =  403
                            reason =  if_http_status=>reason_403 ).

* in unicode system conversion to utf-8
  IF cl_abap_char_utilities=>charsize = 1.
    CALL METHOD cl_http_utility=>get_logon_charset
      IMPORTING
        id                = l_codepage
      EXCEPTIONS
        charset_not_found = 1
        OTHERS            = 2.
    IF sy-subrc <> 0.
      CLEAR l_codepage.
    ENDIF.
  ENDIF.

  IF l_codepage IS INITIAL.
    l_codepage = 'utf-8'.                                                      "#EC NOTEXT
  ENDIF.
  CONCATENATE 'text/html; charset=' l_codepage INTO l_codepage.                "#EC NOTEXT

  me->response->set_header_field( name  = if_http_header_fields=>content_type  "'Content-Type'
                                  value = l_codepage ).

* Cache control
  me->response->set_header_field( name  = if_http_header_fields=>cache_control "'Cache-Control'
                                  value = 'no-cache, no-store' ).              "#EC NOTEXT

  l_realm = get_xhr_logon_realm( c_client ).
  CONCATENATE 'accept=' '"iframe"' INTO l_challenge.                          "#EC NOTEXT
  CONCATENATE l_challenge ', realm="' l_realm '"' INTO l_challenge.           "#EC NOTEXT

  me->response->set_header_field( name  = if_http_header_fields=>x_xhr_logon  "'X-XHR-Logon'
                                  value = l_challenge ).

ENDMETHOD.


METHOD validate_login_xsrf_token.
*------------------------------------------------------------------------------------
*  This method is in the responsibility of the Security Development team.
*  Use message component BC-SEC-LGN to report problems.
*  Author:   D021767
*  Date:     2011-04-27
*------------------------------------------------------------------------------------

  DATA: l_created  TYPE timestamp,
        l_now      TYPE timestamp,
        l_secs     type tzntstmpl,
        l_hmac_b64 TYPE hash512_base_64.

  result = abap_false.

  CALL FUNCTION 'CALCULATE_HMAC_FOR_CHAR'
    EXPORTING
*     ALG                          = 'SHA2'
      data                         = cookie_value
*     LENGTH                       = 0
      client_independent           = 'X'
*     RECORD_NUMBER                = '00'
*     KEY_MUST_EXIST               = ' '
    IMPORTING
*     HMAC                         =
*     HMACLEN                      =
*     HMACX                        =
*     HMACXLEN                     =
      hmacbase64                   = l_hmac_b64  "ALPHABET_UC_BASE64
*     HMACBASE64LEN                =
    EXCEPTIONS
      unknown_alg                  = 1
      param_length_error           = 2
      internal_error               = 3
      malloc_error                 = 4
      abap_caller_error            = 5
      base64_error                 = 6
      calc_hmac_error              = 7
      rsec_record_not_found        = 8
      rsec_record_access_denied    = 9
      rsec_secstore_access_denied  = 10
      rsec_error                   = 11
      param_missing                = 12
      rng_error                    = 13
      record_number_error          = 14
      rsec_system_data_changed     = 15
      rsec_system_data_changed_sid = 16
      OTHERS                       = 17.
  IF sy-subrc <> 0.
    IF sy-subrc > 7.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING secstore_error.
    ELSE.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        RAISING internal_error.
    ENDIF.
  ENDIF.

  TRANSLATE l_hmac_b64 USING '+-/_'. "ALPHABET_UC_BASE64URL
  CHECK formfield_value = l_hmac_b64.

  l_created = cookie_value(14).
  GET TIME STAMP FIELD l_now.
  l_secs = cl_abap_tstmp=>subtract( tstmp1 = l_now  tstmp2 = l_created ).
  result = boolc( l_secs < 300 ).

ENDMETHOD.


METHOD ws_security_authn_result.
  DATA: lv_login_done  TYPE sydebug.

  IF authentication_succeeded = abap_true.
* Is user really logged on ?
    CALL FUNCTION 'RFC_LOGON_INFO'
      IMPORTING
        rfc_login_complete = lv_login_done
      EXCEPTIONS
        OTHERS             = 1.

    IF sy-subrc <> 0 OR lv_login_done <> 'Y'.
      RAISE logon_not_completed.
    ENDIF.

* Set logon as comleted
    c_authenticated = 1.
*
* activate debugging as soon as possible, and if only if the logon is succeeded
*
    IF c_debugging_possible = 'Y'.
      CALL METHOD debugging( ).
    ENDIF.
  ENDIF.
*
* Possible WS securitylogon methods:
* - WSS Username Token : AUTHMETHOD_FIELD/AUTHMETHOD_BASIC (to be clarified)
* - SAML 1.1 Assertion : AUTHMETHOD_SAML
* - X.509 certificate : AUTHMETHOD_CERTIFICATE
* - SAML 1.1 Assertion issued by a central Security Token Service : AUTHMETHOD_SAML
*
  IF authentication_succeeded = abap_true AND
     authentication_method <> authmethod_basic       AND
     authentication_method <> authmethod_certificate AND
     authentication_method <> authmethod_saml.
    RAISE information_mismatch.
  ENDIF.



* Specify the logon method for application and tracing
  me->authentication_method = authentication_method.
* Remeber that this call has been done, otherwise process an error in send_response method
  m_ws_security_logon_done = abap_true.

ENDMETHOD.
ENDCLASS.