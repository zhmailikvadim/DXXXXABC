class CL_IDENTITY definition
  public
  final
  create private

  global friends CL_ACMTEST_HELPER
                 CL_ACMTST_AT_BUSIDB .

public section.
  type-pools SZADR .

  interfaces IF_IDENTITY_DBMS_USER .
  interfaces IF_IDENTITY_ADDRESS .
  interfaces IF_IDENTITY .
  interfaces IF_IDENTITY_CUA .
  interfaces IF_IDENTITY_PASSWORD .
  interfaces IF_IDENTITY_PERSON .
  interfaces IF_IDENTITY_CERTMAP .
  interfaces IF_IDENTITY_ESI_PERSON .

  types:
    begin of ty_timestamp
  ,datum type sy-datum
  ,uzeit type sy-uzeit
  ,uname type sy-uname
  ,timestamp type timestamp
,end of    ty_timestamp .
  types:
    tt_timestamp type standard table of ty_timestamp .

  constants CO_USER_LOCAL type USR02-RESERVED value 11 ##NO_TEXT.
  constants CO_TCODE_SINGLE type SUID_TCODE_MODE value 'S' ##NO_TEXT.
  constants CO_TCODE_MASS type SUID_TCODE_MODE value 'M' ##NO_TEXT.
  constants CO_TCODE_OWN_USER type SUID_TCODE_MODE value 'O' ##NO_TEXT.

  class-methods AFTER_COMMIT
    importing
      !IT_BNAME type SUID_TT_BNAME optional
    raising
      CX_SUID_IDENTITY .
  class-methods AFTER_REJECTED_SAVE .
  methods AUTH_CHECK_SINGLE
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IV_OPERATION type SUID_NODE_ACTIVITY
      !IV_SUBSYSTEM type RFCRCVSYS optional
      !IV_ROLE type USLOCAGR-AGR_NAME optional
      !IV_PROFILE type XUPROFILE optional
      !IV_INITIAL_AS_DUMMY type SESF_BOOLEAN default SPACE
    exporting
      !ES_MSG type SYMSG
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_ALIAS
    importing
      !IV_BNAME type XUBNAME optional
      !IV_ALIAS type USALIAS optional
    exporting
      !EV_BNAME type XUBNAME
      !EV_ALIAS type USALIAS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER .
  class-methods CHECK_BEFORE_SAVE
    exporting
      !EV_REJECTED type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_PROFILES
    importing
      !IT_PROFILES type SUID_TT_NODE_CUA_PROFILES
      !IV_CLASS type XUCLASS default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_PROFILES type SUID_TT_NODE_CUA_PROFILES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_ROLES
    importing
      !IT_ROLES type SUID_TT_NODE_CUA_ROLES
      !IV_GET_ROLE_DETAILS type SESF_BOOLEAN default SPACE
      !IV_GET_ROLE_MEMBERS type SESF_BOOLEAN default SPACE
      !IV_CLASS type XUCLASS default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_ROLES type SUID_TT_NODE_CUA_ROLES
      !ET_ROLE_DETAILS type SUID_TT_NODE_CUA_ROLE_DETAILS
      !ET_ROLE_MEMBERS type SUID_TT_NODE_CUA_ROLE_MEMBERS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_SYSTEMS
    importing
      !IT_CUA_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
      !IV_CLASS type XUCLASS default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_CUA_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_UCLASSES
    importing
      !IT_CUA_UCLASSES type SUID_TT_NODE_CUA_UCLASSES
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_CUA_UCLASSES type SUID_TT_NODE_CUA_UCLASSES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_DEFAULTS
    importing
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    changing
      !CS_DEFAULTS type SUID_ST_NODE_DEFAULTS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_GROUPS
    importing
      !IT_GROUPS type SUID_TT_NODE_GROUPS
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_GROUPS type SUID_TT_NODE_GROUPS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_LOGONDATA
    importing
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
      !IV_MODUS type SUID_TA_MODUS optional
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    changing
      !CS_LOGONDATA type SUID_ST_NODE_LOGONDATA
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_ORGANISATION
    importing
      !IV_GET_LOCATION type SESF_BOOLEAN default SPACE
      !IV_GET_ORGANIZATION_NAME type SESF_BOOLEAN default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ES_LOCATION type SUID_ST_NODE_LOCATION
      !ES_ORGANIZATION_NAME type SUID_ST_NODE_ORGANIZATION_NAME
    changing
      !CS_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_PARAMETERS
    importing
      !IT_PARAMETERS type SUID_TT_NODE_PARAMETERS
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_PARAMETERS type SUID_TT_NODE_PARAMETERS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_PROFILES
    importing
      !IT_PROFILES type SUID_TT_NODE_PROFILES
      !IV_CLASS type XUCLASS default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_PROFILES type SUID_TT_NODE_PROFILES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_REFERENCE_USER
    importing
      !IV_CLASS type XUCLASS default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    changing
      !CS_REFERENCE_USER type SUID_ST_NODE_REFERENCE_USER
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_ROLES
    importing
      !IT_ROLES type SUID_TT_NODE_ROLES
      !IV_GET_ROLE_DETAILS type SESF_BOOLEAN default SPACE
      !IV_GET_ROLE_MEMBERS type SESF_BOOLEAN default SPACE
      !IV_CLASS type XUCLASS default SPACE
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_ROLES type SUID_TT_NODE_ROLES
      !ET_ROLE_DETAILS type SUID_TT_NODE_ROLE_DETAILS
      !ET_ROLE_MEMBERS type SUID_TT_NODE_ROLE_MEMBERS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_ROOT
    importing
      !IV_MODUS type SUID_TA_MODUS
      !IT_BNAME type SUID_TT_BNAME
      !IV_NODE_NAME type SUID_NODE_NAME default IF_IDENTITY_DEFINITION=>GC_NODE_ROOT
    exporting
      !ET_BNAME_NOT_AUTHORIZED type SUID_TT_BNAME
      !ET_BNAME_NOT_EXIST type SUID_TT_BNAME
      !ET_BNAME_EXIST type SUID_TT_BNAME
      !ET_BNAME type SUID_TT_BNAME
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_TECHUSER_DATA
    importing
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    changing
      !CS_TECH_USER_DATA type SUID_ST_NODE_TECH_USER_DATA
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_UCLASS
    exporting
      !EO_ANONYMOUS_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    changing
      !CS_UCLASS type SUID_ST_NODE_UCLASS
    raising
      CX_SUID_IDENTITY .
  class-methods CLASS_CONSTRUCTOR .
  class-methods CLEANUP
    importing
      !IT_BNAME type SUID_TT_BNAME optional
    preferred parameter IT_BNAME
    raising
      CX_SUID_IDENTITY .
  methods CONVERT_USER_TO_IDENTITY
    importing
      !IS_PERSON type SUID_ST_NODE_PERSON
      !IV_NEWPERSON type SESF_BOOLEAN default SPACE
      !IV_IDADTYPE type SUIDADTYPE optional
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods COPY
    importing
      !IV_ID_SOURCE type XUBNAME
      !IV_ID_DESTINATION type XUBNAME
      !IV_COPY_ADDRESS type CHAR1 default SPACE
      !IV_COPY_DEFAULTS type CHAR1 default SPACE
      !IV_COPY_PARAMETERS type CHAR1 default SPACE
      !IV_COPY_REFUSER type CHAR1 default SPACE
      !IV_COPY_ROLES type CHAR1 default SPACE
      !IV_COPY_PROFILES type CHAR1 default SPACE
      !IV_COPY_GROUPS type CHAR1 default SPACE
      !IV_COPY_PERSONALIZATION type CHAR01 default SPACE
      !IV_COPY_UCLASS type CHAR1 default SPACE
      !IV_COPY_EASY_ACCESS type CHAR1 default SPACE
      !IV_COPY_DOCUMENTATION type CHAR01 default SPACE
    exporting
      !EV_NODE_ROOT_SOURCE type SUID_ST_NODE_ROOT
      !EV_NODE_ROOT_DESTINATION type SUID_ST_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods CREATE
    importing
      !IT_BNAME type SUID_TT_BNAME optional
      !IT_IDENTITY type SUID_TT_IDENTITY optional
      !IV_CUA_TS_LOCAL_USER type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_CUA_TS_FORCE_MODIFACTION type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_CUA_CENTRAL_SYSTEM_ASSIGN type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
      !IV_SET_OPTIMISTIC_ENQUEUE_LOCK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods DELETE
    importing
      !IT_BNAME type SUID_TT_BNAME optional
      !IT_IDENTITY_GUID type SUID_TT_IDENTITY_GUID optional
      !IV_REPEAT_ENQ type SESF_BOOLEAN default SPACE
      !IV_DELETE_DBMS_USER type SESF_BOOLEAN default SPACE
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods DELETE_INVALID_CUA_PROF_ASSIGN
    importing
      !IT_DEL_USERS type SUID_TT_BNAME
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_INVALID_ASSIGNMENT type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods DELETE_INVALID_CUA_ROLE_ASSIGN
    importing
      !IT_DEL_USERS type SUID_TT_BNAME
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_INVALID_ASSIGNMENT type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods DELETE_INVALID_PROF_ASSIGNMENT
    importing
      !IT_DEL_USERS type SUID_TT_BNAME
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_INVALID_ASSIGNMENT type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods DELETE_INVALID_ROLE_ASSIGNMENT
    importing
      !IT_DEL_USERS type SUID_TT_BNAME
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_INVALID_ASSIGNMENT type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods DISTRIBUTE
    importing
      !IT_BNAME_SECTION_DISTR type SUID_TT_CUA_USER_SYST_DISTR optional
      !IT_BNAME_COMPLETE_DISTR type SUID_TT_BNAME optional
      !IV_UPDATE_TASK type XFLAG default IF_IDENTITY=>CO_TRUE
    exporting
      !ET_BNAME_DISTRIBUTED type SUID_TT_CUA_USER_SYST_DISTR
      !ET_BNAME_SECT_NOT_DISTRIBUTED type SUID_TT_CUA_USER_SYST_DISTR
      !ET_BNAME_NOT_INSTANTIATED type SUID_TT_BNAME
      !ET_MESSAGES type IF_SUID_MSG_BUFFER=>TT_MESSAGES
    raising
      CX_SUID_IDENTITY .
  class-methods DO_CHECK
    exporting
      !EV_REJECTED type SESF_BOOLEAN
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods DO_SAVE
    importing
      !IV_UPDATE_TASK type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
    exporting
      !ES_TIMESTAMP type CL_IDENTITY=>TY_TIMESTAMP
      !EV_REJECTED type SESF_BOOLEAN
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods FINALIZE
    exporting
      !EV_REJECTED type SESF_BOOLEAN
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods GET_CUA_MODE
    importing
      !IV_BNAME type XUBNAME
    exporting
      !EV_CUA_MODE type SUID_CUA_MODE .
  methods GET_CURRENT_INITIAL_PWD
    exporting
      !ES_INITIAL_PASSWORD type SUID_ST_INITIAL_PASSWORD
      !ET_CUA_INITIAL_PASSWORDS type SUID_TT_INITIAL_PASSWORD
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_LOCKSTATUS
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !EV_LOCKED_BY_ADMIN type CHAR01
      !EV_LOCKED_BY_GLOBAL_ADMIN type CHAR01
      !EV_LOCKED_BY_FAILED_LOGON type CHAR01
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  class-methods NODES_PREFETCH
    importing
      !IT_BNAME type SUID_TT_BNAME
      !IV_PREFETCH_ALL type XFELD optional
      !IT_NODES_PREFETCH type SUID_TT_NODE optional
    raising
      CX_SUID_IDENTITY .
  methods REMOVE_CUA_LOCAL_USER_FLAG
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  class-methods RETRIEVE
    importing
      !IT_BNAME type SUID_TT_BNAME optional
      !IT_IDENTITY_GUID type SUID_TT_IDENTITY_GUID optional
      !IV_ENQUEUE_MODE type SESF_EDIT_MODE optional
      !IT_NODES_PREFETCH type SUID_TT_NODE optional
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_BNAME_NOT_EXIST type SUID_TT_BNAME
      !ET_BNAME_NOT_AUTHORIZED type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods RETRIEVE_FOR_UPDATE
    importing
      !IT_BNAME type SUID_TT_BNAME optional
      !IT_IDENTITY_GUID type SUID_TT_IDENTITY_GUID optional
      !IV_ENQUEUE_MODE type SESF_EDIT_MODE default IF_IDENTITY=>CO_ENQUEUE_MODE_EXCLUSIVE
      !IT_NODES_PREFETCH type SUID_TT_NODE optional
      !IV_NODE_NAME type SUID_NODE_NAME default IF_IDENTITY_DEFINITION=>GC_NODE_ROOT
      !IV_SET_OPTIMISTIC_ENQUEUE_LOCK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_REPEAT_ENQ type SESF_BOOLEAN default SPACE
      !IV_CUA_TS_FORCE_MODIFACTION type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_BNAME_NOT_EXIST type SUID_TT_BNAME
      !ET_BNAME_NOT_AUTHORIZED type SUID_TT_BNAME
      !ET_BNAME_LOCKED type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods RETRIEVE_FOR_UPDATE_OWN_USER
    importing
      !IV_ENQUEUE_MODE type SESF_EDIT_MODE default IF_IDENTITY=>CO_ENQUEUE_MODE_EXCLUSIVE
      !IV_REPEAT_ENQ type SESF_BOOLEAN default SPACE
      !IV_CUA_TS_FORCE_MODIFACTION type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods RETRIEVE_OWN_USER
    importing
      !IV_ENQUEUE_MODE type SESF_EDIT_MODE optional
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods SAVE
    importing
      !IV_UPDATE_TASK type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
    exporting
      !ES_TIMESTAMP type CL_IDENTITY=>TY_TIMESTAMP
      !EV_REJECTED type SESF_BOOLEAN
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods SET_CUA_MODE
    importing
      !IV_MODE type SUID_CUA_MODE
      !IV_SOURCE_SYSTEM type USZBVSYS-SUBSYSTEM optional .
  methods SET_EXTENDED_CUA_ROLES
    importing
      !IT_ROLES type SUID_TT_NODE_CUA_ROLES
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NODE_CUA_ROLES type SUID_TT_NODE_CUA_ROLES
    raising
      CX_SUID_IDENTITY .
  methods SET_EXTENDED_ROLES
    importing
      !IT_ROLES type SUID_TT_NODE_ROLES
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NODE_ROLES type SUID_TT_NODE_ROLES
    raising
      CX_SUID_IDENTITY .
  class-methods SET_OPTIMISTIC_TO_EXCL_LOCK
    importing
      !IT_BNAME type SUID_TT_BNAME
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  class-methods SET_PERSDATA_MODIFIED_FLAG
    importing
      !IV_BNAME type XUBNAME .
  methods SET_PFUD_PROFILES
    importing
      !IT_PROFILES type SUID_TT_NODE_PROFILES
      !IT_ROLES type SUID_TT_NODE_ROLES optional
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods SET_PFUD_ROLES
    importing
      !IT_ROLES type SUID_TT_NODE_ROLES
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  class-methods SET_TCODE_MODE
    importing
      !IV_TCODE_MODE type SUID_TCODE_MODE .
  class-methods SET_APPLREFS_MODIFIED_FLAG
    importing
      !IV_BNAME type XUBNAME
      !IV_MODIFIED type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE .
protected section.
*"* protected components of class CL_IDENTITY
*"* do not include other source files here!!!

  class-methods SET_UNIT_TEST_MODE .
  class-methods RESET_UNIT_TEST_MODE .
private section.

  types:
    begin of ty_control
    ,bname type xubname
    ,idref type ref to cl_identity
 ,end   of ty_control .
  types:
    tt_control type standard table of ty_control .
  types:
    begin of ty_instance_manager
  , bname              type xubname
  , status             type suid_ta_status
  , modus              type suid_ta_modus
  , enqmode            type sesf_edit_mode "suid_enqueue_mode
  , flg_own_data       type char01
  , flg_pers_modified  type char01
  , flg_appref_modified type char01
  , easy_access_copied type suid_st_bname_copy  "SAP Easy Access Menu copied from source user
  , class_checked      type sesf_boolean        " Create mode: Usergroup in buffer is checked
*         Node Status
  , sn_logondata       type suid_node_status
  , sn_defaults        type suid_node_status
  , sn_snc             type suid_node_status
  , sn_password        type suid_node_status
  , sn_pwdhash         type suid_node_status
  , sn_lockdata        type suid_node_status
  , sn_certmap         type suid_node_status
  , sn_roles           type suid_node_status
  , sn_profiles        type suid_node_status
  , sn_parameter       type suid_node_status
  , sn_groups          type suid_node_status
  , sn_uclass          type suid_node_status
  , sn_cua_systems     type suid_node_status
  , sn_cua_roles       type suid_node_status
  , sn_cua_profiles    type suid_node_status
  , sn_cua_uclass      type suid_node_status
  , sn_cua_password    type suid_node_status
  , sn_refuser         type suid_node_status
  , sn_tech_user       type suid_node_status
  , sn_tech_user_data  type suid_node_status
  , sn_organization    type suid_node_status
  , sn_person_name     type suid_node_status
  , sn_workplace       type suid_node_status
  , sn_person          type suid_node_status
  , sn_telephone       type suid_node_status
  , sn_facsimile       type suid_node_status
  , sn_email           type suid_node_status
  , sn_web             type suid_node_status
  , sn_telex           type suid_node_status
  , sn_teletex         type suid_node_status
  , sn_remote_mail     type suid_node_status
  , sn_x400            type suid_node_status
  , sn_printer         type suid_node_status
  , sn_ssf             type suid_node_status
  , sn_pager           type suid_node_status
  , sn_dbms_user       type suid_node_status
  , sn_dbms_roles      type suid_node_status
  , sn_docu            type suid_node_status
, end   of ty_instance_manager .
  types:
    begin of ty_error_systems
    , subsystem   type uszbvsys-subsystem
    , return_code type sy-subrc
    , msg         type symsg
  , end of ty_error_systems .
  types:
    tt_error_systems type standard table of ty_error_systems .
  types:
    begin of ty_cua_user_syst_distr
    , bname type xubname
    , subsystem type uszbvsys-subsystem
    , usersection(1)     type c
    , profilesection(1)  type c
    , actgrpsection(1)   type c
    , global_lock(1)     type c
    , password(1)        type c
    , end of ty_cua_user_syst_distr .
  types:
    tt_cua_user_syst_distr type standard table of ty_cua_user_syst_distr .
  types:
    begin of ty_map_bup_fields
    , id_field         type suid_node_field
    , bup_field        type string  "suid_node_field
    , id_node          type suid_node_name
    , end of ty_map_bup_fields .
  types:
    tt_map_bup_fields type standard table of ty_map_bup_fields .
  types:
    begin of ty_cua_data_distribute_back
      , logondatax   type  bapilogonx
      , defaultsx    type  bapidefax
      , parameterx   type  bapiparamx
      , addressx     type  bapiaddr3x
      , companyx     type  bapiuscomx
      , addcomx      type  bapiadcomx
  , end of ty_cua_data_distribute_back .
  types:
    begin of ty_cua_data_distribute
    , user_masterdata(1) type c
    , profiles(1)        type c
    , roles(1)           type c
    , global_lock(1)     type c
    , password(1)        type c
    , license_data(1)    type c
    , cua_systems(1)     type c
    , end of ty_cua_data_distribute .
  types:
    begin of ty_cua_user_transfer
    , active        type sesf_boolean
    , source_system type uszbvsys-subsystem
    , end of ty_cua_user_transfer .

  constants CO_APPL_FIELD type AD_APPLFLD value 'PERSNUMBER' ##NO_TEXT.
  constants CO_APPL_TABLE type AD_APPLTAB value 'USR21' ##NO_TEXT.
  constants CO_CUA_CHILD_COPY type SUID_CUA_MODE value 14 ##NO_TEXT.
  constants CO_CUA_CREATE type SUID_CUA_MODE value 11 ##NO_TEXT.
  constants CO_CUA_LOCAL_CREATE type SUID_CUA_MODE value 15 ##NO_TEXT.
  constants CO_CUA_NOT_TRANSFERRED type SUID_CUA_MODE value 12 ##NO_TEXT.
  constants CO_CUA_RESERVED type SUID_CUA_MODE value 13 ##NO_TEXT.
  constants CO_CUST_ASSIGNMENT_EXIT type SSM_ID value 'Z_USERS_TRANSFER' ##NO_TEXT.
  constants CO_LOCK type CHAR01 value 'L' ##NO_TEXT.
  constants CO_MARKED_ROLE type C value 'X' ##NO_TEXT.
  constants CO_OWN_DATA type CHAR01 value 'O' ##NO_TEXT.
  constants CO_PERSGROUP type AD_GROUP_P value 'BC01' ##NO_TEXT.
  constants CO_PROFILE_LENGTH type INT4 value 12 ##NO_TEXT.
  constants CO_PROFILE_MAXVALUE type INT4 value 312 ##NO_TEXT.
  constants CO_PROFILE_OFFSET type INT4 value 2 ##NO_TEXT.
  constants CO_SAP_ASSIGNMENT_EXIT type SSM_ID value 'SAP_USERS_TRANSFER' ##NO_TEXT.
  constants CO_TRX_BP type CHAR01 value 'B' ##NO_TEXT.
  constants CO_TRX_USER type CHAR01 value 'U' ##NO_TEXT.
  constants CO_UNLOCK type CHAR01 value 'U' ##NO_TEXT.
  constants CO_USERTYPE_DIALOG type XUUSTYP value 'A' ##NO_TEXT.
  constants CO_USERTYPE_SERVICE type XUUSTYP value 'S' ##NO_TEXT.
  constants CO_USERTYPE_REFERENCE type XUUSTYP value 'L' ##NO_TEXT.
  constants CO_USERTYPE_SYSTEM type XUUSTYP value 'B' ##NO_TEXT.
  class-data GO_ANONYMOUS_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER .
  class-data GO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER .
  class-data GO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER .
  class-data GO_PERSISTENCE type ref to CL_IDENTITY_PERSISTENCE .
  class-data GS_CUA_USER_TRANSFER type TY_CUA_USER_TRANSFER .
  class-data GT_CONTROL type TT_CONTROL .
  class-data GV_ACTIVE_BADI_IDENTITY_UPDATE type SESF_BOOLEAN .
  class-data GV_CUA_ACTIVE type CHAR01 .
  class-data GV_CUA_CENTRAL type CHAR01 .
  class-data GV_CUA_CHILD type CHAR01 .
  class-data GV_CLASS_IS_REQUIRED type SESF_BOOLEAN .
  class-data GV_EARLYWATCHCLIENT type SESF_BOOLEAN .
  class-data GV_IDOC_PROCESSING type CHAR01 .
  class-data GV_MACRO_KEY type SUID_NODE_KEY .
  class-data GV_UPG_IS_SHADOW_SYSTEM type SESF_BOOLEAN .
  data MS_MANAGER type TY_INSTANCE_MANAGER .
  data MS_SEGMENT_ADDRESS type SUID_ST_SEGMENT_ADDRESS .
  data MS_SEGMENT_AUDITLOG type SUID_ST_SEGMENT_AUDITLOG .
  data MS_SEGMENT_CUA_ACT_DISTR type SUID_ST_SEGMENT_CUA_ACT_DISTR .
  data MS_SEGMENT_CUA_PASSWORD type SUID_ST_SEGMENT_CUA_PASSWORD .
  data MS_SEGMENT_CUA_PROFILES type SUID_ST_SEGMENT_CUA_PROFILES .
  data MS_SEGMENT_CUA_ROLES type SUID_ST_SEGMENT_CUA_ROLES .
  data MS_SEGMENT_CUA_SYSTEMS type SUID_ST_SEGMENT_CUA_SYSTEMS .
  data MS_SEGMENT_CUA_UCLASSES type SUID_ST_SEGMENT_CUA_UCLASSES .
  data MS_SEGMENT_CUA_USER_PROT type SUID_ST_SEGMENT_CUA_USER_PROT .
  data MS_SEGMENT_DEFAULTS type SUID_ST_SEGMENT_DEFAULTS .
  data MS_SEGMENT_GROUPS type SUID_ST_SEGMENT_GROUPS .
  data MS_SEGMENT_HEADER type SUID_ST_SEGMENT_HEADER .
  data MS_SEGMENT_HEADER_HIST type SUID_ST_SEGMENT_HEADER_HIST .
  data MS_SEGMENT_PARAMETER type SUID_ST_SEGMENT_PARAMETER .
  data MS_SEGMENT_PRINTPARAM type SUID_ST_SEGMENT_PRINTPARAM .
  data MS_SEGMENT_PROFILES_R04 type SUID_ST_SEGMENT_PROFILES_R04 .
  data MS_SEGMENT_PROFILES_R04_HIST type SUID_ST_SEGMENT_PROFILES_R04_H .
  data MS_SEGMENT_PROFILES_T04 type SUID_ST_SEGMENT_PROFILES_T04 .
  data MS_SEGMENT_PWDHISTORY type SUID_ST_SEGMENT_PWDHISTORY .
  data MS_SEGMENT_REFUSER type SUID_ST_SEGMENT_REFUSER .
  data MS_SEGMENT_ROLES type SUID_ST_SEGMENT_ROLES .
  data MS_SEGMENT_SNC type SUID_ST_SEGMENT_SNC .
  data MS_SEGMENT_UCLASS type SUID_ST_SEGMENT_UCLASS .
  data MS_SEGMENT_USERSTAMP type SUID_ST_SEGMENT_STAMP .
  data MS_SEGMENT_CERTMAP type SUID_ST_SEGMENT_CERTMAP .
  data MS_SEGMENT_DBMS_USER type SUID_ST_SEGMENT_DBMS_USER .
  class-data MT_BUP_MAP_FIELDS type TT_MAP_BUP_FIELDS .
  class-data MT_INVALID_CUA_PROF_ASSIGNMENT type SUID_TT_SEGMENT_CUA_PROFILES .
  class-data MT_INVALID_CUA_ROLE_ASSIGNMENT type SUID_TT_SEGMENT_CUA_ROLES .
  class-data MT_INVALID_PROFILE_ASSIGNMENT type SUID_TT_SEGMENT_PROFILES_T04 .
  class-data MT_INVALID_ROLE_ASSIGNMENT type SUID_TT_SEGMENT_ROLES .
  data MV_CUA_MODE type SUID_CUA_MODE .
  class-data MT_CERTMAP_ENQUEUED type SUID_TT_USRCERTMAP_SORTED .
  class-data GS_TIMESTAMP_FINALIZE type TY_TIMESTAMP .
  class-data MV_TCODE_MODE type SUID_TCODE_MODE .
  class-data MO_BADI_IDENTITY_CHECK type ref to CL_BADI_BASE .
  data MS_SEGMENT_DOCU type SUID_ST_SEGMENT_DOCU .
  class-data MV_UNIT_TEST_MODE type SESF_BOOLEAN .

  methods SET_LOGONDATA
    importing
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
      !IS_LOGONDATA type SUID_ST_NODE_LOGONDATA
      !IV_IGNORE_CUA_FLAGS type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods ADDR_ADJUST_TIMZONE
    raising
      CX_SUID_IDENTITY .
  methods ADBP_ADD_NOTIFICATIONS
    importing
      !IT_ADDR_NOTIFICATIONS type ADDRT_CHANGE_NOTIFICATION
    raising
      CX_SUID_IDENTITY .
  methods ADBP_CHECK_COMMDATA_MAINTAIN
    importing
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CS_CURRENT_STATE type BUP_S_CURRENT_STATE_COMMDATA .
  class-methods ADBP_CHECK_ORGANIZATION
    importing
      !IV_BNAME type XUBNAME optional
      !IS_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IV_ORGTYPE type SUID_ORGTYPE optional
    exporting
      !ES_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
      !EV_REJECT_ASSIGNMENT type SESF_BOOLEAN
      !EV_ORG_NODE_ID type ADDR_NODE_ID
    raising
      CX_SUID_IDENTITY .
  methods ADBP_DELETE
    raising
      CX_SUID_IDENTITY .
  class-methods ADBP_GET_ID
    importing
      !IO_ADDR_MAIN type ref to CL_ADDR_MAIN
      !IV_ADDRESS_TYPE type ADDR_ADDRESS_TYPE
      !IV_ADDRESS_NUMBER type AD_ADDRNUM optional
      !IV_PERSON_NUMBER type AD_PERSNUM optional
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      value(EV_ADDR_NODEID) type ADDR_NODE_ID
    raising
      CX_SUID_IDENTITY .
  methods ADBP_GET_PROPERTY_FOR_NODE
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IV_ENABLE type SESF_BOOLEAN optional
      !IV_READONLY type SESF_BOOLEAN optional
    exporting
      !EV_ENABLE type SESF_BOOLEAN
      !EV_READONLY type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods ADBP_MAP_CHANGE_FIELD
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS
    changing
      !CT_ADDR_CHANGE_FIELDS type ADDRT_CHANGED_FIELDS
    raising
      CX_SUID_IDENTITY .
  class-methods ADBP_READ_ORG_ADDRESS
    importing
      !IV_ORGNUM type AD_ADDRNUM
      !IV_ORGADDRID type ADDR_NODE_ID optional
    changing
      !ES_LOCATION type SUID_ST_NODE_LOCATION optional
      !ES_ORGANIZATION_NAME type SUID_ST_NODE_ORGANIZATION_NAME optional
    raising
      CX_SUID_IDENTITY .
  methods ADBP_SET_PROPERTY_FOR_NODE
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IV_ENABLE type SESF_BOOLEAN optional
      !IV_READONLY type SESF_BOOLEAN optional
    raising
      CX_SUID_IDENTITY .
  methods SET_PERSONNAME
    importing
      !IS_PERSONNAME type SUID_ST_NODE_PERSON_NAME
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
      !IV_IGNORE_CUA_CHECK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods ADDR_CHANGE_ADDRESS
    importing
      !IV_CHANGE_NODE type SUID_NODE_NAME
      !IS_PERSONNAME type SUID_ST_NODE_PERSON_NAME optional
      !IS_WORKPLACE type SUID_ST_NODE_WORKPLACE optional
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
    raising
      CX_SUID_IDENTITY .
  methods SET_WORKPLACEDATA
    importing
      !IS_WORKPLACE type SUID_ST_NODE_WORKPLACE
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
      !IV_IGNORE_CUA_CHECK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods ADDR_CHANGE_COMMUNICATION_DATA
    importing
      !IT_TELEPHONE type ADDRT_TELEPHONE_NUMBER optional
      !IT_FACSIMILE type ADDRT_FACSIMILE_NUMBER optional
      !IT_EMAIL type ADDRT_EMAIL_ADDRESS optional
      !IT_WEB type ADDRT_WEB_ADDRESS optional
      !IT_TELEX type ADDRT_TELEX_NUMBER optional
      !IT_TELETEX type ADDRT_TELETEX_NUMBER optional
      !IT_RML type ADDRT_REMOTE_MAIL_ADDRESS optional
      !IT_X400 type ADDRT_X400_ADDRESS optional
      !IT_PRINTER type ADDRT_PRINTER optional
      !IT_SSF type ADDRT_SSF_ADDRESS optional
      !IT_PAGER type ADDRT_PAGER_NUMBER optional
      !IS_CURRENT_STATE type BUP_S_CURRENT_STATE_COMMDATA optional
    exporting
      !ET_NEW_TELEPHONE_ID type ADDRT_CREATED_ID
      !ET_NEW_FACSIMILE_ID type ADDRT_CREATED_ID
      !ET_NEW_EMAIL_ID type ADDRT_CREATED_ID
      !ET_NEW_WEB_ID type ADDRT_CREATED_ID
      !ET_NEW_TELEX_ID type ADDRT_CREATED_ID
      !ET_NEW_TELETEX_ID type ADDRT_CREATED_ID
      !ET_NEW_RML_ID type ADDRT_CREATED_ID
      !ET_NEW_X400_ID type ADDRT_CREATED_ID
      !ET_NEW_PRINTER_ID type ADDRT_CREATED_ID
      !ET_NEW_SSF_ID type ADDRT_CREATED_ID
      !ET_NEW_PAGER_ID type ADDRT_CREATED_ID
    raising
      CX_SUID_IDENTITY .
  methods ADDR_CREATE_ADDRESS
    importing
      !IS_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
      !IV_ORG_NODE_ID type ADDR_NODE_ID
    exporting
      !EV_REJECT_ASSIGNMENT type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods SET_COMMUNICATION_DATA
    importing
      !IT_TELEPHONE type ADDRT_TELEPHONE_NUMBER optional
      !IT_FACSIMILE type ADDRT_FACSIMILE_NUMBER optional
      !IT_EMAIL type ADDRT_EMAIL_ADDRESS optional
      !IT_WEB type ADDRT_WEB_ADDRESS optional
      !IT_TELEX type ADDRT_TELEX_NUMBER optional
      !IT_TELETEX type ADDRT_TELETEX_NUMBER optional
      !IT_RML type ADDRT_REMOTE_MAIL_ADDRESS optional
      !IT_X400 type ADDRT_X400_ADDRESS optional
      !IT_PRINTER type ADDRT_PRINTER optional
      !IT_SSF type ADDRT_SSF_ADDRESS optional
      !IT_PAGER type ADDRT_PAGER_NUMBER optional
      !IS_CURRENT_STATE type BUP_S_CURRENT_STATE_COMMDATA optional
      !IV_IGNORE_CUA_CHECK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NEW_TELEPHONE_ID type ADDRT_CREATED_ID
      !ET_NEW_FACSIMILE_ID type ADDRT_CREATED_ID
      !ET_NEW_EMAIL_ID type ADDRT_CREATED_ID
      !ET_NEW_WEB_ID type ADDRT_CREATED_ID
      !ET_NEW_TELEX_ID type ADDRT_CREATED_ID
      !ET_NEW_TELETEX_ID type ADDRT_CREATED_ID
      !ET_NEW_RML_ID type ADDRT_CREATED_ID
      !ET_NEW_X400_ID type ADDRT_CREATED_ID
      !ET_NEW_PRINTER_ID type ADDRT_CREATED_ID
      !ET_NEW_SSF_ID type ADDRT_CREATED_ID
      !ET_NEW_PAGER_ID type ADDRT_CREATED_ID
    raising
      CX_SUID_IDENTITY .
  methods ADDR_DELETE_ADDRESS
    raising
      CX_SUID_IDENTITY .
  methods ADDR_MAP_COMMDATA
    changing
      !CT_COMM_TABLE type STANDARD TABLE
    raising
      CX_SUID_IDENTITY .
  methods ADDR_MAP_ERROR_TABLE
    importing
      !IV_MSG_ONCE type XFELD default 'X'
      !IV_MSG_PERMANENT type XFELD default 'X'
      !IV_MSG_FOR_NODE type SUID_NODE_NAME default SPACE
      !IT_ADDR_ERROR type ADDRT_ERROR
    raising
      CX_SUID_IDENTITY .
  methods ADDR_MSG_COMMDATA
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IT_COMM_TABLE type STANDARD TABLE
      !IS_CURRENT_STATE type XFLAG
    raising
      CX_SUID_IDENTITY .
  methods ADDR_READ_ADDRESS
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_PERSONNAME type SUID_ST_NODE_PERSON_NAME
      !ES_WORKPLACE type SUID_ST_NODE_WORKPLACE
    raising
      CX_SUID_IDENTITY .
  methods SET_DEFAULTS
    importing
      !IS_DEFAULTS type SUID_ST_NODE_DEFAULTS
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
      !IV_IGNORE_CUA_FLAGS type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods ADDR_READ_COMMUNICATION_DATA
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ET_TELEPHONE type ADDRT_TELEPHONE_NUMBER
      !ET_FACSIMILE type ADDRT_FACSIMILE_NUMBER
      !ET_EMAIL type ADDRT_EMAIL_ADDRESS
      !ET_WEB type ADDRT_WEB_ADDRESS
      !ET_TELEX type ADDRT_TELEX_NUMBER
      !ET_TELETEX type ADDRT_TELETEX_NUMBER
      !ET_RML type ADDRT_REMOTE_MAIL_ADDRESS
      !ET_X400 type ADDRT_X400_ADDRESS
      !ET_PRINTER type ADDRT_PRINTER
      !ET_SSF type ADDRT_SSF_ADDRESS
      !ET_PAGER type ADDRT_PAGER_NUMBER
    changing
      !CS_COMM_READ type ADDRS_COMMUNICATION_DATA_READ
    raising
      CX_SUID_IDENTITY .
  class-methods AFTER_COMMIT_CUSTOMER_EXIT
    importing
      !IT_SEGMENT_ROLES type SUID_TT_SEGMENT_ROLES
    exporting
      !ET_STR_AGRS type SUID_TT_STR_AGRS .
  methods AFTER_COMMIT_SINGLE
    raising
      CX_SUID_IDENTITY .
  methods AUTH_CHECK_FOR_NEW_CLASS
    importing
      !IV_NEW_CLASS type XUCLASS
      !IV_EXT_LIFETIME type IF_SUID_MSG_BUFFER=>TY_MSG_LIFETIME default IF_SUID_MSG_BUFFER=>CO_LIFETIME_ONCE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    exporting
      !EV_REJECT_CLASS type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods BP_DELETE_EMPLOYEE_WORK_ADDR
    raising
      CX_SUID_IDENTITY .
  methods BP_DELETE_ORGANIZATION
    raising
      CX_SUID_IDENTITY .
  methods BP_GET_COMMUNICATION_DATA
    importing
      !IS_COMMDATA_READ type BUP_S_COMMDATA_READ_API
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ET_TELEPHONE type ADDRT_TELEPHONE_NUMBER
      !ET_FACSIMILE type ADDRT_FACSIMILE_NUMBER
      !ET_EMAIL type ADDRT_EMAIL_ADDRESS
      !ET_WEB type ADDRT_WEB_ADDRESS
      !ET_TELEX type ADDRT_TELEX_NUMBER
      !ET_TELETEX type ADDRT_TELETEX_NUMBER
      !ET_RML type ADDRT_REMOTE_MAIL_ADDRESS
      !ET_X400 type ADDRT_X400_ADDRESS
      !ET_PRINTER type ADDRT_PRINTER
      !ET_SSF type ADDRT_SSF_ADDRESS
      !ET_PAGER type ADDRT_PAGER_NUMBER
    raising
      CX_SUID_IDENTITY .
  methods BP_GET_EMPL_ADDRESSDATA
    importing
      !IV_WORKPLACE_READ type SESF_BOOLEAN optional
      !IS_COMMDATA_READ type BUP_S_COMMDATA_READ_API optional
      !IV_LOCATION_READ type SESF_BOOLEAN optional
      !IV_ORGNAME_READ type SESF_BOOLEAN optional
    exporting
      !ES_WORKPLACE type SUID_ST_NODE_WORKPLACE
      !ET_TELEPHONE type ADDRT_TELEPHONE_NUMBER
      !ET_FACSIMILE type ADDRT_FACSIMILE_NUMBER
      !ET_EMAIL type ADDRT_EMAIL_ADDRESS
      !ET_WEB type ADDRT_WEB_ADDRESS
      !ET_TELEX type ADDRT_TELEX_NUMBER
      !ET_TELETEX type ADDRT_TELETEX_NUMBER
      !ET_RML type ADDRT_REMOTE_MAIL_ADDRESS
      !ET_X400 type ADDRT_X400_ADDRESS
      !ET_PRINTER type ADDRT_PRINTER
      !ET_SSF type ADDRT_SSF_ADDRESS
      !ET_PAGER type ADDRT_PAGER_NUMBER
      !ES_LOCATION type SUID_ST_NODE_LOCATION
      !ES_ORGANIZATION_NAME type SUID_ST_NODE_ORGANIZATION_NAME
    raising
      CX_SUID_IDENTITY .
  methods BP_GET_PERSONNAME
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_PERSONNAME type SUID_ST_NODE_PERSON_NAME
    raising
      CX_SUID_IDENTITY .
  methods BP_GET_WORKPLACEDATA
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_WORKPLACE type SUID_ST_NODE_WORKPLACE
    raising
      CX_SUID_IDENTITY .
  methods BP_MAP_BUP_FIELDS
    importing
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
    exporting
      !ET_BUP_MAP_FIELDS type TT_MAP_BUP_FIELDS
    raising
      CX_SUID_IDENTITY .
  methods BP_MAP_ERROR
    importing
      !IT_BUP_MSG type CMD_T_MSG_COMPLETE
    raising
      CX_SUID_IDENTITY .
  methods BP_MAP_PERSONNAME_ERROR
    importing
      !IT_BUP_MSG type CMD_T_MSG_COMPLETE
    raising
      CX_SUID_IDENTITY .
  methods BP_RESET_MODIFICATION
    importing
      !IV_DO_CLEANUP type SESF_BOOLEAN optional
    raising
      CX_SUID_IDENTITY .
  methods BP_SET_COMMUNICATION_DATA
    importing
      !IT_TELEPHONE type ADDRT_TELEPHONE_NUMBER optional
      !IT_FACSIMILE type ADDRT_FACSIMILE_NUMBER optional
      !IT_EMAIL type ADDRT_EMAIL_ADDRESS optional
      !IT_WEB type ADDRT_WEB_ADDRESS optional
      !IT_TELEX type ADDRT_TELEX_NUMBER optional
      !IT_TELETEX type ADDRT_TELETEX_NUMBER optional
      !IT_RML type ADDRT_REMOTE_MAIL_ADDRESS optional
      !IT_X400 type ADDRT_X400_ADDRESS optional
      !IT_PRINTER type ADDRT_PRINTER optional
      !IT_SSF type ADDRT_SSF_ADDRESS optional
      !IT_PAGER type ADDRT_PAGER_NUMBER optional
      !IS_CURRENT_STATE type BUP_S_CURRENT_STATE_COMMDATA optional
    exporting
      !ET_NEW_TELEPHONE_ID type ADDRT_CREATED_ID
      !ET_NEW_FACSIMILE_ID type ADDRT_CREATED_ID
      !ET_NEW_EMAIL_ID type ADDRT_CREATED_ID
      !ET_NEW_WEB_ID type ADDRT_CREATED_ID
      !ET_NEW_TELEX_ID type ADDRT_CREATED_ID
      !ET_NEW_TELETEX_ID type ADDRT_CREATED_ID
      !ET_NEW_RML_ID type ADDRT_CREATED_ID
      !ET_NEW_X400_ID type ADDRT_CREATED_ID
      !ET_NEW_PRINTER_ID type ADDRT_CREATED_ID
      !ET_NEW_SSF_ID type ADDRT_CREATED_ID
      !ET_NEW_PAGER_ID type ADDRT_CREATED_ID
    raising
      CX_SUID_IDENTITY .
  methods BP_SET_EMPLOYEE_WORK_ADDR
    importing
      !IS_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
    exporting
      !EV_REJECT_ASSIGNMENT type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods BP_SET_ORGANIZATION
    importing
      !IS_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
      !IV_ORG_NODE_ID type ADDR_NODE_ID
    exporting
      !EV_REJECT_ASSIGNMENT type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods BP_SET_PERSON
    importing
      !IS_PERSON type SUID_ST_NODE_PERSON
      !IV_NEWPERSON type SESF_BOOLEAN
    exporting
      !EV_REJECT_ASSIGNMENT type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods BP_SET_PERSONNAME
    importing
      !IS_PERSONNAME type SUID_ST_NODE_PERSON_NAME
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
    raising
      CX_SUID_IDENTITY .
  methods BP_SET_WORKPLACEDATA
    importing
      !IS_WORKPLACE type SUID_ST_NODE_WORKPLACE
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
    raising
      CX_SUID_IDENTITY .
  class-methods CATCH_TXN_FINISHED
    for event TRANSACTION_FINISHED of CL_SYSTEM_TRANSACTION_STATE
    importing
      !KIND .
  methods CERT_CHECK_CERTIFICATE
    importing
      !IS_CERTIFICATE type SUID_ST_NODE_CERTIFICATE optional
      !IS_CERTMAP type SUID_ST_NODE_CERTMAP optional
      !IV_CERT type CHAR01
    exporting
      !ES_CERTMAP type USRCERTMAP
      !ES_MSG type SYMSG
      !EV_REJECT_ASSIGNMENT type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods CHECKS_BEFORE_ACCESS
    importing
      !IV_METHOD type CHAR01
      !IV_CHANGE_NODE type SUID_NODE_NAME
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_MSG type SYMSG
    raising
      CX_SUID_IDENTITY .
  methods CHECK_CUA_LANDSCAPE
    importing
      !IV_NODE_NAME type SUID_NODE_NAME default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EV_VALID type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_PROFILES_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER optional
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    changing
      !CT_PROFILES type SUID_TT_NODE_CUA_PROFILES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_ROLES_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER optional
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    changing
      !CT_ROLES type SUID_TT_NODE_CUA_ROLES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_SYSTEMS_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IV_CLASS type XUCLASS optional
    changing
      !CT_CUA_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_CUA_UCLASSES_INTERNAL
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IT_ASSIGNED_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS optional
    changing
      !CT_CUA_UCLASSES type SUID_TT_NODE_CUA_UCLASSES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_DEFAULTS_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CS_DEFAULTS type SUID_ST_NODE_DEFAULTS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_DBMS_USER_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CS_DBMS_USER type SUID_ST_NODE_DBMS_USER
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_GROUPS_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CT_GROUPS type SUID_TT_NODE_GROUPS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_DBMS_ROLES_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CT_DBMS_ROLES type SUID_TT_NODE_DBMS_ROLES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_IF_CUA_USERS
    importing
      !IT_BNAME type SUID_TT_BNAME
      !IT_HEADERS type SUID_TT_USR02 optional
    exporting
      !ET_CUA_USERS type SUID_TT_BNAME
      !ET_DELETED_CUA_USERS type SUID_TT_BNAME
      !ET_NOT_CUA_USERS type SUID_TT_BNAME
      !ET_RESERVED_CUA_USERS type SUID_TT_BNAME
      !ET_LOCAL_USERS type SUID_TT_BNAME .
  class-methods CHECK_LOGONDATA_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER optional
      !IV_MODUS type SUID_TA_MODUS
      !IO_IDREF type ref to CL_IDENTITY optional
      !IV_SECPOL_OLD type SUID_ST_NODE_LOGONDATA-SECURITY_POLICY optional
    exporting
      !EV_CLASS_CHECKED type SESF_BOOLEAN
      !EV_REJECT_CLASS type SESF_BOOLEAN
      !EV_REJECT_SECPOL type SESF_BOOLEAN
    changing
      !CS_LOGONDATA type SUID_ST_NODE_LOGONDATA
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_PARAMETERS_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CT_PARAMETERS type SUID_TT_NODE_PARAMETERS
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_PROFILES_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER optional
      !IV_ALLOW_GENERATED_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    changing
      !CT_PROFILES type SUID_TT_NODE_PROFILES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_REFERENCE_USER_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IV_EXT_NODENAME type SUID_NODE_NAME default SPACE
      !IV_EXT_FIELD type SUID_NODE_FIELD default SPACE
      !IV_USE_EXT_NODE type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_EXT_LIFETIME type IF_SUID_MSG_BUFFER=>TY_MSG_LIFETIME default IF_SUID_MSG_BUFFER=>CO_LIFETIME_ONCE
    exporting
      !EV_IS_AUTHORIZED type SESF_BOOLEAN
    changing
      !CS_OLD_REFERENCE_USER type SUID_ST_NODE_REFERENCE_USER optional
      !CS_NEW_REFERENCE_USER type SUID_ST_NODE_REFERENCE_USER optional
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_ROLES_INTERNAL
    importing
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER optional
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    changing
      !CT_ROLES type SUID_TT_NODE_ROLES
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_TECHUSER_DATA_INTERNAL
    importing
      !IT_CHECK_FIELDS type SUID_TT_FIELDS optional
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    changing
      !CS_TECH_USER_DATA type SUID_ST_NODE_TECH_USER_DATA
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_UCLASS_INTERNAL
    importing
      !IV_CUA_CASE type SESF_BOOLEAN optional
      !IV_NODENAME type SUID_NODE_NAME
      !IV_BNAME type XUBNAME
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IV_CENTRAL_SYSTEM type RFCRCVSYS optional
      !IV_KEY_HANDLE type SUID_NODE_KEY_HANDLE optional
    changing
      !CS_UCLASS type SUID_ST_NODE_UCLASS
    raising
      CX_SUID_IDENTITY .
  methods CLEANUP_SINGLE
    importing
      !IV_IGNORE_BAS type BOOLEAN default ABAP_FALSE
    raising
      CX_SUID_IDENTITY .
  class-methods CHECK_REFUSER_DELETE_INTERNAL
    importing
      !IV_BNAME type XUBNAME
      !IV_NODE_NAME type SUID_NODE_NAME
      !IV_SYSTEM type SUID_ST_NODE_CUA_SYSTEM-SUBSYSTEM default SPACE
    exporting
      !EV_VALID type SESF_BOOLEAN
      !EO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER .
  methods CLEAR_NODE_STATUS
    raising
      CX_SUID_IDENTITY .
  methods CLEAR_SEGMENTS
    importing
      !IV_KEEP_HEADER type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods CONSTRUCTOR
    importing
      !IV_BNAME type XUBNAME
      !IV_MODUS type SUID_TA_MODUS
      !IS_HEADER type USR02
      !IV_ENQ_MODE type SESF_EDIT_MODE optional
      !IV_CUA_MODE type SUID_CUA_MODE optional
    raising
      CX_SUID_IDENTITY .
  methods CUA_CHECK_FIELD_DISTRIBUTE
    importing
      !IS_NODE_FIELD type SUID_ST_CUA_FILTERS
    exporting
      !EV_DISTRIBUTE type XFLAG .
  methods CUA_DELETE_USER_SYSTEM_PROT
    importing
      !IV_SUBSYSTEM type USZBVSYS-SUBSYSTEM
      !IV_USER_SECTION type SESF_BOOLEAN optional
      !IV_ROLE_SECTION type SESF_BOOLEAN optional
      !IV_PROF_SECTION type SESF_BOOLEAN optional
    raising
      CX_SUID_IDENTITY .
  methods CUA_GET_CHANGES_FOR_DISTRIBUTE
    exporting
      !ES_CUA_DATA_DISTRIBUTE type TY_CUA_DATA_DISTRIBUTE
      !ES_CUA_DATA_DISTRIBUTE_BACK type TY_CUA_DATA_DISTRIBUTE_BACK
    raising
      CX_SUID_IDENTITY .
  methods CUA_IF_FIELD_NO_MAINTAIN
    importing
      !IV_NODE_NAME type SUID_NODE_NAME
      !IV_FIELD_NAME type SUID_NODE_FIELD optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER optional
    returning
      value(RV_NO_MAINTAIN) type SESF_BOOLEAN .
  methods CUA_PREPARE_CHANGED_USER_SEND
    importing
      !IS_TIMESTAMP type TY_TIMESTAMP
    exporting
      !ET_CUA_USER_SYST_DISTR type TT_CUA_USER_SYST_DISTR
    changing
      !CT_SEGMENT_CUA_SYSTEMS type SUID_TT_SEGMENT_CUA_SYSTEMS optional
      !CT_SEGMENT_CUA_USER_PROT type SUID_TT_SEGMENT_CUA_USER_PROT optional
    raising
      CX_SUID_IDENTITY .
  methods CUA_PREPARE_USER_SEND
    importing
      !IS_TIMESTAMP type TY_TIMESTAMP
      !IS_CUA_USER_SYST_DISTR type SUID_ST_CUA_USER_SYST_DISTR
    exporting
      !ES_USER_CHILD_SYST_DISTR type TY_CUA_USER_SYST_DISTR
      !ES_CUA_USER_SYST_NO_DISTR type SUID_ST_CUA_USER_SYST_DISTR
    changing
      !CS_SEGMENT_CUA_SYSTEMS type SUID_ST_SEGMENT_CUA_SYSTEMS
    raising
      CX_SUID_IDENTITY .
  class-methods CUA_SEND_USERS
    importing
      !IV_UPDATE_TASK type XFLAG default IF_IDENTITY=>CO_TRUE
      !IT_CUA_USER_SYST_DISTR type TT_CUA_USER_SYST_DISTR
      !IV_ONLY_CHANGED_UCLASSES type XFLAG default IF_IDENTITY=>CO_TRUE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods CUA_SEND_USER_BACK
    raising
      CX_SUID_IDENTITY .
  methods CUA_SET_STATUS_FOR_CENTRALSYST
    importing
      !IV_USRSECTION type USZBVSYS-USRSECTION
      !IV_DELETED type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IS_TIMESTAMP type TY_TIMESTAMP
    raising
      CX_SUID_IDENTITY .
  methods CUA_SET_SYST_ASSIGNMENT
    exporting
      !ET_ERROR_SYSTEMS type TT_ERROR_SYSTEMS
    changing
      !CT_ASSIGN_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
    raising
      CX_SUID_IDENTITY .
  methods CUA_UCLASS_DELETE_USER_SYSTEM
    importing
      !IT_CUA_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods DO_CHECK_SINGLE
    exporting
      !EV_REJECTED type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  class-methods EASY_ACCESS_MENU_SAVE
    importing
      !IV_UPDATE_TASK type CHAR01
      !IT_BNAME_COPY type SUID_TT_BNAME_COPY optional
      !IT_BNAME_DELETE type SUID_TT_BNAME optional .
  methods EASY_ACCESS_MENU_SET_COPIED
    importing
      !IV_SOURCE_BNAME type XUBNAME .
  methods FETCH_SEGMENT_ADDRESS
    importing
      !IS_ADDRESS type USR21 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_CERTMAP
    importing
      !IT_CERTMAP type SUID_TT_USRCERTMAP optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_CUA_PROFILES
    importing
      !IT_CUA_PROFILES type SUID_TT_USL04 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_CUA_ROLES
    importing
      !IT_ROLES type SUID_TT_USLA04 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_CUA_SYSTEMS
    importing
      !IT_CUA_SYSTEMS type SUID_TT_USZBVSYS optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_CUA_UCLASSES
    importing
      !IT_CUA_UCLASSES type SUID_TT_USR06SYS optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_CUA_USER_PROT
    importing
      !IT_CUA_USERS_PROT type SUID_TT_USZBVPROT optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_DBMS_USER
    importing
      !IS_DBMS_USER type USR_DBMS_USER optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_DEFAULTS
    importing
      !IS_DEFAULTS type USR01 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_GROUPS
    importing
      !IT_GROUPS type SUID_TT_USGRP_USER optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_PARAMETER
    importing
      !IT_PARAMETER type SUID_TT_USR05 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_PROFILES_T04
    importing
      !IT_PROFILES type SUID_TT_UST04 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_REFUSER
    importing
      !IS_REFUSER type USREFUS optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_ROLES
    importing
      !IT_ROLES type SUID_TT_AGR_USERS optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_SNC
    importing
      !IS_SNC type USRACL optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_UCLASS
    importing
      !IS_UCLASS type USR06 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_USR04
    importing
      !IT_USR04 type SUID_TT_USR04 optional
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_USRSTAMP
    importing
      !IT_USRSTAMP type SUID_TT_USRSTAMP optional
    raising
      CX_SUID_IDENTITY .
  class-methods FETCH_USR04
    importing
      !IV_BNAME type XUBNAME
      !IV_MODUS type SUID_TA_MODUS optional
      !IV_STATUS type SUID_TA_STATUS optional
    exporting
      !ES_SEGMENT_USR04 type SUID_ST_SEGMENT_PROFILES_R04
    raising
      CX_SUID_IDENTITY .
  class-methods FINALIZE_SET_TIMESTAMPS
    raising
      CX_SUID_IDENTITY .
  methods FINALIZE_SINGLE
    exporting
      !EV_REJECTED type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods GET_CERTMAP
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_CERTMAP type SUID_TT_NODE_CERTMAP
    raising
      CX_SUID_IDENTITY .
  methods GET_CLASS
    importing
      !IV_FOR_AUTH type SESF_BOOLEAN
    exporting
      !EV_CLASS type XUCLASS
    raising
      CX_SUID_IDENTITY .
  methods GET_COMMUNICATION_DATA
    importing
      !IS_RETRIEVE_COMMDATA type BUP_S_COMMDATA_READ_API optional
      !IV_RETRIEVE_COMMDATA_ALL type SESF_BOOLEAN optional
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ET_TELEPHONE type ADDRT_TELEPHONE_NUMBER
      !ET_FACSIMILE type ADDRT_FACSIMILE_NUMBER
      !ET_EMAIL type ADDRT_EMAIL_ADDRESS
      !ET_WEB type ADDRT_WEB_ADDRESS
      !ET_TELEX type ADDRT_TELEX_NUMBER
      !ET_TELETEX type ADDRT_TELETEX_NUMBER
      !ET_RML type ADDRT_REMOTE_MAIL_ADDRESS
      !ET_X400 type ADDRT_X400_ADDRESS
      !ET_PRINTER type ADDRT_PRINTER
      !ET_SSF type ADDRT_SSF_ADDRESS
      !ET_PAGER type ADDRT_PAGER_NUMBER
    raising
      CX_SUID_IDENTITY .
  methods GET_CUA_PROFILES
    importing
      !IV_GET_PROF_DETAILS type SESF_BOOLEAN default 'X'
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ET_PROFILES type SUID_TT_NODE_CUA_PROFILES
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_CUA_ROLES
    importing
      !IV_GET_ROLE_DETAILS type SESF_BOOLEAN default SPACE
      !IV_GET_ROLE_MEMBERS type SESF_BOOLEAN default SPACE
      !IV_GET_ROLE_ADJUSTMENTS type SESF_BOOLEAN default SPACE
      !IV_GET_PROFILE_SYNC_STATUS type SESF_BOOLEAN default SPACE
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ET_ROLES type SUID_TT_NODE_CUA_ROLES
      !ET_ROLE_DETAILS type SUID_TT_NODE_CUA_ROLE_DETAILS
      !ET_ROLE_MEMBERS type SUID_TT_NODE_CUA_ROLE_MEMBERS
      !ET_ROLE_ADJUSTMENTS type SUID_TT_NODE_CUA_ROLE_ADJUST
      !EV_ADJUSTMENT_REQUIRED type SUID_ROLE_ADJUSTMENT_STATUS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_CUA_SYSTEMS
    importing
      !IV_GET_TEXT type SESF_BOOLEAN default SPACE
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ET_CUA_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_CUA_UCLASSES
    exporting
      !ET_CUA_UCLASSES type SUID_TT_NODE_CUA_UCLASSES
      !ET_USER_LAW_SUBSYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_DEFAULTS
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ES_DEFAULTS type SUID_ST_NODE_DEFAULTS
      !EV_KOSTL type XUKOSTL
    raising
      CX_SUID_IDENTITY .
  methods GET_DBMS_USER
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ES_DBMS_USER type SUID_ST_NODE_DBMS_USER
    raising
      CX_SUID_IDENTITY .
  methods GET_GROUPS
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
      !IV_GET_TEXT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_GROUPS type SUID_TT_NODE_GROUPS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_LOGONDATA
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
      !IV_GET_GRP_TEXT type SESF_BOOLEAN optional
    exporting
      !ES_LOGONDATA type SUID_ST_NODE_LOGONDATA
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_ORGANIZATION
    importing
      !IV_GET_LOCATION type SESF_BOOLEAN default SPACE
      !IV_GET_ORGANIZATION_NAME type SESF_BOOLEAN default SPACE
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_ORGANIZATION type SUID_ST_NODE_ORGANIZATION
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ES_LOCATION type SUID_ST_NODE_LOCATION
      !ES_ORGANIZATION_NAME type SUID_ST_NODE_ORGANIZATION_NAME
    raising
      CX_SUID_IDENTITY .
  methods GET_PARAMETERS
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
      !IV_GET_TEXT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_PARAMETERS type SUID_TT_NODE_PARAMETERS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_PASSWORD_HASH
    exporting
      !ES_NODE_PWDHASH type SUID_ST_NODE_PWDHASH
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_PERSONNAME
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_PERSONNAME type SUID_ST_NODE_PERSON_NAME
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_PROFILES
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
      !IV_GET_PROF_DETAILS type SESF_BOOLEAN default 'X'
    exporting
      !ET_PROFILES type SUID_TT_NODE_PROFILES
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_REFERENCE_USER
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_REFERENCE_USER type SUID_ST_NODE_REFERENCE_USER
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_ROLES
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_ROLES type SUID_TT_NODE_ROLES
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods GET_SNC
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !ES_SNC type SUID_ST_NODE_SNC
    raising
      CX_SUID_IDENTITY .
  methods GET_UCLASS .
  methods GET_WORKPLACEDATA
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
    exporting
      !ES_WORKPLACE type SUID_ST_NODE_WORKPLACE
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  class-methods INSTANTIATION_BY_MODE
    importing
      !IV_MODUS type SUID_TA_MODUS
      !IT_IDENTITY type SUID_TT_IDENTITY optional
      !IT_BNAME type SUID_TT_BNAME
      !IV_ENQ_MODE type SESF_EDIT_MODE default IF_IDENTITY=>CO_ENQUEUE_MODE_EXCLUSIVE
      !IV_TRANSACTION type CHAR01 optional
      !IV_NODE_NAME type SUID_NODE_NAME default IF_IDENTITY_DEFINITION=>GC_NODE_ROOT
      !IV_CUA_TS_LOCAL_USER type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_CUA_TS_FORCE_MODIFACTION type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_SET_OPTIMISTIC_ENQUEUE_LOCK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_REPEAT_ENQ type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !ET_BNAME_EXIST type SUID_TT_BNAME
      !ET_BNAME_NOT_EXIST type SUID_TT_BNAME
      !ET_BNAME_NOT_AUTHORIZED type SUID_TT_BNAME
      !ET_BNAME_LOCKED type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods INSTANTIATION_FOR_DISTRIBUTION
    importing
      !IT_BNAME type SUID_TT_BNAME
      !IV_BNAME_NOT_EXIST_NO_ERROR type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
    exporting
      !ET_NODE_ROOT type SUID_TT_NODE_ROOT
      !ET_BNAME_INSTANTIATED type SUID_TT_BNAME
      !ET_BNAME_FAILED type SUID_TT_BNAME
      !ET_BNAME_NOT_EXIST type SUID_TT_BNAME
    raising
      CX_SUID_IDENTITY .
  class-methods NODES_PREFILL_DEFAULT_VALUES
    importing
      !IT_NODE_ROOT type SUID_TT_NODE_ROOT
      !IV_MODUS type SUID_TA_MODUS
    raising
      CX_SUID_IDENTITY .
  class-methods NODE_AUTHORITY_CHECK
    importing
      !IV_NODE_NAME type SUID_NODE_NAME
      !IV_TRANSACTION_MODE type SUID_TA_MODUS
      !IV_CLASS type XUCLASS
      !IV_METHOD type CHAR01 default 'G'
      !IV_BNAME type XUBNAME optional
    exporting
      !ES_MSG type SYMSG
      !EV_AUTH_NODE type SUID_NODE_NAME
    raising
      CX_SUID_IDENTITY .
  methods PASSWORD_CONVERT_TO_HASH
    importing
      !IV_PWDPLAIN type SUID_ST_NODE_PASSWORD
      !IV_SELF_REGISTER type SESF_BOOLEAN default SPACE
      !IV_PRODUCTIVE_PWD type SESF_BOOLEAN default SPACE
    exporting
      !EV_PWDHASH type SUID_ST_NODE_PWDHASH
    raising
      CX_SUID_IDENTITY .
  methods PERSDATA_SET_MODIFIED
    importing
      !IV_MODIFIED type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE .
  methods PREPARE_AUDIT_SEGMENT
    importing
      !IS_TIMESTAMP type TY_TIMESTAMP
    raising
      CX_SUID_IDENTITY .
  methods PREPARE_INTERNAL_SEGMENTS
    importing
      !IS_TIMESTAMP type TY_TIMESTAMP
    raising
      CX_SUID_IDENTITY .
  class-methods PREPARE_PROFILE_SEGMENTS
    importing
      !IS_TIMESTAMP type TY_TIMESTAMP
      !IV_BNAME type XUBNAME
      !IV_STATUS type SUID_TA_STATUS optional
      !IV_MODUS type SUID_TA_MODUS optional
    exporting
      !ES_SEGMENT_USH04 type SUID_ST_SEGMENT_PROFILES_R04_H
    changing
      !CS_SEGMENT_USR04 type SUID_ST_SEGMENT_PROFILES_R04
      !CS_SEGMENT_UST04 type SUID_ST_SEGMENT_PROFILES_T04
    raising
      CX_SUID_IDENTITY .
  class-methods PREPARE_SEGMENTS_POSTFETCH
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_ADD_ADJUSTMENT_INFO
    exporting
      !EV_ADJUSTMENT_REQUIRED type SUID_ROLE_ADJUSTMENT_STATUS
    changing
      !CT_NODE_ROLES type SUID_TT_NODE_ROLE_ADJUSTMENTS
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_ADJUST
    importing
      !IT_ROLES type SUID_TT_AGR_USERS
      !IT_PARENT_CHILD_RELATIONSHIP type SUID_TT_AGR_AGRS optional
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_USER_PROFILE type SUID_TT_USPROF
    raising
      CX_SUID_IDENTITY .
  class-methods PROFILE_CHECK_DELTA_AUTHORITY
    importing
      !IT_OLD_PROFILES type SUID_TT_UST04 optional
      !IT_NEW_PROFILES type SUID_TT_UST04 optional
      !IV_CHECK_GENERATED_PROFILE type SESF_BOOLEAN
      !IT_OLD_CUA_PROFILES type SUID_TT_USL04 optional
      !IT_NEW_CUA_PROFILES type SUID_TT_USL04 optional
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IV_EXT_NODENAME type SUID_NODE_NAME default SPACE
      !IV_EXT_FIELD type SUID_NODE_FIELD default SPACE
      !IV_USE_EXT_NODE type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_EXT_LIFETIME type IF_SUID_MSG_BUFFER=>TY_MSG_LIFETIME default IF_SUID_MSG_BUFFER=>CO_LIFETIME_ONCE
    returning
      value(RV_AUTHORIZED) type I
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_ADD_ADJUST_INFO
    exporting
      !EV_ADJUSTMENT_REQUIRED type SUID_ROLE_ADJUSTMENT_STATUS
    changing
      !CT_NODE_ROLES type SUID_TT_NODE_CUA_ROLE_ADJUST
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_DELETE_USER_SYSTEM
    importing
      !IV_SYSTEM type RFCRCVSYS
      !IV_NODE_NAME type SUID_NODE_NAME default IF_IDENTITY_DEFINITION=>GC_NODE_CUA_PROFILE
    exporting
      !EV_PROFILES_DELETED type SESF_BOOLEAN
      !EO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_GET_CHANGED_SYSTEM
    exporting
      !ET_CHANGED_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_GET_FOR_SYST_DISTR
    importing
      !IV_SUBSYSTEM type RFCRCVSYS
    exporting
      !ET_CUA_SYSTEM_PROFILES type SUID_TT_BAPIPROF
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_MERGE_TO_RESULT
    exporting
      !ET_USL04 type SUID_TT_USL04
    changing
      !CT_UPDATE_PROFILE_NODE type SUID_TT_NODE_CUA_PROFILES
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_SET
    importing
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NODE_CUA_PROFILES type SUID_TT_NODE_CUA_PROFILES
    changing
      !CT_PROFILES type SUID_TT_NODE_CUA_PROFILES
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_CUA_SET_INTERNAL
    importing
      !IT_PROFILES type SUID_TT_NODE_CUA_PROFILES
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NODE_CUA_PROFILES type SUID_TT_NODE_CUA_PROFILES
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_GET_GENERATED_PROFILE
    exporting
      !ET_USER_PROFILE type SUID_TT_USPROF
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_INITIALIZE_UST04
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN default SPACE
      !IV_GET_PROFILE_TEXT type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
    exporting
      !ET_USER_PROFILE type SUID_TT_USPROF
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_MERGE_TO_RESULT
    importing
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IO_NOTIFY type ref to CL_SUID_NOTIFICATION_HANDLER
    exporting
      !ET_USER_PROFILE type SUID_TT_USPROF
    changing
      !CT_PROFILES type SUID_TT_NODE_PROFILES
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_SET
    importing
      !IV_ALLOW_GENERATED_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NODE_PROFILES type SUID_TT_NODE_PROFILES
    changing
      !CT_PROFILES type SUID_TT_NODE_PROFILES
    raising
      CX_SUID_IDENTITY .
  methods PROFILE_WRITE_TO_SEGMENT
    importing
      !IT_USER_PROFILE type SUID_TT_USPROF
    exporting
      !ET_UST04 type SUID_TT_UST04
    raising
      CX_SUID_IDENTITY .
  methods REFRESH
    importing
      !IV_RELEASE_ENQUEUE_LOCK type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
    raising
      CX_SUID_IDENTITY .
  methods RELEASE_ENQUEUE_LOCK
    importing
      !IV_RELEASE_OPTIMISTIC_LOCK type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    raising
      CX_SUID_IDENTITY .
  class-methods ROLES_ADD_PARENT_INFORMATION
    importing
      !IT_ROLE_NAME type SUID_TT_ROLE_NAME
    exporting
      !ET_NODE_ROLES type SUID_TT_NODE_ROLE_MEMBERS .
  class-methods ROLES_ADD_TEXT
    changing
      !CT_NODE_ROLES type SUID_TT_NODE_ROLE_DETAILS
    raising
      CX_SUID_IDENTITY .
  class-methods ROLES_ADD_TYPE
    changing
      !CT_NODE_ROLES type SUID_TT_NODE_ROLE_DETAILS .
  class-methods ROLES_CHECK_AUTHORITY
    importing
      !IT_OLD_ROLES type SUID_TT_AGR_USERS optional
      !IT_NEW_ROLES type SUID_TT_AGR_USERS optional
      !IT_OLD_CUA_ROLES type SUID_TT_USLA04 optional
      !IT_NEW_CUA_ROLES type SUID_TT_USLA04 optional
      !IV_BNAME type XUBNAME optional
      !IV_CLASS type XUCLASS default SPACE
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IV_EXT_NODENAME type SUID_NODE_NAME default SPACE
      !IV_EXT_FIELD type SUID_NODE_FIELD default SPACE
      !IV_USE_EXT_NODE type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_EXT_LIFETIME type IF_SUID_MSG_BUFFER=>TY_MSG_LIFETIME default IF_SUID_MSG_BUFFER=>CO_LIFETIME_ONCE
    returning
      value(RV_AUTHORIZED) type I
    raising
      CX_SUID_IDENTITY .
  class-methods ROLES_CUA_ADD_PARENT_INFO
    importing
      !IT_ROLES type SUID_TT_NODE_CUA_ROLES
    exporting
      !ET_NODE_ROLES type SUID_TT_NODE_CUA_ROLE_MEMBERS .
  class-methods ROLES_CUA_ADD_TEXT
    changing
      !CT_NODE_CUA_ROLE_DETAIL type SUID_TT_NODE_CUA_ROLE_DETAILS
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_DELETE_USER_SYSTEM
    importing
      !IV_SYSTEM type RFCRCVSYS
      !IV_NODE_NAME type SUID_NODE_NAME default IF_IDENTITY_DEFINITION=>GC_NODE_CUA_ROLE
    exporting
      !EO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !EV_ROLES_DELETED type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_GET_CHANGED_SYSTEM
    exporting
      !ET_CHANGED_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_GET_COLLECTION_ELMTS
    exporting
      !ET_PARENT_CHILD_RELATIONSHIP type SUID_TT_AGR_AGRS
    changing
      !CT_USLA04 type SUID_TT_USLA04
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_GET_FOR_SYST_DISTR
    importing
      !IV_SUBSYSTEM type RFCRCVSYS
    exporting
      !ET_CUA_SYSTEM_ROLES type SUID_TT_BAPIAGR
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_MERGE_TO_RESULT
    importing
      !IV_DO_ROLE_RESOLVING type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_USLA04 type SUID_TT_USLA04
    changing
      !CT_UPDATE_ROLE_NODES type SUID_TT_NODE_CUA_ROLES
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_SET
    importing
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_DO_ROLE_RESOLVING type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_SET_EXTENDED type SESF_BOOLEAN default SPACE
    exporting
      !ET_NODE_CUA_ROLES type SUID_TT_NODE_CUA_ROLES
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    changing
      !CT_ROLES type SUID_TT_NODE_CUA_ROLES
    raising
      CX_SUID_IDENTITY .
  methods ROLES_CUA_SET_INTERNAL
    importing
      !IT_ROLES type SUID_TT_NODE_CUA_ROLES
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_CHECK_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
      !IV_DO_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_SET_EXTENDED type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_DO_ROLE_RESOLVING type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_NODE_CUA_ROLES type SUID_TT_NODE_CUA_ROLES
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods ROLES_GET_COLLECTION_ELEMENTS
    exporting
      !ET_PARENT_CHILD_RELATIONSHIP type SUID_TT_AGR_AGRS
    changing
      !CT_AGR_USERS type SUID_TT_AGR_USERS
    raising
      CX_SUID_IDENTITY .
  methods ROLES_MERGE_TO_RESULT
    importing
      !IV_DO_ROLE_RESOLVING type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_AGR_USERS type SUID_TT_AGR_USERS
    changing
      !CT_UPDATE_ROLE_NODES type SUID_TT_NODE_ROLES
    raising
      CX_SUID_IDENTITY .
  methods ROLES_SET
    importing
      !IV_CHECK_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
      !IV_DO_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_SET_EXTENDED type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_DO_ROLE_RESOLVING type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
      !ET_NODE_ROLES type SUID_TT_NODE_ROLES
    changing
      !CT_ROLES type SUID_TT_NODE_ROLES
    raising
      CX_SUID_IDENTITY .
  methods ROLES_SET_INTERNAL
    importing
      !IT_ROLES type SUID_TT_NODE_ROLES
      !IV_CHECK_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
      !IV_DO_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_SET_EXTENDED type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_DO_ROLE_RESOLVING type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    exporting
      !ET_NODE_ROLES type SUID_TT_NODE_ROLES
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
  methods ROLES_VALIDATE_CUA_CONTEXT
    importing
      !IV_BNAME type XUBNAME optional
      !IV_NODE_NAME type SUID_NODE_NAME optional
    exporting
      !EO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !EV_VALID type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods ROLES_VALIDATE_CUA_MASTER
    importing
      !IV_BNAME type XUBNAME
      !IV_NODE_NAME type SUID_NODE_NAME
    exporting
      !EV_CUA_MASTER type RFCRCVSYS
      !EV_NO_MAINTAIN_NODE type SESF_BOOLEAN
    raising
      CX_SUID_IDENTITY .
  methods ROLES_WRITE_TO_SEGMENT
    importing
      !IT_USER_ROLES type SUID_TT_AGR_USERS
      !IV_CHECK_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE
      !IV_DO_COMPARE_PROFILES type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_PERMIT type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
    raising
      CX_SUID_IDENTITY .
  methods SET_CUA_ATTRIBUTES
    importing
      !IV_CUA_MODE type SUID_CUA_MODE optional .
  methods SET_INTERNAL_TIMESTAMP
    importing
      !IS_TIMESTAMP_NEW type TY_TIMESTAMP
      !IS_TIMESTAMP_OLD type TY_TIMESTAMP
    raising
      CX_SUID_IDENTITY .
  methods UCLASSES_CUA_GET_CHANGED
    exporting
      !ET_CUA_CHANGED_UCLASSES type SUID_TT_NODE_CUA_UCLASSES
      !ET_CHANGED_SYSTEMS type SUID_TT_NODE_CUA_SYSTEMS .
  class-methods UCLASS_CHECK_SPEC_CONDITIONS
    importing
      !IV_NODENAME type SUID_NODE_NAME
      !IV_BNAME type XUBNAME optional
      !IO_MSG_BUFFER type ref to CL_SUID_MSG_BUFFER
      !IS_UCLASS type SUID_ST_NODE_UCLASS
      !IV_CUA_CASE type SESF_BOOLEAN default IF_IDENTITY=>CO_FALSE
      !IV_SUBSYSTEM type RFCRCVSYS optional
      !IV_KEY_HANDLE type SUID_NODE_KEY_HANDLE optional
    raising
      CX_SUID_IDENTITY .
  methods VERIFY_NODE_FIELDS
    importing
      !IT_CHANGE_FIELDS type SUID_TT_FIELDS optional
      !IV_NODE_NAME type SUID_NODE_NAME
    exporting
      !ET_CHANGEABLE_FIELDS type SUID_TT_FIELDS
    raising
      CX_SUID_IDENTITY .
  methods APPLREFS_SET_MODIFIED
    importing
      !IV_MODIFIED type SESF_BOOLEAN default IF_IDENTITY=>CO_TRUE .
  methods GET_TECHNICAL_USER_DATA
    importing
      !IV_REQUEST_BEFORE_IMAGE type SESF_BOOLEAN optional
    exporting
      !ES_TECH_USER_DATA type SUID_ST_NODE_TECH_USER_DATA
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
    raising
      CX_SUID_IDENTITY .
  methods FETCH_SEGMENT_DOCU
    importing
      !IT_DOCU type SUID_TT_USDOCU optional
    raising
      CX_SUID_IDENTITY .
  methods SET_DOCUMENTATION_COMPLETE
    importing
      !IT_DOCU type SUID_TT_NODE_DOCU
    exporting
      !EO_MSG_BUFFER type ref to IF_SUID_MSG_BUFFER
      !EO_NOTIFY type ref to IF_SUID_NOTIFICATION_HANDLER
    raising
      CX_SUID_IDENTITY .
ENDCLASS.



CLASS CL_IDENTITY IMPLEMENTATION.


method adbp_add_notifications.

  data: lr_addr_notification     type ref to addrs_change_notification
      , lv_nodename              type        suid_node_name
      , lv_key                   type        suid_node_key
      .


  loop at it_addr_notifications reference into lr_addr_notification.

*   Map nodename
    case lr_addr_notification->node_name.
      when cl_addr_main=>c_node_telephone       or
           cl_addr_main=>c_node_telephone_note  or
           cl_addr_main=>c_node_telephone_usage.
        lv_nodename = if_identity_definition=>gc_node_telephone.
      when cl_addr_main=>c_node_facsimile       or
           cl_addr_main=>c_node_facsimile_note  or
           cl_addr_main=>c_node_facsimile_usage.
        lv_nodename = if_identity_definition=>gc_node_facsimile.
      when cl_addr_main=>c_node_email       or
           cl_addr_main=>c_node_email_note  or
           cl_addr_main=>c_node_email_usage.
        lv_nodename = if_identity_definition=>gc_node_email.
      when cl_addr_main=>c_node_web       or
           cl_addr_main=>c_node_web_note  or
           cl_addr_main=>c_node_web_usage.
        lv_nodename = if_identity_definition=>gc_node_web.
      when cl_addr_main=>c_node_telex       or
           cl_addr_main=>c_node_telex_note  or
           cl_addr_main=>c_node_telex_usage.
        lv_nodename = if_identity_definition=>gc_node_telex.
      when cl_addr_main=>c_node_teletex       or
           cl_addr_main=>c_node_teletex_note  or
           cl_addr_main=>c_node_teletex_usage.
        lv_nodename = if_identity_definition=>gc_node_teletex.
      when cl_addr_main=>c_node_rml       or
           cl_addr_main=>c_node_rml_note  or
           cl_addr_main=>c_node_rml_usage.
        lv_nodename = if_identity_definition=>gc_node_remote_mail.
      when cl_addr_main=>c_node_x400       or
           cl_addr_main=>c_node_x400_note  or
           cl_addr_main=>c_node_x400_usage.
        lv_nodename = if_identity_definition=>gc_node_x400.
      when cl_addr_main=>c_node_printer       or
           cl_addr_main=>c_node_printer_note  or
           cl_addr_main=>c_node_printer_usage.
        lv_nodename = if_identity_definition=>gc_node_printer.
      when cl_addr_main=>c_node_ssf       or
           cl_addr_main=>c_node_ssf_note  or
           cl_addr_main=>c_node_ssf_usage.
        lv_nodename = if_identity_definition=>gc_node_ssf.
      when cl_addr_main=>c_node_pager       or
           cl_addr_main=>c_node_pager_note  or
           cl_addr_main=>c_node_pager_usage.
        lv_nodename = if_identity_definition=>gc_node_pager.
      when others. "Root
        continue.
    endcase.

    lv_key = lr_addr_notification->node_id.

    case lr_addr_notification->updateflag.
      when 'I'.
        go_notify->notify_create(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = lv_nodename
            iv_key      = lv_key ).
      when 'U'.
        go_notify->notify_update(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = lv_nodename
            iv_key      = lv_key ).
      when 'D'.
        go_notify->notify_delete(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = lv_nodename
            iv_key      = lv_key ).
    endcase.

  endloop.


endmethod.


method ADBP_CHECK_COMMDATA_MAINTAIN.

  data: lv_no_maintain        type        sesf_boolean
      , lr_descr_struct       type ref to cl_abap_structdescr
      , lt_struct_components  type        abap_compdescr_tab
      , lr_struct_component   type ref to abap_compdescr
      , ls_node               type        suid_node_name
      .

  field-symbols:  <state>    type addr_current_state
               .

* Get fields of the structure
  lr_descr_struct ?= cl_abap_structdescr=>describe_by_data( cs_current_state ).
  lt_struct_components = lr_descr_struct->components.

  loop at lt_struct_components reference into lr_struct_component.
    clear: ls_node.

    assign component  lr_struct_component->name of structure cs_current_state
           to <state>.
*   No fitting field in change structure
    if sy-subrc <> 0.
      continue.
    endif.
*   If field is not supposed to be changed --> no check, continue
    if <state> = if_identity=>co_false.
      continue.
    endif.

*   Map change structure fields with communication data structures
    case lr_struct_component->name.
      when 'CURRENT_STATE_TEL'.
        ls_node = if_identity_definition=>gc_node_telephone.
      when 'CURRENT_STATE_FAX'.
        ls_node = if_identity_definition=>gc_node_facsimile.
      when 'CURRENT_STATE_EMAIL'.
        ls_node = if_identity_definition=>gc_node_email.
      when 'CURRENT_STATE_WEB'.
        ls_node = if_identity_definition=>gc_node_web.
      when 'CURRENT_STATE_TELEX'.
        ls_node = if_identity_definition=>gc_node_telex.
      when 'CURRENT_STATE_TELETEX'.
        ls_node = if_identity_definition=>gc_node_teletex.
      when 'CURRENT_STATE_X400'.
        ls_node = if_identity_definition=>gc_node_x400.
      when 'CURRENT_STATE_RML'.
        ls_node = if_identity_definition=>gc_node_remote_mail.
      when 'CURRENT_STATE_PRINTER'.
        ls_node = if_identity_definition=>gc_node_printer.
      when 'CURRENT_STATE_SSF'.
        ls_node = if_identity_definition=>gc_node_ssf.
      when 'CURRENT_STATE_PAGER'.
        ls_node = if_identity_definition=>gc_node_pager.
      when others.
    endcase.

    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = ls_node
        io_msg_buffer  = io_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

*   If field maintenance is not allowed ==> clear corresponding change field
    if lv_no_maintain = if_identity=>co_true.
      clear: <state>.
    endif.
  endloop.




endmethod.


method adbp_check_organization.
*
* Check company or organization
*
* Importing:
*
* - ORGTYPE = co_bp_org: BPORGANIZATION
*                        ORGADDR
* - ORGTYPE = co_company: COMPANY
* - ORGTYPE = space:      Get default company (or organization)
*
* Exporting:
*   complete ES_ORGANIZATION in case company/org exists
*   ev_org_node_id


  data: lo_addr_main        type ref to cl_addr_main
      , ls_msg              type        symsg
      , lv_readdefault      type        c
      , lv_bporg_node_id    type        addr_node_id
      , lt_key_addr         type        bup_t_addr_key_api
      , ls_key_addr         type        bup_s_addr_key_api
      , lt_failed_keys_addr type        bup_t_addr_key_api
      , lv_orgtype          type        suid_orgtype
      .


* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Read default company -------------------------------
*
  if     is_organization-orgtype is initial.

    lv_readdefault = 'X'.


* --- Check Company --------------------------------------
*
  elseif is_organization-orgtype eq if_identity=>co_company.

    call method cl_suid_organization=>check_user_company
      exporting
        iv_company = is_organization-company
      importing
        ev_orgaddr = es_organization-orgaddr
        es_msg     = ls_msg.

    if ls_msg is not initial.
      io_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
    endif.

    if es_organization-orgaddr is initial.
      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.

    es_organization-orgtype = is_organization-orgtype.
    es_organization-company = is_organization-company.


* --- Check Organization ------------------------------------------
*
  elseif is_organization-orgtype        eq if_identity=>co_bp_org    and
         is_organization-org_uuid       is not initial  and
       ( is_organization-orgaddr        is not initial or
         is_organization-orgaddr_uuid   is not initial ).


*   Get Organization node id
    if is_organization-orgaddr_uuid is initial.
      adbp_get_id(
        exporting
          io_addr_main      = lo_addr_main
          iv_address_type   = cl_addr_main=>c_organization_address
          iv_address_number = is_organization-orgaddr
        importing
          ev_addr_nodeid    = lv_bporg_node_id ).
    else.
      call method cl_suid_organization=>map_org_addr_uuid_to_id
        exporting
          iv_org_uuid     = is_organization-org_uuid
          iv_orgaddr_uuid = is_organization-orgaddr_uuid
        importing
          ev_address_id   = lv_bporg_node_id.
    endif.

    ls_key_addr-address_id   = lv_bporg_node_id.
    ls_key_addr-partner_uuid = is_organization-org_uuid.
    append ls_key_addr to lt_key_addr.

*...Check address of Organization
    cl_bup_address_api=>read(
      exporting
        it_key_addr         = lt_key_addr
      importing
        et_failed_keys_addr = lt_failed_keys_addr
    ).

    read table lt_failed_keys_addr
         with key partner_uuid = ls_key_addr-partner_uuid
                  address_id   = lv_bporg_node_id
         transporting no fields.
    if sy-subrc eq 0.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '025'.
*     ToDo Organization Address !!!!!!!!!!!!
*     MSG: Company address cannot be selected
      if 1 = 0. message e025(01). endif.

      io_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.

    es_organization = is_organization.


* --- Wrong parameters ------------------------------------------
*
  else.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname  = iv_bname.
  endif.



* --- Get Default company ---------------------------------------
*
  if lv_readdefault eq 'X'.
    clear: ls_msg.

*   Get default org, dependig on Identity Indicator
    if iv_orgtype is initial.
      if cl_identity_factory=>get_default_idadtype( ) = if_identity=>co_idad_olduser.
        lv_orgtype = if_identity=>co_company.
      else.
        lv_orgtype = if_identity=>co_bp_org.
      endif.
    else.
      lv_orgtype = iv_orgtype.
    endif.

    case lv_orgtype.
      when if_identity=>co_company.

        call method cl_suid_organization=>get_default_user_company
          importing
            es_msg         = ls_msg
            es_default_org = es_organization.

        if ls_msg is not initial.
          io_msg_buffer->add_object_message_symsg(
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_organization
              is_msg      = ls_msg
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
        endif.

        if es_organization is initial.
          ev_reject_assignment = if_identity=>co_true.
          return.
        endif.


      when if_identity=>co_bp_org.
        call method cl_suid_organization=>get_default_user_org
          importing
            es_msg         = ls_msg
            es_default_org = es_organization.
        if sy-subrc <> 0.
          io_msg_buffer->add_object_message_symsg(
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_organization
              is_msg      = ls_msg
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
        endif.
        if es_organization is initial.
          ev_reject_assignment = if_identity=>co_true.
          return.
        endif.

    endcase.
  endif.


* --- Company/Org exists: Get Organization node id ------
*
  if lv_bporg_node_id is not initial.
    ev_org_node_id = lv_bporg_node_id.
  else.
    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = es_organization-orgaddr
      importing
        ev_addr_nodeid    = ev_org_node_id ).
  endif.

endmethod.


method adbp_delete.
*
* This method deletes a user's address or the person and org assignment
*
  data: lo_addr_main             type ref to cl_addr_main
      , ls_addr_del              type        addrs_address
      , lt_addr_del              type        addrt_address
      , lt_addr_error            type        addrt_error
      , lt_office_delete         type        bcst_adrchg
      , ls_office_delete         type        bcss_adrchg
      , lv_workplace_node_id     type        addr_node_id
      .

  if ms_segment_address-before_image-idadtype   eq if_identity=>co_idad_olduser and
     ms_segment_address-before_image-addrnumber is initial and
     ms_segment_address-before_image-persnumber is initial.
    return.
  endif.

* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


* --- Evaluate workplace and organization address id ---------------------------------
*
  if ms_segment_address-before_image-idadtype eq if_identity=>co_idad_olduser         or
     ms_segment_address-before_image-idadtype eq if_identity=>co_idad_person_org_rela.

    try.

        adbp_get_id(
          exporting
            io_addr_main      = lo_addr_main
            iv_address_type   = cl_addr_main=>c_contact_partner_address
            iv_address_number = ms_segment_address-before_image-addrnumber
            iv_person_number  = ms_segment_address-before_image-persnumber
          importing
            ev_addr_nodeid    = lv_workplace_node_id ).

        if lv_workplace_node_id is initial.
          macro_raise_internal_error.
        endif.

        if ms_segment_address-actadd-org_node_id is initial.
          adbp_get_id(
            exporting
              io_addr_main      = lo_addr_main
              iv_address_type   = cl_addr_main=>c_organization_address
              iv_address_number = ms_segment_address-before_image-addrnumber
            importing
              ev_addr_nodeid    = ms_segment_address-actadd-org_node_id ).

          if ms_segment_address-actadd-org_node_id is initial.
            macro_raise_internal_error.
          endif.
        endif.

      catch cx_suid_identity.
        return.
    endtry.

  endif.


* ---- Inform SAP Office -------------------------------------------------
*
  clear: ls_office_delete, lt_office_delete.
  ls_office_delete-username        = ms_manager-bname.
  ls_office_delete-addrnumber_img  = ms_segment_address-before_image-addrnumber.
  ls_office_delete-persnumber_img  = ms_segment_address-before_image-persnumber.
  ls_office_delete-addrtype_img    = ms_segment_address-before_image-idadtype.

  append ls_office_delete to lt_office_delete.

  call method cl_so_office_user_address=>delete_user
    changing
      ct_deleted_users = lt_office_delete.

*  read table lt_office_delete into ls_office_delete index 1.
*  if ls_office_delete-rejected eq 'X'.
*    clear: ls_msg.
*    ls_msg-msgty = 'W'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '009'.
**   MSG: Fehler in SAP Office.
*    if 1 = 0. message w009(suid01). endif.
*
*    go_msg_buffer->add_object_message_symsg(
*      exporting
*        iv_bname    = ms_manager-bname
*        iv_nodename = if_identity_definition=>gc_node_organization
*        is_msg      = ls_msg
*        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
*  endif.


* ------ Delete address depending on identity model -----------
*
  case ms_segment_address-before_image-idadtype.

*...------ Type 3 address of old user -----------------------------
    when if_identity=>co_idad_olduser.

*     Delete type 3 address together with user reference
      ls_addr_del-address_id                                                  = lv_workplace_node_id.
      ls_addr_del-updateflag                                                  = cl_addr_main=>c_delete.
      ls_addr_del-delete_information-person_reference-appl_table              = co_appl_table.
      ls_addr_del-delete_information-person_reference-appl_field              = co_appl_field.
      concatenate sy-mandt ms_manager-bname into ls_addr_del-delete_information-person_reference-appl_key.
      ls_addr_del-delete_information-person_reference-pers_addr               = space.
      ls_addr_del-delete_information-person_reference-organization_address_id = ms_segment_address-actadd-org_node_id.
      ls_addr_del-delete_information-person_reference-pers_group              = co_persgroup.
      ls_addr_del-delete_information-person_reference-owner                   = 'X'.
      ls_addr_del-delete_information-retain_person                            = space. "'X'.
      append ls_addr_del to lt_addr_del.

      lo_addr_main->modify_address(
        exporting
          it_address_modification = lt_addr_del
        importing
          et_error                = lt_addr_error ).

      read table lt_addr_error
           with key msg_type = 'E'
           transporting no fields.
      if sy-subrc ne 0.
*       Register id of changed address
        append lv_workplace_node_id to ms_segment_address-actadd-changed_bas_workplace_node_id.
      endif.

*      if lt_addr_error is not initial.
*        call method addr_map_error_table
*          exporting
*            iv_msg_once      = 'X'
*            iv_msg_permanent = space
*            iv_msg_for_node  = if_identity_definition=>gc_node_organization
*            it_addr_error    = lt_addr_error.
**       return.
*      endif.



*...------ Type 3 address of BP-Org Rel ---------------------------
    when if_identity=>co_idad_person_org_rela.

*     Delete only user reference
*      ls_person_reference-appl_table              = co_appl_table.
*      ls_person_reference-appl_field              = co_appl_field.
*      concatenate sy-mandt ms_manager-bname    into ls_person_reference-appl_key.
*      ls_person_reference-pers_addr               = space.
*      ls_person_reference-organization_address_id = ms_segment_address-actadd-org_node_id.
*      ls_person_reference-pers_group              = co_persgroup.
*      ls_person_reference-owner                   = 'X'.
*
*
*        lo_addr_main->delete_person_reference(
*          exporting
*            iv_address_id       = lv_workplace_node_id
*            is_person_reference = ls_person_reference
*          importing
*            et_error            = lt_addr_error ).
*
*        read table lt_addr_error
*             with key msg_type = 'E'
*             transporting no fields.
*        if sy-subrc ne 0.
**       Register id for saving
*          ms_segment_address-actadd-bp_wp_node_id = lv_workplace_node_id.
*        endif.
**      if lt_addr_error is not initial.
**        call method addr_map_error_table
**          exporting
**            iv_msg_once      = 'X'
**            iv_msg_permanent = space
**            iv_msg_for_node  = if_identity_definition=>gc_node_organization
**            it_addr_error    = lt_addr_error.
**      endif.

  endcase.


endmethod.


method adbp_get_id.

  data: ls_addr_key         type        addrs_address_key
      , lt_addr_key         type        addrt_address_key
      , lt_addr_key_to_id   type        addrt_key_to_id
      , lr_addr_key_to_id   type ref to addrs_key_to_id
      .


  ls_addr_key-address_type   = iv_address_type.
  ls_addr_key-address_number = iv_address_number.
  ls_addr_key-person_number  = iv_person_number.
  append ls_addr_key to lt_addr_key.

  call method io_addr_main->convert_key_to_id
    exporting
      it_address_key           = lt_addr_key
      iv_retrieve_before_image = iv_request_before_image
    importing
      et_key_to_id             = lt_addr_key_to_id.

  read table lt_addr_key_to_id
       reference into lr_addr_key_to_id
       with key address_type   = iv_address_type
                address_number = iv_address_number
                person_number  = iv_person_number.
  if sy-subrc eq 0.
    ev_addr_nodeid = lr_addr_key_to_id->address_id.
  else.
*   This should not happen
    raise exception type cx_suid_identity
      exporting
        textid         = cx_suid_identity=>internal_address_error
        address_type   = iv_address_type
        address_number = iv_address_number
        person_number  = iv_person_number.

  endif.



endmethod.


method adbp_get_property_for_node.


  data: lt_properties       type        if_suid_property_handler=>tt_properties
      , lr_property         type ref to if_suid_property_handler=>ty_property
      , lt_node_fields      type        suid_tt_fields
      , lr_node_field       type ref to suid_node_field
      , lo_property_handler type ref to cl_suid_property_handler
      .

  lo_property_handler = cl_suid_property_handler=>get_instance( ).

  call method lo_property_handler->get_field_properties
    exporting
      io_identity   = me
      iv_node_name  = iv_nodename
    importing
      et_properties = lt_properties.


  if iv_readonly is supplied.
    read table lt_properties reference into lr_property
         with key idref          = me
                  node_name      = iv_nodename
                  field_name     = space
                  property_name  = if_suid_property_handler=>co_read_only
         binary search.
    if sy-subrc eq 0.
      ev_readonly = lr_property->property_value.
    else.
*     Check fields of node
      call method cl_suid_tools=>get_node_fields
        exporting
          iv_node_name   = iv_nodename
        importing
          et_node_fields = lt_node_fields.

      ev_readonly = if_identity=>co_true.

      loop at lt_node_fields reference into lr_node_field.
        read table lt_properties reference into lr_property
             with key idref          = me
                      node_name      = iv_nodename
                      field_name     = lr_node_field->*
                      property_name  = if_suid_property_handler=>co_read_only
             binary search.
        if sy-subrc ne 0.
          ev_readonly = if_identity=>co_false.
          exit.
        elseif lr_property->property_value eq if_identity=>co_false.
          ev_readonly = if_identity=>co_false.
          exit.
        endif.
      endloop.

      if iv_nodename eq if_identity_definition=>gc_node_workplace and
         ev_readonly eq if_identity=>co_true.

        clear: lt_properties.
        call method lo_property_handler->get_field_properties
          exporting
            io_identity   = me
            iv_node_name  = if_identity_definition=>gc_node_telephone
          importing
            et_properties = lt_properties.

        read table lt_properties reference into lr_property
             with key idref          = me
                      node_name      = if_identity_definition=>gc_node_telephone
                      field_name     = space
                      property_name  = if_suid_property_handler=>co_read_only
             binary search.
        if sy-subrc ne 0.
          ev_readonly = if_identity=>co_false.
        elseif lr_property->property_value eq if_identity=>co_false.
          ev_readonly = if_identity=>co_false.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_facsimile
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_facsimile
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_email
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_email
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_web
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_web
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_telex
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_telex
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_teletex
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_teletex
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_remote_mail
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_remote_mail
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_x400
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_x400
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_printer
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_printer
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_ssf
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_ssf
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

        if ev_readonly eq if_identity=>co_true.
          clear: lt_properties.
          call method lo_property_handler->get_field_properties
            exporting
              io_identity   = me
              iv_node_name  = if_identity_definition=>gc_node_pager
            importing
              et_properties = lt_properties.

          read table lt_properties reference into lr_property
               with key idref          = me
                        node_name      = if_identity_definition=>gc_node_pager
                        field_name     = space
                        property_name  = if_suid_property_handler=>co_read_only
               binary search.
          if sy-subrc ne 0.
            ev_readonly = if_identity=>co_false.
          elseif lr_property->property_value eq if_identity=>co_false.
            ev_readonly = if_identity=>co_false.
          endif.
        endif.

      endif.

      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = ev_readonly
          io_identity  = me
          iv_node_name = iv_nodename.

    endif.
  endif.

  if iv_enable is supplied.
    read table lt_properties reference into lr_property
         with key idref          = me
                  node_name      = iv_nodename
                  field_name     = space
                  property_name  = if_suid_property_handler=>co_enabled
         binary search.
    if sy-subrc eq 0.
      ev_enable = lr_property->property_value.
    else.
      ev_enable = if_identity=>co_true.
    endif.
  endif.



endmethod.


method ADBP_MAP_CHANGE_FIELD.

  data: lo_descr                 type ref to cl_abap_structdescr
      , lr_descr                 type ref to abap_compdescr
      , lv_addr_fieldname        type        addr_fieldname
      , lr_change_field          type ref to suid_node_field
      .


  if it_change_fields is initial.

    if iv_nodename eq if_identity_definition=>gc_node_person_name.
      lo_descr ?= cl_abap_typedescr=>describe_by_name( if_identity_definition=>gc_node_person_name ).

      loop at lo_descr->components reference into lr_descr.
        case lr_descr->name.
          when 'PERS_NO'.
            continue.
          when 'LANGU'.
            concatenate 'COMMUNICATION_PREFERENCE' '-' lr_descr->name into lv_addr_fieldname.
          when others.
            concatenate 'PERSON_NAME' '-' lr_descr->name into lv_addr_fieldname.
        endcase.
        append lv_addr_fieldname to ct_addr_change_fields.
      endloop.

    elseif iv_nodename eq if_identity_definition=>gc_node_workplace.
      lo_descr ?= cl_abap_typedescr=>describe_by_name( if_identity_definition=>gc_node_workplace ).

      loop at lo_descr->components reference into lr_descr.
        case lr_descr->name.
          when 'DEFLT_COMM'.
            concatenate 'COMMUNICATION_PREFERENCE' '-' lr_descr->name into lv_addr_fieldname.
          when others.
            concatenate 'WORKPLACE' '-' lr_descr->name into lv_addr_fieldname.
        endcase.
        append lv_addr_fieldname to ct_addr_change_fields.
      endloop.
    endif.

  else.

    if iv_nodename eq if_identity_definition=>gc_node_person_name.

      loop at it_change_fields reference into lr_change_field.
        case lr_change_field->*.
          when 'PERS_NO'.
            continue.
          when 'LANGU'.
            concatenate 'COMMUNICATION_PREFERENCE' '-' lr_change_field->* into lv_addr_fieldname.
          when others.
            concatenate 'PERSON_NAME' '-' lr_change_field->* into lv_addr_fieldname.
        endcase.
        append lv_addr_fieldname to ct_addr_change_fields.
      endloop.

    elseif iv_nodename eq if_identity_definition=>gc_node_workplace.

      loop at it_change_fields reference into lr_change_field.
        case lr_change_field->*.
          when 'DEFLT_COMM'.
            concatenate 'COMMUNICATION_PREFERENCE' '-' lr_change_field->* into lv_addr_fieldname.
          when others.
            concatenate 'WORKPLACE' '-' lr_change_field->* into lv_addr_fieldname.
        endcase.
        append lv_addr_fieldname to ct_addr_change_fields.
      endloop.

    endif.

  endif.


endmethod.


method adbp_read_org_address.

  data: lo_addr_main        type ref to cl_addr_main
      , lv_org_nodeid       type        addr_node_id
      , lt_addr_id          type        addrt_address_id
      , lt_address          type        addrt_address
      , lr_address          type ref to addrs_address
      , lr_addr_version     type ref to addrs_version
      , lr_notes            type ref to addrs_note
      .

* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Read address ---------------------------------------------

* Convert to NodeID
  if iv_orgaddrid is not initial.
    lv_org_nodeid = iv_orgaddrid.
  else.
    call method adbp_get_id
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = iv_orgnum
      importing
        ev_addr_nodeid    = lv_org_nodeid.
  endif.

* Read address
  append lv_org_nodeid to lt_addr_id.
  call method lo_addr_main->retrieve_address
    exporting
      it_address_id = lt_addr_id
    importing
      et_address    = lt_address.

  read table lt_address
       reference into lr_address
       with key address_id = lv_org_nodeid.
  if sy-subrc ne 0.
*   Address does not exist
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error.
  endif.

  read table lr_address->data
       reference into lr_addr_version
       with key nation = space.
  if sy-subrc ne 0.
*   Address does not exist
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error.
  endif.



* --- Copy address -----------------------------------------
  if es_location is supplied.
    move-corresponding lr_addr_version->location           to es_location."#EC ENHOK
    move lr_addr_version->communication_preference-langu   to es_location-langu.
    read table lr_addr_version->notes reference into lr_notes
         with key langu = sy-langu.
    if sy-subrc eq 0.
      move lr_notes->remark                                to es_location-remark.
    endif.
  endif.

  if es_organization_name is supplied.
    move-corresponding lr_addr_version->organization_name  to es_organization_name."#EC ENHOK
  endif.


endmethod.


method adbp_set_property_for_node.


  data: lt_node_fields      type        suid_tt_fields
      , lr_node_field       type ref to suid_node_field
      , lt_properties       type        if_suid_property_handler=>tt_properties
      , lr_property         type ref to if_suid_property_handler=>ty_property
      , lv_set_readonly     type        sesf_boolean
      , lv_set_enable       type        sesf_boolean
      , lo_property_handler type ref to cl_suid_property_handler
      .

* Check if something has to be done
  lo_property_handler = cl_suid_property_handler=>get_instance( ).

  call method lo_property_handler->get_field_properties
    exporting
      io_identity   = me
      iv_node_name  = iv_nodename
    importing
      et_properties = lt_properties.

  if iv_readonly is supplied.
    read table lt_properties reference into lr_property
          with key idref          = me
                  node_name      = iv_nodename
                  field_name     = space
                  property_name  = if_suid_property_handler=>co_read_only
          binary search.
    if sy-subrc eq 0.
      if iv_readonly ne lr_property->property_value.
        lv_set_readonly = if_identity=>co_true.
      endif.
    else.
      if iv_readonly eq if_identity=>co_true.
        lv_set_readonly = if_identity=>co_true.
      endif.
    endif.
  endif.

  if iv_enable is supplied.
    read table lt_properties reference into lr_property
          with key idref          = me
                  node_name      = iv_nodename
                  field_name     = space
                  property_name  = if_suid_property_handler=>co_enabled
          binary search.
    if sy-subrc eq 0.
      if iv_enable ne lr_property->property_value.
        lv_set_enable = if_identity=>co_true.
      endif.
    else.
      if iv_enable eq if_identity=>co_false.
        lv_set_enable = if_identity=>co_true.
      endif.
    endif.
  endif.


  if lv_set_readonly eq if_identity=>co_false and
      lv_set_enable   eq if_identity=>co_false.
    return.
  endif.


  call method cl_suid_tools=>get_node_fields
    exporting
      iv_node_name   = iv_nodename
    importing
      et_node_fields = lt_node_fields.


* ---- Read Only --------------------------------------------------
  if lv_set_readonly eq if_identity=>co_true.

    loop at lt_node_fields reference into lr_node_field.
      call method lo_property_handler->set_field_read_only
        exporting
          iv_value      = iv_readonly
          io_identity   = me
          iv_node_name  = iv_nodename
          iv_field_name = lr_node_field->*.
    endloop.
    call method lo_property_handler->set_node_read_only
      exporting
        iv_value     = iv_readonly
        io_identity  = me
        iv_node_name = iv_nodename.


    if iv_nodename eq if_identity_definition=>gc_node_workplace.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_telephone.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_facsimile.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_email.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_web.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_telex.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_teletex.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_remote_mail.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_x400.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_printer.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_ssf.
      call method lo_property_handler->set_node_read_only
        exporting
          iv_value     = iv_readonly
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_pager.
    endif.
  endif.


* ---- Enable -----------------------------------------------------
  if lv_set_enable eq if_identity=>co_true.

    loop at lt_node_fields reference into lr_node_field.
      call method lo_property_handler->set_field_enabled
        exporting
          iv_value      = iv_enable
          io_identity   = me
          iv_node_name  = iv_nodename
          iv_field_name = lr_node_field->*.
    endloop.

    call method lo_property_handler->set_node_enabled
      exporting
        iv_value     = iv_enable
        io_identity  = me
        iv_node_name = iv_nodename.


    if iv_nodename eq if_identity_definition=>gc_node_workplace.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_telephone.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_facsimile.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_email.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_web.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_telex.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_teletex.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_remote_mail.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_x400.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_printer.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_ssf.
      call method lo_property_handler->set_node_enabled
        exporting
          iv_value     = iv_enable
          io_identity  = me
          iv_node_name = if_identity_definition=>gc_node_pager.
    endif.

  endif.

endmethod.


  method addr_adjust_timzone.
    " Copy timezone of company to defaults-timezone only if
    " - defaults-timezone is initial
    " - CUA allows field change
    " No messages, infos...

    data: ls_location       type suid_st_node_location
        , ls_defaults       type suid_st_node_defaults
        , lt_change_fields  type suid_tt_fields
        , lv_error_found    type sesf_boolean
        , lv_no_maintain    type sesf_boolean
        .

    " Read timezone
    call method me->get_defaults
      importing
        es_defaults = ls_defaults.

    " If timezone is already set -> ignore Company timezone
    if ls_defaults-tzone is not initial.
      return.
    endif.

    " CUA: Check SCUM setting for Timezone
    if gv_cua_child eq if_identity=>co_true.
      call method cua_if_field_no_maintain
        exporting
          iv_node_name   = if_identity_definition=>gc_node_defaults
          iv_field_name  = if_identity_definition=>gc_field_defaults_tzone
        receiving
          rv_no_maintain = lv_no_maintain.
      if lv_no_maintain eq if_identity=>co_true.
        " Timezone cannot be set -> return
        return.
      endif.
    endif.

    " Read company time zone
    call method me->if_identity_person~get_organization
      exporting
        iv_get_location = if_identity=>co_true
      importing
        es_location     = ls_location.

    " Check company timezone
    if ls_location-time_zone is initial.
      return.
    endif.


    " ------------------------------------------------
    " Copy company time zone into empty defaults field
    clear: lt_change_fields.
    append if_identity_definition=>gc_field_defaults_tzone to lt_change_fields.
    ls_defaults-tzone = ls_location-time_zone.

    call method me->if_identity~set_defaults
      exporting
        is_defaults      = ls_defaults
        it_change_fields = lt_change_fields.

    call method go_msg_buffer->find_error_for_node_field
      exporting
        iv_bname          = ms_manager-bname
        iv_nodename       = if_identity_definition=>gc_node_defaults
        iv_field          = if_identity_definition=>gc_field_defaults_tzone
        iv_permanent_only = if_identity=>co_true
      receiving
        ev_error          = lv_error_found.

    if lv_error_found eq if_identity=>co_true.
      " Timezone can't be changed -> No message

      " Delete original messages
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname             = ms_manager-bname
          iv_nodename          = if_identity_definition=>gc_node_defaults
          iv_field             = if_identity_definition=>gc_field_defaults_tzone
          iv_lifetimeonce_only = space.

      " Set timezone back to SPACE
      clear: lt_change_fields
           , ls_defaults-tzone
           .
      append if_identity_definition=>gc_field_defaults_tzone to lt_change_fields.
      call method me->if_identity~set_defaults
        exporting
          is_defaults      = ls_defaults
          it_change_fields = lt_change_fields.
    endif.

  endmethod.


method addr_change_address.
*
* This method is either called to change the PERSON_NAME
* or WORKPLACE node !!
*

  data: lo_addr_main             type ref to cl_addr_main
      , lv_use_changed_fields    type        xfeld
      , ls_addr_mod_version      type        addrs_version
      , ls_addr_mod              type        addrs_address
      , lt_addr_mod              type        addrt_address
      , lt_addr_check_nodes      type        addrt_address_id
      , lt_addr_notifications    type        addrt_change_notification
      , lt_addr_error            type        addrt_error
      , lt_addr_change_fields    type        addrt_changed_fields
      , ls_check_personname      type        suid_st_node_person_name
      , ls_msg                   type        symsg
      .


  " Consistence check
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser.
    macro_raise_internal_error.
  endif.

  " Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


  " --- Evaluate workplace address id ---------------------------------
  "
  if ms_segment_address-actadd-bas_wp_node_id is initial.

    if ms_segment_address-actual-persnumber is initial.
      macro_raise_internal_error.
    endif.

    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_contact_partner_address
        iv_address_number = ms_segment_address-actual-addrnumber
        iv_person_number  = ms_segment_address-actual-persnumber
      importing
        ev_addr_nodeid    = ms_segment_address-actadd-bas_wp_node_id ).

    if ms_segment_address-actadd-bas_wp_node_id is initial.
      macro_raise_internal_error.
    endif.

  endif.


  " --- Map change_fields table -----------------------------------------
  "
  " Map either PERSON_NAME or WORKPLACE
  adbp_map_change_field(
    exporting
      iv_nodename           = iv_change_node
      it_change_fields      = it_change_fields
    changing
      ct_addr_change_fields = lt_addr_change_fields ).


  " Fill changed fields
  if not lt_addr_change_fields is initial.

    lv_use_changed_fields              = 'X'.
    ls_addr_mod_version-changed_fields = lt_addr_change_fields.

    " --- Copy Person_Name or Workplace to BAS structure ------------------
    "
    if     iv_change_node eq if_identity_definition=>gc_node_person_name.
      move-corresponding is_personname to ls_addr_mod_version-person_name."#EC ENHOK
      move is_personname-langu         to ls_addr_mod_version-communication_preference-langu.
    elseif iv_change_node eq if_identity_definition=>gc_node_workplace.
      move-corresponding is_workplace  to ls_addr_mod_version-workplace."#EC ENHOK
      move is_workplace-deflt_comm     to ls_addr_mod_version-communication_preference-deflt_comm.
    else.
      macro_raise_internal_error.
    endif.


    " --- Change old user "type 3" address ---------------------------------
    "
    " Change person name
    ls_addr_mod-address_id           = ms_segment_address-actadd-bas_wp_node_id.
    ls_addr_mod-updateflag           = cl_addr_main=>c_update.
    ls_addr_mod_version-nation       = space.
    ls_addr_mod_version-updateflag   = cl_addr_main=>c_update.
    append ls_addr_mod_version to ls_addr_mod-data.
    append ls_addr_mod         to lt_addr_mod.

    " Modify address
    lo_addr_main->modify_address(
      exporting
        it_address_modification = lt_addr_mod
        iv_use_changed_fields   = lv_use_changed_fields
      importing
        et_change_notifications = lt_addr_notifications
        et_error                = lt_addr_error ).

    " Read process messages
    if lt_addr_error is not initial.
      addr_map_error_table(
        exporting
          iv_msg_once         = 'X'
          iv_msg_permanent    = space
          iv_msg_for_node     = iv_change_node
          it_addr_error       = lt_addr_error ).
    endif.

  endif.

  " Read permanent messages
  append ms_segment_address-actadd-bas_wp_node_id to lt_addr_check_nodes.
  call method lo_addr_main->check
    exporting
      it_node_id = lt_addr_check_nodes
    importing
      et_error   = lt_addr_error.

  if lt_addr_error is not initial.
    addr_map_error_table(
      exporting
        iv_msg_once         = space
        iv_msg_permanent    = 'X'
        iv_msg_for_node     = iv_change_node
        it_addr_error       = lt_addr_error ).
  endif.

  " Notification, if there is any address notification
  if lt_addr_notifications is not initial.

    if iv_change_node eq if_identity_definition=>gc_node_person_name.
      go_notify->notify_update(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person_name ).
      ms_segment_address-actadd-changed_person_name = if_identity=>co_true.
    else.
      go_notify->notify_update(
                  exporting
                    iv_bname    = ms_manager-bname
                    iv_nodename = if_identity_definition=>gc_node_workplace ).
      ms_segment_address-actadd-changed_workplace_data = if_identity=>co_true.
    endif.

    " Register ID of changed address
    append ms_segment_address-actadd-bas_wp_node_id to ms_segment_address-actadd-changed_bas_workplace_node_id.

  endif.


  " Check Last Name in CREATE mode
  if ( ms_manager-modus eq go_persistence->co_ta_modus_create    or
       ms_manager-modus eq go_persistence->co_ta_modus_modify )  and
     iv_change_node     eq if_identity_definition=>gc_node_person_name.

    call method addr_read_address
      importing
        es_personname = ls_check_personname.

    if ls_check_personname-name_last is initial.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '092'.
      " MSG: Nachname eines Benutzers muss angegeben werden!
      if 1 = 0. message e092(01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname     = ms_manager-bname
          iv_nodename  = if_identity_definition=>gc_node_person_name
          iv_field     = 'NAME_LAST'
          is_msg       = ls_msg ).

    endif.

  endif.

endmethod.


method addr_change_communication_data.

  data: lo_addr_main             type ref to cl_addr_main
      , lt_addr_telephone        type        addrt_telephone_numbers
      , lt_addr_facsimile        type        addrt_facsimile_numbers
      , lt_addr_email            type        addrt_email_addresses
      , lt_addr_web              type        addrt_web_addresses
      , lt_addr_telex            type        addrt_telex_numbers
      , lt_addr_teletex          type        addrt_teletex_numbers
      , lt_addr_rml              type        addrt_remote_mail_addresses
      , lt_addr_x400             type        addrt_x400_addresses
      , lt_addr_printer          type        addrt_printers
      , lt_addr_ssf              type        addrt_ssf_addresses
      , lt_addr_pager            type        addrt_pager_numbers
      , ls_addr_telephone        type        addrs_telephone_numbers
      , ls_addr_facsimile        type        addrs_facsimile_numbers
      , ls_addr_email            type        addrs_email_addresses
      , ls_addr_web              type        addrs_web_addresses
      , ls_addr_telex            type        addrs_telex_numbers
      , ls_addr_teletex          type        addrs_teletex_numbers
      , ls_addr_rml              type        addrs_remote_mail_addresses
      , ls_addr_x400             type        addrs_x400_addresses
      , ls_addr_printer          type        addrs_printers
      , ls_addr_ssf              type        addrs_ssf_addresses
      , ls_addr_pager            type        addrs_pager_numbers
      , lt_addr_error            type        addrt_error
      , lt_addr_notifications    type        addrt_change_notification
      .


* Consistence check
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser.
    macro_raise_internal_error.
  endif.

* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Evaluate "type 3" address id ---------------------------------
*
  if ms_segment_address-actadd-bas_wp_node_id is initial.
    if ms_segment_address-actual-persnumber is initial.
      macro_raise_internal_error.
    endif.
    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_contact_partner_address
        iv_address_number = ms_segment_address-actual-addrnumber
        iv_person_number  = ms_segment_address-actual-persnumber
      importing
        ev_addr_nodeid    = ms_segment_address-actadd-bas_wp_node_id ).

    if ms_segment_address-actadd-bas_wp_node_id is initial.
      macro_raise_internal_error.
    endif.
  endif.


* --- Change old user "type 3" address ---------------------------------
*
* Map tables
  ls_addr_telephone-address_id    = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_telephone-data          = it_telephone.
  ls_addr_telephone-current_state = is_current_state-current_state_tel.
  if ls_addr_telephone-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_telephone-data ).
  endif.
  append ls_addr_telephone       to lt_addr_telephone.

  ls_addr_facsimile-address_id    = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_facsimile-data          = it_facsimile.
  ls_addr_facsimile-current_state = is_current_state-current_state_fax.
  if ls_addr_facsimile-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_facsimile-data ).
  endif.
  append ls_addr_facsimile       to lt_addr_facsimile.

  ls_addr_email-address_id        = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_email-data              = it_email.
  ls_addr_email-current_state     = is_current_state-current_state_email.
  if ls_addr_email-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_email-data ).
  endif.
  append ls_addr_email           to lt_addr_email.

  ls_addr_web-address_id          = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_web-data                = it_web.
  ls_addr_web-current_state       = is_current_state-current_state_web.
  if ls_addr_web-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_web-data ).
  endif.
  append ls_addr_web             to lt_addr_web.

  ls_addr_telex-address_id        = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_telex-data              = it_telex.
  ls_addr_telex-current_state     = is_current_state-current_state_telex.
  if ls_addr_telex-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_telex-data ).
  endif.
  append ls_addr_telex           to lt_addr_telex.

  ls_addr_teletex-address_id      = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_teletex-data            = it_teletex.
  ls_addr_teletex-current_state   = is_current_state-current_state_teletex.
  if ls_addr_teletex-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_teletex-data ).
  endif.
  append ls_addr_teletex         to lt_addr_teletex.

  ls_addr_rml-address_id          = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_rml-data                = it_rml.
  ls_addr_rml-current_state       = is_current_state-current_state_rml.
  if ls_addr_rml-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_rml-data ).
  endif.
  append ls_addr_rml             to lt_addr_rml.

  ls_addr_x400-address_id         = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_x400-data               = it_x400.
  ls_addr_x400-current_state      = is_current_state-current_state_x400.
  if ls_addr_x400-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_x400-data ).
  endif.
  append ls_addr_x400            to lt_addr_x400.

  ls_addr_printer-address_id      = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_printer-data            = it_printer.
  ls_addr_printer-current_state   = is_current_state-current_state_printer.
  if ls_addr_printer-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_printer-data ).
  endif.
  append ls_addr_printer         to lt_addr_printer.

  ls_addr_ssf-address_id          = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_ssf-data                = it_ssf.
  ls_addr_ssf-current_state       = is_current_state-current_state_ssf.
  if ls_addr_ssf-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_ssf-data ).
  endif.
  append ls_addr_ssf             to lt_addr_ssf.

  ls_addr_pager-address_id        = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_pager-data              = it_pager.
  ls_addr_pager-current_state     = is_current_state-current_state_pager.
  if ls_addr_pager-current_state is initial.
    addr_map_commdata( changing ct_comm_table = ls_addr_pager-data ).
  endif.
  append ls_addr_pager           to lt_addr_pager.


* Modify communication data
  call method lo_addr_main->modify_communication_data
    exporting
      it_telephone_modification = lt_addr_telephone
      it_facsimile_modification = lt_addr_facsimile
      it_email_modification     = lt_addr_email
      it_web_modification       = lt_addr_web
      it_telex_modification     = lt_addr_telex
      it_teletex_modification   = lt_addr_teletex
      it_rml_modification       = lt_addr_rml
      it_x400_modification      = lt_addr_x400
      it_printer_modification   = lt_addr_printer
      it_ssf_modification       = lt_addr_ssf
      it_pager_modification     = lt_addr_pager
      iv_use_changed_fields     = 'X'                 "Always use changed_fields, can be overwritten with current_state
    importing
      et_new_telephone_id       = et_new_telephone_id
      et_new_facsimile_id       = et_new_facsimile_id
      et_new_email_id           = et_new_email_id
      et_new_web_id             = et_new_web_id
      et_new_telex_id           = et_new_telex_id
      et_new_teletex_id         = et_new_teletex_id
      et_new_rml_id             = et_new_rml_id
      et_new_x400_id            = et_new_x400_id
      et_new_printer_id         = et_new_printer_id
      et_new_ssf_id             = et_new_ssf_id
      et_new_pager_id           = et_new_pager_id
      et_change_notifications   = lt_addr_notifications
      et_error                  = lt_addr_error.


* Errorhandling
  if lt_addr_error is not initial.
    call method addr_map_error_table
      exporting
        it_addr_error = lt_addr_error.

  endif.

* Start: Check influence to workplace node
  data: lt_addr_check_nodes      type        addrt_address_id.
  clear: lt_addr_error.

  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace
      iv_field    = 'DEFLT_COMM'.

  append ms_segment_address-actadd-bas_wp_node_id to lt_addr_check_nodes.
  call method lo_addr_main->check
    exporting
      it_node_id = lt_addr_check_nodes
    importing
      et_error   = lt_addr_error.

  delete lt_addr_error
   where node_name ne cl_addr_main=>c_node_communication_preferenc
      or fieldname ne 'DEFLT_COMM'.

  if lt_addr_error is not initial.
    addr_map_error_table(
      exporting
        iv_msg_once         = space
        iv_msg_permanent    = 'X'
        iv_msg_for_node     = if_identity_definition=>gc_node_workplace
        it_addr_error       = lt_addr_error ).
  endif.
* End: Check influence to workplace node


* Notification, if there is any address notification
  if lt_addr_notifications is not initial.
    call method adbp_add_notifications
      exporting
        it_addr_notifications = lt_addr_notifications.

*   Register ID of changed address
    append ms_segment_address-actadd-bas_wp_node_id to ms_segment_address-actadd-changed_bas_workplace_node_id.
    ms_segment_address-actadd-changed_comm_data = if_identity=>co_true.
  endif.


endmethod.


method addr_create_address.

  data: lo_addr_main             type ref to cl_addr_main
      , lv_workplace_node_id     type        addr_node_id
      , ls_addr_mod_version      type        addrs_version
      , ls_addr_mod              type        addrs_address
      , lt_addr_mod              type        addrt_address
      , lt_new_addr_id           type        addrt_created_id
      , lr_new_addr_id           type ref to addrs_created_id
*     , lt_addr_notifications    type        addrt_change_notification
      , lt_addr_error            type        addrt_error
      , ls_person_reference      type        addrs_person_reference
      , lv_office_created        type        os_boolean
      , ls_msg                   type        symsg
      .


* --- Consistency check -----------------------------------------------
*
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser.
    macro_raise_internal_error.
  endif.

  if iv_org_node_id is  initial.
    macro_raise_internal_error.
  endif.


* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Create address (First existence check of address ?) ----------------------
*
  ls_addr_mod-address_id                         = ms_manager-bname.        " Temp Key
  ls_addr_mod-updateflag                         = cl_addr_main=>c_insert.  " Insert address
  ls_addr_mod_version-nation                     = space.
  ls_addr_mod_version-updateflag                 = cl_addr_main=>c_insert.
  ls_addr_mod-insert_information-address_type    = cl_addr_main=>c_contact_partner_address.
  ls_addr_mod-insert_information-organization_id = iv_org_node_id.
  ls_addr_mod-insert_information-pers_group      = co_persgroup.
  append ls_addr_mod_version to ls_addr_mod-data.
  append ls_addr_mod         to lt_addr_mod.

* Create address
  call method lo_addr_main->modify_address
    exporting
      it_address_modification = lt_addr_mod
      iv_use_changed_fields   = space
    importing
      et_new_address_id       = lt_new_addr_id
      et_error                = lt_addr_error.

* Get final key
  read table lt_new_addr_id reference into lr_new_addr_id
       with key temporary_id = ms_manager-bname.
  if sy-subrc eq 0.
*   Address was created
    lv_workplace_node_id = lr_new_addr_id->final_id.

    if lt_addr_error is not initial.
      call method addr_map_error_table
        exporting
          iv_msg_once      = 'X'
          iv_msg_permanent = space
          iv_msg_for_node  = if_identity_definition=>gc_node_organization
          it_addr_error    = lt_addr_error.
    endif.
  else.
*   Address could not be created -> Add process messaged and exit
    call method addr_map_error_table
      exporting
        iv_msg_once      = 'X'
        iv_msg_permanent = space
        iv_msg_for_node  = if_identity_definition=>gc_node_organization
        it_addr_error    = lt_addr_error.

    ev_reject_assignment = if_identity=>co_true.

    return.
  endif.


* --- Add user referenence -----------------------------------------------
*
  ls_person_reference-appl_table              = co_appl_table.
  ls_person_reference-appl_field              = co_appl_field.
  concatenate sy-mandt ms_manager-bname    into ls_person_reference-appl_key.
  ls_person_reference-pers_addr               = space.
  ls_person_reference-organization_address_id = iv_org_node_id.
  ls_person_reference-pers_group              = co_persgroup.
  ls_person_reference-owner                   = 'X'.

  call method lo_addr_main->add_person_reference
    exporting
      iv_address_id       = lv_workplace_node_id
      is_person_reference = ls_person_reference
    importing
      et_error            = lt_addr_error.

* Error handling
  if lt_addr_error is not initial.
    call method addr_map_error_table
      exporting
        iv_msg_once      = 'X'
        iv_msg_permanent = space
        iv_msg_for_node  = if_identity_definition=>gc_node_organization
        it_addr_error    = lt_addr_error.
  endif.


* --- Add SAP Office referenence -----------------------------------------------
  call method cl_so_office_user_address=>create_reference
    exporting
      i_username       = ms_manager-bname
      i_address_id     = lv_workplace_node_id
      i_org_address_id = iv_org_node_id
    importing
      e_created        = lv_office_created.
  if lv_office_created eq space.
    clear: ls_msg.
    ls_msg-msgty = 'W'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '009'.
*   MSG: Fehler in SAP Office.
    if 1 = 0. message w009(suid01). endif.

    go_msg_buffer->add_object_message_symsg(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
  endif.


* --- Modify actual buffer -----------------------------------------------
*

* Notification
  go_notify->notify_create(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).
  go_notify->notify_create(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).


  clear: ms_segment_address-actual-bpperson,
         ms_segment_address-actual-organization.

  ms_segment_address-actual-idadtype           = if_identity=>co_idad_olduser.
  ms_segment_address-actual-mandt              = sy-mandt.
  ms_segment_address-actual-bname              = ms_manager-bname.
  ms_segment_address-actual-persnumber         = space.  " New Personnumber in Finalize !
  ms_segment_address-actual-addrnumber         = is_organization-orgaddr.
  ms_segment_address-actadd-bas_wp_node_id     = lv_workplace_node_id.
  ms_segment_address-actadd-org_node_id        = iv_org_node_id.

* Register ID of changed BAS addresses
  append lv_workplace_node_id to ms_segment_address-actadd-changed_bas_workplace_node_id.


endmethod.


method addr_delete_address.

  data: ls_msg                type        symsg
      , lo_addr_main          type ref to cl_addr_main
      , ls_addr_del           type        addrs_address
      , lt_addr_del           type        addrt_address
*     , lt_addr_notification  type        addrt_change_notification
      , lt_addr_error         type        addrt_error
      , lv_office_deleted     type        os_boolean
      .


* --- Consistency check -----------------------------------------------
*
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser.
    macro_raise_internal_error.
  endif.

* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Evaluate workplace address id ---------------------------------
*
  if ms_segment_address-actadd-bas_wp_node_id is initial.
    if ms_segment_address-actual-persnumber is initial.
      macro_raise_internal_error.
    endif.

    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_contact_partner_address
        iv_address_number = ms_segment_address-actual-addrnumber
        iv_person_number  = ms_segment_address-actual-persnumber
      importing
        ev_addr_nodeid    = ms_segment_address-actadd-bas_wp_node_id ).

    if ms_segment_address-actadd-bas_wp_node_id is initial.
      macro_raise_internal_error.
    endif.
  endif.


* --- Evaluate workplace address id ---------------------------------
*
  if ms_segment_address-actadd-org_node_id is initial.
    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = ms_segment_address-actual-addrnumber
      importing
        ev_addr_nodeid    = ms_segment_address-actadd-org_node_id ).

    if ms_segment_address-actadd-org_node_id is initial.
      macro_raise_internal_error.
    endif.
  endif.


* --- Delete SAP Office reference -----------------------------------------
*
  cl_so_office_user_address=>delete_reference(
    exporting
      i_username       = ms_manager-bname
      i_address_id     = ms_segment_address-actadd-bas_wp_node_id
      i_org_address_id = ms_segment_address-actadd-org_node_id
    importing
      e_deleted        = lv_office_deleted ).
  if lv_office_deleted eq space.
    clear: ls_msg.
    ls_msg-msgty = 'W'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '009'.
*   MSG: Fehler in SAP Office.
    if 1 = 0. message w009(suid01). endif.

    go_msg_buffer->add_object_message_symsg(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
  endif.


* --- Delete workplace address --------------------------------------------
*
* Delete type 3 address together with user reference
  ls_addr_del-address_id                                                  = ms_segment_address-actadd-bas_wp_node_id.
  ls_addr_del-updateflag                                                  = cl_addr_main=>c_delete.
  ls_addr_del-delete_information-person_reference-appl_table              = co_appl_table.
  ls_addr_del-delete_information-person_reference-appl_field              = co_appl_field.
  concatenate sy-mandt ms_manager-bname into ls_addr_del-delete_information-person_reference-appl_key.
  ls_addr_del-delete_information-person_reference-pers_addr               = space.
  ls_addr_del-delete_information-person_reference-organization_address_id = ms_segment_address-actadd-org_node_id.
  ls_addr_del-delete_information-person_reference-pers_group              = co_persgroup.
  ls_addr_del-delete_information-person_reference-owner                   = 'X'.
  ls_addr_del-delete_information-retain_person                            = space. "'X'.
  append ls_addr_del to lt_addr_del.

  lo_addr_main->modify_address(
    exporting
      it_address_modification = lt_addr_del
    importing
*     et_change_notifications = lt_addr_notification
      et_error                = lt_addr_error ).

  if lt_addr_error is not initial.
    call method addr_map_error_table
      exporting
        iv_msg_once      = 'X'
        iv_msg_permanent = space
        iv_msg_for_node  = if_identity_definition=>gc_node_organization
        it_addr_error    = lt_addr_error.

*    return. TODO Notifications auswerten !!!
  endif.


* --- Modify actual buffer -----------------------------------------------
*

* Register id of changed address
  append ms_segment_address-actadd-bas_wp_node_id to ms_segment_address-actadd-changed_bas_workplace_node_id.

* Notification
  go_notify->notify_delete(
    exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization ).

* Delete all messages belonging to PERSON_NAME and WORKPLACE
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).


  ms_segment_address-actual-idadtype           = if_identity=>co_idad_olduser.
  ms_segment_address-actual-mandt              = sy-mandt.
  ms_segment_address-actual-bname              = ms_manager-bname.
  ms_segment_address-actual-persnumber         = space.
  ms_segment_address-actual-addrnumber         = space.
  ms_segment_address-actadd-bas_wp_node_id     = space.
  ms_segment_address-actadd-org_node_id        = space.

  clear: ms_segment_address-actual-bpperson
       , ms_segment_address-actual-organization
       .

* Set node status of PersonName and Workplace
  clear: ms_manager-sn_person_name, "? = go_persistence->co_node_status_changed.
         ms_manager-sn_workplace.   "? = go_persistence->co_node_status_changed.


endmethod.


method addr_map_commdata.

  field-symbols:
        <lr_line>             type any
      , <lr_update>           type any
      , <lr_changed_fields>   type standard table
      .

  data: lr_descr_ref          type ref to cl_abap_structdescr
      , lr_field              type ref to abap_compdescr
      .


  loop at ct_comm_table assigning <lr_line>.

    assign component 'UPDATEFLAG' of structure <lr_line> to <lr_update>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    if <lr_update> ne 'I' and
       <lr_update> ne 'U'.
      continue.
    endif.

    assign component 'CHANGED_FIELDS' of structure <lr_line> to <lr_changed_fields>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    if <lr_changed_fields> is initial.
      lr_descr_ref ?= cl_abap_typedescr=>describe_by_data( <lr_line> ).

      loop at lr_descr_ref->components reference into lr_field.
        if lr_field->name eq 'TELEPHONE_ID'   or
           lr_field->name eq 'UPDATEFLAG'     or
           lr_field->name eq 'CHANGED_FIELDS'.
          continue.
        endif.

        append lr_field->name to <lr_changed_fields>.

      endloop.
    endif.

  endloop.


endmethod.


method addr_map_error_table.


  data: lr_addr_error        type ref to addrs_error
      , ls_msg               type        symsg
      , lv_nodename          type        suid_node_name
      , lv_field             type        suid_node_field
      , lv_lifetime          type        if_suid_msg_buffer=>ty_msg_lifetime
      , lv_key               type        suid_node_key
      .


  loop at it_addr_error reference into lr_addr_error.

*   Lifetime Once
    if lr_addr_error->node_name is initial.
      if iv_msg_once is initial.
        continue.
      endif.

      lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

      lv_nodename = iv_msg_for_node.

*   Lifetime Permanent
    else.
      if iv_msg_permanent is initial.
        continue.
      endif.

      clear: lv_key.

      lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.

      lv_nodename = lr_addr_error->node_name.
      lv_field    = lr_addr_error->fieldname.

*     Map nodename
      case lv_nodename.
        when cl_addr_main=>c_node_person_name. "'PERSON_NAME'.
          lv_nodename = if_identity_definition=>gc_node_person_name.
        when cl_addr_main=>c_node_workplace. "'WORKPLACE'.
          lv_nodename = if_identity_definition=>gc_node_workplace.
        when cl_addr_main=>c_node_communication_preferenc. "'COMMUNICATION_PREFERENCE'.
          if     lv_field eq 'LANGU'.
            lv_nodename = if_identity_definition=>gc_node_person_name.
          elseif lv_field eq 'DEFLT_COMM'.
            lv_nodename = if_identity_definition=>gc_node_workplace.
          endif.
        when cl_addr_main=>c_node_telephone       or
             cl_addr_main=>c_node_telephone_note  or
             cl_addr_main=>c_node_telephone_usage.
          lv_nodename = if_identity_definition=>gc_node_telephone.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_facsimile       or
             cl_addr_main=>c_node_facsimile_note  or
             cl_addr_main=>c_node_facsimile_usage.
          lv_nodename = if_identity_definition=>gc_node_facsimile.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_email       or
             cl_addr_main=>c_node_email_note  or
             cl_addr_main=>c_node_email_usage.
          lv_nodename = if_identity_definition=>gc_node_email.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_web       or
             cl_addr_main=>c_node_web_note  or
             cl_addr_main=>c_node_web_usage.
          lv_nodename = if_identity_definition=>gc_node_web.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_telex       or
             cl_addr_main=>c_node_telex_note  or
             cl_addr_main=>c_node_telex_usage.
          lv_nodename = if_identity_definition=>gc_node_telex.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_teletex       or
             cl_addr_main=>c_node_teletex_note  or
             cl_addr_main=>c_node_teletex_usage.
          lv_nodename = if_identity_definition=>gc_node_teletex.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_rml       or
             cl_addr_main=>c_node_rml_note  or
             cl_addr_main=>c_node_rml_usage.
          lv_nodename = if_identity_definition=>gc_node_remote_mail.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_x400       or
             cl_addr_main=>c_node_x400_note  or
             cl_addr_main=>c_node_x400_usage.
          lv_nodename = if_identity_definition=>gc_node_x400.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_printer       or
             cl_addr_main=>c_node_printer_note  or
             cl_addr_main=>c_node_printer_usage.
          lv_nodename = if_identity_definition=>gc_node_printer.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_ssf       or
             cl_addr_main=>c_node_ssf_note  or
             cl_addr_main=>c_node_ssf_usage.
          lv_nodename = if_identity_definition=>gc_node_ssf.
          lv_key      = lr_addr_error->node_id.
        when cl_addr_main=>c_node_pager       or
             cl_addr_main=>c_node_pager_note  or
             cl_addr_main=>c_node_pager_usage.
          lv_nodename = if_identity_definition=>gc_node_pager.
          lv_key      = lr_addr_error->node_id.

      endcase.

      if iv_msg_for_node is not initial and
         lv_nodename     ne iv_msg_for_node.
        continue.
      endif.
    endif.


    ls_msg-msgty = lr_addr_error->msg_type.
    ls_msg-msgid = lr_addr_error->msg_id.
    ls_msg-msgno = lr_addr_error->msg_number.
    ls_msg-msgv1 = lr_addr_error->msg_var1.
    ls_msg-msgv2 = lr_addr_error->msg_var2.
    ls_msg-msgv3 = lr_addr_error->msg_var3.
    ls_msg-msgv4 = lr_addr_error->msg_var4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = lv_nodename
        iv_key      = lv_key
        iv_field    = lv_field
        is_msg      = ls_msg
        iv_lifetime = lv_lifetime.


  endloop.


endmethod.                    "addr_map_error_table


method addr_msg_commdata.

  field-symbols:
        <lr_line>             type any
      , <lr_update>           type any
      , <lr_line_id>          type any
      .

  data: lv_key                type        suid_node_key
      .



* Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = iv_nodename.

* Delete all messages belonging to this node
  if is_current_state eq if_identity=>co_true.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = iv_nodename.
  else.

    loop at it_comm_table assigning <lr_line>.

      assign component 'UPDATEFLAG' of structure <lr_line> to <lr_update>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

      if <lr_update> ne 'I' and
         <lr_update> ne 'U'.
        continue.
      endif.


      assign component 1 of structure <lr_line> to <lr_line_id>. "'TELEPHONE_ID'
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

      if <lr_line_id> is initial.
        continue.
      endif.

      lv_key = <lr_line_id>.
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = iv_nodename
          iv_key      = lv_key.

    endloop.

  endif.


endmethod.


method addr_read_address.

  data: lo_addr_main        type ref to cl_addr_main
      , lt_addr_id          type        addrt_address_id
      , lt_address          type        addrt_address
      , lr_address          type ref to addrs_address
      , lr_addr_version     type ref to addrs_version
      , lv_wp_node_id       type        addr_node_id
      .


* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


  if iv_request_before_image eq space.

*   Consistence check
    if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser.
      macro_raise_internal_error.
    endif.

*...Evaluate "type 3" address id
    if ms_segment_address-actadd-bas_wp_node_id is initial.
      if ms_segment_address-actual-persnumber is initial.
        macro_raise_internal_error.
      endif.

      adbp_get_id(
        exporting
          io_addr_main      = lo_addr_main
          iv_address_type   = cl_addr_main=>c_contact_partner_address
          iv_address_number = ms_segment_address-actual-addrnumber
          iv_person_number  = ms_segment_address-actual-persnumber
        importing
          ev_addr_nodeid    = ms_segment_address-actadd-bas_wp_node_id ).

      if ms_segment_address-actadd-bas_wp_node_id is initial.
        macro_raise_internal_error.
      endif.
    endif.

    lv_wp_node_id = ms_segment_address-actadd-bas_wp_node_id.

  else.

    if ms_segment_address-before_image-idadtype   ne if_identity=>co_idad_olduser or
       ms_segment_address-before_image-persnumber is initial         or
       ms_segment_address-before_image-addrnumber is initial.
      return.
    endif.

*...Evaluate "type 3" address id
    adbp_get_id(
      exporting
        io_addr_main            = lo_addr_main
        iv_address_type         = cl_addr_main=>c_contact_partner_address
        iv_address_number       = ms_segment_address-before_image-addrnumber
        iv_person_number        = ms_segment_address-before_image-persnumber
        iv_request_before_image = iv_request_before_image
      importing
        ev_addr_nodeid          = lv_wp_node_id ).
    if lv_wp_node_id is initial.
      return.
    endif.

  endif.


* --- Read address ---------------------------------------------
*
  append lv_wp_node_id to lt_addr_id.
  call method lo_addr_main->retrieve_address
    exporting
      it_address_id            = lt_addr_id
      iv_retrieve_before_image = iv_request_before_image
    importing
      et_address               = lt_address.

  read table lt_address
       reference into lr_address
       with key address_id = lv_wp_node_id.
  if sy-subrc ne 0.
*   Address does not exist
    macro_raise_internal_error.
  endif.

  read table lr_address->data
       reference into lr_addr_version
       with key nation = space.
  if sy-subrc ne 0.
*   Address does not exist
    macro_raise_internal_error.
  endif.


* --- Copy address -----------------------------------------
*
  if es_personname is supplied.
    move-corresponding lr_addr_version->person_name           to es_personname."#EC ENHOK
    move lr_addr_version->communication_preference-langu      to es_personname-langu.
    if iv_request_before_image eq space.
      move ms_segment_address-actual-persnumber               to es_personname-pers_no.
    else.
      move ms_segment_address-before_image-persnumber         to es_personname-pers_no.
    endif.
  endif.

  if es_workplace is supplied.
    move-corresponding lr_addr_version->workplace             to es_workplace."#EC ENHOK
    move lr_addr_version->communication_preference-deflt_comm to es_workplace-deflt_comm.
  endif.


endmethod.


method addr_read_communication_data.

  data: lo_addr_main        type ref to cl_addr_main
      , lt_comm_read        type        addrt_communication_data_read
      , lt_addr_telephone   type        addrt_telephone_numbers
      , lt_addr_facsimile   type        addrt_facsimile_numbers
      , lt_addr_email       type        addrt_email_addresses
      , lt_addr_web         type        addrt_web_addresses
      , lt_addr_telex       type        addrt_telex_numbers
      , lt_addr_teletex     type        addrt_teletex_numbers
      , lt_addr_rml         type        addrt_remote_mail_addresses
      , lt_addr_x400        type        addrt_x400_addresses
      , lt_addr_printer     type        addrt_printers
      , lt_addr_ssf         type        addrt_ssf_addresses
      , lt_addr_pager       type        addrt_pager_numbers
      , lr_addr_telephone   type ref to addrs_telephone_numbers
      , lr_addr_facsimile   type ref to addrs_facsimile_numbers
      , lr_addr_email       type ref to addrs_email_addresses
      , lr_addr_web         type ref to addrs_web_addresses
      , lr_addr_telex       type ref to addrs_telex_numbers
      , lr_addr_teletex     type ref to addrs_teletex_numbers
      , lr_addr_rml         type ref to addrs_remote_mail_addresses
      , lr_addr_x400        type ref to addrs_x400_addresses
      , lr_addr_printer     type ref to addrs_printers
      , lr_addr_ssf         type ref to addrs_ssf_addresses
      , lv_wp_node_id       type        addr_node_id
      , lr_addr_pager       type ref to addrs_pager_numbers
      .


* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


  if iv_request_before_image eq space.

*   Consistence check
    if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser.
      macro_raise_internal_error.
    endif.

*...Evaluate "type 3" address id
    if ms_segment_address-actadd-bas_wp_node_id is initial.
      if ms_segment_address-actual-persnumber is initial.
        macro_raise_internal_error.
      endif.

      adbp_get_id(
        exporting
          io_addr_main      = lo_addr_main
          iv_address_type   = cl_addr_main=>c_contact_partner_address
          iv_address_number = ms_segment_address-actual-addrnumber
          iv_person_number  = ms_segment_address-actual-persnumber
        importing
          ev_addr_nodeid    = ms_segment_address-actadd-bas_wp_node_id ).

      if ms_segment_address-actadd-bas_wp_node_id is initial.
        macro_raise_internal_error.
      endif.
    endif.

    lv_wp_node_id = ms_segment_address-actadd-bas_wp_node_id.

  else.

    if ms_segment_address-before_image-idadtype   ne if_identity=>co_idad_olduser or
       ms_segment_address-before_image-persnumber is initial         or
       ms_segment_address-before_image-addrnumber is initial.
      return.
    endif.

*...Evaluate "type 3" address id
    adbp_get_id(
      exporting
        io_addr_main            = lo_addr_main
        iv_address_type         = cl_addr_main=>c_contact_partner_address
        iv_address_number       = ms_segment_address-before_image-addrnumber
        iv_person_number        = ms_segment_address-before_image-persnumber
        iv_request_before_image = iv_request_before_image
      importing
        ev_addr_nodeid          = lv_wp_node_id ).
    if lv_wp_node_id is initial.
      return.
    endif.

  endif.




* --- Read address ---------------------------------------------
*
  cs_comm_read-address_id = lv_wp_node_id.
  append cs_comm_read to lt_comm_read.

* Read communication data
  lo_addr_main->retrieve_communication_data(
    exporting
      it_communication_data_id = lt_comm_read
      iv_retrieve_before_image = iv_request_before_image
    importing
      et_telephone             = lt_addr_telephone
      et_facsimile             = lt_addr_facsimile
      et_email                 = lt_addr_email
      et_web                   = lt_addr_web
      et_telex                 = lt_addr_telex
      et_teletex               = lt_addr_teletex
      et_rml                   = lt_addr_rml
      et_x400                  = lt_addr_x400
      et_printer               = lt_addr_printer
      et_ssf                   = lt_addr_ssf
      et_pager                 = lt_addr_pager ).


  if cs_comm_read-telephone eq 'X'.
    read table lt_addr_telephone reference into lr_addr_telephone
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_telephone = lr_addr_telephone->data.
    endif.
  endif.

  if cs_comm_read-facsimile eq 'X'.
    read table lt_addr_facsimile reference into lr_addr_facsimile
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_facsimile = lr_addr_facsimile->data.
    endif.
  endif.

  if cs_comm_read-email     eq 'X'.
    read table lt_addr_email reference into lr_addr_email
               with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_email = lr_addr_email->data.
    endif.
  endif.

  if cs_comm_read-web       eq 'X'.
    read table lt_addr_web reference into lr_addr_web
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_web = lr_addr_web->data.
    endif.
  endif.

  if cs_comm_read-telex     eq 'X'.
    read table lt_addr_telex reference into lr_addr_telex
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_telex = lr_addr_telex->data.
    endif.
  endif.

  if cs_comm_read-teletex   eq 'X'.
    read table lt_addr_teletex reference into lr_addr_teletex
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_teletex = lr_addr_teletex->data.
    endif.
  endif.

  if cs_comm_read-rml       eq 'X'.
    read table lt_addr_rml reference into lr_addr_rml
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_rml = lr_addr_rml->data.
    endif.
  endif.

  if cs_comm_read-x400      eq 'X'.
    read table lt_addr_x400 reference into lr_addr_x400
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_x400 = lr_addr_x400->data.
    endif.
  endif.

  if cs_comm_read-printer   eq 'X'.
    read table lt_addr_printer reference into lr_addr_printer
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_printer = lr_addr_printer->data.
    endif.
  endif.

  if cs_comm_read-ssf       eq 'X'.
    read table lt_addr_ssf reference into lr_addr_ssf
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_ssf = lr_addr_ssf->data.
    endif.
  endif.

  if cs_comm_read-pager     eq 'X'.
    read table lt_addr_pager reference into lr_addr_pager
         with key address_id = cs_comm_read-address_id.
    if sy-subrc ne 0.
*     Address does not exist
      macro_raise_internal_error.
    else.
      et_pager = lr_addr_pager->data.
    endif.
  endif.



endmethod.


method after_commit.
*
* This method must only be called from ESI framework
*

  data: lr_control type ref to ty_control
       ,lr_bname   type ref to suid_st_bname
       .

  if it_bname is not initial.
    loop at it_bname reference into lr_bname.   "Cleanup given instances
      read table gt_control reference into lr_control
        with key bname = lr_bname->bname
        binary search.
      if sy-subrc = 0.
        call method lr_control->idref->after_commit_single.
      endif.
    endloop.
  else.
    loop at gt_control reference into lr_control. "After commit for all instances
      call method lr_control->idref->after_commit_single.
    endloop.
  endif.

endmethod.


METHOD after_commit_customer_exit.

  DATA: lr_segment_roles    TYPE REF TO suid_st_segment_roles.
  DATA: lt_agr_users_delete TYPE        suid_tt_agr_users.
  DATA: lt_agr_users_insert TYPE        suid_tt_agr_users.
  DATA: lt_agr_users_update TYPE        suid_tt_agr_users.
  DATA: lr_agr_users        TYPE REF TO agr_users.
  DATA: lt_str_agrs         TYPE        suid_tt_str_agrs.
  DATA: ls_str_agrs         TYPE        str_agrs.


* collect all changed roles first
  LOOP AT it_segment_roles REFERENCE INTO lr_segment_roles.

    IF lr_segment_roles->before_image NE lr_segment_roles->actual.
*.....Something has changed
      IF lr_segment_roles->actual       IS NOT INITIAL AND
      lr_segment_roles->before_image IS NOT INITIAL.

        CALL METHOD cl_suid_tools=>compare_tables_agr_users
          EXPORTING
            it_agr_users_new = lr_segment_roles->actual
            it_agr_users_old = lr_segment_roles->before_image
          CHANGING
            ct_del           = lt_agr_users_delete
            ct_ins           = lt_agr_users_insert
            ct_upd           = lt_agr_users_update.

      ELSEIF lr_segment_roles->actual       IS NOT INITIAL.
*         Create db entry
        APPEND LINES OF lr_segment_roles->actual TO lt_agr_users_insert.
      ELSEIF lr_segment_roles->before_image IS NOT INITIAL.
*         Delete db entry
        APPEND LINES OF lr_segment_roles->before_image TO lt_agr_users_delete.
      ENDIF.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_agr_users_insert REFERENCE INTO lr_agr_users.
    MOVE-CORRESPONDING lr_agr_users->* TO ls_str_agrs.
    IF lr_agr_users->col_flag EQ 'X' AND ls_str_agrs-org_flag <> 'X'.
      ls_str_agrs-org_flag = 'C'.
    ENDIF.
    APPEND ls_str_agrs TO lt_str_agrs.
  ENDLOOP.

  LOOP AT lt_agr_users_update REFERENCE INTO lr_agr_users.
    MOVE-CORRESPONDING lr_agr_users->* TO ls_str_agrs.
    IF lr_agr_users->col_flag EQ 'X' AND ls_str_agrs-org_flag <> 'X'.
      ls_str_agrs-org_flag = 'C'.
    ENDIF.
    APPEND ls_str_agrs TO lt_str_agrs.
  ENDLOOP.

  LOOP AT lt_agr_users_delete REFERENCE INTO lr_agr_users.
    MOVE-CORRESPONDING lr_agr_users->* TO ls_str_agrs.
    IF lr_agr_users->col_flag EQ 'X' AND ls_str_agrs-org_flag <> 'X'.
      ls_str_agrs-org_flag = 'C'.
    ENDIF.
    APPEND ls_str_agrs TO lt_str_agrs.
  ENDLOOP.

et_str_agrs = lt_str_agrs.

ENDMETHOD.


method after_commit_single.
* Try to keep all segments
* Keep transaction mode and enqueue-mode
* Keep reference in control table GT_CONTROL

  data: lt_bname                  type        suid_tt_bname_locked
      , lt_bname_check_opt        type        suid_tt_bname_locked
      , lv_update_instance        type        sesf_boolean value if_identity=>co_false
      , lv_update_enqueue         type        sesf_boolean value if_identity=>co_false
      .

* Status must be valid
  if ms_manager-status eq go_persistence->co_ta_status_invalid.
    raise exception
      type
      cx_suid_identity
      exporting
        textid          = cx_suid_identity=>invalid_identity
        ref_to_identity = me
        bname           = ms_manager-bname
        ta_modus        = ms_manager-modus
        ta_status       = ms_manager-status.

  endif.

* ---- set mode of Identity instance -----------------------------------------------*
  case ms_manager-modus.

*---- display mode
    when go_persistence->co_ta_modus_display.
*     instance which is in mode display remains the same
      lv_update_instance = if_identity=>co_false.

*     retrieve may be done in optimistic mode
      lv_update_enqueue  = if_identity=>co_true.

*---- modify mode
    when go_persistence->co_ta_modus_modify.
*     stay in mode modify and unchanged
      if ms_manager-status eq go_persistence->co_ta_status_unchanged.
*       update instance not necessary
        lv_update_instance  = if_identity=>co_false.
*       handle enqueue locks
        lv_update_enqueue  = if_identity=>co_true.
      endif.

*     stay in mode modify and change status to unchanged
      if ms_manager-status eq go_persistence->co_ta_status_saved.
*       update status
        ms_manager-status   = go_persistence->co_ta_status_unchanged.
*       update instance
        lv_update_instance  = if_identity=>co_true.
*       handle enqueue locks
        lv_update_enqueue  = if_identity=>co_true.
      endif.

*---- create mode
    when go_persistence->co_ta_modus_create.
*     switch to mode modify and change status to unchanged
      if ms_manager-status eq go_persistence->co_ta_status_saved.
        ms_manager-modus    = go_persistence->co_ta_modus_modify.
        ms_manager-status   = go_persistence->co_ta_status_unchanged.
        lv_update_instance  = if_identity=>co_true.
*       handle enqueue locks
        lv_update_enqueue  = if_identity=>co_true.
      endif.

*---- delete mode
    when go_persistence->co_ta_modus_delete.
      if ms_manager-status eq go_persistence->co_ta_status_saved.
        ms_manager-status = go_persistence->co_ta_status_invalid.
        me->cleanup_single( ).
*       do not use this instance anymore
        lv_update_instance = if_identity=>co_false.
*       handle enqueue locks
        lv_update_enqueue  = if_identity=>co_false.
      endif.

*---- other cases
    when others.
*     do not update instance
      lv_update_instance = if_identity=>co_false.
      lv_update_enqueue  = if_identity=>co_false.
  endcase.


* ---- handle enqueue -------------------------------------------------*
  if lv_update_enqueue = if_identity=>co_true.
* check if enqueue lock has been requested for read-only mode
    if ms_manager-enqmode <> if_identity=>co_enqueue_mode_no_lock.

      if ms_manager-enqmode = if_identity=>co_enqueue_mode_exclusive.

*       check whether object has optimistic lock for dialog user
        call method cl_suid_tools=>enqueue
          exporting
            i_bname     = ms_manager-bname
            i_enq_mode  = cl_suid_tools=>co_check_lock_mode_opt
            i_enq_scope = 1
          importing
            et_bname    = lt_bname_check_opt.

*       Optimistic lock is existing already -> Promote to update task only
        if lt_bname_check_opt is initial. " Empty if lock exists!
*         Promote optimistic dialog lock to owner_2 (update_owner) lock
          call method cl_suid_tools=>enqueue
            exporting
              i_bname     = ms_manager-bname
              i_enq_mode  = cl_suid_tools=>co_lock_mode_opt
              i_enq_scope = 2
            importing
              et_bname    = lt_bname.

*       Optimistic lock not existing -> Acquire scope 3 optimistic lock
        else.
*         exclusive lock is released after call of commit
*         request optimistic lock scope 3 for dialog and update task
          call method cl_suid_tools=>enqueue
            exporting
              i_bname     = ms_manager-bname
              i_enq_mode  = cl_suid_tools=>co_lock_mode_opt
              i_enq_scope = 3
            importing
              et_bname    = lt_bname.
        endif.

*       optimistice lock could not be acquired
        if lt_bname is not initial.

          me->cleanup_single( ).

          raise exception
            type
            cx_suid_identity
            exporting
              textid    = cx_suid_identity=>invalid_enqueue_lock
              bname     = ms_manager-bname
              enq_mode  = cl_suid_tools=>co_lock_mode_opt
              enq_scope = 3.
        else.
*         update ms_manager enqmode
          ms_manager-enqmode = if_identity=>co_enqueue_mode_optimistic.
        endif.

      else.

*       verify that object has optimistic lock for dialog user
        call method cl_suid_tools=>enqueue
          exporting
            i_bname     = ms_manager-bname
            i_enq_mode  = cl_suid_tools=>co_check_lock_mode_opt
            i_enq_scope = 1
          importing
            et_bname    = lt_bname.

*       invalid enqueue mode -> refresh this instance
        if lt_bname is not initial.

          me->cleanup_single( ).

          raise exception
            type
            cx_suid_identity
            exporting
              textid    = cx_suid_identity=>invalid_enqueue_lock
              bname     = ms_manager-bname
              enq_mode  = cl_suid_tools=>co_lock_mode_opt_to_excl
              enq_scope = 1.
        endif.

*       Promote optimistic dialog lock to owner_2 (update_owner) lock
        call method cl_suid_tools=>enqueue
          exporting
            i_bname     = ms_manager-bname
            i_enq_mode  = cl_suid_tools=>co_lock_mode_opt
            i_enq_scope = 2
          importing
            et_bname    = lt_bname.

*       optimistice lock could not be promoted
        if lt_bname is not initial.

          me->cleanup_single( ).

          raise exception
            type
            cx_suid_identity
            exporting
              textid    = cx_suid_identity=>invalid_enqueue_lock
              bname     = ms_manager-bname
              enq_mode  = cl_suid_tools=>co_lock_mode_opt
              enq_scope = 2.
        else.
*       update ms_manager enqmode
          ms_manager-enqmode = if_identity=>co_enqueue_mode_optimistic.
        endif.

      endif.

    endif.

  endif.


* Reset Certmap enqueue
  call method cl_suid_tools=>dequeue_certmap_for_user
    exporting
      iv_bname            = ms_manager-bname
    changing
      it_certmap_enqueued = mt_certmap_enqueued.



*   -------------------------------------------*
*   Update instance segments and nodes
*   -------------------------------------------*

  if lv_update_instance = if_identity=>co_true.
*   ---- Adapt instance manager ---------------------------------------*
    clear_node_status( ).

* ---- Clear all messages and notifications ---------------------------*
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname = ms_manager-bname.

    call method go_notify->delete_notifications
      exporting
        iv_bname = ms_manager-bname.

*   ---- consider each segment ---------------------------------------*

*   Header segment
    if ms_segment_header-status = go_persistence->co_seg_changed.
      ms_segment_header-before_image = ms_segment_header-actual.
      clear: ms_segment_header-status.
      clear: ms_segment_header-initial_password.
    endif.

*   Address segment
    if ms_segment_address-status = go_persistence->co_seg_changed.
      ms_segment_address-before_image = ms_segment_address-actual.
      clear: ms_segment_address-status,
             ms_segment_address-actadd.
    endif.

*   History segment for header data only keeps actual image
    if ms_segment_header_hist-status = go_persistence->co_seg_changed.
      clear: ms_segment_header_hist-actual.
      clear: ms_segment_header_hist-status.
    endif.

*   Audit log segment only keeps actual image
    if ms_segment_auditlog-status = go_persistence->co_seg_changed.
      clear: ms_segment_auditlog-actual.
      clear: ms_segment_auditlog-status.
    endif.

*   User stamp segment: move actual to before_image + clear actual
    if ms_segment_userstamp-status = go_persistence->co_seg_changed.
      if ms_segment_userstamp-actual is not initial.
        ms_segment_userstamp-before_image = ms_segment_userstamp-actual.
        clear ms_segment_userstamp-actual.
      endif.
*      CLEAR: ms_segment_userstamp-actual.
      clear: ms_segment_userstamp-status.
    endif.

*  reference user
    if ms_segment_refuser-status = go_persistence->co_seg_changed.
      ms_segment_refuser-before_image = ms_segment_refuser-actual.
      clear: ms_segment_refuser-status.
    endif.

*  roles
    if ms_segment_roles-status = go_persistence->co_seg_changed.
      ms_segment_roles-before_image = ms_segment_roles-actual.
      clear: ms_segment_roles-status.
    endif.

*  defaults
    if ms_segment_defaults-status = go_persistence->co_seg_changed.
      ms_segment_defaults-before_image = ms_segment_defaults-actual.
      clear: ms_segment_defaults-status.
    endif.

*  snc
    if ms_segment_snc-status = go_persistence->co_seg_changed.
      ms_segment_snc-before_image = ms_segment_snc-actual.
      clear: ms_segment_snc-status.
    endif.

*  profiles: ust04
    if ms_segment_profiles_t04-status = go_persistence->co_seg_changed.
      ms_segment_profiles_t04-before_image = ms_segment_profiles_t04-actual.
      clear: ms_segment_profiles_t04-status.
    endif.

*  profiles: usr04
    if ms_segment_profiles_r04-status = go_persistence->co_seg_changed.
      ms_segment_profiles_r04-before_image = ms_segment_profiles_r04-actual.
      clear: ms_segment_profiles_r04-status.
    endif.

*   Profiles history segment only keeps actual image
    if ms_segment_profiles_r04_hist-status = go_persistence->co_seg_changed.
      clear: ms_segment_profiles_r04_hist-actual.
      clear: ms_segment_profiles_r04_hist-status.
    endif.

*  Parameter
    if ms_segment_parameter-status = go_persistence->co_seg_changed.
      ms_segment_parameter-before_image = ms_segment_parameter-actual.
      clear: ms_segment_parameter-status.
    endif.

*   Groups
    if ms_segment_groups-status = go_persistence->co_seg_changed.
      ms_segment_groups-before_image = ms_segment_groups-actual.
      clear: ms_segment_groups-status.
    endif.

*  Uclass
    if ms_segment_uclass-status = go_persistence->co_seg_changed.
      ms_segment_uclass-before_image = ms_segment_uclass-actual.
      clear: ms_segment_uclass-status.
    endif.

*   Print parameter segment only keeps actual image
    if ms_segment_printparam-status = go_persistence->co_seg_changed.
      clear: ms_segment_printparam-actual.
      clear: ms_segment_printparam-status.
    endif.

*   Password history segment only keeps actual image
    if ms_segment_pwdhistory-status = go_persistence->co_seg_changed.
      clear: ms_segment_pwdhistory-actual.
      clear: ms_segment_pwdhistory-status.
    endif.

*   cua roles segment
    if ms_segment_cua_roles-status = go_persistence->co_seg_changed.
      ms_segment_cua_roles-before_image = ms_segment_cua_roles-actual.
      clear: ms_segment_cua_roles-status.
    endif.

*   cua profiles segment
    if ms_segment_cua_profiles-status = go_persistence->co_seg_changed.
      ms_segment_cua_profiles-before_image = ms_segment_cua_profiles-actual.
      clear: ms_segment_cua_profiles-status.
    endif.

*   cua systems segment
    if ms_segment_cua_systems-status = go_persistence->co_seg_changed.
      ms_segment_cua_systems-before_image = ms_segment_cua_systems-actual.
      clear: ms_segment_cua_systems-status.
    endif.

*   ms_segment_cua_user_prot
    if ms_segment_cua_user_prot-status = go_persistence->co_seg_changed.
      ms_segment_cua_user_prot-before_image = ms_segment_cua_user_prot-actual.
      clear: ms_segment_cua_user_prot-status.
    endif.

*   ms_segment_cua_uclass
    if ms_segment_cua_uclasses-status = go_persistence->co_seg_changed.
      ms_segment_cua_uclasses-before_image = ms_segment_cua_uclasses-actual.
      clear: ms_segment_cua_uclasses-status.
    endif.

*   ms_segment_cua_password
    if ms_segment_cua_password-status = go_persistence->co_seg_changed.
      clear: ms_segment_cua_password-actual.
      clear: ms_segment_cua_password-status.
    endif.

*   ms_segment_cua_password
    if ms_segment_cua_act_distr-status = go_persistence->co_seg_changed.
      clear: ms_segment_cua_act_distr-actual.
      clear: ms_segment_cua_act_distr-status.
    endif.

*   certificate mapping segment
    if ms_segment_certmap-status = go_persistence->co_seg_changed.
      ms_segment_certmap-before_image = ms_segment_certmap-actual.
      clear: ms_segment_certmap-status.
    endif.

*    DBMS User segment
    if ms_segment_dbms_user-status = go_persistence->co_seg_changed.
      ms_segment_dbms_user-before_image          = ms_segment_dbms_user-actual.
      ms_segment_dbms_user-dbms_user_data_before = ms_segment_dbms_user-dbms_user_data_actual.
      ms_segment_dbms_user-dbms_roles_before     = ms_segment_dbms_user-dbms_roles_actual.
      clear: ms_segment_dbms_user-dbms_change_mode
           , ms_segment_dbms_user-status
           .
    endif.

*    Pattern for additional segments:
*    if ms_segment_-status = go_persistence->co_seg_changed.
*      ms_segment_-before_image = ms_segment_-actual.
*      clear: ms_segment_-status.
*    endif.

  endif.

endmethod.


METHOD after_rejected_save.
* Set transaction status to "Unchecked" for all imported BNAMEs

  DATA: lr_control TYPE REF TO ty_control
       .

  LOOP AT gt_control REFERENCE INTO lr_control.

*   Allow another roundtrip
*   enqueue mode remains the same for every mode
    CASE lr_control->idref->ms_manager-modus.
*---- display mode
      WHEN go_persistence->co_ta_modus_display.
*       ignore instances which are in mode display: leave them as they are
*       do nothing
        CONTINUE.
*---- modify mode
      WHEN go_persistence->co_ta_modus_modify.
*       instances which are in mode:
*         - modify and unchanged: remain in this mode
*         - invalid:              remain in this mode
        IF lr_control->idref->ms_manager-status = go_persistence->co_ta_status_unchanged OR
           lr_control->idref->ms_manager-status = go_persistence->co_ta_status_invalid.
          CONTINUE.
        ELSE.
          lr_control->idref->ms_manager-status = go_persistence->co_ta_status_unchecked.
        ENDIF.
*---- create or delete mode
      WHEN go_persistence->co_ta_modus_create OR go_persistence->co_ta_modus_delete.
        lr_control->idref->ms_manager-status = go_persistence->co_ta_status_unchecked.
*---- other cases
      WHEN OTHERS.
*       do nothing
        CONTINUE.
    ENDCASE.

  ENDLOOP.


ENDMETHOD.


method APPLREFS_SET_MODIFIED.
* Set/delete flag if some operation was executed, which could modify appl. references

  if iv_modified = if_identity=>co_true.
*   No application calls during upgrade ==> no personalization modifications
    if gv_upg_is_shadow_system is initial.
      ms_manager-flg_appref_modified = go_persistence->co_flag_active.
      ms_manager-status = go_persistence->co_ta_status_unchecked.
    endif.
  else.
    clear: ms_manager-flg_appref_modified.
  endif.

endmethod.


method auth_check_for_new_class.


  data: ls_msg                type          symsg
      , ls_reference_user     type          suid_st_node_reference_user
      , lv_is_authorized      type          sesf_boolean
      , lv_no_maintain        type          sesf_boolean
      , lt_cua_systems        type          suid_tt_node_cua_systems
      , lr_cua_systems        type ref to   suid_st_node_cua_system
      , lt_roles              type          suid_tt_node_roles
      , lr_roles              type ref to   suid_st_node_role
      , lt_cua_roles          type          suid_tt_node_cua_roles
      , lr_cua_roles          type ref to   suid_st_node_cua_role
      , lt_profiles           type          suid_tt_node_profiles
      , lr_profiles           type ref to   suid_st_node_profile
      , lv_prof_torso         type          xuprofile
      , lt_cua_profiles       type          suid_tt_node_cua_profiles
      , lr_cua_profiles       type ref to   suid_st_node_cua_profile
      , lv_overwrite          type          sesf_boolean
      .


  " Check authorizations for the following nodes
  " - Reference user
  " - Systems
  " - Roles / CUA-Roles
  " - Profiles /ZBV-Profiles
  " All messages are related to logondata-class

  " Init
  ev_reject_class = if_identity=>co_false.

  if iv_ext_lifetime eq if_suid_msg_buffer=>co_lifetime_permanent.
    lv_overwrite = if_identity=>co_true.
  endif.

  " --- Reference user ---
  call method me->get_reference_user
    importing
      es_reference_user = ls_reference_user.

  if ls_reference_user is not initial.
    call method cl_identity=>check_reference_user_internal
      exporting
        iv_bname              = ms_manager-bname
        iv_class              = iv_new_class
        io_msg_buffer         = io_msg_buffer
        iv_ext_nodename       = if_identity_definition=>gc_node_logondata
        iv_ext_field          = if_identity_definition=>gc_field_logondata_class
        iv_use_ext_node       = if_identity=>co_true
        iv_ext_lifetime       = iv_ext_lifetime
      importing
        ev_is_authorized      = lv_is_authorized
      changing
        cs_new_reference_user = ls_reference_user.

    if lv_is_authorized eq if_identity=>co_false.
      ev_reject_class = if_identity=>co_true.
    endif.
  endif.


  " --- Systems ---
  if gv_cua_central eq if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_system
      receiving
        rv_no_maintain = lv_no_maintain.
  else.
    lv_no_maintain = if_identity=>co_true.
  endif.

  if lv_no_maintain eq if_identity=>co_false.
    " Check system assignment
    call method me->get_cua_systems
      importing
        et_cua_systems = lt_cua_systems.

    loop at lt_cua_systems reference into lr_cua_systems.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_system
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_new_class
          iv_subsystem = lr_cua_systems->subsystem
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Fehlende Zuordnungsberechtigung für Benutzergruppe &1 zum System &2
        if 1 = 0. message e631(01) with ls_msg-msgv1 ls_msg-msgv2. endif.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            is_msg       = ls_msg
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once.
            iv_overwrite = lv_overwrite.

        ev_reject_class = if_identity=>co_true.
      endif.
    endloop.
  endif.


  " --- Roles ---
  if gv_cua_central eq if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_role
      receiving
        rv_no_maintain = lv_no_maintain.
  else.
    lv_no_maintain = if_identity=>co_true.
  endif.

  if lv_no_maintain eq if_identity=>co_false.
    " Check CUA role assignment
    call method me->get_cua_roles
      importing
        et_roles = lt_cua_roles.

    loop at lt_cua_roles reference into lr_cua_roles.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_role
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_new_class
          iv_bname     = ms_manager-bname
          iv_subsystem = lr_cua_roles->subsystem
          iv_role      = lr_cua_roles->agr_name
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &3 zur Rolle &2 für System &1
        if 1 = 0. message e637(01) with ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3. endif. "#EC *

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            is_msg       = ls_msg
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once.
            iv_overwrite = lv_overwrite.

        ev_reject_class = if_identity=>co_true.
      endif.
    endloop.
  else.
    " Check role assignment
    call method me->get_roles
      importing
        et_roles = lt_roles.

    loop at lt_roles reference into lr_roles.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_role
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_new_class
          iv_bname     = ms_manager-bname
          iv_role      = lr_roles->agr_name
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &2 zur Rolle &1
        if 1 = 0. message e639(01) with lr_roles->agr_name iv_new_class. endif. "#EC *

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            is_msg       = ls_msg
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once.
            iv_overwrite = lv_overwrite.

        ev_reject_class = if_identity=>co_true.
      endif.
    endloop.
  endif.


  " --- Profiles ---
  if gv_cua_central eq if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_profile
      receiving
        rv_no_maintain = lv_no_maintain.
  else.
    lv_no_maintain = if_identity=>co_true.
  endif.

  if lv_no_maintain eq if_identity=>co_false.
    " Check CUA profiles
    call method me->get_cua_profiles
      exporting
        iv_get_prof_details = if_identity=>co_false
      importing
        et_profiles         = lt_cua_profiles.

    loop at lt_cua_profiles reference into lr_cua_profiles.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_profile
          iv_operation = cl_suid_tools=>co_activity_create
          iv_bname     = ms_manager-bname
          iv_class     = iv_new_class
          iv_subsystem = lr_cua_profiles->subsystem
          iv_profile   = lr_cua_profiles->profile
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Keine Berechtigung zur Profilzuordnung für System &1
        if 1 = 0. message e636(01) with ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3. endif. "#EC *

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            is_msg       = ls_msg
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once.
            iv_overwrite = lv_overwrite.

        ev_reject_class = if_identity=>co_true.
      endif.
    endloop.

  else.
    " Check profile assignment
    call method me->get_profiles
      exporting
        iv_get_prof_details = if_identity=>co_true
      importing
        et_profiles         = lt_profiles.

    loop at lt_profiles reference into lr_profiles.
      " Profile torso
      if lr_profiles->type eq if_identity~co_prof_type_generated. "'G'. "Generated
        lv_prof_torso = lr_profiles->profile(10).
      else. "'S'ingle,'C'omposite
        lv_prof_torso = lr_profiles->profile.
      endif.

      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_profile
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_new_class
          iv_profile   = lv_prof_torso
          iv_bname     = ms_manager-bname
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &2 zum Profil &1
        if 1 = 0. message e638(01) with lr_profiles->profile iv_new_class. endif. "#EC *

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            is_msg       = ls_msg
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once.
            iv_overwrite = lv_overwrite.

        ev_reject_class = if_identity=>co_true.
      endif.
    endloop.

  endif.


endmethod.


method auth_check_single.

  data: lv_class              type          xuclass
      .


  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  call method cl_suid_tools=>auth_check_single
    exporting
      iv_nodename         = iv_nodename
      iv_operation        = iv_operation
      iv_bname            = me->ms_manager-bname
      iv_class            = lv_class
      iv_subsystem        = iv_subsystem
      iv_role             = iv_role
      iv_profile          = iv_profile
      iv_initial_as_dummy = iv_initial_as_dummy
    importing
      es_msg              = es_msg.

endmethod.


method bp_delete_employee_work_addr.


* --- Consistency check -----------------------------------------------
*
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_employee.
    macro_raise_internal_error.
  endif.

* BP trx only
  if ms_segment_address-actadd-trx_with_bp ne co_trx_bp.
    macro_raise_internal_error.
  endif.


* --- Modify actual buffer -----------------------------------------------
*

* Notification:
  go_notify->notify_delete(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).

* Delete all messages belonging to WORKPLACE
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).


  ms_segment_address-actual-idadtype      = if_identity=>co_idad_person.
  ms_segment_address-actual-mandt         = sy-mandt.
  ms_segment_address-actual-bname         = ms_manager-bname.

  clear: ms_segment_address-actual-organization,
         ms_segment_address-actual-addrnumber,
         ms_segment_address-actadd-org_node_id.

* Set node status of Workplace
  clear: ms_manager-sn_workplace. "?   = go_persistence->co_node_status_changed.


endmethod.


method bp_delete_organization.

  data: lt_relc_key              type        bup_t_relc_key_api
      , ls_relc_key              type        bup_s_relc_key_api
      , lv_relc_rejected         type        boole_d
      , ls_msg                   type        symsg
      .


* --- Consistency check -----------------------------------------------
*
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.


* --- Reset modifications: Only if relation was changed ----------
*
  if ms_segment_address-actadd-changed_bprel eq if_identity=>co_true.
    ls_relc_key-partner1_uuid = ms_segment_address-actual-bpperson.
    ls_relc_key-partner2_uuid = ms_segment_address-actual-organization.
    ls_relc_key-reldir        = '2'.
    append ls_relc_key to lt_relc_key.

    call method cl_bup_transaction_relt_api=>reset_modifications
      exporting
        it_keys            = lt_relc_key
      importing
*       et_message         = lt_relc_msg
*       er_message_handler = lr_relc_msg_handler
        ev_rejected        = lv_relc_rejected.

    if lv_relc_rejected is not initial.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '050'.
*     MSG: Fehler beim Ändern des Geschäftspartners.
      if 1 = 0. message e050(suid01). endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endif.

    clear: ms_segment_address-actadd-changed_bprel.
  endif.


* --- Modify actual buffer -----------------------------------------------
*

* Notification:
  go_notify->notify_delete(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).

* Delete all messages belonging to WORKPLACE
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).


  ms_segment_address-actual-idadtype      = if_identity=>co_idad_person.
  ms_segment_address-actual-mandt         = sy-mandt.
  ms_segment_address-actual-bname         = ms_manager-bname.

  clear: ms_segment_address-actual-organization,
         ms_segment_address-actual-addrnumber,
         ms_segment_address-actadd-org_node_id.

* Set node status of Workplace
  clear: ms_manager-sn_workplace. "?   = go_persistence->co_node_status_changed.


endmethod.


method bp_get_communication_data.


  data: lt_rela_keys         type        bup_t_rela_key_api
      , ls_rela_keys         type        bup_s_rela_key_api
      , lt_rela_data         type        bup_t_rela_data_api
      , lr_rela_data         type ref to bup_s_rela_data_api
      , lt_rela_msg          type        cmd_t_msg_complete
      , lr_rela_msg          type ref to cmd_s_msg_complete
      , lo_addr_main         type ref to cl_addr_main
      , ls_msg               type        symsg
      .


  " Consistence check
  if iv_request_before_image is initial.
    if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela.
      macro_raise_internal_error.
    endif.
  else.
    if ms_segment_address-before_image-idadtype ne if_identity=>co_idad_person_org_rela.
      return.
    endif.
  endif.

  " User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.

  " Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Read Comm Data -----------------------------------------
*
  if iv_request_before_image is initial.
    "...Current Data

    if ms_segment_address-actadd-org_node_id is initial.
      adbp_get_id(
        exporting
          io_addr_main      = lo_addr_main
          iv_address_type   = cl_addr_main=>c_organization_address
          iv_address_number = ms_segment_address-actual-addrnumber
        importing
          ev_addr_nodeid    = ms_segment_address-actadd-org_node_id ).
    endif.

    ls_rela_keys-partner1_uuid  = ms_segment_address-actual-bpperson.
    ls_rela_keys-partner2_uuid  = ms_segment_address-actual-organization.
    ls_rela_keys-org_address_id = ms_segment_address-actadd-org_node_id.
    ls_rela_keys-reldir         = '2'.        "Direction: Person -> Org

    append ls_rela_keys to lt_rela_keys.

    call method cl_bup_rela_api=>read
      exporting
        it_keys            = lt_rela_keys
        is_commdata_read   = is_commdata_read
      importing
        et_data            = lt_rela_data
        et_message         = lt_rela_msg.

    " Errorhandling: Only lifetime one messages should appear
    delete lt_rela_msg where lifetime eq 0.

    loop at lt_rela_msg reference into lr_rela_msg.
      clear: ls_msg.

      ls_msg-msgty = lr_rela_msg->msgty.
      ls_msg-msgid = lr_rela_msg->msgid.
      ls_msg-msgno = lr_rela_msg->msgno.
      ls_msg-msgv1 = lr_rela_msg->msgv1.
      ls_msg-msgv2 = lr_rela_msg->msgv2.
      ls_msg-msgv3 = lr_rela_msg->msgv3.
      ls_msg-msgv4 = lr_rela_msg->msgv4.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endloop.

    " Properties
    call method adbp_set_property_for_node
      exporting
        iv_nodename = if_identity_definition=>gc_node_workplace
        iv_readonly = if_identity=>co_true.

  else.
    "...Before Image

    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = ms_segment_address-before_image-addrnumber
      importing
        ev_addr_nodeid    = ls_rela_keys-org_address_id ).

    ls_rela_keys-partner1_uuid  = ms_segment_address-before_image-bpperson.
    ls_rela_keys-partner2_uuid  = ms_segment_address-before_image-organization.
    ls_rela_keys-reldir         = '2'.        "Direction: Person -> Org
    append ls_rela_keys to lt_rela_keys.

    call method cl_bup_rela_api=>read
      exporting
        it_keys                  = lt_rela_keys
        iv_retrieve_before_image = 'X'
      importing
        et_data                  = lt_rela_data.

  endif.


* --- Copy address -----------------------------------------
*
  read table lt_rela_data reference into lr_rela_data
       with key partner1_uuid  = ls_rela_keys-partner1_uuid
                partner2_uuid  = ls_rela_keys-partner2_uuid
                org_address_id = ms_segment_address-actadd-org_node_id.

  if sy-subrc eq 0.
    et_telephone    = lr_rela_data->commdata-telephone.
    et_facsimile    = lr_rela_data->commdata-facsimile.
    et_email        = lr_rela_data->commdata-email.
    et_web          = lr_rela_data->commdata-web.
    et_telex        = lr_rela_data->commdata-telex.
    et_teletex      = lr_rela_data->commdata-teletex.
    et_rml          = lr_rela_data->commdata-rml.
    et_x400         = lr_rela_data->commdata-x400.
    et_printer      = lr_rela_data->commdata-printer.
    et_ssf          = lr_rela_data->commdata-ssf.
    et_pager        = lr_rela_data->commdata-pager.

    if iv_request_before_image is initial.
      " Enable Workplace
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_true.
    endif.
  else.
    if iv_request_before_image is initial.
      " Data could not be read: Set enable flag for node
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_false.
    endif.
  endif.

endmethod.


method bp_get_empl_addressdata.

  data: lt_eewa_keys     type        bup_t_eewa_key_api
      , ls_eewa_keys     type        bup_s_eewa_key_api
      , lt_eewa_msg      type        cmd_t_msg_complete
      , lr_eewa_msg      type ref to cmd_s_msg_complete
      , lt_eewa_data     type        bup_t_eewa_core_data_api
      , lr_eewa_data     type ref to bup_s_eewa_core_data_api
      , lt_eewamapkey    type        bup_t_addrkey_mapping
      , ls_eewamapkey    TYPE        bup_s_addrkey_mapping
      , ls_msg           type        symsg
      , lr_notes         type ref to addrs_note
      .


* Consistence check
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_employee.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.


* --- Evaluate Org NodeID ------------------------------------
*
  if ms_segment_address-actadd-org_node_id is initial.

      ls_eewamapkey-addrtype    = '4'.
      ls_eewamapkey-person_uuid = ms_segment_address-actual-bpperson.
      ls_eewamapkey-addrnumber  = ms_segment_address-actual-addrnumber.

      append ls_eewamapkey to lt_eewamapkey.
      call method cl_bup_addr_map_api=>get_corresponding_keys
        changing
          ct_addrkey = lt_eewamapkey.

      clear: ls_eewamapkey.
      read table lt_eewamapkey into ls_eewamapkey index 1.
      if ls_eewamapkey-address_id IS initial.
        macro_raise_internal_error.
      endif.

      ms_segment_address-actadd-org_node_id = ls_eewamapkey-address_id.
  endif.

  ls_eewa_keys-partner_uuid   = ms_segment_address-actual-bpperson.
  ls_eewa_keys-org_address_id = ms_segment_address-actadd-org_node_id.
  append ls_eewa_keys to lt_eewa_keys.


* --- Read Employee address data -------------------------------
*
* Only read access to the employee workplace is supported, therefore no lock is required
  call method cl_bup_eewa_api=>read
    exporting
      it_keys          = lt_eewa_keys
      is_commdata_read = is_commdata_read
    importing
      et_data_core     = lt_eewa_data
      et_message       = lt_eewa_msg.

* Errorhandling: Only lifetime once messages should appear
  delete lt_eewa_msg where lifetime eq 0.

  loop at lt_eewa_msg reference into lr_eewa_msg.
    clear: ls_msg.
    ls_msg-msgty = lr_eewa_msg->msgty.
    ls_msg-msgid = lr_eewa_msg->msgid.
    ls_msg-msgno = lr_eewa_msg->msgno.
    ls_msg-msgv1 = lr_eewa_msg->msgv1.
    ls_msg-msgv2 = lr_eewa_msg->msgv2.
    ls_msg-msgv3 = lr_eewa_msg->msgv3.
    ls_msg-msgv4 = lr_eewa_msg->msgv4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_workplace
*       iv_field    = lv_id_field
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
  endloop.


* Read data
  read table lt_eewa_data reference into lr_eewa_data
       with key partner_uuid   = ls_eewa_keys-partner_uuid
                org_address_id = ls_eewa_keys-org_address_id.
  if sy-subrc eq 0.

*   Read workplace data
    if iv_workplace_read eq if_identity=>co_true.
      move-corresponding lr_eewa_data->workplace             to es_workplace."#EC ENHOK
      move lr_eewa_data->communication_preference_wp-deflt_comm to es_workplace-deflt_comm.
    endif.

    if is_commdata_read  is not initial.
      et_telephone    = lr_eewa_data->commdata_wp-telephone.
      et_facsimile    = lr_eewa_data->commdata_wp-facsimile.
      et_email        = lr_eewa_data->commdata_wp-email.
      et_web          = lr_eewa_data->commdata_wp-web.
      et_telex        = lr_eewa_data->commdata_wp-telex.
      et_teletex      = lr_eewa_data->commdata_wp-teletex.
      et_rml          = lr_eewa_data->commdata_wp-rml.
      et_x400         = lr_eewa_data->commdata_wp-x400.
      et_printer      = lr_eewa_data->commdata_wp-printer.
      et_ssf          = lr_eewa_data->commdata_wp-ssf.
      et_pager        = lr_eewa_data->commdata_wp-pager.
    endif.

    if iv_location_read eq if_identity=>co_true.
      move-corresponding lr_eewa_data->location             to es_location."#EC ENHOK
      move lr_eewa_data->communication_preference_wp-langu to es_location-langu.
      read table lr_eewa_data->notes reference into lr_notes
           with key langu = sy-langu.
      if sy-subrc eq 0.
        move lr_notes->remark to es_location-remark.
      endif.
    endif.

    if iv_orgname_read eq if_identity=>co_true.
      move lr_eewa_data->title to es_organization_name-title.
      move lr_eewa_data->name1 to es_organization_name-name1.
      move lr_eewa_data->name2 to es_organization_name-name2.
      move lr_eewa_data->name3 to es_organization_name-name3.
      move lr_eewa_data->name4 to es_organization_name-name4.
      move lr_eewa_data->sort1 to es_organization_name-sort1.
      move lr_eewa_data->sort2 to es_organization_name-sort2.
    endif.


    if iv_workplace_read eq if_identity=>co_true or
       is_commdata_read  is not initial.

*     Enable Workplace
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_true.

*     Properties: Set ReadOnly
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_readonly = if_identity=>co_true.

    endif.

  else.
    if iv_workplace_read eq if_identity=>co_true or
       is_commdata_read  is not initial.

*     Data could not be read: Set enable flag for node
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_false.

    endif.
  endif.






endmethod.


method bp_get_personname.

  data: lt_bup_partner       type        bup_t_cent_key_api
      , ls_bup_partner       type        bup_s_cent_key_api
      , lt_bup_data          type        bup_t_cent_data_api
      , lr_bup_data          type ref to bup_s_cent_data_api
      , lt_bup_description   type        bup_t_cent_description_api
      , lr_bup_description   type ref to bup_s_cent_description_api
      , lt_bup_map_fields    type        tt_map_bup_fields
      , lr_bup_map_fields    type ref to ty_map_bup_fields
      , lt_bup_msg           type        cmd_t_msg_complete
      .

  field-symbols:
         <lv_node_field>     type any
       , <lv_bup_field>      type any
       .

  " Consistence check
  if iv_request_before_image is initial.
    if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person          and
       ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela and
       ms_segment_address-actual-idadtype ne if_identity=>co_idad_employee.
      macro_raise_internal_error.
    endif.
  else.
    if ms_segment_address-before_image-idadtype ne if_identity=>co_idad_person          and
       ms_segment_address-before_image-idadtype ne if_identity=>co_idad_person_org_rela and
       ms_segment_address-before_image-idadtype ne if_identity=>co_idad_employee.
      return.
    endif.
  endif.


  " User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.


* --- Read BP-Person -----------------------------------------
*
  if iv_request_before_image is initial.
    "...Current Data

    ls_bup_partner-partner_uuid = ms_segment_address-actual-bpperson.
    append ls_bup_partner to lt_bup_partner.

    cl_bup_cent_api=>read(
      exporting
        it_partner               = lt_bup_partner
      importing
        et_data                  = lt_bup_data
        et_message               = lt_bup_msg ).

    " Errorhandling: Only lifetime one messages should appear
    delete lt_bup_msg where lifetime eq 0.
    if lt_bup_msg is not initial.
      bp_map_personname_error(
        exporting
          it_bup_msg = lt_bup_msg ).
    endif.

  else.
    "...Before Image

    ls_bup_partner-partner_uuid = ms_segment_address-before_image-bpperson.
    append ls_bup_partner to lt_bup_partner.

    cl_bup_cent_api=>read(
      exporting
        it_partner               = lt_bup_partner
        iv_retrieve_before_image = 'X'
      importing
        et_data                  = lt_bup_data ).

  endif.

* --- Copy address -----------------------------------------
*
  read table lt_bup_data reference into lr_bup_data
       with key partner_uuid = ls_bup_partner-partner_uuid.

  if sy-subrc eq 0.

    " Get Mapping table
    bp_map_bup_fields(
      importing
        et_bup_map_fields = lt_bup_map_fields ).

    " Copy Bupa structure to Person_Name
    loop at lt_bup_map_fields reference into lr_bup_map_fields.

      assign component lr_bup_map_fields->id_field of structure es_personname to <lv_node_field>.
      if sy-subrc ne 0.
        macro_raise_internal_error. "The field must exist
      endif.

      assign component lr_bup_map_fields->bup_field of structure lr_bup_data->* to <lv_bup_field>.
      if sy-subrc ne 0.
        macro_raise_internal_error. "The field must exist
      endif.

      " Move bup field value
      <lv_node_field> = <lv_bup_field>.
    endloop.

    " Persumber is read-only
    es_personname-pers_no = lr_bup_data->persnumber.

    " Read Description
    cl_bup_cent_api=>read_description(
      exporting
        it_partner     = lt_bup_partner
      importing
        et_description = lt_bup_description ).

    " Copy Description
    read table lt_bup_description reference into lr_bup_description
         with key partner_uuid = ls_bup_partner-partner_uuid.
    if sy-subrc eq 0.
      es_personname-name_text = lr_bup_description->description.
    endif.

    if iv_request_before_image is initial.
      " Set read only flag for node
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_person_name
          iv_readonly = if_identity=>co_true.
      " Enable PersonName
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_person_name
          iv_enable   = if_identity=>co_true.
    endif.
  else.
    if iv_request_before_image is initial.
      " Data could not be read: Set enable flag for node
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_person_name
          iv_enable   = if_identity=>co_false.
    endif.
  endif.

endmethod.


method bp_get_workplacedata.

  data: lt_rela_keys         type        bup_t_rela_key_api
      , ls_rela_keys         type        bup_s_rela_key_api
      , lt_rela_data         type        bup_t_rela_data_api
      , lr_rela_data         type ref to bup_s_rela_data_api
      , lt_rela_msg          type        cmd_t_msg_complete
      , lr_rela_msg          type ref to cmd_s_msg_complete
      , lo_addr_main         type ref to cl_addr_main
      , ls_msg               type        symsg
      .

  " Consistence check
  if iv_request_before_image is initial.
    if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela.
      macro_raise_internal_error.
    endif.
  else.
    if ms_segment_address-before_image-idadtype ne if_identity=>co_idad_person_org_rela.
      return.
    endif.
  endif.

  " User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.

  " Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Read Workplace data ------------------------------------
*
  if iv_request_before_image is initial.
    " ...Current Data

    if ms_segment_address-actadd-org_node_id is initial.
      adbp_get_id(
        exporting
          io_addr_main      = lo_addr_main
          iv_address_type   = cl_addr_main=>c_organization_address
          iv_address_number = ms_segment_address-actual-addrnumber
        importing
          ev_addr_nodeid    = ms_segment_address-actadd-org_node_id ).
    endif.

    ls_rela_keys-partner1_uuid  = ms_segment_address-actual-bpperson.
    ls_rela_keys-partner2_uuid  = ms_segment_address-actual-organization.
    ls_rela_keys-org_address_id = ms_segment_address-actadd-org_node_id.
    ls_rela_keys-reldir         = '2'.        "Direction: Person -> Org

    append ls_rela_keys to lt_rela_keys.

    call method cl_bup_rela_api=>read
      exporting
        it_keys            = lt_rela_keys
      importing
        et_data            = lt_rela_data
        et_message         = lt_rela_msg.

    " Errorhandling: Only lifetime one messages should appear
    delete lt_rela_msg where lifetime eq 0.

    loop at lt_rela_msg reference into lr_rela_msg.
      clear: ls_msg.
      ls_msg-msgty = lr_rela_msg->msgty.
      ls_msg-msgid = lr_rela_msg->msgid.
      ls_msg-msgno = lr_rela_msg->msgno.
      ls_msg-msgv1 = lr_rela_msg->msgv1.
      ls_msg-msgv2 = lr_rela_msg->msgv2.
      ls_msg-msgv3 = lr_rela_msg->msgv3.
      ls_msg-msgv4 = lr_rela_msg->msgv4.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endloop.

    " Properties
    call method adbp_set_property_for_node
      exporting
        iv_nodename = if_identity_definition=>gc_node_workplace
        iv_readonly = if_identity=>co_true.

  else.
    "...Before Image

    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = ms_segment_address-before_image-addrnumber
      importing
        ev_addr_nodeid    = ls_rela_keys-org_address_id ).

    ls_rela_keys-partner1_uuid  = ms_segment_address-before_image-bpperson.
    ls_rela_keys-partner2_uuid  = ms_segment_address-before_image-organization.
    ls_rela_keys-reldir         = '2'.        "Direction: Person -> Org
    append ls_rela_keys to lt_rela_keys.

    call method cl_bup_rela_api=>read
      exporting
        it_keys                  = lt_rela_keys
        iv_retrieve_before_image = 'X'
      importing
        et_data                  = lt_rela_data.

  endif.

* --- Copy address -----------------------------------------
*
  read table lt_rela_data reference into lr_rela_data
       with key partner1_uuid  = ls_rela_keys-partner1_uuid
                partner2_uuid  = ls_rela_keys-partner2_uuid
                org_address_id = ls_rela_keys-org_address_id.

  if sy-subrc eq 0.

    move-corresponding lr_rela_data->workplace             to es_workplace."#EC ENHOK
    move lr_rela_data->communication_preference-deflt_comm to es_workplace-deflt_comm.

    if iv_request_before_image is initial.
      " Enable Workplace
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_true.
    endif.
  else.

    if iv_request_before_image is initial.
      " Data could not be read: Set enable flag for node
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_false.
    endif.
  endif.

endmethod.


method BP_MAP_BUP_FIELDS.

* ET_BUP_MAP_FIELDS is sorted by identity parameter


  data: ls_bup_map_fields   type  ty_map_bup_fields
      , lr_change_field     type ref to fieldname
      , lr_bup_map_fields   type ref to ty_map_bup_fields
      .


  if mt_bup_map_fields is initial.

*...PersonName
    ls_bup_map_fields-id_field   = 'TITLE'.
    ls_bup_map_fields-bup_field  = 'TITLE'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAME_FIRST'.
    ls_bup_map_fields-bup_field  = 'NAME_FIRST'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAME_LAST'.
    ls_bup_map_fields-bup_field  = 'NAME_LAST'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAME2'.
    ls_bup_map_fields-bup_field  = 'NAME_LAST2'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAMEMIDDLE'.
    ls_bup_map_fields-bup_field  = 'NAMEMIDDLE'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAME_LAST2'.
    ls_bup_map_fields-bup_field  = 'NAME_LST2'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAME_TEXT'.
    ls_bup_map_fields-bup_field  = 'NAME1_TEXT'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'TITLE_ACA1'.
    ls_bup_map_fields-bup_field  = 'TITLE_ACA1'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'TITLE_ACA2'.
    ls_bup_map_fields-bup_field  = 'TITLE_ACA2'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'PREFIX1'.
    ls_bup_map_fields-bup_field  = 'PREFIX1'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'PREFIX2'.
    ls_bup_map_fields-bup_field  = 'PREFIX2'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'TITLE_SPPL'.
    ls_bup_map_fields-bup_field  = 'TITLE_ROYL'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NICKNAME'.
    ls_bup_map_fields-bup_field  = 'NICKNAME'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'INITIALS'.
    ls_bup_map_fields-bup_field  = 'INITIALS'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAMEFORMAT'.
    ls_bup_map_fields-bup_field  = 'NAMEFORMAT'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'NAMCOUNTRY'.
    ls_bup_map_fields-bup_field  = 'NAMCOUNTRY'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'SORT1'.
    ls_bup_map_fields-bup_field  = 'BU_SORT1'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'SORT2'.
    ls_bup_map_fields-bup_field  = 'BU_SORT2'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

    ls_bup_map_fields-id_field   = 'LANGU'.
    ls_bup_map_fields-bup_field  = 'BU_LANGU'.
    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_person_name.
    append ls_bup_map_fields    to mt_bup_map_fields.

*...Workplace
*    ls_bup_map_fields-id_field   = 'FUNCTION'.
*    ls_bup_map_fields-bup_field  = 'FUNCTION'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.
*
*    ls_bup_map_fields-id_field   = 'BUILDING'.
*    ls_bup_map_fields-bup_field  = 'BUILDING'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.
*
*    ls_bup_map_fields-id_field   = 'FLOOR'.
*    ls_bup_map_fields-bup_field  = 'FLOOR'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.
*
*    ls_bup_map_fields-id_field   = 'ROOMNUMBER'.
*    ls_bup_map_fields-bup_field  = 'ROOMNUMBER'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.
*
*    ls_bup_map_fields-id_field   = 'ID_CODE'.
*    ls_bup_map_fields-bup_field  = 'ID_CODE'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.
*
*    ls_bup_map_fields-id_field   = 'IH_MAIL'.
*    ls_bup_map_fields-bup_field  = 'IH_MAIL'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.
*
*    ls_bup_map_fields-id_field   = 'DEFLT_COMM'.
*    ls_bup_map_fields-bup_field  = 'DEFLT_COMM'.
*    ls_bup_map_fields-id_node    = if_identity_definition=>gc_node_workplace.
*    append ls_bup_map_fields    to mt_bup_map_fields.

    sort mt_bup_map_fields by id_field.

  endif.

* Evaluate exporting table
  if it_change_fields is initial.
    et_bup_map_fields = mt_bup_map_fields.
  else.
    loop at it_change_fields reference into lr_change_field.
      read table mt_bup_map_fields
           reference into lr_bup_map_fields
           with key id_field = lr_change_field->*
           binary search.
      if sy-subrc eq 0.
        append lr_bup_map_fields->* to et_bup_map_fields.
      endif.
    endloop.
  endif.

endmethod.


method bp_map_error.

  data: lr_bup_msg           type ref to cmd_s_msg_complete
      , ls_msg               type        symsg
      , lv_lifetime          type        if_suid_msg_buffer=>ty_msg_lifetime
      , lv_key               type        suid_node_key
      , lv_nodename          type        suid_node_name
      , lv_field             type        suid_node_field
      .


  loop at it_bup_msg reference into lr_bup_msg.
    clear: ls_msg.

*   Map nodename
    case lr_bup_msg->mds_name.
      when cl_addr_main=>c_node_telephone       or
           cl_addr_main=>c_node_telephone_note  or
           cl_addr_main=>c_node_telephone_usage.
        lv_nodename = if_identity_definition=>gc_node_telephone.
      when cl_addr_main=>c_node_facsimile       or
           cl_addr_main=>c_node_facsimile_note  or
           cl_addr_main=>c_node_facsimile_usage.
        lv_nodename = if_identity_definition=>gc_node_facsimile.
      when cl_addr_main=>c_node_email       or
           cl_addr_main=>c_node_email_note  or
           cl_addr_main=>c_node_email_usage.
        lv_nodename = if_identity_definition=>gc_node_email.
      when cl_addr_main=>c_node_web       or
           cl_addr_main=>c_node_web_note  or
           cl_addr_main=>c_node_web_usage.
        lv_nodename = if_identity_definition=>gc_node_web.
      when cl_addr_main=>c_node_telex       or
           cl_addr_main=>c_node_telex_note  or
           cl_addr_main=>c_node_telex_usage.
        lv_nodename = if_identity_definition=>gc_node_telex.
      when cl_addr_main=>c_node_teletex       or
           cl_addr_main=>c_node_teletex_note  or
           cl_addr_main=>c_node_teletex_usage.
        lv_nodename = if_identity_definition=>gc_node_teletex.
      when cl_addr_main=>c_node_rml       or
           cl_addr_main=>c_node_rml_note  or
           cl_addr_main=>c_node_rml_usage.
        lv_nodename = if_identity_definition=>gc_node_remote_mail.
      when cl_addr_main=>c_node_x400       or
           cl_addr_main=>c_node_x400_note  or
           cl_addr_main=>c_node_x400_usage.
        lv_nodename = if_identity_definition=>gc_node_x400.
      when cl_addr_main=>c_node_printer       or
           cl_addr_main=>c_node_printer_note  or
           cl_addr_main=>c_node_printer_usage.
        lv_nodename = if_identity_definition=>gc_node_printer.
      when cl_addr_main=>c_node_ssf       or
           cl_addr_main=>c_node_ssf_note  or
           cl_addr_main=>c_node_ssf_usage.
        lv_nodename = if_identity_definition=>gc_node_ssf.
      when cl_addr_main=>c_node_pager       or
           cl_addr_main=>c_node_pager_note  or
           cl_addr_main=>c_node_pager_usage.
        lv_nodename = if_identity_definition=>gc_node_pager.
      when cl_addr_main=>c_node_workplace or
           cl_addr_main=>c_node_communication_preferenc.   "Attention in case of personname
        lv_nodename = if_identity_definition=>gc_node_workplace.
      when others. "Root
        continue.
    endcase.

    ls_msg-msgty = lr_bup_msg->msgty.
    ls_msg-msgid = lr_bup_msg->msgid.
    ls_msg-msgno = lr_bup_msg->msgno.
    ls_msg-msgv1 = lr_bup_msg->msgv1.
    ls_msg-msgv2 = lr_bup_msg->msgv2.
    ls_msg-msgv3 = lr_bup_msg->msgv3.
    ls_msg-msgv4 = lr_bup_msg->msgv4.

    if lr_bup_msg->lifetime eq 1.
      lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    else.
      lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
    endif.

    lv_field    = lr_bup_msg->mds_attr.
    lv_key      = lr_bup_msg->mds_key.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = lv_nodename
        iv_key      = lv_key
        iv_field    = lv_field
        is_msg      = ls_msg
        iv_lifetime = lv_lifetime.
  endloop.


endmethod.


method bp_map_personname_error.

  data: lt_bup_change_fields type        tt_map_bup_fields
      , lr_bup_change_fields type ref to ty_map_bup_fields
      , lr_bup_msg           type ref to cmd_s_msg_complete
      , ls_msg               type        symsg
      , lv_id_field          type        suid_node_field
      , lv_lifetime          type        if_suid_msg_buffer=>ty_msg_lifetime
      , lr_bup_attr_source   type ref to cmd_s_mdsattr
      .


  bp_map_bup_fields(
    importing
      et_bup_map_fields = lt_bup_change_fields ).

  sort lt_bup_change_fields by bup_field.

  loop at it_bup_msg reference into lr_bup_msg.
    clear: ls_msg.

    ls_msg-msgty = lr_bup_msg->msgty.
    ls_msg-msgid = lr_bup_msg->msgid.
    ls_msg-msgno = lr_bup_msg->msgno.
    ls_msg-msgv1 = lr_bup_msg->msgv1.
    ls_msg-msgv2 = lr_bup_msg->msgv2.
    ls_msg-msgv3 = lr_bup_msg->msgv3.
    ls_msg-msgv4 = lr_bup_msg->msgv4.

*   Find appropriate node field
    clear: lv_id_field.
    loop at lr_bup_msg->mds_attr_source reference into lr_bup_attr_source.
      read table lt_bup_change_fields reference into lr_bup_change_fields
           with key bup_field = lr_bup_attr_source->mds_attr
           binary search.
      if sy-subrc eq 0.
        if lr_bup_change_fields->id_node ne if_identity_definition=>gc_node_person_name.
*         Hopefully this will never happen
          macro_raise_internal_error.
        endif.
        lv_id_field = lr_bup_change_fields->id_field.
        exit.
      endif.
    endloop.

*   Lifetime
    if lr_bup_msg->lifetime eq 0.
      lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
    else.
      lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endif.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_person_name
        iv_field    = lv_id_field
        is_msg      = ls_msg
        iv_lifetime = lv_lifetime.
  endloop.


endmethod.


method bp_reset_modification.


  data: ls_relc_key              type        bup_s_relc_key_api
      , lt_relc_key              type        bup_t_relc_key_api
      , ls_bup_cent              type        bup_s_cent_uuidkey_api
      , lt_bup_cent              type        bup_t_cent_uuidkey_api
*      , lv_partner1_uuid         type        bu_partner_uuid
*      , lv_partner2_uuid         type        bu_partner_uuid
      .


  if ms_segment_address-actadd-trx_with_bp eq co_trx_user.

*   BP Relation
    if ms_segment_address-actual-bpperson     is not initial and
       ms_segment_address-actual-organization is not initial.
      clear: ls_relc_key, lt_relc_key.
      ls_relc_key-partner1_uuid = ms_segment_address-actual-bpperson. " UUID must be filled !
      ls_relc_key-partner2_uuid = ms_segment_address-actual-organization. " UUID must be filled !
      ls_relc_key-reldir        = '2'.
      append ls_relc_key to lt_relc_key.
      cl_bup_transaction_relt_api=>reset_modifications(
        exporting
          iv_do_cleanup      = iv_do_cleanup
          it_keys            = lt_relc_key ).
*        importing
*          ev_rejected        = lv_rejected ).
*call method cl_bup_transaction_api=>cleanup
**  importing
**    et_message         =
**    er_message_handler =
*    .

    endif.


*   Reset default org if necessary
    if ms_segment_address-actual-organization  is not initial and
       ms_segment_address-actual-addrnumber    is initial     and
       ms_segment_address-actadd-org_node_id   is not initial.
      loop at gt_control transporting no fields
           where idref->ms_manager-modus                       ne go_persistence->co_ta_modus_display
             and bname                                         ne ms_manager-bname
             and idref->ms_segment_address-actual-organization eq ms_segment_address-actual-organization
             and idref->ms_segment_address-actadd-org_node_id  eq ms_segment_address-actadd-org_node_id.
        exit.
      endloop.
      if sy-subrc ne 0.
        call method cl_suid_organization=>reset_modification_default_org
          exporting
            iv_orgnode_id = ms_segment_address-actadd-org_node_id.
      endif.
    endif.


*   BP Person
    if ms_segment_address-actual-bpperson is not initial.
      clear: ls_bup_cent, lt_bup_cent.
      ls_bup_cent-partner_uuid = ms_segment_address-actual-bpperson.  " UUID must be filled !
      append ls_bup_cent to lt_bup_cent.
      cl_bup_transaction_partner_api=>reset_modifications(
        exporting
          iv_do_cleanup      = iv_do_cleanup
          it_keys            = lt_bup_cent ).
*        importing
*          ev_rejected        = lv_rejected ).
    endif.

  endif.


endmethod.


method bp_set_communication_data.

  data: lt_rela_mod                type        bup_t_rela_modification_api
      , ls_rela_mod                type        bup_s_rela_modification_api
      , lt_rela_msg                type        cmd_t_msg_complete
      , lt_rela_comm_notitication  type        addrt_change_notification
      , lo_addr_main               type ref to cl_addr_main
      , ls_comm_created_id         type        bup_s_addr_comm_created_id
      .


* Consistence check
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.

* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Evaluate Org NodeID ------------------------------------
*
  if ms_segment_address-actadd-org_node_id is initial.
    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = ms_segment_address-actual-addrnumber
      importing
        ev_addr_nodeid    = ms_segment_address-actadd-org_node_id ).
  endif.


* --- Copy CommData to Bupa structure --------------------
*
  ls_rela_mod-commdata-telephone     = it_telephone.
  if is_current_state-current_state_tel is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-telephone ).
  endif.
  ls_rela_mod-commdata-facsimile     = it_facsimile.
  if is_current_state-current_state_fax is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-facsimile ).
  endif.
  ls_rela_mod-commdata-email         = it_email.
  if is_current_state-current_state_email is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-email ).
  endif.
  ls_rela_mod-commdata-web           = it_web.
  if is_current_state-current_state_web is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-web ).
  endif.
  ls_rela_mod-commdata-telex         = it_telex.
  if is_current_state-current_state_telex is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-telex ).
  endif.
  ls_rela_mod-commdata-teletex       = it_teletex.
  if is_current_state-current_state_teletex is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-teletex ).
  endif.
  ls_rela_mod-commdata-rml           = it_rml.
  if is_current_state-current_state_rml is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-rml ).
  endif.
  ls_rela_mod-commdata-x400          = it_x400.
  if is_current_state-current_state_x400 is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-x400 ).
  endif.
  ls_rela_mod-commdata-printer       = it_printer.
  if is_current_state-current_state_printer is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-printer ).
  endif.
  ls_rela_mod-commdata-ssf           = it_ssf.
  if is_current_state-current_state_ssf is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-ssf ).
  endif.
  ls_rela_mod-commdata-pager         = it_pager.
  if is_current_state-current_state_pager is initial.
    addr_map_commdata( changing ct_comm_table = ls_rela_mod-commdata-pager ).
  endif.


* --- Change CommData ----------------------------------------
*
  ls_rela_mod-partner1_uuid          = ms_segment_address-actual-bpperson.
  ls_rela_mod-partner2_uuid          = ms_segment_address-actual-organization.
  ls_rela_mod-mod_key-reldir         = '2'.       "Direction: Person -> Org
  ls_rela_mod-mod_key-org_address_id = ms_segment_address-actadd-org_node_id.
  ls_rela_mod-current_state_commdata = is_current_state.

  append ls_rela_mod to lt_rela_mod.


  call method cl_bup_rela_api=>modify
    exporting
      it_modifications             = lt_rela_mod
    importing
      et_message                   = lt_rela_msg
      et_change_notifications_comm = lt_rela_comm_notitication
      es_comm_created_id           = ls_comm_created_id.


* Notification
  if lt_rela_comm_notitication is not initial.
    call method adbp_add_notifications
      exporting
        it_addr_notifications = lt_rela_comm_notitication.

*   Register ID of BP
    ms_segment_address-actadd-changed_bprel = if_identity=>co_true.   " BP->Save must be called
  endif.

* Messages
* Start: Check influence to workplace node
*  call method go_msg_buffer->delete_object_message
*    exporting
*      iv_bname    = ms_manager-bname
*      iv_nodename = if_identity_definition=>gc_node_workplace
*      iv_field    = 'DEFLT_COMM'.
* End: Check influence to workplace node

  if lt_rela_msg is not initial.
    call method me->bp_map_error
      exporting
        it_bup_msg = lt_rela_msg.
  endif.

  et_new_telephone_id = ls_comm_created_id-telephone.
  et_new_facsimile_id = ls_comm_created_id-facsimile.
  et_new_email_id     = ls_comm_created_id-email.
  et_new_web_id       = ls_comm_created_id-web.
  et_new_telex_id     = ls_comm_created_id-telex.
  et_new_teletex_id   = ls_comm_created_id-teletex.
  et_new_rml_id       = ls_comm_created_id-rml.
  et_new_x400_id      = ls_comm_created_id-x400.
  et_new_printer_id   = ls_comm_created_id-printer.
  et_new_ssf_id       = ls_comm_created_id-ssf.
  et_new_pager_id     = ls_comm_created_id-pager.


endmethod.


method bp_set_employee_work_addr.


  data: ls_msg                   type        symsg
      , lt_eewamapkey            type        bup_t_addrkey_mapping
      , ls_eewamapkey            type        bup_s_addrkey_mapping
      , lt_eewa_keys             type        bup_t_eewa_key_api
      , ls_eewa_keys             type        bup_s_eewa_key_api
      , lt_eewa_msg              type        cmd_t_msg_complete
      , lr_eewa_msg              type ref to cmd_s_msg_complete
      , lt_failed_eewa_keys      type        bup_t_eewa_key_api
      .


* --- Consistency check -----------------------------------------------
*
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person.
    macro_raise_internal_error.
  endif.

* BP trx only
  if ms_segment_address-actadd-trx_with_bp ne co_trx_bp.
    macro_raise_internal_error.
  endif.

* Get Organization Workplace address NodeID
  ls_eewamapkey-addrtype     = '4'.
  ls_eewamapkey-person_uuid  = ms_segment_address-actual-bpperson.
  ls_eewamapkey-address_uuid = is_organization-orgaddr_uuid.
  append ls_eewamapkey to lt_eewamapkey.
  call method cl_bup_addr_map_api=>get_corresponding_keys
    changing
      ct_addrkey = lt_eewamapkey.

  clear: ls_eewamapkey.
  read table lt_eewamapkey into ls_eewamapkey index 1.


* --- Existence check: Read Employee address data ---------------------------
*
  ls_eewa_keys-partner_uuid   = ms_segment_address-actual-bpperson.
  ls_eewa_keys-org_address_id = ls_eewamapkey-address_id.
  append ls_eewa_keys to lt_eewa_keys.

  call method cl_bup_eewa_api=>read
    exporting
      it_keys        = lt_eewa_keys
    importing
      et_failed_keys = lt_failed_eewa_keys
      et_message     = lt_eewa_msg.

  read table lt_failed_eewa_keys
       with key partner_uuid   = ls_eewa_keys-partner_uuid
                org_address_id = ls_eewa_keys-org_address_id
       transporting no fields.
  if sy-subrc is initial.
    loop at lt_eewa_msg reference into lr_eewa_msg.
      clear: ls_msg.
      ls_msg-msgty = lr_eewa_msg->msgty.
      ls_msg-msgid = lr_eewa_msg->msgid.
      ls_msg-msgno = lr_eewa_msg->msgno.
      ls_msg-msgv1 = lr_eewa_msg->msgv1.
      ls_msg-msgv2 = lr_eewa_msg->msgv2.
      ls_msg-msgv3 = lr_eewa_msg->msgv3.
      ls_msg-msgv4 = lr_eewa_msg->msgv4.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          iv_field    = if_identity_definition=>gc_field_organization_orgaddid
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endloop.
    ev_reject_assignment = if_identity=>co_true.
    return.
  endif.


* --- Modify actual buffer -----------------------------------------------
*
* todo ms_segment_address-actual-addrnumber
  ms_segment_address-actual-idadtype           = if_identity=>co_idad_employee.
  ms_segment_address-actual-mandt              = sy-mandt.
  ms_segment_address-actual-bname              = ms_manager-bname.
  ms_segment_address-actual-addrnumber         = ls_eewamapkey-addrnumber.
  ms_segment_address-actadd-org_node_id        = ls_eewa_keys-org_address_id.



endmethod.


method bp_set_organization.


  data: lt_relc_keys             type        bup_t_relc_key_api
      , ls_relc_keys             type        bup_s_relc_key_api
      , lt_relc_failed_keys      type        bup_t_relc_key_api
      , lt_relc_msg              type        cmd_t_msg_complete
      , lr_relc_msg              type ref to cmd_s_msg_complete
      , ls_relc_mod              type        bup_s_relc_modification_api
      , lt_relc_mod              type        bup_t_relc_modification_api
      , lt_relc_changed_keys     type        bup_t_relc_changedkey_api
      , lt_rela_keys             type        bup_t_rela_key_api
      , ls_rela_keys             type        bup_s_rela_key_api
      , lt_rela_msg              type        cmd_t_msg_complete
      , lr_rela_msg              type ref to cmd_s_msg_complete
      , lt_rela_failed_keys      type        bup_t_rela_key_api
      , ls_rela_mod              type        bup_s_rela_modification_api
      , lt_rela_mod              type        bup_t_rela_modification_api
      , lt_rela_changed_keys     type        bup_t_rela_changedkey_api
      , lv_rela_exist            type        sesf_boolean
      , ls_msg                   type        symsg
      , lv_lifetime              type        if_suid_msg_buffer=>ty_msg_lifetime
      .


* --- Consistency check -----------------------------------------------
*
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.


* --- Check relationship between Person and Organization --------------
*
  ls_relc_keys-partner1_uuid = ms_segment_address-actual-bpperson.
  ls_relc_keys-partner2_uuid = is_organization-org_uuid.
  ls_relc_keys-reldir        = '2'.        "Direction: Person -> Org

  append ls_relc_keys to lt_relc_keys.

  cl_bup_relc_api=>read(
    exporting
      it_keys            = lt_relc_keys
    importing
      et_failed_keys     = lt_relc_failed_keys ).

  read table lt_relc_failed_keys
       with key partner1_uuid = ls_relc_keys-partner1_uuid
                partner2_uuid = ls_relc_keys-partner2_uuid
       transporting no fields.

  if sy-subrc eq 0.
* --- Create relationship between Person and Organization --------------
*
    ls_relc_mod-create_handle    = ms_manager-bname.
    ls_relc_mod-partner1_uuid    = ls_relc_keys-partner1_uuid.
    ls_relc_mod-partner2_uuid    = ls_relc_keys-partner2_uuid.
    ls_relc_mod-mod_data-reldir  = '2'.      "Direction: Person -> Org
    append 'RELDIR' to ls_relc_mod-changed_fields.
    ls_relc_mod-change_mode      = 'C'.      "Create
    append ls_relc_mod to lt_relc_mod.

    cl_bup_relc_api=>modify(
      exporting
        it_modifications   = lt_relc_mod
      importing
        et_message         = lt_relc_msg
        et_changed_keys    = lt_relc_changed_keys ).

*   Map messages
    loop at lt_relc_msg reference into lr_relc_msg.
      clear: ls_msg.

      ls_msg-msgty = lr_relc_msg->msgty.
      ls_msg-msgid = lr_relc_msg->msgid.
      ls_msg-msgno = lr_relc_msg->msgno.
      ls_msg-msgv1 = lr_relc_msg->msgv1.
      ls_msg-msgv2 = lr_relc_msg->msgv2.
      ls_msg-msgv3 = lr_relc_msg->msgv3.
      ls_msg-msgv4 = lr_relc_msg->msgv4.

*     Lifetime
      if lr_relc_msg->lifetime eq 0.
        lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
      else.
        lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
      endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = lv_lifetime.
    endloop.

*   Check: Was RELC created?
    read table lt_relc_changed_keys
      with key create_handle = ms_manager-bname
      transporting no fields.
    if sy-subrc ne 0.
      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.

  endif.


* --- Read workplace address -------------------------------------
*
  ls_rela_keys-partner1_uuid   = ms_segment_address-actual-bpperson.
  ls_rela_keys-partner2_uuid   = is_organization-org_uuid.
  ls_rela_keys-org_address_id  = iv_org_node_id.
  ls_rela_keys-reldir          = '2'.        "Direction: Person -> Org
  append ls_rela_keys to lt_rela_keys.

  cl_bup_rela_api=>read(
    exporting
      it_keys            = lt_rela_keys
    importing
      et_failed_keys     = lt_rela_failed_keys
      et_message         = lt_rela_msg ).

  read table lt_rela_failed_keys
       with key partner1_uuid   = ls_rela_keys-partner1_uuid
                partner2_uuid   = ls_rela_keys-partner2_uuid
                org_address_id  = iv_org_node_id
       transporting no fields.

  if sy-subrc eq 0.
* --- Create workplace address -------------------------------------
*
    ls_rela_mod-create_handle           = ms_manager-bname.
    ls_rela_mod-partner1_uuid           = ls_rela_keys-partner1_uuid.
    ls_rela_mod-partner2_uuid           = ls_rela_keys-partner2_uuid.
    ls_rela_mod-mod_data-org_address_id = iv_org_node_id.
    ls_rela_mod-mod_data-reldir         = '2'.       "Direction: Person -> Org
    append 'RELDIR' to ls_rela_mod-changed_fields.
    ls_rela_mod-change_mode             = 'C'.       "Create
    append ls_rela_mod to lt_rela_mod.

    call method cl_bup_rela_api=>modify
      exporting
        it_modifications = lt_rela_mod
      importing
        et_message       = lt_rela_msg
        et_changed_keys  = lt_rela_changed_keys.

*   Map messages
    loop at lt_rela_msg reference into lr_rela_msg.
      clear: ls_msg.

      ls_msg-msgty = lr_rela_msg->msgty.
      ls_msg-msgid = lr_rela_msg->msgid.
      ls_msg-msgno = lr_rela_msg->msgno.
      ls_msg-msgv1 = lr_rela_msg->msgv1.
      ls_msg-msgv2 = lr_rela_msg->msgv2.
      ls_msg-msgv3 = lr_rela_msg->msgv3.
      ls_msg-msgv4 = lr_rela_msg->msgv4.

*     Lifetime
      if lr_rela_msg->lifetime eq 0.
        lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
      else.
        lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
      endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = lv_lifetime.
    endloop.

    read table lt_rela_changed_keys
      with key create_handle = ms_manager-bname
      transporting no fields.
    if sy-subrc ne 0.
      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.

  else.
*   Relationship between Person and Org exist and type 3 address as well
*   -> It is dangerous overwriting the workplace data !
    lv_rela_exist = if_identity=>co_true.
  endif.

* RELC ChangeMode auf 'X' ???
* RELA ChangeMode auf 'X' ???


* --- Modify actual buffer -----------------------------------------------
*
* Notification: There must be a distinction between creating the workplace address
*               and just reusing !
  if lv_rela_exist eq if_identity=>co_true.
*    go_notify->notify_update(
*      exporting
*        iv_bname    = ms_manager-bname
*        iv_nodename = if_identity_definition=>gc_node_workplace ).
  else.
    go_notify->notify_create(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_workplace ).
  endif.

  if is_organization-orgaddr_uuid is not initial.
*   First take Org address UUID
    call method cl_suid_organization=>map_org_addr_uuid_to_id
      exporting
        iv_org_uuid     = is_organization-org_uuid
        iv_orgaddr_uuid = is_organization-orgaddr_uuid
      importing
        ev_address_no   = ms_segment_address-actual-addrnumber.
  else.
    ms_segment_address-actual-addrnumber       = is_organization-orgaddr.
  endif.


  ms_segment_address-actual-idadtype           = if_identity=>co_idad_person_org_rela.
  ms_segment_address-actual-mandt              = sy-mandt.
  ms_segment_address-actual-bname              = ms_manager-bname.
  ms_segment_address-actual-organization       = is_organization-org_uuid.
  ms_segment_address-actadd-org_node_id        = iv_org_node_id.


* Register changed bupa relation, if rela (and relc) were created
  if lv_rela_exist eq if_identity=>co_false.
    ms_segment_address-actadd-changed_bprel = if_identity=>co_true.
  endif.


endmethod.


method bp_set_person.

  data: lv_bup_type          type        bup_s_cent_data_api-type
      , lt_bup_partner       type        bup_t_cent_key_api
      , ls_bup_partner       type        bup_s_cent_key_api
      , lt_bup_data          type        bup_t_cent_data_api
      , lr_bup_data          type ref to bup_s_cent_data_api
      , ls_bup_changed       type        fieldname
      , lt_bup_cent          type        bup_t_cent_create_api
      , ls_bup_cent          type        bup_s_cent_create_api
      , lt_bup_msg           type        cmd_t_msg_complete
      , lr_bup_msg           type ref to cmd_s_msg_complete
      , lt_bup_created_keys  type        bup_t_cent_createkey_api
      , lr_bup_created_keys  type ref to bup_s_cent_createkey_api
      , lv_person_persno     type        ad_persnum
      , lv_person_guid       type        sysuuid_x
      , lv_usr21_person      type        usr21-bpperson
      , ls_msg               type        symsg
      , lv_lifetime          type        if_suid_msg_buffer=>ty_msg_lifetime
      .


* --- Parameter check ----------------------------------------
*
  if iv_newperson ne if_identity=>co_false and
     iv_newperson ne if_identity=>co_true.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.


  if iv_newperson eq if_identity=>co_false.
*...Check: Assign Person: PersonID must be filled
    if is_person-person_uuid is initial.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '016'.
*     MSG: Geben Sie die UUID des Geschäftspartners an.
      if 1 = 0. message e016(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          iv_field    = if_identity_definition=>gc_field_person_person_uuid
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.
  endif.


* --- Existence check of Person ------------------------------
*
  if is_person-person_uuid is not initial.
    clear: lt_bup_partner, lt_bup_data.

    ls_bup_partner-partner_uuid = is_person-person_uuid.
    append ls_bup_partner to lt_bup_partner.

    cl_bup_cent_api=>read(
      exporting
        it_partner         = lt_bup_partner
      importing
        et_data            = lt_bup_data ).

    read table lt_bup_data reference into lr_bup_data
         with key partner_uuid = ls_bup_partner-partner_uuid.

    if sy-subrc eq 0.
*     BP could be Person or Organization or Group
      lv_bup_type = lr_bup_data->type.
      if lr_bup_data->type eq if_bup_const=>gc_type_person.
        lv_person_persno = lr_bup_data->persnumber.
      endif.

      if lv_bup_type is initial.
        lv_bup_type = 'X'. " Just for security
      endif.
    else.
      clear: lv_bup_type.  " Business Partner does not exist
    endif.

*...--- Assign Person ---------
    if iv_newperson eq if_identity=>co_false.

*.....The Business Partner must exist
      if lv_bup_type is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '017'.
*       MSG: Der Geschäftspartner existiert nicht.
        if 1 = 0. message e017(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            iv_field    = if_identity_definition=>gc_field_person_person_uuid
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        ev_reject_assignment = if_identity=>co_true.
        return.
      endif.

*.....The Business Partner must be of type PERSON
      if lv_bup_type ne if_bup_const=>gc_type_person.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '018'.
*       MSG: Der Geschäftspartner ist nicht vom Typ 'Person'.
        if 1 = 0. message e018(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            iv_field    = if_identity_definition=>gc_field_person_person_uuid
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        ev_reject_assignment = if_identity=>co_true.
        return.
      endif.

*...--- Create Person ---------
    else.

*.....The Business Partner must NOT exist
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '019'.
*     MSG: Der Geschäftspartner existiert bereits.
      if 1 = 0. message e019(suid01). endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          iv_field    = if_identity_definition=>gc_field_person_person_uuid
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

      ev_reject_assignment = if_identity=>co_true.
      return.

    endif.
  endif.


* --- Assign Person --------------------------------------------
*
  if iv_newperson eq if_identity=>co_false.

*...Check: Is Person already assigned to another Identity ?
*   -> Ersetzen durch Search Methode (wahrscheinlich wird auch eine Sperre benötigt)

    select single bpperson from usr21 into lv_usr21_person
           where bpperson eq is_person-person_uuid
             and bname    ne ms_manager-bname.              "#EC *
    if sy-subrc eq 0.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '020'.
*     MSG: Der Geschäftspartner ist einer anderen Identity zugeordnet.
      if 1 = 0. message e020(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          iv_field    = if_identity_definition=>gc_field_person_person_uuid
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.

*   The following fields now must have defined values
*   lv_person_persno  " already set
    lv_person_guid = is_person-person_uuid.


* --- Create Person --------------------------------------------
*
  else.   " iv_newperson eq if_identity=>co_true.

*...Check: Create new Person (with or without UUID)
    clear: ls_bup_cent, lt_bup_cent, ls_bup_changed.
    if is_person-person_uuid is not initial.
      ls_bup_cent-partner_uuid = is_person-person_uuid.
    endif.
    ls_bup_cent-create_handle  = ms_manager-bname.      " Always fill handle
    ls_bup_cent-type           = if_bup_const=>gc_type_person.
    ls_bup_changed             = 'TYPE'.
    append ls_bup_changed to ls_bup_cent-changed_fields.
    append ls_bup_cent    to lt_bup_cent.

    cl_bup_cent_api=>create_partner(
      exporting
        it_modifications   = lt_bup_cent
      importing
        et_message         = lt_bup_msg
        et_created_keys    = lt_bup_created_keys ).

    read table lt_bup_created_keys reference into lr_bup_created_keys
         with key create_handle = ms_manager-bname.

    if sy-subrc eq 0.

      lv_person_guid = lr_bup_created_keys->partner_uuid.

*.....Node PersonName was created
      go_notify->notify_create(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person_name ).

    else.
*     Copy errors
      loop at lt_bup_msg reference into lr_bup_msg.
        clear: ls_msg.

        ls_msg-msgty = lr_bup_msg->msgty.
        ls_msg-msgid = lr_bup_msg->msgid.
        ls_msg-msgno = lr_bup_msg->msgno.
        ls_msg-msgv1 = lr_bup_msg->msgv1.
        ls_msg-msgv2 = lr_bup_msg->msgv2.
        ls_msg-msgv3 = lr_bup_msg->msgv3.
        ls_msg-msgv4 = lr_bup_msg->msgv4.

*       Lifetime
        if lr_bup_msg->lifetime eq 0.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
        else.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      endloop.

      ev_reject_assignment = if_identity=>co_true.
      return.
    endif.

*   The following fields now must have defined values
*   lv_person_guid                             " already set
    lv_person_persno              = space.     " Read in Finalize

*   Register change of BP
    ms_segment_address-actadd-changed_bp = if_identity=>co_true.   " BP->Save must be called

  endif.


* --- Move values to segements -------------------------------
*
  clear: ms_segment_address-actual-addrnumber,
         ms_segment_address-actual-organization,
         ms_segment_address-actadd-org_node_id.

  ms_segment_address-actual-idadtype      = if_identity=>co_idad_person.
  ms_segment_address-actual-mandt         = sy-mandt.
  ms_segment_address-actual-bname         = ms_manager-bname.
  ms_segment_address-actual-bpperson      = lv_person_guid.
  ms_segment_address-actual-persnumber    = lv_person_persno.



endmethod.


method bp_set_personname.


  data: lt_bup_cent          type        bup_t_cent_modification_api
      , ls_bup_cent          type        bup_s_cent_modification_api
      , lt_bup_msg           type        cmd_t_msg_complete
      , lt_bup_changed_keys  type        bup_t_cent_changedkey_api
      , lt_bup_change_fields type        tt_map_bup_fields
      , lr_bup_change_fields type ref to ty_map_bup_fields
      .

  field-symbols:
         <lv_node_field>     type any
       , <lv_bup_field>      type any
       .


* Consistence check
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person          and
     ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.


* --- Get Mapping table -----------------------------------
*
  bp_map_bup_fields(
    exporting
      it_change_fields  = it_change_fields
    importing
      et_bup_map_fields = lt_bup_change_fields ).


* --- Copy Person_Name to Bupa structure --------------------
*
  loop at lt_bup_change_fields reference into lr_bup_change_fields.

*   Fill Bupa change fields
    append lr_bup_change_fields->bup_field to ls_bup_cent-changed_fields.

    assign component lr_bup_change_fields->id_field of structure is_personname to <lv_node_field>.
    if sy-subrc ne 0.
      macro_raise_internal_error. "The field must exist
    endif.

    assign component lr_bup_change_fields->bup_field of structure ls_bup_cent-data to <lv_bup_field>.
    if sy-subrc ne 0.
      macro_raise_internal_error. "The field must exist
    endif.

*   Move node field value
    <lv_bup_field> = <lv_node_field>.

  endloop.


* --- Modify BP-Person -----------------------------------------
* -> Change current time slice
*
  ls_bup_cent-mod_key-partner_uuid = ms_segment_address-actual-bpperson.
  ls_bup_cent-change_mode          = 'U'.
  append ls_bup_cent to lt_bup_cent.

  cl_bup_cent_api=>modify(
    exporting
      it_modifications   = lt_bup_cent
    importing
      et_message         = lt_bup_msg
      et_changed_keys    = lt_bup_changed_keys
     ).

  read table lt_bup_changed_keys
       with key change_key-partner_uuid = ls_bup_cent-mod_key-partner_uuid
       transporting no fields.

* Notification, if something has changed
  if sy-subrc eq 0.
    go_notify->notify_update(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_person_name ).

*   Register ID of BP
    ms_segment_address-actadd-changed_bp = if_identity=>co_true.   " BP->Save must be called
  endif.

* Mapping of Error Table
  if lt_bup_msg is not initial.

    bp_map_personname_error(
      exporting
        it_bup_msg = lt_bup_msg ).

  endif.


endmethod.


method bp_set_workplacedata.


  data: lt_rela_mod                type        bup_t_rela_modification_api
      , ls_rela_mod                type        bup_s_rela_modification_api
      , lt_rela_msg                type        cmd_t_msg_complete
      , lt_rela_changed_workplaces type        bup_t_rela_key_api
      , lo_addr_main               type ref to cl_addr_main
      .


* Consistence check
  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_person_org_rela.
    macro_raise_internal_error.
  endif.

* User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.

* Get address instance
  lo_addr_main = cl_addr_main=>get_instance( ).


* --- Evaluate Org NodeID ------------------------------------
*
  if ms_segment_address-actadd-org_node_id is initial.
    adbp_get_id(
      exporting
        io_addr_main      = lo_addr_main
        iv_address_type   = cl_addr_main=>c_organization_address
        iv_address_number = ms_segment_address-actual-addrnumber
      importing
        ev_addr_nodeid    = ms_segment_address-actadd-org_node_id ).
  endif.


* --- Map change_fields --------------------------------------
*
  call method adbp_map_change_field
    exporting
      iv_nodename           = if_identity_definition=>gc_node_workplace
      it_change_fields      = it_change_fields
    changing
      ct_addr_change_fields = ls_rela_mod-changed_fields_bas.


* --- Copy Workplace to Bupa structure --------------------
*
  move-corresponding is_workplace to ls_rela_mod-workplace. "#EC ENHOK
  move is_workplace-deflt_comm    to ls_rela_mod-communication_preference-deflt_comm.


* --- Change Workplace data ----------------------------------
*
  ls_rela_mod-partner1_uuid           = ms_segment_address-actual-bpperson.
  ls_rela_mod-partner2_uuid           = ms_segment_address-actual-organization.
  ls_rela_mod-change_mode_bas         = 'U'.
  ls_rela_mod-mod_key-reldir          = '2'.       "Direction: Person -> Org
  ls_rela_mod-mod_key-org_address_id  = ms_segment_address-actadd-org_node_id.

  append ls_rela_mod to lt_rela_mod.

  call method cl_bup_rela_api=>modify
    exporting
      it_modifications      = lt_rela_mod
    importing
      et_message            = lt_rela_msg
      et_changed_workplaces = lt_rela_changed_workplaces.

  read table lt_rela_changed_workplaces
       with key partner1_uuid  = ls_rela_mod-partner1_uuid
                partner2_uuid  = ls_rela_mod-partner2_uuid
                org_address_id = ms_segment_address-actadd-org_node_id
       transporting no fields.
  if sy-subrc eq 0.
*   Notification, if something has changed
    go_notify->notify_update(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_workplace ).

*   Register changed bupa relation
    ms_segment_address-actadd-changed_bprel = if_identity=>co_true.
  endif.

  if lt_rela_msg is not initial.
    call method me->bp_map_error
      exporting
        it_bup_msg = lt_rela_msg.
  endif.


endmethod.


method catch_txn_finished.

  data: lr_control          type ref to ty_control
       ,lt_segment_roles    type        suid_tt_segment_roles
       ,lv_exit_name        type        ssm_path
       ,lt_str_agrs         type        suid_tt_str_agrs
       ,lv_func_name        type        funcname
       ,lv_msg_key_value    type        string
       ,lv_msg_data         type        symsg
       ,lo_exception        type ref to cx_suid_identity
       ,lv_save_bp          type        sesf_boolean
       .

**********************************************************************
*--------------------------------------------------------------------*
* Commit work
***

  if kind = 'C'.     " Transaction finished by COMMIT WORK

* ---- Additional information -----------------------------------------*
*      Cannot be persisted in the update task: No rollback possible

* ---- Get information for audit log and print parameters and authorities
    loop at gt_control reference into lr_control
         where idref->ms_manager-modus  ne go_persistence->co_ta_modus_display     and
               idref->ms_manager-status eq go_persistence->co_ta_status_saved.

      if lr_control->idref->ms_manager-modus  eq go_persistence->co_ta_modus_delete.
        call function 'DELETE_DEFAULT_PRINTPARAMS'
          exporting
            user                = lr_control->idref->ms_manager-bname
          exceptions
            error_deleting_data = 0
            others              = 0.
      else.
*       only add changed printparam segment to internal table
        if lr_control->idref->ms_segment_printparam-status eq go_persistence->co_seg_changed.

          call function 'UPDATE_DEFAULT_PRINTPARAMS'        "#EC *
            exporting
              user               = lr_control->idref->ms_manager-bname
              src_user           = lr_control->idref->ms_segment_printparam-actual-printsource
              destination        = lr_control->idref->ms_segment_printparam-actual-pdest
              immediately        = lr_control->idref->ms_segment_printparam-actual-primm
              release            = lr_control->idref->ms_segment_printparam-actual-prrel
*             new_list_id        = lr_control->idref->ms_segment_printparam-actual-prnew  "should not be set
            exceptions
              error_storing_data = 0
              others             = 0.

        endif.
      endif.

*     only add changed roles segment to internal table
      if lr_control->idref->ms_segment_roles-status eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_roles to lt_segment_roles.
      endif.
    endloop.


* -------------------------- SAP and Customer Exit --------------------
* call SAP and Customer Exits
* for user-role assignment (like PRGN_USER_ASSIGNMENT_CHANGE)
* ---------------------------------------------------------------------

    if lines( lt_segment_roles ) > 0.
*     check if SAP or customer exit is set
      call method cl_suid_role_helper=>get_role_assignment_exit
        exporting
          iv_exit_name  = cl_identity=>co_sap_assignment_exit
        importing
          ev_exit_value = lv_exit_name.

      if lv_exit_name is not initial and lv_exit_name ne space.

        call method cl_identity=>after_commit_customer_exit
          exporting
            it_segment_roles = lt_segment_roles
          importing
            et_str_agrs      = lt_str_agrs.

        lv_func_name = lv_exit_name.

        call function 'FUNCTION_EXISTS'
          exporting
            funcname           = lv_func_name
          exceptions
            function_not_exist = 1
            others             = 2.
        if sy-subrc = 0.
          call function lv_func_name
            tables
              activity_groups = lt_str_agrs.
        endif.

      endif.

      clear lv_exit_name.
      call method cl_suid_role_helper=>get_role_assignment_exit
        exporting
          iv_exit_name  = cl_identity=>co_cust_assignment_exit
        importing
          ev_exit_value = lv_exit_name.

      if lv_exit_name is not initial and lv_exit_name ne space.

*       if changed roles have been computed already do not compute again
        if lt_str_agrs is initial.
          call method cl_identity=>after_commit_customer_exit
            exporting
              it_segment_roles = lt_segment_roles
            importing
              et_str_agrs      = lt_str_agrs.
        endif.

        call function lv_exit_name
          tables
            activity_groups = lt_str_agrs.
      endif.
    endif.


* --- Now perform general cleanup activities --------------------------*
*     Required steps:
*     - Cleanup all saved instance
*     - Delete messages from message buffer for these identities
*     - Delete notifications from notification handler

    loop at gt_control reference into lr_control.
*         where idref->ms_manager-status = go_persistence->co_ta_status_saved.
*   clean up all instances: use case PFCG
*   there are instances with status CO_TA_STATUS_UNCHANGED and modus
*   CO_TA_MODUS_MODIFY which has the effect that enqueue locks are
*   not released for these instances
*   therefore call cleanup on all instances in gt_control

      if lr_control->idref->ms_segment_address-actadd-trx_with_bp   eq co_trx_user and
       ( lr_control->idref->ms_segment_address-actadd-changed_bp    eq if_identity=>co_true or
         lr_control->idref->ms_segment_address-actadd-changed_bprel eq if_identity=>co_true ).
        lv_save_bp = if_identity=>co_true.
      endif.

      try.
          call method lr_control->idref->cleanup_single( iv_ignore_bas = abap_true ).
        catch cx_suid_identity into lo_exception.
          clear: lv_msg_data, lv_msg_key_value.

          lv_msg_key_value  = lr_control->bname.
          lv_msg_data-msgty = if_suid_msg_buffer=>co_type_info.
          lv_msg_data-msgid = 'SUID01'.
          lv_msg_data-msgno = '025'.
          lv_msg_data-msgv1 = lo_exception->get_text( ).
          lv_msg_data-msgv2 = lr_control->bname.

          if 1 = 0.
*           Interner Fehler &1 bei Instanz des Benutzers &2 aufgetreten.
            message i025(suid01)
              with lv_msg_data-msgv1 lv_msg_data-msgv2.
          endif.

          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = lr_control->bname
              iv_nodename = if_identity_definition=>gc_node_root
              iv_key      = lv_msg_key_value
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
              is_msg      = lv_msg_data.

      endtry.

    endloop.

*   Check BP
    if lv_save_bp eq if_identity=>co_true.
      call method cl_bup_transaction_api=>after_commit.
    endif.

**********************************************************************
*--------------------------------------------------------------------*
* Rollback work
**********************************************************************

  elseif kind = 'R'. " Transaction finished by ROLLBACK WORK
* --- Perform general cleanup activities ------------------------------*
*     Required steps:
*     - Cleanup all finalized instances
*     - In Cleanup: Delete messages from message buffer
*     - In Cleanup: Delete notifications from notification handler

    loop at gt_control reference into lr_control.
*         where idref->ms_manager-status eq go_persistence->co_ta_status_finalized.
*   clean up all instances: use case PFCG
*   there are instances with status CO_TA_STATUS_UNCHANGED and modus
*   CO_TA_MODUS_MODIFY which has the effect that enqueue locks are
*   not released for these instances
*   therefore call cleanup on all instances in gt_control

      if lr_control->idref->ms_segment_address-actadd-trx_with_bp   eq co_trx_user and
       ( lr_control->idref->ms_segment_address-actadd-changed_bp    eq if_identity=>co_true or
         lr_control->idref->ms_segment_address-actadd-changed_bprel eq if_identity=>co_true ).
        lv_save_bp = if_identity=>co_true.
      endif.

      try .
*       Messages and Notifications are deleted within CLEANUP_SINGLE
          call method lr_control->idref->cleanup_single.
        catch cx_suid_identity into lo_exception.
          clear: lv_msg_data, lv_msg_key_value.
          lv_msg_key_value  = lr_control->bname.
          lv_msg_data-msgty = if_suid_msg_buffer=>co_type_info.
          lv_msg_data-msgid = 'SUID01'.
          lv_msg_data-msgno = '025'.
          lv_msg_data-msgv1 = lo_exception->get_text( ).
          lv_msg_data-msgv2 = lr_control->bname.

          if 1 = 0.
*           Interner Fehler &1 bei Instanz des Benutzers &2 aufgetreten.
            message i025(suid01)
              with lv_msg_data-msgv1 lv_msg_data-msgv2.
          endif.

          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = lr_control->bname
              iv_nodename = if_identity_definition=>gc_node_root
              iv_key      = lv_msg_key_value
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
              is_msg      = lv_msg_data.

      endtry.

    endloop.


* ---- BP -------------------------------------
    if lv_save_bp eq if_identity=>co_true.
      call method cl_bup_transaction_api=>cleanup.
    endif.

  endif. " Rollback


endmethod.


method cert_check_certificate.

  data: lv_foreign_lock     type        sesf_boolean
      , ls_certmap_enq      type        usrcertmap
      , ls_lock_msg         type        symsg
      , ls_certmap_db       type        usrcertmap
      , lv_rule_user        type        xubname
      , lv_hashxstring      type        xstring
      , lr_cx_digest        type ref to cx_abap_message_digest
      , lv_text             type        string
      .

  clear: es_certmap, es_msg, ev_reject_assignment.


  " --- Evaluate Certificate ---------------------------------
  "
  case iv_cert.
    when 'C'.
      " Check certificate
      call function 'CERTRULE_GET_CERTINFOS'
        exporting
          certificate       = is_certificate-certificate
        importing
          subject           = es_certmap-subject
          issuer            = es_certmap-issuer
          subject_sha1      = es_certmap-subjecth
          issuer_sha1       = es_certmap-issuerh
        exceptions
          error_parameter   = 1
          error_ssf_lib     = 2
          error_certificate = 3
          error_convert     = 4
          error_internal    = 5
          others            = 6.

      if sy-subrc ne 0.
        clear: es_msg.

        es_msg-msgid = sy-msgid.
        es_msg-msgno = sy-msgno.
        es_msg-msgv1 = sy-msgv1.
        es_msg-msgv2 = sy-msgv2.
        es_msg-msgv3 = sy-msgv3.
        es_msg-msgv4 = sy-msgv4.
        es_msg-msgty = if_suid_msg_buffer=>co_type_error.

        clear: es_certmap.
        ev_reject_assignment = if_identity=>co_true.
        return.
      endif.

    when 'M'.
      " Calculate hash values
      es_certmap-subject = is_certmap-subject.
      es_certmap-issuer  = is_certmap-issuer.

      try.
          clear: lv_hashxstring.
          call method cl_abap_message_digest=>calculate_hash_for_char
            exporting
              if_algorithm   = 'SHA1'
              if_data        = es_certmap-subject
            importing
              ef_hashxstring = lv_hashxstring.
          es_certmap-subjecth = lv_hashxstring.

          clear: lv_hashxstring.
          call method cl_abap_message_digest=>calculate_hash_for_char
            exporting
              if_algorithm   = 'SHA1'
              if_data        = es_certmap-issuer
            importing
              ef_hashxstring = lv_hashxstring.
          es_certmap-issuerh = lv_hashxstring.

        catch cx_abap_message_digest into lr_cx_digest.
          lv_text = lr_cx_digest->get_text( ).

          clear: es_msg.
          es_msg-msgty = if_suid_msg_buffer=>co_type_error.
          es_msg-msgid = 'SUID01'.
          es_msg-msgno = '301'.
          es_msg-msgv1 = lv_text.
          " Interner Fehler beim Zuordnen von Zertifikaten (Fehlercode &1)
          if 1 = 0. message e301(suid01) with es_msg-msgv1. endif.

          clear: es_certmap.
          ev_reject_assignment = if_identity=>co_true.
          return.
      endtry.

    when others.
      return.
  endcase.


  " --- CHECK: Is mapping assigned to own user ---------------
  "
  read table ms_segment_certmap-actual
       with key subjecth = es_certmap-subjecth
                issuerh  = es_certmap-issuerh
       binary search
       transporting no fields.
  if sy-subrc eq 0.
    clear: es_msg.
    es_msg-msgty = if_suid_msg_buffer=>co_type_error.
    es_msg-msgid = 'SUID01'.
    es_msg-msgno = '303'.
    es_msg-msgv1 = ms_manager-bname.
    " Das Zertifikat ist bereits dem Benutzer &1 zugeordnet
    if 1 = 0. message e303(suid01) with es_msg-msgv1. endif.

    ev_reject_assignment = if_identity=>co_true.
    return.
  endif.


  " --- CHECK: Is mapping assigned to other user -------------
  "
  select single subjecth issuerh bname
         from usrcertmap
         into corresponding fields of ls_certmap_db
        where subjecth eq es_certmap-subjecth
          and issuerh  eq es_certmap-issuerh
          and bname    ne ms_manager-bname. "instead of before_image check
  if sy-subrc eq 0.
    clear: es_msg.
    es_msg-msgty = if_suid_msg_buffer=>co_type_error.
    es_msg-msgid = 'SUID01'.
    es_msg-msgno = '303'.
    es_msg-msgv1 = ls_certmap_db-bname.
    " Das Zertifikat ist bereits dem Benutzer &1 zugeordnet
    if 1 = 0. message e303(suid01) with es_msg-msgv1. endif.

    ev_reject_assignment = if_identity=>co_true.
    return.
  endif.


  " --- CHECK: Is mapping locked in current trx --------------
  "
  read table mt_certmap_enqueued from es_certmap into ls_certmap_enq.

  if sy-subrc eq 0 and ls_certmap_enq-bname ne ms_manager-bname.
    clear: es_msg.
    es_msg-msgty = if_suid_msg_buffer=>co_type_error.
    es_msg-msgid = 'SUID01'.
    es_msg-msgno = '303'.
    es_msg-msgv1 = ls_certmap_enq-bname.
    " Das Zertifikat ist bereits dem Benutzer &1 zugeordnet
    if 1 = 0. message e303(suid01) with es_msg-msgv1. endif.

    ev_reject_assignment = if_identity=>co_true.
    return.
  endif.


  " --- CHECK: Is mapping locked in system -------------------
  "
  call method cl_suid_tools=>enqueue_certmap
    exporting
      is_certmap      = es_certmap
    importing
      es_msg          = ls_lock_msg
      ev_foreign_lock = lv_foreign_lock.

  if ls_lock_msg is not initial.
    clear: es_msg.

    if lv_foreign_lock eq if_identity=>co_true.
      es_msg-msgid = 'SUID01'.
      es_msg-msgno = '304'.
      es_msg-msgv1 = ls_lock_msg-msgv1.
      " Das Zertifikat ist durch Benutzer &1 gesperrt
      if 1 = 0. message e304(suid01) with es_msg-msgv1. endif.
    else.
      es_msg = ls_lock_msg.
    endif.
    es_msg-msgty = if_suid_msg_buffer=>co_type_error.

    ev_reject_assignment = if_identity=>co_true.
    return.
  endif.


  " --- CHECK: Is certificate mapping necessary ? ------------
  "
  case iv_cert.
    when 'C'.
      call function 'CERTRULE_RULES_TO_USER'
        exporting
          certificate        = is_certificate-certificate
        importing
          username           = lv_rule_user
        exceptions
          error_parameter    = 1
          error_ssf_lib      = 2
          error_certificate  = 3
          error_convert      = 4
          error_user_mapping = 5
          error_user         = 6
          error_no_rule      = 7
          error_internal     = 8
          others             = 9.
      if sy-subrc eq 0 and lv_rule_user eq ms_manager-bname.
        " Das Anlegen einer Ausnahme ist nicht erforderlich
        if 1 = 0. message e305(suid01). endif.

        clear: es_msg.
        es_msg-msgty = if_suid_msg_buffer=>co_type_warning.
        es_msg-msgid = 'SUID01'.
        es_msg-msgno = '305'.
      endif.

    when 'M'.

  endcase.


  " Insert into enqueued certmap table
  es_certmap-bname = ms_manager-bname.
  insert es_certmap into table mt_certmap_enqueued.
  if sy-subrc ne 0.
    macro_raise_internal_error.
  endif.


endmethod.


method checks_before_access.
**********************************************************************
* 26.02.2008 D050920  Note 1116083
* - Call NODE_AUTHORITY_CHECK and AUTH_CHECK_SINGLE with parameter
* IV_BNAME. Because username is used by some messages (01/585, 01/586..  )
*
**********************************************************************

  data:   lv_msg_data             type symsg
        , lv_msg_key_value        type string
        , lo_prop_handler         type ref to cl_suid_property_handler
        , lv_auth_node            type suid_node_name
        , lv_class                type xuclass
        .

  clear: es_msg.

  " --- Check: ms_manager must be filled -----------------------------
  "
  if ms_manager-bname is initial.
    raise exception
      type
      cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error.
  endif.

  " --- Check transaction status and modus -----------------------------
  "
  " Status must be valid
  if ms_manager-status eq go_persistence->co_ta_status_invalid.
    macro_raise_internal_error.
  endif.
  if ms_manager-status eq go_persistence->co_ta_status_saved and
     iv_method         eq 'S'.
    macro_raise_internal_error.
  endif.


  " --- Upgrade handling  -----------------------------------------------*
  "
  " --- No application calls during upgrade
  if gv_upg_is_shadow_system eq if_identity=>co_true.
    if iv_change_node eq if_identity_definition=>gc_node_person_name  or
       iv_change_node eq if_identity_definition=>gc_node_organization or
       iv_change_node eq if_identity_definition=>gc_node_person       or
       iv_change_node eq if_identity_definition=>gc_node_workplace    or
       iv_change_node eq if_identity_definition=>gc_node_uclass       or
       iv_change_node eq if_identity_definition=>gc_node_group.

      "* Während des Upgrade Prozesses können Daten nicht geändert werden.
      " IF 1 = 0. MESSAGE e028(suid01). ENDIF.
      " CLEAR: lv_msg_data, lv_msg_key_value.
      " lv_msg_data-msgid = 'SUID01'.
      " lv_msg_data-msgno = '028'.

      " --- provide error message without filling the message buffer and return to caller
      lv_msg_data-msgty = 'E'.
      es_msg            = lv_msg_data.
      return.

    endif.
  endif.

  " --- Check Early Watch Client and Upgrade Process ------------------------*
  "
  " --- No calls to address methods
  if gv_earlywatchclient eq if_identity=>co_true.
    if iv_change_node eq if_identity_definition=>gc_node_person_name    or
       iv_change_node eq if_identity_definition=>gc_node_organization   or
       iv_change_node eq if_identity_definition=>gc_node_person         or
       iv_change_node eq if_identity_definition=>gc_node_workplace.

      "* Im Mandanten &1 können bestimmte Daten nicht geändert werden.
      " IF 1 = 0. MESSAGE e026(suid01) WITH gv_earlywatchclient. ENDIF.
      " CLEAR: lv_msg_data, lv_msg_key_value.
      " lv_msg_data-msgid = 'SUID01'.
      " lv_msg_data-msgno = '026'.
      " lv_msg_data-msgv1 = gv_earlywatchclient.

      " --- provide error message without filling the message buffer and return to caller
      lv_msg_data-msgty = 'E'.
      es_msg            = lv_msg_data.
      return.
    endif.
  endif.

  " --- Check if own user is changed -----------------------------------
  "
  if ms_manager-flg_own_data eq go_persistence->co_flag_active.
    " In case of "Change own user" only Address, Parameter and Defaults
    " can be read or written
    if iv_change_node eq if_identity_definition=>gc_node_person_name    or
       iv_change_node eq if_identity_definition=>gc_node_workplace      or
       iv_change_node eq if_identity_definition=>gc_node_organization   or
       iv_change_node eq if_identity_definition=>gc_node_tech_user_data or
       iv_change_node eq if_identity_definition=>gc_node_defaults       or
       iv_change_node eq if_identity_definition=>gc_node_parameter      or
       iv_change_node eq if_identity_definition=>gc_node_admindata      or
       iv_change_node eq if_identity_definition=>gc_node_root           or
       iv_change_node eq if_identity_definition=>gc_node_certmap.
      " make sure that authority check is not executed for own data => return to caller
      return.
    elseif ( iv_change_node eq if_identity_definition=>gc_node_person or
             iv_change_node eq if_identity_definition=>gc_node_tech_user ) and
           iv_method      eq 'G'.
      " Person assignment and tech user indicator cannot be changed
      return.
    else.
      macro_raise_internal_error.
    endif.
  endif.


  " -----------------------------------------------------------------
  " --- SET Method ---
  "
  if iv_method eq 'S'.

    " Set: Call only allowed in Create or Modify mode
    if ms_manager-modus ne go_persistence->co_ta_modus_create and
       ms_manager-modus ne go_persistence->co_ta_modus_modify.
      macro_raise_internal_error.
    endif.

    " During SAVE: BADI_IDENTITY_UPDATE MUST not call any SET methode
    if gv_active_badi_identity_update eq if_identity=>co_true.
      macro_raise_internal_error.
    endif.

    " --- Check if authority is sufficient
    " get logon->group information in order to call authority check
    call method me->get_class
      exporting
        iv_for_auth = if_identity=>co_true
      importing
        ev_class    = lv_class.

    " check authority only in modification mode
    if ms_manager-modus = cl_identity_persistence=>co_ta_modus_modify.
      call method cl_identity=>node_authority_check
        exporting
          iv_node_name        = iv_change_node
          iv_transaction_mode = ms_manager-modus
          iv_class            = lv_class
          iv_bname            = ms_manager-bname
        importing
          es_msg              = lv_msg_data
          ev_auth_node        = lv_auth_node.

      " handle invalid authorization: data cannot be changed
      if lv_msg_data-msgty = 'E'.
        clear: lv_msg_key_value.
        lv_msg_key_value  = ms_manager-bname.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = lv_auth_node
            iv_key      = lv_msg_key_value
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = lv_msg_data.

      endif.
    endif.

    if lv_msg_data-msgty <> 'E'.
      " --- Check if optimistic lock has to be promoted
      case me->ms_manager-enqmode.
        when if_identity=>co_enqueue_mode_exclusive or cl_suid_tools=>co_enqueue_mode_opt_to_excl.
          " nothing left to do: already in exclusive mode
        when if_identity=>co_enqueue_mode_optimistic.
          call method me->if_identity~set_optimistic_to_excl_lock.
        when others.
          macro_raise_internal_error.
      endcase.
    endif.


    " -----------------------------------------------------------------
    " --- GET Method ---
    "
  elseif iv_method eq 'G'.
    " Get: Call only allowed if NOT in Delete mode
    if ms_manager-modus eq cl_identity_persistence=>co_ta_modus_delete
      and iv_request_before_image = if_identity=>co_false.
      macro_raise_internal_error.
    endif.

    " --- Check if authority is sufficient
    " get logon->group information in order to call authority check
    call method me->get_class
      exporting
        iv_for_auth = if_identity=>co_true
      importing
        ev_class    = lv_class.

    " check authority only in modification mode
    if ms_manager-modus = cl_identity_persistence=>co_ta_modus_modify.
      " Check user group
      call method cl_identity=>node_authority_check
        exporting
          iv_node_name        = iv_change_node
          iv_transaction_mode = ms_manager-modus
          iv_class            = lv_class
          iv_bname            = ms_manager-bname
        importing
          es_msg              = lv_msg_data
          ev_auth_node        = lv_auth_node.

      " handle invalid authorization: data cannot be changed
      if lv_msg_data-msgty = 'E'.
        clear: lv_msg_key_value.
        lv_msg_key_value  = ms_manager-bname.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = lv_auth_node
            iv_key       = lv_msg_key_value
            iv_lifetime  = if_suid_msg_buffer=>co_lifetime_once
            is_msg       = lv_msg_data
            iv_overwrite = 'X'.

        " Check if authority is sufficient to display data: check root_node
        clear: lv_msg_data.
        if iv_change_node eq if_identity_definition=>gc_node_cua_system.
          " Extended fallback for systems
          call method cl_identity=>node_authority_check
            exporting
              iv_node_name        = iv_change_node
              iv_transaction_mode = cl_identity_persistence=>co_ta_modus_display
              iv_class            = lv_class
              iv_bname            = ms_manager-bname
            importing
              es_msg              = lv_msg_data
              ev_auth_node        = lv_auth_node.
        endif.

        if iv_change_node ne if_identity_definition=>gc_node_cua_system or
           lv_msg_data    is not initial.
          call method cl_identity=>node_authority_check
            exporting
              iv_node_name        = if_identity_definition=>gc_node_root
              iv_transaction_mode = cl_identity_persistence=>co_ta_modus_display
              iv_class            = lv_class
              iv_bname            = ms_manager-bname
            importing
              es_msg              = lv_msg_data
              ev_auth_node        = lv_auth_node.
        endif.

        if lv_msg_data-msgty = 'E'.
          clear: lv_msg_key_value.
          lv_msg_key_value  = ms_manager-bname.

          call method me->go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname     = ms_manager-bname
              iv_nodename  = lv_auth_node "iv_change_node
              iv_key       = lv_msg_key_value
              iv_lifetime  = if_suid_msg_buffer=>co_lifetime_once
              is_msg       = lv_msg_data
              iv_overwrite = 'X'.

          " handle insufficient authority to RETRIEVE data
          lo_prop_handler = cl_suid_property_handler=>get_instance( ).

          lo_prop_handler->set_node_enabled(
                              iv_value     = space      "set disabled
                              io_identity  = me
                              iv_node_name = iv_change_node ).

          if iv_change_node eq if_identity_definition=>gc_node_organization or
             iv_change_node eq if_identity_definition=>gc_node_person       or
             iv_change_node eq if_identity_definition=>gc_node_person_name  or
             iv_change_node eq if_identity_definition=>gc_node_workplace.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_organization.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_person.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_person_name.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_workplace.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_telephone.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_facsimile.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_email.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_web.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_telex.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_teletex.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_remote_mail.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_x400.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_printer.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_ssf.
            call method lo_prop_handler->set_node_enabled
              exporting
                iv_value     = space
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_pager.
          endif.

        else.
          " handle insufficient authority to CHANGE data
          lo_prop_handler = cl_suid_property_handler=>get_instance( ).

          lo_prop_handler->set_node_read_only(
                              io_identity  = me
                              iv_node_name = iv_change_node ).

          if iv_change_node eq if_identity_definition=>gc_node_workplace.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_telephone.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_facsimile.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_email.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_web.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_telex.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_teletex.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_remote_mail.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_x400.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_printer.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_ssf.
            call method lo_prop_handler->set_node_read_only
              exporting
                io_identity  = me
                iv_node_name = if_identity_definition=>gc_node_pager.
          endif.
        endif.

      endif.

    elseif iv_change_node = if_identity_definition=>gc_node_pwdhash.

      call method cl_identity=>node_authority_check
        exporting
          iv_node_name        = if_identity_definition=>gc_node_pwdhash
          iv_transaction_mode = cl_identity_persistence=>co_ta_modus_modify
          iv_class            = lv_class
          iv_bname            = ms_manager-bname
        importing
          es_msg              = lv_msg_data.

    endif.

  endif.

  " return last sy_msg if set
  es_msg = lv_msg_data.

endmethod.


method check_alias.
* For given Identity ID: Read and return alias
* For given Alias:       Read and return Identity
* If Identity ID AND Alias are imported, check: Do they match?

* Messages occurring in this method:
*  E 01 183   No user found for alias &
*  E 01 184   Alias &1 does not match user &2

  data: ls_bname   type        suid_st_bname
       ,lt_bname   type        suid_tt_bname
       ,lr_refuser type ref to usrefus
       ,lt_refuser type        suid_tt_usrefus
       ,lv_flg_mismatch type   sesf_boolean value if_identity=>co_false
       ,ls_msg     type        symsg
       .

  eo_msg_buffer = go_msg_buffer.

  if iv_bname is not initial.
    ls_bname-bname = iv_bname.
    append ls_bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_refuser = lt_refuser.
    read table lt_refuser with key bname = iv_bname
         reference into lr_refuser
         binary search.
    if sy-subrc = 0.
      ev_alias = lr_refuser->useralias.
      if iv_alias is not initial.
*       imported alias doesn't match persisted alias for this Identity
        if iv_alias <> ev_alias.
          clear ls_msg.
          ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
          ls_msg-msgno = '184'.
          ls_msg-msgid = '01'.
          ls_msg-msgv1 = iv_alias.
          ls_msg-msgv2 = iv_bname.
*         E 01 184   Alias &1 does not match user &2
          if 1 = 0. message e184(01) with iv_alias iv_bname. endif.
          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname     = iv_bname
              iv_lifetime  = if_suid_msg_buffer=>co_lifetime_once
              iv_nodename = if_identity_definition=>gc_node_logondata
              iv_field    = if_identity_definition=>gc_field_logondata_useralias
              is_msg       = ls_msg.
          lv_flg_mismatch  = if_identity=>co_true.
        else. " Imported BNAME and ALIAS belong together
          ev_bname = iv_bname.
          return.
        endif.
      endif.
    endif.
  endif.

  if iv_alias is not initial.
    select single bname from  usrefus
              into  ev_bname
              where useralias = iv_alias.                   "#EC *
    if sy-subrc <> 0.
      clear ls_msg.
      ls_msg-msgty = eo_msg_buffer->co_type_error.
      ls_msg-msgno = '183'.
      ls_msg-msgid = '01'.
      ls_msg-msgv1 = iv_alias.
*     E 01 183   No user found for alias &
      if 1 = 0. message e183(01) with iv_alias. endif.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ev_bname
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          iv_nodename = if_identity_definition=>gc_node_logondata
          iv_field    = if_identity_definition=>gc_field_logondata_useralias
          is_msg      = ls_msg.
    else.
      if iv_bname is not initial.
        if ev_bname <> iv_bname.
*         Message not yet in message buffer:
          if lv_flg_mismatch <> if_identity=>co_true.
*         imported alias doesn't match persisted alias for this Identity
            if iv_alias <> ev_alias.
              clear ls_msg.
              ls_msg-msgty = eo_msg_buffer->co_type_error.
              ls_msg-msgno = '184'.
              ls_msg-msgid = '01'.
              ls_msg-msgv1 = iv_alias.
              ls_msg-msgv2 = iv_bname.
*             E 01 184   Alias &1 does not match user &2
              if 1 = 0. message e184(01) with iv_alias iv_bname. endif.
              call method go_msg_buffer->add_object_message_symsg
                exporting
                  iv_bname    = iv_bname
                  iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
                  iv_nodename = if_identity_definition=>gc_node_logondata
                  iv_field    = if_identity_definition=>gc_field_logondata_useralias
                  is_msg      = ls_msg.
            endif.
          endif.
        endif.
      endif.
    endif.
  endif.

endmethod.


method check_before_save.
* Check before Save is required by ESA for the Service Provider


  data: lr_control           type ref to ty_control
      , lv_check_bp          type        sesf_boolean
      , lv_bp_rejected       type        boole_d
      , lt_bup_msg           type        cmd_t_msg_complete
      , lr_bup_msg           type ref to cmd_s_msg_complete
      , ls_msg               type        symsg
      , lv_lifetime          type        if_suid_msg_buffer=>ty_msg_lifetime
.


* --- Check_before_Save of BP and BP-Rel ----------------------------
*
  loop at gt_control reference into lr_control
       where idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    if lr_control->idref->ms_segment_address-actadd-trx_with_bp   eq co_trx_user and
     ( lr_control->idref->ms_segment_address-actadd-changed_bp    eq if_identity=>co_true or
       lr_control->idref->ms_segment_address-actadd-changed_bprel eq if_identity=>co_true ).
      lv_check_bp = if_identity=>co_true.
    endif.
  endloop.

*   BP-Check_before_Save
  if lv_check_bp eq if_identity=>co_true.

    call method cl_bup_transaction_api=>check_before_save
      importing
        ev_rejected = lv_bp_rejected
        et_message  = lt_bup_msg.

    if lv_bp_rejected eq 'X'.
      ev_rejected = if_identity=>co_true.

      loop at lt_bup_msg reference into lr_bup_msg.
        clear: ls_msg.

        ls_msg-msgty = lr_bup_msg->msgty.
        ls_msg-msgid = lr_bup_msg->msgid.
        ls_msg-msgno = lr_bup_msg->msgno.
        ls_msg-msgv1 = lr_bup_msg->msgv1.
        ls_msg-msgv2 = lr_bup_msg->msgv2.
        ls_msg-msgv3 = lr_bup_msg->msgv3.
        ls_msg-msgv4 = lr_bup_msg->msgv4.

        if lr_bup_msg->lifetime eq 0.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
        else.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ''
            is_msg      = ls_msg
            iv_nodename = if_identity_definition=>gc_node_root
            iv_lifetime = lv_lifetime.
      endloop.

      return.
    endif.

  endif.

endmethod.


METHOD check_cua_landscape.


* Returns error message in eo_msg_buffer:
*     - if system is not part of CUA landscape
*     - if current system is not central system

  DATA:   lv_logsys              TYPE          t000-logsys
        , ls_msg                 TYPE          symsg
        , lv_no_maintain_node    TYPE          sesf_boolean.

* initialize return value
  ev_valid = if_identity=>co_true.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.

* --- Check CUA landscape ----------------------------------
*
* Get logical name of actual system and active child systems
  CALL METHOD cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    IMPORTING
      ev_system_logsys = lv_logsys.

* CUA is not active - system node shouldn't be filled --> error message and exit
  IF gv_cua_active = if_identity=>co_false.
    ls_msg-msgv1 = lv_logsys.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
*     MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    IF 1 = 0. MESSAGE e381(01) WITH ls_msg-msgv1. ENDIF.
    CALL METHOD go_msg_buffer->add_object_message_symsg
      EXPORTING
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

*   set return value and return
    ev_valid = if_identity=>co_false.
    return.
  ENDIF.

* Actual system is not central system - system node shouldn't be filled --> error message and exit
  IF gv_cua_central = if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
*   MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    IF 1 = 0. MESSAGE e351(01). ENDIF.
    CALL METHOD go_msg_buffer->add_object_message_symsg
      EXPORTING
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.

*   set return value and return
    ev_valid = if_identity=>co_false.
    RETURN.
  ENDIF.

* check if node can be maintained
  IF iv_node_name IS NOT INITIAL.

    cua_if_field_no_maintain(
      EXPORTING
        iv_node_name   = iv_node_name
        io_msg_buffer  = go_msg_buffer
      RECEIVING
        rv_no_maintain = lv_no_maintain_node ).

    IF lv_no_maintain_node = if_identity=>co_false.
      ev_valid = if_identity=>co_true.
    ELSE.
      ev_valid = if_identity=>co_false.
*     message is already added by cua_if_field_no_maintain
    ENDIF.

  ENDIF.


ENDMETHOD.


method check_cua_profiles.

  data: lt_profiles         type suid_tt_node_cua_profiles
      , ls_usergroup        type cl_suid_tools=>ty_groups
      .

  " Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

  " Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  " Check class: If class does not exist -> Dummy check
  ls_usergroup-usergroup = iv_class.
  call method cl_suid_tools=>check_exist_groups
    changing
      cs_usergroup = ls_usergroup.
  if ls_usergroup-notexist eq if_identity=>co_true.
    clear: ls_usergroup-usergroup.
  endif.

  lt_profiles = it_profiles.

  call method cl_identity=>check_cua_profiles_internal
    exporting
      iv_bname      = space
      iv_class      = ls_usergroup-usergroup
      io_msg_buffer = go_anonymous_msg_buffer
    changing
      ct_profiles   = lt_profiles.

  " fill exporting table with texts
  call method cl_suid_role_helper=>get_cua_profile_texts
    changing
      ct_cua_profile = lt_profiles.

  clear et_profiles.
  et_profiles = lt_profiles.

endmethod.


method check_cua_profiles_internal.
**********************************************************************
* check_cua_profiles_internal implements following functionality: ..................
*   - delete entries with empty profile names
*   - delete entries with empty system names
*   - existence check of profiles
*   - eliminate duplicate entries
*   - complete messages for roles and profiles
**********************************************************************

  constants:
        co_no_activity          type         int1 value 255.

  data: lv_msg_key_value        type         string
      , lv_msg_data             type         symsg
      , lr_node_profile         type ref to  suid_st_node_cua_profile
      , lv_tabix                type         sy-tabix
      , lt_existing_profiles    type         suid_tt_node_cua_profiles
      , lr_existing_profile     type ref to  suid_st_node_cua_profile
      , lv_name                 type         string
      , lv_operation            type         suid_node_activity
      , lt_hashed_profiles      type hashed table of suid_st_node_cua_profile
                                with unique key subsystem profile change_mode
      , lv_central_system       type         rfcsendsys
      , ls_cua_child_systems    type         uszbvlndrc
      , lt_cua_child_systems    type         suid_tt_uszbvlndrc
      .


  " Get CUA systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys    = lv_central_system
      et_cua_child_systems = lt_cua_child_systems.
  if lv_central_system is not initial.
    ls_cua_child_systems-rcvsystem = lv_central_system.
    append ls_cua_child_systems to lt_cua_child_systems.
  endif.
  sort lt_cua_child_systems by rcvsystem.

  sort ct_profiles by subsystem profile change_mode.

  " --- check change mode and initial profiles/systems
  loop at ct_profiles reference into lr_node_profile.

    " remember index
    lv_tabix = sy-tabix.

    " check value of change_mode: only insert, delete and space are allowed
    case lr_node_profile->change_mode.
      when if_identity=>co_insert.
      when if_identity=>co_delete.
      when if_identity=>co_unchanged.
      when others.
        " Wrong change mode
        if 1 = 0. message e047(s#) . endif.                 "#EC *
        clear: lv_msg_data.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_info.
        lv_msg_data-msgid = 'S#'.
        lv_msg_data-msgno = '047'.

        concatenate lr_node_profile->subsystem lr_node_profile->profile
               into lv_msg_key_value respecting blanks.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_profile_profile
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        " Ignore wrong mode
        delete ct_profiles index lv_tabix.
        continue.
    endcase.

    " -- ignore entries with empty profile_name
    if lr_node_profile->profile is initial.
      if 1 = 0. message w865(01) with lr_node_profile->subsystem lr_node_profile->profile. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '865'.
      lv_msg_data-msgv1 = lr_node_profile->subsystem.
      lv_msg_data-msgv2 = lr_node_profile->profile.

      concatenate lr_node_profile->subsystem lr_node_profile->profile
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_profile_profile
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if io_notify is supplied and lr_node_profile->change_mode eq if_identity=>co_insert.
        call method io_notify->notify_failed_create
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_profile->key_handle.
      endif.

      " Ignore empty profile
      delete ct_profiles index lv_tabix.
      continue. "go ahead with next role
    endif.

    " -- ignore entries with empty system_name
    if lr_node_profile->subsystem is initial.
      " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
      if 1 = 0. message w381(01) with lr_node_profile->subsystem. endif. "#EC *

      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '381'.
      lv_msg_data-msgv1 = lr_node_profile->subsystem.

      concatenate lr_node_profile->subsystem lr_node_profile->profile
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_profile_subsystem
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if io_notify is supplied and lr_node_profile->change_mode eq if_identity=>co_insert.
        call method io_notify->notify_failed_create
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_profile->key_handle.
      endif.

      " Ignore empty system
      delete ct_profiles index lv_tabix.
      continue. "go ahead with next role
    endif.

    " Convert to upper case
    clear lv_name.
    lv_name                  = lr_node_profile->profile.
    lr_node_profile->profile = cl_suid_tools=>to_upper_case( lv_name ).
  endloop.


  " --- existence check and authorizations check of profiles
  call method cl_suid_role_helper=>check_existence_cua_profile
    exporting
      it_profile_name       = ct_profiles
    importing
      et_profile_name_exist = lt_existing_profiles.


  loop at ct_profiles reference into lr_node_profile.
    " remember index
    lv_tabix = sy-tabix.

    " -- Existence check: Subsystem
    clear lv_name.
    lv_name                    = lr_node_profile->subsystem.
    lr_node_profile->subsystem = cl_suid_tools=>to_upper_case( lv_name ).

    " Target system must be part of CUA definition
    read table lt_cua_child_systems
         with key rcvsystem = lr_node_profile->subsystem
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
      if 1 = 0. message w381(01) with lr_node_profile->subsystem. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '381'.
      lv_msg_data-msgv1 = lr_node_profile->subsystem.

      concatenate lr_node_profile->subsystem lr_node_profile->profile
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_profile_subsystem
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_profile->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_profile
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_profile->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_profile->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_profile->change_mode.
      endif.
      continue.
    endif.

    " -- Existence check: Profile
    read table lt_existing_profiles
         reference into lr_existing_profile
         with key subsystem = lr_node_profile->subsystem
                  profile   = lr_node_profile->profile
         binary search.

    if sy-subrc ne 0.
      " -- Profile does not exist
      check lr_node_profile->change_mode ne if_identity=>co_delete.

      " MSG: Profil &2 existiert nicht im System &1.
      if 1 = 0. message w865(01) with lr_node_profile->subsystem lr_node_profile->profile. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '865'.
      lv_msg_data-msgv1 = lr_node_profile->subsystem.
      lv_msg_data-msgv2 = lr_node_profile->profile.

      concatenate lr_node_profile->subsystem lr_node_profile->profile
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_profile_profile
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_profile->change_mode = if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_profile
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_profile->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_profile->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_profile->change_mode.
      endif.
      continue.

    else.
      " write type of profile into ct_profile
      lr_node_profile->type = lr_existing_profile->type.

      " -- Profile exists
      if lr_node_profile->type eq if_identity~co_prof_type_generated or
       ( lr_node_profile->type is initial and lr_node_profile->change_mode ne if_identity=>co_delete ).

        " provide error message
        " MSG: Profil &2 in System &1 ist generiert. Zuordnung ist nicht möglich.
        if 1 = 0. message w866(01) with lr_node_profile->subsystem lr_node_profile->profile. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.

        concatenate lr_node_profile->subsystem lr_node_profile->profile
          into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '01'.
        lv_msg_data-msgno = '866'.
        lv_msg_data-msgv1 = lr_node_profile->subsystem.
        lv_msg_data-msgv2 = lr_node_profile->profile.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_profile_profile
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        if lr_node_profile->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_profile->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_profile->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_profile->change_mode.
        endif.
        continue. "go ahead with next profile
      endif.

      " --  authority check
      if iv_permit eq if_identity=>co_false.
        case lr_node_profile->change_mode.
          when if_identity=>co_insert.
            lv_operation = cl_suid_tools=>co_activity_create.
          when if_identity=>co_update.
            lv_operation = cl_suid_tools=>co_activity_update.
          when if_identity=>co_delete.
            lv_operation = cl_suid_tools=>co_activity_delete.
          when others. " handles empty entry like no authority check
            lv_operation = co_no_activity.
        endcase.

        if lv_operation ne co_no_activity.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename  = if_identity_definition=>gc_node_cua_profile
              iv_operation = lv_operation
              iv_bname     = iv_bname
              iv_class     = iv_class
              iv_subsystem = lr_node_profile->subsystem
              iv_profile   = lr_node_profile->profile
            importing
              es_msg       = lv_msg_data.

          if lv_msg_data-msgty eq 'E'.
            " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &3 zum Profil &2 für System &1
            if 1 = 0. message e636(01) with lv_msg_data-msgv1 lv_msg_data-msgv2 lv_msg_data-msgv3. endif. "#EC *
            clear: lv_msg_key_value.

            concatenate lr_node_profile->subsystem lr_node_profile->profile
              into lv_msg_key_value respecting blanks.

            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_profile->key_handle
                iv_field      = if_identity_definition=>gc_field_cua_profile_profile
                is_msg        = lv_msg_data
                iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

            " send insert failed notification
            if lr_node_profile->change_mode eq if_identity=>co_insert.
              if io_notify is supplied.
                call method io_notify->notify_failed_create
                  exporting
                    iv_bname      = iv_bname
                    iv_nodename   = if_identity_definition=>gc_node_cua_profile
                    iv_key        = lv_msg_key_value
                    iv_key_handle = lr_node_profile->key_handle.
              endif.
              " Keep line: Insert failed
              lr_node_profile->change_mode = if_identity=>co_failed_create.
            else.
              " Keep line: Change failed
              clear: lr_node_profile->change_mode.
            endif.
            continue.
          endif.
        endif.
      endif.

      " --  Duplicate entries: insert into hashed table
      insert lr_node_profile->* into table lt_hashed_profiles.
      if sy-subrc ne 0.
        " MSG: Das Profil &1 für das Zielssystem &2 ist bereits zugeordnet
        if 1 = 0. message e063(suid01) with lr_node_profile->profile lr_node_profile->subsystem. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = 'SUID01'.
        lv_msg_data-msgno = '063'.
        lv_msg_data-msgv1 = lr_node_profile->profile.
        lv_msg_data-msgv2 = lr_node_profile->subsystem.

        concatenate lr_node_profile->subsystem lr_node_profile->profile
          into lv_msg_key_value respecting blanks.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_profile_profile
            is_msg        = lv_msg_data
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

        " send insert failed notification
        if lr_node_profile->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_profile->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_profile->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_profile->change_mode.
        endif.
        continue.
      endif.
    endif.
  endloop.

  sort ct_profiles by subsystem profile.

  clear lt_hashed_profiles.

endmethod.


method check_cua_roles.

  data: lt_roles                type        suid_tt_node_cua_roles
      , lr_cua_role             type ref to suid_st_node_cua_role
      , ls_role_detail          type        suid_st_node_cua_role_detail
      , lt_collective_roles     type        suid_tt_node_cua_roles
      , lv_tabix                type        sy-tabix
      , lr_role_member          type ref to suid_st_node_cua_role_member
      , ls_role                 type        suid_st_node_cua_role
      , lr_role                 type ref to suid_st_node_cua_role
      , lr_child_role           type ref to suid_st_node_cua_role
      , ls_usergroup            type        cl_suid_tools=>ty_groups
      .

  clear: et_roles, et_role_details, et_role_members.

  " Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

  " Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  " Check class: If class does not exist -> Dummy check
  ls_usergroup-usergroup = iv_class.
  call method cl_suid_tools=>check_exist_groups
    changing
      cs_usergroup = ls_usergroup.
  if ls_usergroup-notexist eq if_identity=>co_true.
    clear: ls_usergroup-usergroup.
  endif.

  lt_roles = it_roles.

  " separate and delete roles which are assigned as part of a collective role
  loop at lt_roles reference into lr_cua_role.
    lv_tabix = sy-tabix.
    if lr_cua_role->agr_assign_type = if_identity=>co_agr_assign_type_coll.
      insert lr_cua_role->* into table lt_collective_roles.
      delete lt_roles index lv_tabix.
    endif.
  endloop.

  call method cl_identity=>check_cua_roles_internal
    exporting
      iv_bname      = space
      iv_class      = ls_usergroup-usergroup
      io_msg_buffer = go_anonymous_msg_buffer
    changing
      ct_roles      = lt_roles.

  if iv_get_role_members eq if_identity~co_true.
    clear: et_role_members.
    " --- provide additional info of parent role in node of role
    call method roles_cua_add_parent_info
      exporting
        it_roles      = lt_roles
      importing
        et_node_roles = et_role_members.
  endif.

  " add members to result list
  loop at et_role_members reference into lr_role_member.
    clear ls_role.
    ls_role-subsystem       = lr_role_member->child_subsystem.
    ls_role-agr_name        = lr_role_member->child_role.
    " get parent entry
    read table lt_roles with key
        subsystem = lr_role_member->parent_subsystem
        agr_name  = lr_role_member->parent_role
        reference into lr_role.
    if sy-subrc = 0.
      " check separated lt_collective_roles
      read table lt_collective_roles with key
          subsystem = lr_role_member->child_subsystem
          agr_name  = lr_role_member->child_role
          from_dat  = lr_role->from_dat
          to_dat    = lr_role->to_dat
          reference into lr_child_role.
      if sy-subrc = 0.
        insert lr_child_role->* into table lt_roles.
      else.
        ls_role-from_dat        = lr_role->from_dat.
        ls_role-to_dat          = lr_role->to_dat.
        ls_role-agr_assign_type = if_identity=>co_agr_assign_type_coll.
        insert ls_role into table lt_roles.
      endif.

    endif.

  endloop.

  " check for additional role information: text and parent_child
  if iv_get_role_details eq if_identity~co_true.

    clear: et_role_details.
    loop at lt_roles reference into lr_cua_role.
      clear: ls_role_detail.

      ls_role_detail-subsystem = lr_cua_role->subsystem.
      ls_role_detail-agr_name  = lr_cua_role->agr_name.
      insert ls_role_detail into table et_role_details.

    endloop.


    " --- Read text of roles
    call method roles_cua_add_text
      changing
        ct_node_cua_role_detail = et_role_details.
  endif.

  sort lt_roles by subsystem agr_name from_dat to_dat.
  delete adjacent duplicates from lt_roles.

  et_roles = lt_roles.

endmethod.


method check_cua_roles_internal.
**********************************************************************
* check_cua_roles_internal implements following functionality:
*   - delete entries with empty role names
*   - delete entries with empty system names
*   - verification of from_dat and to_dat
*   - check if interval [from_dat, to_dat] is valid
*   - invalid values of change_mode are ignored.
*   - existence check of roles
*   - eliminate duplicate entries
*   - complete messages for roles and profiles

  constants:
        co_no_activity          type int1 value 255.

  data: lv_msg_key_value        type                 string
      , lv_msg_data             type                 symsg
      , lv_rc                   type                 int1
      , lr_node_role            type ref to          suid_st_node_cua_role
      , ls_node_role            type                 suid_st_node_cua_role
      , lv_tabix                like                 sy-tabix
      , lt_existing_roles       type                 suid_tt_node_cua_roles
      , lv_name                 type                 string
      , lv_operation            type                 suid_node_activity
      , lv_central_system       type                 rfcsendsys
      , ls_cua_child_systems    type                 uszbvlndrc
      , lt_cua_child_systems    type                 suid_tt_uszbvlndrc
      , lt_hashed_roles         type hashed table of suid_st_node_cua_role
                                with unique key      subsystem agr_name from_dat
                                                     to_dat agr_assign_type change_mode
      .


  " Get CUA systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys    = lv_central_system
      et_cua_child_systems = lt_cua_child_systems.
  if lv_central_system is not initial.
    ls_cua_child_systems-rcvsystem = lv_central_system.
    append ls_cua_child_systems to lt_cua_child_systems.
  endif.
  sort lt_cua_child_systems by rcvsystem.

  " --- check change mode and initial profiles/systems
  loop at ct_roles reference into lr_node_role.

    " remember index
    lv_tabix = sy-tabix.

    " check value of change_mode: only insert, delete and space are allowed
    case lr_node_role->change_mode.
      when if_identity=>co_insert.
      when if_identity=>co_delete.
      when if_identity=>co_update.
      when if_identity=>co_unchanged.
      when others.
        " Wrong change mode
        if 1 = 0. message e047(s#) . endif.                 "#EC *
        clear: lv_msg_data.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_info.
        lv_msg_data-msgid = 'S#'.
        lv_msg_data-msgno = '047'.

        concatenate lr_node_role->subsystem lr_node_role->agr_name
                    lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        " Ignore wrong mode
        delete ct_roles index lv_tabix.
        continue.
    endcase.

    " -- ignore entries with empty role_names
    if lr_node_role->agr_name is initial.
      if 1 = 0. message w216(s#) with lr_node_role->agr_name. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = 'S#'.
      lv_msg_data-msgno = '216'.
      lv_msg_data-msgv1 = lr_node_role->agr_name.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if io_notify is supplied and lr_node_role->change_mode eq if_identity=>co_insert.
        call method io_notify->notify_failed_create
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle.
      endif.

      " Ignore empty role
      delete ct_roles index lv_tabix.
      continue. "go ahead with next role
    endif.

    " -- ignore entries with empty system_name
    if lr_node_role->subsystem is initial.
      " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
      if 1 = 0. message e381(01) with lr_node_role->agr_name. endif. "#EC *

      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '381'.
      lv_msg_data-msgv1 = lr_node_role->subsystem.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_subsystem
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if io_notify is supplied and lr_node_role->change_mode eq if_identity=>co_insert.
        call method io_notify->notify_failed_create
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle.
      endif.

      " Ignore empty system
      delete ct_roles index lv_tabix.
      continue. "go ahead with next role
    endif.

    " -- Child roles are not supposed to be changed - ignore change_mode
    if lr_node_role->agr_assign_type eq 'C'.
      clear: lr_node_role->change_mode.
    endif.

    " Convert to upper case
    clear lv_name.
    lv_name                = lr_node_role->agr_name.
    lr_node_role->agr_name = cl_suid_tools=>to_upper_case( lv_name ).
  endloop.

  " Define sort order: Unchanged, Delete, Update, insert
  loop at ct_roles reference into lr_node_role.
    replace if_identity=>co_insert in lr_node_role->change_mode with 'Z'.
  endloop.
  sort ct_roles by change_mode subsystem agr_name from_dat to_dat agr_assign_type.
  loop at ct_roles reference into lr_node_role.
    replace 'Z' in lr_node_role->change_mode with if_identity=>co_insert.
  endloop.


  " --- existence check and authorizations check of profiles
  call method cl_suid_role_helper=>check_existence_cua_role_node
    exporting
      it_role_name       = ct_roles
    importing
      et_role_name_exist = lt_existing_roles.

  loop at ct_roles reference into lr_node_role.
    " remember index
    lv_tabix = sy-tabix.

    " -- Existence check: Subsystem
    clear lv_name.
    lv_name                 = lr_node_role->subsystem.
    lr_node_role->subsystem = cl_suid_tools=>to_upper_case( lv_name ).

    " Target system must be part of CUA definition
    read table lt_cua_child_systems
         with key rcvsystem = lr_node_role->subsystem
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " MSG:  Das System &1 ist nicht Teil der Zentralen Benutzerpflege
      if 1 = 0. message e381(01) with lr_node_role->subsystem. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '381'.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgv1 = lr_node_role->subsystem.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_subsystem
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_role->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_role->change_mode.
      endif.
      continue. "go ahead with next role
    endif.

    " set from_dat
    if lr_node_role->from_dat is initial.
      lr_node_role->from_dat = sy-datum.

    elseif lr_node_role->from_dat < cl_suid_tools=>co_lowest_date.
      lr_node_role->from_dat = cl_suid_tools=>co_lowest_date.

    else.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = lr_node_role->from_dat
        importing
          e_boolean = lv_rc.
      if lv_rc ne 0.
        if 1 = 0. message e302(00) with lr_node_role->from_dat. endif. "#EC *
        "send message for invalid from_dat
        clear: lv_msg_data, lv_msg_key_value.

        concatenate lr_node_role->subsystem lr_node_role->agr_name
                    lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '00'.
        lv_msg_data-msgno = '302'.
        lv_msg_data-msgv1 = lr_node_role->from_dat.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_field      = if_identity_definition=>gc_field_cua_role_from_dat
            is_msg        = lv_msg_data.

        " send insert failed notification
        if lr_node_role->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_role->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_role->change_mode.
        endif.
        continue.
      endif.
    endif.

    " set to_dat
    if lr_node_role->to_dat is initial.
      lr_node_role->to_dat = cl_suid_tools=>co_highest_date.

    else.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = lr_node_role->to_dat
        importing
          e_boolean = lv_rc.
      if lv_rc ne 0.
        if 1 = 0. message e302(00) with lr_node_role->to_dat. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.

        concatenate lr_node_role->subsystem lr_node_role->agr_name
                    lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '00'.
        lv_msg_data-msgno = '302'.
        lv_msg_data-msgv1 = lr_node_role->to_dat.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_field      = if_identity_definition=>gc_field_cua_role_to_dat
            is_msg        = lv_msg_data.

        " send insert failed notification
        if lr_node_role->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_role->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_role->change_mode.
        endif.
        continue.
      endif.
    endif.

    " check interval [from_dat, to_dat]
    if lr_node_role->from_dat > lr_node_role->to_dat.

      if 1 = 0. message e105(01) with lr_node_role->from_dat lr_node_role->to_dat. endif. "#EC *
      " send message for invalid interval
      clear: lv_msg_data, lv_msg_key_value.
      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '105'.
      write lr_node_role->from_dat to lv_msg_data-msgv1.
      write lr_node_role->to_dat   to lv_msg_data-msgv2.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          iv_field      = if_identity_definition=>gc_field_cua_role_to_dat
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_role->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_role->change_mode.
      endif.
      continue.
    endif.

    " only in case the role should be updated
    if lr_node_role->change_mode eq if_identity=>co_update.
      " set UPDATE_FROM_DAT
      if lr_node_role->update_from_dat is initial.
        lr_node_role->update_from_dat = sy-datum.

      elseif lr_node_role->update_from_dat < cl_suid_tools=>co_lowest_date.
        lr_node_role->update_from_dat = cl_suid_tools=>co_lowest_date.

      else.
        call method cl_suid_tools=>is_valid_date
          exporting
            i_date    = lr_node_role->update_from_dat
          importing
            e_boolean = lv_rc.
        if lv_rc <> 0.
          if 1 = 0. message e302(00) with lr_node_role->update_from_dat. endif. "#EC *
          "send message for invalid from_dat
          clear: lv_msg_data, lv_msg_key_value.

          concatenate lr_node_role->subsystem lr_node_role->agr_name
                      lr_node_role->from_dat lr_node_role->to_dat
                 into lv_msg_key_value respecting blanks.

          lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
          lv_msg_data-msgid = '00'.
          lv_msg_data-msgno = '302'.
          lv_msg_data-msgv1 = lr_node_role->update_from_dat.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle
              iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
              iv_field      = if_identity_definition=>gc_field_cua_role_from_dat
              is_msg        = lv_msg_data.

          " Keep line: Change failed
          clear: lr_node_role->change_mode.

          continue.
        endif.
      endif.

      " set UPDATE_TO_DAT
      if lr_node_role->update_to_dat is initial.
        lr_node_role->update_to_dat = cl_suid_tools=>co_highest_date.

      else.
        call method cl_suid_tools=>is_valid_date
          exporting
            i_date    = lr_node_role->update_to_dat
          importing
            e_boolean = lv_rc.
        if lv_rc ne 0.
          if 1 = 0. message e302(00) with lr_node_role->update_to_dat. endif. "#EC *
          clear: lv_msg_data, lv_msg_key_value.

          concatenate lr_node_role->subsystem lr_node_role->agr_name
                      lr_node_role->from_dat lr_node_role->to_dat
                 into lv_msg_key_value respecting blanks.

          lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
          lv_msg_data-msgid = '00'.
          lv_msg_data-msgno = '302'.
          lv_msg_data-msgv1 = lr_node_role->update_to_dat.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle
              iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
              iv_field      = if_identity_definition=>gc_field_cua_role_to_dat
              is_msg        = lv_msg_data.

          " Keep line: Change failed
          clear: lr_node_role->change_mode.

          continue.
        endif.
      endif.

      " check interval [update_from_dat, update_to_dat]
      if lr_node_role->update_from_dat > lr_node_role->update_to_dat.

        if 1 = 0. message e105(01) with lr_node_role->update_from_dat lr_node_role->update_to_dat. endif. "#EC *
        " send message for invalid interval
        clear: lv_msg_data, lv_msg_key_value.
        concatenate lr_node_role->subsystem lr_node_role->agr_name
                    lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '01'.
        lv_msg_data-msgno = '105'.
        lv_msg_data-msgv1 = lr_node_role->update_from_dat.
        lv_msg_data-msgv2 = lr_node_role->update_to_dat.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_field      = if_identity_definition=>gc_field_cua_role_to_dat
            is_msg        = lv_msg_data.

        " Keep line: Change failed
        clear: lr_node_role->change_mode.

        continue.
      endif.
    endif.

    " -- Existence check: Role
    read table lt_existing_roles
         with key subsystem = lr_node_role->subsystem
                  agr_name  = lr_node_role->agr_name
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " -- Role does not exist
      check lr_node_role->change_mode ne if_identity=>co_delete.

      " MSG: Die Rolle &2 existiert nicht im System &1.
      if 1 = 0. message e592(s#) with lr_node_role->subsystem lr_node_role->agr_name . endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = 'S#'.
      lv_msg_data-msgno = '592'.
      lv_msg_data-msgv1 = lr_node_role->subsystem.
      lv_msg_data-msgv2 = lr_node_role->agr_name.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_role->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_cua_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_role->change_mode.
      endif.
      continue. "go ahead with next role

    else.
      " --  authority check
      " do not check authority if iv_permit is true:
      " needed for deletion of CUA systems
      if iv_permit eq if_identity=>co_false.
        lv_tabix = sy-tabix.
        case lr_node_role->change_mode.
          when if_identity=>co_insert.
            lv_operation = cl_suid_tools=>co_activity_create.
          when if_identity=>co_update.
            lv_operation = cl_suid_tools=>co_activity_update.
          when if_identity=>co_delete.
            lv_operation = cl_suid_tools=>co_activity_delete.
          when others. " handles empty entry like no authority check
            lv_operation = co_no_activity.
        endcase.

        if lv_operation ne co_no_activity.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename  = if_identity_definition=>gc_node_cua_role
              iv_operation = lv_operation
              iv_class     = iv_class
              iv_bname     = iv_bname
              iv_subsystem = lr_node_role->subsystem
              iv_role      = lr_node_role->agr_name
            importing
              es_msg       = lv_msg_data.

          if lv_msg_data-msgty eq 'E'.
            " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &3 zur Rolle &2 für System &1
            if 1 = 0. message e637(01) with lv_msg_data-msgv1 lv_msg_data-msgv2 lv_msg_data-msgv3. endif. "#EC *
            clear: lv_msg_key_value.

            concatenate lr_node_role->subsystem lr_node_role->agr_name
                        lr_node_role->from_dat lr_node_role->to_dat
                   into lv_msg_key_value respecting blanks.

            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle
                iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
                is_msg        = lv_msg_data
                iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

            " send insert failed notification
            if lr_node_role->change_mode eq if_identity=>co_insert.
              if io_notify is supplied.
                call method io_notify->notify_failed_create
                  exporting
                    iv_bname      = iv_bname
                    iv_nodename   = if_identity_definition=>gc_node_cua_role
                    iv_key        = lv_msg_key_value
                    iv_key_handle = lr_node_role->key_handle.
              endif.
              " Keep line: Insert failed
              lr_node_role->change_mode = if_identity=>co_failed_create.
            else.
              " Keep line: Change failed
              clear: lr_node_role->change_mode.
            endif.
            continue.
          endif.
        endif.
      endif.

      " --  Duplicate entries: insert into hashed table
      if lr_node_role->change_mode eq if_identity=>co_update.
        ls_node_role          = lr_node_role->*.
        ls_node_role-from_dat = lr_node_role->update_from_dat.
        ls_node_role-to_dat   = lr_node_role->update_to_dat.
        insert ls_node_role into table lt_hashed_roles.
      else.
        insert lr_node_role->* into table lt_hashed_roles.
      endif.
      if sy-subrc ne 0.
        " MSG: Die Rolle &1 für das Zielssystem &2 ist bereits zugeordnet
        if 1 = 0. message e061(suid01) with lr_node_role->agr_name lr_node_role->subsystem. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = 'SUID01'.
        lv_msg_data-msgno = '061'.
        lv_msg_data-msgv1 = lr_node_role->agr_name.
        lv_msg_data-msgv2 = lr_node_role->subsystem.

        concatenate lr_node_role->subsystem lr_node_role->agr_name
                    lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
            is_msg        = lv_msg_data
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

        " send insert failed notification
        if lr_node_role->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_cua_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_role->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_role->change_mode.
        endif.
        continue.
      endif.
    endif.
  endloop.

  clear lt_hashed_roles.

endmethod.


method check_cua_systems.


  data: ls_msg                 type          symsg
      , lr_node_cua_systems    type ref to   suid_st_node_cua_system
      , lv_lastsubsystem       type          uszbvsys-subsystem
      , lv_tabix               type          sy-tabix
      , lt_check_cua_systems   type          suid_tt_node_cua_systems
      , ls_usergroup           type          cl_suid_tools=>ty_groups
      .


  " Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.


  " Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  " Check class: If class does not exist -> Dummy check
  ls_usergroup-usergroup = iv_class.
  call method cl_suid_tools=>check_exist_groups
    changing
      cs_usergroup = ls_usergroup.
  if ls_usergroup-notexist eq if_identity=>co_true.
    clear: ls_usergroup-usergroup.
  endif.

  " Check systems
  clear: lv_lastsubsystem.

  et_cua_systems = it_cua_systems.
  sort et_cua_systems by subsystem.


  loop at et_cua_systems reference into lr_node_cua_systems.

    lv_tabix = sy-tabix.

    " Ignore empty line
    if lr_node_cua_systems->subsystem is initial.
      continue.
    endif.

    " Duplicate CUA system
    if lr_node_cua_systems->subsystem = lv_lastsubsystem.
      clear: ls_msg.
      ls_msg-msgv1 = lr_node_cua_systems->subsystem.
      " !!! Correct error message !!!!
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '793'.
      " MSG: An entry already exists for system &1
      if 1 = 0. message e793(01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_node_cua_systems->subsystem.
      call method go_anonymous_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ''
          iv_nodename = if_identity_definition=>gc_node_cua_system
          iv_key      = gv_macro_key
          iv_field    = if_identity_definition=>gc_field_cua_system_subsystem
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

      lr_node_cua_systems->change_mode = if_identity=>co_failed_create.
      continue.
    else.

      lv_lastsubsystem = lr_node_cua_systems->subsystem.
    endif.

    " Split et_cua_systems into lt_check_cua_systems and rest
    append lr_node_cua_systems->* to lt_check_cua_systems.
    delete et_cua_systems index lv_tabix.

  endloop.


  " --- Check values ------------------------------------------
  "
  call method cl_identity=>check_cua_systems_internal
    exporting
      iv_bname       = ''
      iv_class       = ls_usergroup-usergroup
      io_msg_buffer  = go_anonymous_msg_buffer
    changing
      ct_cua_systems = lt_check_cua_systems.


  " Add lt_check_groups to rest
  append lines of lt_check_cua_systems to et_cua_systems.
  sort et_cua_systems by subsystem.

  loop at et_cua_systems reference into lr_node_cua_systems.
    " Read system text (temporary) from tbdlst
    select single stext from tbdlst
                        into lr_node_cua_systems->systemtext
                        where langu  = sy-langu
                          and logsys = lr_node_cua_systems->subsystem.
  endloop.

endmethod.


method check_cua_systems_internal.


  data:  lr_cua_systems        type ref to   suid_st_node_cua_system
       , lv_logsys             type          t000-logsys
       , lt_cua_child_systems  type          suid_tt_uszbvlndrc
       , ls_msg                type          symsg
       , lv_lifetime           type          if_suid_msg_buffer=>ty_msg_lifetime
       , lv_operation          type          suid_node_activity
       .

  " Something to do ?
  if ct_cua_systems is initial.
    return.
  endif.


  " Actual system is not central system - system node shouldn't be filled --> error message and exit
  if gv_cua_central = space.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method io_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = iv_bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    exit.
  endif.


  " Get active CUA systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys    = lv_logsys
      et_cua_child_systems = lt_cua_child_systems.

  " Check existence
  loop at ct_cua_systems reference into lr_cua_systems.
    " If not central system of active CUA
    if lr_cua_systems->subsystem ne lv_logsys.
      " Child system of active CUA landscape?
      read table lt_cua_child_systems
        with key rcvsystem = lr_cua_systems->subsystem
        transporting no fields
        binary search.
      if sy-subrc <> 0.
        " If system is not a part of active CUA
        " System should be deleted: system is not a part of active CUA -> Delete node with note
        if lr_cua_systems->change_mode eq if_identity=>co_delete.
          continue.
        endif.

        clear: ls_msg.
        ls_msg-msgv1 = lr_cua_systems->subsystem.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
        " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege.
        if 1 = 0. message e381(01) with ls_msg-msgv1. endif.
        gv_macro_key = lr_cua_systems->subsystem.

        case lr_cua_systems->change_mode.
          when space.
            " For existing system assignment: Permanent error, because system is not a part of active CUA
            lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
          when if_identity=>co_insert.
            " Node creation failed: Do not store entry in trx buffer
            lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
            " Node could not be created
            lr_cua_systems->change_mode = if_identity=>co_failed_create.
        endcase.

        " In case of SU10 Check, always use lifetime_once
        if iv_bname is initial.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_system
            iv_key        = gv_macro_key
            iv_key_handle = lr_cua_systems->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_system_subsystem
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.


    " Authorization-check
    " Only INSERT and DELETE are possible for CUA systems
    if lr_cua_systems->change_mode eq if_identity=>co_insert or
       lr_cua_systems->change_mode eq if_identity=>co_delete.

      if lr_cua_systems->change_mode = if_identity=>co_insert.
        lv_operation = cl_suid_tools=>co_activity_create.
      else.
        lv_operation = cl_suid_tools=>co_activity_delete.
      endif.

      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_system
          iv_operation = lv_operation
          iv_class     = iv_class
          iv_subsystem = lr_cua_systems->subsystem
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty = 'E'.
        case lr_cua_systems->change_mode.
          when if_identity=>co_insert.
            " Node could not be created
            lr_cua_systems->change_mode = if_identity=>co_failed_create.

          when if_identity=>co_delete.
            " No notification
            clear: lr_cua_systems->change_mode.
        endcase.

        gv_macro_key = lr_cua_systems->subsystem.
        " MSG: Fehlende Zuordnungsberechtigung für Benutzergruppe &1 zum System &2
        if 1 = 0. message e631(01) with ls_msg-msgv1 ls_msg-msgv2. endif.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_cua_system
            iv_key        = gv_macro_key
            iv_key_handle = lr_cua_systems->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_system_subsystem
            is_msg        = ls_msg
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.
      endif.
    endif.
  endloop.

endmethod.


method CHECK_CUA_UCLASSES.

  data: ls_msg                 type          symsg
      , lr_node_cua_uclass     type ref to   suid_st_node_cua_uclass
      , lv_lastsubsystem       type          uszbvsys-subsystem
      , lv_tabix               type          sy-tabix
      , lt_check_cua_uclasses  type          suid_tt_node_cua_uclasses
      .


* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.


* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.


* Check systems
  clear: lv_lastsubsystem.

  et_cua_uclasses = it_cua_uclasses.
  sort et_cua_uclasses by subsystem.

  loop at et_cua_uclasses reference into lr_node_cua_uclass.

    lv_tabix = sy-tabix.

*...Ignore empty line
    if lr_node_cua_uclass->subsystem is initial.
      continue.
    endif.

*...Duplicate CUA system
    if lr_node_cua_uclass->subsystem = lv_lastsubsystem.
      clear: ls_msg.
      ls_msg-msgv1 = lr_node_cua_uclass->subsystem.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '274'.
*     MSG: Lizenzvermessung: Mehrere Einträge für System &1
      if 1 = 0. message e274(bv) with ls_msg-msgv1. endif.
      gv_macro_key = lr_node_cua_uclass->subsystem.
      call method go_anonymous_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ''
          iv_nodename = if_identity_definition=>gc_node_cua_uclass
          iv_key      = gv_macro_key
          iv_field    = if_identity_definition=>gc_field_cua_system_subsystem
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

      lr_node_cua_uclass->change_mode = if_identity=>co_failed_create.
      continue.
    else.

      lv_lastsubsystem = lr_node_cua_uclass->subsystem.
    endif.

*   Split et_cua_systems into lt_check_cua_systems and rest
    append lr_node_cua_uclass->* to lt_check_cua_uclasses.
    delete et_cua_uclasses index lv_tabix.

  endloop.


* --- Check values ------------------------------------------
*
  call method cl_identity=>check_cua_uclasses_internal
    exporting
      iv_nodename     = if_identity_definition=>gc_node_cua_uclass
      io_msg_buffer   = go_anonymous_msg_buffer
    changing
      ct_cua_uclasses = lt_check_cua_uclasses.

* Add lt_check_groups to rest
  append lines of lt_check_cua_uclasses to et_cua_uclasses.
  sort et_cua_uclasses by subsystem.


endmethod.


method check_cua_uclasses_internal.
* If parameter IV_BNAME is provided then table IT_ASSIGNED_SYSTEMS should be also provided
*
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_LIC_TYPE (LIC_TYPE)
*   E266(BV)           - Der Benutzertyp &1 ist im Tochtersystem &2 unbekannt
*   E265(BV)           - Der Benutzertyp &1 ist im Tochtersystem &2 nicht aktiv
*   E407(LAW_MESSAGES) - Verwendung von Benutzertyp &1 ist nicht erlaubt
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_SUB_FROM  (SUBSTITUTE_FROM)
*   E256(BV)           - Specify the period of the substitution
*   E257(BV)           - The period for the substitution is invalid
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_SUB_UNTIL (SUBSTITUTE_UNTIL)
*   E256(BV)           - Specify the period of the substitution
*   E017(BV)           - &1 is in the past
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_SYSID     (SYSID)
*   E258(BV)           - Specify "&1" as the system of the substituted user
*   E261(BV)           - The name of the system with the chargeable user is missing
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_CLIENT    (CLIENT)
*   E259(BV)           - Specify "&1" as the client of the substituted user
*   E262(BV)           - The client with the chargeable user in system &1 is missing
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_BNAME_CHARGE (BNAME_CHARGEABLE)
*   E263(BV)           - Specify the user ID of the chargeable user
*   E753(01)           - User identical to substitute
*   E270(BV)           - Der vertretene Benutzer &1 existiert im logischen System &2 nicht
*   E088(BV)           - User type 11 in the same system/client is not permitted
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_SPEC_VERS    (SPEC_VERS)
*   E252(BV)           - Specification of a special version is not permitted for user type &1
*   E253(BV)           - Special version and country surcharge are not permitted simultaneously
*   E272(BV)           - Die Sonderversion &1 ist im Tochtersystem &2 unbekannt.
* GC_NODE_CUA_UCLASS - GC_FIELD_UCLASS_SURCHARGE    (COUNTRY_SURCHARGE)
*   E249(BV)           - Specification of a country surcharge for user type &1 is not permitted
*   E254(BV)           - The country surcharge may not be smaller than -100%
*   E255(BV)           - The country surcharge cannot be larger than 999 %
"--------------------------------------------------------------------------------------------------
"  07.07.2017  D034406 ( note 2501018 )                                                 7.31+
" The classification error of a user for a NOT assigned child system will remain for all other
" child systems, too.
"--------------------------------------------------------------------------------------------------

  data: ls_msg           type symsg
      , ls_systutypa     type usrsysutpa
      , ls_sysvtyp       type usrsysvtyp                    "#EC NEEDED
      , ls_sysuzus       type usrsysuzus                    "#EC NEEDED
      .

  data: lt_support_systems  type          suid_tt_node_cua_systems
      , lv_central_logsys   type          uszbvlndsc-sendsystem
      , lr_cua_uclass       type ref to   suid_st_node_cua_uclass
      , lr_uclass           type ref to   suid_st_node_uclass
      , lv_error            type          sesf_boolean
      , lv_lifetime         type          if_suid_msg_buffer=>ty_msg_lifetime
      .


  " ---------------------------------------------------------------------
  "
  " Is there any classification => we don't have to check this parameter.
  if ct_cua_uclasses is initial.
    return.
  endif.

  " Get central and child systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys = lv_central_logsys.

  " Get child systems, which are supporting CUA for License data
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_law_support_subsystems
    importing
      et_cua_law_subsystems = lt_support_systems.



  " --- Do the check -------------------------------
  loop at ct_cua_uclasses reference into lr_cua_uclass.

    lv_error = if_identity=>co_false.                      "note 2501018

    " Determine lifetime of error message
    case lr_cua_uclass->change_mode.
      when space or if_identity=>co_update.
        " Already assigned data: Permanent error
        lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
      when if_identity=>co_insert or if_identity=>co_delete.
        " Node creation failed: Do not store entry in trx buffer
        lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endcase.
    " In case of SU10 Check, always use lifetime_once
    if iv_bname is initial.
      lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endif.

    " Child system supports CUA for License data?
    if lr_cua_uclass->subsystem ne lv_central_logsys.
      read table lt_support_systems
           with key subsystem = lr_cua_uclass->subsystem
           transporting no fields
           binary search.
      if sy-subrc ne 0.
        " If system doesn't support CUA for License data
        if lr_cua_uclass->change_mode eq if_identity=>co_delete.
          " System should be deleted: system is not a part of active CUA -> Delete node with note
          continue.
        endif.

        clear: ls_msg.
        ls_msg-msgv1 = lr_cua_uclass->subsystem.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '273'.
        " MSG: Das Tochtsystem &1 unterstützt keine globale Nutzerklassifikation
        if 1 = 0. message e273(bv) with ls_msg-msgv1. endif.
        gv_macro_key = lr_cua_uclass->subsystem.

        lv_error = if_identity=>co_true.
      endif.
    endif.

    " For user specific check: is system assigned?
    if iv_bname is not initial and lv_error eq if_identity=>co_false.
      read table it_assigned_systems
           with key subsystem = lr_cua_uclass->subsystem
           transporting no fields
           binary search.
      if sy-subrc ne 0.
        " System should be deleted: system is not a part of active CUA -> Delete node with note
        if lr_cua_uclass->change_mode eq if_identity=>co_delete.
          continue.
        endif.

        clear: ls_msg.
        ls_msg-msgv1 = lr_cua_uclass->subsystem.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '269'.
        " MSG: System &1 ist dem Benutzer nicht zugeordnet oder nicht Teil der ZBV
        if 1 = 0. message e269(bv) with ls_msg-msgv1. endif.
        gv_macro_key = lr_cua_uclass->subsystem.

        lv_error = if_identity=>co_true.
      endif.
    endif.

    " Write error message into buffer
    if lv_error eq if_identity=>co_true.
      if lr_cua_uclass->change_mode eq if_identity=>co_insert.
        " Node could not be created
        lr_cua_uclass->change_mode = if_identity=>co_failed_create.
      endif.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = iv_nodename
          iv_key        = gv_macro_key
          iv_key_handle = lr_cua_uclass->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_system_subsystem
          is_msg        = ls_msg
          iv_lifetime   = lv_lifetime.
      continue.
    endif.

    " No additional checks of License data for to be deleted nodes
    if lr_cua_uclass->change_mode eq if_identity=>co_delete.
      continue.
    endif.

    " Insert '00' as license type not possible
    if lr_cua_uclass->lic_type is initial or lr_cua_uclass->lic_type = '00'.
      if lr_cua_uclass->change_mode eq if_identity=>co_insert.
        clear: ls_msg.
        ls_msg-msgv1 = lr_cua_uclass->lic_type.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '004'.
        " MSG: Verwendung von Benutzertyp &1 ist nicht erlaubt
        if 1 = 0. message e004(bv) with ls_msg-msgv1. endif.
        gv_macro_key = lr_cua_uclass->subsystem.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = gv_macro_key
            iv_key_handle = lr_cua_uclass->key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_lic_type
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.

        " Node could not be created
        lr_cua_uclass->change_mode = if_identity=>co_failed_create.
      endif.

      " No additional checks for other change modes
      continue.
    endif.


    " Further in case of SU01 Check, always use lifetime_permanent
    if iv_bname is not initial.
      lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
    endif.

    " Check definition of user type
    if lr_cua_uclass->subsystem = lv_central_logsys.
      " If central system of active CUA --> check local tables
      create data: lr_uclass.
      move-corresponding lr_cua_uclass->* to lr_uclass->*.
      call method check_uclass_internal
        exporting
          iv_cua_case       = if_identity=>co_true
          iv_nodename       = iv_nodename
          iv_bname          = iv_bname
          io_msg_buffer     = io_msg_buffer
          iv_central_system = lr_cua_uclass->subsystem
          iv_key_handle     = lr_cua_uclass->key_handle
        changing
          cs_uclass         = lr_uclass->*.
    else.

      " Child system
      select single * into ls_systutypa
        from usrsysutpa
       where subsystem = lr_cua_uclass->subsystem
         and usertyp   = lr_cua_uclass->lic_type.
      if sy-subrc <> 0.
        clear: ls_msg.
        ls_msg-msgv1 = lr_cua_uclass->lic_type.
        ls_msg-msgv2 = lr_cua_uclass->subsystem.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '266'.
        " MSG: Der Benutzertyp &1 ist im Tochtersystem &2 unbekannt
        if 1 = 0. message e266(bv) with ls_msg-msgv1 ls_msg-msgv2. endif.
        gv_macro_key = lr_cua_uclass->subsystem.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = gv_macro_key
            iv_key_handle = lr_cua_uclass->key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_lic_type
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
        continue.
      endif.

      " Check whether the user type is active
      if space eq cl_suid_tools=>check_active_cua_uclass( iv_subsystem = lr_cua_uclass->subsystem
                                                          iv_usertyp   = lr_cua_uclass->lic_type ).
        clear: ls_msg.
        ls_msg-msgv1 = lr_cua_uclass->lic_type.
        ls_msg-msgv2 = lr_cua_uclass->subsystem.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '265'.
        " MSG: Der Benutzertyp &1 ist im Tochtersystem &2 nicht aktiv
        if 1 = 0. message e265(bv) with ls_msg-msgv1 ls_msg-msgv2. endif.
        gv_macro_key = lr_cua_uclass->subsystem.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = gv_macro_key
            iv_key_handle = lr_cua_uclass->key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_lic_type
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
        continue.
      endif.

      " Check the special conditions for user types
      create data: lr_uclass.
      move-corresponding lr_cua_uclass->* to lr_uclass->*.
      call method uclass_check_spec_conditions
        exporting
          iv_nodename   = iv_nodename
          iv_bname      = iv_bname
          io_msg_buffer = io_msg_buffer
          is_uclass     = lr_uclass->*
          iv_cua_case   = if_identity=>co_true
          iv_subsystem  = lr_cua_uclass->subsystem
          iv_key_handle = lr_cua_uclass->key_handle.

      " Check the special version
      if lr_cua_uclass->spec_vers ne space and lr_cua_uclass->spec_vers ne '00'.
        " Check whether a special version is allowed for this user type.
        if ls_systutypa-sondervers is initial.
          clear: ls_msg.
          ls_msg-msgv1 = lr_cua_uclass->lic_type.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '252'.
          " MSG: Specification of a special version is not permitted for user type &1
          if 1 = 0. message e252(bv) with ls_msg-msgv1. endif.
          gv_macro_key = lr_cua_uclass->subsystem.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

        " Check whether both a special version and a country surcharge were specified.
        if lr_cua_uclass->country_surcharge ne 0.
          clear: ls_msg.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '253'.
          " MSG: Special version and country surcharge are not permitted simultaneously
          if 1 = 0. message e253(bv). endif.
          gv_macro_key = lr_cua_uclass->subsystem.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

        " Check existence of the special version
        select single * into ls_sysuzus                     "#EC WARNOK
                 from usrsysuzus
                where subsystem  = lr_cua_uclass->subsystem
                  and sondervers = lr_cua_uclass->spec_vers.
        if sy-subrc ne 0.
          clear: ls_msg.
          ls_msg-msgv1 = lr_cua_uclass->spec_vers.
          ls_msg-msgv2 = lr_cua_uclass->subsystem.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '272'.
          " MSG: Die Sonderversion &1 ist im Tochtersystem &2 unbekannt.
          if 1 = 0. message e272(bv) with ls_msg-msgv1 ls_msg-msgv2. endif.
          gv_macro_key = lr_cua_uclass->subsystem.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.
      endif.


      " Check the country surcharge
      if lr_cua_uclass->country_surcharge ne 0.
        " Check whether a country surcharge is allowed for this user type.
        if ls_systutypa-country is initial.
          clear: ls_msg.
          ls_msg-msgv1 = lr_cua_uclass->lic_type.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '249'.
          " MSG: Specification of a country surcharge for user type &1 is not permitted
          if 1 = 0. message e249(bv) with ls_msg-msgv1. endif.
          gv_macro_key = lr_cua_uclass->subsystem.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_surcharge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.

          " Range check
        elseif lr_cua_uclass->country_surcharge lt -100.
          clear: ls_msg.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '254'.
          " MSG: The country surcharge may not be smaller than -100%
          if 1 = 0. message e254(bv). endif.
          gv_macro_key = lr_cua_uclass->subsystem.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_surcharge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.

        elseif lr_cua_uclass->country_surcharge > 999.
          clear: ls_msg.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '255'.
          " MSG: The country surcharge cannot be larger than 999 %
          if 1 = 0. message e255(bv). endif.
          gv_macro_key = lr_cua_uclass->subsystem.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_surcharge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.
      endif.
    endif.
  endloop.


endmethod.


method check_dbms_roles_internal.

  data: ls_msg                type          symsg
      , lv_lifetime           type          if_suid_msg_buffer=>ty_msg_lifetime
      .


* Something to do ?
  if ct_dbms_roles is initial.
    return.
  endif.

  " Get Provider for DBMS checks
  cl_dbms_user_factory=>get_dbms_user_provider(
    importing
      eo_db_user_provider = data(lr_dbms_us_prov)
      et_messages         = data(lt_prov_messages)
  ).
  loop at lt_prov_messages assigning field-symbol(<ls_msg>).
    clear ls_msg.
    ls_msg-msgty      = <ls_msg>-type.
    ls_msg-msgid      = <ls_msg>-id.
    ls_msg-msgno      = <ls_msg>-number.
    ls_msg-msgv1      = <ls_msg>-message_v1.
    ls_msg-msgv2      = <ls_msg>-message_v2.
    ls_msg-msgv3      = <ls_msg>-message_v3.
    ls_msg-msgv4      = <ls_msg>-message_v4.
    call method io_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = iv_bname
        iv_nodename = if_identity_definition=>gc_node_dbms_role
        iv_field    = if_identity_definition=>gc_field_dbms_user_role
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
  endloop.

  " Check Roles
  loop at ct_dbms_roles reference into data(lr_dbms_role).

    " Check existence
    if lr_dbms_role->change_mode <> if_identity=>co_delete. "deletion is always possible

      lr_dbms_us_prov->check_role_exist(
        exporting
          iv_role_name   = lr_dbms_role->dbms_role
        importing
          ev_failed      = data(lv_failed)
          ev_role_exists = data(lv_roles_exist)
          et_messages    = data(lt_dbms_messages)
      ).
      loop at lt_dbms_messages assigning <ls_msg>.
        clear ls_msg.
        ls_msg-msgty      = <ls_msg>-type.
        ls_msg-msgid      = <ls_msg>-id.
        ls_msg-msgno      = <ls_msg>-number.
        ls_msg-msgv1      = <ls_msg>-message_v1.
        ls_msg-msgv2      = <ls_msg>-message_v2.
        ls_msg-msgv3      = <ls_msg>-message_v3.
        ls_msg-msgv4      = <ls_msg>-message_v4.

        lv_lifetime       = if_suid_msg_buffer=>co_lifetime_once.
        gv_macro_key      = lr_dbms_role->dbms_role.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_dbms_role
            iv_key        = gv_macro_key
            iv_key_handle = lr_dbms_role->key_handle
            iv_field      = if_identity_definition=>gc_field_dbms_user_role
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.

      endloop.

      if lv_roles_exist is initial or lv_failed = 'X'.
        lr_dbms_role->change_mode = if_identity=>co_failed_create.
      endif.

    endif.

    "Auth check for DBMS-roles?
*    if lr_dbms_role->change_mode eq if_identity=>co_insert or
*       lr_dbms_role->change_mode eq if_identity=>co_delete.
*    endif.

  endloop.

endmethod.


method check_dbms_user_internal.

  types:
    begin of ty_check,
      dbms_user                    type c length 1,
      password                     type c length 1,
      user_deactivated             type c length 1,
      external_identity            type c length 1,
      is_password_enabled          type c length 1,
      is_kerberos_enabled          type c length 1,
      is_saml_enabled              type c length 1,
      is_sap_logon_ticket_enabled  type c length 1,
      is_sap_assert_ticket_enabled type c length 1,
      is_x509_enabled              type c length 1,
      valid_from                   type c length 1,
      valid_to                     type c length 1,
      email_address                type c length 1,
      is_restricted                type c length 1,
    end of ty_check.

  field-symbols:
        <lv_field>      type any
      .

  data: ls_check        type          ty_check
      , ls_msg          type          symsg
      , lv_date_invalid type          char01
      .

* Set the fields to be checked
  if it_check_fields is initial.
    clear ls_check with 'X'.
  else.
    loop at it_check_fields reference into data(lr_field).
      assign component lr_field->* of structure ls_check to <lv_field>.
      if <lv_field> is assigned.
        <lv_field> = 'X'.
      endif.
    endloop.
  endif.

* === Start: Check values =============================================
  " Pre check
  if ls_check-password            eq 'X' or
    ls_check-user_deactivated     eq 'X' or
    ls_check-external_identity    eq 'X' or
    ls_check-is_password_enabled  eq 'X' or
    ls_check-is_kerberos_enabled  eq 'X' or
    ls_check-is_saml_enabled      eq 'X' or
    ls_check-is_sap_logon_ticket_enabled  eq 'X' or
    ls_check-is_sap_assert_ticket_enabled eq 'X' or
    ls_check-is_x509_enabled      eq 'X' or
    ls_check-valid_from           eq 'X' or
    ls_check-valid_to             eq 'X' or
    ls_check-email_address        eq 'X' or
    ls_check-is_restricted        eq 'X'
    .
    if cs_dbms_user-dbms_user is initial.
      clear: ls_msg.
      ls_msg-msgty = 'W'. ls_msg-msgid = 'SUSR_DBMS'. ls_msg-msgno = '015'.
      ls_msg-msgv1 = iv_bname.
      " Please assign DBMS User
      if 1 = 0. message w015(susr_dbms) with ls_msg-msgv1. endif.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_dbms_user
          iv_field    = if_identity_definition=>gc_field_dbms_user_dbms_user
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
      clear: cs_dbms_user.
    endif.
  endif.
  " Get Provider for DBMS checks
  if ls_check-password  eq 'X' or
     ls_check-dbms_user eq 'X'.
    cl_dbms_user_factory=>get_dbms_user_provider(
      importing
        eo_db_user_provider = data(lr_dbms_us_prov)
        et_messages         = data(lt_prov_messages)
    ).
    loop at lt_prov_messages assigning field-symbol(<ls_msg>).
      clear ls_msg.
      ls_msg-msgty      = <ls_msg>-type.
      ls_msg-msgid      = <ls_msg>-id.
      ls_msg-msgno      = <ls_msg>-number.
      ls_msg-msgv1      = <ls_msg>-message_v1.
      ls_msg-msgv2      = <ls_msg>-message_v2.
      ls_msg-msgv3      = <ls_msg>-message_v3.
      ls_msg-msgv4      = <ls_msg>-message_v4.
      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_dbms_user
          iv_field    = if_identity_definition=>gc_field_dbms_user_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
    endloop.
  endif.

* ----- DBMS User ---------------------------------------------
*
  " Check DBMS User
  if ls_check-dbms_user eq 'X'.
    if cs_dbms_user-dbms_user is not initial.

      " Check existence of entry for DBMS User in table USR_DBMS_USER
      data lv_bnamedbms type xubname.
      select single bname from usr_dbms_user into lv_bnamedbms
            where bname     <> iv_bname and
                  dbms_user =  cs_dbms_user-dbms_user.      "#EC *
      if sy-subrc = 0.
        if lv_bnamedbms <> iv_bname.
          clear: ls_msg.
          ls_msg-msgv1 = cs_dbms_user-dbms_user.
          ls_msg-msgv2 = lv_bnamedbms.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'SUSR_DBMS'. ls_msg-msgno = '005'.
          " DBMS User &1 is already assigned to another ABAP user &2
          if 1 = 0. message e005(susr_dbms) with ls_msg-msgv1 ls_msg-msgv2. endif.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_dbms_user
              iv_field    = if_identity_definition=>gc_field_dbms_user_dbms_user
              is_msg      = ls_msg.
        endif.
      endif.
      " Check DBMS User name
      if lr_dbms_us_prov is not initial.
        lr_dbms_us_prov->is_user_name_valid(
          exporting
            iv_user_name = cs_dbms_user-dbms_user
          importing
            ev_valid     = data(lv_usr_valid)
            et_messages  = data(lt_usr_messages)
        ).
        if lv_usr_valid <> 'X'.
          loop at lt_usr_messages assigning field-symbol(<ls_usr_msg>).
            ls_msg-msgid = <ls_usr_msg>-id.
            ls_msg-msgno = <ls_usr_msg>-number.
            ls_msg-msgty = <ls_usr_msg>-type.
            ls_msg-msgv1 = <ls_usr_msg>-message_v1.
            ls_msg-msgv2 = <ls_usr_msg>-message_v2.
            ls_msg-msgv3 = <ls_usr_msg>-message_v3.
            ls_msg-msgv4 = <ls_usr_msg>-message_v4.

            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = iv_bname
                iv_nodename = if_identity_definition=>gc_node_dbms_user
                iv_field    = if_identity_definition=>gc_field_dbms_user_dbms_user
                iv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent "we should not allow to map to incorrect DBMS-user name
                is_msg      = ls_msg.

          endloop.
        endif.
      else.
        "messages already added
      endif.
    endif.
  endif.

  "--- Check Password

  if ls_check-password eq 'X'.
    if cs_dbms_user-password is not initial.
      if cs_dbms_user-password <> cs_dbms_user-password2.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = 293.
        " Bitte Kennworte übereinstimmend eingeben
        if 1 = 0. message e293(01). endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_dbms_user
            iv_field    = if_identity_definition=>gc_field_dbms_user_password
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = ls_msg.
        clear: cs_dbms_user-password, cs_dbms_user-password2.
      else.
        " Check DBMS rules for password
        if lr_dbms_us_prov is not initial.
          lr_dbms_us_prov->is_password_valid(
            exporting
              iv_password = cs_dbms_user-password
            importing
              ev_valid    = data(lv_pwd_valid)
              et_messages = data(lt_pwd_messages)
          ).
          if lv_pwd_valid <> 'X'.
            loop at lt_pwd_messages assigning field-symbol(<ls_pwd_msg>).
              ls_msg-msgid = <ls_pwd_msg>-id.
              ls_msg-msgno = <ls_pwd_msg>-number.
              ls_msg-msgty = <ls_pwd_msg>-type.
              ls_msg-msgv1 = <ls_pwd_msg>-message_v1.
              ls_msg-msgv2 = <ls_pwd_msg>-message_v2.
              ls_msg-msgv3 = <ls_pwd_msg>-message_v3.
              ls_msg-msgv4 = <ls_pwd_msg>-message_v4.

              call method io_msg_buffer->add_object_message_symsg
                exporting
                  iv_bname    = iv_bname
                  iv_nodename = if_identity_definition=>gc_node_dbms_user
                  iv_field    = if_identity_definition=>gc_field_dbms_user_password
                  iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
                  is_msg      = ls_msg.
            endloop.
            clear: cs_dbms_user-password, cs_dbms_user-password2.
          endif.
        else.
          "messages already added
          clear: cs_dbms_user-password, cs_dbms_user-password2.
        endif.
      endif.
    endif.
  endif.

  "--- Check whether date format is valid: GLTGV, GLTGB
  "
  if ls_check-valid_from eq 'X'.
    if cs_dbms_user-valid_from is not initial.
      clear ls_msg.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = cs_dbms_user-valid_from
        importing
          e_message = ls_msg.
      if ls_msg is not initial.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_dbms_user
            iv_field    = if_identity_definition=>gc_field_dbms_valid_from
            is_msg      = ls_msg.
        lv_date_invalid = 'X'.
      endif.
    endif.
  endif.

  if ls_check-valid_to eq 'X'.
    if cs_dbms_user-valid_to is not initial.
      clear ls_msg.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = cs_dbms_user-valid_to
        importing
          e_message = ls_msg.
      if ls_msg is not initial.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_dbms_user
            iv_field    = if_identity_definition=>gc_field_dbms_valid_to
            is_msg      = ls_msg.
        lv_date_invalid = 'X'.
      endif.
    endif.
  endif.

  "--- Check validity dates
  "
  if ( ls_check-valid_from eq 'X' or ls_check-valid_to eq 'X' ) and
     lv_date_invalid is initial. "no sense to compare invalid dates
    if ( cs_dbms_user-valid_from is not initial ) and
       ( cs_dbms_user-valid_to   is not initial ) and
       ( cs_dbms_user-valid_from > cs_dbms_user-valid_to ).

      clear ls_msg.
      write cs_dbms_user-valid_from to ls_msg-msgv1.
      write cs_dbms_user-valid_to   to ls_msg-msgv2.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '105'.
      " Invalid time interval: Start date &1 after end date &2
      if 1 = 0. message e105(01) with ls_msg-msgv1 ls_msg-msgv2. endif.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_dbms_user
          iv_field    = if_identity_definition=>gc_field_dbms_valid_to
          is_msg      = ls_msg.
    endif.
*   "Check that from_to is not in the past
*    if cs_dbms_user-valid_from is not initial and cs_dbms_user-valid_from < sy-datum.
*      clear ls_msg.
*      ls_msg-msgty = 'E'. ls_msg-msgid = '00'. ls_msg-msgno = '697'.
*      write cs_dbms_user-valid_from to ls_msg-msgv1.
*      if 1 = 0. message e697(00) with ls_msg-msgv1. endif.
*      call method io_msg_buffer->add_object_message_symsg
*        exporting
*          iv_bname    = iv_bname
*          iv_nodename = if_identity_definition=>gc_node_dbms_user
*          iv_field    = if_identity_definition=>gc_field_dbms_valid_from
*          is_msg      = ls_msg.
*    endif.
  endif.

  "--- Check Email
  if ls_check-email_address eq 'X'.
    if cs_dbms_user-email_address is not initial.

      clear ls_msg.
      data ls_unstruct type sx_address.
      ls_unstruct-address = cs_dbms_user-email_address.
      ls_unstruct-type    = 'INT'.
      call function 'SX_INTERNET_ADDRESS_TO_NORMAL'
        exporting
          address_unstruct = ls_unstruct
        exceptions
          others           = 1.
      if sy-subrc <> 0.
        move-corresponding sy to ls_msg.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_dbms_user
            iv_field    = if_identity_definition=>gc_field_dbms_email_address
            is_msg      = ls_msg.

      endif.
    endif.
  endif.


* === End: Check values =============================================

endmethod.


method CHECK_DEFAULTS.

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

* Check node
  call method cl_identity=>check_defaults_internal
    exporting
      it_check_fields = it_check_fields
      io_msg_buffer    = go_anonymous_msg_buffer
    changing
      cs_defaults      = cs_defaults.

endmethod.


method check_defaults_internal.
**********************************************************************
* 14.03.2008 D050920  Note 1152246
* - PRGN_CUST parameters CUA_DATEFORMAT_CHECK and CUA_DECIMALNOT_CHECK
*  with value 'I'(Ignore) was treated as Information message.
**********************************************************************


  types:
    begin of ty_check,
       spld(1)        type c,
       splg(1)        type c,
       spdb(1)        type c,
       spda(1)        type c,
       datfm(1)       type c,
       timefm(1)      type c,
       dcpfm(1)       type c,
       langu(1)       type c,
       cattkennz(1)   type c,
       start_menu(1)  type c,
       tzone(1)       type c,
    end of ty_check.

  field-symbols:
        <lv_field>    type any
      .

  data: ls_check           type          ty_check
      , lr_field           type ref to   suid_node_field
      , ls_field_filter    type          suid_st_cua_filters
      , lv_prgn_cust_value type          prgn_cust-path
      , ls_msg             type          symsg
      , lv_msgty           type          symsg-msgty
      , lv_padest          type          tsp03-padest
      , lv_spras           type          t002-spras
      , lv_tzone           type          ttzz-tzone
      , lt_dd07v           type table of dd07v
      , lr_dd07v           type ref to   dd07v
  .


* Set the fields to be checked
  if it_check_fields is initial.
    clear ls_check with 'X'.
  else.
    loop at it_check_fields reference into lr_field.
      assign component lr_field->* of structure ls_check to <lv_field>.
      <lv_field> = 'X'.
    endloop.
  endif.


* === Start: Check values =============================================

* ----- Date format ---------------------------------------------
*
  if ls_check-datfm eq 'X'.
    if cs_defaults-datfm is initial.
*.....Set default date format
      call function 'SUSR_USER_DEFAULT_DATE_FORMAT'
        importing
          datfm = cs_defaults-datfm.

    else.
      if cl_abap_datfm=>check_date_format( cs_defaults-datfm ) = abap_false. " 'X'.
*.......Wrong date format supplied.

*  ->>> Different error handling in CUA and SCUG !!!
*       SCUG: transfer new users from child system into CUA (create them in central system) or
*       Idoc processing in child system
        if gs_cua_user_transfer-active = if_identity=>co_true  or
           gv_idoc_processing = if_identity=>co_true.
*         If new users are transferred (SCUG) and SCUM attribute is 'L' - local ==>
*         give warning message
          if gs_cua_user_transfer-active = if_identity=>co_true.
            clear: ls_field_filter.
            ls_field_filter-node_name  = if_identity_definition=>gc_node_defaults.
            ls_field_filter-node_field = if_identity_definition=>gc_field_defaults_datfm.
            call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
              changing
                cs_field_filter = ls_field_filter.
            if ls_field_filter-field_attr = if_suid_cua_runtime=>gc_local.
              lv_msgty = if_suid_msg_buffer=>co_type_warning.
            endif.
          endif.

*         Otherwise set message type according customizing switch
          if lv_msgty is initial.
            cl_suid_tools=>get_customizing_property(
              exporting
                iv_property_name  = cl_suid_tools=>co_cua_prgn_cust_dateformat
              importing
                ev_property_value = lv_prgn_cust_value  ).

            case lv_prgn_cust_value.
              when 'W'.
                lv_msgty = if_suid_msg_buffer=>co_type_warning.
              when 'S'.
                lv_msgty = if_suid_msg_buffer=>co_type_success.
              when 'I'.
                lv_msgty =  space. " 'I' = Ignore not if_suid_msg_buffer=>co_type_info.
              when others.
                lv_msgty = if_suid_msg_buffer=>co_type_error.
            endcase.
          endif.

*       Non-CUA case or not Idoc processing and not new user transfer with SCUG
        else.
          lv_msgty = if_suid_msg_buffer=>co_type_error.
        endif.

        clear: ls_msg.
        ls_msg-msgty = lv_msgty.
        ls_msg-msgid = '01'.

        if lv_msgty = if_suid_msg_buffer=>co_type_error.
*         Check domain values
          call function 'DDUT_DOMVALUES_GET'
            exporting
              name       = 'XUDATFM'
              texts_only = 'X'
            tables
              dd07v_tab  = lt_dd07v
            exceptions
              others     = 0.
          read table lt_dd07v
               reference into lr_dd07v
               with key domvalue_l = cs_defaults-datfm.
          if sy-subrc = 0.
*           Entry exits in domain values, but is not supported by the kernel
            ls_msg-msgv1 = lr_dd07v->ddtext.
            ls_msg-msgno = '409'.
*           MSG: Das Datumsformat & wird noch nicht unterstützt (siehe Hinweis 831333)
            if 1 = 0. message e409(01) with ls_msg-msgv1. endif.
          else.
*           Entry is wrong
            ls_msg-msgv1 = cs_defaults-datfm.
            ls_msg-msgno = '036'.
*           MSG: Invlaid date format &.
            if 1 = 0. message e036(01) with ls_msg-msgv1. endif.
          endif.

*       If message type is not 'E' ( SCUG or Idoc processing) ==> set default format
        else.
*         Set default date format
          call function 'SUSR_USER_DEFAULT_DATE_FORMAT'
            importing
              datfm = cs_defaults-datfm.

*         MSG: Datumsformat & ungultig. Profilparameter wird verwendet.
          if 1 = 0. message w398(01) with ls_msg-msgv1. endif.
          ls_msg-msgv1  = cs_defaults-datfm.
          ls_msg-msgno  = '398'.
        endif.

        if  lv_msgty is not initial.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_defaults
              iv_field    = if_identity_definition=>gc_field_defaults_datfm
              is_msg      = ls_msg.
        endif.

      endif.
    endif.
  endif.

* ----- Time format ---------------------------------------------
*
  if ls_check-timefm eq 'X'.
    if cs_defaults-timefm is initial.
*.....Set default time format
      call function 'SUSR_USER_DEFAULT_TIME_FORMAT'
       importing
         timefm = cs_defaults-timefm.

    elseif cl_suid_tools=>check_timefm( cs_defaults-timefm ) = abap_false.

      clear: ls_msg.
      ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
      ls_msg-msgid = 'SUID01'.
      ls_msg-msgno = '031'.
      ls_msg-msgv1 = cs_defaults-timefm.

*.....Wrong timeformat supplied.
*     MSG: Time format & is invalid
      if 1 = 0. message e031(suid01) with ls_msg-msgv1. endif.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_defaults
          iv_field    = if_identity_definition=>gc_field_defaults_timefm
          is_msg      = ls_msg.

    endif.
  endif.


* ----- Decimal format -------------------------------------
*
  if ls_check-dcpfm eq 'X'.
    if not ( cs_defaults-dcpfm eq ' ' or
             cs_defaults-dcpfm eq 'X' or
             cs_defaults-dcpfm eq 'x' or
             cs_defaults-dcpfm eq 'Y' or
             cs_defaults-dcpfm eq 'y' ).

*  ->>> Different error handling in CUA and SCUG !!!
*     SCUG: transfer new users from child system into CUA (create them in central system) or
*     Idoc processing in child system
      if gs_cua_user_transfer-active = if_identity=>co_true  or
         gv_idoc_processing = if_identity=>co_true.
*       If new users are transferred (SCUG) and SCUM attribute is 'L' - local ==>
*       give warning message
        if gs_cua_user_transfer-active = if_identity=>co_true.
          clear: ls_field_filter.
          ls_field_filter-node_name  = if_identity_definition=>gc_node_defaults.
          ls_field_filter-node_field = if_identity_definition=>gc_field_defaults_dcpfm.
          call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
            changing
              cs_field_filter = ls_field_filter.
          if ls_field_filter-field_attr = if_suid_cua_runtime=>gc_local.
            lv_msgty = if_suid_msg_buffer=>co_type_warning.
          endif.
        endif.

*       Otherwise set message type according customizing switch
        if lv_msgty is initial.
          cl_suid_tools=>get_customizing_property(
            exporting
              iv_property_name  = cl_suid_tools=>co_cua_prgn_cust_decimalnot
            importing
              ev_property_value = lv_prgn_cust_value  ).

          case lv_prgn_cust_value.
            when 'W'.
              lv_msgty = if_suid_msg_buffer=>co_type_warning.
            when 'S'.
              lv_msgty = if_suid_msg_buffer=>co_type_success.
            when 'I'.
              lv_msgty = space. " 'I' = Ignore not if_suid_msg_buffer=>co_type_info.
            when others.
              lv_msgty = if_suid_msg_buffer=>co_type_error.
          endcase.
        endif.

*     Non-CUA case or not Idoc processing and not new user transfer with SCUG
      else.
        lv_msgty = if_suid_msg_buffer=>co_type_error.
      endif.

      clear: ls_msg.
      ls_msg-msgty = lv_msgty.
      ls_msg-msgid = '01'.
      ls_msg-msgv1 = cs_defaults-dcpfm.

      if lv_msgty = if_suid_msg_buffer=>co_type_error.
*.......Wrong decimal format supplied.
        ls_msg-msgno = '086'.
*       MSG: Decimal format & is invalid. (Not ' ', X or Y)
        if 1 = 0. message e086(01) with ls_msg-msgv1. endif.

*     If message type is not 'E' ( SCUG or Idoc processing) ==> set default notation
      else.
        ls_msg-msgno = '399'.
*       MSG: Dezimalformat ungultig. Profilparameter wird verwendet.
        if 1 = 0. message w399(01) with ls_msg-msgv1. endif.

*       Read profile parameter
        call function 'SUSR_USER_DEFAULT_DEC_NOTATION'
          importing
            dcpfm = cs_defaults-dcpfm.
      endif.

      if lv_msgty is not initial.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_defaults
            iv_field    = if_identity_definition=>gc_field_defaults_dcpfm
            is_msg      = ls_msg.
      endif.

    endif.
  endif.

* ----- Printer ---------------------------------------------------------
*
* Spool: Ausgabegerät
  if ls_check-spld eq 'X'.
    if cs_defaults-spld is not initial.
      select single padest from tsp03 into lv_padest
                           where padest = cs_defaults-spld.
      if sy-subrc <> 0.
*.......Printer does not exist
        clear: ls_msg.
        ls_msg-msgv1 = cs_defaults-spld.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '029'.
*       MSG: Output device & does not exist
        if 1 = 0. message e029(01) with ls_msg-msgv1. endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_defaults
            iv_field    = if_identity_definition=>gc_field_defaults_spld
            is_msg      = ls_msg.

      endif.
    endif.
  endif.

* Print parameter 3: Delete, Keep
  if ls_check-spda eq 'X'.
    if cs_defaults-spda is initial.
*.....Set default parameter
      cs_defaults-spda = 'K'.             " Keep

    else.
      if not ( cs_defaults-spda = 'D' or
               cs_defaults-spda = 'K' ).
*.......Parameter not valid
        clear: ls_msg.
        ls_msg-msgv1 = cs_defaults-spda.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '033'.
*       MSG: Print parameters & for 'Delete after print' not equal to D(elete)/K(eep)
        if 1 = 0. message e033(01) with ls_msg-msgv1. endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_defaults
            iv_field    = if_identity_definition=>gc_field_defaults_spda
            is_msg      = ls_msg.

      endif.
    endif.
  endif.

* Print parameter 2: Go, Hold
  if ls_check-spdb eq 'X'.
    if cs_defaults-spdb is initial.
*.....Set default parameter
      cs_defaults-spdb = 'H'.     " Hold

    else.
      if not ( cs_defaults-spdb = 'G' or
               cs_defaults-spdb = 'H' ).
*.......Parameter not valid
        clear: ls_msg.
        ls_msg-msgv1 = cs_defaults-spdb.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '035'.
*       MSG: Print parameter & for 'Print immed.' not equal to G(o) or H(old).
        if 1 = 0. message e035(01) with ls_msg-msgv1. endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_defaults
            iv_field    = if_identity_definition=>gc_field_defaults_spdb
            is_msg      = ls_msg.

      endif.
    endif.
  endif.


* ----- Language ---------------------------------------------------
*
  if ls_check-langu eq 'X'.
    if cs_defaults-langu is not initial.
      select single spras from t002 into lv_spras
                          where spras = cs_defaults-langu.
      if sy-subrc <> 0.
*.......Language is not supported
        clear: ls_msg.
        ls_msg-msgv1 = cs_defaults-langu.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'TL'. ls_msg-msgno = '080'.
*       MSG: Language & not in system
        if 1 = 0. message e080(tl) with ls_msg-msgv1. endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_defaults
            iv_field    = if_identity_definition=>gc_field_defaults_langu
            is_msg      = ls_msg.

      endif.
    endif.
  endif.


* ----- Time zone --------------------------------------------------
*
  if ls_check-tzone eq 'X'.
    if cs_defaults-tzone is not initial.
      select single tzone from ttzz into lv_tzone
                          where tzone = cs_defaults-tzone.
      if sy-subrc <> 0.
*.......Time zone does not exist
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '028'.
*       MSG: Invalid time zone
        if 1 = 0. message e028(01). endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_defaults
            iv_field    = if_identity_definition=>gc_field_defaults_tzone
            is_msg      = ls_msg.

      endif.
    endif.
  endif.


* === End: Check values =============================================


endmethod.


method check_groups.


  data: ls_msg            type          symsg
      , lt_check_groups   type          suid_tt_node_groups
      , lr_node_groups    type ref to   suid_st_node_group
*     , lv_usergroup      type          usgrp-usergroup
      , lv_lastgroup      type          usgrp-usergroup
      , lv_tabix          type          sy-tabix
      .

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

* Check groups
  clear: lv_lastgroup.

  et_groups = it_groups.
  sort et_groups by usergroup.


  loop at et_groups reference into lr_node_groups.

    lv_tabix = sy-tabix.

*...Ignore empty line
    if lr_node_groups->usergroup is initial.
      continue.
    endif.


*...Duplicate Usergroup
    if lr_node_groups->usergroup = lv_lastgroup.
      clear: ls_msg.
      ls_msg-msgv1 = lr_node_groups->usergroup.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '408'.
*     MSG: An entry already exists for group &
      if 1 = 0. message e408(01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_node_groups->usergroup.
      call method go_anonymous_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ''
          iv_nodename   = if_identity_definition=>gc_node_group
          iv_key        = gv_macro_key
          iv_key_handle = lr_node_groups->key_handle
          iv_field      = if_identity_definition=>gc_field_group_usergroup
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      lr_node_groups->change_mode = if_identity=>co_failed_create.
      continue.
    else.

      lv_lastgroup = lr_node_groups->usergroup.

    endif.

*   Split et_groups into lt_check_groups and rest
    append lr_node_groups->* to lt_check_groups.
    delete et_groups index lv_tabix.

  endloop.

* --- Check values ------------------------------------------
*
  call method cl_identity=>check_groups_internal
    exporting
      iv_bname      = ''
      io_msg_buffer = go_anonymous_msg_buffer
    changing
      ct_groups     = lt_check_groups.


* Add lt_check_groups to rest
  append lines of lt_check_groups to et_groups.
  sort et_groups by usergroup.

* Read Group text (temporary)
  loop at et_groups reference into lr_node_groups
                    where usergroup is not initial.
    select single text
             from usgrpt
             into lr_node_groups->grouptext
            where sprsl     = sy-langu
              and usergroup = lr_node_groups->usergroup.
  endloop.



endmethod.


method check_groups_internal.
**********************************************************************
* 14.03.2008 D050920  Note 1152246
* - PRGN_CUST parameters CUA_USERGROUPS_CHECK with value 'I'(Ignore)
*   was treated as Information message.
**********************************************************************

  data: lr_groups             type ref to   suid_st_node_group
      , lt_usergroup          type          cl_suid_tools=>tt_groups
      , ls_usergroup          type          cl_suid_tools=>ty_groups
      , lr_usergroup          type ref to   cl_suid_tools=>ty_groups
      , ls_msg                type          symsg
      , lv_msgty              type          symsg-msgty
      , lv_lifetime           type          if_suid_msg_buffer=>ty_msg_lifetime
      , lv_prgn_cust_value    type          prgn_cust-path
      , lv_operation          type          suid_node_activity
      , lt_new_usgrps         type          suid_tt_usgrp
      , lt_new_usgrpts        type          suid_tt_usgrpt
      , ls_new_usgrp          type          usgrp
      , ls_new_usgrpt         type          usgrpt
      .


* Something to do ?
  if ct_groups is initial.
    return.
  endif.

  clear: lv_prgn_cust_value.
* ->>> Different error handling in CUA and SCUG !!!
* In CUA case (SCUG or Idoc processing) check customizing switch settings
  if gv_cua_active eq if_identity=>co_true and
   ( gv_idoc_processing          eq if_identity=>co_true or
     gs_cua_user_transfer-active eq if_identity=>co_true ).

    cl_suid_tools=>get_customizing_property(
      exporting
        iv_property_name  = cl_suid_tools=>co_cua_prgn_cust_usergroups
      importing
        ev_property_value = lv_prgn_cust_value  ).

    case lv_prgn_cust_value.
      when 'E'.
        lv_msgty = if_suid_msg_buffer=>co_type_error.
      when 'S'.
        lv_msgty = if_suid_msg_buffer=>co_type_success.
      when 'I' or 'C'.
        lv_msgty = space. " 'I' = ignore, not info-message
      when others.
        lv_msgty = if_suid_msg_buffer=>co_type_warning.
    endcase.

* No CUA transfer
  else.
    lv_msgty = if_suid_msg_buffer=>co_type_error.
  endif.


* Check existence
  loop at ct_groups reference into lr_groups.
    ls_usergroup = lr_groups->usergroup.
    append ls_usergroup to lt_usergroup.
  endloop.

  call method cl_suid_tools=>check_exist_groups
    changing
      ct_usergroup = lt_usergroup.


  loop at ct_groups reference into lr_groups.
    clear: ls_new_usgrp
         , ls_new_usgrpt
         .

    read table lt_usergroup reference into lr_usergroup
         with key usergroup = lr_groups->usergroup
         binary search.
    if sy-subrc eq 0.
      if lr_usergroup->notexist eq if_identity=>co_true.

*       Usergroup should be deleted: Group does not exist -> Delete node with note
        if lr_groups->change_mode eq if_identity=>co_delete.
          continue.
        endif.

*   ->>> Different error handling in CUA Idoc processing and SCUG cases!!!
*       Collect not existing groups in order to create them if customizing switch allow this
        if lv_prgn_cust_value eq 'C' and
         ( gv_idoc_processing          eq if_identity=>co_true or
           gs_cua_user_transfer-active eq if_identity=>co_true ).

          ls_new_usgrp-usergroup = lr_usergroup->usergroup.

          ls_new_usgrpt-usergroup = lr_usergroup->usergroup.
          ls_new_usgrpt-sprsl     = sy-langu.
          move lr_usergroup->usergroup to ls_new_usgrpt-text.

*       Other cases
        else.
          clear: ls_msg.
          ls_msg-msgv1 = lr_usergroup->usergroup.
          ls_msg-msgty = lv_msgty.
          ls_msg-msgid = '01'.
          ls_msg-msgno = '518'.
*         MSG: User group & does not exist.
          if 1 = 0. message e518(01) with ls_msg-msgv1. endif.
          gv_macro_key = lr_usergroup->usergroup.

*         SCUG or Idoc processing: Do not store entry in trx buffer
          if gv_idoc_processing          eq if_identity=>co_true or
             gs_cua_user_transfer-active eq if_identity=>co_true .

            lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
*           Node could not be created
            lr_groups->change_mode = if_identity=>co_failed_create.

*         Otherwise lifetime depends of processing mode
          else.
            case lr_groups->change_mode.
              when space.
*               For existing groups: Permanent error, because group does not exist
                lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
              when if_identity=>co_insert.
*               Node creation failed: Do not store entry in trx buffer
                lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
*               Node could not be created
                lr_groups->change_mode = if_identity=>co_failed_create.
            endcase.
          endif.

*         In case of SU10 Check, always use lifetime_once
          if iv_bname is initial.
            lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
          endif.

          if lv_msgty is not initial.
            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_group
                iv_key        = gv_macro_key
                iv_key_handle = lr_groups->key_handle
                iv_field      = if_identity_definition=>gc_field_group_usergroup
                is_msg        = ls_msg
                iv_lifetime   = lv_lifetime.
          endif.

          continue.
        endif.
      endif.
    else.
*     Cache must be filled
      raise exception type cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error.
    endif.


    if lr_groups->change_mode eq if_identity=>co_insert or
       lr_groups->change_mode eq if_identity=>co_delete.

      clear: ls_msg.

      if lr_groups->change_mode = if_identity=>co_insert.
        lv_operation = cl_suid_tools=>co_activity_create.
      else.
        lv_operation = cl_suid_tools=>co_activity_delete.
      endif.

*     Deletion of Usergroup space must be possible
      clear: ls_msg.
      if lr_groups->usergroup is not initial.
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename  = if_identity_definition=>gc_node_group
            iv_operation = lv_operation
            iv_class     = lr_groups->usergroup
          importing
            es_msg       = ls_msg.
      endif.

      if ls_msg-msgty = 'E'.
        case lr_groups->change_mode.
          when if_identity=>co_insert.
*           ls_msg-msgv1 = lr_groups->usergroup.
*           ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '491'.
*           MSG: You are not authorized to assign group &
*           IF 1 = 0. MESSAGE e505(01) WITH ls_msg-msgv1. ENDIF.
*           Node could not be created
            lr_groups->change_mode = if_identity=>co_failed_create.
            lv_lifetime            = if_suid_msg_buffer=>co_lifetime_once.
          when if_identity=>co_delete.
*           ls_msg-msgv1 = lr_groups->usergroup.
*           ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '526'.
*           MSG: You are not authorized to remove group &
*           IF 1 = 0. MESSAGE e526(01) WITH ls_msg-msgv1. ENDIF.
*           No notification
            clear: lr_groups->change_mode.
            lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
        endcase.

*       In case of SU10 Check, always use lifetime_once
        if iv_bname is initial.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

        gv_macro_key = lr_groups->usergroup.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_group
            iv_key        = gv_macro_key
            iv_key_handle = lr_groups->key_handle
            iv_field      = if_identity_definition=>gc_field_group_usergroup
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.

        continue.

      endif.

*   ->>> Different error handling in CUA Idoc processing and SCUG !!!
*     Collect new user groups in order to create them
      if ls_new_usgrp is not initial.
        append ls_new_usgrp to lt_new_usgrps.
      endif.

      if ls_new_usgrpt is not initial.
        append ls_new_usgrpt to lt_new_usgrpts.
      endif.
    endif.
  endloop.

*   ->>> Different error handling in CUA Idoc processing and SCUG !!!
* Create not existing groups with texts( they are commected only Idoc processing or SCUG cases)
  if lt_new_usgrps is not initial.
    cl_suid_tools=>create_new_usergroups(
        it_new_usgrps  = lt_new_usgrps
        it_new_usgrpts = lt_new_usgrpts  ).
  endif.

endmethod.


method check_if_cua_users.
* Internal check of users' CUA status before their instantiation

* If list of local users is requested then the list of user's USR02 entries
* should be also provided (local users are marked like USR02-RESERVED = co_user_local),
* otherwise optional


  data:   lt_cua_systems    type        suid_tt_uszbvsys
        , lr_cua_system     type ref to uszbvsys
        , lv_logsys         type        t000-logsys
        , lr_bname          type ref to suid_st_bname
        , lt_headers        type        suid_tt_usr02
        , lr_header         type ref to usr02
        .


  clear: et_cua_users, et_not_cua_users, et_deleted_cua_users
       , et_reserved_cua_users, et_local_users.


  " User name should be filled
  if it_bname is initial.
    return.
  endif.

  " Check that CUA landscape is active
  if gv_cua_active <> if_identity=>co_true.
    return.
  endif.

  lt_headers = it_headers.
  sort lt_headers by bname.

  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.


  " Read from DB
  call method go_persistence->if_suid_persistence_read~read
    exporting
      it_bname       = it_bname
    importing
      et_cua_systems = lt_cua_systems.


  " Check that user is transferred into CUA landscape
  loop at it_bname reference into lr_bname.
    if lt_headers is not initial and
     ( et_not_cua_users is requested or et_local_users is requested ).
      read table lt_headers reference into lr_header
           with key bname = lr_bname->bname
           binary search.
      if sy-subrc = 0.
        if lr_header->reserved = co_user_local.
          " If list of local users is requested
          if et_local_users is requested.
            append lr_bname->* to et_local_users.
          endif.
          " Add to not CUA users
          if et_not_cua_users is requested.
            append lr_bname->* to et_not_cua_users.
          endif.

          continue.
        endif.
      endif.
    endif.

    read table lt_cua_systems reference into lr_cua_system
         with key bname      = lr_bname->bname
                  usrsection = if_suid_cua_runtime=>gc_user_usrsection
                  subsystem  = lv_logsys
         binary search.
    " User is transferred into CUA landscape
    if sy-subrc = 0.
      " System assignment of a user is deleted
      if lr_cua_system->status = if_suid_cua_runtime=>gc_deleted       or
         lr_cua_system->status = if_suid_cua_runtime=>gc_to_be_deleted or
         lr_cua_system->status = if_suid_cua_runtime=>gc_deleted_runtime.
        if et_deleted_cua_users is requested.
          append lr_bname->* to et_deleted_cua_users.
        endif.
      " Active CUA user
      else.
        if et_cua_users is requested.
          append lr_bname->* to et_cua_users.
        endif.

        " In child system check if user is a reserved CUA user - Profile/Role Idoc
        " was processed before User Idoc and user didn't exist at that point ==>
        " user was created with default values and deactivated password and
        " and profile/role assignments and was marked in USZBVSYS with entry for USER
        " section and status 'O' - unconfirmed assignment (the only case in child
        " system when status 'O' is set)
        if gv_cua_child = if_identity=>co_true and et_reserved_cua_users is requested and
           lr_cua_system->status = if_suid_cua_runtime=>gc_to_be_assigned.
          append lr_bname->* to et_reserved_cua_users.
        endif.
      endif.

    " Otherwise user doesn't exist in CUA landscape
    else.
      if et_not_cua_users is requested.
        append lr_bname->* to et_not_cua_users.
      endif.
    endif.
  endloop.


  if et_cua_users is requested.
    sort et_cua_users.
  endif.

  if et_deleted_cua_users is requested.
    sort et_deleted_cua_users.
  endif.

  if et_not_cua_users is requested.
    sort et_not_cua_users.
  endif.

  if et_reserved_cua_users is requested.
    sort et_reserved_cua_users.
  endif.

  if et_local_users is requested.
    sort et_local_users.
  endif.


endmethod.


method check_logondata.

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

* Check node
  call method cl_identity=>check_logondata_internal
    exporting
      it_check_fields = it_check_fields
      io_msg_buffer   = go_anonymous_msg_buffer
      iv_modus        = iv_modus
    changing
      cs_logondata    = cs_logondata.

* Get text for usergroup CLASS:
  if cs_logondata-class is not initial.
    clear cs_logondata-classtxt.
    select single text from usgrpt into cs_logondata-classtxt
      where sprsl     = sy-langu
      and   usergroup = cs_logondata-class.
  endif.


endmethod.


method check_logondata_internal.
**********************************************************************
* 14.03.2008 D050920  Note 1152246
* - PRGN_CUST parameters CUA_USERGROUPS_CHECK with value 'I'(Ignore)
*   was treated as Information message.
**********************************************************************


  types:
    begin of ty_check,
      gltgv(1)        type c,
      gltgb(1)        type c,
      ustyp(1)        type c,
      class(1)        type c,
      accnt(1)        type c,
      kostl(1)        type c,
      useralias(1)    type c,
      security_policy type c length 1,
    end of ty_check.

  field-symbols:
        <lv_field>    type any
      .

  data: ls_check              type          ty_check
      , lr_field              type ref to   suid_node_field
      , ls_msg                type          symsg
      , lv_subrc              type          sy-subrc
      , lt_dd07v              type table of dd07v
      , lv_bnamealias         type          usrefus-useralias
      , lv_msgty              type          symsg-msgty
      , lv_prgn_cust_value    type          prgn_cust-path
      , ls_usergroup          type          cl_suid_tools=>ty_groups
      , lt_new_usgrps         type          suid_tt_usgrp
      , lt_new_usgrpts        type          suid_tt_usgrpt
      , ls_new_usgrp          type          usgrp
      , ls_new_usgrpt         type          usgrpt
      , lv_date_invalid       type          char01
      , ls_lockscope          type          suid_st_lockscope
      , lv_class              type          xuclass
      , lv_lifetime           type          if_suid_msg_buffer=>ty_msg_lifetime
      , lv_msg_permanent      type          char01
      .


  clear: ev_reject_class, ev_reject_secpol, ev_class_checked.

  " Set the fields to be checked
  if it_check_fields is initial.
    clear ls_check with 'X'.
  else.
    loop at it_check_fields reference into lr_field.
      assign component lr_field->* of structure ls_check to <lv_field>.
      <lv_field> = 'X'.
    endloop.
  endif.


  " === Start: Check values =============================================
  "

  "--- Check whether date format is valid: GLTGV, GLTGB
  "
  if ls_check-gltgv eq 'X'.
    if cs_logondata-gltgv is not initial.
      clear: ls_msg.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = cs_logondata-gltgv
        importing
          e_message = ls_msg.
      if ls_msg is not initial.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_logondata
            iv_field    = if_identity_definition=>gc_field_logondata_gltgv
            is_msg      = ls_msg.
        lv_date_invalid = 'X'.
      endif.
    endif.
  endif.

  if ls_check-gltgb eq 'X'.
    if cs_logondata-gltgb is not initial.
      clear: ls_msg.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = cs_logondata-gltgb
        importing
          e_message = ls_msg.
      if ls_msg is not initial.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_logondata
            iv_field    = if_identity_definition=>gc_field_logondata_gltgb
            is_msg      = ls_msg.
        lv_date_invalid = 'X'.
      endif.
    endif.
  endif.


  "--- Check validity date: GLTGV, GLTGB
  "
  if ( ls_check-gltgv eq 'X' or ls_check-gltgb eq 'X' ) and
     lv_date_invalid is initial. "no sense to compare invalid dates
    if ( cs_logondata-gltgv is not initial ) and
       ( cs_logondata-gltgb is not initial ) and
       ( cs_logondata-gltgv > cs_logondata-gltgb )
       .
      clear: ls_msg.
      write cs_logondata-gltgv to ls_msg-msgv1.
      write cs_logondata-gltgb to ls_msg-msgv2.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '105'.
      " Invalid time interval: Start date &1 after end date &2
      if 1 = 0. message e105(01) with ls_msg-msgv1 ls_msg-msgv2. endif.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_logondata
          iv_field    = if_identity_definition=>gc_field_logondata_gltgv
          is_msg      = ls_msg.

    elseif iv_bname is not initial and io_idref is bound.
      " --- Due to License reasons it is not allowed to set "date_to"
      " --- in the past. See Internal memo for the note 1124634.
      "  This is user-specific check!

      data: lv_locked_by_local_admin  type         char01
          , lv_locked_by_global_admin type         char01
          , lv_dummy                  type         char255  "#EC NEEDED
          .

      if ls_check-gltgb eq 'X'.
        " "Valid_to" date is smaller than last logondate?
        if cs_logondata-gltgb is not initial and
           io_idref->ms_segment_header-before_image-trdat > cs_logondata-gltgb.

          clear ls_msg.
          ls_msg-msgty = 'W'. ls_msg-msgid = '01'. ls_msg-msgno = '770'.
          ls_msg-msgv1 = iv_bname.
          write cs_logondata-gltgb to ls_msg-msgv2.
          message w770(01) with iv_bname  cs_logondata-gltgb into lv_dummy.

          if io_idref->ms_segment_header-before_image-trdat = sy-datum.
            call method io_idref->get_lockstatus
              importing
                ev_locked_by_admin        = lv_locked_by_local_admin
                ev_locked_by_global_admin = lv_locked_by_global_admin.
            if not ( lv_locked_by_local_admin  = 'X' or
                     lv_locked_by_global_admin = 'X' ).
              " User has already logged on today -> lock the user
              ls_lockscope-flg_lockscope_local = 'X'.
              io_idref->if_identity~action_lock( is_lockscope = ls_lockscope ).
              ls_msg-msgno = '771'.
              message w771(01) with iv_bname  cs_logondata-gltgb into lv_dummy.
            endif.
          endif.

          " "Valid_to" date should not be smaller then last logondate ->
          " change "Valid_to" to last logondate
          cs_logondata-gltgb = io_idref->ms_segment_header-before_image-trdat.

          " Message
          if ls_msg is not initial.
            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = iv_bname
                iv_nodename = if_identity_definition=>gc_node_logondata
                iv_field    = if_identity_definition=>gc_field_logondata_gltgb
                iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
                is_msg      = ls_msg.
          endif.
        endif.
      endif.
    endif.
  endif.


  "--- Check the user group: CLASS
  "
  if ls_check-class eq 'X'.
    if gv_class_is_required  eq if_identity=>co_true and
       cs_logondata-class    is initial.

      " Check if usergroup is mandatory
      " Switch to user group space. Use cases:
      " - space to space       -> permanent error message
      " - not initial to space -> lifetime once error message
      lv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once.
      if io_idref is bound.
        call method io_idref->get_class
          exporting
            iv_for_auth = if_identity=>co_false
          importing
            ev_class    = lv_class.

        if lv_class is initial.
          lv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_permanent.
        endif.
      endif.

      clear: ls_msg.
      ls_msg-msgty = 'E'.
      ls_msg-msgid = '01'.
      ls_msg-msgno = '583'.
      " Ordnen Sie eine Benutzergruppe zu (Hinweis 1663177).
      if 1 = 0. message e583(01). endif.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_logondata
          iv_field    = if_identity_definition=>gc_field_logondata_class
          iv_lifetime = lv_lifetime
          is_msg      = ls_msg.

      ev_reject_class = if_identity=>co_true.

    elseif cs_logondata-class is not initial.
      " Existence check for usergroup
      "
      clear: lv_prgn_cust_value.
      " ->>> Different error handling in CUA and SCUG !!!
      " In CUA case (SCUG or Idoc processing) check customizing switch settings
      if gv_cua_active eq if_identity=>co_true and
       ( gv_idoc_processing          eq if_identity=>co_true or
         gs_cua_user_transfer-active eq if_identity=>co_true ).

        cl_suid_tools=>get_customizing_property(
          exporting
            iv_property_name  = cl_suid_tools=>co_cua_prgn_cust_usergroups
          importing
            ev_property_value = lv_prgn_cust_value  ).

        case lv_prgn_cust_value.
          when 'W'.
            lv_msgty = if_suid_msg_buffer=>co_type_warning.
          when 'S'.
            lv_msgty = if_suid_msg_buffer=>co_type_success.
          when 'I' or 'C'.
            lv_msgty = space. " 'I' = ignore, not info-message
          when others.
            lv_msgty         = if_suid_msg_buffer=>co_type_error.
            lv_msg_permanent = 'X'. " Do not save user data in case user group does not exist
        endcase.

        " No CUA transfer
      else.
        lv_msgty = if_suid_msg_buffer=>co_type_error.
      endif.

      " Check existence
      ls_usergroup-usergroup = cs_logondata-class.
      call method cl_suid_tools=>check_exist_groups
        changing
          cs_usergroup = ls_usergroup.

      if ls_usergroup-notexist eq if_identity=>co_true.
        " In SCUG or Idoc processing case and customizing switch value 'C'
        " accept absent group and collect it for create
        if lv_prgn_cust_value eq 'C' and
           ( gv_idoc_processing          eq if_identity=>co_true or
             gs_cua_user_transfer-active eq if_identity=>co_true ).

          ls_new_usgrp-usergroup = ls_usergroup-usergroup.

          ls_new_usgrpt-usergroup = ls_usergroup-usergroup.
          ls_new_usgrpt-sprsl     = sy-langu.
          move ls_usergroup-usergroup to ls_new_usgrpt-text.

          " In other cases place message of corresponding type
        else.
          ev_reject_class = if_identity=>co_true.

          " Save user in case of error?
          if lv_msg_permanent eq 'X'.
            lv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_permanent.
          else.
            lv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once.
          endif.

          clear: ls_msg.
          ls_msg-msgv1 = cs_logondata-class.
          ls_msg-msgty = lv_msgty.
          ls_msg-msgid = '01'.
          ls_msg-msgno = '518'.
          " User group & does not exist
          if 1 = 0. message e518(01) with ls_msg-msgv1. endif.

          if lv_msgty is not initial.
            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = iv_bname
                iv_nodename = if_identity_definition=>gc_node_logondata
                iv_field    = if_identity_definition=>gc_field_logondata_class
                iv_lifetime = lv_lifetime
                is_msg      = ls_msg.
          endif.
        endif.
      endif.
    endif.

    " -----------------------------------------
    " Authority check for user group assignment
    "
    if ev_reject_class eq if_identity=>co_false.
      case iv_modus.
        when go_persistence->co_ta_modus_create.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename  = if_identity_definition=>gc_node_logondata
              iv_field     = if_identity_definition=>gc_field_logondata_class
              iv_operation = cl_suid_tools=>co_activity_create
              iv_class     = cs_logondata-class
            importing
              es_msg       = ls_msg.

          " In Create mode: Auth. for role/profile/.. assignment must be checked
          if ls_msg-msgty ne 'E' and io_idref is bound.
            call method io_idref->auth_check_for_new_class
              exporting
                iv_new_class    = cs_logondata-class
                io_msg_buffer   = io_msg_buffer
              importing
                ev_reject_class = ev_reject_class.
          endif.

        when go_persistence->co_ta_modus_modify.
          if io_idref is bound.
            call method io_idref->get_class
              exporting
                iv_for_auth = if_identity=>co_false
              importing
                ev_class    = lv_class.
          endif.
          " No check if usergroup already assigned
          if ( io_idref is bound and lv_class ne cs_logondata-class ) or
               io_idref is not bound.
            call method cl_suid_tools=>auth_check_single
              exporting
                iv_nodename  = if_identity_definition=>gc_node_logondata
                iv_field     = if_identity_definition=>gc_field_logondata_class
                iv_operation = cl_suid_tools=>co_activity_update
                iv_class     = cs_logondata-class
              importing
                es_msg       = ls_msg.
          endif.
      endcase.

      if ls_msg-msgty    eq 'E'               or
         ev_reject_class eq if_identity=>co_true. "Authority check failed

        ev_reject_class = if_identity=>co_true.
        if ls_msg-msgty eq 'E'. " Add message if available
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_logondata
              iv_field    = if_identity_definition=>gc_field_logondata_class
              iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
              is_msg      = ls_msg.
        endif.

        " Successfull authorization check
      else.
        " ->>> CUA Idoc processing and SCUG !!!
        "      Create new user group if customizing switch requires it (checked above)
        if ls_new_usgrpt is not initial.
          append ls_new_usgrpt to lt_new_usgrpts.
        endif.

        if ls_new_usgrp is not initial.
          append ls_new_usgrp to lt_new_usgrps.

          cl_suid_tools=>create_new_usergroups(
              it_new_usgrps  = lt_new_usgrps
              it_new_usgrpts = lt_new_usgrpts  ).
        endif.
        " Usergroup is ok
        ev_class_checked = if_identity=>co_true.
      endif.
    endif.
  endif.

  "--- Check the Security Policy: SECURITY_POLICY
  "
  if ls_check-security_policy eq 'X'.
    if cs_logondata-security_policy is not initial.
      " existence check
      if 'X' <> cl_security_policy=>exists( cs_logondata-security_policy ).

        " No different logic with customizing switch in CUA case - always error message
        lv_msgty = if_suid_msg_buffer=>co_type_error.

        " Sicherheitsrichtlinie & existiert nicht
        if 1 = 0. message e001(security_policy) with cs_logondata-security_policy. endif.
        clear: ls_msg.
        ls_msg-msgty = lv_msgty.
        ls_msg-msgid = 'SECURITY_POLICY'.
        ls_msg-msgno = '001'.
        ls_msg-msgv1 = cs_logondata-security_policy.

        ev_reject_secpol = abap_true.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_logondata
            iv_field    = if_identity_definition=>gc_field_logondata_sec_policy
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = ls_msg.

      endif.
    endif.

    if ev_reject_secpol is initial. "policy exists

      ".. Authorization check
      " - On the first stage implement with direct check and not in cl_suid_tools=>auth_check_single.
      "   Because interface and buffering in auth_check_single is not fit for this check.
      " - For policy unassignment – check with dummy
      " - During user creation - no check for dummy value.

      if   iv_secpol_old ne cs_logondata-security_policy  " SU01: old sec_pol is supplied and new value differs from old one.
        or iv_secpol_old is not supplied.                 " SU10: old sec_pol is not supplied, simple check of new value

        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename         = if_identity_definition=>gc_node_logondata
            iv_field            = if_identity_definition=>gc_field_logondata_sec_policy
            iv_operation        = cl_suid_tools=>co_activity_update
            iv_secpol           = cs_logondata-security_policy
            iv_initial_as_dummy = if_identity=>co_true
          importing
            es_msg              = ls_msg.

        if ls_msg-msgty = 'E'.
          ev_reject_secpol = abap_true.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_logondata
              iv_field    = if_identity_definition=>gc_field_logondata_sec_policy
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
              is_msg      = ls_msg.
        endif.
      endif.
    endif.
  endif.

  "--- Check the user type: USTYP - set default if empty
  "
  if ls_check-ustyp eq 'X'.
    if cs_logondata-ustyp is initial.
      " Default values: User type = 'A' (dialog user) if neither filled nor provided
      cs_logondata-ustyp = co_usertype_dialog.          " Dialog user is default
      " Notification for default user type
      if io_notify is bound.
        call method io_notify->notify_create
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_logondata.
      endif.
    else.
      " Replace by call of helpvalues later.
      if 1 = 0. call method cl_suid_tools=>get_helpvalues. endif.

      call function 'DD_DOMVALUES_GET'
        exporting
          domname        = 'XUUSTYP'
        importing
          rc             = lv_subrc
        tables
          dd07v_tab      = lt_dd07v
        exceptions
          wrong_textflag = 1
          others         = 2.
      if sy-subrc <> 0 or lv_subrc <> 0.
        clear lt_dd07v.
      endif.
      read table lt_dd07v
           with key domvalue_l = cs_logondata-ustyp
           transporting no fields
           .
      if sy-subrc ne 0.
        clear: ls_msg.
        ls_msg-msgv1 = cs_logondata-ustyp.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '519'.
        " Invalid user type &
        if 1 = 0. message e519(01) with ls_msg-msgv1. endif.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_logondata
            iv_field    = if_identity_definition=>gc_field_logondata_ustyp
            is_msg      = ls_msg.
      endif.
    endif.
  endif.


  "--- Check Alias: USERALIAS
  " Check existence of entry for useralias in table USREFUS
  "
  if ls_check-useralias eq 'X'.
    if cs_logondata-useralias is not initial.
      set locale language sy-langu.
      translate cs_logondata-useralias to upper case.

      select single bname from  usrefus
                    into  lv_bnamealias
                    where bname     ne iv_bname
                      and useralias eq cs_logondata-useralias. "#EC *
      if sy-subrc eq 0.
        if lv_bnamealias ne iv_bname.
          clear: ls_msg.
          ls_msg-msgv1 = cs_logondata-useralias.
          ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '189'.
          " The alias & already exists
          if 1 = 0. message e189(01) with ls_msg-msgv1. endif.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = if_identity_definition=>gc_node_logondata
              iv_field    = if_identity_definition=>gc_field_logondata_useralias
              is_msg      = ls_msg.
        endif.
      endif.
    endif.
  endif.

  " === End: Check values =============================================


endmethod.


method check_organisation.

  data: lv_reject_assignment  type sesf_boolean
      , lv_org_node_id        type addr_node_id
      .


* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.


* Check node
  call method cl_identity=>adbp_check_organization
    exporting
      is_organization      = cs_organization
      io_msg_buffer        = go_anonymous_msg_buffer
    importing
      es_organization      = cs_organization
      ev_org_node_id       = lv_org_node_id
      ev_reject_assignment = lv_reject_assignment.

  if lv_reject_assignment eq if_identity=>co_true.
    return.
  endif.


  if iv_get_location          = if_identity=>co_true or
     iv_get_organization_name = if_identity=>co_true.

    call method adbp_read_org_address
      exporting
        iv_orgnum            = cs_organization-orgaddr
        iv_orgaddrid         = lv_org_node_id "cs_organization-orgaddrid
      changing
        es_location          = es_location
        es_organization_name = es_organization_name.

  endif.


endmethod.


method check_parameters.

  data: ls_msg            type          symsg
      , lt_check_param    type          suid_tt_node_parameters
      , lr_node_param     type ref to   suid_st_node_parameter
*     , lv_paramid        type          tpara-paramid
      , lv_lastparid      type          tpara-paramid
      , lv_tabix          type          sy-tabix
      .

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

* Check parameter
  clear: lv_lastparid.

  et_parameters = it_parameters.
  sort et_parameters by parid.

  loop at et_parameters reference into lr_node_param.

    lv_tabix = sy-tabix.

*...Ignore empty line
    if lr_node_param->parid is initial and
       lr_node_param->parva is initial.
      continue.
    endif.

*...Duplicate Parameter
    if lr_node_param->parid = lv_lastparid.
      clear: ls_msg.
      ls_msg-msgv1 = lr_node_param->parid.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '093'.
*     MSG: An entry already exists for parameter &
      if 1 = 0. message e093(01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_node_param->parid.
      call method go_anonymous_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ''
          iv_nodename   = if_identity_definition=>gc_node_parameter
          iv_key        = gv_macro_key
          iv_key_handle = lr_node_param->key_handle
          iv_field      = if_identity_definition=>gc_field_parameter_parid
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      lr_node_param->change_mode = if_identity=>co_failed_create.
      continue.
    else.

      lv_lastparid = lr_node_param->parid.
    endif.

*   Split et_param into lt_check_param and rest
    append lr_node_param->* to lt_check_param.
    delete et_parameters index lv_tabix.

  endloop.

* --- Check values ------------------------------------------
*
  call method cl_identity=>check_parameters_internal
    exporting
      iv_bname      = ''
      io_msg_buffer = go_anonymous_msg_buffer
    changing
      ct_parameters = lt_check_param.


* Add lt_check_groups to rest
  append lines of lt_check_param to et_parameters.
  sort et_parameters by parid.

* Read Parameter text (temporary)
  loop at et_parameters reference into lr_node_param
                        where parid is not initial.
    select single partext
         from tparat
         into lr_node_param->partxt
        where paramid  = lr_node_param->parid
          and  sprache = sy-langu.
  endloop.


endmethod.


method check_parameters_internal.
**********************************************************************
* 14.03.2008 D050920  Note
* - PRGN_CUST parameters CUA_USERGROUPS_CHECK with value 'I'(Ignore)
*   was treated as Information message.
* - PRGN_CUST parameters CUA_PARAMETER_CHECK should not be
*   checked in SU01 in CUA-target
**********************************************************************


  data: lr_parameter          type ref to   suid_st_node_parameter
      , lt_paramid            type          cl_suid_tools=>tt_parameter
      , ls_paramid            type          cl_suid_tools=>ty_parameter
      , lr_paramid            type ref to   cl_suid_tools=>ty_parameter
      , ls_msg                type          symsg
      , lv_msgty              type          symsg-msgty
      , lv_lifetime           type          if_suid_msg_buffer=>ty_msg_lifetime
      , lv_prgn_cust_value    type          prgn_cust-path
      .


* Something to do ?
  if ct_parameters is initial.
    return.
  endif.

*  ->>> Different error handling in CUA and SCUG !!!
* In CUA case check customizing switch settings
*  if gv_cua_active = if_identity=>co_true.
  if gv_cua_central = if_identity=>co_true or gv_idoc_processing = if_identity=>co_true.
    cl_suid_tools=>get_customizing_property(
      exporting
        iv_property_name  = cl_suid_tools=>co_cua_prgn_cust_parameter
      importing
        ev_property_value = lv_prgn_cust_value  ).

    case lv_prgn_cust_value.
      when 'E'.
        lv_msgty = if_suid_msg_buffer=>co_type_error.
      when 'S'.
        lv_msgty = if_suid_msg_buffer=>co_type_success.
      when 'I'.
        lv_msgty = space. " 'I' = ignore, not info-message.
      when others.
        lv_msgty = if_suid_msg_buffer=>co_type_warning.
    endcase.

* Non-CUA case or CUA-target
  else.
    lv_msgty = if_suid_msg_buffer=>co_type_error.
  endif.


* === Start: Check values =============================================
*

* Deletion is always possible
  loop at ct_parameters reference into lr_parameter.

    if lr_parameter->change_mode eq if_identity=>co_delete.
*     No further checks: Delete of node is possible
      continue.
    endif.

    ls_paramid = lr_parameter->parid.
    append ls_paramid to lt_paramid.
  endloop.

* Something to do ?
  if lt_paramid is initial.
    return.
  endif.

* Check existence
  call method cl_suid_tools=>check_exist_parameter
    changing
      ct_paramid = lt_paramid.


  loop at ct_parameters reference into lr_parameter
       where change_mode ne if_identity=>co_delete.

    read table lt_paramid reference into lr_paramid
         with key paramid = lr_parameter->parid
         binary search.
    if sy-subrc eq 0.
      if lr_paramid->notexist eq if_identity=>co_true.
*       Wrong parameter ID.

        clear: ls_msg.
        ls_msg-msgv1 = lr_parameter->parid.
        ls_msg-msgty = lv_msgty. ls_msg-msgid = '01'. ls_msg-msgno = '037'.
*       MSG: ParameterID & does not exist.
        if 1 = 0. message e037(01) with ls_msg-msgv1. endif.
        gv_macro_key = lr_parameter->parid.

*  ->>> Different error handling in CUA
*       In CUA case (central system or Idoc processing) check customizing switch settings
        if gv_cua_central = if_identity=>co_true or gv_idoc_processing = if_identity=>co_true.
*         Do not store entry in trx buffer
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

*         Insert not existing entry in central system and ignore in other cases
          if lr_parameter->change_mode = if_identity=>co_insert and gv_cua_central <> if_identity=>co_true.
            lr_parameter->change_mode = if_identity=>co_failed_create.
          endif.

*      Handling in other cases
        else.
          case lr_parameter->change_mode.
            when space.
              lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
            when if_identity=>co_insert.
*           Node creation failed: Do not store entry in trx buffer
*            delete ct_parameters index lv_tabix.
              lr_parameter->change_mode = if_identity=>co_failed_create.
              lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
            when if_identity=>co_update.
*           Update node
              lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
            when if_identity=>co_delete.
*           This case is handled above
          endcase.
        endif.

*       In case of SU10 Check, always use lifetime_once
        if iv_bname is initial.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

*       Attention: lr_parameter is no longer valid!

        if lv_msgty is not initial.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_parameter
              iv_key        = gv_macro_key
              iv_key_handle = lr_parameter->key_handle
              iv_field      = if_identity_definition=>gc_field_parameter_parid
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

        continue.
      endif.
    else.
*     Cache must be filled
      raise exception type cx_suid_identity
        exporting
          textid    = cx_suid_identity=>internal_error.
    endif.

  endloop.


endmethod.


method check_profiles.

  data: lt_profiles           type suid_tt_node_profiles
      , ls_usergroup          type cl_suid_tools=>ty_groups
      .

  " Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

  " initialize exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  " Check class: If class does not exist -> Dummy check
  ls_usergroup-usergroup = iv_class.
  call method cl_suid_tools=>check_exist_groups
    changing
      cs_usergroup = ls_usergroup.
  if ls_usergroup-notexist eq if_identity=>co_true.
    clear: ls_usergroup-usergroup.
  endif.

  lt_profiles = it_profiles.
  if lt_profiles is not initial.
    " eliminate duplicates and empty profiles from input values
    call method cl_identity=>check_profiles_internal
      exporting
        iv_bname      = space
        iv_class      = ls_usergroup-usergroup
        io_msg_buffer = go_anonymous_msg_buffer
      changing
        ct_profiles   = lt_profiles.

    call method cl_suid_role_helper=>add_external_profile_state
      exporting
        iv_get_profile_text = if_identity=>co_true
      changing
        ct_user_profile     = lt_profiles.
  endif.

  clear et_profiles.
  et_profiles = lt_profiles.

endmethod.


method check_profiles_internal.
**********************************************************************
* check_cua_profiles_internal implements following functionality: ..................
*   - delete entries with empty profile names
*   - delete entries with empty system names
*   - existence check of profiles
*   - eliminate duplicate entries
*   - complete messages for roles and profiles
**********************************************************************
* 10.01.2008 C5032002  Note 1131220
*
*  -If method is called with IV_ALLOW_GENERATED_PROFILES = 'X'
*   (via call of SET_PFUD_PROFILES)
*   the behavior must be similar to method PFOFILE_ADJUST.
*   It must not be any error messages except missing-authority.
*   If generated profiles does not exist this should not leads
*   to an error message.
*
*   In FM PRGN_ACTIVITY_GROUP_USERPROFS we call SET_PFUD_PROFILES
*   method. The results life-time-one errors are transformed into
*   exception AUTHORITY_INCOMPLETE.
*   As a results message 225(01) "Generated profile not exist"  will
*   leads to confusing message
*   426(S#) "You are not authorized to adjust user master recs"
*
* - If in DB is stored non-existing profile do not remove it
*  automatically, but only show the error message.

* 26.02.2008 D050920  Note 1116083
* - Add parameter IV_PERMIT. Do not check authority when
*   deleting central system assignment.
* - Correct checkman warnings for bad logical expression: "1 = 0"
**********************************************************************

  constants:
        co_no_activity        type int1 value 255.

  data: lv_msg_key_value      type          string
      , lv_msg_data           type          symsg
      , lr_profile            type ref to   suid_st_node_profile
      , lv_tabix              like          sy-tabix
      , lv_name               type          string
      , lv_prof_torso         type          ust04-profile
      , lv_operation          type          suid_node_activity
      , lt_hashed_profiles    type hashed table of suid_st_node_profile
                                   with unique key profile change_mode
      .

  sort ct_profiles by profile change_mode.

  " --- check change mode and initial profiles
  loop at ct_profiles reference into lr_profile.

    " remember index
    lv_tabix = sy-tabix.

    " check value of change_mode: only insert, delete and space are allowed
    case lr_profile->change_mode.
      when if_identity=>co_insert.
      when if_identity=>co_delete.
      when if_identity=>co_unchanged.
      when others.
        " Wrong change mode
        if 1 = 0. message e047(s#) . endif.                 "#EC *
        clear: lv_msg_data.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_info.
        lv_msg_data-msgid = 'S#'.
        lv_msg_data-msgno = '047'.

        lv_msg_key_value = lr_profile->profile.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_profile_profile
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        " Ignore wrong mode
        delete ct_profiles index lv_tabix.
        continue.
    endcase.

    " -- ignore entries with empty profile_name
    if lr_profile->profile is initial.
      if 1 = 0. message w255(s#) with lr_profile->profile. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.

      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = 'S#'.
      lv_msg_data-msgno = '255'.
      lv_msg_data-msgv1 = lr_profile->profile.

      lv_msg_key_value = lr_profile->profile.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_profile_profile
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if io_notify is supplied and lr_profile->change_mode eq if_identity=>co_insert.
        call method io_notify->notify_failed_create
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_profile->key_handle.
      endif.

      " Ignore empty profile
      delete ct_profiles index lv_tabix.
      continue. "go ahead with next profile
    endif.

    " Convert to upper case
    lv_name             = lr_profile->profile.
    lr_profile->profile = cl_suid_tools=>to_upper_case( lv_name ).
  endloop.


  " --- existence check and authorizations check of profiles
  call method cl_suid_role_helper=>add_external_profile_state
    changing
      ct_user_profile = ct_profiles.

  loop at ct_profiles reference into lr_profile.
    lv_tabix = sy-tabix.

    " eliminate non-existing profiles
    if lr_profile->aktps is initial.

      " check if profile should be deleted
      if lr_profile->change_mode ne if_identity=>co_delete.

        " provide error message
        if 1 = 0. message w255(s#) with lr_profile->profile. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.

        lv_msg_key_value  = lr_profile->profile.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = 'S#'.
        lv_msg_data-msgno = '255'.
        lv_msg_data-msgv1 = lr_profile->profile.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_profile_profile
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        " send insert failed notification
        if lr_profile->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_profile->key_handle.
          endif.
          " Keep line: Insert failed
          lr_profile->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_profile->change_mode.
        endif.
      endif.
      " Invalid profiles to be deleted are processed without further checks.
      continue. "go ahead with next profile

    elseif lr_profile->aktps eq 'P'.
      " check if profile is active
      " check if profile should be deleted
      if lr_profile->change_mode ne if_identity=>co_delete.

        " provide error message
        if 1 = 0. message w225(01) with lr_profile->profile. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.

        lv_msg_key_value  = lr_profile->profile.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '01'.
        lv_msg_data-msgno = '225'.
        lv_msg_data-msgv1 = lr_profile->profile.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_profile_profile
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        " send insert failed notification
        if lr_profile->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_profile->key_handle.
          endif.
          " Keep line: Insert failed
          lr_profile->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_profile->change_mode.
        endif.
        continue. "go ahead with next profile
      endif.
    endif.

    " allow to set generated profiles if PFUD is running:
    " consistency checks need to add/delete generated profiles
    " if a role has been modified meanwhile
    if iv_allow_generated_profiles eq if_identity=>co_false.
      if lr_profile->type eq if_identity~co_prof_type_generated. "'G'.

        case lr_profile->change_mode.
            " in case a generated profile should be inserted
            " provide error message
          when if_identity=>co_insert.
            if 1 = 0. message w864(01) with lr_profile->profile. endif. "#EC *
            clear: lv_msg_data, lv_msg_key_value.

            lv_msg_key_value  = lr_profile->profile.
            lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
            lv_msg_data-msgid = '01'.
            lv_msg_data-msgno = '864'.
            lv_msg_data-msgv1 = lr_profile->profile.

            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_profile->key_handle
                iv_field      = if_identity_definition=>gc_field_profile_profile
                iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
                is_msg        = lv_msg_data.

            " send insert failed notification
            if io_notify is supplied.
              call method io_notify->notify_failed_create
                exporting
                  iv_bname      = iv_bname
                  iv_nodename   = if_identity_definition=>gc_node_profile
                  iv_key        = lv_msg_key_value
                  iv_key_handle = lr_profile->key_handle.
            endif.

            " Keep line: Insert failed
            lr_profile->change_mode = if_identity=>co_failed_create.

            continue. "go ahead with next profile

            " in case a generated profile should be deleted
            " provide error message
          when if_identity=>co_delete.
            if 1 = 0. message w023(suid01) with lr_profile->profile. endif. "#EC *
            clear: lv_msg_data, lv_msg_key_value.

            lv_msg_key_value  = lr_profile->profile.
            lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
            lv_msg_data-msgid = 'SUID01'.
            lv_msg_data-msgno = '023'.
            lv_msg_data-msgv1 = lr_profile->profile.

            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_profile
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_profile->key_handle
                iv_field      = if_identity_definition=>gc_field_profile_profile
                iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
                is_msg        = lv_msg_data.

            " Keep line: Change failed
            clear: lr_profile->change_mode.

            continue. "go ahead with next profile
          when others. "nothing to do
        endcase.
      endif.

    else.
      " Only assign generated profiles
      if lr_profile->type ne if_identity~co_prof_type_generated. "'G'.
        if not ( lr_profile->aktps is initial and lr_profile->change_mode eq if_identity=>co_delete ).
          " Ignore profile
          delete ct_profiles index lv_tabix.
          continue.
        endif.
      endif.
    endif.


    " --- authority check
    " do not check authority if iv_permit is true:
    " needed for deletion of CUA systems
    if iv_permit eq if_identity=>co_false.
      case lr_profile->change_mode.
        when if_identity=>co_insert.
          lv_operation = cl_suid_tools=>co_activity_create.
        when if_identity=>co_update.
          lv_operation = cl_suid_tools=>co_activity_update.
        when if_identity=>co_delete.
          lv_operation = cl_suid_tools=>co_activity_delete.
        when others. " handles empty entry like no authority check
          lv_operation = co_no_activity.
      endcase.

      if lv_operation ne co_no_activity.
        " Get torso, if necessary
        if lr_profile->type eq if_identity~co_prof_type_generated. "'G'. "Generated
          lv_prof_torso = lr_profile->profile(10).
        else. "'S'ingle,'C'omposite
          lv_prof_torso = lr_profile->profile.
        endif.

        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename  = if_identity_definition=>gc_node_profile
            iv_operation = lv_operation
            iv_class     = iv_class
            iv_profile   = lv_prof_torso
            iv_bname     = iv_bname
          importing
            es_msg       = lv_msg_data.

        if lv_msg_data-msgty eq 'E'.
          " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &2 zum Profil &1
          if 1 = 0. message e638(01) with lr_profile->profile iv_class. endif. "#EC *
          clear: lv_msg_key_value.

          lv_msg_key_value  = lr_profile->profile.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_profile
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_profile->key_handle
              iv_field      = if_identity_definition=>gc_field_profile_profile
              is_msg        = lv_msg_data
              iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

          " send insert failed notification
          if lr_profile->change_mode eq if_identity=>co_insert.
            if io_notify is supplied.
              call method io_notify->notify_failed_create
                exporting
                  iv_bname      = iv_bname
                  iv_nodename   = if_identity_definition=>gc_node_profile
                  iv_key        = lv_msg_key_value
                  iv_key_handle = lr_profile->key_handle.
            endif.
            " Keep line: Insert failed
            lr_profile->change_mode = if_identity=>co_failed_create.
          else.
            " Keep line: Change failed
            clear: lr_profile->change_mode.
          endif.
          continue.
        endif.
      endif.
    endif.


    " Duplicate entries: insert into hashed table
    insert lr_profile->* into table lt_hashed_profiles.
    if sy-subrc ne 0.
      " MSG: Das Profil &1 ist bereits zugeordnet
      if 1 = 0. message e062(suid01) with lr_profile->profile. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = 'SUID01'.
      lv_msg_data-msgno = '062'.
      lv_msg_data-msgv1 = lr_profile->profile.

      lv_msg_key_value = lr_profile->profile.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_profile_profile
          is_msg        = lv_msg_data
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      " send insert failed notification
      if lr_profile->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_profile
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_profile->key_handle.
        endif.
        " Keep line: Insert failed
        lr_profile->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_profile->change_mode.
      endif.
      continue.
    endif.
  endloop.

  clear lt_hashed_profiles.

endmethod.


method check_reference_user.

  data: ls_usergroup            type        cl_suid_tools=>ty_groups
      .

  " Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

  " Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  " Check class: If class does not exist -> Dummy check
  ls_usergroup-usergroup = iv_class.
  call method cl_suid_tools=>check_exist_groups
    changing
      cs_usergroup = ls_usergroup.
  if ls_usergroup-notexist eq if_identity=>co_true.
    clear: ls_usergroup-usergroup.
  endif.

  call method cl_identity=>check_reference_user_internal
    exporting
      iv_class              = ls_usergroup-usergroup
      io_msg_buffer         = go_anonymous_msg_buffer
    changing
      cs_new_reference_user = cs_reference_user.

endmethod.


method check_reference_user_internal.

  data: lv_string                 type          string
      , ls_bname                  type          suid_st_bname
      , lt_bname                  type          suid_tt_bname
      , lt_identity_exist         type          suid_tt_identity
      , lv_msg_data               type          symsg
      , lv_msg_key_value          type          string
      , lv_is_reference_user      type          sesf_boolean
      , lv_value                  type          prgn_cust-path
      , lv_msg_type               type          symsgty

      , ls_field_filter           type          suid_st_cua_filters
      , lv_maint_cua_role         type          sesf_boolean
      , lv_maint_cua_profile      type          sesf_boolean

      , lt_ust04                  type          suid_tt_ust04
      , lr_ust04                  type ref to   ust04
      , lt_new_ref_user_profiles  type          suid_tt_ust04
      , lt_old_ref_user_profiles  type          suid_tt_ust04
      , lt_cua_profiles           type          suid_tt_usl04
      , lr_cua_profiles           type ref to   usl04
      , lt_new_ref_user_cua_prof  type          suid_tt_usl04
      , lt_old_ref_user_cua_prof  type          suid_tt_usl04
      , lv_is_profile_authorized  type          i

      , lt_agr_users              type          suid_tt_agr_users
      , lr_agr_users              type ref to   agr_users
      , lt_new_ref_user_agrs      type          suid_tt_agr_users
      , lt_old_ref_user_agrs      type          suid_tt_agr_users
      , lt_cua_roles              type          suid_tt_usla04
      , lr_cua_roles              type ref to   usla04
      , lt_new_ref_user_cua_agrs  type          suid_tt_usla04
      , lt_old_ref_user_cua_agrs  type          suid_tt_usla04
      , lv_is_role_authorized     type          i
      .

  " initialize return value
  ev_is_authorized = if_identity=>co_false.

  " ----- Check existence of user  ------------------------------------
  "
  if cs_old_reference_user is not initial.
    lv_string                      = cs_old_reference_user-refuser.
    cs_old_reference_user-refuser  = cl_suid_tools=>to_upper_case( lv_string ).
    ls_bname-bname = cs_old_reference_user-refuser.
    insert ls_bname into table lt_bname.
  endif.

  if cs_new_reference_user is not initial.
    clear ls_bname.
    lv_string                      = cs_new_reference_user-refuser.
    cs_new_reference_user-refuser  = cl_suid_tools=>to_upper_case( lv_string ).
    ls_bname-bname = cs_new_reference_user-refuser.
    insert ls_bname into table lt_bname.
  endif.

  if lt_bname is initial.
    return.
  else.
    sort lt_bname.
    delete adjacent duplicates from lt_bname.
  endif.

  " Existence check
  call method go_persistence->if_suid_persistence_query~existence_check
    exporting
      it_bname          = lt_bname
    importing
      et_identity_exist = lt_identity_exist.


  " New reference user must exist
  if cs_new_reference_user-refuser is not initial.
    read table lt_identity_exist
         with key bname = cs_new_reference_user-refuser
         transporting no fields.
    if sy-subrc ne 0.
      " Referenzbenutzer &1 existiert nicht
      if 1 = 0. message e339(01) with cs_new_reference_user-refuser. endif.
      clear: lv_msg_data, lv_msg_key_value.

      lv_msg_key_value    = cs_new_reference_user-refuser.
      lv_msg_data-msgty   = 'E'.
      lv_msg_data-msgid   = '01'.
      lv_msg_data-msgno   = '339'.
      lv_msg_data-msgv1   = cs_new_reference_user-refuser.

      " provide Lifetime once message
      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = if_identity_definition=>gc_node_reference_user
          iv_key      = lv_msg_key_value
          iv_field    = if_identity_definition=>gc_field_reference_user
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = lv_msg_data.

      " do not accept a non-existing user
      return.
    endif.
  endif.


  " ---- Check correct type of reference user  ------------------------
  "
  if cs_new_reference_user-refuser is not initial and
     iv_use_ext_node               eq if_identity=>co_false. " No check in create

    call method cl_suid_role_helper=>is_reference_user
      exporting
        iv_bname             = cs_new_reference_user-refuser
      importing
        ev_is_reference_user = lv_is_reference_user.

    " Error handling
    if lv_is_reference_user eq if_identity=>co_false.
      " read customization of message type
      call method cl_suid_tools=>get_customizing_property
        exporting
          iv_property_name  = cl_suid_tools=>co_prgn_cust_ref_user_check
        importing
          ev_property_value = lv_value.

      if lv_value is not initial.
        case lv_value.
          when 'W'. lv_msg_type = 'W'.
          when 'E'. lv_msg_type = 'E'.
          when 'S'. lv_msg_type = 'S'.
          when 'I'. clear lv_msg_type.
          when others. lv_msg_type = 'W'.
        endcase.
      else.
        lv_msg_type = 'W'.
      endif.

      if lv_msg_type is not initial.
        " Benutzer &1 ist kein Referenzbenutzer (siehe Langtext)
        if 1 = 0. message s391(01) with cs_new_reference_user-refuser. endif.
        clear: lv_msg_data, lv_msg_key_value.

        lv_msg_key_value    = cs_new_reference_user-refuser.
        lv_msg_data-msgty   = lv_msg_type .
        lv_msg_data-msgid   = '01'.
        lv_msg_data-msgno   = '391'.
        lv_msg_data-msgv1   = cs_new_reference_user-refuser.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = if_identity_definition=>gc_node_reference_user
            iv_key      = lv_msg_key_value
            iv_field    = if_identity_definition=>gc_field_reference_user
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = lv_msg_data.

        " if MSG_TYPE is error: Refuser is not accepted
        if lv_msg_type eq 'E'.
          return.
        endif.
      endif.
    endif.
  endif.


  " --- Check CUA environment -------
  "

  if gv_cua_central eq if_identity=>co_true.
    ls_field_filter-node_name = if_identity_definition=>gc_node_cua_role.
    " Get CUA filter for roles
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_field_filter.
    if ls_field_filter-field_attr eq if_suid_cua_runtime=>gc_global.
      lv_maint_cua_role = if_identity=>co_true.
    endif.
    clear: ls_field_filter.
    ls_field_filter-node_name = if_identity_definition=>gc_node_cua_profile.
    " Get CUA filter for profiles
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_field_filter.
    if ls_field_filter-field_attr eq if_suid_cua_runtime=>gc_global.
      lv_maint_cua_profile = if_identity=>co_true.
    endif.
  endif.


  " --- Read roles and profiles for reference users -------
  "
  move lt_identity_exist to lt_bname.

  if lines( lt_bname ) gt 0.
    " read roles from DB
    call method cl_suid_role_helper=>read_roles_from_db
      exporting
        it_bname         = lt_bname
        iv_read_cua_role = lv_maint_cua_role
      importing
        et_roles         = lt_agr_users
        et_cua_roles     = lt_cua_roles.

    " Sort into old and new reference user roles
    loop at lt_agr_users reference into lr_agr_users.
      if lr_agr_users->uname eq cs_new_reference_user-refuser.
        insert lr_agr_users->* into table lt_new_ref_user_agrs.
      elseif lr_agr_users->uname eq cs_old_reference_user-refuser.
        insert lr_agr_users->* into table lt_old_ref_user_agrs.
      endif.
    endloop.
    " Sort into old and new reference user cua roles
    loop at lt_cua_roles reference into lr_cua_roles.
      if lr_cua_roles->bname eq cs_new_reference_user-refuser.
        insert lr_cua_roles->* into table lt_new_ref_user_cua_agrs.
      elseif lr_cua_roles->bname eq cs_old_reference_user-refuser.
        insert lr_cua_roles->* into table lt_old_ref_user_cua_agrs.
      endif.
    endloop.

    " read profiles from DB
    call method cl_suid_role_helper=>read_profiles_from_db
      exporting
        it_bname            = lt_bname
        iv_read_cua_profile = lv_maint_cua_profile
      importing
        et_profiles         = lt_ust04
        et_cua_profiles     = lt_cua_profiles.

    " Sort into old and new reference user profiles
    loop at lt_ust04 reference into lr_ust04.
      if lr_ust04->bname eq cs_new_reference_user-refuser.
        insert lr_ust04->* into table lt_new_ref_user_profiles.
      elseif lr_ust04->bname eq cs_old_reference_user-refuser.
        insert lr_ust04->* into table lt_old_ref_user_profiles.
      endif.
    endloop.
    " Sort into old and new reference user cua profiles
    loop at lt_cua_profiles reference into lr_cua_profiles.
      if lr_cua_profiles->bname eq cs_new_reference_user-refuser.
        insert lr_cua_profiles->* into table lt_new_ref_user_cua_prof.
      elseif lr_cua_profiles->bname eq cs_old_reference_user-refuser.
        insert lr_cua_profiles->* into table lt_old_ref_user_cua_prof.
      endif.
    endloop.
  endif.


  " --- Authority check for role assignment -------
  "
  call method roles_check_authority
    exporting
      it_old_roles     = lt_old_ref_user_agrs
      it_new_roles     = lt_new_ref_user_agrs
      it_old_cua_roles = lt_old_ref_user_cua_agrs
      it_new_cua_roles = lt_new_ref_user_cua_agrs
      iv_bname         = iv_bname
      iv_class         = iv_class
      iv_ext_nodename  = iv_ext_nodename
      iv_ext_field     = iv_ext_field
      iv_use_ext_node  = iv_use_ext_node
      iv_ext_lifetime  = iv_ext_lifetime
      io_msg_buffer    = io_msg_buffer
    receiving
      rv_authorized    = lv_is_role_authorized.


  " --- Authority check for profile assignment -------
  "
  call method profile_check_delta_authority
    exporting
      it_old_profiles            = lt_old_ref_user_profiles
      it_new_profiles            = lt_new_ref_user_profiles
      iv_check_generated_profile = lv_maint_cua_profile
      it_old_cua_profiles        = lt_old_ref_user_cua_prof
      it_new_cua_profiles        = lt_new_ref_user_cua_prof
      iv_bname                   = iv_bname
      iv_class                   = iv_class
      iv_ext_nodename            = iv_ext_nodename
      iv_ext_field               = iv_ext_field
      iv_use_ext_node            = iv_use_ext_node
      iv_ext_lifetime            = iv_ext_lifetime
      io_msg_buffer              = io_msg_buffer
    receiving
      rv_authorized              = lv_is_profile_authorized.


  " --- Result of authority checks -------
  "
  if lv_is_profile_authorized eq 1 and
     lv_is_role_authorized    eq 1.
    ev_is_authorized = if_identity=>co_true.
  endif.


endmethod.


method check_refuser_delete_internal.
  " - Deletion of users may lead into inconsistencies if the deleted
  "   user is still in use as reference user.
  " - The content of iv_system (filled or empty) indicates if it will
  "   be a CUA or non-CUA case.
  " - EV_VALID will be abap_false & an according message will be added
  "   if the user is still in use.
  "--------------------------------------------------------------------

  data:
     lv_is_used              type                sesf_boolean
    ,lv_logsys               type                t000-logsys
    ,lv_central_logsys       type                t000-logsys
    ,lv_msg_data             type                symsg
    ,lv_msg_key_value        type                string
    ,ls_node_filter          type                suid_st_cua_filters
    .

  "--- initialization steps -------------------------------------------
  "initialize return value
  ev_valid      = if_identity=>co_false.
  eo_msg_buffer = go_msg_buffer.

  "delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = iv_bname
      iv_nodename          = iv_node_name
      iv_lifetimeonce_only = if_identity=>co_true.


  "--- preliminary checks ---------------------------------------------
  if ( not iv_system is initial ).
    "1. CUA case ......................................................
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
      importing
        ev_system_logsys     = lv_logsys
        ev_central_logsys    = lv_central_logsys
        .

    if ( gv_cua_active = if_identity=>co_false ).
      "1.a. Wrong call: iv_system is provided but no CUA is active

      lv_msg_key_value = iv_bname.

      clear: lv_msg_data.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '381'.
      lv_msg_data-msgv1 = lv_logsys.
      "System &1 is not part of Central User Administration
      if 1 = 0. message e381(01) with lv_msg_data-msgv1. endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = iv_node_name
          iv_key      = lv_msg_key_value
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = lv_msg_data.

      return.

    endif.   "iv_system is provided but no CUA is active


    if ( gv_cua_central = if_identity=>co_false ).
      "1.b. function was called within a CUA child system

      lv_msg_key_value = iv_bname.

      clear: lv_msg_data.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '351'.
      "You have not logged onto the central system
      if 1 = 0. message e351(01). endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = iv_node_name
          iv_key      = lv_msg_key_value
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent
          is_msg      = lv_msg_data.

      return.

    else.
      "1.c. function was called within the CUA central system
      if ( iv_system <> lv_central_logsys ).

        "i.  An additional check for iv_system is part of the current
        "    landscape isn't necessary in case of deletion.

        "ii. Check SCUM settings
        "    An additional check for referencing users is necessary only
        "    if it is set to 'Global' for reference users.
        ls_node_filter-node_name = if_identity_definition=>gc_node_reference_user.
        call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
          changing
            cs_field_filter = ls_node_filter.

        if ls_node_filter-field_attr <> if_suid_cua_runtime=>gc_global.
          ev_valid = if_identity=>co_true.
          return.
        endif.   "SCUM settings for refuser not Global

      endif.   "a child system assignment shell be deleted

    endif.   "CUA child system

  endif.   "CUA case?

  "--- main check -----------------------------------------------------
  "... Non-CUA & CUA central system having SCUM = 'Global' can be   ...
  "... handled identically.                                         ...
  lv_is_used = cl_suid_tools=>check_referencing_users( iv_bname = iv_bname ).

  if lv_is_used = if_identity=>co_true.

    lv_msg_key_value = iv_bname.

    clear: lv_msg_data.
    lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
    lv_msg_data-msgid = '01'.
    lv_msg_data-msgno = '662'.
    lv_msg_data-msgv1 = iv_bname.
    "Deletion not possible. User & is in use as reference user.
    if 1 = 0. message e662(01) with lv_msg_data-msgv1. endif.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = iv_bname
        iv_nodename = iv_node_name
        iv_key      = lv_msg_key_value
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = lv_msg_data.

  else.   "lv_is_used = if_identity=>co_false.
    ev_valid = if_identity=>co_true.
  endif.

endmethod.


method check_roles.

  data: lt_roles                type        suid_tt_node_roles
      , lr_role                 type ref to suid_st_node_role
      , lr_child_role           type ref to suid_st_node_role
      , ls_role_detail          type        suid_st_node_role_detail
      , lt_parent_role          type        suid_tt_role_name
      , ls_role_name            type        suid_st_role_name
      , lr_role_member          type ref to suid_st_node_role_member
      , ls_role                 type        suid_st_node_role
      , lt_collective_roles     type        suid_tt_node_roles
      , lv_tabix                type        sy-tabix
      , ls_usergroup            type        cl_suid_tools=>ty_groups
      .

  clear: et_roles, et_role_details, et_role_members.

  " Always refresh anonymous msg buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

  " Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  " Check class: If class does not exist -> Dummy check
  ls_usergroup-usergroup = iv_class.
  call method cl_suid_tools=>check_exist_groups
    changing
      cs_usergroup = ls_usergroup.
  if ls_usergroup-notexist eq if_identity=>co_true.
    clear: ls_usergroup-usergroup.
  endif.

  lt_roles = it_roles.

  sort lt_roles by agr_name from_dat to_dat.
  delete adjacent duplicates from lt_roles .

  " separate and delete roles which are assigned as part of a collective role
  loop at lt_roles reference into lr_role.
    lv_tabix = sy-tabix.
    if lr_role->agr_assign_type = if_identity=>co_agr_assign_type_coll.
      insert lr_role->* into table lt_collective_roles.
      delete lt_roles index lv_tabix.
    endif.
  endloop.

  call method cl_identity=>check_roles_internal
    exporting
      iv_bname      = space
      iv_class      = ls_usergroup-usergroup
      io_msg_buffer = go_anonymous_msg_buffer
    changing
      ct_roles      = lt_roles.

  " check for additional role information: text and parent_child
  if lines( lt_roles ) > 0.
    loop at lt_roles reference into lr_role.
      ls_role_name-agr_name  = lr_role->agr_name.
      insert ls_role_name into table lt_parent_role.
    endloop.

    " always get role members
    " --- provide additional info of parent role in node of role -------------------
    call method roles_add_parent_information
      exporting
        it_role_name  = lt_parent_role
      importing
        et_node_roles = et_role_members.

    if et_role_members is not initial.

      delete adjacent duplicates from et_role_members.

      " add members to result list
      loop at et_role_members reference into lr_role_member.

        " get parent entry
        loop at lt_roles reference into lr_role
          where agr_name = lr_role_member->parent_role.

          " check separated lt_collective_roles
          read table lt_collective_roles with key
              agr_name = lr_role_member->child_role
              from_dat = lr_role->from_dat
              to_dat   = lr_role->to_dat
              reference into lr_child_role.
          if sy-subrc = 0.
            insert lr_child_role->* into table lt_roles.
          else.
            clear ls_role.
            ls_role-agr_name        = lr_role_member->child_role.
            ls_role-from_dat        = lr_role->from_dat.
            ls_role-to_dat          = lr_role->to_dat.
            ls_role-agr_assign_type = if_identity=>co_agr_assign_type_coll.
            insert ls_role into table lt_roles.
          endif.

        endloop.

      endloop.
    endif.

    sort lt_roles by agr_name from_dat to_dat.
    delete adjacent duplicates from lt_roles .

    loop at lt_roles reference into lr_role.
      clear: ls_role_detail.
      ls_role_detail-agr_name  = lr_role->agr_name.
      insert ls_role_detail into table et_role_details.
    endloop.

    if iv_get_role_details eq if_identity~co_true.
      " --- Read text of roles --------------------------------
      call method roles_add_text
        changing
          ct_node_roles = et_role_details.
    endif.

    " --- always read type of roles --------------------------------
    call method roles_add_type
      changing
        ct_node_roles = et_role_details.

  endif.

  et_roles = lt_roles.

endmethod.


method check_roles_internal.
**********************************************************************
* check_cua_roles_internal implements following functionality: ..................
*   - delete entries with empty role names
*   - verification of from_dat and to_dat
*   - check if interval [from_dat, to_dat] is valid
*   - invalid values of change_mode are ignored.
*   - existence check of roles
*   - eliminate duplicate entries
*   - complete messages for roles and profiles
**********************************************************************

  constants: co_no_activity   type int1 value 255.

  data: lv_msg_key_value      type                 string
      , lv_msg_data           type                 symsg
      , lv_rc                 type                 int1
      , lr_node_role          type ref to          suid_st_node_role
      , ls_node_role          type                 suid_st_node_role
      , lv_tabix              type                 sy-tabix
      , lt_existing_roles     type                 suid_tt_node_roles
      , lv_name               type                 string
      , lv_operation          type                 suid_node_activity
      , lt_hashed_roles       type hashed table of suid_st_node_role
                              with unique key agr_name from_dat to_dat agr_assign_type change_mode
      .


  " --- check change mode and initial profiles
  loop at ct_roles reference into lr_node_role.
    " remember index
    lv_tabix = sy-tabix.

    " check value of change_mode
    case lr_node_role->change_mode.
      when if_identity=>co_insert.
      when if_identity=>co_delete.
      when if_identity=>co_update.
      when if_identity=>co_unchanged.
      when others.
        " Wrong change mode
        if 1 = 0. message e047(s#) . endif.                 "#EC *
        clear: lv_msg_data.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_info.
        lv_msg_data-msgid = 'S#'.
        lv_msg_data-msgno = '047'.                          "or i311

        concatenate lr_node_role->agr_name lr_node_role->from_dat
          lr_node_role->to_dat into lv_msg_key_value respecting blanks.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_field      = if_identity_definition=>gc_field_role_agr_name
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        " Ignore wrong mode
        delete ct_roles index lv_tabix.
        continue.
    endcase.

    " -- ignore entries with empty role_names
    if lr_node_role->agr_name is initial.
      if 1 = 0. message w216(s#) with lr_node_role->agr_name. endif. "#EC *
      clear: lv_msg_data, lv_msg_key_value.

      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = 'S#'.
      lv_msg_data-msgno = '216'.
      lv_msg_data-msgv1 = lr_node_role->agr_name.

      concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
        into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if io_notify is supplied and lr_node_role->change_mode eq if_identity=>co_insert.
        call method io_notify->notify_failed_create
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle.
      endif.

      " Ignore empty profile
      delete ct_roles index lv_tabix.
      continue. "go ahead with next role
    endif.


    " -- Child roles are not supposed to be changed - ignore change_mode
    if lr_node_role->agr_assign_type eq 'C'.
      clear: lr_node_role->change_mode.
    endif.

    " Convert to upper case
    lv_name                = lr_node_role->agr_name.
    lr_node_role->agr_name = cl_suid_tools=>to_upper_case( lv_name ).
  endloop.

  " Define sort order: Unchanged, Delete, Update, insert
  loop at ct_roles reference into lr_node_role.
    replace if_identity=>co_insert in lr_node_role->change_mode with 'Z'.
  endloop.
  sort ct_roles by change_mode agr_name from_dat to_dat agr_assign_type.
  loop at ct_roles reference into lr_node_role.
    replace 'Z' in lr_node_role->change_mode with if_identity=>co_insert.
  endloop.


  " --- existence check and authorizations check of profiles
  call method cl_suid_role_helper=>check_existence_role_node
    exporting
      it_role_name       = ct_roles
    importing
      et_role_name_exist = lt_existing_roles.

  loop at ct_roles reference into lr_node_role.
    " remember index
    lv_tabix = sy-tabix.

    " set from_dat
    if lr_node_role->from_dat is initial.
      lr_node_role->from_dat = sy-datum.

    elseif lr_node_role->from_dat < cl_suid_tools=>co_lowest_date.
      lr_node_role->from_dat = cl_suid_tools=>co_lowest_date.

    else.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = lr_node_role->from_dat
        importing
          e_boolean = lv_rc.
      if lv_rc ne 0.
        if 1 = 0. message e302(00) with lr_node_role->from_dat. endif. "#EC *
        "send message for invalid from_dat
        clear: lv_msg_data, lv_msg_key_value.

        concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
          into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '00'.
        lv_msg_data-msgno = '302'.
        lv_msg_data-msgv1 = lr_node_role->from_dat.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_field      = if_identity_definition=>gc_field_role_from_dat
            is_msg        = lv_msg_data.

        " send insert failed notification
        if lr_node_role->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_role->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_role->change_mode.
        endif.
        continue.
      endif.
    endif.

    " set to_dat
    if lr_node_role->to_dat is initial.
      lr_node_role->to_dat = cl_suid_tools=>co_highest_date.

    else.
      call method cl_suid_tools=>is_valid_date
        exporting
          i_date    = lr_node_role->to_dat
        importing
          e_boolean = lv_rc.
      if lv_rc ne 0.
        if 1 = 0. message e302(00) with lr_node_role->to_dat. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.

        concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
          into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '00'.
        lv_msg_data-msgno = '302'.
        lv_msg_data-msgv1 = lr_node_role->to_dat.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_field      = if_identity_definition=>gc_field_role_to_dat
            is_msg        = lv_msg_data.

        " send insert failed notification
        if lr_node_role->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_role->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_role->change_mode.
        endif.
        continue.
      endif.
    endif.

    " check interval [from_dat, to_dat]
    if lr_node_role->from_dat > lr_node_role->to_dat.

      if 1 = 0. message e105(01) with lr_node_role->from_dat lr_node_role->to_dat. endif. "#EC *
      " send message for invalid interval
      clear: lv_msg_data, lv_msg_key_value.
      concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
        into lv_msg_key_value respecting blanks.

      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = '01'.
      lv_msg_data-msgno = '105'.
      write lr_node_role->from_dat to lv_msg_data-msgv1.
      write lr_node_role->to_dat   to lv_msg_data-msgv2.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          iv_field      = if_identity_definition=>gc_field_role_to_dat
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_role->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_role->change_mode.
      endif.
      continue.
    endif.

    " only in case the role should be updated
    if lr_node_role->change_mode eq if_identity=>co_update.
      " set UPDATE_FROM_DAT
      if lr_node_role->update_from_dat is initial.
        lr_node_role->update_from_dat = sy-datum.

      elseif lr_node_role->update_from_dat < cl_suid_tools=>co_lowest_date.
        lr_node_role->update_from_dat = cl_suid_tools=>co_lowest_date.

      else.
        call method cl_suid_tools=>is_valid_date
          exporting
            i_date    = lr_node_role->update_from_dat
          importing
            e_boolean = lv_rc.
        if lv_rc ne 0.
          if 1 = 0. message e302(00) with lr_node_role->update_from_dat. endif. "#EC *
          "send message for invalid from_dat
          clear: lv_msg_data, lv_msg_key_value.

          concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
            into lv_msg_key_value respecting blanks.

          lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
          lv_msg_data-msgid = '00'.
          lv_msg_data-msgno = '302'.
          lv_msg_data-msgv1 = lr_node_role->update_from_dat.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle
              iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
              iv_field      = if_identity_definition=>gc_field_role_from_dat
              is_msg        = lv_msg_data.

          " Keep line: Change failed
          clear: lr_node_role->change_mode.

          continue.
        endif.
      endif.

      " set UPDATE_TO_DAT
      if lr_node_role->update_to_dat is initial.
        lr_node_role->update_to_dat = cl_suid_tools=>co_highest_date.

      else.
        call method cl_suid_tools=>is_valid_date
          exporting
            i_date    = lr_node_role->update_to_dat
          importing
            e_boolean = lv_rc.
        if lv_rc ne 0.
          if 1 = 0. message e302(00) with lr_node_role->update_to_dat. endif. "#EC *
          clear: lv_msg_data, lv_msg_key_value.

          concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
            into lv_msg_key_value respecting blanks.

          lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
          lv_msg_data-msgid = '00'.
          lv_msg_data-msgno = '302'.
          lv_msg_data-msgv1 = lr_node_role->update_to_dat.

          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle
              iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
              iv_field      = if_identity_definition=>gc_field_role_to_dat
              is_msg        = lv_msg_data.

          " Keep line: Change failed
          clear: lr_node_role->change_mode.

          continue.
        endif.
      endif.

      " check interval [update_from_dat, update_to_dat]
      if lr_node_role->update_from_dat > lr_node_role->update_to_dat.

        if 1 = 0. message e105(01) with lr_node_role->update_from_dat lr_node_role->update_to_dat. endif. "#EC *
        " send message for invalid interval
        clear: lv_msg_data, lv_msg_key_value.
        concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
          into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = '01'.
        lv_msg_data-msgno = '105'.
        lv_msg_data-msgv1 = lr_node_role->update_from_dat.
        lv_msg_data-msgv2 = lr_node_role->update_to_dat.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_field      = if_identity_definition=>gc_field_role_to_dat
            is_msg        = lv_msg_data.

        " Keep line: Change failed
        clear: lr_node_role->change_mode.

        continue.
      endif.
    endif.

    " -- Existence check: Role
    read table lt_existing_roles
         with key agr_name = lr_node_role->agr_name
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " -- Role does not exist
      check lr_node_role->change_mode ne if_identity=>co_delete.

      if 1 = 0. message w216(s#) with lr_node_role->agr_name. endif. "#EC *
      " Die Rolle & ist nicht vorhanden
      clear: lv_msg_data, lv_msg_key_value.
      lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      lv_msg_data-msgid = 'S#'.
      lv_msg_data-msgno = '216'.
      lv_msg_data-msgv1 = lr_node_role->agr_name.

      concatenate lr_node_role->agr_name lr_node_role->from_dat
        lr_node_role->to_dat into lv_msg_key_value respecting blanks.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " send insert failed notification
      if lr_node_role->change_mode eq if_identity=>co_insert.
        if io_notify is supplied.
          call method io_notify->notify_failed_create
            exporting
              iv_bname      = iv_bname
              iv_nodename   = if_identity_definition=>gc_node_role
              iv_key        = lv_msg_key_value
              iv_key_handle = lr_node_role->key_handle.
        endif.
        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
      else.
        " Keep line: Change failed
        clear: lr_node_role->change_mode.
      endif.
      continue. "go ahead with next role

    else.
      " --  authority check
      " do not check authority if iv_permit is true:
      " needed for deletion of CUA systems
      if iv_permit eq if_identity=>co_false.
        case lr_node_role->change_mode.
          when if_identity=>co_insert.
            lv_operation = cl_suid_tools=>co_activity_create.
          when if_identity=>co_update.
            lv_operation = cl_suid_tools=>co_activity_update.
          when if_identity=>co_delete.
            lv_operation = cl_suid_tools=>co_activity_delete.
          when others. " handles empty entry like no authority check
            lv_operation = co_no_activity.
        endcase.

        if lv_operation ne co_no_activity.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename  = if_identity_definition=>gc_node_role
              iv_operation = lv_operation
              iv_class     = iv_class
              iv_bname     = iv_bname
              iv_role      = lr_node_role->agr_name
            importing
              es_msg       = lv_msg_data.

          if lv_msg_data-msgty eq 'E'.
            " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &2 zur Rolle &1
            if 1 = 0. message e639(01) with lr_node_role->agr_name iv_class. endif. "#EC *
            clear: lv_msg_key_value.

            concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
              into lv_msg_key_value respecting blanks.

            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle
                iv_field      = if_identity_definition=>gc_field_role_agr_name
                is_msg        = lv_msg_data
                iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

            " send insert failed notification
            if lr_node_role->change_mode eq if_identity=>co_insert.
              if io_notify is supplied.
                call method io_notify->notify_failed_create
                  exporting
                    iv_bname      = iv_bname
                    iv_nodename   = if_identity_definition=>gc_node_role
                    iv_key        = lv_msg_key_value
                    iv_key_handle = lr_node_role->key_handle.
              endif.
              " Keep line: Insert failed
              lr_node_role->change_mode = if_identity=>co_failed_create.
            else.
              " Keep line: Change failed
              clear: lr_node_role->change_mode.
            endif.
            continue.
          endif.
        endif.
      endif.

      " --  Duplicate entries: insert into hashed table
      if lr_node_role->change_mode eq if_identity=>co_update.
        ls_node_role          = lr_node_role->*.
        ls_node_role-from_dat = lr_node_role->update_from_dat.
        ls_node_role-to_dat   = lr_node_role->update_to_dat.
        insert ls_node_role into table lt_hashed_roles.
      else.
        insert lr_node_role->* into table lt_hashed_roles.
      endif.
      if sy-subrc ne 0.
        " MSG: Die Rolle &1 ist bereits zugeordnet
        if 1 = 0. message e060(suid01) with lr_node_role->agr_name. endif. "#EC *
        clear: lv_msg_data, lv_msg_key_value.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = 'SUID01'.
        lv_msg_data-msgno = '060'.
        lv_msg_data-msgv1 = lr_node_role->agr_name.

        concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_field      = if_identity_definition=>gc_field_role_agr_name
            is_msg        = lv_msg_data
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

        " send insert failed notification
        if lr_node_role->change_mode eq if_identity=>co_insert.
          if io_notify is supplied.
            call method io_notify->notify_failed_create
              exporting
                iv_bname      = iv_bname
                iv_nodename   = if_identity_definition=>gc_node_role
                iv_key        = lv_msg_key_value
                iv_key_handle = lr_node_role->key_handle.
          endif.
          " Keep line: Insert failed
          lr_node_role->change_mode = if_identity=>co_failed_create.
        else.
          " Keep line: Change failed
          clear: lr_node_role->change_mode.
        endif.
        continue.
      endif.
    endif.
  endloop.

  clear lt_hashed_roles.

endmethod.


method check_root.
**********************************************************************
* Check-method for ROOT-node. Used on initial screen of SU10.
* Check existence and authority see also INSTANTIATION_BY_MODE method
**********************************************************************
  data: lr_bname              type ref to suid_st_bname
      , lt_bname              type        suid_tt_bname
      , ls_msg                type        symsg
      , lt_identity_exist     type        suid_tt_identity
      , lt_identity_not_exist type        suid_tt_identity
      , lt_bname_exist        type        suid_tt_bname
      , lt_bname_not_exist    type        suid_tt_bname
      .
  field-symbols: <lt_bname>       type suid_tt_bname
                .

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

*--- Transaction mode valid? ------------------------------------------*
  if    iv_modus ne go_persistence->co_ta_modus_create
    and iv_modus ne go_persistence->co_ta_modus_modify
    and iv_modus ne go_persistence->co_ta_modus_display
    and iv_modus ne go_persistence->co_ta_modus_delete
    .
    raise exception type cx_suid_identity
      exporting
        textid   = cx_suid_identity=>internal_error
        ta_modus = iv_modus.
  endif.

  lt_bname = it_bname. " IT_BNAME may not be changed

  set locale language sy-langu.
*--- First perform some checks on imported Identity IDs ---------------*
  loop at lt_bname reference into lr_bname.
    if lr_bname->bname is initial.
      clear: ls_msg.
*     ls_msg-msgv1 = lr_bname->bname.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '279'.
      if 1 = 0. message e279(01). endif.

      call method go_anonymous_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_bname->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.

*     Delete empty usernames
      delete lt_bname.
      continue.
    endif.

*...Upper case conversion
    translate lr_bname->bname to upper case.
  endloop.
  " If single user was given: lt_bname is empty now
  check: lt_bname is not initial.
*--- Existence check --------------------------------------------------*
  call method go_persistence->if_suid_persistence_query~existence_check
    exporting
      it_bname              = lt_bname
    importing
      et_identity_exist     = lt_identity_exist
      et_identity_not_exist = lt_identity_not_exist.

  move lt_identity_exist     to lt_bname_exist.
  move lt_bname_exist        to et_bname_exist.
  move lt_identity_not_exist to lt_bname_not_exist.
  move lt_bname_not_exist    to et_bname_not_exist.

*...Create mode: lt_bname_exist should be empty
  if iv_modus = go_persistence->co_ta_modus_create.
    if lt_bname_exist is not initial.
      loop at lt_bname_exist reference into lr_bname.
        clear: ls_msg.
        ls_msg-msgv1 = lr_bname->bname.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '224'.
*       User & already exists
        if 1 = 0. message e224(01) with ls_msg-msgv1. endif.

        call method go_anonymous_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = lr_bname->bname
            iv_nodename = if_identity_definition=>gc_node_root
            iv_field    = if_identity_definition=>gc_field_root_bname
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = ls_msg.
      endloop.
    endif.
  else.      "--- Not in create mode!
*...Modify, Display or Delete mode: lt_bname_not_exist should be empty
    if lt_bname_not_exist is not initial.
      loop at lt_bname_not_exist reference into lr_bname.
        clear: ls_msg.
        ls_msg-msgv1 = lr_bname->bname.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '124'.
*       User & does not exist
        if 1 = 0. message e124(01) with ls_msg-msgv1. endif.

        call method go_anonymous_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = lr_bname->bname
            iv_nodename = if_identity_definition=>gc_node_root
            iv_field    = if_identity_definition=>gc_field_root_bname
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = ls_msg.
      endloop.
    endif.
  endif.

*--- Depending on mode: -----------------------------------------------*
*      - Decide for table (lt_bname_exist OR lt_bname_not_exist) for:
*          => Authority check
*          => Enqueue Identities
*          => Constructor

  case iv_modus.
    when go_persistence->co_ta_modus_create.
      assign lt_bname_not_exist to <lt_bname>.
    when go_persistence->co_ta_modus_modify.
      assign lt_bname_exist to <lt_bname>.
    when go_persistence->co_ta_modus_display.
      assign lt_bname_exist to <lt_bname>.
    when go_persistence->co_ta_modus_delete.
      assign lt_bname_exist to <lt_bname>.
    when others.
*     does not apply: Modus was checked at the beginning of this method
  endcase.


*--- Authority check --------------------------------------------------*
* Basic auth check because we do not bnow the class to perform
* auth check for every user.

  case iv_modus.
    when go_persistence->co_ta_modus_create.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_root
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = space "No class in create-mode
        importing
          es_msg       = ls_msg.
    when go_persistence->co_ta_modus_modify.
      call method cl_identity=>node_authority_check
        exporting
          iv_node_name        = iv_node_name
          iv_transaction_mode = iv_modus
          iv_class            = space
        importing
          es_msg              = ls_msg.
    when go_persistence->co_ta_modus_display.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_root
          iv_operation = cl_suid_tools=>co_activity_retrieve
          iv_class     = space
        importing
          es_msg       = ls_msg.
    when go_persistence->co_ta_modus_delete.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_root
          iv_operation = cl_suid_tools=>co_activity_delete
          iv_class     = space
        importing
          es_msg       = ls_msg.

  endcase.

  if ls_msg-msgty = 'E'. "Authority check failed
* add all user to not_auth table
    et_bname_not_authorized = <lt_bname>.

    call method go_anonymous_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = space
        iv_nodename = if_identity_definition=>gc_node_root
        iv_field    = if_identity_definition=>gc_field_root_bname
        iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
        is_msg      = ls_msg.
    clear <lt_bname>.
  endif.

  et_bname = <lt_bname>.
endmethod.


method check_techuser_data.

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.

* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.

  call method check_techuser_data_internal
    exporting
      io_msg_buffer     = go_anonymous_msg_buffer
      it_check_fields   = it_check_fields
    changing
      cs_tech_user_data = cs_tech_user_data.

endmethod.


method check_techuser_data_internal.
  data ls_msg type symsg.
* Check node
* --- Check values ------------------------------------------
*
  data lr_field type ref to suid_node_field.
  loop at it_check_fields reference into lr_field.
    case lr_field->*.
      when if_identity_definition=>gc_field_techuser_responsible.

        if cs_tech_user_data-responsible is not initial.
*         Existence check, check also for person ???
          data lv_bname type xubname.
          select single bname from usr02 into lv_bname
                 where bname = cs_tech_user_data-responsible.
          if sy-subrc ne 0.
            clear: ls_msg.
            ls_msg-msgv1 = cs_tech_user_data-responsible.
            ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'.
            ls_msg-msgno = '003'.
*           MSG: Der Benutzer &1 existiert nicht.
            if 1 = 0. message e003(suid01) with ls_msg-msgv1. endif.

            io_msg_buffer->add_object_message_symsg(
              exporting
                iv_bname    = iv_bname
                iv_nodename =
                    if_identity_definition=>gc_node_tech_user_data
                iv_field    =
                 if_identity_definition=>gc_field_techuser_responsible
                is_msg      = ls_msg ).
          endif.
        endif.
    endcase.
  endloop.

endmethod.


method CHECK_UCLASS.

* Always refresh anonymous msg buffer and notification buffer
  call method go_anonymous_msg_buffer->delete_all_object_messages.


* Exporting parameter
  eo_anonymous_msg_buffer = go_anonymous_msg_buffer.


* Check node
  call method cl_identity=>check_uclass_internal
    exporting
      iv_nodename   = if_identity_definition=>gc_node_uclass
      iv_bname      = ''
      io_msg_buffer = go_anonymous_msg_buffer
    changing
      cs_uclass     = cs_uclass.

endmethod.


method check_uclass_internal.
* Check local License data
*
* Parameter IV_CUA_CASE = CO_TRUE if method is called to check License data assignment in central system
* In this case parameters IV_CENTRAL_SYSTEM and IV_KEY_HANDLE are also required

* ToDo
* !!! Meldungen müssen noch überarbeitet werden !!!
*
* GC_NODE_UCLASS - GC_FIELD_UCLASS_LIC_TYPE (LIC_TYPE)
*   E250(BV)           - User type &1 is unknown
*   E008(LAW_MESSAGES) - User type & is not active
* GC_NODE_UCLASS - GC_FIELD_UCLASS_SUB_FROM  (SUBSTITUTE_FROM)
*   E256(BV)           - Specify the period of the substitution
*   E257(BV)           - The period for the substitution is invalid
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_UCLASS - GC_FIELD_UCLASS_SUB_UNTIL (SUBSTITUTE_UNTIL)
*   E256(BV)           - Specify the period of the substitution
*   E017(BV)           - &1 is in the past
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_UCLASS - GC_FIELD_UCLASS_SYSID     (SYSID)
*   E258(BV)           - Specify "&1" as the system of the substituted user
*   E261(BV)           - The name of the system with the chargeable user is missing
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_UCLASS - GC_FIELD_UCLASS_CLIENT    (CLIENT)
*   E259(BV)           - Specify "&1" as the client of the substituted user
*   E262(BV)           - The client with the chargeable user in system &1 is missing
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_UCLASS - GC_FIELD_UCLASS_BNAME_CHARGE (BNAME_CHARGEABLE)
*   E263(BV)           - Specify the user ID of the chargeable user
*   E753(01)           - User identical to substitute
*   E260(BV)           - Substitued user &1 does not exist
*   E088(BV)           - User type 11 in the same system/client is not permitted
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_NODE_UCLASS - GC_FIELD_UCLASS_SPEC_VERS    (SPEC_VERS)
*   E252(BV)           - Specification of a special version is not permitted for user type &1
*   E253(BV)           - Special version and country surcharge are not permitted simultaneously
*   E251(BV)           - Special version &1 is unknown
* GC_NODE_UCLASS - GC_FIELD_UCLASS_SURCHARGE    (COUNTRY_SURCHARGE)
*   E249(BV)           - Specification of a country surcharge for user type &1 is not permitted
*   E254(BV)           - The country surcharge may not be smaller than -100%
*   E255(BV)           - The country surcharge cannot be larger than 999 %


  data: ls_msg           type symsg
      , ls_tutypa        type tutypa
      , ls_tutypnow      type tutypnow                      "#EC NEEDED
      , ls_tuzus         type tuzus                         "#EC NEEDED
      , lv_key           type suid_node_key
      , lv_lifetime      type if_suid_msg_buffer=>ty_msg_lifetime
      .


* ---------------------------------------------------------------------
* ----- Check the user type -------------------------------------------
*
* Is there any classification => we don't have to check this parameter.
  if cs_uclass-lic_type is initial or cs_uclass-lic_type = '00'.
    return.
  endif.

  if iv_cua_case = if_identity=>co_true and iv_central_system is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname  = iv_bname.
  endif.

  lv_key = iv_central_system.

*     In case of SU10 Check, always use lifetime_once
  if iv_bname is initial.
    lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
  else.
    lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
  endif.


* ---- Check definition of user type ---------------------------
  select single * into ls_tutypa
           from tutypa
          where usertyp = cs_uclass-lic_type.
  if sy-subrc <> 0.
*   MSG: User type &1 is unknown
    clear: ls_msg.
    ls_msg-msgv1 = cs_uclass-lic_type.
    ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '250'.
    if 1 = 0. message e250(bv) with ls_msg-msgv1. endif.

    if iv_cua_case = if_identity=>co_false.
      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = iv_bname
          iv_nodename = iv_nodename
          iv_field    = if_identity_definition=>gc_field_uclass_lic_type
          is_msg      = ls_msg
          iv_lifetime = lv_lifetime.
    else.
      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = iv_bname
          iv_nodename   = iv_nodename
          iv_key        = lv_key
          iv_key_handle = iv_key_handle
          iv_field      = if_identity_definition=>gc_field_uclass_lic_type
          is_msg        = ls_msg
          iv_lifetime   = lv_lifetime.
    endif.

    return.
  endif.


* ---- Check whether the user type is active ----------------
*    select * into ls_tutypnow
*             from tutypnow up to 1 rows
*             where usertyp = cs_uclass-lic_type.
*    endselect.
*    if sy-subrc <> 0.
    if space = cl_suid_tools=>check_active_uclass( cs_uclass-lic_type ).
*   MSG: User type & is not active
      clear: ls_msg.
      ls_msg-msgv1 = cs_uclass-lic_type.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '003'.
      if 1 = 0. message e003(bv) with ls_msg-msgv1. endif.

      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_lic_type
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_lic_type
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

      return.
    endif.


* ---------------------------------------------------------------------
* Check the special conditions for user types
*
    call method uclass_check_spec_conditions
      exporting
        iv_nodename   = iv_nodename
        iv_bname      = iv_bname
        io_msg_buffer = io_msg_buffer
        is_uclass     = cs_uclass
        iv_cua_case   = iv_cua_case
        iv_subsystem  = iv_central_system
        iv_key_handle = iv_key_handle.


* ---------------------------------------------------------------------
* Check the special version
*
    if cs_uclass-spec_vers ne space and cs_uclass-spec_vers ne '00'.

*...Check whether a special version is allowed for this user type.
      if ls_tutypa-sondervers    is initial.
*     MSG: Specification of a special version is not permitted for user type &1
        clear: ls_msg.
        ls_msg-msgv1 = cs_uclass-lic_type.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '252'.
        if 1 = 0. message e252(bv) with ls_msg-msgv1. endif.

        if iv_cua_case = if_identity=>co_false.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = iv_nodename
              iv_field    = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg      = ls_msg
              iv_lifetime = lv_lifetime.
        else.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.
      endif.

*     Check whether both a special version and a country surcharge were
*     specified.
      if cs_uclass-country_surcharge ne 0.
*       MSG: Special version and country surcharge are not permitted simultaneously
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '253'.
        if 1 = 0. message e253(bv). endif.

        if iv_cua_case = if_identity=>co_false.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = iv_nodename
              iv_field    = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg      = ls_msg
              iv_lifetime = lv_lifetime.
        else.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.
      endif.

*   Check existence of the special version
      select * into ls_tuzus
               from tuzus up to 1 rows
               where sondervers = cs_uclass-spec_vers.
      endselect.
      if sy-subrc <> 0.
*     MSG: Special version &1 is unknown
        clear: ls_msg.
        ls_msg-msgv1 = cs_uclass-spec_vers.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '251'.
        if 1 = 0. message e251(bv) with ls_msg-msgv1. endif.

        if iv_cua_case = if_identity=>co_false.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = iv_nodename
              iv_field    = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg      = ls_msg
              iv_lifetime = lv_lifetime.
        else.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_spec_vers
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.
      endif.

    endif.                               " if special version specified


* ---------------------------------------------------------------------
* Check the country surcharge
*
    if cs_uclass-country_surcharge <> 0.
*     Check whether a country surcharge is allowed for this user type.
      if ls_tutypa-country    is initial .
*       MSG: Specification of a country surcharge for user type &1 is not permitted
        clear: ls_msg.
        ls_msg-msgv1 = cs_uclass-lic_type.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '249'.
        if 1 = 0. message e249(bv) with ls_msg-msgv1. endif.

        if iv_cua_case = if_identity=>co_false.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = iv_nodename
              iv_field    = if_identity_definition=>gc_field_uclass_surcharge
              is_msg      = ls_msg
              iv_lifetime = lv_lifetime.
        else.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_surcharge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

*     Range check
      elseif cs_uclass-country_surcharge lt -100.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '254'.
*       MSG: The country surcharge may not be smaller than -100%
        if 1 = 0. message e254(bv). endif.

        if iv_cua_case = if_identity=>co_false.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = iv_nodename
              iv_field    = if_identity_definition=>gc_field_uclass_surcharge
              is_msg      = ls_msg
              iv_lifetime = lv_lifetime.
        else.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_surcharge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

      elseif cs_uclass-country_surcharge > 999.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '255'.
*       MSG: The country surcharge cannot be larger than 999 %
        if 1 = 0. message e255(bv). endif.

        if iv_cua_case = if_identity=>co_false.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = iv_bname
              iv_nodename = iv_nodename
              iv_field    = if_identity_definition=>gc_field_uclass_surcharge
              is_msg      = ls_msg
              iv_lifetime = lv_lifetime.
        else.
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_surcharge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

      endif.
    endif.


  endmethod.


method class_constructor.

  " Early Watch Mandant: Adresspflege wird inaktiviert
  constants: co_earlywatchmandt like sy-mandt value '066'.

  data: lv_shadow           type gsugi_pa-w_istatus
      .

  if sy-mandt eq co_earlywatchmandt.
    gv_earlywatchclient = if_identity=>co_true.
  endif.

  " determine if upgrade is in process
  call function 'UPG_IS_SHADOW_SYSTEM'
    importing
      ev_shadow = lv_shadow.

  if lv_shadow is initial.
    gv_upg_is_shadow_system = if_identity=>co_false.
  else.
    gv_upg_is_shadow_system = if_identity=>co_true.
    " This setting is also done in method SET_UNIT_TEST_MODE. See comment there.
  endif.


  " Create link to persistence class
  call method cl_identity_persistence=>get_instance
    importing
      ecl_persistence = go_persistence.

  " Is CUA active? Is system central or child?
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_cua_active  = gv_cua_active
      ev_cua_central = gv_cua_central
      ev_cua_child   = gv_cua_child.


  " Class is a mandatory field
  call method cl_suid_tools=>check_user_grp_required
    importing
      ev_active = gv_class_is_required.


  " Create message log class
  if go_msg_buffer is initial.
    create object go_msg_buffer.
  endif.

  " Create notification buffer
  if go_notify is initial.
    create object go_notify.
  endif.

  " Create anonymous message log class
  if go_anonymous_msg_buffer is initial.
    create object go_anonymous_msg_buffer.
  endif.

** In ESI darf dieses Ereignis nicht registriert werden.
** -> Methoden nach commit oder rollback werden von ESI gerufen !
*  SET HANDLER cl_identity=>catch_txn_finished.

endmethod.


method cleanup.

* Clean up all instances

  data: lr_control              type ref to ty_control
      , lr_bname                type ref to suid_st_bname
      , lv_esi_instance_exists  type        sesf_boolean
      .

  lv_esi_instance_exists = if_identity=>co_false.

  "We need to check ALL instances (independent from it_bname) if they are handled via ESI_Person,
  "because cl_bup_transaction_api=>cleanup would also do the whole cleanup for all active BP instances.
  loop at gt_control reference into lr_control. "Cleanup all instances
    if ( lr_control->idref->ms_segment_address-actadd-trx_with_bp = co_trx_bp ).
      lv_esi_instance_exists = if_identity=>co_true.
      exit. "one is enough
    endif.
  endloop.

  if it_bname is not initial.
    " check: it_bname is not initial. "Else: ==========> Jump to ENDMETHOD
    loop at it_bname reference into lr_bname.   "Cleanup given instances
      read table gt_control reference into lr_control
        with key bname = lr_bname->bname
        binary search.
      if sy-subrc = 0.
        call method lr_control->idref->cleanup_single.
      endif.
    endloop.
  else.
    loop at gt_control reference into lr_control. "Cleanup all instances
      call method lr_control->idref->cleanup_single.
    endloop.
  endif.

  if ( lv_esi_instance_exists = if_identity=>co_false ).
    cl_bup_transaction_api=>cleanup( ).
  endif.

  " clean up invalid_(cua)role_assignments
  clear:   mt_invalid_role_assignment
         , mt_invalid_cua_role_assignment
         .

  " clean up invalid_(cua)profile_assignments
  clear:   mt_invalid_profile_assignment
         , mt_invalid_cua_prof_assignment
          .

  " Cleanup of role and profile cache
  if gt_control is initial.
    call method cl_suid_role_helper=>cleanup.
    call method cl_suid_tools=>cleanup.
  endif.

  " Cleanup BAdI
  clear: mo_badi_identity_check.


endmethod.


method cleanup_single.
* Clear all segments
* Clear transaction mode, set transaction status to Invalid
* Remove reference from control table GT_CONTROL

  data: lv_bname                 type        xubname
      , lt_office_users          type        bcsy_user
      , lo_addr_main             type ref to cl_addr_main
      , lo_prop_handler          type ref to cl_suid_property_handler
      , lv_prop_is_initialized   type        sesf_boolean
      , lt_bname                 type        susr_t_ususers
      .

* ---- Dequeue Identity -----------------------------------------------*
  release_enqueue_lock( iv_release_optimistic_lock = if_identity=>co_true ).

* ---- Clear address data ---------------------------------------------*
* SAP Office
  if ms_segment_address-status = go_persistence->co_seg_changed.
    append ms_manager-bname to lt_office_users.
    call method cl_so_office_user_address=>cancel
      exporting
        it_users = lt_office_users.
  endif.

* BAS
  if iv_ignore_bas eq abap_false.
    if ms_segment_address-actadd-bas_wp_node_id is not initial.
      append ms_segment_address-actadd-bas_wp_node_id to ms_segment_address-actadd-changed_bas_workplace_node_id.
    endif.
    if ms_segment_address-actadd-changed_bas_workplace_node_id is not initial.
      lo_addr_main = cl_addr_main=>get_instance( ).
      call method lo_addr_main->reset_modifications
        exporting
          it_address_id = ms_segment_address-actadd-changed_bas_workplace_node_id.
      call method lo_addr_main->cleanup
        exporting
          it_address_id = ms_segment_address-actadd-changed_bas_workplace_node_id.
    endif.
  endif.

* BP Reset
  call method me->bp_reset_modification
    exporting
      iv_do_cleanup = 'X'.

* Reset Certmap enqueue
  call method cl_suid_tools=>dequeue_certmap_for_user
    exporting
      iv_bname            = ms_manager-bname
    changing
      it_certmap_enqueued = mt_certmap_enqueued.


* ---- Clear all segments ---------------------------------------------*
  clear_segments( iv_keep_header = ' ' ).

* ---- If personalization data is involved: Clear respective buffer ---*
  if ms_manager-flg_pers_modified = go_persistence->co_flag_active.
    call method cl_pers_service=>clear_instances.
  endif.

* ---- If appl. references are involved: Clear respective buffer ------*
  if ms_manager-flg_appref_modified = go_persistence->co_flag_active.
    append ms_manager-bname to lt_bname.
    call method cl_suid_applref=>cleanup( it_bname = lt_bname ).
  endif.

** ---- If SAP Easy Access Menu copy is involved -----------------------*
*  if ms_manager-easy_access_copied is not initial.
*    call function 'PRGN_USER_TABLES_RESET_BUFFER'.
*  endif.

*   ---- Adapt instance manager -----------------------------------------*
  lv_bname = ms_manager-bname. " Remember Identity ID
  clear: ms_manager.   " This includes all node status flags

* invalidate instance and remove from gt_control list
  ms_manager-bname  = lv_bname. " Keep information about ID and status
  ms_manager-status = go_persistence->co_ta_status_invalid.
*---- Remove entry in control table ----------------------------------*
  read table gt_control with key bname = ms_manager-bname
    binary search
    transporting no fields.
  if sy-subrc = 0.
    delete gt_control index sy-tabix.
  endif.

* ---- Clear all messages and notifications ---------------------------*
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname = ms_manager-bname.

  call method go_notify->delete_notifications
    exporting
      iv_bname = ms_manager-bname.

* ---- Clear Property Handler -----------------------------------------*

  lv_prop_is_initialized = cl_suid_property_handler=>is_initialized( ).

  if lv_prop_is_initialized = if_identity=>co_true.
    lo_prop_handler = cl_suid_property_handler=>get_instance( ).
    lo_prop_handler->delete_identity_entry( io_identity = me ).
  endif.

endmethod.


method clear_node_status.

*...Clear node status
  clear: ms_manager-sn_logondata
      , ms_manager-sn_defaults
      , ms_manager-sn_snc
      , ms_manager-sn_password
      , ms_manager-sn_pwdhash
      , ms_manager-sn_lockdata
      , ms_manager-sn_roles
      , ms_manager-sn_profiles
      , ms_manager-sn_parameter
      , ms_manager-sn_groups
      , ms_manager-sn_certmap
      , ms_manager-sn_dbms_user
      , ms_manager-sn_dbms_roles
      , ms_manager-sn_uclass
      , ms_manager-sn_cua_systems
      , ms_manager-sn_cua_roles
      , ms_manager-sn_cua_profiles
      , ms_manager-sn_cua_uclass
      , ms_manager-sn_cua_password
      , ms_manager-sn_refuser
      , ms_manager-sn_tech_user
      , ms_manager-sn_tech_user_data
      , ms_manager-sn_organization
      , ms_manager-sn_person_name
      , ms_manager-sn_workplace
      , ms_manager-sn_person
      , ms_manager-sn_telephone
      , ms_manager-sn_facsimile
      , ms_manager-sn_email
      , ms_manager-sn_web
      , ms_manager-sn_telex
      , ms_manager-sn_teletex
      , ms_manager-sn_remote_mail
      , ms_manager-sn_x400
      , ms_manager-sn_printer
      , ms_manager-sn_ssf
      , ms_manager-sn_pager
      .

  " Clear additional status data
  ms_manager-class_checked = if_identity=>co_false.

endmethod.


method clear_segments.
*...Clear all segments

  clear:
       ms_segment_address
     , ms_segment_auditlog
     , ms_segment_cua_roles
     , ms_segment_cua_systems
     , ms_segment_cua_user_prot
     , ms_segment_defaults
     , ms_segment_groups
     , ms_segment_header_hist
     , ms_segment_parameter
     , ms_segment_printparam
     , ms_segment_cua_profiles
     , ms_segment_profiles_r04
     , ms_segment_profiles_r04_hist
     , ms_segment_profiles_t04
     , ms_segment_pwdhistory
     , ms_segment_refuser
     , ms_segment_roles
     , ms_segment_snc
     , ms_segment_uclass
     , ms_segment_cua_uclasses
     , ms_segment_cua_password
     , ms_segment_userstamp
     , ms_segment_cua_act_distr
     , ms_segment_certmap
     , ms_segment_dbms_user
     .
  if iv_keep_header <> 'X'.
    clear: ms_segment_header.
  else.
    clear: ms_segment_header-initial_password.
  endif.

endmethod.


method constructor.
*
* Create a new Identity instance
* - Header segment: Must be passed to constructor for Modify, Display, Delete
*                   Must NOT be passed to constructor for Create
* - Important fields:
*   - ms_segment_header-BNAME               -> Identity ID
*   - ms_segment_header-STATUS              -> Actual buffer is unchanged/unchecked
*   - ms_segment_header-before_image-status -> Entry exists on DB (value 'Filled')

*----------------------------------------------------------------------------


* Set instance manager
  ms_manager-bname   = iv_bname.
  ms_manager-modus   = iv_modus.             " DISPLAY, CREATE, MODIFY, DELETE
  ms_manager-enqmode = iv_enq_mode.         " Enqueue mode

  if gv_cua_active = if_identity=>co_true.
    mv_cua_mode = iv_cua_mode.
  endif.

*----------------------------------------------------------------------------
* Evaluate modus and prepare header segment accordingly
  case ms_manager-modus.

*...---- Create identity ----------------------------------------------------
    when go_persistence->co_ta_modus_create.

*.....Create header segment: Before Image always is empty
      ms_segment_header-bname        = ms_manager-bname.                      " Identity ID
      ms_manager-status              = go_persistence->co_ta_status_unchecked. " Identity is changed
      ms_segment_header-actual-bname = ms_manager-bname.                      " Set BNAME
      ms_segment_header-status       = go_persistence->co_seg_changed.

      set_cua_attributes( iv_cua_mode = iv_cua_mode ).

      if is_header is not initial.                         " Header data must not be passed for CREATE
        raise exception type cx_suid_identity
          exporting
            textid    = cx_suid_identity=>internal_error
            bname     = ms_manager-bname
            ta_modus  = ms_manager-modus
            .
      endif.


*...---- Modify identity: Both Before and Actual Image are filled -----------
    when go_persistence->co_ta_modus_modify.

*.....Create header segment
      ms_segment_header-bname              = ms_manager-bname.                " Identity ID
      ms_manager-status                    = go_persistence->co_ta_status_unchanged. " Identity is not yet changed
      ms_segment_header-before_image-bname = ms_manager-bname.                " Set BNAME
      if is_header is not initial.                                             " Header data was passed
        ms_segment_header-before_image     = is_header.
        ms_segment_header-actual           = ms_segment_header-before_image.
*        ms_segment_header-status           = g_persistence->co_seg_status_filled. " Header is filled
      else.                                                " Header data must be passed for MODIFY
        raise exception type cx_suid_identity
          exporting
            textid    = cx_suid_identity=>internal_error
            bname     = ms_manager-bname
            ta_modus  = ms_manager-modus
            .
      endif.

*...---- Display or Distribute identity: Both Before and Actual Image are filled  -------
    when go_persistence->co_ta_modus_display.

*.....Create header segment
      ms_segment_header-bname              = ms_manager-bname.                " Buffer is filled
      ms_manager-status                    = go_persistence->co_ta_status_unchanged.
      ms_segment_header-before_image-bname = ms_manager-bname.                " Set BNAME
      if is_header is not initial.                                              " Header data was passed
        ms_segment_header-before_image     = is_header.
        ms_segment_header-actual           = ms_segment_header-before_image.
*        ms_segment_header-status           = g_persistence->co_seg_status_filled. " Header is filled
      else.                                                " Header data must be passed for DISPLAY
        raise exception type cx_suid_identity
          exporting
            textid    = cx_suid_identity=>internal_error
            bname     = ms_manager-bname
            ta_modus  = ms_manager-modus
            .
      endif.

*...---- Delete identity: Before Image is filled, Actual Image is empty -------
    when go_persistence->co_ta_modus_delete.

*.....Create header segment
      ms_segment_header-bname              = ms_manager-bname.                       " Identity ID
      ms_manager-status                    = go_persistence->co_ta_status_unchecked.  " Identity is changed
      ms_segment_header-before_image-bname = ms_manager-bname.                " Set BNAME
      ms_segment_header-status             = go_persistence->co_seg_changed.
      if is_header is not initial.                                              " Header data was passed
        ms_segment_header-before_image     = is_header.
        clear: ms_segment_header-actual.                                      " Identity will be deleted
*        ms_segment_header-status           = g_persistence->co_seg_status_changed. " Header is filled
      else.                                                " Header data must be passed for DELETE
        raise exception type cx_suid_identity
          exporting
            textid = cx_suid_identity=>internal_error
            bname  = ms_manager-bname
            .
      endif.

  endcase.


endmethod.


method convert_user_to_identity.
*
*  data: ls_msg             type        symsg
*      , ls_tech_user       type        suid_st_node_tech_user
**      , lv_error           type        sesf_boolean
*      .
*
*
** Exporting parameter
*  eo_msg_buffer = go_msg_buffer.
*  eo_notify     = go_notify.
*
** --- Transaction handling ---------------------------------
**
** Set values only in CREATE or CHANGE mode
*  checks_before_access(
*    exporting
*      iv_method = 'S'
*      iv_change_node = if_identity_definition=>gc_node_organization
*    importing
*      es_msg         = ls_msg ).
*
*  if ls_msg-msgty = 'E'.
**   Return to caller
*    return.
*  endif.
*
*
** --- Consistency checks ---
**  if iv_newperson is not initial.
**    return. "not yet supported
**  endif.
**  if is_person is initial.
**    return.
**  endif.
*
*
** --- Check address buffer ---
*  if ms_segment_address-bname is initial.
*    fetch_segment_address( ).
*  endif.
*
*
*  if iv_idadtype is supplied.
*    ms_segment_address-actual-idadtype = iv_idadtype.
*    return.
*  endif.
*
*
** --- Convert old user ---
*  if ms_segment_address-actual-idadtype ne if_identity=>co_idad_olduser and
*     ms_segment_address-actual-idadtype ne if_identity=>co_idad_techuser.
*    return.
*  endif.
*
*  case ms_segment_address-actual-idadtype.
*
*    when if_identity=>co_idad_olduser.
**.....Delete company assignment
*      if ms_segment_address-actual-addrnumber is not initial.
*        call method me->if_identity_person~delete_organization_assignment.
*      endif.
*
*    when if_identity=>co_idad_techuser.
**.....Delete technical user indicator
*      ls_tech_user-tech_indicator = ' '.
*      call method me->if_identity~set_technical_user_indicator
*        exporting
*          is_tech_user = ls_tech_user.
*
*  endcase.
*
** --- Switch IDADType ---
*  ms_segment_address-actual-idadtype = if_identity=>co_idad_person.
*
** --- Assign Person ---
*  call method me->if_identity_person~set_person
*    exporting
*      is_person    = is_person
*      iv_newperson = iv_newperson.
*
endmethod.


method copy.
*
* Copy Identity from given source Identity
*   First get references for both Identities
*    - if not existing yet: Call RETRIEVE and CREATE, respectively
*        potential error messages arise in these methods
*
*   According to importing parameters call GET and SET methods


* Keine Meldung falls keine der Checkboxes aktiviert ist:
*                                 Nur Logondaten/ZBV-Systeme kopieren!
* Siehe LSUID_MAINTENANCEP31 - ab Zeile ca. 553

  data: lr_control_source       type ref to suid_st_node_root
      , lr_control_dest         type ref to suid_st_node_root
      , ls_identity_ref         type ref to cl_identity
      , ls_msg                  type        symsg
      , lt_bname                type        suid_tt_bname
      , ls_bname                type        suid_st_bname
      , lt_node_root            type        suid_tt_node_root
      , lt_control              type        suid_tt_node_root
      , ls_node_logondata       type        suid_st_node_logondata
      , ls_node_personname      type        suid_st_node_person_name
      , ls_node_person          type        suid_st_node_person
      , ls_node_workplace       type        suid_st_node_workplace
      , ls_node_organization    type        suid_st_node_organization
      , ls_node_defaults        type        suid_st_node_defaults
      , lt_node_parameters      type        suid_tt_node_parameters
      , lr_node_parameter       type ref to suid_st_node_parameter
      , ls_node_refuser         type        suid_st_node_reference_user
      , lt_node_roles           type        suid_tt_node_roles
      , lr_node_roles           type ref to suid_st_node_role
      , lr_node_profile         type ref to suid_st_node_profile
      , lt_node_profiles        type        suid_tt_node_profiles
      , lt_node_groups          type        suid_tt_node_groups
      , lr_node_group           type ref to suid_st_node_group
      , ls_node_uclass          type        suid_st_node_uclass
      , lv_source_id_indicator  type        suidadtype
      , lv_dest_id_indicator    type        suidadtype
      , ls_tech_user            type        suid_st_node_tech_user
      , ls_tech_user_data       type        suid_st_node_tech_user_data
      , lt_telephone            type        addrt_telephone_number
      , lt_facsimile            type        addrt_facsimile_number
      , lt_email                type        addrt_email_address
      , lt_web                  type        addrt_web_address
      , lt_telex                type        addrt_telex_number
      , lt_teletex              type        addrt_teletex_number
      , lt_rml                  type        addrt_remote_mail_address
      , lt_x400                 type        addrt_x400_address
      , lt_printer              type        addrt_printer
      , lt_ssf                  type        addrt_ssf_address
      , lt_pager                type        addrt_pager_number
      , ls_current_state        type        bup_s_current_state_commdata
      , lv_cua_roles            type        sesf_boolean
      , lv_cua_profiles         type        sesf_boolean
      , lv_cua_uclasses         type        sesf_boolean
      , ls_node_filter          type        suid_st_cua_filters
      , lt_node_cua_systems     type        suid_tt_node_cua_systems
      , lr_cua_system           type ref to suid_st_node_cua_system
      , lt_node_cua_roles       type        suid_tt_node_cua_roles
      , lr_cua_role             type ref to suid_st_node_cua_role
      , lt_node_cua_profiles    type        suid_tt_node_cua_profiles
      , lr_cua_profile          type ref to suid_st_node_cua_profile
      , lt_node_cua_uclasses    type        suid_tt_node_cua_uclasses
      , lr_cua_uclass           type ref to suid_st_node_cua_uclass
      , lt_docu                 type        suid_tt_node_docu
      , et_source_messages      type        if_suid_msg_buffer=>tt_messages ##needed
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Get references for source and target Identity -------------------*

  " Get reference to source Identity
  ls_bname-bname = iv_id_source.
  append ls_bname to lt_bname.
  call method cl_identity=>retrieve
    exporting
      it_bname      = lt_bname
    importing
      et_node_root  = lt_node_root
      eo_msg_buffer = eo_msg_buffer
      eo_notify     = eo_notify.
  " Instantiation successful?
  append lines of lt_node_root to lt_control.
  read table lt_control with key bname = iv_id_source
    reference into lr_control_source.

  if sy-subrc <> 0.
    go_notify->notify_failed_create(
      exporting
        iv_bname      = iv_id_source
        iv_nodename   = if_identity_definition=>gc_node_root ).

    return.
  endif.

  " fill export structure
  ev_node_root_source-bname = iv_id_source.
  ev_node_root_source-idref = lr_control_source->idref.

  " read identity GUID/UUID
  lr_control_source->idref->get_identity_uuid(
    importing
      ev_identity_guid = ev_node_root_source-identity_guid ).

  " If CUA is active and actual system is not central ==> error message and exit
  if gv_cua_active = if_identity=>co_true and gv_cua_central = if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = iv_id_source
        iv_nodename = if_identity_definition=>gc_node_root
        iv_field    = if_identity_definition=>gc_field_root_bname
        iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
        is_msg      = ls_msg.

    go_notify->notify_failed_create(
      exporting
        iv_bname      = iv_id_source
        iv_nodename   = if_identity_definition=>gc_node_root ).

    return.
  endif.

  " Check if source and target users are different
  if iv_id_source = iv_id_destination.
    clear: ls_msg.
    ls_msg-msgv1 = iv_id_destination.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '224'.
    " MSG: User & exists
    if 1 = 0. message e224(01) with ls_msg-msgv1. endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = iv_id_destination
        iv_nodename = if_identity_definition=>gc_node_root
        iv_field    = if_identity_definition=>gc_field_root_bname
        iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
        is_msg      = ls_msg.

    go_notify->notify_failed_create(
      exporting
        iv_bname      = iv_id_destination
        iv_nodename   = if_identity_definition=>gc_node_root ).

    return.
  endif.

  " Get reference to destination Identity
  " Target Identity was not instantiated yet
  refresh lt_bname.
  clear ls_bname.

  ls_bname-bname = iv_id_destination.
  append ls_bname to lt_bname.
  " Instantiate now
  call method cl_identity=>create
    exporting
      it_bname                     = lt_bname
      iv_cua_central_system_assign = if_identity=>co_false
    importing
      et_node_root                 = lt_node_root
      eo_msg_buffer                = eo_msg_buffer
      eo_notify                    = eo_notify.
  " Instantiation successful?
  append lines of lt_node_root to lt_control.
  read table lt_control with key bname = iv_id_destination
    reference into lr_control_dest.

  if sy-subrc <> 0.
    return.
  endif.

  ev_node_root_destination-bname = iv_id_destination.
  ev_node_root_destination-idref = lr_control_dest->idref.

* --- Now call SET and GET methods for nodes --------------------------*
* Always copy: Logondata, CUA systems
* Copy address: Person name, Workplace, Company

  " Get identity type of source user
  call method lr_control_source->idref->get_identity_indicator
    importing
      ev_id_indicator = lv_source_id_indicator.

  " Get identity type of dest user
  call method lr_control_dest->idref->get_identity_indicator
    importing
      ev_id_indicator = lv_dest_id_indicator.

  " Copy Address
  if iv_copy_address is not initial.

    "--- User with old model -----------------------------------------
    if lv_dest_id_indicator eq if_identity=>co_idad_olduser.

      " Set company of dest user or default company
      clear: ls_node_organization.
      if lv_source_id_indicator eq if_identity=>co_idad_olduser.
        call method lr_control_source->idref->if_identity_person~get_organization
          importing
            es_organization = ls_node_organization
            eo_msg_buffer   = eo_msg_buffer.
      endif.

      call method lr_control_dest->idref->if_identity_person~set_organization
        exporting
          is_organization = ls_node_organization
        importing
          eo_msg_buffer   = eo_msg_buffer.

      " Set Person_Name or username as last name
      clear: ls_node_personname.
      if lv_source_id_indicator eq if_identity=>co_idad_techuser.
        ls_node_personname-name_last = iv_id_destination.
      else.
        call method lr_control_source->idref->if_identity_person~get_personname
          importing
            es_personname = ls_node_personname
            eo_msg_buffer = eo_msg_buffer.
      endif.

      call method lr_control_dest->idref->if_identity_person~set_personname
        exporting
          is_personname = ls_node_personname
        importing
          eo_msg_buffer = eo_msg_buffer.

      " Set workplace data and communication data if exist
      if lv_source_id_indicator ne if_identity=>co_idad_techuser  and
         lv_source_id_indicator ne if_identity=>co_idad_person.

        call method lr_control_source->idref->if_identity_person~get_workplacedata
          importing
            es_workplace  = ls_node_workplace
            eo_msg_buffer = eo_msg_buffer.

        call method lr_control_dest->idref->if_identity_person~set_workplacedata
          exporting
            is_workplace  = ls_node_workplace
          importing
            eo_msg_buffer = eo_msg_buffer.

        " Communication data
        lr_control_source->idref->if_identity_person~get_communication_data(
          exporting
            iv_retrieve_commdata_all = if_identity=>co_true
          importing
            eo_msg_buffer            = eo_msg_buffer
            et_telephone             = lt_telephone
            et_facsimile             = lt_facsimile
            et_email                 = lt_email
            et_web                   = lt_web
            et_telex                 = lt_telex
            et_teletex               = lt_teletex
            et_rml                   = lt_rml
            et_x400                  = lt_x400
            et_printer               = lt_printer
            et_ssf                   = lt_ssf
            et_pager                 = lt_pager     ).

        clear: ls_current_state with 'X'.
        lr_control_dest->idref->if_identity_person~set_communication_data(
          exporting
            it_telephone        = lt_telephone
            it_facsimile        = lt_facsimile
            it_email            = lt_email
            it_web              = lt_web
            it_telex            = lt_telex
            it_teletex          = lt_teletex
            it_rml              = lt_rml
            it_x400             = lt_x400
            it_printer          = lt_printer
            it_ssf              = lt_ssf
            it_pager            = lt_pager
            is_current_state    = ls_current_state
          importing
            eo_msg_buffer       = eo_msg_buffer     ).
      endif.

    "--- User with new model ---------------------------------------
    else.

      " Technical User
      if lv_source_id_indicator eq if_identity=>co_idad_techuser.

        ls_tech_user-tech_indicator = if_identity=>co_true.
        call method lr_control_dest->idref->set_technical_user_indicator
          exporting
            is_tech_user = ls_tech_user.

        call method lr_control_source->idref->get_technical_user_data
          importing
            es_tech_user_data = ls_tech_user_data.

        call method lr_control_dest->idref->set_technical_user_data
          exporting
            is_tech_user_data = ls_tech_user_data.

      " else.
      " idadtype = 02 will be created without person-assignment
      endif.

    endif.

  "--- Set Default address -----------------------------------------
  else.

    " Get identity type of dest user
    call method lr_control_dest->idref->get_identity_indicator
      importing
        ev_id_indicator = lv_dest_id_indicator.

    "...--- User with old model -----------------------------------------
    if lv_dest_id_indicator eq if_identity=>co_idad_olduser.

      " Set Company
      clear: ls_node_organization.
      call method lr_control_dest->idref->if_identity_person~set_organization
        exporting
          is_organization = ls_node_organization
        importing
          eo_msg_buffer   = eo_msg_buffer.

      " Set UserID as last name
      clear: ls_node_personname.
      ls_node_personname-name_last = iv_id_destination.

      call method lr_control_dest->idref->if_identity_person~set_personname
        exporting
          is_personname = ls_node_personname
        importing
          eo_msg_buffer = eo_msg_buffer.

    "--- User with new model ---------------------------------------
    else.

      " Technical User
      if lv_source_id_indicator eq if_identity=>co_idad_techuser.
        ls_tech_user-tech_indicator = if_identity=>co_true.
        call method lr_control_dest->idref->set_technical_user_indicator
          exporting
            is_tech_user = ls_tech_user.

        call method lr_control_source->idref->get_technical_user_data
          importing
            es_tech_user_data = ls_tech_user_data.

        call method lr_control_dest->idref->set_technical_user_data
          exporting
            is_tech_user_data = ls_tech_user_data.
      " else.
      " idadtype = 02 will be created without person-assignment
      endif.
    endif.

  endif.

  " Copy defaults
  if iv_copy_defaults is not initial.

    call method lr_control_source->idref->get_defaults
      importing
        eo_msg_buffer = eo_msg_buffer
        es_defaults   = ls_node_defaults.
    call method lr_control_dest->idref->set_defaults
      exporting
        is_defaults   = ls_node_defaults
      importing
        eo_msg_buffer = eo_msg_buffer.

    " Copy also print parameters
    ls_identity_ref ?= lr_control_dest->idref.
    if ls_identity_ref->ms_segment_defaults-status = go_persistence->co_seg_changed.
      ls_identity_ref->ms_segment_defaults-printsource = iv_id_source.
    endif.

  endif.

  " Copy parameters
  if iv_copy_parameters is not initial.

    call method lr_control_source->idref->get_parameters
      importing
        eo_msg_buffer = eo_msg_buffer
        et_parameters = lt_node_parameters.

    loop at lt_node_parameters reference into lr_node_parameter.
      lr_node_parameter->change_mode = if_identity=>co_insert.
    endloop.

    call method lr_control_dest->idref->set_parameters
      exporting
        it_parameters = lt_node_parameters
      importing
        eo_msg_buffer = eo_msg_buffer.

  endif.

  " Copy groups
  if iv_copy_groups is not initial.

    call method lr_control_source->idref->get_groups
      exporting
        iv_get_text   = if_identity=>co_true
      importing
        et_groups     = lt_node_groups
        eo_msg_buffer = eo_msg_buffer.

    loop at lt_node_groups reference into lr_node_group.
      lr_node_group->change_mode = if_identity=>co_insert.
    endloop.

    call method lr_control_dest->idref->set_groups
      exporting
        it_groups     = lt_node_groups
      importing
        eo_msg_buffer = eo_msg_buffer.

  endif.

  " Copy reference user
  if iv_copy_refuser is not initial.

    call method lr_control_source->idref->get_reference_user
      importing
        eo_msg_buffer     = eo_msg_buffer
        es_reference_user = ls_node_refuser.

    call method lr_control_dest->idref->set_reference_user
      exporting
        is_reference_user = ls_node_refuser
      importing
        eo_msg_buffer     = eo_msg_buffer.

  endif.

  " Copy Personalization
  if iv_copy_personalization is not initial.

    ls_identity_ref ?= lr_control_dest->idref.
    ls_identity_ref->persdata_set_modified( ).

    " Copy if not system upgrade (check is inside of SET_PERSDATA_MODIFIED)
    if ls_identity_ref->ms_manager-flg_pers_modified = go_persistence->co_flag_active.
      cl_pers_service=>user_copy(
        exporting
          p_uname_source         = iv_id_source
          p_uname_target         = iv_id_destination
          p_no_buffer            = space
        exceptions
          user_does_not_exist    = 0
          target_user_exists     = 0
          access_class_not_found = 0  ).
    endif.

  endif.

  " Copy SAP Easy Access Menu
  if iv_copy_easy_access is not initial.

    ls_identity_ref ?= lr_control_dest->idref.
    ls_identity_ref->easy_access_menu_set_copied( iv_source_bname = iv_id_source ).

  endif.

  " Copy User Documentation
  if iv_copy_documentation is not initial.

    call method lr_control_source->idref->get_documentation
      importing
        eo_msg_buffer     = eo_msg_buffer
        et_docu           = lt_docu.

    call method lr_control_source->idref->get_technical_user_data
      importing
        eo_msg_buffer     = eo_msg_buffer
        es_tech_user_data = ls_tech_user_data.

    ls_identity_ref ?= lr_control_dest->idref.

    call method ls_identity_ref->set_documentation_complete
      exporting
        it_docu           = lt_docu
      importing
        eo_msg_buffer     = eo_msg_buffer.

    call method lr_control_dest->idref->set_technical_user_data
      exporting
        is_tech_user_data = ls_tech_user_data
      importing
        eo_msg_buffer     = eo_msg_buffer.

  endif.

  "--- CUA dependent data -------------------------------------
  if gv_cua_active = if_identity=>co_true.
    " Assign systems (systems should be assigned before we try to assign License data,
    " otherwise License data for child systems will bw ignored)
    lr_control_source->idref->if_identity_cua~get_cua_systems(
      importing
        et_cua_systems = lt_node_cua_systems
        eo_msg_buffer  = eo_msg_buffer     ).

    loop at lt_node_cua_systems reference into lr_cua_system.
      lr_cua_system->change_mode = if_identity=>co_insert.
    endloop.

    if lt_node_cua_systems is not initial.
      lr_control_dest->idref->if_identity_cua~set_cua_systems(
        exporting
          it_cua_systems = lt_node_cua_systems
        importing
          eo_msg_buffer  = eo_msg_buffer     ).
    endif.

    " Check SCUM settings
    if iv_copy_roles is not initial.
      " Get CUA distribution filter for roles
      ls_node_filter-node_name = if_identity_definition=>gc_node_cua_role.
      call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
        changing
          cs_field_filter = ls_node_filter.
      if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
        lv_cua_roles = if_identity=>co_true.
      endif.
    endif.

    if iv_copy_profiles is not initial.
      " Get CUA distribution filter for profiles
      clear: ls_node_filter.
      ls_node_filter-node_name = if_identity_definition=>gc_node_cua_profile.
      call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
        changing
          cs_field_filter = ls_node_filter.
      if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
        lv_cua_profiles = if_identity=>co_true.
      endif.
    endif.

    if iv_copy_uclass is not initial.
      " Get CUA distribution filter for License data
      clear: ls_node_filter.
      ls_node_filter-node_name = if_identity_definition=>gc_node_cua_uclass.
      call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
        changing
          cs_field_filter = ls_node_filter.
      if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
        lv_cua_uclasses = if_identity=>co_true.
      endif.
    endif.

  endif.

  " Copy roles
  if iv_copy_roles is not initial.

    if lv_cua_roles = if_identity=>co_true.
      " CUA roles
      lr_control_source->idref->if_identity_cua~get_cua_roles(
        importing
          et_roles            = lt_node_cua_roles
          eo_msg_buffer       = eo_msg_buffer ).

      loop at lt_node_cua_roles reference into lr_cua_role.
        lr_cua_role->change_mode = if_identity=>co_insert.
      endloop.

      if lt_node_cua_roles is not initial.
        ls_identity_ref ?= lr_control_dest->idref.
        " HR-Org roles should not be copied, because such assignments
        " will be anyway later deleted by PFUD
        ls_identity_ref->if_identity_cua~set_cua_roles(
          exporting
            it_roles          = lt_node_cua_roles
          importing
            eo_msg_buffer     = eo_msg_buffer ).
      endif.
    else.
      " Local roles
      call method lr_control_source->idref->get_roles
        importing
          et_roles      = lt_node_roles
          eo_msg_buffer = eo_msg_buffer.

      loop at lt_node_roles reference into lr_node_roles.
        lr_node_roles->change_mode = if_identity=>co_insert.
      endloop.

      ls_identity_ref ?= lr_control_dest->idref.
      " HR-Org roles should not be copied, because such assignments
      " will be anyway later deleted by PFUD
      ls_identity_ref->if_identity~set_roles(
        exporting
          it_roles      = lt_node_roles
        importing
          eo_msg_buffer = eo_msg_buffer ).
    endif.

  endif.

  " Copy profiles
  if iv_copy_profiles is not initial.
    if lv_cua_profiles = if_identity=>co_true.
      " CUA profiles
      lr_control_source->idref->if_identity_cua~get_cua_profiles(
        importing
          et_profiles   = lt_node_cua_profiles
          eo_msg_buffer = eo_msg_buffer   ).

      loop at lt_node_cua_profiles reference into lr_cua_profile.
        if lr_cua_profile->type ne if_identity~co_prof_type_generated. " if not generated profile
          lr_cua_profile->change_mode = if_identity=>co_insert.
        else.
          delete lt_node_cua_profiles.
        endif.
      endloop.

      if lt_node_cua_profiles is not initial.
        lr_control_dest->idref->if_identity_cua~set_cua_profiles(
          exporting
            it_profiles          = lt_node_cua_profiles
          importing
            eo_msg_buffer        = eo_msg_buffer   ).
      endif.

    else.
      " Local profiles
      call method lr_control_source->idref->get_profiles
        importing
          et_profiles   = lt_node_profiles
          eo_msg_buffer = eo_msg_buffer.

      loop at lt_node_profiles reference into lr_node_profile.
        if lr_node_profile->type ne if_identity~co_prof_type_generated. " if not generated profile
          lr_node_profile->change_mode = if_identity=>co_insert.
        else.
          delete lt_node_profiles.
        endif.
      endloop.

      call method lr_control_dest->idref->set_profiles
        exporting
          it_profiles   = lt_node_profiles
        importing
          eo_msg_buffer = eo_msg_buffer.
    endif.

  endif.

  " Copy licence data
  if iv_copy_uclass is not initial.

    if lv_cua_uclasses = if_identity=>co_true.
      " CUA License data
      lr_control_source->idref->if_identity_cua~get_cua_uclasses(
        importing
          et_cua_uclasses        = lt_node_cua_uclasses
          eo_msg_buffer          = eo_msg_buffer  ).

      loop at lt_node_cua_uclasses reference into lr_cua_uclass.
        lr_cua_uclass->change_mode = if_identity=>co_insert.
      endloop.

      if lt_node_cua_uclasses is not initial.
        lr_control_dest->idref->if_identity_cua~set_cua_uclasses(
          exporting
            it_cua_uclasses = lt_node_cua_uclasses
          importing
            eo_msg_buffer   = eo_msg_buffer  ).
      endif.

    else.
      " Local License data
      call method lr_control_source->idref->get_uclass
        importing
          eo_msg_buffer = eo_msg_buffer
          es_uclass     = ls_node_uclass.

      call method lr_control_dest->idref->set_uclass
        exporting
          is_uclass     = ls_node_uclass
        importing
          eo_msg_buffer = eo_msg_buffer.
    endif.

  endif.

  " Copy Logondata: Set logondata at last in order to get all roles, profiles and reference user
  call method lr_control_source->idref->get_logondata
    importing
      es_logondata  = ls_node_logondata
      eo_msg_buffer = eo_msg_buffer.

  " User alias should not be copied: It must be unique anyway
  clear: ls_node_logondata-useralias.

  call method lr_control_dest->idref->set_logondata
    exporting
      is_logondata  = ls_node_logondata
    importing
      eo_msg_buffer = eo_msg_buffer.

  " prepare return variable: read identity GUID/UUID
  lr_control_dest->idref->get_identity_uuid(
    importing
      ev_identity_guid = ev_node_root_destination-identity_guid ).

  " Read error messages of source user
  call method eo_msg_buffer->get_messages
    exporting
      iv_bname    = iv_id_source
    receiving
      et_messages = et_source_messages.

endmethod.


method create.

**********************************************************************
* Create new Identity instances with transaction mode "Create"
**********************************************************************
  data: lv_lock_mode           type sesf_edit_mode
                               value if_identity=>co_enqueue_mode_exclusive
      , lr_node_root           type ref to suid_st_node_root
      , lt_bname               type suid_tt_bname
      , lr_bname               type ref to suid_st_bname
      , lt_identity            type suid_tt_identity
      , lr_identity            type ref to suid_st_identity
      , lt_cua_systems         type suid_tt_node_cua_systems
      , lr_cua_system          type ref to suid_st_node_cua_system
      , lv_logsys              type t000-logsys
      , lt_node_root1          type suid_tt_node_root
      , lt_node_root2          type suid_tt_node_root
      .


**********************************************************************
* Set exporting parameters
**********************************************************************
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

**********************************************************************
* Pass to method for instantiation
**********************************************************************

  clear: lt_bname, lt_identity.

  if it_bname is not initial.

    call method instantiation_by_mode       "Create identities with generated UUIDs
      exporting
        iv_modus                        = go_persistence->co_ta_modus_create
        it_bname                        = it_bname
        iv_enq_mode                     = lv_lock_mode
        iv_cua_ts_local_user            = iv_cua_ts_local_user
        iv_cua_ts_force_modifaction     = iv_cua_ts_force_modifaction
        iv_set_optimistic_enqueue_lock  = iv_set_optimistic_enqueue_lock
      importing
        et_node_root                    = et_node_root.

  elseif it_identity is not initial.

    loop at it_identity reference into lr_identity.
      if lr_identity->identity_guid is initial.
        append lr_identity->bname to lt_bname.
      else.
        append lr_identity->* to lt_identity.
      endif.
    endloop.

    if lt_bname is not initial.
      call method instantiation_by_mode       "Create identities with generated UUIDs
        exporting
          iv_modus                        = go_persistence->co_ta_modus_create
          it_bname                        = lt_bname
          iv_enq_mode                     = lv_lock_mode
          iv_cua_ts_local_user            = iv_cua_ts_local_user
          iv_cua_ts_force_modifaction     = iv_cua_ts_force_modifaction
          iv_set_optimistic_enqueue_lock  = iv_set_optimistic_enqueue_lock
        importing
          et_node_root                    = lt_node_root1.

      append lines of lt_node_root1 to et_node_root.
    endif.

    if lt_identity is not initial.
      clear lt_bname.
      move lt_identity to lt_bname.
      call method instantiation_by_mode       "Create identities with supplied UUIDs
        exporting
          iv_modus                        = go_persistence->co_ta_modus_create
          it_bname                        = lt_bname
          it_identity                     = lt_identity
          iv_enq_mode                     = lv_lock_mode
          iv_cua_ts_local_user            = iv_cua_ts_local_user
          iv_cua_ts_force_modifaction     = iv_cua_ts_force_modifaction
          iv_set_optimistic_enqueue_lock  = iv_set_optimistic_enqueue_lock
        importing
          et_node_root                    = lt_node_root2.

      append lines of lt_node_root2 to et_node_root.
    endif.
  endif.

* --- send notifications for newly created identities ------------------
*
  clear lt_bname.
  if it_bname is not initial.
    move it_bname to lt_bname.
  else.
    move it_identity to lt_bname.
  endif.

  loop at et_node_root reference into lr_node_root.
    delete lt_bname where bname = lr_node_root->bname.
    go_notify->notify_create(
    exporting
      iv_bname      = lr_node_root->bname
      iv_nodename   = if_identity_definition=>gc_node_root ).
  endloop.

* --- send notifications for failed creations ---------------------------
*
  loop at lt_bname reference into lr_bname.
    go_notify->notify_failed_create(
    exporting
      iv_bname      = lr_bname->bname
      iv_nodename   = if_identity_definition=>gc_node_root ).
  endloop.

  check: et_node_root is not initial.


**********************************************************************
* Perform Prefetch: For Create, all segments are processed
**********************************************************************
  call method nodes_prefetch
    exporting
      it_bname        = it_bname
      iv_prefetch_all = go_persistence->co_flag_active.

  call method nodes_prefill_default_values
    exporting
      it_node_root = et_node_root
      iv_modus     = go_persistence->co_ta_modus_create.


* Create local user in central system ==> create normal user + assign central system
  if gv_cua_central eq if_identity=>co_true and
    (  iv_cua_ts_local_user         eq if_identity=>co_true or
       iv_cua_central_system_assign eq if_identity=>co_true  ).

*   Get actual system logical name
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
      importing
        ev_system_logsys = lv_logsys.

    append initial line to lt_cua_systems reference into lr_cua_system.
    lr_cua_system->subsystem   = lv_logsys.
    lr_cua_system->change_mode = if_identity=>co_insert.

*   Assign central system to users
    loop at et_node_root reference into lr_node_root.
      lr_node_root->idref->if_identity_cua~set_cua_systems(
        exporting
          it_cua_systems = lt_cua_systems ).
    endloop.
  endif.




endmethod.


method cua_check_field_distribute.

  data: ls_field_filter  type suid_st_cua_filters
      .

  clear: ev_distribute.

  if gv_cua_active = if_identity=>co_false.
    return.
  endif.

  if ms_manager-modus <> go_persistence->co_ta_modus_create and
     ms_manager-modus <> go_persistence->co_ta_modus_modify.
    return.
  endif.

  ls_field_filter = is_node_field.

  cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter( changing cs_field_filter = ls_field_filter ).
  if ls_field_filter-field_attr is initial.
    return.
  endif.

* In central system changes should be distributed only if they are not done during
* transfer of new user from child system into CUA (transaction SCUG)
  if gv_cua_central = if_identity=>co_true and mv_cua_mode <> co_cua_child_copy.
*   Proposal fields should be distributed from central system in create mode only
    if ls_field_filter-field_attr = if_suid_cua_runtime=>gc_template.
      if  ms_manager-modus = go_persistence->co_ta_modus_create.
        ev_distribute = if_identity=>co_true.
      endif.
*   Local fields shouldn't be distributed
    elseif ls_field_filter-field_attr <> if_suid_cua_runtime=>gc_local.
      ev_distribute = if_identity=>co_true.
    endif.

  elseif gv_cua_child = if_identity=>co_true and gv_idoc_processing = if_identity=>co_false and
         ms_manager-modus = go_persistence->co_ta_modus_modify    and
         mv_cua_mode is initial.
    if ls_field_filter-field_attr = if_suid_cua_runtime=>gc_maint_back.
      ev_distribute = if_identity=>co_true.
    endif.
  endif.

endmethod.


method cua_delete_user_system_prot.
* This method deletes USZBVPROT protocol entries for certain system and section(s)
* Used when system assignment

  data: usersections    type range of uszbvsys-usrsection
      , ls_usersection  like line of usersections
      .


* --- Check CUA central system ----------------------------------
*
* If not in central system --> exit
  if gv_cua_central = if_identity=>co_false.
    return.
  endif.

* --- Transaction handling ---------------------------------
* Transactional check
*  if ms_manager-status ne go_persistence->co_ta_status_checked or
  if ms_manager-modus  eq go_persistence->co_ta_modus_display.
    return.
  endif.

* --- Prepare user section ranges table -------------------
*
  ls_usersection-sign   = 'I'.
  ls_usersection-option = 'EQ'.

* USER section
  if iv_user_section = if_identity=>co_true.
    ls_usersection-low = if_suid_cua_runtime=>gc_user_usrsection.
    append ls_usersection to usersections.
  endif.

* ACTGRP section
  if iv_role_section = if_identity=>co_true.
    ls_usersection-low = if_suid_cua_runtime=>gc_role_usrsection.
    append ls_usersection to usersections.
  endif.

* PROFILE section
  if iv_prof_section = if_identity=>co_true.
    ls_usersection-low = if_suid_cua_runtime=>gc_prof_usrsection.
    append ls_usersection to usersections.
  endif.


*----- Modify USZBVPROT segment (delete existing entries for system and section(s)) -------

* Fill CUA_USER_PROT segment if needed
  if ms_segment_cua_user_prot-bname is initial.
    call method fetch_segment_cua_user_prot.
  endif.

  delete ms_segment_cua_user_prot-actual
         where usrsection in usersections
           and subsystem  eq iv_subsystem.

* Set segment change flag for USZBVPROT segment
  if ms_segment_cua_user_prot-actual ne ms_segment_cua_user_prot-before_image.
    ms_segment_cua_user_prot-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_cua_user_prot-status.
  endif.



endmethod.


method cua_get_changes_for_distribute.
* The method checks in central and child systems if some changes should be
* distributed.
*
* In central system is checked:
*       -  if some system specific data has been chaged ==> distribute;
*       -  some non-system  specific data has been changed and SCUM attribute
*          of this data requires distribution ==> distribute;
*       -  as soon as we know that smth. from user master data should be
*          distributed ==> no further checks of other fields are needed
*          for USER section
*
* In child system is checked:
*       -  if some field has been changed and this field has SCUM attribute
*          'Back Distribution' ==> collect it for back distribution
*       -  all fields, which can be back distribution relevant are checked
*          and collected as above (we don't stop after first found distribution
*          relevant field opposite to behaviour in central system)
*
*  !!! If some changes in check routine in central system are done don't
*  !!! forget to check if they chould be also implemented for child system
*  !!! and the other way round

  data: ls_node_filter        type        suid_st_cua_filters
      , lv_distribute	        type        sesf_boolean
      , lr_descr_struct       type ref to cl_abap_structdescr
      , lt_struct_components  type        abap_compdescr_tab
      , lr_struct_component   type ref to abap_compdescr
      , lt_node_fields        type        suid_tt_fields
      , lr_field              type ref to suid_node_field
      , lt_distr_nodefields   type        cl_suid_tools=>tt_node_fields
      , ls_distr_nodefields   type        cl_suid_tools=>ty_node_fields
      .

  data: ls_personname_before  type        suid_st_node_person_name
      , ls_personname_actual  type        suid_st_node_person_name
      , ls_workplace_before   type        suid_st_node_workplace
      , ls_workplace_actual   type        suid_st_node_workplace
      , lt_telephone_before   type        addrt_telephone_number
      , lt_facsimile_before   type        addrt_facsimile_number
      , lt_email_before       type        addrt_email_address
      , lt_web_before         type        addrt_web_address
      , lt_telex_before       type        addrt_telex_number
      , lt_teletex_before     type        addrt_teletex_number
      , lt_rml_before         type        addrt_remote_mail_address
      , lt_x400_before        type        addrt_x400_address
      , lt_printer_before     type        addrt_printer
      , lt_ssf_before         type        addrt_ssf_address
      , lt_pager_before       type        addrt_pager_number
      , lt_telephone_actual   type        addrt_telephone_number
      , lt_facsimile_actual   type        addrt_facsimile_number
      , lt_email_actual       type        addrt_email_address
      , lt_web_actual         type        addrt_web_address
      , lt_telex_actual       type        addrt_telex_number
      , lt_teletex_actual     type        addrt_teletex_number
      , lt_rml_actual         type        addrt_remote_mail_address
      , lt_x400_actual        type        addrt_x400_address
      , lt_printer_actual     type        addrt_printer
      , lt_ssf_actual         type        addrt_ssf_address
      , lt_pager_actual       type        addrt_pager_number
      .

  field-symbols:  <lv_checkfield_before> type any
                , <lv_checkfield_actual> type any
                .



  clear: es_cua_data_distribute
       , es_cua_data_distribute_back.


* Exit if not in CUA case
  if gv_cua_active <> if_identity=>co_true.
    return.
  endif.

* Exit if not CUA user
  if gv_cua_child = if_identity=>co_true  and
    ( mv_cua_mode = co_cua_not_transferred or
      mv_cua_mode = co_cua_local_create    ).
    return.
  endif.

* Deletion requieres distribution of user master data section to
* all assigned child systems, no further data checks are required here
  if ms_manager-modus = go_persistence->co_ta_modus_delete.
    if gv_cua_central = if_identity=>co_true.
      es_cua_data_distribute-user_masterdata = if_identity=>co_true.
      clear: ms_segment_cua_systems-systems_add.
    endif.
    return.
  endif.

* Collect distribution relevant changes only in create or modify case
  if ms_manager-modus <> go_persistence->co_ta_modus_create and
     ms_manager-modus <> go_persistence->co_ta_modus_modify.
    return.
  endif.


*----------------------------------------------------------------------
*        Checks, which are only central system relevant
*----------------------------------------------------------------------
  if gv_cua_central = if_identity=>co_true.
* --- First check if system specific data was modified
* ------
*   Trans. SCUG - transfer roles from child system: even if role assignments are not
*   really changed, status 'G' in USZBVSYS should be set if method SET_CUA_ROLES was called for a user
    if gs_cua_user_transfer-active eq if_identity=>co_true.
      es_cua_data_distribute-roles = ms_segment_cua_act_distr-actual-actgrpsection.

*   MS_SEGMENT_CUA_ROLES changes
    else.
      if ms_segment_cua_roles-status      eq go_persistence->co_seg_changed.
*       Get CUA distribution filter for CUA role assignments
        clear: ls_node_filter .
        ls_node_filter-node_name = if_identity_definition=>gc_node_cua_role.
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-roles.
      endif.
    endif.

* ------
*   Trans. SCUG - transfer profiles from child system: even if prof. assignments are not
*   really changed, status 'G' in USZBVSYS should be set if method SET_CUA_PROFILES was
*   called for a user
    if gs_cua_user_transfer-active eq if_identity=>co_true.
      es_cua_data_distribute-profiles = ms_segment_cua_act_distr-actual-profilesection.

*   MS_SEGMENT_CUA_PROFILES changes
    else.
      if ms_segment_cua_profiles-status   eq go_persistence->co_seg_changed.
*       Get CUA distribution filter for CUA profile assignments
        clear: ls_node_filter .
        ls_node_filter-node_name = if_identity_definition=>gc_node_cua_profile.
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-profiles.
      endif.
    endif.

* ------
*   Global Lock - internal segment MS_SEGMENT_CUA_ACT_DISTR
*   Check if global lock/unlock was set during transaction
*   (segment is filled only if SCUM settings suppose distribution)
    if ms_segment_cua_act_distr-actual-global_lock = co_lock   or
       ms_segment_cua_act_distr-actual-global_lock = co_unlock .
      es_cua_data_distribute-global_lock = if_identity=>co_true.
    endif.

* ------
*   Initial Password - internal segment MS_SEGMENT_CUA_ACT_DISTR
*   Check if initial passwords were set during transaction (segment is filled only if
*   SCUM settings suppose distribution)
    if ms_segment_cua_act_distr-actual-password is not initial.
      es_cua_data_distribute-password = ms_segment_cua_act_distr-actual-password.
    endif.

* ------
*   MS_SEGMENT_CUA_UCLASS changes (in transaction SCUG license data transfer from child
*   system alone doesn't lead to status change in USZBVSYS and distribution, therefore
*   we check only real changes in "normal" processing)
    if ms_segment_cua_uclasses-status eq go_persistence->co_seg_changed and
       gs_cua_user_transfer-active ne if_identity=>co_true.
*     Get CUA distribution filter for changed field (node)
      clear: ls_node_filter .
      ls_node_filter-node_name  = if_identity_definition=>gc_node_uclass.
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = es_cua_data_distribute-license_data.
    endif.

* ------
*   User transfer from child system (transaction SCUG) if not copying a new user
*   from child system into CUA (identical or different user case)
    if gs_cua_user_transfer-active = if_identity=>co_true            and
       mv_cua_mode         <> co_cua_child_copy  .
*     Mark personalization as changed in order to distribute it to child system
      ms_manager-flg_pers_modified = go_persistence->co_flag_active.
    endif.

* ------
*   MS_SEGMENT_CUA_SYSTEMS changes
    if ms_segment_cua_systems-status eq go_persistence->co_seg_changed.
      es_cua_data_distribute-cua_systems = if_identity=>co_true.
*     In Creation mode changed system assignments = all assigned systems,
*     no further checks are needed here
      if ms_manager-modus = go_persistence->co_ta_modus_create.
        return.
      endif.
    endif.

*   User transfer from child system (transaction SCUG) - user should be distributed
*   to one child system only, no further checks of user master data are needed
    if gs_cua_user_transfer-active = if_identity=>co_true.
      return.
    endif.


* --- Now check if general user master data was modified
* ------
*   MS_SEGMENT_GROUPS changes
    if ms_segment_groups-status  eq go_persistence->co_seg_changed.
*     Get CUA distribution filter for changed field (node)
      clear: ls_node_filter .
      ls_node_filter-node_name  = if_identity_definition=>gc_node_group.
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = es_cua_data_distribute-user_masterdata.
*     If one node or field of user master data is distribution relevant ==>
*     complete user master data should be distributed, no further check is needed
      if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
        return.
      endif.
    endif.

* ------
*   MS_SEGMENT_SNC changes
    if ms_segment_snc-status  eq go_persistence->co_seg_changed.
*     Get CUA distribution filter for changed field (node)
      clear: ls_node_filter .
      ls_node_filter-node_name  = if_identity_definition=>gc_node_snc.
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = es_cua_data_distribute-user_masterdata.
*     If one node or field of user master data is distribution relevant ==>
*     complete user master data should be distributed, no further check is needed
      if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
        return.
      endif.
    endif.

* ------
*   MS_SEGMENT_PARAMETER changes
    if ms_segment_parameter-status  eq go_persistence->co_seg_changed.
*     Get CUA distribution filter for changed field (node)
      clear: ls_node_filter .
      ls_node_filter-node_name  = if_identity_definition=>gc_node_parameter.
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = es_cua_data_distribute-user_masterdata.
*     If one node or field of user master data is distribution relevant ==>
*     complete user master data should be distributed, no further check is needed
      if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
        return.
      endif.
    endif.

* ------
*   PERSONALIZATION changes
    if ms_manager-flg_pers_modified = go_persistence->co_flag_active.
*     Get CUA distribution filter for changed field (node)
      clear: ls_node_filter .
      ls_node_filter-node_name  = if_suid_cua_runtime=>gc_persdata.
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = es_cua_data_distribute-user_masterdata.
*     If one node or field of user master data is distribution relevant ==>
*     complete user master data should be distributed, no further check is needed
      if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
        return.
      endif.
    endif.

* ------
*   MS_SEGMENT_REFUSER changes
    if ms_segment_refuser-status  eq go_persistence->co_seg_changed.
*     First check field USERALIAS from node LOGONDATA
*     Get field values of before_image and actual
      unassign: <lv_checkfield_before>
              , <lv_checkfield_actual>
              .
      assign component if_identity_definition=>gc_field_logondata_useralias
             of structure ms_segment_refuser-before_image to <lv_checkfield_before>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.
      assign component if_identity_definition=>gc_field_logondata_useralias
             of structure ms_segment_refuser-actual to <lv_checkfield_actual>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

      clear: ls_node_filter .
      if <lv_checkfield_before> <> <lv_checkfield_actual>.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_logondata.
        ls_node_filter-node_field = if_identity_definition=>gc_field_logondata_useralias.
      else.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_reference_user.
      endif.

*     Get CUA distribution filter for changed field (node)
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = es_cua_data_distribute-user_masterdata.
*     If one node or field of user master data is distribution relevant ==>
*     complete user master data should be distributed, no further check is needed
      if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
        return.
      endif.
    endif.

* ------
*   MS_SEGMENT_HEADER changes
    if ms_segment_header-status  eq go_persistence->co_seg_changed.
      refresh: lt_node_fields.

*     Here we only check segment fields, which belong to nodes LOGONDATA and DEFAULTS
*     Other fields are either not distribution relevant or are already evaluated above

*     Get list of fields belonging to the node LOGONDATA
      call method cl_suid_tools=>get_node_fields
        exporting
          iv_node_name   = if_identity_definition=>gc_node_logondata
        importing
          et_node_fields = lt_node_fields.

      loop at lt_node_fields reference into lr_field.
        clear: ls_node_filter .

*       Get field values of before_image and actual
        unassign: <lv_checkfield_before>
                , <lv_checkfield_actual>
                .
        assign component lr_field->* of structure ms_segment_header-before_image
               to <lv_checkfield_before>.
        if sy-subrc ne 0.
          continue.
        endif.
        assign component lr_field->* of structure ms_segment_header-actual
               to <lv_checkfield_actual>.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.

*       If field value has been changed ==> check if this change is distribution relevant
        if <lv_checkfield_before> <> <lv_checkfield_actual>.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_logondata.
          ls_node_filter-node_field = lr_field->*.
*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute-user_masterdata.
*         If one node or field of user master data is distribution relevant ==>
*         complete user master data should be distributed, no further check is needed
          if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
            return.
          endif.
        endif.
      endloop.

*     Get field values of before_image and actual
      unassign: <lv_checkfield_before>
              , <lv_checkfield_actual>
              .
*     Check field TZONE from node DEFAULTS
      assign component if_identity_definition=>gc_field_defaults_tzone
             of structure ms_segment_header-before_image to <lv_checkfield_before>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.
      assign component if_identity_definition=>gc_field_defaults_tzone
             of structure ms_segment_header-actual to <lv_checkfield_actual>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

*     If field value has been changed ==> check if this change is distribution relevant
      if <lv_checkfield_before> <> <lv_checkfield_actual>.
        clear: ls_node_filter .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_defaults.
        ls_node_filter-node_field = if_identity_definition=>gc_field_defaults_tzone.
*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
    endif.

* ------
*   MS_SEGMENT_DEFAULTS changes
    if ms_segment_defaults-status  eq go_persistence->co_seg_changed.
      clear: lr_descr_struct.
      refresh: lt_struct_components.

*     Get fields of segment before_image structure
      lr_descr_struct ?= cl_abap_structdescr=>describe_by_data( ms_segment_defaults-before_image ).
      lt_struct_components = lr_descr_struct->components.

      loop at lt_struct_components reference into lr_struct_component.
*       Get field values of before_image and actual
        unassign: <lv_checkfield_before>
                , <lv_checkfield_actual>
                .
        assign component lr_struct_component->name of structure ms_segment_defaults-before_image
               to <lv_checkfield_before>.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.
        assign component lr_struct_component->name of structure ms_segment_defaults-actual
               to <lv_checkfield_actual>.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.

*       If field value has been changed ==> check if this change is distribution relevant
        if <lv_checkfield_before> <> <lv_checkfield_actual>.
          clear: ls_node_filter .
          ls_node_filter-node_name  = if_identity_definition=>gc_node_defaults.
          ls_node_filter-node_field = lr_struct_component->name.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute-user_masterdata.
*         If one node or field of user master data is distribution relevant ==>
*         complete user master data should be distributed, no further check is needed
          if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
            return.
          endif.
        endif.
      endloop.
    endif.

* ------
*   MS_SEGMENT_ADDRESS changes
    if ms_segment_address-status  eq go_persistence->co_seg_changed.
*--   If Cost Center has been changed (node LOGONDATA)
      if ms_segment_address-before_image-kostl <> ms_segment_address-actual-kostl.
        clear: ls_node_filter .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_logondata.
        ls_node_filter-node_field = if_identity_definition=>gc_field_logondata_kostl.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.

*--   If Start menu has been changed (node DEFAULTS)
      if ms_segment_address-before_image-start_menu <> ms_segment_address-actual-start_menu.
        clear: ls_node_filter .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_defaults.
        ls_node_filter-node_field = if_identity_definition=>gc_field_defaults_start_menu.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.

*--   If company has been changed
      if ms_segment_address-before_image-addrnumber <> ms_segment_address-actual-addrnumber.
        clear: ls_node_filter .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_organization.
        ls_node_filter-node_field = if_identity_definition=>gc_field_organization_company.

*         Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*         If one node or field of user master data is distribution relevant ==>
*         complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.

*--   If responsible person has been changed
      if ms_segment_address-before_image-responsible <> ms_segment_address-actual-responsible.
        clear: ls_node_filter .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_tech_user_data.
        ls_node_filter-node_field = if_identity_definition=>gc_field_techuser_responsible.

*         Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*         If one node or field of user master data is distribution relevant ==>
*         complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.

*--   If description has been changed
      if ms_segment_address-before_image-techdesc <> ms_segment_address-actual-techdesc.
        clear: ls_node_filter .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_tech_user_data.
        ls_node_filter-node_field = if_identity_definition=>gc_field_techuser_techdesc.

*         Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*         If one node or field of user master data is distribution relevant ==>
*         complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.

    endif.

* ------
*  Address has been changed
    if ms_segment_address-actadd-changed_bas_workplace_node_id is not initial or
       ms_segment_address-actadd-changed_bp                    is not initial or
       ms_segment_address-actadd-changed_bprel                 is not initial.
*--   If person name has been changed
      me->get_personname(
        exporting
          iv_request_before_image = if_identity=>co_true
        importing
          es_personname           = ls_personname_before ).

      me->get_personname(
        importing
          es_personname = ls_personname_actual ).

      if ls_personname_before <> ls_personname_actual.
        refresh: lt_node_fields.

*       Get list of fields belonging to the node PERSON_NAME
        call method cl_suid_tools=>get_node_fields
          exporting
            iv_node_name   = if_identity_definition=>gc_node_person_name
          importing
            et_node_fields = lt_node_fields.

        loop at lt_node_fields reference into lr_field.
*         Get field values of before_image and actual
          unassign: <lv_checkfield_before>
                  , <lv_checkfield_actual>
                  .
          assign component lr_field->* of structure ls_personname_before
                 to <lv_checkfield_before>.
          if sy-subrc ne 0.
            macro_raise_internal_error.
          endif.
          assign component lr_field->* of structure ls_personname_actual
                 to <lv_checkfield_actual>.
          if sy-subrc ne 0.
            macro_raise_internal_error.
          endif.

*         Check changed fields
          if <lv_checkfield_before> <> <lv_checkfield_actual>.
            clear: ls_node_filter.
            ls_node_filter-node_name  = if_identity_definition=>gc_node_person_name.
            ls_node_filter-node_field = lr_field->*.

*           Get CUA distribution filter for changed field (node)
            call method cua_check_field_distribute
              exporting
                is_node_field = ls_node_filter
              importing
                ev_distribute = es_cua_data_distribute-user_masterdata.
*           If one node or field of user master data is distribution relevant ==>
*           complete user master data should be distributed, no further check is needed
            if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
              return.
            endif.
          endif.
        endloop.
      endif.

*--   If workplace has been changed
      me->get_workplacedata(
         exporting
           iv_request_before_image = if_identity=>co_true
         importing
           es_workplace            = ls_workplace_before  ).

      me->get_workplacedata(
         importing
           es_workplace            = ls_workplace_actual  ).

      if ls_workplace_before <> ls_workplace_actual.
        refresh: lt_node_fields.

*       Get list of fields belonging to the node PERSON_NAME
        call method cl_suid_tools=>get_node_fields
          exporting
            iv_node_name   = if_identity_definition=>gc_node_workplace
          importing
            et_node_fields = lt_node_fields.

        loop at lt_node_fields reference into lr_field.
*         Get field values of before_image and actual
          unassign: <lv_checkfield_before>
                  , <lv_checkfield_actual>
                  .
          assign component lr_field->* of structure ls_workplace_before
                 to <lv_checkfield_before>.
          if sy-subrc ne 0.
            macro_raise_internal_error.
          endif.
          assign component lr_field->* of structure ls_workplace_actual
                 to <lv_checkfield_actual>.
          if sy-subrc ne 0.
            macro_raise_internal_error.
          endif.

*         Check changed fields
          if <lv_checkfield_before> <> <lv_checkfield_actual>.
            clear: ls_node_filter.
            ls_node_filter-node_name  = if_identity_definition=>gc_node_workplace.
            ls_node_filter-node_field = lr_field->*.

*           Get CUA distribution filter for changed field (node)
            call method cua_check_field_distribute
              exporting
                is_node_field = ls_node_filter
              importing
                ev_distribute = es_cua_data_distribute-user_masterdata.
*            If one node or field of user master data is distribution relevant ==>
*           complete user master data should be distributed, no further check is needed
            if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
              return.
            endif.
          endif.
        endloop.
      endif.

*--   If communication data has been changed
*     Get old communication data
      me->get_communication_data(
        exporting
          iv_retrieve_commdata_all = if_identity=>co_true
          iv_request_before_image  = if_identity=>co_true
        importing
          et_telephone             = lt_telephone_before
          et_facsimile             = lt_facsimile_before
          et_email                 = lt_email_before
          et_web                   = lt_web_before
          et_telex                 = lt_telex_before
          et_teletex               = lt_teletex_before
          et_rml                   = lt_rml_before
          et_x400                  = lt_x400_before
          et_printer               = lt_printer_before
          et_ssf                   = lt_ssf_before
          et_pager                 = lt_pager_before     ).
*     Get actual communication data
      me->get_communication_data(
        exporting
          iv_retrieve_commdata_all = if_identity=>co_true
        importing
          et_telephone             = lt_telephone_actual
          et_facsimile             = lt_facsimile_actual
          et_email                 = lt_email_actual
          et_web                   = lt_web_actual
          et_telex                 = lt_telex_actual
          et_teletex               = lt_teletex_actual
          et_rml                   = lt_rml_actual
          et_x400                  = lt_x400_actual
          et_printer               = lt_printer_actual
          et_ssf                   = lt_ssf_actual
          et_pager                 = lt_pager_actual     ).

*     Check if some communication data has been changed
      if lt_telephone_before <> lt_telephone_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_telephone.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_facsimile_before <> lt_facsimile_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_facsimile.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_email_before <> lt_email_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_email.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_web_before <> lt_web_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_web.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_telex_before <> lt_telex_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_telex.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_teletex_before <> lt_teletex_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_teletex.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_rml_before <> lt_rml_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_remote_mail.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_x400_before <> lt_x400_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_x400.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_printer_before <> lt_printer_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_printer.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_ssf_before <> lt_ssf_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_ssf.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
*-----
      if lt_pager_before <> lt_pager_actual.
        clear: ls_node_filter.
        ls_node_filter-node_name  = if_identity_definition=>gc_node_pager.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = es_cua_data_distribute-user_masterdata.
*       If one node or field of user master data is distribution relevant ==>
*       complete user master data should be distributed, no further check is needed
        if es_cua_data_distribute-user_masterdata = if_identity=>co_true.
          return.
        endif.
      endif.
    endif.


*----------------------------------------------------------------------
*        Checks, which are only child system relevant
*!!! Although SCUM allow attribute 'B' for Personalization,
*    back distribution for it was never and is not implemented
*----------------------------------------------------------------------
  elseif gv_cua_child = if_identity=>co_true.

* No back distribution in create mode
    if ms_manager-modus = go_persistence->co_ta_modus_create.
      return.
    endif.

*   No back distribution for not CUA users
    if mv_cua_mode = co_cua_not_transferred or
       mv_cua_mode = co_cua_local_create .
      return.
    endif.

* ------
*   MS_SEGMENT_PARAMETER changes
    if ms_segment_parameter-status  eq go_persistence->co_seg_changed.
*     Get CUA distribution filter for changed field (node)
      clear: ls_node_filter .
      ls_node_filter-node_name  = if_identity_definition=>gc_node_parameter.
      call method cua_check_field_distribute
        exporting
          is_node_field = ls_node_filter
        importing
          ev_distribute = lv_distribute.
      if lv_distribute = if_identity=>co_true.
        clear es_cua_data_distribute_back-parameterx with 'X'.
      endif.
    endif.

*-----
*   MS_SEGMENT_HEADER changes
    if ms_segment_header-status  eq go_persistence->co_seg_changed.
      refresh: lt_node_fields.

*     Here we only check segment fields, which belong to nodes LOGONDATA and DEFAULTS
*     Other fields are either not back distribution relevant

*     Get list of fields belonging to the node LOGONDATA
      call method cl_suid_tools=>get_node_fields
        exporting
          iv_node_name   = if_identity_definition=>gc_node_logondata
        importing
          et_node_fields = lt_node_fields.

      loop at lt_node_fields reference into lr_field.
*       Get field values of before_image and actual
        unassign: <lv_checkfield_before>
                , <lv_checkfield_actual>
                .
        assign component lr_field->* of structure ms_segment_header-before_image
               to <lv_checkfield_before>.
        if sy-subrc ne 0.
          continue.
        endif.
        assign component lr_field->* of structure ms_segment_header-actual
               to <lv_checkfield_actual>.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.

*       If field value has been changed ==> check if this change is distribution relevant
        if <lv_checkfield_before> <> <lv_checkfield_actual>.
          clear: ls_node_filter
               , lv_distribute
               .
          ls_node_filter-node_name  = if_identity_definition=>gc_node_logondata.
          ls_node_filter-node_field = lr_field->*.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = lv_distribute.
*         If field is back distribution relevant ==> set 'X' in change fields structure
          if lv_distribute = if_identity=>co_true.
*           Set change field flag in LOGONDATAX
            call method cl_suid_tools=>set_structure_field_value
              exporting
                iv_field       = lr_field->*
                iv_field_value = if_identity=>co_true
              changing
                cs_structure   = es_cua_data_distribute_back-logondatax.
          endif.
        endif.
      endloop.

*     Get field values of before_image and actual
      unassign: <lv_checkfield_before>
              , <lv_checkfield_actual>
              .
*     Check field TZONE from node DAFAULTS
      assign component if_identity_definition=>gc_field_defaults_tzone
             of structure ms_segment_header-before_image to <lv_checkfield_before>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.
      assign component if_identity_definition=>gc_field_defaults_tzone
             of structure ms_segment_header-actual to <lv_checkfield_actual>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

*     If field value has been changed ==> check if this change is distribution relevant
      if <lv_checkfield_before> <> <lv_checkfield_actual>.
        clear: ls_node_filter
             , lv_distribute
             .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_defaults.
        ls_node_filter-node_field = if_identity_definition=>gc_field_defaults_tzone.
*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = lv_distribute.
*       If field is back distribution relevant ==> set 'X' in change fields structure
        if lv_distribute = if_identity=>co_true.
*         Set change field flag in LOGONDATAX
          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field       = if_identity_definition=>gc_field_defaults_tzone
              iv_field_value = if_identity=>co_true
            changing
              cs_structure   = es_cua_data_distribute_back-logondatax.
        endif.
      endif.
    endif.

* ------
*   MS_SEGMENT_DEFAULTS changes
    if ms_segment_defaults-status  eq go_persistence->co_seg_changed.
      clear: lr_descr_struct.
      refresh: lt_struct_components.

*     Get fields of segment before_image structure
      lr_descr_struct ?= cl_abap_structdescr=>describe_by_data( ms_segment_defaults-before_image ).
      lt_struct_components = lr_descr_struct->components.

      loop at lt_struct_components reference into lr_struct_component.
*       Get field values of before_image and actual
        unassign: <lv_checkfield_before>
                , <lv_checkfield_actual>
                .
        assign component lr_struct_component->name of structure ms_segment_defaults-before_image
               to <lv_checkfield_before>.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.
        assign component lr_struct_component->name of structure ms_segment_defaults-actual
               to <lv_checkfield_actual>.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.

*       If field value has been changed ==> check if this change is distribution relevant
        if <lv_checkfield_before> <> <lv_checkfield_actual>.
          clear: ls_node_filter
               , lv_distribute
               .
          ls_node_filter-node_name  = if_identity_definition=>gc_node_defaults.
          ls_node_filter-node_field = lr_struct_component->name.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = lv_distribute.
*         If field is back distribution relevant ==> set 'X' in change fields structure
          if lv_distribute = if_identity=>co_true.
            if lr_struct_component->name = if_identity_definition=>gc_field_defaults_cattkennz.
              es_cua_data_distribute_back-defaultsx-catt = if_identity=>co_true.
            else.
*             Set change field flag in DEFAULTSX
              call method cl_suid_tools=>set_structure_field_value
                exporting
                  iv_field       = lr_struct_component->name
                  iv_field_value = if_identity=>co_true
                changing
                  cs_structure   = es_cua_data_distribute_back-defaultsx.
            endif.
          endif.
        endif.
      endloop.
    endif.

* ------
*   MS_SEGMENT_ADDRESS changes
    if ms_segment_address-status  eq go_persistence->co_seg_changed.
*--   If cost center has been changed (node LOGONDATA)
      if ms_segment_address-before_image-kostl <> ms_segment_address-actual-kostl.
        clear: ls_node_filter
             , lv_distribute
             .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_logondata.
        ls_node_filter-node_field = if_identity_definition=>gc_field_logondata_kostl.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = lv_distribute.
*       If field is back distribution relevant ==> set 'X' in change fields structure
        if lv_distribute = if_identity=>co_true.
*         Set change field flag in DEFAULTSX-KOSTL
          es_cua_data_distribute_back-defaultsx-kostl = if_identity=>co_true.
        endif.
      endif.

*--   If Start menu has been changed (node DAFAULTS)
      if ms_segment_address-before_image-start_menu <> ms_segment_address-actual-start_menu.
        clear: ls_node_filter
             , lv_distribute
             .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_defaults.
        ls_node_filter-node_field = if_identity_definition=>gc_field_defaults_start_menu.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = lv_distribute.
*       If field is back distribution relevant ==> set 'X' in change fields structure
        if lv_distribute = if_identity=>co_true.
*         Set change field flag in DEFAULTSX-START_MENU
          es_cua_data_distribute_back-defaultsx-start_menu = if_identity=>co_true.
        endif.
      endif.

*--   If company has been changed
      if ms_segment_address-before_image-addrnumber <> ms_segment_address-actual-addrnumber.
        clear: ls_node_filter
             , lv_distribute
             .
        ls_node_filter-node_name  = if_identity_definition=>gc_node_organization.
        ls_node_filter-node_field = if_identity_definition=>gc_field_organization_company.

*       Get CUA distribution filter for changed field (node)
        call method cua_check_field_distribute
          exporting
            is_node_field = ls_node_filter
          importing
            ev_distribute = lv_distribute.
*       If field is back distribution relevant ==> set 'X' in change fields structure
        if lv_distribute = if_identity=>co_true.
*         Set change field flag in COMPANYX
          clear es_cua_data_distribute_back-companyx with 'X'.
        endif.
      endif.
    endif.

* ------
*   Address data has been changed
    if ms_segment_address-actadd-changed_bas_workplace_node_id is not initial or
       ms_segment_address-actadd-changed_bp                    is not initial or
       ms_segment_address-actadd-changed_bprel                 is not initial.

*--   If person name has been changed
      if ms_segment_address-actadd-changed_person_name is not initial or
         ms_segment_address-actadd-changed_bp          is not initial or
         ms_segment_address-actadd-changed_bprel       is not initial.

        me->get_personname(
          exporting
            iv_request_before_image = if_identity=>co_true
          importing
            es_personname           = ls_personname_before ).

        me->get_personname(
          importing
            es_personname = ls_personname_actual ).

        if ls_personname_before <> ls_personname_actual.
          clear: lt_node_fields.

*         Get list of fields belonging to the node PERSON_NAME
          call method cl_suid_tools=>get_node_fields
            exporting
              iv_node_name   = if_identity_definition=>gc_node_person_name
            importing
              et_node_fields = lt_node_fields.

          loop at lt_node_fields reference into lr_field.
*           Get field values of before_image and actual
            unassign: <lv_checkfield_before>
                    , <lv_checkfield_actual>
                    .
            assign component lr_field->* of structure ls_personname_before
                   to <lv_checkfield_before>.
            if sy-subrc ne 0.
              macro_raise_internal_error.
            endif.
            assign component lr_field->* of structure ls_personname_actual
                   to <lv_checkfield_actual>.
            if sy-subrc ne 0.
              macro_raise_internal_error.
            endif.

*           Check changed fields
            if <lv_checkfield_before> <> <lv_checkfield_actual>.
              clear: ls_node_filter
                   , lv_distribute
                   .
              ls_node_filter-node_name  = if_identity_definition=>gc_node_person_name.
              ls_node_filter-node_field = lr_field->*.

*             Get CUA distribution filter for changed field (node)
              call method cua_check_field_distribute
                exporting
                  is_node_field = ls_node_filter
                importing
                  ev_distribute = lv_distribute.
*             If field is back distribution relevant ==> set 'X' in change fields structure
              if lv_distribute = if_identity=>co_true.
                ls_distr_nodefields-node_name  = ls_node_filter-node_name.
                ls_distr_nodefields-field_name = ls_node_filter-node_field.
                append ls_distr_nodefields to lt_distr_nodefields.
              endif.
            endif.
          endloop.
        endif.
      endif.

*--   If workplace has been changed
      if ms_segment_address-actadd-changed_workplace_data is not initial or
         ms_segment_address-actadd-changed_bp             is not initial or
         ms_segment_address-actadd-changed_bprel          is not initial.
        me->get_workplacedata(
           exporting
             iv_request_before_image = if_identity=>co_true
           importing
             es_workplace            = ls_workplace_before  ).

        me->get_workplacedata(
           importing
             es_workplace            = ls_workplace_actual  ).

        if ls_workplace_before <> ls_workplace_actual.
          clear: lt_node_fields.

*         Get list of fields belonging to the node WORKPLACE
          call method cl_suid_tools=>get_node_fields
            exporting
              iv_node_name   = if_identity_definition=>gc_node_workplace
            importing
              et_node_fields = lt_node_fields.

          loop at lt_node_fields reference into lr_field.
*           Get field values of before_image and actual
            unassign: <lv_checkfield_before>
                    , <lv_checkfield_actual>
                    .
            assign component lr_field->* of structure ls_workplace_before
                   to <lv_checkfield_before>.
            if sy-subrc ne 0.
              macro_raise_internal_error.
            endif.
            assign component lr_field->* of structure ls_workplace_actual
                   to <lv_checkfield_actual>.
            if sy-subrc ne 0.
              macro_raise_internal_error.
            endif.

*           Check changed fields
            if <lv_checkfield_before> <> <lv_checkfield_actual>.
              clear: ls_node_filter
                   , lv_distribute
                   .
              ls_node_filter-node_name  = if_identity_definition=>gc_node_workplace.
              ls_node_filter-node_field = lr_field->*.

*             Get CUA distribution filter for changed field (node)
              call method cua_check_field_distribute
                exporting
                  is_node_field = ls_node_filter
                importing
                  ev_distribute = lv_distribute.
*             If field is back distribution relevant ==> set 'X' in change fields structure
              if lv_distribute = if_identity=>co_true.
                ls_distr_nodefields-node_name  = ls_node_filter-node_name.
                ls_distr_nodefields-field_name = ls_node_filter-node_field.
                append ls_distr_nodefields to lt_distr_nodefields.
              endif.
            endif.
          endloop.
        endif.
      endif.

*----- Map Person name and Workplace nodes' fields with BAPIADDR3X
      if lt_distr_nodefields is not initial.
        cl_suid_tools=>map_address_nodes_to_bapi(
          exporting
            it_changed_addr_nodefields = lt_distr_nodefields
          changing
            cs_bapiaddr3x              = es_cua_data_distribute_back-addressx ).
      endif.


*--   If communication data has been changed
      if ms_segment_address-actadd-changed_comm_data is not initial or
         ms_segment_address-actadd-changed_bp        is not initial or
         ms_segment_address-actadd-changed_bprel     is not initial.

        me->get_communication_data(
          exporting
            iv_retrieve_commdata_all = if_identity=>co_true
            iv_request_before_image  = if_identity=>co_true
          importing
            et_telephone             = lt_telephone_before
            et_facsimile             = lt_facsimile_before
            et_email                 = lt_email_before
            et_web                   = lt_web_before
            et_telex                 = lt_telex_before
            et_teletex               = lt_teletex_before
            et_rml                   = lt_rml_before
            et_x400                  = lt_x400_before
            et_printer               = lt_printer_before
            et_ssf                   = lt_ssf_before
            et_pager                 = lt_pager_before     ).

        me->get_communication_data(
          exporting
            iv_retrieve_commdata_all = if_identity=>co_true
          importing
            et_telephone             = lt_telephone_actual
            et_facsimile             = lt_facsimile_actual
            et_email                 = lt_email_actual
            et_web                   = lt_web_actual
            et_telex                 = lt_telex_actual
            et_teletex               = lt_teletex_actual
            et_rml                   = lt_rml_actual
            et_x400                  = lt_x400_actual
            et_printer               = lt_printer_actual
            et_ssf                   = lt_ssf_actual
            et_pager                 = lt_pager_actual     ).
*-----
        if lt_telephone_before <> lt_telephone_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_telephone.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adtel.
*         Communication data should be distributed with communication notes and
*         corresponding fields from BAPIADDR3
          if es_cua_data_distribute_back-addcomx-adtel = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.

            es_cua_data_distribute_back-addressx-tel1_numbr = if_identity=>co_true.
            es_cua_data_distribute_back-addressx-tel1_ext   = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_facsimile_before <> lt_facsimile_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_facsimile.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adfax.
*         Communication data should be distributed with communication notes and
*         corresponding fields from BAPIADDR3
          if es_cua_data_distribute_back-addcomx-adfax = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.

            es_cua_data_distribute_back-addressx-fax_number = if_identity=>co_true.
            es_cua_data_distribute_back-addressx-fax_extens = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_email_before <> lt_email_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_email.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adsmtp.
*         Communication data should be distributed with communication notes and
*         corresponding fields from BAPIADDR3
          if es_cua_data_distribute_back-addcomx-adsmtp = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.

            es_cua_data_distribute_back-addressx-e_mail     = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_web_before <> lt_web_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_web.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-aduri.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-aduri = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_telex_before <> lt_telex_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_telex.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adtlx.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adtlx = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_teletex_before <> lt_teletex_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_teletex.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adttx.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adttx = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_rml_before <> lt_rml_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_remote_mail.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adrml.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adrml = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_x400_before <> lt_x400_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_x400.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adx400.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adx400 = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_printer_before <> lt_printer_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_printer.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adprt.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adprt = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_ssf_before <> lt_ssf_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_ssf.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adssf.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adssf = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
*-----
        if lt_pager_before <> lt_pager_actual.
          clear: ls_node_filter.
          ls_node_filter-node_name  = if_identity_definition=>gc_node_pager.

*         Get CUA distribution filter for changed field (node)
          call method cua_check_field_distribute
            exporting
              is_node_field = ls_node_filter
            importing
              ev_distribute = es_cua_data_distribute_back-addcomx-adpag.
*         Communication data should be distributed with communication notes
          if es_cua_data_distribute_back-addcomx-adpag = if_identity=>co_true.
            es_cua_data_distribute_back-addcomx-adcomrem = if_identity=>co_true.
          endif.
        endif.
      endif.
    endif.

  endif.



endmethod.


method cua_if_field_no_maintain.
* Check if field or node can be maintained
* If field/node can't be maintained and it is not idoc processing - place message into message buffer
*
*  At Idoc processing fields with SCUM attrubute 'Proposal' can be changed only in Create mode or
*  if a user is "Reseved" - Profile/Role Idoc was processed before User Idoc and user didn't exist
*  at that time ==> the user was created with default values, deactivated password and profile/role
*  assignment and was marked as "Reserved" by entry for USER section indb USZBVSYS with status 'O' -
*  assignment unconfirmed (the only case in child system when status 'O' is set)


  data:  ls_field_filter type        suid_st_cua_filters
       , ls_msg          type        symsg
       .


* --- Maintenance check -----------------------------------------------
  if gv_cua_active ne if_identity=>co_true.
    return.
  endif.

* --- Central system: ---
  if gv_cua_central eq if_identity=>co_true.
    case iv_node_name.
      when if_identity_definition=>gc_node_cua_password  or
           if_identity_definition=>gc_node_cua_role      or
           if_identity_definition=>gc_node_cua_profile   or
           if_identity_definition=>gc_node_cua_uclass    or
           if_identity_definition=>gc_node_cua_system    or
           if_identity_definition=>gc_node_lockdata      .

        " Use case CUA nodes: no maintenance if SCUM attribute is not set to 'Global'
        ls_field_filter-node_name  = iv_node_name.
        if iv_field_name is supplied.
          ls_field_filter-node_field = iv_field_name.
        endif.

        " Get CUA distribution filter for field
        call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
          changing
            cs_field_filter = ls_field_filter.

        " If field can't be changed -> exclude it from further processing
        if ls_field_filter-field_maint eq if_suid_cua_runtime=>gc_no_maint.
          " Add message, informing that field can't be changed
          clear: ls_msg.
          ls_msg-msgty = if_suid_msg_buffer=>co_type_warning.
          if  ls_field_filter-node_name = if_identity_definition=>gc_node_cua_uclass.
            " Special message for CUA Licence data
            " MSG: Keine systemspezifische Nutzerklassifikation: Lizenzdaten nicht 'global'
            if 1 = 0. message e267(bv). endif.
            ls_msg-msgid = 'BV'.
            ls_msg-msgno = '267'.
          else.
            " Otherwise common message
            ls_msg-msgid = 'SUID01'.
            ls_msg-msgno = '201'.
            ls_msg-msgv1 = iv_node_name.
            ls_msg-msgv2 = iv_field_name.

            call method cl_suid_tools=>get_node_field_description
              exporting
                iv_node_name   = iv_node_name
                iv_field_name  = iv_field_name
              importing
                ev_description = ls_msg-msgv3.

            " Das Benutzerattribut '&3' kann in diesem System nicht gepflegt werden.
            if 1 = 0. message w201(suid01) with ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3. endif.
          endif.

          rv_no_maintain = if_identity=>co_true.
        endif.

      when others.
        return.
    endcase.

* --- Active CUA, no check for not transferred or local users needed ---
  elseif gv_cua_child eq if_identity=>co_true    and
         mv_cua_mode  ne co_cua_not_transferred  and
         mv_cua_mode  ne co_cua_local_create.

    ls_field_filter-node_name  = iv_node_name.
    if iv_field_name is supplied.
      ls_field_filter-node_field = iv_field_name.
    endif.

    " Get CUA distribution filter for field
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_field_filter.

    " Idoc processing
    if gv_idoc_processing eq if_identity=>co_true and
       gv_cua_child       eq if_identity=>co_true.
      " If at Idoc processing user was retrieved for update ==> user is
      " transferred into CUA landscape, no special check is needed here
      case ls_field_filter-field_attr.
        when if_suid_cua_runtime=>gc_local.
          rv_no_maintain = if_identity=>co_true.

        when if_suid_cua_runtime=>gc_template.
          " Proposal can be maintained only in create CUA user mode or for reserved CUA users
          if mv_cua_mode <> co_cua_reserved and mv_cua_mode <> co_cua_create.
            rv_no_maintain = if_identity=>co_true.
          endif.
        when others.
      endcase.

      " Normal user maintenance process
    else.
      " If field can't be changed -> exclude it from further processing
      if ls_field_filter-field_maint eq if_suid_cua_runtime=>gc_no_maint.
        " Add message, informing that field can't be changed
        clear: ls_msg.
        ls_msg-msgty = if_suid_msg_buffer=>co_type_warning.
        ls_msg-msgid = 'SUID01'.
        ls_msg-msgno = '201'.
        ls_msg-msgv1 = iv_node_name.
        ls_msg-msgv2 = iv_field_name.

        call method cl_suid_tools=>get_node_field_description
          exporting
            iv_node_name   = iv_node_name
            iv_field_name  = iv_field_name
          importing
            ev_description = ls_msg-msgv3.

        " Das Benutzerattribut '&3' kann in diesem System nicht gepflegt werden.
        if 1 = 0. message w201(suid01) with ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3. endif.

        rv_no_maintain = if_identity=>co_true.
      endif.

    endif.
  endif.

  " Place message in message buffer if needed
  if rv_no_maintain = if_identity=>co_true and
     io_msg_buffer is bound                and
     ls_msg is not initial.

    call method io_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = iv_node_name
        iv_field    = iv_field_name
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
  endif.


endmethod.


method cua_prepare_changed_user_send.
* Method is called when identity modifications should be distributed, not for
* simple identity redistribution
*
* Inside of this method it is calculated if identity modifications are
* distribution relevant (on base of field filter and modification mode)
*
* This method must only be called inside SAVE
* -> No authority checks anymore !!!!
*


  data: lv_central_logsys           type        uszbvlndsc-sendsystem
      , lr_actual_cua_systems       type ref to uszbvsys
      , lr_actual                   type ref to uszbvsys
      , lr_before                   type ref to uszbvsys
      , lv_tabix                    type        sy-tabix
      , lt_changed_systems          type        suid_tt_node_cua_systems
      , lr_syst                     type ref to suid_st_node_cua_system
      , lr_cua_user_syst_distr      type ref to ty_cua_user_syst_distr
      , lv_syst_not_assigned        type        sesf_boolean
      , lr_cua_password             type ref to suid_st_node_cua_password
      , lt_changed_uclass_systems   type        suid_tt_node_cua_systems
      , ls_cua_data_distribute      type        ty_cua_data_distribute
      , lr_system                   type ref to ussystem
      , lv_no_distr                 type        sesf_boolean
      , lv_delete                   type        sesf_boolean
      .


* Actual system is not central system of active CUA
  if gv_cua_central ne if_identity=>co_true.
    return.
  endif.

*---------- Local user in central system --------------
** Exit if not CUA user
*  if mv_cua_mode = co_cua_not_transferred or
*     mv_cua_mode = co_cua_local_create    .
*    return.
*  endif.

  clear: et_cua_user_syst_distr.

  if ms_manager-modus  eq go_persistence->co_ta_modus_display.
    return.
  endif.

  if ms_manager-status ne go_persistence->co_ta_status_finalized.
*   SCUG: also unchanged users without fatal errors can be processed
    if not ( gs_cua_user_transfer-active eq if_identity=>co_true and
             ms_manager-status eq go_persistence->co_ta_status_unchanged ).
      return.
    endif.
  endif.


* Get active CUA central system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys = lv_central_logsys.

* Fill CUA_SYSTEMS segment if needed
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.

* Retrieve list of distribution or USZBVSYS/USZBVPROT modification relevant user changes
  cua_get_changes_for_distribute(
    importing
      es_cua_data_distribute      = ls_cua_data_distribute  ).



*------------------------------------------------------------------------------------
*          System Assignment and User master modification
*------------------------------------------------------------------------------------
* Check if USER section should be distributed to all child systems:
*    -  If user is to be deleted --> USER Idoc with bapi method 'DELETE' should be
*                                    distributed to all assigned child systems
*    -  If user was created --> USER Idoc should be distributed to all systems, which
*                               were added during transaction
*    -  If some user master data was changed --> USER Idoc should be sent to all assigned systems
*                                                (if changed data was distribution relevant)
*------------------------------------------------------------------------------------

* If no other fields of user master data changes should be distributed to all systems
*  ==> check if Licence data should be distributed to some systems
  if ls_cua_data_distribute-user_masterdata = if_identity=>co_false and
     ls_cua_data_distribute-license_data    = if_identity=>co_true.
*   Get list of systems, for which Licence data was changed
    if ls_cua_data_distribute-license_data = if_identity=>co_true.
      call method uclasses_cua_get_changed
        importing
          et_changed_systems = lt_changed_uclass_systems.
    endif.
  endif.

* ---- Prepare distribution of USER section ---------------------------------------
*
  if ls_cua_data_distribute-user_masterdata = if_identity=>co_true or
     ls_cua_data_distribute-cua_systems     = if_identity=>co_true or
     ls_cua_data_distribute-license_data    = if_identity=>co_true .
*   Handle USER section and collect for distribution
    loop at ms_segment_cua_systems-actual reference into lr_actual_cua_systems
         where usrsection eq if_suid_cua_runtime=>gc_user_usrsection.
      clear: lv_delete
           , lv_no_distr.

*---- Special handling for SCUG: changes refer only one source system, ignore other
      if gs_cua_user_transfer-active = if_identity=>co_true and
         ( lr_actual_cua_systems->subsystem <> gs_cua_user_transfer-source_system ).
        continue.
      endif.

* --- Delete mode
      if ms_manager-modus = go_persistence->co_ta_modus_delete.
*       No distribution to deleted system
        if lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted         or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_deleted   or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted_runtime or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_failed_delete   .

          continue.
        endif.

        lv_delete = if_identity=>co_true.

*       Update table of deleted system assignments
        read table ms_segment_cua_systems-systems_del
             with key subsystem = lr_actual_cua_systems->subsystem
             transporting no fields
             binary search.
        if sy-subrc <> 0.
          insert initial line into ms_segment_cua_systems-systems_del
                 reference into lr_system index sy-tabix.
          lr_system->subsystem = lr_actual_cua_systems->subsystem.
        endif.

* --- Change/Create mode
      else.
*       Check if system assignment hasn't been deleted during actual transaction
        read table ms_segment_cua_systems-systems_del
             with key subsystem = lr_actual_cua_systems->subsystem
             transporting no fields
             binary search.
*       Deleted assignment
        if sy-subrc = 0.
          lv_delete = if_identity=>co_true.

*       Active assignment
        else.
* ....... No user master data has been changed
          if ls_cua_data_distribute-user_masterdata = if_identity=>co_false.
*           Check if system assignment has been added during actual transaction
            read table ms_segment_cua_systems-systems_add
                 with key subsystem = lr_actual_cua_systems->subsystem
                 transporting no fields
                 binary search.
*           Not a new system assignment
            if sy-subrc <> 0.
              lv_no_distr = if_identity=>co_true.

*             Some Licence data assignmen has been changed
              if ls_cua_data_distribute-license_data = if_identity=>co_true.
*               Check if Licence data for system has been changed
                read table lt_changed_uclass_systems
                     with key subsystem = lr_actual_cua_systems->subsystem
                     transporting no fields
                     binary search.
*               License data for actual system has been changed
                if sy-subrc = 0    and
*                  and system assignment is active ==> distribute to this system
                   lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_deleted         and
                   lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_to_be_deleted   and
                   lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_deleted_runtime and
                   lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_failed_delete   .

                  clear: lv_no_distr.

                endif.
              endif.
            endif.

* ....... User master data has been changed
          else.
*           No distribution to deleted system
            if lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted         or
               lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_deleted   or
               lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted_runtime or
               lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_failed_delete   .
              lv_no_distr = if_identity=>co_true.
            endif.
          endif.

        endif.
      endif.

      if lv_no_distr = if_identity=>co_true.
        continue.
      endif.

* --- Special handling of deleted assignments --------------------------------------*
      if lv_delete = if_identity=>co_true.
*       If system assignment is deleted then role and profile assignment are deleted
*       automatically too (corresponding entries in USZBVSYS and USZBVPROT should be deleted)

*...    Handle role usersection
*       Check if there is role assignment and if positive ==> delete
        read table ms_segment_cua_systems-actual reference into lr_actual
             with key usrsection = if_suid_cua_runtime=>gc_role_usrsection
                      subsystem  = lr_actual_cua_systems->subsystem
             binary search.
        if sy-subrc = 0.
          lv_tabix = sy-tabix.
          delete ms_segment_cua_systems-actual index lv_tabix.

**       In USZBVSYS PROFILE and ACTGRP section stay as they are in
**       BEFORE_IMAGE, deletion is registered only in USER section
**         Check if section was added during this transaction
*          read table ms_segment_cua_systems-before_image reference into lr_before
*               with key usrsection = if_suid_cua_runtime=>gc_role_usrsection
*                        subsystem  = lr_actual_cua_systems->subsystem
*               binary search.
**         If true --> simply delete entry
*          if sy-subrc <> 0.
*            delete ms_segment_cua_systems-actual index lv_tabix.
**           Otherwise --> restore entry from before_image
*          else.
*            lr_actual->* = lr_before->*.
*          endif.
        endif.

*...    Handle profile usersection
*       Check if there is profile assignments and if positive ==> delete
        read table ms_segment_cua_systems-actual reference into lr_actual
             with key usrsection = if_suid_cua_runtime=>gc_prof_usrsection
                      subsystem  = lr_actual_cua_systems->subsystem
             binary search.
        if sy-subrc = 0.
          lv_tabix = sy-tabix.
          delete ms_segment_cua_systems-actual index lv_tabix.

**       In USZBVSYS PROFILE and ACTGRP section stay as they are in
**       BEFORE_IMAGE, deletion is registered only in USER section
**         Check if section was added during this transaction
*          read table ms_segment_cua_systems-before_image reference into lr_before
*               with key usrsection = if_suid_cua_runtime=>gc_prof_usrsection
*                        subsystem  = lr_actual_cua_systems->subsystem
*               binary search.
**         If true --> simply delete entry
*          if sy-subrc <> 0.
*            delete ms_segment_cua_systems-actual index lv_tabix.
**         Otherwise --> restore entry from before_image
*          else.
*            lr_actual->* = lr_before->*.
*          endif.
        endif.

*       Delete role and profile usrsections from USZBVPROT
        cua_delete_user_system_prot(
            iv_subsystem    = lr_actual_cua_systems->subsystem
            iv_role_section = if_identity=>co_true
            iv_prof_section = if_identity=>co_true   ).
      endif.

*---- Collect child systems for distribution and set there status and timestamp ----------*
*     Central system
      if lr_actual_cua_systems->subsystem = lv_central_logsys.
*       Set USBVSYS status 'D' - user assignment to system is deleted or
*       status 'S' - successfully assigned
        call method cua_set_status_for_centralsyst
          exporting
            iv_usrsection = if_suid_cua_runtime=>gc_user_usrsection
            iv_deleted    = lv_delete
            is_timestamp  = is_timestamp.

*       No distribution
        continue.

*     Child system
      else.
*       If new user is transferred into CUA from child system (transaction SCUG) ==> set status 'G'
        if mv_cua_mode = co_cua_child_copy.
          lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_transferred.
*       Normal user maintenance
        else.
          if lv_delete = if_identity=>co_true.
*           'A' - distribution of deletion is started, unconfirmed
            lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_deleted.
          else.
*           'O' - distribution is started, unconfirmed
            lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_assigned.
          endif.
        endif.

*       Set timestamp of modification date, time and user
        lr_actual_cua_systems->moddate  = is_timestamp-datum.
        lr_actual_cua_systems->modtime  = is_timestamp-uzeit.
        lr_actual_cua_systems->modifier = is_timestamp-uname.

*       To make sure that key field is filled
        lr_actual_cua_systems->mandt  = sy-mandt.

*       Collect USER section for distribution (copy new user from child system ==>
*       no distribution is needed )
        if mv_cua_mode <> co_cua_child_copy.
          read table et_cua_user_syst_distr reference into lr_cua_user_syst_distr
               with key bname     = lr_actual_cua_systems->bname
                        subsystem = lr_actual_cua_systems->subsystem
               binary search.
          if sy-subrc <> 0.
            insert initial line into et_cua_user_syst_distr reference into lr_cua_user_syst_distr
                                                            index sy-tabix.
            lr_cua_user_syst_distr->bname     = lr_actual_cua_systems->bname.
            lr_cua_user_syst_distr->subsystem = lr_actual_cua_systems->subsystem.
          endif.

*         User delete
          if lv_delete = if_identity=>co_true.
            lr_cua_user_syst_distr->usersection = if_suid_cua_runtime=>gc_deleted.
*         User master data create/maintain
          else.
            lr_cua_user_syst_distr->usersection = if_suid_cua_runtime=>gc_distribute.
          endif.
        endif.
      endif.

    endloop.
  endif.



*-------------------------------------------------------------------------------
*                         Role Assignment
*-------------------------------------------------------------------------------
  if ls_cua_data_distribute-roles is not initial.
*   If roles has been transferred from child system
    if ls_cua_data_distribute-roles = if_suid_cua_runtime=>gc_transferred.
      clear: lt_changed_systems.
      append initial line to lt_changed_systems reference into lr_syst.
      lr_syst->subsystem = gs_cua_user_transfer-source_system.

*   If role assignments modifications has been changed
    elseif ls_cua_data_distribute-roles = if_identity=>co_true.
*     Get systems with changed role assignments
      call method roles_cua_get_changed_system
        importing
          et_changed_systems = lt_changed_systems.
    endif.

*   Set role section status in USZBVSYS and collect for distribution
    loop at lt_changed_systems reference into lr_syst.
      clear: lv_syst_not_assigned.

*     Check that user has active assignment to this system
      read table ms_segment_cua_systems-actual reference into lr_actual_cua_systems
           with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                    subsystem  = lr_syst->subsystem
           binary search.
      if sy-subrc <> 0.
        lv_syst_not_assigned = if_identity=>co_true.
      else.
        if lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted         or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_deleted   or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted_runtime or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_failed_delete   .
          lv_syst_not_assigned = if_identity=>co_true.
        endif.
      endif.

*     No system assignment --> no role assignment distribution and protocol change to/for this system
      if lv_syst_not_assigned = if_identity=>co_true.
        read table ms_segment_cua_systems-actual reference into lr_actual
             with key usrsection = if_suid_cua_runtime=>gc_role_usrsection
                      subsystem  = lr_syst->subsystem
             binary search.
        if sy-subrc = 0.
          lv_tabix = sy-tabix.
*         Check if section was added during this transaction
          read table ms_segment_cua_systems-before_image reference into lr_before
               with key usrsection = if_suid_cua_runtime=>gc_role_usrsection
                        subsystem  = lr_syst->subsystem
               binary search.
*         If true --> simply delete entry
          if sy-subrc <> 0.
            delete ms_segment_cua_systems-actual index lv_tabix.
*         Otherwise --> restore entry from before_image
          else.
            lr_actual->* = lr_before->*.
          endif.
        endif.

        continue.
      endif.

*     Central system
      if lr_syst->subsystem = lv_central_logsys.
*       Set USBVSYS status 'S'
        call method cua_set_status_for_centralsyst
          exporting
            iv_usrsection = if_suid_cua_runtime=>gc_role_usrsection
            is_timestamp  = is_timestamp.
*     Child system
      else.
        read table ms_segment_cua_systems-actual reference into lr_actual
             with key usrsection = if_suid_cua_runtime=>gc_role_usrsection
                      subsystem  = lr_syst->subsystem
             binary search.
        if sy-subrc <> 0.
*         Add entry for the role section
          insert initial line into ms_segment_cua_systems-actual index sy-tabix
                 reference into lr_actual.
          lr_actual->bname       = ms_manager-bname.
          lr_actual->usrsection  = if_suid_cua_runtime=>gc_role_usrsection.
          lr_actual->subsystem   = lr_syst->subsystem.
        endif.

*       If user transfer into CUA (transaction SCUG) ==> set status 'G'
        if gs_cua_user_transfer-active = if_identity=>co_true.
          lr_actual->status = if_suid_cua_runtime=>gc_transferred.
*       In normal case ==> set status 'O'
        else.
          lr_actual->status = if_suid_cua_runtime=>gc_to_be_assigned.
        endif.
*       Set timestamp of modification date, time and user
        lr_actual->moddate  = is_timestamp-datum.
        lr_actual->modtime  = is_timestamp-uzeit.
        lr_actual->modifier = is_timestamp-uname.

*       To make sure that key field is filled
        lr_actual->mandt       = sy-mandt.

*       Collect for distribution (during user transfer role distribution is not needed)
        if gs_cua_user_transfer-active <> if_identity=>co_true.
          read table et_cua_user_syst_distr reference into lr_cua_user_syst_distr
           with key bname     = lr_actual->bname
                    subsystem = lr_actual->subsystem
           binary search.
          if sy-subrc <> 0.
            insert initial line into et_cua_user_syst_distr reference into lr_cua_user_syst_distr
                                                            index sy-tabix.
            lr_cua_user_syst_distr->bname     = lr_actual->bname.
            lr_cua_user_syst_distr->subsystem = lr_actual->subsystem.
          endif.
          lr_cua_user_syst_distr->actgrpsection = if_suid_cua_runtime=>gc_distribute.
        endif.
      endif.
    endloop.
  endif.


*-------------------------------------------------------------------------------
*                         Profile Assignment
*-------------------------------------------------------------------------------
  if ls_cua_data_distribute-profiles is not initial.
*   If profiles has been transferred from child system
    if ls_cua_data_distribute-profiles = if_suid_cua_runtime=>gc_transferred.
      clear: lt_changed_systems.
      append initial line to lt_changed_systems reference into lr_syst.
      lr_syst->subsystem = gs_cua_user_transfer-source_system.
*   If profile assignments modifications has been changed
    elseif ls_cua_data_distribute-profiles = if_identity=>co_true.
*     Get systems with changed profile assignments
      call method profile_cua_get_changed_system
        importing
          et_changed_systems = lt_changed_systems.
    endif.

*   Set profile section status in USZBVSYS and collect for distribution
    loop at lt_changed_systems reference into lr_syst.
      clear: lv_syst_not_assigned.

      if ms_manager-modus = go_persistence->co_ta_modus_delete.
        lv_syst_not_assigned = if_identity=>co_true.
      else.
*       Check that user has active assignment to this system
        read table ms_segment_cua_systems-actual reference into lr_actual_cua_systems
             with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                      subsystem  = lr_syst->subsystem
             binary search.
        if sy-subrc <> 0.
          lv_syst_not_assigned = if_identity=>co_true.
        else.
          if lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted         or
             lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_deleted   or
             lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted_runtime or
             lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_failed_delete   .
            lv_syst_not_assigned = if_identity=>co_true.
          endif.
        endif.
      endif.

*     No system assignment --> no role assignment distribution and protocol change to/for this system
      if lv_syst_not_assigned = if_identity=>co_true.
        read table ms_segment_cua_systems-actual reference into lr_actual
             with key usrsection = if_suid_cua_runtime=>gc_prof_usrsection
                      subsystem  = lr_syst->subsystem
             binary search.
        if sy-subrc = 0.
          lv_tabix = sy-tabix.
*         Check if section was added during this transaction
          read table ms_segment_cua_systems-before_image reference into lr_before
               with key usrsection = if_suid_cua_runtime=>gc_prof_usrsection
                        subsystem  = lr_syst->subsystem
               binary search.
*           If true --> simply delete entry
          if sy-subrc <> 0.
            delete ms_segment_cua_systems-actual index lv_tabix.
*         Otherwise --> restore entry from before_image
          else.
            lr_actual->* = lr_before->*.
          endif.
        endif.

        continue.
      endif.

*     Central system
      if lr_syst->subsystem = lv_central_logsys.
*         Set USBVSYS status 'S'
        call method cua_set_status_for_centralsyst
          exporting
            iv_usrsection = if_suid_cua_runtime=>gc_prof_usrsection
            is_timestamp  = is_timestamp.
*     Child system
      else.
        read table ms_segment_cua_systems-actual reference into lr_actual
             with key usrsection = if_suid_cua_runtime=>gc_prof_usrsection
                      subsystem  = lr_syst->subsystem
             binary search.
        if sy-subrc <> 0.
*         Add entry for the profile section
          insert initial line into ms_segment_cua_systems-actual index sy-tabix
                 reference into lr_actual.
          lr_actual->bname       = ms_manager-bname.
          lr_actual->usrsection  = if_suid_cua_runtime=>gc_prof_usrsection.
          lr_actual->subsystem   = lr_syst->subsystem.
        endif.

*       If user transfer into CUA (transaction SCUG) ==> set status 'G'
        if gs_cua_user_transfer-active = if_identity=>co_true.
          lr_actual->status = if_suid_cua_runtime=>gc_transferred.
*         In normal case ==> set status 'O'
        else.
          lr_actual->status = if_suid_cua_runtime=>gc_to_be_assigned.
        endif.
*       Set timestamp of modification date, time and user
        lr_actual->moddate  = is_timestamp-datum.
        lr_actual->modtime  = is_timestamp-uzeit.
        lr_actual->modifier = is_timestamp-uname.

*       To make sure that key field is filled
        lr_actual->mandt       = sy-mandt.

*       Collect for distribution (during user transfer role distribution is not needed)
        if gs_cua_user_transfer-active <> if_identity=>co_true.
          read table et_cua_user_syst_distr reference into lr_cua_user_syst_distr
           with key bname     = lr_actual->bname
                    subsystem = lr_actual->subsystem
           binary search.
          if sy-subrc <> 0.
            insert initial line into et_cua_user_syst_distr reference into lr_cua_user_syst_distr
                                                            index sy-tabix.
            lr_cua_user_syst_distr->bname     = lr_actual->bname.
            lr_cua_user_syst_distr->subsystem = lr_actual->subsystem.
          endif.
          lr_cua_user_syst_distr->profilesection = if_suid_cua_runtime=>gc_distribute.
        endif.
      endif.
    endloop.
  endif.


*-------------------------------------------------------------------------------
*                         Global Lock/Unlock
*-------------------------------------------------------------------------------
* Check if global lock/unlock was set during transaction
* (segment is filled only if SCUM settings suppose distribution)
  if ls_cua_data_distribute-global_lock = if_identity=>co_true and
     ms_manager-modus <> go_persistence->co_ta_modus_delete.

    loop at ms_segment_cua_systems-actual reference into lr_actual_cua_systems
         where usrsection eq if_suid_cua_runtime=>gc_user_usrsection.

      if lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_deleted         and
         lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_to_be_deleted   and
         lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_deleted_runtime and
         lr_actual_cua_systems->status <> if_suid_cua_runtime=>gc_failed_delete   .

*       In central system
        if lr_actual_cua_systems->subsystem = lv_central_logsys.
*         Set USBVSYS status 'S'
          call method cua_set_status_for_centralsyst
            exporting
              iv_usrsection = if_suid_cua_runtime=>gc_user_usrsection
              is_timestamp  = is_timestamp.

          lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_assigned.

*       Collect assigned active child systems for distribution
        else.
*         Set status distribution unconfirmed - 'O'
          lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_assigned.

*         Set timestamp of modification date, time and user
          lr_actual_cua_systems->moddate  = is_timestamp-datum.
          lr_actual_cua_systems->modtime  = is_timestamp-uzeit.
          lr_actual_cua_systems->modifier = is_timestamp-uname.

          read table et_cua_user_syst_distr reference into lr_cua_user_syst_distr
                with key bname     = lr_actual_cua_systems->bname
                    subsystem = lr_actual_cua_systems->subsystem
                binary search.
          if sy-subrc <> 0.
            insert initial line into et_cua_user_syst_distr reference into lr_cua_user_syst_distr
                                                            index sy-tabix.
            lr_cua_user_syst_distr->bname     = lr_actual_cua_systems->bname.
            lr_cua_user_syst_distr->subsystem = lr_actual_cua_systems->subsystem.
          endif.
          lr_cua_user_syst_distr->global_lock = ms_segment_cua_act_distr-actual-global_lock.
        endif.

      endif.

    endloop.
  endif.


*-------------------------------------------------------------------------------
*                         Initial Password
*-------------------------------------------------------------------------------
* Check if initial passwords were set during transaction (segment is filled only if
*  SCUM settings suppese distribution)
  if ls_cua_data_distribute-password = if_identity=>co_true    and
     ms_manager-modus <> go_persistence->co_ta_modus_delete.

*   Segment CUA_PASSWORD contains only child systems
    loop at ms_segment_cua_password-actual reference into lr_cua_password.
*     Check that user has active assignment to this system
      read table ms_segment_cua_systems-actual reference into lr_actual_cua_systems
           with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                    subsystem  = lr_cua_password->subsystem
           binary search.
*     No system assignment --> no initial password distribution and protocol change to/for this system
      if sy-subrc <> 0.
        continue.
      else.
        if lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted         or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_deleted   or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_deleted_runtime or
           lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_failed_delete   .
          continue.
        endif.
      endif.

*     Set distribution status
      lr_actual_cua_systems->status = if_suid_cua_runtime=>gc_to_be_assigned.

*     Set timestamp of modification date, time and user
      lr_actual_cua_systems->moddate  = is_timestamp-datum.
      lr_actual_cua_systems->modtime  = is_timestamp-uzeit.
      lr_actual_cua_systems->modifier = is_timestamp-uname.

*     Collect for distribution
      read table et_cua_user_syst_distr reference into lr_cua_user_syst_distr
            with key bname     = lr_actual_cua_systems->bname
                subsystem = lr_actual_cua_systems->subsystem
            binary search.
      if sy-subrc <> 0.
        insert initial line into et_cua_user_syst_distr reference into lr_cua_user_syst_distr
                                                        index sy-tabix.
        lr_cua_user_syst_distr->bname     = lr_actual_cua_systems->bname.
        lr_cua_user_syst_distr->subsystem = lr_actual_cua_systems->subsystem.
      endif.
      lr_cua_user_syst_distr->password = if_suid_cua_runtime=>gc_distribute.
    endloop.
  endif.



*-------------------------------------------------------------------------------
*      Transaction handle
*-------------------------------------------------------------------------------
* Set segment change flag for USZBVSYS segment
  if ms_segment_cua_systems-actual ne ms_segment_cua_systems-before_image.
    ms_segment_cua_systems-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_cua_systems-status.
  endif.

  if  ms_segment_cua_systems-status eq go_persistence->co_seg_changed.
    append ms_segment_cua_systems         to ct_segment_cua_systems.
  endif.

* Can be changed in method CUA_SET_STATUS_FOR_CENTRALSYST
  if  ms_segment_cua_user_prot-status eq go_persistence->co_seg_changed.
    append ms_segment_cua_user_prot         to ct_segment_cua_user_prot.
  endif.


endmethod.


method cua_prepare_user_send.
* !!!!Method should be called by method DISTRIBUTE only!!!!
*
* Method is called when identity modifications should be redistributed: data
* is read and distributed to child systems, only corresponding entries of
* USZBVSYS will be modified
*
* Importing structure IS_CUA_USER_SYST_DISTR should contain entries only for child
* systems and SCUM attributes for role/profile should be checked (corresponding
* field should be set to 'X' only if SCUM attribute is 'Global', otherwise ' ')
*
* Inside of this method ms_segment_cua_systems is prepared (new distribution status,
* time stamp are set) and user sections for distribution to child systems are collected.
*


  data: lr_segment_actual           type ref to uszbvsys
      , lr_user_section             type ref to uszbvsys
      .


  clear: es_user_child_syst_distr, es_cua_user_syst_no_distr.

* Actual system is not central system of active CUA
  if gv_cua_central ne if_identity=>co_true.
    return.
  endif.

* Exit if not CUA user
  if mv_cua_mode = co_cua_not_transferred or
     mv_cua_mode = co_cua_local_create    .
    return.
  endif.

* Transactional mode is not 'Distribute'
*  if ms_manager-modus <> go_persistence->co_ta_modus_distribute.
*    return.
*  endif.

* Fill CUA_SYSTEMS segment if needed
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.


*------------------------------------------------------------------------------------
*          User section
*------------------------------------------------------------------------------------
  if is_cua_user_syst_distr-usersection = if_identity=>co_true.
    read table ms_segment_cua_systems-actual reference into lr_segment_actual
         with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                  subsystem  = is_cua_user_syst_distr-subsystem
         binary search.
    if sy-subrc <> 0.
      es_cua_user_syst_no_distr-usersection = if_identity=>co_true.
    else.
*     Delete system assignments
      if lr_segment_actual->status = if_suid_cua_runtime=>gc_deleted         or
         lr_segment_actual->status = if_suid_cua_runtime=>gc_to_be_deleted   or
         lr_segment_actual->status = if_suid_cua_runtime=>gc_deleted_runtime or
         lr_segment_actual->status = if_suid_cua_runtime=>gc_failed_delete   .
        es_user_child_syst_distr-usersection = if_suid_cua_runtime=>gc_deleted.
*       Set new status and time stamp in USZBVSYS
        lr_segment_actual->status = if_suid_cua_runtime=>gc_to_be_deleted.
        lr_segment_actual->moddate  = is_timestamp-datum.
        lr_segment_actual->modtime  = is_timestamp-uzeit.
        lr_segment_actual->modifier = is_timestamp-uname.
        ms_segment_cua_systems-status = go_persistence->co_seg_changed.

*     Repeat system assignment
      else.
        es_user_child_syst_distr-usersection = if_suid_cua_runtime=>gc_distribute.
*       Set new status and time stamp in USZBVSYS
        lr_segment_actual->status = if_suid_cua_runtime=>gc_to_be_assigned.
        lr_segment_actual->moddate  = is_timestamp-datum.
        lr_segment_actual->modtime  = is_timestamp-uzeit.
        lr_segment_actual->modifier = is_timestamp-uname.
      endif.
    endif.
  endif.


*-------------------------------------------------------------------------------
*                         Role Assignment
*-------------------------------------------------------------------------------
  if is_cua_user_syst_distr-actgrpsection = if_identity=>co_true.
    read table ms_segment_cua_systems-actual reference into lr_segment_actual
         with key usrsection = if_suid_cua_runtime=>gc_role_usrsection
                  subsystem  = is_cua_user_syst_distr-subsystem
         binary search.
*   Roles are not assigned ==> no distribution
    if sy-subrc <> 0.
      es_cua_user_syst_no_distr-actgrpsection = if_identity=>co_true.
    else.
*     Check system assignment
      read table ms_segment_cua_systems-actual reference into lr_user_section
         with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                  subsystem  = is_cua_user_syst_distr-subsystem
         binary search.
*     System is not assigned ==> no role distribution
      if sy-subrc <> 0.
        es_cua_user_syst_no_distr-actgrpsection = if_identity=>co_true.
      else.
        case lr_user_section->status.
*         System assignment is deleted ==> no role distribution
          when if_suid_cua_runtime=>gc_deleted         or
               if_suid_cua_runtime=>gc_to_be_deleted   or
               if_suid_cua_runtime=>gc_deleted_runtime .
            es_cua_user_syst_no_distr-actgrpsection = if_identity=>co_true.

*         System assignment is active
          when others.
            es_user_child_syst_distr-actgrpsection = if_suid_cua_runtime=>gc_distribute.
*           Set new status and time stamp in USZBVSYS
            lr_segment_actual->status = if_suid_cua_runtime=>gc_to_be_assigned.
            lr_segment_actual->moddate  = is_timestamp-datum.
            lr_segment_actual->modtime  = is_timestamp-uzeit.
            lr_segment_actual->modifier = is_timestamp-uname.
            ms_segment_cua_systems-status = go_persistence->co_seg_changed.

        endcase.
      endif.
    endif.
  endif.


*-------------------------------------------------------------------------------
*                         Profile Assignment
*-------------------------------------------------------------------------------
  if is_cua_user_syst_distr-profilesection = if_identity=>co_true.
    read table ms_segment_cua_systems-actual reference into lr_segment_actual
         with key usrsection = if_suid_cua_runtime=>gc_prof_usrsection
                  subsystem  = is_cua_user_syst_distr-subsystem
         binary search.
*   Profiles are not assigned ==> no distribution
    if sy-subrc <> 0.
      es_cua_user_syst_no_distr-profilesection = if_identity=>co_true.
    else.
*     Check system assignment
      read table ms_segment_cua_systems-actual reference into lr_user_section
         with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                  subsystem  = is_cua_user_syst_distr-subsystem
         binary search.
*     System is not assigned ==> no role distribution
      if sy-subrc <> 0.
        es_cua_user_syst_no_distr-profilesection = if_identity=>co_true.
      else.
        case lr_user_section->status.
*         System assignment is deleted ==> no role distribution
          when if_suid_cua_runtime=>gc_deleted         or
               if_suid_cua_runtime=>gc_to_be_deleted   or
               if_suid_cua_runtime=>gc_deleted_runtime .
            es_cua_user_syst_no_distr-profilesection = if_identity=>co_true.

*         System assignment is active
          when others.
            es_user_child_syst_distr-profilesection = if_suid_cua_runtime=>gc_distribute.
*             Set new status and time stamp in USZBVSYS
            lr_segment_actual->status = if_suid_cua_runtime=>gc_to_be_assigned.
            lr_segment_actual->moddate  = is_timestamp-datum.
            lr_segment_actual->modtime  = is_timestamp-uzeit.
            lr_segment_actual->modifier = is_timestamp-uname.
            ms_segment_cua_systems-status = go_persistence->co_seg_changed.

        endcase.
      endif.
    endif.
  endif.


*--- Prepare exporting data ------------------------------------------*
*

  if es_cua_user_syst_no_distr-usersection    is not initial or
     es_cua_user_syst_no_distr-actgrpsection  is not initial or
     es_cua_user_syst_no_distr-profilesection is not initial .
    es_cua_user_syst_no_distr-bname     = is_cua_user_syst_distr-bname.
    es_cua_user_syst_no_distr-subsystem = is_cua_user_syst_distr-subsystem.
  endif.

  if es_user_child_syst_distr-usersection    is not initial  or
     es_user_child_syst_distr-actgrpsection  is not initial  or
     es_user_child_syst_distr-profilesection is not initial  .
    es_user_child_syst_distr-bname      = is_cua_user_syst_distr-bname.
    es_user_child_syst_distr-subsystem  = is_cua_user_syst_distr-subsystem.

*   Set segments change flag
    if ms_segment_cua_systems-actual ne ms_segment_cua_systems-before_image.
      ms_segment_cua_systems-status  = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_cua_systems-status.
    endif.
    cs_segment_cua_systems = ms_segment_cua_systems.
  endif.


endmethod.


method cua_send_users.
*----------------------------------------------------------------------*
*
* This method must only be called inside SAVE and DISTRIBUTE
* -> No authority checks anymore !!!!
*
*----------------------------------------------------------------------*
*   15.11.2008 c5035002 ( note 1132317  )                           7.10+
* from now on the UFLAG is also sent within CLONE IDoc
* therefore new segment (add_fields) was created
* new IDoc type -> USERCLONE06
*----------------------------------------------------------------------*
  data:   lt_bname                 type          suid_tt_bname
        , lr_control               type ref to   ty_control
        , lr_bname                 type ref to   suid_st_bname
        , lt_child_systems         type          suid_tt_uszbvlndrc
        , lv_usrsection            type          uszbvsys-usrsection
        , lr_cua_password          type ref to   suid_st_node_cua_password
        , lv_data_filled           type          sesf_boolean
        , lv_role_distr            type          sesf_boolean
        , lv_prof_distr            type          sesf_boolean
        , lv_lock_distr            type          sesf_boolean
        , lv_unlock_distr          type          sesf_boolean
        , lv_pwd_distr             type          sesf_boolean
        , lv_uclass_distr          type          sesf_boolean
        , lv_persdata_distr        type          sesf_boolean
        , ls_node_filter           type          suid_st_cua_filters
        .


  data: lt_cua_uclasses            type          suid_tt_node_cua_uclasses
      , lr_cua_uclass              type ref to   suid_st_node_cua_uclass
      , ls_node_defaults           type          suid_st_node_defaults
      , ls_node_logondata          type          suid_st_node_logondata
      , ls_password                type          suid_st_node_pwdhash
      , ls_node_snc                type          suid_st_node_snc
      , ls_node_reference_user     type          suid_st_node_reference_user
      , lt_node_groups             type          suid_tt_node_groups
      , lr_node_group              type ref to   suid_st_node_group
      , lt_node_parameters         type          suid_tt_node_parameters
      , lr_node_parameter          type ref to   suid_st_node_parameter
      , ls_node_person_name        type          suid_st_node_person_name
      , ls_node_workplace          type          suid_st_node_workplace
      , ls_node_organization       type          suid_st_node_organization
      , lt_activitygroups          type          suid_tt_bapiagr
      , lt_profiles                type          suid_tt_bapiprof
      , lt_persdata                type          suid_tt_bapipers
      , ls_node_userdesc           type          suid_st_node_tech_user_data
      .

  data:  lr_addr_map              type  ref to  cl_addr_map_from_bapiaddr
       , lt_telephone             type          addrt_telephone_number
       , lt_facsimile             type          addrt_facsimile_number
       , lt_email                 type          addrt_email_address
       , lt_web                   type          addrt_web_address
       , lt_telex                 type          addrt_telex_number
       , lt_teletex               type          addrt_teletex_number
       , lt_rml                   type          addrt_remote_mail_address
       , lt_x400                  type          addrt_x400_address
       , lt_printer               type          addrt_printer
       , lt_ssf                   type          addrt_ssf_address
       , lt_pager                 type          addrt_pager_number
       , ls_address               type          bapiaddr3
       , ls_bapiaddr3             type          bapiaddr3
       , lt_bapiadtel             type          addrt_bapiadtel
       , lt_bapiadfax             type          addrt_bapiadfax
       , lt_bapiadttx             type          addrt_bapiadttx
       , lt_bapiadtlx             type          addrt_bapiadtlx
       , lt_bapiadsmtp            type          addrt_bapiadsmtp
       , lt_bapiadrml             type          addrt_bapiadrml
       , lt_bapiadx400            type          addrt_bapiadx400
       , lt_bapiadrfc             type          addrt_bapiadrfc
       , lt_bapiadprt             type          addrt_bapiadprt
       , lt_bapiadssf             type          addrt_bapiadssf
       , lt_bapiaduri             type          addrt_bapiaduri
       , lt_bapiadpag             type          addrt_bapiadpag
       , lt_bapicomrem            type          addrt_bapicomrem
       .


  data: lv_bname                    type          xubname
      , lv_bapimethod               type          bapimethod-usmethod
      , lr_cua_user_syst_distr      type ref to   ty_cua_user_syst_distr
      , ls_logondata                type          bapilogond
      , ls_defaults                 type          bapidefaul
      , ls_company                  type          bapiuscomp
      , ls_snc                      type          bapisncu
      , ls_ref_user                 type          bapirefus
      , ls_alias                    type          bapialias
      , ls_uclass                   type          bapiuclass
      , ls_uclassx                  type          bapiuclassx
      , lt_groups                   type table of bapigroups
      , lr_group                    type ref to   bapigroups
      , lt_parameters               type table of bapiparam1
      , lr_parameter                type ref to   bapiparam1
      , ls_add_fields               type          bapiaddfld
      , ls_add_fieldsx              type          bapiaddfldx
      , lv_update_task              type          xflag
      , ls_msg                      type          symsg
      .




  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Check CUA central system ----------------------------------
*
* Actual system is not central system - nothing should be distributed --> exit
  if gv_cua_central = if_identity=>co_false.
    return.
  endif.

* Get active CUA child systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      et_cua_child_systems = lt_child_systems.


* Check SCUM settings for roles, profiles, lock/unlock and initial password
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_role.
* Get CUA filter for roles
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
    lv_role_distr = if_identity=>co_true.
  endif.

  clear: ls_node_filter.
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_profile.
* Get CUA filter for profiles
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
    lv_prof_distr = if_identity=>co_true.
  endif.

  clear: ls_node_filter.
  ls_node_filter-node_name  = if_identity_definition=>gc_node_lockdata.
  ls_node_filter-node_field = if_identity_definition=>gc_field_lockdata_global_set.
* Get CUA filter for global lock
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global or
     ls_node_filter-field_attr = if_suid_cua_runtime=>gc_everywhere.
    lv_lock_distr = if_identity=>co_true.
  endif.

  clear: ls_node_filter.
  ls_node_filter-node_name  = if_identity_definition=>gc_node_lockdata.
  ls_node_filter-node_field = if_identity_definition=>gc_field_lockdata_global_rem.
* Get CUA filter for global unlock
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global or
     ls_node_filter-field_attr = if_suid_cua_runtime=>gc_everywhere.
    lv_unlock_distr = if_identity=>co_true.
  endif.

  clear: ls_node_filter.
  ls_node_filter-node_name = if_identity_definition=>gc_node_password.
* Get CUA filter for initial password
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global     or
     ls_node_filter-field_attr = if_suid_cua_runtime=>gc_everywhere or
     ls_node_filter-field_attr = if_suid_cua_runtime=>gc_template.
    lv_pwd_distr = if_identity=>co_true.
  endif.

  clear: ls_node_filter.
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_uclass.
* Get CUA filter for Licenze data
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
    lv_uclass_distr = if_identity=>co_true.
  endif.

* Personalization
* No application calls during upgrade ==> no personalization distribution
  if gv_upg_is_shadow_system is initial.
    clear: ls_node_filter.
    ls_node_filter-node_name = if_suid_cua_runtime=>gc_persdata.
*   Get CUA filter for Personalization
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_node_filter.
    if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global or
       ls_node_filter-field_attr = if_suid_cua_runtime=>gc_everywhere or
       ls_node_filter-field_attr = if_suid_cua_runtime=>gc_template.
      lv_persdata_distr = if_identity=>co_true.
    endif.
  endif.

* Get reference to address structures converting class
  lr_addr_map = cl_addr_map_from_bapiaddr=>get_instance( ).


*---- Prefetch -------------------------------------------------------*
*
  data: lt_pre_bname      type suid_tt_bname
      , lt_nodes_prefetch type suid_tt_node
      .

  loop at it_cua_user_syst_distr reference into lr_cua_user_syst_distr.
    if lr_cua_user_syst_distr->usersection ne if_suid_cua_runtime=>gc_deleted.
      append lr_cua_user_syst_distr->bname to lt_pre_bname.
    endif.
  endloop.
  delete adjacent duplicates from lt_pre_bname.

  if lt_pre_bname is not initial.
    append if_identity_definition=>gc_node_defaults       to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_snc            to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_parameter      to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_group          to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_reference_user to lt_nodes_prefetch.

    call method cl_identity=>nodes_prefetch
      exporting
        it_bname          = lt_pre_bname
        it_nodes_prefetch = lt_nodes_prefetch.
  endif.

  lv_update_task = iv_update_task.
**--- CUA with bgRFC
*  if lv_update_task is not initial.
** Check transport type
*    data lv_prgn_cust_value type prgn_cust-path.
*    cl_suid_tools=>get_customizing_property(
*      exporting
*        iv_property_name  = 'CUA_TRANSPORT_TYPE'
*      importing
*        ev_property_value = lv_prgn_cust_value  ).
*    if lv_prgn_cust_value = 'RFC'.
**   if transport type is RFC then clear LV_UPDATE_TASK
**    (we will make changes in background (bgRFC) anyway)
*      clear lv_update_task.
*    endif.
*  endif.
**--- CUA with bgRFC


*---- Start distribution ---------------------------------------------*
*
* Read data and distribute
  loop at it_cua_user_syst_distr reference into lr_cua_user_syst_distr.

*   Continue if nothing to distribute
    if lr_cua_user_syst_distr->usersection    is initial and
       lr_cua_user_syst_distr->profilesection is initial and
       lr_cua_user_syst_distr->actgrpsection  is initial and
       lr_cua_user_syst_distr->global_lock    is initial and
       lr_cua_user_syst_distr->password       is initial.
      continue.
    endif.

*   Check that child system, otherwise ignore
    read table lt_child_systems
         with key rcvsystem = lr_cua_user_syst_distr->subsystem
         transporting no fields
         binary search.
    if sy-subrc <> 0.
      continue.
    endif.

*   Check consistency: user should be instatiated except of when deleting Idoc is to be sent
*   (deleting Idoc (bapimethod = 'DELETE') doesn't contain any user's data)
    if lr_cua_user_syst_distr->usersection <> if_suid_cua_runtime=>gc_deleted.
      read table gt_control reference into lr_control
           with key bname = lr_cua_user_syst_distr->bname
           binary search.
      if sy-subrc <> 0.
        continue.
      endif.
    endif.


    if lv_bname <> lr_cua_user_syst_distr->bname.
      lv_bname = lr_cua_user_syst_distr->bname.
*     Prepare internal structures and tables for next user
      clear: lv_data_filled, ls_logondata, ls_defaults, ls_snc, ls_uclass, ls_password,
             ls_alias, ls_ref_user, ls_node_logondata, ls_node_defaults, ls_node_snc,
             ls_node_reference_user, ls_company, ls_node_organization, ls_node_workplace,
             ls_address, ls_bapiaddr3, ls_node_person_name.
      refresh: lt_bname, lt_groups, lt_parameters, lt_cua_uclasses, lt_node_groups,
               lt_node_parameters, lt_persdata.
      refresh: lt_bapiadtel, lt_bapiadfax, lt_bapiadttx, lt_bapiadtlx, lt_bapiadsmtp,
               lt_bapiadrml, lt_bapiadx400, lt_bapiadrfc, lt_bapiadprt, lt_bapiadssf,
               lt_bapiaduri, lt_bapiadpag, lt_bapicomrem.
      refresh: lt_telephone, lt_facsimile , lt_email, lt_web, lt_telex, lt_teletex,
               lt_rml, lt_x400, lt_printer, lt_ssf, lt_pager.
    endif.

    if ( lr_control is bound ). "Only in case of bapimethod = 'DELETE' it isn't bound
      "Distribute logon data EVERY TIME to be able to use them in child systems e.g. for user creation in case of:
      "ACTGROUPS-/PROFILES_ASSIGN IDocs are overtaking the CLONE-IDoc.
      lr_control->idref->get_logondata( importing es_logondata = ls_node_logondata ).
      move-corresponding ls_node_logondata to ls_logondata.
    endif.

*----------------------------------------------------------------------
*                  Distribute USER section
*----------------------------------------------------------------------
    if lr_cua_user_syst_distr->usersection is not initial.
      lv_usrsection = if_suid_cua_runtime=>gc_user_usrsection.
*     Set Idoc method
      case lr_cua_user_syst_distr->usersection.
        when if_suid_cua_runtime=>gc_deleted.
*         Set method 'DELETE'
          lv_bapimethod = if_suid_cua_runtime=>gc_user_delete.
*         No user data should be read

        when if_suid_cua_runtime=>gc_distribute.
*         Set method 'CLONE'
          lv_bapimethod = if_suid_cua_runtime=>gc_user_clone.

        when others.
          continue.
      endcase.

      append initial line to lt_bname reference into lr_bname.
      lr_bname->bname = lr_cua_user_syst_distr->bname.

*     Fill Idoc structures - one time for a user
      if lv_bapimethod = if_suid_cua_runtime=>gc_user_clone and
         lv_data_filled = if_identity=>co_false.
        lv_data_filled = if_identity=>co_true.

*       Fill Licenze data
        if lv_uclass_distr = if_identity=>co_true.
*         Only changes should be distributed
          if iv_only_changed_uclasses = if_identity=>co_true.
            call method lr_control->idref->uclasses_cua_get_changed
              importing
                et_cua_changed_uclasses = lt_cua_uclasses.
*         All licenze data should be redistributed
          else.
            call method lr_control->idref->get_cua_uclasses
              importing
                et_cua_uclasses = lt_cua_uclasses.
          endif.
        endif.


* ---- Get data and fill corresponding bapi structures --------------------------
*       Defaults
        call method lr_control->idref->get_defaults
          importing
            es_defaults = ls_node_defaults.

        move-corresponding ls_node_defaults to ls_defaults.

*       Logon data (completion)
        ls_logondata-ltime = lr_control->idref->ms_segment_header-actual-ltime.
        ls_logondata-tzone = ls_node_defaults-tzone.

        ls_defaults-kostl  = ls_node_logondata-kostl.

        ls_alias-useralias = ls_node_logondata-useralias.

*       Password
        call method lr_control->idref->get_password_hash
          importing
            es_node_pwdhash = ls_password.

*       Overwrite password with new set password
        read table lr_control->idref->ms_segment_cua_password-actual reference into lr_cua_password
             with key subsystem = lr_cua_user_syst_distr->subsystem
             binary search.
        if sy-subrc eq 0 and lr_cua_password->password is not initial.
          ls_password = lr_cua_password->password.
        endif.

*       Map password to logondata bapi structure
        call method cl_suid_tools=>map_pwdhash_node_to_bapi
          exporting
            is_password      = ls_password
          importing
            es_idoc_password = ls_logondata.

*       SNC
        call method lr_control->idref->get_snc
          importing
            es_snc = ls_node_snc.

        ls_snc-guiflag = ls_node_snc-guiflag.
        ls_snc-pname   = ls_node_snc-pname.

*       Reference user
        call method lr_control->idref->get_reference_user
          importing
            es_reference_user = ls_node_reference_user.

        ls_ref_user-ref_user = ls_node_reference_user-refuser.

*       Groups
        call method lr_control->idref->get_groups
          importing
            et_groups = lt_node_groups.

        loop at lt_node_groups reference into lr_node_group.
          append initial line to lt_groups reference into lr_group.
          lr_group->usergroup = lr_node_group->usergroup.
        endloop.

*       Parameters
        call method lr_control->idref->get_parameters
          exporting
            iv_get_text   = if_identity=>co_true
          importing
            et_parameters = lt_node_parameters.

        loop at lt_node_parameters reference into lr_node_parameter.
          append initial line to lt_parameters reference into lr_parameter.
          lr_parameter->parid  = lr_node_parameter->parid.
          lr_parameter->parva  = lr_node_parameter->parva.
          lr_parameter->partxt = lr_node_parameter->partxt.
        endloop.

*       User description
        call method lr_control->idref->get_technical_user_data
          importing
            es_tech_user_data = ls_node_userdesc.

        ls_add_fields-responsible  = ls_node_userdesc-responsible.
        ls_add_fieldsx-responsible = abap_true.
        ls_add_fields-techdesc     = ls_node_userdesc-techdesc.
        ls_add_fieldsx-techdesc    = abap_true.


* --- Get personalization if it is involved -------
        if lr_control->idref->ms_manager-flg_pers_modified = go_persistence->co_flag_active and
           lv_persdata_distr = if_identity=>co_true.
          call function 'SPERS_GET_DISTRIBUTION_DATA'
            exporting
              p_user              = lr_control->bname
            tables
              p_distribution_data = lt_persdata
            exceptions
              operation_failed    = 1.

          if sy-subrc <> 0.
            " something went wrong during pers.-data collection
            clear: ls_msg.
            ls_msg-msgid = sy-msgid.
            ls_msg-msgno = sy-msgno.
            ls_msg-msgty = sy-msgty.
            ls_msg-msgv1 = sy-msgv1.
            ls_msg-msgv2 = sy-msgv2.
            ls_msg-msgv3 = sy-msgv3.
            ls_msg-msgv4 = sy-msgv4.

            call method go_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = lr_control->bname
                iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
                iv_nodename = if_identity_definition=>gc_node_root
                is_msg      = ls_msg.
          endif.        endif.

* ---- Get address data ---------------------------
*
        if lr_control->idref->ms_segment_address-actual-idadtype eq if_identity=>co_idad_techuser.
          ls_node_person_name-name_last = lr_control->bname.
        else.
          call method lr_control->idref->get_personname
            importing
              es_personname = ls_node_person_name.
        endif.

        call method lr_control->idref->get_workplacedata
          importing
            es_workplace = ls_node_workplace.

        call method lr_control->idref->get_organization
          importing
            es_organization = ls_node_organization.

*       Fill BAPIADDR3 structure
        call method cl_suid_tools=>map_address_nodes_to_bapi
          exporting
            is_node_person_name = ls_node_person_name
            is_node_workplace   = ls_node_workplace
          changing
            cs_bapiaddr3        = ls_address.

        ls_company-company = ls_node_organization-company.


*       Fill communication data
        lr_control->idref->get_communication_data(
          exporting
            iv_retrieve_commdata_all = if_identity=>co_true
          importing
            et_telephone             = lt_telephone
            et_facsimile             = lt_facsimile
            et_email                 = lt_email
            et_web                   = lt_web
            et_telex                 = lt_telex
            et_teletex               = lt_teletex
            et_rml                   = lt_rml
            et_x400                  = lt_x400
            et_printer               = lt_printer
            et_ssf                   = lt_ssf
            et_pager                 = lt_pager  ).

        lr_addr_map->convert_to_bapiaddr3(
          exporting
            it_telephone_number    = lt_telephone
            it_facsimile_number    = lt_facsimile
            it_email_address       = lt_email
            it_web_address         = lt_web
            it_telex_number        = lt_telex
            it_teletex_number      = lt_teletex
            it_remote_mail_address = lt_rml
            it_x400_address        = lt_x400
            it_printer             = lt_printer
            it_ssf_address         = lt_ssf
            it_pager_number        = lt_pager
          importing
            es_bapiaddr3           = ls_bapiaddr3
            et_bapiadtel           = lt_bapiadtel
            et_bapiadfax           = lt_bapiadfax
            et_bapiadttx           = lt_bapiadttx
            et_bapiadtlx           = lt_bapiadtlx
            et_bapiadsmtp          = lt_bapiadsmtp
            et_bapiadrml           = lt_bapiadrml
            et_bapiadx400          = lt_bapiadx400
            et_bapiadrfc           = lt_bapiadrfc
            et_bapiadprt           = lt_bapiadprt
            et_bapiadssf           = lt_bapiadssf
            et_bapiaduri           = lt_bapiaduri
            et_bapiadpag           = lt_bapiadpag
            et_bapicomrem          = lt_bapicomrem ).

        ls_address-tel1_numbr = ls_bapiaddr3-tel1_numbr.
        ls_address-tel1_ext   = ls_bapiaddr3-tel1_ext.
        ls_address-fax_number = ls_bapiaddr3-fax_number.
        ls_address-fax_extens = ls_bapiaddr3-fax_extens.
        ls_address-e_mail     = ls_bapiaddr3-e_mail.

*     <<<note 1132317
*.....fill additional fields
        ls_add_fields-uflag = lr_control->idref->ms_segment_header-actual-uflag.
        ls_add_fieldsx-uflag = 'X'.
*     >>>note 1132317

*     End of not system specific Idoc structures filling
      endif.


* ---- Get Licenze data for target system ---------
*     (if user is not to be deleted in this system)
      clear: ls_uclassx, ls_uclass.
      if lv_uclass_distr = if_identity=>co_true                                 and
         lr_cua_user_syst_distr->usersection <> if_suid_cua_runtime=>gc_deleted .
        read table lt_cua_uclasses reference into lr_cua_uclass
             with key subsystem = lr_cua_user_syst_distr->subsystem
             binary search.
        if sy-subrc = 0.
          clear ls_uclassx-uclass with 'X'.
          move-corresponding lr_cua_uclass->* to ls_uclass.
        endif.
      endif.

* ---- Distribution of USER section ---------------------------------------------
*
*     Start distribution
      if lv_update_task = if_identity=>co_true.
*       In update task - asynchronious
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          in update task
          exporting
            iv_bname       = lr_cua_user_syst_distr->bname
            iv_update_task = iv_update_task
            iv_method      = lv_bapimethod
            iv_section     = lv_usrsection
            iv_subsystem   = lr_cua_user_syst_distr->subsystem
            is_logondata   = ls_logondata
            is_defaults    = ls_defaults
            is_address     = ls_address
            is_company     = ls_company
            is_snc         = ls_snc
            is_ref_user    = ls_ref_user
            is_alias       = ls_alias
            is_uclass      = ls_uclass
            is_uclassx     = ls_uclassx
            it_groups      = lt_groups
            it_persdata    = lt_persdata
            it_parameters  = lt_parameters
            it_addtel      = lt_bapiadtel
            it_addfax      = lt_bapiadfax
            it_addttx      = lt_bapiadttx
            it_addtlx      = lt_bapiadtlx
            it_addsmtp     = lt_bapiadsmtp
            it_addrml      = lt_bapiadrml
            it_addx400     = lt_bapiadx400
            it_addrfc      = lt_bapiadrfc
            it_addprt      = lt_bapiadprt
            it_addssf      = lt_bapiadssf
            it_adduri      = lt_bapiaduri
            it_addpag      = lt_bapiadpag
            it_addcomrem   = lt_bapicomrem
            add_fields     = ls_add_fields
            add_fieldsx    = ls_add_fieldsx.

      else.
*       As synchronious task
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          exporting
            iv_bname      = lr_cua_user_syst_distr->bname
            iv_method     = lv_bapimethod
            iv_section    = lv_usrsection
            iv_subsystem  = lr_cua_user_syst_distr->subsystem
            is_logondata  = ls_logondata
            is_defaults   = ls_defaults
            is_address    = ls_address
            is_company    = ls_company
            is_snc        = ls_snc
            is_ref_user   = ls_ref_user
            is_alias      = ls_alias
            is_uclass     = ls_uclass
            is_uclassx    = ls_uclassx
            it_groups     = lt_groups
            it_persdata   = lt_persdata
            it_parameters = lt_parameters
            it_addtel     = lt_bapiadtel
            it_addfax     = lt_bapiadfax
            it_addttx     = lt_bapiadttx
            it_addtlx     = lt_bapiadtlx
            it_addsmtp    = lt_bapiadsmtp
            it_addrml     = lt_bapiadrml
            it_addx400    = lt_bapiadx400
            it_addrfc     = lt_bapiadrfc
            it_addprt     = lt_bapiadprt
            it_addssf     = lt_bapiadssf
            it_adduri     = lt_bapiaduri
            it_addpag     = lt_bapiadpag
            it_addcomrem  = lt_bapicomrem
            add_fields    = ls_add_fields
            add_fieldsx   = ls_add_fieldsx.

      endif.

    endif.

*----------------------------------------------------------------------
*                  Distribute role assignments
*----------------------------------------------------------------------
    if lr_cua_user_syst_distr->actgrpsection = if_suid_cua_runtime=>gc_distribute and
       lv_role_distr = if_identity=>co_true                                       and
*      If deletion of user in system was started ==> no sense to distribute anyth. else
       lr_cua_user_syst_distr->usersection <> if_suid_cua_runtime=>gc_deleted     .

      lv_usrsection = if_suid_cua_runtime=>gc_role_usrsection.
*     Set method 'ACTGROUPS_ASSIGN'
      lv_bapimethod = if_suid_cua_runtime=>gc_roles_assign.

*     Get roles for distribution
      call method lr_control->idref->roles_cua_get_for_syst_distr
        exporting
          iv_subsystem        = lr_cua_user_syst_distr->subsystem
        importing
          et_cua_system_roles = lt_activitygroups.

*     Start distribution
      if lv_update_task = if_identity=>co_true.
*       In update task - asynchronious
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          in update task
          exporting
            iv_bname          = lr_cua_user_syst_distr->bname
            iv_method         = lv_bapimethod
            iv_section        = lv_usrsection
            iv_subsystem      = lr_cua_user_syst_distr->subsystem
            is_logondata      = ls_logondata
            it_activitygroups = lt_activitygroups.

      else.
*       As synchronious task
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          exporting
            iv_bname          = lr_cua_user_syst_distr->bname
            iv_method         = lv_bapimethod
            iv_section        = lv_usrsection
            iv_subsystem      = lr_cua_user_syst_distr->subsystem
            is_logondata      = ls_logondata
            it_activitygroups = lt_activitygroups.
      endif.

    endif.


*----------------------------------------------------------------------
*                  Distribute profile assignments
*----------------------------------------------------------------------
    if lr_cua_user_syst_distr->profilesection  = if_suid_cua_runtime=>gc_distribute and
       lv_prof_distr = if_identity=>co_true                                         and
*      If deletion of user in system was started ==> no sense to distribute anyth. else
       lr_cua_user_syst_distr->usersection <> if_suid_cua_runtime=>gc_deleted       .

      lv_usrsection = if_suid_cua_runtime=>gc_prof_usrsection.
*     Set method 'PROFILES_ASSIGN'
      lv_bapimethod = if_suid_cua_runtime=>gc_profiles_assign.

*     Get profiles for distribution
      call method lr_control->idref->profile_cua_get_for_syst_distr
        exporting
          iv_subsystem           = lr_cua_user_syst_distr->subsystem
        importing
          et_cua_system_profiles = lt_profiles.

*     Start distribution
      if lv_update_task = if_identity=>co_true.
*       In update task - asynchronious
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          in update task
          exporting
            iv_bname     = lr_cua_user_syst_distr->bname
            iv_method    = lv_bapimethod
            iv_section   = lv_usrsection
            iv_subsystem = lr_cua_user_syst_distr->subsystem
            is_logondata = ls_logondata
            it_profiles  = lt_profiles.

      else.
*       As synchronious task
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          exporting
            iv_bname     = lr_cua_user_syst_distr->bname
            iv_method    = lv_bapimethod
            iv_section   = lv_usrsection
            iv_subsystem = lr_cua_user_syst_distr->subsystem
            is_logondata = ls_logondata
            it_profiles  = lt_profiles.
      endif.

    endif.


*----------------------------------------------------------------------
*                  Distribute initial password
*----------------------------------------------------------------------
    if lr_cua_user_syst_distr->password = if_suid_cua_runtime=>gc_distribute and
       lv_pwd_distr = if_identity=>co_true                                   and
*      If deletion of user in system was started ==> no sense to distribute anyth. else
       lr_cua_user_syst_distr->usersection <> if_suid_cua_runtime=>gc_deleted  .

      lv_usrsection = if_suid_cua_runtime=>gc_user_usrsection.
*     Set method 'PWDINIT'
      lv_bapimethod = if_suid_cua_runtime=>gc_init_password.

*     Fill initial password data
      read table lr_control->idref->ms_segment_cua_password-actual reference into lr_cua_password
           with key subsystem = lr_cua_user_syst_distr->subsystem
           binary search.
      if sy-subrc <> 0.
        continue.
      endif.

      call method cl_suid_tools=>map_pwdhash_node_to_bapi
        exporting
          is_password      = lr_cua_password->password
        importing
          es_idoc_password = ls_logondata.

*     Take care that LTIME is initial (initial password, not productive)
      clear: ls_logondata-ltime.

*     Start distribution
      if lv_update_task = if_identity=>co_true.
*       In update task - asynchronious
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          in update task
          exporting
            iv_bname     = lr_cua_user_syst_distr->bname
            iv_method    = lv_bapimethod
            iv_section   = lv_usrsection
            iv_subsystem = lr_cua_user_syst_distr->subsystem
            is_logondata = ls_logondata.

      else.
*       As synchronious task
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          exporting
            iv_bname     = lr_cua_user_syst_distr->bname
            iv_method    = lv_bapimethod
            iv_section   = lv_usrsection
            iv_subsystem = lr_cua_user_syst_distr->subsystem
            is_logondata = ls_logondata.
      endif.

    endif.


*----------------------------------------------------------------------
*                  Distribute global Lock/Unlock
*----------------------------------------------------------------------
    if lr_cua_user_syst_distr->global_lock  is not initial   and
*      If deletion of user in system was started ==> no sense to distribute anyth. else
       lr_cua_user_syst_distr->usersection <> if_suid_cua_runtime=>gc_deleted     .

      lv_usrsection = if_suid_cua_runtime=>gc_user_usrsection.
*     Set method 'LOCK' or 'UNLOCK'
      if lr_cua_user_syst_distr->global_lock  = co_lock.
*       Check that distribution is allowed
        if lv_lock_distr = if_identity=>co_false.
          continue.
        endif.
        lv_bapimethod = if_suid_cua_runtime=>gc_global_lock.

      elseif lr_cua_user_syst_distr->global_lock  = co_unlock.
*       Check that distribution is allowed
        if lv_unlock_distr = if_identity=>co_false.
          continue.
        endif.
        lv_bapimethod = if_suid_cua_runtime=>gc_global_unlock.

      else.
        continue.
      endif.

*     Start distribution
      if lv_update_task = if_identity=>co_true.
*       In update task - asynchronious
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          in update task
          exporting
            iv_bname     = lr_cua_user_syst_distr->bname
            iv_method    = lv_bapimethod
            iv_section   = lv_usrsection
            iv_subsystem = lr_cua_user_syst_distr->subsystem
            is_logondata = ls_logondata.

      else.
*       As synchronious task
        call function 'SUID_IDENTITY_CUA_SEND_USER'
          exporting
            iv_bname     = lr_cua_user_syst_distr->bname
            iv_method    = lv_bapimethod
            iv_section   = lv_usrsection
            iv_subsystem = lr_cua_user_syst_distr->subsystem
            is_logondata = ls_logondata.
      endif.

    endif.

  endloop.


endmethod.                    "IF_IDENTITY_CUA~SEND_CUA_USER


method cua_send_user_back.
* Back distribution of changed user data from child system to central
* ( SCUM attribute is equal 'B')

* Affected nodes:
*               Logondata
*               Defaults
*               Parameter
*               Address nodes

*!!! Although SCUM allow attribute 'B' for Personalization,
*    back distribution for it was never and is not implemented

  data:  lv_central_logsys  type        uszbvlndsc-sendsystem
       , lv_logon_filled    type        sesf_boolean
       , lv_default_filled  type        sesf_boolean
       , ls_node_defaults   type        suid_st_node_defaults
       , ls_node_logondata  type        suid_st_node_logondata
       , lt_node_parameter  type        suid_tt_node_parameters
       , lr_node_parameter  type ref to suid_st_node_parameter
       , ls_node_workplace  type        suid_st_node_workplace
       , ls_node_personname type        suid_st_node_person_name
       , ls_node_organiz    type        suid_st_node_organization
       , ls_retrieve_comm   type        bup_s_commdata_read_api
       , lt_telephone       type        addrt_telephone_number
       , lt_facsimile       type        addrt_facsimile_number
       , lt_email           type        addrt_email_address
       , lt_web             type        addrt_web_address
       , lt_telex           type        addrt_telex_number
       , lt_teletex         type        addrt_teletex_number
       , lt_rml             type        addrt_remote_mail_address
       , lt_x400            type        addrt_x400_address
       , lt_printer         type        addrt_printer
       , lt_ssf             type        addrt_ssf_address
       , lt_pager           type        addrt_pager_number
       .

  data: ls_logondata    type  bapilogond
      , ls_defaults     type  bapidefaul
      , ls_address      type  bapiaddr3
      , ls_company      type  bapiuscomp
      , lt_parameter1    type table of  bapiparam1
      , lr_parameter1    type ref   to  bapiparam1
      , lt_parameter     type table of  bapiparam
      , lr_parameter     type ref   to  bapiparam
      .

  data:  ls_bapiaddr3             type          bapiaddr3
       , lr_addr_map              type ref to   cl_addr_map_from_bapiaddr
       , lt_bapiadtel             type          addrt_bapiadtel
       , lt_bapiadfax             type          addrt_bapiadfax
       , lt_bapiadttx             type          addrt_bapiadttx
       , lt_bapiadtlx             type          addrt_bapiadtlx
       , lt_bapiadsmtp            type          addrt_bapiadsmtp
       , lt_bapiadrml             type          addrt_bapiadrml
       , lt_bapiadx400            type          addrt_bapiadx400
       , lt_bapiadprt             type          addrt_bapiadprt
       , lt_bapiadssf             type          addrt_bapiadssf
       , lt_bapiaduri             type          addrt_bapiaduri
       , lt_bapiadpag             type          addrt_bapiadpag
       , lt_bapicomrem            type          addrt_bapicomrem
       , lt_return                type table of  bapiret2
       .

  data: ls_cua_distr_back     type        ty_cua_data_distribute_back
      , lr_descr_struct       type ref to cl_abap_structdescr
      , lt_struct_components  type        abap_compdescr_tab
      , lr_struct_component   type ref to abap_compdescr
      .

  field-symbols: <lv_checkfield> type any
               .


*------  Checks -------------------------------------------------------
  if gv_cua_child <> if_identity=>co_true.
    return.
  endif.

* Back Distribution can be possible if identity in child system is modified:
  if ms_manager-modus  ne go_persistence->co_ta_modus_modify     or
     ms_manager-status ne go_persistence->co_ta_status_finalized  .
    return.
  endif.

* Check if user is transferred into CUA
  if mv_cua_mode = co_cua_not_transferred or
     mv_cua_mode = co_cua_local_create    .
    return.
  endif.

* Get fields for back distribution
  cua_get_changes_for_distribute(
    importing
      es_cua_data_distribute_back = ls_cua_distr_back ).

* Exit if nothing to distribute
  if ls_cua_distr_back is initial.
    return.
  endif.

* Get RFC destination to CUA central system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys = lv_central_logsys.


*------  Get data, which has to be sent back --------------------------

*--- Logon data
  if ls_cua_distr_back-logondatax is not initial.
*   Get fields of segment before_image structure
    lr_descr_struct ?= cl_abap_structdescr=>describe_by_data( ls_cua_distr_back-logondatax ).
    lt_struct_components = lr_descr_struct->components.

    loop at lt_struct_components reference into lr_struct_component.
*     Get field values of before_image and actual
      unassign: <lv_checkfield>.
      assign component lr_struct_component->name of structure ls_cua_distr_back-logondatax
             to <lv_checkfield>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

      if <lv_checkfield> <> if_identity=>co_true.
        continue.
      endif.

*    Set values to bapi structure
      case lr_struct_component->name.
        when if_identity_definition=>gc_field_defaults_tzone.
          if lv_default_filled <> if_identity=>co_true.
            call method me->get_defaults
              importing
                es_defaults = ls_node_defaults.
            lv_default_filled = if_identity=>co_true.
          endif.
          ls_logondata-tzone = ls_node_defaults-tzone.

        when others.
          if lv_logon_filled <> if_identity=>co_true.
            call method me->get_logondata
              importing
                es_logondata = ls_node_logondata.
            lv_logon_filled = if_identity=>co_true.
          endif.

*         Set changed field in bapi structure
          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field         = lr_struct_component->name
              is_get_structure = ls_node_logondata
            changing
              cs_structure     = ls_logondata.
      endcase.
    endloop.
  endif.

*--- Defaults
  if ls_cua_distr_back-defaultsx is not initial.
    clear: lr_descr_struct.
    refresh: lt_struct_components.

*   Get fields of segment before_image structure
    lr_descr_struct ?= cl_abap_structdescr=>describe_by_data( ls_cua_distr_back-defaultsx ).
    lt_struct_components = lr_descr_struct->components.

    loop at lt_struct_components reference into lr_struct_component.
*     Get field values of before_image and actual
      unassign: <lv_checkfield> .
      assign component lr_struct_component->name of structure ls_cua_distr_back-defaultsx
             to <lv_checkfield>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

      if <lv_checkfield> <> if_identity=>co_true.
        continue.
      endif.

*    Set values to bapi structure
      case lr_struct_component->name.
        when if_suid_cua_runtime=>gc_field_catt.
          if lv_default_filled <> if_identity=>co_true.
            call method me->get_defaults
              importing
                es_defaults = ls_node_defaults.
            lv_default_filled = if_identity=>co_true.
          endif.
          ls_defaults-cattkennz = ls_node_defaults-cattkennz.

        when if_identity_definition=>gc_field_logondata_kostl.
          if lv_logon_filled <> if_identity=>co_true.
            call method me->get_logondata
              importing
                es_logondata = ls_node_logondata.
            lv_logon_filled = if_identity=>co_true.
          endif.
          ls_defaults-kostl = ls_node_logondata-kostl.

        when others.
          if lv_default_filled <> if_identity=>co_true.
            call method me->get_defaults
              importing
                es_defaults = ls_node_defaults.
            lv_default_filled = if_identity=>co_true.
          endif.

*         Set changed field in bapi structure
          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field         = lr_struct_component->name
              is_get_structure = ls_node_defaults
            changing
              cs_structure     = ls_defaults.
      endcase.
    endloop.
  endif.

*--- Parameter
  if ls_cua_distr_back-parameterx is not initial.
*   Get parameter node
    call method me->get_parameters
      exporting
        iv_get_text   = if_identity=>co_true
      importing
        et_parameters = lt_node_parameter.

*   Fill parameter table
    loop at lt_node_parameter reference into lr_node_parameter.
      append initial line to lt_parameter1 reference into lr_parameter1.
      move-corresponding lr_node_parameter->* to lr_parameter1->*.

      append initial line to lt_parameter reference into lr_parameter.
      move-corresponding lr_node_parameter->* to lr_parameter->*.
    endloop.

    sort lt_parameter1.
    sort lt_parameter.
  endif.

*--- Address
  if ls_cua_distr_back-addressx is not initial.
*   Get Person name address node
    call method me->get_personname
      importing
        es_personname = ls_node_personname.

*   Get Workplace address node
    call method me->get_workplacedata
      importing
        es_workplace = ls_node_workplace.

    cl_suid_tools=>map_address_nodes_to_bapi(
      exporting
        is_node_person_name     = ls_node_personname
        is_node_workplace       = ls_node_workplace
        is_bapiaddr3x           = ls_cua_distr_back-addressx
      changing
        cs_bapiaddr3            = ls_address  ).
  endif.


*--- Company
  if ls_cua_distr_back-companyx is not initial.
    call method me->get_organization
      importing
        es_organization = ls_node_organiz.

    ls_company-company  = ls_node_organiz-company.
  endif.

*--- Communication data
  if ls_cua_distr_back-addcomx is not initial.
*  Get reference to address structures converting class
    lr_addr_map = cl_addr_map_from_bapiaddr=>get_instance( ).

*   Map change fields with retrieve commdata fields
    if ls_cua_distr_back-addcomx-adtel = if_identity=>co_true.
      ls_retrieve_comm-telephone = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adfax = if_identity=>co_true.
      ls_retrieve_comm-facsimile = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adsmtp = if_identity=>co_true.
      ls_retrieve_comm-email = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-aduri = if_identity=>co_true.
      ls_retrieve_comm-web = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adtlx = if_identity=>co_true.
      ls_retrieve_comm-telex = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adttx = if_identity=>co_true.
      ls_retrieve_comm-teletex = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adrml = if_identity=>co_true.
      ls_retrieve_comm-rml = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adx400 = if_identity=>co_true.
      ls_retrieve_comm-x400 = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adprt = if_identity=>co_true.
      ls_retrieve_comm-printer = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adssf = if_identity=>co_true.
      ls_retrieve_comm-ssf = if_identity=>co_true.
    endif.
    if ls_cua_distr_back-addcomx-adpag = if_identity=>co_true.
      ls_retrieve_comm-pager = if_identity=>co_true.
    endif.

*   Fill communication data
    me->get_communication_data(
      exporting
        is_retrieve_commdata      = ls_retrieve_comm
      importing
        et_telephone             = lt_telephone
        et_facsimile             = lt_facsimile
        et_email                 = lt_email
        et_web                   = lt_web
        et_telex                 = lt_telex
        et_teletex               = lt_teletex
        et_rml                   = lt_rml
        et_x400                  = lt_x400
        et_printer               = lt_printer
        et_ssf                   = lt_ssf
        et_pager                 = lt_pager  ).

    lr_addr_map->convert_to_bapiaddr3(
      exporting
        it_telephone_number    = lt_telephone
        it_facsimile_number    = lt_facsimile
        it_email_address       = lt_email
        it_web_address         = lt_web
        it_telex_number        = lt_telex
        it_teletex_number      = lt_teletex
        it_remote_mail_address = lt_rml
        it_x400_address        = lt_x400
        it_printer             = lt_printer
        it_ssf_address         = lt_ssf
        it_pager_number        = lt_pager
      importing
        es_bapiaddr3           = ls_bapiaddr3
        et_bapiadtel           = lt_bapiadtel
        et_bapiadfax           = lt_bapiadfax
        et_bapiadttx           = lt_bapiadttx
        et_bapiadtlx           = lt_bapiadtlx
        et_bapiadsmtp          = lt_bapiadsmtp
        et_bapiadrml           = lt_bapiadrml
        et_bapiadx400          = lt_bapiadx400
        et_bapiadprt           = lt_bapiadprt
        et_bapiadssf           = lt_bapiadssf
        et_bapiaduri           = lt_bapiaduri
        et_bapiadpag           = lt_bapiadpag
        et_bapicomrem          = lt_bapicomrem ).

*   Fill communication data sattelite fields in BAPIADDR3
*   (in BAPIADDR3X the are alredy set to 'X')
    if ls_cua_distr_back-addcomx-adtel = if_identity=>co_true.
      ls_address-tel1_numbr = ls_bapiaddr3-tel1_numbr.
      ls_address-tel1_ext   = ls_bapiaddr3-tel1_ext.
    endif.
    if ls_cua_distr_back-addcomx-adfax = if_identity=>co_true.
      ls_address-fax_number = ls_bapiaddr3-fax_number.
      ls_address-fax_extens = ls_bapiaddr3-fax_extens.
    endif.
    if ls_cua_distr_back-addcomx-adsmtp = if_identity=>co_true.
      ls_address-e_mail     = ls_bapiaddr3-e_mail.
    endif.
  endif.

*  BAPIRFC is not supported any more


*--- Distribute back --------------------------------------------------

  call function 'BAPI_USER_CHANGE'
    in background task
    destination lv_central_logsys
    exporting
      username   = ms_manager-bname
      logondata  = ls_logondata
      logondatax = ls_cua_distr_back-logondatax
      defaults   = ls_defaults
      defaultsx  = ls_cua_distr_back-defaultsx
      address    = ls_address
      addressx   = ls_cua_distr_back-addressx
      parameterx = ls_cua_distr_back-parameterx
      company    = ls_company
      companyx   = ls_cua_distr_back-companyx
      addcomx    = ls_cua_distr_back-addcomx
    tables
      parameter  = lt_parameter
      parameter1 = lt_parameter1
      return     = lt_return
      addtel     = lt_bapiadtel
      addfax     = lt_bapiadfax
      addttx     = lt_bapiadttx
      addtlx     = lt_bapiadtlx
      addsmtp    = lt_bapiadsmtp
      addrml     = lt_bapiadrml
      addx400    = lt_bapiadx400
      addprt     = lt_bapiadprt
      addssf     = lt_bapiadssf
      adduri     = lt_bapiaduri
      addpag     = lt_bapiadpag
      addcomrem  = lt_bapicomrem.




endmethod.


method cua_set_status_for_centralsyst.
* This method set USZBVSYS status for user assignments (user sections) to central system
*
* We don't write USZBVPROT messages for any user section for central system because
* there is no necessity in them any more - unlike in old coding here all checks
* are done before SAVE and user with assignment in central system will be either
* saved ==> successfully  distributed or not saved ==> no db tables update will be
* done at all

  data:  lv_logsys         type        t000-logsys
       , lv_section_status type        uszbvsys-status value if_suid_cua_runtime=>gc_assigned
       , lr_actual_system  type ref to uszbvsys
       , lv_tabix          type        sy-tabix
       , ls_field_filter   type        suid_st_cua_filters
       .


* --- Check CUA central system ----------------------------------
*
* If not in central system --> exit
  if gv_cua_central = if_identity=>co_false.
    return.
  endif.

* Get actual system name
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.



* --- Transaction handling ---------------------------------
* Transactional check
*  if ms_manager-status ne go_persistence->co_ta_status_checked or
  if ms_manager-modus  eq go_persistence->co_ta_modus_display.
    return.
  endif.

* --- Prepare user distribution protocol -------------------
*
* Role or Profile Idoc method
  if iv_usrsection ne if_suid_cua_runtime=>gc_user_usrsection.
*   Check field attribute
    case iv_usrsection.
      when if_suid_cua_runtime=>gc_role_usrsection.
        ls_field_filter-node_name = if_identity_definition=>gc_node_cua_role.
      when if_suid_cua_runtime=>gc_prof_usrsection.
        ls_field_filter-node_name = if_identity_definition=>gc_node_cua_profile.
      when others.
    endcase.

    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_field_filter.
*   No distribution protocol update if field attribute is not 'Global'
    if ls_field_filter-field_attr ne if_suid_cua_runtime=>gc_global.
      return.
    endif.
  endif.

* Set status
  case iv_usrsection.
*   USER section
    when if_suid_cua_runtime=>gc_user_usrsection.
*---- Special case - user transfer into CUA (transaction SCUG)
      if gs_cua_user_transfer-active = if_identity=>co_true.
*       'G' - user transferred from child system into CUA
        lv_section_status = if_suid_cua_runtime=>gc_transferred.

*---- Normal case
      else.
        if iv_deleted = if_identity=>co_false.
*         'S' - successfully changed/assigned
          lv_section_status = if_suid_cua_runtime=>gc_assigned.
        elseif iv_deleted = if_identity=>co_true.
*         'D' - successfully changed/assigned
          lv_section_status = if_suid_cua_runtime=>gc_deleted.
        endif.
      endif.

*   PROFILE and ACTGRP sections
    when if_suid_cua_runtime=>gc_role_usrsection or if_suid_cua_runtime=>gc_prof_usrsection.
*---- Special case - user transfer into CUA (transaction SCUG)
      if gs_cua_user_transfer-active = if_identity=>co_true.
*       'G' - user transferred from child system into CUA
        lv_section_status = if_suid_cua_runtime=>gc_transferred.

*---- Normal case
      else.
*     'S' - successfully assigned
        lv_section_status = if_suid_cua_runtime=>gc_assigned.
      endif.

    when others.
      return.

  endcase.


*---- Modify USZBVSYS segment ------------------------------------------------------
*
* Fill CUA_SYSTEMS segment if needed
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.

* Modify USZBVSYS correspondingly
  read table ms_segment_cua_systems-actual reference into lr_actual_system
       with key bname      = ms_manager-bname
                usrsection = iv_usrsection
                subsystem  = lv_logsys
       binary search.
  lv_tabix = sy-tabix.
  if sy-subrc <> 0.
*   Add entry for the section
    insert initial line into ms_segment_cua_systems-actual index lv_tabix
           reference into lr_actual_system.
    lr_actual_system->bname      = ms_manager-bname.
    lr_actual_system->usrsection = iv_usrsection.
    lr_actual_system->subsystem  = lv_logsys.
  endif.

  lr_actual_system->status = lv_section_status.
* Set timestamp of modification date, time and user
  lr_actual_system->moddate  = is_timestamp-datum.
  lr_actual_system->modtime  = is_timestamp-uzeit.
  lr_actual_system->modifier = is_timestamp-uname.

* Set segment change flag for USZBVSYS segment
  if ms_segment_cua_systems-actual ne ms_segment_cua_systems-before_image.
    ms_segment_cua_systems-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_cua_systems-status.
  endif.


*----- Modify USZBVPROT segment (delete existing entries for central system) -------

* Fill CUA_USER_PROT segment if needed
  if ms_segment_cua_user_prot-bname is initial.
    call method fetch_segment_cua_user_prot.
  endif.

* Delete all old messages from USZBVPROT (iv_usrsection and lv_logsys relevant)
  read table ms_segment_cua_user_prot-actual
       with key usrsection = iv_usrsection
                subsystem  = lv_logsys
       transporting no fields
       binary search.
  if sy-subrc = 0.
    delete ms_segment_cua_user_prot-actual
      where usrsection = iv_usrsection and
            subsystem  = lv_logsys.

*   Set segment change flag for USZBVPROT segment
    if ms_segment_cua_user_prot-actual ne ms_segment_cua_user_prot-before_image.
      ms_segment_cua_user_prot-status  = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_cua_user_prot-status.
    endif.
  endif.



endmethod.


method cua_set_syst_assignment.
*
* This method should be only called for new system assignments
* because of new role or profile assignments
*
* - Only new systems to be assigned are allowed
* - No check against already assigned systems
* - Invalid systems are ignored
*
* Table ET_ERROR_SYSTEMS returns list of systems, for which role/profile
* assignment is not possible with corresponding return code:
*                 1  - system is not part of active CUA landscape
*                 2  - no authorizations to assign new system

* Table CT_ASSIGN_SYSTEMS is a list of systems, which shouold be added
* If a system con not be assigned it will be deletet from CT_ASSIGN_SYSTEMS
*

  data:  lv_logsys             type        t000-logsys
      " , lt_assigned_systems   type        suid_tt_node_cua_systems
       , lr_cua_system         type ref to suid_st_node_cua_system
       , lt_new_systems        type        suid_tt_node_cua_systems
       , lr_new_system         type ref to suid_st_node_cua_system
       , lt_cua_child_systems  type        suid_tt_uszbvlndrc
       , lr_error_system       type ref to ty_error_systems
       , ls_msg                type        symsg
       , lv_operation          type        suid_node_activity
       , lv_class              type        xuclass
       .

  " Initialization
  refresh et_error_systems.

  " --- Check CUA landscape ----------------------------------
  "
  " CUA is not active - system node shouldn't be filled --> error message and exit
  if gv_cua_active ne if_identity=>co_true or gv_cua_central ne if_identity=>co_true.
    macro_raise_internal_error.
  endif.


  " --- Consistency checks ----------------------------------------------*
  " Manager structure must be filled
  if ms_manager-bname is initial.
    macro_raise_internal_error.
  endif.


  " --- Fill buffer ------------------------------------------
  "
  " Get active CUA central system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys     = lv_logsys
      et_cua_child_systems = lt_cua_child_systems.

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " Write section entry in actual image
  loop at ct_assign_systems reference into lr_cua_system.
    if lr_cua_system->subsystem ne lv_logsys.
      " Child system of active CUA landscape?
      read table lt_cua_child_systems
        with key rcvsystem = lr_cua_system->subsystem
        transporting no fields
        binary search.
      " If system is not a part of active CUA - write error protocol and delete
      if sy-subrc ne 0.
        append initial line to et_error_systems reference into lr_error_system.
        lr_error_system->subsystem   = lr_cua_system->subsystem.
        lr_error_system->return_code = 1.

        delete ct_assign_systems.
        continue.
      endif.
    endif.

    " Assign new system
    " Authorization check for insert
    lv_operation = cl_suid_tools=>co_activity_create.

    call method cl_suid_tools=>auth_check_single
      exporting
        iv_nodename  = if_identity_definition=>gc_node_cua_system
        iv_operation = lv_operation
        iv_class     = lv_class
        iv_subsystem = lr_cua_system->subsystem
      importing
        es_msg       = ls_msg.

    if ls_msg-msgty eq 'E'.
      " If no authorization to assign new system - write error protocol and delete system
      append initial line to et_error_systems reference into lr_error_system.
      lr_error_system->subsystem   = lr_cua_system->subsystem.
      lr_error_system->return_code = 2.

      " Write message later
      lr_error_system->msg = ls_msg.

      delete ct_assign_systems.
      continue.
    endif.

    append initial line to lt_new_systems reference into lr_new_system.
    lr_new_system->*           = lr_cua_system->*.
    lr_new_system->change_mode = if_identity=>co_insert.
  endloop.


  " Assign new systems
  if lt_new_systems is not initial.
    sort lt_new_systems.
    delete adjacent duplicates from lt_new_systems.

    call method me->if_identity_cua~set_cua_systems
      exporting
        it_cua_systems = lt_new_systems.
  endif.


endmethod.


method cua_uclass_delete_user_system.
*!!! This method cis dediceted for deleting CUA licence data of child system
*!!! when system assignment is being deleted

* We suppose that all checks for system deletion are done before this method call,
* no additional checks for deletion of licence data are needed

*
* Alowed CHANGE_MODE:
*      -  CO_DELETE
*
*
*   E351(01)           - Sie sind nicht auf dem Zentralsystem angemeldet.
*   E381(01)           - Das System &1 ist nicht Teil der Zentralen Benutzerpflege


  data: lr_cua_system            type ref to   suid_st_node_cua_system
      , lv_logsys                type          t000-logsys
      , lv_tabix                 type          sy-tabix
      , ls_node_filter           type          suid_st_cua_filters
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " --- Check CUA landscape ----------------------------------
  "
  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.

  " Actual system is not central system --> exit
  if gv_cua_central ne if_identity=>co_true.
    return.
  endif.

  " Check if CUA licence data is active (SCUM attribute = 'G')
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_uclass.
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr <> if_suid_cua_runtime=>gc_global.
    return.
  endif.

  " --- Transaction handling ---------------------------------
  "
  " Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_uclass.

  " Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_cua_uclass
      iv_lifetimeonce_only = if_identity=>co_true.



  " --- Fill buffer ------------------------------------------
  "
  " Fetch local License data
  if ms_segment_uclass-bname is initial.
    call method fetch_segment_uclass.
  endif.

  " Fetch License data assignments in child systems
  if ms_segment_cua_uclasses-bname is initial.
    call method fetch_segment_cua_uclasses.
  endif.

  " --- Delete licence data ----------------------------------
  "
  loop at it_cua_systems reference into lr_cua_system.
    if lr_cua_system->change_mode ne if_identity=>co_delete.
      continue.
    endif.

    " Delete messages for systems which should be checked
    gv_macro_key = lr_cua_system->subsystem.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        iv_key      = gv_macro_key.

    " Central system
    if lr_cua_system->subsystem = lv_logsys.
      " No License data assignment in central system
      if ms_segment_uclass-actual is initial.
        continue.
        " Otherwise delete license data for central system
      else.
        clear: ms_segment_uclass-actual.
      endif.
      " Child system
    else.
      read table ms_segment_cua_uclasses-actual
           with key rcvsystem = lr_cua_system->subsystem
           transporting no fields
           binary search.
      lv_tabix = sy-tabix.
      " No License data assignment in child system
      if sy-subrc ne 0.
        continue.
        " Otherwise delete license data for system
      else.
        delete ms_segment_cua_uclasses-actual index lv_tabix.
      endif.
    endif.

    " Write notifications
    gv_macro_key = lr_cua_system->subsystem.
    " Notification: Node successful deleted
    call method go_notify->notify_delete
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        iv_key      = gv_macro_key.
  endloop.


  " --- Transaction handling ---------------------------------
  "
  " only set transaction status if there have been changes
  if ms_segment_cua_uclasses-actual ne ms_segment_cua_uclasses-before_image or
     ms_segment_uclass-actual       ne ms_segment_uclass-before_image.

    " New transaction status: UNCHECKED
    ms_manager-status = go_persistence->co_ta_status_unchecked.

    " New node status: CHECKED
    ms_manager-sn_cua_uclass = go_persistence->co_node_status_checked.

    " Set segment change flag
    if ms_segment_cua_uclasses-actual ne ms_segment_cua_uclasses-before_image.
      ms_segment_cua_uclasses-status = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_cua_uclasses-status.
    endif.

    " Set segment change flag
    if ms_segment_uclass-actual ne ms_segment_uclass-before_image.
      ms_segment_uclass-status = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_uclass-status.
    endif.
  else.
    " in case actual and before_image are identical: set segment
    " status to unchanged.
    clear: ms_segment_cua_uclasses-status, ms_segment_uclass-status, ms_manager-sn_cua_uclass.
  endif.

endmethod.


method delete.
*
* Create new Identity instances with transaction mode "Delete"
*
  data:
        lv_lock_mode_excl           type sesf_edit_mode
                                    value if_identity=>co_enqueue_mode_exclusive
      , ls_bname                    type suid_st_bname
      , lr_control                  type ref to ty_control
      , lt_uname_list               type spers_ulst
      , lt_bname                    type suid_tt_bname
      , lr_node_root                type ref to suid_st_node_root
      , lt_identity                 type suid_tt_identity
      .

*---- Set exporting parameters ----------------------------------------*
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

*---- Pass to method for instantiation --------------------------------*
  if it_bname is not initial.
    call method instantiation_by_mode
      exporting
        iv_modus      = go_persistence->co_ta_modus_delete
        it_bname      = it_bname
        iv_enq_mode   = lv_lock_mode_excl
        iv_repeat_enq = iv_repeat_enq
      importing
        et_node_root  = et_node_root.
  elseif it_identity_guid is not initial.
    call method go_persistence->if_suid_persistence_query~query_identity_by_uuid
      exporting
        it_identity_guid = it_identity_guid
      importing
        et_identity      = lt_identity.
    if lt_identity is not initial.
      move lt_identity to lt_bname.
      call method instantiation_by_mode
        exporting
          iv_modus      = go_persistence->co_ta_modus_delete
          it_bname      = lt_bname
          iv_enq_mode   = lv_lock_mode_excl
          iv_repeat_enq = iv_repeat_enq
        importing
          et_node_root  = et_node_root.
    endif.
  endif.

  check: et_node_root is not initial.

*--- use result of instantiation by mode for further processing -------*
*    returned list may differ from input parameter list
  clear lt_bname.
  loop at et_node_root reference into lr_node_root.
    ls_bname-bname = lr_node_root->bname.
    insert ls_bname into table lt_bname.
  endloop.

*---- Perform Prefetch: For Create, all segments are processed --------*
  call method nodes_prefetch
    exporting
      it_bname        = lt_bname
      iv_prefetch_all = go_persistence->co_flag_active.


*---- Delete address and personalization-------------------------------*

  loop at lt_bname into ls_bname.
    set locale language sy-langu.
    translate ls_bname-bname to upper case.

*   Read corresponding entry from gt_control
    read table gt_control reference into lr_control
       with key bname = ls_bname-bname
       binary search.
    if sy-subrc = 0.

* --- Check Early Watch Client and Upgrade Process ------------------------*
*     no address and application calls
      if gv_earlywatchclient     eq if_identity=>co_false and
         gv_upg_is_shadow_system eq if_identity=>co_false.

*       Delete address
        call method lr_control->idref->adbp_delete.

*       Collect users to delete personalization (sytem is already checked)
        lr_control->idref->persdata_set_modified( ).
        append ls_bname-bname to lt_uname_list.

*       Collect users to delete appl.-references
        lr_control->idref->applrefs_set_modified( ).

      endif.

*     Delete DBMS User.
      if iv_delete_dbms_user eq if_identity=>co_true and
        lr_control->idref->ms_segment_dbms_user-before_image-dbms_user is not initial.
        lr_control->idref->ms_segment_dbms_user-dbms_change_mode = cl_identity_persistence=>co_ta_modus_delete.
      endif.

*     send notification for deleted user
      go_notify->notify_delete(
        exporting
          iv_bname      = ls_bname-bname
          iv_nodename   = if_identity_definition=>gc_node_root ).

    endif.
  endloop.

* Delete personalization
* will be done during save!!
*  if lt_uname_list is not initial.
*
** --- Check Early Watch Client and Upgrade Process ------------------------*
**     ==> no personalization modifications
*    if gv_earlywatchclient     eq if_identity=>co_false and
*       gv_upg_is_shadow_system eq if_identity=>co_false.
*
*      cl_pers_service=>user_delete(
*        exporting
*          p_uname_list               = lt_uname_list
*          p_delete_when_buffer_saved = 'X'
*        exceptions
*          user_does_not_exist        = 0
*          pers_key_does_not_exist    = 0
*          access_class_not_found     = 0  ).
*    endif.
*
*  endif.

endmethod.


method delete_invalid_cua_prof_assign.
* delete invalid profile assignments where users do not exist anymore
* Therefore cl_identity object cannot be instantiated
*   - complete messages for roles and profiles

  data: ls_msg_data             type          symsg
      , lt_existing_users       type          suid_tt_identity
      , lr_existing_user        type ref to   suid_st_identity
      , lt_del_users            type          suid_tt_bname
      , lr_bname                type ref to   suid_st_bname
      , lt_cua_profiles         type          suid_tt_usl04
      , lr_cua_profile          type ref to   usl04
      , ls_cua_profile_segment  type          suid_st_segment_cua_profiles
      , ls_found_invalid_entry  type          suid_st_bname
      .

  clear: et_invalid_assignment.

  eo_msg_buffer ?= go_msg_buffer.

  lt_del_users = it_del_users.

  sort lt_del_users.
  delete adjacent duplicates from lt_del_users.

  go_persistence->if_suid_persistence_query~existence_check(
    exporting
      it_bname              = lt_del_users
    importing
      et_identity_exist     = lt_existing_users
    exceptions
      cx_suid_identity      = 1
      others                = 2 ).

  if sy-subrc ne 0.
    clear: ls_msg_data.
    ls_msg_data-msgid = sy-msgid.
    ls_msg_data-msgty = sy-msgty.
    ls_msg_data-msgno = sy-msgno.
    ls_msg_data-msgv1 = sy-msgv1.
    ls_msg_data-msgv2 = sy-msgv2.
    ls_msg_data-msgv3 = sy-msgv3.
    ls_msg_data-msgv4 = sy-msgv4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = space
        iv_nodename = if_identity_definition=>gc_node_cua_profile
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg_data.
  endif.

  " delete existing users from list
  loop at lt_existing_users reference into lr_existing_user.
    delete lt_del_users where bname = lr_existing_user->bname.
  endloop.

  go_persistence->if_suid_persistence_read~read(
    exporting
      it_bname        = lt_del_users
    importing
      et_cua_profiles = lt_cua_profiles ).

  if lt_cua_profiles is not initial.
    sort lt_cua_profiles.

    " for each user object create a segment
    loop at lt_del_users reference into lr_bname.
      clear ls_cua_profile_segment.

      " insert profiles of this user
      loop at lt_cua_profiles reference into lr_cua_profile
        where bname = lr_bname->bname.

        " fill profiles segment of this user
        insert lr_cua_profile->* into table ls_cua_profile_segment-before_image.
      endloop.

      " make sure there are entries which have to be deleted -> before_image
      if ls_cua_profile_segment-before_image is not initial.
        " check if there is already an entry in mt_invalid_cua_prof_assignment for this user
        read table mt_invalid_cua_prof_assignment
          with key
            bname = lr_bname->bname
          transporting no fields.
        if sy-subrc ne 0.
          " make sure bname of segment is set and actual part is empty
          ls_cua_profile_segment-bname    = lr_bname->bname.
          ls_cua_profile_segment-status   = go_persistence->co_seg_changed.
          clear ls_cua_profile_segment-actual.
          insert ls_cua_profile_segment into table mt_invalid_cua_prof_assignment.
          " add invalid entry to return table
          ls_found_invalid_entry-bname = lr_bname->bname.
          insert ls_found_invalid_entry into table et_invalid_assignment.
        endif.
      endif.
    endloop.
  endif.

endmethod.


method delete_invalid_cua_role_assign.
* delete invalid role assignments where users do not exist anymore
* Therefore cl_identity object cannot be instantiated
*   - complete messages for roles and profiles

  data: ls_msg_data             type          symsg
      , lt_existing_users       type          suid_tt_identity
      , lr_existing_user        type ref to   suid_st_identity
      , lt_del_users            type          suid_tt_bname
      , lr_bname                type ref to   suid_st_bname
      , lt_cua_roles            type          suid_tt_usla04
      , lr_usla04               type ref to   usla04
      , ls_cua_role_segment     type          suid_st_segment_cua_roles
      , ls_found_invalid_entry  type          suid_st_bname
      .

  clear: et_invalid_assignment.

  eo_msg_buffer ?= go_msg_buffer.

  lt_del_users = it_del_users.

  sort lt_del_users.
  delete adjacent duplicates from   lt_del_users.

  go_persistence->if_suid_persistence_query~existence_check(
    exporting
      it_bname              = lt_del_users
    importing
      et_identity_exist     = lt_existing_users
    exceptions
      cx_suid_identity      = 1
      others                = 2 ).
  if sy-subrc ne 0.
    clear: ls_msg_data.
    ls_msg_data-msgid = sy-msgid.
    ls_msg_data-msgty = sy-msgty.
    ls_msg_data-msgno = sy-msgno.
    ls_msg_data-msgv1 = sy-msgv1.
    ls_msg_data-msgv2 = sy-msgv2.
    ls_msg_data-msgv3 = sy-msgv3.
    ls_msg_data-msgv4 = sy-msgv4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = space
        iv_nodename = if_identity_definition=>gc_node_cua_role
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg_data.
  endif.

 " delete existing users from list
  loop at lt_existing_users reference into lr_existing_user.
    delete lt_del_users where bname = lr_existing_user->bname.
  endloop.

  go_persistence->if_suid_persistence_read~read(
    exporting
      it_bname        = lt_del_users
    importing
      et_cua_roles    = lt_cua_roles ).

  if lt_cua_roles is not initial.
    sort lt_cua_roles by bname subsystem agr_name from_dat to_dat org_flag.
    " for each user object create a segment
    loop at lt_del_users reference into lr_bname.
      clear ls_cua_role_segment.

      " insert roles of this user
      loop at lt_cua_roles reference into lr_usla04
        where bname = lr_bname->bname.

        " fill roles segment of this user
        insert lr_usla04->* into table ls_cua_role_segment-before_image.
      endloop.

      " make sure there are entries which have to be deleted -> before_image
      if ls_cua_role_segment-before_image is not initial.
        " check if there is already an entry in mt_invalid_cua_role_assignment for this user
        sort ls_cua_role_segment-before_image by bname subsystem agr_name from_dat to_dat org_flag.
        read table mt_invalid_cua_role_assignment
          with key
            bname = lr_bname->bname
          transporting no fields.
        if sy-subrc ne 0.
          " make sure bname of segment is set and actual part is empty
          ls_cua_role_segment-bname   = lr_bname->bname.
          ls_cua_role_segment-status  = go_persistence->co_seg_changed.
          clear ls_cua_role_segment-actual.
          insert ls_cua_role_segment into table mt_invalid_cua_role_assignment.
          " add invalid entry to return table
          ls_found_invalid_entry-bname = lr_bname->bname.
          insert ls_found_invalid_entry into table et_invalid_assignment.
        endif.
      endif.
    endloop.
  endif.

endmethod.


method delete_invalid_prof_assignment.
* delete invalid profile assignments where users do not exist anymore
* Therefore cl_identity object cannot be instantiated
*   - complete messages for roles and profiles

  data: ls_msg_data             type          symsg
      , lt_existing_users       type          suid_tt_identity
      , lr_existing_user        type ref to   suid_st_identity
      , lt_del_users            type          suid_tt_bname
      , lr_bname                type ref to   suid_st_bname
      , lt_profiles             type          suid_tt_ust04
      , lr_profile              type ref to   ust04
      , ls_profile_segment      type          suid_st_segment_profiles_t04
      , ls_found_invalid_entry  type          suid_st_bname
      .

  clear: et_invalid_assignment.

  eo_msg_buffer ?= go_msg_buffer.

  lt_del_users = it_del_users.

  sort lt_del_users.
  delete adjacent duplicates from lt_del_users.

  go_persistence->if_suid_persistence_query~existence_check(
    exporting
      it_bname              = lt_del_users
    importing
      et_identity_exist     = lt_existing_users
    exceptions
      cx_suid_identity      = 1
      others                = 2 ).

  if sy-subrc ne 0.
    clear: ls_msg_data.
    ls_msg_data-msgid = sy-msgid.
    ls_msg_data-msgty = sy-msgty.
    ls_msg_data-msgno = sy-msgno.
    ls_msg_data-msgv1 = sy-msgv1.
    ls_msg_data-msgv2 = sy-msgv2.
    ls_msg_data-msgv3 = sy-msgv3.
    ls_msg_data-msgv4 = sy-msgv4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = space
        iv_nodename = if_identity_definition=>gc_node_profile
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg_data.
  endif.

  " delete existing users from list
  loop at lt_existing_users reference into lr_existing_user.
    delete lt_del_users where bname = lr_existing_user->bname.
  endloop.

  go_persistence->if_suid_persistence_read~read(
    exporting
      it_bname    = lt_del_users
    importing
      et_profiles = lt_profiles ).

  if lt_profiles is not initial.
    sort lt_profiles.

    " for each user object create a segment
    loop at lt_del_users reference into lr_bname.
      clear ls_profile_segment.

      " insert profiles of this user
      loop at lt_profiles reference into lr_profile
            where bname = lr_bname->bname.

        " fill profiles segment of this user
        insert lr_profile->* into table ls_profile_segment-before_image.
      endloop.

      " make sure there are entries which have to be deleted -> before_image
      if ls_profile_segment-before_image is not initial.
        " check if there is already an entry in mt_invalid_profile_assignment for this user
        read table mt_invalid_profile_assignment
          with key bname = lr_bname->bname
          transporting no fields.
        if sy-subrc ne 0.
          " make sure bname of segment is set and actual part is empty
          ls_profile_segment-bname    = lr_bname->bname.
          ls_profile_segment-status   = go_persistence->co_seg_changed.
          clear ls_profile_segment-actual.
          insert ls_profile_segment into table mt_invalid_profile_assignment.
          " add invalid entry to return table
          ls_found_invalid_entry-bname = lr_bname->bname.
          insert ls_found_invalid_entry into table et_invalid_assignment.
        endif.
      endif.
    endloop.
  endif.

endmethod.


method delete_invalid_role_assignment.
* delete invalid role assignments where users do not exist anymore
* Therefore cl_identity object cannot be instantiated
*   - complete messages for roles and profiles

  data: ls_msg_data             type          symsg
      , lt_existing_users       type          suid_tt_identity
      , lr_existing_user        type ref to   suid_st_identity
      , lt_del_users            type          suid_tt_bname
      , lr_bname                type ref to   suid_st_bname
      , lt_roles                type          suid_tt_agr_users
      , lr_agr_users            type ref to   agr_users
      , ls_role_segment         type          suid_st_segment_roles
      , ls_found_invalid_entry  type          suid_st_bname
      .

  clear: et_invalid_assignment.

  eo_msg_buffer ?= go_msg_buffer.

  lt_del_users = it_del_users.

  sort lt_del_users.
  delete adjacent duplicates from   lt_del_users.

  go_persistence->if_suid_persistence_query~existence_check(
    exporting
      it_bname              = lt_del_users
    importing
      et_identity_exist     = lt_existing_users
    exceptions
      cx_suid_identity      = 1
      others                = 2 ).
  if sy-subrc ne 0.
    clear: ls_msg_data.
    ls_msg_data-msgid = sy-msgid.
    ls_msg_data-msgty = sy-msgty.
    ls_msg_data-msgno = sy-msgno.
    ls_msg_data-msgv1 = sy-msgv1.
    ls_msg_data-msgv2 = sy-msgv2.
    ls_msg_data-msgv3 = sy-msgv3.
    ls_msg_data-msgv4 = sy-msgv4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = space
        iv_nodename = if_identity_definition=>gc_node_role
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg_data.
  endif.

* delete existing users from list
  loop at lt_existing_users reference into lr_existing_user.
    delete lt_del_users where bname = lr_existing_user->bname.
  endloop.

  go_persistence->if_suid_persistence_read~read(
    exporting
      it_bname    = lt_del_users
    importing
      et_roles    = lt_roles ).

  if lt_roles is not initial.
    sort lt_roles by agr_name uname from_dat to_dat org_flag.
    " for each user object create a segment
    loop at lt_del_users reference into lr_bname.
      clear ls_role_segment.

      " insert roles of this user
      loop at lt_roles reference into lr_agr_users
        where uname = lr_bname->bname.

        " fill roles segment of this user
        insert lr_agr_users->* into table ls_role_segment-before_image.
      endloop.

      " make sure there are entries which have to be deleted -> before_image
      if ls_role_segment-before_image is not initial.
        " check if there is already an entry in mt_invalid_role_assignment for this user
        sort ls_role_segment-before_image by agr_name uname from_dat to_dat org_flag.
        read table mt_invalid_role_assignment
          with key bname = lr_bname->bname
          transporting no fields.
        if sy-subrc ne 0.
          " make sure bname of segment is set and actual part is empty
          ls_role_segment-bname   = lr_bname->bname.
          ls_role_segment-status  = go_persistence->co_seg_changed.
          clear ls_role_segment-actual.
          insert ls_role_segment into table mt_invalid_role_assignment.
          " add invalid entry to return table
          ls_found_invalid_entry-bname = lr_bname->bname.
          insert ls_found_invalid_entry into table et_invalid_assignment.
        endif.
      endif.
    endloop.
  endif.

endmethod.


method distribute.
* This method's task is to read user data and to send it unchanged to
* child systems, no distribution to central system. This kind of
* distribution is also known as 'Re-distribution'.

* This method is complete ==> it includes all operations starting from
* user instantiation and ending up with inctances cleanup

* Existing instances with maintenance modes other than 'Display' will not
* be taken into re-distribution processing

* Importing table it_bname_section_distr contains following information:
*     BNAME          - User name
*     SUBSYSTEM      - Child system to which user should be distributed
*     USERSECTION    - User's master data should be sent if field is set to 'X'
*     ACTGRPSECTION  - Role assignments to child system should be sent (if set to 'X')
*     PROFILESECTION - Profile seeignments should be sent (if set to 'X')
*
* Importing table IT_BNAME_COMPLETE_DISTR contains list of users, for which
* all their sections should be distributed to all assigned child systems
*
* At a time only one of the importing table will be processed

* Exporting table ET_BNAME_DISTRIBUTED contains information about for which section
* (corresponding section field is marked with 'X') of which user and to which child
* system distribution was started.
* This table is filled both if selective distribution (IT_BNAME_SECTION_DISTR is
* supplied) or complete distribution (IT_BNAME_COMPLETE_DISTR) is required
*

* Exporting table ET_BNAME_SECT_NOT_DISTRIBUTED can be filled only if SELECTIVE user
* distribution is required (IT_BNAME_SECTION_DISTR is supplied). It contains
* information about for which of selected section (corresponding section field is
* marked with 'X') of which user and to which child system distribution was NOT
* started.
* For complete user distribution (IT_BNAME_COMPLETE_DISTR) we don't expect distribution
* of some specific user sections to some specific systems and wherefore the only
* reason why user distribution to all assigned child systems can't be started is that
* user can't be instantiated (user doesn't exist, is locked, no authorizations, etc.)

* Exporting table ET_BNAME_NOT_INSTANTIATED contains list of user's, which couldn't
* be instantiated because of one o# possible reasons: user not exist, user is locked
* by administrator, no authorizations, etc.


  data: lt_bname_distr          type        suid_tt_cua_user_syst_distr
      , lr_bname_distr          type ref to suid_st_cua_user_syst_distr
      , ls_bname_distr          type        suid_st_cua_user_syst_distr
      , lr_bname                type ref to suid_st_bname
      , lt_bname                type        suid_tt_bname
      , lt_bname_failed         type        suid_tt_bname
      , lt_bname_not_exist      type        suid_tt_bname
      , lt_bname_instantiated   type        suid_tt_bname
      , lt_bname_syst_delete    type        tt_cua_user_syst_distr
      , lr_bname_syst_delete    type ref to ty_cua_user_syst_distr
      , lt_user_syst_del        type        tt_cua_user_syst_distr
      , lt_cua_systems          type        suid_tt_uszbvsys
      , lr_cua_subsystem        type ref to uszbvsys
      , lt_cua_user_systems     type        suid_tt_uszbvsys
      , lt_cua_user_systems_act type        suid_tt_uszbvsys
      , lr_uszbvsys_actual      type ref to uszbvsys
      , ls_msg                  type        symsg
      , ls_node_filter          type        suid_st_cua_filters
      , lv_role_distr           type        sesf_boolean
      , lv_prof_distr           type        sesf_boolean
      , lv_role                 type        sesf_boolean
      , lv_prof                 type        sesf_boolean
      , lv_user                 type        sesf_boolean
      , lv_bname                type        xubname
      , lv_subsystem            type        uszbvsys-subsystem
      , lv_instantiate          type        sesf_boolean
      , lt_user_syst_distr      type        tt_cua_user_syst_distr
      , lr_user_no_distr        type ref to suid_st_cua_user_syst_distr
      , lt_node_root            type        suid_tt_node_root
      , lr_node_root            type ref to suid_st_node_root
      , lv_central_logsys       type        uszbvlndsc-sendsystem
      , lt_cua_child_systems    type        suid_tt_uszbvlndrc
      , ls_timestamp            type        ty_timestamp
      , ls_child_syst_distr     type        ty_cua_user_syst_distr
      , ls_user_no_distr        type        suid_st_cua_user_syst_distr
      , ls_segment_cua_systems  type        suid_st_segment_cua_systems
      , lt_segment_cua_systems  type        suid_tt_segment_cua_systems
      , lt_segment_del_systems  type        suid_tt_segment_cua_systems
      , lr_segment_cua_systems  type ref to suid_st_segment_cua_systems
      , ls_identity_ref         type ref to cl_identity
      , lv_tabix                type        sy-tabix
      , lv_cua_tabix            type        sy-tabix
      , lt_nodes_prefetch       type        suid_tt_node
      , lt_bname_user_prefetch  type        suid_tt_bname
      , lt_bname_role_prefetch  type        suid_tt_bname
      , lt_bname_prof_prefetch  type        suid_tt_bname
      , lt_bname_cua_systems    type        suid_tt_node_cua_systems
      , lr_cua_system           type ref to suid_st_node_cua_system
      .


*---------------------------------------------------------------------*
*---- Initialization -------------------------------------------------*
*---------------------------------------------------------------------*
  refresh: et_bname_distributed, et_bname_sect_not_distributed
         , et_bname_not_instantiated.

* Check if in central system
  if gv_cua_central <> if_identity=>co_true.
*   Selective distribution
    if it_bname_section_distr is not initial.
      read table it_bname_section_distr reference into lr_bname_distr index 1.
      lv_bname = lr_bname_distr->bname.
      et_bname_sect_not_distributed = it_bname_section_distr.
*   Complete distribution
    elseif it_bname_complete_distr is not initial.
      read table it_bname_complete_distr reference into lr_bname index 1.
      lv_bname = lr_bname->bname.
    endif.

    clear: ls_msg.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
*   You have not logged onto the central system
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = lv_bname
        iv_nodename = if_identity_definition=>gc_node_root
        iv_field    = if_identity_definition=>gc_field_root_bname
        iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
        is_msg      = ls_msg.

*   Perform evaluation of message buffer
    call method cl_identity_tools=>msg_buffer_retrieve
      exporting
        io_msg_buffer        = go_msg_buffer
        iv_lifetimeonce_only = if_identity=>co_false
      changing
        ct_messages          = et_messages.

    return.
  endif.

* Copy imported table and sort
  lt_bname_distr = it_bname_section_distr.
  sort lt_bname_distr by bname subsystem.

* Get active CUA central and child systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys    = lv_central_logsys
      et_cua_child_systems = lt_cua_child_systems.


*---------------------------------------------------------------------*
*---- Check if roles/profiles can be distributed ---------------------*
*---------------------------------------------------------------------*
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_role.
* Get CUA filter for roles
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
    lv_role_distr = if_identity=>co_true.
  endif.

  clear: ls_node_filter.
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_profile.
* Get CUA filter for profiles
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.
  if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
    lv_prof_distr = if_identity=>co_true.
  endif.

  set locale language sy-langu.


*---------------------------------------------------------------------*
*---- Collect user names for instatiation ----------------------------*
*---------------------------------------------------------------------*

*---- If selective distribution is required----------------------
  if it_bname_section_distr is not initial.
    loop at lt_bname_distr reference into lr_bname_distr.
      if lr_bname_distr is initial or lr_bname_distr->bname is initial or
         lr_bname_distr->subsystem is initial.
        delete lt_bname_distr.
        continue.
      endif.
*     At new user
      if lv_bname <> lr_bname_distr->bname.
        if lv_bname is not initial.
*         Collect users for instatiation
          if lv_instantiate = if_identity=>co_true.
            append initial line to lt_bname reference into lr_bname.
            lr_bname->bname = lv_bname.
*...........Upper case conversion
            translate lr_bname->bname to upper case.
          endif.
        endif.
        lv_bname = lr_bname_distr->bname.
        clear: lv_instantiate, lv_subsystem.
      endif.

*     At new system
      if lv_subsystem <> lr_bname_distr->subsystem.
        lv_subsystem = lr_bname_distr->subsystem.

*       No redistribution in central system
        if lv_subsystem = lv_central_logsys.
*         Collect not distributed to system users
          append lr_bname_distr->* to et_bname_sect_not_distributed.
*          clear: lr_bname_distr->usersection    with if_identity=>co_true
*               , lr_bname_distr->actgrpsection  with if_identity=>co_true
*               , lr_bname_distr->profilesection with if_identity=>co_true.
*         Delete system from further processing
          delete lt_bname_distr.
          continue.
        endif.

*       Check if active child system
        read table lt_cua_child_systems
             with key rcvsystem = lv_subsystem
             binary search
             transporting no fields.
        if sy-subrc <> 0.
*         Collect not distributed to system users
          append lr_bname_distr->* to et_bname_sect_not_distributed.
*          clear: lr_bname_distr->usersection    with if_identity=>co_true
*               , lr_bname_distr->actgrpsection  with if_identity=>co_true
*               , lr_bname_distr->profilesection with if_identity=>co_true.
*         Delete system from further processing
          delete lt_bname_distr.
          continue.
        endif.

*       Chek if SCUM attributes allow distribution of role/profile sections
        if lv_role_distr = if_identity=>co_false.
          if lr_bname_distr->actgrpsection = if_identity=>co_true.
            append initial line to et_bname_sect_not_distributed reference into lr_user_no_distr.
            lr_user_no_distr->bname     = lr_bname_distr->bname.
            lr_user_no_distr->subsystem = lr_bname_distr->subsystem.
            lr_user_no_distr->actgrpsection = if_identity=>co_true.
          endif.
          clear: lr_bname_distr->actgrpsection.
        endif.
        if lv_prof_distr = if_identity=>co_false.
          if lr_bname_distr->profilesection = if_identity=>co_true.
*         Collect not distributed user sections
*         As table lt_bname_distr is sorted th# table et_bname_sect_not_distributed
*         when filled with append in the same order will be also sorted
*         ==> BINARY SEARCH can be used
            read table et_bname_sect_not_distributed reference into lr_user_no_distr
                 with key bname     = lr_bname_distr->bname
                          subsystem = lr_bname_distr->subsystem
                 binary search.
            if sy-subrc = 0.
              lr_user_no_distr->profilesection = if_identity=>co_true.
            else.
              append initial line to et_bname_sect_not_distributed reference into lr_user_no_distr.
              lr_user_no_distr->bname     = lr_bname_distr->bname.
              lr_user_no_distr->subsystem = lr_bname_distr->subsystem.
              lr_user_no_distr->profilesection = if_identity=>co_true.
            endif.
          endif.

          clear: lr_bname_distr->profilesection.
        endif.

*       Nothing to distribute to child system
        if lr_bname_distr->usersection    is initial and
           lr_bname_distr->actgrpsection  is initial and
           lr_bname_distr->profilesection is initial.
*         Delete system from further processing
          delete lt_bname_distr.
          continue.
*       Smth. can be distributed to child system ==> instaiation is needed
        else.
          lv_instantiate = if_identity=>co_true.
*         Collect users for prefetch
          if lr_bname_distr->usersection = if_identity=>co_true.
            append initial line to lt_bname_user_prefetch reference into lr_bname.
            lr_bname->bname = lv_bname.
          endif.
          if lr_bname_distr->actgrpsection = if_identity=>co_true.
            append initial line to lt_bname_role_prefetch reference into lr_bname.
            lr_bname->bname = lv_bname.
          endif.
          if lr_bname_distr->profilesection = if_identity=>co_true.
            append initial line to lt_bname_prof_prefetch reference into lr_bname.
            lr_bname->bname = lv_bname.
          endif.
        endif.
      endif.
    endloop.
*   For the last user in loop
    if lv_bname is not initial.
*     Collect him for instatiation
      if lv_instantiate = if_identity=>co_true.
        append initial line to lt_bname reference into lr_bname.
        lr_bname->bname = lv_bname.
*.......Upper case conversion
        translate lr_bname->bname to upper case.
      endif.
    endif.

*---- If complete distribution is required ----------------------
  elseif it_bname_complete_distr is not initial.
    lt_bname = it_bname_complete_distr.
    sort lt_bname.
    delete adjacent duplicates from lt_bname.
    lt_bname_user_prefetch = lt_bname.
    if lv_prof_distr = if_identity=>co_true.
      lt_bname_prof_prefetch = lt_bname.
    endif.
    if lv_role_distr = if_identity=>co_true.
      lt_bname_role_prefetch = lt_bname.
    endif.
  endif.

  sort lt_bname_user_prefetch.
  delete adjacent duplicates from lt_bname_user_prefetch comparing bname.
  sort lt_bname_role_prefetch.
  delete adjacent duplicates from lt_bname_role_prefetch comparing bname.
  sort lt_bname_prof_prefetch.
  delete adjacent duplicates from lt_bname_prof_prefetch comparing bname.

*---------------------------------------------------------------------*
*---- Instantiation --------------------------------------------------*
*---------------------------------------------------------------------*
  if lt_bname is not initial.
    instantiation_for_distribution(
      exporting
        it_bname             = lt_bname
     importing
       et_node_root          = lt_node_root
       et_bname_instantiated = lt_bname_instantiated
       et_bname_failed       = lt_bname_failed
       et_bname_not_exist    = lt_bname_not_exist ).
*       eo_msg_buffer         = eo_msg_buffer ).

*   Perform evaluation of message buffer
    call method cl_identity_tools=>msg_buffer_retrieve
      exporting
        io_msg_buffer        = go_msg_buffer
        iv_lifetimeonce_only = if_identity=>co_false
      changing
        ct_messages          = et_messages.
  endif.

*--- Set timestamp -----------------------------------------
  ls_timestamp-uname = sy-uname ##user_ok.
  ls_timestamp-datum = sy-datum.
  ls_timestamp-uzeit = sy-uzeit.
  get time stamp field ls_timestamp-timestamp.


*---------------------------------------------------------------------*
*---- Prepare USZBVSYS segments and re-distribution of ---------------*
*   deleting Idocs for already deleted in central system
*          (inactive, no entry in USR02) users
*---------------------------------------------------------------------*

* Select USZBVSYS entries for not instantiated users in order to
* find out if deletion Idoc to child system should be sent for
* already deleted in central system user (no entry in USR02)
  if lt_bname_not_exist is not initial.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname       = lt_bname_not_exist
      importing
        et_cua_systems = lt_cua_systems.

    loop at lt_bname_not_exist reference into lr_bname.
      clear: lt_cua_user_systems
           , lt_cua_user_systems_act
           , lv_cua_tabix
           , lt_user_syst_del
           .
*     Check that inactive user has USZBVSYS entries at all
      read table lt_cua_systems
           with key bname      = lr_bname->bname
           transporting no fields
           binary search.
      if sy-subrc <> 0.
        continue.
      else.
        lv_cua_tabix = sy-tabix.
      endif.

*---- If selective user distribution is required
      if it_bname_section_distr is not initial.
        read table lt_bname_distr
             with key bname     = lr_bname->bname
             transporting no fields
             binary search.
        if sy-subrc <> 0.
          continue.
        else.
          lv_tabix = sy-tabix.
        endif.

        loop at lt_bname_distr reference into lr_bname_distr from lv_tabix.
*         Quit if next user
          if lr_bname_distr->bname <> lr_bname->bname.
            exit.
          endif.

*         Ignore system if USER section distribution is not required or if
*         system is central CUA system
          if lr_bname_distr->usersection <> if_identity=>co_true or
             lr_bname_distr->subsystem  = lv_central_logsys     .
            continue.
          endif.

*         Check that system assignment has status, which allows distribution of deletion
          read table lt_cua_systems reference into lr_cua_subsystem
               with key bname      = lr_bname->bname
                        usrsection = if_suid_cua_runtime=>gc_user_usrsection
                        subsystem  = lr_bname_distr->subsystem
               binary search.
          if sy-subrc = 0  and
           ( lr_cua_subsystem->status = if_suid_cua_runtime=>gc_to_be_deleted or
             lr_cua_subsystem->status = if_suid_cua_runtime=>gc_failed_delete or
             lr_cua_subsystem->status = if_suid_cua_runtime=>gc_deleted_runtime  ).

*           Collect into list of user system assignments which are to be deleted anew
            append initial line to lt_user_syst_del reference into lr_bname_syst_delete.
            lr_bname_syst_delete->bname       = lr_bname->bname.
            lr_bname_syst_delete->subsystem   = lr_cua_subsystem->subsystem.
            lr_bname_syst_delete->usersection = if_suid_cua_runtime=>gc_deleted.
*         Ignore if USER section doesn't have status A, F or X
          else.
            continue.
          endif.
        endloop.

        if lt_user_syst_del is not initial.
          sort lt_user_syst_del by subsystem.
*       If no deletion to be distributed ==> go to next user
        else.
          continue.
        endif.
      endif.

*     If deletion should be distributed ==> collect all USZBVSYS entries of inactive user
*     into SUID_ST_CUA_SYSTEMS segment structure
      loop at lt_cua_systems reference into lr_cua_subsystem from lv_cua_tabix.
        if lr_cua_subsystem->bname <> lr_bname->bname.
          exit.
        endif.

*       Collect for actual image
        append initial line to lt_cua_user_systems_act reference into lr_uszbvsys_actual.
        move lr_cua_subsystem->* to lr_uszbvsys_actual->*.
*       Collect for before image
        append lr_cua_subsystem->* to lt_cua_user_systems.

*       If system assignment has status, which allows distribution of deletion (A, F or X)
        if lr_cua_subsystem->usrsection = if_suid_cua_runtime=>gc_user_usrsection and
           lr_cua_subsystem->subsystem <> lv_central_logsys                       and
          ( lr_cua_subsystem->status = if_suid_cua_runtime=>gc_to_be_deleted or
            lr_cua_subsystem->status = if_suid_cua_runtime=>gc_failed_delete or
            lr_cua_subsystem->status = if_suid_cua_runtime=>gc_deleted_runtime  ).

*-------- If selective user distribution is required
          if it_bname_section_distr is not initial.
*           If system wasn't selected for distribution ==> leave entry unchanged
            read table lt_user_syst_del
                 with key subsystem = lr_cua_subsystem->subsystem
                 transporting no fields
                 binary search.
            if sy-subrc <> 0.
              continue.
            endif.
*-------- If complete user distribution is required
          elseif it_bname_complete_distr is not initial.
*           Collect into list of user system assignments which are to be deleted anew
            append initial line to lt_user_syst_del reference into lr_bname_syst_delete.
            lr_bname_syst_delete->bname       = lr_bname->bname.
            lr_bname_syst_delete->subsystem   = lr_cua_subsystem->subsystem.
            lr_bname_syst_delete->usersection = if_suid_cua_runtime=>gc_deleted.
          endif.

*         Set new status and time stamp in USZBVSYS actual image
          lr_uszbvsys_actual->status   = if_suid_cua_runtime=>gc_to_be_deleted.
          lr_uszbvsys_actual->moddate  = ls_timestamp-datum.
          lr_uszbvsys_actual->modtime  = ls_timestamp-uzeit.
          lr_uszbvsys_actual->modifier = ls_timestamp-uname.
        endif.
      endloop.

      if lt_user_syst_del is not initial.
        append initial line to lt_segment_del_systems reference into lr_segment_cua_systems.
        lr_segment_cua_systems->bname        = lr_cua_subsystem->bname.
        lr_segment_cua_systems->status       = go_persistence->co_seg_changed.
        lr_segment_cua_systems->before_image = lt_cua_user_systems.
        lr_segment_cua_systems->actual       = lt_cua_user_systems_act.

        append lines of lt_user_syst_del to lt_bname_syst_delete.
      endif.
    endloop.

    sort lt_bname_syst_delete by bname subsystem.
  endif.


* Delete failed users from distribution process and collect them
* into failed distributions table
  loop at lt_bname_failed reference into lr_bname.
*   Delete failed users from prefetch tables
    read table lt_bname_user_prefetch
         with key bname = lr_bname->bname
         transporting no fields
         binary search.
    if sy-subrc = 0.
      delete lt_bname_user_prefetch index sy-tabix.
    endif.
    read table lt_bname_role_prefetch
         with key bname = lr_bname->bname
         transporting no fields
         binary search.
    if sy-subrc = 0.
      delete lt_bname_role_prefetch index sy-tabix.
    endif.
    read table lt_bname_prof_prefetch
         with key bname = lr_bname->bname
         transporting no fields
         binary search.
    if sy-subrc = 0.
      delete lt_bname_prof_prefetch index sy-tabix.
    endif.

*---- If selective user distribution is required ----------------
    if it_bname_section_distr is not initial.
      read table lt_bname_distr
           with key bname = lr_bname->bname
           transporting no fields
           binary search.

      if sy-subrc = 0.
        loop at lt_bname_distr reference into lr_bname_distr from sy-tabix.
          if lr_bname_distr->bname <> lr_bname->bname.
            exit.
          endif.
*         Check if deleting Idoc for inactive user (no entry in USR02) should be send
          read table lt_bname_syst_delete
               with key bname     = lr_bname_distr->bname
                        subsystem = lr_bname_distr->subsystem
               transporting no fields
               binary search.
          if sy-subrc = 0.
            clear: lr_bname_distr->usersection.
          endif.

*         If some section is marked ==> collect to list of not started Idocs
          if lr_bname_distr->usersection    = if_identity=>co_true or
             lr_bname_distr->actgrpsection  = if_identity=>co_true or
             lr_bname_distr->profilesection = if_identity=>co_true.
*           Collect failed users into table of not started distributions
            read table et_bname_sect_not_distributed reference into lr_user_no_distr
                 with key bname     = lr_bname_distr->bname
                          subsystem = lr_bname_distr->subsystem
                 binary search.
            if sy-subrc <> 0.
              lv_tabix = sy-tabix.
              insert lr_bname_distr->* into et_bname_sect_not_distributed index lv_tabix.
            else.
              move lr_bname_distr->* to lr_user_no_distr->*.
            endif.
          endif.

*         Delete user from further processing
          delete lt_bname_distr.
        endloop.
      endif.

    endif.
  endloop.


*---------------------------------------------------------------------*
*---- Prepare USZBVSYS segments and distribution ---------------------*
*         for instantiated (active) users
*---------------------------------------------------------------------*
* Collect user sections for distribution and prepare USZBVSYS data for modificetion
  loop at lt_node_root reference into lr_node_root.
    ls_identity_ref ?= lr_node_root->idref.
    clear: ls_segment_cua_systems
         , lv_role
         , lv_prof
         , lv_user.

*---- If selective user distribution is required ----------------
    if it_bname_section_distr is not initial.
      read table lt_bname_distr
           with key bname = lr_node_root->bname
           transporting no fields
           binary search.
      if sy-subrc = 0.
        lv_tabix = sy-tabix.

        loop at lt_bname_distr reference into lr_bname_distr from lv_tabix.
          if lr_bname_distr->bname <> lr_node_root->bname.
            exit.
          endif.
          ls_identity_ref->cua_prepare_user_send(
            exporting
              is_timestamp              = ls_timestamp
              is_cua_user_syst_distr    = lr_bname_distr->*
            importing
              es_user_child_syst_distr  = ls_child_syst_distr
              es_cua_user_syst_no_distr = ls_user_no_distr
            changing
              cs_segment_cua_systems    = ls_segment_cua_systems  ).

*         Collect user sections, which can't be distributed
          if ls_user_no_distr is not initial.
            read table et_bname_sect_not_distributed reference into lr_user_no_distr
                 with key bname     = lr_bname_distr->bname
                          subsystem = lr_bname_distr->subsystem
                 binary search.
            if sy-subrc <> 0.
              insert ls_user_no_distr into et_bname_sect_not_distributed index sy-tabix.
            else.
              lr_user_no_distr->usersection    = ls_user_no_distr-usersection.
              lr_user_no_distr->actgrpsection  = ls_user_no_distr-actgrpsection.
              lr_user_no_distr->profilesection = ls_user_no_distr-profilesection.
            endif.
          endif.

*         Collect data for distribution and modification
          if ls_child_syst_distr is not initial.
            append ls_child_syst_distr to lt_user_syst_distr.
            lv_user = ls_child_syst_distr-usersection.
            lv_role = ls_child_syst_distr-actgrpsection.
            lv_prof = ls_child_syst_distr-profilesection.
          endif.
        endloop.
      endif.

*---- If complete user distribution is required. ----------------
    elseif it_bname_complete_distr is not initial.
      ls_bname_distr-bname          = lr_node_root->bname.
      ls_bname_distr-usersection    = if_identity=>co_true.
      ls_bname_distr-profilesection = lv_prof_distr.
      ls_bname_distr-actgrpsection  = lv_role_distr.

*     Get assigned systems for a user
      ls_identity_ref->get_cua_systems(
        importing
          et_cua_systems = lt_bname_cua_systems  ).

      loop at lt_bname_cua_systems reference into lr_cua_system.
*       No distribution to central system
        if lr_cua_system->subsystem = lv_central_logsys.
          continue.
        endif.

        ls_bname_distr-subsystem      = lr_cua_system->subsystem.
        ls_identity_ref->cua_prepare_user_send(
          exporting
            is_timestamp              = ls_timestamp
            is_cua_user_syst_distr    = ls_bname_distr
          importing
            es_user_child_syst_distr  = ls_child_syst_distr
          changing
            cs_segment_cua_systems    = ls_segment_cua_systems  ).

*       Collect data for distribution and modification
        if ls_child_syst_distr is not initial.
          append ls_child_syst_distr to lt_user_syst_distr.
          lv_user = ls_child_syst_distr-usersection.
          lv_role = ls_child_syst_distr-actgrpsection.
          lv_prof = ls_child_syst_distr-profilesection.
        endif.
      endloop.
    endif.

*   If some section for a user will be distributed ==> USZBVSYS should be modified,
*   collect ms_segment_cua_systems for update
    if ls_segment_cua_systems-status  = go_persistence->co_seg_changed and
      ( lv_user is not initial or lv_role is not initial or lv_prof is not initial ).
      append ls_segment_cua_systems to lt_segment_cua_systems.
    endif.

*   Delete user from prefetch tables if his corresponding section
*   will not be distributed at all
    if lv_user <> if_suid_cua_runtime=>gc_distribute.
      read table lt_bname_user_prefetch
           with key bname = lr_node_root->bname
           transporting no fields
           binary search.
      if sy-subrc = 0.
        delete lt_bname_user_prefetch index sy-tabix.
      endif.
    endif.
    if lv_role <> if_suid_cua_runtime=>gc_distribute.
      read table lt_bname_role_prefetch
           with key bname = lr_node_root->bname
           transporting no fields
           binary search.
      if sy-subrc = 0.
        delete lt_bname_role_prefetch index sy-tabix.
      endif.
    endif.
    if lv_prof <> if_suid_cua_runtime=>gc_distribute.
      read table lt_bname_prof_prefetch
           with key bname = lr_node_root->bname
           transporting no fields
           binary search.
      if sy-subrc = 0.
        delete lt_bname_prof_prefetch index sy-tabix.
      endif.
    endif.
  endloop.


*---- Prefetch nodes -------------------------------------------------*
  if lt_bname_user_prefetch is not initial.
    append if_identity_definition=>gc_node_logondata to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_defaults to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_snc to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_group to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_parameter to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_cua_uclass to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_reference_user to lt_nodes_prefetch.
    append if_identity_definition=>gc_node_workplace to lt_nodes_prefetch.

    call method cl_identity=>nodes_prefetch
      exporting
        it_bname          = lt_bname_user_prefetch
        it_nodes_prefetch = lt_nodes_prefetch.
  endif.

  if lt_bname_role_prefetch is not initial.
    refresh: lt_nodes_prefetch.
    append if_identity_definition=>gc_node_cua_role to lt_nodes_prefetch.
    call method cl_identity=>nodes_prefetch
      exporting
        it_bname          = lt_bname_role_prefetch
        it_nodes_prefetch = lt_nodes_prefetch.
  endif.

  if lt_bname_prof_prefetch is not initial.
    refresh: lt_nodes_prefetch.
    append if_identity_definition=>gc_node_cua_profile to lt_nodes_prefetch.
    call method cl_identity=>nodes_prefetch
      exporting
        it_bname          = lt_bname_prof_prefetch
        it_nodes_prefetch = lt_nodes_prefetch.
  endif.


*---------------------------------------------------------------------*
*---- Update USZBVSYS table and send collected Idocs -----------------*
*---------------------------------------------------------------------*
* Sort distribution table and prevent duplicates
  append lines of lt_bname_syst_delete to lt_user_syst_distr.
  sort lt_user_syst_distr by bname subsystem.
  delete adjacent duplicates from lt_user_syst_distr comparing bname subsystem.

* Collect USZBVSYS segments
  append lines of lt_segment_del_systems to lt_segment_cua_systems.

* Save changes and start distribution
  if lt_user_syst_distr is not initial.
*   Save USZBVSYS table
    call method go_persistence->if_suid_persistence_modify~modify
      exporting
        iv_update_task         = iv_update_task
        is_timestamp           = ls_timestamp
        it_segment_cua_systems = lt_segment_cua_systems.


*   Start distribution
    call method cua_send_users
      exporting
        iv_update_task           = iv_update_task
        it_cua_user_syst_distr   = lt_user_syst_distr
        iv_only_changed_uclasses = if_identity=>co_false.

    commit work.
  endif.

  et_bname_distributed      = lt_user_syst_distr.
  et_bname_not_instantiated = lt_bname_failed.


*---------------------------------------------------------------------*
*---- Cleanup instances ----------------------------------------------*
*---------------------------------------------------------------------*
  cl_identity=>cleanup( it_bname = lt_bname_instantiated ).


endmethod.


method do_check.

  data: lr_control           type ref to ty_control
      , lv_rejected          type        sesf_boolean
      .


* Default: Check ok
  ev_rejected   = if_identity=>co_false.
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* Check instances which should be written to the database
  loop at gt_control reference into lr_control
       where idref->ms_manager-status eq go_persistence->co_ta_status_unchecked and
             idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    call method lr_control->idref->do_check_single
      importing
        ev_rejected = lv_rejected.

*   If one instance failed: whole check failed
    if lv_rejected eq if_identity=>co_true.
      ev_rejected = if_identity=>co_true.
    endif.
  endloop.



endmethod.


method do_check_single.

* This message is called from DO_CHECK or as part of the action 'Check'
*
* Node check is done in the SET methods
* Only checks on: Node status
*                 Cross node checks
*                 Address

  data: ls_msg                       type        symsg
      , lv_return                    type        sesf_boolean
      , lv_error                     type        sesf_boolean
"     , lo_badi_identity_check       type ref to cl_badi_base  "BADI_IDENTITY_CHECK_TEST
      , lv_num_badi                  type        i
      , ls_badi_identity_check       type        suid_st_badi_identity
      , ls_badi_identity_cua_systems type        suid_st_badi_cua_systems
      , ls_badi_identity_cua_roles   type        suid_st_badi_cua_roles
      , ls_badi_identity_roles       type        suid_st_badi_roles
      , ls_badi_identity_groups      type        suid_st_badi_groups
      , lt_badi_filter               type        badi_filter_bindings
      , ls_badi_filter               type        badi_filter_binding
      , lv_reject_class              type        sesf_boolean
      .


  " ---- Consistency check -------------------------------------------------------
  "
  " MANAGER-STATUS: Only UNCHECKED allowed - in case of CHECKED: Return
  if ms_manager-status eq go_persistence->co_ta_status_checked.
    return.
  elseif ms_manager-status eq go_persistence->co_ta_status_invalid   or
         ms_manager-status eq go_persistence->co_ta_status_finalized or
         ms_manager-status eq go_persistence->co_ta_status_saved     or
         ms_manager-status eq go_persistence->co_ta_status_unchanged.
    macro_raise_internal_error.
  endif.

  " MANAGER-MODUS: Only CREATE/DELETE/MODIFY allowed
  if ms_manager-modus eq go_persistence->co_ta_modus_display.
    macro_raise_internal_error.
  endif.


  " ---- Check for mandatory fields -------------------------------------*
  "
  " Default: Reject Check
  ev_rejected = if_identity=>co_true.
  lv_return   = if_identity=>co_false.


  " ---- Initial password: Check only in CREATE mode --------------------*
  "
  if ms_manager-modus       eq go_persistence->co_ta_modus_create.

    if    ms_segment_header-actual-codvn         is initial
      and ms_segment_header-actual-bcode         is initial
      and ms_segment_header-actual-passcode      is initial
      and ms_segment_header-actual-pwdsaltedhash is initial.

      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_password.

      " All password relevant fields are empty: No inital password given
      clear ls_msg.
      " Please enter an initial password
      if 1 = 0. message e290(01). endif.                    "#EC *
      ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
      ls_msg-msgid = '01'.
      ls_msg-msgno = '290'.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_password
          is_msg      = ls_msg.

      lv_return = if_identity=>co_true.
    endif.

  endif.

  " ----  DBMS User check ( initial password ) -----------*


  if abap_true = cl_dbms_customizing=>if_dbms_um_active( ). "DBMS User management active in client

    if ms_segment_dbms_user-dbms_user_data_actual-user_name is not initial. "DBMS User assigned
      if ms_segment_dbms_user-status = go_persistence->co_seg_changed.
        if  ms_segment_dbms_user-dbms_user_data_actual-user_id is initial.  "DBMS user does not exist in DB

          "allow user creation w.o. password
          ms_segment_dbms_user-dbms_change_mode = cl_identity_persistence=>co_ta_modus_create.

*          if ms_segment_dbms_user-dbms_user_data_actual-password is not initial.
*            ms_segment_dbms_user-dbms_change_mode = cl_identity_persistence=>co_ta_modus_create.
*          else.
*            " Can not create DBMS user wo password -> message
*            clear ms_segment_dbms_user-dbms_change_mode.
*            call method go_msg_buffer->delete_object_message
*              exporting
*                iv_bname    = ms_manager-bname
*                iv_nodename = if_identity_definition=>gc_node_dbms_user
*                iv_field    = if_identity_definition=>gc_field_dbms_user_password.
*            if     ms_manager-modus       eq go_persistence->co_ta_modus_create or
*                  " we assign roles to non-existing DBMS-user, DBMS-password is not entered
*                 ( ms_manager-modus       eq go_persistence->co_ta_modus_modify and
*                   ms_segment_dbms_user-dbms_roles_actual is not initial ).
*              clear ls_msg.
*              " Please enter an initial password
*              if 1 = 0. message e010(susr_dbms). endif.     "#EC *
*              ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
*              ls_msg-msgid = 'SUSR_DBMS'.
*              ls_msg-msgno = '010'.
*              call method go_msg_buffer->add_object_message_symsg
*                exporting
*                  iv_bname    = ms_manager-bname
*                  iv_nodename = if_identity_definition=>gc_node_dbms_user
*                  iv_field    = if_identity_definition=>gc_field_dbms_user_password
*                  is_msg      = ls_msg.
*              lv_return = if_identity=>co_true.
*            elseif ms_manager-modus       eq go_persistence->co_ta_modus_modify.
*              "Different message and error handling in change mode because we want to allow chaning inconsistent user
*              " DBMS-user &1 is assigned to user &2, but does not exist
*              if 1 = 0. message e017(susr_dbms) with ls_msg-msgv1 ls_msg-msgv2. endif. "#EC *
*              ls_msg-msgty = if_suid_msg_buffer=>co_type_warning.
*              ls_msg-msgid = 'SUSR_DBMS'.
*              ls_msg-msgno = '017'.
*              ls_msg-msgv1 = ms_segment_dbms_user-dbms_user_data_actual-user_name.
*              ls_msg-msgv2 = ms_manager-bname.
*              call method go_msg_buffer->add_object_message_symsg
*                exporting
*                  iv_bname    = ms_manager-bname
*                  iv_nodename = if_identity_definition=>gc_node_dbms_user
*                  iv_field    = if_identity_definition=>gc_field_dbms_user_dbms_user
*                  iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
*                  is_msg      = ls_msg.
*            endif.
*          endif.
        else.
          ms_segment_dbms_user-dbms_change_mode = cl_identity_persistence=>co_ta_modus_modify.
        endif.
      endif.
    endif.
  endif.

  " ---- Usergroup: Check in CREATE/CHANGE mode --------------------*
  "
  if ms_manager-flg_own_data is initial                              and
     ( ms_manager-modus      eq go_persistence->co_ta_modus_create or
       ms_manager-modus      eq go_persistence->co_ta_modus_modify ).

    data: lv_class           type  xuclass
        .

    " --- Check: Class must be assigned ---
    if gv_class_is_required eq if_identity=>co_true.
      call method me->get_class
        exporting
          iv_for_auth = if_identity=>co_false
        importing
          ev_class    = lv_class.

      if lv_class is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '583'.
        " Ordnen Sie eine Benutzergruppe zu (Hinweis 1663177).
        if 1 = 0. message e583(01). endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            iv_lifetime  = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_permanent
            is_msg       = ls_msg
            iv_overwrite = if_identity=>co_true.

        lv_return = if_identity=>co_true.
      endif.
    endif.

    " --- Check: Authority Check in CREATE mode ---
    if ms_manager-modus         eq go_persistence->co_ta_modus_create and
       lv_class                 is not initial                        and
       ms_manager-class_checked eq if_identity=>co_false.

      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_logondata
          iv_field     = if_identity_definition=>gc_field_logondata_class
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = lv_class
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'. "Authority check failed
        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_logondata
            iv_field     = if_identity_definition=>gc_field_logondata_class
            iv_lifetime  = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_permanent
            is_msg       = ls_msg
            iv_overwrite = if_identity=>co_true.

        lv_return = if_identity=>co_true.

      else.
        " In Create mode: Auth. for role/profile/.. assignment must be checked
        call method me->auth_check_for_new_class
          exporting
            iv_new_class    = lv_class
            iv_ext_lifetime = if_suid_msg_buffer=>co_lifetime_permanent "Usergroup is already assigned
            io_msg_buffer   = go_msg_buffer
          importing
            ev_reject_class = lv_reject_class.
        if lv_reject_class eq if_identity=>co_true.
          lv_return = if_identity=>co_true.
        else.
          " New class is checked
          ms_manager-class_checked = if_identity=>co_true.
        endif.
      endif.
    endif.
  endif.


  " ---- Address / BP ---------------------------------------------------*
  "
  if ( gv_earlywatchclient     eq if_identity=>co_false and
       gv_upg_is_shadow_system eq if_identity=>co_false     ) and
       ms_manager-modus        eq go_persistence->co_ta_modus_create.

    " Check address buffer
    if ms_segment_address-bname is initial.
      fetch_segment_address( ).
    endif.

    " Old User - Address must be created and Last Name must be filled
    if ms_segment_address-actual-idadtype eq if_identity=>co_idad_olduser.

      " Check: Company must be assigned
      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
        " MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.              "#EC *

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_organization
            is_msg       = ls_msg
            iv_overwrite = if_identity=>co_true ).

        lv_return = if_identity=>co_true.

      elseif ms_manager-sn_person_name is initial.
        " Until now the node Person_Name was not changed, but company is assigned
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '092'.
        " MSG: Nachname eines Benutzers muss angegeben werden!
        if 1 = 0. message e092(01). endif.                  "#EC *

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_person_name
            iv_field     = 'NAME_LAST'
            is_msg       = ls_msg ).

        lv_return = if_identity=>co_true.

      endif.

      " BP
    elseif ms_segment_address-actual-idadtype eq if_identity=>co_idad_person.

      " Person assigned
      if ms_segment_address-actual-bpperson is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
        " MSG: Es ist kein Geschäftspartner zugeordnet.
        if 1 = 0. message e011(suid01). endif.              "#EC *

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname     = ms_manager-bname
            iv_nodename  = if_identity_definition=>gc_node_person_name
            is_msg       = ls_msg
            iv_overwrite = if_identity=>co_true ).

        lv_return = if_identity=>co_true.
      endif.

    endif.

  elseif ( gv_earlywatchclient     eq if_identity=>co_false and
           gv_upg_is_shadow_system eq if_identity=>co_false )      and
           ms_manager-modus        eq go_persistence->co_ta_modus_modify.

    " Old User
    if ms_segment_address-actual-idadtype eq if_identity=>co_idad_olduser.

      if ms_manager-sn_organization is not initial.

        " Check: Company must be assigned
        if ms_segment_address-actual-addrnumber is initial.
          clear: ls_msg.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
          " MSG: Es ist keine Firma zugeordnet.
          if 1 = 0. message e012(suid01). endif.            "#EC *

          go_msg_buffer->add_object_message_symsg(
            exporting
              iv_bname     = ms_manager-bname
              iv_nodename  = if_identity_definition=>gc_node_organization
              is_msg       = ls_msg
              iv_overwrite = if_identity=>co_true ).

          lv_return = if_identity=>co_true.

        elseif ms_manager-sn_person_name is initial.

          " Until now the node Person_Name was not changed, but company is assigned
          clear: ls_msg.
          ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '092'.
          " MSG: Nachname eines Benutzers muss angegeben werden!
          if 1 = 0. message e092(01). endif.                "#EC *

          go_msg_buffer->add_object_message_symsg(
            exporting
              iv_bname     = ms_manager-bname
              iv_nodename  = if_identity_definition=>gc_node_person_name
              iv_field     = 'NAME_LAST'
              is_msg       = ls_msg ).

          lv_return = if_identity=>co_true.

        endif.

      endif.

      " BP
    elseif ms_segment_address-actual-idadtype eq if_identity=>co_idad_person.

      if ms_manager-sn_person is not initial or
         ms_manager-sn_tech_user is not initial.
        if ms_segment_address-actual-bpperson is initial.
          clear: ls_msg.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
          " MSG: Es ist kein Geschäftspartner zugeordnet.
          if 1 = 0. message e011(suid01). endif.            "#EC *

          go_msg_buffer->add_object_message_symsg(
            exporting
              iv_bname     = ms_manager-bname
              iv_nodename  = if_identity_definition=>gc_node_person_name
              is_msg       = ls_msg
              iv_overwrite = if_identity=>co_true ).

          lv_return = if_identity=>co_true.
        endif.
      endif.

    endif.
  endif.


  " ---- Address --------------------------------------------------------*
  " Crosscheck: Workplace - CommData
  if gv_earlywatchclient                eq if_identity=>co_false        and
     gv_upg_is_shadow_system            eq if_identity=>co_false        and
     ms_segment_address-bname           is not initial                  and
     ms_segment_address-actual-idadtype eq if_identity=>co_idad_olduser.

    if ms_manager-sn_workplace     is not initial or
       ms_manager-sn_telephone     is not initial or
       ms_manager-sn_facsimile     is not initial or
       ms_manager-sn_email         is not initial or
       ms_manager-sn_web           is not initial or
       ms_manager-sn_telex         is not initial or
       ms_manager-sn_teletex       is not initial or
       ms_manager-sn_remote_mail   is not initial or
       ms_manager-sn_x400          is not initial or
       ms_manager-sn_printer       is not initial or
       ms_manager-sn_ssf           is not initial or
       ms_manager-sn_pager         is not initial.

      " Check error status of node
      call method go_msg_buffer->find_error_for_node
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
        receiving
          ev_error    = lv_error.

      if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
        ms_manager-sn_workplace = go_persistence->co_node_status_checked.
      else.                     "  New node status: CHANGED
        ms_manager-sn_workplace = go_persistence->co_node_status_changed.
        lv_return = if_identity=>co_true.
      endif.
    endif.
  endif.


  " BADI
  if gv_upg_is_shadow_system eq if_identity=>co_false.
    try.
        " Dynamic call: BADIs MUST NOT be called during upgrade, because they might not activated
        if mo_badi_identity_check is not bound.
          ls_badi_filter-name = 'TCODE_MODE'.
          get reference of mv_tcode_mode into ls_badi_filter-value.
          append ls_badi_filter to lt_badi_filter.

          get badi mo_badi_identity_check type ('BADI_IDENTITY_CHECK')
            filter-table lt_badi_filter.
        endif.

        call method cl_badi_query=>number_of_implementations
          exporting
            badi = mo_badi_identity_check
          receiving
            num  = lv_num_badi.

        if lv_num_badi ne 0.

          ls_badi_identity_check-bname         = ms_manager-bname.
          ls_badi_identity_check-idref         = me.
          ls_badi_identity_check-identity_guid = ms_segment_address-actual-identity_guid.
          ls_badi_identity_check-modus         = ms_manager-modus.

          move-corresponding ms_segment_cua_systems to ls_badi_identity_cua_systems.
          move-corresponding ms_segment_cua_roles   to ls_badi_identity_cua_roles.
          move-corresponding ms_segment_roles       to ls_badi_identity_roles.
          move-corresponding ms_segment_groups      to ls_badi_identity_groups.

          call badi mo_badi_identity_check->('CHECK')
            exporting
              is_badi_identity_check       = ls_badi_identity_check
              io_badi_msg_buffer           = go_msg_buffer
              is_badi_identity_cua_systems = ls_badi_identity_cua_systems
              is_badi_identity_cua_roles   = ls_badi_identity_cua_roles
              is_badi_identity_roles       = ls_badi_identity_roles
              is_badi_identity_groups      = ls_badi_identity_groups.

          call method go_msg_buffer->find_error_for_user
            exporting
              iv_bname = ms_manager-bname
            receiving
              ev_error = lv_error.

          if lv_error eq if_identity=>co_true.
            lv_return = if_identity=>co_true.
          endif.
        endif.

      catch cx_badi.                                    "#EC NO_HANDLER
    endtry.
  endif.


  " Return, if errors in buffer
  if lv_return = if_identity=>co_true.
    return.
  endif.


  " Check node status (Initial: No change OR Checked: Changes ok)

  check : ms_manager-sn_logondata       ne go_persistence->co_node_status_changed
        , ms_manager-sn_defaults        ne go_persistence->co_node_status_changed
        , ms_manager-sn_snc             ne go_persistence->co_node_status_changed
        , ms_manager-sn_password        ne go_persistence->co_node_status_changed
        , ms_manager-sn_pwdhash         ne go_persistence->co_node_status_changed
        , ms_manager-sn_lockdata        ne go_persistence->co_node_status_changed
        , ms_manager-sn_roles           ne go_persistence->co_node_status_changed
        , ms_manager-sn_profiles        ne go_persistence->co_node_status_changed
        , ms_manager-sn_parameter       ne go_persistence->co_node_status_changed
        , ms_manager-sn_groups          ne go_persistence->co_node_status_changed
        , ms_manager-sn_certmap         ne go_persistence->co_node_status_changed
        , ms_manager-sn_dbms_user       ne go_persistence->co_node_status_changed
        , ms_manager-sn_uclass          ne go_persistence->co_node_status_changed
        , ms_manager-sn_cua_systems     ne go_persistence->co_node_status_changed
        , ms_manager-sn_cua_roles       ne go_persistence->co_node_status_changed
        , ms_manager-sn_cua_profiles    ne go_persistence->co_node_status_changed
        , ms_manager-sn_cua_uclass      ne go_persistence->co_node_status_changed
        , ms_manager-sn_cua_password    ne go_persistence->co_node_status_changed
        , ms_manager-sn_refuser         ne go_persistence->co_node_status_changed
        , ms_manager-sn_tech_user       ne go_persistence->co_node_status_changed
        , ms_manager-sn_tech_user_data  ne go_persistence->co_node_status_changed
        , ms_manager-sn_organization    ne go_persistence->co_node_status_changed
        , ms_manager-sn_person_name     ne go_persistence->co_node_status_changed
        , ms_manager-sn_workplace       ne go_persistence->co_node_status_changed
        , ms_manager-sn_person          ne go_persistence->co_node_status_changed
        , ms_manager-sn_telephone       ne go_persistence->co_node_status_changed
        , ms_manager-sn_facsimile       ne go_persistence->co_node_status_changed
        , ms_manager-sn_email           ne go_persistence->co_node_status_changed
        , ms_manager-sn_web             ne go_persistence->co_node_status_changed
        , ms_manager-sn_telex           ne go_persistence->co_node_status_changed
        , ms_manager-sn_teletex         ne go_persistence->co_node_status_changed
        , ms_manager-sn_remote_mail     ne go_persistence->co_node_status_changed
        , ms_manager-sn_x400            ne go_persistence->co_node_status_changed
        , ms_manager-sn_printer         ne go_persistence->co_node_status_changed
        , ms_manager-sn_ssf             ne go_persistence->co_node_status_changed
        , ms_manager-sn_pager           ne go_persistence->co_node_status_changed
        .

  " New status: Instance is checked
  ms_manager-status = go_persistence->co_ta_status_checked.
  ev_rejected       = if_identity=>co_false.



endmethod.


method do_save.
*
* Save all modified instances
*
  data: lv_update_task              type        sesf_boolean
      .

* Set exporting parameter
  ev_rejected   = if_identity=>co_false.
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Evaluate if function modules should be called in update task handler
*     Default is: call function in update task
*     in emergency case provide parameter to be able to modify without update task
  if iv_update_task is supplied.
    lv_update_task = iv_update_task.
  else.
      lv_update_task = iv_update_task.
  endif.

* --- finalize instances ----------------------------------------------*
* --- Set timestamp, fill segments for change history -----------------*
  call method cl_identity=>finalize
    importing
      ev_rejected = ev_rejected.

  if ev_rejected eq if_identity=>co_true.
*   if finalize fails, set identities back to Unchecked
    call method cl_identity=>after_rejected_save.
    return.
  endif.

* --- Check before Save -----------------------------------------------*
  call method cl_identity=>check_before_save
    importing
      ev_rejected = ev_rejected.
  if ev_rejected eq if_identity=>co_true.
*   if check before save fails, set identities back to Unchecked
    call method cl_identity=>after_rejected_save.
    return.
  endif.

* --- Perform Save ----------------------------------------------------*
*
* Set event handler for external commit for non-ESI context
  set handler cl_identity=>catch_txn_finished.

  call method cl_identity=>save
    exporting
      iv_update_task = lv_update_task
    importing
      es_timestamp   = es_timestamp
      ev_rejected    = ev_rejected.

endmethod.


method easy_access_menu_save.

  if iv_update_task = if_identity=>co_true.
    call function 'SUID_IDENTITY_EASY_ACC_TO_DB'
      in update task
      exporting
        it_bname_copy   = it_bname_copy
        it_bname_delete = it_bname_delete.
  else.
    call function 'SUID_IDENTITY_EASY_ACC_TO_DB'
      exporting
        it_bname_copy   = it_bname_copy
        it_bname_delete = it_bname_delete.
  endif.


endmethod.


method easy_access_menu_set_copied.
* Set flag to mark that SAP EASY ACCESS should be handled in case some user
* is being deleted or being copied with SAP EASY ACCESS MENU

  if iv_source_bname is not initial.
    ms_manager-easy_access_copied-source_bname = iv_source_bname.
    ms_manager-easy_access_copied-target_bname = ms_manager-bname.
    ms_manager-status = go_persistence->co_ta_status_unchecked.
  endif.


endmethod.


method fetch_segment_address.
*
* Fill address segment
*   - From DB if IS_ADDRESS is empty
*   - From importing parameter IS_ADDRESS if this is supplied
*

  data: lr_address type ref to usr21
       ,lt_address type        suid_tt_usr21
       ,ls_address type        usr21
       ,lt_bname   type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_address-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if is_address is supplied.
    get reference of is_address into lr_address.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_address = lt_address.

    read table lt_address
         reference into lr_address
         with key bname = ms_manager-bname
         binary search.
    if sy-subrc <> 0.
      get reference of ls_address into lr_address.
    endif.
  endif.


* --- Now take data and move it to the segment ------------------------*
  if lr_address->* is initial.
*   Pre-Fill this mandatory segment
    ms_segment_address-bname                  = ms_manager-bname. " Mark segment as read
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
      ms_segment_address-actual-mandt           = sy-mandt.
      ms_segment_address-actual-bname           = ms_manager-bname.
      ms_segment_address-status                 = go_persistence->co_seg_changed.
      ms_segment_address-actual-idadtype        = cl_identity_factory=>get_default_idadtype( ).  " User with Person assignment or Old User
    else.
      clear: ms_segment_address-status.
    endif.
  else. " Everything ok: Now really fill segment!
    ms_segment_address-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create.
      ms_segment_address-status                 = go_persistence->co_seg_changed.
      ms_segment_address-before_image           = lr_address->*.
      clear ms_segment_address-actual.
      ms_segment_address-actual-mandt           = sy-mandt.
      ms_segment_address-actual-bname           = ms_manager-bname.
      ms_segment_address-actual-idadtype        = cl_identity_factory=>get_default_idadtype( ).  " User with Person assignment or Old User
    elseif ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only - open for address handling !!!!!
      ms_segment_address-status       = go_persistence->co_seg_changed.
      ms_segment_address-before_image = lr_address->*.
      clear ms_segment_address-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_address-status.
      ms_segment_address-before_image = lr_address->*.
      ms_segment_address-actual       = ms_segment_address-before_image.
    endif.
  endif.


endmethod.


method fetch_segment_certmap.
*
* Fill certmap segment
*   - From DB if IT_CERTMAP is empty
*   - From importing parameter IT_CERTMAP if this is supplied
*

  data: lt_certmap type        suid_tt_usrcertmap
       ,lt_bname   type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_certmap-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_certmap is supplied.
    lt_certmap = it_certmap.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_certmap = lt_certmap.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_certmap is initial.
*   No certmap is assigned - however, segment has been read
    ms_segment_certmap-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_certmap-status.
  else. " Everything ok: Now really fill segment!
    ms_segment_certmap-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_certmap-status       = go_persistence->co_seg_changed.
      ms_segment_certmap-before_image = lt_certmap.
      clear ms_segment_certmap-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_certmap-status.
      ms_segment_certmap-before_image = lt_certmap.
      ms_segment_certmap-actual       = ms_segment_certmap-before_image.
    endif.
  endif.


endmethod.


METHOD fetch_segment_cua_profiles.
*
* Fill cua roles segment
*   - From DB if it_cua_profiles is empty
*   - From importing parameter it_cua_profiles if this is supplied
*

  DATA: lt_profiles   TYPE        suid_tt_usl04.
  DATA: lt_bname      TYPE        suid_tt_bname.

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  IF ms_manager-bname IS INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  ENDIF.

* Segment must not be filled
  IF ms_segment_cua_profiles-bname IS NOT INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  ENDIF.

* --- Decide: Take importing parameter or information from DB? --------*
  IF it_cua_profiles IS SUPPLIED.
    lt_profiles = it_cua_profiles.
  ELSE.
*   No data available for this segment yet --> read from DB
    CLEAR lt_bname.
    APPEND ms_manager-bname TO lt_bname.
    CALL METHOD go_persistence->if_suid_persistence_read~read
      EXPORTING
        it_bname        = lt_bname
      IMPORTING
        et_cua_profiles = lt_profiles.
  ENDIF.

* --- Now take data and move it to the segment ------------------------*
  IF lt_profiles IS INITIAL.
*   No profile is assigned - however, segment has been read
    ms_segment_cua_profiles-bname = ms_manager-bname.  " Mark segment as read
    CLEAR ms_segment_cua_profiles-status.
  ELSE. " Everything ok: Now really fill segment!
    ms_segment_cua_profiles-bname  = ms_manager-bname.
*   Take transaction mode into account
    IF     ms_manager-modus = go_persistence->co_ta_modus_create
      OR   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_cua_profiles-status        = go_persistence->co_seg_changed.
      ms_segment_cua_profiles-before_image  = lt_profiles.
      CLEAR ms_segment_cua_profiles-actual.
    ELSEIF ms_manager-modus = go_persistence->co_ta_modus_display
      OR   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      CLEAR ms_segment_cua_profiles-status.
      ms_segment_cua_profiles-before_image = lt_profiles.
      ms_segment_cua_profiles-actual       = ms_segment_cua_profiles-before_image.
    ENDIF.
  ENDIF.
ENDMETHOD.


METHOD fetch_segment_cua_roles.
*
* Fill cua roles segment
*   - From DB if IT_ROLES is empty
*   - From importing parameter IT_ROLES if this is supplied
*

  DATA: lt_roles  TYPE        suid_tt_usla04
       ,lt_bname  TYPE        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  IF ms_manager-bname IS INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  ENDIF.

* Segment must not be filled
  IF ms_segment_cua_roles-bname IS NOT INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  ENDIF.

* --- Decide: Take importing parameter or information from DB? --------*
  IF it_roles IS SUPPLIED.
    lt_roles = it_roles.
  ELSE.
*   No data available for this segment yet --> read from DB
    CLEAR lt_bname.
    APPEND ms_manager-bname TO lt_bname.
    CALL METHOD go_persistence->if_suid_persistence_read~read
      EXPORTING
        it_bname     = lt_bname
      IMPORTING
        et_cua_roles = lt_roles.
  ENDIF.

* --- Now take data and move it to the segment ------------------------*
  IF lt_roles IS INITIAL.
*   No role is assigned - however, segment has been read
    ms_segment_cua_roles-bname = ms_manager-bname.  " Mark segment as read
    CLEAR ms_segment_cua_roles-status.
  ELSE. " Everything ok: Now really fill segment!
    ms_segment_cua_roles-bname  = ms_manager-bname.
*   Take transaction mode into account
    IF     ms_manager-modus = go_persistence->co_ta_modus_create
      OR   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_cua_roles-status = go_persistence->co_seg_changed.
      ms_segment_cua_roles-before_image = lt_roles.
      CLEAR ms_segment_cua_roles-actual.
    ELSEIF ms_manager-modus = go_persistence->co_ta_modus_display
      OR   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      CLEAR ms_segment_cua_roles-status.
      ms_segment_cua_roles-before_image = lt_roles.
      ms_segment_cua_roles-actual       = ms_segment_cua_roles-before_image.
    ENDIF.
  ENDIF.
ENDMETHOD.


method fetch_segment_cua_systems.
*
* Fill system and user distribution protocol segments
*   - From DB if IT_CUA_SYSTEMS is empty
*   - From importing parameter IT_CUA_SYSTEMS if this is supplied
*   - CUA and central system check should be already done before
*
*   - Actual image of MS_SEGMENT_CUA_SYSTEMS should be filled also in Delete case
*     unlike other segments


  data:   lt_cua_systems    type      suid_tt_uszbvsys
        , lt_bname          type      suid_tt_bname
        .



* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_cua_systems-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.



* --- Decide: Take importing parameter or information from DB? --------*
  if it_cua_systems is supplied.
    lt_cua_systems = it_cua_systems.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname       = lt_bname
      importing
        et_cua_systems = lt_cua_systems.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_cua_systems is initial.
*   No systems are assigned - however, segment has been read
    ms_segment_cua_systems-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_cua_systems-status.

  else. " Everything ok: Now really fill segment!
    ms_segment_cua_systems-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create.
*     Move data to before image only
      ms_segment_cua_systems-status = go_persistence->co_seg_changed.
      ms_segment_cua_systems-before_image = lt_cua_systems.
      clear: ms_segment_cua_systems-actual.

    elseif ms_manager-modus = go_persistence->co_ta_modus_delete.
*     In central system and for CUA users in child system
      if gv_cua_central = if_identity=>co_true or
        ( gv_cua_child = if_identity=>co_true and mv_cua_mode <> co_cua_not_transferred ).
*       Move data to both before and actual image (USZBVSYS entries shouldn't be deleted)
        clear: ms_segment_cua_systems-status.
        ms_segment_cua_systems-before_image = lt_cua_systems.
        ms_segment_cua_systems-actual       = ms_segment_cua_systems-before_image.
*     For not CUA users (USZBVSYS entries should be deleted)
      else.
*       Move data to before image only
        ms_segment_cua_systems-status = go_persistence->co_seg_changed.
        ms_segment_cua_systems-before_image = lt_cua_systems.
        clear: ms_segment_cua_systems-actual.
      endif.

    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear: ms_segment_cua_systems-status.
      ms_segment_cua_systems-before_image = lt_cua_systems.
      ms_segment_cua_systems-actual       = ms_segment_cua_systems-before_image.

    endif.
  endif.

endmethod.


method fetch_segment_cua_uclasses.
*
* Fill CUA-licence segment
*   - From DB if IT_CUA_UCLASSES is empty
*   - From importing table IT_CUA_UCLASSES if this is supplied
*

  data: lt_cua_uclasses   type        suid_tt_usr06sys
       ,lt_bname          type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    macro_raise_internal_error.
  endif.

* Segment must not be filled
  if ms_segment_cua_uclasses-bname is not initial.
    macro_raise_internal_error.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_cua_uclasses is supplied.
    lt_cua_uclasses = it_cua_uclasses.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname        = lt_bname
      importing
        et_cua_uclasses = lt_cua_uclasses.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_cua_uclasses is initial.
*   No licence data is assigned in child systems - however, segment has been read
    ms_segment_cua_uclasses-bname = ms_manager-bname.  " Mark segment as read
    clear: ms_segment_cua_uclasses-status.
  else.                             " Everything ok: Now fill segment!
    ms_segment_cua_uclasses-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_cua_uclasses-status = go_persistence->co_seg_changed.
      ms_segment_cua_uclasses-before_image = lt_cua_uclasses.
      clear: ms_segment_cua_uclasses-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear: ms_segment_cua_uclasses-status.
      ms_segment_cua_uclasses-before_image = lt_cua_uclasses.
      ms_segment_cua_uclasses-actual       = ms_segment_cua_uclasses-before_image.
    endif.
  endif.



endmethod.


method fetch_segment_cua_user_prot.
*
* Fill system and user distribution protocol segments
*   - From DB if IT_CUA_USERS_PROT is empty
*   - From importing parameter IT_CUA_USERS_PROT if this is supplied
*   - CUA and central system check should be already done before
*

  data:   lt_cua_user_prot  type      suid_tt_uszbvprot
        , lt_bname          type      suid_tt_bname
        .



* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_cua_user_prot-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.


* --- Decide: Take importing parameter or information from DB? --------*
  if it_cua_users_prot is supplied.
    lt_cua_user_prot = it_cua_users_prot.
  else.
*   No data available for this segment yet --> read from DB
    clear: lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname         = lt_bname
      importing
        et_cua_user_prot = lt_cua_user_prot.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_cua_user_prot is initial.
*   No systems are assigned - however, segment has been read
    ms_segment_cua_user_prot-bname = ms_manager-bname.  " Mark segment as read
    clear: ms_segment_cua_user_prot-status.

  else. " Everything ok: Now really fill segment!
    ms_segment_cua_user_prot-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create.
*     Move data to before image only
      ms_segment_cua_user_prot-status = go_persistence->co_seg_changed.
      ms_segment_cua_user_prot-before_image = lt_cua_user_prot.
      clear: ms_segment_cua_user_prot-actual.

    elseif ms_manager-modus = go_persistence->co_ta_modus_delete.
*     In central system and for CUA users in child system
      if gv_cua_central = if_identity=>co_true or
        ( gv_cua_child = if_identity=>co_true and mv_cua_mode <> co_cua_not_transferred ).
*       Move data to both before and actual image (USZBVSYS entries shouldn't be deleted)
        clear: ms_segment_cua_user_prot-status.
        ms_segment_cua_user_prot-before_image = lt_cua_user_prot.
        ms_segment_cua_user_prot-actual       = ms_segment_cua_user_prot-before_image.
*     For not CUA users (USZBVSYS entries should be deleted)
      else.
*       Move data to before image only
        ms_segment_cua_user_prot-status = go_persistence->co_seg_changed.
        ms_segment_cua_user_prot-before_image = lt_cua_user_prot.
        clear: ms_segment_cua_user_prot-actual.
      endif.

    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear: ms_segment_cua_user_prot-status.
      ms_segment_cua_user_prot-before_image = lt_cua_user_prot.
      ms_segment_cua_user_prot-actual       = ms_segment_cua_user_prot-before_image.

    endif.
  endif.


endmethod.


method fetch_segment_dbms_user.
*
* Fill DBMS_USER segment
*   - From DB if IS_DBMS_USER is empty
*   - From importing parameter IS_DBMS_USER if this is supplied
*

  data: ls_dbms_user type        usr_dbms_user
      , lt_bname     type        suid_tt_bname
      , lr_dbms_user type ref to usr_dbms_user
      .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_dbms_user-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if is_dbms_user is supplied.
    get reference of is_dbms_user into lr_dbms_user.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname     = lt_bname
      importing
        et_dbms_user = data(lt_dbms_user).

    read table lt_dbms_user
         reference into lr_dbms_user
         with key bname = ms_manager-bname
         binary search.
    if sy-subrc <> 0.
      get reference of ls_dbms_user into lr_dbms_user.
    endif.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lr_dbms_user->* is initial.
*   No data is assigned - however, segment has been read
    ms_segment_dbms_user-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_dbms_user-status.
  else.                             " Everything ok: Now fill segment!
    ms_segment_dbms_user-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_dbms_user-status = go_persistence->co_seg_changed.
      ms_segment_dbms_user-before_image = lr_dbms_user->*.
      clear ms_segment_dbms_user-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_dbms_user-status.
      ms_segment_dbms_user-before_image = lr_dbms_user->*.
      ms_segment_dbms_user-actual       = ms_segment_dbms_user-before_image.
    endif.
  endif.

* Read DBMS User Data
  if ms_segment_dbms_user-before_image-dbms_user is not initial and  "Read if mapping is saved in USR_DBMS_USER table
     cl_dbms_customizing=>if_dbms_um_active( ) = abap_true. ".. and DBMS users generaly supported in the system
    cl_suid_dbms=>dbms_user_data_read(
      exporting
        iv_dbms_user      =  ms_segment_dbms_user-before_image-dbms_user
      importing
        es_dbms_user_data = ms_segment_dbms_user-dbms_user_data_before
        et_dbms_roles     = ms_segment_dbms_user-dbms_roles_before
    ).
  endif.

  if ms_segment_dbms_user-actual-dbms_user is not initial.
    ms_segment_dbms_user-dbms_user_data_actual = ms_segment_dbms_user-dbms_user_data_before.
    ms_segment_dbms_user-dbms_roles_actual     = ms_segment_dbms_user-dbms_roles_before.
  endif.

endmethod.


method fetch_segment_defaults.
*
* Fill defaults segment
*   - From DB if IS_DEFAULTS is empty
*   - From importing parameter IS_DEFAULTS if this is supplied
*

  data: lr_defaults type ref to usr01
       ,ls_defaults type        usr01
       ,lt_defaults type        suid_tt_usr01
       ,lt_bname    type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_defaults-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if is_defaults is supplied.
    get reference of is_defaults into lr_defaults.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname
      importing
        et_defaults = lt_defaults.

    read table lt_defaults
         reference into lr_defaults
         with key bname = ms_manager-bname
         binary search.
    if sy-subrc <> 0.
      get reference of ls_defaults into lr_defaults.
    endif.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lr_defaults->* is initial.
    ms_segment_defaults-bname  = ms_manager-bname.
    if     ms_manager-modus = go_persistence->co_ta_modus_create.
      ms_segment_defaults-status = go_persistence->co_seg_changed.
    elseif ms_manager-modus = go_persistence->co_ta_modus_modify
      or   ms_manager-modus = go_persistence->co_ta_modus_display.
*     Data inconsistency: User was created without table entry for USR01
*     Set values for: - Date format (Profile parameter)
*                     - Time format (Profile parameter)
*                     - Number format (Profile parameter)
*                     - Print parameter 2 SPDA ('K')
*                     - Print parameter 3 SPDB ('H')
      call function 'SUSR_USER_DEFAULT_DATE_FORMAT'
        importing
          datfm = ms_segment_defaults-actual-datfm.
      call function 'SUSR_USER_DEFAULT_TIME_FORMAT'
       importing
         timefm = ms_segment_defaults-actual-timefm.
      call function 'SUSR_USER_DEFAULT_DEC_NOTATION'
        importing
          dcpfm = ms_segment_defaults-actual-dcpfm.
      ms_segment_defaults-actual-spda  = 'K'.     " Keep
      ms_segment_defaults-actual-spdb  = 'H'.     " Hold
      ms_segment_defaults-actual-bname = ms_manager-bname.
      if ms_manager-modus = go_persistence->co_ta_modus_modify.
        ms_segment_defaults-status = go_persistence->co_seg_changed.
      else.
        clear ms_segment_defaults-status.
      endif.
    else.
      clear ms_segment_defaults-status.
    endif.

  else.                         " Everything ok: Now fill segment!
    ms_segment_defaults-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_defaults-status = go_persistence->co_seg_changed.
      ms_segment_defaults-before_image = lr_defaults->*.
      clear ms_segment_defaults-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_defaults-status.
      ms_segment_defaults-before_image = lr_defaults->*.
      ms_segment_defaults-actual       = ms_segment_defaults-before_image.

*     Data inconsistency: User was created without table entry for USR01
*     Set values for: - Date format (Profile parameter)
*                     - Print parameter 2 SPDA ('K')
*                     - Print parameter 3 SPDB ('H')
      if ms_segment_defaults-actual-datfm is initial.
        call function 'SUSR_USER_DEFAULT_DATE_FORMAT'
          importing
            datfm = ms_segment_defaults-actual-datfm.
        if ms_manager-modus = go_persistence->co_ta_modus_modify.
          ms_segment_defaults-status = go_persistence->co_seg_changed.
        endif.
      endif.
      if ms_segment_defaults-actual-timefm is initial.
        call function 'SUSR_USER_DEFAULT_TIME_FORMAT'
         importing
           timefm = ms_segment_defaults-actual-timefm.
        if ms_manager-modus = go_persistence->co_ta_modus_modify.
          ms_segment_defaults-status = go_persistence->co_seg_changed.
        endif.
      endif.
      if ms_segment_defaults-actual-spda is initial.
        ms_segment_defaults-actual-spda = 'K'.     " Keep
        if ms_manager-modus = go_persistence->co_ta_modus_modify.
          ms_segment_defaults-status = go_persistence->co_seg_changed.
        endif.
      endif.
      if ms_segment_defaults-actual-spdb is initial.
        ms_segment_defaults-actual-spdb = 'H'.     " Hold
        if ms_manager-modus = go_persistence->co_ta_modus_modify.
          ms_segment_defaults-status = go_persistence->co_seg_changed.
        endif.
      endif.

    endif.
  endif.
endmethod.


method fetch_segment_docu.
*
* Fill docu segment
*   - From DB if IS_DOCU is empty
*   - From importing parameter IS_DOCU if this is supplied
*

  data: lt_docu    TYPE        suid_tt_usdocu
       ,lt_bname   type        suid_tt_bname
       .

  " --- Consistency checks ----------------------------------------------*
  " Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

  " Segment must not be filled
  if ms_segment_docu-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

  " --- Decide: Take importing parameter or information from DB? --------*
  if it_docu is supplied.
    lt_docu = it_docu.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname = lt_bname
      importing
        et_docu  = lt_docu.
  endif.

  " --- Now take data and move it to the segment ------------------------*
  if lt_docu is initial.
    " No docu data is assigned - however, segment has been read
    ms_segment_docu-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_docu-status.
  else.                             " Everything ok: Now fill segment!
    ms_segment_docu-bname  = ms_manager-bname.
    " Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
      " Move data to before image only
      ms_segment_docu-status = go_persistence->co_seg_changed.
      ms_segment_docu-before_image = lt_docu.
      clear ms_segment_docu-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
      " Move data to both before and actual image
      clear ms_segment_docu-status.
      ms_segment_docu-before_image = lt_docu.
      ms_segment_docu-actual       = ms_segment_docu-before_image.
    endif.
  endif.

endmethod.


method FETCH_SEGMENT_GROUPS.
*
* Fill address segment
*   - From DB if IT_GROUPS is empty
*   - From importing parameter IT_GROUPS if this is supplied
*

  data: lt_groups  type        suid_tt_usgrp_user
       ,lt_bname   type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_groups-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_groups is supplied.
    lt_groups = it_groups.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_groups  = lt_groups.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_groups is initial.
*   No group is assigned - however, segment has been read
    ms_segment_groups-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_groups-status.
  else. " Everything ok: Now really fill segment!
    ms_segment_groups-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_groups-status = go_persistence->co_seg_changed.
      ms_segment_groups-before_image = lt_groups.
      clear ms_segment_groups-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_groups-status.
      ms_segment_groups-before_image = lt_groups.
      ms_segment_groups-actual       = ms_segment_groups-before_image.
    endif.
  endif.
endmethod.


method fetch_segment_parameter.
*
* Fill parameter segment
*   - From DB if IT_PARAMETER is empty
*   - From importing parameter IT_PARAMETER if this is supplied
*

  data: lt_parameter  type        suid_tt_usr05
       ,lt_bname      type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_parameter-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_parameter is supplied.
    lt_parameter = it_parameter.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname     = lt_bname
      importing
        et_parameter = lt_parameter.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_parameter is initial.
*   No parameter is assigned - however, segment has been read
    ms_segment_parameter-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_parameter-status.
  else. " Everything ok: Now really fill segment!
    ms_segment_parameter-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_parameter-status = go_persistence->co_seg_changed.
      ms_segment_parameter-before_image = lt_parameter.
      clear ms_segment_parameter-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_parameter-status.
      ms_segment_parameter-before_image = lt_parameter.
      ms_segment_parameter-actual       = ms_segment_parameter-before_image.
    endif.
  endif.
endmethod.


method FETCH_SEGMENT_PROFILES_T04.
*
* Fill address segment
*   - From DB if IT_profiles is empty
*   - From importing parameter IT_profiles if this is supplied
*

  data: lt_profiles  type      suid_tt_ust04
       ,lt_bname     type      suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_profiles_t04-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_profiles is supplied.
    lt_profiles = it_profiles.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_profiles  = lt_profiles.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_profiles is initial.
*   No group is assigned - however, segment has been read
    ms_segment_profiles_t04-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_profiles_t04-status.
  else. " Everything ok: Now really fill segment!
    ms_segment_profiles_t04-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_profiles_t04-status = go_persistence->co_seg_changed.
      ms_segment_profiles_t04-before_image = lt_profiles.
      clear ms_segment_profiles_t04-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_profiles_t04-status.
      ms_segment_profiles_t04-before_image = lt_profiles.
      ms_segment_profiles_t04-actual       = ms_segment_profiles_t04-before_image.
    endif.
  endif.
endmethod.


method fetch_segment_refuser.
*
* Fill refuser segment
*   - From DB if IS_REFUSER is empty
*   - From importing parameter IS_REFUSER if this is supplied
*

  data: lr_refuser type ref to usrefus
       ,ls_refuser type        usrefus
       ,lt_refuser type        suid_tt_usrefus
       ,lt_bname   type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_refuser-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if is_refuser is supplied.
    get reference of is_refuser into lr_refuser.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_refuser = lt_refuser.

    read table lt_refuser
         reference into lr_refuser
         with key bname = ms_manager-bname
         binary search.
    if sy-subrc <> 0.
      get reference of ls_refuser into lr_refuser.
    endif.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lr_refuser->* is initial.
*   Pre-Fill this mandatory segment
    ms_segment_refuser-bname = ms_manager-bname.
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
      ms_segment_refuser-actual-bname = ms_manager-bname.
      ms_segment_refuser-status       = go_persistence->co_seg_changed.
    else.
      clear ms_segment_refuser-status.
    endif.
  else. " Everything ok: Now really fill segment!
    ms_segment_refuser-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create.
*     Move data to before image and prefill this mandatory segment
      ms_segment_refuser-status       = go_persistence->co_seg_changed.
      ms_segment_refuser-before_image = lr_refuser->*.
      ms_segment_refuser-actual-bname = ms_manager-bname.
    elseif ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_refuser-status       = go_persistence->co_seg_changed.
      ms_segment_refuser-before_image = lr_refuser->*.
      clear ms_segment_refuser-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_refuser-status.
      ms_segment_refuser-before_image = lr_refuser->*.
      ms_segment_refuser-actual       = ms_segment_refuser-before_image.
    endif.
  endif.
endmethod.


method FETCH_SEGMENT_ROLES.
*
* Fill address segment
*   - From DB if IT_ROLES is empty
*   - From importing parameter IT_ROLES if this is supplied
*

  data: lt_roles  type        suid_tt_agr_users
       ,lt_bname  type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_roles-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_roles is supplied.
    lt_roles = it_roles.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname
      importing
        et_roles  = lt_roles.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_roles is initial.
*   No role is assigned - however, segment has been read
    ms_segment_roles-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_roles-status.
  else. " Everything ok: Now really fill segment!
    ms_segment_roles-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_roles-status = go_persistence->co_seg_changed.
      ms_segment_roles-before_image = lt_roles.
      clear ms_segment_roles-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_roles-status.
      ms_segment_roles-before_image = lt_roles.
      ms_segment_roles-actual       = ms_segment_roles-before_image.
    endif.
  endif.
endmethod.


method FETCH_SEGMENT_SNC.
*
* Fill snc segment
*   - From DB if IS_SNC is empty
*   - From importing parameter IS_SNC if this is supplied
*

  data: lr_snc    type ref to usracl
       ,ls_snc    type        usracl
       ,lt_snc    type        suid_tt_usracl
       ,lt_bname  type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_snc-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if is_snc is supplied.
    get reference of is_snc into lr_snc.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname
      importing
        et_snc = lt_snc.

    read table lt_snc
         reference into lr_snc
         with key bname = ms_manager-bname
         binary search.
    if sy-subrc <> 0.
      get reference of ls_snc into lr_snc.
    endif.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lr_snc->* is initial.
*   No SNC data is assigned - however, segment has been read
    ms_segment_snc-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_snc-status.
  else.                             " Everything ok: Now fill segment!
    ms_segment_snc-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_snc-status = go_persistence->co_seg_changed.
      ms_segment_snc-before_image = lr_snc->*.
      clear ms_segment_snc-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_snc-status.
      ms_segment_snc-before_image = lr_snc->*.
      ms_segment_snc-actual       = ms_segment_snc-before_image.
    endif.
  endif.
endmethod.


method FETCH_SEGMENT_UCLASS.
*
* Fill licence segment
*   - From DB if IS_UCLASS is empty
*   - From importing parameter IS_UCLASS if this is supplied
*

  data: lr_uclass type ref to usr06
       ,ls_uclass type        usr06
       ,lt_uclass type        suid_tt_usr06
       ,lt_bname    type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_uclass-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if is_uclass is supplied.
    get reference of is_uclass into lr_uclass.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname
      importing
        et_uclass = lt_uclass.

    read table lt_uclass
         reference into lr_uclass
         with key bname = ms_manager-bname
         binary search.
    if sy-subrc <> 0.
      get reference of ls_uclass into lr_uclass.
    endif.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lr_uclass->* is initial.
*   No licence data is assigned - however, segment has been read
    ms_segment_uclass-bname = ms_manager-bname.  " Mark segment as read
    clear ms_segment_uclass-status.
  else.                             " Everything ok: Now fill segment!
    ms_segment_uclass-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      ms_segment_uclass-status = go_persistence->co_seg_changed.
      ms_segment_uclass-before_image = lr_uclass->*.
      clear ms_segment_uclass-actual.
    elseif ms_manager-modus = go_persistence->co_ta_modus_display
      or   ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      clear ms_segment_uclass-status.
      ms_segment_uclass-before_image = lr_uclass->*.
      ms_segment_uclass-actual       = ms_segment_uclass-before_image.
    endif.
  endif.
endmethod.


METHOD fetch_segment_usr04.
*
* Fill profile usr04 segment
*   - From DB
*

  DATA: lr_usr04        TYPE REF TO usr04
       ,lt_usr04        TYPE        suid_tt_usr04
       ,lt_bname        TYPE        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  IF ms_manager-bname IS INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  ENDIF.

* Segment must not be filled
  IF ms_segment_profiles_r04-bname IS NOT INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  ENDIF.

* --- Decide: Take importing parameter or information from DB? --------*
  IF it_usr04 IS SUPPLIED.
    lt_usr04 = it_usr04.
  ELSE.
*   No data available for this segment yet --> read from DB
    CLEAR lt_bname.
    APPEND ms_manager-bname TO lt_bname.

    go_persistence->if_suid_persistence_read~read(
      EXPORTING
        it_bname      = lt_bname
      IMPORTING
        et_prof_usr04 = lt_usr04 ).

  ENDIF.

  READ TABLE lt_usr04
        REFERENCE INTO lr_usr04
        WITH KEY bname = ms_manager-bname
        BINARY SEARCH.

* --- Now take data and move it to the segment ------------------------*
  IF lt_usr04 IS INITIAL.
*   No profile is assigned - however, segment has been read
    ms_segment_profiles_r04-bname = ms_manager-bname.  " Mark segment as read
    CLEAR ms_segment_profiles_r04-status.
  ELSE. " Everything ok: Now really fill segment!
    ms_segment_profiles_r04-bname  = ms_manager-bname.  " Mark segment as read
    CLEAR ms_segment_profiles_r04-status.

*   Take transaction mode into account
    IF ms_manager-modus = go_persistence->co_ta_modus_create OR
       ms_manager-modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
*     set segment to changed: create + delete are also recorded in USR04
      ms_segment_profiles_r04-status        = go_persistence->co_seg_changed.
      ms_segment_profiles_r04-before_image  = lr_usr04->*.
      CLEAR ms_segment_profiles_r04-actual.

    ELSEIF ms_manager-modus = go_persistence->co_ta_modus_display OR
           ms_manager-modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      CLEAR ms_segment_profiles_r04-status.
      ms_segment_profiles_r04-before_image = lr_usr04->*.
      ms_segment_profiles_r04-actual       = ms_segment_profiles_r04-before_image.
    ENDIF.

  ENDIF.
ENDMETHOD.


method FETCH_SEGMENT_USRSTAMP.
*
* Fill usrstamp segment
*   - From DB if IS_USRSTAMP is empty
*   - From importing parameter IS_USRSTAMP if this is supplied
*

  data:
        lt_usrstamp type        suid_tt_usrstamp
       ,lt_bname    type        suid_tt_bname
       .

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  if ms_manager-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* Segment must not be filled
  if ms_segment_userstamp-bname is not initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

* --- Decide: Take importing parameter or information from DB? --------*
  if it_usrstamp is supplied.
    lt_usrstamp = it_usrstamp.
  else.
*   No data available for this segment yet --> read from DB
    clear lt_bname.
    append ms_manager-bname to lt_bname.
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname
      importing
        et_usrstamp = lt_usrstamp.
  endif.

* --- Now take data and move it to the segment ------------------------*
  if lt_usrstamp is initial.
    ms_segment_userstamp-bname  = ms_manager-bname.
    if ms_manager-modus = go_persistence->co_ta_modus_create OR
       ms_manager-modus = go_persistence->co_ta_modus_delete OR
       ms_manager-modus = go_persistence->co_ta_modus_modify OR
       ms_manager-modus = go_persistence->co_ta_modus_display.
        clear ms_segment_userstamp-status.
    endif.
  else.                         " Everything ok: Now fill segment!
    ms_segment_userstamp-bname  = ms_manager-bname.
*   Take transaction mode into account
    if     ms_manager-modus = go_persistence->co_ta_modus_create
      or   ms_manager-modus = go_persistence->co_ta_modus_delete
      or   ms_manager-modus = go_persistence->co_ta_modus_modify
      or   ms_manager-modus = go_persistence->co_ta_modus_display.
*     Move data to before image only: actual image will be changed
*       in save - step depending on changed segments of user
      ms_segment_userstamp-before_image = lt_usrstamp.
      clear ms_segment_userstamp-actual.
    endif.
  endif.
endmethod.


METHOD fetch_usr04.
*
* Fill profile usr04 segment
*   - From DB
*

  DATA: lr_prof_usr04  TYPE REF TO usr04
       ,lt_prof_usr04  TYPE        suid_tt_usr04
       ,lt_bname       TYPE        suid_tt_bname
       .

  CLEAR es_segment_usr04.

* --- Consistency checks ----------------------------------------------*
* Manager structure must be filled
  IF iv_bname IS INITIAL.
    RAISE EXCEPTION TYPE cx_suid_identity
      EXPORTING
        textid    = cx_suid_identity=>internal_error
        bname     = iv_bname
        ta_modus  = iv_modus
        ta_status = iv_status.
  ENDIF.

* No data available for this segment yet --> read from DB
  CLEAR lt_bname.
  APPEND iv_bname TO lt_bname.
  CALL METHOD go_persistence->if_suid_persistence_read~read
    EXPORTING
      it_bname      = lt_bname
    IMPORTING
      et_prof_usr04 = lt_prof_usr04.

  READ TABLE lt_prof_usr04
        REFERENCE INTO lr_prof_usr04
        WITH KEY bname = iv_bname
        BINARY SEARCH.

* --- Now take data and move it to the segment ------------------------*
  IF lt_prof_usr04 IS INITIAL.
*   No profile is assigned - however, segment has been read
    es_segment_usr04-bname = iv_bname.  " Mark segment as read
    CLEAR es_segment_usr04-status.
  ELSE. " Everything ok: Now really fill segment!
    es_segment_usr04-bname  = iv_bname.
*   Take transaction mode into account
    IF     iv_modus = go_persistence->co_ta_modus_create
      OR   iv_modus = go_persistence->co_ta_modus_delete.
*     Move data to before image only
      es_segment_usr04-status = go_persistence->co_seg_changed.
      es_segment_usr04-before_image = lr_prof_usr04->*.
      CLEAR es_segment_usr04-actual.
    ELSEIF iv_modus = go_persistence->co_ta_modus_display
      OR   iv_modus = go_persistence->co_ta_modus_modify.
*     Move data to both before and actual image
      CLEAR es_segment_usr04-status.
      es_segment_usr04-before_image = lr_prof_usr04->*.
      es_segment_usr04-actual       = es_segment_usr04-before_image.
    ENDIF.
  ENDIF.
ENDMETHOD.


method finalize.

  data: lr_control           type ref to ty_control
      , lv_rejected          type        sesf_boolean
      , lv_finalize_bp       type        sesf_boolean
      , lv_bp_rejected       type        boole_d
      , lt_bup_msg           type        cmd_t_msg_complete
      , lr_bup_msg           type ref to cmd_s_msg_complete
      , ls_msg               type        symsg
      , lv_lifetime          type        if_suid_msg_buffer=>ty_msg_lifetime
      .

* Default: Check ok
  ev_rejected   = if_identity=>co_false.
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Check: Instances must be checked ------------------------
*
  call method cl_identity=>do_check
    importing
      ev_rejected = ev_rejected.

  if ev_rejected eq if_identity=>co_true.
    return.
  endif.

* --- 1. Finalize of BP and BP-Rel ----------------------------
*
  loop at gt_control reference into lr_control
       where idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    if lr_control->idref->ms_segment_address-actadd-trx_with_bp   eq co_trx_user and
     ( lr_control->idref->ms_segment_address-actadd-changed_bp    eq if_identity=>co_true or
       lr_control->idref->ms_segment_address-actadd-changed_bprel eq if_identity=>co_true ).
      lv_finalize_bp = if_identity=>co_true.
    endif.
  endloop.

* BP-Finalize must be the 1. call, in order to obtain the PersNo
  if lv_finalize_bp eq if_identity=>co_true.

    clear: lt_bup_msg.
    call method cl_bup_transaction_api=>check_before_finalize
      importing
        ev_rejected = lv_bp_rejected
        et_message  = lt_bup_msg.

    if lv_bp_rejected eq space.
      clear: lt_bup_msg.
      call method cl_bup_transaction_api=>finalize
        importing
          ev_rejected = lv_bp_rejected
          et_message  = lt_bup_msg.
    endif.

    if lv_bp_rejected eq 'X'.
      ev_rejected = if_identity=>co_true.

      loop at lt_bup_msg reference into lr_bup_msg.
        clear: ls_msg.

        ls_msg-msgty = lr_bup_msg->msgty.
        ls_msg-msgid = lr_bup_msg->msgid.
        ls_msg-msgno = lr_bup_msg->msgno.
        ls_msg-msgv1 = lr_bup_msg->msgv1.
        ls_msg-msgv2 = lr_bup_msg->msgv2.
        ls_msg-msgv3 = lr_bup_msg->msgv3.
        ls_msg-msgv4 = lr_bup_msg->msgv4.

        if lr_bup_msg->lifetime eq 0.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
        else.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ''
            is_msg      = ls_msg
            iv_nodename = if_identity_definition=>gc_node_root
            iv_lifetime = lv_lifetime.
      endloop.

      return.
    endif.
  endif.


* --- 2. Finalize of Identity ---------------------------------
*
  loop at gt_control reference into lr_control
       where ( idref->ms_manager-status eq go_persistence->co_ta_status_unchanged   or
               idref->ms_manager-status eq go_persistence->co_ta_status_checked     or
               idref->ms_manager-status eq go_persistence->co_ta_status_unchecked ) and
               idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    if lr_control->idref->ms_manager-status eq go_persistence->co_ta_status_unchanged.
      lr_control->idref->ms_manager-status = go_persistence->co_ta_status_finalized.
    else.
      call method lr_control->idref->finalize_single
        importing
          ev_rejected = lv_rejected.

*   If one instance failed: whole check failed
      if lv_rejected eq if_identity=>co_true.
        ev_rejected = if_identity=>co_true.
      endif.
    endif.

  endloop.

*----- 3. Finalize Timestamp

  finalize_set_timestamps( ).

endmethod.


method finalize_set_timestamps.
*--------------------------------------------------------------------*
*
* Set timestamps
*
*--------------------------------------------------------------------*


  data: lr_control                   type ref to ty_control
      , ls_timestamp                 type        ty_timestamp
      , ls_timestamp_new             type        ty_timestamp
      , lv_changed_segment_counter   type        i value 0
      , lt_bname                     type        suid_tt_bname
      , lt_control_timestamp         type        tt_control
      , lv_timezone                  type        ttzz-tzone "empty = 'UTC'
      .


* 1. Get Timestamp
  ls_timestamp-uname = sy-uname ##user_ok.
* Content Separation (SCOS_CODE)
  ls_timestamp-datum = sy-datum.
  ls_timestamp-uzeit = sy-uzeit.

*  get time stamp field ls_timestamp-timestamp.
  convert date ls_timestamp-datum time ls_timestamp-uzeit into time stamp ls_timestamp-timestamp time zone lv_timezone.

* 2. Prepare the instances: Fill internal segments with timestamp
  cl_identity=>prepare_segments_postfetch( ).

* 3. Check if this timestamp is ok (to avoid duplications)
  "3.1 Get changed users

  loop at gt_control reference into lr_control
       where idref->ms_manager-status eq go_persistence->co_ta_status_finalized and
             idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    clear lv_changed_segment_counter.

*   Identity is created, modified or deleted:
    if lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_create or
       lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_modify or
       lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete.

      case go_persistence->co_seg_changed.
        when lr_control->idref->ms_segment_header-status      or
             lr_control->idref->ms_segment_header_hist-status or
             lr_control->idref->ms_segment_refuser-status     or
             lr_control->idref->ms_segment_roles-status       or
             lr_control->idref->ms_segment_defaults-status    or
             lr_control->idref->ms_segment_address-status     or
             lr_control->idref->ms_segment_snc-status         or
             lr_control->idref->ms_segment_profiles_t04-status or
             lr_control->idref->ms_segment_profiles_r04-status or
             lr_control->idref->ms_segment_profiles_r04_hist-status or
             lr_control->idref->ms_segment_parameter-status    or
             lr_control->idref->ms_segment_groups-status       or
             lr_control->idref->ms_segment_certmap-status      or
             lr_control->idref->ms_segment_uclass-status       or
             lr_control->idref->ms_segment_cua_uclasses-status or
             lr_control->idref->ms_segment_pwdhistory-status   or
             lr_control->idref->ms_segment_cua_roles-status    or
             lr_control->idref->ms_segment_cua_profiles-status or
             lr_control->idref->ms_segment_cua_systems-status  or
             lr_control->idref->ms_segment_cua_user_prot-status or
             lr_control->idref->ms_segment_cua_password-status.

          lv_changed_segment_counter = 1.
      endcase.

*     BAS
      if lr_control->idref->ms_segment_address-actadd-changed_bas_workplace_node_id is not initial.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
*     BP
      if lr_control->idref->ms_segment_address-actadd-trx_with_bp   eq co_trx_user and
       ( lr_control->idref->ms_segment_address-actadd-changed_bp    eq if_identity=>co_true or
         lr_control->idref->ms_segment_address-actadd-changed_bprel eq if_identity=>co_true ).
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.

      if gv_upg_is_shadow_system eq if_identity=>co_false.
*       Check if personalization was changed
        if lr_control->idref->ms_manager-flg_pers_modified = go_persistence->co_flag_active.
          lv_changed_segment_counter = lv_changed_segment_counter + 1.
        endif.

*       Check if SAP Easy Access Menu is involved
*         If user is copied with SAP Easy Access Menu
        if lr_control->idref->ms_manager-easy_access_copied is not initial.
          lv_changed_segment_counter = lv_changed_segment_counter + 1.
        endif.
      endif.

      if lv_changed_segment_counter is not initial.
*       list of changed users for timestamp calculation
        append lr_control->bname to lt_bname.
        append lr_control->* to lt_control_timestamp.
      endif.
    endif.
  endloop.

  "3.2 Check timestamp and get new if needed
  if lt_bname is not initial.
    call method go_persistence->if_suid_persistence_modify~get_timestamp
      exporting
        it_bname         = lt_bname
        is_timestamp     = ls_timestamp
      importing
        es_timestamp_new = ls_timestamp_new.
    if ls_timestamp_new <> ls_timestamp.
      ls_timestamp = ls_timestamp_new.
    endif.
  endif.

* 4. Update internal segments with new timestamp

  loop at lt_control_timestamp reference into lr_control
        where idref->ms_manager-status eq go_persistence->co_ta_status_finalized and
              idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

*   Identity is created, modified or deleted:
    if lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_create or
       lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_modify or
       lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete.

*     Prepare the instances: Fill internal segments with timestamps etc.
      call method lr_control->idref->prepare_internal_segments
        exporting
          is_timestamp = ls_timestamp.

*     only if at least one segment was changed: audit log entry and USER STAMP are updated
      call method lr_control->idref->prepare_audit_segment
        exporting
          is_timestamp = ls_timestamp.

* if gs_timestamp_finalize is not initial means that finalize is executed second time
* we need to replace old gs_timestamp_finalize
      if gs_timestamp_finalize is not initial.
        call method lr_control->idref->set_internal_timestamp
          exporting
            is_timestamp_new = ls_timestamp
            is_timestamp_old = gs_timestamp_finalize.
      endif.

    else.
      raise exception type cx_suid_identity
        exporting
          textid    = cx_suid_identity=>internal_error
          bname     = lr_control->bname
          ta_modus  = lr_control->idref->ms_manager-modus
          ta_status = lr_control->idref->ms_manager-status.
    endif.
  endloop.

  gs_timestamp_finalize = ls_timestamp.

endmethod.


method finalize_single.

* This method MUST only be called from FINALIZE
*

  data: lo_addr_main             type ref to cl_addr_main
      , ls_person_reference	     type        addrs_person_reference
      , lv_org_nodeid	           type        addr_node_id
      , lt_bupa_data             type        bup_t_cent_data_api
      , lr_bupa_data             type ref to bup_s_cent_data_api
      , lt_partner               type        bup_t_cent_key_api
      , ls_partner               type        bup_s_cent_key_api
      , lt_office_deleted_users  type        bcst_adrchg
      , ls_office_deleted_users  type        bcss_adrchg
      .


* Default: Reject Finalize
  ev_rejected = if_identity=>co_true.


* ---- Consistency check -------------------------------------------------------
*
* MANAGER-STATUS: Only CHECKED allowed at this point!
  if ms_manager-status ne go_persistence->co_ta_status_checked.
    macro_raise_internal_error.
  endif.

* MANAGER-MODUS: Only CREATE/DELETE/MODIFY allowed
  if ms_manager-modus eq go_persistence->co_ta_modus_display.
    macro_raise_internal_error.
  endif.


* --- Finalize BAS -------------------------------------------
*
  if ms_segment_address-status eq go_persistence->co_seg_changed and
     ms_manager-modus          ne go_persistence->co_ta_modus_delete.

    if ms_segment_address-actual-idadtype           eq if_identity=>co_idad_olduser and
       ms_segment_address-actual-persnumber         is initial         and
       ms_segment_address-actadd-bas_wp_node_id     is not initial.

*     Get address instance
      lo_addr_main = cl_addr_main=>get_instance( ).

*     Get Organization node id
      call method adbp_get_id
        exporting
          io_addr_main      = lo_addr_main
          iv_address_type   = cl_addr_main=>c_organization_address
          iv_address_number = ms_segment_address-actual-addrnumber
        importing
          ev_addr_nodeid    = lv_org_nodeid.

*     Get person number and set USER Reference ONCE AGAIN !
      ls_person_reference-appl_table              = co_appl_table.
      ls_person_reference-appl_field              = co_appl_field.
      concatenate sy-mandt ms_manager-bname into ls_person_reference-appl_key.
      ls_person_reference-pers_addr               = space.
      ls_person_reference-organization_address_id = lv_org_nodeid.
      ls_person_reference-pers_group              = co_persgroup.
      ls_person_reference-owner                   = 'X'.

      call method lo_addr_main->get_person_number
        exporting
          iv_address_id       = ms_segment_address-actadd-bas_wp_node_id
          is_person_reference = ls_person_reference
        receiving
          rv_person_number    = ms_segment_address-actual-persnumber.


* --- Finalize Business Partner ------------------------------
*
    elseif ( ms_segment_address-actual-idadtype  eq if_identity=>co_idad_person          or
             ms_segment_address-actual-idadtype  eq if_identity=>co_idad_person_org_rela or
             ms_segment_address-actual-idadtype  eq if_identity=>co_idad_employee ).

*     Get BAS Person
      if ms_segment_address-actual-bpperson    is not initial    and
         ms_segment_address-actual-persnumber  is initial.

        clear: ls_partner, lt_partner, lt_bupa_data.

*       Evaluate Person UUID
        ls_partner-partner_uuid = ms_segment_address-actual-bpperson.
        append ls_partner to lt_partner.

        call method cl_bup_cent_api=>read
          exporting
            it_partner = lt_partner
          importing
            et_data    = lt_bupa_data.

        read table lt_bupa_data reference into lr_bupa_data
             with key partner_uuid = ls_partner-partner_uuid.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.

        move lr_bupa_data->persnumber     to ms_segment_address-actual-persnumber.
      endif.

*     Get Org AddrNo
      if ( ms_segment_address-actual-idadtype    eq if_identity=>co_idad_person_org_rela or
           ms_segment_address-actual-idadtype    eq if_identity=>co_idad_employee )      and
           ms_segment_address-actual-addrnumber  is initial                              and
           ms_segment_address-actadd-org_node_id is not initial.

        data: lt_address_id         type        addrt_address_id
            , lt_id_to_key          type        addrt_id_to_key
            , lr_id_to_key          type ref to addrs_id_to_key
            .

        lo_addr_main = cl_addr_main=>get_instance( ).

        append ms_segment_address-actadd-org_node_id to lt_address_id.

        call method lo_addr_main->convert_id_to_key
          exporting
            it_address_id = lt_address_id
          importing
            et_id_to_key  = lt_id_to_key.

        read table lt_id_to_key reference into lr_id_to_key
             index 1.
        if sy-subrc ne 0.
          macro_raise_internal_error.
        endif.
        move lr_id_to_key->address_number to ms_segment_address-actual-addrnumber.
        if ms_segment_address-actual-addrnumber is initial.
          macro_raise_internal_error.
        endif.
      endif.

    endif.
  endif.


* --- Finalize SAP OFFICE in case of deleting user -----------
*
  if ms_segment_address-status eq go_persistence->co_seg_changed and
    ( ms_manager-modus          eq go_persistence->co_ta_modus_delete or
      ms_manager-modus          eq go_persistence->co_ta_modus_modify and
      ms_segment_address-before_image-idadtype = if_identity=>co_idad_olduser and
      ms_segment_address-before_image-idadtype <> ms_segment_address-actual-idadtype ).

    if ms_segment_address-before_image-persnumber is not initial and
       ms_segment_address-before_image-addrnumber is not initial.

      clear: ls_office_deleted_users, lt_office_deleted_users.

      ls_office_deleted_users-username = ms_manager-bname.
      append ls_office_deleted_users to lt_office_deleted_users.

      call method cl_so_office_user_address=>finalize
        changing
          ct_deleted_users = lt_office_deleted_users.

    endif.

  endif.


* New status: Instance is checked
  ms_manager-status = go_persistence->co_ta_status_finalized.
  ev_rejected       = if_identity=>co_false.

endmethod.


method get_certmap.
*
* Internal Method without Authority-Check
*
  data: lr_certmaps     type ref to suid_tt_usrcertmap
      , lr_certmap      type ref to usrcertmap
      , ls_node_certmap type        suid_st_node_certmap
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_certmap.


* --- Fill buffer ------------------------------------------
*
* Check certmap buffer
  if ms_segment_certmap-bname is initial.
    call method fetch_segment_certmap.
  endif.


* Export actual or before image requested?
  if iv_request_before_image is initial.
    get reference of ms_segment_certmap-actual into lr_certmaps.
  else.
    get reference of ms_segment_certmap-before_image into lr_certmaps.
  endif.


* --- Read values --------------------------------
  loop at lr_certmaps->* reference into lr_certmap.
    clear: ls_node_certmap.
    move-corresponding lr_certmap->* to ls_node_certmap.

    append ls_node_certmap to et_certmap.
  endloop.


endmethod.


method get_class.


  if iv_for_auth eq if_identity=>co_false.
    " Buffer for header information is always filled during instantiation
    move ms_segment_header-actual-class to ev_class.

  else.
    if ms_manager-modus eq go_persistence->co_ta_modus_modify.
      " Use last saved class
      move ms_segment_header-before_image-class to ev_class.
    elseif ms_manager-modus eq go_persistence->co_ta_modus_create.
      " Create
      if ms_manager-class_checked eq if_identity=>co_true.
        move ms_segment_header-actual-class to ev_class.
      else.
        " Current class is not checked -> Dummy auth checks
        clear: ev_class.
      endif.
    else.
      " Display, Delete: Use current class
      move ms_segment_header-actual-class to ev_class.
    endif.
  endif.


endmethod.


method get_communication_data.
*
* Internal Method without Authority-Check
*

  data: ls_addr_comm_read  type    addrs_communication_data_read
      , ls_bup_comm_read   type    bup_s_commdata_read_api
      , ls_msg             type    symsg
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_telephone,
         et_facsimile,
         et_email,
         et_web,
         et_telex,
         et_teletex,
         et_rml,
         et_x400,
         et_printer,
         et_ssf,
         et_pager.


* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    if ms_segment_address-before_image-idadtype eq if_identity=>co_idad_olduser.
      if iv_retrieve_commdata_all eq if_identity=>co_true.
        clear: ls_addr_comm_read with 'X'.
      else.
        move-corresponding is_retrieve_commdata to ls_addr_comm_read."#EC ENHOK
      endif.
      if ls_addr_comm_read is initial.
        return.
      endif.

      call method addr_read_communication_data
        exporting
          iv_request_before_image = iv_request_before_image
        importing
          et_telephone            = et_telephone
          et_facsimile            = et_facsimile
          et_email                = et_email
          et_web                  = et_web
          et_telex                = et_telex
          et_teletex              = et_teletex
          et_rml                  = et_rml
          et_x400                 = et_x400
          et_printer              = et_printer
          et_ssf                  = et_ssf
          et_pager                = et_pager
        changing
          cs_comm_read            = ls_addr_comm_read.

    elseif ms_segment_address-before_image-idadtype eq if_identity=>co_idad_person_org_rela.

      if iv_retrieve_commdata_all eq if_identity=>co_true.
        clear: ls_bup_comm_read with 'X'.
      else.
        move-corresponding is_retrieve_commdata to ls_bup_comm_read.
      endif.
      if ls_bup_comm_read is initial.
        return.
      endif.

      call method bp_get_communication_data
        exporting
          is_commdata_read        = ls_bup_comm_read
          iv_request_before_image = iv_request_before_image
        importing
          et_telephone            = et_telephone
          et_facsimile            = et_facsimile
          et_email                = et_email
          et_web                  = et_web
          et_telex                = et_telex
          et_teletex              = et_teletex
          et_rml                  = et_rml
          et_x400                 = et_x400
          et_printer              = et_printer
          et_ssf                  = et_ssf
          et_pager                = et_pager.

    endif.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      clear: ls_msg.

      if ms_segment_address-actual-addrnumber is initial.
*       Check: Company assignment
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
*       MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_true.

      else.
*       Read address
        if iv_retrieve_commdata_all eq if_identity=>co_true.
          clear: ls_addr_comm_read with 'X'.
        else.
          move-corresponding is_retrieve_commdata to ls_addr_comm_read."#EC ENHOK
        endif.
        if ls_addr_comm_read is initial.
          return.
        endif.

        try.
            addr_read_communication_data(
              importing
                et_telephone = et_telephone
                et_facsimile = et_facsimile
                et_email     = et_email
                et_web       = et_web
                et_telex     = et_telex
                et_teletex   = et_teletex
                et_rml       = et_rml
                et_x400      = et_x400
                et_printer   = et_printer
                et_ssf       = et_ssf
                et_pager     = et_pager
              changing
                cs_comm_read = ls_addr_comm_read ).

            call method adbp_set_property_for_node
              exporting
                iv_nodename = if_identity_definition=>gc_node_organization
                iv_enable   = if_identity=>co_true.

          catch cx_suid_identity.
            ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
*           MSG: Schiefstand bei Adresse.
            if 1 = 0. message e022(01). endif.

            call method adbp_set_property_for_node
              exporting
                iv_nodename = if_identity_definition=>gc_node_organization
                iv_enable   = if_identity=>co_false.
        endtry.
      endif.

*     Errorhandling
      if ls_msg is not initial.
        clear: et_telephone
              ,et_facsimile
              ,et_email
              ,et_web
              ,et_telex
              ,et_teletex
              ,et_rml
              ,et_x400
              ,et_printer
              ,et_ssf
              ,et_pager
              .

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_workplace
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_false.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_false.
        return.

      else.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_true.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_true.
      endif.



*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '013'.
*     MSG: Es ist keine Organisation zugeordnet.
      if 1 = 0. message e013(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_person_org_rela.

*     What should be read ?
      if iv_retrieve_commdata_all eq if_identity=>co_true.
        clear: ls_bup_comm_read with 'X'.
      else.
        move-corresponding is_retrieve_commdata to ls_bup_comm_read.
      endif.

      if ls_bup_comm_read is initial.
        return.
      endif.

      bp_get_communication_data(
        exporting
          is_commdata_read = ls_bup_comm_read
        importing
          et_telephone     = et_telephone
          et_facsimile     = et_facsimile
          et_email         = et_email
          et_web           = et_web
          et_telex         = et_telex
          et_teletex       = et_teletex
          et_rml           = et_rml
          et_x400          = et_x400
          et_printer       = et_printer
          et_ssf           = et_ssf
          et_pager         = et_pager ).


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.

*     What should be read ?
      if iv_retrieve_commdata_all eq if_identity=>co_true.
        clear: ls_bup_comm_read with 'X'.
      else.
        move-corresponding is_retrieve_commdata to ls_bup_comm_read.
      endif.

      if ls_bup_comm_read is initial.
        return.
      endif.

      bp_get_empl_addressdata(
        exporting
          is_commdata_read = ls_bup_comm_read
        importing
          et_telephone     = et_telephone
          et_facsimile     = et_facsimile
          et_email         = et_email
          et_web           = et_web
          et_telex         = et_telex
          et_teletex       = et_teletex
          et_rml           = et_rml
          et_x400          = et_x400
          et_printer       = et_printer
          et_ssf           = et_ssf
          et_pager         = et_pager ).


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
*     MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

endmethod.


method get_cua_mode.

  data: lr_control type ref to ty_control
      .


  clear: ev_cua_mode.

  if gv_cua_active <> if_identity=>co_true.
    return.
  endif.

* Read corresponding entry from gt_control
  read table gt_control reference into lr_control
     with key bname = iv_bname
     binary search.
  if sy-subrc = 0.
    ev_cua_mode = lr_control->idref->mv_cua_mode.
  endif.


endmethod.


method get_cua_profiles.

  data: ls_node_profile               type        suid_st_node_cua_profile
      , lr_profile                    type ref to usl04
      , lr_profile_segment            type ref to suid_tt_usl04
      .

  eo_msg_buffer = me->go_msg_buffer.

  " Check buffer
  if ms_segment_cua_profiles-bname is initial.
    call method me->fetch_segment_cua_profiles.
  endif.

  if iv_request_before_image is initial.
    get reference of ms_segment_cua_profiles-actual into lr_profile_segment.
  else.
    get reference of ms_segment_cua_profiles-before_image into lr_profile_segment.
  endif.

  clear et_profiles.
  " --- Read values --------------------------------
  if lr_profile_segment->* is not initial.
    loop at lr_profile_segment->* reference into lr_profile.
      ls_node_profile-subsystem       = lr_profile->subsystem.
      ls_node_profile-profile         = lr_profile->profile.
      ls_node_profile-change_mode     = if_identity=>co_unchanged.

      insert ls_node_profile into table et_profiles.
    endloop.

    " fill exporting table with texts
    if iv_get_prof_details = 'X'.
      call method cl_suid_role_helper=>get_cua_profile_texts
        changing
          ct_cua_profile = et_profiles.

      " fill exporting table with type information
      call method cl_suid_role_helper=>get_cua_profile_type
        changing
          ct_cua_profile = et_profiles.
    endif.

  endif.

  sort et_profiles by subsystem profile.

endmethod.


method get_cua_roles.

  data: lr_role                 type ref to usla04
      , ls_node_role            type        suid_st_node_cua_role
      , ls_node_role_detail     type        suid_st_node_cua_role_detail
      , ls_node_role_adjust     type        suid_st_node_cua_role_adjust
      , lr_roles_segment        type ref to suid_tt_usla04
      .

  " initialize Exporting parameter
  eo_msg_buffer = go_msg_buffer.

  " clear output table
  clear et_roles.
  if iv_get_role_details eq if_identity~co_true.
    clear et_role_details.
  endif.
  if iv_get_role_members eq if_identity~co_true.
    clear et_role_members.
  endif.

  " Check buffer
  if ms_segment_cua_roles-bname is initial.
    call method fetch_segment_cua_roles.
  endif.

  if iv_request_before_image is initial.
    get reference of ms_segment_cua_roles-actual into lr_roles_segment.
  else.
    get reference of ms_segment_cua_roles-before_image into lr_roles_segment.
  endif.

  " --- Read values --------------------------------
  if lr_roles_segment->* is not initial.
    loop at lr_roles_segment->* reference into lr_role.
      clear ls_node_role.
      ls_node_role-subsystem       = lr_role->subsystem.
      ls_node_role-agr_name        = lr_role->agr_name.
      ls_node_role-from_dat        = lr_role->from_dat.
      ls_node_role-to_dat          = lr_role->to_dat.
      ls_node_role-change_mode     = if_identity=>co_unchanged.
      " get org and col flag
      ls_node_role-agr_assign_type = lr_role->org_flag.

      insert ls_node_role into table et_roles.

      " fill exporting table et_role_detail
      if iv_get_role_details eq if_identity~co_true.
        clear ls_node_role_detail.
        ls_node_role_detail-subsystem = ls_node_role-subsystem.
        ls_node_role_detail-agr_name  = ls_node_role-agr_name.
        insert ls_node_role_detail into table et_role_details.
      endif.

      " fill exporting table et_role_adjustment
      if iv_get_role_adjustments    eq if_identity~co_true  or
         iv_get_profile_sync_status eq if_identity~co_true.
        clear ls_node_role_adjust.
        ls_node_role_adjust-subsystem           = ls_node_role-subsystem.
        ls_node_role_adjust-agr_name            = ls_node_role-agr_name.
        ls_node_role_adjust-from_dat            = ls_node_role-from_dat.
        ls_node_role_adjust-to_dat              = ls_node_role-to_dat.
        ls_node_role_adjust-adjustment_required = if_identity=>co_unknown_master_record.
        insert ls_node_role_adjust into table et_role_adjustments.
      endif.

    endloop.
  endif.

  " fetch additional role information: text and parent_child
  if iv_get_role_details eq if_identity~co_true.

    delete adjacent duplicates from et_role_details.

    " --- Read text of roles --------------------------------
    call method roles_cua_add_text
      changing
        ct_node_cua_role_detail = et_role_details.
  endif.

  if iv_get_role_members eq if_identity~co_true.

    " --- provide additional info of parent role in node of role ----
    call method roles_cua_add_parent_info
      exporting
        it_roles      = et_roles
      importing
        et_node_roles = et_role_members.

  endif.

* fetch additional profile adjustment infos if available
  if iv_get_role_adjustments eq if_identity~co_true or
    iv_get_profile_sync_status eq if_identity~co_true.

    " --- add information if profiles have to be updated --------
    call method me->profile_cua_add_adjust_info
      importing
        ev_adjustment_required = ev_adjustment_required
      changing
        ct_node_roles          = et_role_adjustments.

  endif.

  sort et_roles.

endmethod.


method get_cua_systems.
*
* Internal Method without Authority-Check
*

  data: lv_logsys              type          t000-logsys
      , lr_seg_cua_systems     type ref to   uszbvsys
      , lr_node_cua_systems    type ref to   suid_st_node_cua_system
      , lt_cua_child_systems   type          suid_tt_uszbvlndrc
      , lr_system_segment      type ref to   suid_tt_uszbvsys
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.

  " Get logical name of actual system and active child systems
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys     = lv_logsys
      et_cua_child_systems = lt_cua_child_systems.

  " --- Fill buffer ------------------------------------------
  "
  " Check system buffer
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.

  if iv_request_before_image is initial.
    get reference of ms_segment_cua_systems-actual into lr_system_segment.
  else.
    get reference of ms_segment_cua_systems-before_image into lr_system_segment.
  endif.

  " --- Read values --------------------------------
  loop at lr_system_segment->* reference into lr_seg_cua_systems.
    if lr_seg_cua_systems->usrsection <> if_suid_cua_runtime=>gc_user_usrsection.
      continue.
    endif.

    " Check that system is a part of active CUA
    if lr_seg_cua_systems->subsystem ne lv_logsys.
      " If not central system (lv_logsys) -> check among child systems
      read table lt_cua_child_systems
        with key rcvsystem = lr_seg_cua_systems->subsystem
        transporting no fields
        binary search.
      " Ignore the system if it is not a part of active CUA
      if sy-subrc <> 0.
        continue.
      endif.
    endif.

    " Check that system assignment is not deleted and not local
    if lr_seg_cua_systems->status <> if_suid_cua_runtime=>gc_deleted         and
       lr_seg_cua_systems->status <> if_suid_cua_runtime=>gc_to_be_deleted   and
       lr_seg_cua_systems->status <> if_suid_cua_runtime=>gc_deleted_runtime and
       lr_seg_cua_systems->status <> if_suid_cua_runtime=>gc_failed_delete   and
       lr_seg_cua_systems->status <> if_suid_cua_runtime=>gc_local_user.

      read table et_cua_systems
        with key subsystem  = lr_seg_cua_systems->subsystem
        transporting no fields
        binary search.
      if sy-subrc <> 0.
        insert initial line into et_cua_systems reference into lr_node_cua_systems
               index sy-tabix.
        lr_node_cua_systems->subsystem = lr_seg_cua_systems->subsystem.
        " Read system text (temporary) from tbdlst if requested
        if iv_get_text eq if_identity=>co_true.
          select single stext from tbdlst
                              into lr_node_cua_systems->systemtext
                              where langu  = sy-langu
                                and logsys = lr_node_cua_systems->subsystem.
        endif.
      endif.
    endif.

  endloop.


endmethod.


method get_cua_uclasses.
*
* Internal Method without Authority-Check
*

  data: lv_logsys              type          t000-logsys
      , lt_cua_systems         type          suid_tt_node_cua_systems
      , lt_cua_law_systems     type          suid_tt_node_cua_systems
      , lr_system              type ref to   suid_st_node_cua_system
      , lr_cua_uclass          type ref to   suid_st_node_cua_uclass
      , lr_usr06sys            type ref to   usr06sys
      , lt_node_fields         type          suid_tt_fields
      , lr_node_field          type ref to   suid_node_field
      , lr_segment_field       type ref to   suid_node_field
      .


  " Initializing
  refresh: et_cua_uclasses, et_user_law_subsystems.


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.


  " --- Check CUA landscape ----------------------------------
  "
  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.


  " --- Fill buffer ------------------------------------------
  "
  " Fetch local License data
  if ms_segment_uclass-bname is initial.
    call method fetch_segment_uclass.
  endif.

  " Fetch License data assignments in child systems
  if ms_segment_cua_uclasses-bname is initial.
    call method fetch_segment_cua_uclasses.
  endif.


  " --- Read values --------------------------------
  if ms_segment_cua_uclasses-actual is not initial or
     ms_segment_uclass-actual       is not initial.
    " Get list of fields belonging to the node
    call method cl_suid_tools=>get_node_fields
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_uclass
      importing
        et_node_fields = lt_node_fields.

    create data lr_segment_field.
  endif.


  " Get active CUA system assignments
  call method me->get_cua_systems
    importing
      et_cua_systems = lt_cua_systems.

  " Get child systems which support CUA for License data
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_law_support_subsystems
    importing
      et_cua_law_subsystems = lt_cua_law_systems.


  " --- Fill return table --------------------------
  " License data in child systems
  if ms_segment_cua_uclasses-actual is not initial.
    loop at ms_segment_cua_uclasses-actual reference into lr_usr06sys.
      " Entry for central system is not allowed in USR06SYS
      if lr_usr06sys->rcvsystem = lv_logsys.
        continue.
      endif.

      " Check that system supports CUA for License data
      read table lt_cua_law_systems
           with key subsystem = lr_usr06sys->rcvsystem
           transporting no fields
           binary search.
      if sy-subrc <> 0.
        continue.
      endif.

      " Check that system is assigned to a user
      read table lt_cua_systems
           with key subsystem = lr_usr06sys->rcvsystem
           transporting no fields
           binary search.
      if sy-subrc <> 0.
        continue.
      endif.

      read table et_cua_uclasses
           with key subsystem = lr_usr06sys->rcvsystem
           transporting no fields
           binary search.
      if sy-subrc <> 0.
        insert initial line into et_cua_uclasses index sy-tabix reference into lr_cua_uclass.

        " Fill node fields from segment MS_SEGMENT_CUA_UCLASS
        loop at lt_node_fields reference into lr_node_field.
          call method cl_suid_tools=>map_uclass_nodes_to_segment
            exporting
              iv_node_name     = if_identity_definition=>gc_node_cua_uclass
              iv_node_field    = lr_node_field->*
            importing
              ev_segment_field = lr_segment_field->*.

          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field         = lr_node_field->*
              is_get_structure = lr_usr06sys->*
              iv_get_field     = lr_segment_field->*
            changing
              cs_structure     = lr_cua_uclass->*.
        endloop.
      endif.
    endloop.
  endif.


  " License data in central system
  if ms_segment_uclass-actual-lic_type is not initial.
    " Check that central system is assigned to a user
    read table lt_cua_systems
         with key subsystem = lv_logsys
         transporting no fields
         binary search.
    if sy-subrc = 0.
      " No duplicated entris are allowed
      read table et_cua_uclasses
           with key subsystem = lv_logsys
           transporting no fields
           binary search.
      if sy-subrc <> 0.
        insert initial line into et_cua_uclasses index sy-tabix reference into lr_cua_uclass.

        " Fill node fields
        loop at lt_node_fields reference into lr_node_field.
          if lr_node_field->* eq if_identity_definition=>gc_field_cua_system_subsystem.
            " Set system field
            lr_cua_uclass->subsystem = lv_logsys.
          else.
            " Fill node fields from segment MS_SEGMENT_UCLASS
            call method cl_suid_tools=>map_uclass_nodes_to_segment
              exporting
                iv_node_name     = if_identity_definition=>gc_node_cua_uclass
                iv_node_field    = lr_node_field->*
              importing
                ev_segment_field = lr_segment_field->*.

            call method cl_suid_tools=>set_structure_field_value
              exporting
                iv_field         = lr_node_field->*
                is_get_structure = ms_segment_uclass-actual
                iv_get_field     = lr_segment_field->*
              changing
                cs_structure     = lr_cua_uclass->*.
          endif.
        endloop.

      endif.
    endif.
  endif.


  " Fill list of assigned systems, which support CUA for License data
  loop at lt_cua_systems reference into lr_system.
    " Check that child system supports CUA for License data
    if lr_system->subsystem <> lv_logsys.
      read table lt_cua_law_systems
           with key subsystem = lr_system->subsystem
           transporting no fields
           binary search.
      if sy-subrc <> 0.
        continue.
      endif.
    endif.

    read table et_user_law_subsystems
         with key subsystem = lr_system->subsystem
         transporting no fields
         binary search.
    if sy-subrc <> 0.
      " Add entry for system
      insert lr_system->* into et_user_law_subsystems index sy-tabix.
    endif.
  endloop.


endmethod.


method get_current_initial_pwd.
* Read initial password for the current transaction
* A initial password must be set before
* Can only be used in create or change mode

  data: ls_msg                      type        symsg
      , lr_initial_password         type ref to suid_st_initial_password
      , ls_cua_initial_password     type        suid_st_initial_password
      , lr_cua_initial_password     type ref to suid_st_initial_password
      , lv_tabix                    type        sy-tabix
      , lr_cua_password             type ref to suid_st_node_cua_password
      , lt_cua_systems              type        suid_tt_node_cua_systems
      , lr_system                   type ref to ussystem
      , lv_central_logsys	          type        uszbvlndsc-sendsystem
      .

  clear: es_initial_password
       , et_cua_initial_passwords
       .

  eo_msg_buffer = go_msg_buffer.

  " Set values only in CREATE or CHANGE mode
  " This method can only be used in create or change mode !
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.


  " Read initial passwords, only in change/create mode
  if ms_manager-modus eq go_persistence->co_ta_modus_create or
     ms_manager-modus eq go_persistence->co_ta_modus_modify.

    " Read initial password for current system and for new CUA systems
    if ms_manager-sn_password is not initial.
      if ms_segment_header-actual-pwdinitial ne if_identity=>co_pwdinitial_initial or
         ms_segment_header-actual-codvn      eq if_identity=>co_password_inactive.
        clear: ms_segment_header-initial_password.
      else.
        if ms_segment_header-initial_password is not initial.
          if gv_cua_central eq if_identity=>co_false.
            " Password is set for current system
            call function 'OWN_LOGICAL_SYSTEM_GET'
              importing
                own_logical_system = es_initial_password-subsystem
              exceptions
                others             = 0.

            es_initial_password-password = ms_segment_header-initial_password.
          else.
            " Is central system assigned?
            me->get_cua_systems( importing et_cua_systems = lt_cua_systems ).

            call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
              importing
                ev_central_logsys = lv_central_logsys.

            read table lt_cua_systems
                 with key subsystem  = lv_central_logsys
                 transporting no fields.
            if sy-subrc eq 0.
              ls_cua_initial_password-subsystem = lv_central_logsys.
              ls_cua_initial_password-password  = ms_segment_header-initial_password.
              append ls_cua_initial_password to et_cua_initial_passwords.
            endif.

            " Password is valid for new systems (without central system)
            loop at ms_segment_cua_systems-systems_add reference into lr_system
              where subsystem ne lv_central_logsys.
              ls_cua_initial_password-subsystem = lr_system->subsystem.
              ls_cua_initial_password-password  = ms_segment_header-initial_password.
              append ls_cua_initial_password to et_cua_initial_passwords.
            endloop.
          endif.
        endif.
      endif.
    endif.

    " Read initial password for CUA target systems
    if gv_cua_central eq if_identity=>co_true.
      if ms_manager-sn_cua_password is not initial.

        " Read assigned systems
        me->get_cua_systems( importing et_cua_systems = lt_cua_systems ).

        " Get CUA passwords
        loop at ms_segment_cua_password-initial_password
             reference into lr_initial_password.

          lv_tabix = sy-tabix.

          " System must be assigned
          read table lt_cua_systems
               with key subsystem  = lr_initial_password->subsystem
               transporting no fields.
          if sy-subrc eq 0.
            " Password must be a initial password
            read table ms_segment_cua_password-actual
                 reference into lr_cua_password
                 with key subsystem = lr_initial_password->subsystem.
            if sy-subrc eq 0.
              if lr_cua_password->password-pwdinitial eq if_identity=>co_pwdinitial_initial.
                read table et_cua_initial_passwords
                     reference into lr_cua_initial_password
                     with key subsystem = lr_initial_password->subsystem
                     binary search.
                if sy-subrc eq 0.
                  " Overwrite with new password
                  lr_cua_initial_password->password = lr_initial_password->password.
                else.
                  insert lr_initial_password->* into et_cua_initial_passwords index sy-tabix.
                endif.
                continue.
              endif.
            endif.
          endif.

          " Delete current entry
          delete ms_segment_cua_password-initial_password index lv_tabix.
        endloop.
      endif.
    endif.
  endif.

endmethod.


method get_dbms_user.

  data: ls_msg          type symsg
      , lv_dbms_disable type sesf_boolean
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_dbms_user.

  data(lo_property_handler) = cl_suid_property_handler=>get_instance( ).


* --- Fill buffer ------------------------------------------
*
* Check buffer
  if ms_segment_dbms_user-bname is initial.
    call method fetch_segment_dbms_user.
  endif.

  " Check if DBMS User is active in client
  if cl_dbms_customizing=>if_dbms_um_active( ) <> abap_true.

    lv_dbms_disable = abap_true. "Disable all data fields
    clear ls_msg.

    if 1 = 0. message i014(susr_dbms). endif. "DBMS Users are not supported in the system

    ls_msg-msgty = 'W'. ls_msg-msgid = 'SUSR_DBMS'. ls_msg-msgno = '014'.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_segment_dbms_user-bname
        iv_nodename = if_identity_definition=>gc_node_dbms_user
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

  elseif ms_segment_dbms_user-actual-dbms_user is not initial.

    if ms_segment_dbms_user-dbms_user_data_actual-user_name is initial. " Not read yet
      cl_suid_dbms=>dbms_user_data_read(
        exporting
          iv_dbms_user      =  ms_segment_dbms_user-actual-dbms_user
        importing
          es_dbms_user_data = ms_segment_dbms_user-dbms_user_data_actual
          et_suid_messages  = data(lt_dbms_messages)
      ).

      if ms_segment_dbms_user-dbms_user_data_actual is initial. "DB Read was unsuccessful
        loop at lt_dbms_messages assigning field-symbol(<ls_suid_msg>).
          move-corresponding <ls_suid_msg> to ls_msg.
          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = ms_segment_dbms_user-bname
              iv_nodename = if_identity_definition=>gc_node_dbms_user
              is_msg      = ls_msg
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endloop.
        " Disable all data fields
        lv_dbms_disable = abap_true.
      endif.
    endif.
  endif.

  " Set properties
  if "ms_segment_dbms_user-actual-dbms_user is initial or
      lv_dbms_disable = abap_true.

    call method cl_suid_tools=>get_node_fields
      exporting
        iv_node_name   = if_identity_definition=>gc_node_dbms_user
      importing
        et_node_fields = data(lt_node_fields).
    "disable all fields exept dbms_user. it should be possible to see and remove mapping if it exist in DB
    delete lt_node_fields where table_line = if_identity_definition=>gc_field_dbms_user_dbms_user.
    loop at lt_node_fields assigning field-symbol(<ls_node_field>).
      lo_property_handler->set_field_enabled(
          iv_value      = if_identity=>co_false
          io_identity   = me
          iv_node_name  = if_identity_definition=>gc_node_dbms_user
          iv_field_name = <ls_node_field> ).
    endloop.

    lo_property_handler->set_node_enabled(
      exporting
        iv_value         = space
        io_identity      = me
        iv_node_name     = if_identity_definition=>gc_node_dbms_role
    ).

  elseif ms_segment_dbms_user-actual-dbms_user is not initial.
    lo_property_handler->set_field_enabled(
        iv_value      = if_identity=>co_true
        io_identity   = me
        iv_node_name  = if_identity_definition=>gc_node_dbms_user
        iv_field_name = if_identity_definition=>gc_field_dbms_user_deactivated ).
    lo_property_handler->set_field_enabled(
        iv_value      = if_identity=>co_true
        io_identity   = me
        iv_node_name  = if_identity_definition=>gc_node_dbms_user
        iv_field_name = if_identity_definition=>gc_field_dbms_user_password ).
    lo_property_handler->set_field_enabled(
        iv_value      = if_identity=>co_true
        io_identity   = me
        iv_node_name  = if_identity_definition=>gc_node_dbms_user
        iv_field_name = if_identity_definition=>gc_field_dbms_user_password2 ).

  endif.

*  " Do not allow to switch user with property handler
*  " From other side we need somehow to remove incorrect mapping
*  if me->ms_manager-modus = go_persistence->co_ta_modus_modify and
*     ms_segment_dbms_user-before_image-dbms_user is not initial.
*    lo_property_handler->set_field_read_only(
*        iv_value      = if_identity=>co_true
*        io_identity   = me
*        iv_node_name  = if_identity_definition=>gc_node_dbms_user
*        iv_field_name = if_identity_definition=>gc_field_dbms_user_dbms_user ).
*  endif.

* --- Read values --------------------------------
  if iv_request_before_image is initial.
    move-corresponding ms_segment_dbms_user-actual                to es_dbms_user.
    move-corresponding ms_segment_dbms_user-dbms_user_data_actual to es_dbms_user.

    if ms_segment_dbms_user-dbms_user_data_actual-user_id is not initial.
      es_dbms_user-dbms_user_exist = abap_true.
    elseif ms_segment_dbms_user-dbms_user_data_actual-user_name is not initial.
      es_dbms_user-dbms_user_exist = abap_false.
    else.
      es_dbms_user-dbms_user_exist = abap_undefined.
    endif.
  else.
    move-corresponding ms_segment_dbms_user-before_image          to es_dbms_user.
    move-corresponding ms_segment_dbms_user-dbms_user_data_before to es_dbms_user.

    if ms_segment_dbms_user-dbms_user_data_before-user_id is not initial.
      es_dbms_user-dbms_user_exist = 'X'.
    elseif ms_segment_dbms_user-dbms_user_data_before-user_name is not initial.
      es_dbms_user-dbms_user_exist = abap_false.
    else.
      es_dbms_user-dbms_user_exist = abap_undefined.
    endif.

  endif.
  clear: es_dbms_user-password, es_dbms_user-password2.

endmethod.


method get_defaults.
*--------------------------------------------------------------------*
*
* Internal Method without Authority-Check
*
*--------------------------------------------------------------------*
* Note 1177467     D050920   09.06.2008
* GET_DEFAULTS returned different TIMEFM
* in BEFORE_IMAGE and ACTUAL-modes.
*--------------------------------------------------------------------*

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_defaults, ev_kostl.


* --- Fill buffer ------------------------------------------
*
* Check default and address buffer
  if ms_segment_defaults-bname is initial.
    call method fetch_segment_defaults.
  endif.

  if ms_segment_address-bname is initial.
    call method fetch_segment_address.
  endif.


* --- Read values --------------------------------
  if iv_request_before_image is initial.
    move-corresponding ms_segment_defaults-actual           to es_defaults.
    move               ms_segment_header-actual-tzone       to es_defaults-tzone.
    move               ms_segment_address-actual-start_menu to es_defaults-start_menu.
    move               ms_segment_address-actual-kostl      to ev_kostl.
  else.
    move-corresponding ms_segment_defaults-before_image     to es_defaults.
    move               ms_segment_header-before_image-tzone to es_defaults-tzone.
    move         ms_segment_address-before_image-start_menu to es_defaults-start_menu.
    move         ms_segment_address-before_image-kostl      to ev_kostl.
  endif.

*     Data inconsistency: User was created without table entry for USR01
*     Set values for: - Date format (Profile parameter)
*                     - Time format (Profile parameter)
*                     - Number format (Profile parameter)
*                     - Print parameter 2 SPDA ('K')
*                     - Print parameter 3 SPDB ('H')
* We do the same in  fetch_segment_defaults for ACTUAL_IMAGE.
* This block is relevant for BEFORE_IMAGE.
* ACTUAL and BEFORE_IMAGE should return the same results in display mode!
  if es_defaults-timefm is initial.
    call function 'SUSR_USER_DEFAULT_TIME_FORMAT'
     importing
       timefm = es_defaults-timefm.
  endif.
  if es_defaults-datfm is initial.
    call function 'SUSR_USER_DEFAULT_DATE_FORMAT'
      importing
        datfm = es_defaults-datfm.
  endif.
  if es_defaults-spda is initial.
    es_defaults-spda = 'K'.     " Keep
  endif.
  if es_defaults-spdb is initial.
    es_defaults-spdb = 'H'.     " Hold
  endif.

endmethod.


method get_groups.
*
* Internal Method without Authority-Check
*

  data: lr_seg_groups     type ref to   usgrp_user
      , ls_node_groups    type          suid_st_node_group
      .

  field-symbols: <lt_groups> type any table
                .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_groups.


* --- Fill buffer ------------------------------------------
*
* Check group buffer
  if ms_segment_groups-bname is initial.
    call method fetch_segment_groups.
  endif.

* Export actual or before image requested?
  if iv_request_before_image is initial.
    assign ms_segment_groups-actual to <lt_groups>.
  else.
    assign ms_segment_groups-before_image to <lt_groups>.
  endif.

* --- Read values --------------------------------
  loop at <lt_groups> reference into lr_seg_groups.
    clear: ls_node_groups.
    move-corresponding lr_seg_groups->* to ls_node_groups.

*   Read Group text (temporary)
    if iv_get_text eq if_identity=>co_true.
      select single text
               from usgrpt
               into ls_node_groups-grouptext
              where sprsl     = sy-langu
                and usergroup = ls_node_groups-usergroup.
    endif.

    append ls_node_groups to et_groups.
  endloop.


endmethod.


method get_lockstatus.
  data: lv_lockstatus type x
      , lo_property_handler   type ref to cl_suid_property_handler
      , lv_disable_global_unlock type flag
      , ls_field_filter type suid_st_cua_filters
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: ev_locked_by_admin
        ,ev_locked_by_global_admin
        ,ev_locked_by_failed_logon
        .

  if iv_request_before_image is initial.
    lv_lockstatus = ms_segment_header-actual-uflag.
  else.
    lv_lockstatus = ms_segment_header-before_image-uflag.
  endif.
  if lv_lockstatus o if_identity=>co_locked_by_admin.
    ev_locked_by_admin = go_persistence->co_flag_active.
  endif.
  if lv_lockstatus o if_identity=>co_locked_by_global_admin.
    ev_locked_by_global_admin = go_persistence->co_flag_active.
  endif.
  if lv_lockstatus o if_identity=>co_locked_by_wrong_logon.
    ev_locked_by_failed_logon = go_persistence->co_flag_active.
  endif.

  lv_disable_global_unlock = if_identity=>co_true.
  ls_field_filter-node_name  = if_identity_definition=>gc_node_lockdata.
  ls_field_filter-node_field = if_identity_definition=>gc_field_lockdata_local_rem.
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_field_filter.
  if ls_field_filter-field_attr = if_suid_cua_runtime=>gc_everywhere .
    lv_disable_global_unlock = if_identity=>co_false.
  endif.

  clear ls_field_filter-field_attr.
  ls_field_filter-node_field = if_identity_definition=>gc_field_lockdata_wrong_rem.
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_field_filter.
  if ls_field_filter-field_attr = if_suid_cua_runtime=>gc_global  or
     ls_field_filter-field_attr = if_suid_cua_runtime=>gc_everywhere.
    lv_disable_global_unlock = if_identity=>co_false.
  endif.

*---- Disable some Lock actions for Property Handler
  if ev_locked_by_admin        <> go_persistence->co_flag_active and
     ev_locked_by_global_admin <> go_persistence->co_flag_active and
     ev_locked_by_failed_logon <> go_persistence->co_flag_active .

    "Disabling Local Unlock only!
    "Global Unlock should be possible to solve local locks and wrong logon lock in client systems.
    lo_property_handler = cl_suid_property_handler=>get_instance( ).
    lo_property_handler->set_action_enabled(
        iv_value      = if_identity=>co_false
        io_identity   = me
        iv_node_name  = if_identity_definition=>gc_node_lockdata
        iv_action     = if_identity_definition=>gc_action_local_unlock ).


    if lv_disable_global_unlock = if_identity=>co_true.
      lo_property_handler = cl_suid_property_handler=>get_instance( ).
      lo_property_handler->set_action_enabled(
          iv_value      = if_identity=>co_false
          io_identity   = me
          iv_node_name  = if_identity_definition=>gc_node_lockdata
          iv_action     = if_identity_definition=>gc_action_global_unlock ).
    endif.

  else.

    if ev_locked_by_global_admin = go_persistence->co_flag_active.
      "... CUA Global Admin Lock ......................................
      lo_property_handler = cl_suid_property_handler=>get_instance( ).
      lo_property_handler->set_action_enabled(
          iv_value      = if_identity=>co_false
          io_identity   = me
          iv_node_name  = if_identity_definition=>gc_node_lockdata
          iv_action     = if_identity_definition=>gc_action_global_lock ).
    else.
      "... CUA Global Admin Unlock ......................................
      if lv_disable_global_unlock = if_identity=>co_true.
        lo_property_handler = cl_suid_property_handler=>get_instance( ).
        lo_property_handler->set_action_enabled(
            iv_value      = if_identity=>co_false
            io_identity   = me
            iv_node_name  = if_identity_definition=>gc_node_lockdata
            iv_action     = if_identity_definition=>gc_action_global_unlock ).
      endif.
    endif.

    if ev_locked_by_admin = go_persistence->co_flag_active.
      "... Local Admin Lock ...........................................
      lo_property_handler = cl_suid_property_handler=>get_instance( ).
      lo_property_handler->set_action_enabled(
          iv_value      = if_identity=>co_false
          io_identity   = me
          iv_node_name  = if_identity_definition=>gc_node_lockdata
          iv_action     = if_identity_definition=>gc_action_local_lock ).
    else.
      if ev_locked_by_failed_logon <> go_persistence->co_flag_active.
        "... Wrong Logon Lock .........................................
        "Local Unlock should be disabled only if NEITHER Local Lock NOR Wrong Logon is set!
        lo_property_handler = cl_suid_property_handler=>get_instance( ).
        lo_property_handler->set_action_enabled(
            iv_value      = if_identity=>co_false
            io_identity   = me
            iv_node_name  = if_identity_definition=>gc_node_lockdata
            iv_action     = if_identity_definition=>gc_action_local_unlock ).
      endif.
    endif.

  endif.

endmethod.


method get_logondata.
*
* Internal Method without Authority-Check
*

* Return reference to message buffer
  eo_msg_buffer = go_msg_buffer.

* Buffer for header information is always filled during instantiation

* Check buffer for address information: Needed for field KOSTL
  if ms_segment_address-bname is initial.
    call method fetch_segment_address.
  endif.

* Check buffer for reference user information: Needed for field USERALIAS
  if ms_segment_refuser-bname is initial.
    call method fetch_segment_refuser.
  endif.

* valid from/to date, user type, user group, account ID
  if iv_request_before_image is initial.
    move-corresponding ms_segment_header-actual to es_logondata.
    es_logondata-kostl     = ms_segment_address-actual-kostl.
    es_logondata-useralias = ms_segment_refuser-actual-useralias.
  else.
    move-corresponding ms_segment_header-before_image to es_logondata.
    es_logondata-kostl     = ms_segment_address-before_image-kostl.
    es_logondata-useralias = ms_segment_refuser-before_image-useralias.
  endif.

* Get text for usergroup CLASS:
  if iv_get_grp_text is not initial.
    select single text from usgrpt into es_logondata-classtxt
      where sprsl     = sy-langu
      and   usergroup = es_logondata-class
      .
  endif.

endmethod.


method get_organization.
*--------------------------------------------------------------------**
* Internal Method without Authority-Check
*
*--------------------------------------------------------------------*
* Note 1177467     D050920   09.06.2008
* Get_Organization returned different results for IDADTYPE = 03 and 00
* in BEFORE_IMAGE and ACTUAL-modes
*--------------------------------------------------------------------*

  data: ls_msg               type   symsg
      , lt_eewamapkey        type bup_t_addrkey_mapping
      , ls_eewamapkey        type bup_s_addrkey_mapping
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_organization, es_location, es_organization_name.


* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    case ms_segment_address-before_image-idadtype.

      when if_identity=>co_idad_olduser.

        if ms_segment_address-before_image-addrnumber is not initial.
          es_organization-orgtype = if_identity=>co_company.
          es_organization-orgaddr = ms_segment_address-before_image-addrnumber.
          call method cl_suid_organization=>check_user_company
            exporting
              iv_orgaddr = ms_segment_address-before_image-addrnumber
            importing
              ev_company = es_organization-company.

*         Read Org address
          if es_organization-company is not initial.
            if iv_get_location          = if_identity=>co_true or
               iv_get_organization_name = if_identity=>co_true.
              try.
                  call method adbp_read_org_address
                    exporting
                      iv_orgnum            = ms_segment_address-actual-addrnumber
                    changing
                      es_location          = es_location
                      es_organization_name = es_organization_name.
                catch cx_suid_identity.
                  clear: ls_msg.
                  ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '429'.
*                 MSG: Es liegt ein Datenschiefstand bei den Firmenadressen vor.
                  if 1 = 0. message e429(01). endif.
              endtry.
            endif.
          endif.
        endif.

      when if_identity=>co_idad_person_org_rela.

        es_organization-orgtype        = if_identity=>co_bp_org.
        es_organization-org_uuid       = ms_segment_address-before_image-organization.
        es_organization-orgaddr        = ms_segment_address-before_image-addrnumber.

        call method cl_suid_organization=>map_org_addr_id_to_uuid   " note 1177467
          exporting
            iv_org_uuid     = ms_segment_address-before_image-organization
            iv_address_no   = ms_segment_address-before_image-addrnumber
          importing
            ev_orgaddr_uuid = es_organization-orgaddr_uuid.

*       Read Org address
        if ms_segment_address-actual-addrnumber is not initial.
          if iv_get_location          = if_identity=>co_true or
             iv_get_organization_name = if_identity=>co_true.

            call method adbp_read_org_address
              exporting
                iv_orgnum            = ms_segment_address-actual-addrnumber
                iv_orgaddrid         = ms_segment_address-actadd-org_node_id
              changing
                es_location          = es_location
                es_organization_name = es_organization_name.
          endif.
        endif.

      when if_identity=>co_idad_employee.

        if ms_segment_address-before_image-bpperson   is not initial and
           ms_segment_address-before_image-addrnumber is not initial.
          clear: lt_eewamapkey, ls_eewamapkey.
          ls_eewamapkey-addrtype    = '4'.
          ls_eewamapkey-person_uuid = ms_segment_address-before_image-bpperson.
          ls_eewamapkey-addrnumber  = ms_segment_address-before_image-addrnumber.

          append ls_eewamapkey to lt_eewamapkey.
          call method cl_bup_addr_map_api=>get_corresponding_keys
            changing
              ct_addrkey = lt_eewamapkey.

          clear: ls_eewamapkey.
          read table lt_eewamapkey into ls_eewamapkey index 1.
          if sy-subrc ne 0.
            macro_raise_internal_error.
          endif.


          es_organization-orgtype      = if_identity=>co_bp_empl.
          es_organization-orgaddr      = ls_eewamapkey-addrnumber.
          es_organization-orgaddr_uuid = ls_eewamapkey-address_uuid.
        endif.
    endcase.

    return.
  endif.


* ------ Read organization assignment depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      data: lv_display_address type sesf_boolean value if_identity=>co_true
          , lv_assign_org      type sesf_boolean value if_identity=>co_true
          .

      clear: ls_msg.

      if ms_segment_address-actual-addrnumber is initial.
*       Check: Company assignment
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
*       MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        lv_display_address = if_identity=>co_false.

      else.
*       Check: USCOMPANY entry must exist
        call method cl_suid_organization=>check_user_company
          exporting
            iv_orgaddr = ms_segment_address-actual-addrnumber
          importing
            ev_company = es_organization-company.

        if es_organization-company is initial.
*         Autorepair
          data: lv_name1     type adrc-name1,
                ls_uscompany type uscompany.

          select single name1 from adrc
                 into lv_name1
                 where addrnumber = ms_segment_address-actual-addrnumber."#EC *
          if sy-subrc eq 0.
            translate lv_name1 to upper case.
            concatenate lv_name1 ms_segment_address-actual-addrnumber into ls_uscompany-company.
            ls_uscompany-addrnumber = ms_segment_address-actual-addrnumber.
            insert uscompany from ls_uscompany.
            if sy-subrc ne 0.
              clear: ls_msg.
              ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '429'.
*             MSG: Es liegt ein Datenschiefstand bei den Firmenadressen vor.
              if 1 = 0. message e429(01). endif.
            endif.
          else.
*         Autorepair
            clear: ls_msg.
            ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '429'.
*           MSG: Es liegt ein Datenschiefstand bei den Firmenadressen vor.
            if 1 = 0. message e429(01). endif.
          endif.
        endif.
      endif.

*     Read Org address
      if lv_display_address eq if_identity=>co_true.
        if iv_get_location          = if_identity=>co_true or
           iv_get_organization_name = if_identity=>co_true.
          try.
              call method adbp_read_org_address
                exporting
                  iv_orgnum            = ms_segment_address-actual-addrnumber
                changing
                  es_location          = es_location
                  es_organization_name = es_organization_name.
            catch cx_suid_identity.
              clear: ls_msg.
              ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '429'.
*             MSG: Es liegt ein Datenschiefstand bei den Firmenadressen vor.
              if 1 = 0. message e429(01). endif.

              lv_display_address = if_identity=>co_false.
              lv_assign_org      = if_identity=>co_false.
          endtry.
        endif.
      endif.

*     Fill message buffer
      if ls_msg-msgty is not initial.
        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
      endif.


*     Errorhandling
      if lv_assign_org eq if_identity=>co_true.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_true.
      else.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_false.
      endif.

      if lv_display_address eq if_identity=>co_true.
        es_organization-orgtype = if_identity=>co_company.
        es_organization-orgaddr = ms_segment_address-actual-addrnumber.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_true.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_true.

      else.
        clear: es_organization, es_location, es_organization_name.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_false.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_false.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '013'.
*     MSG: Es ist keine Organisation zugeordnet.
      if 1 = 0. message e013(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_organization
          iv_enable   = if_identity=>co_false.
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_false.

      return.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_person_org_rela.

*     User or BP trx
      if ms_segment_address-actadd-trx_with_bp is initial.
        ms_segment_address-actadd-trx_with_bp = co_trx_user.
      endif.

*      if ms_segment_address-actual-addrnumber is initial and
*        ms_segment_address-actadd-org_node_id is initial.
** No shortdump in case of empty addressnumber - just the same behaviour
** as with incorrect address number.
*
**        macro_raise_internal_error.
*      endif.

      es_organization-orgtype        = if_identity=>co_bp_org.
      es_organization-org_uuid       = ms_segment_address-actual-organization.
      es_organization-orgaddr        = ms_segment_address-actual-addrnumber.

      call method cl_suid_organization=>map_org_addr_id_to_uuid
        exporting
          iv_org_uuid     = ms_segment_address-actual-organization
          iv_address_id   = ms_segment_address-actadd-org_node_id
          iv_address_no   = ms_segment_address-actual-addrnumber
        importing
          ev_orgaddr_uuid = es_organization-orgaddr_uuid.

      if es_organization-orgaddr_uuid is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '206'.
*       MSG: Die zugeordnete Organisation existiert nicht
        if 1 = 0. message e206(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        clear: es_organization, es_location, es_organization_name.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_false.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_false.

        return.
      endif.

*     Read Org address
      if iv_get_location          = if_identity=>co_true or
         iv_get_organization_name = if_identity=>co_true.

        call method adbp_read_org_address
          exporting
            iv_orgnum            = ms_segment_address-actual-addrnumber
            iv_orgaddrid         = ms_segment_address-actadd-org_node_id
          changing
            es_location          = es_location
            es_organization_name = es_organization_name.
      endif.

      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_organization
          iv_enable   = if_identity=>co_true.
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_true.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.

*     User or BP trx
      if ms_segment_address-actadd-trx_with_bp is initial.
        ms_segment_address-actadd-trx_with_bp = co_trx_user.
      endif.

*      if ms_segment_address-actual-addrnumber is initial and
*        ms_segment_address-actadd-org_node_id is initial.
** No shortdump in case of empty addressnumber - just the same behaviour
** as with incorrect address number.
*
**        macro_raise_internal_error.
*      endif.

*     Map Keys
      clear: lt_eewamapkey, ls_eewamapkey.
      ls_eewamapkey-addrtype    = '4'.
      ls_eewamapkey-person_uuid = ms_segment_address-actual-bpperson.
      ls_eewamapkey-address_id  = ms_segment_address-actadd-org_node_id.
      ls_eewamapkey-addrnumber  = ms_segment_address-actual-addrnumber.

      append ls_eewamapkey to lt_eewamapkey.
      call method cl_bup_addr_map_api=>get_corresponding_keys
        changing
          ct_addrkey = lt_eewamapkey.

      clear: ls_eewamapkey.
      read table lt_eewamapkey into ls_eewamapkey index 1.
      if sy-subrc ne 0 or ls_eewamapkey-address_uuid is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '206'.
*       MSG: Die zugeordnete Organisation existiert nicht
        if 1 = 0. message e206(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        clear: es_organization, es_location, es_organization_name.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_false.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_false.

        return.
*         macro_raise_internal_error.
      endif.

      ms_segment_address-actadd-org_node_id = ls_eewamapkey-address_id.

      es_organization-orgtype     = if_identity=>co_bp_empl.
      es_organization-orgaddr     = ls_eewamapkey-addrnumber.
      es_organization-orgaddr_uuid = ls_eewamapkey-address_uuid.

*     Read Org address
      if iv_get_location          = if_identity=>co_true or
         iv_get_organization_name = if_identity=>co_true.

        call method bp_get_empl_addressdata
          exporting
            iv_location_read     = iv_get_location
            iv_orgname_read      = iv_get_organization_name
          importing
            es_location          = es_location
            es_organization_name = es_organization_name.

      endif.

*     Properties
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_organization
          iv_enable   = if_identity=>co_true.
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_organization
          iv_readonly = if_identity=>co_true.
      call method adbp_set_property_for_node
        exporting
          iv_nodename = if_identity_definition=>gc_node_workplace
          iv_enable   = if_identity=>co_true.




*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
*     MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


endmethod.


method get_parameters.
*
* Internal Method without Authority-Check
*

  data: lr_seg_param     type ref to   usr05
      , ls_node_param    type          suid_st_node_parameter
      .

  field-symbols: <lt_parameters> type any table.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_parameters.


* --- Fill buffer ------------------------------------------
*
* Check parameter buffer
  if ms_segment_parameter-bname is initial.
    call method fetch_segment_parameter.
  endif.

* Return actual or before image?
  if iv_request_before_image is initial.
    assign ms_segment_parameter-actual to <lt_parameters>.
  else.
    assign ms_segment_parameter-before_image to <lt_parameters>.
  endif.

* --- Read values --------------------------------
  loop at <lt_parameters> reference into lr_seg_param.
    clear: ls_node_param.
    move-corresponding lr_seg_param->* to ls_node_param.


*   Read Parameter text (temporary)
    if iv_get_text eq if_identity=>co_true.
      select single partext
               from tparat
               into ls_node_param-partxt
              where paramid  = ls_node_param-parid
                and  sprache = sy-langu.
    endif.

    append ls_node_param to et_parameters.
  endloop.


endmethod.


method get_password_hash.
*
* Internal Method without Authority-Check
*
  clear: es_node_pwdhash.

  eo_msg_buffer = go_msg_buffer.

  move-corresponding ms_segment_header-actual to es_node_pwdhash.


endmethod.


method get_personname.
*
* Internal Method without Authority-Check
*

  data: ls_msg type symsg
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_personname.


* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    if ms_segment_address-before_image-idadtype eq if_identity=>co_idad_olduser.
      call method addr_read_address
        exporting
          iv_request_before_image = iv_request_before_image
        importing
          es_personname           = es_personname.
    elseif ms_segment_address-before_image-idadtype eq if_identity=>co_idad_person          or
           ms_segment_address-before_image-idadtype eq if_identity=>co_idad_person_org_rela or
           ms_segment_address-before_image-idadtype eq if_identity=>co_idad_employee.
      call method bp_get_personname
        exporting
          iv_request_before_image = iv_request_before_image
        importing
          es_personname           = es_personname.
    endif.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      clear: ls_msg.

      if ms_segment_address-actual-addrnumber is initial.
*       Check: Company assignment
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
*       MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_true.

      else.
*       Read address
        try.
            addr_read_address( importing es_personname = es_personname ).

            call method adbp_set_property_for_node
              exporting
                iv_nodename = if_identity_definition=>gc_node_organization
                iv_enable   = if_identity=>co_true.

          catch cx_suid_identity.
            ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
*           MSG: Schiefstand bei Adresse.
            if 1 = 0. message e022(01). endif.

            call method adbp_set_property_for_node
              exporting
                iv_nodename = if_identity_definition=>gc_node_organization
                iv_enable   = if_identity=>co_false.
        endtry.
      endif.

*     Errorhandling
      if ls_msg is not initial.
        clear: es_personname.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person_name
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_false.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_false.
        return.

      else.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_true.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_true.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person          or
         if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      if ms_segment_address-actual-bpperson is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
*       MSG: Es ist kein Geschäftspartner zugeordnet.
        if 1 = 0. message e011(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person_name
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.

      bp_get_personname( importing es_personname = es_personname ).


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
*     MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person_name
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.





endmethod.


METHOD get_profiles.

  DATA: ls_node_profile               TYPE suid_st_node_profile.
  DATA: lt_usprof                     TYPE suid_tt_usprof.
  DATA: lr_usprof                     TYPE REF TO suid_st_usprof.

  eo_msg_buffer = me->go_msg_buffer.
* clear output table
  CLEAR et_profiles.

* --- Read values --------------------------------
  CALL METHOD me->profile_initialize_ust04
    EXPORTING
      iv_get_profile_text     = iv_get_prof_details
      iv_request_before_image = iv_request_before_image
    IMPORTING
      et_user_profile         = lt_usprof.

  LOOP AT lt_usprof REFERENCE INTO lr_usprof.
    MOVE-CORRESPONDING lr_usprof->* TO ls_node_profile.
    ls_node_profile-change_mode = if_identity=>co_unchanged.
    INSERT ls_node_profile INTO TABLE et_profiles.
  ENDLOOP.

  SORT et_profiles.

ENDMETHOD.


method get_reference_user.
*
* Internal Method without Authority-Check
*

* Initialize Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear es_reference_user.


* --- Fill buffer ------------------------------------------
  if ms_segment_refuser-bname is initial.
    call method fetch_segment_refuser.
  endif.


* --- Read values --------------------------------
  if iv_request_before_image is initial.
    es_reference_user-refuser = ms_segment_refuser-actual-refuser.
  else.
    es_reference_user-refuser = ms_segment_refuser-before_image-refuser.
  endif.

endmethod.


METHOD GET_ROLES.

  DATA: lr_role               TYPE REF TO agr_users.
  DATA: ls_node_role          TYPE suid_st_node_role.
  DATA: lr_roles_segment      TYPE REF TO suid_tt_agr_users.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.

* clear output table
  CLEAR: et_roles.

* Check buffer
  IF ms_segment_roles-bname IS INITIAL.
    CALL METHOD fetch_segment_roles.
  ENDIF.

  IF iv_request_before_image IS INITIAL.
    GET REFERENCE OF ms_segment_roles-actual INTO lr_roles_segment.
  ELSE.
    GET REFERENCE OF ms_segment_roles-before_image INTO lr_roles_segment.
  ENDIF.
* --- Read values --------------------------------
  IF lr_roles_segment->* IS NOT INITIAL.
    LOOP AT lr_roles_segment->* REFERENCE INTO lr_role.
      CLEAR ls_node_role.
      ls_node_role-agr_name        = lr_role->agr_name.
      ls_node_role-from_dat        = lr_role->from_dat.
      ls_node_role-to_dat          = lr_role->to_dat.
      ls_node_role-change_mode     = if_identity=>co_unchanged.
*     get org and col flag: first read col_flag then org_flag
      CASE lr_role->col_flag.
        WHEN 'X'.
          ls_node_role-agr_assign_type = 'C'.
        WHEN OTHERS.
          ls_node_role-agr_assign_type = lr_role->col_flag.
      ENDCASE.

      CASE lr_role->org_flag.
        WHEN space.
*          do nothing
        WHEN 'X'.
          ls_node_role-agr_assign_type = 'X'.
        WHEN OTHERS.
          ls_node_role-agr_assign_type = lr_role->org_flag.
      ENDCASE.

      INSERT ls_node_role INTO TABLE et_roles.

    ENDLOOP.
  ENDIF.

  SORT et_roles.

ENDMETHOD.


method get_snc.
*
* Internal Method without Authority-Check
*

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_snc.


* --- Fill buffer ------------------------------------------
*
* Check default, header and address buffer
  if ms_segment_snc-bname is initial.
    call method fetch_segment_snc.
  endif.


* --- Read values --------------------------------
  if iv_request_before_image is initial.
    move-corresponding ms_segment_snc-actual to es_snc.
  else.
    move-corresponding ms_segment_snc-before_image to es_snc.
  endif.

* Is canonical name defined?
  if ms_segment_snc-actual-knamelen > 0.
    es_snc-knamestat = if_identity=>co_true.
  else.
    es_snc-knamestat = if_identity=>co_false.
  endif.


endmethod.


method GET_TECHNICAL_USER_DATA.
*
* Internal Method without Authority-Check
*

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_tech_user_data.

  " --- Fill buffer -----------------------------------------
  "
  " --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  " --- Read values -----------------------------------------
  if iv_request_before_image is initial.
    move ms_segment_address-actual-responsible       to es_tech_user_data-responsible.
    move ms_segment_address-actual-techdesc          to es_tech_user_data-techdesc.
  else.
    move ms_segment_address-before_image-responsible to es_tech_user_data-responsible.
    move ms_segment_address-before_image-techdesc    to es_tech_user_data-techdesc.
  endif.

endmethod.


method get_uclass.

  " can be deleted in SP

endmethod.


method get_workplacedata.
*
* Internal Method without Authority-Check
*

  data: ls_msg type symsg
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_workplace.


* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    if ms_segment_address-before_image-idadtype eq if_identity=>co_idad_olduser.
      call method addr_read_address
        exporting
          iv_request_before_image = iv_request_before_image
        importing
          es_workplace            = es_workplace.
    elseif ms_segment_address-before_image-idadtype eq if_identity=>co_idad_person_org_rela.
      call method bp_get_workplacedata
        exporting
          iv_request_before_image = iv_request_before_image
        importing
          es_workplace            = es_workplace.
    endif.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      clear: ls_msg.

      if ms_segment_address-actual-addrnumber is initial.
*       Check: Company assignment
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
*       MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_organization
            iv_enable   = if_identity=>co_true.

      else.
*       Read address
        try.
            addr_read_address( importing es_workplace = es_workplace ).

            call method adbp_set_property_for_node
              exporting
                iv_nodename = if_identity_definition=>gc_node_organization
                iv_enable   = if_identity=>co_true.

          catch cx_suid_identity.
            ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
*           MSG: Schiefstand bei Adresse.
            if 1 = 0. message e022(01). endif.

            call method adbp_set_property_for_node
              exporting
                iv_nodename = if_identity_definition=>gc_node_organization
                iv_enable   = if_identity=>co_false.
        endtry.
      endif.

*     Errorhandling
      if ls_msg is not initial.
        clear: es_workplace.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_workplace
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_false.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_false.
        return.

      else.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_true.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_workplace
            iv_enable   = if_identity=>co_true.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '013'.
*     MSG: Es ist keine Organisation zugeordnet.
      if 1 = 0. message e013(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_person_org_rela.

      bp_get_workplacedata( importing es_workplace = es_workplace ).


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.

      call method bp_get_empl_addressdata
        exporting
          iv_workplace_read = if_identity=>co_true
        importing
          es_workplace      = es_workplace.


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
*     MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


endmethod.


method if_identity_address~get_communication_data.


  data: ls_msg                 type        symsg
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_telephone,
         et_facsimile,
         et_email,
         et_web,
         et_telex,
         et_teletex,
         et_rml,
         et_x400,
         et_printer,
         et_ssf,
         et_pager.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_workplace
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
*   Return to caller
    return.
  endif.

* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    call method me->get_communication_data
      exporting
        is_retrieve_commdata     = is_retrieve_commdata
        iv_retrieve_commdata_all = iv_retrieve_commdata_all
        iv_request_before_image  = iv_request_before_image
      importing
        et_telephone             = et_telephone
        et_facsimile             = et_facsimile
        et_email                 = et_email
        et_web                   = et_web
        et_telex                 = et_telex
        et_teletex               = et_teletex
        et_rml                   = et_rml
        et_x400                  = et_x400
        et_printer               = et_printer
        et_ssf                   = et_ssf
        et_pager                 = et_pager.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

*     Check organization
      if ms_segment_address-actual-addrnumber is initial.
        return.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      return.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


* Get CommData
  call method me->get_communication_data
    exporting
      is_retrieve_commdata     = is_retrieve_commdata
      iv_retrieve_commdata_all = iv_retrieve_commdata_all
    importing
      et_telephone             = et_telephone
      et_facsimile             = et_facsimile
      et_email                 = et_email
      et_web                   = et_web
      et_telex                 = et_telex
      et_teletex               = et_teletex
      et_rml                   = et_rml
      et_x400                  = et_x400
      et_printer               = et_printer
      et_ssf                   = et_ssf
      et_pager                 = et_pager.


endmethod.


method if_identity_address~get_organization.

  data: ls_msg                 type        symsg
      .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_organization, es_location, es_organization_name.

* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'G'
      iv_change_node = if_identity_definition=>gc_node_organization
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
*   Return to caller
    return.
  endif.

* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
  call method me->get_organization
    exporting
      iv_get_location          = iv_get_location
      iv_get_organization_name = iv_get_organization_name
    importing
      es_organization          = es_organization
      es_location              = es_location
      es_organization_name     = es_organization_name.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

*     Check organization
      if ms_segment_address-actual-addrnumber is initial.
        return.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      return.


*...------ Organization is already assigned -----------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.


*...------ Technical user --------------------------------------
    when if_identity=>co_idad_techuser.

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


* Get Organization
  call method me->get_organization
    exporting
      iv_get_location          = iv_get_location
      iv_get_organization_name = iv_get_organization_name
    importing
      es_organization          = es_organization
      es_location              = es_location
      es_organization_name     = es_organization_name.

endmethod.


method if_identity_address~get_personname.


  data: ls_msg                 type        symsg
      .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_personname.

* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_person_name
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
*   Return to caller
    return.
  endif.

* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    call method me->get_personname
      exporting
        iv_request_before_image = iv_request_before_image
      importing
        es_personname           = es_personname.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

*     Check organization
      if ms_segment_address-actual-addrnumber is initial.
        return.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

*     Check Person
      if ms_segment_address-actual-bpperson is initial.
        return.
      endif.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      es_personname-name_last = ms_manager-bname.
      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


* Get PersonName
  call method me->get_personname
    importing
      es_personname = es_personname.


endmethod.


method if_identity_address~get_workplacedata.


  data: ls_msg                 type        symsg
      .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_workplace.

* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_workplace
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
*   Return to caller
    return.
  endif.

* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


* --- Before Image -------------------------------------------------
  if iv_request_before_image is not initial.
    call method me->get_workplacedata
      exporting
        iv_request_before_image = iv_request_before_image
      importing
        es_workplace            = es_workplace.
    return.
  endif.


* ------ Read address depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

*     Check organization
      if ms_segment_address-actual-addrnumber is initial.
        return.
      endif.


*...------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      return.


*...------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


* Get WorkplaceData
  call method me->get_workplacedata
    importing
      es_workplace = es_workplace.


endmethod.


method if_identity_address~set_communication_data.

  data: ls_msg                 type        symsg
      , ls_organization	       type        suid_st_node_organization
      , ls_tech_user           type        suid_st_node_tech_user
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.
  clear: et_new_telephone_id,
         et_new_facsimile_id,
         et_new_email_id,
         et_new_web_id,
         et_new_telex_id,
         et_new_teletex_id,
         et_new_rml_id,
         et_new_x400_id,
         et_new_printer_id,
         et_new_ssf_id,
         et_new_pager_id.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_workplace
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  "------ Change address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      " Set default organization
      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_organization.

        call method cl_suid_organization=>get_default_user_company
          exporting
            iv_create      = if_identity=>co_true
          importing
            es_default_org = ls_organization.

        call method me->if_identity_person~set_organization
          exporting
            is_organization = ls_organization.
      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " needed for the creation of Technical user
      if ms_segment_address-actual-bpperson is initial.

        " Set technical user indicator
        ls_tech_user-tech_indicator = abap_true.
        call method me->if_identity~set_technical_user_indicator
          exporting
            is_tech_user = ls_tech_user.

      endif.

      return.

    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee        or
         if_identity=>co_idad_techuser.

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  " Set CommData
  call method me->if_identity_person~set_communication_data
    exporting
      it_telephone        = it_telephone
      it_facsimile        = it_facsimile
      it_email            = it_email
      it_web              = it_web
      it_telex            = it_telex
      it_teletex          = it_teletex
      it_rml              = it_rml
      it_x400             = it_x400
      it_printer          = it_printer
      it_ssf              = it_ssf
      it_pager            = it_pager
      is_current_state    = is_current_state
    importing
      et_new_telephone_id = et_new_telephone_id
      et_new_facsimile_id = et_new_facsimile_id
      et_new_email_id     = et_new_email_id
      et_new_web_id       = et_new_web_id
      et_new_telex_id     = et_new_telex_id
      et_new_teletex_id   = et_new_teletex_id
      et_new_rml_id       = et_new_rml_id
      et_new_x400_id      = et_new_x400_id
      et_new_printer_id   = et_new_printer_id
      et_new_ssf_id       = et_new_ssf_id
      et_new_pager_id     = et_new_pager_id.

endmethod.


method if_identity_address~set_organization.

  data: ls_msg                 type        symsg
      , ls_organization        type        suid_st_node_organization
      , ls_tech_user           type        suid_st_node_tech_user
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_organization
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  "------ Create address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old User -----------------------------------------------
    when if_identity=>co_idad_olduser.

      if ms_segment_address-actual-addrnumber is initial.
        " Set Company
        if is_organization-orgtype is initial or
           is_organization-orgtype eq if_identity=>co_company.
          call method me->if_identity_person~set_organization
            exporting
              is_organization = is_organization.
        else.
          " Set Default Company
          clear: ls_organization.
          call method me->if_identity_person~set_organization
            exporting
              is_organization = ls_organization.
        endif.

      else.
        " Switch Company
        if is_organization-orgtype is initial or
           is_organization-orgtype eq if_identity=>co_company.
          call method me->if_identity_person~switch_organization_assignment
            exporting
              is_organization = is_organization.
        endif.

      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " needed for the creation of Technical user
      if ms_segment_address-actual-bpperson is initial.

        " Set technical user indicator
        ls_tech_user-tech_indicator = abap_true.
        call method me->if_identity~set_technical_user_indicator
          exporting
            is_tech_user = ls_tech_user.

      endif.

      return.

    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee        or
         if_identity=>co_idad_techuser.

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

endmethod.


method if_identity_address~set_personname.

  data: ls_msg                 type        symsg
      , ls_organization	       type        suid_st_node_organization
      , ls_tech_user           type        suid_st_node_tech_user
      , ls_node_tech_user_data type        suid_st_node_tech_user_data
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_person_name
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  "------ Change address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      " Set default organization
      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_organization.

        call method cl_suid_organization=>get_default_user_company
          exporting
            iv_create      = if_identity=>co_true
          importing
            es_default_org = ls_organization.

        call method me->if_identity_person~set_organization
          exporting
            is_organization = ls_organization.
      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " needed for the creation of Technical user
      if ms_segment_address-actual-bpperson is initial.

        " Set technical user indicator
        ls_tech_user-tech_indicator = abap_true.
        call method me->if_identity~set_technical_user_indicator
          exporting
            is_tech_user = ls_tech_user.

        " Set description (for compatibility)
        ls_node_tech_user_data-techdesc = is_personname-name_last.
        call method me->if_identity~set_technical_user_data
          exporting
            is_tech_user_data = ls_node_tech_user_data.

      endif.

      return.

    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee        or
         if_identity=>co_idad_techuser.

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


  " Set PersonName
  call method me->if_identity_person~set_personname
    exporting
      is_personname    = is_personname
      it_change_fields = it_change_fields.

endmethod.


method if_identity_address~set_technical_user_indicator.

  data: ls_msg                 type        symsg
      , ls_organization        type        suid_st_node_organization
      , ls_person_name         type        suid_st_node_person_name
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_tech_user
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  "------ Set technical user indicating depending on Identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old User -----------------------------------------------
    when if_identity=>co_idad_olduser.

      " Delete technical user indicator: Nothing to do
      if is_tech_user-tech_indicator is initial.
        return.
      endif.

      "switch old user -> techuser only supported for S/4 on premise in create mode
      if ms_manager-modus = go_persistence->co_ta_modus_create and
         cl_identity_factory=>check_identity_model( ) = abap_true.

        " delete existing address data
        if ms_segment_address-actual-addrnumber is not initial or
           ms_segment_address-actual-persnumber is not initial.
          try.
            addr_delete_address( ).
          catch cx_suid_identity.
            ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
            " MSG: Schiefstand bei Adresse.
            if 1 = 0. message e022(01). endif.

            go_msg_buffer->add_object_message_symsg(
              exporting
                iv_bname    = ms_manager-bname
                iv_nodename = if_identity_definition=>gc_node_organization
                is_msg      = ls_msg
                iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

            return.
          endtry.
        endif.

        " Set technical user indicator
        call method me->if_identity~set_technical_user_indicator
          exporting
            is_tech_user = is_tech_user.

      else.
        " Set Default Company
        if ms_segment_address-actual-addrnumber is initial.
          clear: ls_organization.
          call method me->if_identity_person~set_organization
            exporting
              is_organization = ls_organization.
        endif.

        " Check Last Name
        call method me->if_identity_person~get_personname
          importing
            es_personname = ls_person_name.

        if ls_person_name-name_last is initial.
          ls_person_name-name_last = ms_manager-bname.
          call method me->if_identity_person~set_personname
            exporting
              is_personname = ls_person_name.
        endif.

      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " needed for the creation of Technical user
      if is_tech_user-tech_indicator is not initial and
         ms_segment_address-actual-bpperson is initial.

        " Set technical user indicator
        call method me->if_identity~set_technical_user_indicator
          exporting
            is_tech_user = is_tech_user.
      else.

        return.

      endif.

    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_techuser        or
         if_identity=>co_idad_employee.

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

endmethod.


method if_identity_address~set_workplacedata.

  data: ls_msg                 type        symsg
      , ls_organization	       type        suid_st_node_organization
      , ls_tech_user           type        suid_st_node_tech_user
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_workplace
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  "------ Change address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      " Set default organization
      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_organization.

        call method cl_suid_organization=>get_default_user_company
          exporting
            iv_create      = if_identity=>co_true
          importing
            es_default_org = ls_organization.

        call method me->if_identity_person~set_organization
          exporting
            is_organization = ls_organization.
      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " needed for the creation of Technical user
      if ms_segment_address-actual-bpperson is initial.

        " Set technical user indicator
        ls_tech_user-tech_indicator = abap_true.
        call method me->if_identity~set_technical_user_indicator
          exporting
            is_tech_user = ls_tech_user.

      endif.

      return.

    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee        or
         if_identity=>co_idad_techuser.

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  " Set WorkplaceData
  call method me->if_identity_person~set_workplacedata
    exporting
      is_workplace     = is_workplace
      it_change_fields = it_change_fields.

endmethod.


method if_identity_certmap~add_certificate.


  data: ls_certmap           type        usrcertmap
      , lv_subject_char      type        suid_st_node_certmap-subject
      , lv_issuer_char       type        suid_st_node_certmap-issuer
      , lv_key               type        suid_node_key
      , ls_msg               type        symsg
      , lv_reject_assignment type        sesf_boolean
      , lv_error             type        sesf_boolean
      .



* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_certmap
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
*   Return to caller
    return.
  endif.


* --- Fill buffer ------------------------------------------
*
* Check certmap buffer
  if ms_segment_certmap-bname is initial.
    call method fetch_segment_certmap.
  endif.

* Delete all messages for the node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_certmap
      iv_lifetimeonce_only = 'X'.

* Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_certmap.


* --- Check CertMap ----------------------------------------
*
  call method me->cert_check_certificate
    exporting
      is_certificate       = is_certificate
      iv_cert              = 'C'
    importing
      es_certmap           = ls_certmap
      es_msg               = ls_msg
      ev_reject_assignment = lv_reject_assignment.

* Map Key
  if ls_certmap-subjecth is not initial and
     ls_certmap-issuerh  is not initial.
    lv_subject_char  = ls_certmap-subjecth.
    lv_issuer_char   = ls_certmap-issuerh.
    concatenate lv_subject_char lv_issuer_char
      into lv_key respecting blanks.
  endif.

  if ls_msg is not initial.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_certmap
        iv_key      = lv_key
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
  endif.

  if lv_reject_assignment eq if_identity=>co_true.
    call method go_notify->notify_failed_create
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_certmap
        iv_key      = lv_key.

    return.
  endif.


* --- Store CertMap ----------------------------------------
*

* Notification
  call method go_notify->notify_create
    exporting
      iv_bname    = ms_segment_certmap-bname
      iv_nodename = if_identity_definition=>gc_node_certmap
      iv_key      = lv_key.

* Update segment
  ls_certmap-mandt = sy-mandt.

  read table ms_segment_certmap-actual
       with key subjecth = ls_certmap-subjecth
                issuerh  = ls_certmap-issuerh
       binary search
       transporting no fields.

  insert ls_certmap into ms_segment_certmap-actual index sy-tabix.

* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_certmap
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_certmap = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_certmap = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_certmap-actual ne ms_segment_certmap-before_image.
    ms_segment_certmap-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_certmap-status.
  endif.



endmethod.


method if_identity_certmap~add_certmap.

  data: ls_certmap           type        usrcertmap
      , lv_subject_char      type        suid_st_node_certmap-subject
      , lv_issuer_char       type        suid_st_node_certmap-issuer
      , lv_key               type        suid_node_key
      , ls_msg               type        symsg
      , lv_reject_assignment type        sesf_boolean
      , lv_error             type        sesf_boolean
      .



  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_certmap
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.


  " --- Fill buffer ------------------------------------------
  "
  " Check certmap buffer
  if ms_segment_certmap-bname is initial.
    call method fetch_segment_certmap.
  endif.

  " Delete all messages for the node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_certmap
      iv_lifetimeonce_only = 'X'.

  " Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_certmap.


  " --- Check CertMap ----------------------------------------
  "
  if is_certmap-change_mode ne if_identity=>co_insert.
    return.
  endif.

  call method me->cert_check_certificate
    exporting
      is_certmap           = is_certmap
      iv_cert              = 'M'
    importing
      es_certmap           = ls_certmap
      es_msg               = ls_msg
      ev_reject_assignment = lv_reject_assignment.

  " Map Key
  if ls_certmap-subjecth is not initial and
     ls_certmap-issuerh  is not initial.
    lv_subject_char  = ls_certmap-subjecth.
    lv_issuer_char   = ls_certmap-issuerh.
    concatenate lv_subject_char lv_issuer_char
           into lv_key respecting blanks.
  endif.

  if ls_msg is not initial.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname      = ms_manager-bname
        iv_nodename   = if_identity_definition=>gc_node_certmap
        iv_key        = lv_key
        iv_key_handle = is_certmap-key_handle
        iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
        is_msg        = ls_msg.
  endif.

  if lv_reject_assignment eq if_identity=>co_true.
    call method go_notify->notify_failed_create
      exporting
        iv_bname      = ms_manager-bname
        iv_nodename   = if_identity_definition=>gc_node_certmap
        iv_key        = lv_key
        iv_key_handle = is_certmap-key_handle.
    return.
  endif.


  " --- Store CertMap ----------------------------------------
  "
  " Notification
  call method go_notify->notify_create
    exporting
      iv_bname      = ms_segment_certmap-bname
      iv_nodename   = if_identity_definition=>gc_node_certmap
      iv_key        = lv_key
      iv_key_handle = is_certmap-key_handle.

  " Update segment
  ls_certmap-mandt = sy-mandt.

  read table ms_segment_certmap-actual
       with key subjecth = ls_certmap-subjecth
                issuerh  = ls_certmap-issuerh
       binary search
       transporting no fields.

  insert ls_certmap into ms_segment_certmap-actual index sy-tabix.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_certmap
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_certmap = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_certmap = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_certmap-actual ne ms_segment_certmap-before_image.
    ms_segment_certmap-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_certmap-status.
  endif.


endmethod.


method if_identity_certmap~delete_certmap.


  data: lr_node_certmap   type ref to suid_st_node_certmap
      , ls_certmap        type        usrcertmap
      , lt_certmap_deq    type        suid_tt_usrcertmap
      , lv_key            type        suid_node_key
      , ls_msg            type        symsg
      , lv_error          type        sesf_boolean
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_certmap
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
*   Return to caller
    return.
  endif.

* Delete all messages for the node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_certmap
      iv_lifetimeonce_only = 'X'.

* Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_certmap.


* --- Fill buffer ------------------------------------------
*
* Check certmap buffer
  if ms_segment_certmap-bname is initial.
    call method fetch_segment_certmap.
  endif.


  loop at it_certmap reference into lr_node_certmap
       where change_mode eq if_identity=>co_delete. "Only delete is allowed

*   Subject and Issuer hash must be filled
    if lr_node_certmap->subjecth is initial or
       lr_node_certmap->issuerh  is initial.
      continue.
    endif.

    ls_certmap-subjecth = lr_node_certmap->subjecth.
    ls_certmap-issuerh  = lr_node_certmap->issuerh.

*   Delete
    read table ms_segment_certmap-actual
         with key subjecth = ls_certmap-subjecth
                  issuerh  = ls_certmap-issuerh
         binary search
         transporting no fields.
    if sy-subrc eq 0.
      delete ms_segment_certmap-actual index sy-tabix.

      concatenate lr_node_certmap->subjecth lr_node_certmap->issuerh
        into lv_key respecting blanks.

      call method go_notify->notify_delete
        exporting
          iv_bname      = ms_segment_certmap-bname
          iv_nodename   = if_identity_definition=>gc_node_certmap
          iv_key        = lv_key
          iv_key_handle = lr_node_certmap->key_handle.

*     Dequeue, if certificate was added in same session
      delete table mt_certmap_enqueued from ls_certmap.
      if sy-subrc eq 0.
        append ls_certmap to lt_certmap_deq.
      endif.

    endif.
  endloop.


* Dequeue, if certificate was added in same session
  if lt_certmap_deq is not initial.
    call method cl_suid_tools=>dequeue_certmap
      exporting
        it_certmap = lt_certmap_deq.
  endif.


* --- Transaction handling ---------------------------------
*

* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_certmap
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_certmap = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_certmap = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_certmap-actual ne ms_segment_certmap-before_image.
    ms_segment_certmap-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_certmap-status.
  endif.


endmethod.


method if_identity_certmap~get_certmap.

  data: ls_msg             type        symsg
      , lt_logonnames      type        usrlogonnames_t
      , ls_logonnames      type        usrlogonnames_s
      , ls_logondata       type        suid_st_node_logondata
      , lt_usrcertrules    type        usrcertrules_t
      , lr_usrcertrules    type ref to usrcertrules_s
      , ls_cert_usrrules   type        suid_st_node_cert_usrrules
      .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_certmap, et_cert_usrrules.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method               = 'G'
      iv_change_node          = if_identity_definition=>gc_node_certmap
      iv_request_before_image = iv_request_before_image
    importing
      es_msg                  = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

  call method me->get_certmap
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      eo_msg_buffer           = eo_msg_buffer
      et_certmap              = et_certmap.


  if iv_get_cert_usrrules is not initial.

    call method me->get_logondata
      importing
        es_logondata = ls_logondata.

*   append bname
    ls_logonnames-type = 'U'.
    ls_logonnames-name = ms_manager-bname.
    append ls_logonnames to lt_logonnames.
*   append alias
    if ls_logondata-useralias is not initial.
      ls_logonnames-type = 'A'.
      ls_logonnames-name = ls_logondata-useralias.
      append ls_logonnames to lt_logonnames.
    endif.


    call function 'CERTRULE_USER_TO_RULES'
      exporting
        logonnames         = lt_logonnames
      importing
        usrcertrules       = lt_usrcertrules
      exceptions
        error_parameter    = 1
        error_ssf_lib      = 2
        error_certificate  = 3
        error_convert      = 4
        error_user_mapping = 5
        error_user         = 6
        error_no_rule      = 7
        error_internal     = 8
        others             = 9.

    if sy-subrc ne 0.
      ls_msg-msgid = sy-msgid.
      ls_msg-msgno = sy-msgno.
      ls_msg-msgv1 = sy-msgv1.
      ls_msg-msgv2 = sy-msgv2.
      ls_msg-msgv3 = sy-msgv3.
      ls_msg-msgv4 = sy-msgv4.
      ls_msg-msgty = sy-msgty.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_cert_usrrules
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
    endif.

    loop at lt_usrcertrules reference into lr_usrcertrules.
      move-corresponding lr_usrcertrules->* to ls_cert_usrrules.
      append ls_cert_usrrules to et_cert_usrrules.
    endloop.

  endif.


endmethod.


method if_identity_cua~cua_password_deactivate.
* Deactivate password for imported CUA systems

  data: lv_logsys       type t000-logsys
       ,ls_msg          type symsg
       ,lr_cua_system   type ref to suid_st_node_cua_system
       ,lv_error        type sesf_boolean
       ,ls_pwd_new      type suid_st_node_pwdhash
       ,ls_cua_password type suid_st_node_cua_password
       ,lv_number_of_systems type i
       ,lv_tabix        type sy-tabix
       ,lv_no_maintain  type sesf_boolean
       .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling --------------------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_cua_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_password.

  " Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_cua_password
      iv_lifetimeonce_only = if_identity=>co_true.

  " --- Check CUA landscape ---------------------------------------------
  "
  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.

  " CUA is not active - this node shouldn't be filled --> error message and exit
  if gv_cua_active = if_identity=>co_false.
    ls_msg-msgv1 = lv_logsys.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
    " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    if 1 = 0. message e381(01) with ls_msg-msgv1. endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Actual system is not central system - system node shouldn't be filled --> error message and exit
  if gv_cua_central = if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Check if node can be maintained
  if gv_cua_central = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_password
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

    " Node can't be maintained: do not proceed
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.


  " --- Transaction handling --------------------------------------------
  " Lazy fetch of CUA systems segment for check
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.

  " Check imported systems: Are they CUA systems of the user?
  loop at it_cua_systems reference into lr_cua_system.
    read table ms_segment_cua_systems-actual
      with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
               subsystem  = lr_cua_system->subsystem
      transporting no fields.
    if sy-subrc <> 0.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '071'.
      " MSG: Kein System der aktuellen ZBV zu dieser Selektion gefunden.
      if 1 = 0. message e071(01). endif.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_cua_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
      return.
*    else.
*      append lr_cua_system->* to lt_systems.
    endif.
  endloop.

  " Method call with empty system list without IV_PWD_CHECKS_ONLY active
  if it_cua_systems is initial.
    " Issue error message
    clear: ls_msg.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '068'.
    " You have not selected a system
    if 1 = 0. message e068(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_password
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " ---- Now perform password deactivation, first in central system  ----
  read table it_cua_systems reference into lr_cua_system
       with key subsystem   = lv_logsys.  " Central system affected?
  if sy-subrc = 0.
    call method if_identity_password~password_deactivate
      importing
        eo_msg_buffer = eo_msg_buffer
        eo_notify     = eo_notify.
    describe table it_cua_systems lines lv_number_of_systems.
    if lv_number_of_systems = 1. " Only CUA central system imported!
      " All transaction logic was done in PASSWORD_DEACTIVATE: Can leave here
      return.
    endif.
  endif.

  " --- Now move data for deactivation to all imported child systems ----

  clear ls_pwd_new.
  " Fields BCODE and PASSCODE are empty for deactivated password
  ls_pwd_new-codvn      = if_identity=>co_password_inactive.
  ls_pwd_new-pwdinitial = if_identity=>co_pwdinitial_initial.

  " All other systems but central
  loop at it_cua_systems
       reference into lr_cua_system
       where subsystem <> lv_logsys.

    if ms_segment_cua_password-bname is initial.
      ms_segment_cua_password-bname = ms_manager-bname.
    endif.

    clear: ls_cua_password.
    move lr_cua_system->subsystem       to ls_cua_password-subsystem.
    move-corresponding ls_pwd_new       to ls_cua_password-password.
    read table ms_segment_cua_password-actual
         with key subsystem   = lr_cua_system->subsystem
         transporting no fields.
    lv_tabix = sy-tabix.
    if sy-subrc <> 0.
      append ls_cua_password to ms_segment_cua_password-actual.
    else.
      modify ms_segment_cua_password-actual
             from ls_cua_password
             index lv_tabix.
    endif.
  endloop.

  if sy-subrc = 0. " LOOP body was executed at least once
    call method go_notify->notify_update  " Notification
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_password.
  endif.

  " Continue with transactional only if systems are provided
  check: it_cua_systems is not initial.

  " ---- Transaction handling -------------------------------------------
  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_password
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_cua_password = go_persistence->co_node_status_checked.
    " Mark internal CUA segment to trigger password distribution
    ms_segment_cua_act_distr-actual-password = go_persistence->co_flag_active.
  else.                     "  New node status: CHANGED
    ms_manager-sn_cua_password = go_persistence->co_node_status_changed.
  endif.

  " Set segment status to Changed
  if ms_segment_cua_password-actual is not initial.
    ms_segment_cua_password-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.

endmethod.


method if_identity_cua~get_cua_profiles.

  data: lv_is_cua_active              type sesf_boolean
      , lv_msg_data                   type symsg
      .

  eo_msg_buffer = me->go_msg_buffer.

  " check if CUA is active and if current system is defined as CUA
  roles_validate_cua_context(
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_profile
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_is_cua_active ).

  if lv_is_cua_active eq if_identity=>co_false.
    return.
  endif.

  " clear output table
  clear et_profiles.

  " Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_cua_profile
    importing
      es_msg         = lv_msg_data.

  if lv_msg_data-msgty = 'E'.
    " Return to caller if not authorized
    return.
  endif.

  " read profiles
  call method me->get_cua_profiles
    exporting
      iv_get_prof_details     = iv_get_prof_details
      iv_request_before_image = iv_request_before_image
    importing
      et_profiles             = et_profiles
      eo_msg_buffer           = eo_msg_buffer.

endmethod.


method if_identity_cua~get_cua_roles.

  data: lv_is_cua_active        type sesf_boolean
      , lv_msg_data             type symsg
      .

  " initialize Exporting parameter
  eo_msg_buffer = go_msg_buffer.

  " check if CUA is active and if current system is defined as CUA
  roles_validate_cua_context(
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_role
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_is_cua_active ).

  if lv_is_cua_active eq if_identity=>co_false.
    return.
  endif.

  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_cua_role
    importing
      es_msg         = lv_msg_data ).

  if lv_msg_data-msgty = 'E'.
    " Return to caller if not authorized
    return.
  endif.

  call method me->get_cua_roles
    exporting
      iv_get_role_details        = iv_get_role_details
      iv_get_role_members        = iv_get_role_members
      iv_get_role_adjustments    = iv_get_role_adjustments
      iv_get_profile_sync_status = iv_get_profile_sync_status
      iv_request_before_image	   = iv_request_before_image
    importing
      et_roles                   = et_roles
      et_role_details            = et_role_details
      et_role_members            = et_role_members
      et_role_adjustments        = et_role_adjustments
      ev_adjustment_required     = ev_adjustment_required
      eo_msg_buffer              = eo_msg_buffer.


endmethod.


method if_identity_cua~get_cua_systems.
*
* Returns active system assignments of a user:
*    - system should be a part of active cua
*    - active system assignment means that usersection 'USER' exists
*    - system assignment shouldn't have status 'D' - deleted or 'A' - to be deleted
*
*???? one more return table et_node_cua_scul_systems, which contains all system assignments
*     with their statuses


  data: ls_msg                 type          symsg
      , lv_valid               type          sesf_boolean
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.


  " --- Check CUA landscape ----------------------------------
  "
  me->check_cua_landscape(
    exporting
      iv_node_name  = if_identity_definition=>gc_node_cua_system
    importing
      eo_msg_buffer = eo_msg_buffer
      ev_valid      = lv_valid ).

  " Node can't be maintained: do not proceed
  if lv_valid = if_identity=>co_false.
    return.
  endif.

  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  clear: ls_msg.
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_cua_system
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    clear: et_cua_systems.
    return.
  endif.

  " --- Fill buffer ------------------------------------------
  "
  call method me->get_cua_systems
    exporting
      iv_get_text             = iv_get_text
      iv_request_before_image = iv_request_before_image
    importing
      et_cua_systems          = et_cua_systems
      eo_msg_buffer           = eo_msg_buffer.

endmethod.


method if_identity_cua~get_cua_uclasses.
* Returns CUA License data system assignments of a user in table ET_CUA_UCLASSES:
*
* License data for central system is read from local db table USR06 => from MS_SEGMENT_UCLASS
* Lisence data assignments in child systems is read from USR06SYS   => from MS_SEGMENT_CUA_UCLASSES

* Lisence data assignment should correspond following requirements:
*    - system should be assigned to user (entry for user section 'USER' should exist in USZBVSYS )
*    - system assignment shouldn't have status 'D' - deleted or 'A' - to be deleted or
*                                              'X' - deleted in runtime (obsolete status)
*    - child system should support CUA for License data - entry should present in feature db table TUTYPASYS
*
*
* Also returns list of systems, which are assigned to a user and support CUA for license data in
* table ET_USER_LAW_SUBSYSTEMS
*

* ERROR MESSAGES:
*                 -  381(01)  -  Das System &1 ist nicht Teil der Zentralen Benutzerpflege
*                 -  351(01)  -  Sie sind nicht auf dem Zentralsystem angemeldet
*                 -  267(bv)  -  Keine systemspezifische Nutzerklassifikation: Lizenzdaten nicht 'global'

  data: ls_msg                 type          symsg
      , lv_no_maintain         type          sesf_boolean
      .


  " Initializing
  refresh: et_cua_uclasses, et_user_law_subsystems.


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.


  " --- Check CUA landscape ----------------------------------
  "
  " CUA is not active - system node shouldn't be filled --> error message and exit
  if gv_cua_active = if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
    " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    if 1 = 0. message e381(01) with ls_msg-msgv1. endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    return.
  endif.

  " Actual system is not central system - system node shouldn't be filled --> error message and exit
  if gv_cua_central = if_identity=>co_false.
    clear: ls_msg.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    return.
  endif.

  call method cua_if_field_no_maintain
    exporting
      iv_node_name   = if_identity_definition=>gc_node_cua_uclass
    receiving
      rv_no_maintain = lv_no_maintain.

  " Node can't be maintained: do not proceed
  if lv_no_maintain = if_identity=>co_true.
    return.
  endif.

  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_cua_uclass
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    clear: et_cua_uclasses
          ,et_user_law_subsystems
          .
    return.
  endif.


  call method me->get_cua_uclasses
    importing
      et_cua_uclasses        = et_cua_uclasses
      et_user_law_subsystems = et_user_law_subsystems
      eo_msg_buffer          = eo_msg_buffer.


endmethod.


method if_identity_cua~set_cua_password.

  data: ls_pwd_new           type        suid_st_node_pwdhash
      , lv_logsys            type        t000-logsys
      , lr_cua_system        type ref to suid_st_node_cua_system
      , ls_cua_password      type        suid_st_node_cua_password
      , ls_msg               type        symsg
      , lv_error             type        sesf_boolean
      , lv_number_of_systems type        i
      , lv_tabix             type        sy-tabix
      , lv_no_maintain       type        sesf_boolean
      , ls_initial_password  type        suid_st_initial_password
      , lr_initial_password  type ref to suid_st_initial_password
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " --- Transaction handling --------------------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_cua_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_password.

  " Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_cua_password
      iv_lifetimeonce_only = if_identity=>co_true.

  " --- Check CUA landscape ---------------------------------------------
  "
  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.

  " CUA is not active - this node shouldn't be filled --> error message and exit
  if gv_cua_active = if_identity=>co_false.
    ls_msg-msgv1 = lv_logsys.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
    " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    if 1 = 0. message e381(01) with ls_msg-msgv1. endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Actual system is not central system - system node shouldn't be filled --> error message and exit
  if gv_cua_central = if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Check if node can be maintained
  if gv_cua_central = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_password
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

    " Node can't be maintained: do not proceed
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.


  " --- Transaction handling --------------------------------------------
  " Lazy fetch of CUA systems segment for check
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.

  " Check imported systems: Are they CUA systems of the user?
  loop at it_cua_systems reference into lr_cua_system.
    read table ms_segment_cua_systems-actual
      with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
               subsystem  = lr_cua_system->subsystem
      transporting no fields.
    if sy-subrc <> 0.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '071'.
      " MSG: Kein System der aktuellen ZBV zu dieser Selektion gefunden.
      if 1 = 0. message e071(01). endif.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_cua_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
      return.
*    else.
*      append lr_cua_system->* to lt_systems.
    endif.
  endloop.

  " ---- Now perform password conversion and fill password segments -----
  read table it_cua_systems reference into lr_cua_system
       with key subsystem   = lv_logsys.  " Central system affected?
  if sy-subrc = 0.
    " Password is changed in central system: Call local SET Method
    call method if_identity_password~set_password
      exporting
        iv_pwdplain   = iv_pwdplain
      importing
        eo_msg_buffer = eo_msg_buffer
        eo_notify     = eo_notify.
    describe table it_cua_systems lines lv_number_of_systems.
    if lv_number_of_systems = 1. " Only CUA central system imported!
      " All transaction logic was done in SET_PASSWORD: Can leave here
      return.
    endif.
  endif.

  if iv_pwdplain is not initial.
    " For all other systems: Fill CUA Password segment
    call method password_convert_to_hash
      exporting
        iv_pwdplain = iv_pwdplain
      importing
        ev_pwdhash  = ls_pwd_new.
  else.
    clear: ls_msg.
    ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
    ls_msg-msgid = '01'.
    ls_msg-msgno = '290'.
    " Please enter an initial password
    if 1 = 0. message e290(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_password
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

*  if iv_pwd_checks_only eq if_identity=>co_true.
*    return.
*  endif.

  " Method call with empty system list without IV_PWD_CHECKS_ONLY active
  if    iv_pwd_checks_only = if_identity=>co_false
    and it_cua_systems is initial.
    " Issue error message
    clear: ls_msg.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '068'.
    " You have not selected a system
    if 1 = 0. message e068(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_password
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  clear: ls_pwd_new-pwdlgndate.
  ls_pwd_new-pwdinitial = if_identity=>co_pwdinitial_initial.

  " All other systems but central
  loop at it_cua_systems reference into lr_cua_system
       where subsystem <> lv_logsys.

    if ms_segment_cua_password-bname is initial.
      ms_segment_cua_password-bname = ms_manager-bname.
    endif.

    clear: ls_cua_password.
    move lr_cua_system->subsystem       to ls_cua_password-subsystem.
    move-corresponding ls_pwd_new       to ls_cua_password-password.
    read table ms_segment_cua_password-actual
         with key subsystem   = lr_cua_system->subsystem
         transporting no fields.
    lv_tabix = sy-tabix.
    if sy-subrc <> 0.
      append ls_cua_password to ms_segment_cua_password-actual.
    else.
      modify ms_segment_cua_password-actual from ls_cua_password index lv_tabix.
    endif.

    " Remember initial password
    read table ms_segment_cua_password-initial_password
         reference into lr_initial_password
         with key subsystem = lr_cua_system->subsystem
         binary search.
    lv_tabix = sy-tabix.
    if sy-subrc eq 0.
      if ls_pwd_new-pwdinitial eq if_identity=>co_pwdinitial_initial.
        lr_initial_password->password   = iv_pwdplain.
      else.
        clear: lr_initial_password->password.
      endif.
    else.
      if ls_pwd_new-pwdinitial eq if_identity=>co_pwdinitial_initial.
        ls_initial_password-subsystem = lr_cua_system->subsystem.
        ls_initial_password-password  = iv_pwdplain.
        insert ls_initial_password into ms_segment_cua_password-initial_password index lv_tabix.
      endif.
    endif.
  endloop.

  if sy-subrc = 0. " LOOP body was executed at least once
    call method go_notify->notify_update  " Notification
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_password.
  endif.


  " Continue with transactional only if systems are provided
  check: it_cua_systems is not initial.

  " ---- Transaction handling -------------------------------------------
  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_password
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_cua_password = go_persistence->co_node_status_checked.
    " Mark internal CUA segment to trigger password distribution
    ms_segment_cua_act_distr-actual-password = go_persistence->co_flag_active.
  else.                     "  New node status: CHANGED
    ms_manager-sn_cua_password = go_persistence->co_node_status_changed.
  endif.

  " Set segment status to Changed
  if ms_segment_cua_password-actual is not initial.
    ms_segment_cua_password-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.

endmethod.


method if_identity_cua~set_cua_profiles.
*
* Uses case:
* - Manual assignments of profiles (SU01, PFCG,..)
* - CUA central system
*

  data: lv_is_cua_active          type sesf_boolean.

  " initialize exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " check if CUA is active and if current system is defined as CUA
  " check if CUA roles can be maintained.
  call method roles_validate_cua_context
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_profile
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_is_cua_active.

  if lv_is_cua_active eq if_identity=>co_false.
    " do not proceed: error message was already written; now return
    return.
  endif.

  call method me->profile_cua_set_internal
    exporting
      it_profiles          = it_profiles
      iv_permit            = if_identity=>co_false
    importing
      eo_msg_buffer        = eo_msg_buffer
      eo_notify            = eo_notify
      et_node_cua_profiles = et_node_cua_profiles.


endmethod.


method if_identity_cua~set_cua_roles.
*
* Uses case:
* - Manual assignments of roles (SU01, PFCG,..)
* - CUA central system
*

  data: lv_is_cua_active            type sesf_boolean
      .

  " initialize exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " check if CUA is active and if current system is defined as CUA
  " check if CUA roles can be maintained.
  call method roles_validate_cua_context
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_role
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_is_cua_active.

  if lv_is_cua_active eq if_identity=>co_false.
    " do not proceed: error message was already written; now return
    return.
  endif.

  call method me->roles_cua_set_internal
    exporting
      it_roles          = it_roles
      iv_permit         = if_identity=>co_false
      iv_set_extended   = if_identity=>co_false
    importing
      et_node_cua_roles = et_node_cua_roles
      eo_msg_buffer     = eo_msg_buffer
      eo_notify         = eo_notify.


endmethod.


method if_identity_cua~set_cua_systems.

* GC_NODE_CUA_SYSTEMS - GC_FIELD_CUA_SYSTEMS_SUBSYSTEM
* GC_USER_USRSECTION
*   E351(01) - Sie sind nicht auf dem Zentralsystem angemeldet.
*   E381(01) - Das System &1 ist nicht Teil der Zentralen Benutzerpflege
*   E152(01) - Keine Berechtigung Tochtersystem & zuzuordnen oder zu entfernen.
*   E793(01) - Zum System &1 existiert bereits ein Eintrag

* If central system assignment is deleted then field MS_SEGMET_HEADER-ACTUAL_ZBVMASTER
* is set to 'X', otherwise when central system is assigned then this field is cleared

* In USZBVPROT segment the changes for child systems will be done at SAVE respectevly,
* for central system entries in USZBVPROT are done for section ACTGRP and PROFILE only
* added use case: CUA active + roles/profiles are changed locally

  data: lt_check_cua_systems     type        suid_tt_node_cua_systems
      , lt_add_cua_systems       type        suid_tt_node_cua_systems
      , lr_add_cua_systems       type ref to suid_st_node_cua_system
      , lr_cua_systems           type ref to suid_st_node_cua_system
      , ls_cua_systems           type        suid_st_node_cua_system
      , lr_check_cua_systems     type ref to suid_st_node_cua_system
      , lr_segment_cua_system    type ref to uszbvsys
      , lr_before_cua_system     type ref to uszbvsys
      , lv_logsys                type        t000-logsys
      , lv_tabix                 type        sy-tabix
      , lv_add_tabix             type        sy-tabix
      , lv_del_tabix             type        sy-tabix
      , ls_msg                   type        symsg
      , lv_error                 type        sesf_boolean
      , ls_node_filter           type        suid_st_cua_filters
      , lv_role_global           type        sesf_boolean
      , lv_prof_global           type        sesf_boolean
      , lv_uclass_global         type        sesf_boolean
      , lv_delete                type        sesf_boolean
      , lr_system                type ref to ussystem
      , lv_sys_tabix             type        sy-tabix
      , lv_no_maintain           type        sesf_boolean
      , lv_class                 type        xuclass
      , lv_role_node             type        suid_node_name value if_identity_definition=>gc_node_cua_role
      , lv_profile_node          type        suid_node_name value if_identity_definition=>gc_node_cua_profile
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_cua_system
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_system.

  " Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_cua_system
      iv_lifetimeonce_only = if_identity=>co_true.


  " --- Check CUA landscape ----------------------------------
  "
  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.

  " CUA is not active - system node shouldn't be filled --> error message and exit
  if gv_cua_active = if_identity=>co_false.
    ls_msg-msgv1 = lv_logsys.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
    " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    if 1 = 0. message e381(01) with ls_msg-msgv1. endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Actual system is not central system - system node shouldn't be filled --> error message and exit
  if gv_cua_central = if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Check for local users (no CUA data can be set to local users)
  " Check if node can be maintained
  call method cua_if_field_no_maintain
    exporting
      iv_node_name   = if_identity_definition=>gc_node_cua_system
      io_msg_buffer  = go_msg_buffer
    receiving
      rv_no_maintain = lv_no_maintain.

  " Node can't be maintained: do not proceed
  if lv_no_maintain = if_identity=>co_true.
    return.
  endif.


  " --- Transaction handling ---------------------------------
  " Lazy fetch of groups segment
  if ms_segment_cua_systems-bname is initial.
    call method fetch_segment_cua_systems.
  endif.

  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.


  " --- Check entries with change_mode = space, delete -------------------
  "
  " Comment: - Check only values, which are in the importing table
  "          - Handle first change_mode = space ,delete
  "          -> Key (Subsystem) must be unique
  "          -> Duplicate entries are only allowed for change_mode = insert
  loop at it_cua_systems reference into lr_cua_systems
       where change_mode ne if_identity=>co_insert.

    if lr_cua_systems->change_mode ne space     and
       lr_cua_systems->change_mode ne if_identity=>co_delete.
      " Wrong change mode: Only space, delete (or insert) are allowed
      raise exception type cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error
          bname  = ms_manager-bname.
    endif.

    if lr_cua_systems->change_mode eq if_identity=>co_delete.
      lv_delete = if_identity=>co_true.
    endif.

    " Delete messages for systems which should be checked
    gv_macro_key = lr_cua_systems->subsystem.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
        iv_key      = gv_macro_key.

    " Check: Entry for 'USER' section must exist in actual image
    read table ms_segment_cua_systems-actual
           reference into lr_segment_cua_system
           with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                    subsystem  = lr_cua_systems->subsystem
           binary search.
    if sy-subrc ne 0.
      " Ignore system or warning
      continue.
    else.
      " Ignore or warning if system assignment is already deleted
      if lr_segment_cua_system->status eq if_suid_cua_runtime=>gc_deleted         or
         lr_segment_cua_system->status eq if_suid_cua_runtime=>gc_to_be_deleted   or
         lr_segment_cua_system->status eq if_suid_cua_runtime=>gc_deleted_runtime or
         lr_segment_cua_system->status eq if_suid_cua_runtime=>gc_failed_delete   .
        continue.
      endif.

      " Entry must be unique in check_table
      read table lt_check_cua_systems
           with key subsystem   = lr_cua_systems->subsystem
           transporting no fields
           binary search.
      if sy-subrc ne 0.
        " Insert into checktable
        insert lr_cua_systems->* into lt_check_cua_systems index sy-tabix.
      else.
        " Duplicate entries in IT_CUA_SYSTEMS -> Exception
        macro_raise_internal_error.
      endif.
    endif.
  endloop.

  " Check systems with change_mode: space, delete
  if lt_check_cua_systems is not initial.
    call method check_cua_systems_internal
      exporting
        iv_bname       = ms_manager-bname
        iv_class       = lv_class
        io_msg_buffer  = go_msg_buffer
      changing
        ct_cua_systems = lt_check_cua_systems.
  endif.


  " If some systems assignment is supposed to be deleted then
  " role and profile assignments and also license data eventually
  " should be also deleted depending on their SCUM settings ==> read here SCUM settings
  if lv_delete eq if_identity=>co_true and
     lt_check_cua_systems is not initial.

    ls_node_filter-node_name = if_identity_definition=>gc_node_cua_role.

    " Get CUA distribution filter for roles
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_node_filter.
    if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
      lv_role_global = if_identity=>co_true.
      lv_role_node   = if_identity_definition=>gc_node_cua_role.
    else.
      lv_role_node   = if_identity_definition=>gc_node_role.
    endif.

    clear: ls_node_filter.
    ls_node_filter-node_name = if_identity_definition=>gc_node_cua_profile.
    " Get CUA distribution filter for profiles
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_node_filter.
    if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
      lv_prof_global  = if_identity=>co_true.
      lv_profile_node = if_identity_definition=>gc_node_cua_profile.
    else.
      lv_profile_node = if_identity_definition=>gc_node_profile.
    endif.

    clear: ls_node_filter.
    ls_node_filter-node_name = if_identity_definition=>gc_node_cua_uclass.
    " Get CUA distribution filter for License data
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
      changing
        cs_field_filter = ls_node_filter.
    if ls_node_filter-field_attr = if_suid_cua_runtime=>gc_global.
      lv_uclass_global = if_identity=>co_true.
    endif.
  endif.


  " --- Move values to segements Part I ------------------------
  " Central system should be the first one to be deleted
  read table lt_check_cua_systems
       into ls_cua_systems
       with key subsystem   = lv_logsys
                change_mode = if_identity=>co_delete.
  if sy-subrc eq 0 and sy-tabix ne 1.
    delete lt_check_cua_systems index sy-tabix.
    insert ls_cua_systems into lt_check_cua_systems index 1.
  endif.

  " Take over systems which can be deleted
  loop at lt_check_cua_systems reference into lr_check_cua_systems
       where change_mode eq if_identity=>co_delete.

    lv_del_tabix = sy-tabix.

    read table ms_segment_cua_systems-actual
         reference into lr_segment_cua_system
         with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                  subsystem  = lr_check_cua_systems->subsystem
         binary search.
    lv_tabix = sy-tabix.
    if sy-subrc eq 0.

      " additional check if the assignment to the central system shell be deleted
      call method cl_identity=>check_refuser_delete_internal
        exporting
          iv_bname      = ms_manager-bname
          iv_node_name  = if_identity_definition=>gc_node_cua_system
          iv_system     = lr_check_cua_systems->subsystem
        importing
          ev_valid      = lv_delete
          .

      if lv_delete eq if_identity=>co_false.
        "No system assignment deletion if e.g. the user is still used as reference user
        delete lt_check_cua_systems index lv_del_tabix.
        continue.
      endif.

      " Delete correspondingly role and profile system assignments (if SCUM setting is 'Global')
      " or if roles/profiles are assigned locally: if <local system> = system which is deleted
      if lv_role_global                  eq if_identity=>co_true or
         lr_check_cua_systems->subsystem eq lv_logsys.

        clear: lv_delete.
        call method roles_cua_delete_user_system
          exporting
            iv_node_name     = lv_role_node
            iv_system        = lr_check_cua_systems->subsystem
          importing
            ev_roles_deleted = lv_delete.
        " No system assignment deletion if role assignment are not deleted
        if lv_delete eq if_identity=>co_false.
          delete lt_check_cua_systems.
          continue.
        endif.
      endif.

      " if roles/profiles are assigned locally: if <local system> = system which is deleted
      " delete local profiles
      if lv_prof_global                  eq if_identity=>co_true or
         lr_check_cua_systems->subsystem eq lv_logsys.

        clear: lv_delete.
        call method profile_cua_delete_user_system
          exporting
            iv_system           = lr_check_cua_systems->subsystem
            iv_node_name        = lv_profile_node
          importing
            ev_profiles_deleted = lv_delete.
        " No system assignment deletion if profile assignments are not deleted
        if lv_delete = if_identity=>co_false.
          delete lt_check_cua_systems.
          continue.
        endif.
      endif.

      " --- Delete User assignment
      " update of ROLE/Profile usrsection in USZBVSYS will be done before distribution

      " Check if system assignment was added during current transaction ==> no change, return
      " to BEFORE_IMAGE
      read table  ms_segment_cua_systems-systems_add
           with key subsystem = lr_check_cua_systems->subsystem
           transporting no fields
           binary search.
      lv_sys_tabix = sy-tabix.
      if sy-subrc = 0.
        delete ms_segment_cua_systems-systems_add index lv_sys_tabix.

        read table ms_segment_cua_systems-before_image reference into lr_before_cua_system
             with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                      subsystem  = lr_check_cua_systems->subsystem
             binary search.
        if sy-subrc eq 0.
          " System returns to the status as at the beginning of transaction, no db update needed ->
          " --> restore data
          lr_segment_cua_system->* = lr_before_cua_system->*.
        else.
          " System was assigned during transaction runtime, return to BEFORE_IMAGE status,
          " no db update needed --> delete entry from ACTUAL image
          delete ms_segment_cua_systems-actual index lv_tabix.
        endif.

      else.
        " Set status deletion unconfirmed
        lr_segment_cua_system->status = if_suid_cua_runtime=>gc_to_be_deleted.

        " Update table for deleted system assignments
        read table ms_segment_cua_systems-systems_del
             with key subsystem = lr_check_cua_systems->subsystem
             transporting no fields
             binary search.
        if sy-subrc <> 0.
          insert initial line into ms_segment_cua_systems-systems_del
                 reference into lr_system index sy-tabix.
          lr_system->subsystem = lr_check_cua_systems->subsystem.
        else.
          " Duplicate system assignment deletion ==> Exception
          macro_raise_internal_error.
        endif.
      endif.

      " Set ZBVMASTER flag if assignment to central system is deleted
      if lr_check_cua_systems->subsystem eq lv_logsys.
        ms_segment_header-actual-zbvmaster = go_persistence->co_flag_active.
      endif.

      " Notification: Node successfully deleted
      gv_macro_key = lr_check_cua_systems->subsystem.
      call method go_notify->notify_delete
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_system
          iv_key        = gv_macro_key
          iv_key_handle = lr_check_cua_systems->key_handle.
    else.
      macro_raise_internal_error.
    endif.
  endloop.

  " If CUA License data is active ==> delete it for deleted systems
  if lv_uclass_global     eq if_identity=>co_true and
     lt_check_cua_systems is not initial.
    cua_uclass_delete_user_system(
      exporting
        it_cua_systems = lt_check_cua_systems  ).
  endif.


  " --- Check entries with change_mode = insert -------------------
  "
  " Comment: -> -> Duplicate entries -> errormessage
  loop at it_cua_systems reference into lr_cua_systems
       where change_mode eq if_identity=>co_insert.

    clear: lv_error.

    " No error messages or notifications exist ?!

    " Check for duplicates in IT_CUA_SYSTEMS
    read table lt_add_cua_systems
         with key subsystem = lr_cua_systems->subsystem
         transporting no fields
         binary search.
    lv_add_tabix = sy-tabix. " Remind position

    if sy-subrc eq 0.
      lv_error = if_identity=>co_true.
    else.
      " Check if system already exists in actual image
      read table ms_segment_cua_systems-actual
           reference into lr_segment_cua_system
           with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                    subsystem  = lr_cua_systems->subsystem
           binary search.
      if sy-subrc eq 0.
        " Error if system assignment is active
        if lr_segment_cua_system->status ne if_suid_cua_runtime=>gc_deleted         and
           lr_segment_cua_system->status ne if_suid_cua_runtime=>gc_to_be_deleted   and
           lr_segment_cua_system->status ne if_suid_cua_runtime=>gc_deleted_runtime and
           lr_segment_cua_system->status ne if_suid_cua_runtime=>gc_failed_delete   .
          lv_error = if_identity=>co_true.
        endif.
      endif.

      if lv_error ne if_identity=>co_true.
        insert lr_cua_systems->* into lt_add_cua_systems index lv_add_tabix.
      endif.
    endif.

    if lv_error eq if_identity=>co_true.
      clear: ls_msg.
      ls_msg-msgv1 = lr_cua_systems->subsystem.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '793'.
      " MSG: Zum System &1 existiert bereits ein Eintrag
      if 1 = 0. message e793(01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_cua_systems->subsystem.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_system
          iv_key        = gv_macro_key
          iv_key_handle = lr_cua_systems->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_system_subsystem
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      " Node creation failed
      call method go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_system
          iv_key        = gv_macro_key
          iv_key_handle = lr_cua_systems->key_handle.
    endif.
  endloop.


  " Check systems with change_mode: insert
  if lt_add_cua_systems is not initial.
    call method check_cua_systems_internal
      exporting
        iv_bname       = ms_manager-bname
        iv_class       = lv_class
        io_msg_buffer  = go_msg_buffer
      changing
        ct_cua_systems = lt_add_cua_systems.
  endif.


  " --- Move values to segements Part II ------------------------
  " Take over systems which can be inserted
  loop at lt_add_cua_systems reference into lr_add_cua_systems.

    case lr_add_cua_systems->change_mode.

      when if_identity=>co_failed_create.
        " Creation of system assignment failed
        gv_macro_key = lr_add_cua_systems->subsystem.
        call method go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_system
            iv_key        = gv_macro_key
            iv_key_handle = lr_add_cua_systems->key_handle.
        continue.

      when if_identity=>co_insert.
        " Modify actual image
        read table ms_segment_cua_systems-actual reference into lr_segment_cua_system
             with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                      subsystem  = lr_add_cua_systems->subsystem
             binary search.
        lv_tabix = sy-tabix.
        if sy-subrc ne 0.
          " Insert new system assignment
          insert initial line into ms_segment_cua_systems-actual reference into lr_segment_cua_system
                 index lv_tabix.
          lr_segment_cua_system->mandt      = sy-mandt.
          lr_segment_cua_system->bname      = ms_manager-bname.
          lr_segment_cua_system->subsystem  = lr_add_cua_systems->subsystem.
          lr_segment_cua_system->usrsection = if_suid_cua_runtime=>gc_user_usrsection.
          " Set status assignment unconfirmed
          lr_segment_cua_system->status = if_suid_cua_runtime=>gc_to_be_assigned.

          read table ms_segment_cua_systems-systems_add
               with key subsystem = lr_add_cua_systems->subsystem
               transporting no fields
               binary search.
          if sy-subrc <> 0.
            insert initial line into ms_segment_cua_systems-systems_add
                   reference into lr_system index sy-tabix.
            lr_system->subsystem = lr_add_cua_systems->subsystem.
          else.
            " Duplicate system assignment insertion ==> Exception
            macro_raise_internal_error.
          endif.
        else.

          " System was already once assigned (entry exists in BEFORE_IMAGE, entry in ACTUAL is inactive)
          " Check if system assignment was deleted during current transaction ==> no update, return to BEFORE_IMAGE
          read table ms_segment_cua_systems-systems_del
               with key subsystem = lr_add_cua_systems->subsystem
               transporting no fields
               binary search.
          lv_sys_tabix = sy-tabix.
          " Restoration of system assignment deleted during actual transaction
          if sy-subrc = 0.
            " Delete system from table of deleted assignments
            delete ms_segment_cua_systems-systems_del index lv_sys_tabix.

            read table ms_segment_cua_systems-before_image reference into lr_before_cua_system
               with key usrsection = if_suid_cua_runtime=>gc_user_usrsection
                        subsystem  = lr_add_cua_systems->subsystem
               binary search.
            if sy-subrc = 0.
              " System assignment returns to the status as at the beginning of transaction
              lr_segment_cua_system->* = lr_before_cua_system->*.
            else.
              macro_raise_internal_error.
            endif.
          else.

            " System assignment has initial (BEFORE_IMAGE) state
            " Set status assignment unconfirmed
            lr_segment_cua_system->status = if_suid_cua_runtime=>gc_to_be_assigned.

            read table ms_segment_cua_systems-systems_add
                 with key subsystem = lr_add_cua_systems->subsystem
                 transporting no fields
                 binary search.
            if sy-subrc <> 0.
              insert initial line into ms_segment_cua_systems-systems_add
                     reference into lr_system index sy-tabix.
              lr_system->subsystem = lr_add_cua_systems->subsystem.
            else.
              " Duplicate system assignment insertion ==> Exception
              macro_raise_internal_error.
            endif.
          endif.
        endif.

        " Clear ZBVMASTER flag if central system is assigned
        if lr_add_cua_systems->subsystem eq lv_logsys.
          clear: ms_segment_header-actual-zbvmaster.
        endif.

        " Notification Node created
        gv_macro_key = lr_add_cua_systems->subsystem.
        call method go_notify->notify_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_system
            iv_key        = gv_macro_key
            iv_key_handle = lr_add_cua_systems->key_handle.

      when others.
    endcase.
  endloop.


  " --- Transaction handling ---------------------------------
  "
  " New transaction status: UNCHECKED
  " Set segments change flag
  if ms_segment_cua_systems-actual ne ms_segment_cua_systems-before_image or
     ms_segment_cua_systems-systems_add is not initial                    or
     ms_segment_cua_systems-systems_del is not initial.

    " New transaction status: UNCHECKED
    ms_manager-status = go_persistence->co_ta_status_unchecked.

    " Check node status:
    call method go_msg_buffer->find_error_for_node
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_system
      receiving
        ev_error    = lv_error.

    if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
      ms_manager-sn_cua_systems = go_persistence->co_node_status_checked.
    else.                                  "  New node status: CHANGED
      ms_manager-sn_cua_systems = go_persistence->co_node_status_changed.
    endif.

    " Set segment change flag for DB
    if ms_segment_header-actual ne ms_segment_header-before_image.
      ms_segment_header-status = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_header-status.
    endif.

    " Set segment change flag for DB
    ms_segment_cua_systems-status = go_persistence->co_seg_changed.
  else.
    " in case actual and before_image are identical: set segment
    " status to unchanged.
    clear: ms_segment_cua_systems-status, ms_manager-sn_cua_systems.
  endif.

endmethod.


method if_identity_cua~set_cua_uclasses.
*
* GC_NODE_CUA_UCLASS
* GC_USER_USRSECTION
*
* Alowed CHANGE_MODEs:
*      -  CO_UPDATE
*      -  CO_INSERT
*      -  CO_DELETE
*      -  SPACE
*
*
*   E351(01)           - Sie sind nicht auf dem Zentralsystem angemeldet.
*   E381(01)           - Das System &1 ist nicht Teil der Zentralen Benutzerpflege
*   E274(bv)           - Lizenzvermessung: Mehrere Einträge für System &1
*   E275(bv)           - Lizenzvermessung: Mehrere Einträge für das Zentralsystem &1
*   E004(bv)           - Verwendung von Benutzertyp &1 ist nicht erlaubt
*   E152(01)           - Keine Berechtigung Tochtersystem & zuzuordnen oder zu entfernen.
*   E793(01)           - Zum System &1 existiert bereits ein Eintrag
*   E407(LAW_MESSAGES) - Verwendung von Benutzertyp &1 ist nicht erlaubt


  data: lt_check_cua_uclasses    type          suid_tt_node_cua_uclasses
      , lr_cua_uclass            type ref to   suid_st_node_cua_uclass
      , lr_seg_uclass            type ref to   usr06sys
      , ls_seg_uclass            type          usr06sys
      , lt_assigned_systems      type          suid_tt_node_cua_systems
      , lt_cua_uclasses          type          suid_tt_node_cua_uclasses
      , lv_logsys                type          t000-logsys
      , lv_tabix                 type          sy-tabix
      , ls_msg                   type          symsg
      , lv_error                 type          sesf_boolean
      , lv_field                 type          suid_node_field
      , lv_no_maintain           type          sesf_boolean
      , lt_node_fields           type          suid_tt_fields
      , lr_node_field            type ref to   suid_node_field
      , lr_segment_field         type ref to   suid_node_field
      .

  field-symbols: <ls_segment>  type any.


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_cua_uclass
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_uclass.

  " Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_cua_uclass
      iv_lifetimeonce_only = if_identity=>co_true.


  " --- Check CUA landscape ----------------------------------
  "
  " Get logical name of actual system
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_system_logsys = lv_logsys.

  " CUA is not active - system node shouldn't be filled --> error message and exit
  if gv_cua_active eq if_identity=>co_false.
    ls_msg-msgv1 = lv_logsys.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '381'.
    " MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    if 1 = 0. message e381(01) with ls_msg-msgv1. endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Actual system is not central system - system node shouldn't be filled --> error message and exit
  if gv_cua_central eq if_identity=>co_false.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
    " MSG: Sie sind nicht auf dem Zentralsystem angemeldet
    if 1 = 0. message e351(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " Check if node can be maintained
  if gv_cua_central eq if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_uclass
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

    " Node can't be maintained: do not proceed
    if lv_no_maintain eq if_identity=>co_true.
      return.
    endif.
  endif.

  " Get list of fields belonging to the node
  call method cl_suid_tools=>get_node_fields
    exporting
      iv_node_name   = if_identity_definition=>gc_node_cua_uclass
    importing
      et_node_fields = lt_node_fields.

  " Get assigned to a user systems: Invalid systems are ignored
  call method me->get_cua_systems
    importing
      et_cua_systems = lt_assigned_systems.


  " --- Fill buffer ------------------------------------------
  "
  " Fetch local License data
  if ms_segment_uclass-bname is initial.
    call method fetch_segment_uclass.
  endif.

  " Fetch License data assignments in child systems
  if ms_segment_cua_uclasses-bname is initial.
    call method fetch_segment_cua_uclasses.
  endif.

  create data: lr_segment_field.

  " Get assigned uclasses
  call method me->get_cua_uclasses
    importing
      et_cua_uclasses = lt_cua_uclasses.


  " --- Check entries with change_mode = space, delete -------------------
  "
  " Comment: - Check only values, which are in the importing table
  "          - Collect change_mode = insert for other check
  "          - Handle first change_mode = space, delete, update
  "          -> Key (Subsystem) must be unique
  "          -> Duplicate entries are only allowed for change_mode = insert
  loop at it_cua_uclasses reference into lr_cua_uclass
       where change_mode ne if_identity=>co_insert .

    if lr_cua_uclass->change_mode ne space                  and
       lr_cua_uclass->change_mode ne if_identity=>co_delete and
       lr_cua_uclass->change_mode ne if_identity=>co_update.
      " Wrong change mode: Only space, delete, update (or insert) are allowed
      macro_raise_internal_error.
    endif.

    " Check that License data in system is already assigned
    if lr_cua_uclass->subsystem eq lv_logsys.
      " No License data assignment in central system
      if ms_segment_uclass-actual is initial.
        continue.
      endif.
    elseif lr_cua_uclass->change_mode ne if_identity=>co_delete.
      read table lt_cua_uclasses
           with key subsystem = lr_cua_uclass->subsystem
           transporting no fields
           binary search.
      " No License data assignment in child system
      if sy-subrc ne 0.
        continue.
      endif.
    endif.

    " Delete messages for systems which should be checked
    gv_macro_key = lr_cua_uclass->subsystem.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
        iv_key      = gv_macro_key.

    read table lt_check_cua_uclasses
         with key subsystem = lr_cua_uclass->subsystem
         transporting no fields
         binary search.
    if sy-subrc ne 0.
      " Insert into checktable
      insert lr_cua_uclass->* into lt_check_cua_uclasses index sy-tabix.
    else.
      macro_raise_internal_error.
    endif.
  endloop.


  " Check systems with change_mode: space, delete, update
  if lt_check_cua_uclasses is not initial.
    call method check_cua_uclasses_internal
      exporting
        iv_nodename         = if_identity_definition=>gc_node_cua_uclass
        iv_bname            = ms_manager-bname
        io_msg_buffer       = go_msg_buffer
        it_assigned_systems = lt_assigned_systems
      changing
        ct_cua_uclasses     = lt_check_cua_uclasses.
  endif.


  " --- Move values to segements Part I ------------------------
  " Take over License data which can be deleted or updated
  loop at lt_check_cua_uclasses reference into lr_cua_uclass
       where change_mode eq if_identity=>co_delete or
             change_mode eq if_identity=>co_update.

    clear: lv_error.

    case lr_cua_uclass->change_mode.
      when if_identity=>co_delete.
        " -- Delete
        if lr_cua_uclass->subsystem eq lv_logsys.
          " Central system
          clear: ms_segment_uclass-actual.
        else.
          " Child system
          read table ms_segment_cua_uclasses-actual
               reference into lr_seg_uclass
               with key rcvsystem = lr_cua_uclass->subsystem
               binary search.
          lv_tabix = sy-tabix.
          if sy-subrc eq 0.
            " Do not delete entry, if system is assigned
            read table lt_assigned_systems with key subsystem = lr_cua_uclass->subsystem
              transporting no fields binary search.
            if sy-subrc ne 0.
              delete ms_segment_cua_uclasses-actual index lv_tabix.
            else.
              ls_seg_uclass = lr_seg_uclass->*.
              clear: lr_seg_uclass->*.
              lr_seg_uclass->mandt     = ls_seg_uclass-mandt.
              lr_seg_uclass->bname     = ls_seg_uclass-bname.
              lr_seg_uclass->rcvsystem = ls_seg_uclass-rcvsystem.
              "lr_seg_uclass->lic_type  = '00'.
            endif.
          else.
            lv_error = if_identity=>co_true.
          endif.
        endif.

        if lv_error eq if_identity=>co_false.
          " Write notifications
          gv_macro_key = lr_cua_uclass->subsystem.
          " Notification: Node successful deleted
          call method go_notify->notify_delete
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_cua_uclass
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle.
        endif.

      when if_identity=>co_update.
        " -- Update
        if lr_cua_uclass->lic_type is initial or lr_cua_uclass->lic_type eq '00'.
          " Update as delete
          if lr_cua_uclass->subsystem eq lv_logsys.
            " Central system
            clear: ms_segment_uclass-actual.
          else.
            " Child system
            read table ms_segment_cua_uclasses-actual
                 reference into lr_seg_uclass
                 with key rcvsystem = lr_cua_uclass->subsystem
                 binary search.
            lv_tabix = sy-tabix.
            if sy-subrc eq 0.
              " Do not delete entry, if system is assigned
              read table lt_assigned_systems with key subsystem = lr_cua_uclass->subsystem
                transporting no fields binary search.
              if sy-subrc ne 0.
                delete ms_segment_cua_uclasses-actual index lv_tabix.
              else.
                ls_seg_uclass = lr_seg_uclass->*.
                clear: lr_seg_uclass->*.
                lr_seg_uclass->mandt     = ls_seg_uclass-mandt.
                lr_seg_uclass->bname     = ls_seg_uclass-bname.
                lr_seg_uclass->rcvsystem = ls_seg_uclass-rcvsystem.
                "lr_seg_uclass->lic_type  = '00'.
              endif.
            else.
              lv_error = if_identity=>co_true.
            endif.
          endif.

        else.
          " -- Update as another LIC_TYPE assignment
          if lr_cua_uclass->subsystem eq lv_logsys.
            " Central system
            if ms_segment_uclass-actual is initial.
              lv_error = if_identity=>co_true.
            else.
              assign ms_segment_uclass-actual to <ls_segment>.
            endif.
          else.
            " Child system
            read table ms_segment_cua_uclasses-actual assigning <ls_segment>
                 with key rcvsystem = lr_cua_uclass->subsystem
                 binary search.
            lv_tabix = sy-tabix.
            if sy-subrc ne 0.
              lv_error = if_identity=>co_true.
            endif.
          endif.
        endif.

        if lv_error eq if_identity=>co_false.
          if lr_cua_uclass->change_mode ne if_identity=>co_delete and
             not ( lr_cua_uclass->lic_type is initial or lr_cua_uclass->lic_type eq '00' ).
            " Update segment MS_SEGMENT_UCLASS or MS_SEGMENT_CUA_UCLASS from node
            loop at lt_node_fields reference into lr_node_field.
              if lr_node_field->* = if_identity_definition=>gc_field_cua_system_subsystem.
                continue.
              endif.
              call method cl_suid_tools=>map_uclass_nodes_to_segment
                exporting
                  iv_node_name     = if_identity_definition=>gc_node_uclass
                  iv_node_field    = lr_node_field->*
                importing
                  ev_segment_field = lr_segment_field->*.

              call method cl_suid_tools=>set_structure_field_value
                exporting
                  iv_field         = lr_segment_field->*
                  is_get_structure = lr_cua_uclass->*
                  iv_get_field     = lr_node_field->*
                changing
                  cs_structure     = <ls_segment>.
            endloop.
          endif.

          " Write notifications
          gv_macro_key = lr_cua_uclass->subsystem.
          " Notification: Node successful deleted
          call method go_notify->notify_update
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_cua_uclass
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle.
        endif.
    endcase.
  endloop.


  " --- Check entries with change_mode = insert -------------------
  "
  refresh: lt_check_cua_uclasses.

  " Comment: -> -> Duplicate entries -> errormessage
  loop at it_cua_uclasses reference into lr_cua_uclass
       where change_mode eq if_identity=>co_insert.
    clear:  lv_error
          , lv_field
          , ls_msg.

    " No error messages or notifications exist ?!

    " Check for duplicates in IT_CUA_UCLASSES
    read table lt_check_cua_uclasses
         with key subsystem = lr_cua_uclass->subsystem
         transporting no fields
         binary search.
    lv_tabix = sy-tabix. " Remind position

    if sy-subrc eq 0.
      lv_error     = if_identity=>co_true.
      lv_field     = if_identity_definition=>gc_field_cua_system_subsystem.
      ls_msg-msgv1 = lr_cua_uclass->subsystem.

      if lr_cua_uclass->subsystem eq lv_logsys.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '275'.
        " MSG: Lizenzvermessung: Mehrere Einträge für das Zentralsystem &1
        if 1 = 0. message e275(bv) with ls_msg-msgv1. endif.
      else.
        " Child system
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '274'.
        " MSG: Lizenzvermessung: Mehrere Einträge für System &1
        if 1 = 0. message e274(bv) with ls_msg-msgv1. endif.
      endif.
    endif.

    if lv_error eq if_identity=>co_false.
      " LIC_TYPE = '00' or INITIAL are only allowed for CHANGE_MODE = space, delete, update
      if lr_cua_uclass->lic_type is initial or lr_cua_uclass->lic_type = '00'.
        lv_error = if_identity=>co_true.
        lv_field = if_identity_definition=>gc_field_uclass_lic_type.
        ls_msg-msgv1 = lr_cua_uclass->lic_type.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '004'.
        " MSG: Verwendung von Benutzertyp &1 ist nicht erlaubt
        if 1 = 0. message e004(bv) with ls_msg-msgv1. endif.
      endif.
    endif.

    if lv_error eq if_identity=>co_true.
      " Report the error
      gv_macro_key = lr_cua_uclass->subsystem.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_uclass
          iv_key        = gv_macro_key
          iv_key_handle = lr_cua_uclass->key_handle
          iv_field      = lv_field
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      " Node creation failed
      call method go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_uclass
          iv_key        = gv_macro_key
          iv_key_handle = lr_cua_uclass->key_handle.

      " ->>> Different error handling in CUA and SCUG !!!
      continue.
    elseif lv_error eq if_identity=>co_false.
      " Insert into insert_check_table
      insert lr_cua_uclass->* into lt_check_cua_uclasses index lv_tabix.
    endif.
  endloop.


  " Check systems with change_mode: insert
  if lt_check_cua_uclasses is not initial.
    call method check_cua_uclasses_internal
      exporting
        iv_nodename         = if_identity_definition=>gc_node_cua_uclass
        iv_bname            = ms_manager-bname
        io_msg_buffer       = go_msg_buffer
        it_assigned_systems = lt_assigned_systems
      changing
        ct_cua_uclasses     = lt_check_cua_uclasses.
  endif.


  " --- Move values to segements Part II ------------------------
  " Take over License data which can be inserted
  loop at lt_check_cua_uclasses reference into lr_cua_uclass.

    case lr_cua_uclass->change_mode.

      when if_identity=>co_failed_create.
        " Insertion failed
        gv_macro_key = lr_cua_uclass->subsystem.
        call method go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_uclass
            iv_key        = gv_macro_key
            iv_key_handle = lr_cua_uclass->key_handle.
        continue.

      when if_identity=>co_insert.
        if lr_cua_uclass->subsystem eq lv_logsys.
          " Central system
          if ms_segment_uclass-actual-lic_type is initial or
             ms_segment_uclass-actual-lic_type = '00'.
            assign ms_segment_uclass-actual to <ls_segment>.
          endif.
        else.
          " Child system
          " Add new License data assignment
          read table ms_segment_cua_uclasses-actual reference into lr_seg_uclass
               with key rcvsystem = lr_cua_uclass->subsystem
               binary search.
          lv_tabix = sy-tabix.
          if sy-subrc ne 0.
            " Insert actual image
            insert initial line into ms_segment_cua_uclasses-actual index lv_tabix assigning <ls_segment>.
          else.
            " Update deleted assignment
            if lr_seg_uclass->lic_type is initial or lr_seg_uclass->lic_type eq '00'.
              assign lr_seg_uclass->* to <ls_segment>.
            endif.
          endif.
        endif.

        " Set values to BNAME and MANDT to segments
        if <ls_segment> is assigned.
          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field       = 'BNAME'
              iv_field_value = ms_manager-bname
            changing
              cs_structure   = <ls_segment>.

          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field       = 'MANDT'
              iv_field_value = sy-mandt
            changing
              cs_structure   = <ls_segment>.

          " Notification Node created
          gv_macro_key = lr_cua_uclass->subsystem.
          call method go_notify->notify_create
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_cua_uclass
              iv_key        = gv_macro_key
              iv_key_handle = lr_cua_uclass->key_handle.

        else.

          macro_raise_internal_error.
        endif.
    endcase.


    if lr_cua_uclass->change_mode eq if_identity=>co_insert and <ls_segment> is assigned.
      " Update segment MS_SEGMENT_CUA_UCLASS or MS_SEGMENT_UCLASS from node
      loop at lt_node_fields reference into lr_node_field.
        " Ignore field SUBSYSTEM for central system (system field is absent in MS_SEGMENT_UCLASS)
        if lr_cua_uclass->subsystem eq lv_logsys and
           lr_node_field->*         eq if_identity_definition=>gc_field_cua_system_subsystem.
          continue.
        endif.
        call method cl_suid_tools=>map_uclass_nodes_to_segment
          exporting
            iv_node_name     = if_identity_definition=>gc_node_cua_uclass
            iv_node_field    = lr_node_field->*
          importing
            ev_segment_field = lr_segment_field->*.

        call method cl_suid_tools=>set_structure_field_value
          exporting
            iv_field         = lr_segment_field->*
            is_get_structure = lr_cua_uclass->*
            iv_get_field     = lr_node_field->*
          changing
            cs_structure     = <ls_segment>.
      endloop.
    endif.
  endloop.


  " --- Transaction handling ---------------------------------
  "
  if ms_segment_cua_uclasses-actual ne ms_segment_cua_uclasses-before_image or
     ms_segment_uclass-actual       ne ms_segment_uclass-before_image.

    " New transaction status: UNCHECKED
    ms_manager-status = go_persistence->co_ta_status_unchecked.

    " Check node status:
    call method go_msg_buffer->find_error_for_node
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_uclass
      receiving
        ev_error    = lv_error.

    if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
      ms_manager-sn_cua_uclass = go_persistence->co_node_status_checked.
    else.                     "  New node status: CHANGED
      ms_manager-sn_cua_uclass = go_persistence->co_node_status_changed.
    endif.

    " Set segment change flag
    if ms_segment_cua_uclasses-actual ne ms_segment_cua_uclasses-before_image.
      ms_segment_cua_uclasses-status  = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_cua_uclasses-status.
    endif.

    if ms_segment_uclass-actual ne ms_segment_uclass-before_image.
      ms_segment_uclass-status  = go_persistence->co_seg_changed.
    else.
      clear: ms_segment_uclass-status.
    endif.

  else.
    " in case actual and before_image are identical: set segment
    " status to unchanged.
    clear: ms_segment_cua_uclasses-status
         , ms_segment_uclass-status
         , ms_manager-sn_cua_uclass
         .
  endif.

endmethod.


  method if_identity_dbms_user~get_dbms_roles.

    field-symbols: <lt_dbms_roles> type suid_tt_dbms_roles.

* Exporting parameter
    eo_msg_buffer = go_msg_buffer.
    clear: et_dbms_roles.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
    call method checks_before_access
      exporting
        iv_method               = 'G'
        iv_change_node          = if_identity_definition=>gc_node_dbms_role
        iv_request_before_image = iv_request_before_image
      importing
        es_msg                  = data(ls_msg).

    if ls_msg-msgty = 'E'.
      return.
    endif.


* Exporting parameter
    eo_msg_buffer = go_msg_buffer.
    clear: et_dbms_roles.

* --- Fill buffer ------------------------------------------
*
* Check parameter buffer
    if ms_segment_dbms_user-bname is initial.
      call method fetch_segment_dbms_user.
    endif.

* Return actual or before image?
    if iv_request_before_image is initial.
      assign ms_segment_dbms_user-dbms_roles_actual to <lt_dbms_roles>.
    else.
      assign ms_segment_dbms_user-dbms_roles_before to <lt_dbms_roles>.
    endif.

    loop at <lt_dbms_roles> assigning field-symbol(<ls_dbms_role>).
      append initial line to et_dbms_roles assigning field-symbol(<ls_node_dbms_role>).
      move-corresponding <ls_dbms_role> to <ls_node_dbms_role>.
    endloop.


  endmethod.


  method if_identity_dbms_user~get_dbms_user.

    data: ls_msg           type          symsg
        .

* Exporting parameter
    eo_msg_buffer = go_msg_buffer.
    clear: es_dbms_user.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
    checks_before_access(
      exporting
        iv_method      = 'G'
        iv_change_node = if_identity_definition=>gc_node_dbms_user
        iv_request_before_image = iv_request_before_image
      importing
        es_msg         = ls_msg
         ).

    if ls_msg-msgty = 'E'.
      return.
    endif.

    call method me->get_dbms_user
      exporting
        iv_request_before_image = iv_request_before_image
      importing
        es_dbms_user            = es_dbms_user
        eo_msg_buffer           = eo_msg_buffer.


  endmethod.


method if_identity_dbms_user~set_dbms_roles.

  data: lt_check_dbms_role   type        suid_tt_node_dbms_roles
      , lt_insert_dbms_role  type        suid_tt_node_dbms_roles
      , lr_insert_dbms_role  type ref to suid_st_node_dbms_role
      , lr_check_dbms_role   type ref to suid_st_node_dbms_role
      , ls_seg_dbms_role     type        suid_st_dbms_role
      , lv_tabix             type        sy-tabix
      , lv_ins_tabix         type        sy-tabix
      , ls_msg               type        symsg
      , lv_error             type        sesf_boolean
      .

* Exporting dbms_role
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_dbms_role
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
* Return to caller
    return.
  endif.

* Lazy fetch of dbms_user segment
  if ms_segment_dbms_user-bname is initial.
    call method fetch_segment_dbms_user.
  endif.


* Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_dbms_role.

*   Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_dbms_role
      iv_lifetimeonce_only = if_identity=>co_true.

** --- Maintenance check ------------------------------------------------
**
*  data lv_no_maintain       type        sesf_boolean.
*  if gv_cua_child = if_identity=>co_true.
*    call method cua_if_field_no_maintain
*      exporting
*        iv_node_name   = if_identity_definition=>gc_node_dbms_role
*        io_msg_buffer  = go_msg_buffer
*      receiving
*        rv_no_maintain = lv_no_maintain.
*
** If node cannot be maintaind - leave
*    if lv_no_maintain = if_identity=>co_true.
*      return.
*    endif.
*  endif.

* --- Check entries with change_mode = space, delete,  ----------------
*
* Comment: - Check only values, which are in the importing table
*          - Handle first change_mode = space ,delete
*          -> Key (dbms_role) must be unique
*          -> Duplicate entries are only allowed for change_mode = insert
  loop at it_dbms_roles reference into data(lr_dbms_role)
       where change_mode ne if_identity=>co_insert.

    if lr_dbms_role->change_mode ne space     and
       lr_dbms_role->change_mode ne if_identity=>co_delete.
*     Wrong change mode: Only space, delete, (or insert) are allowed
      raise exception type cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error
          bname  = ms_manager-bname.
    endif.

*   Delete messages for dbms_role which should be checked
    gv_macro_key = lr_dbms_role->dbms_role.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_dbms_role
        iv_key      = gv_macro_key.

*   Check: Entry must exist in actual image
    read table ms_segment_dbms_user-dbms_roles_actual
         with key dbms_role = lr_dbms_role->dbms_role
                  grantor   = lr_dbms_role->grantor
         transporting no fields
         binary search.
    if sy-subrc ne 0.
*     Ignore dbms_role or warning
      continue.
    else.
*     Entry must be unique in check_table
      read table lt_check_dbms_role
           with key dbms_role = lr_dbms_role->dbms_role
                    grantor   = lr_dbms_role->grantor
           transporting no fields
           binary search.
      if sy-subrc ne 0.
*       Insert into checktable
        insert lr_dbms_role->* into lt_check_dbms_role index sy-tabix.
      else.
*       Duplicate entries in IT_dbms_role -> Exception
        raise exception type cx_suid_identity
          exporting
            textid = cx_suid_identity=>internal_error
            bname  = ms_manager-bname.
      endif.
    endif.

  endloop.

* Check dbms_role with change_mode: space, delete
  if lt_check_dbms_role is not initial.
    call method check_dbms_roles_internal
      exporting
        iv_bname      = ms_manager-bname
        io_msg_buffer = go_msg_buffer
      changing
        ct_dbms_roles = lt_check_dbms_role.
  endif.

* --- Move values to segements Part I ------------------------
* Take over dbms_role which can be deleted
  loop at lt_check_dbms_role reference into lr_check_dbms_role
       where change_mode eq if_identity=>co_delete.

    read table ms_segment_dbms_user-dbms_roles_actual
         reference into data(lr_seg_dbms_role)
         with key dbms_role = lr_check_dbms_role->dbms_role
                  grantor   = lr_check_dbms_role->grantor
         binary search.
    lv_tabix = sy-tabix.
    if sy-subrc eq 0.
      case lr_check_dbms_role->change_mode.
        when if_identity=>co_delete.
          delete ms_segment_dbms_user-dbms_roles_actual index lv_tabix.
*         Notification: Node successful deleted
          gv_macro_key = lr_check_dbms_role->dbms_role && lr_check_dbms_role->grantor.
          call method go_notify->notify_delete
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_dbms_role
              iv_key        = gv_macro_key
              iv_key_handle = lr_check_dbms_role->key_handle.
      endcase.
    endif.
  endloop.


* --- Check entries with change_mode = insert -------------------
*
* Comment: -> -> Duplicate entries -> errormessage
  loop at it_dbms_roles reference into lr_dbms_role
       where change_mode eq if_identity=>co_insert.

*   No error messages or notifications exist ?!

*   Check for duplicates in IT_dbms_role
    read table lt_insert_dbms_role
         with key dbms_role = lr_dbms_role->dbms_role
                  grantor   = lr_dbms_role->grantor
         transporting no fields
         binary search.
    lv_ins_tabix = sy-tabix. " Remind position
    clear: lv_error.

    if sy-subrc eq 0.
      lv_error = 'X'.
    else.
*     Check if dbms_role alread exists in actual image
      read table ms_segment_dbms_user-dbms_roles_actual
           with key dbms_role = lr_dbms_role->dbms_role
                    grantor   = lr_dbms_role->grantor
           transporting no fields
           binary search.
      if sy-subrc eq 0.
        lv_error = 'X'.
      else.
*       Insert into insert_check_table
        insert lr_dbms_role->* into lt_insert_dbms_role index lv_ins_tabix.
      endif.
    endif.

    if lv_error eq 'X'.
      clear: ls_msg.
      ls_msg-msgv1 = lr_dbms_role->dbms_role.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '060'.
*         MSG: An entry already exists for dbms_role &
      if 1 = 0. message e060(suid01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_dbms_role->dbms_role && lr_dbms_role->grantor.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_dbms_role
          iv_key        = gv_macro_key
          iv_key_handle = lr_dbms_role->key_handle
          iv_field      = if_identity_definition=>gc_field_dbms_user_role
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

*     Node creation failed
      call method go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_dbms_role
          iv_key        = gv_macro_key
          iv_key_handle = lr_dbms_role->key_handle.

*         ->>> Different error handling in CUA and SCUG !!!
      continue.
    endif.
  endloop.

* Check dbms_role with change_mode: insert
  if lt_insert_dbms_role is not initial.
    call method check_dbms_roles_internal
      exporting
        iv_bname      = ms_manager-bname
        io_msg_buffer = go_msg_buffer
      changing
        ct_dbms_roles = lt_insert_dbms_role.
  endif.


* --- Move values to segements Part II ------------------------
* Take over dbms_role which can be inserted
  loop at lt_insert_dbms_role reference into lr_insert_dbms_role.

    case lr_insert_dbms_role->change_mode.

      when if_identity=>co_failed_create.
*       Insertion failed
        gv_macro_key = lr_insert_dbms_role->dbms_role && lr_insert_dbms_role->grantor.
        call method go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_dbms_role
            iv_key        = gv_macro_key
            iv_key_handle = lr_insert_dbms_role->key_handle.
        continue.

      when if_identity=>co_insert.
*       Insert actual image
        read table ms_segment_dbms_user-dbms_roles_actual
             with key dbms_role = lr_insert_dbms_role->dbms_role
                      grantor   = lr_insert_dbms_role->grantor
             transporting no fields
             binary search.
        lv_tabix = sy-tabix.

        if sy-subrc ne 0.
          clear ls_seg_dbms_role.
          ls_seg_dbms_role-dbms_role = lr_insert_dbms_role->dbms_role.
          insert ls_seg_dbms_role into ms_segment_dbms_user-dbms_roles_actual index lv_tabix.

*         Notification Node created
          gv_macro_key = lr_insert_dbms_role->dbms_role && lr_insert_dbms_role->grantor.
          call method go_notify->notify_create
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_dbms_role
              iv_key        = gv_macro_key
              iv_key_handle = lr_insert_dbms_role->key_handle.
        endif.
    endcase.

  endloop.

* --- Transaction handling ---------------------------------
*
* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check node status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_dbms_role
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_dbms_roles = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_dbms_roles = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if    ms_segment_dbms_user-actual ne ms_segment_dbms_user-before_image  "DBMS User assignment was changed
     or ms_segment_dbms_user-dbms_user_data_actual ne ms_segment_dbms_user-dbms_user_data_before "DBMS User data was changed
     or ms_segment_dbms_user-dbms_roles_actual ne ms_segment_dbms_user-dbms_roles_before "DBMS-roles was changed
     or ( ms_segment_dbms_user-dbms_user_data_actual-user_id   is initial and
          ms_segment_dbms_user-dbms_user_data_actual-user_name is not initial ). "DBMS user does not exist and to be created

    ms_segment_dbms_user-status = go_persistence->co_seg_changed.

  else.
    clear: ms_segment_dbms_user-status.
  endif.


endmethod.


  method if_identity_dbms_user~set_dbms_user.

    data: ls_old_dbms_user         type suid_st_node_dbms_user
        , ls_check_dbms_user       type suid_st_node_dbms_user
        , lt_change_fields         type suid_tt_fields
        , lv_lifetimeonce_only     type char1
        , lt_check_nodes           type table of suid_node_name
        .

  field-symbols:
        <lv_checkfield>   type any
       .
    " Exporting parameter
    eo_msg_buffer = go_msg_buffer.
    eo_notify     = go_notify.

    " Need to check change_fields before calling check_before_access
    " to get nodes/fields for correct AUTHORITY-CHECK

    if it_change_fields is initial. "set all fields

      "Get list of fields belonging to the node
      call method cl_suid_tools=>get_node_fields
        exporting
          iv_node_name   = if_identity_definition=>gc_node_dbms_user
        importing
          et_node_fields = lt_change_fields.
    else.
      lt_change_fields     = it_change_fields.
      lv_lifetimeonce_only = if_identity=>co_true.

      " Validity Fields should be operated together, because message
      " w105(01) - "Ungültiges Zeitintervall: Beginndatum &1 größer als Endedatum &2"
      " is triggered for one field but belongs to both fields.
      data lv_i type i value 0.
      loop at lt_change_fields assigning <lv_checkfield>.
        case <lv_checkfield>.
          when if_identity_definition=>gc_field_dbms_valid_to.
            lv_i = lv_i - 1.
          when if_identity_definition=>gc_field_dbms_valid_from.
            lv_i = lv_i + 1.
        endcase.
      endloop.
      case lv_i.
        when -1.
          append if_identity_definition=>gc_field_dbms_valid_from to lt_change_fields.
        when 1.
          append if_identity_definition=>gc_field_dbms_valid_to to lt_change_fields.
      endcase.
      sort lt_change_fields.
      delete adjacent duplicates from lt_change_fields.
    endif.

    "Get table of nodes for authority-check
    " Nodes gc_node_dbms_user_pwd and gc_node_dbms_user_lock do not exist as strcutues,
    " and used for authorization check only.
    loop at lt_change_fields assigning field-symbol(<lv_change_field>).
      case  <lv_change_field>.
        when if_identity_definition=>gc_field_dbms_user_password or
             if_identity_definition=>gc_field_dbms_user_password2.
          collect if_identity_definition=>gc_node_dbms_user_pwd into lt_check_nodes.
        when if_identity_definition=>gc_field_dbms_user_deactivated.
          collect if_identity_definition=>gc_node_dbms_user_lock into lt_check_nodes.
        when others.
          collect if_identity_definition=>gc_node_dbms_user into lt_check_nodes.
      endcase.
    endloop.

    " If DBMS User is not active in client we allow only to remove mapping wo any DBMS operation
    if cl_dbms_customizing=>if_dbms_um_active( ) <> abap_true.
      read table lt_change_fields from if_identity_definition=>gc_field_dbms_user_dbms_user transporting no fields.
      if sy-subrc = 0 and is_dbms_user-dbms_user is initial.
        clear lt_change_fields.
        append  if_identity_definition=>gc_field_dbms_user_dbms_user to lt_change_fields.
      else.
        clear lt_change_fields.
        return.
      endif.
    endif.

    " --- Transaction handling ---------------------------------
    "
    " Set values only in CREATE or CHANGE mode
    loop at lt_check_nodes assigning field-symbol(<lv_check_node>).
      call method checks_before_access
        exporting
          iv_method      = 'S' " Call from SET method
          iv_change_node = <lv_check_node>
        importing
          es_msg         = data(ls_msg).

      if ls_msg-msgty = 'E'.
        " Return to caller
        return.
      endif.
    endloop.
    if sy-subrc <> 0.
      macro_raise_internal_error.
    endif.

    " Lazy fetch
    if ms_segment_dbms_user-bname is initial.
      call method fetch_segment_dbms_user.
    endif.

    move-corresponding ms_segment_dbms_user-dbms_user_data_actual to ls_old_dbms_user.
    ls_old_dbms_user-dbms_user = ms_segment_dbms_user-actual-dbms_user.

    " Delete all notification belonging to this node
    call method go_notify->delete_notifications
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_dbms_user.

* --- Set values ------------------------------------------
*
* Fill check structure with old values first
    ls_check_dbms_user = ls_old_dbms_user.
    clear: ls_check_dbms_user-password, ls_check_dbms_user-password2. "Do not move and check old password.

* Delete lifetime_once messages  belonging to this node
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname             = ms_manager-bname
        iv_nodename          = if_identity_definition=>gc_node_dbms_user
        iv_lifetimeonce_only = lv_lifetimeonce_only.

    loop at lt_change_fields reference into data(lr_field).
      if it_change_fields is not initial.
*     Delete lifetime_permanent messages  belonging to this node
        if lr_field->* =  if_identity_definition=>gc_field_dbms_user_dbms_user.
          call method go_msg_buffer->delete_object_message
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_dbms_user.
        else.
          call method go_msg_buffer->delete_object_message
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_dbms_user
              iv_field    = lr_field->*.
        endif.
      endif.

**** Check maintenance
***  if gv_cua_child = if_identity=>co_true.
***    if  lv_scum_checked = if_identity=>co_false.
***      call method cua_if_field_no_maintain
***        exporting
***          iv_node_name   = if_identity_definition=>gc_node_dbms_user
***          io_msg_buffer  = go_msg_buffer
***          iv_field_name  = lr_field->*
***        receiving
***          rv_no_maintain = lv_no_maintain.
***
***      lv_scum_checked = if_identity=>co_true.
***    endif.
***    if lv_no_maintain = if_identity=>co_true.
***      delete lt_change_fields.
***      continue.
***    endif.
***  endif.
*   Set new field value
      assign component lr_field->* of structure is_dbms_user to field-symbol(<lv_newfield>).
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

      assign component lr_field->* of structure ls_check_dbms_user to <lv_checkfield>.
      if sy-subrc ne 0.
        macro_raise_internal_error.
      endif.

*   Move node field
      <lv_checkfield> = <lv_newfield>.

    endloop.

* It is not allowed to switch DBMS User
    read table lt_change_fields from if_identity_definition=>gc_field_dbms_user_dbms_user transporting no fields.
    if sy-subrc = 0.
      if ms_segment_dbms_user-before_image-dbms_user is not initial and                   "mapping exist in DB (BEFORE_IMAGE)
         ms_segment_dbms_user-before_image-dbms_user <> ls_check_dbms_user-dbms_user and  "and we try to change it
         ls_check_dbms_user-dbms_user is not initial.
        clear: ls_msg.

        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUSR_DBMS'. ls_msg-msgno = '009'.
        if 1 = 0. message e009(susr_dbms). endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_dbms_user
            iv_field    = if_identity_definition=>gc_field_dbms_user_dbms_user
            is_msg      = ls_msg.
      endif.
    endif.

* --- Check values ------------------------------------------
* -> Check always complete node !
*
    call method check_dbms_user_internal
      exporting
        iv_bname        = ms_manager-bname
        it_check_fields = lt_change_fields
        io_msg_buffer   = go_msg_buffer
      changing
        cs_dbms_user    = ls_check_dbms_user.


* --- Move values to segements -------------------------------
*
    ms_segment_dbms_user-actual-mandt      = sy-mandt.
    ms_segment_dbms_user-actual-bname      = ms_manager-bname.
    ms_segment_dbms_user-actual-dbms_user  = ls_check_dbms_user-dbms_user.

    if ms_segment_dbms_user-actual-dbms_user <> ms_segment_dbms_user-dbms_user_data_before-user_name.
      "DBMS User was assigned -> Read DMBS User Data from DB
      clear: ms_segment_dbms_user-dbms_user_data_actual, ms_segment_dbms_user-dbms_user_data_before.
      ms_segment_dbms_user-dbms_user_data_actual-user_name = ms_segment_dbms_user-actual-dbms_user.
      ms_segment_dbms_user-dbms_user_data_before-user_name = ms_segment_dbms_user-actual-dbms_user.

      cl_suid_dbms=>dbms_user_data_read(
        exporting
          iv_dbms_user      = ms_segment_dbms_user-actual-dbms_user
        importing
          et_dbms_roles     = ms_segment_dbms_user-dbms_roles_actual
          es_dbms_user_data = ms_segment_dbms_user-dbms_user_data_actual
      ).
      ms_segment_dbms_user-dbms_user_data_before = ms_segment_dbms_user-dbms_user_data_actual.
      ms_segment_dbms_user-dbms_roles_before    = ms_segment_dbms_user-dbms_roles_actual.
    else.
      move-corresponding ls_check_dbms_user to ms_segment_dbms_user-dbms_user_data_actual.
      ms_segment_dbms_user-dbms_user_data_actual-password  = ls_old_dbms_user-password.
    endif.

    if ls_check_dbms_user-password is not initial.
      ms_segment_dbms_user-dbms_user_data_actual-password = ls_check_dbms_user-password.
    endif.


* --- Transaction handling ---------------------------------
*

* Notification
    if ls_check_dbms_user <> ls_old_dbms_user.
      call method go_notify->notify_update
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_dbms_user
*         iv_key      = ls_check_dbms_user-dbms_user
        .
    endif.

* New transaction status: UNCHECKED
    ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check status:
    call method go_msg_buffer->find_error_for_node
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_dbms_user
      receiving
        ev_error    = data(lv_error).

    if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
      ms_manager-sn_dbms_user = go_persistence->co_node_status_checked.
    else.                     "  New node status: CHANGED
      ms_manager-sn_dbms_user = go_persistence->co_node_status_changed.
    endif.

* Set segment change flag
    if    ms_segment_dbms_user-actual ne ms_segment_dbms_user-before_image  "DBMS User assignment was changed
       or ms_segment_dbms_user-dbms_user_data_actual ne ms_segment_dbms_user-dbms_user_data_before "DBMS User data was changed
       or ms_segment_dbms_user-dbms_roles_actual ne ms_segment_dbms_user-dbms_roles_before "DBMS-roles was changed
       or ( ms_segment_dbms_user-dbms_user_data_actual-user_id   is initial and
            ms_segment_dbms_user-dbms_user_data_actual-user_name is not initial ). "DBMS user does not exist and to be created

      ms_segment_dbms_user-status = go_persistence->co_seg_changed.

    else.
      clear: ms_segment_dbms_user-status.
    endif.

  endmethod.


method if_identity_esi_person~delete_organization_assignment.

  "Call methods of interface IF_IDENTITY_ESI_PERSON only in BP or ESI trx
  if cl_identity_factory=>check_identity_model( ) = abap_false or
     ms_segment_address-actadd-trx_with_bp eq co_trx_user.
    macro_raise_internal_error.
  endif.

  ms_segment_address-actadd-trx_with_bp = co_trx_bp.

  call method me->if_identity_person~delete_organization_assignment
    importing
      eo_msg_buffer = eo_msg_buffer
      eo_notify     = eo_notify.

endmethod.


method if_identity_esi_person~delete_person_assignment.

  " Call methods of interface IF_IDENTITY_ESI_PERSON only in BP or ESI trx
  if cl_identity_factory=>check_identity_model( ) = abap_false or
     ms_segment_address-actadd-trx_with_bp eq co_trx_user.
    macro_raise_internal_error.
  endif.

  ms_segment_address-actadd-trx_with_bp = co_trx_bp.

  call method me->if_identity_person~delete_person_assignment
    importing
      eo_msg_buffer = eo_msg_buffer
      eo_notify     = eo_notify.

endmethod.


method if_identity_esi_person~get_organization.

  clear: es_organization.

* Call methods of interface IF_IDENTITY_ESI_PERSON only in BP or ESI trx
  if ms_segment_address-actadd-trx_with_bp eq co_trx_user.
    macro_raise_internal_error.
  endif.
  ms_segment_address-actadd-trx_with_bp = co_trx_bp.


  call method me->if_identity_person~get_organization
    exporting
      iv_request_before_image  = iv_request_before_image
      iv_get_location          = space
      iv_get_organization_name = space
    importing
      es_organization          = es_organization
      eo_msg_buffer            = eo_msg_buffer.


endmethod.


method if_identity_esi_person~get_person.

  clear: es_person.

* Call methods of interface IF_IDENTITY_ESI_PERSON only in BP or ESI trx
  if ms_segment_address-actadd-trx_with_bp eq co_trx_user.
    macro_raise_internal_error.
  endif.
  ms_segment_address-actadd-trx_with_bp = co_trx_bp.


  call method me->if_identity_person~get_person
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      es_person               = es_person
      eo_msg_buffer           = eo_msg_buffer.


endmethod.


method if_identity_esi_person~set_organization.

  " Call methods of interface IF_IDENTITY_ESI_PERSON only in BP or ESI trx
  if cl_identity_factory=>check_identity_model( ) = abap_false or
     ms_segment_address-actadd-trx_with_bp eq co_trx_user.
    macro_raise_internal_error.
  endif.

  ms_segment_address-actadd-trx_with_bp = co_trx_bp.

  " Only organization can be assigned
  if is_organization-orgtype eq if_identity=>co_company or
     is_organization-company is not initial.
    macro_raise_internal_error.
  endif.

  call method me->if_identity_person~set_organization
    exporting
      is_organization = is_organization
    importing
      eo_msg_buffer   = eo_msg_buffer
      eo_notify       = eo_notify.

endmethod.


method if_identity_esi_person~set_person.

  clear: es_person.

  " Call methods of interface IF_IDENTITY_ESI_PERSON only in BP or ESI trx
  if cl_identity_factory=>check_identity_model( ) = abap_false or
     ms_segment_address-actadd-trx_with_bp eq co_trx_user.
    macro_raise_internal_error.
  endif.

  ms_segment_address-actadd-trx_with_bp = co_trx_bp.

  call method me->if_identity_person~set_person
    exporting
      is_person     = is_person
      iv_newperson  = space
    importing
      eo_msg_buffer = eo_msg_buffer
      eo_notify     = eo_notify
      es_person     = es_person.

endmethod.


method if_identity_password~get_password_hash.
* Read node information for password hash

  data: ls_msg type symsg
      .

  clear: es_node_pwdhash.

  eo_msg_buffer = go_msg_buffer.


  " Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_pwdhash "password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    clear: es_node_pwdhash.
    return.
  endif.

  " Read password hash, only in display mode allowed
  if ms_manager-modus eq go_persistence->co_ta_modus_display.
    call method me->get_password_hash
      importing
        es_node_pwdhash = es_node_pwdhash
        eo_msg_buffer   = eo_msg_buffer.
  endif.

endmethod.


method if_identity_password~get_password_state.

  data: ls_msg         type symsg
      , lv_msgarea     type sy-msgid
      , lv_msgno       type sy-msgno
      , lv_pwdstate    type xupwdstate
      , ls_logondata   type suid_st_node_logondata
      .


  clear: ev_password_state
        ,ev_password_active
        ,ev_password_logon
        ,ev_pwd_lastchanged_date
        ,ev_pwd_lastlogin_date
        ,ev_pwd_set_date
        ,ev_old_rule_switch_allowed
        .

  eo_msg_buffer = go_msg_buffer.

  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

  " ev_old_rule_switch_allowed - allowed for users of "service" and "system" types
  " Needed for SU01 to get usertype w.o. calling get_logondata with authority-check
  "(note 1529805 and 1365205)
  me->get_logondata(
    importing
      es_logondata = ls_logondata
  ).
  if ls_logondata-ustyp = co_usertype_system or
     ls_logondata-ustyp = co_usertype_service.
    ev_old_rule_switch_allowed = 'X'.
  endif.

  " Return password state: 'P' for productive password
  "                        'I' for initial password
  if ms_segment_header-actual-pwdinitial = if_identity=>co_pwdinitial_initial.
    ev_password_state = if_identity=>co_password_initial.
  elseif ms_segment_header-actual-pwdinitial = if_identity=>co_pwdinitial_productive.
    ev_password_state = if_identity=>co_password_productive.
  else.
    " Fallback, if PWDINITIAL is not filled so far
    if ms_segment_header-actual-codvn is not initial.
      if ms_segment_header-actual-ltime is initial.
        ev_password_state = if_identity=>co_password_initial.
      else.
        ev_password_state = if_identity=>co_password_productive.
      endif.
    endif.
  endif.

  " Overwrite password state for System and Service user
  if ev_password_state                   eq if_identity=>co_password_initial and
   ( ms_segment_header-actual-ustyp      eq co_usertype_system  or
     ms_segment_header-actual-ustyp      eq co_usertype_service ).
    ev_password_state = if_identity=>co_password_productive.
  endif.

  " Return whether password is deactivated (Code version 'X'):
  if ms_segment_header-actual-codvn eq if_identity=>co_password_inactive. " or
    "ms_segment_header-actual-ustyp eq co_usertype_reference.
    ev_password_active = if_identity=>co_password_deactivated.
    clear: ev_password_state.
  else.
    ev_password_active = if_identity=>co_password_active.
  endif.

  " Return Password last changed date:
  ev_pwd_lastchanged_date = ms_segment_header-actual-pwdchgdate.

  " Return Password last login date:
  ev_pwd_lastlogin_date = ms_segment_header-actual-pwdlgndate.

  " Return Password set date:
  ev_pwd_set_date = ms_segment_header-actual-pwdsetdate.



  " Check, if password logon is possible
  call 'PASSWORD' id 'OPCODE'    field 'S'
                  id 'USR02'     field ms_segment_header-actual
                  id 'MSGAREA'   field lv_msgarea
                  id 'MSGNO'     field lv_msgno
                  id 'PASSFLAG'  field lv_pwdstate.       "#EC CI_CCALL

  if sy-subrc eq 0 and lv_pwdstate eq -3.

    case lv_msgno.
      when '139'.                " password logon disabled (via profile parameter)
        ev_password_logon = 'P'. " -> Kennwortanmeldung generell nicht möglich
      when '200'.                " password lock active / too many failed attempts
        ev_password_logon = 'F'. " -> Benutzer gesperrt durch Falschanmeldung
      when '182'.                " idle usage of initial password beyond treshold
        ev_password_logon = 'I'. " -> Kennwort deaktiviert (Initialkennwort ist abgelaufen)
      when '790'.                " idle usage of productive password beyond treshold
        ev_password_logon = 'K'. " -> Kennwort deaktiviert (Produktivkennwort ist abgelaufen)
    endcase.

  endif.


* Returnvalues of c-call
*
* SY-SUBRC = -1 indicates an invalid parameter usage (missing / wrong type)
* SY-SUBRC = -2 means 'unknown opcode'
*
* PASSFLAG is used to return the result of the analysis.
* In addition, MSGAREA and MSGNO will be filled (if provided)
* PASSFLAG | MSGAREA | MSGNO | comment                                              | init./prod.
* ---------+---------+-------+------------------------------------------------------+-------------
*   -5     | n/a     | n/a   | user not found                                       | n/a
*   -4     | 00      | 198   | user has no password (CODVN=X) or REFERENCE user     | n/a
* ---------+---------+-------+------------------------------------------------------+-------------
**  -3     | 00      | 139   | password logon disabled (via profile parameter)      | no statement
**  -3     | 00      | 200   | password lock active / too many failed attempts      | no statement
**  -3     | 00      | 182   | idle usage of initial password beyond threshold      | initial
**  -3     | 00      | 790   | idle usage of productive password beyond threshold   | productive
* ---------+---------+-------+------------------------------------------------------+-------------
*   -2     | n/a     | n/a   | password cannot be changed (SERVICE / SYSTEM user)   | productive
*   -1     | n/a     | n/a   | password cannot be changed (due to waittime, # days) | productive
*    0     | n/a     | n/a   | password change possible but not required            | productive
*    1     | n/a     | n/a   | password change required (initial password)          | initial
*    2     | n/a     | n/a   | password change required (regular change)            | productive
*    3     | n/a     | n/a   | password change required (stricter password rules)   | productive



endmethod.


method if_identity_password~password_deactivate.

  data: ls_pwd_new            type suid_st_node_pwdhash
       ,lv_no_maintain        type sesf_boolean
       ,ls_msg                type symsg
       .

  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S' " Call from SET method
      iv_change_node = if_identity_definition=>gc_node_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.


  " Delete messages for node (concerns BCODE, CODVN, PASSCODE)
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Check if node can be maintained
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_password
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

    " Node can't be maintained: do not proceed
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.

  " Prepare to be able to track any changes
  clear: ls_pwd_new. ", ls_pwd_old.  " be careful not to have any relics
  " Only the fields for password hash and code version are looked at here
  ls_pwd_new-codvn = if_identity=>co_password_inactive.

  " Fields LTIME and PWDINITIAL are not changed

  "  Old and new content of password may be identical:
  "  - Initial password is not checked against history
  "  - AND password change date must be update due to admin action
  "    even if same password information (as in database) is entered
  "  - The latter takes place in method PREPARE_INTERNAL_SEGMENTS
  "      and is performed due to node status = 'Checked'
  "

  call method if_identity_password~set_password_hash
    exporting
      is_node_pwdhash = ls_pwd_new
    importing
      eo_msg_buffer   = eo_msg_buffer
      eo_notify       = eo_notify.

  " Reset "User locked due to incorrect logon"
  if 1 = 0.
    data: ls_lockscope  type suid_st_lockscope.
    ls_lockscope-flg_lockscope_wrong_logon = 'X'.
    if_identity~action_unlock( is_lockscope = ls_lockscope ).
    "if_identity=>co_lockscope_wrong_logon ).
  endif.
  " -> This will also send IDOCs.....


endmethod.


method if_identity_password~password_generate.

  data: ls_msg                type symsg
       ,lv_generated_password type xubcode
       ,lv_sec_policy         type usr02-security_policy
       .


  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* Get Security Policy
  move ms_segment_header-actual-security_policy to lv_sec_policy.

* Any authorization checks etc. are done in the called SET method below
  " Change from deprecated RSEC_... to actual SUSR_... Function module
  call function 'SUSR_GENERATE_PASSWORD' "'RSEC_GENERATE_PASSWORD'
    exporting
*     alphabet             = space " Note 631196
      downwards_compatible = iv_downward_comp
      security_policy      = lv_sec_policy
    importing
      password             = lv_generated_password
    exceptions
      generator_error      = 1
      others               = 2.
  if sy-subrc <> 0.
    clear ls_msg.
    ls_msg-msgid = sy-msgid.
    ls_msg-msgty = sy-msgty.
    ls_msg-msgno = sy-msgno.
    ls_msg-msgv1 = sy-msgv1.
    ls_msg-msgv2 = sy-msgv2.
    ls_msg-msgv3 = sy-msgv3.
    ls_msg-msgv4 = sy-msgv4.

    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_password
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.
  ev_generated_password = lv_generated_password.

  if ev_generated_password is not initial
    and iv_return_pwd_only is initial.
    " Take over the generated password
    call method if_identity_password~set_password
      exporting
        iv_pwdplain   = ev_generated_password
      importing
        eo_msg_buffer = eo_msg_buffer
        eo_notify     = eo_notify.

    if iv_create_message eq if_identity=>co_true.
      " Add message with generated password
      clear ls_msg.
      if iv_password_in_message eq if_identity=>co_true.
        ls_msg-msgty = eo_msg_buffer->co_type_info.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '094'.
        ls_msg-msgv1 = ms_manager-bname.
        ls_msg-msgv2 = ev_generated_password.
        if 1 = 0. message i094(01) with ls_msg-msgv1 ls_msg-msgv2. endif.
      else.
        ls_msg-msgty = eo_msg_buffer->co_type_info.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '275'.
        if 1 = 0. message i275(01). endif.
      endif.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
    endif.
  endif.


endmethod.


method if_identity_password~set_password.
*--------------------------------------------------------------------*
* Receive plain text password that is converted to hash value

* Node checks, messages and notifications refer to node PASSWORD
*--------------------------------------------------------------------*
* ...
*--------------------------------------------------------------------*
  data: ls_pwd_new         type suid_st_node_pwdhash
      , ls_msg             type symsg
      , lv_error           type abap_bool
      , lv_no_maintain     type sesf_boolean
      , lv_self_register   type sesf_boolean
      , lv_productive_pwd  type sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S' " Call from SET method
      iv_change_node = if_identity_definition=>gc_node_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all messages for the node (concerns BCODE/PASSCODE/CODVN)
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Check CUA maintenance
  " Password has one field attribute for all fields
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_password
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.
    " Password maintenance is not allowed by SCUM settings --> return to caller
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.

  " Prepare to be able to track any changes
  clear: ls_pwd_new.
  " Only the fields for password hash and code version are looked at here

  if iv_pwdplain is not initial.

    " Self-register only permitted in Create mode!
    if iv_self_register is not initial                        and
       ms_manager-modus eq go_persistence->co_ta_modus_create.
      lv_self_register = if_identity=>co_true.
    else.
      lv_self_register = if_identity=>co_false.
    endif.

    " Set Productive password. Similar to IV_SELF_REGISTER,
    " but valid for change mode and requires additional checks.
    clear lv_productive_pwd.
    if iv_productive_pwd is not initial.
      " get logon->group information in order to call authority check
      data lv_class type usr02-class.
      call method me->get_class
        exporting
          iv_for_auth = if_identity=>co_true
        importing
          ev_class    = lv_class.
      " Check a new authorization (set productive password)
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_password
          iv_operation = cl_suid_tools=>co_activity_set_productive
          iv_class     = lv_class
          iv_bname     = ms_manager-bname
        importing
          es_msg       = ls_msg.
      if ls_msg-msgty <> 'E'.
        " Check that logon was with SNC
        constants session_info type x value 2.
        data auth_type         type xuauthmethod.
        call 'LOGIN_INFO' id 'OPCODE'    field session_info
                          id 'AUTH_TYPE' field auth_type. "#EC CI_CCALL
        if auth_type = 'S'. "this session was personalized using SNC authentication
          " possible values: 'S' (SNC),
          "                  'P' (Password),
          "                  'X' (X.509 client certificate authentication),
          "                  'E' (External, SAML)
          lv_productive_pwd = if_identity=>co_true.
        endif.
      endif.

    endif.

    call method password_convert_to_hash
      exporting
        iv_pwdplain       = iv_pwdplain
        iv_self_register  = lv_self_register
        iv_productive_pwd = lv_productive_pwd
      importing
        ev_pwdhash        = ls_pwd_new.

    if ls_pwd_new        is not initial          and "password hash is created
       iv_productive_pwd is not initial          and " method call to set productive pwd..
       lv_productive_pwd = if_identity=>co_false.    "..but it is not allowed (Auth. or SNC)

      " if it is not possible to set productive password we try to set initial and then
      "   display message:
      ls_msg-msgid = 'SUID01'.
      ls_msg-msgno = '041'.
      ls_msg-msgv1 = ms_manager-bname.

      " Set msg type to 'W' because initial password is set and saved
      ls_msg-msgty = if_suid_msg_buffer=>co_type_warning.
      if 1 = 0. message w041(suid01) with ls_msg-msgv1. endif. "#EC *
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.
    endif.
  else.
    clear: ls_msg.
    ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
    ls_msg-msgid = '01'.
    ls_msg-msgno = '290'.
    " Please enter an initial password
    if 1 = 0. message e290(01). endif.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_password
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.
    return.
  endif.

  " if all four fields are initial, something went wrong
  "  ==> don't take over the data. Message buffer contains error message
  check: ls_pwd_new-bcode         is not initial
      or ls_pwd_new-codvn         is not initial
      or ls_pwd_new-passcode      is not initial
      or ls_pwd_new-pwdsaltedhash is not initial
      .

  " Perform node checks
  "
  "  Old and new content of password may be identical:
  "  - Initial password is not checked against history
  "  - AND password change date must be update due to admin action
  "    even if same password information (as in database) is entered
  "  - The latter takes place in method PREPARE_INTERNAL_SEGMENTS
  "      and is performed due to node status = 'Checked'
  "
  call method go_notify->notify_update  " Notification
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  ms_segment_header-actual-bcode         = ls_pwd_new-bcode.
  ms_segment_header-actual-passcode      = ls_pwd_new-passcode.
  ms_segment_header-actual-codvn         = ls_pwd_new-codvn.
  ms_segment_header-actual-pwdsaltedhash = ls_pwd_new-pwdsaltedhash.
  ms_segment_header-actual-pwdlgndate    = ls_pwd_new-pwdlgndate.
  ms_segment_header-actual-pwdinitial    = ls_pwd_new-pwdinitial.
  " Remember initial password
  if ls_pwd_new-pwdinitial eq if_identity=>co_pwdinitial_initial.
    ms_segment_header-initial_password   = iv_pwdplain.
  else.
    clear: ms_segment_header-initial_password.
  endif.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_password = go_persistence->co_node_status_checked.
  else.                                  "  New node status: CHANGED
    ms_manager-sn_password = go_persistence->co_node_status_changed.
  endif.

  " Set segment status to Changed - even if no real change was performed
  "   --> needed for correct setting of PWDCHGDATE/PWDSETDATE!
  ms_segment_header-status = go_persistence->co_seg_changed.

endmethod.


method if_identity_password~set_password_hash.
* Receive hash value for password
*   make checks for compatibility - old and new code version

* Node checks, messages and notifications refer to node PASSWORD

  data: ls_pwdhash_new        type suid_st_node_pwdhash
       ,lv_pwd_error          type char01   " Flag for error message
       ,lv_password_only_new  type char01
       ,ls_msg                type symsg
       ,lv_rc                 type sy-subrc
       ,lv_error              type sesf_boolean
       ,lv_no_maintain        type sesf_boolean
       .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S' " Call from SET method
      iv_change_node = if_identity_definition=>gc_node_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all messages for the node (concerns BCODE/PASSCODE/CODVN)
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.


  " Check CUA maintenance
  " Password has one field attribute for all fields
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_pwdhash
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.
    " Password maintenance is not allowed by SCUM settings --> return to caller
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.


  " Only the fields for password hash and code version are looked at here
  " In contrast to other SET methods, always ALL fields must be informed!
  clear: ls_pwdhash_new.
  ls_pwdhash_new = is_node_pwdhash.

  " Default: Raises error message: Password is initial
  lv_pwd_error = if_identity=>co_true.


  " ---- Check password hash values -------------------------------------

  " Check compatibility of old password - old style allowed? (policy)
  call function 'GET_PASSWORD_COMPATIBILITY'
    importing
      only_new_style = lv_password_only_new.

  case ls_pwdhash_new-codvn.
    when if_identity=>co_password_codeversion_a
      or if_identity=>co_password_codeversion_b
      or if_identity=>co_password_codeversion_d
      or if_identity=>co_password_codeversion_e
      or if_identity=>co_password_codeversion_f
      or if_identity=>co_password_codeversion_g
      .
      " Only NEW style password allowed: Clear password hash
      if lv_password_only_new = go_persistence->co_flag_active.

        " Deactivate password
        clear: ls_pwdhash_new-bcode
              ,ls_pwdhash_new-passcode
              ,ls_pwdhash_new-pwdsaltedhash
              ,ls_msg.
        ls_pwdhash_new-codvn = if_identity=>co_password_inactive.

        ls_msg-msgty         = if_suid_msg_buffer=>co_type_warning.
        ls_msg-msgno         = '419'.
        ls_msg-msgid         = '01'.
        " Password hash is rejected; password is deactivated
        if 1 = 0. message w419(01). endif.
        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_password
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = ls_msg.

        lv_pwd_error = if_identity=>co_false. " Pwd is deactivated, no error

      else.
        case ls_pwdhash_new-codvn.
          when if_identity=>co_password_codeversion_f.
            if ls_pwdhash_new-passcode is not initial.
              lv_pwd_error = if_identity=>co_false.
            endif.
          when if_identity=>co_password_codeversion_g.
            if    ls_pwdhash_new-passcode is not initial
              and ls_pwdhash_new-bcode    is not initial.
              lv_pwd_error = if_identity=>co_false.
            endif.
          when others.
            if   ls_pwdhash_new-bcode    is not initial.
              lv_pwd_error = if_identity=>co_false. " Password is not empty
            endif.
        endcase.
      endif.

    when if_identity=>co_password_codeversion_h.
      if ls_pwdhash_new-pwdsaltedhash is not initial.
        lv_pwd_error = if_identity=>co_false.
      endif.
    when if_identity=>co_password_codeversion_i.
      if    ls_pwdhash_new-pwdsaltedhash is not initial
        and ls_pwdhash_new-passcode      is not initial
        and ls_pwdhash_new-bcode         is not initial
        .
        lv_pwd_error = if_identity=>co_false.
      endif.
      " Check whether code version must be mapped
      if lv_password_only_new = go_persistence->co_flag_active.
        clear: ls_pwdhash_new-bcode,
               ls_pwdhash_new-passcode.
        ls_pwdhash_new-codvn = if_identity=>co_password_codeversion_h.
      endif.
    when if_identity=>co_password_inactive.
      if    ls_pwdhash_new-passcode      is initial
        and ls_pwdhash_new-pwdsaltedhash is initial
        and ls_pwdhash_new-bcode         is initial
        .
        lv_pwd_error = if_identity=>co_false. " Pwd is initial, no error
      endif.
  endcase.


  " Check Salted Hash, if supported by kernel
  clear: lv_rc, ls_msg.
  if lv_pwd_error eq if_identity=>co_false and
    ( ls_pwdhash_new-codvn eq if_identity=>co_password_codeversion_h or
      ls_pwdhash_new-codvn eq if_identity=>co_password_codeversion_i ).

    call function 'CHECK_PWDHASHSTRING_SUPPORTED'
      exporting
        pwdsaltedhash = ls_pwdhash_new-pwdsaltedhash
      importing
        ev_rc         = lv_rc
        es_msg        = ls_msg.

    if lv_rc ne 0.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.

      " Stop processing
      return.
    endif.
  endif.


  " Check pwd status
  if lv_pwd_error = if_identity=>co_true. " Password is initial
    clear ls_msg.
    " Please enter an initial password
    if 1 = 0. message e290(01). endif.
    ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
    ls_msg-msgid = '01'.
    ls_msg-msgno = '290'.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_password
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
        is_msg      = ls_msg.

    " Stop processing
    return.
  endif.


  " Everything ok: Fill relevant fields of header segment
  clear ls_pwdhash_new-pwdlgndate.

  " Password set by admin --> Initial, In CREATE mode also productive allowed
  if ls_pwdhash_new-pwdinitial eq if_identity=>co_pwdinitial_productive and
     ms_manager-modus          eq go_persistence->co_ta_modus_create.
    ls_pwdhash_new-pwdinitial = if_identity=>co_pwdinitial_productive.

  elseif ls_pwdhash_new-pwdinitial eq if_identity=>co_pwdinitial_productive and
         ms_manager-modus          eq go_persistence->co_ta_modus_modify    and
         gv_idoc_processing        eq if_identity=>co_true                  and
         mv_cua_mode               eq co_cua_reserved.
    "special handling of creation of users via IDoc in child systems if an
    "role- or profile assign IDoc was processed before:
    ls_pwdhash_new-pwdinitial = if_identity=>co_pwdinitial_productive.

  else.
    ls_pwdhash_new-pwdinitial = if_identity=>co_pwdinitial_initial.
  endif.


  " Write Notification
  "
  "  Old and new content of password may be identical:
  "  - Initial password is not checked against history
  "  - AND password change date must be update due to admin action
  "    even if same password information (as in database) is entered
  "  - The latter takes place in method PREPARE_INTERNAL_SEGMENTS
  "      and is performed due to node status = 'Checked'
  "
  call method go_notify->notify_update
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Take over changes
  ms_segment_header-actual-bcode         = ls_pwdhash_new-bcode.
  ms_segment_header-actual-passcode      = ls_pwdhash_new-passcode.
  ms_segment_header-actual-codvn         = ls_pwdhash_new-codvn.
  ms_segment_header-actual-pwdsaltedhash = ls_pwdhash_new-pwdsaltedhash.
  ms_segment_header-actual-pwdlgndate    = ls_pwdhash_new-pwdlgndate.
  ms_segment_header-actual-pwdinitial    = ls_pwdhash_new-pwdinitial.
  clear: ms_segment_header-initial_password.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_password = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_password = go_persistence->co_node_status_changed.
  endif.

  " Set segment status to Changed
  ms_segment_header-status = go_persistence->co_seg_changed.

endmethod.


method if_identity_password~set_password_to_initial.

  data: lv_error          type abap_bool
       ,lv_pwdinitial_new type xupwdinit
       ,ls_msg            type symsg
       ,lv_no_maintain    type sesf_boolean
       .

  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'  " Call from SET method
      iv_change_node = if_identity_definition=>gc_node_password
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete messages for node (concerns PWDINITIAL, PWDLGNDATE, PWDCHGDATE)
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Delete all notifications for the node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password.

  " Check if node can be maintained
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_password
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

    " Node can't be maintained: do not proceed
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.

  " Valid Password
  if ms_segment_header-actual-passcode      is initial and
     ms_segment_header-actual-bcode         is initial and
     ms_segment_header-actual-pwdsaltedhash is initial.
    return.
  endif.

  lv_pwdinitial_new = if_identity=>co_pwdinitial_initial.
  " Field LTIME will be cleared in method PREPARE_INTERNAL_SEGMENTS

  " Write Notification
  if ms_segment_header-actual-pwdinitial <> lv_pwdinitial_new.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_password.
    " Take over changes
    ms_segment_header-actual-pwdinitial = lv_pwdinitial_new.
  endif.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_password
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_password = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_password = go_persistence->co_node_status_changed.
  endif.

  " Set segment status to Changed
  if ms_segment_header-actual <> ms_segment_header-before_image.
    ms_segment_header-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.

endmethod.


method if_identity_password~set_password_to_productive.

* This method can be deleted
  return.


*  data: ls_msg type symsg
*       ,lv_error type abap_bool
*       ,lv_pwdinitial_new type xupwdinit
*       ,lv_no_maintain    type sesf_boolean
*       .
*
*  eo_msg_buffer = go_msg_buffer.
*  eo_notify     = go_notify.
*
*
** Set values only in CREATE or CHANGE mode
*  call method checks_before_access
*    exporting
*      iv_method      = 'S' " Call from SET method
*      iv_change_node = if_identity_definition=>gc_node_password
*    importing
*      es_msg         = ls_msg.
*
*  if ls_msg-msgty = 'E'.
**   Return to caller
*    return.
*  endif.
*
*
** Delete messages for node (concerns PWDINITIAL, PWDLGNDATE, PWDCHGDATE)
*  call method go_msg_buffer->delete_object_message
*    exporting
*      iv_bname    = ms_manager-bname
*      iv_nodename = if_identity_definition=>gc_node_password.
*
** Delete all notifications for the node
*  call method go_notify->delete_notifications
*    exporting
*      iv_bname    = ms_manager-bname
*      iv_nodename = if_identity_definition=>gc_node_password.
*
** Check if node can be maintained
*  if gv_cua_child = if_identity=>co_true.
*    call method cua_if_field_no_maintain
*      exporting
*        iv_node_name   = if_identity_definition=>gc_node_password
*        io_msg_buffer  = go_msg_buffer
*      receiving
*        rv_no_maintain = lv_no_maintain.
*
**   Node can't be maintained: do not proceed
*    if lv_no_maintain = if_identity=>co_true.
*      return.
*    endif.
*  endif.
*
*
*  lv_pwdinitial_new = if_identity=>co_pwdinitial_productive.
** Field LTIME will be filled in method PREPARE_INTERNAL_SEGMENTS
*
** Password can only be set to productive if either BCODE or PASSCODE or PWDSALTEDHASH
**   and CODVN are filled.
*
*  lv_error = if_identity=>co_false. " no error
*
*  if ms_manager-modus ne go_persistence->co_ta_modus_create.
**   Only permitted in Create mode! Use case: Self-register
*    ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
*    ls_msg-msgno = '005'.
*    ls_msg-msgid = 'SUID01'.
**   Im Änderungsmodus kann kein Produktivkennwort gesetzt werden
*    if 1 = 0. message e005(suid01). endif.
*    call method go_msg_buffer->add_object_message_symsg
*      exporting
*        iv_bname    = ms_manager-bname
*        iv_nodename = if_identity_definition=>gc_node_password
*        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
*        is_msg      = ls_msg.
**   In this case no data is taken over
*    lv_error = if_identity=>co_true. " error occurred
*  elseif ms_segment_header-actual-codvn is initial.
**   Code version must be filled
*    ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
*    ls_msg-msgno = '290'.
*    ls_msg-msgid = '01'.
**   Please enter an initial password
*    if 1 = 0. message e290(01). endif.
*    call method go_msg_buffer->add_object_message_symsg
*      exporting
*        iv_bname    = ms_manager-bname
*        iv_nodename = if_identity_definition=>gc_node_password
*        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
*        is_msg      = ls_msg.
**   In this case no data is taken over
*    lv_error = if_identity=>co_true. " error occurred
*  else.
**   Either BOCDE or PASSCODE or PWDSALTEDHASH must be filled
*    if    ms_segment_header-actual-passcode      is initial
*      and ms_segment_header-actual-bcode         is initial
*      and ms_segment_header-actual-pwdsaltedhash is initial
*      .
*      ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
*      ls_msg-msgno = '290'.
*      ls_msg-msgid = '01'.
**     Please enter an initial password
*      if 1 = 0. message e290(01). endif.
*      call method go_msg_buffer->add_object_message_symsg
*        exporting
*          iv_bname    = ms_manager-bname
*          iv_nodename = if_identity_definition=>gc_node_password
*          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
*          is_msg      = ls_msg.
**     In this case no data is taken over
*      lv_error = if_identity=>co_true. " error occurred
*    endif.
*  endif.
*
*  if lv_error = if_identity=>co_false.  " no error issued in this method
**   Write Notification
*    if ms_segment_header-actual-pwdinitial <> lv_pwdinitial_new.
*      call method go_notify->notify_update
*        exporting
*          iv_bname    = ms_manager-bname
*          iv_nodename = if_identity_definition=>gc_node_password.
**     Take over changes
*      ms_segment_header-actual-pwdinitial = lv_pwdinitial_new.
*    endif.
*  endif.
*
** New transaction status: UNCHECKED
*  ms_manager-status = go_persistence->co_ta_status_unchecked.
*
*  clear: lv_error.
** Check status:
*  call method go_msg_buffer->find_error_for_node
*    exporting
*      iv_bname    = ms_manager-bname
*      iv_nodename = if_identity_definition=>gc_node_password
*    receiving
*      ev_error    = lv_error.
*
*  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
*    ms_manager-sn_password = go_persistence->co_node_status_checked.
*  else.                     "  New node status: CHANGED
*    ms_manager-sn_password = go_persistence->co_node_status_changed.
*  endif.
*
** Set segment status to Changed
*  if ms_segment_header-actual <> ms_segment_header-before_image.
*    ms_segment_header-status = go_persistence->co_seg_changed.
*  else.
*    clear: ms_segment_header-status.
*  endif.
endmethod.


method if_identity_person~delete_organization_assignment.

  data: ls_msg             type        symsg
      , lv_error           type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_organization
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.


  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  " Notifications are only valid for one roundtrip
  " Delete all notification
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).


  "------ Delete address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      " Delete old user "type 3" address
      " Check: Company assignment
      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
        " MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.

      try.
        addr_delete_address( ).
      catch cx_suid_identity.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
        " MSG: Schiefstand bei Adresse.
        if 1 = 0. message e022(01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endtry.

    "------ Person -------------------------------------
    when if_identity=>co_idad_person.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '013'.
      " MSG: Es ist keine Organisation zugeordnet.
      if 1 = 0. message e013(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Person-BPOrg-Rel is assigned --------------------------
    when if_identity=>co_idad_person_org_rela.
      " CHECK: Employee work address assignment can only be deleted in ESI trx
      if ms_segment_address-actadd-trx_with_bp ne co_trx_bp.
        macro_raise_internal_error.
      endif.

      " Delete organization assignment
      bp_delete_organization( ).

    "------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.
      " CHECK: Employee work address assignment can only be deleted in ESI trx
      if ms_segment_address-actadd-trx_with_bp ne co_trx_bp.
        macro_raise_internal_error.
      endif.

      " Delete Employee workplace address assignment
      call method bp_delete_employee_work_addr.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

* --- Transaction handling ---------------------------------

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.     " New node status: CHECKED
    ms_manager-sn_organization = go_persistence->co_node_status_checked.
  else.                                     " New node status: CHANGED
    ms_manager-sn_organization = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity_person~delete_person_assignment.

  data: ls_bup_cent          type        bup_s_cent_uuidkey_api
      , lt_bup_cent          type        bup_t_cent_uuidkey_api
      , lv_bup_rejected      type        boole_d
      , ls_msg               type        symsg
      , lv_error             type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_person
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  " Notifications are only valid for one roundtrip
  " Delete all notification
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).

  "------ Delete BP-Person assignment depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Person is assigned ----------------------------------
    when if_identity=>co_idad_person.

      if ms_segment_address-actadd-trx_with_bp ne co_trx_bp.
        macro_raise_internal_error.
      endif.

      if ms_segment_address-actual-bpperson is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
        " MSG: Es ist kein Geschäftspartner zugeordnet.
        if 1 = 0. message e011(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.

    "------ No Person assigned ----------------------------------
    when if_identity=>co_idad_olduser  or
         if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
      " MSG: Es ist kein Geschäftspartner zugeordnet.
      if 1 = 0. message e011(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Organization is assigned ----------------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '021'.
      " MSG: Löschen Sie zuerst die Zuordnung zur Organisation.
      if 1 = 0. message e021(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  " User or BP trx
  if ms_segment_address-actadd-trx_with_bp is initial.
    ms_segment_address-actadd-trx_with_bp = co_trx_user.
  endif.

  "------ Reset Modifications ----------------------------
  if ms_segment_address-actadd-changed_bp eq if_identity=>co_true.

    ls_bup_cent-partner_uuid = ms_segment_address-actual-bpperson.
    append ls_bup_cent to lt_bup_cent.

    cl_bup_transaction_partner_api=>reset_modifications(
      exporting
        it_keys            = lt_bup_cent
      importing
        ev_rejected        = lv_bup_rejected ).

    if lv_bup_rejected eq 'X'.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '050'.
      " MSG: Fehler beim Ändern des Geschäftspartners.
      if 1 = 0. message e050(suid01). endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endif.

    clear: ms_segment_address-actadd-changed_bp.
  endif.

  "--- Move values to segements -------------------------------
  move sy-mandt                     to ms_segment_address-actual-mandt.
  move ms_manager-bname             to ms_segment_address-actual-bname.
  move if_identity=>co_idad_person  to ms_segment_address-actual-idadtype.

  clear: ms_segment_address-actual-bpperson,
         ms_segment_address-actual-persnumber,
         ms_segment_address-actual-addrnumber,
         ms_segment_address-actual-organization,
         ms_segment_address-actadd-org_node_id.

* --- Transaction handling ---------------------------------

  " Notification:
  go_notify->notify_delete(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).

  " Delete all messages belonging to WORKPLACE
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).

  " Set node status of Person_Name
  clear: ms_manager-sn_person_name.

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  " New node status: CHECKED
    ms_manager-sn_person = go_persistence->co_node_status_checked.
  else.                                  " New node status: CHANGED
    ms_manager-sn_person = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity_person~get_communication_data.

  data: ls_msg             type    symsg
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_telephone,
         et_facsimile,
         et_email,
         et_web,
         et_telex,
         et_teletex,
         et_rml,
         et_x400,
         et_printer,
         et_ssf,
         et_pager.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_workplace
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg
      ).


  if ls_msg-msgty = 'E'.
    return.
  endif.


  call method me->get_communication_data
    exporting
      is_retrieve_commdata     = is_retrieve_commdata
      iv_retrieve_commdata_all = iv_retrieve_commdata_all
      iv_request_before_image  = iv_request_before_image
    importing
      eo_msg_buffer            = eo_msg_buffer
      et_telephone             = et_telephone
      et_facsimile             = et_facsimile
      et_email                 = et_email
      et_web                   = et_web
      et_telex                 = et_telex
      et_teletex               = et_teletex
      et_rml                   = et_rml
      et_x400                  = et_x400
      et_printer               = et_printer
      et_ssf                   = et_ssf
      et_pager                 = et_pager.


endmethod.


method if_identity_person~get_organization.

  data: ls_msg               type   symsg
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_organization, es_location, es_organization_name.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_organization
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg
      ).

  if ls_msg-msgty = 'E'.
    return.
  endif.


  call method me->get_organization
    exporting
      iv_get_location          = iv_get_location
      iv_get_organization_name = iv_get_organization_name
      iv_request_before_image  = iv_request_before_image
    importing
      es_organization          = es_organization
      eo_msg_buffer            = eo_msg_buffer
      es_location              = es_location
      es_organization_name     = es_organization_name.


endmethod.


method if_identity_person~get_person.

  data: ls_msg type symsg
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_person.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_person
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg
      ).

  if ls_msg-msgty = 'E'.
    return.
  endif.

* Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


* ------ Read before image ------------------------------------
  if iv_request_before_image is not initial.
    if ms_segment_address-before_image-bpperson is not initial.
      es_person-person_uuid = ms_segment_address-before_image-bpperson.
    endif.
    return.
  endif.


* ------ Read BP-Person depending on identity model -----------
*
  case ms_segment_address-actual-idadtype.

*...------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
*     MSG: Es ist kein Geschäftspartner zugeordnet.
      if 1 = 0. message e011(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Person is assigned ----------------------------------
    when if_identity=>co_idad_person          or
         if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

*     User or BP trx
      if ms_segment_address-actadd-trx_with_bp is initial.
        ms_segment_address-actadd-trx_with_bp = co_trx_user.
      endif.

      if ms_segment_address-actual-bpperson is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
*       MSG: Es ist kein Geschäftspartner zugeordnet.
        if 1 = 0. message e011(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person
            iv_enable   = if_identity=>co_false.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_false.

        return.
      else.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person
            iv_enable   = if_identity=>co_true.
        call method adbp_set_property_for_node
          exporting
            iv_nodename = if_identity_definition=>gc_node_person_name
            iv_enable   = if_identity=>co_true.
      endif.

      es_person-person_uuid = ms_segment_address-actual-bpperson.


*...------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
*     MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


endmethod.


method if_identity_person~get_personname.

  data: ls_msg type symsg
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_personname.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_person_name
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg
      ).

  if ls_msg-msgty = 'E'.
    return.
  endif.


  call method me->get_personname
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      es_personname           = es_personname
      eo_msg_buffer           = eo_msg_buffer.


endmethod.


method if_identity_person~get_workplacedata.

  data: ls_msg type symsg
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_workplace.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_workplace
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg
      ).
  if ls_msg-msgty = 'E'.
    return.
  endif.


  call method me->get_workplacedata
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      es_workplace            = es_workplace
      eo_msg_buffer           = eo_msg_buffer.


endmethod.


method if_identity_person~set_classical_address.


  data: ls_msg               type        symsg
      , ls_organization      type        suid_st_node_organization
      , lv_error             type        sesf_boolean
      , lv_org_node_id       type        addr_node_id
      , lv_reject_assignment type        sesf_boolean
      , ls_seg_add_sik       type        suid_st_segment_address
      , ls_personname        type        suid_st_node_person_name
      , lt_change_fields     type        suid_tt_fields
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_organization
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  "------ Create address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

      "------ Old User -----------------------------------------------
    when if_identity=>co_idad_olduser.
      " Conversion to classical type 3 address not necessary

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '027'.
      " MSG: Es ist bereits eine Firma zugeordnet.
      if 1 = 0. message e027(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      lv_reject_assignment = if_identity=>co_true.

      "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " CHECK: can not be changed in BP/ESI trx
      if ms_segment_address-actadd-trx_with_bp eq co_trx_bp.
        macro_raise_internal_error.
      endif.

      " Check: Person must NOT be assigned
      if ms_segment_address-actual-bpperson is not initial.

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '015'.
        " MSG: Es ist bereits ein Geschäftspartner zugeordnet.
        if 1 = 0. message e015(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      elseif is_organization-orgtype is not initial and
             is_organization-orgtype ne     if_identity=>co_company.
        " Check: Old users can only be assigned to companies

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '007'.
        " MSG: Ordnen Sie eine Firma zu
        if 1 = 0. message e007(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      else.
        " Check: Existence check of Company
        adbp_check_organization(
          exporting
            iv_bname             = ms_manager-bname
            iv_orgtype           = if_identity=>co_company
            is_organization      = is_organization
            io_msg_buffer        = go_msg_buffer
          importing
            es_organization      = ls_organization
            ev_org_node_id       = lv_org_node_id
            ev_reject_assignment = lv_reject_assignment ).

        if lv_reject_assignment eq if_identity=>co_false.
          " Backup
          ls_seg_add_sik = ms_segment_address.

          " Change IDADType
          ms_segment_address-actual-idadtype = if_identity=>co_idad_olduser.

          " Create old user "type 3" address
          addr_create_address( exporting is_organization      = ls_organization
                                         iv_org_node_id       = lv_org_node_id
                               importing ev_reject_assignment = lv_reject_assignment ).

          " Copy company timezone to default-timezone
          if lv_reject_assignment eq if_identity=>co_false.
            call method me->addr_adjust_timzone.

            " Add last name to address
            ls_personname-name_last = ms_manager-bname.
            append 'NAME_LAST' to lt_change_fields.
            call method set_personname
              exporting
                is_personname       = ls_personname
                it_change_fields    = lt_change_fields
                iv_ignore_cua_check = if_identity=>co_true.

          else.
            " Restore backup
            ms_segment_address = ls_seg_add_sik.
          endif.
        endif.

      endif.

      "------ Organization is already assigned -----------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      " Check: Company or Organization is already assigned
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '004'.
      " MSG: Es ist bereits eine Organisation zugeordnet.
      if 1 = 0. message e004(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      lv_reject_assignment = if_identity=>co_true.

      "------ Technical user --------------------------------------
    when if_identity=>co_idad_techuser.

      " Check: An organization can not be assigned to a technical user
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      lv_reject_assignment = if_identity=>co_true.

      "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


  "--- Errorhandling -----------------------------------------
  if lv_reject_assignment eq if_identity=>co_true.
    go_notify->notify_failed_create(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization ).

    return.
  else.
    go_notify->notify_create(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization ).
  endif.

* --- Transaction handling ---------------------------------

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  go_msg_buffer->find_error_for_node(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization
    receiving
      ev_error    = lv_error ).

  if lv_error eq if_identity=>co_false.       " New node status: CHECKED
    ms_manager-sn_organization = go_persistence->co_node_status_checked.
  else.                                       " New node status: CHANGED
    ms_manager-sn_organization = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity_person~set_communication_data.

  call method me->set_communication_data
    exporting
      it_telephone        = it_telephone
      it_facsimile        = it_facsimile
      it_email            = it_email
      it_web              = it_web
      it_telex            = it_telex
      it_teletex          = it_teletex
      it_rml              = it_rml
      it_x400             = it_x400
      it_printer          = it_printer
      it_ssf              = it_ssf
      it_pager            = it_pager
      is_current_state    = is_current_state
      iv_ignore_cua_check = if_identity=>co_false
    importing
      eo_msg_buffer       = eo_msg_buffer
      eo_notify           = eo_notify
      et_new_telephone_id = et_new_telephone_id
      et_new_facsimile_id = et_new_facsimile_id
      et_new_email_id     = et_new_email_id
      et_new_web_id       = et_new_web_id
      et_new_telex_id     = et_new_telex_id
      et_new_teletex_id   = et_new_teletex_id
      et_new_rml_id       = et_new_rml_id
      et_new_x400_id      = et_new_x400_id
      et_new_printer_id   = et_new_printer_id
      et_new_ssf_id       = et_new_ssf_id
      et_new_pager_id     = et_new_pager_id.

endmethod.


method if_identity_person~set_organization.

  data: ls_msg               type        symsg
      , ls_organization      type        suid_st_node_organization
      , lv_error             type        sesf_boolean
      , lv_org_node_id       type        addr_node_id
      , lv_reject_assignment type        sesf_boolean
      , lv_no_maintain       type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_organization
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization ).

  " Check SCUM settings in child system for old user type
  if gv_cua_child = if_identity=>co_true.
    if ms_segment_address-actual-idadtype = if_identity=>co_idad_olduser.
      cua_if_field_no_maintain(
        exporting
          iv_node_name      = if_identity_definition=>gc_node_organization
          iv_field_name     = if_identity_definition=>gc_field_organization_company
          io_msg_buffer     = go_msg_buffer
        receiving
          rv_no_maintain    = lv_no_maintain ).

      " Company address can't be maintained --> return to caller
      if lv_no_maintain = if_identity=>co_true.
        return.
      endif.
    endif.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  "------ Create address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old User -----------------------------------------------
    when if_identity=>co_idad_olduser.

      " Check: Company is already assigned
      if ms_segment_address-actual-addrnumber is not initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '027'.
        " MSG: Es ist bereits eine Firma zugeordnet.
        if 1 = 0. message e027(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      " Check: Old users can only be assigned to companies
      elseif is_organization-orgtype is not initial and
             is_organization-orgtype ne     if_identity=>co_company.

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '007'.
        " MSG: Ordnen Sie eine Firma zu
        if 1 = 0. message e007(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      else.

        " Check: Existence check of Company
        adbp_check_organization(
          exporting
            iv_bname             = ms_manager-bname
            iv_orgtype           = if_identity=>co_company
            is_organization      = is_organization
            io_msg_buffer        = go_msg_buffer
          importing
            es_organization      = ls_organization
            ev_org_node_id       = lv_org_node_id
            ev_reject_assignment = lv_reject_assignment ).

        if lv_reject_assignment eq if_identity=>co_false.

          " Create old user "type 3" address
          addr_create_address( exporting is_organization      = ls_organization
                                         iv_org_node_id       = lv_org_node_id
                               importing ev_reject_assignment = lv_reject_assignment ).

          " Copy company timezone to default-timezone
          if lv_reject_assignment eq if_identity=>co_false.
            call method me->addr_adjust_timzone.
          endif.
        endif.

      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      " CHECK: can only be assigned in ESI trx
      if ms_segment_address-actadd-trx_with_bp ne co_trx_bp.
        macro_raise_internal_error.
      endif.

      " Check: Person must be assigned
      if ms_segment_address-actual-bpperson is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '006'.
        " MSG: Ordnen Sie dem Benutzer zunächst einen Geschäftspartner zu.
        if 1 = 0. message e006(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      " Check: Only organization of type BP can be assigned
      elseif is_organization-orgtype ne if_identity=>co_bp_org and
             is_organization-orgtype ne if_identity=>co_bp_empl.

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '008'.
        " MSG: Ordnen Sie  eine Organisation zu
        if 1 = 0. message e008(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      else.
        if is_organization-orgtype eq if_identity=>co_bp_org.
          " Check: Existence check of BP-Organization
          adbp_check_organization(
            exporting
              iv_bname             = ms_manager-bname
              iv_orgtype           = if_identity=>co_bp_org
              is_organization      = is_organization
              io_msg_buffer        = go_msg_buffer
            importing
              es_organization      = ls_organization
              ev_org_node_id       = lv_org_node_id
              ev_reject_assignment = lv_reject_assignment ).

          if lv_reject_assignment eq if_identity=>co_false.
            " Assign BP-Org to BP-Person
            bp_set_organization( exporting is_organization      = ls_organization
                                           iv_org_node_id       = lv_org_node_id
                                 importing ev_reject_assignment = lv_reject_assignment ).
          endif.

        else.
          " Assign Employee work address
          bp_set_employee_work_addr( exporting is_organization      = is_organization
                                     importing ev_reject_assignment = lv_reject_assignment ).
        endif.

      endif.

    "------ Organization is already assigned -----------------------
    when if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      " Check: Company or Organization is already assigned
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '004'.
      " MSG: Es ist bereits eine Organisation zugeordnet.
      if 1 = 0. message e004(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      lv_reject_assignment = if_identity=>co_true.

    "------ Technical user --------------------------------------
    when if_identity=>co_idad_techuser.

      " Check: An organization can not be assigned to a technical user
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      lv_reject_assignment = if_identity=>co_true.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


  "--- Errorhandling -----------------------------------------
  if lv_reject_assignment eq if_identity=>co_true.
    go_notify->notify_failed_create(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization ).

    return.
  else.
    go_notify->notify_create(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_organization ).
  endif.

* --- Transaction handling ---------------------------------

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  go_msg_buffer->find_error_for_node(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_organization
    receiving
      ev_error    = lv_error ).

  if lv_error eq if_identity=>co_false.       " New node status: CHECKED
    ms_manager-sn_organization = go_persistence->co_node_status_checked.
  else.                                       " New node status: CHANGED
    ms_manager-sn_organization = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity_person~set_person.

  data: ls_msg               type        symsg
      , lv_error             type        sesf_boolean
      , lv_reject_assignment type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.
  clear: es_person.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_person
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  " Delete all notification
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).

  "------ Assign BP-Person depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      if ms_segment_address-actadd-trx_with_bp eq co_trx_bp.
        " Switch old user to person
        if iv_newperson is not initial.
          macro_raise_internal_error.
        endif.

        " Delete old address data ans SAP office
        adbp_delete( ).

        " Switch idadtype
        ms_segment_address-actual-idadtype = if_identity=>co_idad_person.

        " Assign Person
        bp_set_person(
          exporting
            is_person            = is_person
            iv_newperson         = iv_newperson
          importing
            ev_reject_assignment = lv_reject_assignment ).

      else.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '014'.
        " MSG: Zuordnen eines Geschäftspartners ist nicht möglich
        if 1 = 0. message e014(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.
      endif.

    "------ Person is assigned ----------------------------------
    when if_identity=>co_idad_person          or
         if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      " CHECK: can only be assigned in ESI trx
      if ms_segment_address-actadd-trx_with_bp ne co_trx_bp or
         iv_newperson is not initial.
        macro_raise_internal_error.
      endif.

      if ( ms_segment_address-actual-idadtype eq if_identity=>co_idad_person and
           ms_segment_address-actual-bpperson is not initial )                        or
           ms_segment_address-actual-idadtype eq if_identity=>co_idad_person_org_rela or
           ms_segment_address-actual-idadtype eq if_identity=>co_idad_employee.

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '015'.
        " MSG: Es ist bereits ein Geschäftspartner zugeordnet.
        if 1 = 0. message e015(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        lv_reject_assignment = if_identity=>co_true.

      else.
        " Assign Person
        bp_set_person(
          exporting
            is_person            = is_person
            iv_newperson         = iv_newperson
          importing
            ev_reject_assignment = lv_reject_assignment ).

      endif.

    "------ Technical user --------------------------------------
    when if_identity=>co_idad_techuser.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      lv_reject_assignment = if_identity=>co_true.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  "--- Errorhandling -----------------------------------------
  if lv_reject_assignment eq if_identity=>co_true.

    go_notify->notify_failed_create(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).

    return.
  endif.

  "--- Fill exporting parameter -------------------------------
  es_person-person_uuid = ms_segment_address-actual-bpperson.

* --- Transaction handling ---------------------------------

  " Notification
  go_notify->notify_create(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person ).

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  " New node status: CHECKED
    ms_manager-sn_person = go_persistence->co_node_status_checked.
  else.                                  " New node status: CHANGED
    ms_manager-sn_person = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity_person~set_personname.

  call method me->set_personname
    exporting
      is_personname       = is_personname
      it_change_fields    = it_change_fields
      iv_ignore_cua_check = if_identity=>co_false
    importing
      eo_msg_buffer       = eo_msg_buffer
      eo_notify           = eo_notify.

endmethod.


method if_identity_person~set_workplacedata.

  call method me->set_workplacedata
    exporting
      is_workplace        = is_workplace
      it_change_fields    = it_change_fields
      iv_ignore_cua_check = if_identity=>co_false
    importing
      eo_msg_buffer       = eo_msg_buffer
      eo_notify           = eo_notify.

endmethod.


method if_identity_person~switch_organization_assignment.

  data: ls_msg               type        symsg
      , ls_old_org           type        suid_st_node_organization
      , lv_error             type        sesf_boolean
      , ls_personname        type        suid_st_node_person_name
      , ls_workplace         type        suid_st_node_workplace
      , lt_telephone         type        addrt_telephone_number
      , lt_facsimile         type        addrt_facsimile_number
      , lt_email             type        addrt_email_address
      , lt_web               type        addrt_web_address
      , lt_telex             type        addrt_telex_number
      , lt_teletex           type        addrt_teletex_number
      , lt_rml               type        addrt_remote_mail_address
      , lt_x400              type        addrt_x400_address
      , lt_printer           type        addrt_printer
      , lt_ssf               type        addrt_ssf_address
      , lt_pager             type        addrt_pager_number
      , ls_current_state     type        bup_s_current_state_commdata
      , lv_no_maintain       type        sesf_boolean
      , lv_orgtype           type        suid_orgtype
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_organization
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check SCUM settings in child system for old user type
  if gv_cua_child = if_identity=>co_true.
    if ms_segment_address-actual-idadtype = if_identity=>co_idad_olduser.
      cua_if_field_no_maintain(
        exporting
          iv_node_name      = if_identity_definition=>gc_node_organization
          iv_field_name     = if_identity_definition=>gc_field_organization_company
          io_msg_buffer     = go_msg_buffer
        receiving
          rv_no_maintain    = lv_no_maintain ).

      " Company address can't be maintained --> return to caller
      if lv_no_maintain = if_identity=>co_true.
        return.
      endif.
    endif.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  "------ Switch organization assignment depending in Identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old user -----------------------------------------------
    when if_identity=>co_idad_olduser.

      " Read old company
      if_identity_person~get_organization(
        importing
          es_organization = ls_old_org ).

      if is_organization-company        eq ls_old_org-company        and
         is_organization-org_uuid       eq ls_old_org-org_uuid       and
         is_organization-orgtype        eq ls_old_org-orgtype.
        return.
      endif.

      " Check of idadtype
      if  is_organization-orgtype eq if_identity=>co_bp_org.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '007'.
        " MSG: Ordnen Sie eine Firma zu
        if 1 = 0. message e007(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.

      " Get orgtype for default org
      if is_organization-orgtype is initial.
        lv_orgtype = if_identity=>co_company.
      endif.

      " Check new company
      adbp_check_organization(
        exporting
          iv_bname             = ms_manager-bname
          is_organization      = is_organization
          iv_orgtype           = lv_orgtype
          io_msg_buffer        = go_msg_buffer
        importing
          ev_reject_assignment = lv_error ).
      if lv_error eq if_identity=>co_true.
        return.
      endif.

      " Read address data
      if_identity_person~get_personname(
        importing
          es_personname = ls_personname ).

      if_identity_person~get_workplacedata(
        importing
          es_workplace = ls_workplace ).

      if_identity_person~get_communication_data(
        exporting
          iv_retrieve_commdata_all = if_identity=>co_true
        importing
          eo_msg_buffer            = eo_msg_buffer
          et_telephone             = lt_telephone
          et_facsimile             = lt_facsimile
          et_email                 = lt_email
          et_web                   = lt_web
          et_telex                 = lt_telex
          et_teletex               = lt_teletex
          et_rml                   = lt_rml
          et_x400                  = lt_x400
          et_printer               = lt_printer
          et_ssf                   = lt_ssf
          et_pager                 = lt_pager ).

      " Delete organization assignment
      if_identity_person~delete_organization_assignment( ).

      " Set organization assignment
      if_identity_person~set_organization(
        exporting
          is_organization = is_organization ).

      " Write address data
      set_personname(
        exporting
          is_personname       = ls_personname
          iv_ignore_cua_check = if_identity=>co_true ).

      set_workplacedata(
        exporting
          is_workplace        = ls_workplace
          iv_ignore_cua_check = if_identity=>co_true ).

      clear: ls_current_state with 'X'.
      set_communication_data(
        exporting
          it_telephone        = lt_telephone
          it_facsimile        = lt_facsimile
          it_email            = lt_email
          it_web              = lt_web
          it_telex            = lt_telex
          it_teletex          = lt_teletex
          it_rml              = lt_rml
          it_x400             = lt_x400
          it_printer          = lt_printer
          it_ssf              = lt_ssf
          it_pager            = lt_pager
          is_current_state    = ls_current_state
          iv_ignore_cua_check = if_identity=>co_true
        importing
          eo_msg_buffer       = eo_msg_buffer ).

    "------ Others -------------------------------------------------
    when others.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '666'.
      " MSG: Aktion nicht zulaessig.
      if 1 = 0. message e666(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

  endcase.

endmethod.


method if_identity~action_lock.

  data: lv_lock_local            type        char01
       ,lv_lock_global           type        char01
       ,lv_cua_active            type        char01
       ,lv_cua_central           type        char01
       ,lv_lock_status           type        x
       ,lv_error                 type        abap_bool
       ,ls_msg                   type        symsg
       ,lv_no_maintain           type        sesf_boolean
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* ---- Transactional preliminaries ------------------------------------*
  " Buffer for header information is always filled during instantiation
  if ms_segment_header-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S' " Call from SET like method
      iv_change_node = if_identity_definition=>gc_node_lockdata
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_lockdata.


  " Field filter settings in CUA are well-defined for locks:
  "   --> Global lock always may only be maintained in central system
  "   --> Local  lock always may only be maintained locally
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_cua_active  = lv_cua_active
      ev_cua_central = lv_cua_central.

  " --- Detemine lockscope - Only local and global lock! Wrong logon lock set by Kernel only.
  if is_lockscope is initial.
    " Use BAPI default behaviour
    if lv_cua_active eq go_persistence->co_flag_active.
      if lv_cua_central eq go_persistence->co_flag_active. " Central system
        lv_lock_global = go_persistence->co_flag_active.
      else.                " This is not the central system of CUA
        lv_lock_local = go_persistence->co_flag_active.
      endif.
    else.                  " CUA not active
      lv_lock_local = go_persistence->co_flag_active.
    endif.
  else.
    " Use lockscope
    if is_lockscope-flg_lockscope_local eq go_persistence->co_flag_active.
      lv_lock_local = go_persistence->co_flag_active.
    endif.
    if is_lockscope-flg_lockscope_global eq go_persistence->co_flag_active and
       ( lv_cua_central     eq go_persistence->co_flag_active or " Central system
         gv_idoc_processing eq if_identity=>co_true ).           " Target system + IDOC processing
      lv_lock_global = go_persistence->co_flag_active.
    endif.
  endif.

  " ---- Now determine lock scope from CUA
  if lv_lock_global is not initial.
    cua_if_field_no_maintain(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_lockdata
        iv_field_name  = if_identity_definition=>gc_field_lockdata_global_set
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain ).
    if lv_no_maintain eq if_identity=>co_true.
      " Maintenance not allowed: Don't unlock!
      clear lv_lock_global. " Message buffer was filled in method CUA_IF_FIELD_NO_MAINTAIN
    endif.
  endif.

  if lv_lock_local is not initial.
    cua_if_field_no_maintain(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_lockdata
        iv_field_name  = if_identity_definition=>gc_field_lockdata_local_set
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain ).
    if lv_no_maintain eq if_identity=>co_true.
      " Maintenance not allowed: Don't unlock!
      clear lv_lock_local. " Message buffer was filled in method CUA_IF_FIELD_NO_MAINTAIN
    endif.
  endif.


  " --- Now evaluate lv_lock_global, lv_lock_local
  clear: lv_lock_status.
  " Use field of type x due to unicode
  lv_lock_status = ms_segment_header-actual-uflag.

  if    lv_lock_status z  if_identity=>co_locked_by_admin
    and lv_lock_local  eq go_persistence->co_flag_active.
    lv_lock_status                 = lv_lock_status + if_identity=>co_locked_by_admin.
    ms_segment_header-actual-uflag = lv_lock_status.
  endif.

  if    lv_lock_status z  if_identity=>co_locked_by_global_admin
    and lv_lock_global eq go_persistence->co_flag_active.
    lv_lock_status                 = lv_lock_status + if_identity=>co_locked_by_global_admin.
    ms_segment_header-actual-uflag = lv_lock_status.
  endif.


* ---- Add lock field UFLAG to changed fields for CUA -----------------*
  if ms_segment_header-before_image-uflag ne ms_segment_header-actual-uflag.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_lockdata.
  endif.


* ---- Usual checks for status fields: --------------------------------*
  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_lockdata
    receiving
      ev_error    = lv_error.

  " Node status
  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_lockdata = go_persistence->co_node_status_checked.
    " Mark internal CUA segment to trigger lock distribution
    if lv_lock_global = go_persistence->co_flag_active.
      ms_segment_cua_act_distr-actual-global_lock = co_lock.
    endif.

  else.                     "  New node status: CHANGED
    ms_manager-sn_lockdata = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag: Therefore compare actual and before image
  if ms_segment_header-actual ne ms_segment_header-before_image.
    " Segment status - Lock information is in header segment
    ms_segment_header-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.

  "DBMS User Lock
  if abap_true = cl_dbms_customizing=>if_dbms_um_active( ).

    call method get_dbms_user
      importing
        es_dbms_user  = data(ls_dbms_user).

    if ls_dbms_user-dbms_user is not initial.  "DBMS user assigned
*       and ls_dbms_user-dbms_user_exist = abap_true. "and exist

      if lv_lock_global eq go_persistence->co_flag_active or
         lv_lock_local  eq go_persistence->co_flag_active.
        ls_dbms_user-user_deactivated = abap_true.
        data lt_change_fields type suid_tt_fields.
        append if_identity_definition=>gc_field_dbms_user_deactivated to lt_change_fields .
        call method if_identity_dbms_user~set_dbms_user
          exporting
            it_change_fields = lt_change_fields
            is_dbms_user     = ls_dbms_user.
      endif.
    endif.
  endif.

endmethod.


method if_identity~action_unlock.

  data: lv_lock_local            type char01
      , lv_lock_global           type char01
      , lv_lock_wrong_logon      type char01
      , lv_lock_status           type x
      , lv_error                 type abap_bool
      , ls_msg                   type symsg
      , lv_no_maintain           type sesf_boolean
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* ---- Transactional preliminaries ------------------------------------*
  " Buffer for header information is always filled during instantiation
  if ms_segment_header-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.

  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S' " Call from SET like method
      iv_change_node = if_identity_definition=>gc_node_lockdata
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_lockdata.

  " Use field of type x due to unicode
  clear: lv_lock_status.
  lv_lock_status = ms_segment_header-actual-uflag.

  " --- Detemine lockscope
  if is_lockscope is initial.
    " Always try to unlock every lock
    lv_lock_global      = go_persistence->co_flag_active.
    lv_lock_local       = go_persistence->co_flag_active.
    lv_lock_wrong_logon = go_persistence->co_flag_active.
  else.
    " Use lockscope
    if is_lockscope-flg_lockscope_local eq go_persistence->co_flag_active.
      lv_lock_local = go_persistence->co_flag_active.
    endif.
    if is_lockscope-flg_lockscope_global eq go_persistence->co_flag_active.
      lv_lock_global = go_persistence->co_flag_active.
    endif.
    if is_lockscope-flg_lockscope_wrong_logon eq go_persistence->co_flag_active.
      lv_lock_wrong_logon = go_persistence->co_flag_active.
    endif.
  endif.

  " ---- Now determine lock scope from CUA
  if    lv_lock_status o  if_identity=>co_locked_by_global_admin
    and lv_lock_global is not initial.
    cua_if_field_no_maintain(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_lockdata
        iv_field_name  = if_identity_definition=>gc_field_lockdata_global_rem
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain ).
    if lv_no_maintain eq if_identity=>co_true.
      " Maintenance not allowed: Don't unlock!
      clear lv_lock_global. " Message buffer was filled in method CUA_IF_FIELD_NO_MAINTAIN
    endif.
  endif.

  if    lv_lock_status o  if_identity=>co_locked_by_admin
    and lv_lock_local is not initial.
    cua_if_field_no_maintain(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_lockdata
        iv_field_name  = if_identity_definition=>gc_field_lockdata_local_rem
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain ).
    if lv_no_maintain eq if_identity=>co_true.
      " Maintenance not allowed: Don't unlock!
      clear lv_lock_local. " Message buffer was filled in method CUA_IF_FIELD_NO_MAINTAIN
    endif.
  endif.

  if    lv_lock_status      o  if_identity=>co_locked_by_wrong_logon
    and lv_lock_wrong_logon is not initial.
    cua_if_field_no_maintain(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_lockdata
        iv_field_name  = if_identity_definition=>gc_field_lockdata_wrong_rem
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain ).
    if lv_no_maintain eq if_identity=>co_true.
      " Maintenance not allowed: Don't unlock!
      clear lv_lock_wrong_logon. " Message buffer was filled in method CUA_IF_FIELD_NO_MAINTAIN
    endif.
  endif.


  " --- Now evaluate lv_lock_global, lv_lock_local, lv_lock_wrong_logon
  if    lv_lock_status o  if_identity=>co_locked_by_global_admin
    and lv_lock_global eq go_persistence->co_flag_active.
    lv_lock_status                 = lv_lock_status - if_identity=>co_locked_by_global_admin.
    ms_segment_header-actual-uflag = lv_lock_status.
  endif.

  if    lv_lock_status o  if_identity=>co_locked_by_admin
    and lv_lock_local  eq go_persistence->co_flag_active.
    lv_lock_status                 = lv_lock_status - if_identity=>co_locked_by_admin.
    ms_segment_header-actual-uflag = lv_lock_status.
  endif.

  if    lv_lock_status      o  if_identity=>co_locked_by_wrong_logon
    and lv_lock_wrong_logon eq go_persistence->co_flag_active.
    lv_lock_status                 = lv_lock_status - if_identity=>co_locked_by_wrong_logon.
    ms_segment_header-actual-uflag = lv_lock_status.
    clear: ms_segment_header-actual-locnt.
  endif.


* ---- Add lock field UFLAG to changed fields for CUA -----------------*
  if ms_segment_header-before_image-uflag ne ms_segment_header-actual-uflag.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_lockdata.
  endif.


* ---- Usual checks for status fields: --------------------------------*
  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_lockdata
    receiving
      ev_error    = lv_error.

  " Node status
  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_lockdata = go_persistence->co_node_status_checked.
    " Mark internal CUA segment to trigger lock distribution
    if lv_lock_global = go_persistence->co_flag_active.
      ms_segment_cua_act_distr-actual-global_lock
                                         = co_unlock.
    endif.
  else.                     "  New node status: CHANGED
    ms_manager-sn_lockdata = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag: Therefore compare actual and before image
  if ms_segment_header-actual ne ms_segment_header-before_image.
    " Segment status - Lock information is in header segment
    ms_segment_header-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.

  "DBMS User unlock
  if abap_true = cl_dbms_customizing=>if_dbms_um_active( ).

    call method get_dbms_user
      importing
        es_dbms_user  = data(ls_dbms_user).

    if ls_dbms_user-dbms_user is not initial. "DBMS user assigned
       "and ls_dbms_user-dbms_user_exist = abap_true. "and exist

      if lv_lock_global eq go_persistence->co_flag_active or
         lv_lock_local  eq go_persistence->co_flag_active.
        ls_dbms_user-user_deactivated = space.
        data lt_change_fields type suid_tt_fields.
        append if_identity_definition=>gc_field_dbms_user_deactivated to lt_change_fields .
        call method if_identity_dbms_user~set_dbms_user
          exporting
            it_change_fields = lt_change_fields
            is_dbms_user     = ls_dbms_user.
      endif.
    endif.
  endif.

endmethod.


method if_identity~align_profiles.

  data: lv_profiles_changed     type          sesf_boolean value if_identity=>co_false
      , lt_user_profile         type          suid_tt_usprof
      , lv_msg_data             type          symsg
      , lv_adjustment_required  type          suid_role_adjustment_status
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " check state of roles if adjustment is necessary
  call method me->if_identity~get_roles
    exporting
      iv_get_role_adjustments = 'X'
    importing
      ev_adjustment_required  = lv_adjustment_required.


  if lv_adjustment_required eq if_identity=>co_compare_master_record.

    lv_profiles_changed = if_identity=>co_true.

    " Delete message buffer
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_role.

    " Authorization check
    call method checks_before_access
      exporting
        iv_method      = 'S'
        iv_change_node = if_identity_definition=>gc_node_profile
      importing
        es_msg         = lv_msg_data.

    if lv_msg_data-msgty = 'E'.
      " Return to caller if not authorized
      return.
    endif.

    " Adjust all assigned rolse
    call method me->profile_adjust
      exporting
        it_roles        = me->ms_segment_roles-actual
      importing
        et_user_profile = lt_user_profile.

    " -- write new profiles into segments
    call method me->profile_write_to_segment
      exporting
        it_user_profile = lt_user_profile.

  endif.

  ev_profiles_adjusted = lv_profiles_changed.

endmethod.


method if_identity~cancel.
*
* Cancel creation, modification or deletion of a user
*  - delete all changes from transaction buffer
*  - dequeue user
*  - use before image
*  - set modus to display
*  - In create mode only: Invalidate instance by Cleanup

* Consistence check: Cancel may be called for Modify and Delete only

  data: lo_addr_main             type ref to cl_addr_main
      , lt_office_users          type        bcsy_user
      , lv_bname                 type        xubname
      , lv_enqueue_mode          type        sesf_edit_mode
      , lt_bname                 type        susr_t_ususers
      .

* Status must be valid
  if ms_manager-status eq go_persistence->co_ta_status_invalid.
    raise exception type cx_suid_identity
      exporting
        textid          = cx_suid_identity=>invalid_identity
        ref_to_identity = me
        bname           = ms_manager-bname
        ta_modus        = ms_manager-modus
        ta_status       = ms_manager-status.

  endif.

  if ms_manager-modus eq go_persistence->co_ta_modus_display.
* do nothing -> return to caller
    return.
  endif.

* ---- If personalization data is involved: Clear respective buffer ---*
  if ms_manager-flg_pers_modified = go_persistence->co_flag_active.
    call method cl_pers_service=>clear_instances.
  endif.

* ---- If appl. references are involved: Clear respective buffer ------*
  if ms_manager-flg_appref_modified = go_persistence->co_flag_active.
    append ms_manager-bname to lt_bname.
    call method cl_suid_applref=>cleanup( it_bname = lt_bname ).
  endif.

* ---- Delete messages and notifications for this user ----------------*
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname = ms_manager-bname.

  call method go_notify->delete_notifications
    exporting
      iv_bname = ms_manager-bname.


* SAP Office
  if ms_segment_address-status = go_persistence->co_seg_changed.
    append ms_manager-bname to lt_office_users.
    call method cl_so_office_user_address=>cancel
      exporting
        it_users = lt_office_users.
  endif.

* BAS
  if ms_segment_address-actadd-changed_bas_workplace_node_id is not initial.
    lo_addr_main = cl_addr_main=>get_instance( ).
    call method lo_addr_main->reset_modifications
      exporting
        it_address_id = ms_segment_address-actadd-changed_bas_workplace_node_id.
*    call method lo_addr_main->initialize
*      exporting
*        it_address_id = ms_segment_address-actadd-changed_bas_workplace_node_id.
  endif.

  if ( ms_segment_address-actadd-trx_with_bp <> co_trx_bp ).
    "BP Reset only if the instance isn't handled via ESI_Person Interface
    call method me->bp_reset_modification.
  endif.

* Reset Certmap enqueue
  call method cl_suid_tools=>dequeue_certmap_for_user
    exporting
      iv_bname            = ms_manager-bname
    changing
      it_certmap_enqueued = mt_certmap_enqueued.


* ---- Special treatment for Create mode ------------------------------*
  if ms_manager-modus = go_persistence->co_ta_modus_create.
*...Clear all segments
    clear_segments( iv_keep_header = ' ' ).

*...Adapt instance manager
    lv_bname        = ms_manager-bname.   " Remember Identity ID
    lv_enqueue_mode = ms_manager-enqmode. " Remember enqmode
    clear: ms_manager.   " This includes all node status flags

*   invalidate instance and remove from gt_control list
    ms_manager-bname   = lv_bname.         " Keep information about ID and status
    ms_manager-status  = go_persistence->co_ta_status_invalid.
    ms_manager-enqmode = lv_enqueue_mode.  " Keep information about enqueue state

*...Remove entry in control table
    read table gt_control with key bname = ms_manager-bname
      binary search
      transporting no fields.
    if sy-subrc = 0.
      delete gt_control index sy-tabix.
    endif.

  else.
*...Adjust instance manager
    ms_manager-modus  = go_persistence->co_ta_modus_display.
    ms_manager-status = go_persistence->co_ta_status_unchanged.

*...Reset status fields for all nodes
    clear_node_status( ).

*   Address
    if ms_segment_address-status = go_persistence->co_seg_changed.
      ms_segment_address-actual = ms_segment_address-before_image.
      clear: ms_segment_address-status,
             ms_segment_address-actadd.
    endif.

*   Header segment
    if ms_segment_header-status = go_persistence->co_seg_changed.
      ms_segment_header-actual = ms_segment_header-before_image.
      clear: ms_segment_header-status.
      clear: ms_segment_header-initial_password.
    endif.

*   History segment for header data only keeps actual image
    if ms_segment_header_hist-status = go_persistence->co_seg_changed.
      clear: ms_segment_header_hist-actual.
      clear: ms_segment_header_hist-status.
    endif.

*   Audit log segment only keeps actual image
    if ms_segment_auditlog-status = go_persistence->co_seg_changed.
      clear: ms_segment_auditlog-actual.
      clear: ms_segment_auditlog-status.
    endif.

*   User stamp segment only keeps actual image
    if ms_segment_userstamp-status = go_persistence->co_seg_changed.
      clear: ms_segment_userstamp-actual.
      clear: ms_segment_userstamp-status.
    endif.

*  reference user
    if ms_segment_refuser-status = go_persistence->co_seg_changed.
      ms_segment_refuser-actual = ms_segment_refuser-before_image.
      clear: ms_segment_refuser-status.
    endif.

*  roles
    if ms_segment_roles-status = go_persistence->co_seg_changed.
      ms_segment_roles-actual = ms_segment_roles-before_image.
      clear: ms_segment_roles-status.
    endif.

*  defaults
    if ms_segment_defaults-status = go_persistence->co_seg_changed.
      ms_segment_defaults-actual = ms_segment_defaults-before_image.
      clear: ms_segment_defaults-status.
    endif.

*  snc
    if ms_segment_snc-status = go_persistence->co_seg_changed.
      ms_segment_snc-actual = ms_segment_snc-before_image.
      clear: ms_segment_snc-status.
    endif.

*  profiles: ust04
    if ms_segment_profiles_t04-status = go_persistence->co_seg_changed.
      ms_segment_profiles_t04-actual = ms_segment_profiles_t04-before_image.
      clear: ms_segment_profiles_t04-status.
    endif.

*  profiles: usr04
    if ms_segment_profiles_r04-status = go_persistence->co_seg_changed.
      ms_segment_profiles_r04-actual = ms_segment_profiles_r04-before_image.
      clear: ms_segment_profiles_r04-status.
    endif.

*   Profiles history segment only keeps actual image
    if ms_segment_profiles_r04_hist-status = go_persistence->co_seg_changed.
      clear: ms_segment_profiles_r04_hist-actual.
      clear: ms_segment_profiles_r04_hist-status.
    endif.

*  Parameter
    if ms_segment_parameter-status = go_persistence->co_seg_changed.
      ms_segment_parameter-actual = ms_segment_parameter-before_image.
      clear: ms_segment_parameter-status.
    endif.

*   Groups
    if ms_segment_groups-status = go_persistence->co_seg_changed.
      ms_segment_groups-actual = ms_segment_groups-before_image.
      clear: ms_segment_groups-status.
    endif.

*  Uclass
    if ms_segment_uclass-status = go_persistence->co_seg_changed.
      ms_segment_uclass-actual = ms_segment_uclass-before_image.
      clear: ms_segment_uclass-status.
    endif.

*   Print parameter segment only keeps actual image
    if ms_segment_printparam-status = go_persistence->co_seg_changed.
      clear: ms_segment_printparam-actual
           , ms_segment_printparam-status
           .
    endif.

*   Password history segment only keeps actual image
    if ms_segment_pwdhistory-status = go_persistence->co_seg_changed.
      clear: ms_segment_pwdhistory-actual.
      clear: ms_segment_pwdhistory-status.
    endif.

*   cua roles segment
    if ms_segment_cua_roles-status = go_persistence->co_seg_changed.
      ms_segment_cua_roles-actual = ms_segment_cua_roles-before_image.
      clear: ms_segment_cua_roles-status.
    endif.

*   cua profiles segment
    if ms_segment_cua_profiles-status = go_persistence->co_seg_changed.
      ms_segment_cua_profiles-actual = ms_segment_cua_profiles-before_image.
      clear: ms_segment_cua_profiles-status.
    endif.

*   cua systems segment
    if ms_segment_cua_systems-status = go_persistence->co_seg_changed.
      ms_segment_cua_systems-actual = ms_segment_cua_systems-before_image.
      clear: ms_segment_cua_systems-status.
    endif.

*   ms_segment_cua_user_prot
    if ms_segment_cua_user_prot-status = go_persistence->co_seg_changed.
      ms_segment_cua_user_prot-actual = ms_segment_cua_user_prot-before_image.
      clear: ms_segment_cua_user_prot-status.
    endif.

*   ms_segment_cua_uclass
    if ms_segment_cua_uclasses-status = go_persistence->co_seg_changed.
      ms_segment_cua_uclasses-actual = ms_segment_cua_uclasses-before_image.
      clear: ms_segment_cua_uclasses-status.
    endif.

*   ms_segment_cua_password
    if ms_segment_cua_password-status = go_persistence->co_seg_changed.
      clear: ms_segment_cua_password-actual.
      clear: ms_segment_cua_password-status.
    endif.

*   ms_segment_cua_password
    if ms_segment_cua_act_distr-status = go_persistence->co_seg_changed.
      clear: ms_segment_cua_act_distr-actual.
      clear: ms_segment_cua_act_distr-status.
    endif.


*   ms_segment_certmap
    if ms_segment_certmap-status = go_persistence->co_seg_changed.
      ms_segment_certmap-actual = ms_segment_certmap-before_image.
      clear: ms_segment_certmap-status.
    endif.

*   ms_segment_dbms_user
    if ms_segment_dbms_user-status = go_persistence->co_seg_changed.
      ms_segment_dbms_user-actual                = ms_segment_dbms_user-before_image.
      ms_segment_dbms_user-dbms_user_data_actual = ms_segment_dbms_user-dbms_user_data_before.
      ms_segment_dbms_user-dbms_roles_actual     = ms_segment_dbms_user-dbms_roles_before.
      clear: ms_segment_dbms_user-dbms_change_mode.
      clear: ms_segment_dbms_user-status.
    endif.

*    Pattern for additional segments:
*    if ms_segment_-status = go_persistence->co_seg_changed.
*      ms_segment_-actual = ms_segment_-before_image.
*      clear: ms_segment_-status.
*    endif.

  endif.

* ---- Dequeue Identity -----------------------------------------------*
  release_enqueue_lock( ).

endmethod.


method if_identity~get_admindata.
  " - ES_ADMINDATA_ON_SAVE is obsolete!
  " - ES_ADMINDATA:
  "   + The first part contains of the unchangeable usr02-fields:
  "       aname, erdat, trdat and ltime
  "   + The second part: moddate, modtime, modifier may not have the
  "     correct value e.g. if the actual image is expected in delete
  "     mode.
  "     In delete mode you explicitly need to request the
  "     BEFORE_IMAGE using Parameter IV_REQUEST_BEFORE_IMAGE = ‘X’.
  "     The current timestamp information will now be provided by a
  "     new exporting parameter ES_TIMESTAMP in methods save and
  "     do_save in class cl_identity and as new optional importing
  "     parameter to the IF_BADI_IDENTITY_UPDATE~SAVE method.
  "   + The third part (SAVE_STATUS_TEXT and SAVE_STATUS_ID) contains
  "     the current status of the instance.
  " - ET_NODES_MODIFIED:
  "     List of modified nodes
  "-------------------------------------------------------------------


  data: lr_userstamp type ref to usrstamp
       ,lv_domname   type        dd07l-domname
       ,lv_domvalue  type        dd07l-domvalue_l
       ,ls_dd07v     type        dd07v
       ,ls_msg       type        symsg
       .
  constants: lco_saved    type suid_saved_status value 'S'
            ,lco_modified type suid_saved_status value 'M'
            ,lco_unsaved  type suid_saved_status value 'U'
            .
  field-symbols: <lr_cua_ts_local_user> type sesf_boolean
               .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_admindata.

  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method               = 'G'
      iv_change_node          = if_identity_definition=>gc_node_admindata
      iv_request_before_image = iv_request_before_image
    importing
      es_msg                  = ls_msg
      ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " ANAME/ERDAT/TRDAT/LTIME from header segment - this is always filled!
  " Take before image!
  move-corresponding ms_segment_header-before_image to es_admindata.

  " MODDATE/MODTIME/MODIFIER from USRSTAMP - which is pre-fetched
  if ms_segment_userstamp-bname is initial.
    fetch_segment_usrstamp( ).
  endif.

  read table ms_segment_userstamp-before_image
       with key username = me->ms_manager-bname
                struct   = '*'
                field    = '*'
       reference into lr_userstamp
       binary search.
  if sy-subrc = 0.
    es_admindata-moddate  = lr_userstamp->moddate.
    es_admindata-modtime  = lr_userstamp->modtime.
    es_admindata-modifier = lr_userstamp->modifier.
  else.
    clear: es_admindata-moddate
          ,es_admindata-modtime
          ,es_admindata-modifier
          .
  endif.

  " Get status text
  case ms_manager-modus .
    when go_persistence->co_ta_modus_create.
      clear: es_admindata-moddate
            ,es_admindata-modtime
            ,es_admindata-modifier
            .
      es_admindata-save_status_id = lco_unsaved.
    when go_persistence->co_ta_modus_modify.
      if   ms_manager-status = go_persistence->co_ta_status_saved
        or ms_manager-status = go_persistence->co_ta_status_unchanged.
        es_admindata-save_status_id = lco_saved.
      else.
        es_admindata-save_status_id = lco_modified.
      endif.
    when go_persistence->co_ta_modus_display.
      es_admindata-save_status_id = lco_saved.
    when others. " delete
      es_admindata-save_status_id = lco_saved.
  endcase.

  if iv_get_status_text = if_identity=>co_true.
    if es_admindata-save_status_id is not initial.
      lv_domname = 'SUID_SAVED_STATUS'.
      lv_domvalue = es_admindata-save_status_id.
      call function 'DD_DOMVALUE_TEXT_GET'
        exporting
          domname  = lv_domname
          value    = lv_domvalue
        importing
          dd07v_wa = ls_dd07v.
      es_admindata-save_status_text = ls_dd07v-ddtext.
    endif.
  endif.

  " Get modified nodes
  if et_nodes_modified is supplied.
    clear: et_nodes_modified.
    if ms_manager-sn_logondata       is not initial.
      append if_identity_definition=>gc_node_logondata to et_nodes_modified.
    endif.
    if ms_manager-sn_defaults        is not initial.
      append if_identity_definition=>gc_node_defaults to et_nodes_modified.
    endif.
    if ms_manager-sn_snc             is not initial.
      append if_identity_definition=>gc_node_snc to et_nodes_modified.
    endif.
    if ms_manager-sn_password        is not initial.
      append if_identity_definition=>gc_node_password to et_nodes_modified.
    endif.
    if ms_manager-sn_pwdhash         is not initial.
      append if_identity_definition=>gc_node_pwdhash to et_nodes_modified.
    endif.
    if ms_manager-sn_lockdata        is not initial.
      append if_identity_definition=>gc_node_lockdata to et_nodes_modified.
    endif.
    if ms_manager-sn_certmap         is not initial.
      append if_identity_definition=>gc_node_certmap to et_nodes_modified.
    endif.
    if ms_manager-sn_roles           is not initial.
      append if_identity_definition=>gc_node_role to et_nodes_modified.
    endif.
    if ms_manager-sn_profiles        is not initial.
      append if_identity_definition=>gc_node_profile to et_nodes_modified.
    endif.
    if ms_manager-sn_parameter       is not initial.
      append if_identity_definition=>gc_node_parameter to et_nodes_modified.
    endif.
    if ms_manager-sn_groups          is not initial.
      append if_identity_definition=>gc_node_group to et_nodes_modified.
    endif.
    if ms_manager-sn_uclass          is not initial.
      append if_identity_definition=>gc_node_uclass to et_nodes_modified.
    endif.
    if ms_manager-sn_cua_systems     is not initial.
      append if_identity_definition=>gc_node_cua_system to et_nodes_modified.
    endif.
    if ms_manager-sn_cua_roles       is not initial.
      append if_identity_definition=>gc_node_cua_role to et_nodes_modified.
    endif.
    if ms_manager-sn_cua_profiles    is not initial.
      append if_identity_definition=>gc_node_cua_profile to et_nodes_modified.
    endif.
    if ms_manager-sn_cua_uclass      is not initial.
      append if_identity_definition=>gc_node_cua_uclass to et_nodes_modified.
    endif.
    if ms_manager-sn_cua_password    is not initial.
      append if_identity_definition=>gc_node_cua_password to et_nodes_modified.
    endif.
    if ms_manager-sn_refuser         is not initial.
      append if_identity_definition=>gc_node_reference_user to et_nodes_modified.
    endif.
    if ms_manager-sn_tech_user       is not initial.
      append if_identity_definition=>gc_node_tech_user to et_nodes_modified.
    endif.
    if ms_manager-sn_tech_user_data  is not initial.
      append if_identity_definition=>gc_node_tech_user_data to et_nodes_modified.
    endif.
    if ms_manager-sn_organization    is not initial.
      append if_identity_definition=>gc_node_organization to et_nodes_modified.
    endif.
    if ms_manager-sn_person_name     is not initial.
      append if_identity_definition=>gc_node_person_name to et_nodes_modified.
    endif.
    if ms_manager-sn_workplace       is not initial.
      append if_identity_definition=>gc_node_workplace to et_nodes_modified.
    endif.
    if ms_manager-sn_person          is not initial.
      append if_identity_definition=>gc_node_person to et_nodes_modified.
    endif.
    if ms_manager-sn_telephone       is not initial.
      append if_identity_definition=>gc_node_telephone to et_nodes_modified.
    endif.
    if ms_manager-sn_facsimile       is not initial.
      append if_identity_definition=>gc_node_facsimile to et_nodes_modified.
    endif.
    if ms_manager-sn_email           is not initial.
      append if_identity_definition=>gc_node_email to et_nodes_modified.
    endif.
    if ms_manager-sn_web             is not initial.
      append if_identity_definition=>gc_node_web to et_nodes_modified.
    endif.
    if ms_manager-sn_telex           is not initial.
      append if_identity_definition=>gc_node_telex to et_nodes_modified.
    endif.
    if ms_manager-sn_teletex         is not initial.
      append if_identity_definition=>gc_node_teletex to et_nodes_modified.
    endif.
    if ms_manager-sn_remote_mail     is not initial.
      append if_identity_definition=>gc_node_remote_mail to et_nodes_modified.
    endif.
    if ms_manager-sn_x400            is not initial.
      append if_identity_definition=>gc_node_x400 to et_nodes_modified.
    endif.
    if ms_manager-sn_printer         is not initial.
      append if_identity_definition=>gc_node_printer to et_nodes_modified.
    endif.
    if ms_manager-sn_ssf             is not initial.
      append if_identity_definition=>gc_node_ssf to et_nodes_modified.
    endif.
    if ms_manager-sn_pager           is not initial.
      append if_identity_definition=>gc_node_pager to et_nodes_modified.
    endif.
  endif.

  "Inform administrators about users having ZBVMASTER='X'
  if ( gv_cua_central is initial                      ) and
     ( ms_segment_header-before_image-zbvmaster = 'X' ).

    clear: ls_msg.
    "The user &1 cannot logon to this client.
    if 1 = 0. message w576(01) with ms_manager-bname. endif.
    ls_msg-msgid = '01'.
    ls_msg-msgno = '576'.
    ls_msg-msgty = 'W'.
    ls_msg-msgv1 = ms_manager-bname.

    call method me->go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname     = ms_manager-bname
        iv_nodename  = if_identity_definition=>gc_node_admindata
        iv_lifetime  = if_suid_msg_buffer=>co_lifetime_once_trx
        is_msg       = ls_msg
        iv_overwrite = 'X'.
  endif.

  " CUA: Local user
  assign component if_identity_definition=>gc_field_admin_cua_local_user
      of structure es_admindata to <lr_cua_ts_local_user>.
  if sy-subrc eq 0.
    if iv_request_before_image is initial.
      if ms_segment_header-actual-reserved eq co_user_local.
        <lr_cua_ts_local_user> = if_identity=>co_true.
      else.
        <lr_cua_ts_local_user> = if_identity=>co_false.
      endif.
    else.
      if ms_segment_header-before_image-reserved eq co_user_local.
        <lr_cua_ts_local_user> = if_identity=>co_true.
      else.
        <lr_cua_ts_local_user> = if_identity=>co_false.
      endif.
    endif.
  endif.

endmethod.


method if_identity~get_defaults.

  data: ls_msg type symsg.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_defaults.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_defaults
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    clear: es_defaults, ev_kostl.
    return.
  endif.

  call method me->get_defaults
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      eo_msg_buffer           = eo_msg_buffer
      es_defaults             = es_defaults
      ev_kostl                = ev_kostl.


endmethod.


method if_identity~get_documentation.

  data: ls_msg type symsg
      , lr_seg_docu type ref to usdocu
      , ls_node_docu type suid_st_node_docu
      .

  field-symbols: <lf_image> type suid_tt_usdocu.

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_docu.


  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method               = 'G'
      iv_change_node          = if_identity_definition=>gc_node_documentation
      iv_request_before_image = iv_request_before_image
    importing
      es_msg                  = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

  " --- Check docu buffer ---
  if ms_segment_docu-bname is initial.
    fetch_segment_docu( ).
  endif.


  " --- Read values -----------------------------------------
  if iv_request_before_image = if_identity=>co_true.
    assign ms_segment_docu-before_image to <lf_image>.
  else.
    assign ms_segment_docu-actual to <lf_image>.
  endif.

  loop at <lf_image> reference into lr_seg_docu.
    move-corresponding lr_seg_docu->* to ls_node_docu.
    append ls_node_docu to et_docu.
  endloop.

endmethod.


METHOD if_identity~get_enqueue_mode.
*  data: lv_enq_mode         type suid_enqueue_mode.

* verify enqueue mode
  rv_enqueue_mode = ms_manager-enqmode.
  IF ms_manager-enqmode = cl_suid_tools=>co_enqueue_mode_opt_to_excl.
    rv_enqueue_mode = if_identity=>co_enqueue_mode_exclusive.
  ELSE.
    rv_enqueue_mode = ms_manager-enqmode.
  ENDIF.

*  CASE rv_enqueue_mode.
**--------No lock ----------------------------------------------------*
*    WHEN if_identity=>co_enqueue_mode_no_lock.
** nothing left to do
*
**--------Exclusive Lock ---------------------------------------------*
*    WHEN if_identity=>co_enqueue_mode_exclusive
**  verify that object has exclusive lock for dialog user
*    call method cl_suid_tools=>enqueue
*      exporting
*        i_bname     = ms_manager-bname
*        i_enq_mode  = cl_suid_tools=>co_check_lock_mode_opt
*        i_enq_scope = 1
*      importing
*        et_bname    = lt_bname.
*
**--------Optimistic lock -------------------------------------------*
*    WHEN if_identity=>co_enqueue_mode_optimistic.
**  verify that object has optimistic lock for dialog user
*      CALL METHOD cl_suid_tools=>enqueue
*        EXPORTING
*          i_bname     = ms_manager-bname
*          i_enq_mode  = cl_suid_tools=>co_check_lock_mode_opt
*          i_enq_scope = 1
*        IMPORTING
*          et_bname    = lt_bname.
*
*    WHEN OTHERS.
*
*  ENDCASE.
ENDMETHOD.


method if_identity~get_groups.


  data: ls_msg            type symsg
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_groups.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_group
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    refresh: et_groups.
    return.
  endif.

  call method me->get_groups
    exporting
      iv_request_before_image = iv_request_before_image
      iv_get_text             = iv_get_text
    importing
      et_groups               = et_groups
      eo_msg_buffer           = eo_msg_buffer.



endmethod.


method if_identity~get_identity_indicator.

  data: ls_msg type symsg
       .

  clear: ev_id_indicator.

* No auth check required
*  call method checks_before_access
*    exporting
*      iv_method      = 'G'
*      iv_change_node = if_identity_definition=>gc_node_root
*      iv_request_before_image = iv_request_before_image
*    importing
*      es_msg         = ls_msg.
*
*  if ls_msg-msgty = 'E'.
*    clear: ev_id_indicator
*          .
*    return.
*  endif.

* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    call method fetch_segment_address.
  endif.


* Get Identity Indicator
  if iv_request_before_image is initial.
    ev_id_indicator = ms_segment_address-actual-idadtype.
  else.
    ev_id_indicator = ms_segment_address-before_image-idadtype.
  endif.

endmethod.


method if_identity~get_identity_uuid.

  data: lv_identity_guid type suid_guid.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: ev_identity_uuid,
         ev_identity_guid.

* Check buffer for address information
  if ms_segment_address-bname is initial.
    call method fetch_segment_address.
  endif.

  case ms_manager-modus. "iv_modus.
    when go_persistence->co_ta_modus_create.
      if ms_segment_address-actual-identity_guid is initial.
        try.
            lv_identity_guid = cl_system_uuid=>if_system_uuid_static~create_uuid_x16( ).
          catch cx_uuid_error.
            clear lv_identity_guid.
        endtry.

        move lv_identity_guid to ms_segment_address-actual-identity_guid.
      endif.

    when go_persistence->co_ta_modus_delete.
      if ms_segment_address-before_image-identity_guid is initial.
        try.
            lv_identity_guid = cl_system_uuid=>if_system_uuid_static~create_uuid_x16( ).
          catch cx_uuid_error.
            clear lv_identity_guid.
        endtry.

*        UPDATE usr21
*          SET identity_guid = lv_identity_guid
*          WHERE bname = ms_segment_address-bname.

        call method go_persistence->if_suid_persistence_modify~set_identity_guid
          exporting
            iv_bname         = ms_segment_address-bname
            iv_identity_guid = lv_identity_guid.

        if sy-subrc = 0.
          move lv_identity_guid to ms_segment_address-before_image-identity_guid.
        endif.
      endif.
    when others.
      if ms_segment_address-actual-identity_guid is initial.
        try.
            lv_identity_guid = cl_system_uuid=>if_system_uuid_static~create_uuid_x16( ).
          catch cx_uuid_error.
            clear lv_identity_guid.
        endtry.

*        UPDATE usr21
*          SET identity_guid = lv_identity_guid
*          WHERE bname = ms_segment_address-bname.

        call method go_persistence->if_suid_persistence_modify~set_identity_guid
          exporting
            iv_bname         = ms_segment_address-bname
            iv_identity_guid = lv_identity_guid.

        if sy-subrc = 0.
          move lv_identity_guid to ms_segment_address-actual-identity_guid.
          move lv_identity_guid to ms_segment_address-before_image-identity_guid.
        endif.
      endif.
  endcase.

  ev_identity_guid = ms_segment_address-actual-identity_guid.

  if ev_identity_uuid is requested.
    call method cl_gdt_conversion=>guid_outbound
      exporting
        im_guid_x = ms_segment_address-actual-identity_guid
      importing
        ex_value  = ev_identity_uuid.
  endif.

endmethod.


method if_identity~get_lockstatus.

  data  ls_msg        type symsg.

* --- Transaction handling ---------------------------------
  call method me->checks_before_access
    exporting
      iv_method               = 'G'
      iv_change_node          = if_identity_definition=>gc_node_lockdata
      iv_request_before_image = iv_request_before_image
    importing
      es_msg                  = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

  call method me->get_lockstatus
    exporting
      iv_request_before_image   = iv_request_before_image
    importing
      ev_locked_by_admin        = ev_locked_by_admin
      ev_locked_by_global_admin = ev_locked_by_global_admin
      ev_locked_by_failed_logon = ev_locked_by_failed_logon
      eo_msg_buffer             = eo_msg_buffer.

endmethod.


method if_identity~get_logondata.

  data: ls_msg type symsg.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_logondata.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_logondata
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    return.
  endif.


  call method me->get_logondata
    exporting
      iv_request_before_image = iv_request_before_image
      iv_get_grp_text         = iv_get_grp_text
    importing
      es_logondata            = es_logondata.


endmethod.


method if_identity~get_parameters.


  data: ls_msg           type          symsg
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: et_parameters.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  checks_before_access(
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_parameter
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg
       ).

  if ls_msg-msgty = 'E'.
    return.
  endif.

  call method me->get_parameters
    exporting
      iv_request_before_image = iv_request_before_image
      iv_get_text             = iv_get_text
    importing
      et_parameters           = et_parameters
      eo_msg_buffer           = eo_msg_buffer.


endmethod.


METHOD if_identity~get_profiles.

  DATA: lv_msg_data                   TYPE symsg.

  eo_msg_buffer = me->go_msg_buffer.
* clear output table
  CLEAR et_profiles.

* Get values only in CREATE or CHANGE or DISPLAY mode
  CALL METHOD checks_before_access
    EXPORTING
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_profile
      iv_request_before_image = iv_request_before_image
    IMPORTING
      es_msg         = lv_msg_data.

  IF lv_msg_data-msgty = 'E'.
* Return to caller if not authorized
    RETURN.
  ENDIF.

* read profiles
  me->get_profiles(
    EXPORTING
      iv_get_prof_details     = iv_get_prof_details
      iv_request_before_image = iv_request_before_image
    IMPORTING
      et_profiles             = et_profiles
      eo_msg_buffer           = eo_msg_buffer ).


ENDMETHOD.


method if_identity~get_reference_user.

  data: ls_msg type symsg
       .

* Initialize Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear es_reference_user.

* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_reference_user
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    clear: es_reference_user.
    return.
  endif.


  call method me->get_reference_user
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      es_reference_user       = es_reference_user
      eo_msg_buffer           = eo_msg_buffer.


endmethod.


method if_identity~get_roles.

  data: lr_node_role          type ref to   suid_st_node_role
      , ls_node_role_detail   type          suid_st_node_role_detail
      , ls_role_name          type          suid_st_role_name
      , ls_node_role_adjust   type          suid_st_node_role_adjustment
      , lt_parent_role        type          suid_tt_role_name
      , lv_msg_data           type          symsg
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.

  " clear output table
  clear: et_roles, ev_adjustment_required.
  if iv_get_role_details eq if_identity~co_true.
    clear et_role_details.
  endif.
  if iv_get_role_members eq if_identity~co_true.
    clear et_role_members.
  endif.
  if iv_get_role_adjustments eq if_identity~co_true.
    clear et_role_adjustments.
  endif.

  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method               = 'G'
      iv_change_node          = if_identity_definition=>gc_node_role
      iv_request_before_image = iv_request_before_image
    importing
      es_msg                  = lv_msg_data.

  if lv_msg_data-msgty = 'E'.
    " Return to caller if not authorized
    return.
  endif.

  " read internal segments
  me->get_roles(
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      et_roles                = et_roles
      eo_msg_buffer           = eo_msg_buffer ).

  " --- Read values --------------------------------
  if  iv_get_role_details         eq if_identity~co_true or
      iv_get_role_members         eq if_identity~co_true or
      iv_get_role_adjustments     eq if_identity~co_true or
      iv_get_profile_sync_status  eq if_identity~co_true.

    loop at et_roles reference into lr_node_role.

      " fill exporting table et_role_detail
      if iv_get_role_details eq if_identity~co_true.
        clear ls_node_role_detail.
        ls_node_role_detail-agr_name  = lr_node_role->agr_name.
        insert ls_node_role_detail into table et_role_details.
      endif.

      " fill exporting table et_role_member
      if iv_get_role_members eq if_identity~co_true.
        clear ls_role_name.
        ls_role_name-agr_name = lr_node_role->agr_name.
        insert ls_role_name into table lt_parent_role.
      endif.

      " fill exporting table et_role_adjustment
      if iv_get_role_adjustments eq if_identity~co_true or
        iv_get_profile_sync_status eq if_identity~co_true.
        clear ls_node_role_adjust.
        ls_node_role_adjust-agr_name  = lr_node_role->agr_name.
        ls_node_role_adjust-from_dat  = lr_node_role->from_dat.
        ls_node_role_adjust-to_dat    = lr_node_role->to_dat.
        insert ls_node_role_adjust into table et_role_adjustments.
      endif.
    endloop.
  endif.

  " fetch additional role information: text, type and profile adjustment infos
  if iv_get_role_details eq if_identity~co_true.

    delete adjacent duplicates from et_role_details.

    " --- Read text of roles --------------------------------
    call method me->roles_add_text
      changing
        ct_node_roles = et_role_details.

    " --- Read type of roles --------------------------------
    call method me->roles_add_type
      changing
        ct_node_roles = et_role_details.

  endif.

  " fetch additional role information: parent-child hierarchy
  if iv_get_role_members eq if_identity~co_true.

    delete adjacent duplicates from lt_parent_role.

    " --- provide additional info of parent role in node of role ----------------
    call method me->roles_add_parent_information
      exporting
        it_role_name  = lt_parent_role
      importing
        et_node_roles = et_role_members.

  endif.

  " fetch additional role information: text, type and profile adjustment infos
  if iv_get_role_adjustments eq if_identity~co_true or
    iv_get_profile_sync_status eq if_identity~co_true.

    " --- add information if profiles have to be updated -----------------------
    call method me->profile_add_adjustment_info
      importing
        ev_adjustment_required = ev_adjustment_required
      changing
        ct_node_roles          = et_role_adjustments.

  endif.

  sort et_roles.

endmethod.


method if_identity~get_snc.

  data: ls_msg type symsg.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_snc.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_snc
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

  call method me->get_snc
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      eo_msg_buffer           = eo_msg_buffer
      es_snc                  = es_snc.


endmethod.


method if_identity~get_snc_equi_names.

  data: ls_msg type symsg.

  field-symbols: <ls_snc> type usracl.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  refresh: et_equi_names.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_snc_equi_name
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

* --- Fill buffer ------------------------------------------
*
* Check snc buffer
  if ms_segment_snc-bname is initial.
    call method fetch_segment_snc.
  endif.

* Read actual or before image?
  if iv_request_before_image is initial.
    assign ms_segment_snc-actual to <ls_snc>.
  else.
    assign ms_segment_snc-before_image to <ls_snc>.
  endif.

* --- Read values --------------------------------
  if <ls_snc>-knamelen > 0.
*   Temporary !

*   Other user with same canonical name
    select mandt bname pname from usracl client specified
      into table et_equi_names
      where hname = <ls_snc>-hname
      order by mandt bname.          "#EC CI_GENBUFF "#EC CI_BUFFCLIENT

    delete et_equi_names where mandt = sy-mandt
                           and bname = <ls_snc>-bname.
  endif.

endmethod.


method if_identity~get_technical_user_data.

  data: ls_msg type symsg
       .

  field-symbols: <ls_address> type usr21.

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_tech_user_data.


  " --- Transaction handling ---------------------------------
  "
  " Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method               = 'G'
      iv_change_node          = if_identity_definition=>gc_node_tech_user_data
      iv_request_before_image = iv_request_before_image
    importing
      es_msg                  = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

  call method me->get_technical_user_data
    exporting
      iv_request_before_image = iv_request_before_image
    importing
      eo_msg_buffer           = eo_msg_buffer
      es_tech_user_data       = es_tech_user_data.


endmethod.


method if_identity~get_technical_user_indicator.

  data: ls_msg type symsg.

  field-symbols: <ls_address> type usr21.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_tech_user.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_tech_user
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.
* --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


* Get actual or before image?
  if iv_request_before_image is initial.
    assign ms_segment_address-actual to <ls_address>.
  else.
    assign ms_segment_address-before_image to <ls_address>.
  endif.


* ------ Get data depending on identity model -----------
*
  case <ls_address>-idadtype.

*...------ User with address --------------------------------------
    when if_identity=>co_idad_olduser         or
         if_identity=>co_idad_person          or
         if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      es_tech_user-tech_indicator = if_identity=>co_false.


*...------ Technical user ----------------------------------
    when if_identity=>co_idad_techuser.
      es_tech_user-tech_indicator = if_identity=>co_true.


*...------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.



endmethod.


method if_identity~get_uclass.

  data: ls_uclass type usr06
       ,ls_msg    type symsg
       .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  clear: es_uclass.


* --- Transaction handling ---------------------------------
*
* Get values only in CREATE or CHANGE or DISPLAY mode
  call method checks_before_access
    exporting
      iv_method      = 'G'
      iv_change_node = if_identity_definition=>gc_node_uclass
      iv_request_before_image = iv_request_before_image
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.


* --- Fill buffer ------------------------------------------
*
* Check uclass buffer
  if ms_segment_uclass-bname is initial.
    call method fetch_segment_uclass.
  endif.

* Read before or actual image?
  if iv_request_before_image is initial.
    ls_uclass = ms_segment_uclass-actual.
  else.
    ls_uclass = ms_segment_uclass-before_image.
  endif.

* --- Read values --------------------------------
  es_uclass-lic_type          = ls_uclass-lic_type.
  es_uclass-substitute_from   = ls_uclass-vondat.
  es_uclass-substitute_until  = ls_uclass-bisdat.
  es_uclass-client            = ls_uclass-mandt2.
  es_uclass-sysid             = ls_uclass-sysid.
  es_uclass-bname_chargeable  = ls_uclass-aname.
  es_uclass-spec_vers         = ls_uclass-spras.
  es_uclass-country_surcharge = ls_uclass-surcharge.


endmethod.


method if_identity~set_defaults.

  call method me->set_defaults
    exporting
      is_defaults      = is_defaults
      it_change_fields = it_change_fields
    importing
      eo_msg_buffer    = eo_msg_buffer
      eo_notify        = eo_notify.

endmethod.


method if_identity~set_documentation.

  data: ls_msg               type        symsg
      , ls_new_docu          type        usdocu
      , lt_old_docu          type        suid_tt_usdocu
      , lv_error             type        abap_bool
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_documentation
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " --- Check docu buffer ---
  if ms_segment_docu-bname is initial.
    fetch_segment_docu( ).
  endif.

  " --- Read from actual image into old structure ---------------
  "
  move ms_segment_docu-actual to lt_old_docu.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_documentation.

  " Delete all messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_documentation
      iv_lifetimeonce_only = 'X'.

  " --- Set values ------------------------------------------
  "
  if is_docu-docu is initial.
    "delete entry
    delete ms_segment_docu-actual where modbe = ''.

  else.
    " Insert/update entry
    move is_docu-docu     to ls_new_docu-docu.
    move sy-mandt         to ls_new_docu-mandt.
    move ms_manager-bname to ls_new_docu-bname.

    read table ms_segment_docu-actual with key modbe = '' transporting no fields.

    if sy-subrc = 0.
      modify ms_segment_docu-actual from ls_new_docu index sy-tabix transporting docu..
    else.
      insert ls_new_docu into table ms_segment_docu-actual.
    endif.

  endif.

  " --- Transaction handling ---------------------------------
  "

  " Notification
  if ms_segment_docu-actual ne lt_old_docu.
    go_notify->notify_update(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_documentation ).

  endif.


  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_documentation
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   "  New node status: CHECKED
    ms_manager-sn_docu = go_persistence->co_node_status_checked.
  else.                                   "  New node status: CHANGED
    ms_manager-sn_docu = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_docu-actual ne ms_segment_docu-before_image.
    ms_segment_docu-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_docu-status.
  endif.

endmethod.


method if_identity~set_groups.


* GC_NODE_GROUPS - GC_FIELD_GROUPS_USERGROUP
*   E518(01) - User group & does not exist.
*   E408(01) - An entry already exists for group &
*   E491(01) - You are not authorized to create users in group &
*   E526(01) - You are not authorized to remove group &


  data: lt_check_groups   type        suid_tt_node_groups
      , lt_insert_groups  type        suid_tt_node_groups
      , lr_insert_groups  type ref to suid_st_node_group
      , lr_groups         type ref to suid_st_node_group
      , lr_check_groups   type ref to suid_st_node_group
      , ls_seg_groups     type        usgrp_user
      , lv_tabix          type        sy-tabix
      , lv_ins_tabix      type        sy-tabix
      , ls_msg            type        symsg
      , lv_error          type        sesf_boolean
      , lv_no_maintain    type        sesf_boolean
      .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode

  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node  = if_identity_definition=>gc_node_group
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
* Return to caller
    return.
  endif.

* Lazy fetch of groups segment
  if ms_segment_groups-bname is initial.
    call method fetch_segment_groups.
  endif.


* Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_group.

*   Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_group
      iv_lifetimeonce_only = if_identity=>co_true.

* --- Maintenance check ------------------------------------------------
*
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_group
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

*   If node cannot be maintaind - leave
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.



* --- Check entries with change_mode = space, delete -------------------
*
* Comment: - Check only values, which are in the importing table
*          - Handle first change_mode = space ,delete
*          -> Key (Usergroup) must be unique
*          -> Duplicate entries are only allowed for change_mode = insert
  loop at it_groups reference into lr_groups
       where change_mode ne if_identity=>co_insert.

    if lr_groups->change_mode ne space     and
       lr_groups->change_mode ne if_identity=>co_delete.
*     Wrong change mode: Only space, delete (or insert) are allowed
      raise exception type cx_suid_identity
        exporting
          textid   = cx_suid_identity=>internal_error
          bname    = ms_manager-bname.
    endif.

*   Delete messages for group which should be checked
    gv_macro_key = lr_groups->usergroup.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_group
        iv_key      = gv_macro_key.

*   Check: Entry must exist in actual image
    read table ms_segment_groups-actual
         with key usergroup = lr_groups->usergroup
         transporting no fields
         binary search.
    if sy-subrc ne 0.
*     Ignore group or warning
      continue.
    else.
*     Entry must be unique in check_table
      read table lt_check_groups
           with key usergroup = lr_groups->usergroup
           transporting no fields
           binary search.
      if sy-subrc ne 0.
*       Insert into checktable
        insert lr_groups->* into lt_check_groups index sy-tabix.
      else.
*       Duplicate entries in IT_GROUPS -> Exception
        raise exception type cx_suid_identity
          exporting
            textid   = cx_suid_identity=>internal_error
            bname    = ms_manager-bname.
      endif.
    endif.

  endloop.

* Check groups with change_mode: space, delete
  if lt_check_groups is not initial.
    call method check_groups_internal
      exporting
        iv_bname      = ms_manager-bname
        io_msg_buffer = go_msg_buffer
*       io_notify     = go_notify
      changing
        ct_groups     = lt_check_groups.
  endif.

* --- Move values to segements Part I ------------------------
* Take over groups which can be deleted
  loop at lt_check_groups reference into lr_check_groups
       where change_mode eq if_identity=>co_delete.

    read table ms_segment_groups-actual
         with key usergroup = lr_check_groups->usergroup
         transporting no fields
         binary search.
    lv_tabix = sy-tabix.
    if sy-subrc eq 0.
      delete ms_segment_groups-actual index lv_tabix.
*     Notification: Node successful deleted
      gv_macro_key = lr_check_groups->usergroup.
      call method go_notify->notify_delete
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_group
          iv_key        = gv_macro_key
          iv_key_handle = lr_check_groups->key_handle.
    endif.
  endloop.


* --- Check entries with change_mode = insert -------------------
*
* Comment: -> -> Duplicate entries -> errormessage
  loop at it_groups reference into lr_groups
       where change_mode eq if_identity=>co_insert.
*   No error messages or notifications exist ?!

*   Ignore insert of space entry
    if lr_groups->usergroup is initial.
      continue.
    endif.

*   Check for duplicates in IT_GROUPS
    read table lt_insert_groups
         with key usergroup = lr_groups->usergroup
         transporting no fields
         binary search.
    lv_ins_tabix = sy-tabix. " Remind position
    clear: lv_error.

    if sy-subrc eq 0.
      lv_error = 'X'.
    else.
*     Check if group alread exists in actual image
      read table ms_segment_groups-actual
           with key usergroup = lr_groups->usergroup
           transporting no fields
           binary search.
      if sy-subrc eq 0.
        lv_error = 'X'.
      else.
*       Insert into insert_check_table
        insert lr_groups->* into lt_insert_groups index lv_ins_tabix.
      endif.
    endif.


    if lv_error eq 'X'.
      clear: ls_msg.
      ls_msg-msgv1 = lr_groups->usergroup.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '408'.
*     MSG: An entry already exists for group &
      if 1 = 0. message e408(01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_groups->usergroup.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_group
          iv_key        = gv_macro_key
          iv_key_handle = lr_groups->key_handle
          iv_field      = if_identity_definition=>gc_field_group_usergroup
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

*     ->>> Different error handling in CUA and SCUG !!!

*     Node creation failed
      call method go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_group
          iv_key        = gv_macro_key
          iv_key_handle = lr_groups->key_handle.

    endif.
  endloop.


* Check groups with change_mode: insert
  if lt_insert_groups is not initial.
    call method check_groups_internal
      exporting
        iv_bname      = ms_manager-bname
        io_msg_buffer = go_msg_buffer
      changing
        ct_groups     = lt_insert_groups.
  endif.


* --- Move values to segements Part II ------------------------
* Take over groups which can be inserted
  loop at lt_insert_groups reference into lr_insert_groups.

    case lr_insert_groups->change_mode.

      when if_identity=>co_failed_create.
*       Insertion failed
        gv_macro_key = lr_insert_groups->usergroup.
        call method go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_group
            iv_key        = gv_macro_key
            iv_key_handle = lr_insert_groups->key_handle.
        continue.

      when if_identity=>co_insert.
*       Insert actual image
        read table ms_segment_groups-actual
             with key usergroup = lr_insert_groups->usergroup
             transporting no fields
             binary search.
        lv_tabix = sy-tabix.

        if sy-subrc ne 0.
          clear: ls_seg_groups.
          ls_seg_groups-usergroup = lr_insert_groups->usergroup.
          ls_seg_groups-bname     = ms_manager-bname.
          ls_seg_groups-mandt     = sy-mandt.
          insert ls_seg_groups into ms_segment_groups-actual index lv_tabix.

*         Notification Node created
          gv_macro_key = lr_insert_groups->usergroup.
          call method go_notify->notify_create
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_group
              iv_key        = gv_macro_key
              iv_key_handle = lr_insert_groups->key_handle.
        endif.
    endcase.

  endloop.

* --- Transaction handling ---------------------------------
*
* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check node status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_group
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_groups = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_groups = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_groups-actual ne ms_segment_groups-before_image.
    ms_segment_groups-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_groups-status.
  endif.


endmethod.


method if_identity~set_logondata.

  call method set_logondata
    exporting
      is_logondata     = is_logondata
      it_change_fields = it_change_fields
    importing
      eo_msg_buffer    = eo_msg_buffer
      eo_notify        = eo_notify.

endmethod.


METHOD if_identity~set_optimistic_to_excl_lock.

  DATA: lt_bname                 TYPE suid_tt_bname.
  DATA: ls_bname                 TYPE suid_st_bname.
  DATA: lr_bname                 TYPE REF TO suid_st_bname_locked.
  DATA: lt_bname_not_locked      TYPE suid_tt_bname_locked.
  DATA: lv_msg_data              TYPE symsg.

* initialize return value.
  eo_msg_buffer = me->go_msg_buffer.

  IF me->ms_manager-enqmode EQ if_identity=>co_enqueue_mode_optimistic.
    ls_bname-bname = ms_manager-bname.
    INSERT ls_bname INTO TABLE lt_bname.

    CALL METHOD cl_suid_tools=>enqueue
      EXPORTING
        it_bname   = lt_bname
        i_enq_mode = cl_suid_tools=>co_lock_mode_opt_to_excl
      IMPORTING
        et_bname   = lt_bname_not_locked.

* Provide error message
    IF lt_bname_not_locked IS NOT INITIAL.
      READ TABLE lt_bname_not_locked
           with key bname = ms_manager-bname
           BINARY search
           REFERENCE INTO lr_bname.

      IF sy-subrc = 0.  " Identity could not be locked: Don't instantiate!

        CALL METHOD me->go_msg_buffer->add_object_message_symsg
          EXPORTING
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_root
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = lr_bname->msg.

        RAISE EXCEPTION TYPE cx_suid_identity
          EXPORTING
            textid    = cx_suid_identity=>invalid_enqueue_lock
            bname     = ms_manager-bname
            enq_mode  = cl_suid_tools=>co_lock_mode_opt_to_excl.

      ENDIF.

    ELSE.
      ms_manager-enqmode = cl_suid_tools=>co_enqueue_mode_opt_to_excl.
    ENDIF.

  ENDIF.

ENDMETHOD.


method if_identity~set_parameters.

* GC_NODE_PARAMETER - GC_FIELD_PARAMETER_PARID
*   E037(01) - ParameterID & does not exist.
*   E037(01) - An entry already exists for parameter &
* GC_NODE_PARAMETER - GC_FIELD_PARAMETER_PARVA
* GC_NODE_PARAMETER - GC_FIELD_PARAMETER_PARTXT


  data: lt_check_parameter   type        suid_tt_node_parameters
      , lt_insert_parameter  type        suid_tt_node_parameters
      , lr_insert_parameter  type ref to suid_st_node_parameter
      , lr_check_parameter   type ref to suid_st_node_parameter
      , lr_parameter         type ref to suid_st_node_parameter
      , lr_seg_parameter     type ref to usr05
      , ls_seg_parameter     type        usr05
      , lv_tabix             type        sy-tabix
      , lv_ins_tabix         type        sy-tabix
      , ls_msg               type        symsg
      , lv_error             type        sesf_boolean
      , lv_no_maintain       type        sesf_boolean
      .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_parameter
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
* Return to caller
    return.
  endif.


* Lazy fetch of parameter segment
  if ms_segment_parameter-bname is initial.
    call method fetch_segment_parameter.
  endif.


* Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_parameter.

*   Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_parameter
      iv_lifetimeonce_only = if_identity=>co_true.

* --- Maintenance check ------------------------------------------------
*
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_parameter
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.

* If node cannot be maintaind - leave
    if lv_no_maintain = if_identity=>co_true.
      return.
    endif.
  endif.

* --- Check entries with change_mode = space, delete, update ----------------
*
* Comment: - Check only values, which are in the importing table
*          - Handle first change_mode = space ,delete, update
*          -> Key (Parameter) must be unique
*          -> Duplicate entries are only allowed for change_mode = insert
  loop at it_parameters reference into lr_parameter
       where change_mode ne if_identity=>co_insert.

    if lr_parameter->change_mode ne space     and
       lr_parameter->change_mode ne if_identity=>co_update and
       lr_parameter->change_mode ne if_identity=>co_delete.
*     Wrong change mode: Only space, delete, update (or insert) are allowed
      raise exception type cx_suid_identity
        exporting
          textid   = cx_suid_identity=>internal_error
          bname    = ms_manager-bname.
    endif.

*   Delete messages for parameter which should be checked
    gv_macro_key = lr_parameter->parid.
    call method go_msg_buffer->delete_object_message
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_parameter
        iv_key      = gv_macro_key.

*   Check: Entry must exist in actual image
    read table ms_segment_parameter-actual
         with key parid = lr_parameter->parid
         transporting no fields
         binary search.
    if sy-subrc ne 0.
*     Ignore group or warning
      continue.
    else.
*     Entry must be unique in check_table
      read table lt_check_parameter
           with key parid = lr_parameter->parid
           transporting no fields
           binary search.
      if sy-subrc ne 0.
*       Insert into checktable
        insert lr_parameter->* into lt_check_parameter index sy-tabix.
      else.
*       Duplicate entries in IT_PARAMETER -> Exception
        raise exception type cx_suid_identity
          exporting
            textid   = cx_suid_identity=>internal_error
            bname    = ms_manager-bname.
      endif.
    endif.

  endloop.

* Check parameter with change_mode: space, delete, update
  if lt_check_parameter is not initial.
    call method check_parameters_internal
      exporting
        iv_bname      = ms_manager-bname
        io_msg_buffer = go_msg_buffer
      changing
        ct_parameters = lt_check_parameter.
  endif.

* --- Move values to segements Part I ------------------------
* Take over parameter which can be deleted or updated
  loop at lt_check_parameter reference into lr_check_parameter
       where change_mode eq if_identity=>co_delete or
             change_mode eq if_identity=>co_update.

    read table ms_segment_parameter-actual
         reference into lr_seg_parameter
         with key parid = lr_check_parameter->parid
         binary search.
    lv_tabix = sy-tabix.
    if sy-subrc eq 0.
      case lr_check_parameter->change_mode.
        when if_identity=>co_delete.
          delete ms_segment_parameter-actual index lv_tabix.
*         Notification: Node successful deleted
          gv_macro_key = lr_check_parameter->parid.
          call method go_notify->notify_delete
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_parameter
              iv_key        = gv_macro_key
              iv_key_handle = lr_check_parameter->key_handle.
        when if_identity=>co_update.
          lr_seg_parameter->parva = lr_check_parameter->parva.
*         Notification: Node successful deleted
          gv_macro_key = lr_check_parameter->parid.
          call method go_notify->notify_update
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_parameter
              iv_key        = gv_macro_key
              iv_key_handle = lr_check_parameter->key_handle.
      endcase.
    endif.
  endloop.


* --- Check entries with change_mode = insert -------------------
*
* Comment: -> -> Duplicate entries -> errormessage
  loop at it_parameters reference into lr_parameter
       where change_mode eq if_identity=>co_insert.

*   No error messages or notifications exist ?!

*   Check for duplicates in IT_PARAMETER
    read table lt_insert_parameter
         with key parid = lr_parameter->parid
         transporting no fields
         binary search.
    lv_ins_tabix = sy-tabix. " Remind position
    clear: lv_error.

    if sy-subrc eq 0.
      lv_error = 'X'.
    else.
*     Check if parameter alread exists in actual image
      read table ms_segment_parameter-actual
           with key parid = lr_parameter->parid
           transporting no fields
           binary search.
      if sy-subrc eq 0.
        lv_error = 'X'.
      else.
*       Insert into insert_check_table
        insert lr_parameter->* into lt_insert_parameter index lv_ins_tabix.
      endif.
    endif.

    if lv_error eq 'X'.
      clear: ls_msg.
      ls_msg-msgv1 = lr_parameter->parid.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '093'.
*         MSG: An entry already exists for parameter &
      if 1 = 0. message e093(01) with ls_msg-msgv1. endif.
      gv_macro_key = lr_parameter->parid.
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_parameter
          iv_key      = gv_macro_key
          iv_key_handle = lr_parameter->key_handle
          iv_field    = if_identity_definition=>gc_field_parameter_parid
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.

*     Node creation failed
      call method go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_parameter
          iv_key        = gv_macro_key
          iv_key_handle = lr_parameter->key_handle.

*         ->>> Different error handling in CUA and SCUG !!!
      continue.
    endif.
  endloop.


* Check parameter with change_mode: insert
  if lt_insert_parameter is not initial.
    call method check_parameters_internal
      exporting
        iv_bname      = ms_manager-bname
        io_msg_buffer = go_msg_buffer
      changing
        ct_parameters = lt_insert_parameter.
  endif.


* --- Move values to segements Part II ------------------------
* Take over parameter which can be inserted
  loop at lt_insert_parameter reference into lr_insert_parameter.

    case lr_insert_parameter->change_mode.

      when if_identity=>co_failed_create.
*       Insertion failed
        gv_macro_key = lr_insert_parameter->parid.
        call method go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_parameter
            iv_key        = gv_macro_key
            iv_key_handle = lr_insert_parameter->key_handle.
        continue.

      when if_identity=>co_insert.
*       Insert actual image
        read table ms_segment_parameter-actual
             with key parid = lr_insert_parameter->parid
             transporting no fields
             binary search.
        lv_tabix = sy-tabix.

        if sy-subrc ne 0.
          clear: ls_seg_parameter.
          ls_seg_parameter-parid = lr_insert_parameter->parid.
          ls_seg_parameter-parva = lr_insert_parameter->parva.
          ls_seg_parameter-bname = ms_manager-bname.
          ls_seg_parameter-mandt = sy-mandt.
          insert ls_seg_parameter into ms_segment_parameter-actual index lv_tabix.

*         Notification Node created
          gv_macro_key = lr_insert_parameter->parid.
          call method go_notify->notify_create
            exporting
              iv_bname      = ms_manager-bname
              iv_nodename   = if_identity_definition=>gc_node_parameter
              iv_key        = gv_macro_key
              iv_key_handle = lr_insert_parameter->key_handle.
        endif.
    endcase.

  endloop.


* --- Transaction handling ---------------------------------
*
* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check node status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_parameter
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_parameter = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_parameter = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_parameter-actual ne ms_segment_parameter-before_image.
    ms_segment_parameter-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_parameter-status.
  endif.


endmethod.


method if_identity~set_profiles.
*
* Uses case:
* - Manual assignments of profiles (SU01, PFCG,..)
* - Non-CUA and CUA
*

  data: lt_profiles                 type          suid_tt_node_profiles
      , lv_invalid                  type          sesf_boolean value if_identity=>co_true
      , lt_cua_profiles             type          suid_tt_node_cua_profiles
      , lr_profile                  type ref to   suid_st_node_profile
      , ls_profile                  type          suid_st_node_profile
      , ls_cua_profile              type          suid_st_node_cua_profile
      , lr_cua_profile              type ref to   suid_st_node_cua_profile
      , lt_node_cua_profiles        type          suid_tt_node_cua_profiles
      , lv_cua_master               type          uszbvlndsc-sendsystem
      , lv_no_maintain              type          sesf_boolean value if_identity=>co_false
      , lt_assigned_systems         type          suid_tt_node_cua_systems
      , ls_new_system               type          suid_st_node_cua_system
      , lt_new_systems              type          suid_tt_node_cua_systems
      , lt_error_systems            type          tt_error_systems
      , lt_node_profiles_failed     type          suid_tt_node_profiles
      , lv_tabix                    type          sy-tabix
      , lv_msg_key_value            type          string
      , ls_msg                      type          symsg
      .

  " initialize export parameter
  eo_msg_buffer   = go_msg_buffer.
  eo_notify       = go_notify.

  " check if node can be maintained
  call method me->roles_validate_cua_master
    exporting
      iv_bname            = ms_manager-bname
      iv_node_name        = if_identity_definition=>gc_node_profile
    importing
      ev_cua_master       = lv_cua_master
      ev_no_maintain_node = lv_invalid.

  " Node can't be maintained: do not proceed
  if lv_invalid eq if_identity=>co_true and lv_cua_master is initial.
    " message is already written by check_field_maintain into message buffer
    return.
  endif.

  lt_profiles = it_profiles.

  " In central system: Call CUA method
  " else: call local method
  if lv_cua_master is not initial.
    " Global or local assignment
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_profile
      receiving
        rv_no_maintain = lv_no_maintain.

    if lv_no_maintain = if_identity=>co_false.
      " --- Global profile assignment ---
      loop at lt_profiles reference into lr_profile.
        ls_cua_profile-subsystem = lv_cua_master.
        move-corresponding lr_profile->* to ls_cua_profile.
        append ls_cua_profile to lt_cua_profiles.
      endloop.

      call method me->profile_cua_set_internal
        exporting
          it_profiles          = lt_cua_profiles
        importing
          eo_msg_buffer        = eo_msg_buffer
          eo_notify            = eo_notify
          et_node_cua_profiles = lt_node_cua_profiles.

      " Importing table + keyhandle
      loop at lt_node_cua_profiles reference into lr_cua_profile
        where subsystem eq lv_cua_master.
        move-corresponding lr_cua_profile->* to ls_profile.
        append ls_profile to et_node_profiles.
      endloop.

      " Exhange CUA node information
      me->go_msg_buffer->exchange_cua_nodes( exporting iv_bname = ms_manager-bname ).
      me->go_notify->exchange_cua_nodes( exporting iv_bname = ms_manager-bname ).

    else.
      " --- Local profile assignment in central system ---
      " Check if central system must be assigned
      read table lt_profiles with key change_mode = if_identity=>co_insert
           transporting no fields.
      if sy-subrc eq 0.
        " get cua_systems without checking authority
        call method me->get_cua_systems
          exporting
            iv_get_text    = if_identity=>co_false
          importing
            et_cua_systems = lt_assigned_systems.

        read table lt_assigned_systems with key subsystem = lv_cua_master
             transporting no fields.
        if sy-subrc ne 0.
          clear ls_new_system.
          ls_new_system-subsystem   = lv_cua_master.
          ls_new_system-change_mode = if_identity=>co_insert.
          insert ls_new_system into table lt_new_systems.

          call method me->cua_set_syst_assignment
            importing
              et_error_systems  = lt_error_systems
            changing
              ct_assign_systems = lt_new_systems.
        endif.

        " Write error message
        if lt_error_systems is not initial.
          loop at lt_profiles reference into lr_profile
            where change_mode eq if_identity=>co_insert.

            lv_tabix         = sy-tabix.

            " Keep line: Insert failed
            lr_profile->change_mode = if_identity=>co_failed_create.
            append lr_profile->* to lt_node_profiles_failed.
            delete lt_profiles index lv_tabix.
          endloop.
        endif.
      endif.

      " Call set_profile anyway
      call method me->profile_set
        importing
          eo_msg_buffer    = eo_msg_buffer
          eo_notify        = eo_notify
          et_node_profiles = et_node_profiles
        changing
          ct_profiles      = lt_profiles.

      " Append error messages
      loop at lt_node_profiles_failed reference into lr_profile.
        lv_msg_key_value = lr_profile->profile.

        " Keine Berechtigung zur Zuordnung des Systems &1 (Profil &2)
        if 1 = 0. message e573(01) with space space. endif. "#EC *
        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '573'.
        ls_msg-msgv1 = lv_cua_master.
        ls_msg-msgv2 = lr_profile->profile.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_profile
            iv_key        = lv_msg_key_value
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_key_handle = lr_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_profile_profile
            is_msg        = ls_msg.

        call method me->go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_profile->key_handle.
      endloop.
      append lines of lt_node_profiles_failed to et_node_profiles.
    endif.

  else.
    " --- Local profile assignment ---
    " Without CUA, IDOC processing, target system with local role assignment
    call method me->profile_set
      importing
        eo_msg_buffer    = eo_msg_buffer
        eo_notify        = eo_notify
        et_node_profiles = et_node_profiles
      changing
        ct_profiles      = lt_profiles.
  endif.


endmethod.


method if_identity~set_reference_user.

  data: ls_msg                type symsg
      , lt_change_fields      type suid_tt_fields
      , lv_string             type string
      , ls_old_reference_user type suid_st_node_reference_user
      , ls_new_reference_user type suid_st_node_reference_user
      , lv_class              type xuclass
      , lv_is_authorized      type sesf_boolean
      , lv_key                type string
      , lv_error              type sesf_boolean
      .


  " Initialize exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_reference_user.

  " Delete all messages belonging to this node (because there is only one field
  " in this structure we don't have to distinguish complete node change and
  " specific field of node change)
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_reference_user.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_reference_user
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller if not authorized
    return.
  endif.

  " Check buffer
  if ms_segment_refuser-bname is initial.
    call method fetch_segment_refuser.
  endif.

  " --- verify input values ----------------------------------------
  call method verify_node_fields
    exporting
      it_change_fields     = it_change_fields
      iv_node_name         = if_identity_definition=>gc_node_reference_user
    importing
      et_changeable_fields = lt_change_fields.

  if lt_change_fields is initial.
    " return to caller because field cannot be modified
    return.
  endif.


  " --- Check values ----------------------------------------
  " Read from actual image into old structure
  ls_old_reference_user-refuser = ms_segment_refuser-actual-refuser.
  lv_string                     = is_reference_user.
  ls_new_reference_user-refuser = cl_suid_tools=>to_upper_case( lv_string ).

  if ls_old_reference_user is initial and
     ls_new_reference_user is initial.
    " Ignore this case
    return.
  endif.

  " Check:
  " - existence of new reference user
  " - verify user type reference
  " - authorizations
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  call method cl_identity=>check_reference_user_internal
    exporting
      iv_bname              = ms_manager-bname
      iv_class              = lv_class
      io_msg_buffer         = go_msg_buffer
    importing
      ev_is_authorized      = lv_is_authorized
    changing
      cs_old_reference_user = ls_old_reference_user
      cs_new_reference_user = ls_new_reference_user.

  " Check failed
  if lv_is_authorized eq if_identity=>co_false.
    return.
  endif.


  " --- Move values to segements ----------------------------
  "
  ms_segment_refuser-actual-refuser = ls_new_reference_user-refuser.


  " --- Transaction handling ---------------------------------
  "

  " Notification
  if ls_old_reference_user ne ls_new_reference_user.
    " Notification
    lv_key = ls_new_reference_user-refuser.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_reference_user
        iv_key      = lv_key.
  endif.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_reference_user
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false. " New node status: CHECKED
    ms_manager-sn_refuser = go_persistence->co_node_status_checked.
  else.                                 " New node status: CHANGED
    ms_manager-sn_refuser = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_refuser-actual ne ms_segment_refuser-before_image.
    ms_segment_refuser-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_refuser-status.
  endif.


endmethod.


method if_identity~set_roles.
*
* Uses case:
* - Manual assignments of roles (SU01, PFCG,..)
* - Non-CUA and CUA
*

* initialize export parameter
  eo_msg_buffer   = go_msg_buffer.
  eo_notify       = go_notify.
  clear: et_node_roles.


  call method me->roles_set_internal
    exporting
      it_roles      = it_roles
    importing
      et_node_roles = et_node_roles
      eo_msg_buffer = eo_msg_buffer
      eo_notify     = eo_notify.


endmethod.


method if_identity~set_snc.

* GC_NODE_SNC - GC_FIELD_SNC_GUIFLAG (No Error)
* GC_NODE_SNC - GC_FIELD_SNC_PNAME
*   W030(SNC) - Unable to determine the canonical SNC name
*               Only warnings, because it should be possible to save PNAME
* GC_NODE_SNC - GC_FIELD_SNC_CNAME (Not set)
* GC_NODE_SNC - GC_FIELD_SNC_CDATE (Not set)
* GC_NODE_SNC - GC_FIELD_SNC_CTIME (Not set)
* GC_NODE_SNC - GC_FIELD_SNC_MNAME (Not set)
* GC_NODE_SNC - GC_FIELD_SNC_MDATE (Not set)
* GC_NODE_SNC - GC_FIELD_SNC_MTIME (Not set)


* SNC errorcodes (see file sncxx.h)
  constants:
        lc_sncerr_bad_nt_prefix type i value -35
      , lc_sncerr_unknown_mech  type i value -38
      , lc_sncerr_not_active    type i value -999
      , lc_snc_others           type i value 1
      , lc_abap_others          type i value 2
      .

  data: lr_field                type ref to suid_node_field
      , lv_error                type        sesf_boolean
      , ls_msg                  type        symsg
      , lv_rc                   type        sy-subrc
      , ls_check_snc            type        suid_st_node_snc
      , lt_change_fields        type        suid_tt_fields
      , ls_old_snc              type        suid_st_node_snc
      , lv_check_hname          type        snc_hname
      , lv_check_knamelen       type        long_len
      , lv_check_kname          type        snc_kname
      , lv_no_maintain          type        sesf_boolean
      , lv_lifetimeonce_only    type        xfeld
      .

  field-symbols: <lv_newfield>     type any
               , <lv_checkfield>   type any
               .



* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_snc
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
* Return to caller
    return.
  endif.

* Lazy fetch of segment snc
  if ms_segment_snc-bname is initial.
    call method fetch_segment_snc.
  endif.

* Read from actual image into old structure
  ls_old_snc-guiflag = ms_segment_snc-actual-guiflag.
  ls_old_snc-pname   = ms_segment_snc-actual-pname.
* Is canonical name defined?
  if ms_segment_snc-actual-knamelen > 0.
    ls_old_snc-knamestat = if_identity=>co_true.
  else.
    ls_old_snc-knamestat = if_identity=>co_false.
  endif.

* Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_snc.




* --- Set values ------------------------------------------
*
  move ls_old_snc to ls_check_snc.
  lv_check_knamelen = ms_segment_snc-actual-knamelen.
  lv_check_kname    = ms_segment_snc-actual-kname.
  lv_check_hname    = ms_segment_snc-actual-hname.

  if it_change_fields is initial.
*   All messages (lifetime_once and permanent) should be deleted
*   for the node

*   Move only GUIFLAG and PNAME of node SNC
*   - timestamps are set later ( CNAME, CDATE, CTIME, MNAME, MDATE, MTIME )
    append if_identity_definition=>gc_field_snc_guiflag to lt_change_fields.
    append if_identity_definition=>gc_field_snc_pname   to lt_change_fields.

  else.
    lt_change_fields     = it_change_fields.
    lv_lifetimeonce_only = if_identity=>co_true.
  endif.

* Delete messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_snc
      iv_lifetimeonce_only = lv_lifetimeonce_only.

* Check maintenance
* SNC has one field attribute for all fields
  if gv_cua_child = if_identity=>co_true.
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_snc
        io_msg_buffer  = go_msg_buffer
      receiving
        rv_no_maintain = lv_no_maintain.
  endif.

  loop at lt_change_fields reference into lr_field.
    if it_change_fields is not initial.
*     Delete lifetime_permanent messages  belonging to this field
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_snc
          iv_field    = lr_field->*.
    endif.

*   Move only GUIFLAG and PNAME of node SNC
*   - timestamps are set later ( CNAME, CDATE, CTIME, MNAME, MDATE, MTIME )
    if lr_field->* <> if_identity_definition=>gc_field_snc_guiflag and
       lr_field->* <> if_identity_definition=>gc_field_snc_pname.
      delete lt_change_fields.
      continue.
    endif.

*   Field can't be maintained --> delete it from further processing
    if lv_no_maintain = if_identity=>co_true.
      delete lt_change_fields.
      continue.
    endif.

*   Get new value of changed field
    assign component lr_field->* of structure is_snc to <lv_newfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    assign component lr_field->* of structure ls_check_snc to <lv_checkfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

*   Move node field value
    <lv_checkfield> = <lv_newfield>.
  endloop.

* If no field can be changed - leave
  if lt_change_fields is initial.
    return.
  endif.

* === Start: Check values =============================================
*
* ----- GUIFLAG ------------------------------------------------------
*
  read table lt_change_fields from if_identity_definition=>gc_field_snc_guiflag
       transporting no fields.
  if sy-subrc eq 0.
    if ls_check_snc-guiflag is not initial.
      if ls_check_snc-guiflag ne 'X'.
        ls_check_snc-guiflag = 'X'.
      endif.
    endif.
  endif.

* ----- SNC-Name ------------------------------------------------------
*
  read table lt_change_fields from if_identity_definition=>gc_field_snc_pname
       transporting no fields.
  if sy-subrc eq 0.

    if     ls_check_snc-pname is initial.

      clear: lv_check_hname,
             lv_check_knamelen,
             lv_check_kname.

    elseif ls_check_snc-pname eq '*'.

      clear: lv_check_knamelen,
             lv_check_kname.

      lv_check_hname = '*'.

    else.

*     Kanonischer Name bestimmen
      call function 'SNC_CONVERT_PNAME_TO_KNAME'
        exporting
          pname          = ls_check_snc-pname
        importing
          knamelen       = lv_check_knamelen
          kname          = lv_check_kname
          hname          = lv_check_hname
          rc             = lv_rc
        exceptions
          internal_error = 1
          others         = 16.

      if sy-subrc ne 0    or lv_rc    ne 0.

        if lv_rc ne 0.
          case lv_rc.
            when lc_sncerr_not_active.
*             No error message
*              clear: ls_msg.
*              write lc_sncerr_not_active to ls_msg-msgv1 left-justified.
*              ls_msg-msgty = 'W'. ls_msg-msgid = 'SNC'. ls_msg-msgno = '030'.
**             MSG: Unable to determine the canonical SNC name - SNC not active
*              if 1 = 0. message w030(snc) with ls_msg-msgv1 ''. endif.
*
*              call method go_msg_buffer->add_object_message_symsg
*                exporting
*                  iv_bname    = ms_manager-bname
*                  iv_nodename = if_identity_definition=>gc_node_snc
*                  iv_field    = if_identity_definition=>gc_field_snc_pname
*                  is_msg      = ls_msg.

            when lc_sncerr_unknown_mech.
              clear: ls_msg.
              data: p1 type i, p2 type i, l type i.
              if ls_check_snc-pname ca '/'. endif.          "#EC NEEDED
              p1 = sy-fdpos.
              if ls_check_snc-pname ca ':'. endif.          "#EC NEEDED
              p2 = sy-fdpos.
              add 1 to p1. l = p2 - p1.
              if l > 0.
                ls_msg-msgv2 = ls_check_snc-pname+p1(l).
              endif.

              write lc_sncerr_unknown_mech to ls_msg-msgv1 left-justified.
*             MSG: Unable to determine the canonical SNC name - SNC mechanism not active
              ls_msg-msgty = 'W'. ls_msg-msgid = 'SNC'. ls_msg-msgno = '030'.
              if 1 = 0. message w030(snc) with ls_msg-msgv1 ls_msg-msgv2. endif.

              call method go_msg_buffer->add_object_message_symsg
                exporting
                  iv_bname    = ms_manager-bname
                  iv_nodename = if_identity_definition=>gc_node_snc
                  iv_field    = if_identity_definition=>gc_field_snc_pname
                  is_msg      = ls_msg.

            when lc_sncerr_bad_nt_prefix.
              clear: ls_msg.
              write lc_sncerr_bad_nt_prefix to ls_msg-msgv1 left-justified.
*             MSG: Unable to determine the canonical SNC name - The SNC name is syntactically incorrect
              ls_msg-msgty = 'W'. ls_msg-msgid = 'SNC'. ls_msg-msgno = '030'.
              if 1 = 0. message w030(snc) with ls_msg-msgv1 ''. endif.

              call method go_msg_buffer->add_object_message_symsg
                exporting
                  iv_bname    = ms_manager-bname
                  iv_nodename = if_identity_definition=>gc_node_snc
                  iv_field    = if_identity_definition=>gc_field_snc_pname
                  is_msg      = ls_msg.

            when others.
              clear: ls_msg.
              write lc_snc_others to ls_msg-msgv1 left-justified.
              write lv_rc         to ls_msg-msgv2 left-justified.
*             MSG: Unable to determine the canonical SNC name - SNC error RC=&1
              ls_msg-msgty = 'W'. ls_msg-msgid = 'SNC'. ls_msg-msgno = '030'.
              if 1 = 0. message w030(snc) with ls_msg-msgv1 ls_msg-msgv2. endif.

              call method go_msg_buffer->add_object_message_symsg
                exporting
                  iv_bname    = ms_manager-bname
                  iv_nodename = if_identity_definition=>gc_node_snc
                  iv_field    = if_identity_definition=>gc_field_snc_pname
                  is_msg      = ls_msg.
          endcase.

        else.
          clear: ls_msg.
          write lc_abap_others to ls_msg-msgv1 left-justified.
          write sy-subrc       to ls_msg-msgv2 left-justified.
*         MSG: Unable to determine the canonical SNC name - SNC ABAP error RC=&1
          ls_msg-msgty = 'W'. ls_msg-msgid = 'SNC'. ls_msg-msgno = '030'.
          if 1 = 0. message w030(snc) with ls_msg-msgv1 ls_msg-msgv2. endif.

          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_snc
              iv_field    = if_identity_definition=>gc_field_snc_pname
              is_msg      = ls_msg.

        endif.

      endif.
    endif.
  endif.

* === End: Check values =============================================

* --- Move values to segements -------------------------------
*
  ms_segment_snc-actual-pname     = ls_check_snc-pname.
  ms_segment_snc-actual-guiflag   = ls_check_snc-guiflag.
  ms_segment_snc-actual-knamelen  = lv_check_knamelen.
  ms_segment_snc-actual-kname     = lv_check_kname.
  ms_segment_snc-actual-hname     = lv_check_hname.

  if ms_segment_snc-actual-pname       is initial and
     ms_segment_snc-actual-guiflag     is initial and
     ms_segment_snc-before_image-bname is initial.
*   No entry in before image: Nothing will be changed
    clear: ms_segment_snc-actual.
  else.
*   Entry should be saved
    ms_segment_snc-actual-mandt = sy-mandt.
    ms_segment_snc-actual-bname = ms_manager-bname.
  endif.

* Is canonical name defined?
  if ms_segment_snc-actual-knamelen > 0.
    ls_check_snc-knamestat = if_identity=>co_true.
  else.
    ls_check_snc-knamestat = if_identity=>co_false.
  endif.


* --- Transaction handling ---------------------------------
*

* Notification
  if ls_check_snc ne ls_old_snc.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_snc.
  endif.

* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_snc
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_snc = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_snc = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_snc-actual ne ms_segment_snc-before_image.
    ms_segment_snc-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_snc-status.
  endif.



endmethod.


method if_identity~set_technical_user_data.

  data: ls_msg                     type        symsg
      , ls_check_tech_user_data    type        suid_st_node_tech_user_data
      , ls_old_tech_user_data      type        suid_st_node_tech_user_data
      , lr_field                   type ref to suid_node_field
      , lt_change_fields           type        suid_tt_fields
      , lv_no_maintain             type        sesf_boolean
      , lv_error                   type        abap_bool
      , lv_lifetimeonce_only       type        xfeld
      .

  field-symbols:
         <lv_newfield>     type any
       , <lv_checkfield>   type any
       .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_tech_user_data
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  " --- Read from actual image into old structure ---------------
  "
  move ms_segment_address-actual-responsible to ls_old_tech_user_data-responsible.
  move ms_segment_address-actual-techdesc    to ls_old_tech_user_data-techdesc.

  " Delete all notification belonging to this node
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_tech_user_data ).


  " --- Set values ------------------------------------------
  "
  " Fill check structure with old data first
  move-corresponding ls_old_tech_user_data to ls_check_tech_user_data.

  if it_change_fields is initial.

    " Get list of fields belonging to the node
    cl_suid_tools=>get_node_fields(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_tech_user_data
      importing
        et_node_fields = lt_change_fields ).

  else.
    " Set changed fields only
    lt_change_fields = it_change_fields.
    " Only lifetime_once messages should be deleted for the node
    lv_lifetimeonce_only = if_identity=>co_true.
  endif.

  " Delete lifetime_once messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_tech_user_data
      iv_lifetimeonce_only = lv_lifetimeonce_only.


  loop at lt_change_fields reference into lr_field.
    if it_change_fields is not initial.
      " Delete lifetime_permanent messages  belonging to this node
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_tech_user_data
          iv_field    = lr_field->*.
    endif.

    if gv_cua_child = if_identity=>co_true.
      " Check if field can be changed
      cua_if_field_no_maintain(
        exporting
          iv_node_name   = if_identity_definition=>gc_node_tech_user_data
          iv_field_name  = lr_field->*
          io_msg_buffer  = go_msg_buffer
        receiving
          rv_no_maintain = lv_no_maintain ).


      " Field can't be maintained --> delete it from further processing
      if lv_no_maintain = if_identity=>co_true.
        delete lt_change_fields.
        continue.
      endif.
    endif.

    " Set new field value if possible
    assign component lr_field->* of structure is_tech_user_data to <lv_newfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    assign component lr_field->* of structure ls_check_tech_user_data to <lv_checkfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    " Move node field value
    <lv_checkfield> = <lv_newfield>.
  endloop.


  " If no field can be changed - leave
  if lt_change_fields is initial.
    return.
  endif.


  " --- Check values ------------------------------------------
  call method check_techuser_data_internal
    exporting
      iv_bname          = ms_manager-bname
      io_msg_buffer     = go_msg_buffer
      it_check_fields   = lt_change_fields
    changing
      cs_tech_user_data = ls_check_tech_user_data.

  " --- Move values to segements -------------------------------
  "
  move sy-mandt                            to ms_segment_address-actual-mandt.
  move ms_manager-bname                    to ms_segment_address-actual-bname.
  move ls_check_tech_user_data-responsible to ms_segment_address-actual-responsible.
  move ls_check_tech_user_data-techdesc    to ms_segment_address-actual-techdesc.


  " --- Transaction handling ---------------------------------
  "

  " Notification
  if ls_check_tech_user_data ne ls_old_tech_user_data.
    go_notify->notify_update(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_tech_user_data ).

  endif.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_tech_user_data
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   "  New node status: CHECKED
    ms_manager-sn_tech_user_data = go_persistence->co_node_status_checked.
  else.                                   "  New node status: CHANGED
    ms_manager-sn_tech_user_data = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity~set_technical_user_indicator.


  data: ls_msg               type        symsg
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_tech_user
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " --- Check address buffer ---
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.


  " Delete all notification
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_tech_user ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_tech_user ).


  " ------ Set technical user indicator depending on identity model --------
  "
  case ms_segment_address-actual-idadtype.

      " ------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      " Delete technical user indicator: Nothing to do
      if is_tech_user-tech_indicator is initial.
        return.
      endif.

      " switch old user -> techuser only supported for S/4 on premise in create mode
      if not ( ms_manager-modus = go_persistence->co_ta_modus_create and
               cl_identity_factory=>check_identity_model( ) = abap_true ).

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '000'.
        " MSG: Technische Benutzer werden nicht unterstützt.
        if 1 = 0. message e000(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_tech_user
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        go_notify->notify_failed_create(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_tech_user ).

        return.

      endif.

      " CHECK: address already assigned
      if ms_segment_address-actual-addrnumber is not initial or
         ms_segment_address-actual-persnumber is not initial.

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '001'.
        " MSG: Das Kennzeichen "Technischer Benutzer" kann nicht gesetzt werden.
        if 1 = 0. message e001(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_tech_user
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        go_notify->notify_failed_create(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_tech_user ).

        return.

      endif.

      " Set technical user indicator
      ms_segment_address-actual-idadtype  = if_identity=>co_idad_techuser.

      " ------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person          or
         if_identity=>co_idad_person_org_rela or
         if_identity=>co_idad_employee.

      " Delete technical user indicator: Nothing to do
      if is_tech_user-tech_indicator is initial.
        return.
      endif.

      " CHECK: Person is assigned
      if ( ms_segment_address-actual-idadtype eq if_identity=>co_idad_person and
           ms_segment_address-actual-bpperson is not initial )                        or
           ms_segment_address-actual-idadtype eq if_identity=>co_idad_person_org_rela or
           ms_segment_address-actual-idadtype eq if_identity=>co_idad_employee.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '001'.
        " MSG: Das Kennzeichen "Technischer Benutzer" kann nicht gesetzt werden.
        if 1 = 0. message e001(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_tech_user
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        go_notify->notify_failed_create(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_tech_user ).

        return.
      endif.

      " Set technical user indicator
      ms_segment_address-actual-idadtype  = if_identity=>co_idad_techuser.

      " Delete messages of address
      go_msg_buffer->delete_object_message(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization ).
      go_msg_buffer->delete_object_message(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person_name ).
      go_msg_buffer->delete_object_message(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace ).

      " ------ Technical user ----------------------------------
    when if_identity=>co_idad_techuser.

      " Set technical user indicator: Nothing to do
      if is_tech_user-tech_indicator is not initial.
        return.
      endif.

      " Delete technical user indicator
      ms_segment_address-actual-idadtype  = if_identity=>co_idad_person. "Default User with Person: Do not change to DEFAULT IDADTYPE!

      " ------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.


  " --- Move values to segements -------------------------------
  "
  ms_segment_address-actual-mandt     = sy-mandt.
  ms_segment_address-actual-bname     = ms_manager-bname.


  " --- Transaction handling ---------------------------------
  "

  " Notification
  if ms_segment_address-actual-idadtype eq if_identity=>co_idad_techuser.
    " Insert Node
    go_notify->notify_create(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_tech_user ).
  else.
    " Delete Node
    go_notify->notify_delete(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_tech_user ).
  endif.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check status: ok
  ms_manager-sn_tech_user = go_persistence->co_node_status_checked.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

endmethod.


method if_identity~set_uclass.


* ToDo
* Fehlermeldungen auflisten

  data: ls_check_uclass      type        suid_st_node_uclass
      , ls_old_uclass        type        suid_st_node_uclass
      , lr_field             type ref to suid_node_field
      , lv_error             type        sesf_boolean
      , lt_change_fields     type        suid_tt_fields
      , lv_no_maintain       type        sesf_boolean
      , lv_lifetimeonce_only type        xfeld
      , lv_scum_checked      type        sesf_boolean
      , ls_msg               type        symsg
      .

  field-symbols:
         <lv_newfield>     type any
       , <lv_checkfield>   type any
       .


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* --- Transaction handling ---------------------------------
*
* Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node  = if_identity_definition=>gc_node_uclass
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
* Return to caller
    return.
  endif.


* Lazy fetch of uclass segment
  if ms_segment_uclass-bname is initial.
    call method fetch_segment_uclass.
  endif.

* Read from actual image into old structure
  ls_old_uclass-lic_type           = ms_segment_uclass-actual-lic_type.
  ls_old_uclass-substitute_from    = ms_segment_uclass-actual-vondat.
  ls_old_uclass-substitute_until   = ms_segment_uclass-actual-bisdat.
  ls_old_uclass-client             = ms_segment_uclass-actual-mandt2.
  ls_old_uclass-sysid              = ms_segment_uclass-actual-sysid.
  ls_old_uclass-bname_chargeable   = ms_segment_uclass-actual-aname.
  ls_old_uclass-spec_vers          = ms_segment_uclass-actual-spras.
  ls_old_uclass-country_surcharge  = ms_segment_uclass-actual-surcharge.


* Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_uclass.


* --- Set values ------------------------------------------
*
* Fill check structure with old values first
  ls_check_uclass = ls_old_uclass.

  if it_change_fields is initial.
*...Set all fields

*   Get list of fields belonging to the node
    call method cl_suid_tools=>get_node_fields
      exporting
        iv_node_name   = if_identity_definition=>gc_node_uclass
      importing
        et_node_fields = lt_change_fields.
  else.

    lt_change_fields = it_change_fields.

    lv_lifetimeonce_only = if_identity=>co_true.
  endif.

* Delete lifetime_once messages  belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_uclass
      iv_lifetimeonce_only = lv_lifetimeonce_only.

* Check maintenance
*  License data has one field attribute for all fields
  if gv_cua_child = if_identity=>co_true.
    if  lv_scum_checked = if_identity=>co_false.
      call method cua_if_field_no_maintain
        exporting
          iv_node_name   = if_identity_definition=>gc_node_uclass
          io_msg_buffer  = go_msg_buffer
        receiving
          rv_no_maintain = lv_no_maintain.

      lv_scum_checked = if_identity=>co_true.
    endif.
  endif.

  loop at lt_change_fields reference into lr_field.
    if it_change_fields is not initial.
*     Delete lifetime_permanent messages  belonging to this node
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_uclass
          iv_field    = lr_field->*.
    endif.

    if lv_no_maintain = if_identity=>co_true.
      delete lt_change_fields.
      continue.
    endif.

*   Set new field value
    assign component lr_field->* of structure is_uclass to <lv_newfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    assign component lr_field->* of structure ls_check_uclass to <lv_checkfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

*   Move node field
    <lv_checkfield> = <lv_newfield>.
  endloop.



* --- Check values ------------------------------------------
* -> Check always complete node !
*
  call method check_uclass_internal
    exporting
      iv_nodename   = if_identity_definition=>gc_node_uclass
      iv_bname      = ms_manager-bname
      io_msg_buffer = go_msg_buffer
    changing
      cs_uclass     = ls_check_uclass.


* --- Move values to segements -------------------------------
*
  if ls_check_uclass-lic_type is initial or
     ls_check_uclass-lic_type eq '00'.
*   Delete entry on DB, if available
    clear: ms_segment_uclass-actual.
  else.
*   Write entry on DB
    ms_segment_uclass-actual-mandt      = sy-mandt.
    ms_segment_uclass-actual-bname      = ms_manager-bname.
    ms_segment_uclass-actual-lic_type   = ls_check_uclass-lic_type.
    ms_segment_uclass-actual-vondat     = ls_check_uclass-substitute_from.
    ms_segment_uclass-actual-bisdat     = ls_check_uclass-substitute_until.
    ms_segment_uclass-actual-mandt2     = ls_check_uclass-client.
    ms_segment_uclass-actual-sysid      = ls_check_uclass-sysid.
    ms_segment_uclass-actual-aname      = ls_check_uclass-bname_chargeable.
    ms_segment_uclass-actual-spras      = ls_check_uclass-spec_vers.
    ms_segment_uclass-actual-surcharge  = ls_check_uclass-country_surcharge.
  endif.


* --- Transaction handling ---------------------------------
*

* Notification
  if ls_check_uclass ne ls_old_uclass.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_uclass.
  endif.

* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_uclass
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_uclass = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_uclass = go_persistence->co_node_status_changed.
  endif.

* Set segment change flag
  if ms_segment_uclass-actual ne ms_segment_uclass-before_image.
    ms_segment_uclass-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_uclass-status.
  endif.


endmethod.


method instantiation_by_mode.

* * List of messages that can be raised during this method directly:
*
*  Instance attribute:
*
*  - Field BNAME
*      E279(01) - Enter a user name
*        CREATE mode:
*      E088(01) - User & exists
*        MODIFY, DISPLAY, DELETE mode:
*      E124(01) - User & does not exist
*        MODIFY, DELETE mode:
*      E200(SUID01) - Benutzer &1 ist nicht in der ZBV. Keine Änderung per IDoc möglich.
*
*  - Field BNAME
*      E410(01) - Maintenance of user &1 locked by user &2
*
* * List of messages that can be raised in called methods:
*
*  - IF_SUID_PERSISTENCE_READ~READ
*
* Parameter IT_BNAME is not sorted !!!
*
**********************************************************************
* 26.02.2008 D050920  Note 1116083
* - Call NODE_AUTHORITY_CHECK and AUTH_CHECK_SINGLE with parameter
* IV_BNAME. Because username is used by some messages (01/585, 01/586..  )
* - Correct checkman warnings for bad logical expression: "1 = 0"
**********************************************************************

*--- Instantiation of Identities per transaction mode -----------------*
  types:
        begin of ty_existing_identity,
          identity            type ty_control,
          post_status         type suid_ta_status,
          post_modus          type suid_ta_modus,
          post_enqmode        type sesf_edit_mode,
          refresh_required    type i,
        end of ty_existing_identity,

        ty_identity_tab       type standard table of ty_existing_identity.

  constants:          " used in structure ty_existing_identity for refresh_required
        co_consistent         type i value 0                "#EC NEEDED
       ,co_refresh_required   type i value 1
       ,co_cleanup_required   type i value 2
       .

*--- Declaration of local data
  data: lr_bname              type ref to suid_st_bname
       ,lr_control            type ref to ty_control
       ,ls_control            type        ty_control
       ,lt_known_refs         type        ty_identity_tab
       ,lr_known_refs         type ref to ty_existing_identity
       ,ls_known_ref          type        ty_existing_identity
       ,ls_node_root          type        suid_st_node_root
       ,lt_bname              type        suid_tt_bname
       ,lt_bname_not_locked   type        suid_tt_bname_locked
       ,lr_bname_not_locked   type ref to suid_st_bname_locked
       ,lt_unlock_bnames      type        suid_tt_bname
       ,lt_not_cua_users      type        suid_tt_bname
       ,lt_reserved_cua_users type        suid_tt_bname
       ,lt_local_users        type        suid_tt_bname
       ,lo_identity           type ref to cl_identity
       ,lt_header             type        suid_tt_usr02
       ,ls_header             type        usr02
       ,lv_tabix              type        sy-tabix
       ,lv_supp_tabix         type        sy-tabix
       ,ls_msg                type        symsg
       ,ls_msg2               type        symsg
       ,lv_identity_guid      type        suid_guid
       ,ls_identity           type        suid_st_identity
       ,lv_enq_mode           type        enqmode
       ,lv_cua_mode           type        suid_cua_mode
       ,lo_property_handler   type ref to cl_suid_property_handler
       ,lt_usr21              type        suid_tt_usr21
       ,lr_usr21              type ref to usr21
       ,ls_usr21              type        usr21
       ,lv_string             type        string
       ,lr_usr02              type ref to usr02
       ,lv_flg_raise_exc      type        sesf_boolean
       ,lv_found_valid_reference type     sesf_boolean
       ,lv_delete             type        sesf_boolean
       ,lv_username_valid     type        sesf_boolean
       ,lv_user_prfx_valid    type        sesf_boolean
       ,lv_prfx_chck_value    type        usr_cust-path
       .

  " initialize exporting parameters
  clear: et_node_root, et_bname_exist, et_bname_not_exist, et_bname_not_authorized, et_bname_locked.

*--- Transaction mode valid? ------------------------------------------*
  if    iv_modus ne go_persistence->co_ta_modus_create
    and iv_modus ne go_persistence->co_ta_modus_modify
    and iv_modus ne go_persistence->co_ta_modus_display
    and iv_modus ne go_persistence->co_ta_modus_delete
    .
    raise exception type cx_suid_identity
      exporting
        textid   = cx_suid_identity=>internal_error
        ta_modus = iv_modus.
  endif.

  lt_bname = it_bname. " IT_BNAME may not be changed
  sort lt_bname.
  delete adjacent duplicates from lt_bname.

**********************************************************************
*--- First perform some checks on imported Identity IDs -------------*
*    and state transitions                                           *
**********************************************************************
  loop at lt_bname reference into lr_bname.
    " Delete notifications and messages
    lv_tabix = sy-tabix.
    if lr_bname->bname is initial.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '279'.
      if 1 = 0. message e279(01). endif.                    "#EC *

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_bname->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.

      " Delete empty usernames
      delete lt_bname index lv_tabix.
      continue.
    endif.

    " Upper case conversion
    lv_string = lr_bname->bname.
    lr_bname->bname = cl_suid_tools=>to_upper_case( iv_name = lv_string ).

    " delete messages
    go_msg_buffer->delete_object_message(
      exporting
        iv_bname    = lr_bname->bname
        iv_nodename = if_identity_definition=>gc_node_root ).

    " delete notifications
    go_notify->delete_notifications(
      exporting
        iv_bname    = lr_bname->bname
        iv_nodename = if_identity_definition=>gc_node_root ).

    " Check if this Identity instance already exists
    read table gt_control
         with key bname = lr_bname->bname
         binary search
         reference into lr_control.

    if sy-subrc = 0.
      " Check whether call is permitted for existing reference
      lv_flg_raise_exc          = if_identity=>co_false.
      lv_found_valid_reference  = if_identity=>co_false.
      clear: ls_known_ref, ls_node_root.

      " Accept existing references in some cases:
      "-- Existing reference is in mode: DISPLAY
      if lr_control->idref->ms_manager-modus = go_persistence->co_ta_modus_display.
        case iv_modus.
            " DISPLAY -> CREATE
            " DISPLAY -> DELETE
            " DISPLAY -> MODIFY
          when go_persistence->co_ta_modus_create or "  Display -> create
               go_persistence->co_ta_modus_delete or "  Display -> Delete
               go_persistence->co_ta_modus_modify.   "  Display -> Change
            " set target state and keep current state + mode
            ls_known_ref-identity          = lr_control->*.
            ls_known_ref-post_modus        = iv_modus.
            ls_known_ref-post_enqmode      = iv_enq_mode.
            ls_known_ref-refresh_required  = co_refresh_required.

            if iv_modus = go_persistence->co_ta_modus_modify.  "  Display -> Change
              ls_known_ref-post_status       = go_persistence->co_ta_status_unchanged.
            else.
              ls_known_ref-post_status       = go_persistence->co_ta_status_unchecked.
            endif.

            " DISPLAY -> DISPLAY
          when go_persistence->co_ta_modus_display."  Display -> Display
            " Display (Own User) -> Display
            if lr_control->idref->ms_manager-flg_own_data eq go_persistence->co_flag_active and
               iv_transaction                             eq space.
              clear: lv_found_valid_reference.
              ls_known_ref-identity          = lr_control->*.
              ls_known_ref-post_modus        = iv_modus.
              ls_known_ref-post_enqmode      = iv_enq_mode.
              ls_known_ref-post_status       = go_persistence->co_ta_status_unchanged.
              ls_known_ref-refresh_required  = co_refresh_required.
            else.
              lv_found_valid_reference = if_identity=>co_true.
            endif.
          when others.
            lv_flg_raise_exc    = if_identity=>co_true.

        endcase.

        "-- Existing reference is in mode: MODIFY
      elseif lr_control->idref->ms_manager-modus = go_persistence->co_ta_modus_modify.
        " MODIFY -> DISPLAY
        " MODIFY -> MODIFY
        " Retrieve Identity in Modify mode for display: Call is allowed!
        if iv_modus = go_persistence->co_ta_modus_display or
           iv_modus = go_persistence->co_ta_modus_modify.
          " Call is ok. No further treatment is needed
          lv_found_valid_reference = if_identity=>co_true.
        else.        " Otherwise call never is permitted for Modify mode
          lv_flg_raise_exc    = if_identity=>co_true.
        endif.
        " Transition from Delete or Create to other modes is never permitted
      else.
        lv_flg_raise_exc    = if_identity=>co_true.
      endif.

      "-- handle instances which can be already returned
      if lv_found_valid_reference = if_identity=>co_true.
        " Fill exporting table for references by BNAME
        move-corresponding lr_control->* to ls_node_root.

        " compute uuid
        lr_control->idref->if_identity~get_identity_uuid(
          importing
            ev_identity_guid = ls_node_root-identity_guid ).

        "-- Fill return tables
        " Get correct line for sorted insertion into et_node_root
        read table et_node_root
              with key bname = ls_node_root-bname
              binary search
              transporting no fields.

        insert ls_node_root into et_node_root index sy-tabix.

        " user exists: add to return table
        append lr_bname->bname to et_bname_exist.

        " delete entry from further processing: reference was found
        delete lt_bname index lv_tabix.

        continue. " go to next entry in loop
      endif.

      "-- fill lt_known_refs
      if ls_known_ref is not initial.
        " Collect all known references
        " Insert new instance: After insert, table is sorted by BNAME
        read table lt_known_refs
             with key identity-bname = lr_bname->bname
             binary search
             transporting no fields.

        lv_supp_tabix = sy-tabix.
        if sy-subrc = 0.
          raise exception type cx_suid_identity
            exporting
              textid   = cx_suid_identity=>internal_error
              bname    = lr_bname->bname
              ta_modus = iv_modus.
        else.
          insert ls_known_ref into lt_known_refs index lv_supp_tabix.
        endif.
      endif.

      "-- throw exception for transistion of modes which are not supported
      if lv_flg_raise_exc    = if_identity=>co_true.
        raise exception type cx_suid_identity
          exporting
            textid   = cx_suid_identity=>internal_error
            bname    = lr_bname->bname
            ta_modus = iv_modus.
      endif.
    endif.
  endloop.

  " If single user was given: lt_bname is empty now
  check: lt_bname is not initial.

**********************************************************************
*--- Enqueue Identities ---------------------------------------------*
**********************************************************************
  if iv_modus ne go_persistence->co_ta_modus_display.

    case iv_enq_mode.

        "-- exclusive lock is requested
      when if_identity=>co_enqueue_mode_exclusive.

        lv_enq_mode = cl_suid_tools=>co_lock_mode_excl.

        " in case IV_SET_OPTIMISTIC_ENQUEUE_LOCK (ESI-Mode) is set
        " an additional optimistic lock has to be requested
        if iv_set_optimistic_enqueue_lock = if_identity=>co_true.
          " Request optimistic lock
          call method cl_suid_tools=>enqueue
            exporting
              it_bname           = lt_bname
              i_enq_mode         = cl_suid_tools=>co_lock_mode_opt
              iv_idoc_processing = gv_idoc_processing
              iv_repeat_enq      = iv_repeat_enq
            importing
              et_bname           = lt_bname_not_locked.

          " Promote to exclusiv lock
          call method cl_suid_tools=>enqueue
            exporting
              it_bname           = lt_bname
              i_enq_mode         = cl_suid_tools=>co_lock_mode_opt_to_excl
              iv_idoc_processing = gv_idoc_processing
              iv_repeat_enq      = iv_repeat_enq
            importing
              et_bname           = lt_bname_not_locked.
        else.

          call method cl_suid_tools=>enqueue
            exporting
              it_bname           = lt_bname
              i_enq_mode         = lv_enq_mode
              iv_idoc_processing = gv_idoc_processing
              iv_repeat_enq      = iv_repeat_enq
            importing
              et_bname           = lt_bname_not_locked.
        endif.

        "-- optimistic lock is requested
      when if_identity=>co_enqueue_mode_optimistic.

        lv_enq_mode = cl_suid_tools=>co_lock_mode_opt.
        call method cl_suid_tools=>enqueue
          exporting
            it_bname           = lt_bname
            i_enq_mode         = lv_enq_mode
            iv_idoc_processing = gv_idoc_processing
            iv_repeat_enq      = iv_repeat_enq
          importing
            et_bname           = lt_bname_not_locked.

        "-- no lock is requested
      when if_identity=>co_enqueue_mode_no_lock.
        lv_enq_mode = space.
        " nothing left to do: no lock requested

        "-- other: exclusive lock is requested
      when others.
        lv_enq_mode = cl_suid_tools=>co_lock_mode_excl.
        call method cl_suid_tools=>enqueue
          exporting
            it_bname           = lt_bname
            i_enq_mode         = lv_enq_mode
            iv_idoc_processing = gv_idoc_processing
            iv_repeat_enq      = iv_repeat_enq
          importing
            et_bname           = lt_bname_not_locked.

    endcase.

    " Evaluate not locked Identities below -> exclude for instantiation
  else.      "--- Display mode!
    " For Display mode only allow enqueue mode 'Optimistic lock'
    if iv_enq_mode = if_identity=>co_enqueue_mode_optimistic.

      lv_enq_mode = cl_suid_tools=>co_lock_mode_opt.
      call method cl_suid_tools=>enqueue
        exporting
          it_bname   = lt_bname
          i_enq_mode = lv_enq_mode
        importing
          et_bname   = lt_bname_not_locked.

    endif.
  endif.
*--- Now also Identities not passing the Existence check were locked!
*    ==> Unlock these again below! Fill lt_unlock_bnames - IMPORTANT!!!!

**********************************************************************
*--- check for successful enqueues and                              -*
**********************************************************************
  loop at lt_bname reference into lr_bname.

    " remember entry
    lv_tabix = sy-tabix.

    clear ls_node_root.

    "-- Check if lock was set successfully
    read table lt_bname_not_locked
         with key bname = lr_bname->bname
         binary search
         reference into lr_bname_not_locked.

    if sy-subrc = 0.  " Identity could not be locked: Don't instantiate!

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_bname->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = lr_bname_not_locked->msg.

      " remove user lt_known_refs
      read table lt_known_refs
           with key identity-bname = lr_bname->bname
           binary search
           transporting no fields.

      lv_supp_tabix = sy-tabix.
      if sy-subrc = 0.
        delete lt_known_refs index lv_supp_tabix.
      endif.

      " user could not be locked
      append lr_bname->bname to et_bname_locked.

      " Delete user which could not be locked
      delete lt_bname index lv_tabix.

    endif.

  endloop.

  " instantiation may be finished because of invalid enqueues.
  check: lt_bname is not initial.

**********************************************************************
*--- existence check of requested identity --------------------------*
**********************************************************************
  " Prefetch header is always performed!
  go_persistence->if_suid_persistence_read~read(
    exporting
      it_bname   = lt_bname
    importing
      et_header  = lt_header ).                 " Needed for constructor

  "-- fill tables et_identity_exist and et_identity_not_exist
  " according to returned values in lt_header
  clear: lt_unlock_bnames.

  loop at lt_bname reference into lr_bname.

    " remember entry
    lv_tabix = sy-tabix.
    clear: ls_identity.

    read table lt_header reference into lr_usr02
      with key bname = lr_bname->bname
      binary search.

    "-- user exists -----------------
    if sy-subrc = 0.
*     user exists: add to return table
      append lr_bname->bname to et_bname_exist.

      " user exists but we are in create mode
      if iv_modus = go_persistence->co_ta_modus_create.
        clear: ls_msg.
        ls_msg-msgv1 = lr_bname->bname.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '224'.
        " user & already exists
        if 1 = 0. message e224(01) with ls_msg-msgv1. endif. "#EC *

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = lr_bname->bname
            iv_nodename = if_identity_definition=>gc_node_root
            iv_field    = if_identity_definition=>gc_field_root_bname
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = ls_msg.

        " remove user from lt_known_refs
        read table lt_known_refs
             with key identity-bname = lr_bname->bname
             binary search
             transporting no fields.

        lv_supp_tabix = sy-tabix.
        if sy-subrc = 0.
          delete lt_known_refs index lv_supp_tabix.
        endif.

        " bname was already locked --> take care to unlock again!
        append lr_bname->bname to lt_unlock_bnames.

        " delete entry from further processing
        delete lt_bname index lv_tabix.
      endif.

      "-- user does not exist ----------
    else.
      " bname does not exist: add to return table
      append lr_bname->bname to et_bname_not_exist.

      if iv_modus <> go_persistence->co_ta_modus_create. "--- not in create mode!
        " Modify, Display or Delete mode: et_bname_not_exist should be empty
        clear: ls_msg.
        ls_msg-msgv1 = lr_bname->bname.
        ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '124'.
        " User & does not exist
        if 1 = 0. message e124(01) with ls_msg-msgv1. endif. "#EC *

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = lr_bname->bname
            iv_nodename = if_identity_definition=>gc_node_root
            iv_field    = if_identity_definition=>gc_field_root_bname
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = ls_msg.

        " remove user from lt_known_refs
        read table lt_known_refs
             with key identity-bname = lr_bname->bname
             binary search
             transporting no fields.

        lv_supp_tabix = sy-tabix.
        if sy-subrc = 0.
          delete lt_known_refs index lv_supp_tabix.
        endif.

        " BNAME was already locked --> Take care to unlock again!
        append lr_bname->bname to lt_unlock_bnames.

        " delete entry from further processing
        delete lt_bname index lv_tabix.

      else.   "--- create mode!

        lv_username_valid  = if_identity=>co_true.
        lv_user_prfx_valid = if_identity=>co_true.
        clear: ls_msg
             , ls_msg2
             .
        lv_username_valid = cl_suid_tools=>check_username( iv_new_bname = lr_bname->bname ).

        if ( lv_username_valid = if_identity=>co_false ).
          ls_msg-msgv1 = lr_bname->bname.
          ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = 630.
          " The username handed over contains of unwanted characters.
          if 1 = 0. message e630(01) with ls_msg-msgv1. endif. "#EC *
        endif.

        cl_suid_tools=>get_customizing_property(
                         exporting
                           iv_property_name  = cl_suid_tools=>co_usr_cust_user_prefix_check
                           iv_table_name     = cl_suid_tools=>co_cust_tab_usr
                         importing
                           ev_property_value = lv_prfx_chck_value
                         ).
        "No prefix checks if some special Unit Tests are active (the leading '!' must be allowed)
        "              OR if the customer switched this check off
        if ( mv_unit_test_mode  =  if_identity=>co_false         ) and
           ( lv_prfx_chck_value <> cl_suid_tools=>co_cust_val_no ).
          "The prefix check message should override the customizing check messages above.
          cl_suid_tools=>check_username_prefix(
                           exporting
                             iv_new_bname      = lr_bname->bname
                           importing
                             ev_username_valid = lv_user_prfx_valid
                             es_message        = ls_msg2
                           ).
        endif.   "Unit Test mode is active

        if ( lv_username_valid  = if_identity=>co_false ) or
           ( lv_user_prfx_valid = if_identity=>co_false ).

          if ( not ls_msg  is initial ).
            "username &1 contains unwanted characters!
            call method go_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = lr_bname->bname
                iv_nodename = if_identity_definition=>gc_node_root
                iv_field    = if_identity_definition=>gc_field_root_bname
                iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
                is_msg      = ls_msg.
          endif.

          if ( not ls_msg2 is initial ).
            " 'The username must not start with: &3'
            call method go_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = lr_bname->bname
                iv_nodename = if_identity_definition=>gc_node_root
                iv_field    = if_identity_definition=>gc_field_root_bname
                iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
                is_msg      = ls_msg2.
          endif.

          " remove user from lt_known_refs
          read table lt_known_refs
               with key identity-bname = lr_bname->bname
               binary search
               transporting no fields.

          lv_supp_tabix = sy-tabix.
          if sy-subrc = 0.
            delete lt_known_refs index lv_supp_tabix.
          endif.

          " BNAME was already locked --> Take care to unlock again!
          append lr_bname->bname to lt_unlock_bnames.

          " delete entry from further processing
          delete lt_bname index lv_tabix.

        endif.   "username contains unwanted characters
      endif.   "--- not in create mode!

    endif.
  endloop.

**********************************************************************
*--- Cleanup: Dequeue BNAMES that were locked, but not instantiated -*
*    cleanup of gt_control for entries which did not pass existence -*
*    check                                                           *
**********************************************************************
  if lt_unlock_bnames is not initial.

    if iv_set_optimistic_enqueue_lock = if_identity=>co_true.
      cl_suid_tools=>dequeue(
        exporting
          it_bname   = lt_unlock_bnames
          i_enq_mode = cl_suid_tools=>co_lock_mode_opt ).
    endif.

    cl_suid_tools=>dequeue(
      exporting
        it_bname   = lt_unlock_bnames
        i_enq_mode = lv_enq_mode ).

    clear lt_unlock_bnames.
  endif.

  " instantiation may be finished because of non-existing entries.
  check: lt_bname is not initial.

**********************************************************************
*--- authority check  -----------------------------------------------*
*--- prepare return table with existing references ------------------*
**********************************************************************
  loop at lt_bname reference into lr_bname.

    " remember entry
    lv_tabix = sy-tabix.

    clear ls_node_root.

    read table lt_header reference into lr_usr02
      with key bname = lr_bname->bname
      binary search.

    "-- Authority check -----------
    case iv_modus.

        " CREATE
      when go_persistence->co_ta_modus_create.
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename  = if_identity_definition=>gc_node_root
            iv_operation = cl_suid_tools=>co_activity_create
            iv_class     = space "No class in create-mode
            iv_bname     = lr_bname->bname
          importing
            es_msg       = ls_msg.

        " MODIFY
      when go_persistence->co_ta_modus_modify.
        if iv_transaction <> co_own_data.
          call method cl_identity=>node_authority_check
            exporting
              iv_node_name        = iv_node_name
              iv_transaction_mode = iv_modus
              iv_class            = lr_usr02->class
              iv_bname            = lr_bname->bname
            importing
              es_msg              = ls_msg.
        endif.

        " DISPLAY
      when go_persistence->co_ta_modus_display.
        if iv_transaction <> co_own_data.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename  = if_identity_definition=>gc_node_root
              iv_operation = cl_suid_tools=>co_activity_retrieve
              iv_class     = lr_usr02->class
            importing
              es_msg       = ls_msg.
        endif.

        " DELETE
      when go_persistence->co_ta_modus_delete.
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename  = if_identity_definition=>gc_node_root
            iv_operation = cl_suid_tools=>co_activity_delete
            iv_class     = lr_usr02->class
            iv_bname     = lr_bname->bname
          importing
            es_msg       = ls_msg.

    endcase.

    if ls_msg-msgty = 'E'. "Authority check failed

      " prepare return variable
      append lr_bname->bname to et_bname_not_authorized.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_bname->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.

      " known references remain in old state
      "  remove user from lt_known_refs
      read table lt_known_refs
           with key identity-bname = lr_bname->bname
           binary search
           transporting no fields.

      lv_supp_tabix = sy-tabix.
      if sy-subrc = 0.
        delete lt_known_refs index lv_supp_tabix.
      endif.

      " BNAME was already locked --> Take care to unlock again!
      append lr_bname->bname to lt_unlock_bnames.

      " delete entry from further processing: not authorized
      delete lt_bname index lv_tabix.

    endif.

  endloop.

**********************************************************************
*--- Cleanup: Dequeue BNAMES that were locked, but not authorized ---*
**********************************************************************
  if lt_unlock_bnames is not initial.

    if iv_set_optimistic_enqueue_lock = if_identity=>co_true.
      cl_suid_tools=>dequeue(
        exporting
          it_bname   = lt_unlock_bnames
          i_enq_mode = cl_suid_tools=>co_lock_mode_opt ).
    endif.

    cl_suid_tools=>dequeue(
      exporting
        it_bname   = lt_unlock_bnames
        i_enq_mode = lv_enq_mode ).

    clear lt_unlock_bnames.

  endif.

  " instantiation may be finished because of existing references
  "  or missing authorization.
  check: lt_bname is not initial.

**********************************************************************
*--- Prefetch USR21-data is always performed because of GUIDS     ---*
**********************************************************************

  call method go_persistence->if_suid_persistence_read~read
    exporting
      it_bname   = lt_bname
    importing
      et_address = lt_usr21.


**********************************************************************
*--- Special check for existing usage as reference user           ---*
**********************************************************************
  "A user must not deleted if it is still in use as reference user!
  if iv_modus = go_persistence->co_ta_modus_delete.

    loop at lt_bname reference into lr_bname.

      lv_tabix = sy-tabix.

      call method cl_identity=>check_refuser_delete_internal
        exporting
          iv_bname      = lr_bname->bname
          iv_node_name  = if_identity_definition=>gc_node_root
        importing
          ev_valid      = lv_delete
          .
      if lv_delete eq if_identity=>co_false.
        "No system assignment deletion if e.g. the user is still used as reference user

        " remove user from lt_known_refs
        read table lt_known_refs
             with key identity-bname = lr_bname->bname
             binary search
             transporting no fields.

        lv_supp_tabix = sy-tabix.
        if sy-subrc = 0.
          delete lt_known_refs index lv_supp_tabix.
        endif.

        " BNAME was already locked --> Take care to unlock again!
        append lr_bname->bname to lt_unlock_bnames.

        " delete entry from further processing
        delete lt_bname index lv_tabix.

        continue.
      endif.

    endloop.

  endif.   "DELETE_MODE


**********************************************************************
*--- Special CUA handling                                         ---*
**********************************************************************
*--- Special check for CUA case ---------------------------------------*
  " Use case: CUA child system still contains Identities that have not
  "           been integrated into the CUA handling
  if gv_cua_child = if_identity=>co_true.
    " only relevant for Modify and Delete mode
    if iv_modus = go_persistence->co_ta_modus_modify or
       iv_modus = go_persistence->co_ta_modus_delete.
      "--> These Identities may require speacial handling in IDoc inbound processing
      if gv_idoc_processing = go_persistence->co_flag_active. " IDoc
        call method cl_identity=>check_if_cua_users
          exporting
            it_bname              = lt_bname
            it_headers            = lt_header
          importing
            et_not_cua_users      = lt_not_cua_users
            et_reserved_cua_users = lt_reserved_cua_users
            et_local_users        = lt_local_users.
      else.
        call method cl_identity=>check_if_cua_users
          exporting
            it_bname         = lt_bname
            it_headers       = lt_header
          importing
            et_not_cua_users = lt_not_cua_users.
      endif.
      " Imported tables are evaluated below
    endif.
  endif.

**********************************************************************
*   Handle CUA mode                                                  *
*   Start creating new instances                                     *
*   Handle input of given UUIDs and GUIDs                            *
**********************************************************************
  loop at lt_bname reference into lr_bname.

    " remember entry
    lv_tabix = sy-tabix.

    clear: ls_node_root
         , lv_cua_mode
         .

    "-- consider CUA state ---------------------------------
    if gv_cua_active = if_identity=>co_true.

      "-- Special case IDoc inbound processing for CUA -----
      if gv_idoc_processing = if_identity=>co_true.
        " Contains only users of CUA child that are not transferred into CUA
        read table lt_not_cua_users
             with key bname = lr_bname->bname
             binary search
             transporting no fields.

        if sy-subrc = 0.
          " User is not transferred in CUA
          read table lt_local_users
               with key bname = lr_bname->bname
               binary search
               transporting no fields.

          if sy-subrc = 0.
            " No maintenance of local users via Idoc
            clear: ls_msg.
            " Lokaler Benutzer &1 darf nicht per IDoc geändert werden
            ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '200'.
            ls_msg-msgv1 = lr_bname->bname.
            if 1 = 0. message e200(suid01) with ls_msg-msgv1. endif. "#EC *

            call method go_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = lr_bname->bname
                iv_nodename = if_identity_definition=>gc_node_root
                iv_field    = if_identity_definition=>gc_field_root_bname
                iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
                is_msg      = ls_msg.

            " remove user from lt_known_refs
            read table lt_known_refs
                 with key identity-bname = lr_bname->bname
                 binary search
                 transporting no fields.

            lv_supp_tabix = sy-tabix.
            if sy-subrc = 0.
              delete lt_known_refs index lv_supp_tabix.
            endif.

            " BNAME was already locked --> Take care to unlock again!
            append lr_bname->bname to lt_unlock_bnames.

            " delete entry from further processing
            delete lt_bname index lv_tabix.

            continue.  "==========================> Jump to next BNAME in LOOP
          else.
            " Maintain as new CUA user
            if ( iv_modus = go_persistence->co_ta_modus_create ).
              lv_cua_mode = co_cua_create.
            "else.
              "leave it '0' (default) leading into normal modifying by an IDoc.
            endif.
          endif.

        else.
          " Already CUA user ==> set CUA processing mode according to trans. mode
          if iv_modus = go_persistence->co_ta_modus_create.
            " Set "Create CUA user" mode
            lv_cua_mode = co_cua_create.
          elseif iv_modus = go_persistence->co_ta_modus_modify or
                 iv_modus = go_persistence->co_ta_modus_delete .
            " Check if "reserved" user (created by ROLE/PROFILE Idoc but deactivated
            " until USER Idoc will be processed )
            read table lt_reserved_cua_users
               with key bname = lr_bname->bname
               binary search
               transporting no fields.
            if sy-subrc = 0.
              " Set "Reserved CUA user" mode
              lv_cua_mode = co_cua_reserved.
            endif.
          endif.
        endif.

        " -- Normal CUA processing ----
      else.
        case iv_modus.
            " -- Create mode
            " CUA child system : normally no direct creation of users in CUA child systems is possible
            " Exceptions: a) user can be created with BAPI_USER_CREATE
            "             b) user can be created as local user
          when go_persistence->co_ta_modus_create.
            " Special case: Create local user (both in central and child systems)
            if iv_cua_ts_local_user eq if_identity=>co_true.
              lv_cua_mode = co_cua_local_create.

              " Special case SCUG: copy user from child system ==> distribution is not needed
            elseif gs_cua_user_transfer-active eq if_identity=>co_true and
                   gv_cua_central              eq if_identity=>co_true.
              lv_cua_mode = co_cua_child_copy.

              " Child system: user is created with BAPI_USER* or SUSR_BAPI_USER*
            elseif iv_cua_ts_force_modifaction eq if_identity=>co_true and
                   gv_cua_child                eq if_identity=>co_true.
              lv_cua_mode = co_cua_not_transferred. "Handle as not transfered

              " Child system: user is to be created not with BAPI_USER* and not as local user
            elseif gv_cua_child          eq if_identity=>co_true.
              clear: ls_msg.
              ls_msg-msgv1 = lr_bname->bname.
              ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '204'.
              " Benutzer &1 darf nicht in ZBV-Tochtersystem angelegt werden.
              if 1 = 0. message e204(suid01) with ls_msg-msgv1. endif. "#EC *

              call method go_msg_buffer->add_object_message_symsg
                exporting
                  iv_bname    = lr_bname->bname
                  iv_nodename = if_identity_definition=>gc_node_root
                  iv_field    = if_identity_definition=>gc_field_root_bname
                  iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
                  is_msg      = ls_msg.

              " remove user from lt_known_refs
              read table lt_known_refs
                   with key identity-bname = lr_bname->bname
                   binary search
                   transporting no fields.

              lv_supp_tabix = sy-tabix.
              if sy-subrc = 0.
                delete lt_known_refs index lv_supp_tabix.
              endif.

              " BNAME was already locked --> Take care to unlock again!
              append lr_bname->bname to lt_unlock_bnames.

              " delete entry from further processing
              delete lt_bname index lv_tabix.

              continue.  "==========================> Jump to next BNAME in LOOP

            endif.

            " -- Delete or modify transaction mode
          when go_persistence->co_ta_modus_modify  or
               go_persistence->co_ta_modus_delete  .
            " Child system
            if gv_cua_child eq if_identity=>co_true.
              " Contains only users of CUA child that are not transferred into CUA environment
              read table lt_not_cua_users
                   with key bname = lr_bname->bname
                   binary search
                   transporting no fields.
              " User is not transferred in CUA or Child system: user is modified with SUSR_BAPI_USER*
              if sy-subrc                    eq 0 or
                 iv_cua_ts_force_modifaction eq if_identity=>co_true.
                lv_cua_mode = co_cua_not_transferred.
              else.
                if iv_modus = go_persistence->co_ta_modus_delete.
                  clear: ls_msg.
                  " Benutzer &1 ist in der ZBV. Keine lokalen Operationen moglich.
                  ls_msg-msgv1 = lr_bname->bname.
                  ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '203'.
                  if 1 = 0. message e203(suid01) with ls_msg-msgv1. endif. "#EC *

                  call method go_msg_buffer->add_object_message_symsg
                    exporting
                      iv_bname    = lr_bname->bname
                      iv_nodename = if_identity_definition=>gc_node_root
                      iv_field    = if_identity_definition=>gc_field_root_bname
                      iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
                      is_msg      = ls_msg.

                  " remove user from lt_known_refs
                  read table lt_known_refs
                       with key identity-bname = lr_bname->bname
                       binary search
                       transporting no fields.

                  lv_supp_tabix = sy-tabix.
                  if sy-subrc = 0.
                    delete lt_known_refs index lv_supp_tabix.
                  endif.

                  " BNAME was already locked --> Take care to unlock again!
                  append lr_bname->bname to lt_unlock_bnames.

                  " delete entry from further processing
                  delete lt_bname index lv_tabix.

                  continue.  "==========================> Jump to next BNAME in LOOP
                endif.
              endif.
            endif.

          when others.

        endcase.
      endif.

      "-- Non-CUA special case: creation of local user---------------------
    else.
      if iv_modus             eq go_persistence->co_ta_modus_create and
         iv_cua_ts_local_user eq  if_identity=>co_true.
        lv_cua_mode = co_cua_local_create.
      endif.

    endif.
**********************************************************************
*   FINISHED computation of lv_cua_mode                              *
**********************************************************************

    read table lt_header reference into lr_usr02
      with key bname = lr_bname->bname
      binary search.
    if sy-subrc ne 0.
      clear: lr_usr02.
    endif.

    clear: ls_control.

**********************************************************************
*   Create or modify instance                                        *
**********************************************************************
    read table lt_known_refs
          with key identity-bname = lr_bname->bname
          binary search
          reference into lr_known_refs.

    if sy-subrc = 0.
      " --- switch state of lt_known_refs into new mode                      *

      case lr_known_refs->refresh_required.
        when co_refresh_required.
          lr_known_refs->identity-idref->refresh( iv_release_enqueue_lock = if_identity=>co_false ).
        when co_cleanup_required.
          lr_known_refs->identity-idref->cleanup_single( ).
        when others.
          " do nothing
      endcase.

      " set target state
      lr_known_refs->identity-idref->ms_manager-modus   = lr_known_refs->post_modus.
      lr_known_refs->identity-idref->ms_manager-status  = lr_known_refs->post_status.
      lr_known_refs->identity-idref->ms_manager-enqmode = lr_known_refs->post_enqmode.
      clear lr_known_refs->identity-idref->ms_manager-flg_own_data.

      " -- transfer instance into new state
      case lr_known_refs->post_modus.
          " DISPLAY (Own User) -> DISPLAY
        when go_persistence->co_ta_modus_display.      "  Display (Own USer) -> Display
          " update header entry
          lr_known_refs->identity-idref->ms_segment_header-bname        = lr_bname->bname.
          lr_known_refs->identity-idref->ms_segment_header-before_image = lr_usr02->*.
          lr_known_refs->identity-idref->ms_segment_header-actual       = lr_usr02->*.
          clear lr_known_refs->identity-idref->ms_segment_header-status.

          " DISPLAY -> MODIFY
        when go_persistence->co_ta_modus_modify.      "  Display -> Modify
          " update header entry
          lr_known_refs->identity-idref->ms_segment_header-bname        = lr_bname->bname.
          lr_known_refs->identity-idref->ms_segment_header-before_image = lr_usr02->*.
          lr_known_refs->identity-idref->ms_segment_header-actual       = lr_usr02->*.
          clear lr_known_refs->identity-idref->ms_segment_header-status.

          "  DISPLAY -> DELETE
        when go_persistence->co_ta_modus_delete.      " Display -> Delete
          " update header entry
          lr_known_refs->identity-idref->ms_segment_header-bname        = lr_bname->bname.
          lr_known_refs->identity-idref->ms_segment_header-status       = go_persistence->co_seg_changed.
          lr_known_refs->identity-idref->ms_segment_header-before_image = lr_usr02->*.
          clear: lr_known_refs->identity-idref->ms_segment_header-actual.

          " DISPLAY -> CREATE
        when go_persistence->co_ta_modus_create.      " Display -> Create
          " update header entry
          clear: lr_known_refs->identity-idref->ms_segment_header-actual,
                 lr_known_refs->identity-idref->ms_segment_header-before_image.
          lr_known_refs->identity-idref->ms_segment_header-bname        = lr_bname->bname.
          lr_known_refs->identity-idref->ms_segment_header-actual-bname = lr_bname->bname.
          lr_known_refs->identity-idref->ms_segment_header-status       = go_persistence->co_seg_changed.

          " handle local user and zbvmaster flag
          lr_known_refs->identity-idref->set_cua_attributes( iv_cua_mode = lv_cua_mode ).

        when others. "no other mode supported
          raise exception type cx_suid_identity
            exporting
              textid   = cx_suid_identity=>internal_error
              bname    = lr_bname->bname
              ta_modus = iv_modus.
      endcase.

      " CUA handling
      if gv_cua_active = if_identity=>co_true.
        lr_known_refs->identity-idref->mv_cua_mode = lv_cua_mode.
      endif.

      " Fill control table
      ls_control-idref = lo_identity = lr_known_refs->identity-idref.
      ls_control-bname = lr_bname->bname.

    else.
      " --- Start creating new instances

      clear: ls_header.

      " initialize ls_header for constructor
      " in create mode lr_usr02 is null -> constructor dumps
      if lr_usr02 is bound.
        ls_header = lr_usr02->*.
      endif.

      " Instantiation
      create object lo_identity
        exporting
          iv_modus    = iv_modus
          iv_bname    = lr_bname->bname
          is_header   = ls_header
          iv_enq_mode = iv_enq_mode
          iv_cua_mode = lv_cua_mode.

      " Fill control table and exporting table with references
      ls_control-idref = lo_identity.
      ls_control-bname = lr_bname->bname.

      " Insert new instance: After insert, table is sorted by BNAME
      read table gt_control
           with key bname = ls_control-bname
           binary search
           transporting no fields.

      lv_supp_tabix = sy-tabix.
      if sy-subrc = 0.
        raise exception type cx_suid_identity
          exporting
            textid   = cx_suid_identity=>internal_error
            bname    = ls_control-bname
            ta_modus = iv_modus.
      else.
        insert ls_control into gt_control index lv_supp_tabix.
      endif.

    endif.

**********************************************************************
*   Post instance handling                                           *
**********************************************************************

    "--- Provide information for Property Handler in case
    "     we are running in cua child system and
    "     user is not transferred into CUA yet
    if gv_cua_child eq if_identity=>co_true and
       ( lv_cua_mode eq co_cua_not_transferred or
         lv_cua_mode eq co_cua_local_create ).
      cl_suid_property_handler=>use_local_filters( lo_identity ).
    endif.

    " Are we in maintenance of own user data?
    if iv_transaction = co_own_data.
      ls_control-idref->ms_manager-flg_own_data = go_persistence->co_flag_active.
      " do not allow to change own email
      lo_property_handler = cl_suid_property_handler=>get_instance( ).

      lo_property_handler->set_node_read_only(
        exporting
          io_identity   = lo_identity
          iv_node_name  = if_identity_definition=>gc_node_email ).
    endif.

    " Fill exporting parameter for list of new instances
    move-corresponding ls_control to ls_node_root.

    " Make sure that fetched address segment is filled
    read table lt_usr21
      with key bname = lr_bname->bname
      reference into lr_usr21
      binary search.
    if sy-subrc = 0.
      " make sure that fetched data is written into segment:
      ls_control-idref->fetch_segment_address(
        exporting
          is_address = lr_usr21->* ).
    else.
      clear: ls_usr21.
      ls_control-idref->fetch_segment_address(
        exporting
          is_address = ls_usr21 ).
    endif.

    " Determine if UUID is supplied
    read table it_identity
         with key bname = lr_bname->bname
         into ls_identity.
    if sy-subrc = 0.
      " Convert UUID into GUID if necessary
      if ls_identity-identity_guid is not initial.
        move ls_identity-identity_guid to ls_control-idref->ms_segment_address-actual-identity_guid.
        lv_identity_guid = ls_identity-identity_guid .
        if ls_identity-identity_uuid is initial.
          call method cl_gdt_conversion=>guid_outbound
            exporting
              im_guid_x = lv_identity_guid
            importing
              ex_value  = ls_identity-identity_uuid.
        endif.
      elseif ls_identity-identity_uuid is not initial.
        call method cl_gdt_conversion=>guid_inbound
          exporting
            im_value  = ls_identity-identity_uuid
          importing
            ex_guid_x = lv_identity_guid.
        move lv_identity_guid to ls_control-idref->ms_segment_address-actual-identity_guid.
      endif.
      ls_node_root-identity_guid = lv_identity_guid.
    else.
      " Create or read identity UUID
      call method ls_control-idref->if_identity~get_identity_uuid
        importing
          ev_identity_guid = ls_node_root-identity_guid.
    endif.

    " Get correct line for sorted insertion into et_node_root
    read table et_node_root
         with key bname = ls_node_root-bname
         binary search
         transporting no fields.

    lv_supp_tabix = sy-tabix.
    if sy-subrc = 0.
      raise exception type cx_suid_identity
        exporting
          textid   = cx_suid_identity=>internal_error
          bname    = ls_control-bname
          ta_modus = iv_modus.
    else.
      insert ls_node_root into et_node_root index lv_supp_tabix.
    endif.

  endloop.

**********************************************************************
*--- Cleanup: Dequeue BNAMES that were locked, but not authorized ---*
**********************************************************************
  if lt_unlock_bnames is not initial.

    if iv_set_optimistic_enqueue_lock = if_identity=>co_true.
      cl_suid_tools=>dequeue(
        exporting
          it_bname   = lt_unlock_bnames
          i_enq_mode = cl_suid_tools=>co_lock_mode_opt ).
    endif.

    cl_suid_tools=>dequeue(
      exporting
        it_bname   = lt_unlock_bnames
        i_enq_mode = lv_enq_mode ).

    clear lt_unlock_bnames.

  endif.

endmethod.


method instantiation_for_distribution.
* Method to instantiate Identities for re-distribution

* Perform following blocks:
*   - Existence check
*   - Authority check for Display
*   - Enqueue (exclusive lock needed)
*   - Check whether Identity reference is already known
*   - If any of the above checks fail: Inform failed BNAME

  data: lr_bname              type ref to suid_st_bname
      , lr_control            type ref to ty_control
      , ls_control            type        ty_control
      , lt_known_refs         type        tt_control
      , ls_node_root          type        suid_st_node_root
      , lt_bname              type        suid_tt_bname
      , lt_bname_for_instantiation type   suid_tt_bname
      , lt_bname_not_locked   type        suid_tt_bname_locked
      , lr_bname_not_locked   type ref to suid_st_bname_locked
       ,lt_unlock_bnames      type        suid_tt_bname
      , lt_nodes_prefetch     type        suid_tt_node
      , lt_header             type        suid_tt_usr02
      , ls_header             type        usr02
      , lt_identity_exist     type        suid_tt_identity
      , lt_identity_not_exist type        suid_tt_identity
      , lr_identity           type ref to suid_st_identity
      , lo_identity           type ref to cl_identity
      , ls_msg                type        symsg
      , lv_tabix_empty_bname  type        sy-tabix
      , lv_tabix              type        sy-tabix
      .

  lt_bname = it_bname. " IT_BNAME may not be changed

  clear: et_bname_failed
       , et_bname_not_exist
       , et_bname_instantiated
       , et_node_root
       .

*  eo_msg_buffer = go_msg_buffer.

*--- Method may only be executed in CUA central system! ---------------*
  if gv_cua_central <> go_persistence->co_flag_active.
    clear: ls_msg.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '351'.
*   You have not logged onto the central system
    if 1 = 0. message e351(01). endif.
    read table it_bname reference into lr_bname index 1.
    call method go_msg_buffer->add_object_message_symsg
      exporting
        iv_bname    = lr_bname->bname
        iv_nodename = if_identity_definition=>gc_node_root
        iv_field    = if_identity_definition=>gc_field_root_bname
        iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
        is_msg      = ls_msg.

    et_bname_failed = it_bname.           " All BNAMES not instantiated
    return.                               " no further processing needed
  endif.

  set locale language sy-langu.
*--- First perform some checks on imported Identity IDs ---------------*
  loop at lt_bname reference into lr_bname.
    if lr_bname->bname is initial.
      clear: ls_msg.
*     ls_msg-msgv1 = lr_bname->bname.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '279'.
*     Enter a user name
      if 1 = 0. message e279(01). endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_bname->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.
      lv_tabix_empty_bname = sy-tabix.
      continue.
    endif.

*...Upper case conversion
    translate lr_bname->bname to upper case.
  endloop.

  if lv_tabix_empty_bname <> 0.
    delete lt_bname index lv_tabix_empty_bname.
  endif.
  " If single user was given: lt_bname is empty now
  check: lt_bname is not initial.

* Check whether a reference for this Identity already exists
  loop at lt_bname reference into lr_bname.
    read table gt_control
         with key bname = lr_bname->bname
         binary search
         reference into lr_control
         .
    if sy-subrc = 0.
*     Accept existing references in some cases: -> No use case !!!!!!
*      if lr_control->idref->ms_manager-modus
*                                  = go_persistence->co_ta_modus_display.
*        lr_control->idref->ms_manager-modus
*                           = go_persistence->co_ta_modus_distribute.
*        lr_control->idref->ms_manager-status
*                           = go_persistence->co_ta_status_unchanged.
**           Refresh: Thus get latest data from persistence by Pre-Fetch
*        call method lr_control->idref->refresh.
*
*        append lr_control->* to lt_known_refs.
*      else.      " Only switch from 'Display' to 'Distribute' is allowed
        append lr_bname->bname to et_bname_failed.
        delete lt_bname.
*      endif.
    endif.
  endloop.

*--- Existence check --------------------------------------------------*
  call method go_persistence->if_suid_persistence_query~existence_check
    exporting
      it_bname              = lt_bname
    importing
      et_identity_exist     = lt_identity_exist
      et_identity_not_exist = lt_identity_not_exist.

  move lt_identity_exist to lt_bname_for_instantiation.

  loop at lt_identity_not_exist reference into lr_identity.
*   Put error message if requested
    if iv_bname_not_exist_no_error = if_identity=>co_false.
      clear: ls_msg.
      ls_msg-msgv1 = lr_identity->bname.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '124'.
*     User & does not exist
      if 1 = 0. message e124(01) with ls_msg-msgv1. endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_identity->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.
    endif.

    append lr_identity->bname to et_bname_failed.
  endloop.

  if et_bname_not_exist is requested.
    et_bname_not_exist = lt_identity_not_exist.
  endif.

*...Check: Known references (were in 'Display' mode!) still exist
  loop at lt_known_refs reference into lr_control.
    read table lt_identity_exist
         with key bname = lr_control->bname
         binary search
         transporting no fields
         .
    lv_tabix = sy-tabix.
    if sy-subrc <> 0.  " Known reference does not exist on database!
      clear: ls_msg.
      ls_msg-msgv1 = lr_control->bname.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '124'.
*     User & does not exist
      if 1 = 0. message e124(01) with ls_msg-msgv1. endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_control->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.

      append lr_control->bname to et_bname_failed.
    endif.
  endloop.

*---- Ok, now: Perform Enqueue and Read header data -------------------*
  call method cl_suid_tools=>enqueue  " Always perform exclusive lock
    exporting
      it_bname          = lt_bname_for_instantiation
    importing
      et_bname          = lt_bname_not_locked
      .

*... Prefetch header is always performed!
  call method go_persistence->if_suid_persistence_read~read
    exporting
      it_bname    = lt_bname_for_instantiation
    importing
      et_header   = lt_header                 " Needed for constructor
*      et_usrstamp = lt_usrstamp
      .

*---- Finally, start instantiation ------------------------------------*
  loop at lt_bname_for_instantiation reference into lr_bname.
    clear ls_control.
    clear ls_header.
    clear ls_msg.

    ls_control-bname = lr_bname->bname.

    read table lt_header into ls_header  "Don't use reference here
      with key bname = ls_control-bname
      binary search.

*    if lv_new_coding = 'X'.
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_root
          iv_operation = cl_suid_tools=>co_activity_distribute
          iv_class     = ls_header-class
        importing
          es_msg       = ls_msg.
*    else.
*      call method cl_identity=>node_authority_check
*        exporting
*          iv_node_name        = if_identity_definition=>gc_node_root
*          iv_transaction_mode = go_persistence->co_ta_modus_display
*          iv_class            = ls_header-class
*        importing
*          es_msg              = ls_msg.
*    endif.

    if ls_msg-msgty = 'E'. "Authority check failed
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_bname->bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = ls_msg.

      append lr_bname->bname to et_bname_failed.
      append lr_bname->bname to lt_unlock_bnames.
      continue.  "==========================> Jump to next BNAME in LOOP
    endif.

*---- Check for lock status
    read table lt_bname_not_locked
         with key bname = ls_control-bname
         binary search
         reference into lr_bname_not_locked
         .
    if sy-subrc = 0.  " Identity could not be locked: Don't instantiate!
*   Check for mode = change here??
      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ls_control-bname
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          is_msg      = lr_bname_not_locked->msg.

      append lr_bname->bname to et_bname_failed.
      continue.  "==========================> Jump to next BNAME in LOOP
    endif.

*   Local user can't be distributed to other systems
* -->> Local user should not be relevant in central system
*    IF ls_header-reserved = cl_identity=>co_user_local.
*      CLEAR: ls_msg.
*      ls_msg-msgv1 = ls_control-bname.
*      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '205'.
**     Lokaler Benutzer &1 darf nicht in ZBV-Tochtersystem verteilt werden.
*      IF 1 = 0.
*        MESSAGE e205(suid01) WITH ls_msg-msgv1.             "#EC *
*      ENDIF.
*
*      CALL METHOD go_msg_buffer->add_object_message_symsg
*        EXPORTING
*          iv_bname    = ls_control-bname
*          iv_nodename = if_identity_definition=>gc_node_root
*          iv_field    = if_identity_definition=>gc_field_root_bname
*          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
*          is_msg      = ls_msg.
*
*      APPEND lr_bname->bname TO et_bname_failed.
*      APPEND lr_bname->bname TO lt_unlock_bnames.
*      CONTINUE.  "==========================> Jump to next BNAME in LOOP
*    ENDIF.

*   Special case transaction mode for known references
    read table lt_known_refs
         with key bname = ls_control-bname
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      read table gt_control reference into lr_control
         with key bname = ls_control-bname
         binary search
         .

*     Take newest database information for header
      lr_control->bname = ls_control-bname.
      lr_control->idref->ms_segment_header-bname = lr_control->bname.

      lr_control->idref->ms_segment_header-before_image = ls_header.
      lr_control->idref->ms_segment_header-actual =
                    lr_control->idref->ms_segment_header-before_image.
      clear lr_control->idref->ms_segment_header-status.

*     Take information about lock mode
      lr_control->idref->ms_manager-enqmode = if_identity=>co_enqueue_mode_exclusive.

*     Fill exporting table for references by BNAME
      move-corresponding lr_control->* to ls_node_root.
*         Get correct line for sorted insertion into et_node_root
      read table et_node_root
           with key bname = ls_node_root-bname
           binary search
           transporting no fields
           .
      insert ls_node_root into et_node_root index sy-tabix.
      continue.  "==========================> Jump to next BNAME in LOOP
    endif.

*---- Instantiation
    create object lo_identity
      exporting
        iv_modus    = go_persistence->co_ta_modus_modify "distribute
        iv_bname    = ls_control-bname
        is_header   = ls_header
        iv_enq_mode = if_identity=>co_enqueue_mode_exclusive.

*---- Fill control table and exporting table with references
    ls_control-idref = lo_identity.
*   Keep enqueue mode:
    ls_control-idref->ms_manager-enqmode = if_identity=>co_enqueue_mode_exclusive.

*   Insert new instance: After insert, table is sorted by BNAME
    read table gt_control
         with key bname = ls_control-bname
         binary search
         transporting no fields
         .
    lv_tabix = sy-tabix.
    if sy-subrc = 0.
      raise exception
        type
        cx_suid_identity
        exporting
          textid   = cx_suid_identity=>internal_error
          bname    = ls_control-bname
          ta_modus = go_persistence->co_ta_modus_modify. "distribute.
    else.
      insert ls_control into gt_control index lv_tabix.
    endif.
*   Fill exporting parameter for list of new instances
    move-corresponding ls_control to ls_node_root.

*   Get correct line for sorted insertion into et_node_root
    read table et_node_root
         with key bname = ls_node_root-bname
         binary search
         transporting no fields
         .
    lv_tabix = sy-tabix.
    if sy-subrc = 0.
      raise exception
        type
        cx_suid_identity
        exporting
          textid   = cx_suid_identity=>internal_error
          bname    = ls_control-bname
          ta_modus = go_persistence->co_ta_modus_modify. "distribute.
    else.
      insert ls_node_root into et_node_root index sy-tabix.
    endif.
  endloop.

*---- Prefetch CUA systems --------------------------------------------*
  refresh: et_bname_instantiated
          ,lt_nodes_prefetch
          .
  loop at et_node_root into ls_node_root.
    append ls_node_root-bname to et_bname_instantiated.
  endloop.
  append if_identity_definition=>gc_node_cua_system to lt_nodes_prefetch.
  call method cl_identity=>nodes_prefetch
    exporting
      it_bname          = et_bname_instantiated
      it_nodes_prefetch = lt_nodes_prefetch.


*--- Cleanup: Dequeue BNAMES that were locked, but not instantiated ---*
  if lt_unlock_bnames is not initial.
    call method cl_suid_tools=>dequeue
      exporting
        it_bname = lt_unlock_bnames.
  endif.

endmethod.


method nodes_prefetch.
*
* Perform Prefetch for given list or all nodes
*

* -> Map nodes to segments
* -> Call READ method of persistence for segment information
* -> Distribute data from READ method to segments

  data: lr_bname            type ref to suid_st_bname
       ,lt_bname            type        suid_tt_bname
       ,lt_bname_read       type        suid_tt_bname
       ,lr_control          type ref to ty_control
       ,lt_address          type        suid_tt_usr21
       ,lr_address          type ref to usr21
       ,lt_refuser          type        suid_tt_usrefus
       ,lr_refuser          type ref to usrefus
       ,lt_cua_systems      type        suid_tt_uszbvsys
       ,lr_cua_systems      type ref to uszbvsys
       ,lt_cua_systems_fetch type       suid_tt_uszbvsys
       ,lt_cua_users_prot   type        suid_tt_uszbvprot
       ,lr_cua_user_prot    type ref to uszbvprot
       ,lt_cua_users_prot_fetch type    suid_tt_uszbvprot
       ,lt_defaults         type        suid_tt_usr01
       ,lr_defaults         type ref to usr01
       ,lt_groups           type        suid_tt_usgrp_user
       ,lr_groups           type ref to usgrp_user
       ,lt_groups_fetch     type        suid_tt_usgrp_user
       ,lt_parameter        type        suid_tt_usr05
       ,lr_parameter        type ref to usr05
       ,lt_parameter_fetch  type        suid_tt_usr05
       ,lt_profiles_t04     type        suid_tt_ust04
       ,lr_profiles_t04     type ref to ust04
       ,lt_profiles_t04_fetch type      suid_tt_ust04
       ,lt_roles            type        suid_tt_agr_users
       ,lr_roles            type ref to agr_users
       ,lt_roles_fetch      type        suid_tt_agr_users
       ,lt_snc              type        suid_tt_usracl
       ,lr_snc              type ref to usracl
       ,lt_uclass           type        suid_tt_usr06
       ,lr_uclass           type ref to usr06
       ,lt_cua_roles        type        suid_tt_usla04
       ,lr_cua_roles        type ref to usla04
       ,lt_cua_roles_fetch  type        suid_tt_usla04
       ,lt_cua_profiles     type        suid_tt_usl04
       ,lr_cua_profiles     type ref to usl04
       ,lt_cua_profiles_fetch type      suid_tt_usl04
       ,lt_cua_uclasses     type        suid_tt_usr06sys
       ,lr_cua_uclasses     type ref to usr06sys
       ,lt_cua_uclasses_fetch type      suid_tt_usr06sys
       ,lt_certmap          type        suid_tt_usrcertmap
       ,lr_certmap          type ref to usrcertmap
       ,lt_certmap_fetch    type        suid_tt_usrcertmap
       ,lt_nodes_prefetch   type        suid_tt_node
       ,lt_userstamp        type        suid_tt_usrstamp
       ,lr_userstamp        type ref to usrstamp
       ,lt_userstamp_fetch  type        suid_tt_usrstamp
       ,lt_dbms_user        type        suid_tt_usr_dbms_user
       ,lr_dbms_user        type ref to usr_dbms_user
       ,lt_docu             type        suid_tt_docu
       ,lr_docu             type ref to suid_st_docu
       ,lt_docu_fetch       type        suid_tt_docu
       .

* One flag for each segment - excluding header: Header is always filled!

  data: lv_seg_address       type char01
       ,lv_seg_cua_systems   type char01
       ,lv_seg_defaults      type char01
       ,lv_seg_groups        type char01
       ,lv_seg_parameter     type char01
       ,lv_seg_profiles_t04  type char01
       ,lv_seg_refuser       type char01
       ,lv_seg_roles         type char01
       ,lv_seg_snc           type char01
       ,lv_seg_uclass        type char01
       ,lv_seg_cua_profiles  type char01
       ,lv_seg_cua_roles     type char01
       ,lv_seg_cua_uclasses  type char01
       ,lv_seg_certmap       type char01
       ,lv_seg_userstamp     type char01
       ,lv_seg_dbms_user     type char01
       ,lv_seg_userdocu      type char01
*       ,lv_seg.....           type char01
       .

*----Preliminaries: Make sure the BNAMES are upper case ---------------*
  lt_bname = it_bname.
  set locale language sy-langu.

  loop at lt_bname reference into lr_bname.
    translate lr_bname->bname to upper case.
  endloop.

* Sort Prefetch table
  lt_nodes_prefetch = it_nodes_prefetch.
  sort lt_nodes_prefetch.


*----Evaluate which nodes are requested for Pre-Fetch -----------------*
  if iv_prefetch_all = go_persistence->co_flag_active.
*... Set all segment flags to active: Read all segments

    lv_seg_address       = go_persistence->co_flag_active.
    lv_seg_cua_systems   = go_persistence->co_flag_active.
    lv_seg_defaults      = go_persistence->co_flag_active.
    lv_seg_groups        = go_persistence->co_flag_active.
    lv_seg_parameter     = go_persistence->co_flag_active.
    lv_seg_profiles_t04  = go_persistence->co_flag_active.
    lv_seg_refuser       = go_persistence->co_flag_active.
    lv_seg_roles         = go_persistence->co_flag_active.
    lv_seg_snc           = go_persistence->co_flag_active.
    lv_seg_uclass        = go_persistence->co_flag_active.
    lv_seg_cua_profiles  = go_persistence->co_flag_active.
    lv_seg_cua_roles     = go_persistence->co_flag_active.
    lv_seg_cua_uclasses  = go_persistence->co_flag_active.
    lv_seg_certmap       = go_persistence->co_flag_active.
    lv_seg_userstamp     = go_persistence->co_flag_active.
    lv_seg_dbms_user     = go_persistence->co_flag_active.
    lv_seg_userdocu      = go_persistence->co_flag_active.
*    lv_seg_...        = go_persistence->co_flag_active.
  else.                               " Evaluate table lt_nodes_prefetch
* First evaluate list of nodes for Prefetch: Which segments are required?

* Nodes PASSWORD. LOCKDATA, PWDHASH: Only header segment is required!

    check: lt_nodes_prefetch is not initial." ELSE ==> Jump to ENDMETHOD

*   Prefetch for logondata node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_logondata
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_refuser = go_persistence->co_flag_active.
      lv_seg_address = go_persistence->co_flag_active.
    endif.

*   Prefetch for reference user node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_reference_user
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_refuser = go_persistence->co_flag_active.
    endif.

*   Prefetch for defaults node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_defaults
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_defaults = go_persistence->co_flag_active.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for SNC node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_snc
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_snc = go_persistence->co_flag_active.
    endif.

* Prefetch for roles node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_role
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_roles = go_persistence->co_flag_active.
    endif.

* Prefetch for organization node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_organization
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for organization_name node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_organization_name
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for person node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_person
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for person_name node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_person_name
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for workplace node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_workplace
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for tech user node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_tech_user
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for tech user data node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_tech_user_data
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_address  = go_persistence->co_flag_active.
    endif.

* Prefetch for profiles node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_profile
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
*      lv_seg_profiles_r04 = go_persistence->co_flag_active.
      lv_seg_profiles_t04 = go_persistence->co_flag_active.
    endif.

* Prefetch for parameter node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_parameter
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_parameter  = go_persistence->co_flag_active.
    endif.

* Prefetch for groups node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_group
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_groups  = go_persistence->co_flag_active.
    endif.

* Prefetch for licence data node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_uclass
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_uclass  = go_persistence->co_flag_active.
    endif.

* Prefetch for CUA systems node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_cua_system
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_cua_systems = go_persistence->co_flag_active.
    endif.

* Prefetch for CUA role node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_cua_role
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_cua_roles = go_persistence->co_flag_active.
    endif.

* Prefetch for CUA profile node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_cua_profile
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_cua_profiles = go_persistence->co_flag_active.
    endif.

* Prefetch for CUA licence data node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_cua_uclass
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_cua_uclasses  = go_persistence->co_flag_active.
    endif.

* Prefetch for certificate mapping
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_certmap
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_certmap = go_persistence->co_flag_active.
    endif.

* Prefetch for admin data node was requested
    read table lt_nodes_prefetch
         with key nodename = if_identity_definition=>gc_node_admindata
         binary search
         transporting no fields
         .
    if sy-subrc = 0.
      lv_seg_userstamp = go_persistence->co_flag_active.
    endif.

* Prefetch for DBMS_USER node was requested
  read table lt_nodes_prefetch
       with key nodename = if_identity_definition=>gc_node_dbms_user
       binary search
       transporting no fields
       .
  if sy-subrc = 0.
    lv_seg_dbms_user      = go_persistence->co_flag_active.
  endif.

* Prefetch for DBMS_ROLES node was requested
  read table lt_nodes_prefetch
       with key nodename = if_identity_definition=>gc_node_dbms_role
       binary search
       transporting no fields
       .
  if sy-subrc = 0.
    lv_seg_dbms_user      = go_persistence->co_flag_active.
  endif.

* Prefetch for user documentation node was requested
  read table lt_nodes_prefetch
       with key nodename = if_identity_definition=>gc_node_documentation
       binary search
       transporting no fields
       .
  if sy-subrc = 0.
    lv_seg_userdocu = go_persistence->co_flag_active.
  endif.

*** Prefetch for ... node was requested
**  read table lt_nodes_prefetch
**       with key nodename = if_identity_definition=>gc_node_...
**       binary search
**       transporting no fields
**       .
**  if sy-subrc = 0.
**    lv_seg_...     = go_persistence->co_flag_active.
**    lv_seg_...     = go_persistence->co_flag_active.
**    ...
**  endif.
  endif.

* Segments to be treated in Prefetch:
*  MS_SEGMENT_USERSTAMP
*  MS_SEGMENT_ADDRESS         OK
*  MS_SEGMENT_CUA_SYSTEMS     OK
*  MS_SEGMENT_CUA_USER_PROT   OK
*  MS_SEGMENT_DEFAULTS        OK
*  MS_SEGMENT_GROUPS          OK
*  MS_SEGMENT_PARAMETER       OK
*  MS_SEGMENT_PROFILES_T04    OK
*  MS_SEGMENT_REFUSER         OK
*  MS_SEGMENT_ROLES           OK
*  MS_SEGMENT_SNC             OK
*  MS_SEGMENT_UCLASS          OK
*  MS_SEGMENT_AGR_DEFINE      intern?
*  MS_SEGMENT_AGR_TIMEC       intern?
*
* The following segments are internal segment: No Prefetch required!
*  MS_SEGMENT_AUDITLOG
*  MS_SEGMENT_HEADER_HIST
*  MS_SEGMENT_PRINTPARAM
*  MS_SEGMENT_PWDHISTORY

*---- Now fill requested segments -------------------------------------*

* One block per segment:
*   1.) Check LT_BNAME: Build new table with all users in LT_BNAME for
*       which the respective segment is NOT filled yet
*       (indicator: field segment...-BNAME is empty)
*   2.) Call READ method of persistence for this segment
*   3.) Distribute data to segments



* Prefetch nodes by request
*---- Prefetch address segment ----------------------------------------*
  if lv_seg_address = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_address-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname_read
      importing
        et_address = lt_address.

*   3.) Distribute data to segment for address
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        read table lt_address reference into lr_address
          with key bname = lr_control->bname
          binary search.
        if sy-subrc = 0.
          call method lr_control->idref->fetch_segment_address
            exporting
              is_address = lr_address->*.
        else.
          data: ls_address type usr21.
          clear: ls_address.
          call method lr_control->idref->fetch_segment_address
            exporting
              is_address = ls_address.
        endif.
      endif.
    endloop.
  endif.


*---- Prefetch CUA systems segment ------------------------------------*
  if lv_seg_cua_systems = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_cua_systems-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname       = lt_bname_read
      importing
        et_cua_systems = lt_cua_systems.

*   3.) Distribute data to segment for CUA systems
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_cua_systems_fetch.
        read table lt_cua_systems
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_cua_systems reference into lr_cua_systems from sy-tabix.
            if lr_cua_systems->bname ne lr_control->bname.
              exit.
            endif.
            append lr_cua_systems->* to lt_cua_systems_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_cua_systems
          exporting
            it_cua_systems = lt_cua_systems_fetch.
      endif.
    endloop.


*---- Prefetch CUA user protocol segment ------------------------------------*
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_cua_user_prot-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname         = lt_bname_read
      importing
        et_cua_user_prot = lt_cua_users_prot.

*   3.) Distribute data to segment for CUA systems
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_cua_users_prot_fetch.
        read table lt_cua_users_prot
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_cua_users_prot reference into lr_cua_user_prot from sy-tabix.
            if lr_cua_user_prot->bname ne lr_control->bname.
              exit.
            endif.
            append lr_cua_user_prot->* to lt_cua_users_prot_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_cua_user_prot
          exporting
            it_cua_users_prot = lt_cua_users_prot_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch defaults segment ---------------------------------------*
  if lv_seg_defaults = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_defaults-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname_read
      importing
        et_defaults = lt_defaults.

*   3.) Distribute data to segment for defaults
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        read table lt_defaults reference into lr_defaults
             with key bname = lr_control->bname
             binary search.
        if sy-subrc = 0.
          call method lr_control->idref->fetch_segment_defaults
            exporting
              is_defaults = lr_defaults->*.
        else.
          data: ls_defaults type usr01.
          clear: ls_defaults.
          call method lr_control->idref->fetch_segment_defaults
            exporting
              is_defaults = ls_defaults.
        endif.
      endif.
    endloop.
  endif.


*---- Prefetch groups segment -----------------------------------------*
  if lv_seg_groups = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_groups-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname  = lt_bname_read
      importing
        et_groups = lt_groups.

*   3.) Distribute data to segment for groups
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_groups_fetch.
        read table lt_groups
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_groups reference into lr_groups from sy-tabix.
            if lr_groups->bname ne lr_control->bname.
              exit.
            endif.
            append lr_groups->* to lt_groups_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_groups
          exporting
            it_groups = lt_groups_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch parameter segment ------------------------------------- *
  if lv_seg_parameter = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_parameter-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname     = lt_bname_read
      importing
        et_parameter = lt_parameter.

*   3.) Distribute data to segment for parameter
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_parameter_fetch.
        read table lt_parameter
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_parameter reference into lr_parameter from sy-tabix.
            if lr_parameter->bname ne lr_control->bname.
              exit.
            endif.
            append lr_parameter->* to lt_parameter_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_parameter
          exporting
            it_parameter = lt_parameter_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch profiles T04 segment -----------------------------------*
  if lv_seg_profiles_t04 = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_profiles_t04-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname_read
      importing
        et_profiles = lt_profiles_t04.

*   3.) Distribute data to segment for PROFILES_T04
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_profiles_t04_fetch.
        read table lt_profiles_t04
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_profiles_t04 reference into lr_profiles_t04 from sy-tabix.
            if lr_profiles_t04->bname ne lr_control->bname.
              exit.
            endif.
            append lr_profiles_t04->* to lt_profiles_t04_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_profiles_t04
          exporting
            it_profiles = lt_profiles_t04_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch reference user segment ---------------------------------*
  if lv_seg_refuser = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_refuser-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname_read
      importing
        et_refuser = lt_refuser.

*   3.) Distribute data to segment for reference user
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        read table lt_refuser reference into lr_refuser
          with key bname = lr_control->bname
          binary search.
        if sy-subrc = 0.
          call method lr_control->idref->fetch_segment_refuser
            exporting
              is_refuser = lr_refuser->*.
        else.
          data: ls_refuser type usrefus.
          clear: ls_refuser.
          call method lr_control->idref->fetch_segment_refuser
            exporting
              is_refuser = ls_refuser.
        endif.
      endif.
    endloop.
  endif.


*---- Prefetch roles segment ------------------------------------------*
  if lv_seg_roles = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_roles-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname = lt_bname_read
      importing
        et_roles = lt_roles.

*   3.) Distribute data to segment for roles
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_roles_fetch.
        read table lt_roles
             with key uname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_roles reference into lr_roles from sy-tabix.
            if lr_roles->uname ne lr_control->bname.
              exit.
            endif.
            append lr_roles->* to lt_roles_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_roles
          exporting
            it_roles = lt_roles_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch SNC segment -------------------------------------------*
  if lv_seg_snc = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_snc-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname = lt_bname_read
      importing
        et_snc   = lt_snc.

*   3.) Distribute data to segment for SNC
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        read table lt_snc reference into lr_snc
             with key bname = lr_control->bname
             binary search.
        if sy-subrc = 0.   " Body of loop was passed at least once
          call method lr_control->idref->fetch_segment_snc
            exporting
              is_snc = lr_snc->*.
        else.
          data: ls_snc type usracl.
          clear: ls_snc.
          call method lr_control->idref->fetch_segment_snc
            exporting
              is_snc = ls_snc.
        endif.
      endif.
    endloop.
  endif.


*---- Prefetch licence segment ----------------------------------------*
  if lv_seg_uclass = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_uclass-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname  = lt_bname_read
      importing
        et_uclass = lt_uclass.

*   3.) Distribute data to segment for uclass
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        read table lt_uclass reference into lr_uclass
             with key bname = lr_control->bname
             binary search.
        if sy-subrc = 0.   " Body of loop was passed at least once
          call method lr_control->idref->fetch_segment_uclass
            exporting
              is_uclass = lr_uclass->*.
        else.
          data: ls_uclass type usr06.
          clear: ls_uclass.
          call method lr_control->idref->fetch_segment_uclass
            exporting
              is_uclass = ls_uclass.
        endif.
      endif.
    endloop.
  endif.


*---- Prefetch cua roles segment --------------------------------------*
  if lv_seg_cua_roles = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_cua_roles-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname     = lt_bname_read
      importing
        et_cua_roles = lt_cua_roles.

*   3.) Distribute data to segment for roles
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_cua_roles_fetch.
        read table lt_cua_roles
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_cua_roles reference into lr_cua_roles from sy-tabix.
            if lr_cua_roles->bname ne lr_control->bname.
              exit.
            endif.
            append lr_cua_roles->* to lt_cua_roles_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_cua_roles
          exporting
            it_roles = lt_cua_roles_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch cua profiles segment -----------------------------------*
  if lv_seg_cua_profiles = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_cua_profiles-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname        = lt_bname_read
      importing
        et_cua_profiles = lt_cua_profiles.

*   3.) Distribute data to segment for roles
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_cua_profiles_fetch.
        read table lt_cua_profiles
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_cua_profiles reference into lr_cua_profiles from sy-tabix.
            if lr_cua_profiles->bname ne lr_control->bname.
              exit.
            endif.
            append lr_cua_profiles->* to lt_cua_profiles_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_cua_profiles
          exporting
            it_cua_profiles = lt_cua_profiles_fetch.
      endif.
    endloop.
  endif.


*---- Prefetch CUA licence segment ------------------------------------*
  if lv_seg_cua_uclasses = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_cua_uclasses-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname        = lt_bname_read
      importing
        et_cua_uclasses = lt_cua_uclasses.

*   3.) Distribute data to segment for roles
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_cua_uclasses_fetch.
        read table lt_cua_uclasses
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_cua_uclasses reference into lr_cua_uclasses from sy-tabix.
            if lr_cua_uclasses->bname ne lr_control->bname.
              exit.
            endif.
            append lr_cua_uclasses->* to lt_cua_uclasses_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_cua_uclasses
          exporting
            it_cua_uclasses = lt_cua_uclasses_fetch.
      endif.
    endloop.
  endif.

*---- Prefetch certifiate mapping segment -----------------------------*
  if lv_seg_certmap = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_certmap-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname   = lt_bname_read
      importing
        et_certmap = lt_certmap.

*   3.) Distribute data to segment for portal roles
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_certmap_fetch.
        read table lt_certmap
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_certmap reference into lr_certmap from sy-tabix.
            if lr_certmap->bname ne lr_control->bname.
              exit.
            endif.
            append lr_certmap->* to lt_certmap_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_certmap
          exporting
            it_certmap = lt_certmap_fetch.
      endif.
    endloop.
  endif.

*---- Prefetch usrstamp segment ------------------------*
  if lv_seg_userstamp = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_userstamp-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname_read
      importing
        et_usrstamp = lt_userstamp.

*   3.) Distribute data to segment for usrstamp
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_userstamp_fetch.
        read table lt_userstamp
             with key username = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_userstamp reference into lr_userstamp from sy-tabix.
            if lr_userstamp->username ne lr_control->bname.
              exit.
            endif.
            append lr_userstamp->* to lt_userstamp_fetch.
          endloop.
        endif.
        lr_control->idref->fetch_segment_usrstamp(
          exporting
            it_usrstamp  = lt_userstamp_fetch ).
      endif.
    endloop.
  endif.

*---- Prefetch DBMS_USER segment ------------------------*
  if lv_seg_dbms_user = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_dbms_user-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname    = lt_bname_read
      importing
        et_dbms_user = lt_dbms_user.

*   3.) Distribute data to segment for usr_dbms_user
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        read table lt_dbms_user reference into lr_dbms_user
             with key bname = lr_control->bname
             binary search.
        if sy-subrc = 0.
          call method lr_control->idref->fetch_segment_dbms_user
            exporting
              is_dbms_user = lr_dbms_user->*.
        else.
          data ls_dbms_user type usr_dbms_user.
          call method lr_control->idref->fetch_segment_dbms_user
            exporting
              is_dbms_user = ls_dbms_user.
        endif.
      endif.
    endloop.
  endif.

*---- Prefetch user documentation segment -------------------------------------------*
  if lv_seg_userdocu = go_persistence->co_flag_active.
*   1.) Check all users in LT_BNAME: Segment empty?
    clear lt_bname_read.
    loop at lt_bname reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        if lr_control->idref->ms_segment_docu-bname is initial.
          append lr_bname->* to lt_bname_read. " Read data for segment
        endif.
      endif.
    endloop.

*   2.) Call READ
    call method go_persistence->if_suid_persistence_read~read
      exporting
        it_bname = lt_bname_read
      importing
        et_docu  = lt_docu.

*   3.) Distribute data to segment for docu
    loop at lt_bname_read reference into lr_bname.
      read table gt_control reference into lr_control
         with key bname = lr_bname->bname
         binary search.
      if sy-subrc = 0.
        clear: lt_docu_fetch.
        read table lt_docu
             with key bname = lr_control->bname
             binary search
             transporting no fields.
        if sy-subrc eq 0.
          loop at lt_docu reference into lr_docu from sy-tabix.
            if lr_docu->bname ne lr_control->bname.
              exit.
            endif.
            append lr_docu->* to lt_docu_fetch.
          endloop.
        endif.
        call method lr_control->idref->fetch_segment_docu
          exporting
            it_docu = lt_docu_fetch.
      endif.
    endloop.
  endif.

endmethod.


method nodes_prefill_default_values.
*  The following fields require an entry and may not be empty:
*        (hence the respective table entry must exist anyway)
*    SUID_ST_NODE_LOGONDATA:
*      USTYP: User type in header table USR02 ('A')
*    SUID_ST_NODE_DEFAULTS:
*      DATFM: Date format in defaults table USR01
*                      (get from function SUSR_USER_DEFAULT_DATE_FORMAT)
*      TIMEFM: Time format in defaults table USR01
*                      (space = '0': 24h Time format is default)
*      SPDA: Print parameter 2 ('K')
*      SPDB: Print parameter 3 ('H')

  data:  lt_node_logondata     type        suid_tt_fields
       , ls_logondata          type        suid_st_node_logondata
       , lt_node_defaults      type        suid_tt_fields
       , ls_defaults           type        suid_st_node_defaults
       , ls_node               type        suid_node_field
       , lr_node_root          type ref to suid_st_node_root
       , lr_identity           type ref to cl_identity
       .


  clear: lt_node_logondata
        ,ls_logondata
        ,lt_node_defaults
        ,ls_defaults
        .

  " Only for Create mode!!
  check: iv_modus = go_persistence->co_ta_modus_create
        .    " Else: ================================> Jump to ENDMETHOD

  " Prepare field list for logondata
  ls_node = if_identity_definition=>gc_field_logondata_ustyp.
  append ls_node to lt_node_logondata.

  " Prepare field list for defaults
  ls_node = if_identity_definition=>gc_field_defaults_datfm.
  append ls_node to lt_node_defaults.
  ls_node = if_identity_definition=>gc_field_defaults_timefm.
  append ls_node to lt_node_defaults.
  ls_node = if_identity_definition=>gc_field_defaults_dcpfm.
  append ls_node to lt_node_defaults.
  ls_node = if_identity_definition=>gc_field_defaults_spda.
  append ls_node to lt_node_defaults.
  ls_node = if_identity_definition=>gc_field_defaults_spdb.
  append ls_node to lt_node_defaults.

  " Before calling the SET methods: Read profile parameters for defaults
  "   Set values for: - Date format (Profile parameter)
  "                   - Number format (Profile parameter)
  "                   - Print parameter 2 SPDA ('K')
  "                   - Print parameter 3 SPDB ('H')

  " First get profile parameters for date,time and number format:
  call function 'SUSR_USER_DEFAULT_DATE_FORMAT'
    importing
      datfm = ls_defaults-datfm.
  call function 'SUSR_USER_DEFAULT_TIME_FORMAT'
    importing
      timefm = ls_defaults-timefm.
  call function 'SUSR_USER_DEFAULT_DEC_NOTATION'
    importing
      dcpfm = ls_defaults-dcpfm.
  ls_defaults-spda = 'K'.     " Keep
  ls_defaults-spdb = 'H'.     " Hold

  " In A1S: Set logon language to system default
  if cl_identity_factory=>check_identity_model( ) eq if_identity=>co_true.
    ls_node = if_identity_definition=>gc_field_defaults_langu.
    append ls_node to lt_node_defaults.

    call 'C_SAPGPARAM'                                    "#EC CI_CCALL
         id 'NAME'  field 'zcsa/system_language'
         id 'VALUE' field ls_defaults-langu.
  endif.


  loop at it_node_root reference into lr_node_root.

    lr_identity ?= lr_node_root->idref.

    " Set default value 'A' for user type
    call method lr_identity->set_logondata
      exporting
        it_change_fields    = lt_node_logondata
        is_logondata        = ls_logondata
        iv_ignore_cua_flags = if_identity=>co_true.
    " Now also the reference user segment is filled with BNAME

    " SET method creates notifications --> Delete these
    call method go_notify->delete_notifications
      exporting
        iv_bname    = lr_node_root->bname
        iv_nodename = if_identity_definition=>gc_node_logondata.

    " Now call SET method
    call method lr_identity->set_defaults
      exporting
        it_change_fields    = lt_node_defaults
        is_defaults         = ls_defaults
        iv_ignore_cua_flags = if_identity=>co_true.
    " Now also the address segment is filled with BNAME

    " SET method creates notifications --> Delete these
    call method go_notify->delete_notifications
      exporting
        iv_bname    = lr_node_root->bname
        iv_nodename = if_identity_definition=>gc_node_defaults.

    " Add default user group - authorization check in do_check()
    if gv_class_is_required eq if_identity=>co_true.
      " Set default
      call method cl_suid_tools=>check_user_grp_required
        importing
          ev_default_class = lr_identity->ms_segment_header-actual-class.
      " Default usergroup in buffer is not checked
      clear: lr_identity->ms_manager-class_checked.
    else.
      " No default usergroup: Usergroup is valid
      lr_identity->ms_manager-class_checked = if_identity=>co_true.
    endif.
  endloop.

endmethod.


method node_authority_check.
**********************************************************************
* 26.02.2008 D050920  Note 1116083
* - Add optional parameter IV_BNAME. It is used
*   by cl_suid_tools=>auth_check_single. Reason: Some messages
*  (f.e. 01/585, 01/586, 01/589, 01/590 uses BNAME as parameters )
*
* (Do not use IV_BNAME to get IV_CLASS like in FM SUSR_BASE_AUTHORITY_CHECK!)
**********************************************************************

  data:   lv_auth_operation       type suid_node_activity.

  " map transaction mode to authority operation mode
  case iv_transaction_mode .
    when go_persistence->co_ta_modus_create.
      lv_auth_operation = cl_suid_tools=>co_activity_create.
    when go_persistence->co_ta_modus_modify.
      lv_auth_operation = cl_suid_tools=>co_activity_update.
    when go_persistence->co_ta_modus_delete.
      lv_auth_operation = cl_suid_tools=>co_activity_delete.
    when go_persistence->co_ta_modus_display.
      lv_auth_operation = cl_suid_tools=>co_activity_retrieve.
    when others.
      lv_auth_operation = cl_suid_tools=>co_activity_retrieve.
  endcase.


  " Call authorization check
  case iv_node_name.
    when
      " password related nodes
        if_identity_definition=>gc_node_cua_password or
        if_identity_definition=>gc_node_password or
        if_identity_definition=>gc_node_pwdhash.

      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_password
          iv_operation = lv_auth_operation
          iv_class     = iv_class
        importing
          es_msg       = es_msg.
      ev_auth_node = if_identity_definition=>gc_node_password.

    when if_identity_definition=>gc_node_snc or
         if_identity_definition=>gc_node_certmap.
      " SNC data
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename         = iv_node_name
          iv_operation        = lv_auth_operation
          iv_class            = iv_class
          iv_initial_as_dummy = if_identity~co_true
        importing
          es_msg              = es_msg.
      ev_auth_node = iv_node_name.

    when if_identity_definition=>gc_node_dbms_user_pwd.

      " Check the same auth for DBMS user password as for ABAP-user password
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_password
          iv_operation = lv_auth_operation
          iv_class     = iv_class
        importing
          es_msg       = es_msg.

      " return message for dbms_user-node
      ev_auth_node = if_identity_definition=>gc_node_dbms_user.

    when
      " authorization related nodes
      if_identity_definition=>gc_node_cua_profile or
      if_identity_definition=>gc_node_cua_role    or
      if_identity_definition=>gc_node_profile     or
      if_identity_definition=>gc_node_role.

      " only check authority when data is retrieved. Dedicated Set methods of
      " above nodes call auth_check_single separately
      if iv_method eq 'G'.
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename         = iv_node_name
            iv_operation        = lv_auth_operation
            iv_class            = iv_class
            iv_bname            = iv_bname
            iv_initial_as_dummy = if_identity=>co_true
          importing
            es_msg              = es_msg.
        ev_auth_node = iv_node_name.
      endif.

    when if_identity_definition=>gc_node_cua_system.
      " only check authority when data is retrieved. Dedicated Set methods of
      " above nodes call auth_check_single separately
      if iv_method eq 'G'.
        if lv_auth_operation eq cl_suid_tools=>co_activity_update.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename         = iv_node_name
              iv_operation        = cl_suid_tools=>co_activity_create
              iv_class            = iv_class
              iv_initial_as_dummy = if_identity=>co_true
            importing
              es_msg              = es_msg.
          if es_msg-msgty eq 'E'.
            clear: es_msg.
            call method cl_suid_tools=>auth_check_single
              exporting
                iv_nodename         = iv_node_name
                iv_operation        = cl_suid_tools=>co_activity_delete
                iv_class            = iv_class
                iv_initial_as_dummy = if_identity=>co_true
              importing
                es_msg              = es_msg.
          endif.
        elseif lv_auth_operation eq cl_suid_tools=>co_activity_retrieve.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename         = iv_node_name
              iv_operation        = cl_suid_tools=>co_activity_update
              iv_class            = iv_class
              iv_initial_as_dummy = if_identity=>co_true
            importing
              es_msg              = es_msg.
        else.
          call method cl_suid_tools=>auth_check_single
            exporting
              iv_nodename         = iv_node_name
              iv_operation        = lv_auth_operation
              iv_class            = iv_class
              iv_initial_as_dummy = if_identity=>co_true
            importing
              es_msg              = es_msg.
        endif.
        ev_auth_node = iv_node_name.
      endif.


    when if_identity_definition=>gc_node_lockdata.
      " Lockdata
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename         = iv_node_name
          iv_operation        = lv_auth_operation
          iv_class            = iv_class
          iv_initial_as_dummy = if_identity~co_true
        importing
          es_msg              = es_msg.
      ev_auth_node = iv_node_name.
    when if_identity_definition=>gc_node_dbms_user_lock.
      " DBMS User Lock: Check the same auth. as for ABAP-user lock
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename         = if_identity_definition=>gc_node_lockdata
          iv_operation        = lv_auth_operation
          iv_class            = iv_class
          iv_initial_as_dummy = if_identity~co_true
        importing
          es_msg              = es_msg.
      " return message for dbms_user-node
      ev_auth_node = if_identity_definition=>gc_node_dbms_user.
    when if_identity_definition=>gc_node_dbms_role.
      " DBMS Roles: Check the same auth. as for PFCG-roles
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename         = if_identity_definition=>gc_node_role
            iv_operation        = lv_auth_operation
            iv_class            = iv_class
            iv_bname            = iv_bname
            iv_initial_as_dummy = if_identity=>co_true
          importing
            es_msg              = es_msg.
        ev_auth_node = iv_node_name.
    when
        " master data (root) related nodes
        if_identity_definition=>gc_node_root or
        if_identity_definition=>gc_node_admindata or
        if_identity_definition=>gc_node_reference_user or

        if_identity_definition=>gc_node_cua_uclass or
        if_identity_definition=>gc_node_defaults or
        if_identity_definition=>gc_node_group or

        if_identity_definition=>gc_node_logondata or
        if_identity_definition=>gc_node_parameter or
        if_identity_definition=>gc_node_snc_equi_name or
        if_identity_definition=>gc_node_uclass or
        if_identity_definition=>gc_node_tech_user or
        if_identity_definition=>gc_node_tech_user_data or
        if_identity_definition=>gc_node_person or
        if_identity_definition=>gc_node_person_name or
        if_identity_definition=>gc_node_organization or
        if_identity_definition=>gc_node_organization_name or
        if_identity_definition=>gc_node_location or
        if_identity_definition=>gc_node_workplace or
        if_identity_definition=>gc_node_telephone or
        if_identity_definition=>gc_node_facsimile or
        if_identity_definition=>gc_node_email or
        if_identity_definition=>gc_node_web or
        if_identity_definition=>gc_node_telex or
        if_identity_definition=>gc_node_teletex or
        if_identity_definition=>gc_node_remote_mail or
        if_identity_definition=>gc_node_x400 or
        if_identity_definition=>gc_node_printer or
        if_identity_definition=>gc_node_ssf or
        if_identity_definition=>gc_node_pager or
        if_identity_definition=>gc_node_dbms_user or
        if_identity_definition=>gc_node_documentation or
*        if_identity_definition=>gc_node_dbms_role or
        space.

      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_root
          iv_operation = lv_auth_operation
          iv_class     = iv_class
        importing
          es_msg       = es_msg.
      ev_auth_node = if_identity_definition=>gc_node_root.

    when others.
      raise exception
        type
        cx_suid_identity
        exporting
          textid   = cx_suid_identity=>internal_error
          ta_modus = iv_transaction_mode.

  endcase.

endmethod.


method password_convert_to_hash.
*--------------------------------------------------------------------*
* Convert password plain text to hash performing appropriate
* password-rules checks
*
* 31.10.2008 Note 1287410
* - New parameter  IV_PRODUCTIVE_PWD to set productive password
*--------------------------------------------------------------------*
  data: lv_password_only_old type char01
       ,lv_password_only_new type char01
       ,lv_pwd_oldstyle      type char01
       ,lv_pwdplain          type suid_st_node_password
       ,ls_msg               type symsg
       ,lv_usr40_check       type c
       ,lv_sec_policy        type usr02-security_policy
       .


* Check compatibility of old password
  call function 'GET_PASSWORD_COMPATIBILITY'
    importing
      only_new_style = lv_password_only_new
      only_old_style = lv_password_only_old.
  if lv_password_only_old is not initial.
****   Password must be max. 8 characters long
***    lv_pwdplain = iv_pwdplain(8).
***    set locale language sy-langu.
***    translate lv_pwdplain to upper case.

*  Truncate of password without. message is misleading, as user will not be able to
*  logon with original password. Therefore we continue here.
*  Later C-Func 'XXPASS' will return us corresponded message.
    lv_pwdplain = iv_pwdplain.

  elseif lv_password_only_new is initial.
    lv_pwdplain = iv_pwdplain.
*   check if password is downwards-compatible
    translate lv_pwdplain to upper case.
    if lv_pwdplain(8) <> iv_pwdplain.
      lv_pwdplain = iv_pwdplain.
*     Display error message only in transactions SU01 and SU10
*        --> Only if set by administrator
      if sy-tcode = 'SU01' or sy-tcode = 'SU10'.
*       The entered password is not downward compatible (see long text)
        if 1 = 0. message w294(00). endif.
        clear ls_msg.
        ls_msg-msgty = if_suid_msg_buffer=>co_type_warning.
        ls_msg-msgid = '00'.
        ls_msg-msgno = '294'.
        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_password
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = ls_msg.
        endif.
    endif.
  else.
    lv_pwdplain = iv_pwdplain.
  endif.

  if   ms_segment_header-actual-ustyp = co_usertype_system
    or ms_segment_header-actual-ustyp = co_usertype_service.

*   Allow old style
    lv_pwd_oldstyle = go_persistence->co_flag_active.
  endif.

* Self Register: Check also against USR40
  if iv_self_register eq if_identity=>co_true.
    lv_usr40_check = 'E'. "failure results in error
  elseif iv_productive_pwd eq if_identity=>co_true.
    lv_usr40_check = 'E'. "failure results in error
  elseif sy-tcode = 'SU01' or sy-tcode = 'SU10'.
*     Display warning message only in transactions SU01 and SU10
*        --> Only if set by administrator
    lv_usr40_check = 'W'.
  else.
    clear: lv_usr40_check.
  endif.

  clear: ls_msg, ev_pwdhash.

* Get security policy
  lv_sec_policy = ms_segment_header-actual-security_policy.

* Encode Password
  call 'XXPASS'
    id 'CODE'          field lv_pwdplain
    id 'OLDSTYLE'      field lv_pwd_oldstyle
    id 'CODX'          field ev_pwdhash-bcode
    id 'PASSCODE'      field ev_pwdhash-passcode
    id 'PWDSALTEDHASH' field ev_pwdhash-pwdsaltedhash
    id 'POLICY'        field lv_sec_policy
    id 'NAME'          field ms_manager-bname
    id 'VERS'          field ev_pwdhash-codvn
    id 'MSGTY'         field ls_msg-msgty
    id 'MESG'          field ls_msg-msgno
    id 'ARBG'          field ls_msg-msgid
    id 'MSGV1'         field ls_msg-msgv1
    id 'MSGV2'         field ls_msg-msgv2
    id 'MSGV3'         field ls_msg-msgv3
    id 'MSGV4'         field ls_msg-msgv4
    id 'USR40_CHECK'   field lv_usr40_check
    .                                                     "#EC CI_CCALL

  if sy-subrc > 0.
    if ls_msg is not initial.
      if ls_msg-msgty is initial.
        ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
      endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_password
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = ls_msg.

      if ls_msg-msgty eq if_suid_msg_buffer=>co_type_error.
        clear: ev_pwdhash.
        return.
      endif.

    endif.
  elseif sy-subrc < 0.
    macro_raise_internal_error.
  endif.

* Fill relevant fields of header segment
  clear ev_pwdhash-pwdlgndate.

* Self Register: Set Password to productive
  if iv_self_register eq if_identity=>co_true.
    ev_pwdhash-pwdinitial = if_identity=>co_pwdinitial_productive.
* IV_PRODUCTIVE_PWD: Set Password to productive
  elseif iv_productive_pwd eq if_identity=>co_true.
    ev_pwdhash-pwdinitial = if_identity=>co_pwdinitial_productive.
  else.
    ev_pwdhash-pwdinitial = if_identity=>co_pwdinitial_initial.
  endif.

endmethod.


method persdata_set_modified.
* Set/delete flag if some operation with personalization was executed,
* which could modify personalization data (user copy, delete, modification
* from SUID01 or BAPIes)

  if iv_modified = if_identity=>co_true.
*   No application calls during upgrade ==> no personalization modifications
    if gv_upg_is_shadow_system is initial.
      ms_manager-flg_pers_modified = go_persistence->co_flag_active.
      ms_manager-status = go_persistence->co_ta_status_unchecked.
    endif.
  else.
    clear: ms_manager-flg_pers_modified.
  endif.


endmethod.


METHOD prepare_audit_segment.
* Set timestamp and prepare any internal segments for the save step
*     -> Collect data for audit log
*     -> User stamp USRSTAMP

  DATA: lr_userstamp   TYPE REF TO usrstamp
       ,ls_userstamp   TYPE        usrstamp
       ,ls_auditline   TYPE suid_st_auditlog
       ,lv_lock_before         TYPE xstring
       ,lv_lock_actual         TYPE xstring
       ,lv_create_audit_entry  TYPE sesf_boolean VALUE if_identity=>co_true
       .

  CONSTANTS:
     co_audit_create(3)        TYPE c VALUE 'AU7'
    ,co_audit_delete(3)        TYPE c VALUE 'AU8'
    ,co_audit_modify(3)        TYPE c VALUE 'AUD'
    ,co_audit_auth_changed(3)  TYPE c VALUE 'AUB'
    ,co_audit_locked(3)        TYPE c VALUE 'AU9'
    ,co_audit_unlocked(3)      TYPE c VALUE 'AUA'
    .

* ---- Fill User Stamp information ------------------------------------*
  READ TABLE ms_segment_userstamp-actual
   with key username = ms_manager-bname
            struct = '*'
            field  = '*'
   BINARY search
   TRANSPORTING no fields.
*   If general entry for Identity modification not yet exists: Add it!
  IF sy-subrc <> 0.
    ls_userstamp-username = ms_manager-bname.
    ls_userstamp-struct   = '*'.
    ls_userstamp-field    = '*'.
    APPEND ls_userstamp TO ms_segment_userstamp-actual.
  ENDIF.

*   For all entries now set date and time!
  LOOP AT ms_segment_userstamp-actual REFERENCE INTO lr_userstamp.
    lr_userstamp->moddate = is_timestamp-datum.
    lr_userstamp->modtime = is_timestamp-uzeit.
    lr_userstamp->modifier = is_timestamp-uname.
  ENDLOOP.

*  describe table ms_segment_userstamp-actual lines lv_lines.
*  if lv_lines <> 0 or ms_manager-modus = go_persistence->co_ta_modus_delete.
  IF ms_segment_userstamp-actual <> ms_segment_userstamp-before_image.
    ms_segment_userstamp-status = go_persistence->co_seg_changed.
  ENDIF.

* ---- Fill Audit Log information -------------------------------------*
  CLEAR ls_auditline.
* Calculate all the information here now
  CLEAR ms_segment_auditlog-actual.

  ms_segment_auditlog-bname = ms_manager-bname.
* Determine audit key according to transaction mode
  ls_auditline-bname = ms_manager-bname.

  CASE ms_manager-modus.
    WHEN go_persistence->co_ta_modus_create.

      ls_auditline-auditkey = co_audit_create.

    WHEN go_persistence->co_ta_modus_modify.

*     check lock/unlock status is changed
      IF ms_segment_header-before_image-uflag NE ms_segment_header-actual-uflag.
*       check if only lock/unlock status is changed
*       if at least one additional node was changed: provide an audit log entry
        lv_create_audit_entry = if_identity=>co_false.
        DO 1 TIMES.
          IF ms_manager-sn_logondata       = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_defaults        = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_snc             = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_password        = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_pwdhash         = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_roles           = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_profiles        = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_parameter       = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_groups          = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_uclass          = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_cua_systems     = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_cua_roles       = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_cua_profiles    = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_cua_uclass      = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_cua_password    = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_refuser         = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_tech_user       = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_tech_user_data  = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_organization    = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_person_name     = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_workplace       = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_person          = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_certmap         = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_dbms_user         = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
          IF ms_manager-sn_dbms_roles         = go_persistence->co_node_status_checked.
            lv_create_audit_entry = if_identity=>co_true.
            EXIT.
          ENDIF.
        ENDDO.

      ENDIF.

*     Provide audit log entry if not only lock status is modified
      IF lv_create_audit_entry = if_identity=>co_true.
        ls_auditline-auditkey = co_audit_modify.
      ENDIF.

    WHEN go_persistence->co_ta_modus_delete.
      ls_auditline-auditkey = co_audit_delete.
  ENDCASE.

  IF ls_auditline-auditkey IS NOT INITIAL.
    APPEND ls_auditline TO ms_segment_auditlog-actual.
  ENDIF.

* ---- Fill audit log entry for Locking/Unlocking ----------------------------*
* Determine audit log entry
  CLEAR ls_auditline-auditkey.
  lv_lock_before = ms_segment_header-before_image-uflag.
  lv_lock_actual = ms_segment_header-actual-uflag.

  IF lv_lock_before NE lv_lock_actual.
*   Check whether Identity was locked with this modification
    IF ( lv_lock_before Z if_identity=>co_locked_by_admin AND
         lv_lock_actual O if_identity=>co_locked_by_admin )
       OR
       ( lv_lock_before Z if_identity=>co_locked_by_wrong_logon AND
         lv_lock_actual O if_identity=>co_locked_by_wrong_logon )
       OR
       ( lv_lock_before Z if_identity=>co_locked_by_global_admin AND
         lv_lock_actual O if_identity=>co_locked_by_global_admin ).
      ls_auditline-auditkey = co_audit_locked.
    ENDIF.

*   Check whether Identity was unlocked with this modification
    IF ( lv_lock_before O if_identity=>co_locked_by_admin AND
         lv_lock_actual Z if_identity=>co_locked_by_admin )
       OR
       ( lv_lock_before O if_identity=>co_locked_by_wrong_logon AND
         lv_lock_actual Z if_identity=>co_locked_by_wrong_logon )
       OR
       ( lv_lock_before O if_identity=>co_locked_by_global_admin AND
         lv_lock_actual Z if_identity=>co_locked_by_global_admin ).
      ls_auditline-auditkey = co_audit_unlocked.
    ENDIF.
  ENDIF.

  IF ls_auditline-auditkey IS NOT INITIAL.
    APPEND ls_auditline TO ms_segment_auditlog-actual.
  ENDIF.

* ---- Fill audit log entry for Authority Changes (UST04) ----------------------------*
*   Determine audit log entry
  IF ms_segment_profiles_t04-actual  <>  ms_segment_profiles_t04-before_image.
    " write audit log entry
    ls_auditline-auditkey = co_audit_auth_changed.
    APPEND ls_auditline TO ms_segment_auditlog-actual.
    CLEAR ls_auditline-auditkey.
  ENDIF.

  IF LINES( ms_segment_auditlog-actual ) <> 0.
    ms_segment_auditlog-status = go_persistence->co_seg_changed.
  ENDIF.

ENDMETHOD.


method prepare_internal_segments.
* Set timestamp and prepare any internal segments for the save step
*     -> Change documents USH02 and USH04
*     -> Collect data for audit log
*     -> User stamp USRSTAMP
*     -> SNC time stamp

  types:
      begin of ltype_header_changes
        ,bcode         type usr02-bcode
        ,passcode      type usr02-passcode
        ,codvn         type usr02-codvn
        ,gltgv         type usr02-gltgv
        ,gltgb         type usr02-gltgb
        ,ustyp         type usr02-ustyp
        ,class         type usr02-class
        ,uflag         type xstring
        ,accnt         type usr02-accnt
        ,pwdinitial    type usr02-pwdinitial
        ,pwdsaltedhash type usr02-pwdsaltedhash
        ,security_policy type usr02-security_policy
     ,end   of ltype_header_changes
     .

  data:
        ls_header_changes_before type        ltype_header_changes
       ,ls_header_changes_actual type        ltype_header_changes
       ,ls_printparam            type        suid_st_printparameters
       ,ls_pwdhistory            type        usrpwdhistory
       ,lv_timezone              type        ttzz-tzone
       ,lv_historydattim         type        timestamp
       ,lr_role                  type ref to agr_users
       ,lr_usrcertmap            type ref to usrcertmap
       .

  clear: ls_header_changes_before
        ,ls_header_changes_actual
        .

* ---- Prepare History Table USH02 ------------------------------------*
* Check whether header changes need to be put to the history:
  move-corresponding ms_segment_header-before_image to ls_header_changes_before.
  move-corresponding ms_segment_header-actual       to ls_header_changes_actual.

* At least one of the relevant fields was changed
  if ls_header_changes_before ne ls_header_changes_actual.
*   Fill segment for header changes
    move-corresponding ms_segment_header-actual to ms_segment_header_hist-actual.
    ms_segment_header_hist-actual-modda = is_timestamp-datum.
    ms_segment_header_hist-actual-modti = is_timestamp-uzeit.
    ms_segment_header_hist-actual-modbe = is_timestamp-uname.
    ms_segment_header_hist-actual-tcode = sy-tcode(4). " ? Maybe take other transaction code
    ms_segment_header_hist-actual-repid = sy-repid.    " ? Maybe take other repid?

    ms_segment_header_hist-bname  = ms_manager-bname.
    ms_segment_header_hist-status = go_persistence->co_seg_changed.
  endif.

* ---- Internal Data for USR02 ----------------------------------------*
* Set creation date and user
  if ms_manager-modus = go_persistence->co_ta_modus_create.
    ms_segment_header-actual-erdat = is_timestamp-datum.
    ms_segment_header-actual-aname = is_timestamp-uname.
  endif.

* fill ANAME and ERDAT of USR02 here

* ---- Timestamps for Password ----------------------------------------*
* Only process if password data was changed successfully
  if ms_manager-sn_password = go_persistence->co_node_status_checked.
*   Fill LTIME for password here: Decide upon PWDINITIAL
    if ms_segment_header-actual-pwdinitial = if_identity=>co_pwdinitial_productive.
      if is_timestamp-uzeit is not initial.
        ms_segment_header-actual-ltime = is_timestamp-uzeit.
      else.  " By chance it is exactly midnight
        ms_segment_header-actual-ltime = '000001'.
      endif.
    else. " For PWDINITIAL = initial: LTIME is empty!
      clear: ms_segment_header-actual-ltime.
    endif.
    ms_segment_header-actual-pwdchgdate = is_timestamp-datum.
    ms_segment_header-actual-pwdsetdate = is_timestamp-datum.
    clear: ms_segment_header-actual-pwdlgndate.
*   For deactivated passwords: PWDINITIAL and LTIME are not modified
  endif.

* ---- Complete Profiles: USR04 ---------------------------------------*
* ---- creation of a user
* ---- deletion of a user
* ---- modification of profiles
*   Check whether profile changed
  cl_identity=>prepare_profile_segments(
  exporting
    is_timestamp     = is_timestamp
    iv_bname         = me->ms_manager-bname
    iv_status        = me->ms_manager-status
    iv_modus         = me->ms_manager-modus
  importing
    es_segment_ush04 = me->ms_segment_profiles_r04_hist
  changing
    cs_segment_usr04 = me->ms_segment_profiles_r04
    cs_segment_ust04 = me->ms_segment_profiles_t04 ).

* ---- Complete Role Assignment: AGR_USERS ----------------------------*
* Role assignment timestamp for AGR_USERS
  if me->ms_segment_roles-status = go_persistence->co_seg_changed.

    loop at me->ms_segment_roles-actual reference into lr_role.
      if lr_role->change_dat is initial.
*       set timestamp of modification date ................................
        lr_role->change_dat = is_timestamp-datum.
      endif.
      if lr_role->change_tim is initial.
*       set timestamp of modification date ................................
        lr_role->change_tim = is_timestamp-uzeit.
      endif.
    endloop.

  endif.

* ---- SNC timestamps -------------------------------------------------*
  if ms_segment_snc-status       eq go_persistence->co_seg_changed and
     ms_segment_snc-actual-bname is not initial.
    if ms_segment_snc-before_image-bname is initial.
*     Create entry
      ms_segment_snc-actual-cname = is_timestamp-uname.
      ms_segment_snc-actual-cdate = is_timestamp-datum.
      ms_segment_snc-actual-ctime = is_timestamp-uzeit.

      clear: ms_segment_snc-actual-mname,
             ms_segment_snc-actual-mdate,
             ms_segment_snc-actual-mtime.
    else.
*     Change entry
      ms_segment_snc-actual-mname = is_timestamp-uname.
      ms_segment_snc-actual-mdate = is_timestamp-datum.
      ms_segment_snc-actual-mtime = is_timestamp-uzeit.

    endif.
  endif.


* ---- CERTMAP timestamps -------------------------------------------------*
  if ms_segment_certmap-status eq go_persistence->co_seg_changed.
    loop at ms_segment_certmap-actual reference into lr_usrcertmap.
      if lr_usrcertmap->created_on is initial.
        lr_usrcertmap->created_on = is_timestamp-timestamp.
        lr_usrcertmap->created_by = is_timestamp-uname.
      endif.
    endloop.
  endif.

* ---- Collect information for update of print parameters -------------*
  if ms_segment_defaults-status       = go_persistence->co_seg_changed and
     ms_segment_defaults-actual-bname is not initial.
    ms_segment_printparam-bname  = ms_manager-bname.

    clear: ls_printparam.
    ls_printparam-mandt = sy-mandt.
    ls_printparam-pdest = ms_segment_defaults-actual-spld.
    if ms_segment_defaults-actual-spda = 'D'.   " Delete
      ls_printparam-prrel = 'X'.
    else.                                       " Keep
      clear ls_printparam-prrel.
    endif.

    if ms_segment_defaults-actual-spdb = 'G'.   " Go
      ls_printparam-primm = 'X'.
    else.                                       " Hold
      clear ls_printparam-primm.
    endif.

    clear ls_printparam-prnew.

*   Only in Create mode: Copy print parameter from source user
    if ms_manager-modus = go_persistence->co_ta_modus_create.
      ls_printparam-printsource = ms_segment_defaults-printsource.
    endif.

    move-corresponding ls_printparam to ms_segment_printparam-actual.
    ms_segment_printparam-status = go_persistence->co_seg_changed.
  endif.

* ---- Decide whether Password History must be converted  -------------*

* UPDATE: No password history conversion to '2' is delivered with AP6
*   Once the new conversion takes place, only move entries with
*   pwdhistory space or '1' to USRPWDHISTORY - all entries with '2'
*   will be treated by kernel only.

* Fill password administrative information: Change date
  if ms_manager-sn_password = go_persistence->co_node_status_checked.
    ms_segment_header-actual-pwdchgdate = is_timestamp-datum.

    clear: ls_pwdhistory.
    ls_pwdhistory-mandt = sy-mandt.
    ls_pwdhistory-bname = ms_manager-bname.

*   Transfer old pwdhistory treatment to newest version
    if  ms_segment_header-actual-pwdhistory is initial. " oldest version
*     Shift old USR02 fields from before image of header segment
      if ms_segment_header-before_image-codv5 is not initial.
        convert date ms_segment_header-before_image-bcda5
                into time stamp lv_historydattim
                time zone lv_timezone " time zone is empty => no shift by time zone
                .
        ls_pwdhistory-timestamp = lv_historydattim.
        ls_pwdhistory-bcode     = ms_segment_header-before_image-ocod5.
        ls_pwdhistory-codvn     = ms_segment_header-before_image-codv5.
*       Passcode is always left empty
        append ls_pwdhistory to ms_segment_pwdhistory-actual.
      endif.
      if ms_segment_header-before_image-codv4 is not initial.
        convert date ms_segment_header-before_image-bcda4
                into time stamp lv_historydattim
                time zone lv_timezone " time zone is empty => no shift by time zone
                .
        if lv_historydattim <= ls_pwdhistory-timestamp.
          lv_historydattim = ls_pwdhistory-timestamp + 1.
        endif.
        ls_pwdhistory-timestamp = lv_historydattim.
        ls_pwdhistory-bcode     = ms_segment_header-before_image-ocod4.
        ls_pwdhistory-codvn     = ms_segment_header-before_image-codv4.
*       Passcode is always left empty
        append ls_pwdhistory to ms_segment_pwdhistory-actual.
      endif.
      if ms_segment_header-before_image-codv3 is not initial.
        convert date ms_segment_header-before_image-bcda3
                into time stamp lv_historydattim
                time zone lv_timezone " time zone is empty => no shift by time zone
                .
        if lv_historydattim <= ls_pwdhistory-timestamp.
          lv_historydattim = ls_pwdhistory-timestamp + 1.
        endif.
        ls_pwdhistory-timestamp = lv_historydattim.
        ls_pwdhistory-bcode     = ms_segment_header-before_image-ocod3.
        ls_pwdhistory-codvn     = ms_segment_header-before_image-codv3.
*       Passcode is always left empty
        append ls_pwdhistory to ms_segment_pwdhistory-actual.
      endif.
      if ms_segment_header-before_image-codv2 is not initial.
        convert date ms_segment_header-before_image-bcda2
                into time stamp lv_historydattim
                time zone lv_timezone " time zone is empty => no shift by time zone
                .
        if lv_historydattim <= ls_pwdhistory-timestamp.
          lv_historydattim = ls_pwdhistory-timestamp + 1.
        endif.
        ls_pwdhistory-timestamp = lv_historydattim.
        ls_pwdhistory-bcode     = ms_segment_header-before_image-ocod2.
        ls_pwdhistory-codvn     = ms_segment_header-before_image-codv2.
*       Passcode is always left empty
        append ls_pwdhistory to ms_segment_pwdhistory-actual.
      endif.
      if ms_segment_header-before_image-codv1 is not initial.
        convert date ms_segment_header-before_image-bcda1
                into time stamp lv_historydattim
                time zone lv_timezone " time zone is empty => no shift by time zone
                .
        if lv_historydattim <= ls_pwdhistory-timestamp.
          lv_historydattim = ls_pwdhistory-timestamp + 1.
        endif.
        ls_pwdhistory-timestamp = lv_historydattim.
        ls_pwdhistory-bcode     = ms_segment_header-before_image-ocod1.
        ls_pwdhistory-codvn     = ms_segment_header-before_image-codv1.
*       Passcode is always left empty
        append ls_pwdhistory to ms_segment_pwdhistory-actual.
      endif.

      ms_segment_header-actual-pwdhistory = '1'.  " Save new value
      ms_segment_pwdhistory-bname  = ms_segment_header-bname.
      ms_segment_pwdhistory-status = go_persistence->co_seg_changed.

    else. " --> it's pwdhistory = '1' in this case!
*     Transfer last active password information to history
      if ms_segment_header-before_image-pwdinitial = if_identity=>co_pwdinitial_productive.
        ls_pwdhistory-timestamp      = is_timestamp-timestamp.
        ls_pwdhistory-bcode          = ms_segment_header-before_image-bcode.
        ls_pwdhistory-codvn          = ms_segment_header-before_image-codvn.
        ls_pwdhistory-passcode       = ms_segment_header-before_image-passcode.
        ls_pwdhistory-pwdsaltedhash  = ms_segment_header-before_image-pwdsaltedhash.
        " Do not append the same password history. Only may happen if we call
        " FINALIZE and PREPARE_INTERNAL_SEGMENTS second time.
        read table ms_segment_pwdhistory-actual
             with key bname         = ms_manager-bname
                      bcode         = ls_pwdhistory-bcode
                      codvn         = ls_pwdhistory-codvn
                      passcode      = ls_pwdhistory-passcode
                      pwdsaltedhash = ls_pwdhistory-pwdsaltedhash
             transporting no fields.
        if sy-subrc <> 0.
          append ls_pwdhistory to ms_segment_pwdhistory-actual.
        endif.
        ms_segment_pwdhistory-bname  = ms_segment_header-bname.
        ms_segment_pwdhistory-status = go_persistence->co_seg_changed.
      endif.
    endif.
  endif.

endmethod.


method prepare_profile_segments.

  data: ls_ush04            type ush04
      , ls_usr04            type usr04
      , lv_num              type i
      , lv_offset           type i
      , lr_ust04            type ref to ust04
      .


  clear: es_segment_ush04.

  " New logic for USR04 and USH04
  "  - creation of a user -> create entry in USR04
  "  - deletion of a user -> delete entry in USR04
  "  - modification of profiles: No storage in USR04 (NRPRO = 0), only in UST04
  "  - Change documents
  "    - No changes in USH04 any more
  "    - User creation/deletion and profile assignment moves to CDPOS

  " Check whether profile changed:
  if cs_segment_ust04-status eq go_persistence->co_seg_changed         or
     iv_modus                eq go_persistence->co_ta_modus_create     or
     iv_modus                eq go_persistence->co_ta_modus_delete.

    " Make sure profiles USR04 is initialized: before_image and actual filled
    if cs_segment_usr04-bname is initial.
      cl_identity=>fetch_usr04(
        exporting
          iv_bname         = iv_bname
          iv_modus         = iv_modus
          iv_status        = iv_status
        importing
          es_segment_usr04 = cs_segment_usr04 ).

      if cs_segment_usr04-bname is initial.
        raise exception type cx_suid_identity
          exporting
            textid    = cx_suid_identity=>internal_error
            bname     = iv_bname
            ta_modus  = iv_modus
            ta_status = iv_status.
      endif.
    endif.

    "   ------  USR04 table ---------------------------------------
    " Make sure that creation of user object is maintained in USR04
    case iv_modus.
      when go_persistence->co_ta_modus_create.
        " start to fill usr04 structure
        clear: ls_usr04.
        ls_usr04-mandt   = sy-mandt.
        ls_usr04-bname   = iv_bname.
        ls_usr04-modda   = is_timestamp-datum.
        ls_usr04-modti   = is_timestamp-uzeit.
        ls_usr04-modbe   = sy-uname ##user_ok.
        ls_usr04-nrpro   = 0. " No profiles any more
        clear: ls_usr04-profs.
        " fill actual image of usr04
        cs_segment_usr04-actual = ls_usr04.
        cs_segment_usr04-status = go_persistence->co_seg_changed.

      when go_persistence->co_ta_modus_modify.
        " Determine change log entry for Authority Changes (USR04)
        " -> Check for last move from USR04 to USH04
        if cs_segment_usr04-before_image-nrpro ne 0 and
           cs_segment_ust04-actual             ne cs_segment_ust04-before_image.

          " start to fill usr04 structure
          clear: ls_usr04.
          ls_usr04-mandt   = sy-mandt.
          ls_usr04-bname   = iv_bname.
          ls_usr04-modda   = is_timestamp-datum.
          ls_usr04-modti   = is_timestamp-uzeit.
          ls_usr04-modbe   = sy-uname ##user_ok.
          ls_usr04-nrpro   = 0. " No profiles any more
          clear: ls_usr04-profs.
          " fill actual image of usr04
          cs_segment_usr04-actual = ls_usr04.
          cs_segment_usr04-status = go_persistence->co_seg_changed.
        endif.
    endcase.

    "   ------  change USH04 table --------------------------------
    "   !! USH04 will no longer be used
    "   Check for last move from USR04 to USH04 (NRPRO ne 0)
    case iv_modus.
      when go_persistence->co_ta_modus_modify.
        " write previous entry of usr04 to history (only if USR04 was changed)
        if cs_segment_usr04-before_image-nrpro ne 0           and
           cs_segment_usr04-before_image       is not initial and
           cs_segment_usr04-status             eq go_persistence->co_seg_changed.

          clear: ls_ush04.
          move-corresponding cs_segment_usr04-before_image to ls_ush04.
          append ls_ush04 to es_segment_ush04-actual.

          es_segment_ush04-bname  = iv_bname.
          es_segment_ush04-status = go_persistence->co_seg_changed.
        endif.

      when go_persistence->co_ta_modus_delete.
        " write previous entry of usr04 to history (only if USR04 was changed)
        if cs_segment_usr04-before_image-nrpro ne 0 and
           cs_segment_usr04-before_image       is not initial.

          clear: ls_ush04.
          move-corresponding cs_segment_usr04-before_image to ls_ush04.
          append ls_ush04 to es_segment_ush04-actual.

          es_segment_ush04-bname  = iv_bname.
          es_segment_ush04-status = go_persistence->co_seg_changed.
        endif.
      when others.
    endcase.
  endif.


endmethod.


METHOD PREPARE_SEGMENTS_POSTFETCH.
*
* Perform Postfetch of dedicated segments for changed identities in gt_control
*

  DATA: lr_bname            TYPE REF TO suid_st_bname
       ,lt_bname_userstamp  TYPE        suid_tt_bname
       ,lt_bname_profiles   TYPE        suid_tt_bname
       ,lr_control          TYPE REF TO ty_control
       ,lt_userstamp        TYPE        suid_tt_usrstamp
       ,lr_userstamp        TYPE REF TO usrstamp
       ,lt_userstamp_fetch  TYPE        suid_tt_usrstamp
       ,lr_usr04            TYPE ref to usr04
       ,lt_usr04            TYPE        suid_tt_usr04
       ,lt_usr04_fetch      TYPE        suid_tt_usr04
       .

* --- Prepare saving ------------------------------------------------
*
* All modified instances must have the status FINALIZED
*
  LOOP AT gt_control REFERENCE INTO lr_control
       WHERE idref->ms_manager-status EQ go_persistence->co_ta_status_finalized AND
             idref->ms_manager-modus  NE go_persistence->co_ta_modus_display.

*   Identity is created, modified or deleted:
    IF lr_control->idref->ms_manager-modus EQ go_persistence->co_ta_modus_create OR
       lr_control->idref->ms_manager-modus EQ go_persistence->co_ta_modus_modify OR
       lr_control->idref->ms_manager-modus EQ go_persistence->co_ta_modus_delete.

*---- Postfetch usrstamp segment ------------------------*
*     Check all users in LT_BNAME: Segment empty?
      IF lr_control->idref->ms_segment_userstamp-bname IS INITIAL.
        APPEND lr_control->idref->ms_manager-bname TO lt_bname_userstamp. " Read data for segment
      ENDIF.

**---- Postfetch profile related segments ------------------------*
*     Check if profiles are changed or user was created or deleted => requires changed
*       entries in USR04 which is used for life cycle of users: 'C' and 'D' flag
      IF lr_control->idref->ms_segment_profiles_t04-status  = go_persistence->co_seg_changed      OR
         lr_control->idref->ms_manager-modus                = go_persistence->co_ta_modus_create  OR
         lr_control->idref->ms_manager-modus                = go_persistence->co_ta_modus_delete.

        IF lr_control->idref->ms_segment_profiles_r04-bname IS INITIAL.
          APPEND lr_control->idref->ms_manager-bname TO lt_bname_profiles. " Read data for segment
        ENDIF.
      ENDIF.

    ENDIF.
  ENDLOOP.

* Segments to be treated in Postfetch:
*  MS_SEGMENT_USERSTAMP
*  MS_SEGMENT_PROFILES_T04

* Fetch data of userstamp
  IF lt_bname_userstamp IS NOT INITIAL.
    CALL METHOD go_persistence->if_suid_persistence_read~read
      EXPORTING
        it_bname    = lt_bname_userstamp
      IMPORTING
        et_usrstamp = lt_userstamp.

*   Distribute data to segment for usrstamp
    LOOP AT lt_bname_userstamp REFERENCE INTO lr_bname.
      READ TABLE gt_control REFERENCE INTO lr_control
         WITH KEY bname = lr_bname->bname
         BINARY SEARCH.
      IF sy-subrc = 0.
        CLEAR: lt_userstamp_fetch.
        LOOP AT lt_userstamp REFERENCE INTO lr_userstamp
          WHERE username = lr_control->bname.
          APPEND lr_userstamp->* TO lt_userstamp_fetch.
        ENDLOOP.
        lr_control->idref->fetch_segment_usrstamp(
          EXPORTING
            it_usrstamp  = lt_userstamp_fetch ).
      ENDIF.
    ENDLOOP.
  ENDIF.

* Fetch data of USR04
  IF lt_bname_profiles IS NOT INITIAL.
    CALL METHOD go_persistence->if_suid_persistence_read~read
      EXPORTING
        it_bname      = lt_bname_profiles
      IMPORTING
        et_prof_usr04 = lt_usr04.

*   Distribute data to segment of usr04
    LOOP AT lt_bname_profiles REFERENCE INTO lr_bname.
      READ TABLE gt_control REFERENCE INTO lr_control
         WITH KEY bname = lr_bname->bname
         BINARY SEARCH.
      IF sy-subrc = 0.
        CLEAR: lt_usr04_fetch.
        LOOP AT lt_usr04 REFERENCE INTO lr_usr04
                         WHERE bname = lr_bname->bname.
          APPEND lr_usr04->* TO lt_usr04_fetch.
        ENDLOOP.
        lr_control->idref->fetch_segment_usr04(
          EXPORTING
            it_usr04  = lt_usr04_fetch ).
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDMETHOD.


method profile_add_adjustment_info.

* this method computes if profiles which are assigned to this instance
* are up-to-date according to the assigned roles

* first get the profiles which should be assigned to this user's instance
* compare with the assigned (generated) profiles
*--------------------------------------------------------------------*

  data: ls_agr_users      type         agr_users
      , lt_agr_users      type         suid_tt_agr_users
      , lt_agr_1016       type         suid_tt_agr_1016
      , lr_agr_1016       type ref to  agr_1016
      , lt_usprof         type         suid_tt_usprof
      , lr_node_role      type ref to  suid_st_node_role_adjustment
      , lv_agr_index      type         sy-tabix
      .


  ev_adjustment_required = if_identity=>co_aligned_master_record. "default is: profiles are in sync

  " initialize adjustment info and use agr_users structure
  loop at ct_node_roles reference into lr_node_role.
    move-corresponding lr_node_role->* to ls_agr_users.
    insert ls_agr_users into table lt_agr_users.
    lr_node_role->adjustment_required = if_identity~co_false.
  endloop.

  call method cl_suid_role_helper=>compute_profiles_from_roles
    exporting
      it_roles    = lt_agr_users
    importing
      et_agr_1016 = lt_agr_1016.

  " lt_agr_1016 contains all profiles which should be assigned to this user

  " get the currently assigned profiles
  call method me->profile_get_generated_profile
    importing
      et_user_profile = lt_usprof.

  sort lt_agr_1016.
  sort lt_usprof.

  " now compare profiles which are assigned as a result of role assignment
  " with actual data of profiles in UST04.

  " for each assigned role provide information
  loop at ct_node_roles reference into lr_node_role.
    " As role can have several generated profiles one BINARY SEARCH READ is not
    " enough. We need to READ table in a DO..ENDDO-cycle.
    do.
      read table lt_agr_1016 reference into lr_agr_1016
          with key agr_name = lr_node_role->agr_name
          binary search.
      if sy-subrc ne 0.
        exit.
      else.
        lv_agr_index = sy-tabix.
        " if role is found: get assigned profile
        " compare if role based assigned profile is assigned to user
        read table lt_usprof
          with key profile = lr_agr_1016->profile
          transporting no fields
          binary search.
        if sy-subrc ne 0.  " adjustment of roles and profiles necessary
          lr_node_role->adjustment_required = if_identity=>co_true.
          " leave inner loop of agr_1016
          ev_adjustment_required = if_identity=>co_compare_master_record.
        else.
          delete lt_usprof index sy-tabix.
        endif.
        delete lt_agr_1016 index lv_agr_index.
      endif.
    enddo.

  endloop.

  if lt_usprof is not initial.
    ev_adjustment_required = if_identity=>co_compare_master_record.
  endif.

endmethod.


method profile_adjust.

*   - complete messages for roles and profiles

  data: ls_user_profile       type          suid_st_usprof
      , lt_user_profile       type          suid_tt_usprof
      , lt_all_user_profile   type          suid_tt_usprof
      , lt_new_user_profile   type          suid_tt_usprof
      , lt_obsolete_profile   type          suid_tt_usprof
      , lt_agr_1016           type          suid_tt_agr_1016
      , lr_agr_1016           type ref to   agr_1016
      , lr_user_profile       type ref to   suid_st_usprof
      , lr_role               type ref to   agr_users
      , lv_prof_torso         type          ust04-profile
      , lmsg_data             type          symsg
      , lv_msg_key_value      type          string
      , lv_failed_role        type          agr_name
      , lr_parent_role        type ref to   agr_agrs
      , ls_agr_users          type          agr_users
      , lv_class              type          xuclass
      .

*--------------------------------------------------------------------
* Algorithm
*   get current status of user's profiles (analyze usr04)
*       use usr04 as master of profiles
*           and write result to ust04
*   compute nominal condition:
*       get entries of agr_1016: role -> profiles
*       check with usr10 if active version exists
*   compare nominal condition and current status:
*       add new profiles
*       delete obsolete entries

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " initialize Profile(UST04)
  me->profile_initialize_ust04(
    importing
      et_user_profile = lt_all_user_profile ).

  " only consider generated profiles in lt_user_profile
  lt_user_profile = lt_all_user_profile.
  delete lt_user_profile where  type  ne if_identity~co_prof_type_generated     " 'G'
                            or  aktps ne if_identity~co_prof_active.            " 'A'

  " compute nominal condition
  call method cl_suid_role_helper=>compute_profiles_from_roles
    exporting
      it_roles    = it_roles
    importing
      et_agr_1016 = lt_agr_1016.

  " compute new and obsolete profiles
  lt_obsolete_profile = lt_user_profile. "initialize obsolete profile with current state

  loop at lt_agr_1016 reference into lr_agr_1016.
    read table lt_user_profile
      with key profile = lr_agr_1016->profile
         binary search
         reference into lr_user_profile.

    if sy-subrc <> 0.  " add profile
      ls_user_profile-profile  = lr_agr_1016->profile.
      ls_user_profile-type     = if_identity~co_prof_type_generated.
      ls_user_profile-aktps    = if_identity~co_prof_active.
      ls_user_profile-agr_name = lr_agr_1016->agr_name.

      insert ls_user_profile into table lt_new_user_profile.

    else. " remove profile entries which are in agr_1016 and in current state
      delete table lt_obsolete_profile from lr_user_profile->*.
    endif.
  endloop.

  " Authority-checks for each new profile
  " add new profiles to lt_user_profile
  loop at lt_new_user_profile reference into lr_user_profile.
    " authority check
    lv_prof_torso = lr_user_profile->profile(10).

    clear lmsg_data.

    if iv_permit eq if_identity=>co_false.
      " do not check permission if system-assignment is deleted
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_profile
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = lv_class
          iv_profile   = lv_prof_torso
          iv_bname     = me->ms_manager-bname
        importing
          es_msg       = lmsg_data.
    endif.

    if lmsg_data-msgty eq 'E'.
      " start error handling
      " error occurred: provide error message that profile cannot be
      " assigned because of associated role or even composite role
      clear: lv_msg_key_value, lv_failed_role.
      "role name is provided in user profile
      read table it_roles
           with key agr_name = lr_user_profile->agr_name
           reference into lr_role.
      " check if this is a single role which is part of a composite role
      if lr_role->col_flag eq cl_identity=>co_marked_role.
        " check if role hierarchy is available
        if it_parent_child_relationship is supplied    and
           it_parent_child_relationship is not initial and
           lines( it_parent_child_relationship ) > 0.
          " read composite role entry
          read table it_parent_child_relationship
            with key child_agr = lr_role->agr_name
            reference into lr_parent_role.
          if sy-subrc eq 0.
            lv_failed_role = lr_parent_role->agr_name.
          endif.
        endif.
      endif.

      if lv_failed_role is initial.
        lv_failed_role = lr_user_profile->agr_name.
      endif.

      concatenate lv_failed_role lr_role->from_dat lr_role->to_dat
             into lv_msg_key_value respecting blanks.

      " Keine Berechtigung zur Profilzuordnung
      if 1 = 0. message w638(01) with lv_prof_torso lv_class. endif. "#EC *

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = me->ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_role
          iv_key      = lv_msg_key_value
          iv_field    = if_identity_definition=>gc_field_role_agr_name
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = lmsg_data.

    else.
      " only add new profile if authority is sufficient
      insert lr_user_profile->* into table lt_user_profile.

      lv_msg_key_value = lr_user_profile->profile.
      call method go_notify->notify_create
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_profile
          iv_key      = lv_msg_key_value.

    endif.
  endloop.

  " Authority-checks for each obsolete profile
  " remove obsolete profiles from lt_user_profile
  loop at lt_obsolete_profile reference into lr_user_profile.

    " check authority of obsolete profiles
    lv_prof_torso = lr_user_profile->profile(10).

    clear lmsg_data.

    if iv_permit = if_identity=>co_false.
      " do not check permission if system-assignment is deleted
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_profile
          iv_operation = cl_suid_tools=>co_activity_delete
          iv_class     = lv_class
          iv_profile   = lv_prof_torso
          iv_bname     = me->ms_manager-bname
        importing
          es_msg       = lmsg_data.
    endif.

    if lmsg_data-msgty = 'E'.
      " error occurred: provide error message that profile cannot be
      " assigned because of associated role or even composite role
      clear: lv_msg_key_value, lv_failed_role.
      "role name is NOT provided in user profile

      call method cl_suid_role_helper=>find_role_of_profile
        exporting
          iv_profile_name    = lr_user_profile->profile
          it_roles           = it_roles
        importing
          ev_associated_role = ls_agr_users.

      " check if this is a single role which is part of a composite role
      if ls_agr_users-col_flag eq cl_identity=>co_marked_role.
        " check if role hierarchy is available
        if it_parent_child_relationship is supplied    and
           it_parent_child_relationship is not initial and
           lines( it_parent_child_relationship ) > 0.
          " read composite role entry
          read table it_parent_child_relationship
            with key child_agr = ls_agr_users-agr_name
            reference into lr_parent_role.
          if sy-subrc = 0.
            lv_failed_role = lr_parent_role->agr_name.
          endif.
        endif.
      endif.

      if lv_failed_role is initial.
        lv_failed_role = ls_agr_users-agr_name.
      endif.

      concatenate lv_failed_role ls_agr_users-from_dat ls_agr_users-to_dat
             into lv_msg_key_value respecting blanks.

      if 1 = 0. message e638(01) with lv_prof_torso lv_class. endif. "#EC *

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = me->ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_role
          iv_key      = lv_msg_key_value
          iv_field    = if_identity_definition=>gc_field_role_agr_name
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
          is_msg      = lmsg_data.
    else.
      " only delete profile if authority is sufficient
      delete table lt_user_profile from lr_user_profile->*.

      " provide notification of deletion
      lv_msg_key_value = lr_user_profile->profile.
      call method go_notify->notify_delete
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_profile
          iv_key      = lv_msg_key_value.
    endif.
  endloop.

  " ADD non generated profiles
  " only consider non-generated profiles in lt_all_user_profile
  delete lt_all_user_profile where  type  eq if_identity~co_prof_type_generated       "'G'
                               and  aktps eq if_identity~co_prof_active.              "'A'.

  loop at lt_all_user_profile reference into lr_user_profile.
    insert lr_user_profile->* into table lt_user_profile.
  endloop.

  " delete duplicates: key is profile
  delete lt_user_profile where profile = space.
  sort lt_user_profile by profile.
  delete adjacent duplicates from lt_user_profile comparing profile.

  et_user_profile = lt_user_profile.

endmethod.


method profile_check_delta_authority.

  data: lr_profile          type ref to   ust04
      , lr_cua_profile      type ref to   usl04
      , ls_msg              type          symsg
      , lv_key              type          string
      , lt_usprof           type          suid_tt_usprof
      , lr_usprof           type ref to   suid_st_usprof
      , lv_prof_torso       type          ust04-profile
      , lv_nodename         type          suid_node_name
      , lv_field            type          suid_node_field
      , lv_overwrite        type          sesf_boolean
      .

  if iv_use_ext_node eq if_identity=>co_true.
    lv_nodename = iv_ext_nodename.
    lv_field    = iv_ext_field.
  else.
    lv_nodename = if_identity_definition=>gc_node_reference_user.
    lv_field    = if_identity_definition=>gc_field_reference_user.
  endif.


  " Profiles must be sorted

  " initialize return value with TRUE
  rv_authorized = 1.

  if iv_ext_lifetime eq if_suid_msg_buffer=>co_lifetime_permanent.
    lv_overwrite = if_identity=>co_true.
  endif.

  " Get profile attributes
  loop at it_old_profiles reference into lr_profile where profile <> space.
    append lr_profile->profile to lt_usprof.
  endloop.
  loop at it_new_profiles reference into lr_profile where profile <> space.
    append lr_profile->profile to lt_usprof.
  endloop.
  sort lt_usprof by profile.
  delete adjacent duplicates from lt_usprof comparing profile.

  call method cl_suid_role_helper=>add_profile_state
    changing
      ct_user_profile = lt_usprof.


  " ---- Authority-checks for removal of old assignment ----
  "
  " Local profiles
  loop at it_old_profiles reference into lr_profile where profile <> space.
    read table it_new_profiles
         with key profile = lr_profile->profile
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " Generated profile -> Check profile torso
      read table lt_usprof reference into lr_usprof
           with key profile = lr_profile->profile
           binary search.

      if lr_usprof->type eq if_identity~co_prof_type_generated.
        lv_prof_torso = lr_profile->profile(10).
      else. "'S'ingle,'C'omposite
        if iv_check_generated_profile eq if_identity=>co_true.
          " Check only generated profiles
          continue.
        endif.
        lv_prof_torso = lr_profile->profile.
      endif.

      " check authority for deletion of profile assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_profile
          iv_operation = cl_suid_tools=>co_activity_delete
          iv_class     = iv_class
          iv_profile   = lv_prof_torso
          iv_bname     = iv_bname
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Benutzergruppe &1 zum Profil &3
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_profile->bname.
        endif.
        if 1 = 0. message e633(01) with iv_class lr_profile->bname lr_profile->profile. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '633'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_profile->bname.
        ls_msg-msgv3 = lr_profile->profile.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.

  " CUA profiles
  loop at it_old_cua_profiles reference into lr_cua_profile.
    read table it_new_cua_profiles
         with key subsystem = lr_cua_profile->subsystem
                  profile   = lr_cua_profile->profile
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " check authority for deletion of profile assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_profile
          iv_operation = cl_suid_tools=>co_activity_delete
          iv_class     = iv_class
          iv_subsystem = lr_cua_profile->subsystem
          iv_profile   = lr_cua_profile->profile
          iv_bname     = iv_bname
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Gruppe &1 zum Profil &3, System &4
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_cua_profile->bname.
        endif.
        if 1 = 0. message e632(01) with iv_class lr_cua_profile->bname lr_cua_profile->profile lr_cua_profile->subsystem. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '632'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_cua_profile->bname.
        ls_msg-msgv3 = lr_cua_profile->profile.
        ls_msg-msgv4 = lr_cua_profile->subsystem.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.


  " ---- Authority-checks for adding new profiles ----
  "
  " Local profiles
  loop at it_new_profiles reference into lr_profile where profile <> space.
    read table it_old_profiles
         with key profile = lr_profile->profile
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " Generated profile -> Check profile torso
      read table lt_usprof reference into lr_usprof
           with key profile = lr_profile->profile
           binary search.

      if lr_usprof->type eq if_identity~co_prof_type_generated.
        lv_prof_torso = lr_profile->profile(10).
      else. "'S'ingle,'C'omposite
        lv_prof_torso = lr_profile->profile.
        if iv_check_generated_profile eq if_identity=>co_true.
          " Check only generated profiles
          continue.
        endif.
      endif.

      " check authority for new profile assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_profile
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_class
          iv_profile   = lv_prof_torso
          iv_bname     = iv_bname
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Benutzergruppe &1 zum Profil &3
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_profile->profile.
        endif.
        if 1 = 0. message e633(01) with iv_class lr_profile->bname lr_profile->profile. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '633'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_profile->bname.
        ls_msg-msgv3 = lr_profile->profile.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.

  " CUA profiles
  loop at it_new_cua_profiles reference into lr_cua_profile.
    read table it_old_cua_profiles
         with key subsystem = lr_cua_profile->subsystem
                  profile   = lr_cua_profile->profile
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " check authority for new profile assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_profile
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_class
          iv_subsystem = lr_cua_profile->subsystem
          iv_profile   = lr_cua_profile->profile
          iv_bname     = iv_bname
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Gruppe &1 zum Profil &3, System &4
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_cua_profile->bname.
        endif.
        if 1 = 0. message e632(01) with iv_class lr_cua_profile->bname lr_cua_profile->profile lr_cua_profile->subsystem. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '632'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_cua_profile->bname.
        ls_msg-msgv3 = lr_cua_profile->profile.
        ls_msg-msgv4 = lr_cua_profile->subsystem.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.

endmethod.


method profile_cua_add_adjust_info.

  " assumption: CUA is active
  " this method computes if profiles which are assigned to this instance
  " are up-to-date according to the assigned roles

  data: lv_cua_active           type        char01
      , lv_system_logsys        type        t000-logsys
      , lv_host_name            type        logsys
      , lt_roles                type        suid_tt_node_roles
      , lr_roles                type ref to suid_st_node_role
      , lr_node_cua_adjust      type ref to suid_st_node_cua_role_adjust
      , lt_role_adjustments     type        suid_tt_node_role_adjustments
      , ls_role_adjustment      type        suid_st_node_role_adjustment
      , lr_role_adjustment      type ref to suid_st_node_role_adjustment
      .

  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_cua_active    = lv_cua_active
      ev_system_logsys = lv_system_logsys.

  if lv_cua_active eq if_identity=>co_true.
    lv_host_name = lv_system_logsys.
  else.
    " return to caller: if cua is not active stop running
    return.
  endif.

  " Read roles
  call method me->get_roles
    importing
      et_roles = lt_roles.

  loop at lt_roles reference into lr_roles.
    clear ls_role_adjustment.
    ls_role_adjustment-agr_name  = lr_roles->agr_name.
    ls_role_adjustment-from_dat  = lr_roles->from_dat.
    ls_role_adjustment-to_dat    = lr_roles->to_dat.
    insert ls_role_adjustment into table lt_role_adjustments.
  endloop.

  " fetch additional role information: profile adjustment infos
  call method me->profile_add_adjustment_info
    importing
      ev_adjustment_required = ev_adjustment_required
    changing
      ct_node_roles          = lt_role_adjustments.


  " write status of local roles into ct_node_roles
  " for each assigned role provide information
  loop at ct_node_roles reference into lr_node_cua_adjust
       where subsystem = lv_host_name.
    " if role is found: get status
    read table lt_role_adjustments
      reference into lr_role_adjustment
      with key agr_name   = lr_node_cua_adjust->agr_name
               from_dat   = lr_node_cua_adjust->from_dat
               to_dat     = lr_node_cua_adjust->to_dat.

    if sy-subrc eq 0.
      lr_node_cua_adjust->adjustment_required = lr_role_adjustment->adjustment_required.
    endif.

  endloop.

endmethod.


method profile_cua_delete_user_system.
*   - complete messages for roles and profiles
**********************************************************************
* 26.02.2008 D050920  Note 1116083
* - Call PROFILE_SET with IV_PERMIT = 'X'
**********************************************************************

  data: lt_node_profiles    type          suid_tt_node_cua_profiles
      , lr_node_profile     type ref to   suid_st_node_cua_profile
      , lv_tabix            like          sy-tabix
      , lv_valid            type          sesf_boolean
      , lt_local_profiles   type          suid_tt_node_profiles
      , lr_local_profile    type ref to   suid_st_node_profile
      .

  clear ev_profiles_deleted.

  eo_msg_buffer = go_msg_buffer.

* default return value
  ev_profiles_deleted = if_identity=>co_true.

  call method roles_validate_cua_context
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = iv_node_name
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_valid.

  if lv_valid eq if_identity=>co_false.
    return.
  endif.

  if iv_node_name eq if_identity_definition=>gc_node_profile.
    " get assigned profiles of this user
    me->get_profiles( importing et_profiles = lt_local_profiles ).

    " mark local profiles for deletion
    loop at lt_local_profiles reference into lr_local_profile.
      lr_local_profile->change_mode = if_identity=>co_delete.
    endloop.

    " delete local roles
    call method me->profile_set
      exporting
        iv_permit   = if_identity=>co_true
      changing
        ct_profiles = lt_local_profiles.

  elseif iv_node_name eq if_identity_definition=>gc_node_cua_profile.
    " get assigned profiles of this user
    call method me->get_cua_profiles
      importing
        et_profiles = lt_node_profiles.

    loop at lt_node_profiles reference into lr_node_profile.
      lv_tabix = sy-tabix.
      if lr_node_profile->subsystem ne iv_system.
        delete lt_node_profiles index lv_tabix.
      else.
        lr_node_profile->change_mode = if_identity=>co_delete.
      endif.

    endloop.

    if ev_profiles_deleted eq if_identity=>co_true.
      " do not check authority to delete profiles
      call method me->profile_cua_set_internal
        exporting
          it_profiles = lt_node_profiles
          iv_permit   = if_identity=>co_true.
    endif.
  endif.

endmethod.


METHOD profile_cua_get_changed_system.

  DATA: ls_changed_system     TYPE suid_st_node_cua_system.
  DATA: lt_changed_systems    TYPE suid_tt_node_cua_systems.

  DATA: lt_usl04_insert	      TYPE suid_tt_usl04.
  DATA: lt_usl04_delete	      TYPE suid_tt_usl04.
  DATA: lr_usl04              TYPE REF TO usl04.
  DATA: lv_valid              TYPE sesf_boolean.

  eo_msg_buffer = go_msg_buffer.

  roles_validate_cua_context(
    EXPORTING
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_profile
    IMPORTING
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_valid ).

  IF lv_valid EQ if_identity=>co_false.
    RETURN.
  ENDIF.

* CUA profile assignment: update USL04
  IF me->ms_segment_cua_profiles-status   EQ go_persistence->co_seg_changed.
    IF ms_segment_cua_profiles-bname IS NOT INITIAL.
*     Evaluate db changes
      IF ms_segment_cua_profiles-before_image NE ms_segment_cua_profiles-actual.
*       Segment has changed
        IF ms_segment_cua_profiles-actual IS NOT INITIAL AND
           ms_segment_cua_profiles-before_image IS NOT INITIAL.

          CALL METHOD cl_suid_tools=>compare_tables_with_key
            EXPORTING
              it_new = ms_segment_cua_profiles-actual
              it_old = ms_segment_cua_profiles-before_image
            CHANGING
              it_del = lt_usl04_delete
              it_ins = lt_usl04_insert.

        ELSEIF ms_segment_cua_profiles-actual IS NOT INITIAL.
*       Create db entry
          APPEND LINES OF ms_segment_cua_profiles-actual TO lt_usl04_insert.
        ELSEIF ms_segment_cua_profiles-before_image IS NOT INITIAL.
*       Delete db entry
          APPEND LINES OF ms_segment_cua_profiles-before_image TO lt_usl04_delete.
        ENDIF.

      ENDIF.
    ENDIF.
  ENDIF.

  IF lt_usl04_delete IS NOT INITIAL.
    LOOP AT lt_usl04_delete REFERENCE INTO lr_usl04.
      ls_changed_system-subsystem   = lr_usl04->subsystem.
      ls_changed_system-change_mode = if_identity=>co_delete.
      INSERT ls_changed_system INTO TABLE lt_changed_systems.
    ENDLOOP.
  ENDIF.

  IF lt_usl04_insert IS NOT INITIAL.
    LOOP AT lt_usl04_insert REFERENCE INTO lr_usl04.
      ls_changed_system-subsystem   = lr_usl04->subsystem.
      ls_changed_system-change_mode = if_identity=>co_insert.
      INSERT ls_changed_system INTO TABLE lt_changed_systems.
    ENDLOOP.
  ENDIF.

  SORT lt_changed_systems BY subsystem.
  DELETE ADJACENT DUPLICATES FROM lt_changed_systems.

  et_changed_systems = lt_changed_systems.

ENDMETHOD.


method profile_cua_get_for_syst_distr.
*
* No authority check during distribution
*
  data: lt_cua_profs         type           suid_tt_node_cua_profiles
      , lr_cua_prof          type ref to    suid_st_node_cua_profile
      , lt_bapiprof          type table of  bapiprof
      , lr_bapiprof          type ref to    bapiprof
      , lr_node_filter       type ref to    suid_st_cua_filters
      .


  clear: et_cua_system_profiles.

* --- Check CUA landscape ----------------------------------
*
* CUA is not active or we method is called not in central system - exit
  if gv_cua_active = if_identity=>co_false or gv_cua_central = if_identity=>co_false.
    return.
  endif.

* Check that global CUA role assignments is allowed
  create data: lr_node_filter.
  lr_node_filter->node_name = if_identity_definition=>gc_node_cua_profile.
* Get CUA distribution filter for field
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = lr_node_filter->*.

  if lr_node_filter->field_attr <> if_suid_cua_runtime=>gc_global.
    return.
  endif.


* --- Get system role assignments --------------------------
*
* Get all CUA roles and their details
  call method me->get_cua_profiles
    importing
      et_profiles = lt_cua_profs.

  read table lt_cua_profs
       with key subsystem = iv_subsystem
       transporting no fields
       binary search.
  if sy-subrc = 0.
    loop at lt_cua_profs reference into lr_cua_prof from sy-tabix.
      if lr_cua_prof->subsystem <> iv_subsystem.
        exit.
      endif.

      append initial line to lt_bapiprof reference into lr_bapiprof.
      lr_bapiprof->bapiprof    = lr_cua_prof->profile.
      lr_bapiprof->bapiptext   = lr_cua_prof->ptext.
      lr_bapiprof->bapitype    = lr_cua_prof->type.
    endloop.
  endif.

  sort lt_bapiprof.
  delete adjacent duplicates from lt_bapiprof comparing all fields.

  et_cua_system_profiles = lt_bapiprof.


endmethod.


method profile_cua_merge_to_result.

  data: lv_msg_key_value    type          string
      , ls_msg              type          symsg
      , lt_usl04            type          suid_tt_usl04
      , lr_node_profile     type ref to   suid_st_node_cua_profile
      , ls_usl04            type          usl04
      , lv_tabix            type          sy-tabix
      , lt_new_systems      type          suid_tt_node_cua_systems
      , lt_assigned_systems	type          suid_tt_node_cua_systems
      , ls_assigned_system  type          suid_st_node_cua_system
      , lt_error_systems    type          tt_error_systems
      .


  " get cua_systems without checking authority
  me->get_cua_systems(
    exporting
      iv_get_text    = if_identity=>co_false
    importing
      et_cua_systems = lt_assigned_systems ).

  sort lt_assigned_systems by subsystem.


  " -- Get new systems which must be assigned
  loop at ct_update_profile_node reference into lr_node_profile
      where change_mode eq if_identity=>co_insert.

    read table lt_assigned_systems
      with key subsystem = lr_node_profile->subsystem
      binary search
      transporting no fields.

    if sy-subrc ne 0.
      clear ls_assigned_system.
      ls_assigned_system-subsystem   = lr_node_profile->subsystem.
      ls_assigned_system-change_mode = if_identity=>co_insert.
      insert ls_assigned_system into table lt_new_systems.
    endif.
  endloop.

  " -- Add new systems
  if lt_new_systems is not initial.
    sort lt_new_systems.
    delete adjacent duplicates from lt_new_systems comparing subsystem.
    call method me->cua_set_syst_assignment
      importing
        et_error_systems  = lt_error_systems
      changing
        ct_assign_systems = lt_new_systems.

    " Evaluate errors
    sort lt_error_systems.
    loop at ct_update_profile_node reference into lr_node_profile
        where change_mode eq if_identity=>co_insert.

      read table lt_error_systems transporting no fields
           with key subsystem = lr_node_profile->subsystem
           binary search.
      if sy-subrc eq 0. "Only authorization error can occur

        " Keine Berechtigung zur Zuordnung des Systems &1 (Profil &2)
        if 1 = 0. message e573(01) with space space. endif. "#EC *
        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '573'.
        ls_msg-msgv1 = lr_node_profile->subsystem.
        ls_msg-msgv2 = lr_node_profile->profile.

        concatenate lr_node_profile->subsystem lr_node_profile->profile
               into lv_msg_key_value respecting blanks.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_key_handle = lr_node_profile->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_profile_profile
            is_msg        = ls_msg.

        call method me->go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_profile
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_profile->key_handle.

        " Keep line: Insert failed
        lr_node_profile->change_mode = if_identity=>co_failed_create.
      endif.
    endloop.
  endif.


  " Read current entries
  lt_usl04 = me->ms_segment_cua_profiles-actual.

  " -- Delete entries
  loop at ct_update_profile_node reference into lr_node_profile
    where change_mode eq if_identity=>co_delete.

    read table lt_usl04
      with key subsystem = lr_node_profile->subsystem
               profile   = lr_node_profile->profile
               bname     = ms_manager-bname
      transporting no fields.

    lv_tabix = sy-tabix.

    if sy-subrc eq 0.
      " Remove old profile: authority is done before
      clear: lv_msg_key_value.
      concatenate lr_node_profile->subsystem lr_node_profile->profile
        into lv_msg_key_value respecting blanks.

      call method me->go_notify->notify_delete
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle.

      delete lt_usl04 index lv_tabix.
    endif.
  endloop.


  " -- Insert new entries
  loop at ct_update_profile_node reference into lr_node_profile
    where change_mode eq if_identity=>co_insert.

    read table lt_usl04
      with key
        subsystem = lr_node_profile->subsystem
        profile   = lr_node_profile->profile
        bname     = ms_manager-bname
      transporting no fields.

    if sy-subrc ne 0.
      " Insert entry
      clear: lv_msg_key_value.
      concatenate lr_node_profile->subsystem lr_node_profile->profile
        into lv_msg_key_value respecting blanks.

      " Insert entry
      clear ls_usl04.
      ls_usl04-mandt     = sy-mandt.                   "set mandt
      ls_usl04-subsystem = lr_node_profile->subsystem. "set system name
      ls_usl04-profile   = lr_node_profile->profile.   "set profile
      ls_usl04-bname     = ms_manager-bname.           "set bname

      insert ls_usl04 into table lt_usl04.

      call method me->go_notify->notify_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle.

    else.
      " MSG: Das Profil &1 für das Zielssystem &2 ist bereits zugeordnet
      if 1 = 0. message e063(suid01) with lr_node_profile->profile lr_node_profile->subsystem. endif. "#EC *
      clear: ls_msg, lv_msg_key_value.
      ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
      ls_msg-msgid = 'SUID01'.
      ls_msg-msgno = '063'.
      ls_msg-msgv1 = lr_node_profile->profile.
      ls_msg-msgv2 = lr_node_profile->subsystem.

      concatenate lr_node_profile->subsystem lr_node_profile->profile
        into lv_msg_key_value respecting blanks.

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_profile_profile
          is_msg        = ls_msg
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      " send insert failed notification
      call method me->go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_profile->key_handle.

      " Keep line: Insert failed
      lr_node_profile->change_mode = if_identity=>co_failed_create.
    endif.
  endloop.

  sort lt_usl04 by subsystem profile.

  et_usl04 = lt_usl04.

endmethod.


method profile_cua_set.

  data: lr_node_cua_profile      type ref to   suid_st_node_cua_profile
      , lt_actual_result         type          suid_tt_usl04
      , lv_error                 type          sesf_boolean
      , lv_msg_data              type          symsg
      , lv_class                 type          xuclass
      , lv_tabix                 type          sy-tabix
      .

  clear: et_node_cua_profiles.

  " initialize Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " Initial check
  if iv_permit = if_identity=>co_false.
    call method checks_before_access
      exporting
        iv_method      = 'S'
        iv_change_node = if_identity_definition=>gc_node_cua_profile
      importing
        es_msg         = lv_msg_data.

    if lv_msg_data-msgty = 'E'.
      " Return to caller if not authorized
      return.
    endif.
  endif.

  " Delete all notification belonging to this node type
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_profile.

  " Delete all message belonging to this node type
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_profile.

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " check buffer
  if ms_segment_cua_profiles-bname is initial.
    call method fetch_segment_cua_profiles.
    if ms_segment_cua_profiles-bname is initial.
      raise exception
        type
        cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error
          bname  = ms_manager-bname.
    endif.
  endif.

  " validate input
  call method cl_identity=>check_cua_profiles_internal
    exporting
      io_msg_buffer = go_msg_buffer
      iv_bname      = ms_manager-bname
      iv_class      = lv_class
      io_notify     = go_notify
      iv_permit     = iv_permit
    changing
      ct_profiles   = ct_profiles.

  " remember Importing table: key_handle and AKTPS, TYPE
  loop at ct_profiles reference into lr_node_cua_profile.
    lv_tabix = sy-tabix.
    if lr_node_cua_profile->change_mode is initial or
       lr_node_cua_profile->change_mode eq if_identity=>co_failed_create.
      append lr_node_cua_profile->* to et_node_cua_profiles.
      delete ct_profiles index lv_tabix.
    endif.
  endloop.

  if ct_profiles is not initial.
    " sort internal table
    sort ct_profiles by subsystem profile change_mode.

    " --- merge into result
    call method me->profile_cua_merge_to_result
      importing
        et_usl04               = lt_actual_result
      changing
        ct_update_profile_node = ct_profiles.

    " remember Importing table: key_handle
    append lines of ct_profiles to et_node_cua_profiles.

    " -- write new profiles into segments
    me->ms_segment_cua_profiles-actual = lt_actual_result.

    " --- Transaction handling
    " only set transaction status if there have been changes
    if me->ms_segment_cua_profiles-actual ne me->ms_segment_cua_profiles-before_image.

      " New transaction status: UNCHECKED
      me->ms_manager-status = go_persistence->co_ta_status_unchecked.

      " Check status:
      call method go_msg_buffer->find_error_for_node
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_cua_profile
        receiving
          ev_error    = lv_error.
      if lv_error eq if_identity=>co_false.
        " New node status: CHECKED
        ms_manager-sn_cua_profiles = go_persistence->co_node_status_checked.
      else.
        " New node status: CHANGED
        ms_manager-sn_cua_profiles = go_persistence->co_node_status_changed.
      endif.
      " Set segment change flag for DB
      me->ms_segment_cua_profiles-status = go_persistence->co_seg_changed.
    else.
      " in case actual and before_image are identical: set segment
      " status to unchanged.
      clear: ms_segment_cua_profiles-status, ms_manager-sn_cua_profiles.
    endif.
  endif.


endmethod.


method profile_cua_set_internal.

  data: lt_profiles               type          suid_tt_node_cua_profiles
      , lv_host_name              type          uszbvlndsc-sendsystem
      , lt_usl04                  type          suid_tt_usl04
      , lr_usl04                  type ref to   usl04
      , lt_ust04_profile          type          suid_tt_usprof
      , lr_ust04_profile          type ref to   suid_st_usprof
      , ls_ust04_profile          type          suid_st_usprof
      , lv_tabix                  type          sy-tabix
      .

  " initialize exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  lt_profiles = it_profiles.

  call method me->profile_cua_set
    exporting
      iv_permit            = iv_permit
    importing
      eo_msg_buffer        = eo_msg_buffer
      eo_notify            = eo_notify
      et_node_cua_profiles = et_node_cua_profiles
    changing
      ct_profiles          = lt_profiles.


  " --- Sync local profile tables
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys = lv_host_name.

  " Get global assigned profiles for central system
  lt_usl04 = me->ms_segment_cua_profiles-actual.

  " Get local assigned profiles
  call method me->profile_initialize_ust04
    exporting
      iv_get_profile_text = if_identity=>co_false
    importing
      et_user_profile     = lt_ust04_profile.


  " Determine profiles to be deleted
  loop at lt_ust04_profile reference into lr_ust04_profile
    where type  ne if_identity~co_prof_type_generated     " 'G'
       or aktps ne if_identity~co_prof_active.            " 'A'

    lv_tabix = sy-tabix.

    read table lt_usl04
         with key subsystem    = lv_host_name
                  profile      = lr_ust04_profile->profile
         transporting no fields.
    if sy-subrc ne 0.
      delete lt_ust04_profile index lv_tabix.
    endif.
  endloop.

  " Determine profiles to be added
  loop at lt_usl04 reference into lr_usl04
    where subsystem eq lv_host_name.

    read table lt_ust04_profile
         with key profile = lr_usl04->profile
         transporting no fields.
    if sy-subrc ne 0.
      ls_ust04_profile-profile = lr_usl04->profile.
      insert ls_ust04_profile into table lt_ust04_profile.
    endif.
  endloop.

  " --- write new profiles into segments (without checks and notifications)
  sort lt_ust04_profile by profile.
  call method me->profile_write_to_segment
    exporting
      it_user_profile = lt_ust04_profile.


* Transaction SCUG: mark in internal CUA segment that we transferred profiles from child system
  if gs_cua_user_transfer-active = if_identity=>co_true.
    ms_segment_cua_act_distr-actual-profilesection = if_suid_cua_runtime=>gc_transferred.
  endif.

endmethod.


method profile_get_generated_profile.

  data: lt_user_profile       type suid_tt_usprof.

  " initializes Profiles structure with UST04
  call method me->profile_initialize_ust04
    exporting
      iv_get_profile_text = if_identity=>co_false
    importing
      et_user_profile     = lt_user_profile.

  delete lt_user_profile where type  ne if_identity~co_prof_type_generated
                            or aktps ne if_identity~co_prof_active.

  et_user_profile = lt_user_profile.

endmethod.


method profile_initialize_ust04.
* instance method
* initializes Profiles structure with UST04

  data: lr_ust04              type ref to   ust04
      , ls_user_profile       type          suid_st_usprof
      , lt_user_profile       type          suid_tt_usprof
      , lr_profile_segment    type ref to   suid_tt_ust04
      .


  " Read UST04 Profile
  if me->ms_segment_profiles_t04-bname is initial.
    call method me->fetch_segment_profiles_t04.
    if ms_segment_profiles_t04-bname is initial.
      raise exception type cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error.
    endif.
  endif.


  if iv_request_before_image is initial.
    get reference of ms_segment_profiles_t04-actual into lr_profile_segment.
  else.
    get reference of ms_segment_profiles_t04-before_image into lr_profile_segment.
  endif.


  if lr_profile_segment->* is not initial.

    loop at lr_profile_segment->* reference into lr_ust04.
      ls_user_profile-profile = lr_ust04->profile.
      insert ls_user_profile into table lt_user_profile.
    endloop.

    call method cl_suid_role_helper=>add_profile_state
      exporting
        iv_get_profile_text = iv_get_profile_text
      changing
        ct_user_profile     = lt_user_profile.

    sort lt_user_profile.

  endif.

  et_user_profile = lt_user_profile.

endmethod.


method profile_merge_to_result.

* PROFILE_MERGE_TO_RESULT implements following functionality:
*   - update profiles structure
*   - All checks are done before

  data: lr_usprof             type ref to   suid_st_node_profile
      , lt_user_profile       type          suid_tt_usprof
      , ls_user_profile       type          suid_st_usprof
      , lv_msg_key_value      type          string
      , ls_msg_data           type          symsg
      .


  " update profiles
  call method me->profile_initialize_ust04
    importing
      et_user_profile = lt_user_profile.

  " Delete profiles
  loop at ct_profiles reference into lr_usprof
    where change_mode eq if_identity=>co_delete.

    delete lt_user_profile where profile = lr_usprof->profile.
    if sy-subrc eq 0.
      lv_msg_key_value = lr_usprof->profile.
      call method io_notify->notify_delete
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_usprof->key_handle.
    endif.
  endloop.

  " Insert profiles
  loop at ct_profiles reference into lr_usprof
    where change_mode eq if_identity=>co_insert.

    move-corresponding lr_usprof->* to ls_user_profile.

    read table lt_user_profile
         with key profile   = lr_usprof->profile
         transporting no fields.
    if sy-subrc eq 0.
      " entry already exists
      lv_msg_key_value = lr_usprof->profile.

      " MSG: Das Profil &1 ist bereits zugeordnet
      if 1 = 0. message e062(suid01) with lr_usprof->profile. endif. "#EC *
      clear: ls_msg_data.
      ls_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
      ls_msg_data-msgid = 'SUID01'.
      ls_msg_data-msgno = '062'.
      ls_msg_data-msgv1 = lr_usprof->profile.

      call method io_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_usprof->key_handle
          iv_field      = if_identity_definition=>gc_field_profile_profile
          is_msg        = ls_msg_data
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once.

      call method io_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_usprof->key_handle.

      " Keep line: Insert failed
      lr_usprof->change_mode = if_identity=>co_failed_create.
    else.
      insert ls_user_profile into table lt_user_profile.
      lv_msg_key_value = lr_usprof->profile.
      call method io_notify->notify_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_profile
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_usprof->key_handle.
    endif.
  endloop.

  sort lt_user_profile.
  et_user_profile = lt_user_profile.

endmethod.


method profile_set.

  data: lt_user_profile         type          suid_tt_usprof
      , lr_profile              type ref to   suid_st_node_profile
      , lv_msg_data             type          symsg
      , lv_class                type          xuclass
      , lv_tabix                type          sy-tabix
      .

  clear: et_node_profiles.

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " Initial check
  if iv_permit = if_identity=>co_false.
    call method checks_before_access
      exporting
        iv_method      = 'S'
        iv_change_node = if_identity_definition=>gc_node_profile
      importing
        es_msg         = lv_msg_data.

    if lv_msg_data-msgty = 'E'.
      " Return to caller if not authorized
      return.
    endif.
  endif.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_profile.

  " Delete all message belonging to this node type
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_profile.

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " check buffer
  if ms_segment_profiles_t04-bname is initial.
    call method fetch_segment_profiles_t04.
  endif.

  " validate input
  call method cl_identity=>check_profiles_internal
    exporting
      io_msg_buffer               = go_msg_buffer
      iv_bname                    = ms_manager-bname
      iv_class                    = lv_class
      io_notify                   = go_notify
      iv_allow_generated_profiles = iv_allow_generated_profiles
      iv_permit                   = iv_permit
    changing
      ct_profiles                 = ct_profiles.

  " remember Importing table: key_handle and AKTPS, TYPE
  loop at ct_profiles reference into lr_profile.
    lv_tabix = sy-tabix.
    if lr_profile->change_mode is initial or
       lr_profile->change_mode eq if_identity=>co_failed_create.
      append lr_profile->* to et_node_profiles.
      delete ct_profiles index lv_tabix.
    endif.
  endloop.

  " Adjust internal buffer
  call method me->profile_merge_to_result
    exporting
      io_msg_buffer   = go_msg_buffer
      io_notify       = go_notify
    importing
      et_user_profile = lt_user_profile
    changing
      ct_profiles     = ct_profiles.

  " Exporting: Import table + Key Handle
  append lines of ct_profiles to et_node_profiles.

  " --- write new profiles into segments
  call method me->profile_write_to_segment
    exporting
      it_user_profile = lt_user_profile.

endmethod.


method profile_write_to_segment.

  data: lr_usprof                 type ref to   suid_st_usprof
      , ls_ust04                  type          ust04
      , ls_msg_data               type          symsg
      , lv_num                    type          i
      , lv_error                  type          sesf_boolean
      , lt_before_update_profile  type          suid_tt_usprof
      .


  call method me->profile_initialize_ust04
    importing
      et_user_profile = lt_before_update_profile.

  " !!! No limit for number of assigned profiles any more !!!

  if lt_before_update_profile ne it_user_profile.
    " ---  initialize UST04 table
    clear me->ms_segment_profiles_t04-actual.

    loop at it_user_profile reference into lr_usprof.
      " -- change UST04 table
      " set mandt otherwise comparison of actual and before_image will differ
      ls_ust04-mandt    = sy-mandt.
      ls_ust04-bname    = me->ms_manager-bname.
      ls_ust04-profile  = lr_usprof->profile.
      insert ls_ust04 into table me->ms_segment_profiles_t04-actual.
    endloop.
  endif.


* --- Transaction handling --------------------------------------------
* only set transaction status if there are any changes in the
* master profile

  " handling of UST04: only filled when profiles are changed
  if me->ms_segment_profiles_t04-actual ne me->ms_segment_profiles_t04-before_image.

    " New transaction status: UNCHECKED
    ms_manager-status      = go_persistence->co_ta_status_unchecked.

    call method go_msg_buffer->find_error_for_node
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_profile
      receiving
        ev_error    = lv_error.

    " Profiles node status: CHANGED or CHECKED
    if lv_error eq if_identity=>co_false.
      " New node status: CHECKED
      me->ms_manager-sn_profiles = go_persistence->co_node_status_checked.
    else.
      " New node status: CHANGED
      me->ms_manager-sn_profiles = go_persistence->co_node_status_changed.
    endif.

    me->ms_segment_profiles_t04-status  =  go_persistence->co_seg_changed.

    sort me->ms_segment_profiles_t04-actual.

  else.
    " in case actual and before_image are identical: set segment
    " status to unchanged.
    clear: ms_segment_profiles_t04-status, ms_manager-sn_profiles.

  endif.

  clear et_ust04.
  et_ust04 = me->ms_segment_profiles_t04-actual.

endmethod.


method refresh.
*
* Clear all segments (ID, actual and before image, status)
* Don't modify transaction mode! (Create/Modify/Update/Delete)

  data: lo_addr_main             type ref to cl_addr_main
      , lt_addr_id               type        addrt_address_id
      , lt_bname                 type        susr_t_ususers.
      .


* Header segment must be filled always --> Keep data from before image

* BAS
  if ms_segment_address-actadd-bas_wp_node_id is not initial.
    lo_addr_main = cl_addr_main=>get_instance( ).
    append ms_segment_address-actadd-bas_wp_node_id to lt_addr_id.
    call method lo_addr_main->cleanup
      exporting
        it_address_id = lt_addr_id.
*    call method lo_addr_main->initialize
*      exporting
*        it_address_id = lt_addr_id.
  endif.

* BP Reset
  call method me->bp_reset_modification
    exporting
      iv_do_cleanup = 'X'.

* clear all segments except header segment
  clear_segments( iv_keep_header = 'X' ).

* Node status is set to Empty (i.e. unchanged) for all nodes
  clear_node_status( ).

* ---- If personalization data is involved: Clear respective buffer ---*
  if ms_manager-flg_pers_modified = go_persistence->co_flag_active.
    call method cl_pers_service=>clear_instances .
  endif.

* ---- If appl. references are involved: Clear respective buffer ------*
  if ms_manager-flg_appref_modified = go_persistence->co_flag_active.
    append ms_manager-bname to lt_bname.
    call method cl_suid_applref=>cleanup( it_bname = lt_bname ).
  endif.

** ---- If SAP Easy Access Menu copy is involved -----------------------*
*  if ms_manager-easy_access_copied is not initial.
*    call function 'PRGN_USER_TABLES_RESET_BUFFER'.
*  endif.

* ---- Dequeue Identity -----------------------------------------------*
  if iv_release_enqueue_lock = if_identity=>co_true.
    release_enqueue_lock( ).
  endif.

* ---- Refresh properties ---------------------------------------------*
  cl_suid_property_handler=>reset_to_default( io_identity = me ).

endmethod.


METHOD release_enqueue_lock.

* ---- Dequeue Identity -----------------------------------------------*
  CASE  ms_manager-enqmode.
    WHEN if_identity=>co_enqueue_mode_exclusive.
      CALL METHOD cl_suid_tools=>dequeue
        EXPORTING
          i_bname = ms_manager-bname.
*     reset ms_manager value to no_lock
      ms_manager-enqmode = if_identity=>co_enqueue_mode_no_lock.

    WHEN cl_suid_tools=>co_enqueue_mode_opt_to_excl.
*     try to get rid of exclusive lock first
      CALL METHOD cl_suid_tools=>dequeue
        EXPORTING
          i_bname    = ms_manager-bname.

*     try to get rid of optimistic lock
      CALL METHOD cl_suid_tools=>dequeue
        EXPORTING
          i_bname    = ms_manager-bname
          i_enq_mode = 'O'.
*     reset ms_manager value to no_lock
      ms_manager-enqmode = if_identity=>co_enqueue_mode_no_lock.

    WHEN if_identity=>co_enqueue_mode_optimistic.
*     stay in optimistic mode or release lock
      IF iv_release_optimistic_lock = if_identity=>co_true.
        CALL METHOD cl_suid_tools=>dequeue
          EXPORTING
            i_bname    = ms_manager-bname
            i_enq_mode = 'O'.

*       reset ms_manager value to no_lock
        ms_manager-enqmode = if_identity=>co_enqueue_mode_no_lock.
      ENDIF.

    WHEN if_identity=>co_enqueue_mode_no_lock.
* nothing left to do
    WHEN OTHERS.
      ms_manager-enqmode = if_identity=>co_enqueue_mode_no_lock.
* do nothing
  ENDCASE.

ENDMETHOD.


method remove_cua_local_user_flag.

  data: ls_msg type symsg.


* Exporting parameter
  eo_msg_buffer = go_msg_buffer.


* ---- Transactional preliminaries ------------------------------------*
* Get values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_root
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    return.
  endif.

* Buffer for header information is always filled during instantiation
  if ms_segment_header-bname is initial.
    raise exception type cx_suid_identity
      exporting
        textid = cx_suid_identity=>internal_error
        bname     = ms_manager-bname
        ta_modus  = ms_manager-modus
        ta_status = ms_manager-status.
  endif.


* --- Check if operation is possible ------------------------
* If some other flag except of 'Local user' or initial value is set ==>
* no modifications are allowed
  if ms_segment_header-actual-reserved <> co_user_local and
     ms_segment_header-actual-reserved <> 0.
    clear: ls_msg.
    ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '207'.
*     MSG: Kennzeichen "Lokaler Benutzer" ist nicht gesetzt.
    if 1 = 0. message e207(suid01). endif.

    go_msg_buffer->add_object_message_symsg(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_root
        iv_field    = if_identity_definition=>gc_field_root_bname
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).
    return.
  endif.


* --- Processing -------------------------------------------
*
  ms_segment_header-actual-reserved = 0.


* --- Transaction handling ---------------------------------
*
* New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  if ms_segment_header-actual ne ms_segment_header-before_image.
    ms_segment_header-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.


endmethod.


method reset_unit_test_mode.

  " Code commented out in April 2015.
  "
  " With the introduction of setting of "gv_upg_is_shadow_system" in SET_UNIT_TEST_MODE, this
  " flag also would have had to be restored, and this would have required re-calling
  " the function module which determimed it.
  "
  " But wait: What is the purpose of this method at all? It is called only (as SET_UNIT_TEST_MODE)
  " from the ACM unit tests, and this code does not "switch" between unit test mode and back, therefore
  " the code entirely is redundant.

  " mv_unit_test_mode = if_identity=>co_false.

endmethod.


METHOD retrieve.
*
* Create new Identity instances with transaction mode "Display"
*

  DATA: lt_bname              TYPE suid_tt_bname
      , lt_identity           TYPE suid_tt_identity
      .

*---- Set exporting parameters ----------------------------------------*
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

*---- Pass to method for instantiation --------------------------------*
  IF it_bname IS NOT INITIAL.

    CALL METHOD instantiation_by_mode
      EXPORTING
        iv_modus                = go_persistence->co_ta_modus_display
        it_bname                = it_bname
        iv_enq_mode             = iv_enqueue_mode
      IMPORTING
        et_node_root            = et_node_root
        et_bname_not_exist      = et_bname_not_exist
        et_bname_not_authorized = et_bname_not_authorized.

  ELSEIF it_identity_guid IS NOT INITIAL.
    CALL METHOD go_persistence->if_suid_persistence_query~query_identity_by_uuid
      EXPORTING
        it_identity_guid = it_identity_guid
      IMPORTING
        et_identity      = lt_identity.

    IF lt_identity IS NOT INITIAL.
      MOVE lt_identity TO lt_bname.
      CALL METHOD instantiation_by_mode
        EXPORTING
          iv_modus                = go_persistence->co_ta_modus_display
          it_bname                = lt_bname
          iv_enq_mode             = iv_enqueue_mode
        IMPORTING
          et_node_root            = et_node_root
          et_bname_not_exist      = et_bname_not_exist
          et_bname_not_authorized = et_bname_not_authorized.
    ENDIF.
  ENDIF.

  CHECK: et_node_root IS NOT INITIAL.

*---- Perform Prefetch: -----------------------------------------------*
*  if   it_nodes_prefetch is supplied.
  IF it_nodes_prefetch IS NOT INITIAL.
    CALL METHOD nodes_prefetch
      EXPORTING
        it_bname          = it_bname
        it_nodes_prefetch = it_nodes_prefetch.
  ENDIF.

ENDMETHOD.


METHOD retrieve_for_update.
*
* Create new Identity instances with transaction mode "Modify"
*

  DATA: lt_bname              TYPE suid_tt_bname
      , lt_identity           TYPE suid_tt_identity
      .

*---- Set exporting parameters ----------------------------------------*
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

*---- Pass to method for instantiation --------------------------------*
  IF it_bname IS NOT INITIAL.
    CALL METHOD instantiation_by_mode
      EXPORTING
        iv_modus                        = go_persistence->co_ta_modus_modify
        it_bname                        = it_bname
        iv_enq_mode                     = iv_enqueue_mode
        iv_node_name                    = iv_node_name
        iv_set_optimistic_enqueue_lock  = iv_set_optimistic_enqueue_lock
        iv_repeat_enq                   = iv_repeat_enq
        iv_cua_ts_force_modifaction     = iv_cua_ts_force_modifaction
      IMPORTING
        et_node_root                    = et_node_root
        et_bname_not_exist              = et_bname_not_exist
        et_bname_not_authorized         = et_bname_not_authorized
        et_bname_locked                 = et_bname_locked.
  ELSEIF it_identity_guid IS NOT INITIAL.
    CALL METHOD go_persistence->if_suid_persistence_query~query_identity_by_uuid
      EXPORTING
        it_identity_guid = it_identity_guid
      IMPORTING
        et_identity      = lt_identity.

    IF lt_identity IS NOT INITIAL.
      MOVE lt_identity TO lt_bname.
      CALL METHOD instantiation_by_mode
        EXPORTING
          iv_modus                        = go_persistence->co_ta_modus_modify
          it_bname                        = lt_bname
          iv_enq_mode                     = iv_enqueue_mode
          iv_node_name                    = iv_node_name
          iv_set_optimistic_enqueue_lock  = iv_set_optimistic_enqueue_lock
          iv_repeat_enq                   = iv_repeat_enq
          iv_cua_ts_force_modifaction     = iv_cua_ts_force_modifaction
        IMPORTING
          et_node_root                    = et_node_root
          et_bname_not_exist              = et_bname_not_exist
          et_bname_not_authorized         = et_bname_not_authorized
          et_bname_locked                 = et_bname_locked.
    ENDIF.
  ENDIF.

  CHECK: et_node_root IS NOT INITIAL.

*---- Perform Prefetch: -----------------------------------------------*
  IF it_nodes_prefetch IS NOT INITIAL.
    CALL METHOD nodes_prefetch
      EXPORTING
        it_bname          = it_bname
        it_nodes_prefetch = it_nodes_prefetch.
*   Empty IT_NODES_PREFETCH means: No Prefetch at all
  ENDIF.

ENDMETHOD.


method retrieve_for_update_own_user.
*
* Create new Identity instances with transaction mode "Modify"
*

  data: lt_bname          type suid_tt_bname
       ,ls_bname          type suid_st_bname
       .

*---- Set exporting parameters ----------------------------------------*
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

*---- Own user only ---------------------------------------------------*
  ls_bname-bname = sy-uname ##user_ok.
  append ls_bname to lt_bname.

*---- Pass to method for instantiation --------------------------------*
  call method instantiation_by_mode
    exporting
      iv_modus                    = go_persistence->co_ta_modus_modify
      it_bname                    = lt_bname
      iv_enq_mode                 = iv_enqueue_mode
      iv_transaction              = co_own_data
      iv_cua_ts_force_modifaction = iv_cua_ts_force_modifaction
    importing
      et_node_root                = et_node_root.


endmethod.


method retrieve_own_user.
*
* Read own Identity instances w
*

  data: lt_bname          type suid_tt_bname
       ,ls_bname          type suid_st_bname
       .

*---- Set exporting parameters ----------------------------------------*
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

*---- Own user only ---------------------------------------------------*
  ls_bname-bname = sy-uname ##user_ok.
  append ls_bname to lt_bname.

*---- Pass to method for instantiation --------------------------------*
  call method instantiation_by_mode
    exporting
      iv_modus       = go_persistence->co_ta_modus_display
      it_bname       = lt_bname
      iv_enq_mode    = iv_enqueue_mode
      iv_transaction = co_own_data
    importing
      et_node_root   = et_node_root.


endmethod.


METHOD roles_add_parent_information.

*  DATA: lr_role_name        TYPE REF TO suid_st_role_name.
  DATA: lt_parent_role      TYPE suid_tt_agr_agrs.
  DATA: lr_parent_role      TYPE REF TO agr_agrs.
  DATA: ls_node_role_member TYPE suid_st_node_role_member.

  CALL METHOD cl_suid_role_helper=>get_child_role
    EXPORTING
      it_parent_roles      = it_role_name
    IMPORTING
      et_parent_role_names = lt_parent_role.

  LOOP AT lt_parent_role REFERENCE INTO lr_parent_role.

    ls_node_role_member-parent_role = lr_parent_role->agr_name.
    ls_node_role_member-child_role  = lr_parent_role->child_agr.

    INSERT ls_node_role_member INTO TABLE et_node_roles.

  ENDLOOP.

ENDMETHOD.


METHOD roles_add_text.

  DATA: lr_node_role        TYPE REF TO suid_st_node_role_detail.
  DATA: lr_role_text        TYPE REF TO agr_texts.
  DATA: lt_role_name        TYPE suid_tt_role_name.
  DATA: ls_role_name        TYPE suid_st_role_name.
  DATA: lt_role_text        TYPE suid_tt_agr_texts.

  LOOP AT ct_node_roles REFERENCE INTO lr_node_role.
    ls_role_name-agr_name = lr_node_role->agr_name.
    INSERT ls_role_name INTO TABLE lt_role_name.
  ENDLOOP.

  DELETE ADJACENT DUPLICATES FROM lt_role_name.

  CALL METHOD cl_suid_role_helper=>get_role_texts
    EXPORTING
      it_role_name = lt_role_name
    IMPORTING
      et_role_text = lt_role_text.

  LOOP AT ct_node_roles REFERENCE INTO lr_node_role.

    READ TABLE lt_role_text
      WITH KEY agr_name = lr_node_role->agr_name
      REFERENCE INTO lr_role_text
      BINARY SEARCH.

    IF sy-subrc = 0.
      IF lr_role_text->text IS NOT INITIAL AND lr_role_text->text NE space.
        lr_node_role->agr_text = lr_role_text->text.
      ELSE.
        lr_node_role->agr_text = lr_node_role->agr_name.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDMETHOD.


METHOD roles_add_type.
*
*  CHANGING
*    ct_node_roles  type suid_tt_node_roles
*

  DATA: lr_node_role        TYPE REF TO suid_st_node_role_detail.
  DATA: lt_role_name        TYPE suid_tt_role_name.
  DATA: ls_role_name        TYPE suid_st_role_name.
  DATA: lt_agr_flags        TYPE suid_tt_agr_flags.
  DATA: lr_agr_flags        TYPE REF TO agr_flags.

  LOOP AT ct_node_roles REFERENCE INTO lr_node_role.
    ls_role_name-agr_name = lr_node_role->agr_name.
    INSERT ls_role_name INTO TABLE lt_role_name.
  ENDLOOP.

  CALL METHOD cl_suid_role_helper=>get_role_type
    EXPORTING
      it_role_name = lt_role_name
    IMPORTING
      et_agr_flags = lt_agr_flags.

  LOOP AT ct_node_roles REFERENCE INTO lr_node_role.

    READ TABLE lt_agr_flags
      WITH KEY agr_name = lr_node_role->agr_name
      REFERENCE INTO lr_agr_flags.

    IF sy-subrc = 0.
      IF lr_agr_flags->flag_value EQ 'X'.
        lr_node_role->role_type = if_identity=>co_role_type_collection.
      ELSE.
        lr_node_role->role_type = if_identity=>co_role_type_single.
      ENDIF.

    ENDIF.

  ENDLOOP.

ENDMETHOD.


method roles_check_authority.

  data: lr_role         type ref to   agr_users
      , lr_cua_role     type ref to   usla04
      , ls_msg          type          symsg
      , lv_key          type          string
      , lv_nodename     type          suid_node_name
      , lv_field        type          suid_node_field
      , lv_overwrite    type          sesf_boolean
      .

  if iv_use_ext_node eq if_identity=>co_true.
    lv_nodename = iv_ext_nodename.
    lv_field    = iv_ext_field.
  else.
    lv_nodename = if_identity_definition=>gc_node_reference_user.
    lv_field    = if_identity_definition=>gc_field_reference_user.
  endif.

  " Role tables must be sorted according to database key

  " initialize return value with TRUE
  rv_authorized = 1.

  if iv_ext_lifetime eq if_suid_msg_buffer=>co_lifetime_permanent.
    lv_overwrite = if_identity=>co_true.
  endif.


  " ---- Authority-checks for removal of old assignment ----
  "
  " Local roles
  loop at it_old_roles reference into lr_role.
    read table it_new_roles
         with key agr_name  = lr_role->agr_name
                  from_dat  = lr_role->from_dat
                  to_dat    = lr_role->to_dat
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " check authority for deletion of role assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_role
          iv_operation = cl_suid_tools=>co_activity_delete
          iv_class     = iv_class
          iv_bname     = iv_bname
          iv_role      = lr_role->agr_name
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Benutzergruppe &1 zur Rolle &3
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_role->uname.
        endif.
        if 1 eq 0. message e635(01) with iv_class lr_role->uname lr_role->agr_name. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '635'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_role->uname.
        ls_msg-msgv3 = lr_role->agr_name.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.

  " CUA roles
  loop at it_old_cua_roles reference into lr_cua_role.
    read table it_new_cua_roles
         with key subsystem = lr_cua_role->subsystem
                  agr_name  = lr_cua_role->agr_name
                  from_dat  = lr_cua_role->from_dat
                  to_dat    = lr_cua_role->to_dat
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " check authority for deletion of role assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_role
          iv_operation = cl_suid_tools=>co_activity_delete
          iv_class     = iv_class
          iv_bname     = iv_bname
          iv_subsystem = lr_cua_role->subsystem
          iv_role      = lr_cua_role->agr_name
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Gruppe &1 zur Rolle &3, System &4
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_cua_role->bname.
        endif.
        if 1 = 0. message e634(01) with iv_class lr_cua_role->bname lr_cua_role->agr_name lr_cua_role->subsystem. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '634'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_cua_role->bname.
        ls_msg-msgv3 = lr_cua_role->agr_name.
        ls_msg-msgv4 = lr_cua_role->subsystem.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.


  " ---- Authority-checks for adding new roles ----
  "
  " Local roles
  loop at it_new_roles reference into lr_role.
    read table it_old_roles
         with key agr_name  = lr_role->agr_name
                  from_dat  = lr_role->from_dat
                  to_dat    = lr_role->to_dat
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " check authority for new roles assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_role
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_class
          iv_bname     = iv_bname
          iv_role      = lr_role->agr_name
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Benutzergruppe &1 zur Rolle &3
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_role->uname.
        endif.
        if 1 eq 0. message e635(01) with iv_class lr_role->uname lr_role->agr_name. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '635'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_role->uname.
        ls_msg-msgv3 = lr_role->agr_name.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.

  " CUA roles
  loop at it_new_cua_roles reference into lr_cua_role.
    read table it_old_cua_roles
         with key subsystem = lr_cua_role->subsystem
                  agr_name  = lr_cua_role->agr_name
                  from_dat  = lr_cua_role->from_dat
                  to_dat    = lr_cua_role->to_dat
         binary search
         transporting no fields.

    if sy-subrc ne 0.
      " check authority for new roles assignment
      call method cl_suid_tools=>auth_check_single
        exporting
          iv_nodename  = if_identity_definition=>gc_node_cua_role
          iv_operation = cl_suid_tools=>co_activity_create
          iv_class     = iv_class
          iv_bname     = iv_bname
          iv_subsystem = lr_cua_role->subsystem
          iv_role      = lr_cua_role->agr_name
        importing
          es_msg       = ls_msg.

      if ls_msg-msgty eq 'E'.
        " MSG: Referenzbenutzer &2: Keine Rechte für Gruppe &1 zur Rolle &3, System &4
        rv_authorized = 0.
        if iv_use_ext_node eq if_identity=>co_true.
          clear: lv_key.
        else.
          lv_key = lr_cua_role->bname.
        endif.
        if 1 = 0. message e634(01) with iv_class lr_cua_role->bname lr_cua_role->agr_name lr_cua_role->subsystem. endif. "#EC *

        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '634'.
        ls_msg-msgv1 = iv_class.
        ls_msg-msgv2 = lr_cua_role->bname.
        ls_msg-msgv3 = lr_cua_role->agr_name.
        ls_msg-msgv4 = lr_cua_role->subsystem.

        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname     = iv_bname
            iv_nodename  = lv_nodename
            iv_field     = lv_field
            iv_key       = lv_key
            iv_lifetime  = iv_ext_lifetime "if_suid_msg_buffer=>co_lifetime_once
            is_msg       = ls_msg
            iv_overwrite = lv_overwrite.
      endif.
    endif.
  endloop.

endmethod.


method roles_cua_add_parent_info.

* information about the roles hierarchy is not available for CUA landscape
* the information is only available for the local CUA system
*
* Assume current system is CUA central system:
*
* HW 1783219: Replace RFC variable
*

  data: lr_child_role         type ref to   suid_st_role_name
      , ls_node_role_member   type          suid_st_node_cua_role_member
      , lt_cua_child_systems  type          suid_tt_uszbvlndrc
      , lv_cua_system         type          uszbvlndsc-sendsystem
      , lt_agr_agrs           type          suid_tt_agr_agrs
      , lr_agr_agrs           type ref to   agr_agrs
      , ls_role_name          type          suid_st_role_name
      , lr_role_name          type ref to   suid_st_node_cua_role
      , lt_child_roles        type          suid_tt_role_name
      .


  clear et_node_roles.

  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys    = lv_cua_system
      et_cua_child_systems = lt_cua_child_systems.

  loop at it_roles reference into lr_role_name.

    clear: lt_child_roles, lt_agr_agrs.

    " only fetch roles which are not marked as child role already
    if lr_role_name->agr_assign_type <> if_identity=>co_agr_assign_type_coll and
       lr_role_name->subsystem = lv_cua_system.
      call method cl_suid_role_helper=>get_collection_elements
        exporting
          i_role_name = lr_role_name->agr_name
        importing
          et_agr_agrs = lt_agr_agrs.

      if lt_agr_agrs is not initial.

        clear lt_child_roles.
        loop at lt_agr_agrs reference into lr_agr_agrs.
          clear ls_role_name.
          ls_role_name-agr_name = lr_agr_agrs->child_agr.
          insert ls_role_name into table lt_child_roles.
        endloop.

        call method cl_suid_role_helper=>get_cua_system_role
          changing
            ct_role_name = lt_child_roles.

        loop at lt_child_roles reference into lr_child_role.
          clear ls_node_role_member.

          ls_node_role_member-parent_subsystem  = lr_role_name->subsystem.
          ls_node_role_member-parent_role       = lr_role_name->agr_name.
          ls_node_role_member-child_role        = lr_child_role->agr_name.

          if lr_child_role->subsystem is initial or
             lr_child_role->subsystem eq lv_cua_system.
            ls_node_role_member-child_subsystem  = lv_cua_system.
          else.
            read table lt_cua_child_systems
                with key rcvsystem = lr_child_role->subsystem
                transporting no fields
                binary search.

            if sy-subrc eq 0.
              ls_node_role_member-child_subsystem  = lr_child_role->subsystem.
            else.
              "such roles should be ignored
              continue.
            endif.
          endif.
          insert ls_node_role_member into table et_node_roles.
        endloop.
      endif.
    endif.
  endloop.

endmethod.


method roles_cua_add_text.

  data: lr_node_role        type ref to   suid_st_node_cua_role_detail
      , lr_role_text        type ref to   usrsysactt
      , lt_role_name        type          suid_tt_role_name
      , ls_role_name        type          suid_st_role_name
      , lt_role_text        type          suid_tt_usrsysactt
      .

  loop at ct_node_cua_role_detail reference into lr_node_role.
    ls_role_name-agr_name  = lr_node_role->agr_name.
    ls_role_name-subsystem = lr_node_role->subsystem.
    insert ls_role_name into table lt_role_name.
  endloop.

  call method cl_suid_role_helper=>get_cua_role_texts
    exporting
      it_role_name = lt_role_name
    importing
      et_role_text = lt_role_text.

  sort lt_role_text by subsystem agr_name.

  loop at ct_node_cua_role_detail reference into lr_node_role.

    read table lt_role_text reference into lr_role_text
      with key subsystem = lr_node_role->subsystem
               agr_name  = lr_node_role->agr_name
      binary search.

    if sy-subrc eq 0.
      if lr_role_text->text is not initial.
        lr_node_role->agr_text = lr_role_text->text.
      else.
        lr_node_role->agr_text = lr_node_role->agr_name.
      endif.
      " set role type
      if lr_role_text->col_agr eq 'X'.
        lr_node_role->role_type = if_identity=>co_role_type_collection.
      else.
        lr_node_role->role_type = if_identity=>co_role_type_single.
      endif.
    else.
      lr_node_role->role_type = if_identity=>co_role_type_single.
    endif.

  endloop.

endmethod.


method roles_cua_delete_user_system.

*   - complete messages for roles and profiles
**********************************************************************
* 26.02.2008 D050920  Note 1116083
* - Deletion of CUA-subsystem leads to deletion of corresponded role
* and profiles. It is not allowed to delete subsystem if it has
* indirectly assigned single roles (from composite one). Msg SUID01/024
* It was possible to delete subsystem if HR-org role was assigned.
* No error message was shown. But later these roles was ignored and
* not deleted.
* It is an open question should we display an error message in such
* situation. If we display error messages in cases of other indirect
* assignments - generated profiles and composite role, then we
* also should display it for HR-roles.
**********************************************************************

  data: lt_node_roles       type          suid_tt_node_cua_roles
      , lr_node_role        type ref to   suid_st_node_cua_role
      , lv_tabix            like          sy-tabix
      , lt_role_members     type          suid_tt_node_cua_role_members
      , lr_role_member      type ref to   suid_st_node_cua_role_member
      , lv_msg_key_value    type          string
      , lv_msg_data         type          symsg
      , lv_permit           type          sesf_boolean value if_identity=>co_true
      , lt_local_roles      type          suid_tt_node_roles
      , lr_local_role       type ref to   suid_st_node_role
      , lv_valid            type          sesf_boolean
      , lv_central_logsys   type          uszbvlndsc-sendsystem
      .

  eo_msg_buffer = go_msg_buffer.

* set default value: roles are deleted
* will be overwritten in case CUA Role cannot be deleted
* because of dependencies to other client roles in different systems
  ev_roles_deleted = if_identity=>co_true.

  call method roles_validate_cua_context
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = iv_node_name
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_valid.

  if lv_valid eq if_identity=>co_false.
    return.
  endif.

  if iv_node_name eq if_identity_definition=>gc_node_role.
    " get assigned roles of this user
    me->get_roles( importing et_roles = lt_local_roles ).

    " mark local roles for deletion
    loop at lt_local_roles reference into lr_local_role.
      " HR Role assignment: Do not delete system assignment
      if lr_local_role->agr_assign_type eq if_identity=>co_agr_assign_type_hr.
        ev_roles_deleted = if_identity=>co_false.
        " System &1 kann nicht gelöscht werden, da die Rolle &2 &3
        " ist die über Org.Management zugeordnet ist.
        clear: lv_msg_data, lv_msg_key_value.

        lv_msg_key_value  = iv_system.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = 'SUID01'.
        lv_msg_data-msgno = '026'.

        lv_msg_data-msgv1 = iv_system.
        lv_msg_data-msgv2 = lr_local_role->agr_name.

        if 1 = 0. message e026(suid01) with iv_system lr_local_role->agr_name. endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_cua_system
            iv_key      = lv_msg_key_value
            iv_field    = if_identity_definition=>gc_field_cua_system_subsystem
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = lv_msg_data.

        exit. "leave inner loop.
      endif.

      lr_local_role->change_mode = if_identity=>co_delete.
    endloop.

    " delete local roles
    if ev_roles_deleted ne if_identity=>co_false.
      call method me->roles_set
        exporting
          iv_set_extended        = if_identity=>co_false
          iv_permit              = lv_permit
          iv_do_compare_profiles = if_identity=>co_true
        changing
          ct_roles               = lt_local_roles.
    endif.

  elseif iv_node_name eq if_identity_definition=>gc_node_cua_role.

    cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape( importing ev_central_logsys = lv_central_logsys ).

    " get assigned roles of this user
    call method me->get_cua_roles
      exporting
        iv_get_role_members = 'X'
      importing
        et_roles            = lt_node_roles
        et_role_members     = lt_role_members.


    " check if system can be deleted
    loop at lt_node_roles reference into lr_node_role
      where subsystem eq iv_system.

      " check if this is a child role
      if lr_node_role->agr_assign_type eq if_identity=>co_agr_assign_type_coll.
        " check system-name of parent roles
        loop at lt_role_members reference into lr_role_member
            where child_subsystem = iv_system and
                  child_role      = lr_node_role->agr_name.
          if lr_role_member->parent_subsystem ne iv_system.
            ev_roles_deleted = if_identity=>co_false.
            " System &1 kann nicht gelöscht werden, da die Sammelrolle &2 &3
            " eine Einzelrolle &4 beinhaltet, die diesem System &1 zugeordnet ist.
            clear: lv_msg_data, lv_msg_key_value.

            lv_msg_key_value  = iv_system.
            lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error. "info.
            lv_msg_data-msgid = 'SUID01'.
            lv_msg_data-msgno = '024'.

            lv_msg_data-msgv1 = iv_system.
            lv_msg_data-msgv2 = lr_role_member->parent_subsystem.
            lv_msg_data-msgv3 = lr_role_member->parent_role.
            lv_msg_data-msgv4 = lr_node_role->agr_name.

            if 1 = 0. message e024(suid01) with iv_system lr_role_member->parent_subsystem lr_role_member->parent_role lr_node_role->agr_name. endif.

            call method go_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = ms_manager-bname
                iv_nodename = if_identity_definition=>gc_node_cua_system
                iv_key      = lv_msg_key_value
                iv_field    = if_identity_definition=>gc_field_cua_system_subsystem
                iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
                is_msg      = lv_msg_data.

            exit. "leave inner loop.
          endif.
        endloop.

        if ev_roles_deleted = if_identity=>co_false.
          exit. " leave loop
        endif.


     "elseif ( lr_node_role->agr_assign_type =  if_identity=>co_agr_assign_type_hr ) and
     "       ( lr_node_role->subsystem       <> lv_central_logsys                  ).
             "Because of note 1798905 indirect role assignments from child systems may exist in CUA central system
             "just to keep the overview for the administrator about the HR-Org based role assignments in child systems.
             "Those child system assignments can be deleted together with the HR-Org based role assignments, because
             "the next HR-Org structure delivery to the child system will check if the user exists locally and
             "do NOT create local role assignments if the user NOT exists (check note 834152)!
             "This old coding (introduced by note 834152) no longer exists as of Identity API Downport into 7.31 but
             "the error will still be raised, now by 'PRGN_USER_ASSIGNMENT_CHANGE'.

      elseif ( lr_node_role->agr_assign_type = if_identity=>co_agr_assign_type_hr ) and
             ( lr_node_role->subsystem       = lv_central_logsys                  ).
        ev_roles_deleted = if_identity=>co_false.
        " provide info message
        " System &1 kann nicht gelöscht werden, da die Rolle &2 &3
        " ist die über Org.Management zugeordnet ist.
        clear: lv_msg_data, lv_msg_key_value.

        lv_msg_key_value  = iv_system.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
        lv_msg_data-msgid = 'SUID01'.
        lv_msg_data-msgno = '026'.

        lv_msg_data-msgv1 = iv_system.
        lv_msg_data-msgv2 = lr_node_role->agr_name.

        if 1 = 0. message e026(suid01) with iv_system lr_node_role->agr_name. endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_cua_system
            iv_key      = lv_msg_key_value
            iv_field    = if_identity_definition=>gc_field_cua_system_subsystem
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
            is_msg      = lv_msg_data.

        exit. "leave inner loop.
      endif.
    endloop.


    " only process if roles will be deleted
    if ev_roles_deleted ne if_identity=>co_false.
      " Authority check is not necessary

      loop at lt_node_roles reference into lr_node_role.
        lv_tabix = sy-tabix.
        if lr_node_role->subsystem ne iv_system.
          delete lt_node_roles index lv_tabix.
        else.
          lr_node_role->change_mode = if_identity=>co_delete.
        endif.
      endloop.

      " call internal method: do not check authority
      if ( iv_system = lv_central_logsys ).
        call method me->roles_cua_set_internal
          exporting
            it_roles               = lt_node_roles
            iv_permit              = if_identity=>co_true
            iv_do_compare_profiles = if_identity=>co_true
            iv_set_extended        = if_identity=>co_false. "omit affecting HR assignments
      else.
        "During this subsystem assignment deletion also the HR-Org indirect role assignment for this child system
        "(made by PFUD of child system - Option: "Replicate Local HR Assignments in Central CUA")
        "must be deleted including change documents because PFUD of child system also created change documents for
        "these informational assignments!
        call method me->roles_cua_set_internal
          exporting
            it_roles               = lt_node_roles
            iv_permit              = if_identity=>co_true
            iv_do_compare_profiles = if_identity=>co_true
            iv_set_extended        = if_identity=>co_true.  "trigger deletion of HR assignments, too
      endif.   "central system OR not?

    endif.   "roles to be deleted?

  endif.

endmethod.


METHOD roles_cua_get_changed_system.

  DATA: ls_changed_system     TYPE suid_st_node_cua_system.
  DATA: lt_changed_systems    TYPE suid_tt_node_cua_systems.

  DATA: lt_usla04_insert        TYPE suid_tt_usla04.
  DATA: lt_usla04_delete        TYPE suid_tt_usla04.
  DATA: lt_usla04_update        TYPE suid_tt_usla04.
  DATA: lr_usla04               TYPE REF TO usla04.
  DATA: lv_valid                TYPE sesf_boolean.

  eo_msg_buffer = go_msg_buffer.

  roles_validate_cua_context(
    EXPORTING
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_role
    IMPORTING
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_valid ).

  IF lv_valid EQ if_identity=>co_false.
    RETURN.
  ENDIF.

* CUA role assignment: compare USLA04 entries
  IF me->ms_segment_cua_roles-status   EQ go_persistence->co_seg_changed.
    IF ms_segment_cua_roles-bname IS NOT INITIAL.
*     Evaluate db changes
      IF ms_segment_cua_roles-before_image NE ms_segment_cua_roles-actual.
*.....Something has changed
        IF     ms_segment_cua_roles-actual       IS NOT INITIAL AND
               ms_segment_cua_roles-before_image IS NOT INITIAL.

          CALL METHOD cl_suid_tools=>compare_tables_usla04
            EXPORTING
              it_usla04_new = ms_segment_cua_roles-actual
              it_usla04_old = ms_segment_cua_roles-before_image
            CHANGING
              ct_del        = lt_usla04_delete
              ct_ins        = lt_usla04_insert
              ct_upd        = lt_usla04_update.

        ELSEIF ms_segment_cua_roles-actual       IS NOT INITIAL.
*       Create db entry
          APPEND LINES OF ms_segment_cua_roles-actual TO lt_usla04_insert.
        ELSEIF ms_segment_cua_roles-before_image IS NOT INITIAL.
*       Delete db entry
          APPEND LINES OF ms_segment_cua_roles-before_image TO lt_usla04_delete.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  IF lt_usla04_delete IS NOT INITIAL.
    LOOP AT lt_usla04_delete REFERENCE INTO lr_usla04.
      ls_changed_system-subsystem   = lr_usla04->subsystem.
      ls_changed_system-change_mode = if_identity=>co_delete.
      INSERT ls_changed_system INTO TABLE lt_changed_systems.
    ENDLOOP.
  ENDIF.

  IF lt_usla04_insert IS NOT INITIAL.
    LOOP AT lt_usla04_insert REFERENCE INTO lr_usla04.
      ls_changed_system-subsystem   = lr_usla04->subsystem.
      ls_changed_system-change_mode = if_identity=>co_insert.
      INSERT ls_changed_system INTO TABLE lt_changed_systems.
    ENDLOOP.
  ENDIF.

  IF lt_usla04_update IS NOT INITIAL.
    LOOP AT lt_usla04_update REFERENCE INTO lr_usla04.
      ls_changed_system-subsystem   = lr_usla04->subsystem.
      ls_changed_system-change_mode = if_identity=>co_update.
      INSERT ls_changed_system INTO TABLE lt_changed_systems.
    ENDLOOP.
  ENDIF.

  SORT lt_changed_systems BY subsystem.
  DELETE ADJACENT DUPLICATES FROM lt_changed_systems.

  et_changed_systems = lt_changed_systems.

ENDMETHOD.


method roles_cua_get_collection_elmts.

* this method loops over ct_usla04, fetches single roles of
* composite roles and insert these single roles into actual segment.
* as a side effect the parent-child relationship of composite roles and
* its single roles is returned if requested.
*   - complete messages for roles and profiles
*
* HW 1783219: Replace RFC variable
*

  data: lr_new_role           type ref to   usla04
      , lt_usla04             type          suid_tt_usla04
      , ls_usla04             type          usla04
      , lr_usla04             type ref to   usla04
      , lt_agr_agrs           type          suid_tt_agr_agrs
      , lr_agr_agrs           type ref to   agr_agrs
      , lt_parent_child_rel   type          suid_tt_agr_agrs
      , lv_msg_key_value      type          string
      , ls_msg                type          symsg
      , lr_assigned_role      type ref to   usla04
      , lv_cua_system         type          uszbvlndsc-sendsystem
      , lt_cua_child_systems  type          suid_tt_uszbvlndrc
      , lt_assigned_systems   type          suid_tt_node_cua_systems
      , ls_assigned_system    type          suid_st_node_cua_system
      , lt_new_systems        type          suid_tt_node_cua_systems
      , lr_new_system         type ref to   suid_st_node_cua_system
      , lt_new_check_systems  type          suid_tt_node_cua_systems
      , lt_error_systems      type          tt_error_systems
      , lt_role_name          type          suid_tt_role_name
      , ls_role_name          type          suid_st_role_name
      , lr_role_name          type ref to   suid_st_role_name
      , lv_class              type          xuclass
      , lv_tabix              type          sy-tabix
      .


  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys    = lv_cua_system
      et_cua_child_systems = lt_cua_child_systems.

  sort lt_cua_child_systems.

  " get systems without authority check
  me->get_cua_systems(
    exporting
      iv_get_text    = if_identity=>co_false
    importing
      et_cua_systems = lt_assigned_systems ).

  sort lt_assigned_systems by subsystem.


  " -- Calculate new child roles
  loop at ct_usla04 reference into lr_new_role.
    " get single roles for each collective role with texts
    if lr_new_role->subsystem ne lv_cua_system.
      " only get collection elements from cua system: info for child systems is not available
      continue.
    endif.

    call method cl_suid_role_helper=>get_collection_elements
      exporting
        i_role_name = lr_new_role->agr_name
      importing
        et_agr_agrs = lt_agr_agrs.

    if lt_agr_agrs is not initial.
      " prepare single roles as potential new db roles
      clear lt_role_name.
      loop at lt_agr_agrs reference into lr_agr_agrs.
        clear ls_role_name.
        ls_role_name-agr_name = lr_agr_agrs->child_agr.
        insert ls_role_name into table lt_role_name.
      endloop.

      call method cl_suid_role_helper=>get_cua_system_role
        changing
          ct_role_name = lt_role_name.

      loop at lt_role_name reference into lr_role_name.
        clear ls_usla04.

        if lr_role_name->subsystem is initial or
           lr_role_name->subsystem eq lv_cua_system.
          ls_usla04-subsystem  = lv_cua_system.         " system name
        else.
          read table lt_cua_child_systems
              with key rcvsystem = lr_role_name->subsystem
              transporting no fields
              binary search.

          if sy-subrc eq 0.
            ls_usla04-subsystem  = lr_role_name->subsystem. " system name
          else.
            "such roles should be ignored
            continue.
          endif.
        endif.

        ls_usla04-mandt      = sy-mandt.                    " mandt
        ls_usla04-agr_name   = lr_role_name->agr_name.      " new role name
        ls_usla04-bname      = me->ms_manager-bname.        " current user
        ls_usla04-from_dat   = lr_new_role->from_dat.       " date of collective role
        ls_usla04-to_dat     = lr_new_role->to_dat.         " date of collective role
        ls_usla04-org_flag   = 'C'.                         " collective role

        insert ls_usla04 into table lt_usla04.
        " do not insert new role into role's ct_usla04 table
        " since this table is used in loop condition

        if et_parent_child_relationship is supplied.
          " insert found entries to parent_child_rel table
          insert lr_agr_agrs->* into table lt_parent_child_rel.
        endif.

        " check if system is already assigned
        read table lt_assigned_systems
          with key subsystem = ls_usla04-subsystem
          binary search
          transporting no fields.

        if sy-subrc <> 0.
          clear ls_assigned_system.
          ls_assigned_system-subsystem   = ls_usla04-subsystem.
          ls_assigned_system-change_mode = if_identity=>co_insert.
          insert ls_assigned_system into table lt_new_systems.
        endif.
      endloop.
    endif.
  endloop.

  " Delete duplicated entries
  sort lt_new_systems.
  delete adjacent duplicates from lt_new_systems comparing all fields.
  sort lt_usla04.
  delete adjacent duplicates from lt_usla04 comparing all fields.


  " --- Delete no longer valid child role assignments
  loop at ct_usla04 reference into lr_usla04
    where org_flag eq 'C'.

    lv_tabix = sy-tabix.

    read table lt_usla04
      with key subsystem   = lr_usla04->subsystem
               agr_name    = lr_usla04->agr_name
               bname       = lr_usla04->bname
               from_dat    = lr_usla04->from_dat
               to_dat      = lr_usla04->to_dat
               org_flag    = 'C'
      transporting no fields.
    if sy-subrc ne 0.
      " Delete notification is written later
      delete ct_usla04 index lv_tabix.
    endif.
  endloop.


  " --- Set new system assignment ---
  clear: lt_new_check_systems, lt_error_systems.

  loop at lt_new_systems reference into lr_new_system.
    append lr_new_system->* to lt_new_check_systems.
  endloop.

  if lt_new_check_systems is not initial.
    call method me->cua_set_syst_assignment
      importing
        et_error_systems  = lt_error_systems
      changing
        ct_assign_systems = lt_new_check_systems.
  endif.


  " ---  add content of temporary internal table ct_usla04
  loop at lt_usla04 reference into lr_usla04.
    " Find table entry: entry may already exist since ct_usla04
    " contains entries read from DB or there have been some calls
    " of set_roles before
    read table ct_usla04
      with key subsystem   = lr_usla04->subsystem
               agr_name    = lr_usla04->agr_name
               bname       = lr_usla04->bname
               from_dat    = lr_usla04->from_dat
               to_dat      = lr_usla04->to_dat
      transporting no fields.

    " part of composite role already exists: continue
    " because timestamp of already set entries should not be overwritten
    if sy-subrc eq 0.
      continue.
    else.
      " check if old entry exists in actual-image: re-use old timestamp
      " of modification time and date
      read table me->ms_segment_cua_roles-actual
        with key subsystem = lr_usla04->subsystem
                 agr_name  = lr_usla04->agr_name
                 bname     = lr_usla04->bname
                 from_dat  = lr_usla04->from_dat
                 to_dat    = lr_usla04->to_dat
                 org_flag  = lr_usla04->org_flag
        reference into lr_assigned_role.

      if sy-subrc eq 0.
        " reuse old entry
        move-corresponding lr_assigned_role->* to ls_usla04.
        insert ls_usla04 into table ct_usla04.
      else.
        " Check authorization error for new system assignment
        read table lt_error_systems transporting no fields
             with key subsystem = lr_usla04->subsystem.

        if sy-subrc eq 0. "Only authorization error can occur

          " Keine Berechtigung zur Zuordnung des Systems &1 (Rolle &2)
          if 1 = 0. message e574(01) with space space. endif. "#EC *
          clear: ls_msg.
          ls_msg-msgty = 'E'.
          ls_msg-msgid = '01'.
          ls_msg-msgno = '574'.
          ls_msg-msgv1 = lr_usla04->subsystem.
          ls_msg-msgv2 = lr_usla04->agr_name.

          concatenate lr_usla04->subsystem lr_usla04->agr_name
                      lr_usla04->from_dat  lr_usla04->to_dat
                 into lv_msg_key_value respecting blanks.

          call method me->go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_cua_role
              iv_key      = lv_msg_key_value
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
              iv_field    = if_identity_definition=>gc_field_cua_role_agr_name
              is_msg      = ls_msg.

          call method me->go_notify->notify_failed_create
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_cua_role
              iv_key      = lv_msg_key_value.

          continue.
        endif.

        " check if authority for new role is sufficient
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename  = if_identity_definition=>gc_node_cua_role
            iv_operation = cl_suid_tools=>co_activity_create
            iv_class     = lv_class
            iv_bname     = ms_manager-bname
            iv_subsystem = lr_usla04->subsystem
            iv_role      = lr_usla04->agr_name
          importing
            es_msg       = ls_msg.

        clear lv_msg_key_value.
        concatenate lr_usla04->subsystem lr_usla04->agr_name
                    lr_usla04->from_dat lr_usla04->to_dat
               into lv_msg_key_value respecting blanks.

        if ls_msg-msgty ne 'E'.
          insert lr_usla04->* into table ct_usla04.

          " handle notification mode:
          call method me->go_notify->notify_create
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_cua_role
              iv_key      = lv_msg_key_value.
        else.
          " not authorized
          " MSG: Fehlende Zuordnungsrechte: Benutzergruppe &3 zur Rolle &2 für System &1
          if 1 = 0. message w637(01) with ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3. endif. "#EC *

          call method me->go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = ms_manager-bname
              iv_nodename = if_identity_definition=>gc_node_cua_role
              iv_key      = lv_msg_key_value
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
              iv_field    = if_identity_definition=>gc_field_cua_role_subsystem
              is_msg      = ls_msg.

          call method me->go_notify->notify_failed_create
            exporting
              iv_bname    = ms_segment_roles-bname
              iv_nodename = if_identity_definition=>gc_node_cua_role
              iv_key      = lv_msg_key_value.

        endif.
      endif.
    endif.
  endloop.

  et_parent_child_relationship = lt_parent_child_rel.

endmethod.


method roles_cua_get_for_syst_distr.
*
* No authority check during distribution
*

  data: lt_cua_roles        type           suid_tt_node_cua_roles
      , lt_cua_role_details type           suid_tt_node_cua_role_details
      , lr_cua_role         type ref to    suid_st_node_cua_role
      , lr_cua_role_detail  type ref to    suid_st_node_cua_role_detail
      , lt_bapiagr          type table of  bapiagr
      , lr_bapiagr          type ref to    bapiagr
      , ls_node_filter      type           suid_st_cua_filters
      .


  clear: et_cua_system_roles.

* --- Check CUA landscape ----------------------------------
*
* CUA is not active or we method is called not in central system - exit
  if gv_cua_active = if_identity=>co_false or gv_cua_central = if_identity=>co_false.
    return.
  endif.

* Check that global CUA role assignments is allowed
  ls_node_filter-node_name = if_identity_definition=>gc_node_cua_role.
* Get CUA distribution filter for field
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_field_filter
    changing
      cs_field_filter = ls_node_filter.

  if ls_node_filter-field_attr <> if_suid_cua_runtime=>gc_global.
    return.
  endif.


* --- Get system role assignments --------------------------
*
* Get all CUA roles and their details
  call method me->get_cua_roles
    exporting
      iv_get_role_details = if_identity=>co_true
    importing
      et_roles            = lt_cua_roles
      et_role_details     = lt_cua_role_details.

  read table lt_cua_roles
       with key subsystem = iv_subsystem
       transporting no fields
       binary search.
  if sy-subrc = 0.
    loop at lt_cua_roles reference into lr_cua_role from sy-tabix.
      if lr_cua_role->subsystem <> iv_subsystem.
        exit.
      endif.

*     Ignore Role assignments from HR because HR assignment is done locally only
*     Keep only roles with org_flag EQ space and 'C' - from collective role
      if lr_cua_role->agr_assign_type = if_identity=>co_agr_assign_type_hr.
        continue.
      endif.

      append initial line to lt_bapiagr reference into lr_bapiagr.
      lr_bapiagr->agr_name = lr_cua_role->agr_name.
      lr_bapiagr->from_dat = lr_cua_role->from_dat.
      lr_bapiagr->to_dat   = lr_cua_role->to_dat.
*     For distribution all roles should be collected with empty ORG_FLAG in
*     order not to loose some assignment in child system(USE CASE: single role
*     from child system is a part of collective role in central system)
*     Role assignments should be resolved correctly in child system  at Idoc procesing
*      lr_bapiagr->org_flag = lr_cua_role->agr_assign_type.

      read table lt_cua_role_details reference into lr_cua_role_detail
           with key subsystem = iv_subsystem
                agr_name      = lr_cua_role->agr_name
           binary search.
      if sy-subrc = 0.
        lr_bapiagr->agr_text = lr_cua_role_detail->agr_text.
      endif.
    endloop.
  endif.

  sort lt_bapiagr.
  delete adjacent duplicates from lt_bapiagr comparing agr_name from_dat to_dat.

  et_cua_system_roles = lt_bapiagr.


endmethod.


method roles_cua_merge_to_result.


  data: lv_msg_key_value    type          string
      , ls_msg              type          symsg
      , lr_node_role        type ref to   suid_st_node_cua_role
      , lr_usla04           type ref to   usla04
      , lv_tabix            type          sy-tabix
      , lv_insert_tabix     type          sy-tabix
      , lv_key_handle       type          suid_node_key_handle
      , lt_assigned_roles   type          suid_tt_usla04
      , lr_assigned_roles   type ref to   usla04
      , ls_assigned_roles   type          usla04
      , lt_assigned_systems	type          suid_tt_node_cua_systems
      , ls_assigned_system  type          suid_st_node_cua_system
      , lt_new_systems      type          suid_tt_node_cua_systems
      , lt_error_systems    type          tt_error_systems
      , lv_calculate_new    type          sesf_boolean
      .


  " all entries are verified already: existence is checked, dates and intervals are valid

  " get cua_systems without checking authority
  me->get_cua_systems(
    exporting
      iv_get_text    = if_identity=>co_false
    importing
      et_cua_systems = lt_assigned_systems ).

  sort lt_assigned_systems by subsystem.

  " -- Get new systems which must be assigned
  loop at ct_update_role_nodes reference into lr_node_role
      where change_mode eq if_identity=>co_insert.

    read table lt_assigned_systems
      with key subsystem = lr_node_role->subsystem
      binary search
      transporting no fields.

    if sy-subrc ne 0.
      clear ls_assigned_system.
      ls_assigned_system-subsystem   = lr_node_role->subsystem.
      ls_assigned_system-change_mode = if_identity=>co_insert.
      insert ls_assigned_system into table lt_new_systems.
    endif.
  endloop.

  " -- Add new systems
  if lt_new_systems is not initial.
    sort lt_new_systems.
    delete adjacent duplicates from lt_new_systems comparing subsystem.
    call method me->cua_set_syst_assignment
      importing
        et_error_systems  = lt_error_systems
      changing
        ct_assign_systems = lt_new_systems.

    " Evaluate errors
    sort lt_error_systems.
    loop at ct_update_role_nodes reference into lr_node_role
        where change_mode eq if_identity=>co_insert.

      read table lt_error_systems transporting no fields
           with key subsystem = lr_node_role->subsystem
           binary search.
      if sy-subrc eq 0. "Only authorization error can occur

        " Keine Berechtigung zur Zuordnung des Systems &1 (Rolle &2)
        if 1 = 0. message e574(01) with space space. endif. "#EC *
        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '574'.
        ls_msg-msgv1 = lr_node_role->subsystem.
        ls_msg-msgv2 = lr_node_role->agr_name.

        concatenate lr_node_role->subsystem lr_node_role->agr_name
                    lr_node_role->from_dat  lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_key_handle = lr_node_role->key_handle
            iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
            is_msg        = ls_msg.

        call method me->go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_cua_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle.

        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
      endif.
    endloop.
  endif.


  " -- Get current assigned roles
  lt_assigned_roles = me->ms_segment_cua_roles-actual.
  sort lt_assigned_roles by subsystem agr_name bname from_dat to_dat org_flag.

  " Collective role resolving?
  if iv_do_role_resolving eq if_identity=>co_true.
    lv_calculate_new = if_identity=>co_true.
  else.
    lv_calculate_new = if_identity=>co_false.
  endif.

  " --- delete entries ------------
  loop at ct_update_role_nodes reference into lr_node_role
    where change_mode eq if_identity=>co_delete.

    lv_calculate_new = if_identity=>co_true.

    read table lt_assigned_roles
      with key subsystem = lr_node_role->subsystem
               agr_name  = lr_node_role->agr_name
               bname     = ms_manager-bname
               from_dat  = lr_node_role->from_dat
               to_dat    = lr_node_role->to_dat
               org_flag  = lr_node_role->agr_assign_type
      binary search
      transporting no fields.

    lv_tabix = sy-tabix.

    if sy-subrc eq 0.
      " Authority Check is done in check_cua_roles_internal
      clear: lv_msg_key_value.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      call method me->go_notify->notify_delete
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle.

      delete lt_assigned_roles index lv_tabix.
    else.
      " Ignore this entry: Change failed
      clear: lr_node_role->change_mode.
    endif.
  endloop.

  " -- Calcutale current assigned child roles --
  if lv_calculate_new eq if_identity=>co_true.
    call method me->roles_cua_get_collection_elmts
      changing
        ct_usla04 = lt_assigned_roles.

    " Current assigned roles (incl. child roles)
    sort lt_assigned_roles by subsystem agr_name bname from_dat to_dat org_flag.
  endif.


  " --- update entries ------------
  lv_calculate_new = if_identity=>co_false.
  loop at ct_update_role_nodes reference into lr_node_role
    where change_mode eq if_identity=>co_update.

    lv_calculate_new = if_identity=>co_true.

    read table lt_assigned_roles
      with key subsystem = lr_node_role->subsystem
               agr_name  = lr_node_role->agr_name
               bname     = ms_manager-bname
               from_dat  = lr_node_role->from_dat
               to_dat    = lr_node_role->to_dat
               org_flag  = lr_node_role->agr_assign_type
      binary search
      reference into lr_assigned_roles.

    if sy-subrc ne 0.
      " MSG: Die Rolle & existiert nicht.
      if 1 = 0. message e410(s#) with lr_node_role->agr_name. endif.
      clear: ls_msg, lv_msg_key_value.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      ls_msg-msgty   = 'E'.
      ls_msg-msgid   = 'S#'.
      ls_msg-msgno   = '410'.
      ls_msg-msgv1   = lr_node_role->agr_name.

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = ls_msg.

      " Keep line: Change failed
      clear: lr_node_role->change_mode.
      continue.
    endif.

    " Ignore update if from_dat and to_dat do not change
    if lr_node_role->from_dat eq lr_node_role->update_from_dat and
       lr_node_role->to_dat   eq lr_node_role->update_to_dat.
      clear: lr_node_role->change_mode.
      continue.
    endif.

    " Check: Insert possible?
    read table lt_assigned_roles
      with key subsystem = lr_node_role->subsystem
               agr_name  = lr_node_role->agr_name
               bname     = ms_manager-bname
               from_dat  = lr_node_role->update_from_dat
               to_dat    = lr_node_role->update_to_dat
      binary search
      reference into lr_assigned_roles.
    if sy-subrc eq 0.
      " MSG: Die Rolle &1 für das Zielssystem &2 ist bereits zugeordnet
      if 1 = 0. message e061(suid01) with lr_node_role->agr_name lr_node_role->subsystem. endif. "#EC *
      clear: ls_msg, lv_msg_key_value.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
      ls_msg-msgid = 'SUID01'.
      ls_msg-msgno = '061'.
      ls_msg-msgv1 = lr_node_role->agr_name.
      ls_msg-msgv2 = lr_node_role->subsystem.

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = ls_msg.

      " Keep line: Change failed
      clear: lr_node_role->change_mode.
      continue.
    endif.

    " Update role - Authority Check is done in check_roles_internal
    clear: lv_msg_key_value.

    " Write notification with old key!
    concatenate lr_node_role->subsystem lr_node_role->agr_name
                lr_node_role->from_dat lr_node_role->to_dat
           into lv_msg_key_value respecting blanks.

    call method me->go_notify->notify_update
      exporting
        iv_bname      = ms_manager-bname
        iv_nodename   = if_identity_definition=>gc_node_cua_role
        iv_key        = lv_msg_key_value
        iv_key_handle = lr_node_role->key_handle.

    " Key Exchange
    lr_node_role->from_dat        = lr_node_role->update_from_dat.
    lr_node_role->to_dat          = lr_node_role->update_to_dat.

    lr_assigned_roles->from_dat   = lr_node_role->update_from_dat. " update from_dat
    lr_assigned_roles->to_dat     = lr_node_role->update_to_dat.   " update to_dat

    " Change Key -> Sort
    sort lt_assigned_roles by subsystem agr_name bname from_dat to_dat org_flag.
  endloop.

  " -- Calcutale current assigned child roles --
  if lv_calculate_new eq if_identity=>co_true.
    call method me->roles_cua_get_collection_elmts
      changing
        ct_usla04 = lt_assigned_roles.

    " Current assigned roles (incl. child roles)
    sort lt_assigned_roles by subsystem agr_name bname from_dat to_dat org_flag.
  endif.


  " --- insert entries ------------
  lv_calculate_new = if_identity=>co_false.
  loop at ct_update_role_nodes reference into lr_node_role
    where change_mode eq if_identity=>co_insert.

    lv_calculate_new = if_identity=>co_true.

    " Check: Insert possible?
    read table lt_assigned_roles
      with key subsystem = lr_node_role->subsystem
               agr_name  = lr_node_role->agr_name
               bname     = ms_manager-bname
               from_dat  = lr_node_role->from_dat
               to_dat    = lr_node_role->to_dat
      binary search
      transporting no fields.

    lv_insert_tabix = sy-tabix.

    if sy-subrc eq 0.
      " MSG: Die Rolle &1 für das Zielssystem &2 ist bereits zugeordnet
      if 1 = 0. message e061(suid01) with lr_node_role->agr_name lr_node_role->subsystem. endif. "#EC *
      clear: ls_msg, lv_msg_key_value.

      concatenate lr_node_role->subsystem lr_node_role->agr_name
                  lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
      ls_msg-msgid = 'SUID01'.
      ls_msg-msgno = '061'.
      ls_msg-msgv1 = lr_node_role->agr_name.
      ls_msg-msgv2 = lr_node_role->subsystem.

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_cua_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = ls_msg.

      call method me->go_notify->notify_failed_create
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle.

      " Keep line: Insert failed
      lr_node_role->change_mode = if_identity=>co_failed_create.
      continue.
    endif.

    " Insert role - Authority Check is done in check_roles_internal
    clear: lv_msg_key_value.

    concatenate lr_node_role->subsystem lr_node_role->agr_name
                lr_node_role->from_dat lr_node_role->to_dat
           into lv_msg_key_value respecting blanks.

    clear ls_assigned_roles.
    ls_assigned_roles-mandt     = sy-mandt.                      " set mandt
    ls_assigned_roles-subsystem = lr_node_role->subsystem.       " set system name
    ls_assigned_roles-agr_name  = lr_node_role->agr_name.        " set agr_name
    ls_assigned_roles-bname     = ms_manager-bname.              " set uname
    ls_assigned_roles-from_dat  = lr_node_role->from_dat.        " set from_dat
    ls_assigned_roles-to_dat    = lr_node_role->to_dat.          " set to_dat
    ls_assigned_roles-org_flag  = lr_node_role->agr_assign_type. " set org_flag

    insert ls_assigned_roles into lt_assigned_roles index lv_insert_tabix.

    call method me->go_notify->notify_create
      exporting
        iv_bname      = ms_manager-bname
        iv_nodename   = if_identity_definition=>gc_node_cua_role
        iv_key        = lv_msg_key_value
        iv_key_handle = lr_node_role->key_handle.
  endloop.

  " -- Calcutale current assigned child roles --
  if lv_calculate_new eq if_identity=>co_true.
    call method me->roles_cua_get_collection_elmts
      changing
        ct_usla04 = lt_assigned_roles.

    " Current assigned roles (incl. child roles)
    sort lt_assigned_roles by subsystem agr_name bname from_dat to_dat org_flag.
  endif.


  " send notification for child roles which are not assigned anymore
  loop at me->ms_segment_cua_roles-actual reference into lr_usla04
    where org_flag eq 'C'.

    read table lt_assigned_roles
      with key subsystem = lr_usla04->subsystem
               agr_name  = lr_usla04->agr_name
               bname     = ms_manager-bname
               from_dat  = lr_usla04->from_dat
               to_dat    = lr_usla04->to_dat
      binary search
      transporting no fields.

    " child role is still part of composite role: continue
    if sy-subrc eq 0.
      continue.
    else.
      clear lv_msg_key_value.
      concatenate lr_usla04->subsystem lr_usla04->agr_name
                  lr_usla04->from_dat  lr_usla04->to_dat
             into lv_msg_key_value respecting blanks.

      call method me->go_notify->notify_delete
        exporting
          iv_bname      = lr_usla04->bname
          iv_nodename   = if_identity_definition=>gc_node_cua_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lv_key_handle.
    endif.
  endloop.

  et_usla04 = lt_assigned_roles.

endmethod.


method roles_cua_set.

* Algorithm: (like prgn_profiles_for_userprof)
*
*  check_cua_roles_internal:
*   - delete entries with empty role names
*   - delete entries with empty system names
*   - verification of from_dat and to_dat
*   - check if interval [from_dat, to_dat] is valid
*   - invalid values of change_mode are ignored.
*   - existence check of roles
*   - eliminate duplicate entries
*
*  roles_merge_to_result:
*  - et_agr_user: Importing table with Key handle
*  - Send notification for deleted child roles only if children are not in result set anymore
*
*  profile_adjust
*  profile_write_to_segment
*


  data: lr_node_cua_role          type ref to   suid_st_node_cua_role
      , lv_error                  type          sesf_boolean
      , lt_actual_result          type          suid_tt_usla04
      , lv_msg_data               type          symsg
      , lv_class                  type          xuclass
      , lv_tabix                  type          sy-tabix
      .

  clear: et_node_cua_roles.

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " Initial check
  if iv_permit eq if_identity=>co_false.
    call method checks_before_access
      exporting
        iv_method      = 'S'
        iv_change_node = if_identity_definition=>gc_node_cua_role
      importing
        es_msg         = lv_msg_data.

    if lv_msg_data-msgty = 'E'.
      "Return to caller if not authorized
      return.
    endif.
  endif.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_role.

  " Delete all message belonging to this node type
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_cua_role.


  " set_roles does not allow to set ORG_FLAG. Therefore check ct_roles table
  " if org_flag is set: ignore records which have ORG_FLAG set
  " Indirect role assignments (Type 'C') are ignored, but not deleted
  if iv_set_extended eq space.
    delete ct_roles where agr_assign_type eq 'X'.
  endif.

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " check buffer
  if ms_segment_cua_roles-bname is initial.
    call method fetch_segment_cua_roles.
    if ms_segment_cua_roles-bname is initial.
      raise exception
        type
        cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error
          bname  = ms_manager-bname.
    endif.
  endif.

  " validate input
  cl_identity=>check_cua_roles_internal(
  exporting
    io_msg_buffer        = go_msg_buffer
    io_notify            = go_notify
    iv_bname             = ms_manager-bname
    iv_class             = lv_class
    iv_permit            = iv_permit
  changing
    ct_roles             = ct_roles ).

  " remember Importing table: key_handle
  loop at ct_roles reference into lr_node_cua_role.
    lv_tabix = sy-tabix.
    if lr_node_cua_role->change_mode is initial or
       lr_node_cua_role->change_mode eq if_identity=>co_failed_create.
      append lr_node_cua_role->* to et_node_cua_roles.
      delete ct_roles index lv_tabix.
    endif.
  endloop.

  " -- merge into result
  call method me->roles_cua_merge_to_result
    exporting
      iv_do_role_resolving = iv_do_role_resolving
    importing
      et_usla04            = lt_actual_result
    changing
      ct_update_role_nodes = ct_roles.

  " remember Importing table: key_handle
  append lines of ct_roles to et_node_cua_roles.

  " Check output table - set D-Flag if necessary
  loop at et_node_cua_roles reference into lr_node_cua_role
    where agr_assign_type eq 'C'.

    read table lt_actual_result
    with key subsystem = lr_node_cua_role->subsystem
             agr_name  = lr_node_cua_role->agr_name
             bname     = ms_manager-bname
             from_dat  = lr_node_cua_role->from_dat
             to_dat    = lr_node_cua_role->to_dat
      binary search
      transporting no fields.

    if sy-subrc ne 0.
      lr_node_cua_role->change_mode = if_identity=>co_delete.
    endif.
  endloop.


  " -- write new roles into segments
  me->ms_segment_cua_roles-actual = lt_actual_result.

  " -- Transaction handling
  " only set transaction status if there have been changes
  if me->ms_segment_cua_roles-actual ne me->ms_segment_cua_roles-before_image.

    " New transaction status: UNCHECKED
    me->ms_manager-status = go_persistence->co_ta_status_unchecked.

    " Check status:
    call method go_msg_buffer->find_error_for_node
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_cua_role
      receiving
        ev_error    = lv_error.
    if lv_error eq if_identity=>co_false.
      " New node status: CHECKED
      ms_manager-sn_cua_roles = go_persistence->co_node_status_checked.
    else.
      " New node status: CHANGED
      ms_manager-sn_cua_roles = go_persistence->co_node_status_changed.
    endif.
    " Set segment change flag for DB
    me->ms_segment_cua_roles-status = go_persistence->co_seg_changed.
  else.
    " in case actual and before_image are identical: set segment
    " status to unchanged.
    clear: ms_segment_cua_roles-status, ms_manager-sn_cua_roles.
  endif.


endmethod.


method roles_cua_set_internal.

  data: lt_roles                  type          suid_tt_node_cua_roles
      , lv_host_name              type          uszbvlndsc-sendsystem
      , lt_usla04                 type          suid_tt_usla04
      , lr_usla04                 type ref to   usla04
      , lt_agr_users              type          suid_tt_agr_users
      , lr_agr_users              type ref to   agr_users
      , ls_agr_users              type          agr_users
      , lv_tabix                  type          sy-tabix
      , lv_org_flag               type          agr_orgcol
      , lv_agr_org_flag           type          agr_org
      , lv_agr_col_flag           type          agr_col
      .

  " initialize exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  lt_roles = it_roles.

  " call internal method
  call method me->roles_cua_set
    exporting
      iv_permit            = iv_permit
      iv_do_role_resolving = iv_do_role_resolving
      iv_set_extended      = iv_set_extended
    importing
      et_node_cua_roles    = et_node_cua_roles
      eo_msg_buffer        = eo_msg_buffer
      eo_notify            = eo_notify
    changing
      ct_roles             = lt_roles.


  " --- Sync local role tables
  call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
    importing
      ev_central_logsys = lv_host_name.

  " Get global assigned roles for central system
  lt_usla04 = me->ms_segment_cua_roles-actual.

  " Get local assigned roles
  if ms_segment_roles-bname is initial.
    call method fetch_segment_roles.
  endif.
  lt_agr_users = ms_segment_roles-actual.


  " Determine roles to be deleted
  loop at lt_agr_users reference into lr_agr_users.

    lv_tabix = sy-tabix.

    clear: lv_org_flag.
    if     lr_agr_users->org_flag eq 'X'.
      lv_org_flag = 'X'.
    elseif lr_agr_users->col_flag eq 'X'.
      lv_org_flag = 'C'.
    endif.

    read table lt_usla04
      with key subsystem    = lv_host_name
               agr_name     = lr_agr_users->agr_name
               from_dat     = lr_agr_users->from_dat
               to_dat       = lr_agr_users->to_dat
               org_flag     = lv_org_flag
    transporting no fields.

    if sy-subrc ne 0.
      delete lt_agr_users index lv_tabix.
    endif.
  endloop.

  " Determine roles to be added
  loop at lt_usla04 reference into lr_usla04
    where subsystem eq lv_host_name.

    case lr_usla04->org_flag.
      when 'X'.
        lv_agr_org_flag = 'X'.
        lv_agr_col_flag = space.
      when 'C'.
        lv_agr_org_flag = space.
        lv_agr_col_flag = 'X'.
      when others.
        clear: lv_agr_org_flag, lv_agr_col_flag.
    endcase.

    read table lt_agr_users
         with key agr_name          = lr_usla04->agr_name
                  from_dat          = lr_usla04->from_dat
                  to_dat            = lr_usla04->to_dat
                  org_flag          = lv_agr_org_flag
                  col_flag          = lv_agr_col_flag
         transporting no fields.
    if sy-subrc ne 0.
      move-corresponding lr_usla04->* to ls_agr_users.
      ls_agr_users-mandt    = sy-mandt.
      ls_agr_users-uname    = ms_manager-bname.
      ls_agr_users-org_flag = lv_agr_org_flag.
      ls_agr_users-col_flag = lv_agr_col_flag.
      insert ls_agr_users into table lt_agr_users.
    endif.
  endloop.

  " --- write new roles into segments (without checks and notifications)
  sort lt_agr_users.
  call method me->roles_write_to_segment
    exporting
      it_user_roles             = lt_agr_users
      iv_permit                 = iv_permit
      iv_check_compare_profiles = iv_check_compare_profiles
      iv_do_compare_profiles    = iv_do_compare_profiles.


  " Transaction SCUG: mark in internal CUA segment that we transferred roles from child system
  if gs_cua_user_transfer-active = if_identity=>co_true.
    ms_segment_cua_act_distr-actual-actgrpsection = if_suid_cua_runtime=>gc_transferred.
  endif.

endmethod.


method roles_get_collection_elements.

* this method loops over ct_agr_users, fetches single roles of
* composite roles and insert these single roles into actual segment.
* as a side effect the parent-child relationship of composite roles and
* its single roles is returned if requested.
*   - complete messages for roles and profiles

  data: lr_new_role           type ref to   agr_users
      , lt_db_role            type          suid_tt_agr_users
      , ls_db_role            type          agr_users
      , lr_db_role            type ref to   agr_users
      , lt_agr_agrs           type          suid_tt_agr_agrs
      , lt_all_agr_agrs       type          suid_tt_agr_agrs
      , lr_agr_agrs           type ref to   agr_agrs
      , lt_parent_child_rel   type          suid_tt_agr_agrs
      , lr_assigned_role      type ref to   agr_users
      , lr_agr_users_handle   type ref to   agr_users
      , ls_agr_users_handle   type          agr_users
      , lv_msg_key_value      type          string
      , lv_msg_data           type          symsg
      , lv_cua_system         type          uszbvlndsc-sendsystem
      , lt_child_roles        type          suid_tt_role_name
      , ls_role_name          type          suid_st_role_name
      , lv_class              type          xuclass
      , lv_cua_active         type          sesf_boolean
      , lv_cua_central        type          sesf_boolean
      , lv_no_maintain        type          sesf_boolean
      , lv_use_system_name    type          sesf_boolean   value if_identity=>co_false
      , lr_role_name          type ref to   suid_st_role_name
      , lv_tabix              type          sy-tabix
      .


  " CUA Info is *needed* since roles can be assigned with active CUA
  " globally or locally(=SCUM settings)
  cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape(
    importing
      ev_cua_active        = lv_cua_active
      ev_cua_central       = lv_cua_central
      ev_central_logsys    = lv_cua_system ).

  " only in case cua is active and set_roles is called on central system
  " check if cua_roles is maintained globally or locally (=SCUM settings)
  if ( lv_cua_active eq if_identity=>co_true and lv_cua_central eq if_identity=>co_true ).

    cua_if_field_no_maintain(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_role
      receiving
        rv_no_maintain = lv_no_maintain ).

    " if cua_roles can be maintained: consider system + role
    if lv_no_maintain = if_identity=>co_false.
      lv_use_system_name = if_identity=>co_true.
    endif.
  endif.

  cl_suid_role_helper=>get_collection_elements(
    exporting
      it_role_name    = ct_agr_users
    importing
      et_agr_agrs     = lt_all_agr_agrs ).

  " collect child roles and read subsystems of all child roles
  loop at lt_all_agr_agrs reference into lr_agr_agrs.
    clear ls_role_name.
    ls_role_name-agr_name = lr_agr_agrs->child_agr.
    insert ls_role_name into table lt_child_roles.
  endloop.

  cl_suid_role_helper=>get_cua_system_role(
    changing
      ct_role_name = lt_child_roles ).


  " -- Calculate new child roles
  loop at ct_agr_users reference into lr_new_role.
    " get single roles for each collective role
    clear: lt_agr_agrs.
    loop at lt_all_agr_agrs reference into lr_agr_agrs
                            where agr_name = lr_new_role->agr_name.
      insert lr_agr_agrs->* into table lt_agr_agrs.
    endloop.

    if lt_agr_agrs is not initial.

      " prepare single roles as potential new db roles
      loop at lt_agr_agrs reference into lr_agr_agrs.
        clear ls_db_role.

        " check subsystem of role
        read table lt_child_roles
          with key agr_name = lr_agr_agrs->child_agr
          reference into lr_role_name.

        if sy-subrc = 0.
          " according to specification:
          " \\dwdf034\GBU-ST\IdentityAPI\Design\Role Handling.xls
          " In case CUA is active but roles are assigned locally
          " subsystem must be ignored

          if lv_use_system_name = if_identity=>co_true.
            if lr_role_name->subsystem is initial or
               lr_role_name->subsystem eq lv_cua_system.

              ls_db_role-mandt      = sy-mandt.                    " mandt
              ls_db_role-agr_name   = lr_agr_agrs->child_agr.      " role name
              ls_db_role-uname      = me->ms_segment_roles-bname.  " current user
              ls_db_role-from_dat   = lr_new_role->from_dat.       " date of collective role
              ls_db_role-to_dat     = lr_new_role->to_dat.         " date of collective role
              ls_db_role-col_flag   = 'X'.                         " collective role

              insert ls_db_role into table lt_db_role.
              " do not insert new role into role's ct_agr_users table
              " since this table is used in loop condition

            else.
              continue.
              " ignore roles with different system name
            endif.
          else.

            ls_db_role-mandt      = sy-mandt.                    " mandt
            ls_db_role-agr_name   = lr_agr_agrs->child_agr.      " role name
            ls_db_role-uname      = me->ms_segment_roles-bname.  " current user
            ls_db_role-from_dat   = lr_new_role->from_dat.       " date of collective role
            ls_db_role-to_dat     = lr_new_role->to_dat.         " date of collective role
            ls_db_role-col_flag   = 'X'.                         " collective role

            insert ls_db_role into table lt_db_role.
          endif.

          if et_parent_child_relationship is supplied.
            " insert found entries to parent_child_rel table
            insert lr_agr_agrs->* into table lt_parent_child_rel.
          endif.
        endif.
      endloop.
    endif.
  endloop.

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " --- Delete no longer valid child role assignments
  loop at ct_agr_users reference into lr_agr_users_handle
    where col_flag eq 'X'.

    lv_tabix = sy-tabix.

    read table lt_db_role
      with key  agr_name    = lr_agr_users_handle->agr_name
                uname       = lr_agr_users_handle->uname
                from_dat    = lr_agr_users_handle->from_dat
                to_dat      = lr_agr_users_handle->to_dat
                col_flag    = 'X'
      transporting no fields.
    if sy-subrc ne 0.
      " Delete notification is written later
      delete ct_agr_users index lv_tabix.
    endif.
  endloop.

  " ---  add content of temporary internal table ct_agr_Users
  loop at lt_db_role reference into lr_db_role.
    " Find table entry: entry may already exist since ct_agr_users
    " contains entries read from DB or there have been some calls
    " of set_roles before
    read table ct_agr_users
      with key  agr_name    = lr_db_role->agr_name
                uname       = lr_db_role->uname
                from_dat    = lr_db_role->from_dat
                to_dat      = lr_db_role->to_dat
      transporting no fields.

    " part of composite role already exists: continue
    " because timestamp of already set entries should not be overwritten
    if sy-subrc eq 0.
      continue.
    else.
      " check if old entry exists in actual-image: re-use old timestamp
      " of modification time and date
      read table me->ms_segment_roles-actual
        with key agr_name = lr_db_role->agr_name
                 uname    = lr_db_role->uname
                 from_dat = lr_db_role->from_dat
                 to_dat   = lr_db_role->to_dat
                 col_flag = lr_db_role->col_flag
                 org_flag = lr_db_role->org_flag
        reference into lr_assigned_role.

      if sy-subrc eq 0.
        " reuse old entry
        clear ls_agr_users_handle.
        move-corresponding lr_assigned_role->* to ls_agr_users_handle.
        insert ls_agr_users_handle into table ct_agr_users.
      else.
        " check if authority for new role is sufficient
        call method cl_suid_tools=>auth_check_single
          exporting
            iv_nodename  = if_identity_definition=>gc_node_role
            iv_operation = cl_suid_tools=>co_activity_create
            iv_class     = lv_class
            iv_role      = lr_db_role->agr_name
            iv_bname     = lr_db_role->uname
          importing
            es_msg       = lv_msg_data.

        clear lv_msg_key_value.
        concatenate lr_db_role->agr_name lr_db_role->from_dat lr_db_role->to_dat
               into lv_msg_key_value respecting blanks.

        if lv_msg_data-msgty ne 'E'.
          insert lr_db_role->* into table ct_agr_users.

          " handle notification mode:
          call method me->go_notify->notify_create
            exporting
              iv_bname    = ms_segment_roles-bname
              iv_nodename = if_identity_definition=>gc_node_role
              iv_key      = lv_msg_key_value.
        else.
          " not authorized
          if 1 = 0. message e639(01) with lr_db_role->agr_name lv_class. endif. "#EC *

          call method me->go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = lr_db_role->uname
              iv_nodename = if_identity_definition=>gc_node_role
              iv_key      = lv_msg_key_value
              iv_field    = if_identity_definition=>gc_field_role_agr_name
              iv_lifetime = if_suid_msg_buffer=>co_lifetime_once
              is_msg      = lv_msg_data.

          call method me->go_notify->notify_failed_create
            exporting
              iv_bname    = ms_segment_roles-bname
              iv_nodename = if_identity_definition=>gc_node_role
              iv_key      = lv_msg_key_value.
        endif.
      endif.
    endif.
  endloop.

  et_parent_child_relationship = lt_parent_child_rel.

endmethod.


method roles_merge_to_result.

  data: lv_msg_key_value         type          string
      , lv_msg_data              type          symsg
      , lr_agr_users             type ref to   agr_users
      , lr_node_role             type ref to   suid_st_node_role
      , lt_assigned_roles        type          suid_tt_agr_users
      , lr_assigned_roles        type ref to   agr_users
      , ls_assigned_roles        type          agr_users
      , lv_tabix                 type          sy-tabix
      , lv_insert_tabix          type          sy-tabix
      , lv_key_handle            type          suid_node_key_handle
      , lv_org_flag              type          agr_org
      , lv_col_flag              type          agr_col
      , lv_calculate_new         type          sesf_boolean
      .

  " all entries are verified already: existence is checked, dates and intervals are valid


  " -- Get current assigned roles
  lt_assigned_roles = me->ms_segment_roles-actual.
  sort lt_assigned_roles by agr_name uname from_dat to_dat col_flag org_flag.

  " Collective role resolving?
  if iv_do_role_resolving eq if_identity=>co_true.
    lv_calculate_new = if_identity=>co_true.
  else.
    lv_calculate_new = if_identity=>co_false.
  endif.

  " --- delete entries ------------
  loop at ct_update_role_nodes reference into lr_node_role
    where change_mode     eq if_identity=>co_delete
      and agr_assign_type ne 'C'.

    lv_calculate_new = if_identity=>co_true.

    " handling of col_flag and org_flag
    case lr_node_role->agr_assign_type.
      when space.
        lv_org_flag = space.
        lv_col_flag = space.
      when 'X'.
        lv_org_flag = 'X'.
        lv_col_flag = space.
      when 'C'.
        lv_org_flag = space.
        lv_col_flag = 'X'.
      when others.
        lv_org_flag = lr_node_role->agr_assign_type.
        lv_col_flag = space.
    endcase.

    read table lt_assigned_roles
      with key agr_name = lr_node_role->agr_name
               uname    = ms_manager-bname
               from_dat = lr_node_role->from_dat
               to_dat   = lr_node_role->to_dat
               col_flag = lv_col_flag
               org_flag = lv_org_flag
      binary search
      transporting no fields.

    lv_tabix = sy-tabix.

    if sy-subrc eq 0.
      " Authority Check is done in check_roles_internal
      clear: lv_msg_key_value.

      concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      call method me->go_notify->notify_delete
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle.

      delete lt_assigned_roles index lv_tabix.
    else.
      " Ignore this entry: Change failed
      clear: lr_node_role->change_mode.
    endif.
  endloop.

  " -- Calcutale current assigned child roles --
  if lv_calculate_new     eq if_identity=>co_true.
    " get elements of composite role
    call method me->roles_get_collection_elements
      changing
        ct_agr_users = lt_assigned_roles.

    " Current assigned roles (incl. child roles)
    sort lt_assigned_roles by agr_name uname from_dat to_dat col_flag org_flag.
  endif.


  " --- update entries ------------
  lv_calculate_new = if_identity=>co_false.
  loop at ct_update_role_nodes reference into lr_node_role
    where change_mode     eq if_identity=>co_update
      and agr_assign_type ne 'C'.

    lv_calculate_new = if_identity=>co_true.

    "  handling of col_flag and org_flag
    case lr_node_role->agr_assign_type.
      when space.
        lv_org_flag = space.
        lv_col_flag = space.
      when 'X'.
        lv_org_flag = 'X'.
        lv_col_flag = space.
      when 'C'.
        lv_org_flag = space.
        lv_col_flag = 'X'.
      when others.
        lv_org_flag = lr_node_role->agr_assign_type.
        lv_col_flag = space.
    endcase.

    read table lt_assigned_roles
      with key agr_name = lr_node_role->agr_name
               uname    = ms_manager-bname
               from_dat = lr_node_role->from_dat
               to_dat   = lr_node_role->to_dat
               org_flag = lv_org_flag
               col_flag = lv_col_flag
      binary search
      reference into lr_assigned_roles.

    if sy-subrc ne 0.
      " MSG: Die Rolle & existiert nicht.
      if 1 = 0. message e410(s#) with lr_node_role->agr_name. endif.
      clear: lv_msg_data, lv_msg_key_value.

      concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      lv_msg_data-msgty   = 'E'.
      lv_msg_data-msgid   = 'S#'.
      lv_msg_data-msgno   = '410'.
      lv_msg_data-msgv1   = lr_node_role->agr_name.

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " Keep line: Change failed
      clear: lr_node_role->change_mode.
      continue.
    endif.

    " Ignore update if from_dat and to_dat do not change
    if lr_node_role->from_dat eq lr_node_role->update_from_dat and
       lr_node_role->to_dat   eq lr_node_role->update_to_dat.
      clear: lr_node_role->change_mode.
      continue.
    endif.

    " Check: Insert possible?
    read table lt_assigned_roles
      with key agr_name = lr_node_role->agr_name
               uname    = ms_manager-bname
               from_dat = lr_node_role->update_from_dat
               to_dat   = lr_node_role->update_to_dat
      binary search
      transporting no fields.
    if sy-subrc eq 0.
      " MSG: Die Rolle &1 ist bereits zugeordnet
      if 1 = 0. message e060(suid01) with lr_node_role->agr_name. endif.
      clear: lv_msg_data, lv_msg_key_value.

      concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
             into lv_msg_key_value respecting blanks.

      lv_msg_data-msgty   = 'E'.
      lv_msg_data-msgid   = 'SUID01'.
      lv_msg_data-msgno   = '060'.
      lv_msg_data-msgv1   = lr_node_role->agr_name.

      call method me->go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname      = ms_manager-bname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lr_node_role->key_handle
          iv_field      = if_identity_definition=>gc_field_role_agr_name
          iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
          is_msg        = lv_msg_data.

      " Keep line: Change failed
      clear: lr_node_role->change_mode.
      continue.
    endif.

    " Update role - Authority Check is done in check_roles_internal
    clear: lv_msg_key_value.

    " Write notification with old key!
    concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
           into lv_msg_key_value respecting blanks.

    call method me->go_notify->notify_update
      exporting
        iv_bname      = ms_manager-bname
        iv_nodename   = if_identity_definition=>gc_node_role
        iv_key        = lv_msg_key_value
        iv_key_handle = lr_node_role->key_handle.

    " Key Exchange
    lr_node_role->from_dat        = lr_node_role->update_from_dat.
    lr_node_role->to_dat          = lr_node_role->update_to_dat.

    lr_assigned_roles->from_dat   = lr_node_role->update_from_dat. " update from_dat
    lr_assigned_roles->to_dat     = lr_node_role->update_to_dat.   " update to_dat
    clear: lr_assigned_roles->change_dat
         , lr_assigned_roles->change_tim
         , lr_assigned_roles->change_tst
         , lr_assigned_roles->exclude
         .
    " Modify key -> Sort
    sort lt_assigned_roles by agr_name uname from_dat to_dat col_flag org_flag.
  endloop.

  " -- Calcutale current assigned child roles --
  if lv_calculate_new = if_identity=>co_true.
    " get elements of composite role
    call method me->roles_get_collection_elements
      changing
        ct_agr_users = lt_assigned_roles.

    " Current assigned roles (incl. child roles)
    sort lt_assigned_roles by agr_name uname from_dat to_dat col_flag org_flag.
  endif.

  " --- insert entries ------------
  lv_calculate_new = if_identity=>co_false.
  loop at ct_update_role_nodes reference into lr_node_role
    where change_mode     eq if_identity=>co_insert
      and agr_assign_type ne 'C'.

    lv_calculate_new = if_identity=>co_true.

    " handling of col_flag and org_flag
    case lr_node_role->agr_assign_type.
      when space.
        lv_org_flag = space.
        lv_col_flag = space.
      when 'X'.
        lv_org_flag = 'X'.
        lv_col_flag = space.
      when 'C'.
        lv_org_flag = space.
        lv_col_flag = 'X'.
      when others.
        lv_org_flag = lr_node_role->agr_assign_type.
        lv_col_flag = space.
    endcase.

    " Check: Insert possible?
    read table lt_assigned_roles
      reference into lr_assigned_roles
      with key agr_name = lr_node_role->agr_name
               uname    = ms_manager-bname
               from_dat = lr_node_role->from_dat
               to_dat   = lr_node_role->to_dat
      binary search.

    lv_insert_tabix = sy-tabix.

    if sy-subrc eq 0.
      if gv_idoc_processing            eq if_identity=>co_true and
         lr_node_role->agr_assign_type eq space                and
         lr_assigned_roles->col_flag   eq 'X'.

        " Direct assignment overwrites child assignment -> Update role
        lr_assigned_roles->org_flag = lv_org_flag.
        lr_assigned_roles->col_flag = lv_col_flag.
        clear: lr_assigned_roles->change_dat
             , lr_assigned_roles->change_tim
             , lr_assigned_roles->change_tst
             , lr_assigned_roles->exclude
             .

        " Write notification
        concatenate lr_assigned_roles->agr_name lr_assigned_roles->from_dat lr_assigned_roles->to_dat
               into lv_msg_key_value respecting blanks.

        call method me->go_notify->notify_update
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle.

        continue.
      else.
        " MSG: Die Rolle &1 ist bereits zugeordnet
        if 1 = 0. message e060(suid01) with lr_node_role->agr_name. endif.
        clear: lv_msg_data, lv_msg_key_value.

        concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
               into lv_msg_key_value respecting blanks.

        lv_msg_data-msgty   = 'E'.
        lv_msg_data-msgid   = 'SUID01'.
        lv_msg_data-msgno   = '060'.
        lv_msg_data-msgv1   = lr_node_role->agr_name.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle
            iv_field      = if_identity_definition=>gc_field_role_agr_name
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            is_msg        = lv_msg_data.

        call method me->go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_node_role->key_handle.

        " Keep line: Insert failed
        lr_node_role->change_mode = if_identity=>co_failed_create.
        continue.
      endif.
    endif.

    " Insert role - Authority Check is done in check_roles_internal
    clear: lv_msg_key_value.

    concatenate lr_node_role->agr_name lr_node_role->from_dat lr_node_role->to_dat
           into lv_msg_key_value respecting blanks.

    clear ls_assigned_roles.
    ls_assigned_roles-mandt     = sy-mandt.                  " set mandt
    ls_assigned_roles-agr_name  = lr_node_role->agr_name.    " set agr_name
    ls_assigned_roles-uname     = ms_manager-bname.          " set uname
    ls_assigned_roles-from_dat  = lr_node_role->from_dat.    " set from_dat
    ls_assigned_roles-to_dat    = lr_node_role->to_dat.      " set to_dat
    ls_assigned_roles-org_flag  = lv_org_flag.               " set org_flag
    ls_assigned_roles-col_flag  = lv_col_flag.               " set col_flag

    insert ls_assigned_roles into lt_assigned_roles index lv_insert_tabix.

    call method me->go_notify->notify_create
      exporting
        iv_bname      = ms_manager-bname
        iv_nodename   = if_identity_definition=>gc_node_role
        iv_key        = lv_msg_key_value
        iv_key_handle = lr_node_role->key_handle.
  endloop.

  " -- Calcutale current assigned child roles --
  if lv_calculate_new eq if_identity=>co_true.
    " get elements of composite role
    call method me->roles_get_collection_elements
      changing
        ct_agr_users = lt_assigned_roles.
    sort lt_assigned_roles by agr_name uname from_dat to_dat col_flag org_flag.
  endif.


  " send notification for child roles which are not assigned anymore
  loop at me->ms_segment_roles-actual reference into lr_agr_users
    where col_flag eq 'X'.

    read table lt_assigned_roles
      with key agr_name    = lr_agr_users->agr_name
               uname       = lr_agr_users->uname
               from_dat    = lr_agr_users->from_dat
               to_dat      = lr_agr_users->to_dat
      binary search
      transporting no fields.

    " child role is still part of composite role: continue
    if sy-subrc eq 0.
      continue.
    else.
      clear lv_msg_key_value.
      concatenate lr_agr_users->agr_name lr_agr_users->from_dat lr_agr_users->to_dat
             into lv_msg_key_value respecting blanks.

      call method me->go_notify->notify_delete
        exporting
          iv_bname      = lr_agr_users->uname
          iv_nodename   = if_identity_definition=>gc_node_role
          iv_key        = lv_msg_key_value
          iv_key_handle = lv_key_handle.
    endif.
  endloop.

  et_agr_users = lt_assigned_roles.

endmethod.


method roles_set.
*  importing IT_ROLES TYPE SUID_TT_ROLE_ASSIGNMENT
*  changing: ET_RETURN TYPE BAPIRETTAB

* Algorithm: (like prgn_profiles_for_userprof)
*
*  check_roles_internal:
*   - delete entries with empty role names
*   - verification of from_dat and to_dat
*   - check if interval [from_dat, to_dat] is valid
*   - invalid values of change_mode are ignored.
*   - existence check of roles
*   - eliminate duplicate input entries
*
*  roles_merge_to_result:
*  - et_agr_user: Importing table with Key handle
*  - Send notification for deleted child roles only if children are not in result set anymore
*
*  roles_write_to_segment
*

  data: lr_node_role              type ref to   suid_st_node_role
      , lv_msg_data               type          symsg
      , lv_class                  type          xuclass
      , lv_tabix                  type          sy-tabix
      , lt_role_result            type          suid_tt_agr_users
      .

* Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  clear: et_node_roles.

  " Initial check
  if iv_permit eq if_identity=>co_false.
    call method checks_before_access
      exporting
        iv_method      = 'S'
        iv_change_node = if_identity_definition=>gc_node_role
      importing
        es_msg         = lv_msg_data.

    if lv_msg_data-msgty eq 'E'.
      " Return to caller if not authorized
      return.
    endif.
  endif.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_role.

  " Delete all message belonging to this node type
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_role.


  " set_roles does not allow to set ORG_FLAG. Therefore check ct_roles table
  " if org_flag is set: ignore records which have ORG_FLAG set
  " Indirect role assignments (Type 'C') are ignored, but not deleted
  if iv_set_extended eq space.
    delete ct_roles where agr_assign_type eq 'X'.
  endif.

  " get logon->group information in order to call authority check
  call method me->get_class
    exporting
      iv_for_auth = if_identity=>co_true
    importing
      ev_class    = lv_class.

  " check buffer
  if ms_segment_roles-bname is initial.
    call method fetch_segment_roles.
    if ms_segment_roles-bname is initial.
      raise exception
        type
        cx_suid_identity
        exporting
          textid = cx_suid_identity=>internal_error
          bname  = ms_manager-bname.
    endif.
  endif.

  " validate input
  call method cl_identity=>check_roles_internal
    exporting
      io_msg_buffer = go_msg_buffer
      iv_bname      = ms_manager-bname
      iv_class      = lv_class
      io_notify     = go_notify
      iv_permit     = iv_permit
    changing
      ct_roles      = ct_roles.

  " remember Importing table: key_handle
  loop at ct_roles reference into lr_node_role.
    lv_tabix = sy-tabix.
    if lr_node_role->change_mode is initial or
       lr_node_role->change_mode eq if_identity=>co_failed_create.
      append lr_node_role->* to et_node_roles.
      delete ct_roles index lv_tabix.
    endif.
  endloop.

  " -- merge with internal buffer
  call method me->roles_merge_to_result
    exporting
      iv_do_role_resolving = iv_do_role_resolving
    importing
      et_agr_users         = lt_role_result
    changing
      ct_update_role_nodes = ct_roles.

  " remember Importing table: key_handle
  append lines of ct_roles to et_node_roles.

  " Check output table - set D-Flag if necessary
  loop at et_node_roles reference into lr_node_role
    where agr_assign_type eq 'C'.

    read table lt_role_result
      with key agr_name    = lr_node_role->agr_name
               uname       = ms_manager-bname
               from_dat    = lr_node_role->from_dat
               to_dat      = lr_node_role->to_dat
      binary search
      transporting no fields.

    if sy-subrc ne 0.
      lr_node_role->change_mode = if_identity=>co_delete.
    endif.
  endloop.


  " -- write new roles into segments
  call method me->roles_write_to_segment
    exporting
      it_user_roles             = lt_role_result
      iv_check_compare_profiles = iv_check_compare_profiles
      iv_permit                 = iv_permit
      iv_do_compare_profiles    = iv_do_compare_profiles.


endmethod.


method roles_set_internal.

  data: lt_roles                    type          suid_tt_node_roles
      , lv_cua_master               type          uszbvlndsc-sendsystem
      , lv_no_maintain              type          sesf_boolean value if_identity=>co_false
      , lv_invalid                  type          sesf_boolean value if_identity=>co_true
      , lt_assigned_systems         type          suid_tt_node_cua_systems
      , ls_new_system               type          suid_st_node_cua_system
      , lt_new_systems              type          suid_tt_node_cua_systems
      , lt_error_systems            type          tt_error_systems
      , lt_node_roles_failed        type          suid_tt_node_roles
      , ls_role                     type          suid_st_node_role
      , lr_role                     type ref to   suid_st_node_role
      , lt_node_cua_roles	          type          suid_tt_node_cua_roles
      , lt_cua_roles                type          suid_tt_node_cua_roles
      , ls_cua_role                 type          suid_st_node_cua_role
      , lr_cua_role                 type ref to   suid_st_node_cua_role
      , lv_tabix                    type          sy-tabix
      , lv_msg_key_value            type          string
      , ls_msg                      type          symsg
      .


* initialize export parameter
  eo_msg_buffer   = go_msg_buffer.
  eo_notify       = go_notify.

  " check if node can be maintained
  call method me->roles_validate_cua_master
    exporting
      iv_bname            = ms_manager-bname
      iv_node_name        = if_identity_definition=>gc_node_role
    importing
      ev_cua_master       = lv_cua_master
      ev_no_maintain_node = lv_invalid.

  " HR assignments can be maintained in any case
  if iv_set_extended eq if_identity=>co_false.
    " Node can't be maintained: do not proceed
    if lv_invalid eq if_identity=>co_true and lv_cua_master is initial.
      " message is already written by check_field_maintain into message buffer
      return.
    endif.
  endif.

  lt_roles = it_roles.

  " In central system: Call CUA method
  " else: call local method
  if lv_cua_master is not initial.
    " Global or local assignment
    call method cua_if_field_no_maintain
      exporting
        iv_node_name   = if_identity_definition=>gc_node_cua_role
      receiving
        rv_no_maintain = lv_no_maintain.

    if lv_no_maintain eq if_identity=>co_false.
      " --- Global role assignment ---
      loop at lt_roles reference into lr_role.
        ls_cua_role-subsystem = lv_cua_master.
        move-corresponding lr_role->* to ls_cua_role.
        append ls_cua_role to lt_cua_roles.
      endloop.

      call method me->roles_cua_set_internal
        exporting
          iv_check_compare_profiles = iv_check_compare_profiles
          iv_do_compare_profiles    = iv_do_compare_profiles
          iv_set_extended           = iv_set_extended
          iv_do_role_resolving      = iv_do_role_resolving
          it_roles                  = lt_cua_roles
        importing
          eo_msg_buffer             = eo_msg_buffer
          eo_notify                 = eo_notify
          et_node_cua_roles         = lt_node_cua_roles.

      " Importing table + keyhandle
      loop at lt_node_cua_roles reference into lr_cua_role
        where subsystem eq lv_cua_master.
        move-corresponding lr_cua_role->* to ls_role.
        append ls_role to et_node_roles.
      endloop.

      " Exhange CUA node information
      me->go_msg_buffer->exchange_cua_nodes( exporting iv_bname = ms_manager-bname ).
      me->go_notify->exchange_cua_nodes( exporting iv_bname = ms_manager-bname ).

    else.
      " --- Local role assignment in central system ---
      " Check if central system must be assigned
      read table lt_roles with key change_mode = if_identity=>co_insert
           transporting no fields.
      if sy-subrc eq 0.
        " get cua_systems without checking authority
        call method me->get_cua_systems
          exporting
            iv_get_text    = if_identity=>co_false
          importing
            et_cua_systems = lt_assigned_systems.

        read table lt_assigned_systems with key subsystem = lv_cua_master
             transporting no fields.
        if sy-subrc ne 0.
          clear ls_new_system.
          ls_new_system-subsystem   = lv_cua_master.
          ls_new_system-change_mode = if_identity=>co_insert.
          insert ls_new_system into table lt_new_systems.

          call method me->cua_set_syst_assignment
            importing
              et_error_systems  = lt_error_systems
            changing
              ct_assign_systems = lt_new_systems.
        endif.

        " Write error message
        if lt_error_systems is not initial.
          loop at lt_roles reference into lr_role
            where change_mode eq if_identity=>co_insert.

            lv_tabix         = sy-tabix.

            " Keep line: Insert failed
            lr_role->change_mode = if_identity=>co_failed_create.
            append lr_role->* to lt_node_roles_failed.
            delete lt_roles index lv_tabix.
          endloop.
        endif.
      endif.

      " Call set_roles anyway
      call method me->roles_set
        exporting
          iv_check_compare_profiles = iv_check_compare_profiles
          iv_do_compare_profiles    = iv_do_compare_profiles
          iv_set_extended           = iv_set_extended
          iv_do_role_resolving      = iv_do_role_resolving
        importing
          eo_msg_buffer             = eo_msg_buffer
          eo_notify                 = eo_notify
          et_node_roles             = et_node_roles
        changing
          ct_roles                  = lt_roles.

      " Append error messages
      loop at lt_node_roles_failed reference into lr_role.
        concatenate lr_role->agr_name lr_role->from_dat lr_role->to_dat
               into lv_msg_key_value respecting blanks.

        " Keine Berechtigung zur Zuordnung des Systems &1 (Rolle &2)
        if 1 = 0. message e574(01) with space space. endif. "#EC *
        clear: ls_msg.
        ls_msg-msgty = 'E'.
        ls_msg-msgid = '01'.
        ls_msg-msgno = '574'.
        ls_msg-msgv1 = lv_cua_master.
        ls_msg-msgv2 = lr_role->agr_name.

        call method me->go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_lifetime   = if_suid_msg_buffer=>co_lifetime_once
            iv_key_handle = lr_role->key_handle
            iv_field      = if_identity_definition=>gc_field_role_agr_name
            is_msg        = ls_msg.

        call method me->go_notify->notify_failed_create
          exporting
            iv_bname      = ms_manager-bname
            iv_nodename   = if_identity_definition=>gc_node_role
            iv_key        = lv_msg_key_value
            iv_key_handle = lr_role->key_handle.
      endloop.
      append lines of lt_node_roles_failed to et_node_roles.
    endif.

  else.
    " --- Local role assignment ---
    " Without CUA, IDOC processing, target system with local role assignment
    call method me->roles_set
      exporting
        iv_check_compare_profiles = iv_check_compare_profiles
        iv_do_compare_profiles    = iv_do_compare_profiles
        iv_set_extended           = iv_set_extended
        iv_do_role_resolving      = iv_do_role_resolving
      importing
        eo_msg_buffer             = eo_msg_buffer
        eo_notify                 = eo_notify
        et_node_roles             = et_node_roles
      changing
        ct_roles                  = lt_roles.
  endif.

endmethod.


METHOD roles_validate_cua_context.

  DATA: lv_msg_key_value            TYPE  string.
  DATA: lv_msg_data                 TYPE  symsg.
*  DATA: lv_no_maintain              TYPE  fieldmaint.
  DATA: lv_logsys                   TYPE  t000-logsys.
*  DATA: ls_field_filter             TYPE  suid_st_cua_filters.
  DATA: lv_no_maintain_node         TYPE sesf_boolean.

* initialize return value
  ev_valid = if_identity=>co_false.
  eo_msg_buffer = go_msg_buffer.

* Delete lifetime_once messages  belonging to this node
  CALL METHOD go_msg_buffer->delete_object_message
    EXPORTING
      iv_bname             = iv_bname
      iv_nodename          = iv_node_name
      iv_lifetimeonce_only = if_identity=>co_true.

* read values of CUA landscape in order to
*   check if this is the central system
*   check if cua is active

  IF gv_cua_active EQ if_identity=>co_false.
*   Get logical name of actual system
    CALL METHOD cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
      IMPORTING
        ev_system_logsys = lv_logsys.

*   MSG: Das System &1 ist nicht Teil der Zentralen Benutzerpflege
    IF 1 = 0. MESSAGE e381(01) WITH lv_logsys. ENDIF.
    CLEAR: lv_msg_data.
    lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
    lv_msg_data-msgid = '01'.
    lv_msg_data-msgno = '381'.
    lv_msg_data-msgv1 = lv_logsys.

    lv_msg_key_value = iv_bname.

    CALL METHOD go_msg_buffer->add_object_message_symsg
      EXPORTING
        iv_bname    = iv_bname
        iv_nodename = iv_node_name
        iv_key      = lv_msg_key_value
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent
        is_msg      = lv_msg_data.

    RETURN.

  ENDIF.

  IF gv_cua_central EQ if_identity=>co_false.

*   Sie sind nicht auf dem Zentralsystem angemeldet
    IF 1 = 0. MESSAGE e351(01) . ENDIF.                     "or i311
    CLEAR: lv_msg_data.
    lv_msg_data-msgty = if_suid_msg_buffer=>co_type_error.
    lv_msg_data-msgid = '01'.
    lv_msg_data-msgno = '351'.

    lv_msg_key_value = iv_bname.

    CALL METHOD go_msg_buffer->add_object_message_symsg
      EXPORTING
        iv_bname    = iv_bname
        iv_nodename = iv_node_name
        iv_key      = lv_msg_key_value
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent
        is_msg      = lv_msg_data.

    RETURN.

  ENDIF.


* check if node can be maintained
  cua_if_field_no_maintain(
    EXPORTING
      iv_node_name   = iv_node_name
      io_msg_buffer  = go_msg_buffer
    RECEIVING
      rv_no_maintain = lv_no_maintain_node ).

  IF lv_no_maintain_node = if_identity=>co_false.
    ev_valid = if_identity=>co_true.
  ELSE.
    ev_valid = if_identity=>co_false.
*     message is already added by cua_if_field_no_maintain
  ENDIF.

ENDMETHOD.


method roles_validate_cua_master.


  " initialize exporting parameter:
  clear: ev_cua_master, ev_no_maintain_node.

  " Delete lifetime_once messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = iv_bname
      iv_nodename          = iv_node_name
      iv_lifetimeonce_only = if_identity=>co_true.

  " Check :
  " 1.) check if this is CUA master system
  " 2.) check if roles can be maintained

                                                            " 1.)
  " read global values of CUA landscape in order to
  " check if CUA is active and if this is the central system
  if gv_cua_central eq if_identity=>co_true.
    " only initialize in case node can be maintained.
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
      importing
        ev_central_logsys = ev_cua_master.
  endif.

  " 2.) check if node can be maintained
  call method cua_if_field_no_maintain
    exporting
      iv_node_name   = iv_node_name
      io_msg_buffer  = go_msg_buffer
    receiving
      rv_no_maintain = ev_no_maintain_node.

endmethod.


method roles_write_to_segment.

  data: lv_error                  type          sesf_boolean
      , lt_user_profile           type          suid_tt_usprof
      , lv_property_value         type          prgn_cust-path
      , lv_msg_key_value          type          string
      , lv_msg_data               type          symsg
      .

  " check buffer
  if ms_segment_roles-bname is initial.
    call method fetch_segment_roles.
  endif.


  me->ms_segment_roles-actual = it_user_roles.

  " -- Transaction handling
  " Only set transaction status if there have been changes
  if me->ms_segment_roles-actual ne me->ms_segment_roles-before_image.

    " New transaction status: UNCHECKED
    me->ms_manager-status = go_persistence->co_ta_status_unchecked.

    " Check status:
    call method go_msg_buffer->find_error_for_node
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_role
      receiving
        ev_error    = lv_error.

    if lv_error eq if_identity=>co_false.
      " New node status: CHECKED
      ms_manager-sn_roles = go_persistence->co_node_status_checked.
    else.
      " New node status: CHANGED
      ms_manager-sn_roles = go_persistence->co_node_status_changed.
    endif.
    " Set segment change flag for DB
    me->ms_segment_roles-status = go_persistence->co_seg_changed.
  else.
    " in case actual and before_image are identical: set segment
    " status to unchanged.
    clear: me->ms_segment_roles-status, ms_manager-sn_roles.
  endif.


  " if no permanent errors have been reported until now go ahead
  " and check if profiles have to be adjusted.
  if ms_manager-sn_roles ne go_persistence->co_node_status_changed.
    " ---  check customizing flag per default ---
    " however there are use cases like TXN PFUD which adjusts profiles
    " in a separate step
    if iv_check_compare_profiles eq if_identity=>co_true or
       iv_do_compare_profiles    eq if_identity=>co_true.

      if iv_do_compare_profiles  eq if_identity=>co_true.
        " Do profile comparison in any case (deletion of system assignments)
        lv_property_value = 'YES'.
      else.
        " Automatic comparison of user profiles is done if
        " PRGN_CUST AUTO_USERCOMPARE=YES
        call method cl_suid_tools=>get_customizing_property
          exporting
            iv_property_name  = cl_suid_tools=>co_prgn_cust_auto_usercompare
          importing
            ev_property_value = lv_property_value.
      endif.

      if lv_property_value eq 'YES'.
        " adjust profile
        call method me->profile_adjust
          exporting
            it_roles        = it_user_roles
            iv_permit       = iv_permit
          importing
            et_user_profile = lt_user_profile.

        " write new profiles into segments
        call method me->profile_write_to_segment
          exporting
            it_user_profile = lt_user_profile.

      else.
        " Der Benutzerstammabgleich ist global abgeschaltet. (siehe Langtext)
        if 1 = 0. message s858(01). endif.                  "#EC *
        clear: lv_msg_data, lv_msg_key_value.
        lv_msg_data-msgty = if_suid_msg_buffer=>co_type_success.
        lv_msg_data-msgid = '01'.
        lv_msg_data-msgno = '858'.
        lv_msg_data-msgv1 = ms_manager-bname.
        lv_msg_data-msgv2 = 'PRGN_CUST'.
        lv_msg_data-msgv3 = 'AUTO_USERCOMPARE=NO'.
        lv_msg_key_value  = ms_manager-bname.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_role
            iv_key      = lv_msg_key_value
            iv_field    = if_identity_definition=>gc_field_role_uname
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once_trx
            is_msg      = lv_msg_data.
      endif.
    endif.
  endif.


endmethod.


method save.
*
* Perform preparation of segments, then call MODIFY persistence method

* Messages:
*   S039(01): User & has changed
*   S102(01): User & created
*   S226(01): User & was saved
*   S232(01): User & deleted
*   S245(01): User & locked
*   S316(01): umber of users changed: &

  data: lr_control                   type ref to ty_control
      , ls_timestamp                 type        ty_timestamp
      , lt_segment_header            type        suid_tt_segment_header
      , lr_segment_header            type ref to suid_st_segment_header
      , lt_segment_header_hist       type        suid_tt_segment_header_hist
      , lt_segment_auditlog          type        suid_tt_segment_auditlog
      , lt_segment_stamp             type        suid_tt_segment_stamp
      , lt_segment_refuser           type        suid_tt_segment_refuser
      , lt_segment_roles             type        suid_tt_segment_roles
      , lr_segment_role              type ref to suid_st_segment_roles
      , lt_segment_defaults          type        suid_tt_segment_defaults
      , lt_segment_address           type        suid_tt_segment_address
      , lt_office_user               type        bcst_adrchg
      , ls_office_user               type        bcss_adrchg
      , lo_addr_main                 type ref to cl_addr_main
      , lt_address_id                type        addrt_address_id
      , lt_segment_snc               type        suid_tt_segment_snc
      , lt_segment_profiles          type        suid_tt_segment_profiles_t04
      , lt_segment_profiles_usr04    type        suid_tt_segment_profiles_r04
      , lt_segment_profiles_ush04    type        suid_tt_segment_profiles_r04_h
      , lt_segment_parameter         type        suid_tt_segment_parameter
      , lr_segment_parameter         type ref to suid_st_segment_parameter
      , lr_parameter                 type ref to usr05
      , lt_segment_groups            type        suid_tt_segment_groups
      , lr_segment_groups            type ref to suid_st_segment_groups
      , lt_segment_uclass            type        suid_tt_segment_uclass
      , lt_segment_certmap           type        suid_tt_segment_certmap
      , lt_segment_dbms_user         type        suid_tt_segment_dbms_user
      , lt_segment_docu              type        suid_tt_segment_docu
      , lt_segment_cua_uclasses      type        suid_tt_segment_cua_uclasses
      , lt_segment_pwdhistory        type        suid_tt_segment_pwdhistory
      , lt_segment_cua_systems       type        suid_tt_segment_cua_systems
      , lr_segment_cua_systems       type ref to suid_st_segment_cua_systems
      , lt_segment_cua_user_prot     type        suid_tt_segment_cua_user_prot
      , lt_cua_user_syst_distr       type        tt_cua_user_syst_distr
      , lt_cua_users_syst_distr      type        tt_cua_user_syst_distr
      , lt_segment_cua_roles         type        suid_tt_segment_cua_roles
      , lr_segment_cua_roles         type ref to suid_st_segment_cua_roles
      , lt_users_easy_access_copy    type        suid_tt_bname_copy
      , lt_users_easy_access_delete  type        suid_tt_bname
      , ls_msg                       type        symsg
      , lt_cua_filters               type        suid_tt_cua_filters
      , lv_back_distr                type        c
      , lt_segment_cua_profiles      type        suid_tt_segment_cua_profiles
      , lv_bp_rejected               type        boole_d
      , lt_bup_msg                   type        cmd_t_msg_complete
      , lr_bup_msg                   type ref to cmd_s_msg_complete
      , lv_lifetime                  type        if_suid_msg_buffer=>ty_msg_lifetime
      , lv_save_bp                   type        sesf_boolean
      , lv_save_personalization      type        sesf_boolean
      , lv_save_applrefs             type        sesf_boolean
      , lv_changed_segment_counter   type        i value 0
      , lv_trx_with_bp               type        char01
      , lr_segment_profile           type ref to suid_st_segment_profiles_t04
      , ls_segment_usr04             type        suid_st_segment_profiles_r04
      , ls_segment_ush04             type        suid_st_segment_profiles_r04_h
      , lo_badi_identity_update      type ref to cl_badi_base  "BADI_IDENTITY_UPDATE
      , lv_num_badi                  type        i
      , ls_badi_identity_update      type        suid_st_badi_identity
      , lt_badi_identity_update      type        suid_tt_badi_identity
      , lr_badi_identity_update      type ref to suid_st_badi_identity
      , ls_badi_identity_cua_systems type        suid_st_badi_cua_systems
      , lt_badi_identity_cua_systems type        suid_tt_badi_cua_systems
      , ls_badi_identity_cua_roles   type        suid_st_badi_cua_roles
      , lt_badi_identity_cua_roles   type        suid_tt_badi_cua_roles
      , ls_badi_identity_roles       type        suid_st_badi_roles
      , lt_badi_identity_roles       type        suid_tt_badi_roles
      , ls_badi_identity_groups      type        suid_st_badi_groups
      , lt_badi_identity_groups      type        suid_tt_badi_groups
      , lt_badi_message              type        suid_tt_badi_message
      , lr_badi_message              type ref to suid_st_badi_message
      , lt_badi_filter               type        badi_filter_bindings
      , ls_badi_filter               type        badi_filter_binding
      , lt_users_not_changed         type        suid_tt_bname
      , ls_users_not_changed         type        suid_st_bname
      , lr_segment_cua_profile       type ref to suid_st_segment_cua_profiles
      , lt_deleted_users             type        spers_ulst
      , lv_bor_objkey                type        sibfinstid
      , lv_bor_event                 type        sibfevent
      , lr_bor_parameter             type ref to if_swf_ifs_parameter_container
      .

* Set exporting parameter
  ev_rejected   = if_identity=>co_false.
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


* Set timestamp

  ls_timestamp = gs_timestamp_finalize.

* --- Prepare saving ------------------------------------------------
*
* All modified instances must have the status FINALIZED
*
  loop at gt_control reference into lr_control
       where idref->ms_manager-status eq go_persistence->co_ta_status_finalized and
             idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    " Identity is created, modified or deleted:
    if lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_create or
       lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_modify or
       lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete.

      " --- initialize changed segments counter
      lv_changed_segment_counter = 0.

      " --- Check Early Watch Client and Upgrade Process ------------------------*
      "     no address and application calls
      if gv_earlywatchclient     eq if_identity=>co_false and
         gv_upg_is_shadow_system eq if_identity=>co_false.

        " Check if personalization was changed
        if lr_control->idref->ms_manager-flg_pers_modified = go_persistence->co_flag_active.
          lv_save_personalization = if_identity=>co_true.
          lv_changed_segment_counter = lv_changed_segment_counter + 1.
        endif.

        " Check if appl. references were changed
        if lr_control->idref->ms_manager-flg_appref_modified = go_persistence->co_flag_active.
          lv_save_applrefs = if_identity=>co_true.
          lv_changed_segment_counter = lv_changed_segment_counter + 1.
        endif.

        " Check if SAP Easy Access Menu is involved
        if lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete.
          append lr_control->idref->ms_manager-bname to lt_users_easy_access_delete.
          lv_changed_segment_counter = lv_changed_segment_counter + 1.
        else.
          " If user is copied with SAP Easy Access Menu
          if lr_control->idref->ms_manager-easy_access_copied is not initial.
            append lr_control->idref->ms_manager-easy_access_copied to lt_users_easy_access_copy.
            lv_changed_segment_counter = lv_changed_segment_counter + 1.
          endif.
        endif.

      endif.

      " Header
      if lr_control->idref->ms_segment_header-status         eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_header          to lt_segment_header.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Header changes
      if lr_control->idref->ms_segment_header_hist-status    eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_header_hist     to lt_segment_header_hist.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Refuser
      if lr_control->idref->ms_segment_refuser-status        eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_refuser         to lt_segment_refuser.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Roles
      if lr_control->idref->ms_segment_roles-status          eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_roles           to lt_segment_roles.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Defaults
      if lr_control->idref->ms_segment_defaults-status       eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_defaults        to lt_segment_defaults.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Address
      if lr_control->idref->ms_segment_address-actadd-trx_with_bp eq co_trx_user.
        lv_trx_with_bp = co_trx_user.
      endif.
      if lr_control->idref->ms_segment_address-status        eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_address         to lt_segment_address.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
        " Inform SAP Office in Create/Delete mode and Change only if addr numbers have changed
        if lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_create or
           lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete or
         ( lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_modify and
           ( lr_control->idref->ms_segment_address-actual-addrnumber         ne
             lr_control->idref->ms_segment_address-before_image-addrnumber ) or
           ( lr_control->idref->ms_segment_address-actual-persnumber         ne
             lr_control->idref->ms_segment_address-before_image-persnumber ) ).
          ls_office_user-username        = lr_control->idref->ms_segment_address-bname.
          ls_office_user-addrnumber_new  = lr_control->idref->ms_segment_address-actual-addrnumber.
          ls_office_user-persnumber_new  = lr_control->idref->ms_segment_address-actual-persnumber.
          ls_office_user-addrtype_new    = lr_control->idref->ms_segment_address-actual-idadtype.
          ls_office_user-addrnumber_img  = lr_control->idref->ms_segment_address-before_image-addrnumber.
          ls_office_user-persnumber_img  = lr_control->idref->ms_segment_address-before_image-persnumber.
          ls_office_user-addrtype_img    = lr_control->idref->ms_segment_address-before_image-idadtype.
          append ls_office_user to lt_office_user.
        endif.
      endif.
      " BAS
      if lr_control->idref->ms_segment_address-actadd-changed_bas_workplace_node_id is not initial.
        append lines of lr_control->idref->ms_segment_address-actadd-changed_bas_workplace_node_id to lt_address_id.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " BP
      if lr_control->idref->ms_segment_address-actadd-trx_with_bp   eq co_trx_user and
       ( lr_control->idref->ms_segment_address-actadd-changed_bp    eq if_identity=>co_true or
         lr_control->idref->ms_segment_address-actadd-changed_bprel eq if_identity=>co_true ).
        lv_save_bp = if_identity=>co_true.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " SNC
      if lr_control->idref->ms_segment_snc-status            eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_snc             to lt_segment_snc.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Profiles ust04
      if lr_control->idref->ms_segment_profiles_t04-status       eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_profiles_t04        to lt_segment_profiles.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Profiles usr04
      if lr_control->idref->ms_segment_profiles_r04-status eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_profiles_r04  to lt_segment_profiles_usr04.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Profiles history ush04
      if lr_control->idref->ms_segment_profiles_r04_hist-status eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_profiles_r04_hist  to lt_segment_profiles_ush04.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Parameter
      if lr_control->idref->ms_segment_parameter-status      eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_parameter       to lt_segment_parameter.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Groups
      if lr_control->idref->ms_segment_groups-status         eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_groups          to lt_segment_groups.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Certificate mapping
      if lr_control->idref->ms_segment_certmap-status         eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_certmap         to lt_segment_certmap.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " DBMS_USER
      if lr_control->idref->ms_segment_dbms_user-status       eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_dbms_user        to lt_segment_dbms_user.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.

      " Licence data
      if lr_control->idref->ms_segment_uclass-status         eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_uclass          to lt_segment_uclass.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " CUA Licence data
      if lr_control->idref->ms_segment_cua_uclasses-status         eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_cua_uclasses          to lt_segment_cua_uclasses.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " Password history
      if lr_control->idref->ms_segment_pwdhistory-status     eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_pwdhistory      to lt_segment_pwdhistory.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " CUA role assignment: update USLA04
      if lr_control->idref->ms_segment_cua_roles-status      eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_cua_roles       to lt_segment_cua_roles.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " CUA profile assignment: update USL04
      if lr_control->idref->ms_segment_cua_profiles-status   eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_cua_profiles    to lt_segment_cua_profiles.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.
      " user documentation
      if lr_control->idref->ms_segment_docu-status           eq go_persistence->co_seg_changed.
        append lr_control->idref->ms_segment_docu            to lt_segment_docu.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.

      " CUA systems: check if system assignments were changed => increase lv_changed_segment_counter
      " If CUA is active ==> do NOT add segment to segment list because this will be
      " done in CUA handling see section below
      if lr_control->idref->ms_segment_cua_systems-status   eq go_persistence->co_seg_changed.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
        " If CUA is inactivated ==> collect existing entries in USZBVSYS to delete them as inconsistence
        "                           when user is being created or deleted
        if gv_cua_active = if_identity=>co_false and
          ( lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_create or
            lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete    ).
          append lr_control->idref->ms_segment_cua_systems  to lt_segment_cua_systems.
        endif.
      endif.

      " CUA user protocol: check if was modified => increase lv_changed_segment_counter
      " If CUA is active ==> do NOT add segment to segment list because this will be
      " done in CUA handling see section below
      if lr_control->idref->ms_segment_cua_user_prot-status   eq go_persistence->co_seg_changed.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
        "If CUA is inactivated ==> collect existing entries in USZBVPROT to delete them as inconsistence
        "                           when user is being created or deleted
        if gv_cua_active = if_identity=>co_false and
          ( lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_create or
            lr_control->idref->ms_manager-modus eq go_persistence->co_ta_modus_delete    ).
          append lr_control->idref->ms_segment_cua_user_prot  to lt_segment_cua_user_prot.
        endif.
      endif.

      " CUA initial passwords for child systems => increase lv_changed_segment_counter
      "  do NOT add segment to segment list because changed CUA passwords are not saved locally but
      "  only distributed to corresponding child systems and saved there
      if lr_control->idref->ms_segment_cua_password-status  eq go_persistence->co_seg_changed.
        lv_changed_segment_counter = lv_changed_segment_counter + 1.
      endif.

      " only if at least one segment was changed: audit log entry and USER STAMP are updated
      if lv_changed_segment_counter > 0.

        call method lr_control->idref->prepare_audit_segment
          exporting
            is_timestamp = ls_timestamp.

        " Audit log
        if lr_control->idref->ms_segment_auditlog-status       eq go_persistence->co_seg_changed.
          append lr_control->idref->ms_segment_auditlog        to lt_segment_auditlog.
        endif.

        " User stamp
        if lr_control->idref->ms_segment_userstamp-status      eq go_persistence->co_seg_changed.
          append lr_control->idref->ms_segment_userstamp       to lt_segment_stamp.
        endif.

        " BADI
        ls_badi_identity_update-bname         = lr_control->idref->ms_manager-bname.
        ls_badi_identity_update-idref         = lr_control->idref.
        ls_badi_identity_update-identity_guid = lr_control->idref->ms_segment_address-actual-identity_guid.
        ls_badi_identity_update-modus         = lr_control->idref->ms_manager-modus.
        append ls_badi_identity_update to lt_badi_identity_update.

      else.
*       Rememer unchanged users
        ls_users_not_changed-bname = lr_control->bname.
        append ls_users_not_changed to lt_users_not_changed.

      endif.
    endif.
  endloop.

* ------------------- handle invalid role assignment entries -----------------------------
* delete invalid role assignments where user does not exist anymore
* it is not possible to create valid identities for such inconsistencies
* therefore use dedicated mt_invalid_role_assignment segments
  if mt_invalid_role_assignment is not initial.
    loop at mt_invalid_role_assignment reference into lr_segment_role.
*     add changed role assignments to roles_segment
      if lr_segment_role->status        eq go_persistence->co_seg_changed.
        append lr_segment_role->*       to lt_segment_roles.
      endif.
    endloop.
  endif.

* ------------------- handle invalid profile assignment entries -----------------------------
* delete invalid profile assignments where user does not exist anymore
* it is not possible to create valid identities for such inconsistencies
* therefore use dedicated mt_invalid_profile_assignment segments
  if mt_invalid_profile_assignment is not initial.
    loop at mt_invalid_profile_assignment reference into lr_segment_profile.

      clear: ls_segment_ush04,  ls_segment_usr04.
      cl_identity=>prepare_profile_segments(
        exporting
          is_timestamp          = ls_timestamp
          iv_bname              = lr_segment_profile->bname
          iv_modus              = cl_identity_persistence=>co_ta_modus_delete
        importing
          es_segment_ush04      = ls_segment_ush04
        changing
          cs_segment_usr04      = ls_segment_usr04
          cs_segment_ust04      = lr_segment_profile->* ).

      " Profiles ust04: add changed profile assignments
      if lr_segment_profile->status   eq go_persistence->co_seg_changed.
        append lr_segment_profile->*  to lt_segment_profiles.
      endif.
      " Profiles usr04
      if ls_segment_usr04-status      eq go_persistence->co_seg_changed.
        append ls_segment_usr04       to lt_segment_profiles_usr04.
      endif.
      " Profiles history ush04
      if ls_segment_ush04-status      eq go_persistence->co_seg_changed.
        append ls_segment_ush04       to lt_segment_profiles_ush04.
      endif.

    endloop.
  endif.


* ------------------- handle invalid cua roles and profile assignment entries
* delete invalid cua role/profile assignments where user does not exist anymore
* it is not possible to create valid identities for such inconsistencies
* therefore use dedicated mt_invalid_cua_roles/profiles_assignment segments
* --- CUA Profiles
  if mt_invalid_cua_prof_assignment is not initial.
    loop at mt_invalid_cua_prof_assignment reference into lr_segment_cua_profile.
      " Profiles usl04: add changed cua profile assignments
      if lr_segment_cua_profile->status   eq go_persistence->co_seg_changed.
        append lr_segment_cua_profile->*  to lt_segment_cua_profiles.
      endif.
    endloop.
  endif.
* --- CUA Roles
  if mt_invalid_cua_role_assignment is not initial.
    loop at mt_invalid_cua_role_assignment reference into lr_segment_cua_roles.
      " Roles usla04: add changed cua role assignments
      if lr_segment_cua_roles->status   eq go_persistence->co_seg_changed.
        append lr_segment_cua_roles->*  to lt_segment_cua_roles.
      endif.
    endloop.
  endif.


* --- Prepare distribution -----------------------------------------
  if gv_cua_active eq if_identity=>co_true.

    " In child system (and not Idoc processing) check that Back Distribution is required
    if gv_cua_child       eq if_identity=>co_true and
       gv_idoc_processing eq if_identity=>co_false.
      " Check if some field has field attribute Back Distribution
      call method cl_suid_cua=>if_suid_cua_runtime~get_cua_filters
        importing
          et_cua_filters = lt_cua_filters.
      " Set back distribution flag if found
      read table lt_cua_filters
           with key field_attr = if_suid_cua_runtime=>gc_maint_back
           transporting no fields.
      if sy-subrc = 0.
        lv_back_distr = if_identity=>co_true.
      endif.
    endif.

    " Check every instance, if distribution or back distribution is necessary
    loop at gt_control reference into lr_control
         where idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.
      if lr_control->idref->ms_manager-status ne go_persistence->co_ta_status_finalized.
        "SCUG: also unchanged users without fatal errors can require CUA processing; otherwise
        "      only changed and checked users
        if not ( gs_cua_user_transfer-active          eq if_identity=>co_true and
                 lr_control->idref->ms_manager-status eq go_persistence->co_ta_status_unchanged ).
          continue.
        endif.
      endif.

      " Current system is central system of active CUA and there were no problems by Save
      if gv_cua_central eq if_identity=>co_true .
        clear: lt_cua_user_syst_distr.
        " Calculate changes to be distributed and prepare CUA segments for Save
        call method lr_control->idref->cua_prepare_changed_user_send
          exporting
            is_timestamp             = ls_timestamp
          importing
            et_cua_user_syst_distr   = lt_cua_user_syst_distr
          changing
            ct_segment_cua_systems   = lt_segment_cua_systems
            ct_segment_cua_user_prot = lt_segment_cua_user_prot.

        append lines of lt_cua_user_syst_distr to lt_cua_users_syst_distr.

        " Actual system is child system of active CUA and there were no problems by Save and
        " we are not processing Idoc
      elseif gv_cua_child eq if_identity=>co_true.
        " Deletion of not CUA users (local, not transferred)
        if lr_control->idref->mv_cua_mode       eq co_cua_not_transferred and
           lr_control->idref->ms_manager-modus  eq go_persistence->co_ta_modus_delete.
          " If user (for example local) has entries in USZBVSYS ==> collect them for deletion
          if lr_control->idref->ms_segment_cua_systems-status = go_persistence->co_seg_changed.
            append lr_control->idref->ms_segment_cua_systems to lt_segment_cua_systems.
          endif.
          " If user has entries in USZBVPROT ==> collect them for deletion
          if lr_control->idref->ms_segment_cua_user_prot-status = go_persistence->co_seg_changed.
            append lr_control->idref->ms_segment_cua_user_prot to lt_segment_cua_user_prot.
          endif.


          " For all transferred into CUA users start back distribution
          " and some SCUM attribute is set to 'Back Distribution'
        elseif lr_control->idref->mv_cua_mode ne co_cua_not_transferred and
               lr_control->idref->mv_cua_mode ne co_cua_local_create    and
               lv_back_distr = if_identity=>co_true.
          " Prepare and start Back distribution
          call method lr_control->idref->cua_send_user_back.
        endif.
      endif.
    endloop.
  endif.


* --- BADI ---------------------------------------------------------------*
* Important: BAdI must be called before address save
*            (otherwise no get_before_imgage possible)
*
  if lt_badi_identity_update is not initial and
     gv_upg_is_shadow_system eq if_identity=>co_false.

    " During SAVE: BADI_IDENTITY_UPDATE MUST not call any SET methode
    gv_active_badi_identity_update = if_identity=>co_true.

    try.
        " Dynamic call: BADIs MUST NOT be called during upgrade, because they might not activated
        ls_badi_filter-name = 'TCODE_MODE'.
        get reference of mv_tcode_mode into ls_badi_filter-value.
        append ls_badi_filter to lt_badi_filter.

        get badi lo_badi_identity_update type ('BADI_IDENTITY_UPDATE')
            filter-table lt_badi_filter.

        call method cl_badi_query=>number_of_implementations
          exporting
            badi = lo_badi_identity_update
          receiving
            num  = lv_num_badi.

        if lv_num_badi ne 0.

          loop at lt_segment_cua_systems reference into lr_segment_cua_systems.
            move-corresponding lr_segment_cua_systems->* to ls_badi_identity_cua_systems.
            append ls_badi_identity_cua_systems to lt_badi_identity_cua_systems.
          endloop.

          loop at lt_segment_cua_roles reference into lr_segment_cua_roles.
            move-corresponding lr_segment_cua_roles->* to ls_badi_identity_cua_roles.
            append ls_badi_identity_cua_roles to lt_badi_identity_cua_roles.
          endloop.

          loop at lt_segment_roles reference into lr_segment_role.
            move-corresponding lr_segment_role->* to ls_badi_identity_roles.
            append ls_badi_identity_roles to lt_badi_identity_roles.
          endloop.

          loop at lt_segment_groups reference into lr_segment_groups.
            move-corresponding lr_segment_groups->* to ls_badi_identity_groups.
            append ls_badi_identity_groups to lt_badi_identity_groups.
          endloop.

          call badi lo_badi_identity_update->('SAVE')
            exporting
              iv_update_task               = iv_update_task
              it_badi_identity_update      = lt_badi_identity_update
              it_badi_identity_cua_systems = lt_badi_identity_cua_systems
              it_badi_identity_cua_roles   = lt_badi_identity_cua_roles
              it_badi_identity_roles       = lt_badi_identity_roles
              it_badi_identity_groups      = lt_badi_identity_groups
              is_badi_timestamp            = ls_timestamp
            changing
              ct_badi_message              = lt_badi_message.
        endif.

        " Copy messages
        loop at lt_badi_message reference into lr_badi_message.
          if lr_badi_message->bname is initial.
            continue.
          endif.
          " Only Warning, Info and Success allowed
          if lr_badi_message->message-msgty ne if_suid_msg_buffer=>co_type_warning and
             lr_badi_message->message-msgty ne if_suid_msg_buffer=>co_type_info    and
             lr_badi_message->message-msgty ne if_suid_msg_buffer=>co_type_success.
            lr_badi_message->message-msgty = if_suid_msg_buffer=>co_type_warning.
          endif.

          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = lr_badi_message->bname
              iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
              iv_nodename = if_identity_definition=>gc_node_root
              iv_field    = if_identity_definition=>gc_field_root_bname
              is_msg      = lr_badi_message->message.
        endloop.

      catch cx_badi.                                    "#EC NO_HANDLER
    endtry.
    gv_active_badi_identity_update = if_identity=>co_false.
  endif.


* --- Save ----------------------------------------------------------
*
  call method go_persistence->if_suid_persistence_modify~modify
    exporting
      iv_update_task            = iv_update_task
      is_timestamp              = ls_timestamp
      it_segment_header         = lt_segment_header
      it_segment_header_hist    = lt_segment_header_hist
      it_segment_auditlog       = lt_segment_auditlog
      it_segment_stamp          = lt_segment_stamp
      it_segment_refuser        = lt_segment_refuser
      it_segment_defaults       = lt_segment_defaults
      it_segment_roles          = lt_segment_roles
      it_segment_address        = lt_segment_address
      it_segment_snc            = lt_segment_snc
      it_segment_profiles       = lt_segment_profiles
      it_segment_profiles_usr04 = lt_segment_profiles_usr04
      it_segment_profiles_ush04 = lt_segment_profiles_ush04
      it_segment_parameter      = lt_segment_parameter
      it_segment_groups         = lt_segment_groups
      it_segment_uclass         = lt_segment_uclass
      it_segment_cua_systems    = lt_segment_cua_systems
      it_segment_cua_user_prot  = lt_segment_cua_user_prot
      it_segment_pwdhistory     = lt_segment_pwdhistory
      it_segment_cua_roles      = lt_segment_cua_roles
      it_segment_cua_profiles   = lt_segment_cua_profiles
      it_segment_cua_uclasses   = lt_segment_cua_uclasses
      it_segment_certmap        = lt_segment_certmap
      it_segment_dbms_user      = lt_segment_dbms_user
      it_segment_docu           = lt_segment_docu.

* --- Save DBMS User ------------------------------------------------
  if lt_segment_dbms_user is not initial.
    call method cl_suid_dbms=>dbms_users_data_modify
      exporting
        it_segment_dbms_user  = lt_segment_dbms_user
      importing
        et_suid_messages      = data(lt_dbms_messages).

    loop at lt_dbms_messages reference into data(lr_dbms_msg).
      clear: ls_msg.
      move-corresponding lr_dbms_msg->* to ls_msg.
      if lr_dbms_msg->msgty = 'E'.
        ls_msg-msgty = 'W'. "Errors to Warnings because SAVE must be always successful!
      else.
        ls_msg-msgty = lr_dbms_msg->msgty.
      endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_dbms_msg->bname
          is_msg      = ls_msg
          iv_nodename = lr_dbms_msg->nodename
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
    endloop.
  endif.


* --- Save personalization ------------------------------------------------
  if lv_save_personalization = if_identity=>co_true.
    " collect all deleted users
    loop at lt_segment_header reference into lr_segment_header
                              where actual is initial.
      append lr_segment_header->bname to lt_deleted_users.
    endloop.
    "save buffer data
    cl_pers_service=>save_buffer(
        p_background = iv_update_task
        p_db_commit  = space  ).
    "delete user
    if iv_update_task is initial.
      call function 'SPERS_USER_DELETE'
        tables
          p_uname_list       = lt_deleted_users.
    else.
      call function 'SPERS_USER_DELETE_BGD'
        exporting
          p_uname_list       = lt_deleted_users.
    endif.
  endif.

* --- Save appl. references -----------------------------------------------
  if lv_save_applrefs = if_identity=>co_true.
    cl_suid_applref=>save( iv_update_task = iv_update_task ).
  endif.

* --- Save Easy Access Menu -----------------------------------------------
  if lt_users_easy_access_delete is not initial or
     lt_users_easy_access_copy   is not initial.
    easy_access_menu_save(
        iv_update_task  = iv_update_task
        it_bname_copy   = lt_users_easy_access_copy
        it_bname_delete = lt_users_easy_access_delete ).
  endif.

* --- Save address --------------------------------------------------------
  if lt_address_id is not initial.

    sort lt_address_id.
    delete adjacent duplicates from lt_address_id.

    " Get address instance
    lo_addr_main = cl_addr_main=>get_instance( ).

    call method lo_addr_main->save
      exporting
        it_address_id             = lt_address_id
        iv_execute_in_update_task = iv_update_task.

  endif.

* --- Save BP -----------------------------------------------------------
  if lv_save_bp eq if_identity=>co_true.
    call method cl_bup_transaction_api=>do_save
      importing
        ev_rejected = lv_bp_rejected
        et_message  = lt_bup_msg.
    if lv_bp_rejected eq if_identity=>co_true.
      ev_rejected = if_identity=>co_true.

      loop at lt_bup_msg reference into lr_bup_msg.
        clear: ls_msg.

        ls_msg-msgty = lr_bup_msg->msgty.
        ls_msg-msgid = lr_bup_msg->msgid.
        ls_msg-msgno = lr_bup_msg->msgno.
        ls_msg-msgv1 = lr_bup_msg->msgv1.
        ls_msg-msgv2 = lr_bup_msg->msgv2.
        ls_msg-msgv3 = lr_bup_msg->msgv3.
        ls_msg-msgv4 = lr_bup_msg->msgv4.

        if lr_bup_msg->lifetime eq 0.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
        else.
          lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
        endif.

        call method go_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = ''
            is_msg      = ls_msg
            iv_nodename = if_identity_definition=>gc_node_root
            iv_lifetime = lv_lifetime.
      endloop.

      return.
    endif.
  endif.

* --- Save SAP Office ----------------------------------------------------
  if lt_office_user is not initial.
    call method cl_so_office_user_address=>change_address
      exporting
        i_update_task    = iv_update_task
      changing
        ct_changed_users = lt_office_user.
  endif.

* --- Save Default Org ---------------------------------------------------
* Default Org should only be saved in user trx
  if lv_trx_with_bp eq co_trx_user.
    call method cl_suid_organization=>save_default_org
      exporting
        iv_update_task = iv_update_task.
  endif.

* ----- CUA: distribute users ---------------------------------------------
**
  if gv_cua_active = if_identity=>co_true.
*   In central system update USZBVSYS and USZBVPROT tables and send collected Idocs
    if gv_cua_central = if_identity=>co_true.
      " Sort distribution table and prevent duplicates
      sort lt_cua_users_syst_distr.
      delete adjacent duplicates from lt_cua_users_syst_distr comparing bname subsystem.

      " Start distribution
      call method cua_send_users
        exporting
          iv_update_task         = iv_update_task
          it_cua_user_syst_distr = lt_cua_users_syst_distr.
    endif.
  endif.


* --- Delete HR relations -----------------------------------------------*
*
  data(lv_hr_org_active) = if_identity=>co_true.

  call function 'PRGN_CHECK_HR_ORG_ACTIVE'
    exceptions
      hr_org_not_active = 1
      others            = 2
      .
  if ( sy-subrc <> 0 ).
    lv_hr_org_active = if_identity=>co_false.
  endif.

  if    gv_earlywatchclient     eq if_identity=>co_false
    and gv_upg_is_shadow_system eq if_identity=>co_false
    and lv_hr_org_active        eq if_identity=>co_true. " "classic" HR-Org. is active

    loop at lt_segment_header reference into lr_segment_header.
      if lr_segment_header->actual-bname       is initial and
         lr_segment_header->before_image-bname is not initial.
        call function 'RH_USER_ALL_REL_DELETE'
          exporting
            user                = lr_segment_header->bname
            commit_flg          = space
          exceptions
            no_plvar_found      = 1
            no_relations_found  = 2
            error_in_enqueue    = 3
            error_during_delete = 4
            no_auth_for_0105    = 5
            others              = 6.
        if sy-subrc > 2.
          " The HR-Org. Infotype 0105 couldn't be deleted."
          if 1 = 0. message w591(01) with lr_segment_header->bname sy-subrc. endif.
          clear: ls_msg.
          ls_msg-msgid = '01'.
          ls_msg-msgno = '591'.
          ls_msg-msgty = if_suid_msg_buffer=>co_type_warning.
          ls_msg-msgv1 = lr_segment_header->bname.
          ls_msg-msgv2 = sy-subrc.

          call method go_msg_buffer->add_object_message_symsg
            exporting
              iv_bname    = lr_segment_header->bname
              iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
              iv_nodename = if_identity_definition=>gc_node_root
              iv_field    = if_identity_definition=>gc_field_root_bname
              is_msg      = ls_msg.
        endif.
      endif.
    endloop.
  endif.


* --- Create BOR events --------------------------------------------------*
*
  " --- No event during upgrade
  if gv_upg_is_shadow_system is initial.
  try.
      loop at lt_badi_identity_update reference into lr_badi_identity_update.
        lv_bor_objkey = lr_badi_identity_update->bname.

        case lr_badi_identity_update->modus.
          when cl_identity_persistence=>co_ta_modus_create.
            lv_bor_event = 'CREATED'.

          when cl_identity_persistence=>co_ta_modus_delete.
            lv_bor_event = 'DELETED'.

          when cl_identity_persistence=>co_ta_modus_modify.
            lv_bor_event = 'CLONED'.

            " Check change of validity dates
            read table lt_segment_header reference into lr_segment_header
              with key bname = lr_badi_identity_update->bname
              binary search.
            if sy-subrc eq 0.
              if lr_segment_header->actual-gltgv ne lr_segment_header->before_image-gltgv or
                 lr_segment_header->actual-gltgb ne lr_segment_header->before_image-gltgb.

                " Instantiate an empty event container
                clear: lr_bor_parameter.
                call method cl_swf_evt_event=>get_event_container
                  exporting
                    im_objcateg  = cl_swf_evt_event=>mc_objcateg_bor
                    im_objtype   = 'USER'
                    im_event     = 'DELIMITED'
                  receiving
                    re_reference = lr_bor_parameter.

                if lr_bor_parameter is not initial.
                  " Add parameter
                  call method lr_bor_parameter->set( name = 'VALIDFROM'       value = lr_segment_header->actual-gltgv ).
                  call method lr_bor_parameter->set( name = 'VALIDTHROUGH'    value = lr_segment_header->actual-gltgb ).
                  call method lr_bor_parameter->set( name = 'OLDVALIDFROM'    value = lr_segment_header->before_image-gltgv ).
                  call method lr_bor_parameter->set( name = 'OLDVALIDTHROUGH' value = lr_segment_header->before_image-gltgb ).

                  if iv_update_task is initial.
                    call method cl_swf_evt_event=>raise
                      exporting
                        im_objcateg        = cl_swf_evt_event=>mc_objcateg_bor
                        im_objtype         = 'USER'
                        im_event           = 'DELIMITED'
                        im_objkey          = lv_bor_objkey
                        im_event_container = lr_bor_parameter.
                  else.
                    call method cl_swf_evt_event=>raise_in_update_task
                      exporting
                        im_objcateg        = cl_swf_evt_event=>mc_objcateg_bor
                        im_objtype         = 'USER'
                        im_event           = 'DELIMITED'
                        im_objkey          = lv_bor_objkey
                        im_event_container = lr_bor_parameter.
                  endif.
                endif.
              endif.
            endif.

          when others.
            continue.
        endcase.

        if iv_update_task is initial.
          call method cl_swf_evt_event=>raise
            exporting
              im_objcateg = cl_swf_evt_event=>mc_objcateg_bor
              im_objtype  = 'USER'
              im_event    = lv_bor_event
              im_objkey   = lv_bor_objkey.
        else.
          call method cl_swf_evt_event=>raise_in_update_task
            exporting
              im_objcateg = cl_swf_evt_event=>mc_objcateg_bor
              im_objtype  = 'USER'
              im_event    = lv_bor_event
              im_objkey   = lv_bor_objkey.
        endif.
      endloop.
    catch cx_swf_ifs_exception.
  endtry.
  endif.

* --- Everything ok ------------------------------------------------------*
*
  ev_rejected   = if_identity=>co_false.
  es_timestamp  = ls_timestamp.


* --- Set parameter for own user, so they are active without new logon -----*
  read table lt_segment_parameter reference into lr_segment_parameter
       with key bname = sy-uname
       binary search.
  if sy-subrc eq 0.
    "Set deleted parameters
    loop at lr_segment_parameter->before_image reference into lr_parameter.
      read table lr_segment_parameter->actual  with key parid = lr_parameter->parid
         binary search
         transporting no fields.
      if sy-subrc <> 0.
        set parameter id lr_parameter->parid field space.
      endif.
    endloop.

    "Set actual parameters
    loop at lr_segment_parameter->actual reference into lr_parameter.
      set parameter id lr_parameter->parid field lr_parameter->parva.
    endloop.
  endif.

* --- Fill message buffer with success messages -----------------------*
  sort lt_users_not_changed by bname.
  loop at gt_control reference into lr_control
       where idref->ms_manager-status eq go_persistence->co_ta_status_finalized and
             idref->ms_manager-modus  ne go_persistence->co_ta_modus_display.

    " In Idoc processing we need another messages, therefore don't add them here
    if gv_idoc_processing <> if_identity=>co_true.

      clear: ls_msg.
      ls_msg-msgty = 'S'.
      ls_msg-msgid = '01'.
      ls_msg-msgv1 = lr_control->bname.

      read table lt_users_not_changed
           with key bname = lr_control->bname
           binary search
           transporting no fields.
      if sy-subrc eq 0.
        " User & unchanged
        ls_msg-msgid = 'SUID01'.
        ls_msg-msgno = '029'.
        if 1 = 0. message s029(suid01) with ls_msg-msgv1. endif. "#EC *
      else.
        case lr_control->idref->ms_manager-modus.
          when go_persistence->co_ta_modus_create.
            " User & created
            ls_msg-msgno = '102'.
            if 1 = 0. message s102(01) with ls_msg-msgv1. endif. "#EC *
          when go_persistence->co_ta_modus_modify.
            " User & has changed
            ls_msg-msgno = '039'.
            if 1 = 0. message s039(01) with ls_msg-msgv1. endif. "#EC *
          when go_persistence->co_ta_modus_delete.
            " User & deleted
            ls_msg-msgno = '232'.
            if 1 = 0. message s232(01) with ls_msg-msgv1. endif. "#EC *
        endcase.
      endif.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_control->bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          iv_nodename = if_identity_definition=>gc_node_root
          iv_field    = if_identity_definition=>gc_field_root_bname
          is_msg      = ls_msg.

    endif.

    " Switch state of instance from finalized to saved
    " All modified instances are set to SAVED
    if lr_control->idref->ms_manager-status eq go_persistence->co_ta_status_finalized.
      lr_control->idref->ms_manager-status = go_persistence->co_ta_status_saved.
    endif.
  endloop.


* ---------  handle invalid role assignments -------------------------------------------
  if mt_invalid_role_assignment is not initial.
    loop at mt_invalid_role_assignment reference into lr_segment_role.

      clear: ls_msg.
      " Rollenzuordnung zu Benutzer & wurde gelöscht.
      if 1 = 0. message s090(01) with lr_segment_role->bname. endif. "#EC *
      ls_msg-msgty = if_suid_msg_buffer=>co_type_success.
      ls_msg-msgid = '01'.
      ls_msg-msgno = '090'.
      ls_msg-msgv1 = lr_segment_role->bname.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_segment_role->bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          iv_nodename = if_identity_definition=>gc_node_role
          is_msg      = ls_msg.

      " delete entry also in cleanup
      clear lr_segment_role->*.
    endloop.

    " invalidate table
    clear mt_invalid_role_assignment.
  endif.

* ---------  handle invalid profile assignments -------------------------------------------
  if mt_invalid_profile_assignment is not initial.
    loop at mt_invalid_profile_assignment reference into lr_segment_profile.

      clear: ls_msg.
      " Profilzuordnung für Benutzer & wurde gelöscht.
      if 1 = 0. message s089(01) with lr_segment_profile->bname. endif. "#EC *
      ls_msg-msgty = if_suid_msg_buffer=>co_type_success.
      ls_msg-msgid = '01'.
      ls_msg-msgno = '089'.
      ls_msg-msgv1 = lr_segment_profile->bname.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_segment_profile->bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          iv_nodename = if_identity_definition=>gc_node_profile
          is_msg      = ls_msg.

      " delete entry
      clear lr_segment_profile->*.
    endloop.

    " invalidate table of inconsistent entries in cleanup method
    clear mt_invalid_profile_assignment.

  endif.

* ---------  handle invalid role assignments -------------------------------------------
  if mt_invalid_cua_role_assignment is not initial.
    loop at mt_invalid_cua_role_assignment reference into lr_segment_cua_roles.

      clear: ls_msg.
      " Rollenzuordnung zu Benutzer & wurde gelöscht.
      if 1 = 0. message s090(01) with lr_segment_cua_roles->bname. endif. "#EC *
      ls_msg-msgty = if_suid_msg_buffer=>co_type_success.
      ls_msg-msgid = '01'.
      ls_msg-msgno = '090'.
      ls_msg-msgv1 = lr_segment_cua_roles->bname.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_segment_cua_roles->bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          iv_nodename = if_identity_definition=>gc_node_cua_role
          is_msg      = ls_msg.
      " delete entry also in cleanup
      clear lr_segment_cua_roles->*.
    endloop.

    " invalidate table
    clear mt_invalid_cua_role_assignment.
  endif.

* ---------  handle invalid profile assignments -------------------------------------------
  if mt_invalid_cua_prof_assignment is not initial.
    loop at mt_invalid_cua_prof_assignment reference into lr_segment_cua_profile.

      clear: ls_msg.
      " Profilzuordnung für Benutzer & wurde gelöscht.
      if 1 = 0. message s089(01) with lr_segment_cua_profile->bname. endif. "#EC *
      ls_msg-msgty = if_suid_msg_buffer=>co_type_success.
      ls_msg-msgid = '01'.
      ls_msg-msgno = '089'.
      ls_msg-msgv1 = lr_segment_cua_profile->bname.

      call method go_msg_buffer->add_object_message_symsg
        exporting
          iv_bname    = lr_segment_cua_profile->bname
          iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
          iv_nodename = if_identity_definition=>gc_node_cua_profile
          is_msg      = ls_msg.

      " delete entry
      clear lr_segment_cua_profile->*.
    endloop.

    " invalidate table of inconsistent entries in cleanup method
    clear mt_invalid_cua_prof_assignment.

  endif.

  "must be cleared after save!
  clear gs_timestamp_finalize.

endmethod.


method SET_APPLREFS_MODIFIED_FLAG.
* MS_MANAGER-FLG_APPREF_MODIFIED is set to 'X', which means that appl. references
* will be saved
* MS_MANAGER-STATUS is set to go_persistence->co_ta_status_unchecked

  data: lr_control type ref to ty_control.

* Read corresponding entry from gt_control
  read table gt_control reference into lr_control
     with key bname = iv_bname
     binary search.
  if sy-subrc = 0.
    lr_control->idref->applrefs_set_modified( iv_modified ).
  endif.

endmethod.


method set_communication_data.
*
* In order to change telephone, fax,..
* - use current_state = 'X' of specified table or
* - current_state = ' ' and updateflag of table line, if changed_fields is initial
*   it will be set automatically
*

  data: ls_msg                 type        symsg
      , ls_current_state       type        bup_s_current_state_commdata
      , lv_error               type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.
  clear: et_new_telephone_id,
         et_new_facsimile_id,
         et_new_email_id,
         et_new_web_id,
         et_new_telex_id,
         et_new_teletex_id,
         et_new_rml_id,
         et_new_x400_id,
         et_new_printer_id,
         et_new_ssf_id,
         et_new_pager_id.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_workplace
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  " Notification and Messages
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_telephone
      it_comm_table    = it_telephone
      is_current_state = is_current_state-current_state_tel.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_facsimile
      it_comm_table    = it_facsimile
      is_current_state = is_current_state-current_state_fax.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_email
      it_comm_table    = it_email
      is_current_state = is_current_state-current_state_email.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_web
      it_comm_table    = it_web
      is_current_state = is_current_state-current_state_web.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_telex
      it_comm_table    = it_telex
      is_current_state = is_current_state-current_state_telex.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_teletex
      it_comm_table    = it_teletex
      is_current_state = is_current_state-current_state_teletex.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_remote_mail
      it_comm_table    = it_rml
      is_current_state = is_current_state-current_state_rml.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_x400
      it_comm_table    = it_x400
      is_current_state = is_current_state-current_state_x400.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_printer
      it_comm_table    = it_printer
      is_current_state = is_current_state-current_state_printer.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_ssf
      it_comm_table    = it_ssf
      is_current_state = is_current_state-current_state_ssf.
  call method addr_msg_commdata
    exporting
      iv_nodename      = if_identity_definition=>gc_node_pager
      it_comm_table    = it_pager
      is_current_state = is_current_state-current_state_pager.

  "------ Change address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
        " MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_workplace
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.


    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '013'.
      " MSG: Es ist keine Organisation zugeordnet.
      if 1 = 0. message e013(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Person-BPOrg-Rel is assigned --------------------------
    when if_identity=>co_idad_person_org_rela.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '666'.
      " MSG: Aktion nicht zulaessig.
      if 1 = 0. message e666(suid01). endif.
      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '030'.
      " MSG: Arbeitsplatzdaten eines Mitarbeiters dürfen nicht gepflegt werden
      if 1 = 0. message e030(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  " Set values
  ls_current_state = is_current_state.

  if gv_cua_child eq if_identity=>co_true and iv_ignore_cua_check eq if_identity=>co_false.
    adbp_check_commdata_maintain(
      exporting
        io_msg_buffer    = go_msg_buffer
      changing
        cs_current_state = ls_current_state ).
  endif.

  " Own user transaction: No change of E-Mail address allowed - except change of company address
  if ms_manager-flg_own_data eq go_persistence->co_flag_active and
     iv_ignore_cua_check     eq if_identity=>co_false.
    clear: ls_current_state-current_state_email.
  endif.

  " Leave if nothing is to be changed
  if ls_current_state is initial.
    return.
  endif.

  "--- Call BAS  --------------------------------------
  " Change old user "type 3" address
  try.
    addr_change_communication_data(
      exporting
        it_telephone          = it_telephone
        it_facsimile          = it_facsimile
        it_email              = it_email
        it_web                = it_web
        it_telex              = it_telex
        it_teletex            = it_teletex
        it_rml                = it_rml
        it_x400               = it_x400
        it_printer            = it_printer
        it_ssf                = it_ssf
        it_pager              = it_pager
        is_current_state      = ls_current_state
      importing
        et_new_telephone_id   = et_new_telephone_id
        et_new_facsimile_id   = et_new_facsimile_id
        et_new_email_id       = et_new_email_id
        et_new_web_id         = et_new_web_id
        et_new_telex_id       = et_new_telex_id
        et_new_teletex_id     = et_new_teletex_id
        et_new_rml_id         = et_new_rml_id
        et_new_x400_id        = et_new_x400_id
        et_new_printer_id     = et_new_printer_id
        et_new_ssf_id         = et_new_ssf_id
        et_new_pager_id       = et_new_pager_id ).

  catch cx_suid_identity.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
    " MSG: Schiefstand bei Adresse.
    if 1 = 0. message e022(01). endif.

    go_msg_buffer->add_object_message_symsg(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_workplace
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

    return.
  endtry.

* --- Transaction handling ---------------------------------

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_telephone
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_telephone = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_telephone = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_facsimile
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_facsimile = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_facsimile = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_email
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_email = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_email = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_web
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_web = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_web = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_telex
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_telex = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_telex = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_teletex
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_teletex = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_teletex = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_remote_mail
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_remote_mail = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_remote_mail = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_x400
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_x400 = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_x400 = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_printer
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_printer = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_printer = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_ssf
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_ssf = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_ssf = go_persistence->co_node_status_changed.
  endif.

  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_pager
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_pager = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_pager = go_persistence->co_node_status_changed.
  endif.

endmethod.


method set_cua_attributes.

* In case local user is being created
  if iv_cua_mode = co_cua_local_create.
    ms_segment_header-actual-reserved = co_user_local.              " Set local user flag
    " No special CUA mode of user processing in central system (except for SCUG)
    if gv_cua_central = if_identity=>co_true.
      clear: mv_cua_mode.
    endif.
  endif.

* In CUA case set ZBVMASTER to 'X' to indicate, that user doesn't have
* assignment to the central system yet (local users should be allowed to logon)
  if gv_cua_central = if_identity=>co_true.
    ms_segment_header-actual-zbvmaster = if_identity=>co_true.
  endif.

endmethod.


method set_cua_mode.

* Calls attributes are valid for the whole transaction
* Allowed values:
* - SCUG processing
* - IDOC processing

  if gv_cua_active = if_identity=>co_true.

    " Is called in central system of active CUA?
    if gv_cua_central = if_identity=>co_true.
      " Set class attribut for users transfer from child system into CUA environment
      if iv_mode = if_suid_cua_runtime=>gc_cua_central_transfer.
        gs_cua_user_transfer-active        = if_identity=>co_true.
        gs_cua_user_transfer-source_system = iv_source_system.
      endif.

    " Is called in child system of active CUA?
    elseif gv_cua_child = if_identity=>co_true.
      " For Idoc processing set class attribute
      if iv_mode = if_suid_cua_runtime=>gc_cua_child_idoc.
        gv_idoc_processing = if_identity=>co_true.
      endif.
    endif.
  endif.

endmethod.


method set_defaults.
*
* List of messages that can be raised during this method:
*
* Node Defaults (SUID_ST_NODE_DEFAULTS):
*
* - Field data format (GDATFM)
*     E036(01) - Invlaid date format &. (Not 1, 2, 3, 4, 5 or 6.)
* - Field decimal format (DCPFM)
*     E086(01) - Decimal format & is invalid. (Not ' ', X or Y)
* - Field output device (SPLD)
*     E029(01) - Output device & does not exist
* - Field print paramters 2 (SPDA)
*     E033(01) - Print parameters & for 'Delete after print' not equal to D(elete)/K(eep)
* - Field print paramters 3 (SPDB)
*     E035(01) - Print parameter & for 'Print immed.' not equal to G(o) or H(old).
* - Field logon language (LANGU)
*     E080(TL) - Language & not in system
* - Field time zone of user (TZONE)
*     E028(01) - Invalid time zone


  data: ls_check_defaults    type        suid_st_node_defaults
      , ls_old_defaults      type        suid_st_node_defaults
      , lv_error             type        sesf_boolean
      , lr_field             type ref to suid_node_field
      , lt_change_fields     type        suid_tt_fields
      , lv_no_maintain       type        sesf_boolean
      , lv_lifetimeonce_only type        xfeld
      , ls_msg               type        symsg
      .

  field-symbols: <lv_newfield>     type any
               , <lv_checkfield>   type any
               .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_defaults
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Lazy fetch of defaults and address segment
  if ms_segment_defaults-bname is initial.
    call method fetch_segment_defaults.
  endif.
  if ms_segment_address-bname is initial.
    call method fetch_segment_address.
  endif.

  " Read from actual image into old structure
  move-corresponding ms_segment_defaults-actual           to ls_old_defaults.
  move               ms_segment_header-actual-tzone       to ls_old_defaults-tzone.
  move               ms_segment_address-actual-start_menu to ls_old_defaults-start_menu.


  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_defaults.


  " --- Set values ------------------------------------------
  "
  " Fill check structure with old data first
  move ls_old_defaults to ls_check_defaults.

  if it_change_fields is initial.
    " All messages (lifetime_once and permanent) should be deleted
    " for the node

    " Get list of fields belonging to the node
    call method cl_suid_tools=>get_node_fields
      exporting
        iv_node_name   = if_identity_definition=>gc_node_defaults
      importing
        et_node_fields = lt_change_fields.
  else.
    lt_change_fields = it_change_fields.
    " Only lifetime_once messages should be deleted for the node
    lv_lifetimeonce_only = if_identity=>co_true.
  endif.

  " Delete messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_defaults
      iv_lifetimeonce_only = lv_lifetimeonce_only.


  loop at lt_change_fields reference into lr_field.
    if it_change_fields is not initial.
      " Delete lifetime_permanent messages  belonging to this field
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_defaults
          iv_field    = lr_field->*.
    endif.

    " Check SCUM settings in child system
    if gv_cua_child        = if_identity=>co_true and
       iv_ignore_cua_flags = if_identity=>co_false.
      " Check if field can be changed
      call method cua_if_field_no_maintain
        exporting
          iv_node_name   = if_identity_definition=>gc_node_defaults
          iv_field_name  = lr_field->*
          io_msg_buffer  = go_msg_buffer
        receiving
          rv_no_maintain = lv_no_maintain.

      " Field can't be maintained --> delete it from further processing
      if lv_no_maintain = if_identity=>co_true.
        delete lt_change_fields.
        continue.
      endif.
    endif.

    " Set new field value if possible
    assign component lr_field->* of structure is_defaults to <lv_newfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    assign component lr_field->* of structure ls_check_defaults to <lv_checkfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    " Move node field
    <lv_checkfield> = <lv_newfield>.
  endloop.

  " If no field can be changed - leave
  if lt_change_fields is initial.
    return.
  endif.

  " --- Check values ------------------------------------------
  " Checks are only concerning header and defaults segment !
  "
  call method cl_identity=>check_defaults_internal
    exporting
      iv_bname        = ms_manager-bname
      it_check_fields = lt_change_fields
      io_msg_buffer   = go_msg_buffer
    changing
      cs_defaults     = ls_check_defaults.


  " --- Move values to segements -------------------------------
  "
  move-corresponding ls_check_defaults            to ms_segment_defaults-actual.
  move               sy-mandt                     to ms_segment_defaults-actual-mandt.
  move               ms_manager-bname             to ms_segment_defaults-actual-bname.
  move               ls_check_defaults-tzone      to ms_segment_header-actual-tzone.
  move               sy-mandt                     to ms_segment_header-actual-mandt.
  move               ms_manager-bname             to ms_segment_header-actual-bname.
  move               ls_check_defaults-start_menu to ms_segment_address-actual-start_menu.
  move               sy-mandt                     to ms_segment_address-actual-mandt.
  move               ms_manager-bname             to ms_segment_address-actual-bname.


  " --- Transaction handling ---------------------------------
  "

  " Notification
  if ls_check_defaults ne ls_old_defaults.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_defaults.
  endif.

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_defaults
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false. " New node status: CHECKED
    ms_manager-sn_defaults = go_persistence->co_node_status_checked.
  else.                                 " New node status: CHANGED
    ms_manager-sn_defaults = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.

  if ms_segment_header-actual ne ms_segment_header-before_image.
    ms_segment_header-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.

  if ms_segment_defaults-actual ne ms_segment_defaults-before_image.
    ms_segment_defaults-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_defaults-status.
  endif.

endmethod.


method set_documentation_complete.
* only used for the copy methode

  data: ls_msg        type        symsg
      , lr_docu       type ref to suid_st_node_docu
      , ls_new_docu   type        usdocu
      , lt_old_docu   type        suid_tt_usdocu
      , lv_error      type        abap_bool
      .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.


  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method = 'S'
      iv_change_node = if_identity_definition=>gc_node_documentation
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " --- Check docu buffer ---
  if ms_segment_docu-bname is initial.
    fetch_segment_docu( ).
  endif.

  " --- Read from actual image into old structure ---------------
  "
  move ms_segment_docu-actual to lt_old_docu.

  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_documentation.

  " Delete all messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_documentation
      iv_lifetimeonce_only = 'X'.

  " --- Set values ------------------------------------------
  "
  clear: ms_segment_docu-actual
       , ls_new_docu
       .

  move sy-mandt         to ls_new_docu-mandt.
  move ms_manager-bname to ls_new_docu-bname.

  loop at it_docu reference into lr_docu.

    move-corresponding lr_docu->* to ls_new_docu.
    append ls_new_docu            to ms_segment_docu-actual.

  endloop.

  " --- Transaction handling ---------------------------------
  "

  " Notification
  if ms_segment_docu-actual ne lt_old_docu.
    go_notify->notify_update(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_documentation ).

  endif.


  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_documentation
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.
    " New node status: CHECKED
    ms_manager-sn_docu = go_persistence->co_node_status_checked.
  else.
    " New node status: CHANGED
    ms_manager-sn_docu = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_docu-actual ne ms_segment_docu-before_image.
    ms_segment_docu-status  = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_docu-status.
  endif.

endmethod.


method set_extended_cua_roles.
*
* method provides possibility to set HR-ORG or portal roles
* if_identity->set_cua_roles does not allow to set field ORG_FLAG
*
*
* Uses cases:
* - Manual assignments of roles ??
* - HR role assignment
* - Collective role comparison
* - Only in central system with global role assignment
* - Always do role resolving
* - No profile comparison
*

  data: lv_is_cua_active          type sesf_boolean
      .

  " initialize exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " check if CUA is active and if current system is defined as CUA
  " check if CUA roles can be maintained.
  call method roles_validate_cua_context
    exporting
      iv_bname      = ms_manager-bname
      iv_node_name  = if_identity_definition=>gc_node_cua_role
    importing
      eo_msg_buffer = go_msg_buffer
      ev_valid      = lv_is_cua_active.

  if lv_is_cua_active eq if_identity=>co_false.
    " do not proceed: error message was already written; now return
    return.
  endif.

  call method me->roles_cua_set_internal
    exporting
      it_roles                  = it_roles
      iv_permit                 = if_identity=>co_false
      iv_set_extended           = if_identity=>co_true
      iv_check_compare_profiles = if_identity=>co_false
      iv_do_compare_profiles    = if_identity=>co_false
      iv_do_role_resolving      = if_identity=>co_true
    importing
      et_node_cua_roles         = et_node_cua_roles
      eo_msg_buffer             = eo_msg_buffer
      eo_notify                 = eo_notify.


endmethod.


method set_extended_roles.
* method provides possibility to set HR-ORG or portal roles
* if_identity->set_roles does not allow to set field ORG_FLAG
*
* Uses cases:
* - HR role assignment only
* - Collective role comparison
* - Always do role resolving
* - Profile comparison (according PRGN_CUST)
*

  data: lt_roles  type suid_tt_node_roles
      .

  " Only HR assignments are allowed -> Delete manual assignments
  lt_roles = it_roles.
  delete lt_roles where agr_assign_type eq space.

* initialize export parameter
  eo_msg_buffer   = go_msg_buffer.
  eo_notify       = go_notify.
  clear: et_node_roles.


  call method me->roles_set_internal
    exporting
      iv_set_extended = if_identity=>co_true
      it_roles        = lt_roles
    importing
      et_node_roles   = et_node_roles
      eo_msg_buffer   = eo_msg_buffer
      eo_notify       = eo_notify.


endmethod.


method set_internal_timestamp.


  data: ls_pwdhistory       type usrpwdhistory
      , lr_ush04            type ref to ush04
      , lr_role             type ref to agr_users
      , lr_userstamp        type ref to usrstamp
      , lr_usrcertmap       type ref to usrcertmap
      .

* ---- Prepare History Table USH02 ------------------------------------*

  if ms_segment_header_hist-status = go_persistence->co_seg_changed.
    ms_segment_header_hist-actual-modda = is_timestamp_new-datum.
    ms_segment_header_hist-actual-modti = is_timestamp_new-uzeit.
  endif.

* ---- Internal Data for USR02 ----------------------------------------*
* Set creation date and user
  if ms_manager-modus = go_persistence->co_ta_modus_create.
    ms_segment_header-actual-erdat = is_timestamp_new-datum.
  endif.

* ---- Timestamps for Password ----------------------------------------*
* Only process if password data was changed successfully
  if ms_manager-sn_password = go_persistence->co_node_status_checked.
*   Fill LTIME for password here: Decide upon PWDINITIAL
    if ms_segment_header-actual-pwdinitial = if_identity=>co_pwdinitial_productive.
      if is_timestamp_new-uzeit is not initial.
        ms_segment_header-actual-ltime = is_timestamp_new-uzeit.
      else.  " By chance it is exactly midnight
        ms_segment_header-actual-ltime = '000001'.
      endif.
    else. " For PWDINITIAL = initial: LTIME is empty!
      clear: ms_segment_header-actual-ltime.
    endif.
    ms_segment_header-actual-pwdchgdate = is_timestamp_new-datum.
    ms_segment_header-actual-pwdsetdate = is_timestamp_new-datum.
    clear: ms_segment_header-actual-pwdlgndate.
*   For deactivated passwords: PWDINITIAL and LTIME are not modified
  endif.

* ---- Profiles: USR04 ------------------------------------------------*
  if ms_segment_profiles_r04-status = go_persistence->co_seg_changed.
    ms_segment_profiles_r04-actual-modda = is_timestamp_new-datum.
    ms_segment_profiles_r04-actual-modti = is_timestamp_new-uzeit.
  endif.

* ---- Profiles History: USH04 ----------------------------------------*
  if  ms_segment_profiles_r04_hist-status = go_persistence->co_seg_changed and
      ms_manager-modus = go_persistence->co_ta_modus_delete.
    read table ms_segment_profiles_r04_hist-actual with key profs  = 'D' reference into lr_ush04.
    lr_ush04->modda = is_timestamp_new-datum.
    lr_ush04->modti = is_timestamp_new-uzeit.
  endif.

* --- Role Assignment: AGR_USERS ------------------------------------*
  if ms_segment_roles-status = go_persistence->co_seg_changed.
    loop at ms_segment_roles-actual reference into lr_role.
      if lr_role->change_dat = is_timestamp_old-datum.
        lr_role->change_dat = is_timestamp_new-datum.
      endif.
      if lr_role->change_tim = is_timestamp_old-uzeit.
        lr_role->change_tim = is_timestamp_new-uzeit.
      endif.
    endloop.
  endif.

* ---- SNC timestamps -------------------------------------------------*
  if ms_segment_snc-status       eq go_persistence->co_seg_changed and
     ms_segment_snc-actual-bname is not initial.
    if ms_segment_snc-before_image-bname is initial.
*     Create entry
      ms_segment_snc-actual-cdate = is_timestamp_new-datum.
      ms_segment_snc-actual-ctime = is_timestamp_new-uzeit.
    else.
*     Change entry
      ms_segment_snc-actual-mdate = is_timestamp_new-datum.
      ms_segment_snc-actual-mtime = is_timestamp_new-uzeit.
    endif.
  endif.

* ---- CERTMAP timestamps -------------------------------------------------*
  if ms_segment_certmap-status eq go_persistence->co_seg_changed.
    loop at ms_segment_certmap-actual reference into lr_usrcertmap.
      if lr_usrcertmap->created_on = is_timestamp_old-timestamp.
        lr_usrcertmap->created_on = is_timestamp_new-timestamp.
      endif.
    endloop.
  endif.

* ---- Password administrative information: Change date ----------------*
  if ms_manager-sn_password = go_persistence->co_node_status_checked.
    ms_segment_header-actual-pwdchgdate = is_timestamp_new-datum.

    clear: ls_pwdhistory.
    ls_pwdhistory-mandt = sy-mandt.
    ls_pwdhistory-bname = ms_manager-bname.

*   Transfer old pwdhistory treatment to newest version
    if  ms_segment_header-actual-pwdhistory is not initial. " --> it's pwdhistory = '1' in this case!
*     Transfer last active password information to history
      if ms_segment_header-before_image-pwdinitial = if_identity=>co_pwdinitial_productive.
        ls_pwdhistory-timestamp      = is_timestamp_new-timestamp.
        read table ms_segment_pwdhistory-actual
          with key bname = ls_pwdhistory-bname timestamp = is_timestamp_old-timestamp
          transporting no fields.
        if sy-subrc = 0.
          modify ms_segment_pwdhistory-actual index sy-tabix from ls_pwdhistory transporting timestamp.
        endif.
      endif.
    endif.
  endif.

* ---- User Stamp information ------------------------------------*
  if ms_segment_userstamp-status = go_persistence->co_seg_changed.
    loop at ms_segment_userstamp-actual reference into lr_userstamp.
      lr_userstamp->moddate = is_timestamp_new-datum.
      lr_userstamp->modtime = is_timestamp_new-uzeit.
    endloop.
  endif.

endmethod.


method SET_LOGONDATA.
*
* List of messages that can be raised during this method:
*
* Node Logondata (SUID_ST_NODE_LOGONDATA):
*
* - Fields Valid from and Valid to (GLTGV and GLTGB):
*     E105(01) - Invalid time interval: Start date &1 after end date &2
*     E003(S5) - Month & is not plausible
*     E004(S5) - Day & in month & is not plausible
*     E006(S5) - Day & is not plausible
* - Field User Group (CLASS):
*     E518(01) - User group & does not exist
* - Field User Type (USTYP)
*     E519(01) - Invalid user type &
* - Field Alias (USERALIAS)
*     E189(01) - The alias & already exists
* - Field SECURITY_POLICY
*     E001(security_policy) - Security policy does not exist
*     E016(security_policy) - No authorization to assign secpol


  data: ls_check_logondata   type        suid_st_node_logondata
      , ls_old_logondata     type        suid_st_node_logondata
      , lr_field             type ref to suid_node_field
      , lv_error             type        abap_bool
      , lt_change_fields     type        suid_tt_fields
      , lv_no_maintain       type        sesf_boolean
      , lv_lifetimeonce_only type        xfeld
      , ls_msg               type        symsg
      , lv_class_checked     type        sesf_boolean
      , lv_reject_class      type        sesf_boolean
      , lv_reject_secpol     type        sesf_boolean
      .

  field-symbols:
         <lv_newfield>     type any
       , <lv_checkfield>   type any
       .


  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  " --- Transaction handling ---------------------------------
  "
  " Set values only in CREATE or CHANGE mode
  call method checks_before_access
    exporting
      iv_method      = 'S' " Call from SET method
      iv_change_node = if_identity_definition=>gc_node_logondata
    importing
      es_msg         = ls_msg.

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Lazy fetch of refuser and address segment
  if ms_segment_refuser-bname is initial.
    call method fetch_segment_refuser.
  endif.
  if ms_segment_address-bname is initial.
    call method fetch_segment_address.
  endif.

  " Read from actual image into old structure
  move-corresponding ms_segment_header-actual            to ls_old_logondata.
  move               ms_segment_refuser-actual-useralias to ls_old_logondata-useralias.
  move               ms_segment_address-actual-kostl     to ls_old_logondata-kostl.


  " Delete all notification belonging to this node
  call method go_notify->delete_notifications
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_logondata.


  " --- Set values ------------------------------------------
  "
  " Fill check structure with old data first
  move ls_old_logondata to ls_check_logondata.

  if it_change_fields is initial.
    " All messages (lifetime_once and permanent) should be deleted for the node

    " Get list of fields belonging to the node
    call method cl_suid_tools=>get_node_fields
      exporting
        iv_node_name   = if_identity_definition=>gc_node_logondata
      importing
        et_node_fields = lt_change_fields.
  else.
    lt_change_fields = it_change_fields.
    " Fields GLTGB, GLTGV should be operated together, because message
    " w105(01) - "Ungültiges Zeitintervall: Beginndatum &1 größer als Endedatum &2"
    " is triggered for one field but belongs to both fields.
    data lv_i type i value 0.
    loop at lt_change_fields assigning <lv_checkfield>.
      case <lv_checkfield>.
        when if_identity_definition=>gc_field_logondata_gltgb.
          lv_i = lv_i - 1.
        when if_identity_definition=>gc_field_logondata_gltgv.
          lv_i = lv_i + 1.
      endcase.
    endloop.
    case lv_i.
      when -1.
        append if_identity_definition=>gc_field_logondata_gltgv to lt_change_fields.
      when 1.
        append if_identity_definition=>gc_field_logondata_gltgb to lt_change_fields.
    endcase.
    sort lt_change_fields.
    delete adjacent duplicates from lt_change_fields.
    " Only lifetime_once messages should be deleted for the node
    lv_lifetimeonce_only = if_identity=>co_true.
  endif.

  " Delete messages belonging to this node
  call method go_msg_buffer->delete_object_message
    exporting
      iv_bname             = ms_manager-bname
      iv_nodename          = if_identity_definition=>gc_node_logondata
      iv_lifetimeonce_only = lv_lifetimeonce_only.


  loop at lt_change_fields reference into lr_field.
    if it_change_fields is not initial.
      " Delete lifetime_permanent messages  belonging to this field
      call method go_msg_buffer->delete_object_message
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_logondata
          iv_field    = lr_field->*.
    endif.

    if lr_field->* = if_identity_definition=>gc_field_logondata_classtext.
      delete lt_change_fields.
      continue.       " Text of user group must not be modified by SET
    endif.


    " Check SCUM settings in child system
    if gv_cua_child        = if_identity=>co_true and
       iv_ignore_cua_flags = if_identity=>co_false.
      " Check if field can be changed
      call method cua_if_field_no_maintain
        exporting
          iv_node_name   = if_identity_definition=>gc_node_logondata
          iv_field_name  = lr_field->*
          io_msg_buffer  = go_msg_buffer
        receiving
          rv_no_maintain = lv_no_maintain.

      " Field can't be maintained --> delete it from further processing
      if lv_no_maintain = if_identity=>co_true.
        delete lt_change_fields.
        continue.
      endif.
    endif.

    " If we are changing only one field from gltgv, gltgb - do not reset value of the second field
    case lv_i.
      when -1.
        if lr_field->* = if_identity_definition=>gc_field_logondata_gltgv.
          continue.
        endif.
      when 1.
        if lr_field->* = if_identity_definition=>gc_field_logondata_gltgb.
          continue.
        endif.
    endcase.

    " Set new field value if possible
    assign component lr_field->* of structure is_logondata to <lv_newfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    assign component lr_field->* of structure ls_check_logondata to <lv_checkfield>.
    if sy-subrc ne 0.
      macro_raise_internal_error.
    endif.

    " Move node field
    <lv_checkfield> = <lv_newfield>.
  endloop.

  " If no field can be changed - leave
  if lt_change_fields is initial.
    return.
  endif.


  " --- Check values ------------------------------------------
  " Checks are only concerning header and defaults segment !
  "
  call method cl_identity=>check_logondata_internal
    exporting
      iv_bname         = ms_manager-bname
      it_check_fields  = lt_change_fields
      io_msg_buffer    = go_msg_buffer
      io_notify        = go_notify
      iv_modus         = ms_manager-modus
      io_idref         = me
      iv_secpol_old    = ls_old_logondata-security_policy
    importing
      ev_class_checked = lv_class_checked
      ev_reject_class  = lv_reject_class
      ev_reject_secpol = lv_reject_secpol
    changing
      cs_logondata     = ls_check_logondata.

  " If usergroup/security policy can not be assigned, it must be reset to old value
  if lv_reject_class = if_identity=>co_true.
    ls_check_logondata-class = ls_old_logondata-class.
  endif.
  if lv_reject_secpol = if_identity=>co_true.
    ls_check_logondata-security_policy = ls_old_logondata-security_policy.
  endif.

  " --- Move values to segements -------------------------------
  "
  if ms_manager-modus      eq go_persistence->co_ta_modus_create and " Create User
     lv_class_checked      eq if_identity=>co_true.                  " Class is valid now
    ms_manager-class_checked = if_identity=>co_true.
  endif.
  move-corresponding ls_check_logondata           to ms_segment_header-actual.
  move               sy-mandt                     to ms_segment_header-actual-mandt.
  move               ms_manager-bname             to ms_segment_header-actual-bname.
  move               ls_check_logondata-useralias to ms_segment_refuser-actual-useralias.
  move               sy-mandt                     to ms_segment_refuser-actual-mandt.
  move               ms_manager-bname             to ms_segment_refuser-actual-bname.
  move               ls_check_logondata-kostl     to ms_segment_address-actual-kostl.
  move               sy-mandt                     to ms_segment_address-actual-mandt.
  move               ms_manager-bname             to ms_segment_address-actual-bname.

  " Referenceuser -> Deaktivate PW is not set so far
  if ls_check_logondata-ustyp eq co_usertype_reference.
    if ms_segment_header-actual-codvn is initial. " Deactivate PW if it is not set so far
      if_identity_password~password_deactivate( ).
    endif.
  endif.


  " --- Transaction handling ---------------------------------
  "
  " Notification
  if ls_check_logondata ne ls_old_logondata.
    call method go_notify->notify_update
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_logondata.
  endif.

  " New transaction status: UNCHECKED
  ms_manager-status = go_persistence->co_ta_status_unchecked.

* Check status:
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_logondata
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.  "  New node status: CHECKED
    ms_manager-sn_logondata = go_persistence->co_node_status_checked.
  else.                     "  New node status: CHANGED
    ms_manager-sn_logondata = go_persistence->co_node_status_changed.
  endif.

  " Set segment change flag
  if ms_segment_address-actual ne ms_segment_address-before_image.
    ms_segment_address-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_address-status.
  endif.
  if ms_segment_header-actual ne ms_segment_header-before_image.
    ms_segment_header-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_header-status.
  endif.
  if ms_segment_refuser-actual ne ms_segment_refuser-before_image.
    ms_segment_refuser-status = go_persistence->co_seg_changed.
  else.
    clear: ms_segment_refuser-status.
  endif.

endmethod.


METHOD set_optimistic_to_excl_lock.

* Assumption: importing parameter it_bname contains verified BNames
* There is no existence check of the content of it_bname

  DATA: lt_bname                 TYPE suid_tt_bname.
  DATA: lr_bname                 TYPE REF TO suid_st_bname.
  DATA: lt_bname_not_locked      TYPE suid_tt_bname_locked.
  DATA: lr_bname_no_lock         TYPE REF TO suid_st_bname_locked.
  DATA: lr_control               TYPE REF TO ty_control.

* initialize return value.
  eo_msg_buffer = go_msg_buffer.

* check gt_control table for it_bname
* if gt_control entry exists and lock mode is optimistic: put in lt_bname
* in order to call enqueue with this internal table later
  LOOP AT it_bname REFERENCE INTO lr_bname.
    READ TABLE gt_control REFERENCE INTO lr_control
      with key bname = lr_bname->bname
      BINARY search.
    IF sy-subrc = 0.
*   Make sure that only following case is handled:
*     enqueue mode changes from state
*       co_lock_mode_opt -> co_lock_mode_opt_to_excl -> co_lock_mode_xclusive
      IF lr_control->idref->ms_manager-enqmode EQ if_identity=>co_enqueue_mode_optimistic.
        INSERT lr_bname->* INTO TABLE lt_bname.
      ENDIF.
    ELSE.
      CONTINUE.
    ENDIF.
  ENDLOOP.

  IF lt_bname IS NOT INITIAL.
    SORT lt_bname BY bname.
    DELETE ADJACENT DUPLICATES FROM lt_bname.
    CALL METHOD cl_suid_tools=>enqueue
      EXPORTING
        it_bname   = lt_bname
        i_enq_mode = cl_suid_tools=>co_lock_mode_opt_to_excl
      IMPORTING
        et_bname   = lt_bname_not_locked.

* Provide error message
    IF lt_bname_not_locked IS NOT INITIAL.
      LOOP AT lt_bname_not_locked REFERENCE INTO lr_bname_no_lock.

        CALL METHOD go_msg_buffer->add_object_message_symsg
          EXPORTING
            iv_bname    = lr_bname_no_lock->bname
            iv_nodename = if_identity_definition=>gc_node_root
            iv_lifetime = cl_suid_msg_buffer=>if_suid_msg_buffer~co_lifetime_once
            is_msg      = lr_bname_no_lock->msg.

*       update table so it contains only successfully locked users
        READ TABLE lt_bname
             with key bname = lr_bname_no_lock->bname
             BINARY search
             TRANSPORTING no fields.

        IF sy-subrc = 0.  " Identity could not be locked: Don't instantiate!
          DELETE lt_bname INDEX sy-tabix.
        ENDIF.

      ENDLOOP.
    ENDIF.

*   update value of enqmode in data structure ms_manager of affected
*   instances
    LOOP AT lt_bname REFERENCE INTO lr_bname.

      READ TABLE gt_control REFERENCE INTO lr_control
        with key bname = lr_bname->bname
        BINARY search.

      IF sy-subrc = 0.
        lr_control->idref->ms_manager-enqmode = cl_suid_tools=>co_enqueue_mode_opt_to_excl.
      ELSE.
        CONTINUE.
      ENDIF.

    ENDLOOP.

* Provide exception
    IF lt_bname_not_locked IS NOT INITIAL.
*  read first entry
      READ TABLE lt_bname_not_locked INDEX 1
        REFERENCE INTO lr_bname_no_lock.
      RAISE EXCEPTION TYPE cx_suid_identity
        EXPORTING
          textid    = cx_suid_identity=>invalid_enqueue_lock
          bname     = lr_bname_no_lock->bname
          enq_mode  = cl_suid_tools=>co_lock_mode_opt_to_excl.
    ENDIF.

  ENDIF.

ENDMETHOD.


method set_persdata_modified_flag.
* MS_MANAGER-FLG_PERS_MODIFIED is set to 'X', which means that personalization
* data will be saved and occasionly distributed to child systems
* MS_MANAGER-STATUS is set to go_persistence->co_ta_status_unchecked

* Check if system update is running is executed for every method call

  data: lr_control type ref to ty_control
      .

* Read corresponding entry from gt_control
  read table gt_control reference into lr_control
     with key bname = iv_bname
     binary search.
  if sy-subrc = 0.
    lr_control->idref->persdata_set_modified( ).
  endif.

endmethod.


method set_personname.

  data: ls_msg                 type        symsg
      , lv_error               type        sesf_boolean
      , lr_field               type ref to suid_node_field
      , lt_change_fields       type        suid_tt_fields
      , lv_no_maintain         type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_person_name
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  " Delete all notification belonging to this node
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name ).


  "------ Change address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
        " MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person_name
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person          or
         if_identity=>co_idad_person_org_rela.

      if ms_segment_address-actual-bpperson is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '011'.
        " MSG: Es ist kein Geschäftspartner zugeordnet.
        if 1 = 0. message e011(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_person_name
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      else.

        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '666'.
        " MSG: Aktion nicht zulaessig.
        if 1 = 0. message e666(suid01). endif.
        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_organization
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      endif.

      return.

    "------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '030'.
      " MSG: Arbeitsplatzdaten eines Mitarbeiters dürfen nicht gepflegt werden
      if 1 = 0. message e030(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person_name
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_person_name
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  " Set values

  " Set all fields
  if it_change_fields is initial.
    " Get list of fields belonging to the node
    cl_suid_tools=>get_node_fields(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_person_name
      importing
        et_node_fields = lt_change_fields ).
  else.
    " Set only selected fields
    lt_change_fields = it_change_fields.
  endif.

  " Check of SCUM settings in child system
  if gv_cua_child = if_identity=>co_true and iv_ignore_cua_check eq if_identity=>co_false.
    loop at lt_change_fields reference into lr_field.
      cua_if_field_no_maintain(
        exporting
          iv_node_name      = if_identity_definition=>gc_node_person_name
          iv_field_name     = lr_field->*
          io_msg_buffer     = go_msg_buffer
        receiving
          rv_no_maintain    = lv_no_maintain ).

      " Field can't be maintained --> delete it from further processing
      if lv_no_maintain = if_identity=>co_true.
        delete lt_change_fields.
      endif.
    endloop.
  endif.

  " If no field can be changed - leave
  if lt_change_fields is initial.
    return.
  endif.

  "--- Call BAS--------------------------------------
  " Change old user "type 3" address
  try.
    addr_change_address(
      exporting
        iv_change_node        = if_identity_definition=>gc_node_person_name
        is_personname         = is_personname
        it_change_fields      = lt_change_fields ).

  catch cx_suid_identity.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
    " MSG: Schiefstand bei Adresse.
    if 1 = 0. message e022(01). endif.

    go_msg_buffer->add_object_message_symsg(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_person_name
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

    return.
  endtry.

* --- Transaction handling ---------------------------------

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  go_msg_buffer->find_error_for_node(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_person_name
    receiving
      ev_error    = lv_error ).

  if lv_error eq if_identity=>co_false.     " New node status: CHECKED
    ms_manager-sn_person_name = go_persistence->co_node_status_checked.
  else.                                     " New node status: CHANGED
    ms_manager-sn_person_name = go_persistence->co_node_status_changed.
  endif.

endmethod.


method set_pfud_profiles.
*
* Use case:
* - Profile comparison (PFCG / PFUD)
* - Method allows to set generated profiles only
* - IT_PROFILES should be replaced by IT_ROLES
*

  data: lt_profiles                 type suid_tt_node_profiles.

  " initialize export parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

  lt_profiles = it_profiles.

  call method me->profile_set
    exporting
      iv_allow_generated_profiles = if_identity=>co_true
    importing
      eo_msg_buffer               = eo_msg_buffer
      eo_notify                   = eo_notify
    changing
      ct_profiles                 = lt_profiles.


endmethod.


method set_pfud_roles.
*
* Uses cases:
* - No Manual assignments of roles like SU01
* - HR role assignment
* - Role assignment in PFCG
* - Collective role comparison
* - not in central system with global role assignment
* - Always do role resolving
* - No profile comparison
*

  eo_msg_buffer   = go_msg_buffer.
  eo_notify       = go_notify.

  call method me->roles_set_internal
    exporting
      iv_check_compare_profiles = if_identity=>co_false
      iv_do_compare_profiles    = if_identity=>co_false
      iv_set_extended           = if_identity=>co_true
      iv_do_role_resolving      = if_identity=>co_true
      it_roles                  = it_roles
    importing
      eo_msg_buffer             = eo_msg_buffer
      eo_notify                 = eo_notify.

endmethod.


method set_tcode_mode.

  mv_tcode_mode = iv_tcode_mode.

endmethod.


method set_unit_test_mode.

  " This flag actually just allows that users starting with "!" can be created (!ACMTST...)
  mv_unit_test_mode = if_identity=>co_true.

  " By setting this flag, some time consuming activities related to SAP Office (and other things)
  " are omitted. They are not needed for the ACM unit tests, and especially deletion of
  " SAP Office users was very expensive (it searched 99999 user names to find the one to delete...).
  " This line of code reduced the test exectution time from 30 seonds to 2 (in April 2015).
  " Change discussed with D025633.
  "
  " This flag is typically set in CLASS_CONSTRUCTOR using a function module, for the ACM unit
  " tests it is sufficient to change its value here. The code in CLASS_CONSTRUCTOR after the
  " determination of the flag value until the end of the method does not evaluate it.
  gv_upg_is_shadow_system = if_identity=>co_true.

endmethod.


method set_workplacedata.

  data: ls_msg                 type        symsg
      , lv_error               type        sesf_boolean
      , lr_field               type ref to suid_node_field
      , lt_change_fields       type        suid_tt_fields
      , lv_no_maintain         type        sesf_boolean
      .

  " Exporting parameter
  eo_msg_buffer = go_msg_buffer.
  eo_notify     = go_notify.

* --- Transaction handling ---------------------------------

  " Set values only in CREATE or CHANGE mode
  checks_before_access(
    exporting
      iv_method      = 'S'
      iv_change_node = if_identity_definition=>gc_node_workplace
    importing
      es_msg         = ls_msg ).

  if ls_msg-msgty = 'E'.
    " Return to caller
    return.
  endif.

  " Check address buffer
  if ms_segment_address-bname is initial.
    fetch_segment_address( ).
  endif.

  " Delete all notification belonging to this node
  go_notify->delete_notifications(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).

  " Delete all messages belonging to this node
  go_msg_buffer->delete_object_message(
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace ).


  "------ Change address depending on identity model -----------
  case ms_segment_address-actual-idadtype.

    "------ Old type 3 address assigned -------------------------
    when if_identity=>co_idad_olduser.

      if ms_segment_address-actual-addrnumber is initial.
        clear: ls_msg.
        ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '012'.
        " MSG: Es ist keine Firma zugeordnet.
        if 1 = 0. message e012(suid01). endif.

        go_msg_buffer->add_object_message_symsg(
          exporting
            iv_bname    = ms_manager-bname
            iv_nodename = if_identity_definition=>gc_node_workplace
            is_msg      = ls_msg
            iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

        return.
      endif.

    "------ Person is assigned -----------------------------------
    when if_identity=>co_idad_person.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '013'.
      " MSG: Es ist keine Organisation zugeordnet.
      if 1 = 0. message e013(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Person-BPOrg-Rel is assigned --------------------------
    when if_identity=>co_idad_person_org_rela.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '666'.
      " MSG: Aktion nicht zulaessig.
      if 1 = 0. message e666(suid01). endif.
      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_organization
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Person-Org-Relation address assigned -------------------------
    when if_identity=>co_idad_employee.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '030'.
      " MSG: Arbeitsplatzdaten eines Mitarbeiters dürfen nicht gepflegt werden
      if 1 = 0. message e030(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Technical User ---------------------------------------
    when if_identity=>co_idad_techuser.

      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'SUID01'. ls_msg-msgno = '010'.
      " MSG: Bei einem technischen Benutzer können keine Adressdaten gepflegt werden.
      if 1 = 0. message e010(suid01). endif.

      go_msg_buffer->add_object_message_symsg(
        exporting
          iv_bname    = ms_manager-bname
          iv_nodename = if_identity_definition=>gc_node_workplace
          is_msg      = ls_msg
          iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

      return.

    "------ Parameter error -----------------------------------
    when others.
      macro_raise_internal_error.

  endcase.

  " Set values

  " Set all fields
  if it_change_fields is initial.
    " Get list of fields belonging to the node
    cl_suid_tools=>get_node_fields(
      exporting
        iv_node_name   = if_identity_definition=>gc_node_workplace
      importing
        et_node_fields = lt_change_fields ).
  else.
    " Set changed fields only
    lt_change_fields = it_change_fields.
  endif.

  if gv_cua_child = if_identity=>co_true and iv_ignore_cua_check eq if_identity=>co_false.
    loop at lt_change_fields reference into lr_field.
      cua_if_field_no_maintain(
        exporting
          iv_node_name      = if_identity_definition=>gc_node_workplace
          iv_field_name     = lr_field->*
          io_msg_buffer     = go_msg_buffer
        receiving
          rv_no_maintain    = lv_no_maintain ).

      " Field can't be maintained --> delete it from further processing
      if lv_no_maintain = if_identity=>co_true.
        delete lt_change_fields.
      endif.
    endloop.
  endif.

  " If no field can be changed - leave
  if lt_change_fields is initial.
    return.
  endif.

  "--- Call BAS--------------------------------------
  " Change old user "type 3" address
  try.
    addr_change_address(
      exporting
        iv_change_node        = if_identity_definition=>gc_node_workplace
        is_workplace          = is_workplace
        it_change_fields      = lt_change_fields ).

  catch cx_suid_identity.
    ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '022'.
    " MSG: Schiefstand bei Adresse.
    if 1 = 0. message e022(01). endif.

    go_msg_buffer->add_object_message_symsg(
      exporting
        iv_bname    = ms_manager-bname
        iv_nodename = if_identity_definition=>gc_node_workplace
        is_msg      = ls_msg
        iv_lifetime = if_suid_msg_buffer=>co_lifetime_once ).

    return.
  endtry.

* --- Transaction handling ---------------------------------

  " New transaction status: UNCHECKED
  ms_manager-status  = go_persistence->co_ta_status_unchecked.

  " Check error status of node
  call method go_msg_buffer->find_error_for_node
    exporting
      iv_bname    = ms_manager-bname
      iv_nodename = if_identity_definition=>gc_node_workplace
    receiving
      ev_error    = lv_error.

  if lv_error eq if_identity=>co_false.   " New node status: CHECKED
    ms_manager-sn_workplace = go_persistence->co_node_status_checked.
  else.                                   " New node status: CHANGED
    ms_manager-sn_workplace = go_persistence->co_node_status_changed.
  endif.

endmethod.


method uclasses_cua_get_changed.
* In CUA central system returns changed Licence data for all systems
* (child systems and central) or/and a list of systems, for which licence
* data was changed

  data: lr_uclass_actual   type ref to   usr06sys
      , lr_uclass_before   type ref to   usr06sys
      , lt_node_fields     type          suid_tt_fields
      , lr_node_field      type ref to   suid_node_field
      , lr_segment_field   type ref to   suid_node_field
      , lr_changed_uclass  type ref to   suid_st_node_cua_uclass
      , lr_changed_system  type ref to   suid_st_node_cua_system
      , lv_central_logsys  type          uszbvlndsc-sendsystem
      .


  clear: et_cua_changed_uclasses.


* Read data only from central system
  if gv_cua_central <> if_identity=>co_true.
    return.
  endif.


  create data: lr_segment_field.

  if ms_segment_cua_uclasses-bname is not initial or ms_segment_uclass-bname is not initial.

*   Evaluate changes for child systems
    if ms_segment_cua_uclasses-before_image ne ms_segment_cua_uclasses-actual.

      if et_cua_changed_uclasses is requested.
*     Get list of fields belonging to the node CUA_UCLASSES
        call method cl_suid_tools=>get_node_fields
          exporting
            iv_node_name   = if_identity_definition=>gc_node_cua_uclass
          importing
            et_node_fields = lt_node_fields.
      endif.


*     Check if new assignments were added or existing assignments were modified
      loop at ms_segment_cua_uclasses-actual reference into lr_uclass_actual.
        read table ms_segment_cua_uclasses-before_image reference into lr_uclass_before
             with key rcvsystem  = lr_uclass_actual->rcvsystem
             binary search.
        if sy-subrc = 0.
*         if existing assignment wasn't modified --> doesn't collect
          if lr_uclass_before->* = lr_uclass_actual->*.
            continue.
          endif.
        endif.

        if et_changed_systems is requested.
          append initial line to et_changed_systems reference into lr_changed_system.
          lr_changed_system->subsystem = lr_uclass_actual->rcvsystem.
        endif.

        if et_cua_changed_uclasses is requested.
          append initial line to et_cua_changed_uclasses reference into lr_changed_uclass.

*         Fill node fields from segment MS_SEGMENT_CUA_UCLASSES
          loop at lt_node_fields reference into lr_node_field.
            call method cl_suid_tools=>map_uclass_nodes_to_segment
              exporting
                iv_node_name     = if_identity_definition=>gc_node_cua_uclass
                iv_node_field    = lr_node_field->*
              importing
                ev_segment_field = lr_segment_field->*.

            call method cl_suid_tools=>set_structure_field_value
              exporting
                iv_field         = lr_node_field->*
                is_get_structure = lr_uclass_actual->*
                iv_get_field     = lr_segment_field->*
              changing
                cs_structure     = lr_changed_uclass->*.
          endloop.
        endif.
      endloop.

*     Check if some assignments were deleted
      loop at ms_segment_cua_uclasses-before_image reference into lr_uclass_before.
        read table ms_segment_cua_uclasses-actual
             with key rcvsystem  = lr_uclass_before->rcvsystem
             transporting no fields
             binary search.
        if sy-subrc <> 0.
          if et_changed_systems is requested.
            append initial line to et_changed_systems reference into lr_changed_system.
            lr_changed_system->subsystem = lr_uclass_before->rcvsystem.
          endif.

          if et_cua_changed_uclasses is requested.
            append initial line to et_cua_changed_uclasses reference into lr_changed_uclass.
            lr_changed_uclass->subsystem = lr_uclass_before->rcvsystem.
            lr_changed_uclass->lic_type  = '00'.
          endif.
        endif.
      endloop.
    endif.

*   Evaluate changes for central system
    if ms_segment_uclass-actual <> ms_segment_uclass-before_image.
*     Get central system name
      call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
        importing
          ev_central_logsys = lv_central_logsys.

      if et_changed_systems is requested.
        append initial line to et_changed_systems reference into lr_changed_system.
        lr_changed_system->subsystem = lv_central_logsys.
      endif.

      if et_cua_changed_uclasses is requested.
        clear: lt_node_fields.
*       Get list of fields belonging to the node UCLASS
        call method cl_suid_tools=>get_node_fields
          exporting
            iv_node_name   = if_identity_definition=>gc_node_uclass
          importing
            et_node_fields = lt_node_fields.

        append initial line to et_cua_changed_uclasses reference into lr_changed_uclass.

*       Fill node fields from segment MS_SEGMENT_UCLASS
        loop at lt_node_fields reference into lr_node_field.
          call method cl_suid_tools=>map_uclass_nodes_to_segment
            exporting
              iv_node_name     = if_identity_definition=>gc_node_uclass
              iv_node_field    = lr_node_field->*
            importing
              ev_segment_field = lr_segment_field->*.

          call method cl_suid_tools=>set_structure_field_value
            exporting
              iv_field         = lr_node_field->*
              is_get_structure = ms_segment_uclass-actual
              iv_get_field     = lr_segment_field->*
            changing
              cs_structure     = lr_changed_uclass->*.
        endloop.

        lr_changed_uclass->subsystem = lv_central_logsys.
      endif.

    endif.

    sort et_cua_changed_uclasses by subsystem.
    delete adjacent duplicates from et_cua_changed_uclasses comparing subsystem.

    sort et_changed_systems by subsystem.
    delete adjacent duplicates from et_changed_systems comparing subsystem.

  endif.

endmethod.


method uclass_check_spec_conditions.
* Common checks of special conditions for License type for nodes GC_NODE_CUA_UCLASS and GC_NODE_UCLASS

* When calling for CUA case parameters IV_SUBSYSTEM and IV_KEY_HANDLE should be provided

* ToDo
* !!! Meldungen müssen noch überarbeitet werden !!!
*
* GC_FIELD_UCLASS_SUB_FROM  (SUBSTITUTE_FROM)
*   E256(BV)           - Specify the period of the substitution
*   E257(BV)           - The period for the substitution is invalid
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_FIELD_UCLASS_SUB_UNTIL (SUBSTITUTE_UNTIL)
*   E256(BV)           - Specify the period of the substitution
*   E017(BV)           - &1 is in the past
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_FIELD_UCLASS_SYSID     (SYSID)
*   E258(BV)           - Specify "&1" as the system of the substituted user
*   E261(BV)           - The name of the system with the chargeable user is missing
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_FIELD_UCLASS_CLIENT    (CLIENT)
*   E259(BV)           - Specify "&1" as the client of the substituted user
*   E262(BV)           - The client with the chargeable user in system &1 is missing
*   E284(BV)           - Parameter &1 must not be filled for this user type
* GC_FIELD_UCLASS_BNAME_CHARGE (BNAME_CHARGEABLE)
*   E263(BV)           - Specify the user ID of the chargeable user
*   E753(01)           - User identical to substitute
*   E270(BV)           - Der vertretene Benutzer &1 existiert im logischen System &2 nicht
*   E260(BV)           - Substitued user &1 does not exist
*   E088(BV)           - User type 11 in the same system/client is not permitted
*   E284(BV)           - Parameter &1 must not be filled for this user type


  data: ls_msg              type          symsg
      , lv_bname            type          usr02-bname
      , lt_child_systems    type table of uszbvlndrc
      , lv_central_logsys   type          uszbvlndsc-sendsystem
      , lv_key              type          suid_node_key
      , lv_field            type          suid_node_field
      , lr_child_system     type ref to   uszbvlndrc
      , lv_status           type          uszbvsys-status
      , lv_sysid            type          sysysid
      , lv_mandt            type          mandt
      , lv_lifetime         type          if_suid_msg_buffer=>ty_msg_lifetime
      .


* ---------------------------------------------------------------------
*
* Is there any classification => we don't have to check this parameter.
  if is_uclass is initial.
    return.
  endif.

  if iv_cua_case = if_identity=>co_true and iv_subsystem is initial.
    raise exception type cx_suid_identity
      exporting
        textid    = cx_suid_identity=>internal_error
        bname     = iv_bname.
  endif.

*   In case of SU01 Check, always use lifetime_permanent
  if iv_bname is not initial.
    lv_lifetime = if_suid_msg_buffer=>co_lifetime_permanent.
*   In case of SU10 Check, always use lifetime_once
  else.
    lv_lifetime = if_suid_msg_buffer=>co_lifetime_once.
  endif.

  if iv_cua_case = if_identity=>co_true.
*   Get central and child systems
    call method cl_suid_cua=>if_suid_cua_runtime~get_cua_landscape
      importing
        ev_central_logsys    = lv_central_logsys
        et_cua_child_systems = lt_child_systems.
    if iv_subsystem <> lv_central_logsys.
      read table lt_child_systems reference into lr_child_system
           with key rcvsystem = iv_subsystem
           binary search.
      if sy-subrc = 0.
        lv_sysid = lr_child_system->sysname.
        lv_mandt = lr_child_system->sysclient.
      endif.
    else.
      lv_sysid = sy-sysid.
      lv_mandt = sy-mandt.
    endif.
  else.
    lv_sysid = sy-sysid.
    lv_mandt = sy-mandt.
  endif.

  lv_key = iv_subsystem.


* --- Check ------------------------------------------
* User type 04 (Substitute)
  if is_uclass-lic_type eq '04'.
*   Check the time frame for the substitute
    if is_uclass-substitute_from is initial or
       is_uclass-substitute_until is initial.
      clear: ls_msg, lv_field.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '256'.
*     MSG: Bitte geben Sie den Zeitraum der Stellvertretung an!
      if 1 = 0. message e256(bv). endif.    "#EC *
      if is_uclass-substitute_from is initial.
        lv_field = if_identity_definition=>gc_field_uclass_sub_from.
      elseif is_uclass-substitute_until is initial.
        lv_field = if_identity_definition=>gc_field_uclass_sub_until.
      endif.

      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = lv_field
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = lv_field
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
*    "adapted accordingly note 1128421
*    elseif is_uclass-substitute_until lt sy-datum.
*      clear: ls_msg.
*      ls_msg-msgv1 = is_uclass-substitute_until.
*      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '017'.
**     MSG: &1 liegt in der Vergangenheit
*      if 1 = 0. message e017(bv) with ls_msg-msgv1. endif.    "#EC *
*      if iv_cua_case = if_identity=>co_false.
*        call method io_msg_buffer->add_object_message_symsg
*          exporting
*            iv_bname    = iv_bname
*            iv_nodename = iv_nodename
*            iv_field    = if_identity_definition=>gc_field_uclass_sub_until
*            is_msg      = ls_msg
*            iv_lifetime = lv_lifetime.
*      else.
*        call method io_msg_buffer->add_object_message_symsg
*          exporting
*            iv_bname      = iv_bname
*            iv_nodename   = iv_nodename
*            iv_key        = lv_key
*            iv_key_handle = iv_key_handle
*            iv_field      = if_identity_definition=>gc_field_uclass_sub_until
*            is_msg        = ls_msg
*            iv_lifetime   = lv_lifetime.
*      endif.

    elseif is_uclass-substitute_from gt is_uclass-substitute_until.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '257'.
*     MSG: Der Zeitraum für die Stellvertretung ist ungültig!
      if 1 = 0. message e257(bv). endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sub_from
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sub_from
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    endif.

*   Check the chargeable user
    if is_uclass-sysid ne lv_sysid.
      clear: ls_msg.
      ls_msg-msgv1 = lv_sysid.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '258'.
*     MSG: Bitte geben Sie "&1" als System des vertretenen Nutzers an!
      if 1 = 0. message e258(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sysid
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sysid
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    elseif is_uclass-client <> lv_mandt.
      clear: ls_msg.
      ls_msg-msgv1 = lv_mandt.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '259'.
*     MSG: Bitte geben Sie "&1" als Mandant des vertretenen Nutzers an!
      if 1 = 0. message e259(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_client
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_client
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    elseif is_uclass-bname_chargeable is initial.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '263'.
*     MSG: Bitte geben Sie die Nutzer-ID des kostenpflichtigen Nutzers an!
      if 1 = 0. message e263(bv). endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    elseif is_uclass-bname_chargeable eq iv_bname.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = '01'. ls_msg-msgno = '753'.
*     MSG: Benutzer ist identisch mit dem Stellvertreter
      if 1 = 0. message e753(01). endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    else.
*     CUA case
      if iv_cua_case = if_identity=>co_true and iv_subsystem <> lv_central_logsys.
*       Check whether the chargeable user assigned to the system
        select single status
                 into lv_status from uszbvsys
                where bname      = is_uclass-bname_chargeable
                  and usrsection = 'USER'
                  and subsystem  = iv_subsystem.
        if sy-subrc  ne 0 or
         ( lv_status eq 'D' or lv_status eq 'A' or lv_status eq 'X' ).
          clear: ls_msg.
          ls_msg-msgv1 = is_uclass-bname_chargeable.
          ls_msg-msgv2 = iv_subsystem.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '270'.
*         MSG: Der vertretene Benutzer &1 existiert im logischen System &2 nicht.
          if 1 = 0. message e270(bv) with ls_msg-msgv1 ls_msg-msgv2. endif.    "#EC *
          call method io_msg_buffer->add_object_message_symsg
            exporting
              iv_bname      = iv_bname
              iv_nodename   = iv_nodename
              iv_key        = lv_key
              iv_key_handle = iv_key_handle
              iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
              is_msg        = ls_msg
              iv_lifetime   = lv_lifetime.
        endif.

*     Local
      else.
*       Check whether the chargeable user exists.
        select single bname
                 into lv_bname
                 from usr02
                where bname = is_uclass-bname_chargeable.
        if sy-subrc ne 0.
          clear: ls_msg.
          ls_msg-msgv1 = is_uclass-bname_chargeable.
          ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '260'.
*         MSG: Substitued user &1 does not exist
          if 1 = 0. message e260(bv) with ls_msg-msgv1. endif.    "#EC *
          if iv_cua_case = if_identity=>co_false.
            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname    = iv_bname
                iv_nodename = iv_nodename
                iv_field    = if_identity_definition=>gc_field_uclass_bname_charge
                is_msg      = ls_msg
                iv_lifetime = lv_lifetime.
          else.
            call method io_msg_buffer->add_object_message_symsg
              exporting
                iv_bname      = iv_bname
                iv_nodename   = iv_nodename
                iv_key        = lv_key
                iv_key_handle = iv_key_handle
                iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
                is_msg        = ls_msg
                iv_lifetime   = lv_lifetime.
          endif.

        endif.
      endif.
    endif.

* User type 11 (Multi-client/-system)
  elseif is_uclass-lic_type = '11'.
*    Check the chargeable user
    if is_uclass-sysid is initial.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '261'.
*     MSG: Der Name des Systems mit dem kostenpflichtigen Nutzer fehlt!
      if 1 = 0. message e261(bv). endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sysid
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sysid
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    elseif is_uclass-client is initial.
      clear: ls_msg.
      ls_msg-msgv1 = is_uclass-sysid.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '262'.
*     MSG: Der Mandant mit dem kostenpflichtigen Nutzer im System &1 fehlt!
      if 1 = 0. message e262(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_client
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_client
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    elseif is_uclass-bname_chargeable is initial.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '263'.
*     MSG: Specify the user ID of the chargeable user
      if 1 = 0. message e263(bv). endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.

    elseif is_uclass-sysid  = lv_sysid     and
           is_uclass-client = lv_mandt.
      clear: ls_msg.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '088'.
*     MSG: User type 11 in the same system/client is not permitted
      if 1 = 0. message e088(bv). endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

*   Some fields must not be filled
    if is_uclass-substitute_from is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_sub_from.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sub_from
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sub_from
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

    if is_uclass-substitute_until is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_sub_until.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sub_until
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sub_until
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

* Other User types
  else.

*   Some fields must not be filled
    if is_uclass-substitute_from is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_sub_from.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sub_from
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sub_from
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

    if is_uclass-substitute_until is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_sub_until.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sub_until
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sub_until
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

    if is_uclass-sysid is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_sysid.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_sysid
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_sysid
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

    if is_uclass-client is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_client.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_client
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_client
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

    if is_uclass-bname_chargeable is not initial.
      clear: ls_msg.
      ls_msg-msgv1 = if_identity_definition=>gc_field_uclass_bname_charge.
      ls_msg-msgty = 'E'. ls_msg-msgid = 'BV'. ls_msg-msgno = '284'.
*     MSG: Parameter &1 must not be filled for this user type
      if 1 = 0. message e284(bv) with ls_msg-msgv1. endif.    "#EC *
      if iv_cua_case = if_identity=>co_false.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname    = iv_bname
            iv_nodename = iv_nodename
            iv_field    = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg      = ls_msg
            iv_lifetime = lv_lifetime.
      else.
        call method io_msg_buffer->add_object_message_symsg
          exporting
            iv_bname      = iv_bname
            iv_nodename   = iv_nodename
            iv_key        = lv_key
            iv_key_handle = iv_key_handle
            iv_field      = if_identity_definition=>gc_field_uclass_bname_charge
            is_msg        = ls_msg
            iv_lifetime   = lv_lifetime.
      endif.
    endif.

  endif.


endmethod.


METHOD verify_node_fields.

  DATA:  lt_changeable_fields           TYPE        suid_tt_node_fields.
  DATA:  lr_field                       TYPE REF TO suid_st_node_field.
  DATA:  lv_no_maintain                 TYPE        sesf_boolean.
  DATA:  lt_fields                      TYPE        suid_tt_fields.
  DATA:  lv_check_existence             TYPE sesf_boolean VALUE if_identity=>co_false.
  DATA:  lv_valid                       TYPE sesf_boolean.
  data:  lo_property_handler            TYPE REF TO cl_suid_property_handler.

  CLEAR et_changeable_fields.

  lo_property_handler = cl_suid_property_handler=>get_instance( ).

**********************************************************************
*** get fields of node if not provided--------------------------------
  IF it_change_fields IS INITIAL.

*   Get list of fields belonging to this node
    CALL METHOD cl_suid_tools=>get_node_fields
      EXPORTING
        iv_node_name   = iv_node_name
      IMPORTING
        et_node_fields = lt_fields.

    lt_changeable_fields = lt_fields.

  ELSE.
    lt_changeable_fields = it_change_fields.
    lv_check_existence   = if_identity=>co_true.
  ENDIF.

*** verify existence of fields ---------------------------------------
  LOOP AT lt_changeable_fields REFERENCE INTO lr_field.
    IF lv_check_existence EQ if_identity=>co_true.

      lo_property_handler->verify_field_name(
        EXPORTING
          iv_node_name  = iv_node_name
          iv_field_name = lr_field->node_field
        RECEIVING
          ev_valid = lv_valid ).

      IF lv_valid EQ if_identity=>co_false.
        DELETE TABLE lt_changeable_fields
          WITH TABLE KEY node_field = lr_field->node_field.
        CONTINUE. "verify next field
      ENDIF.

    ENDIF.

*** verify if field can be changed according to SCUM settings --------
*   Check SCUM settings in child system
    IF gv_cua_child = if_identity=>co_true.
*     Check if field can be changed
      CALL METHOD cua_if_field_no_maintain
        EXPORTING
          iv_node_name   = iv_node_name
          iv_field_name  = lr_field->node_field
          io_msg_buffer  = go_msg_buffer
        RECEIVING
          rv_no_maintain = lv_no_maintain.

*     Field can't be maintained --> delete it from further processing
      IF lv_no_maintain = if_identity=>co_true.
        DELETE TABLE lt_changeable_fields
          WITH TABLE KEY node_field = lr_field->node_field.
        CONTINUE.
      ENDIF.
    ENDIF.

  ENDLOOP.

  et_changeable_fields = lt_changeable_fields.

ENDMETHOD.
ENDCLASS.