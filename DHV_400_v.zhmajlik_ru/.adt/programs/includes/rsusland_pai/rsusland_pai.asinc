*----------------------------------------------------------------------*
***INCLUDE RSUSLAND_PAI .
*----------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module user_command_0100 input.

  sok_code = ok-code.
  clear ok-code.
  case sok_code.

    when 'GETU'.
      call screen 200.

    when 'LOGS'.
      call function 'SUSR_ZBV_SYSTEMINFO_DISPLAY'.

    when 'LOGP'.
      call function 'SUSR_ZBV_STATUSINFO_DISPLAY'.

    when 'LOGU'.
      call function 'SUSR_ZBV_USERINFO_DISPLAY  '.

    when 'FELD'.
      call screen 300.

    when 'PERR'.
      call function 'SUSR_ZBV_STATUSINFO_DISPLAY'
        exporting
          error_type = 'ERROR'.

    when 'PWAR'.
      call function 'SUSR_ZBV_STATUSINFO_DISPLAY'
        exporting
          error_type = 'WARNING'.

    when 'PSUC'.
      call function 'SUSR_ZBV_STATUSINFO_DISPLAY'
        exporting
          error_type = 'SUCCESS'.

    when 'PUNK'.
      call function 'SUSR_ZBV_STATUSINFO_DISPLAY'
        exporting
          error_type = 'OPEN'.

    when 'DTAL'.                       " Detail display
      display_only = 'X'.
      new_model = ' '.
      perform set_f_200.

    when 'SAVE'.                       " Detail display
      "----------------------------------------------------------------
      "As dynpro 100 (old SCUA) is no longer in use, we can omit
      "writting CUA tables here to be save according the landscape
      "change documents.
      "----------------------------------------------------------------
      "if not usbapilink-bapilink is initial.

      "  modify usbapilink.

      "  call function 'SUSR_ZBV_CENTRALSYSTEM_CHECK'
      "    exceptions
      "      duplicate_central_system = 1
      "      new_system               = 2
      "      not_central              = 3
      "      others                   = 4.

      "  if sy-subrc <> 0.

      "    case sy-subrc.
      "      when 1. message e350(01).                       "ZBV1
      "      when 2. message e355(01) with ' '.              "ZBV1
      "      when 3. message e351(01).                       "ZBV1
      "    endcase.                                          "ZBV1

      "    rollback work.                               "#EC CI_ROLLBACK
      "  else.
      "    commit work.

      "    call function 'SUSR_ZBV_LOCAL_PROFILES_SAVE'
      "      in background task
      "      exporting tcode = sy-tcode.

      "    call function 'SUSR_ZBV_LOCAL_ACTGRPS_SAVE'
      "      in background task
      "      exporting tcode = sy-tcode.

      "  endif.

        " nötig wegen trfc
      "  commit work.

      "  call function 'SUSR_ZBV_LANDSCAPE_SEND'
      "    exceptions
      "      rfc_failure = 0
      "      others      = 0.

      "else.
      "  select single * from usbapilink.
      "  delete usbapilink.
      "  clear usbapilink.
      "  delete from uszbvprot where bname like '%'.
      "  delete from uszbvsys where bname like '%'.
      "  delete from usl04 where bname like '%'.
      "  delete from usla04 where bname like '%'.
      "endif.

      "saved = 'X'.

    when 'DELM'.                       " Detail display
      "clear usbapilink.

    when 'CRTE'.                       " Create
      "if usbapilink-alemodel = ' '.

      "  display_only         = ' '.
      "  uszbvlndsc-modelname = usbapilink-bapilink.
      "  new_model = 'X'.

      "  call screen 220 starting at 1 1 ending at 60 10.

      "  perform set_f_200.

      "else.
      "  call transaction 'BD64'.                         "#EC CI_CALLTA
      "endif.

    when 'CHNG'.                       " Change
      "if usbapilink-alemodel = ' '.

      "  call function 'SCCR_GET_RELEASE_NR'
      "    destination uszbvlndsc-sendsystem
      "    importing
      "      sysid = rm_sysid
      "      mandt = rm_mandt.

      "  if ( rm_sysid <> sy-sysid ) or
      "     ( rm_mandt <> sy-mandt ).
      "    "Sie sind nicht auf dem Zentralsystem angemeldet
      "    message e351(01).
      "  else.
      "    display_only = ' '.
      "    new_model = ' '.
      "    perform set_f_200.
      "  endif.

      "else.
      "  call transaction 'BD64'.                         "#EC CI_CALLTA
      "endif.

    when 'DELE'.                       " Change
      "if usbapilink-alemodel = ' '.
      "  delete from uszbvlndsc where modelname = usbapilink-bapilink.
      "  delete from uszbvlndrc where model     = usbapilink-bapilink.
      "else.
      "  call transaction 'BD64'.                         "#EC CI_CALLTA
      "endif.

    when 'BACK'.                       " Change

      "if saved = ' '.

      "  it_usbapilink = usbapilink.
      "  select single * from usbapilink.

      "  if ( it_usbapilink-bapilink <> usbapilink-bapilink and
      "       it_usbapilink-alemodel <> usbapilink-alemodel     ) or
      "     ( sy-subrc <> 0 ).

      "    usbapilink = it_usbapilink.

      "    concatenate 'Die Zuordnung ist nicht gespeichert.'(v03)
      "                'Möchten Sie wirklich beenden?'(v04)
      "           into text separated by space.

      "    call function 'POPUP_TO_CONFIRM'
      "      exporting
      "        titlebar              = 'Zuordnung Verteilungsmodell'(v02)
      "        text_question         = text
      "        default_button        = '2'
      "        display_cancel_button = space
      "      importing
      "        answer                = answer
      "      exceptions
      "        text_not_found        = 0
      "        others                = 0.

          "Positive answer ---> save changes before leaving the screen
      "    if answer = '1'.
      "      set screen 0.
      "      leave screen.
      "    endif.
      "  else.
      "    set screen 0.
      "    leave screen.
      "  endif.
      "else.
      "  set screen 0.
      "  leave screen.
      "endif.

    when 'STOP'.                       " Change
      set screen 0.
      leave screen.

    when others.
  endcase.
endmodule.                             " USER_COMMAND_0100  INPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0200  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module user_command_0200 input.
  sok_code = ok-code.
  clear ok-code.
  case sok_code.
    when 'GETU'.
      free: gt_usrgetstrc.
      free: userprofiles, useractgrps.
      call screen 401.
    when 'BACK'.
      set screen 0.
      leave screen.
    when 'STOP'.
      set screen 0.
      leave screen.
    when 'ABRT'.
      set screen 0.
      leave screen.
    when others.
  endcase.
endmodule.                             " USER_COMMAND_0200  INPUT

*&---------------------------------------------------------------------*
*&      Module  WRITE_USZBVLNDRC  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*module write_uszbvlndrc input.                              "#EC NEEDED
*
*endmodule.                             " WRITE_USZBVLNDRC  INPUT

*&---------------------------------------------------------------------*
*&      Module  SEARCH_MODEL  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module search_model input.

  refresh: hfields,
           linktab.

  hfields-tabname    = 'USBAPILINK'.
  hfields-fieldname  = 'BAPILINK'.
  hfields-selectflag = 'X'.
  append hfields.

  hfields-tabname    = 'USBAPILINK'.
  hfields-fieldname  = 'ALEMODEL'.
  hfields-selectflag = ' '.
  append hfields.

  dfield-fieldname   = 'USBAPILINK-ALEMODEL'.
  append dfield.

  call function 'DYNP_VALUES_READ'
    exporting
      dyname               = 'RSUSLAND'
      dynumb               = '0100'
    tables
      dynpfields           = dfield
    exceptions
      others               = 0.

  read table dfield index 1.
  usbapilink-alemodel = dfield-fieldvalue.

  call function 'BAPI_ALE_MODEL_GET'
    tables
      bapilinks = it_bapilinks_1.

  loop at it_bapilinks_1 into iv_bapilinks_1
    where   obj_type   = 'USER'.

    linktab-alemodel = 'X'.
    linktab-bapilink = iv_bapilinks_1-cust_model.
    append linktab.

  endloop.

  sort linktab.
  delete adjacent duplicates from linktab.

  if usbapilink-alemodel = ' '.
    select * from uszbvlndsc.
      linktab-alemodel = ' '.
      linktab-bapilink = uszbvlndsc-modelname.
      append linktab.
    endselect.                                          "#EC CI_NOWHERE
  endif.

  call function 'PRGN_HELP_VALUES_GET_NO_DD_NAM'
    exporting
      selectfield                  = 'USBAPILINK-BAPILINK'
    importing
      select_value                 = return
    tables
      fields                       = hfields
      full_table                   = linktab
    exceptions
      others                       = 0.

  usbapilink-bapilink = return.

  loop at linktab where bapilink = usbapilink-bapilink.
    usbapilink-alemodel = linktab-alemodel.
  endloop.

  dfield-fieldname  = 'USBAPILINK-ALEMODEL'.
  dfield-fieldvalue = usbapilink-alemodel.
  append dfield.

  call function 'DYNP_VALUES_UPDATE'
    exporting
      dyname               = 'RSUSLAND'
      dynumb               = '100'
    tables
      dynpfields           = dfield
    exceptions
      invalid_abapworkarea = 1
      invalid_dynprofield  = 2
      invalid_dynproname   = 3
      invalid_dynpronummer = 4
      invalid_request      = 5
      no_fielddescription  = 6
      undefind_error       = 7
      others               = 8.

  if sy-subrc <> 0.
    message id sy-msgid type sy-msgty number sy-msgno
            with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  endif.

endmodule.                             " SEARCH_MODEL  INPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0210  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module user_command_0210 input.

  sok_code = ok-code.
  clear ok-code.

  case sok_code.
    when 'TAKE'.                       " Get Value
      it_uszbvlndrc-model      = usbapilink-bapilink.
      it_uszbvlndrc-rcvsystem  = uszbvlndrc-rcvsystem.
      it_uszbvlndrc-new_system = 'X'.
      append it_uszbvlndrc.
      set screen 0.
      leave screen.

    when 'ABRT'.                       " Change
      set screen 0.
      leave screen.

    when others.
  endcase.

endmodule.                    "USER_COMMAND_0210 INPUT

*&      Module  USER_COMMAND_0220  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module user_command_0220 input.

  sok_code = ok-code.
  clear ok-code.

  case sok_code.
    when 'TAKE'.                       " Get Value
      usbapilink-bapilink = uszbvlndsc-modelname.
      new_model = 'X'.
      set screen 0.
      leave screen.

    when 'ABRT'.                       " Change
      set screen 0.
      leave screen.

    when 'ALEM'.                       " Get ALE-Model
      new_model = ' '.

      call function 'BAPI_ALE_MODEL_GET'
        tables
          bapilinks = it_bapilinks_2.

      clear uszbvlndsc-sendsystem.

      loop at it_bapilinks_2
        where cust_model = uszbvlndsc-modelname
          and obj_type   = 'USER'.

        if uszbvlndsc-sendsystem is initial.

          uszbvlndsc-sendsystem = it_bapilinks_2-sendsystem.

        else.
          if uszbvlndsc-sendsystem <> it_bapilinks_2-sendsystem.

            "ALE-Verteilungsmodell ist inkonsistent
            message i350(01).
          endif.
        endif.

        it_uszbvlndrc-rcvsystem = it_bapilinks_2-rec_system.
        it_uszbvlndrc-model     = it_bapilinks_2-cust_model.
        append it_uszbvlndrc.

      endloop.   "at it_bapilinks_2

      set screen 0.
      leave screen.

    when others.

  endcase.

endmodule.                             " USER_COMMAND_0220  INPUT

*&---------------------------------------------------------------------*
*&      Module  CHECK_INPUT_LOCAL  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module check_input_local input.

  sok_code = ok-code.

  if sok_code <> 'ALEM'.

    call function 'SCCR_GET_RELEASE_NR' destination uszbvlndsc-sendsystem
      importing
        sysid  = remote_sysid
        mandt  = remote_client
      exceptions
        others = 1.

    if sy-subrc <> 0.
      "Das System kann nicht mit RFC Erreicht werden
      message e354(01).
    endif.

    if ( sy-sysid <> remote_sysid ) or
       ( sy-mandt <> remote_client ).
      "Sie sind nicht auf dem Zentralsystem angemeldet
      message e351(01).
    endif.

  endif.

  new_model = ' '.

endmodule.                             " CHECK_INPUT_LOCAL  INPUT

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0300  INPUT
*&---------------------------------------------------------------------*
module user_command_0300 input.

  sok_code = ok-code.
  clear ok-code.
  case sok_code.

    when 'ADDR'.
      field_group         = 'ADDRESS'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'LOCK'.
      field_group         = 'LOCK'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      pager = 1.



    when 'LOGO'.
      field_group        = 'LOGONDATA'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'PARM'.
      field_group         = 'PARAMETERS'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'FEST'.
      field_group         = 'DEFAULTS'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'SNC'.
      field_group         = 'SNC'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'AKTG'.
      field_group         = 'ACTGRP'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'PROF'.
      field_group         = 'PROFILE'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'GROUPS'.
      field_group         = 'GROUPS'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'PERS'.
      field_group         = 'PERSDATA'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.



    when 'LAW'.
      field_group         = 'LAW'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.

    when 'DOCU'.
      field_group         = 'DESCRIPTION'.
      tabstrip1-activetab = sok_code.

      call function 'SUSR_ZBV_FLD_SAVE'
        exporting
          custmodel     = g_bapilink
        tables
          it_usrfldtsel = it_usrfldtsel.

      if ( data_changed is initial                ) and
         ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).
        data_changed = 'X'.
      endif.

      free it_usrfldtsel.
      table_control_310-top_line = 0.

    when 'PGUP'.
      if pager > 1.
        pager = pager - 1.
      endif.

    when 'PGTP'.
      pager = 1.

    when 'PGBT'.
      if loop_lines <> 0.
        pager = max_page.
      endif.

    when 'PGDN'.
      if pager < max_page.
        pager = pager + 1.
      endif.

    when 'BACK' or 'STOP'.
      "If we are in a central system and any changes were made --->
      "propose to to save changes before leaving the screen
      if master_system = 'X'
        and (   data_changed = 'X'
             or it_usrfldtsel_old[] ne it_usrfldtsel[] ).

        call function 'POPUP_TO_CONFIRM'       ##TEXT_UNIQ  ##TEXT_DIFF
          exporting
            titlebar              = 'Exit field selection'(m03)
            text_question         = 'Save field selections?'(m04)
            default_button        = '1'
            display_cancel_button = 'X'
          importing
            answer                = answer
          exceptions
            text_not_found        = 0
            others                = 0.

        if answer = '1'.
         "Positive answer ---> save changes before leaving the screen
         "if answer = 'J' or answer = 'Y'.
          clear: g_role_transfer,
                 g_prof_transfer,
                 g_laws_transfer.

          call function 'SUSR_ZBV_FLD_TO_DB'
            exporting
              custmodel     = g_bapilink
            importing
              scug_role_msg = g_role_transfer
              scug_prof_msg = g_prof_transfer
              scug_laws_msg = g_laws_transfer
            tables
              it_usrfldtsel = it_usrfldtsel.

          clear data_changed.
          it_usrfldtsel_old[] = it_usrfldtsel[].

          perform check_loc_assig_transf_needed.

          call function 'SUSR_ZBV_LANDSCAPE_SEND'
            exceptions
              rfc_failure = 1
              others      = 2.

          if sy-subrc <> 0.
            message id sy-msgid type sy-msgty number sy-msgno
                    with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          else.
            "Data was saved
            message s213(s#).
          endif.

          "now the tRFC will be send
          "tRFC failure -> error in SM58
          commit work.

        elseif answer = '2'.
          "negative answer ---> show "old" values
          "elseif answer = 'N'.
          it_usrfldtsel[] = it_usrfldtsel_old[].
        endif.

      else.
        "If we are in a child system or no changes were made
        answer = '1'.
      endif.

      if     ( gf_status = '0' ) or  ( sok_code = 'STOP' ).
        "leave screen if fcode = STOP or if display mode is read-only
        "If answer is not 'Cancel' ---> leave the screen.
        if not answer eq 'A'.
          leave to screen 0.
        endif.

      elseif ( gf_status = '1' ) and ( sok_code = 'BACK' ).
        "leave to read-only mode of display if display was changeable
        "before or fcode = BACK
        if answer ne 'A'.
          gf_status = '0'.
        endif.

      endif.


    when 'ABRT'.
      if master_system = 'X'
        and (   data_changed        =  'X'
             or it_usrfldtsel_old[] ne it_usrfldtsel[] ).

        concatenate 'Möchten Sie die Transaktion verlassen?'(m01)
                    'Feldselektionen werden nicht gespeichert'(m02)
               into text separated by space.

        call function 'POPUP_TO_CONFIRM'
          exporting
            titlebar              = 'Beenden Feldselektionen'(m03)
            text_question         = text
            default_button        = '2'
            display_cancel_button = space
          importing
            answer                = answer
          exceptions
            text_not_found        = 0
            others                = 0.

      else.
        answer = '1'.
      endif.

      if answer = '1'.
        leave to screen 0.
      endif.

    when 'SAVE'.
      if master_system = 'X'.

        clear: g_role_transfer,
               g_prof_transfer,
               g_laws_transfer.

        call function 'SUSR_ZBV_FLD_TO_DB'
          exporting
            custmodel     = g_bapilink
          importing
            scug_role_msg = g_role_transfer
            scug_prof_msg = g_prof_transfer
            scug_laws_msg = g_laws_transfer
          tables
            it_usrfldtsel = it_usrfldtsel.

        clear data_changed.
        it_usrfldtsel_old[] = it_usrfldtsel[].

        perform check_loc_assig_transf_needed.

        call function 'SUSR_ZBV_LANDSCAPE_SEND'
          exceptions
            rfc_failure = 1
            others      = 2.

        if sy-subrc <> 0.
          message id sy-msgid type sy-msgty number sy-msgno
                  with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        else.
          "Data was saved
          message s213(s#).
        endif.

        "now the tRFC will be send
        "tRFC failure -> error in SM58
        commit work.
      endif.

    when 'CHVIEW'.                     " change view
      "logic for pressing the button ('Anzeigen <> Ändern').
      gd_change_view = 'X'.

      if gf_status = '0'.

        try.
          cl_auth_check_mass_s_user_sys=>auth_check_single(
            exporting
              iv_subsystem = '*'
              iv_activity  = cl_auth_check_mass_s_user_sys=>gc_act_assign
            importing
              ev_subrc     = gd_subrc
              ev_return    = gd_msg
            ).
          catch cx_root.
            "Invalid parameter value
            message e491(00).
        endtry.
        if     gd_subrc <> 0.
          message id '01' type 'S' number '650' display like 'E'.
        elseif gd_subrc =  0.
          gf_status = '1'.
        endif.

      else.

        gf_status = '0'.

        if ( data_changed        =  'X'             ) or
           ( it_usrfldtsel_old[] ne it_usrfldtsel[] ).

          call function 'POPUP_TO_CONFIRM'     ##TEXT_UNIQ  ##TEXT_DIFF
            exporting
              titlebar              = 'Exit field selection'(m03)
              text_question         = 'Save field selections?'(m04)
              default_button        = '1'
              display_cancel_button = 'X'
            importing
              answer                = answer
            exceptions
              text_not_found        = 0
              others                = 0.

          if answer = '1'.
           "Positive answer ---> save changes before leaving the screen
           "if answer = 'J' or answer = 'Y'.
            call function 'SUSR_ZBV_FLD_TO_DB'
              exporting
                custmodel     = usbapilink-bapilink
              tables
                it_usrfldtsel = it_usrfldtsel.

            clear data_changed.
            it_usrfldtsel_old[] = it_usrfldtsel[].

            call function 'SUSR_ZBV_LANDSCAPE_SEND'
              exceptions
                rfc_failure = 1
                others      = 2.

            if sy-subrc <> 0.
              message id sy-msgid type sy-msgty number sy-msgno
                    with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            else.
              "Data was saved
              message s213(s#).
            endif.

            "now the tRFC will be send
            "tRFC failure -> error in SM58
            commit work.

          elseif answer = '2'.
            "negative answer ---> show "old" values
            it_usrfldtsel[] = it_usrfldtsel_old[].
          elseif answer = 'A'.
            "answer = abort ---> switch to read-only mode
            gf_status = '1'.
          endif.

        else.
          "If no changes were made
          answer = '1'.
        endif.
      endif.

  endcase.
endmodule.                             " USER_COMMAND_0300  INPUT

*&---------------------------------------------------------------------*
*&      Module  SAVE_MODEL  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module save_model input.
  "Here we use the same schema to read data from the screen as in PBO
  "module READ_MODEL of screen 310 . This way we can be protected from
  "problems if several logical fields have the same field name.
  index = top_line_old + sy-stepl - 1.

  read table it_usrfldtsel index index.
  if sy-subrc = 0 and it_usrfldtsel-fieldname = usrfldtsel-fieldname.
    if global = 'X'.
      it_usrfldtsel-uflag = 'G'.
    elseif local = 'X'.
      it_usrfldtsel-uflag = 'L'.
    elseif back = 'X'.
      it_usrfldtsel-uflag = 'B'.
    elseif template = 'X'.
      it_usrfldtsel-uflag = 'T'.
    elseif all = 'X'.
      it_usrfldtsel-uflag = 'C'.
    endif.
    modify it_usrfldtsel index index.
  endif.

endmodule.                             " SAVE_MODEL  INPUT

*&---------------------------------------------------------------------*
*&      Module  DISPLAY_FIELD_HELP  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module display_field_help input.

  perform display_field_help.

endmodule.                             " DISPLAY_FIELD_HELP  INPUT

*&---------------------------------------------------------------------*
*&      Module  SAVE_USER  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module save_user input.

  read table gt_usrgetstrc_tab assigning <gs_usrgetstrc_tab>
       with key bname = usrgetstrc-bname
       binary search.

  if sy-subrc = 0.
    <gs_usrgetstrc_tab>-get_users = usrgetstrc-get_users.
  endif.

endmodule.                             " SAVE_USER  INPUT

*---------------------------------------------------------------------*
*       MODULE USER_COMMAND_0401 INPUT                                *
*---------------------------------------------------------------------*
*  PAI for user comparison screen RSUSLAND.401                        *
*---------------------------------------------------------------------*
module user_command_0401 input.

  sok_code = ok-code.
  clear ok-code.

  case sok_code.

    when 'MRK+'.
      "Mark users by selection criteria
      perform mark_unmark_users_block using 'X'.


    when 'MARK'.
      "Mark all users
      perform unmark_users_all using 'X'.


    when 'DEMK'.
      "Unmark all users
      perform unmark_users_all using space.


    when 'FTCH'.
      "----------------------------------------------------------------
      "--- Transfer Users ---------------------------------------------
      clear: exit.
      refresh: gt_error_log.

      perform fetch_users changing exit.

      if exit = 'X'.
        return.
      endif.

      if not gt_error_log[] is initial.
        "--------------------------------------------------------------
        "--- Display error log ----------------------------------------
        perform display_error_log.
      else.
        "MSG: Benutzer wurden übernommen
        message s510(s#).
      endif.

      "----------------------------------------------------------------
      "--- Update NEW_SYSTEM status in db table USZBVLNDRC-------------
      perform set_system_status.

      refresh: gt_usrgetstrc_tab.


    when 'LAWS'.
      "Transfer LAWS for already central users
      clear: exit, title.
      title = 'Transfer local licence types'(004).       "#EC TEXT_DIFF

      perform popup_to_confirm_transfer using    title
                                        changing exit.
      if exit = 'X'.
        return.
      endif.

      perform user_laws_mass_transfer.


    when 'ROLE'.
      "Transfer local role assignments for already central users
      clear: exit, title.
      title = 'Transfer local role assignments'(003).    "#EC TEXT_DIFF

      perform popup_to_confirm_transfer using    title
                                        changing exit.
      if exit = 'X'.
        return.
      endif.

      perform user_role_mass_transfer.


    when 'PROF'.
      "Transfer local profile assignments for already central users
      clear: exit, title.
      title = 'Transfer local profile assignments'(002). "#EC TEXT_DIFF

      perform popup_to_confirm_transfer using    title
                                        changing exit.
      if exit = 'X'.
        return.
      endif.

      perform user_prof_mass_transfer.


    when 'NEWU'.
      "Go to new users tab
      refresh: gt_usrgetstrc_tab.
      new_users = 'N'.
      user_transfer-activetab = sok_code.


    when 'OLDU'.
      "Go to identical users tab
      refresh: gt_usrgetstrc_tab.
      new_users = 'O'.
      user_transfer-activetab = sok_code.


    when 'DIFU'.
      "Go to different users tab
      refresh: gt_usrgetstrc_tab.
      new_users = 'D'.
      user_transfer-activetab = sok_code.


    when 'GOTU'.
      "Go to already CUA users tab
      clear: gt_usrgetstrc_tab.
      refresh: gt_usrgetstrc_tab.
      new_users = 'C'.
      user_transfer-activetab = sok_code.


    when 'LOCU'.
     "------------- Local users in central system ------------------
     " Go to local in central system users tab
      clear: gt_usrgetstrc_tab.
      refresh: gt_usrgetstrc_tab.
      new_users = 'L'.
      user_transfer-activetab = sok_code.

    when 'P++ '.
      "End of tab screen
      tab_410-top_line =  table_lines.

    when 'P+  '.
      "Page down
      tab_410-top_line =  tab_410-top_line + loop_lines.

    when 'P-- '.
      "Beginning of tab screen
      tab_410-top_line =  1.

    when 'P-  '.
      "Page up
      if tab_410-top_line > loop_lines.
        tab_410-top_line =  tab_410-top_line - loop_lines.
      else.
        tab_410-top_line =  1.
      endif.


    when 'BACK' or 'STOP' or 'ABRT'.
      refresh: gt_usrgetstrc_tab
             , gt_usrgetstrc
             , gt_local_users
*            ", gt_central_local_users
             .

      leave to screen 0.

  endcase.

endmodule.                             " USER_COMMAND_0400  INPUT

*&---------------------------------------------------------------------*
*&      Form  display_field_help
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form display_field_help.

  data: tindex         type sy-tabix.

  "Get absolute vertical cursor position on subscreen
  get cursor line tindex.
  tindex = tindex + ( table_control_310-top_line - 1 ).

  "Get dictionary field, which is assigned to selected logical field
  read table it_usrfldtsel index tindex.

  select single * from usrflddef                            "#EC WARNOK
    where log_field = it_usrfldtsel-log_field.          "#EC CI_GENBUFF

  "If logical field is assigned to some dictionary field --> display
  "dictionary field documentation
  if sy-subrc = 0 and usrflddef-fieldname is not initial.

    call function 'HELP_OBJECT_SHOW_FOR_FIELD'
      exporting
        called_for_tab   = usrflddef-tabname
        called_for_field = usrflddef-fieldname
      exceptions
        others           = 0.  " no messages are raised with exceptions

  endif.

endform.                    " display_field_help

*&---------------------------------------------------------------------*
*&      Form  display_error_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form display_error_log.

  data: l_s_log             type         bal_s_log
      , lr_s_msg            type ref to  bal_s_msg
      , l_s_display_profile type         bal_s_prof
      .

  "--------------------------------------------------------------------
  "----- Create log ---------------------------------------------------

  "If there is already an old log, delete it
  if not g_log_handle is initial.

    call function 'BAL_LOG_REFRESH'
      exporting
        i_log_handle = g_log_handle
      exceptions
        others       = 1.

    if sy-subrc <> 0.
      message id sy-msgid type sy-msgty number sy-msgno
             with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.

    clear g_log_handle.
  endif.

  "Create an initial log file
  if g_log_handle is initial.

    call function 'BAL_LOG_CREATE'
      exporting
        i_s_log      = l_s_log
      importing
        e_log_handle = g_log_handle
      exceptions
        others       = 1.

    if sy-subrc <> 0.
      message id sy-msgid type sy-msgty number sy-msgno
              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.

    "------------------------------------------------------------------
    "----- Prepare data for displaying in log -------------------------

    "Add collected messages to log
    loop at gt_error_log reference into lr_s_msg.

      call function 'BAL_LOG_MSG_ADD'
        exporting
          i_log_handle  = g_log_handle
          i_s_msg       = lr_s_msg->*
        exceptions
          log_not_found = 0
          others        = 1.

      if sy-subrc <> 0.
        message id sy-msgid type sy-msgty number sy-msgno
                with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      endif.

    endloop.

    "------------------------------------------------------------------
    "----- Get profile for log (display log as a tree) ----------------

    call function 'BAL_DSP_PROFILE_DETLEVEL_GET'
      importing
        e_s_display_profile = l_s_display_profile
      exceptions
        others              = 1.

    if sy-subrc <> 0.
      message id sy-msgid type sy-msgty number sy-msgno
              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.

    l_s_display_profile-use_grid  = if_identity=>co_true.
    l_s_display_profile-head_text = text-er1.
    l_s_display_profile-head_size = 40.
    l_s_display_profile-title     = sy-title.
    "------------------------------------------------------------------
    "---- Display log  ------------------------------------------------
    call function 'BAL_DSP_LOG_DISPLAY'
      exporting
        i_s_display_profile = l_s_display_profile
      exceptions
        others              = 1.

    if sy-subrc <> 0.
      message id sy-msgid type sy-msgty number sy-msgno
              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.

  endif.   "g_log_handle is initial

endform.                    " display_error_log

*&---------------------------------------------------------------------*
*&      Form  mark_users_mass
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form mark_unmark_users_block using mark type c.

  field-symbols: <ls_usrgetstrc_tab> type ty_usrgetstrc.


  sc_title = 'Mark selected users'(001).                 "#EC TEXT_DIFF

  call selection-screen 4100 starting at 5 5 ending at 85 10.

  "If 'Execute' was pressed
  if sy-subrc = 0.
    loop at gt_usrgetstrc_tab assigning <ls_usrgetstrc_tab>
         where bname in scr_name.
      <ls_usrgetstrc_tab>-get_users = mark.
    endloop.
  endif.


endform.                    " mark_users_mass

*&---------------------------------------------------------------------*
*&      Form  unmark_users_all
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form unmark_users_all using mark type c.

  field-symbols: <ls_usrgetstrc_tab> type ty_usrgetstrc.

  loop at gt_usrgetstrc_tab assigning <ls_usrgetstrc_tab>.
    <ls_usrgetstrc_tab>-get_users = mark.
  endloop.

endform.                    " unmark_users_all

*&---------------------------------------------------------------------*
*&      Form  fetch_users
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form fetch_users changing exit type c.

  data: lt_users_copy       type table of ususername
      , ls_users_copy       type          ususername
      , lt_users_send       type table of bapibname
      , ls_users_send       type          bapibname
      , lt_bapiret2         type table of bapiret2
      , retlist             type table of bapiret2
      , ls_return           type          bapiret2
      , lt_messages         type          if_suid_msg_buffer=>tt_messages
      , lt_local_bname      type table of ususers
      , lr_ususer           type ref to   ususers
      , lr_local_user       type ref to   ty_usrgetstrc
      , lr_normal_user      type ref to   ty_usrgetstrc
      , lv_tabix            type          sy-tabix
      , ls_msg              type          symsg
      , lv_msgtext(80)      type          c
      , lt_systems_dummy    type table of ussystem
      .

  field-symbols: <ls_users_copy>      type ususername,
                 <ls_users_send>      type bapibname,
                 <ls_usergetstrc_tab> type ty_usrgetstrc,
                 <ls_usrgetstrc>      type ty_usrgetstrc.



  "2 possibilities: - Take users from target system
  "                 - Distribute users (maybe overwrite users in
  "                   target system)
  loop at gt_usrgetstrc_tab assigning <ls_usergetstrc_tab>
                                where get_users eq 'X'.
    if <ls_usergetstrc_tab>-user_exist = ' '.
      ".....Take (copy) users from target system
      ls_users_copy-bname = <ls_usergetstrc_tab>-bname.
      append ls_users_copy to lt_users_copy.
    else.
      ".....Distribute users to target system
      ls_users_send-bapibname = <ls_usergetstrc_tab>-bname.
      append ls_users_send to lt_users_send.
    endif.

    "On 'Local Users' tab collect users for type modification in child system
    if new_users = 'L'.
      append initial line to lt_local_bname reference into lr_ususer.
      lr_ususer->bname = <ls_usergetstrc_tab>-bname.
    endif.
  endloop.

  "--------------------------------------------------------------------
  "--- Convert local users in target system into normal users ---------
  if not lt_local_bname is initial.
    "------------ Local users in central system -----------------------
    if new_system = g_sendsystem.

      call function 'SUSR_ZBV_USER_SYSTEM_PUT'
        exporting
          usrsection                = space
          iv_local_user_flag_remove = if_identity=>co_true
        tables
          systems                   = lt_systems_dummy
          userlist                  = lt_local_bname.

    else.

      call function 'SUSR_ZBV_USER_SYSTEM_PUT'
        destination new_system
        exporting
          usrsection                = space
          iv_local_user_flag_remove = if_identity=>co_true
        tables
          systems                   = lt_systems_dummy
          userlist                  = lt_local_bname
        exceptions
          communication_failure     = 1  message lv_msgtext
          system_failure            = 2  message lv_msgtext
          others                    = 3.

      if sy-subrc <> 0.

        clear: lt_local_bname
             , lt_users_send
             , lt_users_copy
             .

        if lv_msgtext is not initial.
          "MSG: Das System &1 kann nicht mit RFC erreicht werden; &2
          if 1 = 0.  message i395(01) with new_system lv_msgtext lv_msgtext. endif.
          ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
          ls_msg-msgid = '01'.
          ls_msg-msgno = '395'.
          ls_msg-msgv1 = new_system.
          "Split the error test into two parts
          ls_msg-msgv2 = lv_msgtext(40).
          ls_msg-msgv3 = lv_msgtext+40(40).
        else.
          ls_msg-msgty   = sy-msgty.
          ls_msg-msgid   = sy-msgid.
          ls_msg-msgno   = sy-msgno.
          ls_msg-msgv1   = sy-msgv1.
          ls_msg-msgv2   = sy-msgv2.
          ls_msg-msgv3   = sy-msgv3.
          ls_msg-msgv4   = sy-msgv4.
        endif.

        "Fill ls_return structure
        call function 'BALW_BAPIRETURN_GET2'
          exporting
            type   = ls_msg-msgty
            cl     = ls_msg-msgid
            number = ls_msg-msgno
            par1   = ls_msg-msgv1
            par2   = ls_msg-msgv2
            par3   = ls_msg-msgv3
            par4   = ls_msg-msgv4
          importing
            return = ls_return
          exceptions
            others = 0.

        append ls_return to retlist.
      endif.
    endif.


    "Add successfully converted user to gt_usrgetstrc - table of 'normal' users
    "and delete him from list of local users
    loop at lt_local_bname reference into lr_ususer.

      read table gt_local_users reference into lr_local_user
           with key bname = lr_ususer->bname
           binary search.

      if sy-subrc = 0.

        lv_tabix = sy-tabix.

        read table gt_usrgetstrc assigning <ls_usrgetstrc>
             with key bname = lr_ususer->bname
             binary search.

        if sy-subrc <> 0.

          insert initial line into gt_usrgetstrc reference into lr_normal_user
                 index sy-tabix.

          if sy-subrc = 0.
            "The user is already classified as New, Different or Identical user
            "(see subroutine GET_USERS)
            move lr_local_user->* to lr_normal_user->* .
          endif.

          if new_system = g_sendsystem.
            "--- Central system:
            "If user already has assignment to central system ==>
            "delete him from further transfer procedure
            if lr_local_user->status = 'C'.

              read table lt_users_send
                   with key bapibname = lr_local_user->bname
                   transporting no fields
                   binary search.

              if sy-subrc = 0.
                delete lt_users_send index sy-tabix.
              endif.

            endif.
          endif.   "new_system = g_sendsystem
        endif.

        delete gt_local_users index lv_tabix.
      endif.

    endloop.   "at lt_local_bname reference into lr_ususer

  endif.   "not lt_local_bname is initial


  if ( lt_users_send[] is initial ) and
     ( lt_users_copy[] is initial ) and
     ( retlist         is initial ).
    "If no users were marked --> stop processing
    "Keinen Eintrag selektiert
    message s296(01).
    exit = 'X'.
    return.
  endif.

  if not lt_users_copy[] is initial.
    "------------------------------------------------------------------
    "--- Take users from target system --------------------------------
    call function 'SUSR_ZBV_USERS_GET_FROM_REMOTE'
      exporting
        source_system          = new_system
      importing
        et_user_error_messages = lt_messages
      tables
        userlist               = lt_users_copy
        retlist                = lt_bapiret2
        userprofiles           = userprofiles
        useractgrps            = useractgrps
        userlaws               = userlaws.

    append lines of lt_bapiret2 to retlist.

    loop at lt_users_copy assigning <ls_users_copy>.
      "...Mark successful user - others are deleted
      read table gt_usrgetstrc assigning <ls_usrgetstrc>
           with key bname = <ls_users_copy>-bname           "#EC WARNOK
           binary search.

      if sy-subrc = 0.
        <ls_usrgetstrc>-status     = 'C'.
        <ls_usrgetstrc>-user_exist = 'X'.
        <ls_usrgetstrc>-name_text  = <ls_usrgetstrc>-rem_name.
      endif.

    endloop.


  elseif not lt_users_send[] is initial.
    "------------------------------------------------------------------
    "--- Distribute to target system ----------------------------------
    call function 'SUSR_ZBV_ADD_USERS_TO_SYSTEM'
      exporting
        new_system             = new_system
      importing
        et_user_error_messages = lt_messages
      tables
        userlist               = lt_users_send
        userprofiles           = userprofiles
        useractgrps            = useractgrps
        retlist                = lt_bapiret2
        userlaws               = userlaws.

    append lines of lt_bapiret2 to retlist.

    loop at lt_users_send assigning <ls_users_send>.
      "...Mark successful user
      read table gt_usrgetstrc assigning <ls_usrgetstrc>
           with key bname = <ls_users_send>-bapibname
           binary search.
      if sy-subrc = 0 .
        <ls_usrgetstrc>-status    = 'C'.
        <ls_usrgetstrc>-rem_name  = <ls_usrgetstrc>-name_text.
      endif.
    endloop.

  endif.   " not lt_users_copy[] is initial


  "Fill error protocol
  refresh: gt_error_log.
  perform fill_error_protocol using retlist
                                    lt_messages.

endform.                    " fetch_users

*&---------------------------------------------------------------------*
*&      Form  check_loc_assig_transf_needed
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form check_loc_assig_transf_needed .

  data: par1            type sy-msgv1,
        par2            type sy-msgv2,
        par3            type sy-msgv3.

  if g_prof_transfer is initial and g_role_transfer is initial and
     g_laws_transfer is initial.
    return.
  endif.

  if g_laws_transfer = 'X'.
    par1 = 'X'.
  endif.

  if g_role_transfer = 'X'.
    par2 = 'X'.
  endif.

  if g_prof_transfer = 'X'.
    par3 = 'X'.
  endif.


  "Transfer local user data to central system to prevent data loss
  message i148(s#) with par1 par2 par3.

endform.                    " check_loc_assig_transf_needed

*&---------------------------------------------------------------------*
*&      Form  modify_uszbvsys
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_OLD_PRF_USERS  text
*      -->P_NEW_SYSTEM  text
*      -->P_3431   text
*----------------------------------------------------------------------*
* called before new CL_IDENTITY by FORMs user_prof_mass_transfer &
* user_role_mass_transfer
*----------------------------------------------------------------------
*form modify_uszbvsys  tables   lt_userlist structure ususers
*                      using    subsystem   type uszbvsys-subsystem
*                               usrsection  type uszbvsys-usrsection
*                      changing exit        type c.
*
*  data: lt_ussystem type table of ussystem,
*        ls_ussystem type ussystem.
*
*  data: msgtext(80) type c,
*        msgpar1     type sy-msgv1,
*        msgpar2     type sy-msgv2.
*
*  ls_ussystem-subsystem = subsystem.
*  append ls_ussystem to lt_ussystem.
*
*  call function 'SUSR_ZBV_USER_SYSTEM_PUT'
*    exporting
*      copied     = 'X'
*      usrsection = usrsection
*    tables
*      systems    = lt_ussystem
*      userlist   = lt_userlist.
*
*  call function 'SUSR_ZBV_USER_SYSTEM_SAVE'.
*
** Distribute changes to child system
*  if subsystem <> g_sendsystem.
*
*    clear: msgtext, msgpar1, msgpar2.
*    call function 'SUSR_ZBV_USER_SYSTEM_PUT'
*      destination subsystem
*      exporting
*        copied                = 'X'
*        usrsection            = usrsection
*      tables
*        systems               = lt_ussystem
*        userlist              = lt_userlist
*      exceptions
*        communication_failure = 2  message msgtext
*        system_failure        = 3  message msgtext
*        others                = 4.
*    if sy-subrc <> 0.
**     Split the error message into two parts
*      msgpar1   = msgtext(40).
*      msgpar2   = msgtext+40(40).
**     MSG: Das System &1 kann nicht mit RFC erreicht werden; &2&3
*      message i395(01) with subsystem msgpar1 msgpar2.
*      exit = 'X'.
*      return.
*    endif.
*
*    clear: msgtext, msgpar1, msgpar2.
*    call function 'SUSR_ZBV_USER_SYSTEM_SAVE'
*      destination subsystem
*      exceptions
*        communication_failure = 2  message msgtext
*        system_failure        = 3  message msgtext
*        others                = 4.
*    if sy-subrc <> 0.
**     Split the error message into two parts
*      msgpar1   = msgtext(40).
*      msgpar2   = msgtext+40(40).
**     MSG: Das System &1 kann nicht mit RFC erreicht werden; &2&3
*      message i395(01) with subsystem msgpar1 msgpar2.
*      exit = 'X'.
*      return.
*    endif.
*
*  endif.
*
*endform.                    " modify_uszbvsys


*&---------------------------------------------------------------------*
*&      Form  user_laws_mass_transfer
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form user_laws_mass_transfer .

  data: lt_bname               type          suid_tt_bname
      , lt_bname_failed        type          suid_tt_bname
      , lr_bname               type ref to   suid_st_bname
      , lt_usrgetstrc          type table of ty_usrgetstrc
      , lx_suid_identity       type ref to   cx_suid_identity
      , lt_node_root           type          suid_tt_node_root
      , lr_node_root           type ref to   suid_st_node_root
      , lo_msg_buffer          type ref to   if_suid_msg_buffer
      , lt_nodes_prefetch      type          suid_tt_node
      , lt_messages            type          if_suid_msg_buffer=>tt_messages
      , lt_msg_buffer          type          if_suid_msg_buffer=>tt_messages
      , lt_error_messages      type          if_suid_msg_buffer=>tt_messages
      , lr_message             type ref to   if_suid_msg_buffer=>ty_messages
      , lt_return              type          bapirettab
      , ls_return              type          bapiret2
      , lv_error               type          sesf_boolean
      , lt_old_cua_uclasses    type          suid_tt_node_cua_uclasses
      , lr_node_cua_uclass     type ref to   suid_st_node_cua_uclass
      , lr_cua_uclass          type ref to   suid_st_node_cua_uclass
      , lt_new_cua_uclasses    type          suid_tt_node_cua_uclasses
      , lr_userlaw             type ref to   usr06sys
      , lv_full_package        type          i
      , lv_process_package     type          sesf_boolean
      , lv_package_size        type          i
      , lr_usrgetstrc_tab      type ref to   ty_usrgetstrc
      .


  "--- Initialization -------------------------------------------------
  loop at gt_usrgetstrc_tab reference into lr_usrgetstrc_tab
                            where get_users eq 'X'.
    "Unmark selected user
    clear: lr_usrgetstrc_tab->get_users.

    append lr_usrgetstrc_tab->* to lt_usrgetstrc.
  endloop.

  if lt_usrgetstrc[] is initial.
    "MSG: Keinen Eintrag selektiert
    message s296(01).
    return.
  endif.

  "--- Get package size
  cl_suid_tools=>get_package_size(
    importing
      ev_package_size = lv_package_size ).

  "Set User Transfer CUA mode
  cl_identity=>set_cua_mode(
    exporting
      iv_mode           = if_suid_cua_runtime=>gc_cua_central_transfer
       iv_source_system = new_system    ).

  append if_identity_definition=>gc_node_cua_uclass to lt_nodes_prefetch.


  "--- Transfer license data assignments from child system for selected (marked) users
  loop at lt_usrgetstrc reference into lr_usrgetstrc_tab.

    append lr_usrgetstrc_tab->bname to lt_bname.

    "---- Process selected users in packages
    lv_full_package = sy-tabix mod lv_package_size.
    if lv_full_package = 0.
      lv_process_package = if_identity=>co_true.
    endif.

    at last.
      lv_process_package = if_identity=>co_true.
    endat.

    if lv_process_package = if_identity=>co_false.
      continue.
    endif.

    "------ Maintenance ------
    try.
        "Get instances
        cl_identity=>retrieve_for_update(
           exporting
             it_bname          = lt_bname
             it_nodes_prefetch = lt_nodes_prefetch
           importing
             et_node_root      = lt_node_root
             eo_msg_buffer     = lo_msg_buffer ).

        "Retrieve lifetimeonce messages
        cl_identity_tools=>msg_buffer_retrieve(
          exporting
            iv_nodename          = if_identity_definition=>gc_node_root
            io_msg_buffer        = lo_msg_buffer
          changing
            ct_error_messages    = lt_messages   ).

        "-------- Maintain instantiated users
        loop at lt_bname reference into lr_bname.
          "Check if user was't instantiated
          read table lt_node_root reference into lr_node_root
               with key bname = lr_bname->bname
               binary search.
          "If not ==> go to another user
          if sy-subrc <> 0.
            continue.
          endif.

          "Transfer identical/different users into CUA
          clear: lt_old_cua_uclasses
               , lt_new_cua_uclasses
               , lv_error
               .

          "---------- Set CUA licence data
          "In order to prevent system inconsitencies get existing licence data assignments
          lr_node_root->idref->if_identity_cua~get_cua_uclasses(
            importing
              et_cua_uclasses        = lt_old_cua_uclasses
              eo_msg_buffer          = lo_msg_buffer ).

          "Set new CUA licence data
          read table userlaws reference into lr_userlaw
               with key bname     = lr_node_root->bname
                        rcvsystem = new_system
               binary search.

          if    ( sy-subrc = 0 ) and
            not ( lr_userlaw->lic_type is initial  or
                  lr_userlaw->lic_type eq '00'        ).

            append initial line to lt_new_cua_uclasses reference into lr_node_cua_uclass.
            lr_node_cua_uclass->subsystem         = new_system.
            lr_node_cua_uclass->lic_type          = lr_userlaw->lic_type.
            lr_node_cua_uclass->spec_vers         = lr_userlaw->spras.
            lr_node_cua_uclass->sysid             = lr_userlaw->sysid.
            lr_node_cua_uclass->client            = lr_userlaw->mandt2.
            lr_node_cua_uclass->substitute_from   = lr_userlaw->vondat.
            lr_node_cua_uclass->substitute_until  = lr_userlaw->bisdat.
            lr_node_cua_uclass->bname_chargeable  = lr_userlaw->aname.
            lr_node_cua_uclass->country_surcharge = lr_userlaw->surcharge.

            read table lt_old_cua_uclasses
                 with key subsystem = new_system
                 transporting no fields
                 binary search.

            if sy-subrc <> 0.
              lr_node_cua_uclass->change_mode       = if_identity=>co_insert.
            else.
              lr_node_cua_uclass->change_mode  = if_identity=>co_update.
              delete lt_old_cua_uclasses index sy-tabix.
            endif.

          endif.

          read table lt_old_cua_uclasses reference into lr_node_cua_uclass
               with key subsystem = new_system
               binary search.

          if sy-subrc = 0.
            append initial line  to lt_new_cua_uclasses reference into lr_cua_uclass.
            move lr_node_cua_uclass->* to lr_cua_uclass->*.
            lr_cua_uclass->change_mode = if_identity=>co_delete.
          endif.

          lr_node_root->idref->if_identity_cua~set_cua_uclasses(
            exporting
              it_cua_uclasses = lt_new_cua_uclasses
            importing
              eo_msg_buffer   = lo_msg_buffer ).

          cl_identity_tools=>msg_buffer_retrieve(
            exporting
              iv_bname             = lr_node_root->bname
              io_msg_buffer        = lo_msg_buffer
            importing
              ev_error_message     = lv_error
            changing
              ct_error_messages    = lt_messages   ).
          if lv_error = if_identity=>co_true.
            append lr_bname->* to lt_bname_failed.
          endif.

        endloop.   "at lt_bname reference into lr_bname

        "--------------------------------------------------------------*
        "   Last check and Cleanup of failed users before Save
        "--------------------------------------------------------------*
        append lines of lt_error_messages to lt_messages.

        clear: lt_error_messages
             .
        cl_identity=>do_check(
          importing
            eo_msg_buffer = lo_msg_buffer  ).

        cl_identity_tools=>msg_buffer_retrieve(
          exporting
            iv_bname             = lr_bname->bname
            io_msg_buffer        = lo_msg_buffer
            iv_lifetimeonce_only = if_identity=>co_false
          changing
            ct_error_messages    = lt_messages  ).

        lt_msg_buffer = lt_messages.
*       "Delete only users with errors from processing
        delete lt_msg_buffer where msgty <> if_suid_msg_buffer=>co_type_error.
        sort lt_msg_buffer by bname.
        delete adjacent duplicates from lt_msg_buffer comparing bname.

        loop at lt_msg_buffer reference into lr_message.
          append lr_message->bname to lt_bname_failed .
        endloop.

        if lt_bname_failed is not initial.
          sort lt_bname_failed by bname.
          delete adjacent duplicates from lt_bname_failed comparing bname.
          cl_identity=>cleanup( it_bname = lt_bname_failed ).
        endif.


        "-------------------------------------------------------------*
        "              Save user locally
        "-------------------------------------------------------------*
        clear: lv_error
             .
        cl_identity=>do_save(
          importing
            ev_rejected   = lv_error
            eo_msg_buffer = lo_msg_buffer  ).

        "EV_REJECTED = 'X' from DO_SAVE ==> fatal error, NO instance can be saved in our case )
        if lv_error = if_identity=>co_true.
          "Collect new messages
          cl_identity_tools=>msg_buffer_retrieve(
            exporting
              io_msg_buffer        = lo_msg_buffer
              iv_lifetimeonce_only = if_identity=>co_false
            changing
              ct_error_messages    = lt_error_messages  ).

          "Delete duplicated messages
          sort lt_error_messages stable by bname nodename msgty msgid msgno message.
          delete adjacent duplicates from lt_error_messages comparing
                 bname nodename msgty msgid msgno message.

          rollback work.
          cl_identity=>cleanup( ).
        else.
          "Cleanup will run automatically on commit work
          commit work.
        endif.

        append lines of lt_error_messages to lt_messages.

      "---------------------------------------------------------------*
      catch cx_suid_identity into lx_suid_identity.
        call method cl_identity_tools=>message_suid_technical_error
          exporting
            ix_suid_identity = lx_suid_identity
          importing
            es_return        = ls_return.

        append ls_return to lt_return.
    endtry.


    clear: lt_bname
         , lt_bname_failed
         , lv_error
         , lt_msg_buffer
         , lv_process_package
         , lt_error_messages
         .
  endloop.


  "Sort user specific error protocol
  sort lt_messages stable by bname nodename msgty message_lifetime.

  "...Fill error protocol
  refresh: gt_error_log.
  perform fill_error_protocol using lt_return
                                    lt_messages.

  if not gt_error_log[] is initial.
    perform display_error_log.
  else.
    "MSG: Ausgewalte Daten wurden ubernommen
    message s149(s#).
  endif.

endform.                    " user_laws_mass_transfer

*&---------------------------------------------------------------------*
*&      Form  user_role_mass_transfer
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form user_role_mass_transfer .

  data: lt_bname               type          suid_tt_bname
      , lt_bname_failed        type          suid_tt_bname
      , lr_bname               type ref to   suid_st_bname
      , lt_usrgetstrc          type table of ty_usrgetstrc
      , lx_suid_identity       type ref to   cx_suid_identity
      , lt_node_root           type          suid_tt_node_root
      , lr_node_root           type ref to   suid_st_node_root
      , lo_msg_buffer          type ref to   if_suid_msg_buffer
      , lt_nodes_prefetch      type          suid_tt_node
      , lt_messages            type          if_suid_msg_buffer=>tt_messages
      , lt_error_messages      type          if_suid_msg_buffer=>tt_messages
      , lt_msg_buffer          type          if_suid_msg_buffer=>tt_messages
      , lr_message             type ref to   if_suid_msg_buffer=>ty_messages
      , ls_msg                 type          symsg
      , lv_msgtext(80)         type          c
      , ls_return              type          bapiret2
      , lt_retlist             type          bapirettab
      , lv_error               type          sesf_boolean
      , lv_rfc_error           type          sesf_boolean
      , lt_bapilocagr          type          suid_tt_bapilocagr
      , lr_bapilocagr          type ref to   bapilocagr
      , lr_useractgrp          type ref to   usla04
      , lt_node_cua_roles      type          suid_tt_node_cua_roles
      , lt_role_uslist         type table of ususers
      , lt_systemlist          type table of ussystem
      , lt_node_subsystem      type          suid_tt_node_cua_systems
      , lr_node_subsystem      type ref to   suid_st_node_cua_system
      , lv_full_package        type          i
      , lv_process_package     type          sesf_boolean
      , lv_package_size        type          i
      , lr_usrgetstrc_tab      type ref to   ty_usrgetstrc
      .


  "--- Initialization -------------------------------------------------
  loop at gt_usrgetstrc_tab reference into lr_usrgetstrc_tab
                            where get_users eq 'X'.
    "Unmark selected user
    clear: lr_usrgetstrc_tab->get_users.

    append lr_usrgetstrc_tab->* to lt_usrgetstrc.
  endloop.

  if lt_usrgetstrc[] is initial.
    "MSG: Keinen Eintrag selektiert
    message s296(01).
    return.
  endif.

  "--- Get package size
  cl_suid_tools=>get_package_size(
    importing
      ev_package_size = lv_package_size ).

  "Set User Transfer CUA mode
  cl_identity=>set_cua_mode(
    exporting
      iv_mode           = if_suid_cua_runtime=>gc_cua_central_transfer
       iv_source_system = new_system    ).

  append if_identity_definition=>gc_node_cua_role to lt_nodes_prefetch.

  append new_system to lt_systemlist.

  append initial line to lt_node_subsystem reference into lr_node_subsystem.
  lr_node_subsystem->subsystem = new_system.


  "--- Transfer role assignments from child system for selected (marked) users
  "
  loop at lt_usrgetstrc reference into lr_usrgetstrc_tab.
    "If with one of the user packages error at RFC destination occurred ==>
    "unmark selected user but don't process them
    if lv_rfc_error = if_identity=>co_true.
      continue.
    endif.

    append lr_usrgetstrc_tab->bname to lt_bname.

    "---- Process selected users in packages
    lv_full_package = sy-tabix mod lv_package_size.
    if lv_full_package = 0.
      lv_process_package = if_identity=>co_true.
    endif.

    at last.
      lv_process_package = if_identity=>co_true.
    endat.

    if lv_process_package = if_identity=>co_false.
      continue.
    endif.

    "------ Maintenance ------
    try.
        "Get instances
        cl_identity=>retrieve_for_update(
           exporting
             it_bname          = lt_bname
             iv_node_name      = if_identity_definition=>gc_node_cua_role
             it_nodes_prefetch = lt_nodes_prefetch
           importing
             et_node_root      = lt_node_root
             eo_msg_buffer     = lo_msg_buffer ).

        "Retrieve lifetimeonce messages
        cl_identity_tools=>msg_buffer_retrieve(
          exporting
            iv_nodename          = if_identity_definition=>gc_node_root
            io_msg_buffer        = lo_msg_buffer
          changing
            ct_error_messages    = lt_error_messages   ).

        "-------- Maintain instantiated users
        loop at lt_bname reference into lr_bname.
          "Check if user was't instantiated
          read table lt_node_root reference into lr_node_root
               with key bname = lr_bname->bname
               binary search.
          "If not ==> go to another user
          if sy-subrc <> 0.
            continue.
          endif.

          "Transfer roles
          clear: lt_node_cua_roles
               , lt_bapilocagr
               , lv_error
               .

          "Collect new role assignments
          read table useractgrps
               with key bname     = lr_node_root->bname
                        subsystem = new_system
               transporting no fields
               binary search.

          if sy-subrc = 0.

            loop at useractgrps reference into lr_useractgrp from sy-tabix.

              if lr_useractgrp->bname <> lr_node_root->bname.
                exit.
              endif.

              if lr_useractgrp->subsystem <> new_system.
                exit.
              endif.

              append initial line to lt_bapilocagr reference into lr_bapilocagr.
              lr_bapilocagr->subsystem = lr_useractgrp->subsystem.
              lr_bapilocagr->agr_name  = lr_useractgrp->agr_name.
              lr_bapilocagr->from_dat  = lr_useractgrp->from_dat.
              lr_bapilocagr->to_dat    = lr_useractgrp->to_dat.
              lr_bapilocagr->org_flag  = lr_useractgrp->org_flag.

            endloop.

          endif.

          "Fill CUA roles node
          cl_suid_tools=>compute_roles_for_systems(
           exporting
             io_idref                    = lr_node_root->idref
             it_bapi_roles               = lt_bapilocagr
             it_limit_to_cua_systems     = lt_node_subsystem
           importing
             et_node_cua_roles           = lt_node_cua_roles ).

          "Don't call SET method only if both in central and child system no roles
          "are assigned, otherwise we should set status 'G' for profile section in
          "USZBVSYS and therefore we should call SET_CUA_ROLES method first to register it
          if ( lt_bapilocagr     is initial ) and
             ( lt_node_cua_roles is initial ).
            continue.
          endif.

          "Set new CUA roles
          lr_node_root->idref->if_identity_cua~set_cua_roles(
            exporting
              it_roles          = lt_node_cua_roles
            importing
              eo_msg_buffer     = lo_msg_buffer ).

          cl_identity_tools=>msg_buffer_retrieve(
            exporting
              iv_bname             = lr_node_root->bname
              io_msg_buffer        = lo_msg_buffer
            importing
              ev_error_message     = lv_error
            changing
              ct_error_messages    = lt_error_messages   ).

          if lv_error = if_identity=>co_true.
            append lr_node_root->bname to lt_bname_failed.
          else.
            append lr_node_root->bname to lt_role_uslist.
          endif.

        endloop.   "at lt_bname reference into lr_bname

        sort lt_role_uslist.

        "-------------------------------------------------------------*
        "     Last check and Cleanup of failed users before Save
        "-------------------------------------------------------------*
        append lines of lt_error_messages to lt_messages.

        clear: lv_error
             , lt_error_messages
             .
        cl_identity=>do_check(
          importing
            eo_msg_buffer = lo_msg_buffer  ).

        "Read all collected messages and sort out failed users (with any errors)
        cl_identity_tools=>msg_buffer_retrieve(
          exporting
            io_msg_buffer        = lo_msg_buffer
            iv_lifetimeonce_only = if_identity=>co_false
          changing
            ct_error_messages    = lt_error_messages   ).

        lt_msg_buffer = lt_error_messages.

        "Delete only users with errors from processing
        delete lt_msg_buffer where msgty <> if_suid_msg_buffer=>co_type_error.
        sort lt_msg_buffer by bname.
        delete adjacent duplicates from lt_msg_buffer comparing bname.

        loop at lt_msg_buffer reference into lr_message.
          append lr_message->bname to lt_bname_failed .

          read table lt_role_uslist
               with key bname = lr_message->bname
               binary search
               transporting no fields.
          if sy-subrc = 0.
            delete lt_role_uslist index sy-tabix.
          endif.
        endloop.

        sort lt_bname_failed.
        delete adjacent duplicates from lt_bname_failed comparing bname.

        "Cleanup failed instances
        if lt_bname_failed is not initial.
          cl_identity=>cleanup( it_bname = lt_bname_failed ).
        endif.

        "-------------------------------------------------------------*
        "              Save changes locally
        "-------------------------------------------------------------*
        cl_identity=>do_save(
          importing
            ev_rejected   = lv_error
            eo_msg_buffer = lo_msg_buffer  ).

        "If ev_rejected = 'X' from DO_SAVE ==> fatal error, NO instance can be saved
        "in our case, new messages can appear in message buffer only in this case on
        "this stage
        if lv_error = if_identity=>co_true.
          clear:lt_role_uslist
               .
          "Collect new messages
          cl_identity_tools=>msg_buffer_retrieve(
            exporting
              io_msg_buffer        = lo_msg_buffer
              iv_lifetimeonce_only = if_identity=>co_false
            changing
              ct_error_messages    = lt_error_messages  ).

          "Delete duplicated messages
          sort lt_error_messages stable by bname nodename msgty msgid msgno message.
          delete adjacent duplicates from lt_error_messages comparing
                 bname nodename msgty msgid msgno message.
        endif.

        append lines of lt_error_messages to lt_messages.


        "-------------------------------------------------------------*
        "             Update USZBVSYS role sections in child system
        "-------------------------------------------------------------*
        clear: ls_return
             , lv_rfc_error
             .

        "Some users have been saved
        if lv_error = if_identity=>co_false.

          if ( lv_rfc_error     <> if_identity=>co_true ) and
             ( lt_role_uslist[] is not initial          ).

            call function 'SUSR_ZBV_USER_SYSTEM_PUT'
              destination new_system
              exporting
                copied                = if_identity=>co_true
                usrsection            = if_suid_cua_runtime=>gc_role_usrsection
              tables
                systems               = lt_systemlist
                userlist              = lt_role_uslist
              exceptions
                communication_failure = 1  message lv_msgtext
                system_failure        = 2  message lv_msgtext
                others                = 3.

            if sy-subrc <> 0.
              lv_rfc_error = if_identity=>co_true.
              if lv_msgtext is not initial.
                "MSG: Das System &1 kann nicht mit RFC erreicht werden; &2
                if 1 = 0.  message i395(01) with new_system ls_msg-msgv2 ls_msg-msgv3. endif.
                ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
                ls_msg-msgid = '01'.
                ls_msg-msgno = '395'.
                ls_msg-msgv1 = new_system.
                "Split the error test into two parts
                ls_msg-msgv2 = lv_msgtext(40).
                ls_msg-msgv3 = lv_msgtext+40(40).
              else.
                ls_msg-msgty   = sy-msgty.
                ls_msg-msgid   = sy-msgid.
                ls_msg-msgno   = sy-msgno.
                ls_msg-msgv1   = sy-msgv1.
                ls_msg-msgv2   = sy-msgv2.
                ls_msg-msgv3   = sy-msgv3.
                ls_msg-msgv4   = sy-msgv4.
              endif.
              "Fill ls_return structure
              call function 'BALW_BAPIRETURN_GET2'
                exporting
                  type   = ls_msg-msgty
                  cl     = ls_msg-msgid
                  number = ls_msg-msgno
                  par1   = ls_msg-msgv1
                  par2   = ls_msg-msgv2
                  par3   = ls_msg-msgv3
                  par4   = ls_msg-msgv4
                importing
                  return = ls_return
                exceptions
                  others = 0.

              append ls_return to lt_retlist.
            endif.

            if ( lv_rfc_error     <> if_identity=>co_true ) and
               ( lt_role_uslist[] is not initial          ).
              "If RFC error already occurred ==> no sense to continue

              call function 'SUSR_ZBV_USER_SYSTEM_SAVE'
                destination new_system
                exceptions
                  communication_failure = 1  message lv_msgtext
                  system_failure        = 2  message lv_msgtext
                  others                = 3.

              if sy-subrc <> 0.
                lv_rfc_error = if_identity=>co_true.
                if lv_msgtext is not initial.
                  "MSG: Das System &1 kann nicht mit RFC erreicht werden; &2
                  if 1 = 0.  message i395(01) with new_system ls_msg-msgv2 ls_msg-msgv3. endif.
                  ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
                  ls_msg-msgid = '01'.
                  ls_msg-msgno = '395'.
                  ls_msg-msgv1 = new_system.
                  "Split the error test into two parts
                  ls_msg-msgv2 = lv_msgtext(40).
                  ls_msg-msgv3 = lv_msgtext+40(40).
                else.
                  ls_msg-msgty   = sy-msgty.
                  ls_msg-msgid   = sy-msgid.
                  ls_msg-msgno   = sy-msgno.
                  ls_msg-msgv1   = sy-msgv1.
                  ls_msg-msgv2   = sy-msgv2.
                  ls_msg-msgv3   = sy-msgv3.
                  ls_msg-msgv4   = sy-msgv4.
                endif.
                "Fill ls_return structure
                call function 'BALW_BAPIRETURN_GET2'
                  exporting
                    type   = ls_msg-msgty
                    cl     = ls_msg-msgid
                    number = ls_msg-msgno
                    par1   = ls_msg-msgv1
                    par2   = ls_msg-msgv2
                    par3   = ls_msg-msgv3
                    par4   = ls_msg-msgv4
                  importing
                    return = ls_return
                  exceptions
                    others = 0.

                append ls_return to lt_retlist.
              endif.
            endif.
          endif.
        endif.


        "-------------------------------------------------------------*
        "             Keep/ignore changes, Cleanup
        "-------------------------------------------------------------*
        "Don't keep changes in local system if RFC error or error during
        "DO_SAVE occured
        if ( lv_rfc_error = if_identity=>co_true ) or
           ( lv_error     = if_identity=>co_true ) .
          rollback work.
          "Cleanup
          cl_identity=>cleanup( ).
        else.
          "Cleanup will run automatically on commit work
          commit work.
        endif.


      "---------------------------------------------------------------*
      catch cx_suid_identity into lx_suid_identity.

        call method cl_identity_tools=>message_suid_technical_error
          exporting
            ix_suid_identity = lx_suid_identity
          importing
            es_return        = ls_return.

        append ls_return to lt_retlist.
    endtry.


    clear: lt_bname
         , lt_bname_failed
         , lt_error_messages
         , lt_msg_buffer
         , lt_role_uslist
         , lv_error
         , lv_process_package
         .

  endloop.


  "Sort user specific error protocol
  sort lt_messages stable by bname nodename msgty message_lifetime.

  "...Fill error protocol
  refresh: gt_error_log.
  perform fill_error_protocol using lt_retlist
                                    lt_messages.

  if not gt_error_log[] is initial.
    perform display_error_log.
  else.
    "MSG: Ausgewälte Daten wurden übernommen
    message s149(s#).
  endif.

endform.                    " user_role_mass_transfer

*&---------------------------------------------------------------------*
*&      Form  user_prof_mass_transfer
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form user_prof_mass_transfer .

  data: lt_bname               type          suid_tt_bname
      , lt_bname_failed        type          suid_tt_bname
      , lr_bname               type ref to   suid_st_bname
      , lt_usrgetstrc          type table of ty_usrgetstrc
      , lx_suid_identity       type ref to   cx_suid_identity
      , lt_node_root           type          suid_tt_node_root
      , lr_node_root           type ref to   suid_st_node_root
      , lo_msg_buffer          type ref to   if_suid_msg_buffer
      , lt_nodes_prefetch      type          suid_tt_node
      , lt_messages            type          if_suid_msg_buffer=>tt_messages
      , lt_msg_buffer          type          if_suid_msg_buffer=>tt_messages
      , lt_error_messages      type          if_suid_msg_buffer=>tt_messages
      , lr_message             type ref to   if_suid_msg_buffer=>ty_messages
      , ls_msg                 type          symsg
      , lv_msgtext(80)         type          c
      , ls_return              type          bapiret2
      , lt_retlist             type          bapirettab
      , lv_error               type          sesf_boolean
      , lv_rfc_error           type          sesf_boolean
      , lt_bapilocprof         type          suid_tt_bapilprof
      , lr_bapilocprof         type ref to   bapilprof
      , lr_userprofile         type ref to   usl04
      , lt_node_cua_profs      type          suid_tt_node_cua_profiles
      , lt_prof_uslist         type table of ususers
      , lt_systemlist          type table of ussystem
      , lt_node_subsystem      type          suid_tt_node_cua_systems
      , lr_node_subsystem      type ref to   suid_st_node_cua_system
      , lv_full_package        type          i
      , lv_process_package     type          sesf_boolean
      , lv_package_size        type          i
      , lr_usrgetstrc_tab      type ref to   ty_usrgetstrc
      .


  "--- Initialization -------------------------------------------------
  loop at gt_usrgetstrc_tab reference into lr_usrgetstrc_tab
                            where get_users eq 'X'.
    "Unmark selected user
    clear: lr_usrgetstrc_tab->get_users.

    append lr_usrgetstrc_tab->* to lt_usrgetstrc.
  endloop.

  if lt_usrgetstrc[] is initial.
    "MSG: Keinen Eintrag selektiert
    message s296(01).
    return.
  endif.

  "--- Get package size
  cl_suid_tools=>get_package_size(
    importing
      ev_package_size = lv_package_size ).

  "Set User Transfer CUA mode
  cl_identity=>set_cua_mode(
    exporting
      iv_mode           = if_suid_cua_runtime=>gc_cua_central_transfer
       iv_source_system = new_system    ).

  append if_identity_definition=>gc_node_cua_profile to lt_nodes_prefetch.

  append new_system to lt_systemlist.

  append initial line to lt_node_subsystem reference into lr_node_subsystem.
  lr_node_subsystem->subsystem = new_system.


  "--- Transfer profile assignments from child system for selected (marked) users
  "
  loop at lt_usrgetstrc reference into lr_usrgetstrc_tab.
    "If with one of the user packages error at RFC destination occurred ==>
    "unmark selected user but don't process them
    if lv_rfc_error = if_identity=>co_true.
      continue.
    endif.

    append lr_usrgetstrc_tab->bname to lt_bname.

    "---- Process selected users in packages, not more than 100 users at once
    lv_full_package = sy-tabix mod lv_package_size.
    if lv_full_package = 0.
      lv_process_package = if_identity=>co_true.
    endif.

    at last.
      lv_process_package = if_identity=>co_true.
    endat.

    if lv_process_package = if_identity=>co_false.
      continue.
    endif.


    "------ Maintenance ------
    try.
        "Get instances
        cl_identity=>retrieve_for_update(
           exporting
             it_bname          = lt_bname
             iv_node_name      = if_identity_definition=>gc_node_cua_profile
             it_nodes_prefetch = lt_nodes_prefetch
           importing
             et_node_root      = lt_node_root
             eo_msg_buffer     = lo_msg_buffer ).

        "Retrieve lifetimeonce messages
        cl_identity_tools=>msg_buffer_retrieve(
          exporting
            iv_nodename          = if_identity_definition=>gc_node_root
            io_msg_buffer        = lo_msg_buffer
          changing
            ct_error_messages    = lt_error_messages   ).

        "-------- Maintain instantiated users
        loop at lt_bname reference into lr_bname.
          "Check if user was't instantiated
          read table lt_node_root reference into lr_node_root
               with key bname = lr_bname->bname
               binary search.
          if sy-subrc <> 0.
            "If not ==> go to another user
            continue.
          endif.

          "Transfer profiles
          clear: lt_node_cua_profs
               , lt_bapilocprof
               , lv_error
               .

          "Collect new profile assignments
          read table userprofiles
               with key bname     = lr_node_root->bname
                        subsystem = new_system
               transporting no fields
               binary search.

          if sy-subrc = 0.

            loop at userprofiles reference into lr_userprofile from sy-tabix.
              if lr_userprofile->bname <> lr_node_root->bname.
                exit.
              endif.
              if lr_userprofile->subsystem <> new_system.
                exit.
              endif.

              append initial line to lt_bapilocprof reference into lr_bapilocprof.
              lr_bapilocprof->subsystem = lr_userprofile->subsystem.
              lr_bapilocprof->profile   = lr_userprofile->profile.
            endloop.

          endif.

          "Fill CUA profiles node
          cl_suid_tools=>compute_profiles_for_systems(
            exporting
              io_idref                = lr_node_root->idref
              it_bapi_profiles        = lt_bapilocprof
              it_limit_to_cua_systems = lt_node_subsystem
            importing
              et_node_cua_profiles    = lt_node_cua_profs  ).

          "Don't call SET method only if both in central and child system no profiles
          "are assigned, otherwise we should set status 'G' for profile section in
          "USZBVSYS and therefore we should call SET_CUA_PROFILES method first to register it
          if lt_bapilocprof is initial and lt_node_cua_profs is initial.
            continue.
          endif.

          "Set CUA profiles
          lr_node_root->idref->if_identity_cua~set_cua_profiles(
            exporting
              it_profiles          = lt_node_cua_profs
            importing
              eo_msg_buffer        = lo_msg_buffer ).

          cl_identity_tools=>msg_buffer_retrieve(
            exporting
              iv_bname             = lr_node_root->bname
              io_msg_buffer        = lo_msg_buffer
            importing
              ev_error_message     = lv_error
            changing
              ct_error_messages    = lt_error_messages  ).

          if lv_error = if_identity=>co_true.
            append lr_node_root->bname to lt_bname_failed.
          else.
            append lr_node_root->bname to lt_prof_uslist.
          endif.

        endloop.   "at lt_bname reference into lr_bname

        sort lt_prof_uslist.

        "-------------------------------------------------------------*
        "     Last check and Cleanup of failed users before Save
        "-------------------------------------------------------------*
        append lines of lt_error_messages to lt_messages.

        clear: lv_error
             , lt_error_messages
             .

        cl_identity=>do_check(
          importing
            eo_msg_buffer = lo_msg_buffer  ).

        "Read all collected messages and sort out failed users (with any errors)
        cl_identity_tools=>msg_buffer_retrieve(
          exporting
            io_msg_buffer        = lo_msg_buffer
            iv_lifetimeonce_only = if_identity=>co_false
          changing
            ct_error_messages    = lt_error_messages   ).

        lt_msg_buffer = lt_error_messages.

        "Delete only users with errors from processing
        delete lt_msg_buffer where msgty <> if_suid_msg_buffer=>co_type_error.
        sort lt_msg_buffer by bname.
        delete adjacent duplicates from lt_msg_buffer comparing bname.

        loop at lt_msg_buffer reference into lr_message.

          append lr_message->bname to lt_bname_failed .

          read table lt_prof_uslist
               with key bname = lr_message->bname
               binary search
               transporting no fields.

          if sy-subrc = 0.
            delete lt_prof_uslist index sy-tabix.
          endif.

        endloop.

        sort lt_bname_failed.
        delete adjacent duplicates from lt_bname_failed comparing bname.

        "Cleanup failed instances
        if lt_bname_failed is not initial.
          cl_identity=>cleanup( it_bname = lt_bname_failed ).
        endif.

        "-------------------------------------------------------------*
        "              Save changes locally
        "-------------------------------------------------------------*
        cl_identity=>do_save(
          importing
            ev_rejected   = lv_error
            eo_msg_buffer = lo_msg_buffer  ).

        "If ev_rejected = 'X' from DO_SAVE ==> fatal error, NO instance can be saved
        "in our case, new messages can appear in message buffer only in this case on
        "this stage
        if lv_error = if_identity=>co_true.

          clear: lt_prof_uslist
               .
          "Collect new messages
          cl_identity_tools=>msg_buffer_retrieve(
            exporting
              io_msg_buffer        = lo_msg_buffer
              iv_lifetimeonce_only = if_identity=>co_false
            changing
              ct_error_messages    = lt_error_messages  ).

          "Delete duplicated messages
          sort lt_error_messages stable by bname nodename msgty msgid msgno message.
          delete adjacent duplicates from lt_error_messages comparing
                 bname nodename msgty msgid msgno message.

        endif.

        append lines of lt_error_messages to lt_messages.

        "-------------------------------------------------------------*
        "             Update USZBVSYS role sections in child system
        "-------------------------------------------------------------*
        clear: ls_return
             , lv_rfc_error
             .
        "If some users have been saved
        if lv_error = if_identity=>co_false.

          if ( lv_rfc_error     <> if_identity=>co_true ) and
             ( lt_prof_uslist[] is not initial          ).

            call function 'SUSR_ZBV_USER_SYSTEM_PUT'
              destination new_system
              exporting
                copied                = if_identity=>co_true
                usrsection            = if_suid_cua_runtime=>gc_prof_usrsection
              tables
                systems               = lt_systemlist
                userlist              = lt_prof_uslist
              exceptions
                communication_failure = 1  message lv_msgtext
                system_failure        = 2  message lv_msgtext
                others                = 3.

            if sy-subrc <> 0.

              lv_rfc_error = if_identity=>co_true.

              if lv_msgtext is not initial.
                "MSG: Das System &1 kann nicht mit RFC erreicht werden; &2
                if 1 = 0.  message i395(01) with new_system ls_msg-msgv2 ls_msg-msgv3. endif.
                ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
                ls_msg-msgid = '01'.
                ls_msg-msgno = '395'.
                ls_msg-msgv1 = new_system.
                "Split the error test into two parts
                ls_msg-msgv2 = lv_msgtext(40).
                ls_msg-msgv3 = lv_msgtext+40(40).
              else.
                ls_msg-msgty   = sy-msgty.
                ls_msg-msgid   = sy-msgid.
                ls_msg-msgno   = sy-msgno.
                ls_msg-msgv1   = sy-msgv1.
                ls_msg-msgv2   = sy-msgv2.
                ls_msg-msgv3   = sy-msgv3.
                ls_msg-msgv4   = sy-msgv4.
              endif.
              "Fill ls_return structure
              call function 'BALW_BAPIRETURN_GET2'
                exporting
                  type   = ls_msg-msgty
                  cl     = ls_msg-msgid
                  number = ls_msg-msgno
                  par1   = ls_msg-msgv1
                  par2   = ls_msg-msgv2
                  par3   = ls_msg-msgv3
                  par4   = ls_msg-msgv4
                importing
                  return = ls_return
                exceptions
                  others = 0.

              append ls_return to lt_retlist.
            endif.

            if ( lv_rfc_error     <> if_identity=>co_true ) and
               ( lt_prof_uslist[] is not initial          ).
              "If RFC error already occurred ==> no sense to continue

              call function 'SUSR_ZBV_USER_SYSTEM_SAVE'
                destination new_system
                exceptions
                  communication_failure = 1  message lv_msgtext
                  system_failure        = 2  message lv_msgtext
                  others                = 3.

              if sy-subrc <> 0.

                lv_rfc_error = if_identity=>co_true.

                if lv_msgtext is not initial.
                  "MSG: Das System &1 kann nicht mit RFC erreicht werden; &2
                  if 1 = 0.  message i395(01) with new_system ls_msg-msgv2 ls_msg-msgv3. endif.
                  ls_msg-msgty = if_suid_msg_buffer=>co_type_error.
                  ls_msg-msgid = '01'.
                  ls_msg-msgno = '395'.
                  ls_msg-msgv1 = new_system.
                  "Split the error test into two parts
                  ls_msg-msgv2 = lv_msgtext(40).
                  ls_msg-msgv3 = lv_msgtext+40(40).
                else.
                  ls_msg-msgty   = sy-msgty.
                  ls_msg-msgid   = sy-msgid.
                  ls_msg-msgno   = sy-msgno.
                  ls_msg-msgv1   = sy-msgv1.
                  ls_msg-msgv2   = sy-msgv2.
                  ls_msg-msgv3   = sy-msgv3.
                  ls_msg-msgv4   = sy-msgv4.
                endif.
                "Fill ls_return structure
                call function 'BALW_BAPIRETURN_GET2'
                  exporting
                    type   = ls_msg-msgty
                    cl     = ls_msg-msgid
                    number = ls_msg-msgno
                    par1   = ls_msg-msgv1
                    par2   = ls_msg-msgv2
                    par3   = ls_msg-msgv3
                    par4   = ls_msg-msgv4
                  importing
                    return = ls_return
                  exceptions
                    others = 0.

                append ls_return to lt_retlist.
              endif.
            endif.
          endif.
        endif.

        "-------------------------------------------------------------*
        "       Keep/ignore changes, Cleanup
        "-------------------------------------------------------------*
        "Don't keep changes in local system if RFC error or error
        "during DO_SAVE occured
        if ( lv_rfc_error = if_identity=>co_true ) or
           ( lv_error     = if_identity=>co_true ).
          rollback work.
          "Cleanup
          cl_identity=>cleanup( ).
        else.
          "Cleanup will run automatically on commit work
          commit work.
        endif.

      "---------------------------------------------------------------*
      catch cx_suid_identity into lx_suid_identity.

        call method cl_identity_tools=>message_suid_technical_error
          exporting
            ix_suid_identity = lx_suid_identity
          importing
            es_return        = ls_return.

        append ls_return to lt_retlist.

    endtry.


    clear: lt_bname
         , lt_bname_failed
         , lt_error_messages
         , lt_msg_buffer
         , lt_prof_uslist
         , lv_error
         , lv_process_package
         .

  endloop.

  "Sort user specific error protocol
  sort lt_messages stable by bname msgty message_lifetime.

  "...Fill error protocol
  refresh: gt_error_log.
  perform fill_error_protocol using lt_retlist
                                    lt_messages.

  if not gt_error_log[] is initial.
    perform display_error_log.
  else.
    "MSG: Ausgewälte Daten wurden übernommen
    message s149(s#).
  endif.

endform.                    " user_prof_mass_transfer

*&---------------------------------------------------------------------*
*&      Form  popup_to_confirm_transfer
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_POPUP_TXT  text
*      <--P_EXIT  text
*----------------------------------------------------------------------*
form popup_to_confirm_transfer  using    title         type any
                                changing exit          type c.

  data: text2(75)          type c,
        text3(75)          type c,
        text_question(400) type c,
        answer             type c.

  read table gt_usrgetstrc_tab transporting no fields
       with key get_users = 'X'.

  if sy-subrc <> 0.
    "Keinen Eintrag selektiert
    message s296(01).
    exit = 'X'.
    return.
  endif.

  text2 = 'Original data for selected users will be overwritten.'(006). "#EC TEXT_DIFF
  text3 = 'Do you want to Continue?'(007).                              "#EC TEXT_DIFF
  concatenate text2 text3 into text_question separated by space.

  call function 'POPUP_TO_CONFIRM'
    exporting
      titlebar              = title
      text_question         = text_question
      default_button        = '2'
      display_cancel_button = space
    importing
      answer                = answer
    exceptions
      text_not_found        = 0
      others                = 0.

  if answer <> '1'.
    exit = 'X'.
  endif.


endform.                    " popup_to_confirm_transfer

*&---------------------------------------------------------------------*
*&      Form  set_system_status
*&---------------------------------------------------------------------*
* Update NEW_SYSTEM status in DB table USZBVLNDRC:
*   If every user from the new system is overtaken into the
*   central system (status 'C' of all users)
*   -> The status NEW of the client system can be deleted
*----------------------------------------------------------------------*
form set_system_status .

  data: new_system_status   type        c
      , old_system_status   type        c
      , ls_snodetext        type        snodetext
      , node_name           type        snode-name
      , retlist             type        bapiret2_t
      , lt_messages         type        if_suid_msg_buffer=>tt_messages
      , ls_uszbvlndrc       type        uszbvlndrc
      , lt_receiver_cd_new  type        ty_t_cd_uszbvlndrc
      , lt_receiver_cd_old  type        ty_t_cd_uszbvlndrc
      , lr_receiver_cd      type ref to vsusr_uszbvlndrc
      , lr_uszbvlndrc       type ref to uszbvlndrc
      .

  field-symbols: <ls_usrgetstrc> type ty_usrgetstrc.

  "Central system cannot have status NEW_SYSTEM
  check new_system <> g_sendsystem.

  "Get old system status
  select single * from uszbvlndrc into ls_uszbvlndrc
        where model     = g_bapilink
          and rcvsystem = new_system.

  if sy-subrc <> 0.
    "Old status pseudo-value: system is not part of the CUA
    old_system_status = 'Z'.
  else.
    old_system_status = ls_uszbvlndrc-new_system.
  endif.

  "Get new system status
  clear new_system_status.
  loop at gt_usrgetstrc assigning <ls_usrgetstrc>.

    if <ls_usrgetstrc>-status <> 'C'.
      new_system_status = 'X'.
      exit.
    endif.

  endloop.

  "Is system status chaged?
  check old_system_status <> new_system_status.

  "prepare change documents
  append initial line to lt_receiver_cd_old reference into lr_receiver_cd.
  move-corresponding ls_uszbvlndrc to lr_receiver_cd->*.
  lr_receiver_cd->kz = cl_susr_cua_tools=>gc_cd_ind_upd.

  append initial line to lt_receiver_cd_new reference into lr_receiver_cd.
  move-corresponding ls_uszbvlndrc to lr_receiver_cd->*.
  lr_receiver_cd->new_system = new_system_status.
  lr_receiver_cd->kz = cl_susr_cua_tools=>gc_cd_ind_upd.

  "Update system status
  update uszbvlndrc set new_system  = new_system_status
                    where model     = g_bapilink
                      and rcvsystem = new_system.

  "write change documents
  call function 'SUSR_USER_CUA_WRITE_CHANGEDOC'
    exporting
      iv_changed_cua = g_bapilink
    tables
      it_xuszbvlndrc = lt_receiver_cd_new
      it_yuszbvlndrc = lt_receiver_cd_old
    exceptions
      others         = 0
      .
  free: lt_receiver_cd_new[]
      , lt_receiver_cd_old[]
      .

  read table it_uszbvlndrc with key rcvsystem = new_system reference into lr_uszbvlndrc.

  if sy-subrc = 0.
    lr_uszbvlndrc->new_system = new_system_status.
  endif.

  "Refresh the display of CUA tree
  node_name = new_system.

  call function 'RS_TREE_GET_NODE_BY_NAME'
    exporting
      node_name = node_name
    importing
      node_info = ls_snodetext
    exceptions
      others    = 0.

  define_new_system_status new_system_status ls_snodetext.

  call function 'RS_TREE_SET_NODE'
    exporting
      node_info = ls_snodetext
    exceptions
      others    = 0.

  "Delete internal buffer function group SUU6
  call function 'SUSR_ZBV_CLEAR_BUFFER'.

  "Update db tables in target systems
  call function 'SUSR_ZBV_LANDSCAPE_SEND'
    tables
      it_bapiret2 = retlist
    exceptions
      others      = 0.

  "Fill error protocol
  perform fill_error_protocol using retlist
                                    lt_messages.
  "792(01): Status of the child system is changed
  message s792(01) with new_system old_system_status.

endform.                    " set_system_status

*&---------------------------------------------------------------------*
*&      Form  fill_error_protocol
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form fill_error_protocol using    it_return      type bapirettab
                                  it_messages    type if_suid_msg_buffer=>tt_messages .

  data: lr_return  type ref to bapiret2
      , lr_message type ref to if_suid_msg_buffer=>ty_messages
      , lr_s_msg   type ref to bal_s_msg
      , lr_u_msg   type ref to bal_s_msg
      , lv_bname   type        xubname
      .


  loop at it_return reference into lr_return.
    append initial line to gt_error_log reference into lr_s_msg.

    lr_s_msg->msgty     = lr_return->type.             "bal_s_msg-type.
    lr_s_msg->msgid     = lr_return->id.               "bal_s_msg-id.
    lr_s_msg->msgno     = lr_return->number.           "bal_s_msg-number.
    lr_s_msg->msgv1     = lr_return->message_v1.       "bal_s_msg-msgv1.
    lr_s_msg->msgv2     = lr_return->message_v2.       "bal_s_msg-msgv2.
    lr_s_msg->msgv3     = lr_return->message_v3.       "bal_s_msg-msgv3.
    lr_s_msg->msgv4     = lr_return->message_v4.       "bal_s_msg-msgv4.
    lr_s_msg->detlevel  = '1'.                         "bal_s_msg-detlevel.
  endloop.

  loop at it_messages reference into lr_message.
    "For every new user add user summarizing header
    if lv_bname <> lr_message->bname.
      lv_bname = lr_message->bname.
      "MSG: Benutzer &1
      if 1 = 0. message e604(01) with lr_message->bname. endif.
      append initial line to gt_error_log reference into lr_u_msg.
      lr_u_msg->msgty     = lr_message->msgty.
      lr_u_msg->msgid     = '01'.
      lr_u_msg->msgno     = '604'.
      lr_u_msg->msgv1     = lr_message->bname.
      lr_u_msg->detlevel  = '1'.
      lr_u_msg->probclass = '1'.
    endif.

    append initial line to gt_error_log reference into lr_s_msg.
    lr_s_msg->msgty     = lr_message->msgty.
    lr_s_msg->msgid     = lr_message->msgid.
    lr_s_msg->msgno     = lr_message->msgno.
    lr_s_msg->msgv1     = lr_message->msgv1.
    lr_s_msg->msgv2     = lr_message->msgv2.
    lr_s_msg->msgv3     = lr_message->msgv3.
    lr_s_msg->msgv4     = lr_message->msgv4.
    lr_s_msg->detlevel  = '2'.

    "Increase the msgty of the "user message" according to the msgty
    "of raised messages per user (if necessary):
    case lr_u_msg->msgty.
      when if_suid_msg_buffer=>co_type_success.
        if ( lr_s_msg->msgty <> if_suid_msg_buffer=>co_type_success ).
          lr_u_msg->msgty = lr_s_msg->msgty.
        endif.

      when if_suid_msg_buffer=>co_type_info.
        if ( lr_s_msg->msgty <> if_suid_msg_buffer=>co_type_success ) and
           ( lr_s_msg->msgty <> if_suid_msg_buffer=>co_type_info    ).
          lr_u_msg->msgty = lr_s_msg->msgty.
        endif.

      when if_suid_msg_buffer=>co_type_warning.
        if ( lr_s_msg->msgty <> if_suid_msg_buffer=>co_type_success ) and
           ( lr_s_msg->msgty <> if_suid_msg_buffer=>co_type_info    ) and
           ( lr_s_msg->msgty <> if_suid_msg_buffer=>co_type_warning ).
          lr_u_msg->msgty = lr_s_msg->msgty.
        endif.

      when others.
        "highest level already reached.
        lr_u_msg->msgty = if_suid_msg_buffer=>co_type_error.
    endcase.

  endloop.

endform.                    " fill_error_protocol
