CLASS ltc_atp_buffer DEFINITION DEFERRED.
CLASS cl_atp_buffer DEFINITION LOCAL FRIENDS ltc_atp_buffer.
CLASS ltc_atp_buffer DEFINITION FOR TESTING
  DURATION SHORT
  RISK LEVEL HARMLESS
  FINAL.

  PRIVATE SECTION.
    DATA:
      f_cut                   TYPE REF TO if_atp_buffer.

    METHODS:
      setup,
      add_to_buffer                 FOR TESTING,
      add_updated_to_buffer         FOR TESTING,
      add_wrong_format_to_buffer    FOR TESTING,
      key_structure                 FOR TESTING,
      key_structure_no_key          FOR TESTING,
      structure                     FOR TESTING,
      components_deep               FOR TESTING,
      reseting_buffer               FOR TESTING,
      get_data_no_key               FOR TESTING,
      get_data_key                  FOR TESTING,
      get_data_key_partner          FOR TESTING,
      get_data_key_not_found        FOR TESTING,
      get_all_data                  FOR TESTING,
      find_specific_data            FOR TESTING,
      find_specific_data_no_data    FOR TESTING,
      find_specific_data_deep_struc FOR TESTING,
      has_specific_data             FOR TESTING,
      get_data_w_2nd_key            FOR TESTING,

      set_negative_buffer          FOR TESTING,
      set_negative_buffer_multiple FOR TESTING,
      set_negative_buffer_sec_key  for TESTING,
      set_neg_buf_set_buf          FOR TESTING,
      set_buf_set_neg_buf          FOR TESTING,
      find_data_not_exist          FOR TESTING,
      get_all_negative_buff        FOR TESTING,
      get_data_and_respect_neg_buf FOR TESTING,

      delete_data_key              FOR TESTING,
      delete_data_w_neg_buffer     FOR TESTING,

      convert_table_key            FOR TESTING.

ENDCLASS.


CLASS ltc_atp_buffer IMPLEMENTATION.

  METHOD setup.
    cl_atp_buffer_manager=>get_vbak_buffer( )->reset( ).
    cl_atp_buffer_manager=>get_item_buffer( )->reset( ).
    cl_atp_buffer_manager=>get_vbap_db_state_buffer( )->reset( ).
  ENDMETHOD.

  METHOD add_to_buffer.
    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '3'.
    INSERT ls_vbak INTO TABLE lt_vbak.

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_data->* TO <lt_data>.

    cl_aunit_assert=>assert_equals( exp = 3  act = lines( <lt_data> ) ).

  ENDMETHOD.

  METHOD add_updated_to_buffer.
    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

* Test data
    ls_vbak-vbeln = '1'.
    ls_vbak-vkorg = '0001'.
    INSERT ls_vbak INTO TABLE lt_vbak.

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_data->* TO <lt_data>.
    DATA lt_vbak_act TYPE TABLE OF vbak.
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( exp = '1'  act = lt_vbak_act[ 1 ]-vbeln ).
    cl_aunit_assert=>assert_equals( exp = '0001'  act = lt_vbak_act[ 1 ]-vkorg ).

* Update data and fill again into buffer
    lt_vbak[ 1 ]-vkorg = '9889'.
    f_cut->set( it_data = lt_vbak ).

    ASSIGN lo_buffer->mr_data->* TO <lt_data>.
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( exp = '1'  act = lt_vbak_act[ 1 ]-vbeln ).
    cl_aunit_assert=>assert_equals( exp = '9889'  act = lt_vbak_act[ 1 ]-vkorg ).

  ENDMETHOD.

  METHOD add_wrong_format_to_buffer.
    DATA: lo_buffer        TYPE REF TO cl_atp_buffer,
          lt_vbap_db_state TYPE if_atp_data_access=>tt_vbap_db_state_data,
          ls_vbap_db_state LIKE LINE OF lt_vbap_db_state.

* Test data
    ls_vbap_db_state-delnr = '1'.
    INSERT ls_vbap_db_state INTO TABLE lt_vbap_db_state.
    ls_vbap_db_state-delnr = '2'.
    INSERT ls_vbap_db_state INTO TABLE lt_vbap_db_state.
    ls_vbap_db_state-delnr = '3'.
    INSERT ls_vbap_db_state INTO TABLE lt_vbap_db_state.

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_item_buffer( ).
    f_cut->set( it_data = lt_vbap_db_state ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_data->* TO <lt_data>.

    cl_aunit_assert=>assert_equals( exp = 3  act = lines( <lt_data> ) ).

  ENDMETHOD.

  METHOD key_structure.

    DATA lr_key_structure TYPE REF TO data.
    DATA lo_struc_desc TYPE REF TO cl_abap_structdescr.

    FIELD-SYMBOLS <ls_key_structure> TYPE any.

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_key_structure(
      IMPORTING
        er_key_structure =  lr_key_structure ).
    ASSIGN lr_key_structure->* TO <ls_key_structure>.
*
** Check
    lo_struc_desc ?= cl_abap_typedescr=>describe_by_data( <ls_key_structure> ).
    DATA(lt_component) = lo_struc_desc->get_components( ).

    "exluded mandt on purpose from key, because we can be sure to have the right mandt and if it is part of the key we need to fill it always
*    cl_aunit_assert=>assert_equals( exp = 'MANDT'  act = lt_component[ 1 ]-name ).
    cl_aunit_assert=>assert_equals( exp = 'VBELN'  act = lt_component[ 1 ]-name ).

  ENDMETHOD.

  METHOD key_structure_no_key.

    DATA lr_key_structure TYPE REF TO data.
    DATA lo_tbl_desc TYPE REF TO cl_abap_tabledescr.
    DATA lt_order_matwerk TYPE if_atp_abc_data_access=>tt_order_matwerk.

    lo_tbl_desc ?= cl_abap_tabledescr=>describe_by_data( p_data = lt_order_matwerk ).

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_eligible_plant_buffer( ).

* Instantiate actual buffer
    f_cut = NEW cl_atp_buffer( io_table_structure = lo_tbl_desc ).

    f_cut->get_key_structure(
      IMPORTING
        er_key_structure =  lr_key_structure ).

* Check
    cl_aunit_assert=>assert_initial( act = lr_key_structure level = if_aunit_constants=>tolerable ).

  ENDMETHOD.

  METHOD structure.

    DATA lo_struc_desc TYPE REF TO cl_abap_structdescr.
    DATA lr_structure TYPE REF TO data.
    FIELD-SYMBOLS <ls_structure> TYPE any.

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_data_structure(
      IMPORTING
        er_structure = lr_structure ).

    ASSIGN lr_structure->* TO <ls_structure>.

* Check
    lo_struc_desc ?= cl_abap_typedescr=>describe_by_data( <ls_structure> ).
    DATA(lt_component) = lo_struc_desc->get_components( ).
    lo_struc_desc ?= cl_abap_typedescr=>describe_by_name( p_name = 'VBAK' ).

    cl_aunit_assert=>assert_equals( exp = lo_struc_desc->get_components( )  act = lt_component ).

  ENDMETHOD.

  METHOD components_deep.
    TYPES: BEGIN OF ts_sub_components,
             material TYPE matnr,
             plant    TYPE werks_d,
           END OF ts_sub_components.
    TYPES: BEGIN OF ts_components,
             delnr TYPE delnr,
             delps TYPE delps.
             INCLUDE TYPE ts_sub_components AS pac_key.
    TYPES: END OF ts_components.

    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    lo_buffer ?= cl_atp_buffer_factory=>create_partner_buffer( )."just any instance

    DATA ls_components TYPE ts_components.
    DATA lo_struc_desc TYPE REF TO cl_abap_structdescr.
    DATA lt_components_act TYPE abap_component_tab.

    lo_struc_desc ?= cl_abap_typedescr=>describe_by_data( ls_components ).
    lt_components_act = lo_buffer->get_all_components( io_data_desc = lo_struc_desc ).

    cl_aunit_assert=>assert_equals( exp = 4 act = lines( lt_components_act ) ).

  ENDMETHOD.

  METHOD reseting_buffer.
    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.

* Call method under test
    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak ).
    f_cut->reset( ).

* Check
    FIELD-SYMBOLS:
         <lt_data> TYPE ANY TABLE.

    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_data->* TO <lt_data>.

    cl_aunit_assert=>assert_equals( exp = 0  act = lines( <lt_data> ) ).

  ENDMETHOD.

  METHOD get_all_data.
    DATA lt_atpmat_data TYPE TABLE OF atp_mat_key.
    DATA lt_atpmat_data_exp TYPE tbl_atp_mat_key.
    DATA lr_result TYPE REF TO data.
    DATA lo_strc_desc TYPE REF TO cl_abap_structdescr.
    DATA lo_tbl_desc TYPE REF TO cl_abap_tabledescr.


    FIELD-SYMBOLS <lt_result> TYPE tbl_atp_mat_key.

* Set test data
    lt_atpmat_data = VALUE #( ( matnr = '123' werks = '0001' berid = '0001' )
                              ( matnr = '124' werks = '0002' berid = '0002' ) ).


    lo_strc_desc ?= cl_abap_structdescr=>describe_by_name( p_name = 'ATP_MAT_KEY' ).
    lo_tbl_desc = cl_abap_tabledescr=>get(
      EXPORTING
        p_line_type  = lo_strc_desc
        p_table_kind = cl_abap_tabledescr=>tablekind_std ).

    f_cut = NEW cl_atp_buffer( io_table_structure = lo_tbl_desc ).
    f_cut->set( it_data = lt_atpmat_data ).

* Call method under test
    f_cut->get_all(
      IMPORTING
        et_data = lr_result
    ).
    ASSIGN lr_result->* TO <lt_result>.

* Check
    lt_atpmat_data_exp = VALUE #( ( matnr = '123' werks = '0001' berid = '0001' )
                                  ( matnr = '124' werks = '0002' berid = '0002' ) ).
    cl_aunit_assert=>assert_equals( exp  = lt_atpmat_data_exp act  = <lt_result> ).

  ENDMETHOD.

  METHOD get_data_no_key.
    DATA lt_atpmat_data TYPE TABLE OF atp_mat_key.
    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lo_strc_desc TYPE REF TO cl_abap_structdescr.
    DATA lo_tbl_desc TYPE REF TO cl_abap_tabledescr.


    FIELD-SYMBOLS <lt_result> TYPE tbl_atp_mat_key.
    FIELD-SYMBOLS <lt_key> TYPE tbl_atp_mat_key.

* Set test data
    lt_atpmat_data = VALUE #( ( matnr = '123' werks = '0001' berid = '0001' )
                              ( matnr = '124' werks = '0002' berid = '0002' ) ).


    lo_strc_desc ?= cl_abap_structdescr=>describe_by_name( p_name = 'ATP_MAT_KEY' ).
    lo_tbl_desc = cl_abap_tabledescr=>get(
      EXPORTING
        p_line_type  = lo_strc_desc
        p_table_kind = cl_abap_tabledescr=>tablekind_std ).

    f_cut = NEW cl_atp_buffer( io_table_structure = lo_tbl_desc ).
    f_cut->set( it_data = lt_atpmat_data ).

* Call method under test
    CREATE DATA lr_key TYPE tbl_atp_mat_key.
    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = VALUE tbl_atp_mat_key( ( lt_atpmat_data[ 1 ] ) ).

    f_cut->get( EXPORTING it_key = lr_key IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

* Check
    cl_aunit_assert=>assert_equals( exp  = 1 act  = lines( <lt_result> ) ).
    cl_aunit_assert=>assert_equals( exp  = '123' act  = <lt_result>[ 1 ]-matnr ).
    cl_aunit_assert=>assert_equals( exp  = '0001' act  = <lt_result>[ 1 ]-werks ).
    cl_aunit_assert=>assert_equals( exp  = '0001' act  = <lt_result>[ 1 ]-berid ).

  ENDMETHOD.

  METHOD get_data_key.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA lt_vbak_key TYPE TABLE OF vbak.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.

    DATA lt_result LIKE lt_vbak_data.


    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key> TYPE any.

* Set test data
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' )
                              ( vbeln = '2' vkorg = 'OR' vtweg = '02' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).

* Get key structure to set request
    f_cut->get_key_table_structure(
      IMPORTING
        er_key_table_structure = lr_key ).

    lt_vbak_key = VALUE #( ( vbeln = '1' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_vbak_key ).

* Call method under test
    f_cut->get( EXPORTING it_key = lr_key IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

    lt_result = CORRESPONDING #( <lt_result> ).

* Check
    cl_aunit_assert=>assert_equals( exp  = 1 act  = lines( lt_result ) ).
    cl_aunit_assert=>assert_equals( exp  = '1' act  = lt_result[ 1 ]-vbeln ).
    cl_aunit_assert=>assert_equals( exp  = 'TA' act  = lt_result[ 1 ]-vkorg ).
    cl_aunit_assert=>assert_equals( exp  = '01' act  = lt_result[ 1 ]-vtweg ).

  ENDMETHOD.

  METHOD get_data_key_partner.
    DATA lt_partner_data TYPE vbpavb_tab.
    DATA lt_partner_key TYPE vbpavb_tab.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.

    DATA lt_result LIKE lt_partner_data.


    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key> TYPE any.

* Set test data
    lt_partner_data = VALUE #( ( vbeln = '1' posnr = '1' parvw = 'A' kunnr = 'X' )
                              ( vbeln = '2' posnr = '1' parvw = '02' kunnr = 'Y' ) ).

    f_cut = cl_atp_buffer_manager=>get_partner_buffer( ).
    f_cut->set( it_data = lt_partner_data ).

* Get key structure to set request
    f_cut->get_key_table_structure(
      IMPORTING
        er_key_table_structure = lr_key ).

    lt_partner_key = VALUE #( ( vbeln = '2' posnr = '1' parvw = '02' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_partner_key ).

* Call method under test
    f_cut->get( EXPORTING it_key = lr_key IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

    lt_result = CORRESPONDING #( <lt_result> ).

* Check
    cl_aunit_assert=>assert_equals( exp  = 1 act  = lines( lt_result ) ).
    cl_aunit_assert=>assert_equals( exp  = '2' act  = lt_result[ 1 ]-vbeln ).

  ENDMETHOD.

  METHOD get_data_key_not_found.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA lt_vbak_key TYPE TABLE OF vbak.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lt_key_not_found LIKE lt_vbak_key.


    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key> TYPE any.

* Set test data
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).

* Get key structure to set request
    f_cut->get_key_table_structure(
      IMPORTING
        er_key_table_structure = lr_key ).

    lt_vbak_key = VALUE #( ( vbeln = '3' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_vbak_key ).

* Call method under test
    f_cut->get( EXPORTING it_key = lr_key
                IMPORTING et_data = lr_result
                          et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.

    lt_key_not_found = CORRESPONDING #( <lt_key_not_found> ).

* Check
    cl_aunit_assert=>assert_initial( act = <lt_result> ).
    cl_aunit_assert=>assert_equals( exp  = 1 act = lines( <lt_key_not_found> ) ).
    cl_aunit_assert=>assert_equals( exp  = '3' act  = lt_key_not_found[ 1 ]-vbeln ).

  ENDMETHOD.

  METHOD find_specific_data.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA lt_vbak_query TYPE TABLE OF vbak.

    DATA lr_result TYPE REF TO data.
    DATA lr_query TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_query> TYPE ANY TABLE.

* Set test data
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' )
                              ( vbeln = '2' vkorg = 'OR' vtweg = '02' )
                              ( vbeln = '3' vkorg = 'OR' vtweg = '02' )
                              ( vbeln = '5' vkorg = 'OR' vtweg = '02' )
                              ( vbeln = '8' vkorg = 'TA' vtweg = '04' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).

* Get structure to set request
    f_cut->get_data_table_structure(
      IMPORTING
        er_table_structure = lr_query
    ).

    lt_vbak_query = VALUE #( ( vbeln = '5' vkorg = 'OR' vtweg = '02' )
                             ( vbeln = '2' vkorg = 'OR' vtweg = '02' )
                             ( vbeln = '6' vkorg = 'OR' vtweg = '66' ) ).

    ASSIGN lr_query->* TO <lt_query>.
    <lt_query> = CORRESPONDING #( lt_vbak_query ).

* Call method under test
    f_cut->find(
      EXPORTING
        it_data           = lr_query
      IMPORTING
        et_data           = lr_result
        et_data_not_found = lr_key_not_found
    ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_not_found>.

    DATA lt_not_found_exp TYPE TABLE OF vbak.
    DATA lt_result_exp TYPE TABLE OF vbak.
    DATA lt_not_found_act TYPE TABLE OF vbak.
    DATA lt_result_act TYPE TABLE OF vbak.

    lt_not_found_exp = VALUE #( ( vbeln = '6' vkorg = 'OR' vtweg = '66' ) ).
    lt_result_exp = VALUE #( ( vbeln = '2' vkorg = 'OR' vtweg = '02' )
                             ( vbeln = '5' vkorg = 'OR' vtweg = '02' ) ).

    lt_not_found_act = CORRESPONDING #( <lt_not_found> ).
    lt_result_act = CORRESPONDING #( <lt_result> ).

* Check
    cl_aunit_assert=>assert_equals( exp  = lt_not_found_exp act  = lt_not_found_act ).
    cl_aunit_assert=>assert_equals( exp  = lt_result_exp    act  = lt_result_act ).
  ENDMETHOD.


  METHOD find_specific_data_no_data.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA lt_vbak_query TYPE TABLE OF vbak.

    DATA lr_result TYPE REF TO data.
    DATA lr_query TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_query> TYPE ANY TABLE.

* Set test data
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).

* Get structure to set request
    f_cut->get_data_table_structure(
      IMPORTING
        er_table_structure = lr_query
    ).

    lt_vbak_query = VALUE #( ( vbeln = '5' vkorg = 'OR' vtweg = '02' ) ).

    ASSIGN lr_query->* TO <lt_query>.
    <lt_query> = CORRESPONDING #( lt_vbak_query ).

* Call method under test
    f_cut->find(
      EXPORTING
        it_data           = lr_query
      IMPORTING
        et_data           = lr_result
        et_data_not_found = lr_key_not_found
    ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_not_found>.

    DATA lt_not_found_act TYPE TABLE OF vbak.
    DATA lt_result_act TYPE TABLE OF vbak.

    lt_not_found_act = CORRESPONDING #( <lt_not_found> ).
    lt_result_act = CORRESPONDING #( <lt_result> ).

* Check
    cl_aunit_assert=>assert_initial( act  = lt_result_act ).
    cl_aunit_assert=>assert_not_initial( act  = lt_not_found_act ).
  ENDMETHOD.



  METHOD find_specific_data_deep_struc.
    DATA lt_vbpavb_data TYPE TABLE OF vbpavb.
    DATA lt_vbpavb_query TYPE TABLE OF vbpavb.

    DATA lr_result TYPE REF TO data.
    DATA lr_query TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_query> TYPE ANY TABLE.

* Set test data
    lt_vbpavb_data = VALUE #( ( vbeln = '1' posnr = '01' parvw = '01' )
                              ( vbeln = '2' posnr = '01' parvw = '02' )
                              ( vbeln = '3' posnr = '01' parvw = '02' )
                              ( vbeln = '5' posnr = '01' parvw = '02' )
                              ( vbeln = '8' posnr = '01' parvw = '04' ) ).

    f_cut = cl_atp_buffer_manager=>get_partner_buffer( ).
    f_cut->set( it_data = lt_vbpavb_data ).

* Get structure to set request
    f_cut->get_data_table_structure(
      IMPORTING
        er_table_structure = lr_query
    ).

    lt_vbpavb_query = VALUE #( ( vbeln = '5' posnr = '01' parvw = '02' )
                               ( vbeln = '2' posnr = '01' parvw = '02' )
                               ( vbeln = '6' posnr = '01' parvw = '66' ) ).

    ASSIGN lr_query->* TO <lt_query>.
    <lt_query> = CORRESPONDING #( lt_vbpavb_query ).


* Call method under test
    f_cut->find(
      EXPORTING
        it_data           = lr_query
      IMPORTING
        et_data           = lr_result
        et_data_not_found = lr_key_not_found
    ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_not_found>.

    DATA lt_not_found_exp TYPE TABLE OF vbpavb.
    DATA lt_result_exp TYPE TABLE OF vbpavb.
    DATA lt_not_found_act TYPE TABLE OF vbpavb.
    DATA lt_result_act TYPE TABLE OF vbpavb.

    lt_not_found_exp = VALUE #( ( vbeln = '6' posnr = '01' parvw = '66' ) ).
    lt_result_exp = VALUE #( ( vbeln = '2' posnr = '01' parvw = '02' )
                             ( vbeln = '5' posnr = '01' parvw = '02' ) ).

    lt_not_found_act = CORRESPONDING #( <lt_not_found> ).
    lt_result_act = CORRESPONDING #( <lt_result> ).

* Check
    cl_aunit_assert=>assert_equals( exp  = lt_not_found_exp act  = lt_not_found_act ).
    cl_aunit_assert=>assert_equals( exp  = lt_result_exp    act  = lt_result_act ).
  ENDMETHOD.

  METHOD has_specific_data.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA ls_vbak_query TYPE vbak.
    DATA lv_has_act TYPE boole.

    DATA lr_query TYPE REF TO data.

    FIELD-SYMBOLS <ls_query> TYPE any.

* Set test data
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' )
                              ( vbeln = '2' vkorg = 'OR' vtweg = '02' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).

* Get structure to set request
    f_cut->get_data_structure(
      IMPORTING
        er_structure = lr_query
    ).

    ls_vbak_query = VALUE #( vbeln = '2' vkorg = 'OR' vtweg = '02' ).

    ASSIGN lr_query->* TO <ls_query>.
    <ls_query> = CORRESPONDING #( ls_vbak_query ).

* Call method under test
    lv_has_act = f_cut->has( is_data = lr_query ).

* Check
    cl_aunit_assert=>assert_equals( exp  = abap_true act  = lv_has_act ).


* Negative test of method under test
    CLEAR <ls_query>.
    ls_vbak_query = VALUE #( vbeln = '9' vkorg = 'OR' vtweg = '02' ).
    <ls_query> = CORRESPONDING #( ls_vbak_query ).

* Call method under test
    lv_has_act = f_cut->has( is_data = lr_query ).

* Check
    cl_aunit_assert=>assert_equals( exp  = abap_false act  = lv_has_act ).
  ENDMETHOD.

  METHOD get_data_w_2nd_key.

    DATA: lt_item_data              TYPE if_atp_data_access=>tt_vbap_db_state_data,
          lt_item_data_negative     like lt_item_data,
          lt_item_data_act          LIKE lt_item_data,
          lt_item_data_exp          LIKE lt_item_data,
          lt_item_key_4_subitems    LIKE lt_item_data,
          lr_item_data              TYPE REF TO data,
          lr_item_key_not_found     TYPE REF TO data,
          lt_item_key_not_found_act LIKE lt_item_data,
          lt_item_key_not_found_exp LIKE lt_item_data,
          lr_item_key_not_exist     TYPE REF TO data,
          lt_item_key_not_exist_act LIKE lt_item_data,
          lt_item_key_not_exist_exp LIKE lt_item_data,
          lr_item_key               TYPE REF TO data.

    FIELD-SYMBOLS: <lt_item_data_act>          TYPE ANY TABLE,
                   <lt_item_key_not_found_act> TYPE ANY TABLE,
                   <lt_item_key_not_exist_act> TYPE ANY TABLE,
                   <lt_item_key>               TYPE ANY TABLE.

* Set test data
    lt_item_data = VALUE #( ( delnr = '1' delps = '10'              )
                            ( delnr = '1' delps = '20' uepos = '10' )
                            ( delnr = '1' delps = '30' uepos = '10' ) ).

    lt_item_data_negative = VALUE #( ( delnr = '1' uepos = '60' ) ).

    lt_item_data_exp = VALUE #( ( delnr = '1' delps = '20' uepos = '10' )
                                ( delnr = '1' delps = '30' uepos = '10' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbap_db_state_buffer( ).
    f_cut->set( it_data = lt_item_data ).
    f_cut->set_negative( it_data = lt_item_data_negative iv_key_name = 'MAIN_ITEM' ).


* Get key structure to set request
    f_cut->get_secondary_key_table_struct(
      EXPORTING
        iv_key_name            = 'MAIN_ITEM'
      IMPORTING
        er_key_table_structure = lr_item_key
    ).

    lt_item_key_4_subitems = VALUE #( ( delnr = '1' delps = '20' uepos = '10' )
                                      ( delnr = '1' delps = '30' uepos = '10' )
                                      ( delnr = '1' delps = '50' uepos = '40' )
                                      ( delnr = '1' delps = '70' uepos = '60' ) ).

    ASSIGN lr_item_key->* TO <lt_item_key>.
    <lt_item_key> = CORRESPONDING #( lt_item_key_4_subitems DISCARDING DUPLICATES ).


* Call method under test
    f_cut->find_with_secondary_key(
      EXPORTING
        it_key           = lr_item_key
        iv_key_name      = 'MAIN_ITEM'
      IMPORTING
        et_data          = lr_item_data
        et_key_not_found = lr_item_key_not_found
        et_key_not_exist = lr_item_key_not_exist
    ).

    ASSIGN lr_item_data->* TO <lt_item_data_act>.

    lt_item_data_act = CORRESPONDING #( <lt_item_data_act> ).

    th_atp_coordinator=>assert_table_equals(
      EXPORTING
        it_act          = lt_item_data_act
        it_exp          = lt_item_data_exp
        iv_ignore_order = abap_true
    ).

    lt_item_key_not_found_exp = VALUE #( ( delnr = '1' uepos = '40' ) ).

    ASSIGN lr_item_key_not_found->* TO <lt_item_key_not_found_act>.

    lt_item_key_not_found_act = CORRESPONDING #( <lt_item_key_not_found_act> ).

    th_atp_coordinator=>assert_table_equals(
      EXPORTING
        it_act          = lt_item_key_not_found_act
        it_exp          = lt_item_key_not_found_exp
        iv_ignore_order = abap_true
    ).

    lt_item_key_not_exist_exp = VALUE #( ( delnr = '1' uepos = '60' ) ).

    ASSIGN lr_item_key_not_exist->* TO <lt_item_key_not_exist_act>.

    lt_item_key_not_exist_act = CORRESPONDING #( <lt_item_key_not_exist_act> ).

    th_atp_coordinator=>assert_table_equals(
      EXPORTING
        it_act          = lt_item_key_not_exist_act
        it_exp          = lt_item_key_not_exist_exp
        iv_ignore_order = abap_true
    ).

  ENDMETHOD.


  METHOD find_data_not_exist.
* Try to find data in buffer with focus on data that was added to negative buffer.
* Therefore the ET_DATA_NO_EXIST should include those entry from negative buffer that fullfill request.

* For now find queries are not supported. Reason is, that the query could ask for one or n fields which are not part of the key.
* Therrfore the result for the negative buffer would always be empty.

    cl_aunit_assert=>fail(
      EXPORTING
        msg    = 'Find is not supported for negative Buffer. Details see unit test description.'
        level  = if_aunit_constants=>severity-low
        quit   = if_aunit_constants=>quit-test
    ).

  ENDMETHOD.

  METHOD get_all_negative_buff.
* Return all entries of negative buffer if requested.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_vbak ).

    f_cut->set_negative( it_data = <lt_negative_buffer> ).

    CLEAR lt_vbak.
    ls_vbak-vbeln = '3'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    f_cut->set( it_data = lt_vbak ).


* Call method under test
    f_cut->get_all(
      IMPORTING
        et_data          = DATA(lr_data)
        et_negative_data = DATA(lr_negative_buffer)
    ).

* Check
    DATA lt_vbak_act TYPE TABLE OF vbak.
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.

    "check data
    ASSIGN lr_data->* TO <lt_data>.
    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '3' ).

    "check negative buffer
    UNASSIGN <lt_data>.
    ASSIGN lr_negative_buffer->* TO <lt_data>.
    cl_aunit_assert=>assert_equals( exp = 2  act = lines( <lt_data> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_data> ).

    SORT lt_vbak_act BY vbeln.
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '1' ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 2 ]-vbeln exp = '2' ).
  ENDMETHOD.

  METHOD get_data_and_respect_neg_buf.
* Return the data that is buffered, include those keys from negative buffer which match the key.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_vbak ).

    f_cut->set_negative( it_data = <lt_negative_buffer> ).
    CLEAR lt_vbak.

    "define request
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '3'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    f_cut->get_key_table_structure(
      IMPORTING
        er_key_table_structure = DATA(lr_key_table_structure)
    ).
    ASSIGN lr_key_table_structure->* TO FIELD-SYMBOL(<lt_buffer_key>).
    <lt_buffer_key> = CORRESPONDING #( lt_vbak ).


* Call method under test
    f_cut->get(
      EXPORTING
        it_key           = lr_key_table_structure
      IMPORTING
        et_data          = DATA(lr_data)
        et_key_not_found = DATA(lr_key_not_found)
        et_key_not_exist = DATA(lr_key_not_exist)
    ).

* Check
    DATA lt_vbak_act TYPE TABLE OF vbak.
    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.

    "check data
    ASSIGN lr_data->* TO <lt_result>.
    cl_aunit_assert=>assert_initial( act = <lt_result> ).

    "check key not found => this should be empty, since the was found, but in negative buffer.
    UNASSIGN <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_result>.
    lt_vbak_act = CORRESPONDING #( <lt_result> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '3' ).

    "check negative buffer
    UNASSIGN <lt_result>.
    ASSIGN lr_key_not_exist->* TO <lt_result>.
    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_result> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_result> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '2' ).

  ENDMETHOD.

  METHOD set_negative_buffer.
* Add an entry to the negative buffer.
    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_vbak ).

* Call method under test
    f_cut->set_negative( it_data = <lt_negative_buffer> ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_negative_buffer_full->* TO <lt_data>.

    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).

  ENDMETHOD.

  METHOD set_negative_buffer_multiple.
* Add mulitple entries to the negative buffer.
    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '1'. "duplicate on purpose
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '4'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_vbak ).

* Call method under test
    f_cut->set_negative( it_data = <lt_negative_buffer> ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_negative_buffer_full->* TO <lt_data>.

    cl_aunit_assert=>assert_equals( exp = 3  act = lines( <lt_data> ) ).

  ENDMETHOD.

  METHOD set_negative_buffer_sec_key.
* Add an entry to the negative buffer using a secondary key.
    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    data lt_item_data              TYPE if_atp_data_access=>tt_vbap_db_state_data.

    f_cut = cl_atp_buffer_manager=>get_vbap_db_state_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    lt_item_data = VALUE #( ( delnr = '1' delps = '20' uepos = '10' )
                            ( delnr = '1' delps = '30' uepos = '10' ) ).

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_item_data ).

* Call method under test
    f_cut->set_negative( it_data = <lt_negative_buffer> iv_key_name = 'MAIN_ITEM' ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_negative_buffer_full->* TO <lt_data>.

    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).

  ENDMETHOD.

  METHOD set_neg_buf_set_buf.
* Add an entry to the negative buffer which than is vanished as soon the "real" buffer is filled with that key.
* Example: When entering a brand new sales order it might occur that there is information not available in parameter or on database.
* this would lead to an entry in negative buffer. It might turn out in a second call, that user provided the information that is needed, which
* then of course needs to be added to buffer and is from now on available.


    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_vbak ).

    f_cut->set_negative( it_data = <lt_negative_buffer> ).

* Call method under test
    CLEAR lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    f_cut->set( it_data = lt_vbak ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_negative_buffer_full->* TO <lt_data>.
    DATA lt_vbak_act TYPE TABLE OF vbak.

    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '1' ).

    "check also the data to ensure consistency
    ASSIGN lo_buffer->mr_data->* TO <lt_data>.
    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '2' ).


  ENDMETHOD.



  METHOD set_buf_set_neg_buf.
* Add an entry to the buffer which than is vanished as soon the negative buffer is filled with that key.
* This is the corresponding other case of SET_NEG_BUF_SET_BUF


    DATA lo_buffer TYPE REF TO cl_atp_buffer.
    DATA lt_vbak TYPE TABLE OF vbak.
    DATA ls_vbak LIKE LINE OF lt_vbak.

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_neg_buff_table_structure)
    ).

* Test data
    ls_vbak-vbeln = '1'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.
    f_cut->set( it_data = lt_vbak ).

* Call method under test
    CLEAR lt_vbak.
    ls_vbak-vbeln = '2'.
    INSERT ls_vbak INTO TABLE lt_vbak.

    ASSIGN lr_neg_buff_table_structure->* TO FIELD-SYMBOL(<lt_negative_buffer>).
    <lt_negative_buffer> = CORRESPONDING #( lt_vbak ).

    f_cut->set_negative( it_data = <lt_negative_buffer> ).

* Check
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    lo_buffer ?= f_cut.
    ASSIGN lo_buffer->mr_negative_buffer_full->* TO <lt_data>.
    DATA lt_vbak_act TYPE TABLE OF vbak.

    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '2' ).

    "check also the data to ensure consistency
    ASSIGN lo_buffer->mr_data->* TO <lt_data>.
    cl_aunit_assert=>assert_equals( exp = 1  act = lines( <lt_data> ) ).
    lt_vbak_act = CORRESPONDING #( <lt_data> ).
    cl_aunit_assert=>assert_equals( act = lt_vbak_act[ 1 ]-vbeln exp = '1' ).


  ENDMETHOD.

  METHOD delete_data_key.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA lt_vbak_key TYPE TABLE OF vbak.

    DATA lr_result            TYPE REF TO data.
    DATA lr_result_not_found  TYPE REF TO data.
    DATA lr_key               TYPE REF TO data.

    FIELD-SYMBOLS <lt_result>           TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_result_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key>              TYPE any.

* Set test data
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' )
                            ( vbeln = '2' vkorg = 'OR' vtweg = '02' ) ).

    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).

* Get key structure to set request
    f_cut->get_key_table_structure(
      IMPORTING
        er_key_table_structure = lr_key ).

    lt_vbak_key = VALUE #( ( vbeln = '1' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_vbak_key ).

* Call method under test
    f_cut->delete( EXPORTING it_key = lr_key IMPORTING et_key_not_found = lr_result_not_found ).
    ASSIGN lr_result_not_found->* TO <lt_result_not_found>.

    f_cut->get_all( IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

* Check
    cl_aunit_assert=>assert_equals( exp  = 1 act  = lines( <lt_result> ) ).
    cl_aunit_assert=>assert_equals( exp  = 0 act  = lines( <lt_result_not_found> ) ).

    lt_vbak_key = VALUE #( ( vbeln = '2' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_vbak_key ).

* Call method under test
    f_cut->delete( EXPORTING it_key = lr_key IMPORTING et_key_not_found = lr_result_not_found ).
    ASSIGN lr_result_not_found->* TO <lt_result_not_found>.

    f_cut->get_all( IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

* Check
    cl_aunit_assert=>assert_equals( exp  = 0 act  = lines( <lt_result> ) ).
    cl_aunit_assert=>assert_equals( exp  = 0 act  = lines( <lt_result_not_found> ) ).

    lt_vbak_key = VALUE #( ( vbeln = '2' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_vbak_key ).

* Call method under test
    f_cut->delete( EXPORTING it_key = lr_key IMPORTING et_key_not_found = lr_result_not_found ).
    ASSIGN lr_result_not_found->* TO <lt_result_not_found>.

    f_cut->get_all( IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

* Check
    cl_aunit_assert=>assert_equals( exp  = 0 act  = lines( <lt_result> ) ).
    cl_aunit_assert=>assert_equals( exp  = 1 act  = lines( <lt_result_not_found> ) ).


  ENDMETHOD.

  METHOD delete_data_w_neg_buffer.
    DATA lt_vbak_data TYPE TABLE OF vbak.
    DATA lt_vbak_key TYPE TABLE OF vbak.
    DATA lt_vbak_act TYPE TABLE OF vbak.

    DATA lr_result            TYPE REF TO data.
    DATA lr_result_not_found  TYPE REF TO data.
    DATA lr_result_not_exist  TYPE REF TO data.
    DATA lr_key               TYPE REF TO data.

    FIELD-SYMBOLS <lt_result>           TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_result_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_result_not_exist> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key>              TYPE any.

* Set test data
    " set 2 lines into buffer
    lt_vbak_data = VALUE #( ( vbeln = '1' vkorg = 'TA' vtweg = '01' )
                            ( vbeln = '2' vkorg = 'OR' vtweg = '02' ) ).
    f_cut = cl_atp_buffer_manager=>get_vbak_buffer( ).
    f_cut->set( it_data = lt_vbak_data ).
    " set one line into negative buffer
    lt_vbak_data = VALUE #( ( vbeln = '3' ) ).
    f_cut->set_negative( it_data = lt_vbak_data ).

* Get key structure to set request
    f_cut->get_key_table_structure(
      IMPORTING
        er_key_table_structure = lr_key ).

    lt_vbak_key = VALUE #( ( vbeln = '1' )
                           ( vbeln = '3' )
                           ( vbeln = '4' ) ).

    ASSIGN lr_key->* TO <lt_key>.
    <lt_key> = CORRESPONDING #( lt_vbak_key ).

* Call method under test
    f_cut->delete( EXPORTING it_key = lr_key
                   IMPORTING et_key_not_found = lr_result_not_found
                             et_key_not_exist = lr_result_not_exist ).
    ASSIGN lr_result_not_found->* TO <lt_result_not_found>.
    ASSIGN lr_result_not_exist->* TO <lt_result_not_exist>.

    f_cut->get_all( IMPORTING et_data = lr_result ).
    ASSIGN lr_result->* TO <lt_result>.

* Check
    lt_vbak_act = CORRESPONDING #( <lt_result> ).
    cl_aunit_assert=>assert_equals( exp  = '2' act  = lt_vbak_act[ 1 ]-vbeln ).
    lt_vbak_act = CORRESPONDING #( <lt_result_not_found> ).
    cl_aunit_assert=>assert_equals( exp  = '4' act  = lt_vbak_act[ 1 ]-vbeln ).
    lt_vbak_act = CORRESPONDING #( <lt_result_not_exist> ).
    cl_aunit_assert=>assert_equals( exp  = '3' act  = lt_vbak_act[ 1 ]-vbeln ).

  ENDMETHOD.

  METHOD convert_table_key.

    DATA(lo_buffer) = cl_atp_buffer_manager=>get_atpmat_buffer( ).

    DATA(lt_atpmat) = VALUE tbl_atpmat_sorted(
      ( matnr = 'Mat-A' mtvfp = '01' )
      ( matnr = 'Mat-A' werks = '0001' mtvfp = '02' )
      ( matnr = 'Mat-A' werks = '0001' berid = '0002' mtvfp = '03' )
    ).

    DATA(lr_table_key_act) = lo_buffer->convert_to_buffer_key( REF #( lt_atpmat )  ).

    ASSIGN lr_table_key_act->* TO FIELD-SYMBOL(<lt_table_key_act>).
    DATA(lt_table_key_act) = CORRESPONDING tbl_atp_mat_key_sorted( <lt_table_key_act> ).

    DATA(lt_table_key_exp) = VALUE tbl_atp_mat_key_sorted(
      ( matnr = 'Mat-A' )
      ( matnr = 'Mat-A' werks = '0001' )
      ( matnr = 'Mat-A' werks = '0001' berid = '0002' )
    ).

    th_atp_table_assert=>equals(
      EXPORTING
        it_act                  = lt_table_key_act
        it_exp                  = lt_table_key_exp
    ).

  ENDMETHOD.

ENDCLASS.