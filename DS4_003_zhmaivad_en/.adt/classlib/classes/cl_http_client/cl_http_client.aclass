CLASS cl_http_client DEFINITION
  PUBLIC
  CREATE PRIVATE

  GLOBAL FRIENDS cl_apc_wsp_client
                 cl_apc_ws_client
                 cl_http_request
                 cl_http_response .

  PUBLIC SECTION.
*"* public components of class CL_HTTP_CLIENT
*"* do not include other source files here!!!
    TYPE-POOLS abap .

    INTERFACES if_http_client .

    ALIASES request
      FOR if_http_client~request .
    ALIASES response
      FOR if_http_client~response .
    ALIASES create_abs_url
      FOR if_http_client~create_abs_url .
    ALIASES create_rel_url
      FOR if_http_client~create_rel_url .
    ALIASES escape_url
      FOR if_http_client~escape_url .

    CONSTANTS schemetype_https TYPE i VALUE 2 ##NO_TEXT.
    CONSTANTS schemetype_http TYPE i VALUE 1 ##NO_TEXT.
    CONSTANTS co_redirect_trial TYPE i VALUE 5 ##NO_TEXT.
    CONSTANTS co_authenticate_trial TYPE i VALUE 3 ##NO_TEXT.
    CLASS-DATA c_compression_supported TYPE i READ-ONLY .
    CONSTANTS http_no_open_connection_error TYPE sysubrc VALUE 1002 ##NO_TEXT.
    CONSTANTS http_processing_failed_error TYPE sysubrc VALUE 1003 ##NO_TEXT.
    CONSTANTS http_invalid_state_error TYPE sysubrc VALUE 1001 ##NO_TEXT.
    DATA m_path_prefix TYPE string READ-ONLY .
    DATA m_use_scc TYPE sap_bool READ-ONLY VALUE abap_false ##NO_TEXT.

    CLASS-METHODS get_client_kernel_version
      RETURNING
        VALUE(version) TYPE i .
    CLASS-METHODS class_constructor .
    CLASS-METHODS _append_xstring_to_string
      IMPORTING
        !source TYPE xstring
      CHANGING
        !dest   TYPE string .
    CLASS-METHODS _append_string_to_xstring
      IMPORTING
        !source TYPE string
      CHANGING
        !dest   TYPE xstring .
    METHODS constructor
      EXCEPTIONS
        create_message_failed .
    CLASS-METHODS create_by_cloud_destination
      IMPORTING
        !i_name                  TYPE char38
        !i_comm_arr_uuid         TYPE uuid OPTIONAL
        !i_service_instance_name TYPE svc_instance_name OPTIONAL
      RETURNING
        VALUE(client)            TYPE REF TO if_http_client
      EXCEPTIONS
        argument_not_found
        destination_not_found
        destination_no_authority
        plugin_not_active
        internal_error .
    CLASS-METHODS create_by_destination
      IMPORTING
        !destination TYPE c
      EXPORTING
        !client      TYPE REF TO if_http_client
      EXCEPTIONS
        argument_not_found
        destination_not_found
        destination_no_authority
        plugin_not_active
        internal_error
        oa2c_set_token_error
        oa2c_missing_authorization
        oa2c_invalid_config
        oa2c_invalid_parameters
        oa2c_invalid_scope
        oa2c_invalid_grant .
    CLASS-METHODS create_internal
      IMPORTING
        !virtual_host TYPE i DEFAULT ihttp_vhost_default
      EXPORTING
        !client       TYPE REF TO if_http_client
      EXCEPTIONS
        plugin_not_active
        internal_error .
    CLASS-METHODS create_by_url
      IMPORTING
        !url                    TYPE string
        !proxy_host             TYPE string OPTIONAL
        !proxy_service          TYPE string OPTIONAL
        !ssl_id                 TYPE ssfapplssl OPTIONAL
        !sap_username           TYPE syuname OPTIONAL
        !sap_client             TYPE symandt OPTIONAL
        !proxy_user             TYPE string OPTIONAL
        !proxy_passwd           TYPE string OPTIONAL
        !do_not_use_client_cert TYPE abap_bool DEFAULT abap_false
        !use_scc                TYPE abap_bool DEFAULT abap_false
        !scc_location_id        TYPE string OPTIONAL
        !oauth_profile          TYPE oa2c_profile OPTIONAL
        !oauth_config           TYPE oa2c_configuration OPTIONAL
      EXPORTING
        !client                 TYPE REF TO if_http_client
      EXCEPTIONS
        argument_not_found
        plugin_not_active
        internal_error
        pse_not_found
        pse_not_distrib
        pse_errors
        oa2c_set_token_error
        oa2c_missing_authorization
        oa2c_invalid_config
        oa2c_invalid_parameters
        oa2c_invalid_scope
        oa2c_invalid_grant .
    CLASS-METHODS create
      IMPORTING
        !host                   TYPE string
        VALUE(service)          TYPE string OPTIONAL
        !proxy_host             TYPE string OPTIONAL
        !proxy_service          TYPE string OPTIONAL
        !scheme                 TYPE i DEFAULT schemetype_http
        !ssl_id                 TYPE ssfapplssl OPTIONAL
        !sap_username           TYPE syuname OPTIONAL
        !sap_client             TYPE symandt OPTIONAL
        !do_not_use_client_cert TYPE abap_bool DEFAULT abap_false
      EXPORTING
        !client                 TYPE REF TO if_http_client
      EXCEPTIONS
        argument_not_found
        plugin_not_active
        internal_error .
    METHODS destructor .
    CLASS-METHODS get_last_error
      EXPORTING
        !code    TYPE sysubrc
        !message TYPE string .
    METHODS send_and_close
      EXCEPTIONS
        http_communication_failure
        http_invalid_state
        http_processing_failed
        http_is_not_supported .
    CLASS-METHODS set_oauth_token
      IMPORTING
        !i_oauth_profile        TYPE oa2c_profile
        !i_oauth_config         TYPE oa2c_configuration OPTIONAL
        !io_http_client         TYPE REF TO if_http_client
        !i_param_kind           TYPE string OPTIONAL
        !i_force_oauth2_request TYPE abap_bool DEFAULT abap_false
      EXCEPTIONS
        oa2c_set_token_error
        oa2c_missing_authorization
        oa2c_invalid_config
        oa2c_invalid_parameters
        oa2c_invalid_scope
        oa2c_invalid_grant .
    METHODS set_oauth2c_info
      IMPORTING
        !io_oa2c_client     TYPE REF TO cl_oa2c_client
      RETURNING
        VALUE(r_returncode) TYPE i .
    METHODS set_oauth2c_info_ext
      IMPORTING
        !io_oa2c_client     TYPE REF TO cl_oa2c_client
      RETURNING
        VALUE(r_returncode) TYPE i .
  PROTECTED SECTION.
*"* protected components of class CL_HTTP_CLIENT
*"* do not include other source files here!!!

    METHODS get_kernel_statistic_info
      EXPORTING
        !e_protocol TYPE i
        !e_host     TYPE string
        !e_port     TYPE string
        !e_path     TYPE string .
private section.

*"* private components of class CL_HTTP_CLIENT
*"* do not include other source files here!!!
  aliases CO_COMPRESS_BASED_ON_MIME_TYPE
    for IF_HTTP_CLIENT~CO_COMPRESS_BASED_ON_MIME_TYPE .
  aliases CO_COMPRESS_IN_ALL_CASES
    for IF_HTTP_CLIENT~CO_COMPRESS_IN_ALL_CASES .
  aliases CO_COMPRESS_NONE
    for IF_HTTP_CLIENT~CO_COMPRESS_NONE .
  aliases CO_DISABLED
    for IF_HTTP_CLIENT~CO_DISABLED .
  aliases CO_ENABLED
    for IF_HTTP_CLIENT~CO_ENABLED .
  aliases CO_EVENT
    for IF_HTTP_CLIENT~CO_EVENT .
  aliases CO_PROMPT
    for IF_HTTP_CLIENT~CO_PROMPT .
  aliases CO_TIMEOUT_DEFAULT
    for IF_HTTP_CLIENT~CO_TIMEOUT_DEFAULT .
  aliases CO_TIMEOUT_INFINITE
    for IF_HTTP_CLIENT~CO_TIMEOUT_INFINITE .
  aliases PROPERTYTYPE_ACCEPT_COMPRESS
    for IF_HTTP_CLIENT~PROPERTYTYPE_ACCEPT_COMPRESS .
  aliases PROPERTYTYPE_ACCEPT_COOKIE
    for IF_HTTP_CLIENT~PROPERTYTYPE_ACCEPT_COOKIE .
  aliases PROPERTYTYPE_APPLY_SPROXY
    for IF_HTTP_CLIENT~PROPERTYTYPE_APPLY_SPROXY .
  aliases PROPERTYTYPE_LOGON_POPUP
    for IF_HTTP_CLIENT~PROPERTYTYPE_LOGON_POPUP .
  aliases PROPERTYTYPE_REDIRECT
    for IF_HTTP_CLIENT~PROPERTYTYPE_REDIRECT .
  aliases PROPERTYTYPE_SEND_SAP_PASSPORT
    for IF_HTTP_CLIENT~PROPERTYTYPE_SEND_SAP_PASSPORT .
  aliases VERSION
    for IF_HTTP_CLIENT~VERSION .
  aliases APPEND_FIELD_URL
    for IF_HTTP_CLIENT~APPEND_FIELD_URL .
  aliases AUTHENTICATE
    for IF_HTTP_CLIENT~AUTHENTICATE .
  aliases CLOSE
    for IF_HTTP_CLIENT~CLOSE .
  aliases ESCAPE_HTML
    for IF_HTTP_CLIENT~ESCAPE_HTML .
  aliases LISTEN
    for IF_HTTP_CLIENT~LISTEN .
  aliases RECEIVE
    for IF_HTTP_CLIENT~RECEIVE .
  aliases REFRESH_COOKIE
    for IF_HTTP_CLIENT~REFRESH_COOKIE .
  aliases REFRESH_REQUEST
    for IF_HTTP_CLIENT~REFRESH_REQUEST .
  aliases REFRESH_RESPONSE
    for IF_HTTP_CLIENT~REFRESH_RESPONSE .
  aliases SEND
    for IF_HTTP_CLIENT~SEND .
  aliases SEND_SAP_LOGON_TICKET
    for IF_HTTP_CLIENT~SEND_SAP_LOGON_TICKET .
  aliases SET_COMPRESSION
    for IF_HTTP_CLIENT~SET_COMPRESSION .
  aliases UNESCAPE_URL
    for IF_HTTP_CLIENT~UNESCAPE_URL .
  aliases EVENTKIND_HANDLE_COOKIE
    for IF_HTTP_CLIENT~EVENTKIND_HANDLE_COOKIE .

  data M_SSO_TICKET type RFCTSYSOPT .
  class-data ECODE_DESTINATION_NOT_FOUND type I value 1001 ##NO_TEXT.
  class-data ECODE_NAME_TOO_LONG type I value 1001 ##NO_TEXT.
  data M_SCHEME type I .
  data M_TARGET_SCHEME type I .
  data M_PATCH type I .
  data M_LAST_RESPONSE_CODE type I .
  data M_REDIRECT_TRIAL type I .
  data M_AUTH_TRIAL type I .
  class-data RETRYTYPE_NONE type I value 0 ##NO_TEXT.
  class-data RETRYTYPE_REDIRECT type I value 2 ##NO_TEXT.
  class-data RETRYTYPE_LOGON type I value 1 ##NO_TEXT.
  class-data STATETYPE_RECEIVE type I value 2 ##NO_TEXT.
  class-data STATETYPE_CLOSE type I value 3 ##NO_TEXT.
  class-data STATETYPE_INITIAL type I value -1 ##NO_TEXT.
  class-data STATETYPE_ERROR type I value 1 ##NO_TEXT.
  class-data STATETYPE_SEND type I value 4 ##NO_TEXT.
  data M_SESSION type STRING .
  data M_PASSPORT type STRING .
  class-data C_SAP_R3AUTH type STRING .
  class-data C_SAPGUI_IS_ON type I .
  data M_C_CCLIENT type %_C_POINTER .
  data M_PASSWORD type STRING .
  data M_IS_PASSWORD_ENCRYPTED type ABAP_BOOL value ABAP_UNDEFINED ##NO_TEXT.
  data M_PROXY_PASSWORD type STRING .
  data M_IS_PROXY_PASSWORD_ENCRYPTED type ABAP_BOOL value ABAP_UNDEFINED ##NO_TEXT.
  data M_PROXY_USERNAME type STRING .
  data M_SSLAPPLIC type SSFAPPLSSL .
  data M_X509FILENAME type LOCALFILE .
  data M_USERNAME type STRING .
  data M_PROXY_SERVICE type STRING .
  data M_TRUSTED type STRING .
  data M_SERVICE type STRING .
  data M_TARGET_SERVICE type STRING .
  data M_IS_SECURE type I .
  data M_TARGET_IS_SECURE type I .
  data M_CLIENT type SYMANDT .
  data M_LANGUAGE type SYLANGU .
  data M_NAME type STRING .
  data M_ECODE type SYSUBRC .
  data M_EMESSAGE type STRING .
  data M_PROXY_HOST type STRING .
  data M_HOST type STRING .
  data M_TARGET_HOST type STRING .
  class-data M_CONNECTION type SYSUUID_C .
  class-data HTTP_CLIENT_INSTANCES type IHTTP_CLIENT_INSTANCES .
  data M_RETRY type I .
  data M_STATE type I .
  data M_DOCUMENT type XSTRING .
  data M_CREATE_INTERNAL type I .
  class-data C_SCHEMETYPE_HTTPS_ACTIVE type I .
  class-data C_SCHEMETYPE_HTTP_ACTIVE type I .
  data M_CREATETYPE type I .
  constants CREATETYPE_CREATE type I value 0 ##NO_TEXT.
  constants CREATETYPE_INTERNAL type I value 1 ##NO_TEXT.
  constants CREATETYPE_DESTINATION_R3 type I value 2 ##NO_TEXT.
  constants CREATETYPE_DESTINATION_EXT type I value 3 ##NO_TEXT.
  constants CREATETYPE_URL type I value 4 ##NO_TEXT.
  data M_SUM_STAT type PFHTPDREC .
  data M_SINGLE_STAT type PFHTPCREC .
  data M_ALREADY_PROCESSED type I .
  data M_PROXY_CONFIGURATION type PPROXY_C .
  data M_IS_SPECIAL_PROXY_CONFIGURED type ABAP_BOOL value ABAP_UNDEFINED ##NO_TEXT.
  class-data C_CLIENT_KERNEL_VERSION type I .
  data M_TRACE type I .
  data M_LOGON_METHOD type C .
  data M_SAP_USERNAME type SYUNAME .
  data M_SAP_CLIENT type SYMANDT .
  class-data C_LAST_MESSAGE_ID type SYSUUID_C .
  class-data C_ROOT_MESSAGE_ID type SYSUUID_C .
  class-data C_SCOPE_MESSAGE_ID type SYSUUID_C .
  class-data C_SCOPE_MESSAGE_NR type SYINDEX .
  data M_PARENT_MESSAGE_ID type SYSUUID_C .
  data M_OBJECT_ID type SYSUUID_C .
  data M_COUNTER type I .
  data M_ICFRECORDER type ICFRECORDER .
  data M_ENABLE_RECORDING type I .
  class-data C_STATISTIC_STATE type I .
  class-data C_ECODE type SYSUBRC .
  class-data C_EMESSAGE type STRING .
  data M_VIRTUAL_HOST type I .
  class-data C_ACCEPT_CLIENT_RECORDER_LEVEL type I .
  class-data C_ACCEPT_CLIENT_PROFILE_LEVEL type I .
  class-data C_TRACE_LEVEL type I .
  data M_TIMEOUT type I .
  data M_DESTINATION_TIMEOUT type I .
  data M_COMPRESS type RFCDISPLAY-RFCTYPE .
  data M_COMPRESS_DEST type RFCDISPLAY-RFCTYPE .
  data M_TIMER type ref to IF_ABAP_RUNTIME .
  data M_ICFRECORDER_FIELDS type IHTTP_RECORDER_FIELDS .
  data M_REQUEST_BODY_LENGTH type I .
  data M_REQUEST_HEADER_LENGTH type I .
  data M_PATH type STRING .
  data M_QUERY type STRING .
  data M_SERVER_PROTOCOL type STRING .
  data M_SEND_AND_CLOSE type C .
  data M_DESTINATION_NAME type PFICF_DESTINATION_NAME .
  data M_EPP_SYSTEM_ENTITY type ref to IF_EPP_SYSTEM_ENTITY .
  data M_EPP_MODIFICATION_COUNTER type I .
  data M_ASSERTION_CLIENT type SYMANDT .
  data M_ASSERTION_SYSTEM_ID type SYSYSID .
  data M_DO_NO_SHOW_CLIENT_CERT type C .
  data M_EPP_ROOT_CONTEXT_ID type SYSUUID_C .
  data M_CLIENT_ID type SYSUUID_C .
  data M_SCC_LOCATION_ID type STRING .
  data M_OAUTH_INFO_IS_SET type ABAP_BOOLEAN .
  data M_OAUTH_STATE type I value 0 ##NO_TEXT.
  data M_OAUTH_PROFILE type OA2C_PROFILE .
  data M_OAUTH_CONFIG type OA2C_CONFIGURATION .
  class-data MV_VALID_URL_REGEX type ref to CL_ABAP_REGEX .
  data MV_HOST_ACL type ref to CL_HTTP_CLIENT_ACL .
  data M_INTTICKET_MODE type I .
  data M_TRUST_SERVERSYSID type STRING .
  data M_TRUST_SERVERINSTNR type STRING .

  class-methods REQUIRESDESTINATIONSERVICE
    importing
      !DESTINATION type C
    returning
      value(REQUIRES) type ABAP_BOOL .
  class-methods CREATEFROMDESTINATIONSERVICE
    importing
      !DESTINATION type C
    returning
      value(CLIENT) type ref to IF_HTTP_CLIENT
    exceptions
      ARGUMENT_NOT_FOUND
      DESTINATION_NOT_FOUND
      DESTINATION_NO_AUTHORITY
      PLUGIN_NOT_ACTIVE
      INTERNAL_ERROR .
  class-methods DO_GARBAGE_COLLECTION .
  methods CREATE_R3_TICKET
    exceptions
      INTERNAL_ERROR .
  methods AUTHENTICATION
    importing
      !PROXY_AUTHENTICATION type C default ' ' .
  methods SEND_COOKIE
    exceptions
      HTTP_PROCESSING_FAILED .
  methods RECEIVE_COOKIE
    exceptions
      HTTP_PROCESSING_FAILED .
  methods STATISTIC
    importing
      !CLIENT type ref to IF_HTTP_CLIENT
      !START type I default 0 .
  methods RECORDER
    importing
      !EXPIRATION_DAY type LIFEDAY optional
      !EXPIRATION_TIME type SYUZEIT optional
      !ICFATTRIB_ENTRY type ICFATTRIB optional
    changing
      !COMPONENT type I default 0
    exceptions
      DISABLE_RECORDING .
  methods CLOSE_CONNECTION
    exceptions
      HTTP_INVALID_STATE .
  methods GET_EXTENDED_PASSPORT
    exporting
      value(PASSPORT) type STRING
    exceptions
      EPP_ERROR .
  methods CHECK_CALL_STACK
    returning
      value(R_SUCCESSFUL) type ABAP_BOOL .
  methods SET_APC_DET_CLIENT_EPP_ROOT_ID
    importing
      !I_ROOT_CONTEXT_ID type SYSUUID_C .
ENDCLASS.



CLASS CL_HTTP_CLIENT IMPLEMENTATION.


  METHOD if_http_client~get_last_error.
    DATA: lv_message_number TYPE msgnr.
    code    = m_ecode.
    message = m_emessage.

* should additional error information be provided ?
    IF message_class IS SUPPLIED OR
       message_number IS SUPPLIED.
      lv_message_number = m_ecode.

      MESSAGE ID 'SCLNT_HTTP' TYPE 'S' NUMBER lv_message_number INTO DATA(lv_string).

      IF lv_string(13) = 'S:SCLNT_HTTP:' OR lv_string IS INITIAL.  " In this case T100-message does not exist
        CLEAR: message_class, message_number.
      ELSE.
*** Set MESSAGE_CLASS
        message_class = 'SCLNT_HTTP'.

*** Currently CODE and MESSAGE NUMBER are equal. If this changes the
*** respective mapping CODE <-> MESSAGE NUMBER has to bee done here

*** Set MESSAGE_NUMBER
        message_number = m_ecode.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD if_http_client~is_scc_in_use.
    is_scc_in_use = m_use_scc.
  ENDMETHOD.


  METHOD if_http_client~listen.
    DATA: http_client_instance TYPE ihttp_client_instance.  "#EC NEEDED
    DATA: client_obj           TYPE REF TO cl_http_client.

* -- exists any open connection
    READ TABLE http_client_instances INTO http_client_instance
                                     WITH KEY state = statetype_send.
    IF sy-subrc <> 0.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 863 RAISING http_no_open_connection.
*      RAISE http_no_open_connection.
    ENDIF.

    client_obj ?= http_client_instance-client->get( ).
* which kind of client object exist (for local or remote communication)
    IF client_obj->m_create_internal IS INITIAL.
      DATA: conn_name TYPE string.

      SYSTEM-CALL RFC_ID 'HTTP' RFC_VALUE 'Select'.         "#EC *
      SYSTEM-CALL RFC_ID 'Name' RFC_VALUE conn_name.        "#EC *
      SYSTEM-CALL RFC_END.                           "#EC CI_SYSTEMCALL
      c_ecode = sy-subrc.

* -- selecting/parking the appropriate error text for application
      IF c_ecode <> 0.
*        CALL FUNCTION 'HTTP_GET_ERRORCODE'
*          EXPORTING
*            errorcode = c_ecode
*          IMPORTING
*            errortext = c_emessage
*          EXCEPTIONS
*            OTHERS    = 0.
        CALL METHOD error_codes=>get_error_text
          EXPORTING
            number = c_ecode
          IMPORTING
            text   = c_emessage.
      ENDIF.

* -- retrieve the client object for the associated handle
      READ TABLE http_client_instances INTO http_client_instance
                                           WITH KEY name = conn_name.
      IF sy-subrc <> 0.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*        RAISE http_communication_failure.
      ENDIF.
      client ?= http_client_instance-client->get( ).
    ELSE.
      client ?= http_client_instance-client->get( ).
    ENDIF.
  ENDMETHOD.


  METHOD if_http_client~receive.
    DATA: connection TYPE ioprop.
    DATA: http_client_instance TYPE ihttp_client_instance.
    DATA: auth TYPE string.
    DATA: reason    TYPE string,                            "#EC NEEDED
          challenge TYPE string,
          dummy     TYPE string,                            "#EC NEEDED
          ok        TYPE c,
          len       TYPE i.
    DATA: subrc         TYPE sysubrc.
    DATA: icfrec_field  TYPE ihttp_recorder_field.
    DATA: detail_encoded TYPE string.
    DATA: detail TYPE string.
    DATA: li_client TYPE REF TO if_http_client.

    IF m_state <> statetype_send.
      m_ecode = http_invalid_state_error.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = m_ecode
        IMPORTING
          text   = m_emessage.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*      RAISE http_invalid_state.
    ENDIF.

    pf_m_open c_statistic_state 'HTTP Receive'.             "#EC *

* -- set my connection name for receiving http data in instantiate step
    connection-name = m_name.
    m_state         = statetype_receive.
    m_retry         = retrytype_none.

    IF m_create_internal IS INITIAL. "m_document is initial.
      DATA: _response TYPE REF TO cl_http_entity,
            c_msg     TYPE %_c_pointer.
      pf_m_open c_statistic_state 'HTTP Read System Call'.  "#EC *

      CALL FUNCTION 'HTTP_READ_SC'
        IMPORTING
          c_msg      = c_msg
        CHANGING
          connection = connection.

      pf_m_close c_statistic_state 'HTTP Read System Call'. "#EC *

      _response ?= response.
* -- set new message id.
      _response->set_c_msg( c_msg ).

    ELSE. " localhost
      CALL METHOD response->from_xstring
        EXPORTING
          data = m_document.
    ENDIF.

    IF connection-ecode <> 0.
      m_ecode    = connection-ecode.
*      CALL FUNCTION 'HTTP_GET_ERRORCODE'
*        EXPORTING
*          errorcode = connection-ecode
*        IMPORTING
*          errortext = connection-emessage
*        EXCEPTIONS
*          OTHERS    = 0.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = connection-ecode
        IMPORTING
          text   = connection-emessage.
      m_emessage = connection-emessage.
      m_state    = statetype_error.
    ENDIF.

* update object state in instance table
    READ TABLE http_client_instances INTO http_client_instance
                                          WITH KEY name = m_name.

    IF sy-subrc = 0.
      http_client_instance-state = m_state.
      MODIFY TABLE http_client_instances FROM http_client_instance.
    ENDIF.

    IF connection-ecode <> 0.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*      RAISE http_communication_failure.
    ENDIF.
*
* ICFRECORDER processing
*
    IF NOT m_icfrecorder IS INITIAL.
      DATA: sap_recorder TYPE string.

* -- user-agent
      m_icfrecorder-partner_type =
             response->get_header_field( 'server' ).        "#EC NOTEXT

*  -- accepting of caller cookie for next request
*  -- do not modify recorder entry (m_icfrecorder)
      sap_recorder =
         response->get_header_field( ihttp_c_sap_recorder_sid ).
      IF sap_recorder IS INITIAL.
        response->get_cookie( EXPORTING name  = ihttp_c_sap_recorder_sid
                              IMPORTING value = sap_recorder ).
      ENDIF.

      IF NOT sap_recorder IS INITIAL.
        DATA: caller_system TYPE sysysid.                   "#EC NEEDED
        DATA: remote_guid   TYPE icfrecoder_uuid.           "#EC NEEDED
        DATA: sap_recorder_entries TYPE TABLE OF string.
        SPLIT sap_recorder AT ',' INTO TABLE sap_recorder_entries.
        LOOP AT sap_recorder_entries INTO sap_recorder.
          IF sap_recorder IS NOT INITIAL.
            IF sap_recorder(2) = 'c='.
* -- ,c=<sysid>-<caller_id>-<message_id>-<message_nr>
              sap_recorder = sap_recorder+2(*).
              SPLIT sap_recorder AT '%-' INTO
                caller_system c_scope_message_id remote_guid dummy. "c_last_message_id dummy.
              c_scope_message_nr = dummy.
            ELSEIF sap_recorder(2) = 'o='.
* -- ,o=<owner_server>-<owner_client>-<owner_user>
              sap_recorder = sap_recorder+2(*).
              SPLIT sap_recorder AT '%-' INTO
                m_icfrecorder-owner_server
                m_icfrecorder-owner_client
                m_icfrecorder-owner_user
                dummy.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.

      IF m_enable_recording >= ihttp_record_cresponse_status.
        DATA: code          TYPE i,
              ccode(8)      TYPE c,
              index         TYPE i,
              body_length   TYPE i,
              header_length TYPE i.

*   should response message be serialized in ICFRECORDER
        IF m_enable_recording >= ihttp_record_cresponse.
          DATA: l_c_sso TYPE ihttpcki.

          response->get_cookie( EXPORTING name  = 'MYSAPSSO2'
                                          path  = '/'
                                IMPORTING value  = l_c_sso-value
                                          domain = l_c_sso-xdomain
                                          expires = l_c_sso-expires
                                          secure  = l_c_sso-secure ).
          IF l_c_sso IS NOT INITIAL.
*  -- delete security relevant fields
            response->delete_cookie_secure(
                                      name = 'MYSAPSSO2' ). "#EC NOTEXT
          ENDIF.

          m_icfrecorder-response = response->to_xstring( ).

          IF l_c_sso IS NOT INITIAL.
*  -- set security relevant fields
            response->set_cookie( EXPORTING name  = 'MYSAPSSO2'
                                            path  = '/'
                                            value  = l_c_sso-value
                                            domain = l_c_sso-xdomain
                                            expires = l_c_sso-expires
                                            secure  = l_c_sso-secure ).
          ENDIF.
        ENDIF.

        CLEAR icfrec_field.
        index = 0.
* -- find next index
        LOOP AT m_icfrecorder_fields TRANSPORTING NO FIELDS
                WHERE range = ihttp_recorder_field_range_col.
          ADD 1 TO index.
        ENDLOOP.
        ADD 1 TO index.

        icfrec_field-range = ihttp_recorder_field_range_col.
        IF m_request_header_length > 0.
          icfrec_field-index = index.
          icfrec_field-name  = 'REQUEST_HEADER_LENGTH'.
          icfrec_field-value = m_request_header_length.
          APPEND icfrec_field TO m_icfrecorder_fields.
          ADD 1 TO index.
        ENDIF.

        IF m_request_body_length > 0.
          icfrec_field-range = ihttp_recorder_field_range_col.
          icfrec_field-index = index.
          icfrec_field-name  = 'REQUEST_BODY_LENGTH'.
          icfrec_field-value = m_request_body_length.
          APPEND icfrec_field TO m_icfrecorder_fields.
          ADD 1 TO index.
        ENDIF.

        icfrec_field-index = index.
        icfrec_field-name  = 'DATABASE_REQUEST_LENGTH'.
        icfrec_field-value = xstrlen( m_icfrecorder-request ).
        APPEND icfrec_field TO m_icfrecorder_fields.
        ADD 1 TO index.

        icfrec_field-index = index.
        CALL METHOD response->get_serialized_message_length
          IMPORTING
            body_length   = body_length
            header_length = header_length.

        IF header_length > 0.
          icfrec_field-name  = 'RESPONSE_HEADER_LENGTH'.
          icfrec_field-value = header_length.
          APPEND icfrec_field TO m_icfrecorder_fields.
          ADD 1 TO index.
        ENDIF.

        IF body_length > 0.
          icfrec_field-index = index.
          icfrec_field-name  = 'RESPONSE_BODY_LENGTH'.
          icfrec_field-value = body_length.
          APPEND icfrec_field TO m_icfrecorder_fields.
          ADD 1 TO index.
        ENDIF.

        IF m_icfrecorder-response IS NOT INITIAL.
          icfrec_field-index = index.
          icfrec_field-name  = 'DATABASE_RESPONSE_LENGTH'.
          icfrec_field-value = xstrlen( m_icfrecorder-response ).
          APPEND icfrec_field TO m_icfrecorder_fields.
          ADD 1 TO index.
        ENDIF.

        CALL FUNCTION 'ICF_RECORDER_ATTRIBUTES'
          EXPORTING
            action                     = ihttp_icfservice_action_pack
*           from_entries               = ihttp_attributes
            icfrecorder_fields_imp     = m_icfrecorder_fields
*        IMPORTING
*           TO_ENTRIES                 =
          CHANGING
            icfrecord_attributes       = m_icfrecorder-attributes
          EXCEPTIONS
            icf_action_not_supported   = 1
            icf_no_authority           = 2
            icf_incomplete_information = 3
            icf_invalid_attributes     = 4
            OTHERS                     = 5.           "#EC *

*   set ~status_line
        CALL METHOD response->get_status
          IMPORTING
            code   = code
            reason = reason.
        ccode = code.
        CONDENSE ccode.
        m_icfrecorder-response_status = ccode.

        CONCATENATE m_icfrecorder-response_status reason INTO
                  m_icfrecorder-response_status SEPARATED BY space.

        GET TIME STAMP FIELD m_icfrecorder-response_tstamp.

        MODIFY icfrecorder FROM m_icfrecorder.
*
* avoid db commit in transactional context, e. g. update task, bgRFC context,
* and transactional instance area of shared objects
*
        cl_icf_recorder=>process_db_commit( ).
*     call function 'DB_COMMIT'.
      ENDIF.
    ENDIF.

*
* reaction of received cookies
*
    pf_m_open c_statistic_state 'HTTP Receive Cookie'.      "#EC *

    CALL METHOD receive_cookie
      EXCEPTIONS
        http_processing_failed = 1.
    subrc = sy-subrc.
    pf_m_close c_statistic_state 'HTTP Receive Cookie'.     "#EC *

* -- cookie handling has failed
    IF subrc <> 0.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 843 RAISING http_processing_failed.
*    RAISE http_processing_failed.
    ENDIF.

*
* requires response user authentication -> create authentication popup
*
    CALL METHOD response->get_status
      IMPORTING
        code   = m_last_response_code
        reason = reason.

    IF c_sapgui_is_on            = 1 AND
       propertytype_logon_popup  = co_enabled AND
       ( m_last_response_code = 401  OR m_last_response_code = 407 ) AND
       m_auth_trial < co_authenticate_trial.

      DATA: sap                  TYPE string,
            r3                   TYPE c,
            l_username           TYPE string,
            l_password           TYPE string,
            l_client             TYPE symandt,
            l_language           TYPE sylangu,
            proxy_authentication TYPE c.
* -- update retry type
      m_retry  = retrytype_logon.

      m_auth_trial =  m_auth_trial + 1.

* remove internal entries for authentication
* in case of when a authentication has failed before
      CASE m_last_response_code.
        WHEN 401.
          proxy_authentication = abap_false.
          CLEAR: m_username, m_password.
        WHEN 407.
          proxy_authentication = abap_true.
          CLEAR: m_proxy_username, m_proxy_password.
      ENDCASE.

      sap       =
        response->get_header_field( 'SAP-System' ).         "#EC NOTEXT
      IF sap IS INITIAL.
        sap       =
          response->get_header_field( 'server' ).           "#EC NOTEXT
        IF sap NS 'SAP'.
          CLEAR sap.
        ENDIF.
      ENDIF.

      challenge =
        response->get_header_field( 'WWW-Authenticate' ).   "#EC NOTEXT
      IF NOT challenge IS INITIAL.
        SPLIT challenge AT 'Basic realm='                   "#EC NOTEXT
            INTO dummy challenge.
        len = strlen( challenge ).
        len = len - 1.
        IF len > 2 AND challenge(1) = '"' AND challenge+len(1) = '"'.
          len = len - 1.
          challenge = challenge+1(len).
        ENDIF.
      ELSEIF m_last_response_code = 407.
        challenge =
      response->get_header_field( 'Proxy-Authenticate' ).   "#EC NOTEXT
        IF challenge IS INITIAL.
          challenge = 'Proxy'.                              "#EC NOTEXT
        ELSE.
          SPLIT challenge AT 'Basic realm='                 "#EC NOTEXT
                   INTO dummy challenge.
          len = strlen( challenge ).
          len = len - 1.
          IF len > 2 AND challenge(1) = '"' AND challenge+len(1) = '"'.
            len = len - 1.
            challenge = challenge+1(len).
          ENDIF.
        ENDIF.
      ENDIF.
*
* ICFRECORDER processing
*
      IF NOT m_icfrecorder IS INITIAL.
        CLEAR: icfrec_field.
* -- find next index
        index = 0.
        LOOP AT m_icfrecorder_fields TRANSPORTING NO FIELDS
                WHERE range = ihttp_recorder_field_range_clo.
          ADD 1 TO index.
        ENDLOOP.
        ADD 1 TO index.

        icfrec_field-range = ihttp_recorder_field_range_clo.
        icfrec_field-index = index.
        icfrec_field-name  = m_last_response_code.
        CONCATENATE icfrec_field-name reason
           INTO icfrec_field-name SEPARATED BY space.
*   'PROPERTYTYPE_LOGON_POPUP'
        icfrec_field-value = challenge.
        APPEND icfrec_field TO m_icfrecorder_fields.
        CALL FUNCTION 'ICF_RECORDER_ATTRIBUTES'
          EXPORTING
            action                     = ihttp_icfservice_action_pack
*           from_entries               = ihttp_attributes
            icfrecorder_fields_imp     = m_icfrecorder_fields
*      IMPORTING
*           TO_ENTRIES                 =
          CHANGING
            icfrecord_attributes       = m_icfrecorder-attributes
          EXCEPTIONS
            icf_action_not_supported   = 1
            icf_no_authority           = 2
            icf_incomplete_information = 3
            icf_invalid_attributes     = 4
            OTHERS                     = 5.             "#EC *
        MODIFY icfrecorder FROM m_icfrecorder.
*
* avoid db commit in transactional context, e. g. update task, bgRFC context,
* and transactional instance area of shared objects
*
        cl_icf_recorder=>process_db_commit( ).
*     call function 'DB_COMMIT'.
      ENDIF.

      IF NOT sap IS INITIAL.
        l_client  =
           response->get_header_field( 'SAP-Client' ).      "#EC NOTEXT
        m_client = l_client.
        IF m_client IS INITIAL.
          m_client = sy-mandt.
        ENDIF.
      ENDIF.
      CLEAR ok.
      IF sap IS INITIAL.
        CLEAR r3.
      ELSEIF ( sap NS 'J2EE' ).
        r3 = 'X'.
      ENDIF.
*
* end of single record and sum statistics
*
      statistic( client = me ).

      pf_m_open c_statistic_state 'HTTP Gui Logon'.         "#EC *
      CALL FUNCTION 'HTTP_GUI_LOGON'
        EXPORTING
          r3       = r3
          resource = challenge
        IMPORTING
          ok       = ok
          username = l_username
          password = l_password
          language = l_language
        CHANGING
          client   = m_client.
      pf_m_close c_statistic_state 'HTTP Gui Logon'.        "#EC *
      IF NOT ok IS INITIAL.
        CALL METHOD if_http_client~authenticate
          EXPORTING
            proxy_authentication = proxy_authentication
            client               = m_client
            username             = l_username
            password             = l_password
            language             = l_language.
*
* remove recorder logon fields, if available
*
        request->delete_header_field_secure(
                              name = ihttp_c_sap_recorder_aut ).

*
* resend new document
*
        CALL METHOD if_http_client~send
          EXPORTING
            timeout                    = m_timeout
          EXCEPTIONS
            http_communication_failure = 1
            http_invalid_state         = 2.

        subrc = sy-subrc.
        IF subrc <> 0.
          pf_m_close c_statistic_state 'HTTP Receive'.      "#EC *
        ENDIF.

        IF subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
        ELSEIF subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
        ENDIF.

        CALL METHOD if_http_client~receive
          EXCEPTIONS
            http_communication_failure = 1
            http_invalid_state         = 2
            http_processing_failed     = 3.

        subrc = sy-subrc.
        IF subrc <> 0.
          pf_m_close c_statistic_state 'HTTP Receive'.      "#EC *
        ENDIF.

        IF subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
        ELSEIF subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
        ELSEIF subrc = 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*          RAISE http_processing_failed.
        ENDIF.
      ENDIF.

    ELSEIF propertytype_redirect = co_enabled AND
      m_redirect_trial < co_redirect_trial AND
      ( m_last_response_code = 301 OR
* 301 Moved Permanently, 302 Moved Temporarily, 307 Temporary Redirect
        m_last_response_code = 302 OR
        m_last_response_code = 307 )."Redirect call

      pf_m_open c_statistic_state 'HTTP Redirect'.          "#EC *

      DATA: l_location        TYPE string,
            l_scheme          TYPE string,
            l_host            TYPE string,
            l_port            TYPE string,
            l_abs_path        TYPE string,
            l_rel_segment     TYPE string,
            l_query           TYPE string,
            l_uri             TYPE string,
            l_path            TYPE string,
            l_uri_is_relative TYPE c,
            l_match_offset    TYPE i.

* update retry type
      m_retry  = retrytype_redirect.

      m_redirect_trial =  m_redirect_trial + 1.

      l_location = response->get_header_field( 'location' ). "#EC NOTEXT

      IF l_location IS INITIAL.
        pf_m_close c_statistic_state 'HTTP Redirect'.       "#EC *
        pf_m_close c_statistic_state 'HTTP Receive'.        "#EC *
        EXIT.
      ENDIF.
*
* ICFRECORDER processing
*
      IF NOT m_icfrecorder IS INITIAL.
        CLEAR: icfrec_field.
        index = 0.
* -- find next index
        LOOP AT m_icfrecorder_fields TRANSPORTING NO FIELDS
                WHERE range = ihttp_recorder_field_range_cre.
          ADD 1 TO index.
        ENDLOOP.
        ADD 1 TO index.

        icfrec_field-range = ihttp_recorder_field_range_cre.
        icfrec_field-index = index.
        icfrec_field-name  = m_last_response_code.
        CONCATENATE icfrec_field-name reason
           INTO icfrec_field-name SEPARATED BY space.
*   'PROPERTYTYPE_REDIRECT'
        icfrec_field-value = l_location.
        APPEND icfrec_field TO m_icfrecorder_fields.
        CALL FUNCTION 'ICF_RECORDER_ATTRIBUTES'
          EXPORTING
            action                     = ihttp_icfservice_action_pack
*           from_entries               = ihttp_attributes
            icfrecorder_fields_imp     = m_icfrecorder_fields
*      IMPORTING
*           TO_ENTRIES                 =
          CHANGING
            icfrecord_attributes       = m_icfrecorder-attributes
          EXCEPTIONS
            icf_action_not_supported   = 1
            icf_no_authority           = 2
            icf_incomplete_information = 3
            icf_invalid_attributes     = 4
            OTHERS                     = 5.             "#EC *
        MODIFY icfrecorder FROM m_icfrecorder.
*
* avoid db commit in transactional context, e. g. update task, bgRFC context,
* and transactional instance area of shared objects
*
        cl_icf_recorder=>process_db_commit( ).
*     call function 'DB_COMMIT'.
      ENDIF.
* --
* parse location
* --
      pf_m_open c_statistic_state 'HTTP URI Parse'.         "#EC *
      CALL FUNCTION 'SWLWP_URI_PARSE'
        EXPORTING
          uri             = l_location
          parse_authority = 'X'
        IMPORTING
          scheme          = l_scheme
*         AUTHORITY       =
*         USERINFO        =
*         HOSTPORT        =
          host            = l_host
          port            = l_port
          abs_path        = l_abs_path
          rel_segment     = l_rel_segment
          query           = l_query
*         OPAQUE_PART     =
*         FRAGMENT        =
          is_relative     = l_uri_is_relative
*         HAS_NET_PATH    =
*         HAS_REL_PATH    =
*         HAS_EMPTY_AUTHORITY =
*         HAS_IPV4_HOST   =
        EXCEPTIONS
          uri_no_path     = 1
          OTHERS          = 2.

      IF sy-subrc <> 0.
        pf_m_close c_statistic_state 'HTTP URI Parse'.      "#EC *
        pf_m_close c_statistic_state 'HTTP Redirect'.       "#EC *
        pf_m_close c_statistic_state 'HTTP Receive'.        "#EC *
        EXIT.
      ENDIF.

      pf_m_close c_statistic_state 'HTTP URI Parse'.        "#EC *
* --
* -- update m_host, m_service and header field host
* --
      IF l_uri_is_relative IS INITIAL.
*   -- redirect with new absolute URI
*   -- set scheme and Is secure flag, for transport of cookies

        "validate host name from absolute
        IF mv_host_acl IS INITIAL.
          CREATE OBJECT mv_host_acl.
        ENDIF.
        TRY.
            DATA(lv_allowed) = mv_host_acl->validate(
              EXPORTING
                iv_hostname         = l_host
                iv_caller_check     = abap_true ).
            IF lv_allowed = abap_false.
*            RAISE http_communication_failure.
              MESSAGE e510(sclnt_http) WITH l_host RAISING http_communication_failure.
            ENDIF.
          CATCH cx_http_client_acl INTO DATA(lx_acl_err). " Exception class for HTTP client ACL API
            MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*            RAISE http_communication_failure.
        ENDTRY.

        CONCATENATE l_scheme ':' INTO l_uri.
        TRANSLATE l_scheme TO UPPER CASE. "EC TRANSLATE

        IF ( l_scheme EQ 'HTTPS' ).
          m_target_scheme = schemetype_https.
          m_target_is_secure = 1.
          IF l_port IS INITIAL.
            l_port = '443'.
          ENDIF.
        ELSE.
          m_target_scheme = schemetype_http.
          m_target_is_secure = 0.
          IF l_port IS INITIAL.
            l_port = '80'.
          ENDIF.
        ENDIF.

        "add router path to host
        DATA ls_result_host_data TYPE match_result.
        DATA lv_router_string TYPE string.

        FIND ALL OCCURRENCES OF '/H/' IN m_target_host RESULTS ls_result_host_data.

        IF ls_result_host_data-offset <> 0.
          DATA(lv_offset_counter) = ls_result_host_data-offset + 3.
          lv_router_string = m_target_host+0(lv_offset_counter).
        ELSE.
          lv_router_string = ''.
        ENDIF.

        m_target_host   = |{ lv_router_string }{ l_host }|.

        CONCATENATE l_uri '//' m_target_host INTO l_uri.

* check validity of port number (16bit Integer)
        IF ( strlen( l_port ) GT 5 )
        OR ( l_port CN '0123456789' ).
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*        RAISE http_processing_failed.
        ELSE.
          m_target_service = l_port.
        ENDIF.
*   -- correction of host header entry
*RFC3986 Uniform Resource Identifier (URI): Generic Syntax
*(...)
*URI producers and normalizers should omit the port component and its ":" delimiter
*if port is empty or if its value would be the same as that of the scheme's default.
        IF m_target_service IS INITIAL
        OR '80' = m_target_service
        OR '443' = m_target_service.
          l_host = m_target_host.
        ELSE.
          CONCATENATE l_uri ':' m_target_service INTO l_uri.
          CONCATENATE m_target_host ':' m_target_service INTO l_host. "#EC NOTEXT
        ENDIF.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'host'                                    "#EC NOTEXT
            value = l_host.

        IF NOT l_abs_path IS INITIAL.
          l_path = l_abs_path.
          CONCATENATE l_uri l_abs_path INTO l_uri.
        ELSE.
          l_path = '/'.
        ENDIF.

        IF NOT l_query IS INITIAL.
          CONCATENATE l_uri '?' l_query INTO l_uri.
        ELSEIF l_abs_path IS INITIAL.
          CONCATENATE l_uri '/' INTO l_uri.
        ENDIF.

      ELSE.
*  -- relative URI
        IF NOT l_abs_path IS INITIAL.
*  -- absolute path replaces old path
          l_path = l_abs_path.
        ELSE.
*  -- relative path
          l_path = request->get_header_field( '~path' ).    "#EC NOTEXT
          IF NOT l_path IS INITIAL.
*  -- remove last segment (including the trailing slash character)
            FIND ALL OCCURRENCES OF SUBSTRING '/' IN l_path
              IN CHARACTER MODE RESPECTING CASE
              MATCH OFFSET l_match_offset.
            REPLACE SECTION OFFSET l_match_offset OF l_path WITH space
              IN CHARACTER MODE.
            CONDENSE l_path.
          ENDIF.
          CONCATENATE l_path '/' l_rel_segment INTO l_path.
        ENDIF.
*  -- now the new path is stored in l_path
*  -- create new absolute URI from base scheme / authority and new path
        IF schemetype_http = m_target_scheme.
          l_uri = 'http:'.
        ELSE.
          l_uri = 'https:'.
        ENDIF.
        CONCATENATE l_uri '//' m_target_host INTO l_uri.
        IF NOT m_target_service IS INITIAL
          AND '80' <> m_target_service
          AND '443' <> m_target_service.
          CONCATENATE l_uri ':' m_target_service INTO l_uri.
        ENDIF.
        CONCATENATE l_uri l_path INTO l_uri.
        IF NOT l_query IS INITIAL.
          CONCATENATE l_uri '?' l_query INTO l_uri.
        ELSEIF l_path IS INITIAL.
          CONCATENATE l_uri '/' INTO l_uri.
        ENDIF.
      ENDIF.

* -- delete old/expired form fields
      DATA: l_fields TYPE tihttpnvp,
            l_field  TYPE ihttpnvp.
      pf_m_open c_statistic_state 'HTTP Delete Old Query'.  "#EC *
      request->get_form_fields( CHANGING fields = l_fields ).
      LOOP AT l_fields INTO l_field.
        request->delete_form_field( name = l_field-name ).
      ENDLOOP.
      pf_m_close c_statistic_state 'HTTP Delete Old Query'. "#EC *

*
* Is global proxy configuration active
*
      IF ( propertytype_apply_sproxy EQ co_enabled
      AND abap_true <> m_is_special_proxy_configured ).
        pf_m_open c_statistic_state 'HTTP Read Proxy'.      "#EC *

        CALL FUNCTION 'ICF_READ_PROXY_CONFIGURATION'
          EXPORTING
            authority_check               = ''
            mandant                       = sy-mandt
            request                       = request
            protocol                      = m_target_scheme
            hostname                      = m_target_host
          IMPORTING
            proxy_configuraion            = m_proxy_configuration
          EXCEPTIONS
            proxy_invalid_protocol        = 1
            proxy_entry_not_available     = 2
            proxy_entry_not_active        = 3
            proxy_parameter_not_available = 4
            proxy_not_necessary           = 5
            proxy_no_authority            = 6
            authority_not_available       = 7
            proxy_exit_erroneous          = 8
            OTHERS                        = 9.
        IF sy-subrc = 0.
          m_proxy_host    = m_proxy_configuration-host.
          m_proxy_service = m_proxy_configuration-port.

          "Validate HOST NAME ACL with m_proxy_host
          IF mv_host_acl IS INITIAL.
            CREATE OBJECT mv_host_acl.
          ENDIF.
          TRY.
              lv_allowed = mv_host_acl->validate(
                EXPORTING
                  iv_hostname         = m_proxy_host
                  iv_caller_check     = abap_true ).
              IF lv_allowed = abap_false.
                MESSAGE e510(sclnt_http) WITH l_host RAISING http_communication_failure.
*              RAISE http_communication_failure.
              ENDIF.
            CATCH cx_http_client_acl. " Exception class for HTTP client ACL API
              RAISE http_communication_failure.
          ENDTRY.

* check validity of proxy port number (16bit Integer)
          IF ( strlen( m_proxy_service ) GT 5 )
          OR ( m_proxy_service CN '0123456789' ).
            MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 845 RAISING http_processing_failed.
*          RAISE http_processing_failed.
          ENDIF.
          IF ( NOT m_proxy_configuration-proxy_user IS INITIAL ) OR
             ( NOT m_proxy_configuration-proxy_pass IS INITIAL ).
* avoid overwritting of application based SSL proxy
* authentication (set in method authenticate)
            IF ( m_proxy_username IS INITIAL ) AND
               ( m_proxy_password IS INITIAL ).
              m_proxy_username = m_proxy_configuration-proxy_user.
              m_proxy_password = m_proxy_configuration-proxy_pass.
            ENDIF.
          ENDIF.
        ENDIF.
        pf_m_close c_statistic_state 'HTTP Read Proxy'.     "#EC *
      ENDIF.

* transport of proxy authentication field, but only for http protocol
      IF m_target_scheme = schemetype_http AND
       ( ( NOT m_proxy_username IS INITIAL ) OR
         ( NOT m_proxy_password IS INITIAL ) ).
        auth =
          request->get_header_field( 'Proxy-Authorization' ). "#EC NOTEXT
        IF auth IS INITIAL.
          CALL METHOD authentication
            EXPORTING
              proxy_authentication = 'X'.
        ENDIF.
      ENDIF.

* --
* no absoult URL in path in case of HTTPS protocol,
* since proxy cannot filter the scheme and host:port part
* --
      IF m_proxy_host IS INITIAL OR
          m_target_scheme = schemetype_https.
*       cl_http_utility=>set_request_uri( request = request
*                                         uri     = uri ).
*  -- set query string
        IF NOT l_query IS INITIAL.
          pf_m_open c_statistic_state 'HTTP Set Query'.     "#EC *
          cl_http_utility=>set_query( request = request
                                      query   = l_query ).
          pf_m_close c_statistic_state 'HTTP Set Query'.    "#EC *
        ENDIF.

*  -- set path
        request->set_header_field( name  = '~request_uri'   "#EC NOTEXT
                                  value = l_path ).

      ELSE.
*  -- redirect with proxy configuration: uri conatins whole url
        pf_m_open c_statistic_state 'HTTP Set Request Uri'. "#EC *
        cl_http_utility=>set_request_uri( request = request
                                          uri     = l_uri ).
        pf_m_close c_statistic_state 'HTTP Set Request Uri'. "#EC *
      ENDIF.

* redirect: open a new connection with the location info
      pf_m_open c_statistic_state 'HTTP New Request'.       "#EC *
      close_connection( ).
      refresh_response( ).
      pf_m_close c_statistic_state 'HTTP New Request'.      "#EC *

*
* end of single record and sum statistics
*
      statistic( client = me start = 1 ).
      pf_m_close c_statistic_state 'HTTP Redirect'.         "#EC *

*
* Remark: in case of a redirect from HTTP to HTTPS "ANONYM" certificate should be
*         used, so that only a connection encryption and no server authentication based on
*         X509 certificate takes place. Otherwise, i.e. by sending a X509 client
*         clertificate in this case, this would lead to a failed the logon as the certificate
*         based authentication has a higher priority at ICF logon procedure list as
*         MYSAPSSO2, assertion or SAP RFC logon ticket based logon.
*

** Remark II:
* Since the  ICMan by not availability of a certificate id, per default uses the server certificate  (DFAULT)
* from the category/directory´"SSL-Sys.Client DFAULT" (SSLC PSE) maintained in the transaction STRUST and
* this lead to logon issues we should resolve this issue by providing only a server certificatie from the
* category/directory "SSL-Sys.Client ANONYM", i.e. "ANAONYM" (SSLA PSE), which are only used for SSL encryption
* and do not provide any client certificate, even if the server requires for one.
* By specifying the parameter M_DO_NO_SHOW_CLIENT_CERT = 'X' the ICM/SSL library won't send any cleint certificate to
* the server. Thus an "ANONYM" certificate is not anymore necessary since with the new strategy the customers are
* able to reuse the existing DFAULT certificates for HTTPS communication without transporting any client certrificate.
*
      IF m_scheme = schemetype_http.
* clear HTTPS related information in csae of communication via HTTP protocol
        CLEAR m_do_no_show_client_cert.
* in case of a redirect from HTTP to HTTPS use no client certificate
        IF m_target_scheme = schemetype_https.
          m_do_no_show_client_cert = 'X'.
        ENDIF.
      ENDIF.

*
* resend new document
*
      CALL METHOD if_http_client~send
        EXPORTING
          timeout                    = m_timeout
        EXCEPTIONS
          http_communication_failure = 1
          http_invalid_state         = 2
          http_processing_failed     = 3.

      subrc = sy-subrc.
      IF subrc <> 0.
        pf_m_close c_statistic_state 'HTTP Receive'.        "#EC *
      ENDIF.

      IF subrc = 1.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
      ELSEIF subrc = 2.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
      ELSEIF subrc = 3.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*        RAISE http_processing_failed.
      ENDIF.

      CALL METHOD if_http_client~receive
        EXCEPTIONS
          http_communication_failure = 1
          http_invalid_state         = 2
          http_processing_failed     = 3.

      subrc = sy-subrc.
      IF subrc <> 0.
        pf_m_close c_statistic_state 'HTTP Receive'.        "#EC *
      ENDIF.

      IF subrc = 1.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
      ELSEIF subrc = 2.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
      ELSEIF subrc = 3.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*        RAISE http_processing_failed.
      ENDIF.
    ELSEIF m_last_response_code = 400.
      "Special handling for code ICM_HTTP_H2_HTTP_1_1_REQUIRED
      DATA(l_icm_err_code) = response->get_header_field( 'sap-icmclnterror' ). "#EC NOTEXT
      IF l_icm_err_code = 428 AND m_redirect_trial < 1. "ICM_HTTP_H2_HTTP_1_1_REQUIRED
        m_redirect_trial = m_redirect_trial + 1.
        request->set_header_field( name = 'sap-icm-force-http1' value = 'true' ).
        close_connection( ).
        refresh_response( ).
        "Resend document
        CALL METHOD if_http_client~send
          EXPORTING
            timeout                    = m_timeout
          EXCEPTIONS
            http_communication_failure = 1
            http_invalid_state         = 2.

        subrc = sy-subrc.
        IF subrc <> 0.
          pf_m_close c_statistic_state 'HTTP Receive'.      "#EC *
        ENDIF.

        IF subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
        ELSEIF subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
        ENDIF.

        CALL METHOD if_http_client~receive
          EXCEPTIONS
            http_communication_failure = 1
            http_invalid_state         = 2
            http_processing_failed     = 3.

        subrc = sy-subrc.
        IF subrc <> 0.
          pf_m_close c_statistic_state 'HTTP Receive'.      "#EC *
        ENDIF.

        IF subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
        ELSEIF subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
        ELSEIF subrc = 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*          RAISE http_processing_failed.
        ENDIF.
      ENDIF.
    ENDIF.

    IF m_last_response_code = 401 AND m_oauth_state = 1.
      m_oauth_state = 2.
      li_client ?= me.
      CALL METHOD cl_http_client=>set_oauth_token
        EXPORTING
          i_oauth_profile = m_oauth_profile
          i_oauth_config  = m_oauth_config
          io_http_client  = li_client
        EXCEPTIONS
          OTHERS          = 1.
      IF sy-subrc = 0.
        refresh_response( ).
*   resend new document
*
        CALL METHOD if_http_client~send
          EXPORTING
            timeout                    = m_timeout
          EXCEPTIONS
            http_communication_failure = 1
            http_invalid_state         = 2
            http_processing_failed     = 3.

        subrc = sy-subrc.
        IF subrc <> 0.
          pf_m_close c_statistic_state 'HTTP Receive'.      "#EC *
        ENDIF.

        IF subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
        ELSEIF subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
        ELSEIF subrc = 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*        RAISE http_processing_failed.
        ENDIF.

        CALL METHOD if_http_client~receive
          EXCEPTIONS
            http_communication_failure = 1
            http_invalid_state         = 2
            http_processing_failed     = 3.

        subrc = sy-subrc.
        IF subrc <> 0.
          pf_m_close c_statistic_state 'HTTP Receive'.      "#EC *
        ENDIF.

        IF subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
        ELSEIF subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
        ELSEIF subrc = 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*        RAISE http_processing_failed.
        ENDIF.
      ENDIF.
    ENDIF.

* -- is any return codes received from ICMAN -> GET_LAST_ERROR
    reason = response->get_header_field( 'sap-icmclnterror' ). "#EC NOTEXT
    IF ( NOT reason IS INITIAL ) AND
       ( reason <> '200' ).
      response->delete_header_field( 'sap-icmclnterror' ).  "#EC NOTEXT

      detail_encoded = response->get_header_field( 'SAP-ICMERRORDETAIL' ). "#EC NOTEXT
* Decode string using ICM method
      detail = cl_icm_api=>client_error_detail_to_string( detail_url_encoded =  detail_encoded ).
      response->delete_header_field( 'SAP-ICMERRORDETAIL' ). "#EC NOTEXT
      m_ecode = reason.
      IF detail IS NOT INITIAL.
        m_emessage = detail.
      ELSE.
        CALL METHOD error_codes=>get_error_text
          EXPORTING
            number = m_ecode
          IMPORTING
            text   = m_emessage.
      ENDIF.
      pf_m_close c_statistic_state 'HTTP Receive'.          "#EC *
*      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
      MESSAGE m_emessage TYPE 'E' RAISING http_communication_failure.
*      RAISE http_communication_failure.
    ENDIF.


*
* end of single record and sum statistics
*
    statistic( client = me start = 0 ).
    pf_m_close c_statistic_state 'HTTP Receive'.            "#EC *

  ENDMETHOD.


  METHOD if_http_client~refresh_cookie.
    DATA: m_last_error TYPE i,
          options      TYPE i.
** refresh cookie object
    SYSTEM-CALL ict
      DID
        47                      "IctAbScHttpClearCookieDB
      PARAMETERS
        m_c_cclient             " < client cookie object
        options                 " < options
        m_last_error.           " > return code (integer)  "#EC CI_SYSTEMCALL

    IF m_last_error <> 0.
      m_ecode = m_last_error.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = http_processing_failed_error
        IMPORTING
          text   = m_emessage.
      RAISE http_processing_failed.
    ENDIF.

** refresh cookie object
** 1) delete cookie object
*    system-call ict
*      did
*        43                      "IctAbScHttpDeleteClient
*      parameters
*        m_c_cclient             " < client object for
*        m_last_error.           " > return code (integer)
*
*     if m_last_error <> 0.
*        m_ecode = m_last_error.
*        call method error_codes=>get_error_text
*                        exporting number = http_processing_failed_error
*                        importing text   = m_emessage.
*        raise http_processing_failed.
*     endif.
*
** 2) create a new cookie object
*    system-call ict
*      did
*        42                      "IctAbScHttpCreateClient
*      parameters
*        m_c_cclient             " > client object
*        m_last_error.           " > return code (integer)
*
*     if m_last_error <> 0.
*        m_ecode = m_last_error.
*        call method error_codes=>get_error_text
*                        exporting number = http_processing_failed_error
*                        importing text   = m_emessage.
*        raise http_processing_failed.
*     endif.
*
  ENDMETHOD.


  METHOD if_http_client~refresh_request.
    DATA: c_msg TYPE %_c_pointer.
    DATA: http_request TYPE REF TO cl_http_request.
    DATA: m_last_error TYPE i.

    SYSTEM-CALL ict
      DID
        ihttp_scid_create_message
      PARAMETERS
        1                              " > message type (1 = requ)
        c_msg                          " < c handle
        m_last_error.                  " < return code  "#EC CI_SYSTEMCALL
    IF m_last_error <> 0.
      m_ecode    = m_last_error.
      m_emessage = 'CREATE_MESSAGE_FAILED'.
      RAISE http_action_failed.
    ENDIF.

    http_request ?= request.
    http_request->set_c_msg( c_msg ).
* assert http_request->m_last_error = 0.

* --
    m_retry = retrytype_none.

* -- setting of header info only once
    m_already_processed = 0.

* -- re-init some header fields as if the client object
* -- has just been created
    IF ( m_createtype EQ createtype_url ).
      IF ( NOT m_path IS INITIAL ).
        request->set_header_field( name  = '~request_uri'
                                   value = m_path ).        "#EC NOTEXT
      ENDIF.

      IF ( NOT m_query IS INITIAL ).
        cl_http_utility=>set_query( request = request
                                    query   = m_query ).
      ENDIF.
    ENDIF.

    IF ( m_createtype EQ createtype_destination_r3
      OR m_createtype EQ createtype_destination_ext ).

      request->set_header_field( name = '~server_protocol'
                                 value = m_server_protocol ). "#EC NOTEXT
    ENDIF.

    IF m_use_scc = abap_true AND m_scc_location_ID IS NOT INITIAL.
      CALL METHOD request->set_header_field
        EXPORTING
          name  = 'SAP-Connectivity-SCC-Location_ID'
          value = m_scc_location_ID.
    ENDIF.

  ENDMETHOD.


  METHOD if_http_client~refresh_response.
* ...
    DATA: c_msg TYPE %_c_pointer.
    DATA: http_response TYPE REF TO cl_http_response.
    DATA: m_last_error TYPE i.

    SYSTEM-CALL ict
      DID
        ihttp_scid_create_message
      PARAMETERS
        2                              " > message type (2 = resp)
        c_msg                          " < c handle
        m_last_error.                  " < return code  "#EC CI_SYSTEMCALL

    IF m_last_error <> 0.
      m_ecode    = m_last_error.
      m_emessage = 'CREATE_MESSAGE_FAILED'.
      RAISE http_action_failed.
    ENDIF.

    http_response ?= response.
    http_response->set_c_msg( c_msg ).
* assert http_response->m_last_error = 0.
  ENDMETHOD.


  METHOD if_http_client~send.
    DATA: host          TYPE rfcdisplay-rfchost,
          service       TYPE rfcgwserv,
          proxy_host    TYPE rfcdisplay-rfchost,
          proxy_service TYPE rfcgwserv,
          auth          TYPE string.
    DATA: http_client_instance     TYPE ihttp_client_instance.
    DATA: data                     TYPE xstring.
    DATA: subrc                    TYPE sysubrc.
    DATA: uri                      TYPE string.
    DATA: myinfo                   TYPE string.
    DATA: c_msg                    TYPE %_c_pointer.
    DATA: dummy                    TYPE string.
    DATA: l_dummy                  TYPE string.
    DATA: l_send_distributed_tracing TYPE c.
    DATA: l_scc_in_use               TYPE c.
    DATA: lv_prof_scc_proxy TYPE string.
    DATA: lv_prof_proxy_host TYPE string.
    DATA: lv_prof_proxy_service TYPE string.
    DATA: lv_scc_as_proxy TYPE abap_bool VALUE abap_false.
    DATA: lv_host_4_acl TYPE string.
*  data: recorder_level  type i.

* --  clear last attributes
    CLEAR: m_ecode.

    IF m_use_scc = abap_true.
      l_scc_in_use = 'X'.
    ELSE.
      l_scc_in_use = ' '.
    ENDIF.

* -- check state
    IF m_state = statetype_send.
      m_ecode = http_invalid_state_error.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = m_ecode
        IMPORTING
          text   = m_emessage.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*      RAISE http_invalid_state.
    ENDIF.
    m_state = statetype_send.

    pf_m_open c_statistic_state 'HTTP Send'.                "#EC *

* -- check timeout
    IF NOT timeout IS INITIAL.
      IF timeout < co_timeout_infinite.
        pf_m_close c_statistic_state 'HTTP Send'.           "#EC *
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 865 RAISING http_invalid_timeout.
*        RAISE http_invalid_timeout.
      ENDIF.
    ENDIF.

*
* single record statistics
*
    pf_m_open c_statistic_state 'HTTP Statistic'.           "#EC *
    statistic( client = me start = 1 ).
    pf_m_close c_statistic_state 'HTTP Statistic'.          "#EC *

* transport of header fields only once, with help of m_retry
    IF m_already_processed = 0.
      m_already_processed = 1.

      pf_m_open c_statistic_state 'HTTP First Processing'.  "#EC *
* set user-agenet
* concatenate 'R3' sy-saprl '(compatible; MSIE 5.0)' into myinfo.
      myinfo    = request->get_header_field( 'User-Agent' ). "#EC NOTEXT
      IF myinfo IS INITIAL.
*     CONCATENATE 'SAP Web Application Server ('            "#EC NOTEXT
        CONCATENATE 'SAP NetWeaver Application Server ('    "#EC NOTEXT
                                 version ';' sy-saprl ')'   "#EC NOTEXT
                                                     INTO myinfo.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'User-Agent'                              "#EC NOTEXT
            value = myinfo.
      ENDIF.

* set host
*RFC3986 Uniform Resource Identifier (URI): Generic Syntax
*(...)
*URI producers and normalizers should omit the port component and its ":" delimiter
*if port is empty or if its value would be the same as that of the scheme's default.
      CLEAR myinfo.
      IF m_target_service IS INITIAL
      OR '80' = m_target_service
      OR '443' = m_target_service.
        myinfo = m_target_host.
      ELSE.
        CONCATENATE m_target_host ':' m_target_service INTO myinfo.
      ENDIF.
      CALL METHOD request->set_header_field
        EXPORTING
          name  = 'host'                                      "#EC NOTEXT
          value = myinfo.

* -- compression supported and should not be suppressed
* -- parameter m_suppress_... is only used for HTTP destinations
      IF propertytype_accept_compress = co_enabled AND
         c_compression_supported      = co_enabled.
        IF m_scheme = schemetype_https.
          CALL METHOD request->set_header_field
            EXPORTING
              name  = 'accept-encoding'
              value = 'gzip, br'.
        ELSE.
          CALL METHOD request->set_header_field
            EXPORTING
              name  = 'accept-encoding'
              value = 'gzip'.
        ENDIF.                                              "#EC NOTEXT
      ENDIF.

* prepare server authentication header field
      IF ( m_createtype EQ createtype_destination_r3
        OR m_createtype EQ createtype_destination_ext ).

        IF ( m_createtype EQ createtype_destination_r3 ).
* -- logen procedure maintained in HTTP destination Typ R3
* -- B = Basic Authentication, SPACE = SAP Standard,
* -- Y = SAP Trusted System.
          IF ( m_logon_method IS INITIAL OR
               m_logon_method = 'Y' ) AND
           NOT m_session IS INITIAL.
            IF m_intticket_mode > 0.
              CALL METHOD create_r3_ticket
                EXCEPTIONS
                  internal_error = 1.
            ENDIF.
            CALL METHOD request->set_header_field
              EXPORTING
                name  = c_sap_r3auth                          "#EC NOTEXT
                value = m_session.
          ELSEIF m_logon_method = 'B'.
* -- is authentication field set by application bevor ?
            auth = request->get_header_field( 'Authorization' ). "#EC NOTEXT
            IF auth IS INITIAL.
              CALL METHOD authentication.
            ENDIF.
          ENDIF.

        ELSEIF ( m_createtype EQ createtype_destination_ext ). "destinationtype_ext
* -- is authentication field set by application bevor ?
          auth = request->get_header_field( 'Authorization' ). "#EC NOTEXT
          IF auth IS INITIAL.
            CALL METHOD authentication.
          ENDIF.

** -- sending of SSO ticket in kernel
*        if m_sso_ticket = 'X' and
*           m_patch      <> 4  and
*           m_patch      <> 5  and
*           m_patch      <> 6  and
*           m_patch      <> 7.
** 0x04 = PATCH_SSO_TICKET
*           m_patch = m_patch + 4.
*        endif.

        ENDIF.

* compression is already set by application (value = 'X')
* or is not required (value = '0')
        IF m_compress <> 'X'         AND
           m_compress IS NOT INITIAL AND
           m_compress <> '0'.
          IF m_compress = '1'.
            CALL METHOD set_compression
              EXPORTING
                options                  = co_compress_based_on_mime_type
              EXCEPTIONS
                compression_not_possible = 1. "#EC *
            m_compress = m_compress_dest.
          ELSE.
            CALL METHOD set_compression
              EXPORTING
                options                  = co_compress_in_all_cases
              EXCEPTIONS
                compression_not_possible = 1. "#EC *
            m_compress = m_compress_dest.
          ENDIF.
        ENDIF.

      ENDIF.

      DATA lv_assertion_ticket TYPE abap_bool VALUE abap_false.

      IF NOT m_assertion_client IS INITIAL  AND
         NOT m_assertion_system_id IS INITIAL.
        lv_assertion_ticket = abap_true.
      ENDIF.

* -- sending of SSO ticket in kernel for any kind of creation types (XI requirement)
      IF ( m_sso_ticket = 'X' OR lv_assertion_ticket = abap_true ) AND
          m_patch      <> 4  AND
          m_patch      <> 5  AND
          m_patch      <> 6  AND
          m_patch      <> 7.
*0x04 = PATCH_SSO_TICKET
        m_patch = m_patch + 4.

*
* Ensure that the client number and language are transported with sso ticket, if available.
* Otherwise, the MYSAPSSO2 logon would fail, when the logon method "SAP standard" is maintained in SM59.
* In case of logon method "SAP standard", the client and language are not sent as single header fields.
* Do not overwrite the application defined sap-client and sap-language fields.
*
        IF NOT m_client IS INITIAL.
          dummy   = request->get_header_field( 'SAP-Client' ). "#EC NOTEXT
          l_dummy = request->get_form_field( 'SAP-Client' ). "#EC NOTEXT
          IF ( dummy IS INITIAL ) AND ( l_dummy IS INITIAL ) .
            dummy = m_client.
            CALL METHOD request->set_header_field
              EXPORTING
                name  = 'SAP-Client'                          "#EC NOTEXT
                value = dummy.
          ENDIF.
        ENDIF.

        IF NOT m_language IS INITIAL.
          dummy   = request->get_header_field( 'SAP-Language' ). "#EC NOTEXT
          l_dummy = request->get_form_field( 'SAP-Language' ). "#EC NOTEXT
          IF ( dummy IS INITIAL ) AND ( l_dummy IS INITIAL ) .
            dummy = m_language.
            CALL METHOD request->set_header_field
              EXPORTING
                name  = 'SAP-Language'                        "#EC NOTEXT
                value = dummy.
          ENDIF.
        ENDIF.
      ENDIF.

* -- transport of sap_username and sap_client in case of
* -- client certificate logon

* -- logon via client certificate, transport of user and client
      IF NOT m_sap_username IS INITIAL.
        dummy = m_sap_username.
        request->set_header_field( name = 'sap-user'        "#EC NOTEXT
                                  value = dummy ).
      ENDIF.

      IF NOT m_sap_client IS INITIAL.
        dummy = m_sap_client.
        request->set_header_field( name = 'sap-client'      "#EC NOTEXT
                                  value = dummy ).
      ENDIF.


*
* Is global proxy configuration active
*
      DATA: l_host_wo_rstring TYPE abap_bool. "router string check
      FIND '/H/' IN m_target_host. "EC NO_TEXT
      IF sy-subrc = 0.
        l_host_wo_rstring = abap_false.
        CLEAR: m_proxy_host, m_proxy_service.
      ELSE.
        l_host_wo_rstring = abap_true.
      ENDIF.

      IF l_host_wo_rstring = abap_true.
        IF ( propertytype_apply_sproxy EQ co_enabled
      AND abap_true <> m_is_special_proxy_configured ).
          pf_m_open c_statistic_state 'HTTP Read Proxy'.    "#EC *

          CALL FUNCTION 'ICF_READ_PROXY_CONFIGURATION'
            EXPORTING
              authority_check               = ''
              mandant                       = sy-mandt
              request                       = request
              protocol                      = m_target_scheme
              hostname                      = m_target_host
            IMPORTING
              proxy_configuraion            = m_proxy_configuration
            EXCEPTIONS
              proxy_invalid_protocol        = 1
              proxy_entry_not_available     = 2
              proxy_entry_not_active        = 3
              proxy_parameter_not_available = 4
              proxy_not_necessary           = 5
              proxy_no_authority            = 6
              authority_not_available       = 7
              proxy_exit_erroneous          = 8
              OTHERS                        = 9.
          IF sy-subrc = 0.
            m_proxy_host    = m_proxy_configuration-host.
            m_proxy_service = m_proxy_configuration-port.
            IF ( NOT m_proxy_configuration-proxy_user IS INITIAL ) OR
               ( NOT m_proxy_configuration-proxy_pass IS INITIAL ).
*   avoid overwritting of application based SSL proxy
*   authentication (set in method authenticate)
              IF ( m_proxy_username IS INITIAL ) AND
                 ( m_proxy_password IS INITIAL ).
                m_proxy_username = m_proxy_configuration-proxy_user.
                m_proxy_password = m_proxy_configuration-proxy_pass.
                m_is_proxy_password_encrypted = abap_true.
              ENDIF.
            ENDIF.
          ENDIF.
          pf_m_close c_statistic_state 'HTTP Read Proxy'.   "#EC *
        ENDIF.
      ENDIF.

* transport of proxy authentication field, but only for http protocol
      IF m_target_scheme = schemetype_http AND
       ( ( NOT m_proxy_username IS INITIAL ) OR
         ( NOT m_proxy_password IS INITIAL ) ).
        auth =
          request->get_header_field( 'Proxy-Authorization' ). "#EC NOTEXT
        IF auth IS INITIAL.
          CALL METHOD authentication
            EXPORTING
              proxy_authentication = 'X'.
        ENDIF.
      ENDIF.

* concatenate prefix path with the actual path
      IF NOT m_path_prefix IS INITIAL. " and

        uri = request->get_header_field( '~request_uri' ).  "#EC NOTEXT

*-- contains request uri form parameters
        IF uri CS '?'.
          DATA: l_prefix       TYPE string,
                l_postfix      TYPE string,
                l_path_prefix  TYPE string,
                l_path_postfix TYPE string.
          SPLIT uri AT '?' INTO l_prefix l_postfix.
*-- contains path prefix form parameters
          IF m_path_prefix CS '?'.
            SPLIT m_path_prefix AT '?' INTO l_path_prefix l_path_postfix.
            CONCATENATE l_path_prefix l_prefix '?'
                        l_path_postfix '&' l_postfix INTO uri.
          ELSE.
            CONCATENATE m_path_prefix l_prefix '?' l_postfix INTO uri.
          ENDIF.
        ELSE.
*-- contains path prefix form parameters
          IF m_path_prefix CS '?'.
            SPLIT m_path_prefix AT '?' INTO l_path_prefix l_path_postfix.
            CONCATENATE l_path_prefix uri '?'
                                      l_path_postfix INTO uri.
          ELSE.
            CONCATENATE m_path_prefix uri INTO uri.
          ENDIF.
        ENDIF.
        cl_http_utility=>set_request_uri( request = request
                                          uri     = uri ).

      ENDIF.

* adjust request line header in case of proxy definition
      IF NOT m_proxy_host IS INITIAL.
        uri = request->get_header_field( '~request_uri' ).  "#EC NOTEXT

* -- check whether uri is full specified, e. g. http://host:port/path
        IF ( uri IS NOT INITIAL )
        AND NOT ( uri CO space ).
          CONDENSE uri.
          DATA: l_scheme        TYPE string,                "#EC NEEDED
                l_host          TYPE string,                "#EC NEEDED
                l_service       TYPE string,                "#EC NEEDED
                l_query         TYPE string,                "#EC NEEDED
                l_path          TYPE string,                "#EC NEEDED
                l_uri           TYPE string,                "#EC NEEDED
                url_is_relative TYPE c.                     "#EC NEEDED

          pf_m_open c_statistic_state 'HTTP URI Parse'.     "#EC *

          CALL FUNCTION 'SWLWP_URI_PARSE'
            EXPORTING
              uri             = uri
              parse_authority = 'X'
            IMPORTING
              scheme          = l_scheme
*             AUTHORITY       =
*             USERINFO        =
*             HOSTPORT        =
              host            = l_host
              port            = l_service
              abs_path        = l_uri
              rel_segment     = l_path
              query           = l_query
*             OPAQUE_PART     =
*             FRAGMENT        =
              is_relative     = url_is_relative
*             HAS_NET_PATH    =
*             HAS_REL_PATH    =
*             HAS_EMPTY_AUTHORITY =
*             HAS_IPV4_HOST   =
            EXCEPTIONS
              uri_no_path     = 1
              OTHERS          = 2.                        "#EC *

          pf_m_close c_statistic_state 'HTTP URI Parse'.    "#EC *

          CLEAR uri.
          IF ( l_uri IS NOT INITIAL )
          AND NOT ( l_uri CO space ).
            IF l_query IS INITIAL.
              uri = l_uri.
            ELSE.
              CONCATENATE l_uri l_query INTO uri SEPARATED BY `?`.
            ENDIF.
          ENDIF.

        ENDIF.

        IF ( uri IS INITIAL )
        OR ( uri CO space ).
          uri = '/'.                                        "#EC NOTEXT
        ENDIF.

* -- ICT layer needs with host also port number by url specification
* -- in case of communication over proxy
        IF m_target_service IS INITIAL.
          CONCATENATE m_target_host uri INTO uri.
        ELSE.
          CONCATENATE m_target_host ':' m_target_service uri INTO uri. "#EC NOTEXT
        ENDIF.

** TODO validate

* -- reconstruction of URL
* no absoult URL in path in case of HTTPS protocol,
* since proxy cannot filter the scheme and host:port part
* --
        IF m_target_scheme = schemetype_http.
          CONCATENATE 'http://' uri INTO uri.               "#EC NOTEXT

          CONDENSE uri NO-GAPS.
          pf_m_open c_statistic_state 'HTTP Set Request Uri'. "#EC *
          cl_http_utility=>set_request_uri( request = request
                                            uri     = uri ).
          pf_m_close c_statistic_state 'HTTP Set Request Uri'. "#EC *
        ENDIF.

      ENDIF.

*
* Aktivierung des remote Traces bei aktivierten
* lokalen Trace (ABAP oder ICF)
*
      IF c_trace_level > 1.
        dummy = c_trace_level.
        request->set_header_field( name  = 'sap-trace'      "#EC NOTEXT
                                   value = dummy ).
      ENDIF.

      pf_m_close c_statistic_state 'HTTP First Processing'. "#EC *

    ENDIF. "m_already_processed.

*
* if no uri exists, set the default value '/'
*
    uri = request->get_header_field( '~request_uri' ).      "#EC NOTEXT
    IF ( uri IS INITIAL )
    OR ( uri CO space ).
      CALL METHOD request->set_header_field
        EXPORTING
          name  = '~request_uri'
          value = '/'.                                        "#EC NOTEXT
    ENDIF.


*
* reaction of received cookies
*
    pf_m_open c_statistic_state 'HTTP Send Cookie'.         "#EC *

    CALL METHOD send_cookie
      EXCEPTIONS
        http_processing_failed = 1.

    IF sy-subrc <> 0.
      pf_m_close c_statistic_state 'HTTP Send Cookie'.      "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_processing_failed.
*      RAISE http_processing_failed.
    ENDIF.
    pf_m_close c_statistic_state 'HTTP Send Cookie'.        "#EC *

* Is new version for proxy configuration in kernel active ?
    IF c_client_kernel_version > 0.
      host    = m_target_host.
      service = m_target_service.
    ELSE.
* -- adjust http header uri in case of proxy definition, and redirect
      IF m_proxy_host IS INITIAL.
        host    = m_target_host.
        service = m_target_service.
      ELSE.
        host = m_proxy_host.
        IF m_proxy_service IS INITIAL.
          service = '80'.
        ELSE.
          service = m_proxy_service.
        ENDIF.
      ENDIF.
    ENDIF.

* assigning proxy information
    proxy_host = m_proxy_host.
    IF NOT proxy_host IS INITIAL AND
       m_proxy_service IS INITIAL.
      proxy_service = '80'.
    ELSE.
      proxy_service = m_proxy_service.
    ENDIF.

*
* increase connection_counter (number of Requests) per client object
* put both m_counter (as connection calls) and m_connection (as connection id) into the extended passport (EPP)
*
    m_counter = m_counter + 1.
*
* transport of (DSR) passport ticket (always to R/3 systems) and by setting
* the attribute propertytype_send_sap_passport
*
    IF ( propertytype_send_sap_passport = co_enabled
      OR m_createtype EQ createtype_destination_r3 ).

*
* use extended passport
*
      get_extended_passport( IMPORTING  passport  = m_passport
                             EXCEPTIONS epp_error = 1 ).
      IF sy-subrc <> 0.
*
* CST proposal 1. Aug. 2007: This error should not lead to a HTTP communication
*                            and prevent the HTTP request
*      RAISE http_processing_failed.
      ELSEIF m_passport IS NOT INITIAL.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'sap-passport'                            "#EC NOTEXT
            value = m_passport.
      ENDIF.
    ENDIF.


* -- activation of ICFRECORDER via SICF transaction
    IF m_enable_recording IS INITIAL AND
       c_accept_client_recorder_level > 0.
      DATA: recorder_attribute TYPE icfrecstru.
      DATA: recorder_lifeday  TYPE lifeday,
            recorder_lifetime TYPE syuzeit,
            entry_exists      TYPE c,
            icfattrib_entry   TYPE icfattrib.

      uri = request->get_header_field( '~path_translated' ). "#EC NOTEXT
      CALL FUNCTION 'HTTP_CLIENT_READ_RECORD'
        EXPORTING
          user            = sy-uname
          path            = uri
        IMPORTING
          entry_exists    = entry_exists
          attribut        = recorder_attribute
          lifeday         = recorder_lifeday
          lifetime        = recorder_lifetime
          icfattrib_entry = icfattrib_entry.
      IF entry_exists = 'Y'.
        IF recorder_attribute-icfrequest IS NOT INITIAL.
*     record request document
          m_enable_recording = ihttp_record_cresponse_status.
        ELSE.
*     record request and response documents
          m_enable_recording = ihttp_record_cresponse.
        ENDIF.
      ENDIF.
    ENDIF.

*
* activate ICF recorder, if necessaty
*
    IF m_enable_recording >= ihttp_record_crequest_status.
      CALL METHOD recorder
        EXPORTING
          expiration_day  = recorder_lifeday
          expiration_time = recorder_lifetime
          icfattrib_entry = icfattrib_entry
        CHANGING
          component       = m_enable_recording
        EXCEPTIONS
          OTHERS          = 1.
    ENDIF.

* inheritance from server call is possible
    IF m_enable_recording IS INITIAL AND
       cl_icf_recorder=>c_enable_client_recording IS NOT INITIAL.
      m_enable_recording  = cl_icf_recorder=>c_enable_client_recording.
    ENDIF.

* inheritance of parent icfattrib, if no icfattrib_entry available
    IF m_enable_recording IS NOT INITIAL.
      IF icfattrib_entry IS INITIAL.
        icfattrib_entry = cl_icf_recorder=>c_icfattrib.
      ENDIF.
      IF recorder_lifeday IS INITIAL
      AND recorder_lifetime IS INITIAL.
        recorder_lifeday = icfattrib_entry-life_day.
        recorder_lifetime = icfattrib_entry-life_time.
      ENDIF.
    ENDIF.

*
* -- inheritance of recorder level plus scope id
*
    IF NOT m_enable_recording IS INITIAL.
      CASE m_enable_recording.
        WHEN ihttp_record_crequest_status.
          dummy = ihttp_record_request_status.
        WHEN ihttp_record_crequest.
          dummy = ihttp_record_request.
        WHEN ihttp_record_cresponse_status.
          dummy = ihttp_record_response_status.
        WHEN ihttp_record_cresponse.
          dummy = ihttp_record_response.
      ENDCASE.
* client request from SAP Web Application Server
      request->set_header_field( name  = ihttp_c_sap_recorder
                                  value = dummy ).
      IF NOT c_scope_message_id IS INITIAL.
* send sap-recorder cookie as message_id"-"message_nr
* use client message nr, in case of processing of
* next message is the successor
* -- ,c=<sysid>-<caller_id>-<message_id>-<message_nr>,<x>=...
        dummy = c_scope_message_nr.
        CONCATENATE ',c='
                    sy-sysid                 '-'
                    c_scope_message_id       '-'
                    m_icfrecorder-message_id '-'
                    dummy
                    ',o='
                    m_icfrecorder-owner_server '-'
                    m_icfrecorder-owner_client '-'
                    m_icfrecorder-owner_user
                    INTO dummy.
        CONDENSE dummy NO-GAPS.
        request->set_header_field( name  = ihttp_c_sap_recorder_sid
                                   value = dummy ).
      ENDIF.
    ENDIF.

*
* setting of connection timeout
*
    IF ( timeout EQ co_timeout_default )
    AND ( m_destination_timeout IS NOT INITIAL ).

      m_timeout = m_destination_timeout.
    ELSE.
      m_timeout = timeout.
    ENDIF.

*
* process the HTTP request either via ICMan or internally
*
    IF m_create_internal = 1. "CREATE_INTERNAL: lokaler Aufruf
      CLEAR m_document.
      data = request->to_xstring( ).
      pf_m_close c_statistic_state 'HTTP Dispatch Request'. "#EC *

      CALL FUNCTION 'HTTP_DISPATCH_REQUEST'
        EXPORTING
          document_in  = data
          client_name  = m_name
          virtual_host = m_virtual_host
        IMPORTING
          document_out = m_document.
      pf_m_close c_statistic_state                        "#EC CI_CCALL
                          'HTTP HTTP Dispatch Request'.     "#EC NOTEXT

    ELSE.

      DATA: _request         TYPE REF TO cl_http_entity.

      _request        ?= request.
      c_msg            = _request->m_c_msg.

      pf_m_open c_statistic_state 'HTTP Write System Call'. "#EC *
      IF m_createtype = createtype_destination_r3 AND
         m_epp_root_context_id IS INITIAL.
        "do not send the header field sap-dtrace in case of APC detached client with new EPP eroot context id,
        "as the responsible function IcfSetDTHeaderFields is not aware of the new EPP root context id !
        l_send_distributed_tracing = 'Y'.
      ELSE.
        CLEAR l_send_distributed_tracing.
      ENDIF.


      IF proxy_host IS NOT INITIAL.
        "check if proxy data is connectivity agent and scc should be used.
        DATA(lv_value) = cl_spfl_profile_parameter=>get_value(
        EXPORTING
          name        = 'http/scc_proxy'
        IMPORTING
          value       = lv_prof_scc_proxy   ).
        IF lv_prof_scc_proxy IS NOT INITIAL.
          SPLIT lv_prof_scc_proxy AT ':' INTO lv_prof_proxy_host lv_prof_proxy_service.
          IF lv_prof_proxy_host IS NOT INITIAL AND lv_prof_proxy_service IS NOT INITIAL.
            IF lv_prof_proxy_host EQ proxy_host AND lv_prof_proxy_service EQ proxy_service.
              lv_scc_as_proxy = abap_true.
            ENDIF.
          ENDIF.
        ENDIF.

        IF lv_scc_as_proxy = abap_false.
          IF mv_host_acl IS INITIAL.
            CREATE OBJECT mv_host_acl.
          ENDIF.
          TRY.
              lv_host_4_acl = proxy_host.
              DATA(lv_allowed) = mv_host_acl->validate(
                EXPORTING
                  iv_hostname         = lv_host_4_acl
                  iv_caller_check     = abap_true ).
              IF lv_allowed = abap_false.
                MESSAGE e511(sclnt_http) WITH lv_host_4_acl RAISING http_communication_failure.
              ENDIF.
            CATCH cx_http_client_acl INTO DATA(lx_acl_err). " Exception class for HTTP client ACL API
              DATA(lv_acl_text) = lx_acl_err->get_text( ).
              MESSAGE e513(sclnt_http) WITH lv_acl_text RAISING http_communication_failure.
          ENDTRY.
*        TRY.
*            lv_host_4_acl = host.
*            lv_allowed = mv_host_acl->validate(
*              EXPORTING
*                iv_hostname         = lv_host_4_acl
*                iv_caller_check     = abap_true ).
*            IF lv_allowed = abap_false.
*              RAISE http_communication_failure.
*            ENDIF.
*          CATCH cx_http_client_acl. " Exception class for HTTP client ACL API
*            RAISE http_communication_failure.
*        ENDTRY.
        ENDIF.
      ELSE.
        IF mv_host_acl IS INITIAL.
          CREATE OBJECT mv_host_acl.
        ENDIF.
        TRY.
            lv_host_4_acl = host.
            lv_allowed = mv_host_acl->validate(
              EXPORTING
                iv_hostname         = lv_host_4_acl
                iv_caller_check     = abap_true ).
            IF lv_allowed = abap_false.
              MESSAGE e510(sclnt_http) WITH lv_host_4_acl RAISING http_communication_failure.
            ENDIF.
          CATCH cx_http_client_acl INTO lx_acl_err. " Exception class for HTTP client ACL API
            lv_acl_text = lx_acl_err->get_text( ).
            MESSAGE e513(sclnt_http) WITH lv_acl_text RAISING http_communication_failure.
        ENDTRY.
      ENDIF.

      CALL FUNCTION 'HTTP_WRITE_SC'
        EXPORTING
          mode                     = '2' "HttpCall
          name                     = m_name
          destination_name         = m_destination_name
          host                     = host
          service                  = service
          proxy_host               = proxy_host
          proxy_service            = proxy_service
          proxy_username           = m_proxy_username
          proxy_password           = m_proxy_password
          protocol                 = m_target_scheme
          patch                    = m_patch     " data = data
          trace                    = m_trace
          c_msg                    = c_msg
          timeout                  = m_timeout
          x509_filename            = m_x509filename
          send_and_close           = m_send_and_close
          send_distributed_tracing = l_send_distributed_tracing
          assertion_client         = m_assertion_client
          assertion_system_id      = m_assertion_system_id
          do_no_show_ccert         = m_do_no_show_client_cert
          use_scc                  = l_scc_in_use
        IMPORTING
          ecode                    = m_ecode
          emessage                 = m_emessage
        EXCEPTIONS
          OTHERS                   = 1.
      subrc = sy-subrc.
      IF subrc <> 0 OR m_ecode <> 0.
        m_state = statetype_error.
      ENDIF.
      pf_m_close c_statistic_state 'HTTP Write System Call'. "#EC *

    ENDIF.

* header and body length of request after serialization
    CALL METHOD request->get_serialized_message_length
      IMPORTING
        body_length   = m_request_body_length
        header_length = m_request_header_length.

* update state of object in instance table
    READ TABLE http_client_instances INTO http_client_instance
                                           WITH KEY name = m_name.

    IF sy-subrc = 0.
      http_client_instance-path_translated = request->get_header_field( '~path_translated' ).
      http_client_instance-state = m_state.
      MODIFY TABLE http_client_instances FROM http_client_instance.
    ELSE.
* insert client entry which closed before (disable garbage collection)
      DATA: c_instance TYPE ihttp_client_instance.
      CREATE OBJECT c_instance-client
        EXPORTING
          oref = me.
      c_instance-name   = m_name.
      c_instance-state  = m_state.
      APPEND c_instance TO http_client_instances.
    ENDIF.

    IF subrc <> 0 OR m_ecode <> 0.
      pf_m_close c_statistic_state 'HTTP Send'.             "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*      RAISE http_communication_failure.
    ENDIF.
    pf_m_close c_statistic_state 'HTTP Send'.               "#EC *

  ENDMETHOD.


  METHOD if_http_client~send_sap_assertion_ticket.
*
* with assertion ticket target client and system id are required
*
    IF client    IS INITIAL OR
       system_id IS INITIAL.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 846 RAISING argument_not_found.
*    RAISE argument_not_found.
    ENDIF.

    m_assertion_client = client.
    m_assertion_system_id = system_id.

* Attention: the most resent call of one of the methods SEND_SAP_LOGON_TICKT and SEND_SAP_ASSERTION_TICKET
* shall overwrite the previous settings
    CLEAR m_sso_ticket.

  ENDMETHOD.


  METHOD if_http_client~send_sap_logon_ticket .
    m_sso_ticket = 'X'.
* Attention: the most resent call of one of the methods SEND_SAP_LOGON_TICKT and SEND_SAP_ASSERTION_TICKET
* shall overwrite the previous settings
    CLEAR: m_assertion_client, m_assertion_system_id.
  ENDMETHOD.


  METHOD if_http_client~set_compression.
    DATA: _entity TYPE REF TO cl_http_entity,
          c_msg   TYPE %_c_pointer.
*
* compression only works
* if server can decode gzip documents ('content-encoding')
* otherwise should response with statuscode 415
*

    IF c_compression_supported = co_disabled.
      m_ecode = 104.
      m_emessage = 'ICT_ENOTIMPL'.                          "#EC NOTEXT
      RAISE compression_not_possible.
    ENDIF.

* -- set compression attributes
    _entity ?= request.
    c_msg    = _entity->m_c_msg.
    SYSTEM-CALL ict
     DID
       ihttp_scid_compress_data
     PARAMETERS
       c_msg                         " > c handle
       options                       " > options
       m_ecode.                      " < return code  "#EC CI_SYSTEMCALL

    IF m_ecode <> 0.
      m_ecode = m_ecode + 100.
      m_emessage = 'ICT_ENOTIMPL'.                          "#EC NOTEXT
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 866 RAISING compression_not_possible.
*      RAISE compression_not_possible.
    ENDIF.

* Bernhard setzt dies in seinem Systemcall
*  call method request->set_header_field
*    exporting
*      name  = 'Content-Encoding'
*      value = 'gzip'. "#EC NOTEXT

    IF ( options NE co_compress_none ).
* -- server accepts compression only in relation with HTTP/1.1
      CALL METHOD request->set_header_field
        EXPORTING
          name  = '~server_protocol'
          value = 'HTTP/1.1'.

    ENDIF.
* -- application overwrite the setting of comression
    m_compress = 'X'.

  ENDMETHOD.


  METHOD if_http_client~unescape_url.
    CLASS cl_http_utility DEFINITION LOAD.
    unescaped = cl_http_utility=>unescape_url( escaped = escaped ).


*  call 'ICT_DISPATCH' id 'did'    field 'url_unescape'
*                      id 'source' field escaped
*                      id 'dest'   field unescaped.

  ENDMETHOD.


  METHOD receive_cookie .
* transport of cookie fields
    IF propertytype_accept_cookie = co_disabled.
      EXIT.
    ENDIF.

    DATA: _entity      TYPE REF TO cl_http_entity,
          c_req_msg    TYPE %_c_pointer,
          c_res_msg    TYPE %_c_pointer,
          m_last_error TYPE i,
          null_str     TYPE string.

    DATA: line    TYPE i VALUE 0,
          cookies TYPE tihttpcki.

    CALL METHOD response->get_cookies
      CHANGING
        cookies = cookies.

    DESCRIBE TABLE cookies LINES line.

    IF line = 0.
      EXIT.
    ENDIF.

*
* ICFRECORDER processing
*
    IF NOT m_icfrecorder IS INITIAL.
      DATA: icfrec_field  TYPE ihttp_recorder_field.
      DATA: icfrec_index  TYPE sytabix.
      DATA: l_cookie      TYPE ihttpcki.
      icfrec_index = 0.
* -- find next index
      LOOP AT m_icfrecorder_fields TRANSPORTING NO FIELDS
              WHERE range = ihttp_recorder_field_range_cre.
        ADD 1 TO icfrec_index .
      ENDLOOP.
      ADD 1 TO icfrec_index.

* 'PROPERTYTYPE_ACCEPT_COOKIE'
      icfrec_field-range = ihttp_recorder_field_range_cck.
      icfrec_field-index = icfrec_index.
      icfrec_field-name  = ihttp_recorder_field_name_ccoo.
      icfrec_field-value = propertytype_accept_cookie.
      APPEND icfrec_field TO m_icfrecorder_fields.
      LOOP AT cookies INTO l_cookie.
        icfrec_index = icfrec_index + 1.
        icfrec_field-index = icfrec_index.
        icfrec_field-name = l_cookie-name.
* value can be security relevant e. g. sap-password/MYSAPSSO2/etc.
        CONCATENATE 'domain:' l_cookie-xdomain
                    'path:'   l_cookie-path
                    INTO icfrec_field-value SEPARATED BY space.
        APPEND icfrec_field TO m_icfrecorder_fields.
      ENDLOOP.
      CALL FUNCTION 'ICF_RECORDER_ATTRIBUTES'
        EXPORTING
          action                     = ihttp_icfservice_action_pack
*         from_entries               = ihttp_attributes
          icfrecorder_fields_imp     = m_icfrecorder_fields
*    IMPORTING
*         TO_ENTRIES                 =
        CHANGING
          icfrecord_attributes       = m_icfrecorder-attributes
        EXCEPTIONS
          icf_action_not_supported   = 1
          icf_no_authority           = 2
          icf_incomplete_information = 3
          icf_invalid_attributes     = 4
          OTHERS                     = 5.               "#EC *

      IF sy-subrc = 0.
        MODIFY icfrecorder FROM m_icfrecorder.
*
* avoid db commit in transactional context, e. g. update task, bgRFC context,
* and transactional instance area of shared objects
*
        cl_icf_recorder=>process_db_commit( ).
*     call function 'DB_COMMIT'.
      ENDIF.
    ENDIF.

* -- global accept is set ?
    IF propertytype_accept_cookie = co_prompt AND
       c_sapgui_is_on             = 1.
* -- prompt
      CALL FUNCTION 'HTTP_COOKIE_ACCEPT'
        EXPORTING
          client = me.
    ELSEIF propertytype_accept_cookie = co_event.
* -- Raise IF_HTTP_CLIENT~EVENTKIND_COOKIE
      RAISE EVENT if_http_client~eventkind_handle_cookie
           EXPORTING
            client  = me
            cookies = cookies.

*       call method m_cookie_handler->handle_cookie
*            exporting
*             client  = me
*             cookies = cookies.
*            importing
*             accept_cookie = propertytype_accept_cookie
*             accept_allcookies = propertytype_accept_allcookies.
*
      IF propertytype_accept_cookie = co_prompt AND
         c_sapgui_is_on             = 1.
* -- prompt
        CALL FUNCTION 'HTTP_COOKIE_ACCEPT'
          EXPORTING
            client = me.
      ENDIF.
    ENDIF.


* -- processing of cookies
    IF propertytype_accept_cookie <> co_disabled.
      _entity ?= request.
      c_req_msg = _entity->m_c_msg.
      _entity ?= response.
      c_res_msg = _entity->m_c_msg.

      pf_m_open c_statistic_state 'HTTP Cookie System Call'. "#EC *

      SYSTEM-CALL ict
        DID
          45                  "IctAbScHttpGetCookiesFromResponse
        PARAMETERS
          m_c_cclient         " < client object for cookie
          c_res_msg           " < Response message ptr
          c_req_msg           " < Request  message ptr
          m_target_host       " < domain, m_host
          null_str            " < path (~path_translated)
          m_last_error.       " > return code (integer)  "#EC CI_SYSTEMCALL

      pf_m_close c_statistic_state 'HTTP Cookie System Call'. "#EC *

      IF m_last_error <> 0.
        m_ecode = m_last_error.
        CALL METHOD error_codes=>get_error_text
          EXPORTING
            number = http_processing_failed_error
          IMPORTING
            text   = m_emessage.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_processing_failed.
*        RAISE http_processing_failed.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD recorder.
    DATA: l_rfcsi      TYPE rfcsi.

*  data: dummy   type string.
*        m_client type string,
*        m_language type string,
*        m_password type string,
*        m_trusted  type string.
    DATA: expire_seconds(8) TYPE p.
*  data: sap_recorder type string.
    DATA: m_recorder_failed_logon TYPE icfrecoder_logon.
* calculation of expiration time
    DATA: l_date TYPE sydatum.
    DATA: l_time TYPE syuzeit.
    DATA: l_value(8)  TYPE p.
    DATA: l_day(8)    TYPE p.
    DATA: expiration_days TYPE i.
    DATA: expire_timestamp TYPE timestampl.
    DATA: present_timestamp TYPE timestampl.

* refresh last recorder entry,
* without m_icfrecorder_fields to protocol the history of object
    CLEAR: m_icfrecorder, m_recorder_failed_logon.

    IF component >= ihttp_record_clast_possibility.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 867 RAISING disable_recording.
*      RAISE disable_recording.
    ENDIF.

    m_icfrecorder-trace_level = component.
*
* inheritance of predecessor message id from server call if possible
*
    IF c_last_message_id IS INITIAL                 AND
       cl_icf_recorder=>c_last_message_id IS NOT INITIAL.
      c_last_message_id  = cl_icf_recorder=>c_last_message_id.
    ENDIF.

* my predecessor message
    m_icfrecorder-parent_messageid = c_last_message_id.

* message type 'I' for ICF/Internal
    m_icfrecorder-message_type = 'I'.

* protocol all the activity done on this record
    m_icfrecorder-protocol_action = 'X'.

*   my system id
    m_icfrecorder-system_id    = sy-sysid.
    CALL FUNCTION 'ICF_CREATE_GUID'
      IMPORTING
        id = c_last_message_id.
    m_icfrecorder-message_id       = c_last_message_id.
    m_icfrecorder-caller_messageid = m_icfrecorder-message_id.
    m_parent_message_id            = c_last_message_id.

*
* inheritance of root message id from server call if possible
*
    IF c_root_message_id IS INITIAL.
      IF cl_icf_recorder=>c_root_message_id IS INITIAL.
        c_root_message_id  = m_icfrecorder-message_id.
      ELSE.
        c_root_message_id  = cl_icf_recorder=>c_root_message_id.
      ENDIF.
    ENDIF.

*   my root message id
    m_icfrecorder-root_messageid = c_root_message_id.

* create once per object it's obkject id
    IF m_object_id IS INITIAL.
      m_object_id   = m_icfrecorder-message_id.
    ENDIF.
    m_icfrecorder-object_id = m_object_id.

    m_icfrecorder-object_counter = m_counter.

**   present statistic information
    CALL FUNCTION 'RFC_SYSTEM_INFO'
      IMPORTING
        rfcsi_export = l_rfcsi.
    m_icfrecorder-logon_server = l_rfcsi-rfcdest.
    m_icfrecorder-logon_client = sy-mandt.
    m_icfrecorder-logon_user   = sy-uname.
    m_icfrecorder-logon_language  = sy-langu.

* get owner data, SICF settings have precedence
    IF ( m_icfrecorder-owner_user IS INITIAL )
    AND NOT ( icfattrib_entry-cusername IS INITIAL ).
      m_icfrecorder-owner_server = icfattrib_entry-server.
      m_icfrecorder-owner_client = icfattrib_entry-client.
      m_icfrecorder-owner_user   = icfattrib_entry-cusername.
    ENDIF.
* if there's no SICF setting, then take the runtime information
    IF ( m_icfrecorder-owner_user IS INITIAL )
    AND NOT ( cl_icf_recorder=>c_owner_user IS INITIAL ).
      m_icfrecorder-owner_server = cl_icf_recorder=>c_owner_server.
      m_icfrecorder-owner_client = cl_icf_recorder=>c_owner_client.
      m_icfrecorder-owner_user = cl_icf_recorder=>c_owner_user.
    ENDIF.

    GET TIME STAMP FIELD m_icfrecorder-logon_timestamp.

*
* inheritance of scope message id/nr from server call if possible
*
    IF c_scope_message_id IS INITIAL.
      IF cl_icf_recorder=>c_scope_message_id IS INITIAL.
        CALL FUNCTION 'ICF_CREATE_GUID'
          IMPORTING
            id = c_scope_message_id.
        c_scope_message_nr = 0.
      ELSE.
        c_scope_message_id = cl_icf_recorder=>c_scope_message_id.
        c_scope_message_nr = cl_icf_recorder=>c_scope_message_nr.
      ENDIF.
    ENDIF.

* -- update the caller id/nr for recorder entry (m_icfrecorder)
* -- sending of sap-recoder cookie (inheritance from server object)
    c_scope_message_nr = c_scope_message_nr + 1.
* inheritance of scope message nr to server
    cl_icf_recorder=>c_scope_message_nr = c_scope_message_nr.
    m_icfrecorder-scope_messageid = c_scope_message_id.
    m_icfrecorder-scope_messagenr = c_scope_message_nr.

* inheritance of icfattrib to server side, if did not happen before
    IF cl_icf_recorder=>c_icfattrib IS INITIAL.
      cl_icf_recorder=>c_icfattrib = icfattrib_entry.
    ENDIF.

* inheritance of owner data to server side
    IF ( cl_icf_recorder=>c_owner_user IS INITIAL )
    AND NOT ( m_icfrecorder-owner_user IS INITIAL ).
      cl_icf_recorder=>c_owner_server = m_icfrecorder-owner_server.
      cl_icf_recorder=>c_owner_client = m_icfrecorder-owner_client.
      cl_icf_recorder=>c_owner_user = m_icfrecorder-owner_user.
    ENDIF.

* request connection parameters
    IF m_target_scheme = schemetype_https.
      m_icfrecorder-request_protocol = ihttp_recorder_protocol_https.
    ELSE.
      m_icfrecorder-request_protocol = ihttp_recorder_protocol_http.
    ENDIF.
    m_icfrecorder-request_host = m_target_host.
    m_icfrecorder-request_port = m_target_service.

    m_icfrecorder-reference_tstamp = m_icfrecorder-logon_timestamp.

*-- expireation time of this record
    IF NOT expiration_day IS INITIAL OR
       NOT expiration_time IS INITIAL.
      expire_seconds = ( expiration_day * 86400 ) + expiration_time.
    ELSE.
      SELECT SINGLE expire_timestamp
                        FROM icfrecorder INTO expire_timestamp
                        WHERE message_id   = ihttp_recorder_exp_msgid AND
                              message_type = ihttp_recorder_exp_mstype.
      IF sy-subrc = 0.
        CONVERT TIME STAMP expire_timestamp
                   TIME ZONE ihttp_c_timezone_utc
                   INTO DATE l_date TIME l_time.
*    number of days
        l_day = l_date.
        l_value = ihttp_recorder_exp_date_basis.
*    date in relation to icfrecorder_exp_date_basis
        expiration_days = l_day - l_value.
        expire_seconds = ( expiration_days * 86400 ) + l_time.
      ELSE.
        expire_seconds = ( ihttp_recorder_def_exp_day * 86400 ) +
                         ihttp_recorder_def_exp_time.
      ENDIF.
    ENDIF.

    GET TIME STAMP FIELD present_timestamp.

    m_icfrecorder-expire_timestamp = cl_abap_tstmp=>add(
                                       tstmp = present_timestamp
                                       secs  = expire_seconds ).

    m_icfrecorder-request_path =
        request->get_header_field( '~path_translated' ).
* -- for SICFRECORDER transaction and DB select statements
    TRANSLATE m_icfrecorder-request_path TO LOWER CASE.  "#EC TRANSLANG

*-- record request or authentication
    IF component >= ihttp_record_crequest.
      DATA: l_f_password       TYPE string,
            l_its_password     TYPE string,
            l_h_password       TYPE string,
            l_h_r3auth         TYPE string,
            l_h_authorization  TYPE string,
            l_h_pauthorization TYPE string,
            l_c_sso            TYPE ihttpcki,
            l_c_ssolist        TYPE string.

* -- removing security relevant fields from request
      l_its_password =
         request->get_form_field( name = '~password' ).
      IF NOT l_its_password IS INITIAL.
        request->delete_form_field_secure(
                              name = '~password' ).         "#EC NOTEXT
        m_recorder_failed_logon-password_method =
                                ihttp_recorder_passwd_ffield.
      ENDIF.
      l_f_password =
         request->get_form_field( name = 'sap-password' ).
      IF NOT l_f_password IS INITIAL.
        request->delete_form_field_secure(
                              name = 'sap-password' ).      "#EC NOTEXT
        m_recorder_failed_logon-password_method =
                                ihttp_recorder_passwd_ffield.
      ENDIF.
      l_h_password =
          request->get_header_field( name = 'sap-password' ).
      IF NOT l_h_password IS INITIAL.
        request->delete_header_field_secure(
                                name = 'sap-password' ).    "#EC NOTEXT
        m_recorder_failed_logon-password_method =
                                ihttp_recorder_passwd_hfield.
      ENDIF.

      l_h_r3auth =
         request->get_header_field( name = c_sap_r3auth ).
      IF NOT l_h_r3auth IS INITIAL.
        request->delete_header_field_secure(
                                name = c_sap_r3auth ).      "#EC NOTEXT
        CONCATENATE m_recorder_failed_logon-tickets
                    ihttp_recorder_r3auth_ticket
                    INTO m_recorder_failed_logon-tickets.
      ENDIF.

      l_h_authorization = request->get_header_field(
                                name = 'authorization' ).   "#EC NOTEXT
      IF NOT l_h_authorization IS INITIAL.
        request->delete_header_field_secure(
                                name = 'authorization' ).   "#EC NOTEXT
        m_recorder_failed_logon-password_method =
                          ihttp_recorder_passwd_bauth.
      ENDIF.

      l_h_pauthorization = request->get_header_field(
                     name = 'proxy-authorization' ).        "#EC NOTEXT
      IF NOT l_h_pauthorization IS INITIAL.
        request->delete_header_field_secure(
                     name = 'proxy-authorization' ).        "#EC NOTEXT
      ENDIF.

      request->get_cookie( EXPORTING name  = 'MYSAPSSO2'
                                     path  = '/'
                           IMPORTING value  = l_c_sso-value
                                     domain = l_c_sso-xdomain
                                     expires = l_c_sso-expires
                                     secure  = l_c_sso-secure ).
      IF NOT l_c_sso IS INITIAL.
        request->delete_cookie_secure(
                                name = 'MYSAPSSO2' ).       "#EC NOTEXT
        CONCATENATE m_recorder_failed_logon-tickets
                    ihttp_recorder_sso_ticket
                    INTO m_recorder_failed_logon-tickets.
      ENDIF.
      request->get_cookie( EXPORTING name  = 'sap-ssolist'
                           IMPORTING value = l_c_ssolist ).
      IF NOT l_c_ssolist IS INITIAL.
        CONCATENATE m_recorder_failed_logon-tickets
                    ihttp_recorder_ssorej_ticket
                    INTO m_recorder_failed_logon-tickets.
      ENDIF.

      m_icfrecorder-request = request->to_xstring( ).
*
* -- adding security relevant fields into request, if available
*
      IF NOT l_its_password IS INITIAL.
        request->set_form_field( name  = '~password'        "#EC NOTEXT
                                 value = l_its_password ).
      ENDIF.

      IF NOT l_f_password IS INITIAL.
        request->set_form_field( name  = 'sap-password'     "#EC NOTEXT
                                 value = l_f_password ).
      ENDIF.

      IF NOT l_h_password IS INITIAL.
        request->set_header_field( name  = 'sap-password'   "#EC NOTEXT
                                   value = l_h_password ).
      ENDIF.

      IF NOT l_h_r3auth IS INITIAL.
        request->set_header_field( name  = c_sap_r3auth
                                   value = l_h_r3auth ).
      ENDIF.

      IF NOT l_h_authorization IS INITIAL.
        request->set_header_field( name  = 'authorization'  "#EC NOTEXT
                                   value = l_h_authorization ).
      ENDIF.

      IF NOT l_h_pauthorization IS INITIAL.
        request->set_header_field(
                  name  = 'proxy-authorization'             "#EC NOTEXT
                  value = l_h_pauthorization ).
      ENDIF.

      IF NOT l_c_sso IS INITIAL.
        request->set_cookie( EXPORTING name  = 'MYSAPSSO2'
                                       path  = '/'
                                       value  = l_c_sso-value
                                       domain = l_c_sso-xdomain
                                       expires = l_c_sso-expires
                                       secure  = l_c_sso-secure ).
      ENDIF.
    ENDIF.

    IF m_createtype = createtype_internal.
* message role is 'CL' for Client Local
      m_icfrecorder-message_role = ihttp_recorder_role_clocal.
    ELSE.
* message role is 'CE' for Client External
      m_icfrecorder-message_role = ihttp_recorder_role_cextern.
    ENDIF.

* authentication method
*   m_icfrecorder-logon_method = authentication_method.

*    if stateful = co_enabled.
*      m_icfrecorder-stateful = 'X'.
*    endif.

*
* add attributes
*

* -- add logon entry into attributes
    IF NOT m_recorder_failed_logon IS INITIAL.
      CALL FUNCTION 'ICF_RECORDER_ATTRIBUTES'
        EXPORTING
          action                       = ihttp_icfservice_action_pack
*         from_entries                 = ihttp_attributes
          icfrecorder_failed_logon_imp = m_recorder_failed_logon
*        IMPORTING
*         TO_ENTRIES                   =
        CHANGING
          icfrecord_attributes         = m_icfrecorder-attributes
        EXCEPTIONS
          icf_action_not_supported     = 1
          icf_no_authority             = 2
          icf_incomplete_information   = 3
          icf_invalid_attributes       = 4
          OTHERS                       = 5.              "#EC *
    ENDIF.

    INSERT icfrecorder FROM m_icfrecorder.
*
* avoid db commit in transactional context, e. g. update task, bgRFC context,
* and transactional instance area of shared objects
*
    cl_icf_recorder=>process_db_commit( ).
* call function 'DB_COMMIT'.

  ENDMETHOD.


  METHOD requiresDestinationService.
    DATA: lo_dest_http_ext TYPE REF TO cl_dest_http_ext.
    TRY.
        lo_dest_http_ext ?= cl_dest_factory=>create(
                          name                     = destination
                          lock                     = abap_false
                          suppress_authority_check = abap_true
                        ).
      CATCH cx_root INTO DATA(cx_root).
        RETURN.
    ENDTRY.

    IF lo_dest_http_ext IS INITIAL.
      RETURN.
    ENDIF.

    IF lo_dest_http_ext->authentication NE 'BasicAuthentication' ##NO_TEXT
      AND lo_dest_http_ext->authentication NE 'ClientCertificateAuthentication' ##NO_TEXT
      AND lo_dest_http_ext->comm_arr_uuid IS NOT INITIAL
      AND lo_dest_http_ext->name_in_dest_service IS NOT INITIAL.
      requires = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD send_and_close.
    DATA: subrc TYPE sysubrc.

    IF c_client_kernel_version <= 1.
* functionality is in kernel not supported
      m_ecode    = 1.
      m_emessage = 'HTTP_IS_NOT_SUPPORTED'.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 868 RAISING http_is_not_supported.
*      RAISE http_is_not_supported.
    ENDIF.

* Send and close connection and release ICF allocated memories

    pf_m_open c_statistic_state 'HTTP SendAndClose'.        "#EC *

* set attribute M_SEND_AND_CLOSE = 'X' for HttpCall
    m_send_and_close = 'X'.

    CALL METHOD if_http_client~send
      EXCEPTIONS
        http_communication_failure = 1
        http_invalid_state         = 2
        http_processing_failed     = 3.

    subrc = sy-subrc.
    IF subrc <> 0.
      pf_m_close c_statistic_state 'HTTP SendAndClose'.     "#EC *
    ENDIF.

    IF subrc = 1.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 864 RAISING http_communication_failure.
*          RAISE http_communication_failure.
    ELSEIF subrc = 2.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*          RAISE http_invalid_state.
    ELSEIF subrc = 3.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*        RAISE http_processing_failed.
    ENDIF.


    CALL METHOD if_http_client~close
      EXCEPTIONS
        http_invalid_state = 1.
    subrc = sy-subrc.
    IF subrc <> 0.
      pf_m_close c_statistic_state 'HTTP SendAndClose'.     "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*      RAISE http_invalid_state.
    ENDIF.

    pf_m_close c_statistic_state 'HTTP SendAndClose'.       "#EC *
  ENDMETHOD.


  METHOD send_cookie .
* transport of cookie fields
    DATA: _entity      TYPE REF TO cl_http_entity,
          c_msg        TYPE %_c_pointer,
          m_last_error TYPE i.

    _entity ?= request.
    c_msg = _entity->m_c_msg.
    DATA: null_str TYPE string.

    SYSTEM-CALL ict
      DID
        44                        "IctAbScHttpInsertCookiesToRequest
      PARAMETERS
        m_c_cclient               " < client object for cookie
        m_target_is_secure        " < HTTP (0) /HHTPS (1)
        m_target_host             " < host, m_host
        m_target_host             " < domain, m_host
        null_str                  " < path (~path_translated)
        c_msg                     " < Request ptr to object, uri
        m_last_error.             " > return code (integer)  "#EC CI_SYSTEMCALL

    IF m_last_error <> 0.
      m_ecode = m_last_error.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = http_processing_failed_error
        IMPORTING
          text   = m_emessage.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 844 RAISING http_processing_failed.
*      RAISE http_processing_failed.
    ENDIF.
  ENDMETHOD.


  METHOD set_apc_det_client_epp_root_id.
    m_epp_root_context_id = i_root_context_id.
  ENDMETHOD.


  METHOD set_oauth2c_info.

    DATA: ls_oa2c_info TYPE oa2c_icf_interface.
    ls_oa2c_info = io_oa2c_client->get_oa2c_icf_interface( ).

    CALL METHOD cl_icf_plugin_session_rt=>_set_oa2c_info
      EXPORTING
        oa2c_info = ls_oa2c_info
        name      = m_name
      IMPORTING
        rc        = r_returncode.

    IF ( r_returncode = 0 ) AND ( m_oauth_info_is_set = abap_false ) .
      m_patch = m_patch + 8.  "PATCH_OAUTH2C
      m_oauth_info_is_set = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD set_oauth2c_info_ext.
    DATA: ls_oa2c_info_ext TYPE oa2c_icf_interface_ext.
    ls_oa2c_info_ext = io_oa2c_client->get_oa2c_icf_interface_ext( ).

    CALL METHOD cl_icf_plugin_session_rt=>_set_oa2c_info_ext
      EXPORTING
        oa2c_info_ext = ls_oa2c_info_ext
        name          = m_name
      IMPORTING
        rc            = r_returncode.
  ENDMETHOD.


  METHOD set_oauth_token.
    DATA: lo_oauth_client TYPE REF TO if_oauth2_client,
          lx_oauth_ex     TYPE REF TO cx_oa2c.

    IF io_http_client IS BOUND.
      CLEAR io_http_client->oauth_last_err_txt.
    ENDIF.

    TRY.
        lo_oauth_client = cl_oauth2_client=>create( i_profile        = i_oauth_profile
                                                    i_configuration  = i_oauth_config ).

        lo_oauth_client->set_token_automatic( io_http_client = io_http_client
                                              i_param_kind   = i_param_kind
                                              i_force_oauth2_request = i_force_oauth2_request ).

      CATCH cx_oa2c_config_not_found cx_oa2c_config_profile_assign cx_oa2c_config_profile_multi
        INTO lx_oauth_ex.
        IF io_http_client IS BOUND.
          io_http_client->oauth_last_err_txt = lx_oauth_ex->get_text( ).
        ENDIF.
        RAISE oa2c_invalid_config.
      CATCH cx_oa2c_missing_authorization INTO lx_oauth_ex.
        IF io_http_client IS BOUND.
          io_http_client->oauth_last_err_txt = lx_oauth_ex->get_text( ).
        ENDIF.
        RAISE oa2c_missing_authorization.
      CATCH cx_oa2c_invalid_scope INTO lx_oauth_ex.
        IF io_http_client IS BOUND.
          io_http_client->oauth_last_err_txt = lx_oauth_ex->get_text( ).
        ENDIF.
        RAISE oa2c_invalid_scope.
      CATCH cx_oa2c_invalid_grant INTO lx_oauth_ex.
        IF io_http_client IS BOUND.
          io_http_client->oauth_last_err_txt = lx_oauth_ex->get_text( ).
        ENDIF.
        RAISE oa2c_invalid_grant.
      CATCH cx_oa2c_invalid_request cx_oa2c_invalid_client
            cx_oa2c_invalid_parameters INTO lx_oauth_ex.
        IF io_http_client IS BOUND.
          io_http_client->oauth_last_err_txt = lx_oauth_ex->get_text( ).
        ENDIF.
        RAISE oa2c_invalid_parameters.
      CATCH cx_oa2c INTO lx_oauth_ex.
        IF io_http_client IS BOUND.
          io_http_client->oauth_last_err_txt = lx_oauth_ex->get_text( ).
        ENDIF.
        RAISE oa2c_set_token_error.
    ENDTRY.
  ENDMETHOD.


  METHOD statistic .
    DATA: time TYPE i.
    pf_m_open c_statistic_state 'HTTP Statistic'.           "#EC *

    IF start = 1.
* -- client entry
      IF m_single_stat-path IS INITIAL.
        m_single_stat-path =
            client->request->get_header_field( '~path_translated' ).
        CONCATENATE m_target_host ':' m_target_service
                                INTO m_single_stat-dest.
      ENDIF.

* -- dest entry
      IF m_sum_stat-dest IS INITIAL.
        m_sum_stat-dest = m_single_stat-dest.
      ENDIF.

      m_single_stat-calltime = m_timer->get_runtime( ).
* get run time field m_single_stat-calltime.

    ELSE.
      DATA: remote_exe TYPE string.
      DATA: stat_table TYPE TABLE OF string.
      DATA: e_time          TYPE string,
            dummy           TYPE string,                    "#EC NEEDED
            l_time          TYPE f,
            remote_exec(64) TYPE c.

*
* single record and sum statistics in miliseconds
*
      time = m_timer->get_runtime( ).
* get run time field time.
      m_single_stat-calltime = ( time - m_single_stat-calltime ) / 1000.
      m_sum_stat-calltime = m_sum_stat-calltime + m_single_stat-calltime.
      remote_exe = client->response->get_header_field( 'sap-statistic' ).
      IF NOT remote_exe IS INITIAL.
        remote_exec = remote_exe.
        pf_m_open  c_statistic_state remote_exec.           "#EC *
        pf_m_close c_statistic_state remote_exec.           "#EC *

        SPLIT remote_exe AT ',' INTO TABLE stat_table.

*   -- evaluation of remote times
        LOOP AT stat_table INTO remote_exe.
          IF remote_exe CS 'e='.
*   -- execution time of handler
            SPLIT remote_exe AT 'e=' INTO dummy e_time.
            IF NOT e_time IS INITIAL.
              l_time = e_time.
*   -- plausi check
              IF l_time < m_single_stat-calltime.
                m_single_stat-rexetime = l_time.
              ENDIF.

              IF l_time < m_sum_stat-calltime.
                m_sum_stat-rexetime = m_sum_stat-rexetime + l_time.
              ENDIF.
            ENDIF.
          ELSEIF remote_exe CS 't='.
*   total execution time of request [start read, start write]
            SPLIT remote_exe AT 't=' INTO dummy e_time.
            IF NOT e_time IS INITIAL.
              l_time = e_time.
*     -- plausi check
              IF l_time < m_single_stat-calltime.
                m_single_stat-rtotaltime = l_time.
              ENDIF.

              IF l_time < m_sum_stat-calltime.
                m_sum_stat-rtotaltime = m_sum_stat-rtotaltime + l_time.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.

*  if m_sum_stat-dest is initial.
*    m_sum_stat-calls = 1.
*    call function 'PF_INSERT_HTTP_CLI_DEST_REC'
*      exporting
*        http_client_dest_rec      = m_sum_stat
*     exceptions
*        others                     = 0.
**       pf_insert_rec_failed       = 1
**       others                     = 2.
*  else.
*    m_sum_stat-calls = m_sum_stat-calls  + 1.
*    call function 'PF_UPDATE_HTTP_CLI_DEST_REC'
*      exporting
*        http_client_dest_rec      = m_sum_stat
*     exceptions
*       others                     = 0.
**       pf_update_rec_failed       = 1
**       others                     = 2.
*  endif.
*
*  call function 'PF_INSERT_HTTP_CLI_REC'
*    exporting
*      http_client_rec            = m_single_stat
*   exceptions
*      others                     = 0.
**     pf_insert_rec_failed       = 1
**     others                     = 2.
    ENDIF.

    pf_m_close c_statistic_state 'HTTP Statistic'.          "#EC *

  ENDMETHOD.


  METHOD _append_string_to_xstring .

    CALL 'ICT_DISPATCH'                                   "#EC CI_CCALL
      ID 'did'    FIELD 'append_string_to_xstring'          "#EC NOTEXT
      ID 'source' FIELD source                              "#EC NOTEXT
      ID 'dest'   FIELD dest.                               "#EC NOTEXT

  ENDMETHOD.


  METHOD _append_xstring_to_string .

    CALL 'ICT_DISPATCH'                                   "#EC CI_CCALL
      ID 'did'    FIELD 'append_xstring_to_string'          "#EC NOTEXT
      ID 'source' FIELD source                              "#EC NOTEXT
      ID 'dest'   FIELD dest.                               "#EC NOTEXT

  ENDMETHOD.


  METHOD if_http_client~escape_url.
    CLASS cl_http_utility DEFINITION LOAD.
    escaped = cl_http_utility=>escape_url( unescaped = unescaped ).
* call method cl_http_utility=>
*  call 'ICT_DISPATCH' id 'did'    field 'url_escape'
*                      id 'source' field unescaped
*                      id 'dest'   field escaped.

  ENDMETHOD.


  METHOD authentication.
* ...
    DATA: auth       TYPE string,
          basic_auth TYPE string,
          dummy      TYPE string.


    pf_m_open c_statistic_state 'HTTP Authentication'.      "#EC NOTEXT

    IF ( proxy_authentication IS INITIAL ).
      IF NOT ( m_username IS INITIAL ).
        IF ( m_is_password_encrypted EQ abap_true ).
          IF m_patch <> 1 AND
             m_patch <> 3 AND
             m_patch <> 5 AND
             m_patch <> 7.
            m_patch = m_patch + 1. "PATCH_SERVER_AUTHENTICATION
          ENDIF.

*
* do not use anymore @ as delimator for basic authorization procedure, as this field could be part of
* RFC destination name and therefore part of secure storage id. This will lead to problems for identifying
* the exact secure storage id. Use explicit header fields, i.e. 'sap-icf-authorization' and
* 'sap-icf-proxy-authorization' to address username:secure_storage_id for authorization's procedures.
*
* check the kernel version to ensure that the the kernel is able to handle the new header fields, i.e.
* 'sap-icf-authorization' and 'sap-icf-proxy-authorization'
*
          IF c_client_kernel_version >= 3.
            CONCATENATE m_username ':' m_password INTO auth. "#EC NOTEXT
            CALL METHOD request->set_header_field
              EXPORTING
                name  = if_http_header_fields_sap=>sap_icf_authorization
                value = auth.
          ELSE.
* insert additional @ which will be replaced in kernel by the password maintained in the RFC destination
            CONCATENATE '@@' m_username ':' m_password  "20 @'s as buffer
                        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
                        '@@@@@@@@@@@@@@@@@@@@' INTO auth.

            CONCATENATE 'Basic' auth                        "#EC NOTEXT
               INTO basic_auth SEPARATED BY space.

            CALL METHOD request->set_header_field
              EXPORTING
                name  = 'Authorization'                       "#EC NOTEXT
                value = basic_auth.
            "  raise encodeing_error.
          ENDIF.

        ELSEIF ( m_is_password_encrypted EQ abap_false ).
          CLEAR: auth, basic_auth.
          CONCATENATE m_username ':' m_password INTO auth.
          basic_auth = cl_http_utility=>if_http_utility~encode_base64( unencoded = auth ).
          CONCATENATE 'Basic' basic_auth                    "#EC NOTEXT
             INTO basic_auth SEPARATED BY space.
          CALL METHOD request->set_header_field
            EXPORTING
              name  = 'Authorization'                         "#EC NOTEXT
              value = basic_auth.

        ENDIF.

      ENDIF.

      IF NOT m_client IS INITIAL.
        dummy = m_client.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'SAP-Client'                              "#EC NOTEXT
            value = dummy.
      ENDIF.

      IF NOT m_language IS INITIAL.
        dummy = m_language.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'SAP-Language'                            "#EC NOTEXT
            value = dummy.
      ENDIF.

    ELSEIF NOT ( m_proxy_username IS INITIAL ).
* Add proxy authentication to header fields
      IF ( m_is_proxy_password_encrypted EQ abap_true ).

        CLEAR: auth, basic_auth.

        IF m_patch <> 2 AND
           m_patch <> 3 AND
           m_patch <> 6 AND
           m_patch <> 7.
          m_patch = m_patch + 2. "PATCH_PROXY_AUTHENTICATION
        ENDIF.

* check the kernel version to ensure that the the kernel is able to handle the new header fields, i.e.
* 'sap-icf-authorization' and 'sap-icf-proxy-authorization'
*
        IF c_client_kernel_version >= 3.
          CONCATENATE m_proxy_username ':' m_proxy_password INTO auth. "#EC NOTEXT
          CALL METHOD request->set_header_field
            EXPORTING
              name  = if_http_header_fields_sap=>sap_icf_proxy_authorization
              value = auth.
        ELSE.
* insert additional @ which will be replaced in kernel by the password maintained in the RFC destination
          CONCATENATE '@@' m_proxy_username
                       ':' m_proxy_password "20 @ as buffer
                      '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
                      '@@@@@@@@@@@@@@@@@@@@' INTO auth.

          CONCATENATE 'Basic' auth                          "#EC NOTEXT
             INTO basic_auth SEPARATED BY space.
          CALL METHOD request->set_header_field
            EXPORTING
              name  = 'Proxy-Authorization'                   "#EC NOTEXT
              value = basic_auth.
          "  raise encodeing_error.
        ENDIF.
      ELSEIF ( m_is_proxy_password_encrypted EQ abap_false ).
        CLEAR: auth, basic_auth.
        CONCATENATE m_proxy_username ':' m_proxy_password INTO auth.
        basic_auth = cl_http_utility=>if_http_utility~encode_base64( unencoded = auth ).
        CONCATENATE 'Basic' basic_auth                      "#EC NOTEXT
           INTO basic_auth SEPARATED BY space.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'Proxy-Authorization'                     "#EC NOTEXT
            value = basic_auth.

      ENDIF.

    ENDIF.

    pf_m_close c_statistic_state 'HTTP Authentication'.     "#EC NOTEXT

  ENDMETHOD.


  METHOD check_call_stack.
    DATA: lt_call_stack          TYPE abap_callstack.
*
* check in case of using start service SSLID '<SPKI>' the permission via call stack
* only class CO_SAPCONTROL_PROXY is permitted  to access start service using SSL ID <SPKI>
* for authentication. This ID cannot be used in SM59 HTTP destination.
*

    r_successful = abap_false.
* determine the whole callstack, as early as possible for the error and exception handling
    CALL FUNCTION 'SYSTEM_CALLSTACK'
      IMPORTING
        callstack = lt_call_stack.

* check the availibility of the class CO_SAPCONTROL_PROXY
    LOOP AT lt_call_stack TRANSPORTING NO FIELDS WHERE mainprogram = 'CO_SAPCONTROL_PROXY===========CP'.
      r_successful = abap_true.
      EXIT.
    ENDLOOP.

* check for report SSFPKITEST4
    READ TABLE lt_call_stack WITH KEY blockname = 'SSFC_CHECK_SYSTEMPKI' TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      r_successful = abap_true.
      EXIT.
    ENDIF.

  ENDMETHOD.


  METHOD class_constructor .
    DATA: c_ecode TYPE i.

* initially the user is not authenticated
    DATA(bo_status) = cl_abap_behv_aux=>get_current_handler_kind( ).

    IF bo_status = space.
      CALL 'RFCControl' ID 'CODE' FIELD '?'.                "#EC *
      IF sy-subrc = 0.
        c_sapgui_is_on = 1.
      ELSE.
        c_sapgui_is_on = 0.
      ENDIF.
    ELSE.
      c_sapgui_is_on = 0.
    ENDIF.


    c_sap_r3auth = 'SAP-R3Auth'.                            "#EC NOTEXT


* Is plugin available
    CALL FUNCTION 'TH_PLUGINS_ACTIVE'
      IMPORTING
        http_active  = c_schemetype_http_active
        https_active = c_schemetype_https_active.

* manchmal liefer der Aufruf nicht die richtige Antwort
    IF c_schemetype_http_active = 0.
      CALL FUNCTION 'TH_GET_PLUGIN_INFO'
        EXPORTING
          protocol         = schemetype_http
          local            = 0
*       IMPORTING
*         NAME             =
*         HOST             =
*         SERVICE          =
        EXCEPTIONS
          no_plugin_active = 1
          internal_error   = 2
          OTHERS           = 3.
      IF sy-subrc = 0.
        c_schemetype_http_active = 1.
      ELSE.
        c_schemetype_http_active = 0.
      ENDIF.
    ENDIF.

    IF c_schemetype_https_active = 0.
      CALL FUNCTION 'TH_GET_PLUGIN_INFO'
        EXPORTING
          protocol         = schemetype_https
          local            = 0
*       IMPORTING
*         NAME             =
*         HOST             =
*         SERVICE          =
        EXCEPTIONS
          no_plugin_active = 1
          internal_error   = 2
          OTHERS           = 3.

      IF sy-subrc = 0.
        c_schemetype_https_active = 1.
      ELSE.
        c_schemetype_https_active = 0.
      ENDIF.
    ENDIF.

* Version number of Client in Kernel
    CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'k'                 "#EC *
     ID 'ClientKernelVersion'     FIELD c_client_kernel_version "#EC NOTEXT
     ID 'TraceLevel'              FIELD c_trace_level       "#EC NOTEXT
     ID 'ClientRecorderLevel'     FIELD c_accept_client_recorder_level "#EC NOTEXT
     ID 'ClientProfileLevel'      FIELD c_accept_client_profile_level. "#EC NOTEXT

* Is Taskhandler statistic active ?
    CALL FUNCTION 'TH_GET_KERNEL_STATISTIC'
      IMPORTING
        statistic = c_statistic_state.

    SYSTEM-CALL ict                                  "#EC CI_SYSTEMCALL
     DID
       ihttp_scid_compress_supported
     PARAMETERS
       c_ecode.                    " < return code
    IF c_ecode = 0 AND
       sy-subrc = 0.
      c_compression_supported = co_enabled.
    ELSE.
      c_compression_supported = co_disabled.
    ENDIF.

    mv_valid_url_regex = NEW cl_abap_regex(
      pattern       = '^(((http|https)(:\/\/)).*)+$'
      ignore_case   = abap_true
      no_submatches = abap_true
    ).

  ENDMETHOD.


  METHOD close_connection.

    IF m_state = statetype_close.
      m_ecode = http_invalid_state_error.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = m_ecode
        IMPORTING
          text   = m_emessage.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 848 RAISING http_invalid_state.
*    RAISE http_invalid_state.
    ENDIF.

    pf_m_open c_statistic_state 'HTTP Close Connection'.    "#EC *
    m_state = statetype_close.

    IF m_createtype <> createtype_internal.
      CALL 'RFCControl' ID 'CODE' FIELD 't'               "#EC CI_CCALL
                        ID 'HTTP' FIELD 'C'
                        ID 'NAME' FIELD m_name.

      m_ecode = sy-subrc.
      IF m_ecode <> 0.
*        CALL FUNCTION 'HTTP_GET_ERRORCODE'
*          EXPORTING
*            errorcode = m_ecode
*          IMPORTING
*            errortext = m_emessage
*          EXCEPTIONS
*            OTHERS    = 0.
*                invalid_errorcode = 1
*                others            = 2.
*      if sy-subrc <> 0.
*      endif.
        CALL METHOD error_codes=>get_error_text
          EXPORTING
            number = m_ecode
          IMPORTING
            text   = m_emessage.

        m_state = statetype_error.
      ENDIF.
    ENDIF.

*
* remove client object from internal table for garbage collector
*
    DELETE http_client_instances WHERE name = m_name.

    pf_m_close c_statistic_state 'HTTP Close Connection'.   "#EC *

  ENDMETHOD.


  METHOD constructor .
* create a request object
    DATA: http_request   TYPE REF TO cl_http_request,
          lv_param_value TYPE string.

    propertytype_logon_popup   = co_enabled.
    propertytype_redirect        = co_enabled.
    propertytype_accept_cookie  = co_disabled.
    propertytype_apply_sproxy   = co_enabled.
* send accept_encoding: gzip to the partner
    propertytype_accept_compress = co_enabled.

* Messung mit hoher Auflösung
    m_timer = cl_abap_runtime=>create_hr_timer( ).

* setting of header info only once (in send method)
    m_already_processed      = 0.

* internal HTTP processing
    m_create_internal        = 0.

    m_oauth_info_is_set = abap_false.

    CREATE OBJECT http_request.
    request = http_request.

* create a response object
    DATA: http_response TYPE REF TO cl_http_response.

    CREATE OBJECT http_response.
    response = http_response.

    CLEAR: m_host, m_service, m_client, m_password, m_username,
           m_language, m_ecode, m_emessage.

* the resquest object get its associated c mgs here:
    DATA: c_msg TYPE %_c_pointer.
    DATA: m_last_error TYPE i.

    SYSTEM-CALL ict                                  "#EC CI_SYSTEMCALL
      DID
        ihttp_scid_create_message
      PARAMETERS
        1                              " > message type (1 = requ)
        c_msg                          " < c handle
        m_last_error.                  " < return code

    IF m_last_error <> 0.
      m_ecode    = m_last_error.
      m_emessage = 'CREATE_MESSAGE_FAILED'.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 849 RAISING create_message_failed.
*    RAISE create_message_failed.
    ENDIF.

    http_request->set_c_msg( c_msg ).

* create cookie proxy object for the client
    SYSTEM-CALL ict                                  "#EC CI_SYSTEMCALL
       DID
         42                                 "IctAbScHttpCreateClient
       PARAMETERS
         m_c_cclient                        " > client object for cookie
         m_last_error.                      " > return code

    IF m_last_error <> 0.
      m_ecode    = m_last_error.
      m_emessage = 'CREATE_MESSAGE_FAILED'.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 849 RAISING create_message_failed.
*    RAISE create_message_failed.
    ENDIF.

    cl_spfl_profile_parameter=>get_value(
      EXPORTING
        name = 'http/intticket/mode'                        "#EC NOTEXT
      IMPORTING
        value = lv_param_value ).
    IF lv_param_value IS NOT INITIAL.
      m_intticket_mode = lv_param_value.
    ELSE.
      m_intticket_mode = 0.
    ENDIF.

  ENDMETHOD.


  METHOD create.
    DATA: client_obj TYPE REF TO cl_http_client.
    DATA: c_instance TYPE ihttp_client_instance.
    DATA: subrc  TYPE sysubrc.
    DATA: l_pse_filename TYPE SSFPSENAME.

    IF ( host IS INITIAL ).
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 239 RAISING argument_not_found.
*    raise argument_not_found.
    ENDIF.
    IF scheme <> schemetype_http AND
       scheme <> schemetype_https.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 834 RAISING argument_not_found.
*    RAISE argument_not_found.
    ENDIF.

    pf_m_open c_statistic_state 'HTTP Create'.              "#EC *

    IF service IS INITIAL.
      " remark: support of SAProuter string in host segment for TCP Socket connections !
      " do not add any default ports in case of SAProuter connection parameter
      IF strlen( host ) > 3 AND host(3) NE '/H/'.
        IF scheme = schemetype_http.
          service = '80'.
        ELSE.
          service = '443'.
        ENDIF.
      ENDIF.
    ELSE.
* check validity of port number (16bit Integer)
      IF ( strlen( service ) GT 5 )
      OR ( service CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.
    ENDIF.

* Is plugin available
    IF scheme = schemetype_http AND
       c_schemetype_http_active = 0.
      pf_m_close c_statistic_state 'HTTP Create'.           "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING plugin_not_active.
*    RAISE plugin_not_active.
    ELSEIF scheme = schemetype_https AND
           c_schemetype_https_active = 0.
      pf_m_close c_statistic_state 'HTTP Create'.           "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING plugin_not_active.
      RAISE plugin_not_active.
    ENDIF.

* Erzeuge der Interface-Referenz
    CREATE OBJECT client_obj
      EXCEPTIONS
        create_message_failed = 1.
    IF sy-subrc <> 0.
      pf_m_close c_statistic_state 'HTTP Create'.           "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 849 RAISING internal_error.
*    RAISE internal_error.
    ENDIF.

    client ?= client_obj.
    client_obj->m_host           = host.
    client_obj->m_target_host    = host.
    client_obj->m_service        = service.
    client_obj->m_target_service = service.

    IF NOT proxy_host IS INITIAL.
      client_obj->m_is_special_proxy_configured = abap_true.
      client_obj->m_proxy_host = proxy_host.
* check validity of proxy port number (16bit Integer)
      IF ( strlen( proxy_service ) GT 5 )
      OR ( proxy_service CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 835 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.
      client_obj->m_proxy_service  = proxy_service.
    ENDIF.

    client_obj->m_scheme         = scheme.
    client_obj->m_target_scheme  = scheme.
    client_obj->m_createtype     = createtype_create.

    pf_m_open c_statistic_state 'HTTP Create TID'.          "#EC *
    CALL FUNCTION 'ICF_CREATE_GUID'
      IMPORTING
        id = m_connection.
    pf_m_close c_statistic_state 'HTTP Create TID'.         "#EC *

    IF m_connection IS INITIAL.
      CONCATENATE host ':' service '@' m_connection
                                         INTO client_obj->m_name.
      CONDENSE client_obj->m_name.
    ELSE.
      client_obj->m_name = m_connection.
    ENDIF.
*  len = strlen( client_obj->m_name ).
** -- is name larger than the key space -> GUID first to build the key
*  if len > 60.
*    clear client_obj->m_name.
*    concatenate m_connection '@' target
*                                      into client_obj->m_name.
*  endif.
    client_obj->m_client_id = client_obj->m_name.
    client_obj->m_state  = statetype_initial.

* Is secure communication, for transport of cookie data
    IF scheme = schemetype_https.
      client_obj->m_is_secure = 1.
    ELSE.
      client_obj->m_is_secure = 0.
    ENDIF.

    client_obj->m_target_is_secure = client_obj->m_is_secure.

    client_obj->m_sslapplic    = ssl_id.

* Ermittlung des Filenamen bei SSL-Konfiguration
    IF scheme = schemetype_https AND
       NOT ( client_obj->m_sslapplic IS INITIAL ).

* check in case of using start service SSLID '<SPKI>' the permission via call stack
      IF ( '<SPKI>' = client_obj->m_sslapplic ).
        IF client_obj->check_call_stack( ) = abap_false.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 836 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.
      ENDIF.

*
* username and client number for mapping of client certificate at R/3
*
      IF ( 'ANONYM' <> client_obj->m_sslapplic ).
        client_obj->m_sap_username = sap_username.
        client_obj->m_sap_client   = sap_client.
      ENDIF.

      pf_m_open c_statistic_state 'HTTP PSE Parameter'.     "#EC *

      CALL FUNCTION 'SSFPSE_PARAMETER'
        EXPORTING
          context         = 'SSLC'
          applic          = client_obj->m_sslapplic
        IMPORTING
*         FALLBACK        =
*         KEY             =
*         HOST            =
*         INSTANCEID      =
         PSENAME         = l_pse_filename
*          profile         = client_obj->m_x509filename
*         ID              =
*         SIGNED          =
*         DATALEN         =
        EXCEPTIONS
          pse_not_distrib = 1
          pse_not_found   = 2
          OTHERS          = 3.
      subrc = sy-subrc.
      client_obj->m_x509filename = l_pse_filename.
      pf_m_close c_statistic_state 'HTTP PSE Parameter'.    "#EC *

      IF subrc <> 0.
        pf_m_close c_statistic_state 'HTTP Create'.         "#EC *
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 851 RAISING argument_not_found.
*        RAISE argument_not_found.
      ENDIF.
    ELSEIF scheme = schemetype_http.
*
* Remark: clear all HTTPS relevant fields in case of HTTP communication. This is necessary
*         since a redirect from HTTP to HTTPS protocol could mistakenly reuse the HTTPS
*         attributes, e.g. SSL context, ID.
*
      CLEAR: client_obj->m_sslapplic, client_obj->m_x509filename.
    ENDIF.

    IF ssl_id IS SUPPLIED AND client_obj->m_sslapplic IS NOT INITIAL.
      IF do_not_use_client_cert IS SUPPLIED.
        IF do_not_use_client_cert = abap_true.
          client_obj->m_do_no_show_client_cert = 'X'.
        ELSE.
          client_obj->m_do_no_show_client_cert = ' '.
        ENDIF.
      ENDIF.
    ENDIF.


    CREATE OBJECT c_instance-client
      EXPORTING
        oref = client_obj.
    c_instance-name   = client_obj->m_name.
    c_instance-state  = client_obj->m_state.
    APPEND c_instance TO http_client_instances.
    do_garbage_collection( ).
    pf_m_close c_statistic_state 'HTTP Create'.             "#EC *
  ENDMETHOD.


  METHOD createFromDestinationService.
    DATA: lo_dest_http_ext         TYPE REF TO cl_dest_http_ext,
          lo_badi_rfc_dest         TYPE REF TO badi_rfc_dest_provider,
          ls_http_destination_data TYPE if_rfc_dest_provider_plugin=>http_destination_data.
    TRY.
        lo_dest_http_ext ?= cl_dest_factory=>create(
                          name                     = destination
                          lock                     = abap_false
                          suppress_authority_check = abap_true
                        ).
      CATCH cx_root.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 842 RAISING internal_error.
*        RAISE internal_error.
    ENDTRY.

    IF lo_dest_http_ext IS INITIAL.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 842 RAISING internal_error.
*    RAISE internal_error.
    ENDIF.

    create_by_cloud_destination(
      EXPORTING
        i_name                   = lo_dest_http_ext->name_in_dest_service
        i_comm_arr_uuid          = lo_dest_http_ext->comm_arr_uuid
*        i_service_instance_name  =
      RECEIVING
        client                   = client
    exceptions
        argument_not_found = 1
        destination_not_found = 2
        destination_no_authority = 3
        plugin_not_active = 4
        internal_error = 5 ).
      if sy-subrc <> 0.
        if sy-subrc eq 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
        elseif sy-subrc eq 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 852 RAISING destination_not_found.
        elseif sy-subrc eq 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 854 RAISING destination_no_authority.
        elseif sy-subrc eq 4.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 069 RAISING plugin_not_active.
        elseif sy-subrc eq 5.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 842 RAISING internal_error.
        endif.
      endif.
  ENDMETHOD.


  METHOD create_by_cloud_destination.
    DATA: lo_badi_rfc_dest         TYPE REF TO badi_rfc_dest_provider,
          ls_http_destination_data TYPE if_rfc_dest_provider_plugin=>http_destination_data.

    "dont check for initial values, as default destination service will not require anything to be passed other than the destination name

    GET BADI lo_badi_rfc_dest.
    TRY.
        CALL BADI lo_badi_rfc_dest->get_dest_data_http
          EXPORTING
            i_name                  = i_name
            i_comm_arr_uuid         = i_comm_arr_uuid
            i_service_instance_name = i_service_instance_name
          IMPORTING
            data                    = ls_http_destination_data.
      CATCH cx_rfc_dest_provider_error.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 852 RAISING destination_not_found.
*        RAISE destination_not_found.
    ENDTRY.

    IF cl_http_utility=>is_valid_url( url = ls_http_destination_data-url white_pattern = mv_valid_url_regex ).
      cl_http_client=>create_by_url(
        EXPORTING
          url                    = ls_http_destination_data-url
          ssl_id                 = ls_http_destination_data-pse
          use_scc                = ls_http_destination_data-use_scc
          scc_location_id        = ls_http_destination_data-scc_location_id
          do_not_use_client_cert = boolc( ls_http_destination_data-use_certificate_logon IS INITIAL )
          sap_client             = ls_http_destination_data-sap_client
        IMPORTING
          client                 = client
        EXCEPTIONS
          argument_not_found     = 1
          plugin_not_active      = 2
          internal_error         = 3
          OTHERS                 = 4
      ).
      IF sy-subrc <> 0.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 841 RAISING internal_error.
*      RAISE internal_error. "create by url failed. Assumption: In case of valid url it should not fail? Therefore throw internal error.
      ENDIF.
    ELSE.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 069 RAISING plugin_not_active.
*    RAISE plugin_not_active. "URL is not valid. The information comes from the destination service. Therefore simply the user input is incorrect. Is plugin_not_active the correct error?
    ENDIF.

    IF ls_http_destination_data-sap_client IS NOT INITIAL.
      DATA: dummy TYPE string.
      dummy = ls_http_destination_data-sap_client.
      CALL METHOD client->request->set_header_field
        EXPORTING
          name  = 'SAP-Client'                          "#EC NOTEXT
          value = dummy.
    ENDIF.

    " Set Authorization Header
    IF lines( ls_http_destination_data-authtokens ) GE 1.
      DATA(lv_auth_type) =  ls_http_destination_data-authtokens[ 1 ]-type.
      DATA(lv_auth_comp) = ls_http_destination_data-authtokens[ 1 ]-type.
      TRANSLATE lv_auth_comp TO LOWER CASE.
      IF lv_auth_comp = 'bearer'. ##NO_TEXT
        lv_auth_type = 'Bearer'. ##NO_TEXT
      ENDIF.
      SYSTEM-CALL DEBUGGER SET PROTECTED PATH ON.
      TRY.
          DATA(lo_deycrypt_api) = cl_a4c_crypt_util=>get_instance( ).
          DATA(lv_decrypted_token_value) = lo_deycrypt_api->decrypt_base64( iv_encrypted = ls_http_destination_data-authtokens[ 1 ]-value ).
        CATCH cx_a4c_fault. "decryption failed, just set pw as received from destination service
          lv_decrypted_token_value = ls_http_destination_data-authtokens[ 1 ]-value.
      ENDTRY.
      client->request->set_header_field(
      EXPORTING
        name    = if_http_header_fields=>authorization
        value   = lv_auth_type && ` ` && lv_decrypted_token_value
      ).
      CLEAR lv_decrypted_token_value.
      SYSTEM-CALL DEBUGGER SET PROTECTED PATH OFF.
    ENDIF.

    " Enable Cookie Handling per Default
    client->propertytype_accept_cookie = if_http_client=>co_enabled.

    DATA lv_jwt_token TYPE string.
    CALL BADI lo_badi_rfc_dest->get_jwt
      IMPORTING
        jwt = lv_jwt_token.
    IF lv_jwt_token IS NOT INITIAL.
      IF client->is_scc_in_use( ) = abap_true AND ls_http_destination_data-authentication = if_rfc_dest_provider_plugin=>user_propagation.
        client->request->set_header_field(
          EXPORTING
            name  = 'SAP-Connectivity-Authentication' ##NO_TEXT
            value = |Bearer { lv_jwt_token }| ##NO_TEXT
        ).
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD create_by_destination.
*  taskhandler statistic macros
*  include perfincl.

    DATA: l_rfcdisplay TYPE rfcdisplay.
    DATA: client_obj TYPE REF TO cl_http_client.
    DATA: c_instance TYPE ihttp_client_instance.
    DATA: target TYPE string.                               "#EC NEEDED
    DATA: service TYPE plg_srv,
          host    TYPE plg_host,
          dest    TYPE rfcdest,
          subrc   TYPE sysubrc,
          dummy   TYPE string.
    DATA: l_http_ext_user TYPE http_ext_user.

    DATA: m_accept_cookie            TYPE rfcdisplay-rfctype.
    DATA: m_suppress_accept_compress TYPE rfcdisplay-rfctype.
    DATA: m_version                  TYPE rfcdisplay-rfctype.
    DATA: l_value(1024) TYPE c.
    DATA: l_proxy_host(1024)  TYPE c,
          l_proxy_service(10) TYPE c.
    DATA: l_oauth_profile TYPE oa2c_profile,
          l_oauth_config  TYPE oa2c_configuration.
    DATA: l_pse_filename  TYPE SSFPSENAME.

    IF ( destination IS INITIAL ).
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 853 RAISING destination_not_found.
*      RAISE destination_not_found.
    ENDIF.

    DATA: scheme TYPE i VALUE schemetype_http.

*    HTTP Outbound for scenarios in Steampunk, where destinations from the destination service are mirrored in the ABAP system.
*    Since some logon mechanism require tokens/certificates to be retrieved from the destination service as an outbound call happens, these destinations require a roundtrip to the destination service each call.
*    For destinations using basic authentication, this is not necessary and all required information is stored in the cached destination.
*    If the roundtrip is necessary or not, is stored within the cached destination and its parameter lo_dest_http_ext->authentication
    IF requiresDestinationService( destination ) EQ abap_true.
      createFromDestinationService(
      exporting
        destination = destination
      receiving
        client = client
      exceptions
        argument_not_found = 1
        destination_not_found = 2
        destination_no_authority = 3
        plugin_not_active = 4
        internal_error = 5 ).
      if sy-subrc <> 0.
        if sy-subrc eq 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
        elseif sy-subrc eq 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 852 RAISING destination_not_found.
        elseif sy-subrc eq 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 854 RAISING destination_no_authority.
        elseif sy-subrc eq 4.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 069 RAISING plugin_not_active.
        elseif sy-subrc eq 5.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 842 RAISING internal_error.
        endif.
      endif.
      RETURN.
    ENDIF.

    pf_m_open c_statistic_state 'HTTP Create By Destination'. "#EC *

* -- creation of interface reference
    CREATE OBJECT client_obj
      EXCEPTIONS
        create_message_failed = 1.
    IF sy-subrc <> 0.
      pf_m_close c_statistic_state                        "#EC CI_CCALL
                 'HTTP Create By Destination'.              "#EC NOTEXT
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 839 RAISING internal_error.
*    RAISE internal_error.
    ENDIF.

    client ?= client_obj.

* save destination for HTTP/HTTPS statistic
    client_obj->m_destination_name = destination.

    IF destination = 'NONE'.
      pf_m_open c_statistic_state 'HTTP Get Plugin Info'.   "#EC *
      CALL FUNCTION 'TH_GET_PLUGIN_INFO'
        EXPORTING
          protocol         = 1
          local            = 1
          plgtype          = 1
        IMPORTING   " NAME =
          host             = host
          service          = service
        EXCEPTIONS
          no_plugin_active = 1
          internal_error   = 2
          OTHERS           = 3.

      subrc = sy-subrc.
      pf_m_close c_statistic_state 'HTTP Get Plugin Info'.  "#EC *

      IF subrc <> 0.
        pf_m_close c_statistic_state                      "#EC CI_CCALL
                        'HTTP Create By Destination'.       "#EC NOTEXT
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING plugin_not_active.
*        RAISE plugin_not_active.
      ENDIF.

      client_obj->m_host     = host. "sy-host.
      client_obj->m_target_host = host.
      client_obj->m_service  = service.
* check validity of port number (16bit Integer)
      IF ( strlen( client_obj->m_service ) GT 5 )
      OR ( client_obj->m_service CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
      ENDIF.
      client_obj->m_target_service = service.
      client_obj->m_language = sy-langu.
      client_obj->m_createtype = createtype_destination_r3.

      IF client_obj->m_session IS INITIAL.
* -- Is there secure store problems, e. g. reading password from secure store
        CALL METHOD client_obj->create_r3_ticket
          EXCEPTIONS
            internal_error = 1.
        IF sy-subrc <> 0.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 837 RAISING internal_error.
*        RAISE internal_error.
        ENDIF.
      ENDIF.
    ELSEIF destination(2) = '%%'.
      DATA: values    TYPE TABLE OF string,
            value     TYPE string,
            part_1    TYPE string,                          "#EC NEEDED
            ashost    TYPE string,
            port      TYPE string,
            l_scheme  TYPE string,
            l_client  TYPE symandt,
            l_user    TYPE string,
            l_lang    TYPE sylangu,
            l_sslcert TYPE string,
            l_ttsysid TYPE string,
            l_ttsysinstnr TYPE string.

      SPLIT destination AT ',' INTO TABLE values.
      LOOP AT values INTO value.
        IF ashost IS INITIAL AND value CS 'ashost='.
          SPLIT value AT 'ashost=' INTO part_1 ashost.
        ELSEIF port IS INITIAL AND value CS 'port='.
          SPLIT value AT 'port=' INTO part_1 port.
        ELSEIF l_client IS INITIAL AND value CS 'client='.
          SPLIT value AT 'client=' INTO part_1 l_client.
        ELSEIF l_user IS INITIAL AND value CS 'user='.
          SPLIT value AT 'user=' INTO part_1 l_user.
        ELSEIF l_lang IS INITIAL AND value CS 'lang='.
          SPLIT value AT 'lang=' INTO part_1 l_lang.
        ELSEIF l_scheme IS INITIAL AND value CS 'scheme='.
          SPLIT value AT 'scheme=' INTO part_1 l_scheme.
        ELSEIF l_sslcert IS INITIAL AND value CS 'sslcert='.
          SPLIT value AT 'sslcert=' INTO part_1 l_sslcert.
          client_obj->m_sslapplic = l_sslcert.
        ELSEIF client_obj->m_trace IS INITIAL AND value CS 'trace='.
* -- activation of trace
          SPLIT value AT 'trace=' INTO part_1 dummy.
          client_obj->m_trace = dummy.
          IF client_obj->m_trace > 3.
            client_obj->m_trace = 3.
          ELSEIF client_obj->m_trace <= 1.
            client_obj->m_trace = 0.
          ENDIF.
        ELSEIF value CS 'trusted=1'.
* -- Y = SAP Trusted System.
          client_obj->m_trusted = 'Y'.
        ELSEIF value CS 'donotuseccert=1'.
          client_obj->m_do_no_show_client_cert = 'X'.
        ELSEIF l_ttsysid IS INITIAL AND value CS 'ttsysid='.
          SPLIT value AT 'ttsysid=' INTO part_1 l_ttsysid.
          client_obj->m_trust_serversysid = l_ttsysid.
        ELSEIF l_ttsysinstnr IS INITIAL AND value CS 'ttsysinstnr='.
          SPLIT value AT 'ttsysinstnr=' INTO part_1 l_ttsysinstnr.
          client_obj->m_trust_serverinstnr = l_ttsysinstnr.
        ENDIF.
      ENDLOOP.

* check validity of port number (16bit Integer)
      IF ( strlen( port ) GT 5 )
      OR ( port CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.

* -- assign paramaters
      client_obj->m_host = ashost.
      client_obj->m_target_host = ashost.
      client_obj->m_service = port.
      client_obj->m_target_service = port.

      IF l_lang IS NOT INITIAL.
        client_obj->m_language = l_lang.
      ELSE.
        client_obj->m_language = sy-langu.
      ENDIF.

      IF l_client IS NOT INITIAL.
        client_obj->m_client = l_client.
      ENDIF.

      IF l_user IS NOT INITIAL.
        client_obj->m_username = l_user.
      ENDIF.
      client_obj->m_createtype = createtype_destination_r3.

      IF NOT l_scheme IS INITIAL.
        IF ( l_scheme <> schemetype_http )
        AND ( l_scheme <> schemetype_https ).
          pf_m_close c_statistic_state                    "#EC CI_CCALL
                    'HTTP Create By Destination'.           "#EC NOTEXT
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 834 RAISING argument_not_found.
*        RAISE argument_not_found.
        ELSE.
          scheme =  l_scheme.
        ENDIF.
      ENDIF.

      IF client_obj->m_session IS INITIAL.
* -- Is there secure store problems, e. g. reading password from secure store
        CALL METHOD client_obj->create_r3_ticket
          EXCEPTIONS
            internal_error = 1.
        IF sy-subrc <> 0.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 837 RAISING internal_error.
*        raise internal_error.
        ENDIF.

      ENDIF.

    ELSE.
      DATA: l_proxy_username TYPE proxyuser,
            l_trust_serverid TYPE RFCSYSID,
            l_trust_instNr   TYPE SLIC_INST.
      dest = destination.
      pf_m_open c_statistic_state 'HTTP Read Destination'.  "#EC *


      CALL FUNCTION 'RFC_READ_HTTP_DESTINATION'
        EXPORTING
          destination             = dest
          authority_check         = ' '
        IMPORTING
          rfctype                 = l_rfcdisplay-rfctype
          servicenr               = l_rfcdisplay-rfcsysid
          server                  = l_rfcdisplay-rfchost
          trace                   = l_rfcdisplay-rfctrace
          language                = l_rfcdisplay-rfclang
          client                  = l_rfcdisplay-rfcclient
          user                    = l_rfcdisplay-rfcalias
          user_long254            = l_http_ext_user
          password                = l_rfcdisplay-rfcexec
*         DESCRIPTION             =
          proxy_host              = l_rfcdisplay-rfcgwhost
          proxy_service           = l_rfcdisplay-rfcgwserv
          proxy_user              = l_proxy_username
          proxy_password          = client_obj->m_proxy_password
          sslapplic               = client_obj->m_sslapplic
          path_prefix             = client_obj->m_path_prefix
*         DESTLOCK                =
          authority               = l_rfcdisplay-authority
          slogin                  = l_rfcdisplay-rfcslogin
          sameusr                 = l_rfcdisplay-rfcsameusr
          ssl                     = l_rfcdisplay-rfcsnc
          http_timeout            = client_obj->m_destination_timeout
          http_version            = m_version
          http_compress           = client_obj->m_compress
          compressreply           = m_suppress_accept_compress
          cookie_accept           = m_accept_cookie
          sso_ticket              = client_obj->m_sso_ticket
          assertion_ticket_sysid  = client_obj->m_assertion_system_id
          assertion_ticket_client = client_obj->m_assertion_client
          scc_enabled             = l_rfcdisplay-scc_enabled
          scc_location_id         = l_rfcdisplay-scc_location_id
          no_client_cert          = l_rfcdisplay-noccert
          oauth_profile           = l_oauth_profile
          oauth_config            = l_oauth_config
          trust_serversysid       = l_trust_serverid
          trust_serverinstnr      = l_trust_instNr
        EXCEPTIONS
          authority_not_available = 1
          destination_not_exist   = 2
          information_failure     = 3
          internal_failure        = 4
          no_http_destination     = 5
          OTHERS                  = 6.

      subrc = sy-subrc.
      client_obj->m_trust_serversysid = l_trust_serverid.
      client_obj->m_trust_serverinstnr = l_trust_instNr.
      client_obj->m_compress_dest = client_obj->m_compress.

      IF client_obj->m_path_prefix IS NOT INITIAL.
        client_obj->if_http_client~path_prefix = client_obj->m_path_prefix.
      ENDIF.

* password is in secure area with key /RFC/<RFC-Destination>'
      IF l_rfcdisplay-rfcexec IS NOT INITIAL AND
         l_rfcdisplay-rfcexec(2) = '%_'.
        CONCATENATE '/RFC/' dest INTO client_obj->m_password.
        client_obj->m_is_password_encrypted = abap_true.
      ENDIF.

      IF NOT l_rfcdisplay-rfcgwhost IS INITIAL.
        client_obj->m_is_special_proxy_configured = abap_true.
        client_obj->m_proxy_host     = l_rfcdisplay-rfcgwhost.
        client_obj->m_proxy_service  = l_rfcdisplay-rfcgwserv.
*        check validity of proxy port number (16bit Integer)
        IF ( strlen( client_obj->m_proxy_service ) GT 5 )
        OR ( client_obj->m_proxy_service CN '0123456789' ).
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 835 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.
        client_obj->m_proxy_username = l_proxy_username.
* proxy password is in secure area with key /RFCP/<RFC-Destination>'
        IF client_obj->m_proxy_password IS NOT INITIAL AND
          client_obj->m_proxy_password(2) = '%_'.
          CONCATENATE '/RFCP/' dest INTO client_obj->m_proxy_password.
          client_obj->m_is_proxy_password_encrypted = abap_true.
        ENDIF.
      ENDIF.

      IF l_rfcdisplay-scc_enabled = 'X'.
        CALL 'C_SAPGPARAM'
             ID    'NAME'
             FIELD 'http/scc_proxy'
             ID    'VALUE'
             FIELD  l_value.
        IF sy-subrc <> 0 OR l_value IS INITIAL.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 838 RAISING argument_not_found.
*          RAISE argument_not_found.
        ENDIF.
        SPLIT l_value AT ':' INTO l_proxy_host l_proxy_service.
        client_obj->m_use_scc = abap_true.
        client_obj->m_is_special_proxy_configured = abap_true.
        client_obj->m_proxy_host     = l_proxy_host.
        client_obj->m_proxy_service  = l_proxy_service.
*        check validity of proxy port number (16bit Integer)
        IF ( strlen( client_obj->m_proxy_service ) GT 5 )
        OR ( client_obj->m_proxy_service CN '0123456789' ).
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 835 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.
        IF l_rfcdisplay-scc_location_id IS NOT INITIAL.
          client_obj->m_scc_location_ID = l_rfcdisplay-scc_location_id.
          CALL METHOD client_obj->request->set_header_field
            EXPORTING
              name  = 'SAP-Connectivity-SCC-Location_ID' ##NO_TEXT
              value = client_obj->m_scc_location_ID.
        ENDIF.
      ENDIF.

      pf_m_close c_statistic_state 'HTTP Read Destination'. "#EC *

      IF subrc <> 0.

        IF subrc = 1.
          pf_m_close c_statistic_state                    "#EC CI_CCALL
                     'HTTP Create By Destination'.          "#EC NOTEXT
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 854 RAISING destination_no_authority.
*          RAISE destination_no_authority.
        ELSE.
          pf_m_close c_statistic_state                    "#EC CI_CCALL
                     'HTTP Create By Destination'.          "#EC NOTEXT
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 852 RAISING destination_no_authority.
*          RAISE destination_not_found.
        ENDIF.
      ENDIF.

* -- activation of trace
      IF l_rfcdisplay-rfctrace IS NOT INITIAL.
        client_obj->m_trace = 2.
      ENDIF.

* -- accept-encoding: gzip
      IF m_suppress_accept_compress = '1'.
        client->propertytype_accept_compress = co_disabled.
      ENDIF.

* -- HTTP version (HTTP/1.1 vs. HTTP/1.0)
* -- store initial protocol version for later use in CLOSE
      IF m_version = '1'.
        client_obj->m_server_protocol = 'HTTP/1.1'.         "#EC NOTEXT
      ELSE.
        client_obj->m_server_protocol = 'HTTP/1.0'.         "#EC NOTEXT
      ENDIF.

      CALL METHOD client->request->set_header_field
        EXPORTING
          name  = '~server_protocol'
          value = client_obj->m_server_protocol.

* -- accept cookie
      IF m_accept_cookie = '1'.
        client->propertytype_accept_cookie = co_enabled.
      ELSEIF m_accept_cookie = '2'.
        client->propertytype_accept_cookie = co_prompt.
      ELSEIF m_accept_cookie = '3'.
        client->propertytype_accept_cookie = co_event.
      ENDIF.

* -- Is plugins (HTTP/HTTPS) available
      IF  l_rfcdisplay-rfcsnc IS INITIAL.
        scheme = schemetype_http.
        IF c_schemetype_http_active = 0.
          pf_m_close c_statistic_state                    "#EC CI_CCALL
                     'HTTP Create By Destination'.          "#EC NOTEXT
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING plugin_not_active.
*          RAISE plugin_not_active.
        ENDIF.
      ELSE.
        scheme = schemetype_https.
        IF c_schemetype_https_active = 0.
          pf_m_close c_statistic_state                    "#EC CI_CCALL
                     'HTTP Create By Destination'.          "#EC NOTEXT
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING plugin_not_active.
*          RAISE plugin_not_active.
        ENDIF.
      ENDIF.

* -- authority check of HTTP destination
      IF NOT l_rfcdisplay-authority IS INITIAL.
        AUTHORITY-CHECK OBJECT 'S_ICF'
                      ID 'ICF_FIELD' FIELD 'DEST'
                      ID 'ICF_VALUE' FIELD l_rfcdisplay-authority.
        IF sy-subrc <> 0.
          pf_m_close c_statistic_state                    "#EC CI_CCALL
                     'HTTP Create By Destination'.          "#EC NOTEXT
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 854 RAISING destination_no_authority.
*          RAISE destination_no_authority.
        ENDIF.
      ENDIF.

      IF l_rfcdisplay-rfctype = 'H'.
        client_obj->m_createtype = createtype_destination_r3.
      ELSE.
        client_obj->m_createtype = createtype_destination_ext.
      ENDIF.

      IF client_obj->m_sslapplic IS NOT INITIAL.
        IF l_rfcdisplay-noccert = abap_true.
          client_obj->m_do_no_show_client_cert = 'X'.
        ELSE.
          client_obj->m_do_no_show_client_cert = ' '.
        ENDIF.
      ENDIF.

      client_obj->m_host = l_rfcdisplay-rfchost.
      client_obj->m_target_host = l_rfcdisplay-rfchost.
      client_obj->m_service = l_rfcdisplay-rfcsysid.
* check validity of port number (16bit Integer)
      IF ( strlen( client_obj->m_service ) GT 5 )
      OR ( client_obj->m_service CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.
      client_obj->m_target_service = l_rfcdisplay-rfcsysid.

      client_obj->m_client   = l_rfcdisplay-rfcclient.
      IF l_rfcdisplay-rfcsameusr IS INITIAL.
        IF l_rfcdisplay-rfctype = 'G'.
          client_obj->m_username = l_http_ext_user.
        ELSE.
          client_obj->m_username = l_rfcdisplay-rfcalias.
        ENDIF.
      ELSE.
        client_obj->m_username = sy-uname.
      ENDIF.
      IF l_rfcdisplay-rfclang IS INITIAL.
        client_obj->m_language = sy-langu.
      ELSE.
        client_obj->m_language = l_rfcdisplay-rfclang.
      ENDIF.

      IF ( client_obj->m_createtype EQ createtype_destination_r3 ).
        IF client_obj->m_service IS INITIAL OR
            client_obj->m_host    IS INITIAL.
          CALL FUNCTION 'TH_GET_PLUGIN_INFO'
            EXPORTING
              protocol = scheme
              local    = 1
              plgtype  = 1
            IMPORTING   " NAME =
              host     = host
              service  = service
            EXCEPTIONS
              OTHERS   = 0.
*           no_plugin_active       = 1
*           internal_error         = 2
*           others                 = 3.
          IF client_obj->m_service IS INITIAL.
            client_obj->m_service = service.
          ENDIF.

          IF client_obj->m_host IS INITIAL.
            client_obj->m_host = host.
          ENDIF.
        ENDIF.

        IF client_obj->m_host IS INITIAL.
          client_obj->m_host = sy-host.
        ENDIF.
* check validity of port number (16bit Integer)
        IF ( strlen( client_obj->m_service ) GT 5 )
        OR ( client_obj->m_service CN '0123456789' ).
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.

        client_obj->m_target_host = client_obj->m_host.
        client_obj->m_target_service = client_obj->m_service.

* -- logen procedure maintained in HTTP destination
* -- B = Basic Authentication, SPACE = SAP Standard,
* -- Y = SAP Trusted System.
        client_obj->m_logon_method = l_rfcdisplay-rfcslogin.

        IF l_rfcdisplay-rfctype = 'H'.
          IF l_rfcdisplay-rfcslogin = 'B'.
* -- basic authentication, logon is done in IF_HTTP_CLIENT~SEND
          ELSEIF l_rfcdisplay-rfcslogin IS INITIAL.
* -- SAP Standard, RFC logon
            CLEAR client_obj->m_trusted.
          ELSEIF l_rfcdisplay-rfcslogin  = 'Y'.
* -- trusted relation
            client_obj->m_trusted  =  l_rfcdisplay-rfcslogin.
          ENDIF.

          IF ( l_rfcdisplay-rfcslogin IS INITIAL OR
               l_rfcdisplay-rfcslogin = 'Y' ) AND
             client_obj->m_session IS INITIAL.
* -- RFC logon procedure (native and trusted):
* -- Is there secure store problems, e. g. reading password from secure store
            CALL METHOD client_obj->create_r3_ticket
              EXCEPTIONS
                internal_error = 1.
            IF sy-subrc <> 0.
              MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 837 RAISING internal_error.
*            RAISE internal_error.
            ENDIF.


          ENDIF.
        ENDIF.
      ELSE.
        IF client_obj->m_host IS INITIAL.
          client_obj->m_host = sy-host.
        ENDIF.

        IF client_obj->m_service IS INITIAL.
          IF scheme = schemetype_http.
            client_obj->m_service = '80'.
          ELSE.
            client_obj->m_service = '443'.
          ENDIF.
        ELSE.
* check validity of port number (16bit Integer)
          IF ( strlen( client_obj->m_service ) GT 5 )
          OR ( client_obj->m_service CN '0123456789' ).
            MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 833 RAISING argument_not_found.
*          RAISE argument_not_found.
          ENDIF.
        ENDIF.
        client_obj->m_target_host = client_obj->m_host.
        client_obj->m_target_service = client_obj->m_service.
      ENDIF.
    ENDIF.
* -- set scheme type: HTTP or HTTPS
    client_obj->m_scheme = scheme.
    client_obj->m_target_scheme  = scheme.

    IF NOT destination IS INITIAL.
      target =  destination.
    ELSE.
      CONCATENATE client_obj->m_host ':' client_obj->m_service
                                                    INTO target.
    ENDIF.

*
* Ermittlung des Filenamen bei SSL-Konfiguration
* Zertifikat ANONYM ist nur fuer SSL-Verschluesselng
*
*  if scheme   = schemetype_https          and
*     'C'      <>  l_rfcdisplay-rfcslogin  and
*     'ANONYM' <> client_obj->m_sslapplic.
** Korrektur der falschen Einstellung
*     client_obj->m_sslapplic = 'ANONYM'.
*  endif.

* Is secure communication, for transport of cookie data
    IF scheme = schemetype_https.
      client_obj->m_is_secure = 1.
    ELSE.
      client_obj->m_is_secure = 0.
    ENDIF.

    client_obj->m_target_is_secure = client_obj->m_is_secure.

    IF scheme = schemetype_https AND
       NOT ( client_obj->m_sslapplic IS INITIAL ).

* check in case of using start service SSLID '<SPKI>' the permission via call stack
      IF ( '<SPKI>' = client_obj->m_sslapplic ).
        IF client_obj->check_call_stack( ) = abap_false.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 836 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.
      ENDIF.

*  Logon method Client Certificate - ANONYMOUS is not a valid client cert
      IF ( 'ANONYM' <> client_obj->m_sslapplic ).
        client_obj->m_sap_username = client_obj->m_username.
        client_obj->m_sap_client   = client_obj->m_client.
      ENDIF.

      pf_m_open c_statistic_state 'HTTP PSE Filename'.      "#EC *

      CALL FUNCTION 'SSFPSE_FILENAME'
        EXPORTING
*         MANDT         = SY-MANDT
          context       = 'SSLC'
          applic        = client_obj->m_sslapplic
*         KEYVERSION    =
        IMPORTING
         PSENAME       = l_pse_filename
*          profile       = client_obj->m_x509filename
*         PSETEXT       =
*         DISTRIB       =
        EXCEPTIONS
          pse_not_found = 1
          OTHERS        = 2.
      subrc = sy-subrc.
      client_obj->m_x509filename = l_pse_filename.
      pf_m_close c_statistic_state 'HTTP PSE Filename'.     "#EC *

      IF subrc <> 0.
        pf_m_close c_statistic_state
                   'HTTP Create By Destination'.            "#EC *
        RAISE argument_not_found.
      ENDIF.
    ELSEIF scheme = schemetype_http.
*
* Remark: clear all HTTPS relevant fields in case of HTTP communication. This is necessary
*         since a redirect from HTTP to HTTPS protocol could mistakenly reuse the HTTPS
*         attributes, e.g. SSL context, ID.
*
      CLEAR: client_obj->m_sslapplic, client_obj->m_x509filename.
    ENDIF.

    IF l_oauth_profile IS NOT INITIAL.
      CALL METHOD cl_http_client=>set_oauth_token
        EXPORTING
          i_oauth_profile            = l_oauth_profile
          i_oauth_config             = l_oauth_config
          io_http_client             = client
        EXCEPTIONS
          oa2c_invalid_config        = 1
          oa2c_missing_authorization = 2
          oa2c_invalid_scope         = 3
          oa2c_invalid_grant         = 4
          oa2c_invalid_parameters    = 5
          oa2c_set_token_error       = 6
          OTHERS                     = 7.

      IF sy-subrc <> 0.
        IF sy-subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 855 RAISING oa2c_invalid_config.
*          RAISE oa2c_invalid_config.
        ELSEIF sy-subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 856 RAISING oa2c_missing_authorization.
*          RAISE oa2c_missing_authorization.
        ELSEIF sy-subrc = 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 857 RAISING oa2c_invalid_scope.
*          RAISE oa2c_invalid_scope.
        ELSEIF sy-subrc = 4.
          RAISE oa2c_invalid_grant.
        ELSEIF sy-subrc = 5.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 858 RAISING oa2c_invalid_parameters.
*          RAISE oa2c_invalid_parameters.
        ELSEIF sy-subrc = 6.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 859 RAISING oa2c_set_token_error.
*          RAISE oa2c_set_token_error.
        ELSE.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 860 RAISING internal_error.
*          RAISE internal_error.
        ENDIF.
      ENDIF.
      client_obj->m_oauth_state = 1.
      client_obj->m_oauth_profile = l_oauth_profile.
      client_obj->m_oauth_config  = l_oauth_config.
    ENDIF.

*
* --  export passport ticket
*
    IF ( client_obj->m_createtype EQ createtype_destination_r3 ).
      client_obj->propertytype_send_sap_passport = co_enabled.
*    data: x_passport type xstring.
*    call function 'TH_GET_CLIENT_ID_NETDATA'
*     importing
*       network_data            =  x_passport
**      NET_DATA_LEN            =
*     exceptions
*       parameter_missing       = 1
*       internal_error          = 2
*       parameter_wrong         = 3
*       others                  = 4.
*
*    if sy-subrc = 0.
*        client_obj->m_passport = x_passport.
** add version number to passport
*        concatenate 'v=1,' client_obj->m_passport
*                   into client_obj->m_passport.
*    endif.
    ENDIF.

    pf_m_open c_statistic_state 'HTTP Create TID'.          "#EC *
    CALL FUNCTION 'ICF_CREATE_GUID'
      IMPORTING
        id = m_connection.
    pf_m_close c_statistic_state 'HTTP Create TID'.         "#EC *

    IF m_connection IS INITIAL.
      CONCATENATE host ':' service '@' m_connection
                                         INTO client_obj->m_name.
      CONDENSE client_obj->m_name.
    ELSE.
      client_obj->m_name = m_connection.
    ENDIF.

*  concatenate target '@' m_connection
*                                     into client_obj->m_name.
*  condense client_obj->m_name.
*  len = strlen( client_obj->m_name ).
** -- is name larger than the key space -> GUID first to build the key
*  if len > 60.
*    clear client_obj->m_name.
*    concatenate m_connection '@' target
*                                      into client_obj->m_name.
*  endif.
    client_obj->m_client_id = client_obj->m_name.
    client_obj->m_state  = statetype_initial.
    CREATE OBJECT c_instance-client
      EXPORTING
        oref = client_obj.
    c_instance-name   = client_obj->m_name.
    c_instance-state  = client_obj->m_state.
    APPEND c_instance TO http_client_instances.
    do_garbage_collection( ).
    pf_m_close c_statistic_state 'HTTP Create By Destination'. "#EC *

  ENDMETHOD.


  METHOD create_by_url .
    DATA: client_obj TYPE REF TO cl_http_client.
    DATA: c_instance TYPE ihttp_client_instance.
    DATA: scheme TYPE string.
    DATA: service TYPE string,
          host    TYPE string.
    DATA: path     TYPE string,
          query    TYPE string,
          userinfo TYPE string.
    DATA: subrc    TYPE sysubrc.
    DATA: lv_successful TYPE abap_bool.
    DATA: lv_saprouter_in_use TYPE abap_bool.
    DATA: l_proxy_host(1024)  TYPE c,
          l_proxy_service(10) TYPE c,
          l_value(1024)       TYPE c.
    DATA: l_pse_filename  TYPE SSFPSENAME.

    IF url IS INITIAL.
    MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 882 RAISING argument_not_found.
*    RAISE argument_not_found.
    ENDIF.
    pf_m_open c_statistic_state 'HTTP Create By Url'.       "#EC *

* filter necessary information from URL
    pf_m_open c_statistic_state 'HTTP Parse Url'.           "#EC *
    CALL FUNCTION 'SWLWP_URI_PARSE'
      EXPORTING
        uri         = url
*       PARSE_AUTHORITY     = 'X'
      IMPORTING
        scheme      = scheme
*       AUTHORITY   =
        userinfo    = userinfo
*       HOSTPORT    =
        host        = host
        port        = service
        abs_path    = path
*       REL_SEGMENT =
        query       = query
*       OPAQUE_PART =
*       FRAGMENT    =
*       IS_RELATIVE =
*       HAS_NET_PATH        =
*       HAS_REL_PATH        =
*       HAS_EMPTY_AUTHORITY =
*       HAS_IPV4_HOST       =
      EXCEPTIONS
        uri_no_path = 1
        OTHERS      = 2.
    subrc = sy-subrc.
    pf_m_close c_statistic_state 'HTTP Parse Url'.          "#EC *

    IF subrc <> 0.
      pf_m_close c_statistic_state 'HTTP Create By Url'.    "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 881 RAISING argument_not_found.
*    RAISE argument_not_found.
    ENDIF.

    " remark: support of saprouter string in host segment for TCP connections via WebSocket !
*  IF host IS INITIAL AND service IS INITIAL AND path IS NOT INITIAL AND path(3) EQ '/H/'.
*    host = path.
*    " if host contains path+/-query section, e.g. http://H/h1/S/s1/<path>?<query> (path MUST NOT contain any /S/<number> !)
*    FIND ALL OCCURRENCES OF REGEX '\/S\/[0-9]+\/'           "#EC NOTEXT
*         IN host MATCH OFFSET DATA(lv_off) MATCH LENGTH DATA(lv_len).
*    IF sy-subrc = 0.
*      DATA(lv_tail_off) = lv_off + lv_len - 1.
*      path = host+lv_tail_off(*).
*      host = host(lv_tail_off).
*      SPLIT path AT '?' INTO path query.
*    ENDIF.
*    lv_saprouter_in_use = abap_true.
*  ENDIF.


*  call function 'HTTP_PARSE_URL'
*      exporting
*           url      = url
*      importing
*           scheme   = scheme_str
*           hostname = host
*           service  = service
*           uri      = uri.
*
*  if host is initial.
*    raise argument_not_found.
*  endif.


    TRANSLATE scheme TO UPPER CASE. "#EC
    IF scheme = 'HTTP'.
      scheme = schemetype_http.
    ELSEIF scheme = 'HTTPS'.
      scheme = schemetype_https.
    ELSE.
      pf_m_close c_statistic_state 'HTTP Create By Url'.    "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 883 RAISING argument_not_found.
*    RAISE argument_not_found.
    ENDIF.

    " do not use default ports for SAProuter scenario (TCP & WebSocket/HTTP)
    IF lv_saprouter_in_use NE abap_true.
      IF service IS INITIAL.
        IF scheme = schemetype_http.
          service = '80'.
        ELSE.
          service = '443'.
        ENDIF.
      ELSE.
* check validity of port number (16bit Integer)
        IF ( strlen( service ) GT 5 )
        OR ( service CN '0123456789' ).
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 884 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.
      ENDIF.
    ENDIF.

* Is plugin available
    IF scheme = schemetype_http AND
       c_schemetype_http_active = 0.
      pf_m_close c_statistic_state 'HTTP Create By Url'.    "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING argument_not_found.
*      RAISE plugin_not_active.
    ELSEIF scheme = schemetype_https AND
           c_schemetype_https_active = 0.
      pf_m_close c_statistic_state 'HTTP Create By Url'.    "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 850 RAISING argument_not_found.
*      RAISE plugin_not_active.
    ENDIF.

* Erzeuge der Interface-Referenz
    CREATE OBJECT client_obj
      EXCEPTIONS
        create_message_failed = 1.
    IF sy-subrc <> 0.
      pf_m_close c_statistic_state 'HTTP Create By Url'.    "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 839 RAISING internal_error.
*    RAISE internal_error.
    ENDIF.

    client ?= client_obj.
    client_obj->m_host           = host.
    client_obj->m_target_host    = host.
    client_obj->m_service        = service.
    client_obj->m_target_service = service.

    IF NOT proxy_host IS INITIAL.
      client_obj->m_is_special_proxy_configured = abap_true.
      client_obj->m_proxy_host     = proxy_host.
* check validity of proxy port number (16bit Integer)
      IF ( strlen( proxy_service ) GT 5 )
      OR ( proxy_service CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 835 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.
      client_obj->m_proxy_service  = proxy_service.
      IF proxy_user IS NOT INITIAL AND
         proxy_passwd IS NOT INITIAL.
        client_obj->m_proxy_username = proxy_user.
        client_obj->m_proxy_password = proxy_passwd.
        client_obj->m_is_proxy_password_encrypted = abap_false.
      ENDIF.
    ENDIF.

    IF oauth_profile IS SUPPLIED.
      CALL METHOD cl_http_client=>set_oauth_token
        EXPORTING
          i_oauth_profile            = oauth_profile
          i_oauth_config             = oauth_config
          io_http_client             = client
        EXCEPTIONS
          oa2c_invalid_config        = 1
          oa2c_missing_authorization = 2
          oa2c_invalid_scope         = 3
          oa2c_invalid_grant         = 4
          oa2c_invalid_parameters    = 5
          oa2c_set_token_error       = 6
          OTHERS                     = 7.

      IF sy-subrc <> 0.
        IF sy-subrc = 1.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 855 RAISING oa2c_invalid_config.
*          RAISE oa2c_invalid_config.
        ELSEIF sy-subrc = 2.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 856 RAISING oa2c_missing_authorization.
*          RAISE oa2c_missing_authorization.
        ELSEIF sy-subrc = 3.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 857 RAISING oa2c_invalid_scope.
*          RAISE oa2c_invalid_scope.
        ELSEIF sy-subrc = 4.
          RAISE oa2c_invalid_grant.
        ELSEIF sy-subrc = 5.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 858 RAISING oa2c_invalid_parameters.
*          RAISE oa2c_invalid_parameters.
        ELSEIF sy-subrc = 6.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 859 RAISING oa2c_set_token_error.
*          RAISE oa2c_set_token_error.
        ELSE.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 860 RAISING internal_error.
*          RAISE internal_error.
        ENDIF.
      ENDIF.

      client_obj->m_oauth_state = 1.
      client_obj->m_oauth_profile = oauth_profile.
      client_obj->m_oauth_config  = oauth_config.
    ENDIF.

    IF use_scc IS SUPPLIED AND use_scc = abap_true.
      CALL 'C_SAPGPARAM'
           ID    'NAME'
           FIELD 'http/scc_proxy'
           ID    'VALUE'
           FIELD  l_value.
      IF sy-subrc <> 0 OR l_value IS INITIAL.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 838 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.
      SPLIT l_value AT ':' INTO l_proxy_host l_proxy_service.
      client_obj->m_is_special_proxy_configured = abap_true.
      client_obj->m_proxy_host     = l_proxy_host.
      client_obj->m_proxy_service  = l_proxy_service.
*       check validity of proxy port number (16bit Integer)
      IF ( strlen( client_obj->m_proxy_service ) GT 5 )
      OR ( client_obj->m_proxy_service CN '0123456789' ).
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 835 RAISING argument_not_found.
*      RAISE argument_not_found.
      ENDIF.
      client_obj->m_use_scc = abap_true.
      IF scc_location_ID IS SUPPLIED AND scc_location_ID IS NOT INITIAL.
        client_obj->m_scc_location_ID = scc_location_ID.
        CALL METHOD client_obj->request->set_header_field
          EXPORTING
            name  = 'SAP-Connectivity-SCC-Location_ID' ##NO_TEXT
            value = scc_location_ID.
      ENDIF.
    ELSE.
      client_obj->m_use_scc = abap_false.
    ENDIF.

    client_obj->m_scheme         = scheme.
    client_obj->m_target_scheme  = scheme.
    client_obj->m_createtype     = createtype_url.
    pf_m_open c_statistic_state 'HTTP Create TID'.          "#EC *

    CALL FUNCTION 'ICF_CREATE_GUID'
      IMPORTING
        id = m_connection.
    pf_m_close c_statistic_state 'HTTP Create TID'.         "#EC *
    IF m_connection IS INITIAL.
      CONCATENATE host ':' service '@' m_connection
                                         INTO client_obj->m_name.
      CONDENSE client_obj->m_name.
    ELSE.
      client_obj->m_name = m_connection.
    ENDIF.
*  len = strlen( client_obj->m_name ).
** -- is name larger than the key space -> GUID first to build the key
*  if len > 60.
*    clear client_obj->m_name.
*    concatenate m_connection '@' target
*                                      into client_obj->m_name.
*  endif.
    client_obj->m_client_id = client_obj->m_name.
    client_obj->m_state  = statetype_initial.

* Is secure communication, for transport of cookie data
    IF scheme = schemetype_https.
      client_obj->m_is_secure = 1.
    ELSE.
      client_obj->m_is_secure = 0.
    ENDIF.

    client_obj->m_target_is_secure = client_obj->m_is_secure.

    client_obj->m_sslapplic    = ssl_id.

* Ermittlung des Filenamen bei SSL-Konfiguration
    IF scheme = schemetype_https AND
       NOT ( client_obj->m_sslapplic IS INITIAL ).

* check in case of using start service SSLID '<SPKI>' the permission via call stack
      IF ( '<SPKI>' = client_obj->m_sslapplic ).
        IF client_obj->check_call_stack( ) = abap_false.
          MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 836 RAISING argument_not_found.
*        RAISE argument_not_found.
        ENDIF.
      ENDIF.

      IF ( 'ANONYM' <> client_obj->m_sslapplic ).
*
* username and client numebr for mapping of client certificate at R/3
*
        client_obj->m_sap_username = sap_username.
        client_obj->m_sap_client   = sap_client.
      ENDIF.

      pf_m_open c_statistic_state 'HTTP PSE Parameter'.     "#EC *
      CALL FUNCTION 'SSFPSE_PARAMETER'
        EXPORTING
          context         = 'SSLC'
          applic          = client_obj->m_sslapplic
        IMPORTING
*         FALLBACK        =
*         KEY             =
*         HOST            =
*         INSTANCEID      =
         PSENAME          = l_pse_filename
          profile         = client_obj->m_x509filename
*         ID              =
*         SIGNED          =
*         DATALEN         =
        EXCEPTIONS
          pse_not_distrib = 1
          pse_not_found   = 2
          OTHERS          = 3.
      subrc = sy-subrc.
      IF l_pse_filename IS NOT INITIAL.
        client_obj->m_x509filename = l_pse_filename.
      ENDIF.
      pf_m_close c_statistic_state 'HTTP PSE Parameter'.    "#EC *
      IF subrc <> 0.
        pf_m_close c_statistic_state 'HTTP Create By Url'.  "#EC *
        CASE subrc.
          WHEN 1.
            MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 851 RAISING pse_not_distrib.
*            RAISE pse_not_distrib.
          WHEN 2.
            MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 851 RAISING pse_not_found.
*            RAISE pse_not_found.
          WHEN 3.
            MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 851 RAISING pse_errors.
*            RAISE pse_errors.
        ENDCASE.
      ENDIF.
    ELSEIF scheme = schemetype_http.
*
* Remark: clear all HTTPS relevant fields in case of HTTP communication. This is necessary
*         since a redirect from HTTP to HTTPS protocol could mistakenly reuse the HTTPS
*         attributes, e.g. SSL context, ID.
*
      CLEAR: client_obj->m_sslapplic, client_obj->m_x509filename.
    ENDIF.

    IF ssl_id IS SUPPLIED AND client_obj->m_sslapplic IS NOT INITIAL.
      IF do_not_use_client_cert IS SUPPLIED.
        IF do_not_use_client_cert = abap_true.
          client_obj->m_do_no_show_client_cert = 'X'.
        ELSE.
          client_obj->m_do_no_show_client_cert = ' '.
        ENDIF.
      ENDIF.
    ENDIF.

*  if not uri is initial.
*    cl_http_utility=>set_request_uri( request = client_obj->request
*                                      uri     = uri ).
*  endif.

* -- set query string (form fields)
    IF NOT query IS INITIAL.
* -- store initial query for later use in CLOSE
      client_obj->m_query = query.
      cl_http_utility=>set_query( request = client_obj->request
                                  query   = query ).
      client_obj->m_ecode = cl_http_utility=>get_last_error( ).
      IF client_obj->m_ecode <> 0.
        pf_m_close c_statistic_state 'HTTP Create By Url'.  "#EC *
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 860 RAISING internal_error.
*        RAISE internal_error.
      ENDIF.
    ENDIF.

* -- store initial path for later use in CLOSE
    client_obj->m_path = path.
*-- set path
    client_obj->request->set_header_field( name  = '~request_uri'
                                           value = path ).
    client_obj->m_ecode = client_obj->request->get_last_error( ).
    IF client_obj->m_ecode <> 0.
      pf_m_close c_statistic_state 'HTTP Create By Url'.    "#EC *
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 860 RAISING internal_error.
*      RAISE internal_error.
    ENDIF.

*-- set user:password
    IF NOT userinfo IS INITIAL.
      SPLIT userinfo AT ':' INTO host service.
      client_obj->authenticate( username = host password = service ).
    ENDIF.

    CREATE OBJECT c_instance-client
      EXPORTING
        oref = client_obj.
    c_instance-name   = client_obj->m_name.
    c_instance-state  = client_obj->m_state.
    APPEND c_instance TO http_client_instances.
    do_garbage_collection( ).
    pf_m_close c_statistic_state 'HTTP Create By Url'.      "#EC *

  ENDMETHOD.


  METHOD create_internal .
    DATA: client_obj TYPE REF TO cl_http_client.
    DATA: c_instance TYPE ihttp_client_instance.

* Is plugin available
    IF c_schemetype_http_active = 0.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 860 RAISING plugin_not_active.
*      RAISE plugin_not_active.
    ENDIF.

* Erzeuge der Interface-Referenz
    CREATE OBJECT client_obj
      EXCEPTIONS
        create_message_failed = 1.
    IF sy-subrc <> 0.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 839 RAISING internal_error.
*    RAISE internal_error.
    ENDIF.

    client ?= client_obj.
    CALL FUNCTION 'ICF_CREATE_GUID'
      IMPORTING
        id = m_connection.

    IF m_connection IS INITIAL.
      CONCATENATE sy-host '@' m_connection
                                         INTO client_obj->m_name.
      CONDENSE client_obj->m_name.
    ELSE.
      client_obj->m_name = m_connection.
    ENDIF.

*  concatenate sy-host '@' m_connection
*                                     into client_obj->m_name.
*  condense client_obj->m_name.
*  len = strlen( client_obj->m_name ).
*  if len > 64.
*    clear client_obj->m_name.
*    concatenate m_connection '@' target
*                                      into client_obj->m_name.
*  endif.
    client_obj->m_client_id = client_obj->m_name.
    client_obj->m_state  = statetype_initial.
    " client_obj->m_scheme = scheme.
    client_obj->m_host = 'localhost'.
    client_obj->m_target_host = 'localhost'.

    CREATE OBJECT c_instance-client EXPORTING oref = client_obj.
    c_instance-name   = client_obj->m_name.
    c_instance-state  = client_obj->m_state.
    APPEND c_instance TO http_client_instances.
    do_garbage_collection( ).

    client_obj->m_create_internal = 1.
    client_obj->m_createtype      = createtype_internal.
    client_obj->m_virtual_host    = virtual_host.

  ENDMETHOD.


  METHOD create_r3_ticket .
* ...
    DATA: version TYPE string,
          client  TYPE string,
          session TYPE xstring.
    version = '1'.

    pf_m_open c_statistic_state 'HTTP Create Ticket'.       "#EC *

* Default values for Client and User
    IF m_client IS INITIAL.
      m_client = sy-mandt.
    ENDIF.
    IF m_username IS INITIAL.
      m_username = sy-uname.
    ENDIF.

    client = m_client. "Typ cast

    CALL 'ICF_DISPATCH' ID 'HTTP'     FIELD 'a'             "#EC *
                        ID 'Version'  FIELD version         "#EC NOTEXT
           "            id 'TimeStamp' field TimeStamp        "#EC NOTEXT
                        ID 'User' FIELD m_username          "#EC NOTEXT
                        ID 'Client' FIELD client            "#EC NOTEXT
                        ID 'Language' FIELD m_language      "#EC NOTEXT
                        ID 'Trusted' FIELD m_trusted        "#EC NOTEXT
                        ID 'Auth'    FIELD m_password       "#EC NOTEXT
                        ID 'SessionID' FIELD session        "#EC NOTEXT
                        ID 'Targethost' FIELD m_host        "#EC NOTEXT
                        ID 'Targetport' FIELD m_service    "#EC NOTEXT
                        ID 'ServerSysId' FIELD m_trust_serversysid "#EC NOTEXT
                        ID 'ServerInstNr' FIELD m_trust_serverinstnr. "#EC NOTEXT
    IF sy-subrc = 0.
* conversion from xstring to string
      m_session = session.
    ELSE.
      RAISE internal_error.
    ENDIF.
    pf_m_close c_statistic_state 'HTTP Create Ticket'.      "#EC *

  ENDMETHOD.


  METHOD destructor .
*  system-call c-destructor 'ict_CDestr_DeleteHttpClient'
*        using M_C_CCLIENT.  "#EC CI_SYSTEMCALL
    SYSTEM-CALL C-DESTRUCTOR 'IcfCDestrHttpClientObj'
      USING m_c_cclient m_client_id.                 "#EC CI_SYSTEMCALL
  ENDMETHOD.


  METHOD do_garbage_collection.
    CONSTANTS: co_gc_steps TYPE i VALUE 100.

    " do garbage-collection by removing "orphaned" entries
    " remove the garbage-collected/un-referenced client entry out of global table avoid memory leak
    IF ( lines( http_client_instances ) MOD co_gc_steps ) EQ 0.
      LOOP AT http_client_instances ASSIGNING FIELD-SYMBOL(<lv_registered_client>).
        IF <lv_registered_client>-client->get( ) IS INITIAL.
          " remove the garbage-collected/un-referenced client entry out of global table avoid memory leak
          DELETE TABLE cl_http_client=>http_client_instances WITH TABLE KEY name = <lv_registered_client>-name.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.


  METHOD get_client_kernel_version.
    DATA: client_kernel_version TYPE i.
* Version number of Client in Kernel
    CALL 'ICF_DISPATCH' ID 'HTTP' FIELD 'k'                 "#EC *
     ID 'ClientKernelVersion'     FIELD client_kernel_version. "#EC NOTEXT

    version = client_kernel_version.

  ENDMETHOD.


  METHOD get_extended_passport.
    DATA: l_epp_system TYPE REF TO if_epp_system_section.
    DATA: l_epp_global TYPE REF TO if_epp_global_section.
    DATA: l_last_connection TYPE epp_connection_id.
    DATA: l_last_ccounter   TYPE epp_connection_counter VALUE 0.
    DATA: l_last_values_are_determined TYPE abap_bool VALUE abap_false.

    CLEAR passport.

    TRY.
* retrieve the default values for connection id and connection counter in the extended passport
        l_epp_global = cl_epp_global_factory=>get_section( ).
        l_epp_system = cl_epp_system_factory=>get_global_section( ).

      CATCH cx_epp_error.
        " do not continue, if passport handling does not work
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 861 RAISING epp_error.
*        RAISE epp_error.
    ENDTRY.

    TRY.
        l_last_connection = l_epp_global->get_connection_id_as_uuid( ).
        l_last_ccounter   = l_epp_global->get_connection_counter( ).

        IF m_epp_root_context_id IS NOT INITIAL.
          " use a dedicated EPP root context id for APC detached client, see CL_APC_WSP_CLIENT~CONNECT_AND_DETACH
          DATA(l_last_root_context_id) = l_epp_global->get_root_context_id_as_uuid( ).
          DATA: lo_epp_core TYPE REF TO cl_epp_core.
          lo_epp_core ?= l_epp_system.
          IF lo_epp_core IS BOUND.
            lo_epp_core->_set_root_context_id_as_uuid( m_epp_root_context_id ).
          ENDIF.
        ENDIF.

* update the connection id in the extended passport
        l_epp_system->set_connection_id_as_uuid( m_connection ).

* update the connection counter in the extended passport
        l_epp_system->set_connection_counter( m_counter ).
* mark it as modified
        l_last_values_are_determined = abap_true.
      CATCH cx_epp_error.
*
* Remark: getting and setting of connection parameters, i.e. connection_id and connection_counter
*         does not work, if the passport version is V2 and not EPP (V3). But never the less
*         V2 passport must be transmitted, in order to transfer the rest of the passport including
*         transaction id.
*
        " do continue
    ENDTRY.

    TRY.
        IF m_epp_system_entity IS INITIAL.
          m_epp_system_entity = l_epp_system->get_entity( ).
        ENDIF.

        passport  = cl_epp_manager=>get_memento( m_epp_system_entity ).

* restore the original connection id and connection counter in the extended passport,
* if they are modified before
        IF l_last_values_are_determined = abap_true.
          TRY.
              l_epp_system->set_connection_id_as_uuid( l_last_connection ).
              l_epp_system->set_connection_counter( l_last_ccounter ).

              IF m_epp_root_context_id IS NOT INITIAL AND
                 lo_epp_core           IS BOUND.
                " restore EPP root context id
                lo_epp_core->_set_root_context_id_as_uuid( l_last_root_context_id ).
              ENDIF.

            CATCH cx_epp_error.
*
* Remark: getting and setting of connection parameters, i.e. connection_id and connection_counter
*         does not work, if the passport version is V2 and not EPP (V3). But never the less
*         V2 passport mut be transmitted, in order to transfer the rest of the passport including
*         transaction id.
*
          ENDTRY.
        ENDIF.

      CATCH cx_epp_error.
        IF l_epp_system IS BOUND AND l_epp_system IS NOT INITIAL.
* restore the original connection id and connection counter in the extended passport,
* if they are modified before
          IF l_last_values_are_determined = abap_true.
            l_epp_system->set_connection_id_as_uuid( l_last_connection ).
            l_epp_system->set_connection_counter( l_last_ccounter ).
          ENDIF.
        ENDIF.
        MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 861 RAISING epp_error.
*        RAISE epp_error.
    ENDTRY.

  ENDMETHOD.


  METHOD get_kernel_statistic_info.
    DATA: lv_path TYPE string.
    lv_path = m_path.
    IF lv_path IS INITIAL.
      lv_path = request->get_header_field( name = '~request_uri' ).
    ENDIF.

    e_protocol = m_scheme.
    e_port    = m_service.
    e_host    = m_host.
    e_path    = lv_path.
  ENDMETHOD.


  METHOD get_last_error.
    code    = c_ecode.
    message = c_emessage.
  ENDMETHOD.


  METHOD if_http_client~append_field_url.
* ...
    DATA: escaped TYPE string.


    IF url CA '?'.
      CONCATENATE url '&' INTO url.
    ELSE.
      CONCATENATE url '?' INTO url.
    ENDIF.

* Use new ABAP XSS Escaping library (see sap note 1644634)
*  escaped = escape_url( name ).
    escaped = escape( val   = name
                      format = cl_abap_format=>e_xss_url ).
    CONCATENATE url escaped '=' INTO url.

*  escaped = escape_url( value ).
    escaped = escape( val  = value
                      format = cl_abap_format=>e_xss_url ).
    CONCATENATE url escaped INTO url.

  ENDMETHOD.


  METHOD if_http_client~authenticate.
* ...
    pf_m_open c_statistic_state 'HTTP Basic Authentication'. "#EC *

    IF proxy_authentication <> 'X'.
      m_username = username.
      m_password = password.
      m_client   = client.
      m_language = language.
      m_is_password_encrypted = abap_false.
    ENDIF.
    m_patch = 0.

    IF proxy_authentication <> 'X'.
      CALL METHOD request->set_authorization
        EXPORTING
          username = m_username
          password = m_password.
    ELSE.
      IF m_target_scheme = schemetype_http.
        m_is_proxy_password_encrypted = abap_false.
* -- proxy logon only for http protocol
        DATA: l_utility TYPE REF TO if_http_utility.
        DATA: logon     TYPE string,
              logon_b64 TYPE string.

        CREATE OBJECT l_utility TYPE cl_http_utility.

        CONCATENATE username ':' password INTO logon.
        logon_b64 = l_utility->encode_base64( logon ).
        CONCATENATE 'Basic' logon_b64 INTO logon_b64        "#EC NOTEXT
           SEPARATED BY space.
        CALL METHOD request->set_header_field
          EXPORTING
            name  = 'Proxy-Authorization' "#EC NOTEXT
            value = logon_b64.
      ELSE.
        IF c_client_kernel_version < 5.
          m_is_proxy_password_encrypted = abap_true.
          DATA: l_password_encrypted(128) TYPE c,
                l_password_original(64)   TYPE c.

*   -- proxy logon via SSL layer
          m_proxy_username    = username.
          l_password_original = password.
*   -- encryption of proxy password in case of SSL communication
*   -- for usage in kernel in FM 'HTTP_WRITE_SC'
          CALL 'RFCControl'                               "#EC CI_CCALL
                ID 'CODE'        FIELD 'v'
                ID 'SOURCE'      FIELD l_password_original
                ID 'DESTINATION' FIELD l_password_encrypted.
          m_proxy_password = l_password_encrypted.
        ELSE.
          m_proxy_username = username.
          m_proxy_password = password.
          m_is_proxy_password_encrypted = abap_false.
        ENDIF.
      ENDIF.
    ENDIF.

    " call method authentication.
    IF NOT m_client IS INITIAL.
      DATA: l_client TYPE string.
      l_client = m_client.
      CALL METHOD request->set_header_field
        EXPORTING
          name  = 'SAP-Client'                                "#EC NOTEXT
          value = l_client.
    ENDIF.

    IF NOT m_language IS INITIAL.
      DATA: l_language TYPE string.
      l_language = m_language.
      CALL METHOD request->set_header_field
        EXPORTING
          name  = 'SAP-Language'                              "#EC NOTEXT
          value = l_language.
    ENDIF.
    pf_m_close c_statistic_state 'HTTP Basic Authentication'. "#EC *
  ENDMETHOD.                    "


  METHOD if_http_client~close.
*  data: http_client_instance type ihttp_client_instance.

    IF m_state = statetype_close.
      m_ecode = http_invalid_state_error.
      CALL METHOD error_codes=>get_error_text
        EXPORTING
          number = m_ecode
        IMPORTING
          text   = m_emessage.
      MESSAGE ID 'SHTTP' TYPE 'E' NUMBER 862 RAISING http_invalid_state.
*      RAISE http_invalid_state.
    ENDIF.

    pf_m_open c_statistic_state 'HTTP Close'.               "#EC *
    m_state = statetype_close.

    IF m_createtype = createtype_internal.
*
* avoid memory leak in case of local calls (CREATE_INTERNAL)
* remove server objects linked to the local client object
*
* remove also multiple entries of the same object
      cl_http_server_par=>remove_local_server( name = m_name ).
    ELSE.
      CALL 'RFCControl' ID 'CODE' FIELD 't'               "#EC CI_CCALL
                        ID 'HTTP' FIELD 'C'
                        ID 'NAME' FIELD m_name.

      m_ecode = sy-subrc.
      IF m_ecode <> 0.
*        CALL FUNCTION 'HTTP_GET_ERRORCODE'
*          EXPORTING
*            errorcode = m_ecode
*          IMPORTING
*            errortext = m_emessage
*          EXCEPTIONS
*            OTHERS    = 0.
*                invalid_errorcode = 1
*                others            = 2.
*      if sy-subrc <> 0.
*      endif.
        CALL METHOD error_codes=>get_error_text
          EXPORTING
            number = m_ecode
          IMPORTING
            text   = m_emessage.

        m_state = statetype_error.
      ENDIF.
    ENDIF.

*  read table http_client_instances into http_client_instance
*                                        with key name = m_name.
*  if sy-subrc = 0.
*    http_client_instance-state = m_state.
*    modify table http_client_instances from http_client_instance.
*  endif.


*
* remove client object from internal table for garbage collector
*
    DELETE http_client_instances WHERE name = m_name.

*
* clear all relevant objects linked to the client object
* this is necessary for statful session
*
    refresh_cookie( ).
    refresh_request( ).
    refresh_response( ).

    pf_m_close c_statistic_state 'HTTP Close'.              "#EC *


  ENDMETHOD.


  METHOD if_http_client~create_abs_url.
    DATA: help TYPE string.
*
*  with CREATE_INTERNAL no absolut URL available but relative URL
*  if no parameter is specified (host, port, etc.)
*

* -- protocol
    IF m_createtype <> createtype_internal OR
       ( m_createtype = createtype_internal AND
         protocol IS NOT INITIAL OR
         host IS NOT INITIAL     OR
         port IS NOT INITIAL ).

      IF protocol IS INITIAL.
*      help = request->get_header_field( '~URI_SCHEME' ).
        IF m_target_scheme = schemetype_https.
          help = 'https'.
        ELSE.
          help = 'http'.
        ENDIF.
      ELSE.
        help = protocol.
      ENDIF.
      CONCATENATE help '://' INTO url.

*   -- host
      IF host IS INITIAL.
*      help = request->get_header_field( '~SERVER_NAME' ).
        help = m_target_host.
      ELSE.
        help = host.
      ENDIF.
      CONCATENATE url help INTO url.

*   -- port
      IF port IS INITIAL.
*      help = request->get_header_field( '~SERVER_PORT' ).
        help = m_target_service.
      ELSE.
        help = port.
      ENDIF.
      IF NOT help IS INITIAL.
        CONCATENATE url ':' help INTO url.
      ENDIF.
    ENDIF.

* -- path
    IF path IS INITIAL.
*    help = request->get_header_field( '~PATH_TRANSLATED' ).
      help = request->get_header_field( '~REQUEST_URI' ).
      IF help CS '?'.
        DATA: postfix TYPE string.                          "#EC NEEDED
        SPLIT help AT '?' INTO help postfix.
      ENDIF.

*    if m_createtype = createtype_destination and
*       m_path_prefix  is not initial.
      IF ( m_createtype EQ createtype_destination_r3
        OR m_createtype EQ createtype_destination_ext )
      and ( m_already_processed EQ 0 )
        AND ( NOT m_path_prefix IS INITIAL ).
        CONCATENATE m_path_prefix help INTO help.
      ENDIF.
    ELSE.
      help = path.
    ENDIF.
    IF NOT help IS INITIAL.
      DATA: my_host         TYPE string,
            my_service      TYPE string,
            my_uri          TYPE string,
            my_path         TYPE string,
            url_is_relative TYPE c.

      CALL FUNCTION 'SWLWP_URI_PARSE'
        EXPORTING
          uri             = help
          parse_authority = 'X'
        IMPORTING
          host            = my_host
          port            = my_service
          abs_path        = my_uri
          rel_segment     = my_path
          is_relative     = url_is_relative
        EXCEPTIONS
          uri_no_path     = 1
          OTHERS          = 2.                        "#EC *

      IF sy-subrc = 0 AND url_is_relative <> 'X'.
        " The url contains host and port, so copy only the path to the new url
        CONCATENATE url my_uri INTO url.
      ELSE.
        CONCATENATE url help INTO url.
      ENDIF.
    ENDIF.

    IF NOT querystring IS INITIAL.
      CONCATENATE url '?' querystring INTO url.
    ENDIF.

  ENDMETHOD.


  METHOD if_http_client~create_rel_url.
* ...
    DATA: _path LIKE path.

    IF NOT path IS INITIAL.
      _path = path.

      IF path(1) = '/'.
        _path = path+1.
      ELSE.
        _path = path.
      ENDIF.

      CONCATENATE url '/' _path INTO url.

    ENDIF.

    IF NOT querystring IS INITIAL.
      CONCATENATE url '?' querystring INTO url.
    ENDIF.


  ENDMETHOD.


  METHOD if_http_client~escape_html.
    CLASS cl_http_utility DEFINITION LOAD.
    escaped = cl_http_utility=>escape_html( unescaped = unescaped ).
*  call 'ICT_DISPATCH' id 'did'    field 'html_escape'
*                      id 'source' field unescaped
*                      id 'dest'   field escaped.

  ENDMETHOD.
ENDCLASS.