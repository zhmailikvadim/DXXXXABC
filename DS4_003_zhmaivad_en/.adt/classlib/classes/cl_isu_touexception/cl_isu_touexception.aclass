class CL_ISU_TOUEXCEPTION definition
  public
  final
  create protected .

public section.
  class CL_ISU_DATE definition load .

  constants CO_WMODE_CREATE type E_MODE value '3'. "#EC NOTEXT
  constants CO_WMODE_CHANGE type E_MODE value '2'. "#EC NOTEXT
  constants CO_WMODE_DISPLAY type E_MODE value '1'. "#EC NOTEXT
  constants CO_WMODE_DELETE type E_MODE value '4'. "#EC NOTEXT
  data DATA type ETOUEXCEPT_DATA read-only .
  data INSTANCE_DB type ref to CL_ISU_TOUEXCEPTION_DB read-only .
  constants CO_STATUS_ACTIVE type E_TOUEXCEPT_STATUS value '01'. "#EC NOTEXT
  constants CO_STATUS_INACTIVE type E_TOUEXCEPT_STATUS value '00'. "#EC NOTEXT

  class-methods CLASS_CONSTRUCTOR .
  type-pools ABAP .
  methods CONSTRUCTOR
    importing
      !X_WMODE type E_MODE
      !X_NO_DIALOG type ABAP_BOOL default ABAP_FALSE
      !X_EXCEPTION_REF_DB type ref to CL_ISU_TOUEXCEPTION_DB
      !X_EXCEPTIONID type E_TOUEXCEPT_INT_ID optional
      !X_SINGLE_CREATION type KENNZX optional
      !X_AUTO_DATA type ETOUEXCEPT_AUTO_DATA optional
      !X_SINGLE_CREATION_CONTRACT type VERTRAG optional
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods GET_EXCEPTION_LIST
    importing
      !XT_EXCEPTION_SEL type ETOUEXCEPT_SELECTION
    exporting
      !YT_EXCEPTION type ETOUEXCEPT_INSTANCE_TAB
      !Y_EXCEPT_INSTANCE_DB type ref to CL_ISU_TOUEXCEPTION_DB
      !Y_NOT_FOUND type ABAP_BOOL
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods GET_INSTANCE
    importing
      !X_WMODE type E_MODE
      !X_NO_DIALOG type ABAP_BOOL default ABAP_FALSE
      !X_EXCEPTION_REF_DB type ref to CL_ISU_TOUEXCEPTION_DB
      !X_EXCEPTIONID type E_TOUEXCEPT_INT_ID optional
      !X_SINGLE_CREATION type KENNZX optional
      !X_AUTO_DATA type ETOUEXCEPT_AUTO_DATA optional
      !X_SINGLE_CREATION_CONTRACT type VERTRAG optional
    exporting
      value(Y_INSTANCE) type ref to CL_ISU_TOUEXCEPTION
    changing
      !XY_EXCEPTIONID type E_TOUEXCEPT_INT_ID optional
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods GET_WMODE
    returning
      value(Y_WMODE) type E_MODE .
  methods SET_EXCEPTION
    importing
      !X_CHANGE_ACTIVATION type ABAP_BOOL default ABAP_FALSE
    changing
      !XY_EXCEPTION_DATA type ETOUEXCEPT_DATA
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods CLOSE
    changing
      !XY_INSTANCE type ref to CL_ISU_TOUEXCEPTION
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods DELETE_EXCEPTION
    importing
      !X_FORCE_DB_DELETE type ABAP_BOOL default ABAP_FALSE
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods GET_INPUT_STATUS
    exporting
      !Y_INPUT_STATUS type ABAP_BOOL
      !Y_INPUT_CHANGED type ABAP_BOOL .
  class-methods START_MAINT_TOOL_WITHOUT_SEL
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods CONVERT_TC_DATETIME_TO_UTC
    importing
      !X_DATE type E_TOUEXCEPT_DATEFROM
      !X_TIME type E_TOUEXCEPT_TIMEFROM
      !X_TIMEZONE type TIMEZONE optional
    exporting
      !Y_DATE_UTC type E_TOUEXCEPT_DATEFROM
      !Y_TIME_UTC type E_TOUEXCEPT_TIMEFROM
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods CONVERT_UTC_DATETIME_TO_TC
    importing
      !X_DATE_UTC type E_TOUEXCEPT_DATEFROM
      !X_TIME_UTC type E_TOUEXCEPT_TIMEFROM
      !X_TIMEZONE type TIMEZONE optional
    exporting
      !Y_DATE type E_TOUEXCEPT_DATEFROM
      !Y_TIME type E_TOUEXCEPT_TIMEFROM
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_OVERLAP_IN_EXCEPTPROG
    importing
      !X_EXCEPTION_DATA type ETOUEXCEPT_DATA
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods PROCESS_AUTO_DATA
    importing
      !XT_EXCEPTION type ETOUEXCEPT_AUTO_DATA_TAB
      !X_WMODE type E_MODE
      !X_NO_COMMIT type ABAP_BOOL default ABAP_FALSE
    exporting
      !YT_EXCEPTION type ETOUEXCEPT_DATA_TAB
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods DELETE_DEPENDENT_EXCEPTRESP
    importing
      !XT_EXCEPTIONID type ETOUEXCEPT_ID_TAB
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  class-methods CHECK_USER
    importing
      !X_USER type SY-UNAME
    exporting
      !Y_NOT_FOUND type ABAP_BOOL
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_EXCEPTION_EXTID
    importing
      !X_EXCEPTION_EXTID type E_TOUEXCEPT_EXT_ID
      !X_EXCEPTIONSOURCE type E_TOUEXCEPT_SOURCE
      !X_EXCLUDE_EXCEPTIONID type E_TOUEXCEPT_INT_ID
    exporting
      !Y_NOT_FOUND type ABAP_BOOL
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
PROTECTED SECTION.

  TYPES:
    BEGIN OF tp_control_data,
     wmode TYPE e_mode,
     no_dialog TYPE e_dark,
     changed TYPE e_change,
     delete_touexcept TYPE abap_bool,
     input_error TYPE abap_bool,
     single_creation TYPE kennzx,
     single_creation_contract TYPE vertrag,
  END OF tp_control_data .

  DATA: control_data TYPE tp_control_data.
private section.

  constants CO_EXCEPTION_NUMBER_RANGE type NROBJ value 'ISU_TOUEX'. "#EC NOTEXT
  data EXCEPTIONID type E_TOUEXCEPT_INT_ID .
  constants CO_AUTHORITY_OBJ type XUOBJECT value 'ETOUEXCEPT'. "#EC NOTEXT
  constants CO_AUTHORITY_ACTIVITY type FIELDNAME value 'ISU_ACTIVT'. "#EC NOTEXT
  class-data EXIT_REF_ACTIVATION_STATUS type ref to ISU_TOUEXCEPT_STATUS .
  data AUTO_DATA type ETOUEXCEPT_AUTO_DATA .

  methods CHECK_INPUT
    importing
      !X_EXCEPTION_DATA type ETOUEXCEPT_DATA
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_DATE_TIME
    importing
      !X_DATE type E_TOUEXCEPT_DATEFROM optional
      !X_TIME type E_TOUEXCEPT_TIMEFROM optional
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_EXCEPTION_PROGRAM
    importing
      !X_EXCEPTPROG_ID type E_TOUEXCEPTPROG_ID
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_ALREADY_BILLED
    importing
      !X_EXCEPTION_DATA type ETOUEXCEPT_DATA
    exporting
      !Y_ALREADY_BILLED type ABAP_BOOL
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods ENQUEUE_EXCEPTION
    importing
      !X_EXCEPTIONID type E_TOUEXCEPT_INT_ID
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods DEQUEUE_EXCEPTION
    importing
      !X_EXCEPTIONID type E_TOUEXCEPT_INT_ID
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_AUTHORITY
    importing
      !X_ACTIVITY type E_ACTIVITY default SPACE
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods SET_ACTIVATION_STATUS
    importing
      !X_CHANGE_ACTIVATION type ABAP_BOOL
    changing
      !XY_EXCEPTION_DATA type ETOUEXCEPT_DATA
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods PREPARE_AUTO_DATA
    importing
      !X_CONVERT_TIMEZONE type ABAP_BOOL default ABAP_FALSE
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_EXCEPTPROG_TIMERANGE
    importing
      !X_EXCEPTION_DATA type ETOUEXCEPT_DATA
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
  methods CHECK_INTERVAL_SIZE
    importing
      !X_DATETIMEFROM type ETOUEXCEPT_DATETIMEFROM
      !X_DATETIMETO type ETOUEXCEPT_DATETIMETO
      !X_EXCEPTIONPROG_ID type E_TOUEXCEPTPROG_ID
    raising
      CX_ISU_TOUEXCEPTION_GEN_FAULT .
ENDCLASS.



CLASS CL_ISU_TOUEXCEPTION IMPLEMENTATION.


METHOD check_already_billed.

  DATA: lr_exceptbill TYPE REF TO cl_isu_touexception_bill_utils.

* get instance
  CALL METHOD cl_isu_touexception_bill_utils=>get_instance
    RECEIVING
      y_instance = lr_exceptbill.

* check for billing
  CALL METHOD lr_exceptbill->check_exception_billed
    EXPORTING
      im_exceptionid = x_exception_data-exceptionid
    IMPORTING
      ex_billed      = y_already_billed.

ENDMETHOD.


METHOD check_authority.

  DATA: it_authority TYPE tab_isu_author,
        wa_authority TYPE isu_author,
        lv_temp_subrc TYPE sy-subrc,
        lv_val1 TYPE sy-msgv1,
        lv_val2 TYPE sy-msgv2,
        lv_val3 TYPE sy-msgv3.

* fill id table with activity
  wa_authority-id = co_authority_activity.
  wa_authority-field = x_activity.
  APPEND wa_authority TO it_authority.

* call isu authority check
  CALL FUNCTION 'ISU_AUTHORITY_CHECK'
    EXPORTING
      x_object  = co_authority_obj
    IMPORTING
      y_subrc   = lv_temp_subrc
    TABLES
      xt_author = it_authority.

* prepare message
  IF lv_temp_subrc <> 0.

    lv_val3 = me->exceptionid.
    SHIFT lv_val3 LEFT DELETING LEADING '0'.

    CASE x_activity.

* display
      WHEN co_wmode_display.
        lv_val1 = text-002.
        lv_val2 = text-001.

* create
      WHEN co_wmode_create.
        lv_val1 = text-003.
        lv_val2 = text-006.

* change
      WHEN co_wmode_change.
        lv_val1 = text-004.
        lv_val2 = text-001.

* delete
      WHEN co_wmode_delete.
        lv_val1 = text-005.
        lv_val2 = text-001.
    ENDCASE.

    MESSAGE e105(e9) WITH lv_val1 lv_val2 lv_val3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDIF.

ENDMETHOD.


METHOD check_date_time.

* check date
  IF NOT x_date IS INITIAL.

    CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
      EXPORTING
        date                      = x_date
      EXCEPTIONS
        plausibility_check_failed = 1
        OTHERS                    = 2.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

* check time
  IF NOT x_time IS INITIAL.

    CALL FUNCTION 'TIME_CHECK_PLAUSIBILITY'
      EXPORTING
        time                      = x_time
      EXCEPTIONS
        plausibility_check_failed = 1
        OTHERS                    = 2.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

ENDMETHOD.


  METHOD check_exception_extid.

    CLEAR: y_not_found.

    DATA: lv_not_found TYPE abap_bool.

* check new data in obj
    LOOP AT me->instance_db->new_data-exception TRANSPORTING NO FIELDS  ##NEEDED
                 WHERE exceptionextid = x_exception_extid
                   AND exceptionsource = x_exceptionsource
                   AND exceptiondel = abap_false
                   AND exceptionid NE x_exclude_exceptionid.
    ENDLOOP.

    IF sy-subrc = 4.
      lv_not_found = abap_true.
    ELSEIF sy-subrc = 0.
      y_not_found = abap_false.
      RETURN.
    ENDIF.

* check already exist on db
    CALL METHOD me->instance_db->read_exception_extid
      EXPORTING
        x_exception_extid     = x_exception_extid
        x_exclude_exceptionid = x_exclude_exceptionid
        x_exceptionsource     = x_exceptionsource
      IMPORTING
        y_not_found           = lv_not_found.

    y_not_found = lv_not_found.

  ENDMETHOD.


METHOD check_exception_program.

  DATA: lr_exceptprog_db TYPE REF TO cl_isu_touexceptprog_db,
        lw_exceptprog TYPE etouexcptprg.

* get instance
  CALL METHOD cl_isu_touexceptprog_db=>get_instance
    RECEIVING
      y_instance = lr_exceptprog_db.

* check program existing
  CALL METHOD lr_exceptprog_db->get_exception_program
    EXPORTING
      x_exceptprog_id = x_exceptprog_id
    IMPORTING
      y_exceptprog    = lw_exceptprog.

  IF me->control_data-single_creation = abap_true.
    IF lw_exceptprog-act_category NE cl_isu_touexceptprog_db=>actcat_active_specific.
      MESSAGE e024(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD check_exceptprog_timerange.

  DATA: lr_exceptprog_db TYPE REF TO cl_isu_touexceptprog_db,
        ls_exceptprog TYPE etouexcptprg,
        lv_msgval1 TYPE sy-msgv1,
        lv_msgval2 TYPE sy-msgv2,
        ls_except_datetime TYPE etouexcept_data,
        ls_exceptresp_datetime TYPE etouexcept_data.

* get instance
  CALL METHOD cl_isu_touexceptprog_db=>get_instance
    RECEIVING
      y_instance = lr_exceptprog_db.

* get program data
  CALL METHOD lr_exceptprog_db->get_exception_program
    EXPORTING
      x_exceptprog_id = x_exception_data-exceptionprogramid
    IMPORTING
      y_exceptprog    = ls_exceptprog.

* exception, LTC
  ls_except_datetime-datefrom = x_exception_data-datefrom.
  ls_except_datetime-timefrom = x_exception_data-timefrom.
  ls_except_datetime-dateto = x_exception_data-dateto.
  ls_except_datetime-timeto = x_exception_data-timeto.

* program, structure used only for comparing, LTC
  ls_exceptresp_datetime-datefrom = ls_exceptprog-validfrom.
  ls_exceptresp_datetime-timefrom = cl_isu_date=>co_time_finite.
  ls_exceptresp_datetime-dateto = ls_exceptprog-validto.
  ls_exceptresp_datetime-timeto = cl_isu_date=>co_time_infinite.

* exception must be inside the valid time range of the program
  IF NOT ( ( ls_except_datetime-from GE ls_exceptresp_datetime-from ) AND
     ( ls_except_datetime-to LE ls_exceptresp_datetime-to ) ).

* prepare date for the message
    WRITE ls_exceptprog-validfrom TO lv_msgval1.
    WRITE ls_exceptprog-validto TO lv_msgval2.

    MESSAGE e041(ee_toue) INTO cl_isu_touexception_exc_facty=>str
      WITH ls_exceptprog-exceptprogid lv_msgval1 lv_msgval2.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDIF.

ENDMETHOD.


METHOD check_input.

  DATA: wa_new_data TYPE etouexcept_data,
        wa_old_data TYPE etouexcept_data,
        lv_datefrom_char TYPE etouexcept_datetimefrom,
        lv_dateto_char TYPE etouexcept_datetimeto,
        lv_timefrom_char TYPE e_touexcept_timefrom,
        lv_timeto_char TYPE e_touexcept_timeto,
        lx_except TYPE REF TO cx_isu_touexception_gen_fault,
        lv_extid_source_not_exist TYPE abap_bool.

* clear control field
  CLEAR: me->control_data-input_error.

* set error flag
  me->control_data-input_error = abap_true.

* check changings
* new data
  MOVE-CORRESPONDING x_exception_data TO wa_new_data.

* old data
  IF NOT me->data IS INITIAL.
    MOVE-CORRESPONDING me->data TO wa_old_data.
  ENDIF.

* check internal exceptionid
* mandatory field
  IF wa_new_data-exceptionid IS INITIAL.
    MESSAGE e004(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONID'.
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDIF.

* check external id. must be unique for one source
  IF NOT wa_new_data-exceptionextid IS INITIAL.
    IF wa_new_data-exceptionextid <> wa_old_data-exceptionextid.

      TRY.
          CALL METHOD me->check_exception_extid
            EXPORTING
              x_exception_extid     = wa_new_data-exceptionextid
              x_exceptionsource     = wa_new_data-exceptionsource
              x_exclude_exceptionid = wa_new_data-exceptionid
            IMPORTING
              y_not_found           = lv_extid_source_not_exist.

        CATCH cx_isu_touexception_gen_fault INTO lx_except.
          lx_except->error_component = 'EXCEPTIONEXTID'.
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDTRY.

* not unique for one source
      IF lv_extid_source_not_exist = abap_false.
        MESSAGE e048(ee_toue) INTO cl_isu_touexception_exc_facty=>str
           WITH wa_new_data-exceptionextid wa_new_data-exceptionsource.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONEXTID'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDIF.
    ENDIF.
  ENDIF.

* check datefrom
* mandatory field
  IF wa_new_data-datefrom IS INITIAL.
    MESSAGE e005(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    cl_isu_touexception_exc_facty=>gf_exc->error_component = 'DATEFROM'.
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ELSE.
    IF wa_new_data-datefrom <> wa_old_data-datefrom.

* check datefrom plausibility
      TRY.
          CALL METHOD me->check_date_time
            EXPORTING
              x_date = wa_new_data-datefrom.

        CATCH cx_isu_touexception_gen_fault INTO lx_except.
          lx_except->error_component = 'DATEFROM'.
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDTRY.
    ENDIF.
  ENDIF.

* check timefrom
* mandatory field
  IF NOT wa_new_data-timefrom IS INITIAL.
    IF wa_new_data-timefrom <> wa_old_data-timefrom.

* check timefrom plausibility
      TRY.
          CALL METHOD me->check_date_time
            EXPORTING
              x_time = wa_new_data-timefrom.

        CATCH cx_isu_touexception_gen_fault INTO lx_except.
          lx_except->error_component = 'TIMEFROM'.
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDTRY.
    ENDIF.
  ENDIF.

* check dateto
* mandatory field
  IF wa_new_data-dateto IS INITIAL.
    MESSAGE e007(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    cl_isu_touexception_exc_facty=>gf_exc->error_component = 'DATETO'.
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ELSE.
    IF wa_new_data-dateto <> wa_old_data-dateto.

* check dateto plausibility
      TRY.
          CALL METHOD me->check_date_time
            EXPORTING
              x_date = wa_new_data-dateto.

        CATCH cx_isu_touexception_gen_fault INTO lx_except.
          lx_except->error_component = 'DATETO'.
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDTRY.
    ENDIF.
  ENDIF.

* check timeto
* mandatory field
  IF wa_new_data-timeto IS INITIAL.
    MESSAGE e008(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    cl_isu_touexception_exc_facty=>gf_exc->error_component = 'TIMETO'.
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ELSE.
    IF wa_new_data-timeto <> wa_old_data-timeto.

* check timeto plausibility
      TRY.
          CALL METHOD me->check_date_time
            EXPORTING
              x_time = wa_new_data-timeto.

        CATCH cx_isu_touexception_gen_fault INTO lx_except.
          lx_except->error_component = 'TIMETO'.
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDTRY.
    ENDIF.
  ENDIF.

* compare datefrom with dateto
  IF ( NOT wa_new_data-datefrom IS INITIAL )
 AND ( NOT wa_new_data-dateto IS INITIAL ).

    IF wa_new_data-datefrom > wa_new_data-dateto.
      WRITE wa_new_data-datefrom TO lv_datefrom_char.
      WRITE wa_new_data-dateto TO lv_dateto_char.

      MESSAGE e009(ee_toue) INTO cl_isu_touexception_exc_facty=>str
         WITH lv_dateto_char lv_datefrom_char.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'DATETO'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

* compare timefrom with timeto, in case of the same date
  IF wa_new_data-datefrom = wa_new_data-dateto.

    IF ( NOT wa_new_data-timefrom IS INITIAL )
   AND ( NOT wa_new_data-timeto IS INITIAL ).

      IF wa_new_data-timefrom >= wa_new_data-timeto.
        WRITE wa_new_data-timefrom TO lv_timefrom_char.
        WRITE wa_new_data-timeto TO lv_timeto_char.

        MESSAGE e023(ee_toue) INTO cl_isu_touexception_exc_facty=>str
           WITH lv_timefrom_char lv_timeto_char.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'TIMETO'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDIF.
    ENDIF.
  ENDIF.

* check programid
* mandatory field
  IF wa_new_data-exceptionprogramid IS INITIAL.
    MESSAGE e010(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ELSE.

* check programid
    IF wa_new_data-exceptionprogramid <> wa_old_data-exceptionprogramid.
      TRY.
          CALL METHOD me->check_exception_program
            EXPORTING
              x_exceptprog_id = wa_new_data-exceptionprogramid.

        CATCH cx_isu_touexception_gen_fault INTO lx_except.
          lx_except->error_component = 'EXCEPTIONPROGRAMID'.
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDTRY.
    ENDIF.
  ENDIF.

* reset error flag
  me->control_data-input_error = abap_false.

* set changed info
  IF wa_new_data <> wa_old_data.
    me->control_data-changed = abap_true.
  ENDIF.

ENDMETHOD.


METHOD check_interval_size.

  DATA: lr_exceptbill TYPE REF TO cl_isu_touexception_bill_utils,
        lx_bill TYPE REF to cx_isu_billing_general_fault.    "#EC NEEDED

* get instance
  CALL METHOD cl_isu_touexception_bill_utils=>get_instance
    RECEIVING
      y_instance = lr_exceptbill.

* check interval size
  TRY.
      CALL METHOD lr_exceptbill->det_intsizes_and_check_from_to
        EXPORTING
          x_exceptprogid = x_exceptionprog_id
          x_from         = x_datetimefrom
          x_to           = x_datetimeto.

* check is only needed if the TOU-exception program is assigned to a conditional billing program
    CATCH cx_isu_billing_general_fault INTO lx_bill.    "#EC NO_HANDLER

    CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDTRY.

ENDMETHOD.


METHOD check_overlap_in_exceptprog.

  FIELD-SYMBOLS: <wa_exception> TYPE etouexception.

  DATA: lr_exceptprog_db TYPE REF TO cl_isu_touexceptprog_db,
        lw_exceptprog TYPE etouexcptprg,
        lv_msgval1 TYPE sy-msgv1,
        lv_msgval2 TYPE sy-msgv2,
        lv_msgval3 TYPE sy-msgv3,
        lv_msgval4 TYPE sy-msgv4,
        it_exception TYPE etouexception_tab,
        lv_date TYPE char10,
        lv_time TYPE char8,
        ls_datetimefrom TYPE etouexcept_datetimefrom,
        ls_datetimeto TYPE etouexcept_datetimeto,
        ls_etouexceptprog_id_range TYPE etouexceptprog_id_range,
        lt_etouexceptprog_id_range TYPE etouexceptprog_id_range_tab,
        lv_not_found TYPE abap_bool.

* get instance
  CALL METHOD cl_isu_touexceptprog_db=>get_instance
    RECEIVING
      y_instance = lr_exceptprog_db.

* check program existing
  CALL METHOD lr_exceptprog_db->get_exception_program
    EXPORTING
      x_exceptprog_id = x_exception_data-exceptionprogramid
    IMPORTING
      y_exceptprog    = lw_exceptprog.

* check is running only if the activation category is not customer individual
  IF lw_exceptprog-act_category NE cl_isu_touexceptprog_db=>actcat_active_specific.

* check in new data
    LOOP AT me->instance_db->new_data-exception ASSIGNING <wa_exception> ##BOOL_OK
                WHERE exceptionprogramid = x_exception_data-exceptionprogramid
                  AND ( exceptiondel NE abap_true )
                  AND ( exceptionid NE x_exception_data-exceptionid )
                  AND ( ( ( ( from BETWEEN x_exception_data-from
                                   AND x_exception_data-to )
                   OR ( to BETWEEN x_exception_data-from
                               AND x_exception_data-to ) ) )
                   OR ( ( ( from BETWEEN x_exception_data-from
                                   AND x_exception_data-to )
                   AND ( to BETWEEN x_exception_data-from
                               AND x_exception_data-to ) ) )
                   OR ( from < x_exception_data-from
                        AND to > x_exception_data-to ) ).

      lv_msgval1 = <wa_exception>-exceptionid.
      SHIFT lv_msgval1 LEFT DELETING LEADING '0'.

      lv_msgval2 = <wa_exception>-exceptionprogramid.

* prepare date/time for the message
      CALL METHOD cl_isu_touexception=>convert_utc_datetime_to_tc
        EXPORTING
          x_date_utc = <wa_exception>-datefrom
          x_time_utc = <wa_exception>-timefrom
          x_timezone = <wa_exception>-exceptionprogtimezone
        IMPORTING
          y_date     = ls_datetimefrom-datefrom
          y_time     = ls_datetimefrom-timefrom.

      WRITE ls_datetimefrom-datefrom TO lv_date.
      WRITE ls_datetimefrom-timefrom TO lv_time.
      CONCATENATE lv_date lv_time INTO lv_msgval3 SEPARATED BY space.

      CALL METHOD cl_isu_touexception=>convert_utc_datetime_to_tc
        EXPORTING
          x_date_utc = <wa_exception>-dateto
          x_time_utc = <wa_exception>-timeto
          x_timezone = <wa_exception>-exceptionprogtimezone
        IMPORTING
          y_date     = ls_datetimeto-dateto
          y_time     = ls_datetimeto-timeto.

      WRITE ls_datetimeto-dateto TO lv_date.
      WRITE ls_datetimeto-timeto TO lv_time.
      CONCATENATE lv_date lv_time INTO lv_msgval4 SEPARATED BY space.

      MESSAGE e029(ee_toue) INTO cl_isu_touexception_exc_facty=>str    ##mg_missing
        WITH lv_msgval1 lv_msgval2 lv_msgval3 lv_msgval4.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDLOOP.

* check database
    ls_etouexceptprog_id_range-sign   = 'I'.
    ls_etouexceptprog_id_range-option = 'EQ'.
    ls_etouexceptprog_id_range-low    = x_exception_data-exceptionprogramid.
    ls_etouexceptprog_id_range-high    = x_exception_data-exceptionprogramid.
    APPEND ls_etouexceptprog_id_range TO lt_etouexceptprog_id_range.

    CALL METHOD me->instance_db->read_exception_by_program
      EXPORTING
        xt_exceptionprog_id_range = lt_etouexceptprog_id_range
      IMPORTING
        yt_exception              = it_exception
        y_not_found               = lv_not_found.

    IF lv_not_found = abap_true.
      RETURN.
    ENDIF.

    IF NOT it_exception IS INITIAL.

      LOOP AT it_exception ASSIGNING <wa_exception> ##BOOL_OK
                  WHERE exceptionid NE x_exception_data-exceptionid
                    AND ( ( ( ( from BETWEEN x_exception_data-from
                                     AND x_exception_data-to )
                     OR ( to BETWEEN x_exception_data-from
                                 AND x_exception_data-to ) ) )
                     OR ( ( ( from BETWEEN x_exception_data-from
                                   AND x_exception_data-to )
                    AND ( to BETWEEN x_exception_data-from
                               AND x_exception_data-to ) ) )
                     OR ( from < x_exception_data-from
                          AND to > x_exception_data-to ) ).

        lv_msgval1 = <wa_exception>-exceptionid.
        SHIFT lv_msgval1 LEFT DELETING LEADING '0'.

        lv_msgval2 = <wa_exception>-exceptionprogramid.

* prepare date/time for the message
        CALL METHOD cl_isu_touexception=>convert_utc_datetime_to_tc
          EXPORTING
            x_date_utc = <wa_exception>-datefrom
            x_time_utc = <wa_exception>-timefrom
            x_timezone = <wa_exception>-exceptionprogtimezone
          IMPORTING
            y_date     = ls_datetimefrom-datefrom
            y_time     = ls_datetimefrom-timefrom.

        WRITE ls_datetimefrom-datefrom TO lv_date.
        WRITE ls_datetimefrom-timefrom TO lv_time.
        CONCATENATE lv_date lv_time INTO lv_msgval3 SEPARATED BY space.

        CALL METHOD cl_isu_touexception=>convert_utc_datetime_to_tc
          EXPORTING
            x_date_utc = <wa_exception>-dateto
            x_time_utc = <wa_exception>-timeto
            x_timezone = <wa_exception>-exceptionprogtimezone
          IMPORTING
            y_date     = ls_datetimeto-dateto
            y_time     = ls_datetimeto-timeto.

        WRITE ls_datetimeto-dateto TO lv_date.
        WRITE ls_datetimeto-timeto TO lv_time.
        CONCATENATE lv_date lv_time INTO lv_msgval4 SEPARATED BY space.

        MESSAGE e029(ee_toue) INTO cl_isu_touexception_exc_facty=>str   ##mg_missing
          WITH lv_msgval1 lv_msgval2 lv_msgval3 lv_msgval4.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDLOOP.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD check_user.

  DATA: lv_user TYPE sy-uname.

  CLEAR: y_not_found.

  IF NOT x_user IS INITIAL.

    SELECT SINGLE bname FROM usr02 INTO lv_user
                        WHERE bname = x_user.

    IF sy-subrc = 4.
      y_not_found = abap_true.
    ELSEIF sy-subrc <> 0.
      MESSAGE e014(e9) WITH 'USR02' space space space INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD class_constructor.

  DATA: lref_badi_error TYPE REF TO cx_badi_not_implemented. "#EC NEEDED

* get instance of the BADI
  TRY.
      GET BADI exit_ref_activation_status.

    CATCH cx_badi_not_implemented INTO lref_badi_error. "#EC NO_HANDLER
  ENDTRY.

ENDMETHOD.


METHOD close.

* check mode
  IF xy_instance->control_data-wmode = co_wmode_change OR
     xy_instance->control_data-wmode = co_wmode_delete.

* do dequeue
    CALL METHOD xy_instance->dequeue_exception
      EXPORTING
        x_exceptionid = xy_instance->exceptionid.
  ENDIF.

* clear object
  CLEAR: xy_instance.

ENDMETHOD.


METHOD constructor.

  DATA: wa_exception TYPE etouexception,
        wa_exception_arch TYPE etouexcept_data,
        wa_exceptiontxt TYPE etouexceptiont,
        lx_except TYPE REF TO cx_isu_touexception_gen_fault, "#EC NEEDED
        lv_new_entry TYPE abap_bool,
        lv_exceptionid TYPE e_touexcept_int_id.

* set control data
  me->control_data-wmode = x_wmode.
  me->control_data-no_dialog = x_no_dialog.
  me->control_data-single_creation = x_single_creation.
  me->control_data-single_creation_contract = x_single_creation_contract.

* init attributes
  me->instance_db = x_exception_ref_db.
  me->exceptionid = x_exceptionid.

* auto data
  me->auto_data = x_auto_data.

* check authority
  IF x_wmode = co_wmode_create
     OR x_wmode = co_wmode_change
     OR x_wmode = co_wmode_delete.

    CALL METHOD me->check_authority
      EXPORTING
        x_activity = x_wmode.
  ENDIF.

* display exception
  IF x_wmode = co_wmode_display.

* determine the exception
    READ TABLE me->instance_db->db_data-exception
       WITH KEY exceptionid = x_exceptionid INTO wa_exception.

    IF sy-subrc <> 0.

* archive data
      CLEAR: wa_exceptiontxt.

      READ TABLE me->instance_db->db_data-exceptionarchive
         WITH KEY exceptionid = x_exceptionid INTO wa_exception_arch.

      IF sy-subrc = 0.
        MOVE-CORRESPONDING wa_exception_arch TO wa_exception. "#EC ENHOK
        wa_exceptiontxt-exceptionid = wa_exception_arch-exceptionid.
        wa_exceptiontxt-exceptiontxt = wa_exception_arch-exceptiontxt.
      ELSE.
        MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDIF.

      APPEND wa_exception TO me->instance_db->db_data-exception.

      IF NOT wa_exceptiontxt-exceptiontxt IS INITIAL.
        APPEND wa_exceptiontxt TO me->instance_db->db_data-exceptiontxt.
      ENDIF.
    ENDIF.

    APPEND wa_exception TO me->instance_db->new_data-exception.
    SORT me->instance_db->new_data-exception BY exceptionid.
    DELETE ADJACENT DUPLICATES FROM me->instance_db->new_data-exception.

* determine the exception text
    CLEAR: wa_exceptiontxt.

    READ TABLE me->instance_db->db_data-exceptiontxt
       WITH KEY exceptionid = x_exceptionid INTO wa_exceptiontxt.

    IF sy-subrc <> 0.                                       "#EC NEEDED
* do nothing
    ENDIF.

    IF NOT wa_exceptiontxt-exceptiontxt IS INITIAL.
      APPEND wa_exceptiontxt TO me->instance_db->new_data-exceptiontxt.
      SORT me->instance_db->new_data-exceptiontxt BY exceptionid.
      DELETE ADJACENT DUPLICATES FROM me->instance_db->new_data-exceptiontxt.
    ENDIF.
  ENDIF.

* change or delete exception
  IF x_wmode = co_wmode_change
    OR x_wmode = co_wmode_delete.

    TRY.
        CALL METHOD me->instance_db->read_single_exception
          EXPORTING
            x_exception_int_id = x_exceptionid
          IMPORTING
            y_exception        = wa_exception
            y_exceptiontxt     = wa_exceptiontxt.

      CATCH cx_isu_touexception_gen_fault INTO lx_except.

* determnine the exception
        READ TABLE me->instance_db->new_data-exception
           WITH KEY exceptionid = x_exceptionid INTO wa_exception.

        IF sy-subrc <> 0.
          MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
          cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
        ENDIF.

* text
        READ TABLE me->instance_db->new_data-exceptiontxt
            WITH KEY exceptionid = x_exceptionid INTO wa_exceptiontxt.

        IF sy-subrc <> 0.                                   "#EC NEEDED
* do nothing
        ENDIF.

* check if archived
        READ TABLE me->instance_db->db_data-exceptionarchive TRANSPORTING NO FIELDS
                WITH KEY exceptionid = x_exceptionid
                         exceptionarchived = abap_true.

        IF sy-subrc = 0.
          lv_exceptionid = x_exceptionid.
          SHIFT lv_exceptionid LEFT DELETING LEADING '0'.

          IF x_wmode = co_wmode_change.
            MESSAGE e046(ee_toue) WITH lv_exceptionid INTO cl_isu_touexception_exc_facty=>str.
            cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
            RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
          ELSEIF x_wmode = co_wmode_delete.
            MESSAGE e047(ee_toue) WITH lv_exceptionid INTO cl_isu_touexception_exc_facty=>str.
            cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
            RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
          ENDIF.
        ENDIF.

        lv_new_entry = abap_true.
    ENDTRY.

    IF lv_new_entry = abap_false.

      MODIFY TABLE me->instance_db->db_data-exception FROM wa_exception.

      IF sy-subrc <> 0.
        MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDIF.
    ENDIF.

    MODIFY TABLE me->instance_db->new_data-exception FROM wa_exception.

    IF sy-subrc <> 0.
      MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.

* text
    IF NOT wa_exceptiontxt-exceptiontxt IS INITIAL.
      MODIFY TABLE me->instance_db->new_data-exceptiontxt FROM wa_exceptiontxt.
    ENDIF.

* update admin fields and exception status
    IF x_no_dialog = abap_true.
      me->auto_data-exception-cr_date = wa_exception-cr_date.
      me->auto_data-exception-cr_time = wa_exception-cr_time.
      me->auto_data-exception-cr_name = wa_exception-cr_name.
      me->auto_data-exception-ch_date = wa_exception-ch_date.
      me->auto_data-exception-ch_time = wa_exception-ch_time.
      me->auto_data-exception-ch_name = wa_exception-ch_name.

      me->auto_data-exception-exceptionstatus = wa_exception-exceptionstatus.
    ENDIF.
  ENDIF.

* create exception
  IF x_wmode = co_wmode_create.
    wa_exception-exceptionid = x_exceptionid.
  ENDIF.

* move current exception in data (only for working)
  MOVE-CORRESPONDING wa_exception TO me->data.              "#EC ENHOK
  me->data-exceptiontxt = wa_exceptiontxt-exceptiontxt.

  IF NOT wa_exception_arch IS INITIAL.
    me->data-exceptiontxt = wa_exception_arch-exceptiontxt.
    me->data-exceptionarchived = wa_exception_arch-exceptionarchived.
  ENDIF.

ENDMETHOD.


METHOD convert_tc_datetime_to_utc.

  DATA: lv_timezone TYPE timezone.

* determine timezone
  IF NOT x_timezone IS INITIAL.
    lv_timezone = x_timezone.
  ELSE.
    lv_timezone = sy-zonlo.
  ENDIF.

* no utc conversion for infinite date/time
  IF x_date = cl_isu_date=>co_date_infinite AND
     x_time = cl_isu_date=>co_time_infinite.

    y_date_utc = x_date.
    y_time_utc = x_time.
  ELSE.

* convert
    CALL FUNCTION 'ISU_DATE_TIME_CONVERT_UTC'
      EXPORTING
        x_date        = x_date
        x_time        = x_time
        x_timezone    = lv_timezone
      IMPORTING
        y_date_utc    = y_date_utc
        y_time_utc    = y_time_utc
      EXCEPTIONS
        general_fault = 1
        OTHERS        = 2.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD convert_utc_datetime_to_tc.

  DATA: lv_timezone TYPE timezone.

* determine timezone
  IF NOT x_timezone IS INITIAL.
    lv_timezone = x_timezone.
  ELSE.
    lv_timezone = sy-zonlo.
  ENDIF.

* no utc conversion for infinite date/time
  IF x_date_utc = cl_isu_date=>co_date_infinite AND
     x_time_utc = cl_isu_date=>co_time_infinite.

    y_date = x_date_utc.
    y_time = x_time_utc.
  ELSE.

* convert
    CALL FUNCTION 'ISU_DATE_TIME_CONVERT_TIMEZONE'
      EXPORTING
        x_date_utc    = x_date_utc
        x_time_utc    = x_time_utc
        x_timezone    = lv_timezone
      IMPORTING
        y_date_lcl    = y_date
        y_time_lcl    = y_time
      EXCEPTIONS
        general_fault = 1
        OTHERS        = 2.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD delete_dependent_exceptresp.

  DATA: lr_exceptresp_db TYPE REF TO cl_isu_touexceptresp_db, "#EC NEEDED
        lr_exceptresp TYPE REF TO cl_isu_touexceptresp,
        lt_exceptresp_instance TYPE etouexceptresp_instance_tab,
        lt_sel_exceptid TYPE isu_ranges_tab,
        lv_exceptid TYPE e_touexcept_int_id,
        wa_exceptid_range TYPE isu_ranges,
        ls_sel_exceptresp TYPE etouexceptresp_selection,
        lx_except TYPE REF TO cx_isu_touexception_gen_fault. "#EC NEEDED

* prepare selection
  LOOP AT xt_exceptionid INTO lv_exceptid.
    wa_exceptid_range-sign = 'I'.
    wa_exceptid_range-option  = 'EQ'.
    wa_exceptid_range-low = lv_exceptid.
    APPEND wa_exceptid_range TO lt_sel_exceptid[].
  ENDLOOP.

  ls_sel_exceptresp-exceptionid = lt_sel_exceptid.

* get object list in delete mode
  TRY.
      CALL METHOD cl_isu_touexceptresp=>get_exception_response_list
        EXPORTING
          x_exceptresp_selection   = ls_sel_exceptresp
          x_wmode                  = cl_isu_touexceptresp=>co_wmode_delete
        IMPORTING
          yt_exceptresp            = lt_exceptresp_instance
          y_exceptresp_instance_db = lr_exceptresp_db.

    CATCH cx_isu_touexception_gen_fault INTO lx_except. "#EC NO_HANDLER
  ENDTRY.

  IF NOT lt_exceptresp_instance IS INITIAL.

* work on list
    LOOP AT lt_exceptresp_instance INTO lr_exceptresp.

* delete responses
      CALL METHOD lr_exceptresp->delete_exception_response
        EXPORTING
          x_force_db_delete = abap_false.
    ENDLOOP.
  ENDIF.

ENDMETHOD.


METHOD delete_exception.

  DATA: wa_exception TYPE etouexception,
        wa_exceptiontxt TYPE etouexceptiont,
        lv_already_billed TYPE abap_bool,
        lv_exceptionid TYPE e_touexcept_int_id,
        lt_except_id TYPE etouexcept_id_tab,
        lt_exceptiontxt TYPE etouexceptiont_tab.

  MOVE-CORRESPONDING me->data TO wa_exception.              "#EC ENHOK
  wa_exception-mandt = sy-mandt.

* text data
  wa_exceptiontxt-mandt = sy-mandt.
  wa_exceptiontxt-spras = sy-langu.
  wa_exceptiontxt-exceptionid = me->exceptionid.
  wa_exceptiontxt-exceptiontxt = me->data-exceptiontxt.

* delete data
  IF me->control_data-wmode = co_wmode_delete.

* check billing
    TRY.
        CALL METHOD me->check_already_billed
          EXPORTING
            x_exception_data = me->data
          IMPORTING
            y_already_billed = lv_already_billed.

      CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDTRY.

    IF lv_already_billed = abap_true.

      lv_exceptionid = me->data-exceptionid.
      SHIFT lv_exceptionid LEFT DELETING LEADING '0'.

      MESSAGE e037(ee_toue) WITH lv_exceptionid INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.

* determine all relevant texts
    CALL METHOD me->instance_db->read_exception_text
      EXPORTING
        x_exception_int_id = me->exceptionid
      IMPORTING
        yt_exceptiontxt    = lt_exceptiontxt.

    IF x_force_db_delete = abap_true.

* delete
      DELETE TABLE me->instance_db->new_data-exception FROM wa_exception.

      IF sy-subrc <> 0.
        MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDIF.

* text
      IF NOT lt_exceptiontxt IS INITIAL.
        LOOP AT lt_exceptiontxt INTO wa_exceptiontxt.

          DELETE TABLE me->instance_db->new_data-exceptiontxt FROM wa_exceptiontxt.

          IF sy-subrc <> 0.                                 "#EC NEEDED

* other language to new
            INSERT wa_exceptiontxt INTO TABLE me->instance_db->db_data-exceptiontxt.

            IF sy-subrc <> 0.                               "#EC NEEDED
* do nothing
            ENDIF.
          ENDIF.

          CLEAR: wa_exceptiontxt.
        ENDLOOP.
      ENDIF.

* set deletion flag
    ELSE.

      wa_exception-exceptiondel = abap_true.

* check first, if exception is on database
      READ TABLE me->instance_db->db_data-exception TRANSPORTING NO FIELDS
          WITH KEY exceptionid = wa_exception-exceptionid.

      IF sy-subrc = 0.

* exception
        MODIFY TABLE me->instance_db->new_data-exception FROM wa_exception.

        IF sy-subrc <> 0.
          MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
          cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
        ENDIF.
      ELSE.

        DELETE TABLE me->instance_db->new_data-exception FROM wa_exception.

        IF sy-subrc <> 0.
          MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
          cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
        ENDIF.
      ENDIF.
    ENDIF.

* delete depending responses
    APPEND me->data-exceptionid TO lt_except_id.

    CALL METHOD cl_isu_touexception=>delete_dependent_exceptresp
      EXPORTING
        xt_exceptionid = lt_except_id.
  ENDIF.

ENDMETHOD.


METHOD dequeue_exception.

* dequeue exception
  CALL FUNCTION 'DEQUEUE_E_TOUEXCEPT'
    EXPORTING
      exceptionid = x_exceptionid.

ENDMETHOD.


METHOD enqueue_exception.

* enqueue exception
  CALL FUNCTION 'ENQUEUE_E_TOUEXCEPT'
    EXPORTING
      exceptionid    = x_exceptionid
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.

  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDIF.

ENDMETHOD.


METHOD get_exception_list.

  DATA: lr_except_db TYPE REF TO cl_isu_touexception_db,
        lr_except TYPE REF TO cl_isu_touexception,
        it_exception TYPE etouexcept_instance_tab.

  FIELD-SYMBOLS: <wa_exception> TYPE etouexception,
                 <wa_exception_data> TYPE etouexcept_data.

  CLEAR: yt_exception,
         y_not_found.

* get instance for exception db
  CALL METHOD cl_isu_touexception_db=>get_instance
    RECEIVING
      y_instance = lr_except_db.

* select data
  CALL METHOD lr_except_db->read_exception_by_selection
    EXPORTING
      xt_exception_sel    = xt_exception_sel
      x_read_exceptiontxt = abap_true
    IMPORTING
      y_not_found         = y_not_found.

  IF y_not_found = abap_true.
    RETURN.
  ENDIF.

* get instance for exception
  LOOP AT lr_except_db->db_data-exception ASSIGNING <wa_exception>.

    CALL METHOD cl_isu_touexception=>get_instance
      EXPORTING
        x_wmode            = co_wmode_display
        x_no_dialog        = abap_false
        x_exception_ref_db = lr_except_db
        x_exceptionid      = <wa_exception>-exceptionid
      IMPORTING
        y_instance         = lr_except.

    APPEND lr_except TO it_exception[].
  ENDLOOP.

* exceptions from archive
  IF xt_exception_sel-archive = abap_true
     AND NOT lr_except_db->db_data-exceptionarchive IS INITIAL.

    LOOP AT lr_except_db->db_data-exceptionarchive ASSIGNING <wa_exception_data>.

      CALL METHOD cl_isu_touexception=>get_instance
        EXPORTING
          x_wmode            = co_wmode_display
          x_no_dialog        = abap_false
          x_exception_ref_db = lr_except_db
          x_exceptionid      = <wa_exception_data>-exceptionid
        IMPORTING
          y_instance         = lr_except.

      APPEND lr_except TO it_exception[].
    ENDLOOP.
  ENDIF.

  y_except_instance_db = lr_except_db.
  yt_exception = it_exception[].

ENDMETHOD.


METHOD get_input_status.

* read input status
  y_input_status = control_data-input_error.
  y_input_changed = control_data-changed.

ENDMETHOD.


METHOD get_instance.

  DATA: lr_except TYPE REF TO cl_isu_touexception.

* check work mode
  IF x_wmode = co_wmode_create  OR
     x_wmode = co_wmode_change  OR
     x_wmode = co_wmode_display OR
     x_wmode = co_wmode_delete.
  ELSE.
    MESSAGE e002(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
    cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
    RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDIF.

* create object
  IF lr_except IS INITIAL.

    CREATE OBJECT lr_except
      EXPORTING
        x_wmode                    = x_wmode
        x_no_dialog                = x_no_dialog
        x_exception_ref_db         = x_exception_ref_db
        x_exceptionid              = x_exceptionid
        x_single_creation          = x_single_creation
        x_single_creation_contract = x_single_creation_contract
        x_auto_data                = x_auto_data.

* do enqueue
    IF x_wmode = co_wmode_change OR
       x_wmode = co_wmode_delete.

      CALL METHOD lr_except->enqueue_exception
        EXPORTING
          x_exceptionid = x_exceptionid.
    ENDIF.
  ENDIF.

* take over id and reference
  IF xy_exceptionid IS INITIAL.
    xy_exceptionid = lr_except->exceptionid.
  ENDIF.

* prepare auto data
  IF x_no_dialog = abap_true AND x_auto_data IS NOT INITIAL.
    CALL METHOD lr_except->prepare_auto_data.
  ENDIF.

  y_instance = lr_except.

ENDMETHOD.


METHOD get_wmode.

* wmode
  y_wmode = control_data-wmode.

ENDMETHOD.


METHOD prepare_auto_data.

  DATA: ls_exception_data TYPE etouexcept_data.

* process the checks for create, change and delete exception
  IF me->control_data-wmode = co_wmode_create
       OR me->control_data-wmode = co_wmode_change.

    ls_exception_data = me->auto_data.                      "#EC ENHOK

    IF x_convert_timezone = abap_true.

* convert time zone date/time from
      CALL METHOD cl_isu_touexception=>convert_utc_datetime_to_tc
        EXPORTING
          x_date_utc = ls_exception_data-datefrom
          x_time_utc = ls_exception_data-timefrom
          x_timezone = ls_exception_data-exceptionprogtimezone
        IMPORTING
          y_date     = ls_exception_data-datefrom
          y_time     = ls_exception_data-timefrom.

* convert time zone date/time to
      CALL METHOD cl_isu_touexception=>convert_utc_datetime_to_tc
        EXPORTING
          x_date_utc = ls_exception_data-dateto
          x_time_utc = ls_exception_data-timeto
          x_timezone = ls_exception_data-exceptionprogtimezone
        IMPORTING
          y_date     = ls_exception_data-dateto
          y_time     = ls_exception_data-timeto.
    ENDIF.

* set exception
    CALL METHOD me->set_exception
      CHANGING
        xy_exception_data = ls_exception_data.
  ENDIF.

* delete exception
  IF me->control_data-wmode = co_wmode_delete.
    CALL METHOD me->delete_exception.
  ENDIF.

ENDMETHOD.


METHOD process_auto_data.

  DATA: lr_except_db TYPE REF TO cl_isu_touexception_db,
        lr_except TYPE REF TO cl_isu_touexception,
        lt_exception TYPE etouexcept_instance_tab,
        lt_exception_sel TYPE etouexcept_selection,
        lt_sel_exceptid TYPE etouexcept_int_id_range_tab,
        wa_exceptid_range TYPE etouexcept_int_id_range,
        wa_exception_data TYPE etouexcept_data,
        lv_not_found TYPE abap_bool.

  FIELD-SYMBOLS: <wa_exception_auto_data> TYPE etouexcept_auto_data.

* get instance for exception db
  CALL METHOD cl_isu_touexception_db=>get_instance
    RECEIVING
      y_instance = lr_except_db.

* change and delete mode
  IF x_wmode = cl_isu_touexception=>co_wmode_change OR
      x_wmode = cl_isu_touexception=>co_wmode_delete.

* prepare selection
    LOOP AT xt_exception INTO wa_exception_data.            "#EC ENHOK
      wa_exceptid_range-sign = 'I'.
      wa_exceptid_range-option  = 'EQ'.
      wa_exceptid_range-low = wa_exception_data-exceptionid.
      APPEND wa_exceptid_range TO lt_sel_exceptid[].
    ENDLOOP.

    lt_exception_sel-exceptionid = lt_sel_exceptid[].

* select data
    CALL METHOD lr_except_db->read_exception_by_selection
      EXPORTING
        xt_exception_sel    = lt_exception_sel
        x_read_exceptiontxt = abap_true
      IMPORTING
        y_not_found         = lv_not_found.

    IF lv_not_found = abap_true.
      MESSAGE e001(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ELSE.
      lr_except_db->new_data = lr_except_db->db_data.
    ENDIF.
  ENDIF.

* get instance for exception
  LOOP AT xt_exception ASSIGNING <wa_exception_auto_data>.

    CALL METHOD cl_isu_touexception=>get_instance
      EXPORTING
        x_wmode            = x_wmode
        x_no_dialog        = abap_true
        x_exception_ref_db = lr_except_db
        x_exceptionid      = <wa_exception_auto_data>-exception-exceptionid
        x_auto_data        = <wa_exception_auto_data>
      IMPORTING
        y_instance         = lr_except.

    APPEND lr_except TO lt_exception.
    APPEND lr_except->data TO yt_exception.
  ENDLOOP.

* prepare save
  CALL METHOD lr_except_db->prepare_save.

* save
  CALL METHOD lr_except_db->save.

* close exception objects
  LOOP AT lt_exception INTO lr_except.

    CALL METHOD cl_isu_touexception=>close
      CHANGING
        xy_instance = lr_except.
  ENDLOOP.

* close db object
  CALL METHOD cl_isu_touexception_db=>close
    CHANGING
      xy_instance = lr_except_db.

* commit handling
  IF x_no_commit = abap_false.
    COMMIT WORK.
  ENDIF.

ENDMETHOD.


METHOD set_activation_status.

* check during change status (both directions)
  IF x_change_activation = abap_true.
    IF NOT me->exit_ref_activation_status IS INITIAL.

* check alread billed
      CALL BADI me->exit_ref_activation_status->check_change_activation_status
        EXPORTING
          x_exceptionid = xy_exception_data-exceptionid.
    ENDIF.
  ENDIF.

* initialization
  IF me->control_data-wmode = me->co_wmode_create.

    IF NOT me->exit_ref_activation_status IS INITIAL.

* set defined default values for activation status
      CALL BADI me->exit_ref_activation_status->set_activation_status
        EXPORTING
          x_exception_data    = xy_exception_data
        CHANGING
          xy_exception_status = xy_exception_data-exceptionstatus.
    ENDIF.
  ELSE.

* change the activation
    IF x_change_activation = abap_true.
      IF xy_exception_data-exceptionstatus = cl_isu_touexception=>co_status_active.
        xy_exception_data-exceptionstatus = cl_isu_touexception=>co_status_inactive.
      ELSEIF xy_exception_data-exceptionstatus = cl_isu_touexception=>co_status_inactive.
        xy_exception_data-exceptionstatus = cl_isu_touexception=>co_status_active.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD set_exception.

  DATA: wa_exception TYPE etouexception,
        wa_exceptiontxt TYPE etouexceptiont,
        lv_exceptprog_timezone TYPE e_touep_tzone,
        lr_exceptprog TYPE REF TO cl_isu_touexceptprog_db,
        lv_already_billed TYPE abap_bool,
        lv_exceptionid TYPE e_touexcept_int_id,
        lr_exceptbill TYPE REF TO cl_isu_touexception_bill_utils.

  IF me->control_data-wmode = co_wmode_create.

* get new number
    CALL FUNCTION 'ISU_NUMBER_GET'
      EXPORTING
        object                      = co_exception_number_range
      IMPORTING
        number                      = me->exceptionid
      EXCEPTIONS
        no_range_number_found       = 1
        number_not_in_intervall     = 2
        interval_not_found          = 3
        quantity_is_0               = 4
        interval_te009_inconsistent = 5
        number_invalid              = 6
        interval_overflow           = 7
        OTHERS                      = 8.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.

    xy_exception_data-exceptionid = me->exceptionid.
  ENDIF.

* check input
  CALL METHOD me->check_input
    EXPORTING
      x_exception_data = xy_exception_data.

* set error flag
  me->control_data-input_error = abap_true.

* check interval size, with LTC
  TRY.
      CALL METHOD me->check_interval_size
        EXPORTING
          x_datetimefrom     = xy_exception_data-from
          x_datetimeto       = xy_exception_data-to
          x_exceptionprog_id = xy_exception_data-exceptionprogramid.

    CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'TIMETO'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDTRY.

* check valid time range from program, with LTC
  TRY.
      CALL METHOD me->check_exceptprog_timerange
        EXPORTING
          x_exception_data = xy_exception_data.

    CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDTRY.

* check individual exception with contract
  IF me->control_data-wmode = co_wmode_create
    AND NOT me->control_data-single_creation_contract IS INITIAL.

    CALL METHOD cl_isu_touexception_bill_utils=>get_instance
      RECEIVING
        y_instance = lr_exceptbill.

    TRY.
        CALL METHOD lr_exceptbill->check_individual_exception
          EXPORTING
            x_from         = xy_exception_data-datefrom
            x_to           = xy_exception_data-dateto
            x_contract     = me->control_data-single_creation_contract
            x_exceptprogid = xy_exception_data-exceptionprogramid.

      CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDTRY.
  ENDIF.

* get timezone for the program
  TRY.
      CALL METHOD cl_isu_touexceptprog_db=>get_instance
        RECEIVING
          y_instance = lr_exceptprog.

      CALL METHOD lr_exceptprog->get_exception_program_timezone
        EXPORTING
          x_exceptprog_id       = xy_exception_data-exceptionprogramid
        IMPORTING
          y_exceptprog_timezone = lv_exceptprog_timezone.

    CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDTRY.

* convert to utc, date/time from
  IF x_change_activation = abap_false.

    TRY.
        CALL METHOD cl_isu_touexception=>convert_tc_datetime_to_utc
          EXPORTING
            x_date     = xy_exception_data-datefrom
            x_time     = xy_exception_data-timefrom
            x_timezone = lv_exceptprog_timezone
          IMPORTING
            y_date_utc = xy_exception_data-datefrom
            y_time_utc = xy_exception_data-timefrom.

      CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'DATEFROM'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDTRY.

* convert to utc, date/time to
    TRY.
        CALL METHOD cl_isu_touexception=>convert_tc_datetime_to_utc
          EXPORTING
            x_date     = xy_exception_data-dateto
            x_time     = xy_exception_data-timeto
            x_timezone = lv_exceptprog_timezone
          IMPORTING
            y_date_utc = xy_exception_data-dateto
            y_time_utc = xy_exception_data-timeto.

      CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'DATETO'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDTRY.
  ENDIF.

* check overlapping in program, with UTC
  TRY.
      CALL METHOD me->check_overlap_in_exceptprog
        EXPORTING
          x_exception_data = xy_exception_data.

    CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
  ENDTRY.

* check already billed
  IF me->control_data-wmode = co_wmode_change.

    TRY.
        CALL METHOD me->check_already_billed
          EXPORTING
            x_exception_data = xy_exception_data
          IMPORTING
            y_already_billed = lv_already_billed.

      CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
        cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDTRY.

    IF lv_already_billed = abap_true.

      lv_exceptionid = xy_exception_data-exceptionid.
      SHIFT lv_exceptionid LEFT DELETING LEADING '0'.

      MESSAGE e037(ee_toue) WITH lv_exceptionid INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      cl_isu_touexception_exc_facty=>gf_exc->error_component = 'EXCEPTIONPROGRAMID'.
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.
  ENDIF.

  me->control_data-input_error = abap_false.

  IF me->control_data-wmode = co_wmode_create OR
     ( me->control_data-wmode = co_wmode_change AND
      x_change_activation = abap_true ).

* set activation status
    TRY.
        CALL METHOD me->set_activation_status
          EXPORTING
            x_change_activation = x_change_activation
          CHANGING
            xy_exception_data   = xy_exception_data.

      CATCH cx_isu_touexception_gen_fault INTO cl_isu_touexception_exc_facty=>gf_exc.
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDTRY.

    me->data-exceptionstatus = xy_exception_data-exceptionstatus.
  ENDIF.

* take over data
  MOVE-CORRESPONDING xy_exception_data TO me->data.
  me->data-exceptionprogtimezone = lv_exceptprog_timezone.

* update new data
  MOVE-CORRESPONDING me->data TO wa_exception.              "#EC ENHOK
  wa_exception-mandt = sy-mandt.

* update new text data
  wa_exceptiontxt-mandt = sy-mandt.
  wa_exceptiontxt-spras = sy-langu.
  wa_exceptiontxt-exceptionid = me->exceptionid.
  wa_exceptiontxt-exceptiontxt = me->data-exceptiontxt.

* current data to new data
  IF me->control_data-wmode = co_wmode_change.

    MODIFY TABLE me->instance_db->new_data-exception FROM wa_exception.

    IF sy-subrc <> 0.
      MESSAGE e003(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.

* text
    READ TABLE me->instance_db->new_data-exceptiontxt
                    TRANSPORTING NO FIELDS
                    WITH KEY exceptionid = me->exceptionid.

    IF sy-subrc = 0.

      IF NOT wa_exceptiontxt-exceptiontxt IS INITIAL.
        MODIFY TABLE me->instance_db->new_data-exceptiontxt FROM wa_exceptiontxt.

        IF sy-subrc <> 0.
          MESSAGE e019(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
          cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
        ENDIF.
      ELSE.

        DELETE TABLE me->instance_db->new_data-exceptiontxt FROM wa_exceptiontxt.

        IF sy-subrc <> 0.
          MESSAGE e019(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
          cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
        ENDIF.
      ENDIF.

    ELSEIF sy-subrc = 4.

      IF NOT wa_exceptiontxt-exceptiontxt IS INITIAL.
        INSERT wa_exceptiontxt INTO TABLE me->instance_db->new_data-exceptiontxt.

        IF sy-subrc <> 0.
          MESSAGE e019(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
          cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
          RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSEIF me->control_data-wmode = co_wmode_create.

    INSERT wa_exception INTO TABLE me->instance_db->new_data-exception.

    IF sy-subrc <> 0.
      MESSAGE e019(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
      cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
      RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
    ENDIF.

* text
    IF NOT wa_exceptiontxt-exceptiontxt IS INITIAL.
      INSERT wa_exceptiontxt INTO TABLE me->instance_db->new_data-exceptiontxt.

      IF sy-subrc <> 0.
        MESSAGE e019(ee_toue) INTO cl_isu_touexception_exc_facty=>str.
        cl_isu_touexception_exc_facty=>gf_exc = cl_isu_touexception_exc_facty=>create_general_fault( ).
        RAISE EXCEPTION cl_isu_touexception_exc_facty=>gf_exc.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD start_maint_tool_without_sel.

  DATA: ls_ami_active TYPE isu_ehp_active_area.

* get active flag for AMI switch in EhP7
  CALL METHOD cl_isu_ehp7_sfw_tools=>get_ami_switch_state
    RECEIVING
      active = ls_ami_active-isu_ami_ehp7_active.

* switch not set
  IF ls_ami_active-isu_ami_ehp7_active = abap_false.
    MESSAGE e000(ee_toue).
  ELSE.

* call the maintance tool without selection, e.g. for create exception
    CALL FUNCTION 'ISU_O_TOUEXCEPTION_OPEN'
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.

ENDMETHOD.
ENDCLASS.