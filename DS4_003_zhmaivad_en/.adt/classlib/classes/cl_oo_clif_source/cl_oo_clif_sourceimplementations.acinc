*----------------------------------------------------------------------*
*       INTERFACE lif_formatable_source_part
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
interface lif_formatable_source_part.
  methods:
    pretty_print
      importing
        pretty_printer_settings type ref to if_pretty_printer_settings.
endinterface.                    "lif_formatable_source_part

*----------------------------------------------------------------------*
*       CLASS lcx_method_unknown DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcx_method_unknown definition inheriting from cx_static_check.
endclass.                    "lcx_method_unknown DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_method_unknown IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcx_method_unknown implementation.
endclass.                    "lcx_method_unknown IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_spacer_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_spacer_source_part definition inheriting from lcl_source_part.
  public section.
    class-methods:
      create_spacer
        importing
          space_lines        type i
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_spacer_source_part.

    methods:
      lif_source_part~read         redefinition.
  private section.
    data:
      space_lines type i.
endclass.                    "lcl_spacer_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_spacer_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_spacer_source_part implementation.

  method create_spacer.
    create object source_part.
    source_part->space_lines = space_lines.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_spacer

  method lif_source_part~read.
    constants:
      c_space_line type string value space.

    clear me->source.
    do me->space_lines times.
      append c_space_line to me->source.
    enddo.
  endmethod.                    "lif_source_part~read

endclass.                    "lcl_spacer_source_part IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_editable_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_editable_source_part definition inheriting from lcl_source_part abstract.
  public section.
    interfaces:
      lif_editable_source_part
      abstract methods
      save
      access_permission
      insert_into_working_area
      corr_insert,
      lif_formatable_source_part.

    methods:
      lif_source_part~read           redefinition,
      lif_source_part~get_line_index redefinition.
  protected section.
    types:
      type_extension type c length 2.
    data:
      locked          type lif_editable_source_part=>type_lock value lif_editable_source_part=>c_lock_unlocked,
      original_source type rswsourcet.

    methods:
      get_extension
        returning
          value(extension) type type_extension,
      is_alredy_locked_exception
        importing
          exception     type ref to cx_oo_source_save_failure
        returning
          value(result) type seox_boolean.
  private section.
    data:
      modification_mode_enabled type seox_boolean value seox_false.
endclass.                    "lcl_editable_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_editable_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_editable_source_part implementation.

  method lif_formatable_source_part~pretty_print.
    data:
      source         type rswsourcet,
      scannable      type ref to lif_scannable_source_part,
      pretty_printer type ref to cl_sedi_pretty_printer,
      exception      type ref to cx_sedi_pretty_printer.

    source = me->lif_source_part~get_source( ).
    create object pretty_printer.
    try.
        pretty_printer->format_source(
          exporting
            i_settings             = pretty_printer_settings
          changing
            c_source               = source    " ABAP Source
        ).
        me->lif_editable_source_part~set_source( source ).
      catch cx_sedi_pretty_printer into exception.
        message exception type 'I'.
    endtry.
  endmethod.                    "lif_formatable_source_part~pretty_print

  method lif_source_part~read.
    super->lif_source_part~read( version = version ).
    me->original_source = me->source.
  endmethod.                    "lif_source_part~read

  method lif_source_part~get_line_index.
    field-symbols:
      <line_index_entry> type edlineindx.

    line_index = super->lif_source_part~get_line_index( ).
    if ( me->lif_editable_source_part~is_locked( ) = seox_true ).
      loop at line_index
          assigning <line_index_entry>.
        <line_index_entry>-noedit_flg = seox_false.
      endloop.
    endif.
  endmethod.                    "lif_source_part~get_line_index

  method lif_editable_source_part~is_locked.
    if ( me->locked = lif_editable_source_part=>c_lock_locked ).
      locked = seox_true.
    else.
      locked = seox_false.
    endif.
  endmethod.                    "if_editable_source_part~is_locked

  method lif_editable_source_part~lock.
    if ( suppress_access_permission = seox_false ).
      me->lif_editable_source_part~access_permission( access_mode = seok_access_modify
                                                      lock_handle = lock_handle
                                                      authority_check = authority_check ).
    endif.
    me->locked = lif_editable_source_part=>c_lock_locked.
  endmethod.                    "if_editable_source_part~lock

  method lif_editable_source_part~unlock.
    if ( me->lif_editable_source_part~is_locked( ) = seox_false ).
      return.
    endif.
    if ( suppress_access_permission = seox_false ).
      me->lif_editable_source_part~access_permission( access_mode = seok_access_free ).
    endif.
    if ( allow_relock = seox_true ).
      me->locked = lif_editable_source_part=>c_lock_unlocked_ephemerally.
    else.
      me->locked = lif_editable_source_part=>c_lock_unlocked.
    endif.
  endmethod.                    "if_editable_source_part~unlock


  method lif_editable_source_part~relock.
    if ( me->locked <> lif_editable_source_part=>c_lock_unlocked_ephemerally ).
      return.
    endif.
    me->lif_editable_source_part~lock( suppress_access_permission = suppress_access_permission
                                       lock_handle                = lock_handle
                                       authority_check            = authority_check ).
  endmethod.                    "lif_editable_source_part~relock


  method get_extension.
*   Return nothing.
  endmethod.                    "get_extension

  method lif_editable_source_part~refresh_original_source.
    data:
      scannable_source_part type ref to lif_scannable_source_part.

    try.
        scannable_source_part ?= me.
        scannable_source_part->refresh( ).
      catch cx_sy_move_cast_error.                      "#EC NO_HANDLER
    endtry.
    me->original_source = me->source.
  endmethod.                    "lif_editable_source_part~refresh_original_source

  method lif_editable_source_part~set_source.
    me->source = source.
  endmethod.                    "lif_editable_source_part~set_source


  method lif_editable_source_part~set_modification_mode_enabled.
    me->modification_mode_enabled = modification_mode_enabled.
  endmethod.


  method lif_editable_source_part~is_modification_mode_enabled.
    result = me->modification_mode_enabled.
  endmethod.

  method is_alredy_locked_exception.
    if ( ( exception->if_t100_message~t100key-msgid = 'CTS_WBO_API' ) and
         ( exception->if_t100_message~t100key-msgno = '020' ) ).
      result = seox_true.
    else.
      result = seox_false.
    endif.
  endmethod.
endclass.                    "if_editable_source_part~unlock

*----------------------------------------------------------------------*
*       CLASS lcl_include_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_include_source_part definition inheriting from lcl_editable_source_part.
  public section.
    interfaces:
      lif_importable_source_part.
    class-methods:
      create
        importing
          include_name       type progname
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_include_source_part.

    methods:
      lif_source_part~get_source                        redefinition,
      lif_source_part~read                              redefinition,
      lif_editable_source_part~save                     redefinition,
      lif_editable_source_part~access_permission        redefinition,
      lif_editable_source_part~insert_into_working_area redefinition,
      lif_editable_source_part~corr_insert              redefinition.
  protected section.
    data:
      include_name type progname.

    methods:
      is_save_allowed
        importing
          force         type seox_boolean
        returning
          value(result) type seox_boolean,
      is_import_allowed
        returning
          value(result) type seox_boolean,
      read_progdir
        importing
          version       type r3state default lif_source_part=>c_version_active
        returning
          value(result) type progdir,
      update_progdir
        importing
          version type r3state
        raising
          cx_oo_source_save_failure.
  private section.

    methods:
      save_source
        importing
          version type r3state
        raising
          cx_oo_source_save_failure,
      has_empty_source
        returning
          value(empty_source) type seox_boolean.
endclass.                    "lcl_include_source_part DEFINITION


*----------------------------------------------------------------------*
*       CLASS lcl_include_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_include_source_part implementation.

  method lif_source_part~get_source.
    source_table = me->source.
  endmethod.                    "if_source_part~get_source

  method lif_source_part~read.
    super->lif_source_part~read( version = version ).
    try.
        me->persistence->if_oo_clif_persistence_source~read_report(
          exporting
            include_name = me->include_name
            state        = version
          importing
            source       = me->source
        ).
      catch cx_include_does_not_exist.    "
        if ( version <> lif_source_part=>c_version_active ).
          lif_source_part~read( version = lif_source_part=>c_version_active ).
        endif.
    endtry.
    me->original_source = me->source.
  endmethod.                    "if_source_part~read

  method has_empty_source.
    field-symbols:
      <source_line> type string.

    empty_source = seox_true.
    if ( me->source is not initial ).
      loop at me->source
          assigning <source_line>.
        if ( <source_line> is not initial ).
          empty_source = seox_false.
        endif.
      endloop.
    endif.
  endmethod.                    "has_empty_source

  method lif_editable_source_part~save.
    data:
      extension          type type_extension,
      source_to_be_saved type rswsourcet.

    if ( me->is_save_allowed( force = force ) = seox_true ).
      me->lif_editable_source_part~corr_insert( ).
*      me->lif_editable_source_part~insert_into_working_area( ). "already done in corr_insert

      me->save_source( version =  lif_source_part=>c_version_inactive  ).
    endif.
  endmethod.

  method save_source.
    data(extension) = me->get_extension( ).
    "storing empty string makes problem for package section -> we have to store at least an empty string
    data(source_to_be_saved) = me->source. " question: is this good? what about memory consumption?
    if ( me->has_empty_source( ) = abap_true ).
      append ` ` to source_to_be_saved.
    endif.

    me->persistence->if_oo_clif_persistence_source~insert_report(
        include_name   = me->include_name
        source         = source_to_be_saved
        state          = version
        program_type   = 'I'
        extension_type = extension
    ).
    me->update_progdir( version = version ).
    me->original_source = source_to_be_saved.
  endmethod.

  "if_editable_source_part~save

  method lif_editable_source_part~access_permission.
*   Do nothing.
  endmethod.                    "lif_editable_source_part~access_permission

  method lif_editable_source_part~insert_into_working_area.
*   Do nothing.
  endmethod.                    "lif_editable_source_part~insert_into_working_area

  method lif_editable_source_part~corr_insert.
*   Do nothing.
  endmethod.                    "lif_editable_source_part~insert_into_working_area

  method create.
    create object source_part.
    source_part->init( persistence = persistence settings = settings ).
    source_part->include_name = include_name.
  endmethod.                    "create

  method is_save_allowed.
    result = seox_false.
    if ( ( ( me->lif_editable_source_part~is_locked( ) = seox_true ) and ( me->source <> me->original_source ) ) or ( force = seox_true ) ).
      result = seox_true.
    endif.
  endmethod.                    "is_save_allowed

  method read_progdir.
    try.
        result = me->persistence->if_oo_clif_persistence_source~read_progdir( include_name = include_name state = version ).
      catch cx_include_does_not_exist.
        if ( version = lif_source_part=>c_version_inactive ).
          result = me->read_progdir( version = lif_source_part=>c_version_active ).
        endif.
    endtry.
  endmethod.                    "read_progdir

  method update_progdir.
    data:
      progdir type progdir.

    progdir = me->read_progdir( lif_source_part=>c_version_inactive ).
    progdir-state = lif_source_part=>c_version_inactive.
    progdir-unam = sy-uname.
    progdir-udat = sy-datum.
    me->persistence->if_oo_clif_persistence_source~update_progdir(
        include_name = me->include_name
        state        = version
        progdir      = progdir
    ).
  endmethod.                    "update_progdir

  method lif_importable_source_part~import.
    if ( me->is_import_allowed( ) = seox_true ).
      me->save_source( version = lif_source_part=>c_version_active ).
    endif.
  endmethod.

  method is_import_allowed.
    result = seox_false.
    if ( me->lif_editable_source_part~is_locked( ) = seox_true ).
      result = seox_true.
    endif.
  endmethod.

endclass.                    "lcl_include_source_part IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_clif_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_clif_source_part definition inheriting from lcl_include_source_part abstract.
  public section.
    interfaces:
      lif_scannable_source_part
      abstract methods
      get_interval
      refresh.
  protected section.
    data:
      clif_key type seoclskey,
      scanner  type ref to cl_oo_source_scanner.
    methods:
      normalize_source
        importing
          normalize_comments_at_end type seox_boolean default seox_false.
endclass.                    "lcl_clif_source_part DEFINITION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_CLIF_SOURCE_PART
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_clif_source_part implementation.

  method lif_scannable_source_part~set_scanner.
    me->scanner ?= scanner.
  endmethod.                    "lif_clif_source_part~set_scanner

  method normalize_source.
    data:
      comment_source       type rswsourcet,
      comment_source_lines type i,
      line_index           type i.
    field-symbols
      <source_line> type string.

    " Collect all comments and empty source lines in front of the METHOD-statement
    loop at me->source
        assigning <source_line>.
      if ( ( <source_line> is not initial ) and ( <source_line>(1) <> '*' ) and ( ( <source_line> na '"' ) or ( <source_line>(sy-fdpos) cn space ) ) ).
        exit. "loop
      endif.
      append <source_line> to comment_source.
    endloop.
    if ( comment_source is not initial ).
      comment_source_lines = lines( comment_source ).
      " Move the comments and empty source lines in front of the METHOD-statement
      " behind the METHOD statement (to the 2nd source line of the method)
      delete me->source from 1 to comment_source_lines.
      insert lines of comment_source into me->source index 2.
    endif.
    if ( normalize_comments_at_end = seox_true ).
      line_index = lines( me->source ).
      clear comment_source.
      while ( line_index > 0 ).
        read table me->source index line_index assigning <source_line>.
        if ( ( <source_line> is not initial ) or ( comment_source is not initial ) ).
          if ( ( <source_line> is not initial ) and ( <source_line>(1) <> '*' ) and ( ( <source_line> na '"' ) or ( <source_line>(sy-fdpos) cn space ) ) ).
            exit. "loop
          endif.
          insert <source_line> into comment_source index 1 .
        endif.
        line_index = line_index - 1.
      endwhile.
      if ( comment_source is not initial ).
        " Move the comments after the ENDMETHOD-statement
        " behind the ENDMETHOD statement (DON'T DO THIS FOR EMPTY SOURCE LINES! => This would change unnecessarily the content of the method implementation)
        delete me->source from ( line_index + 1 ) to lines( me->source ).
        insert lines of comment_source into me->source index line_index.
      endif.
    endif.
    if ( me->original_source <> me->source ).
*     Set the original source
      me->original_source = me->source.
    endif.
  endmethod.


endclass.               "LCL_CLIF_SOURCE_PART

*----------------------------------------------------------------------*
*       CLASS lcl_clif_data_provider_map DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_clif_data_provider_map definition.
  public section.
    class-methods:
      create
        returning
          value(data_provider_map) type ref to lcl_clif_data_provider_map.

    methods:
      get_data_provider
        importing
          clif_name            type csequence
        returning
          value(data_provider) type ref to lif_data_provider,
      add_data_provider
        importing
          clif_name     type csequence
          data_provider type ref to lif_data_provider.
  private section.
    types:
      begin of type_data_provider_entry,
        clif_name     type seoclsname,
        data_provider type ref to lif_data_provider,
      end of type_data_provider_entry.
    types:
      type_data_provider_map type hashed table of type_data_provider_entry
                                 with unique key clif_name.
    data:
      provider_map type type_data_provider_map.
endclass.                    "lcl_corr_insert_data_provider DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_clif_data_provider_map IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_clif_data_provider_map implementation.

  method create.
    create object data_provider_map.
  endmethod.                    "create

  method get_data_provider.
    field-symbols:
      <provider_entry> type type_data_provider_entry.

    read table me->provider_map
        with table key clif_name = clif_name
        assigning <provider_entry>.
    if ( sy-subrc = 0 ).
      data_provider = <provider_entry>-data_provider.
    endif.
  endmethod.                    "get_data_provider

  method add_data_provider.
    data:
      provider_entry type type_data_provider_entry.

    provider_entry-clif_name     = clif_name.
    provider_entry-data_provider = data_provider.
    insert provider_entry into table me->provider_map.
  endmethod.                    "add_data_provider

endclass.                    "lcl_clif_data_provider_map IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_corr_insert_data_provider DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_corr_insert_data_provider definition.
  public section.
    interfaces:
      lif_data_provider.
    class-methods:
      class_constructor,
      get_data_provider
        importing
          clif_name            type seoclsname
        returning
          value(data_provider) type ref to lcl_corr_insert_data_provider.
    data:
      correction_number type trkorr,
      package           type devclass.
  private section.
    class-data:
      clif_data_map type ref to lcl_clif_data_provider_map.
endclass.                    "lcl_corr_insert_data_provider DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_corr_insert_data_provider IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_corr_insert_data_provider implementation.

  method class_constructor.
    clif_data_map = lcl_clif_data_provider_map=>create( ).
  endmethod.                    "class_constructor

  method get_data_provider.
    data_provider ?= clif_data_map->get_data_provider( clif_name ).
    if ( data_provider is initial ).

      create object data_provider.
      clif_data_map->add_data_provider( clif_name = clif_name data_provider = data_provider ).
    endif.
  endmethod.                    "get_data_provider

endclass.                    "lcl_corr_insert_data_provider IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_signature_provider DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_signature_provider definition.
  public section.
    interfaces:
      lif_signature_provider.
    class-methods:
      create_signature_provider
        importing
          clif_name         type csequence
          clif_provider_map type ref to lcl_clif_data_provider_map
        returning
          value(result)     type ref to lcl_signature_provider.
  private section.

    data:
      clif_provider_map type ref to lcl_clif_data_provider_map,
      clif_key          type seoclskey,
      methods           type seoo_methods_r,
      parameters        type seos_parameters_r,
      exceptions        type seos_exceptions_r.
    methods:
      get_signature_provider
        importing
          clif_name                 type csequence
        returning
          value(signature_provider) type ref to lcl_signature_provider.

endclass.                    "lcl_signature_provider DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_signature_provider IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_signature_provider implementation.

  method create_signature_provider.
    create object result.
    result->lif_signature_provider~init( clif_name = clif_name clif_provider_map = clif_provider_map ).
  endmethod.                    "get_signature_provider


  method get_signature_provider.
    signature_provider ?= me->clif_provider_map->get_data_provider( clif_name ).
    if ( signature_provider is initial ).
      signature_provider = create_signature_provider( clif_name = clif_name clif_provider_map = me->clif_provider_map ).
      me->clif_provider_map->add_data_provider( clif_name = clif_name data_provider = signature_provider ).
    endif.
  endmethod.                    "get_signature_provider

  method lif_signature_provider~init.
    me->clif_key-clsname  = clif_name.
    me->clif_provider_map = clif_provider_map.
    me->lif_signature_provider~refresh( ).
  endmethod.                    "init

  method lif_signature_provider~get_method_signature.
*"     REFERENCE(EVENTS) TYPE  SEOO_EVENTS_R
*"     REFERENCE(TYPES) TYPE  SEOO_TYPES_R
*"     REFERENCE(PARAMETERS) TYPE  SEOS_PARAMETERS_R
*"     REFERENCE(EXCEPS) TYPE  SEOS_EXCEPTIONS_R
    data:
      super_signature_provider type ref to lcl_signature_provider,
      super_cmp_key            type seocmpkey,
      super_method_key         type seomtdkey.
    field-symbols:
      <parameter> type seos_parameter_r,
      <exception> type seos_exception_r.

    read table me->methods
        with key clsname = method_key-clsname
                 cmpname  = method_key-mtdname
        into method_signature-method.
    if ( sy-subrc <> 0 ).
      call function 'SEO_COMPONENT_BY_INHERITANCE'
        exporting
          cpdkey       = method_key
          version      = seoc_version_inactive
        importing
          cmpkey       = super_cmp_key
        exceptions
          not_existing = 1
          model_only   = 2
          others       = 3.
      if ( sy-subrc <> 0 ).
        return.
      endif.
      if ( super_cmp_key-clsname = method_key-clsname ).
        return.
      endif.
      super_method_key-clsname = super_cmp_key-clsname.
      super_method_key-mtdname = super_cmp_key-cmpname.
      super_signature_provider = me->get_signature_provider( super_method_key-clsname ).
      method_signature = super_signature_provider->lif_signature_provider~get_method_signature( super_method_key ).
      return.
    endif.
    loop at me->parameters
        assigning <parameter>
        where clsname = method_key-clsname
          and cmpname = method_key-mtdname.
      append <parameter> to method_signature-parameters.
    endloop.
    loop at me->exceptions
        assigning <exception>
        where clsname = method_key-clsname
          and cmpname = method_key-mtdname.
      append <exception> to method_signature-exceptions.
    endloop.
  endmethod.                    "get_method_signature

  method lif_signature_provider~refresh.
    data:
      clif_type type seoclstype.

    call function 'SEO_CLIF_GET'
      exporting
        cifkey  = me->clif_key
      importing
        clstype = clif_type.
    if ( clif_type = seoc_clstype_class ).
      call function 'SEO_CLASS_TYPEINFO_GET'
        exporting
          clskey     = me->clif_key
        importing
          methods    = me->methods
          parameters = me->parameters
          exceps     = me->exceptions.
    else.
      call function 'SEO_INTERFACE_TYPEINFO_GET'
        exporting
          intkey     = me->clif_key
        importing
          methods    = me->methods
          parameters = me->parameters
          exceps     = me->exceptions.
    endif.
  endmethod.

endclass.                    "lcl_signature_provider IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_method_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_method_source_part definition inheriting from lcl_clif_source_part.
  public section.
    class-methods:
      "! Creates a new method implementation source part
      "!
      "! @parameter method_key | Method key
      "! @parameter method_to_be_created | Boolean flag whether the method implementation has newly create and has been stored on the database, yet
      "! @parameter source_part | The method implementation source part which has been created
      create_method
        importing
          method_key           type seomtdkey
          persistence          type ref to lif_persistence_facade
          settings             type ref to if_oo_clif_source_settings
          signature_provider   type ref to lif_signature_provider
          method_to_be_created type seox_boolean
        returning
          value(source_part)   type ref to lcl_method_source_part
        raising
          cx_method_does_not_exist.

    methods:
      lif_source_part~read                              redefinition,
      lif_scannable_source_part~get_interval            redefinition,
      lif_scannable_source_part~refresh                 redefinition,
      lif_editable_source_part~save                     redefinition,
      lif_editable_source_part~access_permission        redefinition,
      lif_editable_source_part~insert_into_working_area redefinition,
      lif_editable_source_part~corr_insert              redefinition,
      lif_editable_source_part~set_source               redefinition,
      lif_editable_source_part~refresh_original_source  redefinition,
      lif_importable_source_part~import                 redefinition.
  protected section.
    data:
      method_key         type seomtdkey.
    methods:
      is_save_allowed redefinition,
      get_extension   redefinition,
      read_progdir    redefinition.
  private section.
    constants:
      co_exposure_undefined   type seoexpose value '9',
      co_mtd_name_constructor type seomtdname value 'CONSTRUCTOR'.
    data:
      modification_info           type ref to if_clm_tool_log,
      original_exposure           type seoexpose value co_exposure_undefined,
      original_super_class        type seoclskey,
      original_is_exception_class type seox_boolean,
      signature_provider          type ref to lif_signature_provider,
      "! This attribute is set when the refresh of the source parts detects
      "! that the method implementation has been removed by the user. In this case
      "! the save shall delete the method implementation instead of saving it.
      method_to_be_deleted        type seox_boolean value seox_false,
      "! This attribute is set when the refresh of the source parts detects
      "! that the method implementation has been added by the user. In this case
      "! the save shall create the method implementation instead before saving it.
      method_to_be_created        type seox_boolean.
    methods:
      get_original_exposure
        returning
          value(result) type seoexpose,
      has_deleted_working_area_entry
        returning
          value(deleted_entry) type seox_boolean,
      read_modification_info,

      disable_modass_or_save_modinfo
        raising
          cx_oo_source_save_failure,
      "! When the method is a constructor and the super class has changed
      "! to an exception class, the method implementation of the constructor
      "! has to be saved to add the ##adt_suppress_generation pragma.
      is_super_class_change_relevant
        returning
          value(result) type seox_boolean.
endclass.                    "lcl_method_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_method_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_method_source_part implementation.

  method create_method.
    create object source_part.
    source_part->clif_key-clsname = method_key-clsname.
    source_part->method_key = method_key.
    if ( method_to_be_created = seox_false ).
      source_part->include_name = persistence->if_oo_clif_persist_meta_data~get_method_include( method_key ).
    endif.
    source_part->signature_provider = signature_provider.
    source_part->method_to_be_created = method_to_be_created.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_method

  method lif_source_part~read.
    data:
      inheritance type vseoextend.

    super->lif_source_part~read( version ).
    me->normalize_source( normalize_comments_at_end = seox_true ).
    if ( me->original_source is initial ).
      " if the original source is empty the method implementation has been deleted
      " => remove the source part list for methods from the class' source part list
      " to avoid inconsistencies between the displayed source and the calculated
      " line index.
      raise event lif_editable_source_part~deleted
        exporting
          source_part = me.
      return.
    endif.
    " For constructors read the super class. If the super class is changed and the new
    " super class is an exception class, the constructor has to be saved, again to tag
    " the method include as "not generated" with the pragma ##adt_suppress_generation
    if (  me->method_key-mtdname = co_mtd_name_constructor ).
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key   = me->clif_key
                                                                        importing inheritance = inheritance ).
      me->original_super_class-clsname = inheritance-refclsname.
      me->original_is_exception_class = me->persistence->if_oo_clif_persist_meta_data~is_exception_class( clif_key = me->clif_key ).
    endif.
  endmethod.                    "lif_source_part~read

  method lif_editable_source_part~save.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider,
      adjustment_was_executed   type seox_boolean value seox_false.

    if ( me->is_save_allowed( force = force ) = seox_true ).
      if ( ( me->method_to_be_deleted = seox_true ) or ( me->source is initial ) ).
        " call CORR_INSERT and INSERT_INTO_WORKING_AREA, because SEO_DELETE_METHOD_INCUDE does not raise any
        " exception if the method cannot be stored to a transport request.
        if ( me->lif_editable_source_part~is_modification_mode_enabled( ) = seox_true ) and
           ( me->persistence->lif_persistence_modass~is_modass_enabled_4_method( me->method_key ) = seox_true ).
          raise exception type cx_oo_source_save_failure
            exporting
              textid = cx_oo_source_save_failure=>forbidden_modifications.
        endif.
        me->lif_editable_source_part~corr_insert( ).
        me->lif_editable_source_part~insert_into_working_area( ).

        " retrieve cached correction number
        corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( me->clif_key-clsname ).
        me->persistence->if_oo_clif_persist_meta_data~delete_method_include(
          exporting method_key = me->method_key
                    version    = lif_source_part=>c_version_inactive
          changing correction_number = corr_insert_data_provider->correction_number ).

        raise event lif_editable_source_part~deleted
          exporting
            source_part = me.
      else.
        if ( me->method_to_be_created = seox_true ).
          persistence->if_oo_clif_persist_meta_data~generate_method_include( method_key = method_key
                                                                             version    = lif_source_part=>c_version_inactive
                                                                             modification_mode_enabled = me->lif_editable_source_part~is_modification_mode_enabled( ) ).
          me->method_to_be_created = seox_false.
        endif.

        try.
            me->include_name = persistence->if_oo_clif_persist_meta_data~get_method_include( method_key ).
          catch cx_method_does_not_exist.
            " Method implementation has been deleted by a roll back due to an error during
            " the last save operation.
            persistence->if_oo_clif_persist_meta_data~generate_method_include( method_key = method_key
                                                                               version    = lif_source_part=>c_version_inactive
                                                                               modification_mode_enabled = me->lif_editable_source_part~is_modification_mode_enabled( ) ).
            retry.
        endtry.

        me->read_modification_info( ).
        me->disable_modass_or_save_modinfo( ).

        if ( method_key-mtdname = co_mtd_name_constructor ).
          if ( me->persistence->if_oo_clif_persist_meta_data~is_exception_class( me->clif_key ) = seox_true ).
            me->persistence->if_oo_clif_persistence_source~add_suppress_generation_pragma( exporting clif_key = me->clif_key changing source = me->source ).
            super->lif_editable_source_part~save( force = seox_true ).
            me->persistence->if_oo_clif_persistence_source~reset_generation_flag_in_tmdir( clif_key = me->clif_key lifecycle_manager = cl_adt_lifecycle_mngr_enum=>corr_manager_dark ).
          else.
            me->persistence->if_oo_clif_persistence_source~del_suppress_generation_pragma( exporting clif_key = me->clif_key
                                                                                           importing adjustment_was_executed = adjustment_was_executed
                                                                                           changing source = me->source ).
            super->lif_editable_source_part~save( force = seox_true ).
            if adjustment_was_executed = seox_true.
              me->persistence->if_oo_clif_persistence_source~reset_generation_flag_in_tmdir( clif_key = me->clif_key lifecycle_manager = cl_adt_lifecycle_mngr_enum=>corr_manager_dark ).
            endif.
          endif.
          " Since we added or removed the pragma ##ADT_SUPPRESS_GENERATION in the method implementation
          " we need adjust the content of the CS-include by calling SET_SOURCE
          me->lif_editable_source_part~set_source( source ).
        else.
          super->lif_editable_source_part~save( force = seox_true ).
        endif.
      endif.
    endif.
  endmethod.                    "lif_editable_source_part~save

  method lif_editable_source_part~access_permission.
    data:
      modass_enabled type seox_boolean.

    me->persistence->lif_persistence_lifecycle~access_permission(
      exporting
        object_type     = seok_limu_method
        clif_key        = me->clif_key
        method_name     = me->method_key-mtdname
        access_mode     = access_mode
        authority_check = authority_check
      importing
        modification_mode_enabled  = modass_enabled
    ).
    me->lif_editable_source_part~set_modification_mode_enabled( modass_enabled ).
  endmethod.                    "lif_editable_source_part~access_permission

  method lif_editable_source_part~insert_into_working_area.
    data:
      objname type trobj_name.

    objname = me->method_key.
    me->persistence->lif_persistence_lifecycle~insert_into_working_area( object_type = seok_limu_method object_name = objname ).
  endmethod.                    "lif_editable_source_part~insert_into_working_area

  method lif_editable_source_part~corr_insert.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider,
      exception                 type ref to cx_oo_source_save_failure.

    corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( me->method_key-clsname ).
    try.
        me->persistence->lif_persistence_lifecycle~corr_insert(
          exporting
            object_type       = seok_limu_method
            clif_key          = me->clif_key
            method_name       = me->method_key-mtdname
          changing
            correction_number = corr_insert_data_provider->correction_number
            package           = corr_insert_data_provider->package
        ).
      catch cx_oo_source_save_failure into exception.
        if ( me->is_alredy_locked_exception( exception ) = seox_true ).
          raise exception type cx_oo_locked_in_other_request
            exporting
              textid         = cx_oo_locked_in_other_request=>method_locked_in_other_request
              previous       = exception
              clif_name      = me->clif_key-clsname
              component_name = me->method_key-mtdname
              request_number = |{ exception->message_variable_3 }|
              request_owner  = |{ exception->message_variable_4 }|.
        else.
          raise exception exception.
        endif.
    endtry.
  endmethod.                    "lif_editable_source_part~corr_insert

  method lif_scannable_source_part~get_interval.
    data:
      class_scanner type ref to cl_oo_source_scanner_class,
      exception     type ref to cx_root.

    class_scanner ?= me->scanner.
    try.
        interval = class_scanner->get_method_impl_interval( me->method_key-mtdname ).
      catch cx_oo_clif_component into exception.
        raise exception
          type
          cx_oo_clif_scan_error
          exporting
            previous = exception.
    endtry.
  endmethod.                    "lif_scannable_source_part~get_interval

  method lif_scannable_source_part~refresh.
    data:
      class_scanner type ref to cl_oo_source_scanner_class.

    class_scanner ?= me->scanner.
    try.
        me->source = class_scanner->get_method_impl_source( me->method_key-mtdname ).
        me->method_to_be_deleted = seox_false.
      catch cx_oo_clif_component.
        if ( me->source is not initial ).
          " If the method implementation had some content before, the user has deleted it, now...
          clear me->source.
          me->method_to_be_deleted = seox_true.
        endif.
    endtry.
  endmethod.                    "lif_scannable_source_part~refresh

  method get_extension.
    extension = srext_ext_class_method.
  endmethod.                    "get_extension

  method has_deleted_working_area_entry.
    data:
      object      type dwinactiv,
      object_list type lif_persistence_lifecycle=>ty_object_list.


    deleted_entry = seox_false.
*   Build up Method object
    object-object   = seok_limu_method.
    object-obj_name = me->method_key.
    append object to object_list.
*   Check workingarea for inactive objects
    me->persistence->lif_persistence_lifecycle~get_inactive_objects( changing object_list = object_list ).
*   check wheter there is an entry with deletion-flag.
    read table object_list
        with key delet_flag = seox_true
        transporting no fields.
    if ( sy-subrc = 0 ).
      deleted_entry = seox_true.
    endif.
  endmethod.                    "has_deleted_working_area_entry

  method is_save_allowed.
    constants:
      c_interface_separator type c length 1 value '~'.

    try.
        result = super->is_save_allowed( force = force ).
        if ( ( result = seox_false ) and
             ( ( me->scanner->get_component_exposure( me->method_key-mtdname ) <> me->get_original_exposure( ) )  or
               ( ( me->source is not initial ) and ( me->has_deleted_working_area_entry( ) = seox_true ) ) or
               ( me->is_super_class_change_relevant( ) = seox_true ) ) ).
          result = seox_true.
        endif.
      catch cx_oo_clif_component.
*       The method definition has been deleted (if it is no interface method).
*       Save the source to keep the method implementation!
        if ( ( me->method_key-mtdname na c_interface_separator ) and ( me->source is not initial ) ).
          result = seox_true.
        endif.
    endtry.
  endmethod.                    "is_save_allowed

  method read_progdir.
    result = super->read_progdir( version ).
    result-subc = 'I'.
  endmethod.                    "read_progdir

  method get_original_exposure.
    data:
      method_data        type vseomethod.

    if ( ( me->original_exposure = co_exposure_undefined ) ).
      me->original_exposure = me->persistence->if_oo_clif_persist_meta_data~get_method_data( me->method_key )-exposure.
    endif.
    result = me->original_exposure.
  endmethod.                    "determine_original_exposure


  method lif_editable_source_part~set_source.
    data:
      source_representation type ref to cl_oo_source_representation.

    super->lif_editable_source_part~set_source( source ).
    source_representation ?= scanner.
    try.
        source_representation->set_method_impl_source( method_name = me->method_key-mtdname source = source ).
      catch cx_oo_clif_component.
        assert 1 = 0.
    endtry.
  endmethod.                    "lif_editable_source_part~set_source

  method read_modification_info.
    if ( me->lif_editable_source_part~is_modification_mode_enabled( ) = seox_true ).
      me->modification_info = me->persistence->lif_persistence_modass~read_modificationinfo_4_method( method_key = me->method_key ).
    endif.
  endmethod.

  method disable_modass_or_save_modinfo.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider,
      p_entries_tab             type standard table of smodi_tool_log_struct.

    if ( me->lif_editable_source_part~is_modification_mode_enabled( ) = seox_false ).
      return.
    endif.

    me->lif_editable_source_part~corr_insert( ).

    if ( me->persistence->lif_persistence_modass~is_modass_enabled_4_method( me->method_key ) = seox_true ).
      corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( clif_name = me->method_key-clsname ).
      if me->modification_info is bound.
        me->modification_info->get_entries(
          importing
            p_entries_tab = p_entries_tab  ).
      endif.
      " METH modification with brackets??
      read table p_entries_tab with key int_type = 'PN' operation = 'MOD' transporting no fields.
      if sy-subrc = 0.  " modifications within brackets exist, save them
        me->persistence->lif_persistence_modass~save_modificationinfo_4_method(
          exporting
            method_key          = me->method_key
            include_name        = me->include_name
            modification_info   = me->modification_info
            correction_number   = corr_insert_data_provider->correction_number
            smodi_transfer_only = seox_false
          changing
            source              = me->source ).
        " Since we might have changed the modification brackets in the method implementation
        " we need adjust the content of the CS-include by calling SET_SOURCE
        me->lif_editable_source_part~set_source( me->source ).
      else.
        " turn off modass for method
        me->persistence->lif_persistence_modass~disable_modass_4_method(
            method_key        = me->method_key
            original_source   = me->original_source
            correction_number = corr_insert_data_provider->correction_number ).
      endif.
    else.
      corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( clif_name = me->method_key-clsname ).
      me->persistence->lif_persistence_modass~save_modificationinfo_4_method(
          method_key          = me->method_key
          include_name        = me->include_name
          modification_info   = me->modification_info
          correction_number   = corr_insert_data_provider->correction_number
          smodi_transfer_only = seox_true ).  "   !! only transfer the table entries
    endif.
  endmethod.

  method lif_editable_source_part~refresh_original_source.
    data:
      inheritance type vseoextend.

    super->lif_editable_source_part~refresh_original_source( ).
    " For constructors read the super class. If the super class is changed and the new
    " super class is an exception class, the constructor has to be saved, again to tag
    " the method include as "not generated" with the pragma ##adt_suppress_generation
    if (  me->method_key-mtdname = co_mtd_name_constructor ).
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key   = me->clif_key
                                                                        importing inheritance = inheritance ).
      me->original_super_class-clsname = inheritance-refclsname.
      me->original_is_exception_class = me->persistence->if_oo_clif_persist_meta_data~is_exception_class( clif_key = me->clif_key ).
    endif.
  endmethod.

  method is_super_class_change_relevant.
    data:
      inheritance type vseoextend.

    result = seox_false.
    if ( method_key-mtdname = co_mtd_name_constructor ) and
             ( me->persistence->if_oo_clif_persist_meta_data~is_exception_class( me->clif_key ) = seox_true or
               me->original_is_exception_class = seox_true ).
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key   = me->clif_key
                                                                        importing inheritance = inheritance ).
      if ( inheritance-refclsname <> me->original_super_class-clsname ).
        result = seox_true.
      endif.
    endif.
  endmethod.


  method lif_importable_source_part~import.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider,
      adjustment_was_executed   type seox_boolean value seox_false.

    if ( me->is_import_allowed( ) = seox_true ).
      if ( ( me->method_to_be_deleted = seox_true ) or ( me->source is initial ) ).
        corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( me->clif_key-clsname ).
        me->persistence->if_oo_clif_persist_meta_data~delete_method_include(
          exporting method_key = me->method_key
                    version    = lif_source_part=>c_version_active

          changing correction_number = corr_insert_data_provider->correction_number ).

        raise event lif_editable_source_part~deleted
          exporting
            source_part = me.
      else.
        if ( me->method_to_be_created = seox_true ).
          persistence->if_oo_clif_persist_meta_data~generate_method_include( method_key = method_key
                                                                             version    = lif_source_part=>c_version_active
                                                                             modification_mode_enabled = me->lif_editable_source_part~is_modification_mode_enabled( ) ).
          me->include_name = cl_oo_classname_service=>get_method_include( mtdkey = method_key ).
          me->method_to_be_created = seox_false.
        endif.
        super->lif_importable_source_part~import( ).
      endif.
    endif.
  endmethod.

endclass.                    "lcl_method_source_part IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcl_method_intf_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_method_sign_source_part definition inheriting from lcl_source_part.
  public section.
    class-methods:
      create_method_signature
        importing
          method_key         type seomtdkey
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
          signature_provider type ref to lif_signature_provider
        returning
          value(source_part) type ref to lcl_method_sign_source_part.

    methods:
      lif_source_part~read       redefinition.
  private section.
    data:
      method_key         type seomtdkey,
      signature_provider type ref to lif_signature_provider.

    methods:
      generate_method_interface.
endclass.                    "lcl_method_intf_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_method_intf_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_method_sign_source_part implementation.

  method create_method_signature.
    create object source_part.
    source_part->method_key = method_key.
    source_part->signature_provider = signature_provider.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_method_interface

  method lif_source_part~read.
    super->lif_source_part~read( version = version ).
    me->generate_method_interface( ).
  endmethod.                    "lif_source_part~read


  method generate_method_interface.
    types:
      begin of type_method,
        kind       type c length 8,
        visibility type c length 9,
        name       type string,
      end of type_method.
    types:
      begin of type_parameter,
        kind      type c length 7,
        name      type c length 31,
        type_kind type c length 12,
        type      type c length 255,
      end of type_parameter.
    types:
      begin of type_exception,
        kind type c length 7,
        name type c length 31,
      end of type_exception.
    constants:
      c_comment                 type string value '* |',
      c_comment_line            type string value '* +-------------------------------------------------------------------------------------------------+',
      c_comment_signature_begin type string value '* <SIGNATURE>---------------------------------------------------------------------------------------+',
      c_comment_signature_end   type string value '* +--------------------------------------------------------------------------------------</SIGNATURE>',
      c_method                  type string value 'Method', "#EC NOTEXT
      c_public                  type string value 'Public', "#EC NOTEXT
      c_protected               type string value 'Protected', "#EC NOTEXT
      c_private                 type string value 'Private', "#EC NOTEXT
      c_static                  type string value 'Static', "#EC NOTEXT
      c_instance                type string value 'Instance', "#EC NOTEXT
      c_like                    type string value 'LIKE',   "#EC NOTEXT
      c_type                    type string value 'TYPE',   "#EC NOTEXT
      c_type_ref_to             type string value 'TYPE REF TO', "#EC NOTEXT
      c_importing               type string value '[--->]',
      c_exporting               type string value '[<---]',
      c_changing                type string value '[<-->]',
      c_returning               type string value '[<-()]',
      c_raising                 type string value '[!CX!]',
      c_exceptions              type string value '[EXC!]',
      c_optional                type string value '(optional)',
      c_default                 type string value 'default = '. "#EC NOTEXT
    data:
      source_line        type string,
      signature_provider type ref to lif_signature_provider,
      method_signature   type lif_signature_provider=>type_method_signature,
      method             type type_method,
      parameter          type type_parameter,
      exception          type type_exception.
    field-symbols:
      <signature_parameter> type seos_parameter_r,
      <signature_exception> type seos_exception_r.

*   Clear the existing source
    clear me->source.
    signature_provider = me->signature_provider.
    method_signature = signature_provider->get_method_signature( me->method_key ).
*   Build method line
    if ( method_signature-method-mtddecltyp = seoo_mtddecltyp_class_method ).
      method-kind = c_static.
      concatenate method_key-clsname '=>' me->method_key-mtdname into method-name.
    else.
      method-kind = c_instance.
      concatenate method_key-clsname '->' me->method_key-mtdname into method-name.
    endif.
    case method_signature-method-exposure.
      when seoc_exposure_public.
        method-visibility = c_public.
      when seoc_exposure_protected.
        method-visibility = c_protected.
      when seoc_exposure_private.
        method-visibility = c_private.
    endcase.
    append c_comment_signature_begin to me->source.
    concatenate c_comment method-kind method-visibility c_method method-name into source_line separated by space.
    append source_line to me->source.
    append c_comment_line to me->source.
*   Build parameter lines
    sort method_signature-parameters by pardecltyp editorder.
    loop at method_signature-parameters
        assigning <signature_parameter>.
      clear parameter.
      case <signature_parameter>-pardecltyp.
        when seos_pardecltyp_importing.
          parameter-kind = c_importing.
        when seos_pardecltyp_exporting.
          parameter-kind = c_exporting.
        when seos_pardecltyp_changing.
          parameter-kind = c_changing.
        when seos_pardecltyp_returning.
          parameter-kind = c_returning.
      endcase.
      parameter-name = <signature_parameter>-sconame.
      case <signature_parameter>-typtype.
        when seoo_typtype_like.
          parameter-type_kind = c_like.
        when seoo_typtype_type.
          parameter-type_kind = c_type.
        when seoo_typtype_ref_to.
          parameter-type_kind = c_type_ref_to.
      endcase.
      parameter-type = <signature_parameter>-type.
      if ( <signature_parameter>-parvalue is not initial ).
        concatenate parameter-type ' (' c_default <signature_parameter>-parvalue ')' into parameter-type.
      elseif ( <signature_parameter>-paroptionl = seox_true ).
        concatenate parameter-type c_optional into parameter-type.
      endif.
      concatenate c_comment parameter into source_line separated by space.
      append source_line to me->source.
    endloop.
*   Build exception lines
    loop at method_signature-exceptions
        assigning <signature_exception>.
      clear exception.
      if ( method_signature-method-mtdnewexc = seox_true ).
        exception-kind = c_raising.
      else.
        exception-kind = c_exceptions.
      endif.
      exception-name = <signature_exception>-sconame.
      concatenate c_comment exception into source_line separated by space.
      append source_line to me->source.
    endloop.
    append c_comment_signature_end to me->source.
  endmethod.                    "generate_method_interface
endclass.                    "lcl_method_intf_source_part IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcl_clif_source_part_list DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_clif_source_part_list definition inheriting from lcl_source_part_list abstract.
  public section.
    interfaces:
      lif_editable_source_part,
      lif_scannable_source_part,
      lif_importable_source_part.
    types:
      begin of type_object,
        type type seu_objtyp,
        name type seu_objkey,
      end of type_object.
    types:
      type_object_list type standard table of type_object with non-unique key table_line.
    methods:
      is_locked_by_position
        importing
          source_position type cl_source_scanner=>type_source_position
        returning
          value(locked)   type seox_boolean
        raising
          lcx_source_part_unknown,
      lock_by_position
        importing
          source_position type cl_source_scanner=>type_source_position
        raising
          cx_oo_access_permission,
      unlock_by_position
        importing
          source_position type cl_source_scanner=>type_source_position
        raising
          cx_oo_access_permission,
      pretty_print_by_position
        importing
          source_position         type cl_source_scanner=>type_source_position
          pretty_printer_settings type ref to if_pretty_printer_settings,
      set_properties_changed abstract.
  protected section.
    data:
      clif_key       type seoclskey.
endclass.                    "lcl_clif_source_part_list DEFINITION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_CLIF_SOURCE_PART_LIST
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_clif_source_part_list implementation.

  method lif_editable_source_part~is_locked.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    locked = seox_false.
    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          if ( editable_source_part->is_locked( ) = seox_true ).
            locked = seox_true.
            return.
          endif.
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~is_locked

  method lif_editable_source_part~lock.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->lock( suppress_access_permission = suppress_access_permission
                                      lock_handle                = lock_handle
                                      authority_check            = authority_check ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~lock

  method lif_editable_source_part~save.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->save( ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~save

  method lif_editable_source_part~unlock.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->unlock( suppress_access_permission = suppress_access_permission
                                        allow_relock               = allow_relock ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~unlock


  method lif_editable_source_part~relock.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->relock( suppress_access_permission = suppress_access_permission
                                        lock_handle                = lock_handle
                                        authority_check            = authority_check ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~relock

  method lif_editable_source_part~access_permission.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->access_permission(
            exporting
              access_mode    = access_mode
              lock_handle    = lock_handle
              authority_check = authority_check ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~insert_into_working_area


  method lif_editable_source_part~insert_into_working_area.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->insert_into_working_area( ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~insert_into_working_area

  method lif_editable_source_part~corr_insert.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->corr_insert( ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no editable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~corr_insert

  method lif_editable_source_part~set_source.
  endmethod.                    "lif_editable_source_part~set_source

  method lif_scannable_source_part~get_interval.
    field-symbols:
      <source_part> type type_source_part.
    data:
      current_interval      type cl_source_scanner=>type_source_interval,
      scannable_source_part type ref to lif_scannable_source_part,
      source_part_list      type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          scannable_source_part ?= <source_part>-source_part.
          current_interval = scannable_source_part->get_interval( ).
          if ( interval is initial ).
            interval = current_interval.
          else.
            if ( ( current_interval-begin-line < interval-begin-line ) or ( ( current_interval-begin-line = interval-begin-line ) and ( current_interval-begin-column < interval-begin-column ) ) ).
              interval-begin = current_interval-begin.
            endif.
            if ( ( current_interval-end-line > interval-end-line ) or ( ( current_interval-end-line = interval-end-line ) and ( current_interval-end-column > interval-end-column ) ) ).
              interval-end = current_interval-end.
            endif.
          endif.
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no scannable source part.
      endtry.
    endloop.
  endmethod.                    "lif_scannable_source_part~get_interval

  method lif_scannable_source_part~set_scanner.
    field-symbols:
      <source_part> type type_source_part.
    data:
      scannable_source_part type ref to lif_scannable_source_part,
      source_part_list      type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          scannable_source_part ?= <source_part>-source_part.
          scannable_source_part->set_scanner( scanner ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no scannable source part.
      endtry.
    endloop.
  endmethod.                    "lif_clif_source_part~set_scanner

  method lif_scannable_source_part~refresh.
    field-symbols:
      <source_part> type type_source_part.
    data:
      scannable_source_part type ref to lif_scannable_source_part,
      source_part_list      type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          scannable_source_part ?= <source_part>-source_part.
          scannable_source_part->refresh( ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no scannable source part.
      endtry.
    endloop.
  endmethod.                    "lif_scannable_source_part~refresh

  method lif_editable_source_part~refresh_original_source.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->refresh_original_source( ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no scannable source part.
      endtry.
    endloop.
  endmethod.                    "lif_editable_source_part~refresh_original_source

  method is_locked_by_position.
    locked = me->lif_editable_source_part~is_locked( ).
  endmethod.                    "is_locked_by_position

  method lock_by_position.
    me->lif_editable_source_part~lock( authority_check = seox_true ).
  endmethod.                    "lock_by_position

  method unlock_by_position.
    me->lif_editable_source_part~unlock( ).
  endmethod.                    "unlock_by_position

  method pretty_print_by_position.
  endmethod.                    "pretty_print_by_position


  method lif_editable_source_part~set_modification_mode_enabled.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          editable_source_part->set_modification_mode_enabled( modification_mode_enabled ).
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no scannable source part.
      endtry.
    endloop.
  endmethod.

  method lif_editable_source_part~is_modification_mode_enabled.
    field-symbols:
      <source_part> type type_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_list     type type_source_part_list.

    result = seox_false.
    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          editable_source_part ?= <source_part>-source_part.
          if ( editable_source_part->is_modification_mode_enabled( ) = seox_true ).
            result = seox_true.
            return.
          endif.
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
*         It's no scannable source part.
      endtry.
    endloop.
  endmethod.

  method lif_importable_source_part~import.
    data(source_part_list) = me->get_source_part_list( ).
    loop at source_part_list
        assigning field-symbol(<source_part>)
        where source_part is instance of lif_importable_source_part.

      data(importable_source_part) = cast lif_importable_source_part( <source_part>-source_part ).
      importable_source_part->import( ).
    endloop.
  endmethod.


endclass.               "LCL_CLIF_SOURCE_PART_LIST


*----------------------------------------------------------------------*
*       CLASS lcl_method_source_part_list DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_method_source_part_list definition inheriting from lcl_clif_source_part_list.
  public section.
    class-methods:
      "! Creates a new method implementation source part list
      "!
      "! @parameter method_key | Method key
      "! @parameter method_to_be_created | Boolean flag whether the method implementation has newly create and has been stored on the database, yet
      "! @parameter source_part | The method implementation source part which has been created
      create_method
        importing
          method_key           type seomtdkey
          persistence          type ref to lif_persistence_facade
          settings             type ref to if_oo_clif_source_settings
          signature_provider   type ref to lif_signature_provider
          method_to_be_created type seox_boolean
        returning
          value(source_part)   type ref to lcl_method_source_part_list.

    methods:
      lif_scannable_source_part~refresh redefinition,
      set_properties_changed            redefinition.
  protected section.
    data:
      method_key           type seomtdkey,
      method_to_be_created type seox_boolean.
    methods:
      handle_source_part_deleted redefinition,
      init_source_part_list      redefinition.
  private section.
    data:
      method_intf_source_part type ref to lif_source_part,
      signature_provider      type ref to lif_signature_provider.
endclass.                    "lcl_method_source_part_list DEFINITION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_METHOD_SOURCE_PART_LIST
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_method_source_part_list implementation.

  method create_method.
    create object source_part.
    source_part->clif_key-clsname = method_key-clsname.
    source_part->method_key = method_key.
    source_part->signature_provider = signature_provider.
    source_part->method_to_be_created = method_to_be_created.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_method

  method init_source_part_list.
    data:
      source_part        type ref to lif_source_part,
      method_source_part type ref to lcl_method_source_part.

    try.
        method_source_part = lcl_method_source_part=>create_method( method_key         = me->method_key
                                                                    persistence        = persistence
                                                                    settings           = settings
                                                                    signature_provider = me->signature_provider
                                                                    method_to_be_created = me->method_to_be_created ).
        source_part = lcl_spacer_source_part=>create_spacer( space_lines = 2 persistence = persistence settings = settings ).
        me->add_source_part( source_part ).
        if ( me->settings->is_signature_enabled( ) = seox_true ).
          me->method_intf_source_part = lcl_method_sign_source_part=>create_method_signature( method_key = me->method_key persistence = persistence settings = settings signature_provider = me->signature_provider ).
          me->add_source_part( method_intf_source_part ).
        endif.
        me->add_source_part( method_source_part ).
      catch cx_method_does_not_exist ##no_handler.
        "add no source part, if the method implementation does not exist
    endtry.
  endmethod.                    "init

  method handle_source_part_deleted.
    super->handle_source_part_deleted( source_part ).
*    clear me->source_part_list.
    raise event lif_editable_source_part~deleted
      exporting
        source_part = me.
  endmethod.                    "handle_source_part_deleted

  method lif_scannable_source_part~refresh.
    super->lif_scannable_source_part~refresh( ).
    if ( me->settings->is_signature_enabled( ) = seox_true ).
      me->method_intf_source_part->read( ).
    endif.
  endmethod.                    "lif_scannable_source_part~refresh


  method set_properties_changed.
    " do nothing method properties can be ignored, currently
  endmethod.
endclass.               "LCL_METHOD_SOURCE_PART_LIST

*----------------------------------------------------------------------*
*       CLASS lcl_section_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_section_source_part definition inheriting from lcl_clif_source_part .
  public section.
    class-methods:
      create_section
        importing
          clif_key           type seoclskey
          exposure           type seoexpose
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_section_source_part.

    methods:
      lif_source_part~read                              redefinition,
      lif_source_part~get_line_index                    redefinition,
      lif_scannable_source_part~get_interval            redefinition,
      lif_scannable_source_part~refresh                 redefinition,
      lif_editable_source_part~save                     redefinition,
      lif_editable_source_part~access_permission        redefinition,
      lif_editable_source_part~insert_into_working_area redefinition,
      lif_editable_source_part~corr_insert              redefinition,
      lif_editable_source_part~set_source               redefinition,
      lif_editable_source_part~refresh_original_source  redefinition,
      lif_importable_source_part~import                 redefinition.
    methods:
      set_properties_changed,
      has_changes_must_be_saved
        returning
          value(result) type seox_boolean.
  protected section.
    data:
      exposure           type seoexpose,
      properties_changed type seox_boolean value seox_false.

    methods:
      get_extension redefinition,
      is_save_allowed   redefinition,
      read_progdir      redefinition.
  private section.
    data original_super_class type seoclskey.
    methods:
      get_object_type
        returning
          value(object_type) type trobjtype,
      has_empty_source
        returning
          value(empty_source) type seox_boolean,
      is_super_class_change_relevant
        returning
          value(result) type seox_boolean,
      is_implementing_list_changed
        returning
          value(result) type seox_boolean.
endclass.                    "lcl_section_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_section_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_section_source_part implementation.

  method create_section.
    create object source_part.
    source_part->exposure = exposure.
    source_part->clif_key = clif_key.
    case exposure.
      when seoc_exposure_public.
        source_part->include_name = cl_oo_classname_service=>get_pubsec_name( clif_key-clsname ).
      when seoc_exposure_protected.
        source_part->include_name = cl_oo_classname_service=>get_prosec_name( clif_key-clsname ).
*      when seoc_exposure_package.
*        source_part->include_name = cl_oo_classname_service=>get_paksec_name( clif_key-clsname ).
      when seoc_exposure_private.
        source_part->include_name = cl_oo_classname_service=>get_prisec_name( clif_key-clsname ).
    endcase.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_section

  method lif_source_part~read.
    data inheritance type vseoextend.
    super->lif_source_part~read( version ).
    " Don't display the empty line of a disabled package section!
    if ( me->has_empty_source( ) = abap_true ).
      clear me->source.
      clear me->original_source.
    endif.
    " if the protected or private section has some comments at the beginning of the source
    " these must be copied behind the first statement so that the section is found correctly
    " This must not be done for the public section, because there can be ABAP Doc statements
    " before the class statement.
    if ( me->exposure = seoc_exposure_protected or me->exposure = seoc_exposure_private ).
      me->normalize_source( ).
    endif.
    " Set super class name to find out whether the protected section has to be
    " saved, when the inheritance is changed (to keep the existing redefinitions).
    if (  me->exposure = seoc_exposure_protected ).
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key   = me->clif_key
                                                                        importing inheritance = inheritance ).
      me->original_super_class-clsname = inheritance-refclsname.
    endif.
  endmethod.                    "lif_source_part~read

  method lif_source_part~get_line_index.
    " ignore empty line -> similar to ~read ; needed for package section
    if ( me->has_empty_source( ) = abap_false ).
      line_index = super->lif_source_part~get_line_index( ).
    endif.
  endmethod.                    "lif_source_part~get_line_index

  method lif_editable_source_part~refresh_original_source.
    data:
      inheritance type vseoextend.

    super->lif_editable_source_part~refresh_original_source( ).
    if (  me->exposure = seoc_exposure_protected ).
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key   = me->clif_key
                                                                        importing inheritance = inheritance ).
      me->original_super_class-clsname = inheritance-refclsname.
    endif.
  endmethod.

  method lif_editable_source_part~save.
    data:
      amdp_support_enabled type seox_boolean value seox_true.

    if ( me->is_save_allowed( force = force ) = seox_true ).
      if me->lif_editable_source_part~is_modification_mode_enabled( ) and
         me->persistence->lif_persistence_modass~is_modass_enabled_4_class_def( class_key = me->clif_key ) = seox_true.
        raise exception type cx_oo_source_save_failure
          exporting
            textid = cx_oo_source_save_failure=>forbidden_modifications.
      endif.
      if ( me->settings->is_ui_enabled( ) = seox_true ).
        " Class Builder in SAP GUI (SE24/SE80) shall not support ABAP
        " managed database procedures
        amdp_support_enabled = seox_false.
      endif.
      me->persistence->if_oo_clif_persist_meta_data~update_class_section_meta_data( class_key             = me->clif_key
                                                                                    exposure              = me->exposure
                                                                                    version               = lif_source_part=>c_version_inactive
                                                                                    source                = me->source
                                                                                    amdp_support_enabled  = amdp_support_enabled ).
      super->lif_editable_source_part~save( force = seox_true ).
      me->properties_changed = seox_false.
    endif.
  endmethod.                    "lif_editable_source_part~save

  method lif_editable_source_part~insert_into_working_area.
    data:
      objname type trobj_name,
      objtype type trobjtype.

    objtype = me->get_object_type( ).
    objname = me->clif_key-clsname.
    me->persistence->lif_persistence_lifecycle~insert_into_working_area( object_type = objtype object_name = objname ).
  endmethod.                    "lif_editable_source_part~insert_into_working_area

  method lif_editable_source_part~access_permission.
    data:
      object_type    type trobjtype,
      access_error   type ref to cx_oo_access_permission,
      modass_enabled type seox_boolean.

    object_type = me->get_object_type( ).
    if ( object_type = seok_limu_public ).
*     lock also the class definition
      me->persistence->lif_persistence_lifecycle~access_permission(
        exporting
          object_type     = seok_limu_class_def
          clif_key        = me->clif_key
          access_mode     = access_mode
          authority_check = authority_check ).
    endif.
    try.
        me->persistence->lif_persistence_lifecycle~access_permission(
          exporting
            object_type     = object_type
            clif_key        = me->clif_key
            access_mode     = access_mode
            authority_check = authority_check
          importing
            modification_mode_enabled = modass_enabled ).
        me->lif_editable_source_part~set_modification_mode_enabled( modass_enabled ).
      catch cx_oo_access_permission into access_error.
        if ( object_type = seok_limu_public ).
*         unlock also the class definition
          me->persistence->lif_persistence_lifecycle~access_permission( object_type     = seok_limu_class_def
                                                                        clif_key        = me->clif_key
                                                                        access_mode     = seok_access_free
                                                                        authority_check = authority_check ).
        endif.
        raise exception access_error.
    endtry.
  endmethod.                    "lif_editable_source_part~access_permission

  method lif_editable_source_part~corr_insert.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider,
      object_type               type trobjtype,
      exception                 type ref to cx_oo_source_save_failure,
      textid                    type scx_t100key.

    corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( me->clif_key-clsname ).
    object_type = me->get_object_type( ).
    try.
        me->persistence->lif_persistence_lifecycle~corr_insert(
          exporting
            object_type       = object_type
            clif_key          = me->clif_key
          changing
            correction_number = corr_insert_data_provider->correction_number
            package           = corr_insert_data_provider->package
        ).
      catch cx_oo_source_save_failure into exception.
        if ( me->is_alredy_locked_exception( exception ) = seox_true ).
          case me->exposure.
            when seoc_exposure_public.
              textid = cx_oo_locked_in_other_request=>pubsec_locked_in_other_request.
            when seoc_exposure_protected.
              textid = cx_oo_locked_in_other_request=>prosec_locked_in_other_request.
            when seoc_exposure_private.
              textid = cx_oo_locked_in_other_request=>prisec_locked_in_other_request.
          endcase.
          raise exception type cx_oo_locked_in_other_request
            exporting
              textid         = textid
              previous       = exception
              clif_name      = me->clif_key-clsname
              request_number = |{ exception->message_variable_3 }|
              request_owner  = |{ exception->message_variable_4 }|.
        else.
          raise exception exception.
        endif.
    endtry.

  endmethod.                    "lif_editable_source_part~corr_insert

  method lif_scannable_source_part~get_interval.
    data:
      class_scanner type ref to cl_oo_source_scanner_class.

    class_scanner ?= scanner.
    case exposure.
      when seoc_exposure_public.
        interval = class_scanner->get_public_section_interval( ).
      when seoc_exposure_protected.
        interval = class_scanner->get_protected_section_interval( ).
      when seoc_exposure_private.
        interval = class_scanner->get_private_section_interval( ).
    endcase.
  endmethod.                    "lif_scannable_source_part~refresh

  method lif_scannable_source_part~refresh.
    data:
      exception     type ref to cx_root,
      class_scanner type ref to cl_oo_source_scanner_class.

    try.
        class_scanner ?= scanner.
        case exposure.
          when seoc_exposure_public.
            me->source = class_scanner->get_public_section_source( ).
          when seoc_exposure_protected.
            me->source = class_scanner->get_protected_section_source( ).
          when seoc_exposure_private.
            me->source = class_scanner->get_private_section_source( ).
        endcase.
      catch cx_oo_clif_scan_error into exception.
        message exception type 'S'.
    endtry.
  endmethod.                    "lif_scannable_source_part~refresh

  method get_extension.
    case me->exposure.
      when seoc_exposure_public.
        extension = srext_ext_class_public.
      when seoc_exposure_protected.
        extension = srext_ext_class_protected.
*      when seoc_exposure_package.
*        extension = srext_ext_class_package.
      when seoc_exposure_private.
        extension = srext_ext_class_private.
    endcase.
  endmethod.                    "get_extension

  method has_empty_source.
    field-symbols:
      <source_line> type string.

    empty_source = seox_true.
    if ( me->source is not initial ).
      loop at me->source
          assigning <source_line>.
        if ( <source_line> is not initial ).
          empty_source = seox_false.
        endif.
      endloop.
    endif.
  endmethod.                    "has_empty_source

  method read_progdir.
    result = super->read_progdir( version ).
    result-subc = 'I'.
  endmethod.                    "read_progdir

  method get_object_type.
    case me->exposure.
      when seoc_exposure_public.
        object_type = seok_limu_public.
      when seoc_exposure_protected.
        object_type = seok_limu_protected.
*      when seoc_exposure_package.
*        object_type = seok_limu_package.
      when seoc_exposure_private.
        object_type = seok_limu_private.
    endcase.
  endmethod.                    "get_object_type

  method lif_editable_source_part~set_source.
    data:
      source_representation type ref to cl_oo_source_representation.

    super->lif_editable_source_part~set_source( source ).
    source_representation ?= scanner.
    case me->exposure.
      when seoc_exposure_public.
        source_representation->set_public_section_source( source ).
      when seoc_exposure_protected.
        source_representation->set_protected_section_source( source ).
*      when seoc_exposure_package.
*        source_representation->set_package_section_source( source ).
      when seoc_exposure_private.
        source_representation->set_private_section_source( source ).
    endcase.

  endmethod.                    "lif_editable_source_part~set_source

  method is_save_allowed.
    if ( ( super->is_save_allowed( force = force ) = seox_true ) or
         ( properties_changed = seox_true ) or
         ( me->is_super_class_change_relevant( ) = seox_true ) or
         ( me->is_implementing_list_changed( ) = seox_true )  ).
      result = seox_true.
    else.
      result = seox_false.
    endif.
  endmethod.

  method set_properties_changed.
    me->properties_changed = seox_true.
  endmethod.

  method is_super_class_change_relevant.
    data:
      inheritance type vseoextend.

    result = seox_false.
    if ( me->exposure = seoc_exposure_protected ).
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key   = me->clif_key
                                                                        importing inheritance = inheritance ).
      if ( inheritance-refclsname <> original_super_class-clsname ).
        result = seox_true.
      endif.
    endif.
  endmethod.

  method is_implementing_list_changed.
    data inheritance          type vseoextend.
    data super_class          type seoclskey.
    data actual_implementings type seor_implementings_r.
    data set_of_comprisings   type seor_comprising_keys.
    data scanned_implementing type seor_comprising_key.
    data intkey               type seoclskey.
    data:
      act_implementings type sorted table of seoclsname with unique key table_line,
      exp_implementings type sorted table of seoclsname with unique key table_line.


    result = seox_false.

    if ( me->exposure = seoc_exposure_public ).

      " Retrieve the actual implemented interfaces. I.e, all interfaces
      " which are implemented by this class (as stored in the metadata tables)
      me->persistence->if_oo_clif_persist_meta_data~get_class_typeinfo( exporting class_key     = me->clif_key
                                                                        importing implementings = actual_implementings
                                                                                  inheritance   = inheritance ).

      loop at actual_implementings assigning field-symbol(<act_impl>).
        insert <act_impl>-refclsname into table act_implementings.
      endloop.

      " Retrieve the interfaces which are implemented by the super classes.
      " These interfaces must not be implemented by this class!
      " REMARK: We can use the super class from the metadata instead from the source code.
      " For the case, the super class has been changed, this method won't be called, because
      " this requires already a source code change in the public section and is_save_allowed( )
      "  will return true anyway.
      super_class-clsname = inheritance-refclsname.
      data(inherited_implementings) = me->persistence->if_oo_clif_persist_meta_data~class_all_implementg_get( class_key = super_class ).

      " Retrieve the expected implemented interfaces which are implemented in the
      " current source of the public section.
      " Additionally, for these interfaces, all comprised interfaces have to
      " be added to the expected interfaces. This is needed for ABAP compiler!
      " Inherited interfaces must be excluded from the list of expectd interfaces
      data(scanned_impls) = me->scanner->get_implementings( ).
      loop at scanned_impls assigning field-symbol(<fs_impl>).
        insert <fs_impl>-name into table exp_implementings.

        " Add all comprised interfaces ...
        clear set_of_comprisings.
        intkey-clsname = <fs_impl>-name.
        set_of_comprisings = me->persistence->if_oo_clif_persist_meta_data~interface_all_compri_get( intkey = intkey ).
        loop at set_of_comprisings assigning field-symbol(<compri>).
          " ... if they are not already implemented by any super class.
          read table inherited_implementings with key refclsname = <compri>-refclsname transporting no fields.
          if ( sy-subrc <> 0 ).
            insert <compri>-refclsname into table exp_implementings.
          endif.
        endloop.
      endloop.

      if ( act_implementings <> exp_implementings ).
        " The actual implemented interfaces are not the expected ones.
        " => The public section has to be saved in order to update table SEOMETAREL
        result = seox_true.
        return.
      endif.

    endif.

  endmethod.

  method has_changes_must_be_saved.
    result = me->is_save_allowed( seox_false ).
  endmethod.

  method lif_importable_source_part~import.
    if ( me->is_import_allowed( ) = seox_true ).
      me->persistence->if_oo_clif_persist_meta_data~update_class_section_meta_data( class_key             = me->clif_key
                                                                                    exposure              = me->exposure
                                                                                    version               = lif_source_part=>c_version_active
                                                                                    source                = me->source
                                                                                    amdp_support_enabled  = seox_true ).
      super->lif_importable_source_part~import( ).
      me->properties_changed = seox_false.
    endif.

  endmethod.

endclass.                    "lcl_section_source_part IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_section_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_class_def_source_part_list definition inheriting from lcl_clif_source_part_list.
  public section.
    class-methods:
      create_class_definition
        importing
          clif_key           type seoclskey
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_class_def_source_part_list.
    methods:
      set_properties_changed        redefinition,
      lif_editable_source_part~save redefinition.

  protected section.
    methods:
      init_source_part_list redefinition.
  private section.
    data:
      public_section_source_part    type ref to lcl_section_source_part,
      protected_section_source_part type ref to lcl_section_source_part,
      private_section_source_part   type ref to lcl_section_source_part,
      sap_version_public            type ref to cl_oo_sap_version_of_section,
      sap_version_protected         type ref to cl_oo_sap_version_of_section,
      sap_version_private           type ref to cl_oo_sap_version_of_section.

    methods:
      read_original_sap_versions
        raising
          cx_oo_source_save_failure,
      disable_modifcation_assistant
        raising
          cx_oo_source_save_failure,
      is_save_of_all_sections_needed
        returning
          value(result) type seox_boolean.
endclass.                    "lcl_section_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_endclass_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_endclass_source_part definition inheriting from lcl_source_part.
  public section.
    interfaces:
      lif_scannable_source_part.
    class-methods:
      create_endclass
        importing
          definition         type seox_boolean
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_endclass_source_part.

    methods:
      lif_source_part~read redefinition.
  private section.
    data:
      definition type seox_boolean,
      scanner    type ref to cl_oo_source_scanner_class.
endclass.                    "lcl_endclass_source_part DEFINITION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_ENDCLASS_SOURCE_PART
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_endclass_source_part implementation.

  method create_endclass.

    create object source_part.
    source_part->init( persistence = persistence settings = settings ).
    source_part->definition = definition.
  endmethod.                    "create_endclass

  method lif_source_part~read.
    super->lif_source_part~read( version ).
    append 'ENDCLASS.' to me->source.
  endmethod.                    "lif_source_part~read

  method lif_scannable_source_part~get_interval.
    if ( me->definition = seox_true ).
      interval = me->scanner->get_endclass_def_interval( ).
    else.
      interval = me->scanner->get_endclass_impl_interval( ).
    endif.
  endmethod.                    "lif_scannable_source_part~get_interval

  method lif_scannable_source_part~refresh.
*   Do nothing.
  endmethod.                    "lif_scannable_source_part~refresh

  method lif_scannable_source_part~set_scanner.
    me->scanner ?= scanner.
  endmethod.                    "lif_scannable_source_part~set_scanner

endclass.               "LCL_ENDCLASS_SOURCE_PART


*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_SECTION_SOURCE_PART_LIST
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_class_def_source_part_list implementation.

  method create_class_definition.
    create object source_part.
    source_part->clif_key-clsname = clif_key.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_section

  method init_source_part_list.
    data:
      source_part type ref to lif_source_part.

    " public section
    me->public_section_source_part = lcl_section_source_part=>create_section( clif_key = me->clif_key exposure = seoc_exposure_public persistence = persistence settings = settings ).
    me->add_source_part( public_section_source_part ).
    " protected section
    me->protected_section_source_part = lcl_section_source_part=>create_section( clif_key = me->clif_key exposure = seoc_exposure_protected persistence = persistence settings = settings ).
    me->add_source_part( me->protected_section_source_part ).
    " private section
    me->private_section_source_part = lcl_section_source_part=>create_section( clif_key = me->clif_key exposure = seoc_exposure_private persistence = persistence settings = settings ).
    me->add_source_part( me->private_section_source_part ).
    " ENDCLASS statement
    source_part = lcl_endclass_source_part=>create_endclass( definition = seox_true persistence = persistence settings = settings ).
    me->add_source_part( source_part ).
  endmethod.

  method set_properties_changed.
    me->public_section_source_part->set_properties_changed( ).
  endmethod.

  method lif_editable_source_part~save.
    data:
      force_save_sections type seox_boolean value seox_false,
      is_modified_cpub    type seox_boolean value seox_false,
      is_modified_cpri    type seox_boolean value seox_false,
      is_modified_cpro    type seox_boolean value seox_false.

    if ( ( force = seox_true ) or ( me->is_save_of_all_sections_needed( ) = seox_true ) ).
      me->read_original_sap_versions( ).
      if me->persistence->lif_persistence_modass~is_modass_enabled_4_class_def( class_key = me->clif_key ) = seox_true.
        me->persistence->lif_persistence_modass~is_clif_modified_with_modass(
          exporting
            object_type               = seok_limu_public
            clif_key                  = me->clif_key
          receiving
            result                    = is_modified_cpub  ).
        me->persistence->lif_persistence_modass~is_clif_modified_with_modass(
         exporting
           object_type               = seok_limu_protected
           clif_key                  = me->clif_key
         receiving
           result                    = is_modified_cpro  ).
        me->persistence->lif_persistence_modass~is_clif_modified_with_modass(
          exporting
            object_type               = seok_limu_private
            clif_key                  = me->clif_key
          receiving
            result                    = is_modified_cpri  ).

        " ec:  turn off only not modified otherwise save modifications
        if is_modified_cpub = seox_false and is_modified_cpro = seox_false and is_modified_cpri = seox_false.
          me->disable_modifcation_assistant( ).
        endif.
      endif.

      super->lif_editable_source_part~save(
          force = seox_true
      ).
    else.
      super->lif_editable_source_part~save(
          force = force
      ).
    endif.
  endmethod.

  method is_save_of_all_sections_needed.
    result = boolc( (  me->lif_editable_source_part~is_modification_mode_enabled( ) = seox_true ) and
                    ( ( me->public_section_source_part->has_changes_must_be_saved( )    = seox_true ) or
                      ( me->protected_section_source_part->has_changes_must_be_saved( ) = seox_true ) or
                      ( me->private_section_source_part->has_changes_must_be_saved( )   = seox_true ) ) ).
  endmethod.

  method read_original_sap_versions.
    me->persistence->lif_persistence_modass~read_sap_versions_4_class_def(
      exporting
        class_key                 = me->clif_key
      importing
        sap_version_public        = me->sap_version_public
        sap_version_protected     = me->sap_version_protected
        sap_version_private       = me->sap_version_private
    ).
  endmethod.

  method disable_modifcation_assistant.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider.

    if ( me->lif_editable_source_part~is_modification_mode_enabled( ) = seox_false ).
      return.
    endif.
    if ( me->persistence->lif_persistence_modass~is_modass_enabled_4_class_def( me->clif_key ) = seox_true ).
      me->lif_editable_source_part~corr_insert( ).
      corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( clif_name = me->clif_key-clsname ).
      me->persistence->lif_persistence_modass~disable_modass_4_class_def(
            class_key             = me->clif_key
            correction_number     = corr_insert_data_provider->correction_number
            sap_version_public    = me->sap_version_public
            sap_version_protected = me->sap_version_protected
            sap_version_private   = me->sap_version_private ).
    endif.
  endmethod.


endclass.               "LCL_SECTION_SOURCE_PART_LIST

*----------------------------------------------------------------------*
*       CLASS lcl_class_impl_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_class_impl_source_part definition inheriting from lcl_source_part.
  public section.
    interfaces:
      lif_scannable_source_part.
    class-methods:
      create_class_implementation
        importing
          class_name         type seoclsname
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_class_impl_source_part.

    methods:
      lif_source_part~read redefinition.
  protected section.

    methods:
      init redefinition.
  private section.
    data:
      class_name type seoclsname,
      scanner    type ref to cl_oo_source_scanner_class.
endclass.                    "lcl_class_impl_source_part DEFINITION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_CLASS_IMPL_SOURCE_PART
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_class_impl_source_part implementation.

  method create_class_implementation.
    create object source_part.
    source_part->class_name = class_name.
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_class_implementation

  method init.
    data:
      source_part      type ref to lcl_abstract_source_part.

    super->init( persistence = persistence settings = settings ).
    source_part = lcl_spacer_source_part=>create_spacer( space_lines = 3 persistence = persistence settings = settings ).
    me->pre_plug->lif_source_part_plug~add_plugin( source_part ).
  endmethod.                    "init

  method lif_source_part~read.
    data:
      source_line type string.

    super->lif_source_part~read( version = version ).
    concatenate 'CLASS' class_name 'IMPLEMENTATION.' into source_line separated by space.
    append source_line to me->source.
  endmethod.                    "lif_source_part~read

  method lif_scannable_source_part~get_interval.
    interval = me->scanner->get_class_impl_interval( ).
  endmethod.                    "lif_scannable_source_part~get_interval

  method lif_scannable_source_part~refresh.
*   Do nothing.
  endmethod.                    "lif_scannable_source_part~refresh

  method lif_scannable_source_part~set_scanner.
    me->scanner ?= scanner.
  endmethod.                    "lif_scannable_source_part~set_scanner

endclass.               "LCL_CLASS_IMPL_SOURCE_PART

*----------------------------------------------------------------------*
*       CLASS lcl_class_source_part_list DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_class_source_part_list definition inheriting from lcl_clif_source_part_list.
  public section.
    class-methods:
      create_class
        importing
                  class_key          type seoclskey
                  persistence        type ref to lif_persistence_facade
                  settings           type ref to if_oo_clif_source_settings
                  signature_provider type ref to lif_signature_provider
                  pos_index_helper   type ref to if_oo_source_pos_index_helper
        returning
                  value(source_part) type ref to lcl_class_source_part_list
        raising   cx_oo_clif_not_exists.

    methods:
      lif_source_part~read                         redefinition,
      lif_source_part~get_source                   redefinition,
      lif_source_part~get_line_index               redefinition,
      lif_editable_source_part~save                redefinition,
      lif_editable_source_part~access_permission   redefinition,
      lif_editable_source_part~is_locked           redefinition,
      lif_editable_source_part~lock                redefinition,
      lif_editable_source_part~unlock              redefinition,
      lif_editable_source_part~relock              redefinition,
      lif_scannable_source_part~set_scanner        redefinition,
      lif_scannable_source_part~refresh            redefinition,
      lif_importable_source_part~import            redefinition,
      is_locked_by_position                        redefinition,
      lock_by_position                             redefinition,
      pretty_print_by_position                     redefinition,
      unlock_by_position                           redefinition,
      set_properties_changed                       redefinition.

    methods:
      is_completely_locked
        returning
          value(locked) type seox_boolean,
      activate
        importing
          timestamp_before_activation type xsddatetime_z
          method_no_before_activation type i.
  protected section.

    methods:
      remove_source_part    redefinition,
      init_source_part_list redefinition.
  private section.
    types:
      begin of method_with_position_entry,
        cpdkey   type seocpdkey,
        incname  type programm,
        position type i,
      end of method_with_position_entry.
    types:
      methods_with_position type standard table of method_with_position_entry with default key.
    types:
      begin of type_method_id_map_entry,
        method type seomtdkey,
        id     type i,
      end of type_method_id_map_entry.
    types:
      type_method_id_map type hashed table of type_method_id_map_entry
                              with unique key method.
    data:
      method_id_map                type type_method_id_map,
      source_representation        type ref to cl_oo_source_representation,
      locked                       type lif_editable_source_part=>type_lock value lif_editable_source_part=>c_lock_unlocked,
      signature_provider           type ref to lif_signature_provider,
      class_definition_source_part type ref to lcl_class_def_source_part_list,
      pos_index_helper             type ref to if_oo_source_pos_index_helper,
      modification_mode_enabled    type seox_boolean value seox_false.


    methods:
      init_class_definition,
      init_class_implementation
        raising cx_oo_clif_not_exists,
      "! Adds a new method implementation source part
      "!
      "! @parameter method_key | Method key
      "! @parameter method_to_be_created | Boolean flag whether the method implementation has newly create and has been stored on the database, yet
      "! @parameter method_source_part | The method implementation source part which has been created
      add_method_implementation
        importing
          method_key                type seomtdkey
          method_to_be_created      type seox_boolean
        returning
          value(method_source_part) type ref to lcl_method_source_part_list,
      create_method_implementation
        importing
          method_key type seomtdkey
        raising
          cx_oo_canceled,
      get_source_part_by_position
        importing
          source_position    type cl_source_scanner=>type_source_position
        returning
          value(source_part) type ref to lif_scannable_source_part
        raising
          cx_oo_clif_scan_error
          lcx_source_part_unknown,
      refresh_method_signatures,
      refresh_source_part_order,
      lock_cs_include
        raising
          cx_oo_cs_include_lock_error,
      unlock_cs_include,
      is_cs_include_valid
        importing
          version            type r3state default if_oo_clif_source=>co_version_inactive
          timestamp_of_class type xsddatetime_z
          method_no_of_class type i
        returning
          value(result)      type seox_boolean
        raising
          cx_include_does_not_exist.
    methods get_pos_index_helper
      returning
        value(result) type ref to if_oo_source_pos_index_helper.
    methods inject_pos_index_helper
      importing
        ref type ref to if_oo_source_pos_index_helper.
    methods save_cs_include
      importing
        version                type r3state
        source                 type rswsourcet
        number_of_method_impls type i.
    methods delete_cs_include
      importing
        include_name type program
        version      type r3state
      raising
        cx_oo_source_save_failure.
    methods sort_methods_by_pos_index
      changing
        methods type seop_methods_w_include.
endclass.                    "lcl_class_source_part_list DEFINITION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_CLASS_SOURCE_PART_LIST
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_class_source_part_list implementation.

  method lock_cs_include.
    data:
      lock_attempts         type i value 0.

    while ( me->persistence->if_oo_clif_persistence_source~lock_cs_include( me->clif_key-clsname ) = seox_false ).
      "source is currently locked => try once more in a second (up to 10 times)
      if ( lock_attempts = 10 ).
        assert id seo condition 1 = 0.
        raise exception type cx_oo_cs_include_lock_error.
      endif.
      wait up to 1 seconds.
      lock_attempts = lock_attempts + 1.
    endwhile.
  endmethod.                    "lock_cs_include

  method unlock_cs_include.
    me->persistence->if_oo_clif_persistence_source~unlock_cs_include( me->clif_key-clsname ).
  endmethod.                    "unlock_cs_include

  method is_cs_include_valid.
    data:
      cs_include_name type program,
      timestamp_of_cs type xsddatetime_z,
      method_no_of_cs type i.

    cs_include_name = cl_oo_classname_service=>get_cs_name( me->clif_key-clsname ).
    timestamp_of_cs = me->persistence->if_oo_clif_persistence_source~read_timestamp_for_include( include_name = cs_include_name state = version ).
    method_no_of_cs = me->persistence->if_oo_clif_persistence_source~read_no_of_method_includes( class_name = me->clif_key-clsname ).
    if ( ( timestamp_of_cs is not initial ) and ( timestamp_of_cs >= timestamp_of_class ) and
         ( method_no_of_cs >= 0 ) and ( method_no_of_cs = method_no_of_class ) ).
      result = seox_true.
    else.
      result = seox_false.
    endif.
  endmethod.                    "is_cs_include_valid

  method activate.
    data:
      cs_include_name    type program,
      cs_include_source  type rswsourcet,
      method_no_of_class type i.

    cs_include_name = cl_oo_classname_service=>get_cs_name( me->clif_key-clsname ).
    try.
        me->lock_cs_include( ).
        if ( me->is_cs_include_valid( version = if_oo_clif_source=>co_version_inactive
                                      timestamp_of_class = timestamp_before_activation
                                      method_no_of_class = method_no_before_activation ) = seox_true ).
*         Activate the content of the cs include.
          me->persistence->if_oo_clif_persistence_source~read_report(
            exporting
              include_name = cs_include_name
              state        = if_oo_clif_source=>co_version_inactive
            importing
              source       = cs_include_source
          ).
          method_no_of_class = lines( me->persistence->if_oo_clif_persist_meta_data~get_all_method_includes( class_name = me->clif_key-clsname ) ).
          me->save_cs_include( version = if_oo_clif_source=>co_version_active source = cs_include_source number_of_method_impls = method_no_of_class ).
          delete_cs_include(
            include_name = cs_include_name
            version      = if_oo_clif_source=>co_version_inactive
          ).
        else.
*         Inactive version is not valid! Delete the active version
          delete_cs_include(
            include_name = cs_include_name
            version      = if_oo_clif_source=>co_version_active
          ).
        endif.
      catch cx_include_does_not_exist.
*       Inactive version not found => delete active version
        delete_cs_include(
          include_name = cs_include_name
          version      = if_oo_clif_source=>co_version_active
        ).
      catch cx_oo_cs_include_lock_error ##no_handler.
        " ignore exception, the content of the cs-include will be dropped if the object will be read the next time.
      cleanup.
        me->unlock_cs_include( ).
    endtry.
    me->unlock_cs_include( ).
  endmethod.        "activate

  method delete_cs_include.
    me->persistence->if_oo_clif_persistence_source~delete_report(
        include_name = include_name
        state        = version
    ).

    data lpos_index_helper type ref to if_oo_source_pos_index_helper.

    lpos_index_helper = get_pos_index_helper( ).
    lpos_index_helper->delete_index(
        class_name = me->clif_key-clsname
        version    = version
    ).
  endmethod.

  method lif_source_part~read.
    data:
      my_version             type r3state,
      exception              type ref to cx_root,
      cs_include_name        type program,
      classpool_include_name type program,
      last_changed           type xsddatetime_z,
      last_changed_cs        type xsddatetime_z,
      scanner                type ref to cl_oo_source_scanner_class,
      cs_include_source      type rswsourcet,
      class_timestamp        type xsddatetime_z,
      method_no_of_class     type i,
      lpos_index_helper      type ref to if_oo_source_pos_index_helper.

    " clear the current source representation, because it might contain an obsolete source!
    clear me->source_representation.
    if ( me->settings->is_signature_enabled( ) = seox_false ).
      try.
          me->lock_cs_include( ).
          my_version = version.
          cs_include_name = cl_oo_classname_service=>get_cs_name( me->clif_key-clsname ).
          try.
              class_timestamp = me->persistence->if_oo_clif_persistence_source~read_timestamp_for_class( class_name = me->clif_key-clsname state = my_version ).
              try.
                  method_no_of_class = lines( me->persistence->if_oo_clif_persist_meta_data~get_all_method_includes( class_name = me->clif_key-clsname ) ).
                catch cx_oo_clif_not_exists into exception.
                  raise exception type cx_oo_clif_inconsistent
                    exporting
                      textid    = cx_oo_clif_inconsistent=>inconsistent_class
                      previous  = exception
                      clif_name = me->clif_key-clsname.
              endtry.
              if ( me->is_cs_include_valid( version = my_version
                                            timestamp_of_class = class_timestamp
                                            method_no_of_class = method_no_of_class ) = seox_true ).
                me->persistence->if_oo_clif_persistence_source~read_report(
                  exporting
                    include_name = cs_include_name
                    state        = my_version
                  importing
                    source       = cs_include_source
                ).
              else.
                super->lif_source_part~read( version = version ).
                cs_include_source = me->lif_source_part~get_source( ).
                me->save_cs_include( version = my_version source = cs_include_source number_of_method_impls = method_no_of_class ).
              endif.
            catch cx_include_does_not_exist cx_oo_clif_scan_error.
              if ( ( my_version = if_oo_clif_source=>co_version_inactive ) and
                   ( me->persistence->if_oo_clif_persistence_source~has_class_inactive_source_part( me->clif_key ) = abap_false ) ).
                my_version = if_oo_clif_source=>co_version_active.
                retry.
              endif.
              super->lif_source_part~read( version = my_version ).
              cs_include_source = me->lif_source_part~get_source( ).
              me->save_cs_include( version = my_version source = cs_include_source number_of_method_impls = method_no_of_class ).
          endtry.
          me->unlock_cs_include( ).
          "  me->source_representation = cl_oo_source_representation=>create_source_representation( clif_name = me->clif_key-clsname source = cs_include_source ).
        catch cx_oo_cs_include_lock_error.
          " Enqueue server can not be reached
          super->lif_source_part~read( version = version ).
          cs_include_source = me->lif_source_part~get_source( ).
        cleanup.
          me->unlock_cs_include( ).
      endtry.
    else.
      super->lif_source_part~read( version = version ).
      cs_include_source = me->lif_source_part~get_source( ).
    endif.
    me->source_representation = cl_oo_source_representation=>create_source_representation( clif_name = me->clif_key-clsname source = cs_include_source ).
  endmethod.                    "lif_source_part~read

  method lif_editable_source_part~save.
    data:
      cs_include_name        type program,
      cs_include_source      type rswsourcet,
      state                  type r3state value lif_source_part=>c_version_inactive,
      number_of_method_impls type i.

    super->lif_editable_source_part~save( force = force ).
    if ( me->settings->is_signature_enabled( ) = seox_false ).
      if ( ( force = seox_false ) and ( me->is_completely_locked( ) = seox_false ) ).
        raise exception type cx_oo_source_save_failure
          exporting
            textid    = cx_oo_source_save_failure=>not_locked
            clif_name = me->clif_key-clsname.
      endif.
      cs_include_name = cl_oo_classname_service=>get_cs_name( me->clif_key-clsname ).
      " we have to insert the CS-include in the working area to verify
      " that the CS-include is activated if there are only changes to the CS-include
      " but no change to any method implementation or section
      if ( me->persistence->if_oo_clif_persistence_source~has_class_inactive_source_part( me->clif_key ) = seox_false ).
        " No section or method implementation is inactive => store the CS-include
        " in the active version. Reason: The activation won't activate the CS-include
        " if no section or method implementation is inactive!
        state = lif_source_part=>c_version_active.
      endif.
      number_of_method_impls = lines( me->persistence->if_oo_clif_persist_meta_data~get_all_method_includes( class_name = me->clif_key-clsname ) ).
      me->save_cs_include(
        exporting
          version                = state
          source                 = me->source_representation->get_source( )
          number_of_method_impls = number_of_method_impls
      ).
    endif.
  endmethod.                    "lif_editable_source_part~save

  method lif_source_part~get_source.
    if ( me->source_representation is not initial ).
      source_table = me->source_representation->get_source( ).
    else.
      source_table = super->lif_source_part~get_source( ).
    endif.
  endmethod.                    "lif_source_part~get_source

  method lif_source_part~get_line_index.
    field-symbols:
      <line_index_entry> type edlineindx.

    line_index = super->lif_source_part~get_line_index( ).
    if ( me->locked = lif_editable_source_part=>c_lock_locked ).
      " mark all lines as editable so that copy/paste works
      loop at line_index
          assigning <line_index_entry>.
        <line_index_entry>-noedit_flg = seox_false.
      endloop.
    endif.
  endmethod.                    "lif_source_part~get_line_index

  method create_class.
    create object source_part.
    source_part->init( persistence = persistence settings = settings ).
    source_part->clif_key = class_key.
    source_part->signature_provider = signature_provider.
    source_part->pos_index_helper = pos_index_helper.
  endmethod.                    "create_class

  method is_completely_locked.
    if ( me->locked = lif_editable_source_part=>c_lock_locked ).
      locked = seox_true.
    else.
      locked = seox_false.
    endif.
  endmethod.                    "is_completely_locked

  method lif_editable_source_part~access_permission.
    data:
      modass_enabled type seox_boolean.

    me->persistence->lif_persistence_lifecycle~access_permission(
      exporting
        object_type     = seok_r3tr_class
        clif_key        = me->clif_key
        access_mode     = access_mode
        lock_handle     = lock_handle
        authority_check = authority_check
      importing
        modification_mode_enabled  = me->modification_mode_enabled ).
  endmethod.                    "lif_editable_source_part~access_permission

  method lif_editable_source_part~lock.
    if ( suppress_access_permission = seox_false ).
      me->lif_editable_source_part~access_permission(
        exporting
          access_mode     = seok_access_modify
          lock_handle     = lock_handle
          authority_check = authority_check ).
    endif.
    me->locked = lif_editable_source_part=>c_lock_locked.
    " if the class is locked the source part list has to be refreshed, because in an inactive
    " version source parts can have been added or deleted by another user.
    me->reset_source_part_list( ).
    super->lif_editable_source_part~lock( suppress_access_permission = seox_true ).
    " propagate that modification assistant is available in the system.
    " This information has been lost due to the reset of the source part list
    " after locking the class.
    me->lif_editable_source_part~set_modification_mode_enabled( me->modification_mode_enabled ).
  endmethod.                    "lif_editable_source_part~lock

  method lif_editable_source_part~unlock.
    data:
      supp_child_access_permission type seox_boolean value seox_true.

    if ( me->locked <> lif_editable_source_part=>c_lock_locked ).
      super->lif_editable_source_part~unlock( suppress_access_permission  = suppress_access_permission
                                              allow_relock                = allow_relock ).
      return.
    endif.
    me->lif_editable_source_part~access_permission( access_mode     = seok_access_free ).
    if ( allow_relock = seox_true ).
      me->locked = lif_editable_source_part=>c_lock_unlocked_ephemerally.
    else.
      me->locked = lif_editable_source_part=>c_lock_unlocked.
    endif.
    super->lif_editable_source_part~unlock( suppress_access_permission = seox_true
                                            allow_relock               = allow_relock ).
  endmethod.                    "lif_editable_source_part~unlock

  method lif_editable_source_part~relock.
    if ( me->locked = lif_editable_source_part=>c_lock_unlocked ).
      super->lif_editable_source_part~relock( suppress_access_permission = suppress_access_permission
                                              lock_handle                = lock_handle
                                              authority_check            = authority_check ).
      return.
    endif.
    me->lif_editable_source_part~lock( suppress_access_permission = suppress_access_permission
                                       lock_handle                = lock_handle
                                       authority_check            = authority_check ).
  endmethod.                    "lif_editable_source_part~relock

  method lif_editable_source_part~is_locked.
    if ( me->locked = lif_editable_source_part=>c_lock_locked ).
      locked = seox_true.
    elseif ( me->settings->is_ui_enabled( ) = seox_true ).
      " only in SAP GUI version it is possible to lock single source parts
      locked = super->lif_editable_source_part~is_locked( ).
    else.
      locked = seox_false.
    endif.
  endmethod.                    "lif_editable_source_part~is_locked

  method lif_scannable_source_part~set_scanner.
    super->lif_scannable_source_part~set_scanner( scanner ).
    me->source_representation ?= scanner.
  endmethod.                    "lif_scannable_source_part~set_scanner

  method lif_scannable_source_part~refresh.
    data:
      clif_scanner           type ref to cl_oo_source_scanner,
      method_implementations type cl_oo_source_scanner_class=>type_method_implementations,
      method_key             type seomtdkey,
      l_orig_name            type seocpdname,
      l_alias_name           type seocmpname.

    field-symbols:
      <method_implementation> type seocpdname.

    me->refresh_method_signatures( ).
*   Refresh the class' source
    super->lif_scannable_source_part~refresh( ).
    try.
        method_implementations = me->source_representation->get_method_implementations( ).
        loop at method_implementations assigning <method_implementation>.
          method_key-clsname = me->clif_key-clsname.
          method_key-mtdname = <method_implementation>.
          read table me->method_id_map
               with table key method = method_key
               transporting no fields.
          if ( sy-subrc <> 0 ).
            " ec : alias-checks to avoid duplicate meth. include creation
            if method_key-mtdname ns '~'.
              l_alias_name = method_key-mtdname.
              l_orig_name = me->source_representation->get_method_by_alias( method_name = l_alias_name ).
              if l_orig_name is not initial. " it's an alias !
                method_key-mtdname = l_orig_name.
                read table me->method_id_map with table key method = method_key transporting no fields.
                if sy-subrc <> 0.
                  me->create_method_implementation( method_key ).
                endif.
              else.
                me->create_method_implementation( method_key ).
              endif.
            else.
              me->create_method_implementation( method_key ).
            endif.
          endif.
        endloop.
      catch cx_sy_move_cast_error.                     "#EC NO_HANDLER.
*       No clif scanner
    endtry.
    me->refresh_source_part_order( ).
  endmethod.                    "lif_scannable_source_part~refresh

  method is_locked_by_position.
    data:
      editable_source_part type ref to lif_editable_source_part,
      exception            type ref to cx_root.

    try.
        editable_source_part ?= me->get_source_part_by_position( source_position ).
        locked = editable_source_part->is_locked( ).
      catch cx_sy_move_cast_error
            cx_oo_clif_scan_error into exception .
        message exception type 'I'.
    endtry.
  endmethod.                    "is_locked_by_position

  method pretty_print_by_position.
    data:
      part_list              type ref to lcl_source_part_list,
      source_part_list       type lcl_source_part_list=>type_source_part_list,
      formatable_source_part type ref to lif_formatable_source_part.
    field-symbols:
      <source_part> type type_source_part.
    try.
        " find source part by position
        part_list ?= me->get_source_part_by_position( source_position ).
        source_part_list = part_list->get_source_part_list( ).
        loop at source_part_list assigning <source_part>.
          try.
              formatable_source_part ?= <source_part>-source_part.
              " trigger pretty print
              formatable_source_part->pretty_print( pretty_printer_settings = pretty_printer_settings ).
            catch cx_sy_move_cast_error.                "#EC NO_HANDLER
          endtry.
        endloop.
      catch lcx_source_part_unknown
            cx_oo_clif_scan_error.                      "#EC NO_HANDLER
        " it is not a formatable source part
    endtry.
  endmethod.                    "pretty_print_by_position

  method lock_by_position.
    data:
      editable_source_part type ref to lif_editable_source_part,
      exception            type ref to cx_root.

    try.
        editable_source_part ?= me->get_source_part_by_position( source_position ).
*       Reread the source again, because it could have been changed by another user
        editable_source_part->lif_source_part~read( lif_source_part=>c_version_inactive ).
        editable_source_part->lock( authority_check = seox_true ).
      catch cx_sy_move_cast_error
            cx_oo_clif_scan_error
            lcx_source_part_unknown into exception.     "#EC NO_HANDLER
        message exception type 'I'.
    endtry.
  endmethod.                    "lock_by_position

  method unlock_by_position.
    data:
      editable_source_part type ref to lif_editable_source_part,
      exception            type ref to cx_root.

    try.
        editable_source_part ?= me->get_source_part_by_position( source_position ).
        editable_source_part->unlock( ).
      catch cx_sy_move_cast_error
            cx_oo_clif_scan_error
            lcx_source_part_unknown into exception.     "#EC NO_HANDLER
        message exception type 'I'.
    endtry.
  endmethod.                    "unlock_by_position

  method init_class_definition.
    me->class_definition_source_part = lcl_class_def_source_part_list=>create_class_definition( clif_key = me->clif_key persistence = persistence settings = settings ).
    me->add_source_part( me->class_definition_source_part ).
  endmethod.                    "init_class_definition

  method init_class_implementation.
    data:
      source_part       type ref to lif_source_part,
      method_key        type seomtdkey,
      methods           type seop_methods_w_include,
      keep_method_order type abap_bool.
    field-symbols:
      <method>            type seop_method_w_include.

*   Add CLASS ... IMPLEMENTATION
    source_part = lcl_class_impl_source_part=>create_class_implementation( class_name = me->clif_key-clsname persistence = persistence settings = settings ).
    me->add_source_part( source_part ).
*   Add method implementations
    methods = me->persistence->if_oo_clif_persist_meta_data~get_all_method_includes( class_name = me->clif_key-clsname ).

    keep_method_order = me->persistence->if_oo_clif_persist_meta_data~keep_method_order( class_name = me->clif_key-clsname ).
    if ( sy-subrc = 0 ).
      if keep_method_order = abap_false.
        me->sort_methods_by_pos_index( changing methods = methods ).
      endif.
      method_key-clsname = me->clif_key-clsname.
      loop at methods
          assigning <method>.
        method_key-mtdname = <method>-cpdkey-cpdname.
        me->add_method_implementation( method_key = method_key method_to_be_created = seox_false ).
      endloop.
    endif.
*   Add Endclass
    source_part = lcl_endclass_source_part=>create_endclass( definition = seox_false persistence = persistence settings = settings ).
    me->add_source_part( source_part ).
  endmethod.                    "init_class_implementation

  method sort_methods_by_pos_index.
*    sort methods by cpdkey.
    data(version) = cond #( when me->persistence->if_oo_clif_persistence_source~has_class_inactive_source_part( me->clif_key )
                              then lif_source_part=>c_version_inactive
                              else lif_source_part=>c_version_active ).

    data(source_pos_index) = me->get_pos_index_helper( )->get_source_pos_index_for_class(
      class_name = me->clif_key-clsname
      version    = version ).
    if lines( source_pos_index ) = 0 and version = lif_source_part=>c_version_inactive.
      source_pos_index = me->get_pos_index_helper( )->get_source_pos_index_for_class(
            class_name = me->clif_key-clsname
            version    = lif_source_part=>c_version_active ).
    endif.

    data(methods_with_position) = value methods_with_position(
      for method in methods
       ( cpdkey = method-cpdkey
         incname = method-incname
         position = value #( source_pos_index[ include_name = method-incname ]-start_line default cl_abap_math=>max_int4 ) )
    ).

    sort methods_with_position by position cpdkey.
    clear methods.
    move-corresponding methods_with_position to methods.
  endmethod.

  method add_method_implementation.
    data:
      method_id_map_entry type type_method_id_map_entry.

    method_source_part = lcl_method_source_part_list=>create_method( method_key         = method_key
                                                                     persistence        = persistence
                                                                     settings           = settings
                                                                     signature_provider = me->signature_provider
                                                                     method_to_be_created = method_to_be_created ).
    me->add_source_part( method_source_part ).
    method_id_map_entry-method = method_key.
    try.
        method_id_map_entry-id     = me->get_id_by_source_part( method_source_part ).
        insert method_id_map_entry into table me->method_id_map.
      catch lcx_source_part_unknown.                    "#EC NO_HANDLER
    endtry.
  endmethod.                    "add_method_implementation

  method create_method_implementation.
    data:
      editable_source_part  type ref to lif_editable_source_part,
      scannable_source_part type ref to lif_scannable_source_part,
      exception             type ref to cx_root,
      textid                type scx_t100key.

    scannable_source_part = me->add_method_implementation( method_key = method_key method_to_be_created = seox_true ).
    try.
        editable_source_part ?= scannable_source_part.
        editable_source_part->set_modification_mode_enabled( me->modification_mode_enabled ).
        editable_source_part->lock( suppress_access_permission = seox_true ).
      catch cx_oo_access_permission into exception.
*       Exception may not occur, because the access permission should be suppressed!
        message exception type 'I'.
      catch cx_sy_move_cast_error.                      "#EC NO_HANDLER
    endtry.
    scannable_source_part->set_scanner( me->source_representation ).
    scannable_source_part->refresh( ).
  endmethod.                    "create_method_implementation

  method refresh_source_part_order.
    types:
      begin of type_source_part_order_entry,
        interval type cl_source_scanner=>type_source_interval,
        id       type i,
      end of type_source_part_order_entry.
    data:
      source_part_list        type type_source_part_list,
      order                   type i,
      source_part_order_entry type type_source_part_order_entry,
      source_part_order       type sorted table of type_source_part_order_entry
                                   with non-unique key interval,
      scannable_source_part   type ref to lif_scannable_source_part.
    field-symbols:
      <source_part>             type type_source_part,
      <source_part_order_entry> type type_source_part_order_entry.

*   Get source part intervals
    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      scannable_source_part ?= <source_part>-source_part.
      try.
          source_part_order_entry-interval = scannable_source_part->get_interval( ).
        catch cx_oo_clif_scan_error.                    "#EC NO_HANDLER
      endtry.
      source_part_order_entry-id       = <source_part>-id.
      insert source_part_order_entry into table source_part_order.
    endloop.
*   bring the new order to the source_part_list.
    order = 0.
    loop at source_part_order                           "#EC CI_SORTSEQ
        assigning <source_part_order_entry>.
      me->set_source_part_order( id = <source_part_order_entry>-id order = order ).
      order = order + 1.
    endloop.
  endmethod.                    "refresh_source_part_order

  method init_source_part_list.
    me->init_class_definition( ).
    me->init_class_implementation( ).
  endmethod.                    "init_source_part_list

  method remove_source_part.
    data:
      source_part_list         type type_source_part_list.
    field-symbols:
      <source_part_list_entry> type type_source_part.

    source_part_list = me->get_source_part_list( ).
    read table source_part_list
        with key source_part = source_part
        assigning <source_part_list_entry>.
    if ( sy-subrc = 0 ).
      delete me->method_id_map
          where id = <source_part_list_entry>-id.
    endif.
    super->remove_source_part( source_part ).
  endmethod.                    "remove_source_part

  method refresh_method_signatures.
    if ( me->settings->is_signature_enabled( ) = seox_true ).
      me->signature_provider->refresh( ).
    endif.
  endmethod.                    "refresh_method_signatures

  method get_source_part_by_position.
    data:
      interval         type cl_source_scanner=>type_source_interval,
      source_part_list type type_source_part_list.
    field-symbols:
      <source_part>             type type_source_part.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      try.
          source_part ?= <source_part>-source_part.
          interval = source_part->get_interval( ).
          if ( ( ( source_position-line > interval-begin-line ) or ( (  source_position-line = interval-begin-line  ) and (  source_position-column > interval-begin-column  ) ) ) and
               ( ( source_position-line < interval-end-line ) or ( (  source_position-line = interval-end-line  ) and (  source_position-column < interval-end-column  ) ) ) ).
*           Source part found!
            return.
          endif.
        catch cx_sy_move_cast_error.                    "#EC NO_HANDLER
      endtry.
    endloop.
    raise exception type lcx_source_part_unknown.
  endmethod.                    "get_source_part_by_position


  method set_properties_changed.
    me->class_definition_source_part->set_properties_changed( ).
  endmethod.

  method get_pos_index_helper.
    if pos_index_helper is initial.
      create object pos_index_helper type cl_oo_source_pos_index_helper.
    endif.
    result = pos_index_helper.
  endmethod.

  method inject_pos_index_helper.
    pos_index_helper = ref.
  endmethod.

  method save_cs_include.
    me->persistence->if_oo_clif_persistence_source~insert_report(
          include_name   = cl_oo_classname_service=>get_cs_name( me->clif_key-clsname )
          state          = version
          source         = source
          program_type   = 'I'
          extension_type = 'CS'
      ).
    me->persistence->if_oo_clif_persistence_source~write_no_of_method_includes(
        class_name            = me->clif_key-clsname
        no_of_method_includes = number_of_method_impls ).

    " create index for source positions to get faster access later
    data(lpos_index_helper) = get_pos_index_helper( ).
    if me->settings->is_signature_enabled( ) = abap_true.
      " signature enable - non AiE mode -> we cannot create the index because source contains method docu
      " we only delete the index in non AiE mode
      lpos_index_helper->delete_index(
        class_name = me->clif_key-clsname
        version    = version
      ).
    else.
      if me->source_representation is bound.
        lpos_index_helper->create_index_with_scanner( class_name = me->clif_key-clsname
                           version = version  scanner = me->source_representation ).
      else.
        lpos_index_helper->create_index( class_name = me->clif_key-clsname
                           version = version ).
      endif.
    endif.

  endmethod.

  method lif_importable_source_part~import.
    data:
      cs_include_name        type program,
      number_of_method_impls type i.

    super->lif_importable_source_part~import( ).
    if ( me->is_completely_locked( ) = seox_false ).
      raise exception type cx_oo_source_save_failure
        exporting
          textid    = cx_oo_source_save_failure=>not_locked
          clif_name = me->clif_key-clsname.
    endif.
    cs_include_name = cl_oo_classname_service=>get_cs_name( me->clif_key-clsname ).
    number_of_method_impls = lines( me->persistence->if_oo_clif_persist_meta_data~get_all_method_includes( class_name = me->clif_key-clsname ) ).
    me->save_cs_include(
      exporting
        version                = lif_source_part=>c_version_active
        source                 = me->source_representation->get_source( )
        number_of_method_impls = number_of_method_impls
    ).
  endmethod.

endclass.               "LCL_CLASS_SOURCE_PART_LIST

*----------------------------------------------------------------------*
*       CLASS lcl_interface_source_part DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_interface_source_part definition inheriting from lcl_clif_source_part .
  public section.
    class-methods:
      create_interface
        importing
          clif_key           type seoclskey
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_interface_source_part.

    methods:
      lif_scannable_source_part~get_interval            redefinition,
      lif_scannable_source_part~refresh                 redefinition,
      lif_editable_source_part~save                     redefinition,
      lif_editable_source_part~access_permission        redefinition,
      lif_editable_source_part~insert_into_working_area redefinition,
      lif_editable_source_part~corr_insert              redefinition,
      lif_importable_source_part~import                 redefinition.
    methods:
      set_properties_changed.
  protected section.
    methods:
      get_extension     redefinition,
      read_progdir      redefinition,
      is_save_allowed   redefinition.
  private section.
    data:
      properties_changed    type seox_boolean value seox_false,
      sap_version_interface type ref to cl_oo_sap_version_of_interface.
    methods:
      read_original_sap_version
        raising
          cx_oo_source_save_failure,
      disable_modification_assistant
        raising
          cx_oo_source_save_failure.
endclass.                    "lcl_section_source_part DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_interface_source_part IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_interface_source_part implementation.

  method create_interface.
    create object source_part.
    source_part->clif_key = clif_key.
    source_part->include_name = cl_oo_classname_service=>get_intfsec_name( clif_key-clsname ).
    source_part->init( persistence = persistence settings = settings ).
  endmethod.                    "create_section

  method lif_editable_source_part~save.
    data:
      scan_error           type ref to cx_oo_clif_scan_error,
      amdp_support_enabled type seox_boolean value seox_true.
    data:
      is_modified                 type seox_boolean value seox_false.

    if ( me->is_save_allowed( force = force ) = seox_true ).
      me->read_original_sap_version( ).
      me->persistence->lif_persistence_modass~is_clif_modified_with_modass(
        exporting
          object_type               = seok_r3tr_interface
          clif_key                  = me->clif_key
        receiving
          result                    = is_modified  ).

      " ec:  turn off only not modified otherwise save modifications
      if is_modified = seox_false.
        me->disable_modification_assistant( ).
      endif.
      me->persistence->if_oo_clif_persist_meta_data~update_intf_section_meta_data( interface_key        = me->clif_key
                                                                                   version              = lif_source_part=>c_version_inactive
                                                                                   source               = source
                                                                                   amdp_support_enabled = amdp_support_enabled ).
      super->lif_editable_source_part~save( force = seox_true ).
      me->properties_changed = seox_false.
    endif.
  endmethod.                    "lif_editable_source_part~save

  method lif_editable_source_part~access_permission.
    data:
      modass_enabled type seox_boolean.

    me->persistence->lif_persistence_lifecycle~access_permission(
      exporting
        object_type     = seok_r3tr_interface
        clif_key        = me->clif_key
        access_mode     = access_mode
        lock_handle     = lock_handle
        authority_check = authority_check

      importing
        modification_mode_enabled = modass_enabled ).
    me->lif_editable_source_part~set_modification_mode_enabled( modass_enabled ).
  endmethod.                    "lif_editable_source_part~access_permission

  method lif_editable_source_part~insert_into_working_area.
    data:
      objname type trobj_name,
      objtype type trobjtype.

    objtype = seok_r3tr_interface.
    objname = me->clif_key-clsname.
    me->persistence->lif_persistence_lifecycle~insert_into_working_area( object_type = objtype object_name = objname ).
  endmethod.                    "lif_editable_source_part~insert_into_working_area

  method lif_editable_source_part~corr_insert.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider,
      object_type               type trobjtype.

    corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( me->clif_key-clsname ).
    object_type = seok_r3tr_interface.
    me->persistence->lif_persistence_lifecycle~corr_insert(
      exporting
        object_type       = object_type
        clif_key          = me->clif_key
      changing
        correction_number = corr_insert_data_provider->correction_number
        package           = corr_insert_data_provider->package
    ).
  endmethod.                    "lif_editable_source_part~corr_insert

  method lif_scannable_source_part~get_interval.
    data:
      interface_scanner type ref to cl_oo_source_scanner_interface.

    interface_scanner ?= scanner.
    interval = interface_scanner->get_interface_section_interval( ).
  endmethod.                    "lif_scannable_source_part~refresh

  method lif_scannable_source_part~refresh.
    data:
      interface_scanner type ref to cl_oo_source_scanner_interface,
      source_line       type string.

    interface_scanner ?= scanner.
    me->source = interface_scanner->get_interface_section_source( ).
  endmethod.                    "lif_scannable_source_part~refresh

  method get_extension.
    extension = srext_ext_interface_public.
  endmethod.                    "get_extension

  method read_progdir.
    result = super->read_progdir( version ).
    result-subc = 'I'.
  endmethod.                    "read_progdir


  method is_save_allowed.
    if ( ( super->is_save_allowed( force = force ) = seox_true ) or ( me->properties_changed = seox_true )  ).
      result = seox_true.
    else.
      result = seox_false.
    endif.
  endmethod.

  method set_properties_changed.
    me->properties_changed = seox_true.
  endmethod.

  method read_original_sap_version.
    me->persistence->lif_persistence_modass~read_sap_version_4_interface(
      exporting
        interface_key             = me->clif_key
      importing
        sap_version_interface     = me->sap_version_interface
    ).
  endmethod.


  method disable_modification_assistant.
    data:
      corr_insert_data_provider type ref to lcl_corr_insert_data_provider.

    if ( me->lif_editable_source_part~is_modification_mode_enabled( ) = seox_false ).
      return.
    endif.
    if ( me->persistence->lif_persistence_modass~is_modass_enabled_4_interface( me->clif_key ) = seox_true ).
      me->lif_editable_source_part~corr_insert( ).
      corr_insert_data_provider = lcl_corr_insert_data_provider=>get_data_provider( clif_name = me->clif_key-clsname ).
      me->persistence->lif_persistence_modass~disable_modass_4_interface(
            interface_key         = me->clif_key
            correction_number     = corr_insert_data_provider->correction_number
            sap_version_interface = me->sap_version_interface ).
    endif.
  endmethod.


  method lif_importable_source_part~import.
    data:
      scan_error           type ref to cx_oo_clif_scan_error,
      amdp_support_enabled type seox_boolean value seox_true.
    data:
      is_modified                 type seox_boolean value seox_false.

    if ( me->is_import_allowed( ) = seox_true ).
      me->persistence->if_oo_clif_persist_meta_data~update_intf_section_meta_data( interface_key        = me->clif_key
                                                                                   version              = lif_source_part=>c_version_active
                                                                                   source               = source
                                                                                   amdp_support_enabled = amdp_support_enabled ).
      super->lif_importable_source_part~import( ).
      me->properties_changed = seox_false.
    endif.

  endmethod.

endclass.                    "lcl_interface_source_part IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_interface_source_part_list DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_interface_source_part_list definition inheriting from lcl_clif_source_part_list.
  public section.
    class-methods:
      create_interface
        importing
          class_key          type seoclskey
          persistence        type ref to lif_persistence_facade
          settings           type ref to if_oo_clif_source_settings
        returning
          value(source_part) type ref to lcl_interface_source_part_list.
    methods:
      set_properties_changed redefinition.
  protected section.

    methods:
      init_source_part_list redefinition.
  private section.
    data:
      interface_source_part type ref to lcl_interface_source_part.
endclass.                    "lcl_interface_source_part_list DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_interface_source_part_list IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_interface_source_part_list implementation.

  method create_interface.
    create object source_part.
    source_part->init( persistence = persistence settings = settings ).
    source_part->clif_key = class_key.

  endmethod.                    "create_interface

  method init_source_part_list.
*   Add Sections
    me->interface_source_part = lcl_interface_source_part=>create_interface( clif_key = me->clif_key persistence = persistence settings = settings ).
    me->add_source_part( me->interface_source_part ).
  endmethod.                    "init_class_definition


  method set_properties_changed.
    me->interface_source_part->set_properties_changed( ).
  endmethod.
endclass.               "LCL_CLASS_SOURCE_PART_LIST

*----------------------------------------------------------------------*
*       CLASS lcl_persistence_source DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_source definition.
  public section.
    interfaces:
      if_oo_clif_persistence_source.
    class-methods:
      get_instance
        returning
          value(instance) type ref to lcl_persistence_source.
endclass.                    "lcl_persistence_source DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_persistence_source IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_source implementation.

  method get_instance.
    create object instance.
  endmethod.                    "get_instance

  method if_oo_clif_persistence_source~read_report.
    read report include_name into source state state.
    if ( sy-subrc <> 0 ).
      raise exception type cx_include_does_not_exist.
    endif.
  endmethod.                    "lif_persistence_source~read_report

  method if_oo_clif_persistence_source~insert_report.
    data:
      exception type ref to cx_sy_write_src_line_too_long.

    try.
        if ( ( extension_type is not supplied ) or ( extension_type is initial ) ).
          insert report include_name from source state state program type program_type .
        else.
          if ( extension_type = 'CS' ).
            insert report include_name from source extension type extension_type state state program type program_type .
          else.
            insert report include_name from source extension type extension_type state state program type program_type .
          endif.
        endif.
        if ( sy-subrc <> 0 ).
          raise exception type cx_oo_source_save_failure.
        endif.
      catch cx_sy_write_src_line_too_long into exception.
        raise exception type cx_oo_source_save_failure
          exporting
            textid   = cx_oo_source_save_failure=>source_line_too_long
            previous = exception.
    endtry.
  endmethod.                    "lif_persistence_source~insert_report

  method if_oo_clif_persistence_source~delete_report.
    delete report include_name state state.
  endmethod.                    "lif_persistence_source~delete_report

  method if_oo_clif_persistence_source~read_progdir.
    select single *
        from progdir
        into progdir
        where name  = include_name and
              state = state.
    if ( sy-subrc <> 0 ).
      raise exception type cx_include_does_not_exist.
    endif.
  endmethod.                    "lif_persistence_source~read_progdir

  method if_oo_clif_persistence_source~update_progdir.
    call function 'UPDATE_PROGDIR'
      exporting
        i_progdir    = progdir
        i_progname   = include_name
        i_state      = state
      exceptions
        not_executed = 1.
    if ( sy-subrc <> 0 ).
      raise exception type cx_oo_source_save_failure.
    endif.
  endmethod.                    "lif_persistence_source~update_progdir

  method if_oo_clif_persistence_source~read_timestamp_for_include.
    data:
      udat  type rdir_udate,
      utime type ddtime.

    select single udat utime from reposrc into (udat, utime)
           where progname = include_name and r3state = state.
    if ( sy-subrc <> 0 ).
      raise exception type cx_include_does_not_exist.
    endif.
    cl_abap_tstmp=>systemtstmp_syst2utc(
            exporting
                syst_date = udat
                syst_time = utime
            importing
                utc_tstmp = result ).
  endmethod.                    "lif_persistence_source~read_timestamp_for_include

  method if_oo_clif_persistence_source~read_timestamp_for_class.
    data:
      helper type ref to cl_oo_clif_source_helper.

    helper = cl_oo_clif_source_helper=>create_instance( ).
    helper->get_include_info(
      exporting
        class_name                  = class_name
        version                     = state
        consider_main_includes_only = abap_true
      changing
        changed_on                  = result
    ).
  endmethod.                    "lif_persistence_source~read_timestamp_for_class

  method if_oo_clif_persistence_source~lock_cs_include.
    data:
      cs_include_name       type program.

    cs_include_name = cl_oo_classname_service=>get_cs_name( class_name ).
    call function 'ENQUEUE_ESEO_CS_INCLUDE'
      exporting
        name           = cs_include_name
      exceptions
        foreign_lock   = 1
        system_failure = 2
        others         = 3.
    case sy-subrc.
      when 0. "OK
        result = seox_true.
      when 1.
        result = seox_false.
      when others.
        raise exception type cx_oo_cs_include_lock_error exporting textid = cx_oo_cs_include_lock_error=>cx_oo_cs_include_lock_error.
    endcase.
  endmethod.                    "lif_persistence_source~lock_cs_include

  method if_oo_clif_persistence_source~unlock_cs_include.
    data:
      cs_include_name       type program.

    cs_include_name = cl_oo_classname_service=>get_cs_name( class_name ).
    call function 'DEQUEUE_ESEO_CS_INCLUDE'
      exporting
        name = cs_include_name.
  endmethod.                    "lif_persistence_source~unlock_cs_include

  method if_oo_clif_persistence_source~reset_generation_flag_in_tmdir.
    data:
       helper type ref to cl_oo_exception_class.

    create object helper
      exporting
        clskey = clif_key.
    helper->reset_generation_flag_in_tmdir( exporting  lifecycle_manager = lifecycle_manager ).

  endmethod.                    "lif_persistence_source~set_constructor_generation

  method if_oo_clif_persistence_source~add_suppress_generation_pragma.
    data:
       helper type ref to cl_oo_exception_class.

    create object helper
      exporting
        clskey = clif_key.
    helper->add_suppress_generation_pragma( changing source = source ).
  endmethod.

  method if_oo_clif_persistence_source~del_suppress_generation_pragma.
    data:
       helper type ref to cl_oo_exception_class.

    create object helper
      exporting
        clskey = clif_key.
    helper->del_suppress_generation_pragma( importing adjustment_was_executed = adjustment_was_executed changing source = source ).
  endmethod.


  method if_oo_clif_persistence_source~has_class_inactive_source_part.
    types:
      begin of ty_include_name,
        name type progname,
      end of ty_include_name.
    data:
      method_includes type seop_methods_w_include,
      include_name    type ty_include_name,
      include_names   type sorted table of ty_include_name with unique key name,
      dummy_state     type standard table of r3state.
    field-symbols:
      <method_include> type seop_method_w_include.

    include_name = cl_oo_classname_service=>get_pubsec_name( class_key-clsname ).
    insert include_name into table include_names.
    include_name = cl_oo_classname_service=>get_prosec_name( class_key-clsname ).
    insert include_name into table include_names.
    include_name = cl_oo_classname_service=>get_prisec_name( class_key-clsname ).
    insert include_name into table include_names.
    method_includes = cl_oo_classname_service=>get_all_method_includes( class_key-clsname ).
    loop at method_includes assigning <method_include>.
      include_name = <method_include>-incname.
      insert include_name into table include_names.
    endloop.
    select state from progdir
                 into table dummy_state
                 up to 1 rows
                 for all entries in include_names
                 where name  = include_names-name and
                       state = lif_source_part=>c_version_inactive.
    if ( sy-subrc = 0 ).
      result = seox_true.
    else.
      result = seox_false.
    endif.
  endmethod.


  method if_oo_clif_persistence_source~write_no_of_method_includes.
    data:
      cs_cache_entry type seo_cs_cache.

    cs_cache_entry-clsname            = class_name.
    cs_cache_entry-no_of_method_impls = no_of_method_includes.
    modify seo_cs_cache from cs_cache_entry.
  endmethod.


  method if_oo_clif_persistence_source~read_no_of_method_includes.
    select single no_of_method_impls from seo_cs_cache into result where clsname = class_name.
    if ( sy-subrc <> 0 ).
      result = -1.
    endif.
  endmethod.

endclass.                    "lcl_persistence_source IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_persistence_meta_data DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_meta_data definition.
  public section.
    interfaces:
      if_oo_clif_persist_meta_data.
    class-methods:
      get_instance
        importing
          lifecycle_manager type ref to if_adt_lifecycle_manager
        returning
          value(instance)   type ref to lcl_persistence_meta_data.
  private section.
    data:
      lifecycle_manager type ref to if_adt_lifecycle_manager.

    methods:
      init
        importing
          lifecycle_manager type ref to if_adt_lifecycle_manager.
endclass.                    "lcl_persistence_meta_data DEFINITION


class lcl_oo_classname_service definition create private.

  public section.
    class-methods:
      get_method_include
        importing
          mtdkey        type seocpdkey
        returning
          value(result) type program
        raising
          cx_method_does_not_exist.
  private section.
    class-methods:
      "! Calcualtes the last 3 numbers for method includes ( *=CM###)
      calculate_index
        importing
                  value(index)  type tmdir-methodindx
        returning value(result) type sychar03,
      "! Calculates one number of the method include index
      calculate_char
        importing
          base  type i
        exporting
          char  type char01
        changing
          index type tmdir-methodindx.
endclass.

class lcl_oo_classname_service implementation.


  method get_method_include.
    data:
      method_index type tmdir-methodindx,
      index        type c length 3.

    select single methodindx
        from tmdir bypassing buffer
        into method_index
        where classname  = mtdkey-clsname
          and methodname = mtdkey-cpdname.
    if ( sy-subrc <> 0 ).
      raise exception type cx_method_does_not_exist.
    endif.
    result = cl_oo_classname_service=>get_classpool_name( mtdkey-clsname ).
    result = result(30) && 'CM' && calculate_index( index = method_index ).
  endmethod.

  method calculate_index.
    calculate_char( exporting base = 1 importing char = result+2(1) changing index = index ).
    calculate_char( exporting base = 2 importing char = result+1(1) changing index = index ).
    calculate_char( exporting base = 3 importing char = result(1)   changing index = index ).
  endmethod.

  method calculate_char.
    constants:
      co_map type c length 36 value '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.
    data:
      mod_divisor type i,
      map_offset  type i.


    mod_divisor = 36 ** ( base - 1 ).
    index = index div mod_divisor.
    map_offset = index mod 36.
    index = index - map_offset.
    char = co_map+map_offset.
  endmethod.
endclass.


*----------------------------------------------------------------------*
*       CLASS lcl_persistence_meta_data IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_meta_data implementation.

  method get_instance.
    create object instance.
    instance->init( lifecycle_manager ).
  endmethod.                    "get_instance

  method init.
    me->lifecycle_manager = lifecycle_manager.
  endmethod.                    "init

  method if_oo_clif_persist_meta_data~update_class_section_meta_data.
    data:
      section_source type ref to cl_oo_class_section_source,
      scan_error     type seox_boolean,
      scan_exception type ref to cx_oo_clif_scan_error.

    create object section_source
      exporting
        clskey                        = class_key
        exposure                      = exposure
        state                         = version
        source                        = source
        lifecycle_manager             = me->lifecycle_manager
        suppress_constrctr_generation = seox_true.

    section_source->set_dark_mode( seox_true ).
    section_source->set_amdp_support( amdp_support_enabled ).
    section_source->scan_section_source(
      receiving
        scan_error             = scan_error
      exceptions
        scan_abap_source_error = 1
        others                 = 2
      ).
    if ( ( sy-subrc <> 0 ) or ( scan_error = seox_true ) ).
      raise exception type cx_oo_clif_scan_error.
    endif.
    section_source->revert_scan_result( suppress_access_permission = seox_true ).
    if ( exposure = seoc_exposure_public ).
*         If the public section has been changed, the class pool has to be generated!!!
      call function 'SEO_CLASS_GENERATE_CLASSPOOL'
        exporting
          clskey        = class_key
          suppress_corr = seox_true
        exceptions
          others        = 1.
      if ( sy-subrc <> 0 ).
        raise exception type cx_oo_source_save_failure.
      endif.
    endif.
  endmethod.                    "lif_persistence_meta_data~update_class_section_meta_data

  method if_oo_clif_persist_meta_data~update_intf_section_meta_data.
    data:
      section_source type ref to cl_oo_interface_section_source,
      scan_error     type seox_boolean,
      scan_exception type ref to cx_oo_clif_scan_error.

    create object section_source
      exporting
        intkey            = interface_key
        state             = version
        source            = source
        lifecycle_manager = me->lifecycle_manager.
    section_source->set_dark_mode( seox_true ).
    section_source->set_amdp_support( amdp_support_enabled ).
    section_source->scan_section_source(
      receiving
        scan_error             = scan_error
      exceptions
        scan_abap_source_error = 1
        others                 = 2
      ).
    if ( ( sy-subrc <> 0 ) or ( scan_error = seox_true ) ).
      raise exception type cx_oo_clif_scan_error.
    endif.
    try.
        section_source->revert_scan_result(
          exporting
            suppress_access_permission = 'X' ).
      catch cx_oo_clif_scan_error into scan_exception.
        message s026(oo_source_based) with interface_key-clsname.
        raise exception type cx_oo_source_save_failure
          exporting
            previous           = scan_exception
            textid             = cx_oo_source_save_failure=>create_textid_from_msg_params( )
            clif_name          = interface_key-clsname
            message_variable_1 = sy-msgv1.
    endtry.
    call function 'SEO_INTERFACE_GENERATE_POOL'
      exporting
        intkey = interface_key
      exceptions
        others = 1.
    if ( sy-subrc <> 0 ).
      raise exception type cx_oo_source_save_failure.
    endif.
  endmethod.                    "lif_persistence_meta_data~update_intf_section_meta_data

  method if_oo_clif_persist_meta_data~delete_method_include.
    if ( version = lif_source_part=>c_version_active ).
      call function 'SEO_CLIF_SET_WBINACTIVE'
        exporting
          wbia = seox_false.
    endif.
    call function 'SEO_METHOD_DELETE_INCLUDE'
      exporting
        mtdkey                        = method_key
        suppress_commit               = seox_true
        lifecycle_manager             = me->lifecycle_manager
        suppress_index_update         = seox_false
      changing
        corrnr                        = correction_number
      exceptions
        _internal_class_not_existing  = 1
        _internal_method_not_existing = 2
        others                        = 3.
    if ( sy-subrc <> 0 ).
      message id sy-msgid type sy-msgty number sy-msgno
              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.
    if ( version = lif_source_part=>c_version_active ).
      call function 'SEO_CLIF_SET_WBINACTIVE'
        exporting
          wbia = seox_true.
    endif.
  endmethod.                    "lif_persistence_meta_data~delete_method_include

  method if_oo_clif_persist_meta_data~generate_method_include.
    data:
      l_extend                    type seox_boolean.

*    until we support proper creation with ModAss from ADT
*    l_extend = modification_mode_enabled.
    if ( version = lif_source_part=>c_version_active ).
      call function 'SEO_CLIF_SET_WBINACTIVE'
        exporting
          wbia = seox_false.
    endif.

    clear: sy-msgno, sy-msgid, sy-msgv1, sy-msgv2, sy-msgv3, sy-msgv4.
    call function 'SEO_METHOD_GENERATE_INCLUDE'
      exporting
        mtdkey                         = method_key
        version                        = seoc_version_inactive
        suppress_mtdkey_check          = seox_true
        lifecycle_manager              = me->lifecycle_manager
        extend                         = l_extend
        suppress_index_update          = seox_true
      exceptions
        not_existing                   = 1
        model_only                     = 2
        include_existing               = 3
        method_imp_not_generated       = 4
        method_imp_not_initialised     = 5
        _internal_class_not_existing   = 6
        _internal_method_overflow      = 7
        cancelled                      = 8
        method_is_abstract_implemented = 9
        method_is_final_implemented    = 10
        internal_error_insert_report   = 11
        others                         = 12.
    case sy-subrc.
      when 0. " No error.
      when 3.
        " This error can be ignored, because the include does exist.
      when 8.
        " The action has been canceled by the user
        if ( version = lif_source_part=>c_version_active ).
          call function 'SEO_CLIF_SET_WBINACTIVE'
            exporting
              wbia = seox_true.
        endif.
        if ( ( sy-msgid is initial ) or ( sy-msgno is initial ) ).
          raise exception type cx_oo_canceled
            exporting
              textid = cx_oo_canceled=>cx_oo_canceled.
        else.
          raise exception type cx_oo_canceled
            exporting
              textid             = cx_oo_canceled=>create_textid_from_msg_params( )
              message_variable_1 = sy-msgv1
              message_variable_2 = sy-msgv2
              message_variable_3 = sy-msgv3
              message_variable_4 = sy-msgv4.
        endif.
      when others.
        message id sy-msgid type 'X' number sy-msgno
                with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endcase.
    if ( version = lif_source_part=>c_version_active ).
      call function 'SEO_CLIF_SET_WBINACTIVE'
        exporting
          wbia = seox_true.
    endif.
  endmethod.                    "lif_persistence_meta_data~generate_method_include

  method if_oo_clif_persist_meta_data~get_clif_type.
    call function 'SEO_CLIF_GET'
      exporting
        cifkey       = clif_key
      importing
        clstype      = clif_type
      exceptions
        not_existing = 1
        others       = 2.
    if ( sy-subrc <> 0 ).
      raise exception type cx_oo_clif_not_exists
        exporting
          clif_name = clif_key-clsname.
    endif.
  endmethod.                    "lif_persistence_meta_data~get_clif_type

  method if_oo_clif_persist_meta_data~get_class_typeinfo.
    call function 'SEO_CLASS_TYPEINFO_GET'
      exporting
        clskey        = class_key
      importing
        methods       = methods
        parameters    = parameters
        exceps        = excepts
        inheritance   = inheritance
        implementings = implementings.
  endmethod.                    "lif_persistence_meta_data~get_class_typeinfo

  method if_oo_clif_persist_meta_data~get_interface_typeinfo.
    call function 'SEO_INTERFACE_TYPEINFO_GET'
      exporting
        intkey      = interface_key
      importing
        methods     = methods
        parameters  = parameters
        exceps      = excepts
        comprisings = comprisings.
  endmethod.                    "lif_persistence_meta_data~get_interface_typeinfo

  method if_oo_clif_persist_meta_data~class_all_implementg_get.
    clear result.
    call function 'SEO_CLASS_ALL_IMPLEMENTG_GET'
      exporting
        clskey                        = class_key
        version                       = seoc_version_inactive
        state                         = '1'
        resolve_comprising_interfaces = seox_true
      importing
        set                           = result
      exceptions
        others                        = 0.
  endmethod.

  method if_oo_clif_persist_meta_data~interface_all_compri_get.
    clear result.
    call function 'SEO_INTERFACE_ALL_COMPRI_GET'
      exporting
        intkey  = intkey
        version = seoc_version_inactive
      importing
        set     = result
      exceptions
        others  = 0.
  endmethod.

  method if_oo_clif_persist_meta_data~get_all_method_includes.
    cl_oo_classname_service=>get_all_method_includes(
      exporting
        clsname            = class_name
      receiving
        result             = method_includes
      exceptions
        class_not_existing = 1
        others             = 2
    ).
    if ( sy-subrc <> 0 ).
      raise exception type cx_oo_clif_not_exists
        exporting
          clif_name = class_name.
    endif.
  endmethod.                    "lif_persistence_meta_data~get_all_method_includes

  method if_oo_clif_persist_meta_data~keep_method_order.
    result = abap_false.
  endmethod.

  method if_oo_clif_persist_meta_data~get_method_include.
    cl_oo_classname_service=>get_method_include(
      exporting
        mtdkey = method_key
      receiving
        result = include_name
      exceptions
        method_not_existing = 1 ).
    if ( sy-subrc <> 0 ).
      " It might be that the buffer of this application server has not been filled yet,
      " therefore we have to bypass the buffer.
      include_name = lcl_oo_classname_service=>get_method_include( mtdkey = method_key ).
    endif.
  endmethod.                    "lif_persistence_meta_data~get_method_include

  method if_oo_clif_persist_meta_data~get_method_data.
    data:
      method_definition_key type seocmpkey.

    call function 'SEO_COMPONENT_BY_INHERITANCE'
      exporting
        cpdkey = method_key
      importing
        cmpkey = method_definition_key.
    call function 'SEO_METHOD_GET'
      exporting
        mtdkey = method_definition_key
      importing
        method = method_data.
  endmethod.                    "lif_persistence_meta_data~get_method_data

  method if_oo_clif_persist_meta_data~is_exception_class.
    data:
      helper type ref to cl_oo_exception_class.

    create object helper
      exporting
        clskey = clif_key.
    result = helper->is_exception_class( ).
  endmethod.                    "lif_persistence_meta_data~is_exception_class
endclass.                    "lcl_persistence_meta_data IMPLEMENTATION


class lcl_persistence_modass definition.
  public section.
    interfaces:
      lif_persistence_modass.

    class-methods:
      get_instance
        importing
          lifecycle_manager type ref to if_adt_lifecycle_manager
        returning
          value(instance)   type ref to lcl_persistence_modass.
  private section.
    data:
      lifecycle_manager type ref to if_adt_lifecycle_manager.
    methods get_dark_editor_information
      importing
        method_key   type seomtdkey
        include_name type progname
      exporting
        dark_editor  type ref to cl_wb_cleditor_services
        wb_source    type ref to cl_wb_source
        wb_editor    type ref to cl_wb_editor.
    methods save_note_entries_in_smodisrc
      importing
        method_key type seomtdkey.
endclass.

class lcl_persistence_modass implementation.

  method get_instance.
    create object instance.
    instance->lifecycle_manager = lifecycle_manager.
  endmethod.                    "get_instance

  method get_dark_editor_information.
    data: object_inactive_version type char1,
          object_is_work_item     type char1,
          version                 type char1.
    data:
     sub_name type eu_lname.

    data obj_type                     type e071-object.
    data obj_name                     type e071-obj_name.
    data obj_name_eu                  type seu_objkey.
    data obj_type_eu                  type seu_objtyp.
    data obj_name_for_dark_processing type eu_lname.

    sub_name(30) = method_key-clsname.
    sub_name+30  = method_key-mtdname.
    call function 'RS_OBJECT_IN_WORKING_AREA'
      exporting
        object                  = seok_limu_method
        obj_name                = sub_name
      importing
        object_inactive_version = object_inactive_version
        object_is_work_item     = object_is_work_item.

    if object_inactive_version <> space or object_is_work_item <> space.
      version = smodi_c_state_inactive.
    else.
      version = smodi_c_state_active.
    endif.

    cl_wb_source_req_dispatcher=>get_object_from_sourcename(
     exporting
       p_source_name = include_name
     importing
       p_object_type = obj_type_eu
       p_object_name = obj_name_eu
     exceptions
       others        = 0 ).

    obj_name_for_dark_processing = obj_name_eu.

    create object dark_editor.
    dark_editor->modification_mode = 'X'.
    dark_editor->set_adt_mode( adt_mode = seox_true ).
    dark_editor->set_lifecycle_manager( lifecycle_manager = me->lifecycle_manager ).

    dark_editor->if_wb_dark_functionality~read(
      exporting
        im_type            = obj_type_eu
        im_name            = obj_name_for_dark_processing
        im_mode            = 'DISPLAY'
        im_no_visualize    = abap_true
        im_active          = version
        im_no_enhancements = abap_true   " as enhas are readed with other resource controler
      importing
        ex_source          = wb_source
        ex_editor          = wb_editor
      exceptions
        others             = 0 ).

  endmethod.


  method lif_persistence_modass~is_clif_modified_with_modass.
    data modinstance     type ref to cl_clm_tool_log.
    data p_entries_tab   type smodi_tool_log_tab.
    data version         type r3state.

    case object_type.
      when seok_r3tr_class.
        cl_oo_class_modifications=>is_modified_with_modass(
          exporting
            clskey = clif_key
          receiving
            result = result
          exceptions
            others = 1 ).
        if ( sy-subrc <> 0 ).
          result = seox_true.
        endif.
      when seok_r3tr_interface.
        cl_oo_interface_modifications=>is_modified_with_modass(
         exporting
           clskey = clif_key
         receiving
           result = result
         exceptions
           others = 1 ).
        if ( sy-subrc <> 0 ).
          result = seox_true.
        endif.
      when seok_limu_public or seok_limu_private or seok_limu_protected.
        if ( cl_oo_clif_modifications=>clif_or_component_in_upgrade( clskey = clif_key ) = seox_false ).
          if ( cl_wb_activation_db_api=>is_own_item( objtype_tr = object_type objname_tr = |{ clif_key-clsname }| ) = abap_true ).
            version = 'I'.
          else.
            version = 'A'.
          endif.
          modinstance ?= me->lif_persistence_modass~read_modificationinfo_4_sectn(
                          object_type = object_type
                          clif_key    = clif_key
                          version     = version ).
          modinstance->get_entries(
            importing
              p_entries_tab = p_entries_tab ).
          if p_entries_tab is not initial.
            result = seox_true.
          else.
            result = seox_false.
          endif.
        else.
          result = seox_true.
        endif.
      when others.
        result = seox_true.
    endcase.
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_interface.
    result = boolc( cl_oo_clif_modifications=>modification_support_disabled( clskey = interface_key ) = seox_false ).
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_class_def.
    " check whether modification assistant for public section is disabled. If this is the case
    " consider that modification assistant is disabled for the whole class
    result = boolc( cl_oo_clif_modifications=>modification_support_disabled( clskey = class_key limu = seok_limu_public ) = seox_false ).
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_method.
    data:
      class_key type seoclskey,
      sub_name  type eu_lname.

    class_key-clsname = method_key-clsname.
    sub_name(30)      = method_key-clsname.
    sub_name+30       = method_key-mtdname.
    result = boolc( cl_oo_clif_modifications=>modification_support_disabled( clskey = class_key limu = seok_limu_method sub_name = sub_name ) = seox_false ).
  endmethod.

  method lif_persistence_modass~check_modass_permissions.
    call function 'RS_CLM_SPECIAL_AUTHORITIES'
      exporting
        object                   = clif_key-clsname
        object_class             = object_type
      exceptions
        no_switch_off_permission = 1.
    if sy-subrc <> 0.
      cx_oo_access_permission=>raise_access_permission_except( msgid = sy-msgid msgno = sy-msgno ).
    endif.
  endmethod.

  method lif_persistence_modass~read_sap_version_4_interface.
    try.
        create object sap_version_interface exporting clskey = interface_key limu = seok_r3tr_interface.
      catch cx_class_not_existent.
        raise exception type cx_oo_source_save_failure.
    endtry.
  endmethod.

  method lif_persistence_modass~read_sap_versions_4_class_def.
    try.
        create object sap_version_public exporting clskey = class_key limu = seok_limu_public.
        create object sap_version_protected exporting clskey = class_key limu = seok_limu_protected.
        create object sap_version_private exporting clskey = class_key limu = seok_limu_private.
      catch cx_class_not_existent.
        raise exception type cx_oo_source_save_failure.
    endtry.
  endmethod.

  method lif_persistence_modass~disable_modass_4_interface.
    data:
      error_occurred type seox_boolean.

    call function 'SEO_CLIF_SAVE_ALL'
      exporting
        cifkey                       = interface_key
        disable_modification_support = seox_true
        lifecycle_manager            = me->lifecycle_manager
      importing
        error_occurred               = error_occurred
      changing
        corrnr                       = correction_number
      exceptions
        not_existing                 = 1
        nothing_to_do                = 2
        access_error                 = 3
        db_error                     = 4
        error_in_code_generation     = 5
        others                       = 6.
    if ( sy-subrc <> 0 or error_occurred = seox_true ).
      raise exception type cx_oo_source_save_failure.
    endif.

    " Store old original version of sections in SMODISRC
    sap_version_interface->save( ).

  endmethod.

  method lif_persistence_modass~disable_modass_4_class_def.
    data:
      error_occurred type seox_boolean.

    call function 'SEO_CLIF_SAVE_ALL'
      exporting
        cifkey                       = class_key
        disable_modification_support = seox_true
        lifecycle_manager            = me->lifecycle_manager
      importing
        error_occurred               = error_occurred
      changing
        corrnr                       = correction_number
      exceptions
        not_existing                 = 1
        nothing_to_do                = 2
        access_error                 = 3
        db_error                     = 4
        error_in_code_generation     = 5
        others                       = 6.
    if ( sy-subrc <> 0 or error_occurred = seox_true ).
      raise exception type cx_oo_source_save_failure.
    endif.
    " Store old original version of sections in SMODISRC
    sap_version_public->save( ).
    sap_version_protected->save( ).
    sap_version_private->save( ).
  endmethod.

  method lif_persistence_modass~disable_modass_4_method.
    data:
      class_key           type seoclskey,
      class_modifications type ref to cl_oo_class_modifications.

    class_key-clsname = method_key-clsname.
    try.
        create object class_modifications exporting clskey = class_key.
        class_modifications->turn_off_modass_for_meth(
            methkey         = method_key
            complete_source = original_source
            corrnr          = correction_number
        ).
        me->save_note_entries_in_smodisrc( method_key ).
      catch cx_class_not_existent.
        raise exception type cx_oo_source_save_failure.
    endtry.
  endmethod.

  method lif_persistence_modass~read_modificationinfo_4_method.
    data:
      sub_name type eu_lname.

    sub_name(30) = method_key-clsname.
    sub_name+30  = method_key-mtdname.
    create object result type cl_clm_tool_log
      exporting
        p_obj_type = seok_r3tr_class
        p_obj_name = |{ method_key-clsname }|
        p_sub_type = seok_limu_method
        p_sub_name = sub_name
        p_state    = smodi_c_state_inactive.

  endmethod.

  method lif_persistence_modass~read_modificationinfo_4_sectn.
    create object result type cl_clm_tool_log
      exporting
        p_obj_type = seok_r3tr_class
        p_obj_name = |{ clif_key-clsname }|
        p_sub_type = object_type
        p_sub_name = |{ clif_key-clsname }|
        p_state    = version.
  endmethod.

  method lif_persistence_modass~save_modificationinfo_4_method.
    data:
      smodilog_entries      type smodi_tool_log_tab,
      transport_key         type trkey,
      note_smodisrc_entries type standard table of smodisrc.

    data dark_editor type ref to cl_wb_cleditor_services.
    data: wb_source     type ref to cl_wb_source,
          wb_editor     type ref to cl_wb_editor,
          lt_source_old type rswsourcet,
          lt_source_new type rswsourcet,
          lt_mod_tab    type smodi_mod_tab,
          lt_korr_tab   type trkorrs,
          result        type abap_bool value abap_false,
          obj_util      type ref to if_sedi_adt_modifications_util.

    field-symbols <l_mod> like line of lt_mod_tab.

    if smodi_transfer_only = seox_false.
      " code bellow allows to save correctly also code within modification brackets
      me->get_dark_editor_information(
          exporting
            method_key   = method_key
            include_name = include_name
          importing
            dark_editor  = dark_editor
            wb_source    = wb_source
            wb_editor    = wb_editor ).

      check wb_editor is bound and wb_source is bound.

      if wb_source->l_extend_mod = abap_true.
*       check that SAP Original Code is not changed
        wb_source->get_source_tab( importing source = lt_source_old ).
        wb_source->get_modification_inf(
          importing
            p_mod_tab      = lt_mod_tab  ).
        loop at lt_mod_tab assigning <l_mod>.
          loop at <l_mod>-inf[] assigning field-symbol(<inf>).
            append <inf>-korrnum to lt_korr_tab.
          endloop.
        endloop.
        sort lt_korr_tab.
        delete adjacent duplicates from lt_korr_tab.

        obj_util = cl_sedi_adt_modifications_util=>create_instance( ).
        lt_source_new = source.
        obj_util->is_valid_source_modification(
          exporting
            source_old = lt_source_old
            source_new = lt_source_new
            trkorrs    = lt_korr_tab
          receiving
            result     = result ).
        if result = abap_false.
          " SAP original source differs!! DO NOT SAVE !!
          raise exception type cx_oo_source_save_failure
            exporting
              textid = cx_oo_source_save_failure=>forbidden_modifications.
        endif.
      endif.

      wb_editor->set_mode(
           exporting
               mode         = 'EDIT'
               no_lineindex = 'X' ).

      wb_source->set_source_tab( source = source  ).

      dark_editor->if_wb_dark_functionality~set(
          exporting
            im_source        = wb_source
            im_editor        = wb_editor
          exceptions
            action_cancelled = 1
            others           = 2   ).                     "#EC CI_SUBRC

      dark_editor->save_method_source( ).

      wb_source->get_source_tab(
        importing
          source = source     ).
    else.
      modification_info->get_entries( importing p_entries_tab = smodilog_entries ).
      modification_info->delete_entries( p_entries_tab = smodilog_entries ).
      modification_info->insert_entries( p_entries_tab = smodilog_entries ).
      modification_info->save( p_state = smodi_c_state_inactive p_trkorr = correction_number ).
      me->save_note_entries_in_smodisrc( method_key ).
    endif.
  endmethod.


  method save_note_entries_in_smodisrc.
    types:
      ty_note_smodisrc_entries type standard table of smodisrc with default key.

    data transport_key type trkey.
    data note_smodisrc_entries type ty_note_smodisrc_entries.

    " save the CI entries in SMODISRC that have been written by note assistant
    transport_key-obj_type     = seok_r3tr_class.
    transport_key-obj_name     = method_key-clsname.
    transport_key-sub_type     = seok_limu_method.
    transport_key-sub_name(30) = method_key-clsname.
    transport_key-sub_name+30  = method_key-mtdname.

    delete from smodisrci
      where  relid        = 'CI'
        and  obj_type     = transport_key-obj_type
        and  obj_name     = transport_key-obj_name
        and  sub_type     = transport_key-sub_type
        and  sub_name     = transport_key-sub_name
        and  operation    = 'NOTE'.
    select * into table note_smodisrc_entries from smodisrc
      where  relid        = 'CI'
        and  obj_type     = transport_key-obj_type
        and  obj_name     = transport_key-obj_name
        and  sub_type     = transport_key-sub_type
        and  sub_name     = transport_key-sub_name
        and  operation    = 'NOTE'.
    if sy-subrc = 0.
      insert smodisrci from table note_smodisrc_entries.
    endif.

  endmethod.

endclass.


*----------------------------------------------------------------------*
*       CLASS lcl_persistence_lifecycle DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_lifecycle definition.
  public section.
    interfaces:
      lif_persistence_lifecycle.
    class-methods:
      get_instance
        importing
          lifecycle_manager  type ref to if_adt_lifecycle_manager optional
          settings           type ref to if_oo_clif_source_settings
          modass_persistence type ref to lif_persistence_modass
        returning
          value(instance)    type ref to lcl_persistence_lifecycle.
  private section.
    data:
      lifecycle_manager  type ref to if_adt_lifecycle_manager,
      settings           type ref to if_oo_clif_source_settings,
      modass_persistence type ref to lif_persistence_modass.
    methods:
      is_db_procedure_proxy_intf
        importing
          clif_type          type seoclstype
          interface_category type seocategry
        returning
          value(result)      type seox_boolean.
endclass.                    "lcl_persistence_lifecycle DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_persistence_lifecycle IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_lifecycle implementation.

  method get_instance.
    create object instance.
    instance->lifecycle_manager  = lifecycle_manager.
    instance->settings           = settings.
    instance->modass_persistence = modass_persistence.
  endmethod.                    "get_instance

  method lif_persistence_lifecycle~insert_into_working_area.
    call function 'RS_INSERT_INTO_WORKING_AREA'
      exporting
        object   = object_type
        obj_name = object_name.
  endmethod.                    "lif_persistence_lifecycle~insert_into_working_area

  method lif_persistence_lifecycle~access_permission.
    constants co_really_suppress_all_dialogs type c length 1 value 'D' ##NO_TEXT.
    data:
      frozen                        type seox_boolean,
      frozen_objects                type tpchk_frozen_objects,
      extend                        type seox_boolean,
      class_data                    type vseoclass,
      interface_data                type vseointerf,
      suppress_dialog               type c length 1,
      exception                     type ref to cx_oo_access_permission,
      clif_type                     type seoclstype,
      suppress_modification_support type seox_boolean,
      limu_object_type              type trobjtype.


    " check if class / interface is a proxy object -> if yes, then class/interface cannot be edited
    if ( access_mode = seok_access_modify ).
      call function 'SEO_CLIF_GET'
        exporting
          cifkey       = clif_key
          version      = seoc_version_inactive
          state        = seoc_state_implemented
        importing
          clstype      = clif_type
          class        = class_data
          interface    = interface_data
        exceptions
          not_existing = 1
          deleted      = 2
          model_only   = 3
          others       = 4.
      if sy-subrc <> 0.
        cx_oo_access_permission=>raise_access_permission_except( msgid = sy-msgid msgno = sy-msgno msgv1 = sy-msgv1 msgv2 = sy-msgv2 msgv3 = sy-msgv3 msgv4 = sy-msgv4 ).
      endif.
      if class_data-clsproxy = abap_true or interface_data-clsproxy = abap_true.
        cx_oo_access_permission=>raise_access_permission_except( msgid = 'OO' msgno = 631 ).
      endif.
    endif.

    if ( settings->is_ui_enabled( ) = seox_false ).
      suppress_dialog = co_really_suppress_all_dialogs.
    else.
      suppress_dialog = seox_false.
    endif.

    if ( settings->is_generator_mode_enabled( ) ).
      suppress_modification_support = seox_true.
    endif.

    if ( object_type <> seok_r3tr_class and object_type <> seok_r3tr_interface ).
      limu_object_type = object_type.
    endif.

    if object_type = seok_r3tr_interface.
      clif_type = seoc_clstype_interface.
    endif.

    call function 'SEO_CLIF_ACCESS_PERMISSION'
      exporting
        cifkey                        = clif_key
        cpdname                       = method_name
        limu                          = limu_object_type
        mode                          = access_mode
        clstype                       = clif_type
        authority_check               = authority_check
        suppress_langu_check          = seox_true
        suppress_language_dialog      = seox_true
        suppress_dialog               = suppress_dialog
        suppress_modification_support = suppress_modification_support
        lock_handle                   = lock_handle
      importing
        frozen                        = frozen
        frozen_objects                = frozen_objects
        extend                        = extend
      exceptions
        no_access                     = 2
        others                        = 3.
    if ( sy-subrc <> 0 ).
      cx_oo_access_permission=>raise_access_permission_except( msgid = sy-msgid msgno = sy-msgno msgv1 = sy-msgv1 msgv2 = sy-msgv2 msgv3 = sy-msgv3 msgv4 = sy-msgv4 ).
    elseif ( access_mode = seok_access_modify ).
      " if the class shall be edited, it may not be frozen or it may not be in modification assistance mode
      if ( frozen <> seox_false ).
        call function 'SEO_CLIF_ACCESS_PERMISSION'
          exporting
            cifkey  = clif_key
            cpdname = method_name
            limu    = object_type
            mode    = seok_access_free.
        cx_oo_access_permission=>raise_access_permission_except( msgid = 'OO' msgno = 665 ).
      elseif ( ( extend = seox_true ) and
               ( suppress_modification_support = seox_false ) and
               ( me->is_db_procedure_proxy_intf( clif_type = clif_type interface_category = interface_data-category ) = seox_false ) ).
        if ( ( me->settings->is_modification_mode_allowed( ) = seox_false ) or
             ( clif_type = seoc_clstype_interface and me->modass_persistence->is_clif_modified_with_modass( object_type = object_type clif_key = clif_key ) = seox_true  ) ).
          call function 'SEO_CLIF_ACCESS_PERMISSION'
            exporting
              cifkey  = clif_key
              cpdname = method_name
              limu    = object_type
              mode    = seok_access_free.
          cx_oo_access_permission=>raise_access_permission_except( msgid = 'OO' msgno = 663 ).
        endif.
        try.
            me->modass_persistence->check_modass_permissions( object_type = object_type clif_key = clif_key ).
            modification_mode_enabled = extend.
          catch cx_oo_access_permission into exception.
            call function 'SEO_CLIF_ACCESS_PERMISSION'
              exporting
                cifkey  = clif_key
                cpdname = method_name
                limu    = object_type
                mode    = seok_access_free.
            raise exception exception.
        endtry.
      endif.
    endif.
  endmethod.

  method is_db_procedure_proxy_intf.
    if ( ( clif_type = seoc_clstype_interface ) and ( interface_category = seoc_category_db_proc_types ) ).
      result = seox_true.
    else.
      result = seox_false.
    endif.
  endmethod.

  method lif_persistence_lifecycle~corr_insert.
    data: trstatus type trstatus.
    data: textid type scx_t100key.
    data: suppress_dialog type seox_boolean.

    constants co_modifiable type trstatus value 'D'.

*   check if correction_number is still valid and object contained in given transport request
    if correction_number is not initial.
      select single trstatus into trstatus from  e070 "#EC - number is not used in the table
         where  trkorr    = correction_number.
      if trstatus <> co_modifiable.
        " transport not modifiable; reset correction number and recalculate a new one
        clear correction_number.
      endif.
    endif.

*   ec: correction_number empty, than clear suppress_dialog in order to enter a tr.request
    if correction_number is initial.
      suppress_dialog   = seox_false.
    else.
      suppress_dialog   = seox_true.
    endif.
    call function 'SEO_CLIF_CORR_INSERT'
      exporting
        cifkey            = clif_key
        cpdname           = method_name
        limu              = object_type
        suppress_dialog   = suppress_dialog
        lifecycle_manager = me->lifecycle_manager
      changing
        corrnr            = correction_number
        devclass          = package
      exceptions
        not_existing      = 1
        no_access         = 2
        unknown_trkey     = 3
        cancelled         = 4
        others            = 5.
    if ( sy-subrc <> 0 ).
      if sy-subrc = 4 and ( sy-msgid is not initial and sy-msgno is not initial ).
        textid-msgid = sy-msgid.
        textid-msgno = sy-msgno.
        textid-attr1 = 'MESSAGE_VARIABLE_1'.
        textid-attr2 = 'MESSAGE_VARIABLE_2'.
        textid-attr3 = 'MESSAGE_VARIABLE_3'.
        textid-attr4 = 'MESSAGE_VARIABLE_4'.
        raise exception type cx_oo_source_save_failure
          exporting
            textid             = textid
            message_variable_1 = sy-msgv1
            message_variable_2 = sy-msgv2
            message_variable_3 = sy-msgv3
            message_variable_4 = sy-msgv4.
      else.
        raise exception type cx_oo_source_save_failure.
      endif.
    else.
      " ec: error situation: a new tr.request was generated => take this one for further save actions
      if me->lifecycle_manager is bound and me->lifecycle_manager is instance of cl_adt_corr_insert_dark and
         correction_number is not initial and me->lifecycle_manager->corrnr is initial.
        me->lifecycle_manager->corrnr = correction_number.
      endif.
    endif.
  endmethod.                     "lif_persistence_lifecycle~corr_insert

  method lif_persistence_lifecycle~get_inactive_objects.
    call function 'RS_GET_INACTIVE_OBJECTS'
      tables
        objectlist = object_list.
  endmethod.                    "lif_persistence_lifecycle~get_inactive_objects


endclass.                    "lcl_persistence_lifecycle IMPLEMENTATION


class lcl_persistence_facade definition.
  public section.
    interfaces:
      lif_persistence_facade.
    class-methods:
      get_instance
        importing
          lifecycle_manager    type ref to if_adt_lifecycle_manager
          settings             type ref to if_oo_clif_source_settings
          source_persistence   type ref to if_oo_clif_persistence_source
          metadata_persistence type ref to if_oo_clif_persist_meta_data
        returning
          value(instance)      type ref to lcl_persistence_facade.

    methods:
      get_lifecycle_manager
        returning
          value(result) type ref to  if_adt_lifecycle_manager.
  protected section.
    data:
      source_persistence    type ref to if_oo_clif_persistence_source,
      meta_data_persistence type ref to if_oo_clif_persist_meta_data,
      lifecycle_persistence type ref to lif_persistence_lifecycle,
      modass_persistence    type ref to lif_persistence_modass.
  private section.
    data:
      lifecycle_manager     type ref to if_adt_lifecycle_manager.
    methods:
      init
        importing
          lifecycle_manager    type ref to if_adt_lifecycle_manager
          settings             type ref to if_oo_clif_source_settings
          source_persistence   type ref to if_oo_clif_persistence_source
          metadata_persistence type ref to if_oo_clif_persist_meta_data .

endclass.                    "lcl_persistence_facade DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_persistence_facade IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_persistence_facade implementation.

  method get_instance.
    create object instance.
    instance->init(
        lifecycle_manager    = lifecycle_manager
        settings             = settings
        source_persistence   = source_persistence
        metadata_persistence = metadata_persistence ).
  endmethod.                    "get_instance

  method init.
    if source_persistence is initial.
      me->source_persistence    = lcl_persistence_source=>get_instance( ).
    else.
      me->source_persistence = source_persistence.
    endif.
    if metadata_persistence is initial.
      me->meta_data_persistence = lcl_persistence_meta_data=>get_instance( lifecycle_manager ).
    else.
      me->meta_data_persistence = metadata_persistence.
    endif.
    me->modass_persistence = lcl_persistence_modass=>get_instance( lifecycle_manager = lifecycle_manager ).
    me->lifecycle_persistence = lcl_persistence_lifecycle=>get_instance( lifecycle_manager = lifecycle_manager settings = settings modass_persistence = modass_persistence ).
    me->lifecycle_manager = lifecycle_manager.
  endmethod.                    "init

  method get_lifecycle_manager.
    result = me->lifecycle_manager.
  endmethod.                    "get_lifecycle_manager

  method if_oo_clif_persistence_source~read_report.
    me->source_persistence->read_report(
      exporting
        include_name = include_name
        state        = state
      importing
        source       = source
    ).
  endmethod.                    "lif_persistence_source~read_report

  method if_oo_clif_persistence_source~insert_report.
    me->source_persistence->insert_report(
        include_name   = include_name
        state          = state
        source         = source
        program_type   = program_type
        extension_type = extension_type
    ).
  endmethod.                    "lif_persistence_source~insert_report

  method if_oo_clif_persistence_source~delete_report.
    me->source_persistence->delete_report(
        include_name   = include_name
        state          = state
    ).
  endmethod.                    "lif_persistence_source~delete_report


  method if_oo_clif_persistence_source~read_progdir.
    progdir = me->source_persistence->read_progdir( include_name = include_name state = state ).
  endmethod.                    "lif_persistence_source~read_progdir

  method if_oo_clif_persistence_source~update_progdir.
    me->source_persistence->update_progdir(
        include_name = include_name
        state        = state
        progdir      = progdir
    ).
  endmethod.                    "lif_persistence_source~update_progdir

  method if_oo_clif_persistence_source~read_timestamp_for_include.
    result = me->source_persistence->read_timestamp_for_include( include_name = include_name state = state ).
  endmethod.                    "lif_persistence_source~read_timestamp_for_include

  method if_oo_clif_persistence_source~read_timestamp_for_class.
    result = me->source_persistence->read_timestamp_for_class( class_name = class_name state = state ).
  endmethod.                    "lif_persistence_source~read_timestamp_for_class

  method if_oo_clif_persistence_source~lock_cs_include.
    result = me->source_persistence->lock_cs_include( class_name = class_name ).
  endmethod.                    "lif_persistence_source~lock_cs_include

  method if_oo_clif_persistence_source~unlock_cs_include.
    me->source_persistence->unlock_cs_include( class_name = class_name ).
  endmethod.                    "lif_persistence_source~unlock_cs_include

  method if_oo_clif_persistence_source~reset_generation_flag_in_tmdir.
    me->source_persistence->reset_generation_flag_in_tmdir(
        clif_key          = clif_key
        lifecycle_manager = lifecycle_manager ).
  endmethod.                    "lif_persistence_source~set_constructor_generation

  method if_oo_clif_persistence_source~add_suppress_generation_pragma.
    me->source_persistence->add_suppress_generation_pragma(
      exporting
        clif_key = clif_key
      changing
        source   = source
    ).
  endmethod.

  method if_oo_clif_persistence_source~del_suppress_generation_pragma.
    me->source_persistence->del_suppress_generation_pragma(
      exporting
        clif_key = clif_key
      importing
        adjustment_was_executed = adjustment_was_executed
      changing
        source   = source
    ).
  endmethod.

  method if_oo_clif_persistence_source~has_class_inactive_source_part.
    result = me->source_persistence->has_class_inactive_source_part( class_key = class_key ).
  endmethod.

  method if_oo_clif_persistence_source~read_no_of_method_includes.
    result = me->source_persistence->read_no_of_method_includes( class_name = class_name ).
  endmethod.

  method if_oo_clif_persistence_source~write_no_of_method_includes.
    source_persistence->write_no_of_method_includes( class_name = class_name no_of_method_includes = no_of_method_includes ).
  endmethod.

  method if_oo_clif_persist_meta_data~get_method_include.
    include_name = me->meta_data_persistence->get_method_include( method_key = method_key ).
  endmethod.                    "lif_persistence_meta_data~get_method_include

  method if_oo_clif_persist_meta_data~update_class_section_meta_data.
    me->meta_data_persistence->update_class_section_meta_data( class_key = class_key exposure = exposure version = version source = source amdp_support_enabled = amdp_support_enabled ).
  endmethod.                    "lif_persistence_meta_data~update_class_section_meta_data

  method if_oo_clif_persist_meta_data~update_intf_section_meta_data.
    me->meta_data_persistence->update_intf_section_meta_data( interface_key = interface_key version = version source = source amdp_support_enabled = amdp_support_enabled ).
  endmethod.                    "lif_persistence_meta_data~update_intf_section_meta_data

  method if_oo_clif_persist_meta_data~delete_method_include.
    me->meta_data_persistence->delete_method_include( exporting method_key = method_key version = version changing correction_number = correction_number ).
  endmethod.                    "lif_persistence_meta_data~delete_method_include

  method if_oo_clif_persist_meta_data~generate_method_include.
    me->meta_data_persistence->generate_method_include( method_key = method_key version = version modification_mode_enabled = modification_mode_enabled ).
  endmethod.                    "lif_persistence_meta_data~generate_method_include

  method if_oo_clif_persist_meta_data~get_all_method_includes.
    method_includes = me->meta_data_persistence->get_all_method_includes( class_name ).
  endmethod.                    "lif_persistence_meta_data~get_all_method_includes

  method if_oo_clif_persist_meta_data~keep_method_order.
    result = me->meta_data_persistence->keep_method_order( class_name ).
  endmethod.

  method if_oo_clif_persist_meta_data~get_clif_type.
    clif_type = me->meta_data_persistence->get_clif_type( clif_key = clif_key ).
  endmethod.                    "lif_persistence_meta_data~get_clif_type

  method if_oo_clif_persist_meta_data~get_class_typeinfo.
    me->meta_data_persistence->get_class_typeinfo(
      exporting
        class_key         = class_key
      importing
        methods           = methods
        parameters        = parameters
        excepts           = excepts
        inheritance       = inheritance
        implementings     = implementings
    ).
  endmethod.                    "lif_persistence_meta_data~get_class_typeinfo

  method if_oo_clif_persist_meta_data~class_all_implementg_get.

    result =  me->meta_data_persistence->class_all_implementg_get( class_key  =  class_key  ).
  endmethod.

  method if_oo_clif_persist_meta_data~interface_all_compri_get.

    result =  me->meta_data_persistence->interface_all_compri_get( intkey = intkey ).
  endmethod.

  method if_oo_clif_persist_meta_data~get_interface_typeinfo.
    me->meta_data_persistence->get_interface_typeinfo(
      exporting
        interface_key     = interface_key
      importing
        methods           = methods
        parameters        = parameters
        excepts           = excepts
        comprisings       = comprisings
    ).
  endmethod.                    "lif_persistence_meta_data~get_interface_typeinfo

  method if_oo_clif_persist_meta_data~get_method_data.
    method_data = me->meta_data_persistence->get_method_data( method_key ).
  endmethod.                    "lif_persistence_meta_data~get_method_data

  method if_oo_clif_persist_meta_data~is_exception_class.
    result = me->meta_data_persistence->is_exception_class( clif_key ).
  endmethod.                    "lif_persistence_meta_data~is_exception_class

  method lif_persistence_lifecycle~insert_into_working_area.
    me->lifecycle_persistence->insert_into_working_area( object_type = object_type object_name = object_name ).
  endmethod.                    "lif_persistence_lifecycle~insert_into_working_area

  method lif_persistence_lifecycle~access_permission.
    me->lifecycle_persistence->access_permission(
      exporting
        object_type               = object_type
        clif_key                  = clif_key
        method_name               = method_name
        access_mode               = access_mode
        lock_handle               = lock_handle
        authority_check = authority_check
      importing
        modification_mode_enabled = modification_mode_enabled
    ).
  endmethod.                    "lif_persistence_lifecycle~access_permission

  method lif_persistence_lifecycle~corr_insert.
    me->lifecycle_persistence->corr_insert(
      exporting
        object_type       = object_type
        clif_key          = clif_key
        method_name       = method_name
      changing
        correction_number = correction_number
        package           = package
    ).
  endmethod.                    "lif_persistence_lifecycle~corr_insert

  method lif_persistence_lifecycle~get_inactive_objects.
    me->lifecycle_persistence->get_inactive_objects( changing object_list = object_list ).
  endmethod.                    "lif_persistence_lifecycle~get_inactive_objects

  method lif_persistence_modass~is_clif_modified_with_modass.
    me->modass_persistence->is_clif_modified_with_modass( exporting
                                                            object_type = object_type  clif_key = clif_key
                                                          receiving
                                                            result = result ).
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_interface.
    result = me->modass_persistence->is_modass_enabled_4_interface( interface_key ).
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_class_def.
    result = me->modass_persistence->is_modass_enabled_4_class_def( class_key ).
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_method.
    result = me->modass_persistence->is_modass_enabled_4_method( method_key ).
  endmethod.

  method lif_persistence_modass~check_modass_permissions.
    me->modass_persistence->check_modass_permissions( object_type = object_type  clif_key = clif_key ).
  endmethod.

  method lif_persistence_modass~read_sap_version_4_interface.
    me->modass_persistence->read_sap_version_4_interface(
      exporting
        interface_key             = interface_key
      importing
        sap_version_interface     = sap_version_interface
    ).
  endmethod.

  method lif_persistence_modass~read_sap_versions_4_class_def.
    me->modass_persistence->read_sap_versions_4_class_def(
      exporting
        class_key                 = class_key
      importing
        sap_version_public        = sap_version_public
        sap_version_protected     = sap_version_protected
        sap_version_private       = sap_version_private
    ).
  endmethod.

  method lif_persistence_modass~disable_modass_4_interface.
    me->modass_persistence->disable_modass_4_interface(
      exporting
        interface_key             = interface_key
        correction_number         = correction_number
        sap_version_interface     = sap_version_interface
    ).
  endmethod.

  method lif_persistence_modass~disable_modass_4_class_def.
    me->modass_persistence->disable_modass_4_class_def(
        class_key                 = class_key
        correction_number         = correction_number
        sap_version_public        = sap_version_public
        sap_version_protected     = sap_version_protected
        sap_version_private       = sap_version_private
    ).
  endmethod.

  method lif_persistence_modass~disable_modass_4_method.
    me->modass_persistence->disable_modass_4_method( method_key = method_key original_source = original_source correction_number = correction_number ).
  endmethod.

  method lif_persistence_modass~read_modificationinfo_4_method.
    result = me->modass_persistence->read_modificationinfo_4_method( method_key = method_key ).
  endmethod.

  method lif_persistence_modass~read_modificationinfo_4_sectn.
    result = me->modass_persistence->read_modificationinfo_4_sectn(
               object_type = object_type
               clif_key    = clif_key
               version     = version  ).
  endmethod.

  method lif_persistence_modass~save_modificationinfo_4_method.
    me->modass_persistence->save_modificationinfo_4_method(
      exporting
        method_key          = method_key
        include_name        = include_name
        modification_info   = modification_info
        correction_number   = correction_number
        smodi_transfer_only = smodi_transfer_only
      changing
        source              = source
         ).
  endmethod.

endclass.                    "lcl_persistence_facade IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_source_part_list IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_source_part_list implementation.

  method lif_source_part~get_source.
    data:
      source_part_list type type_source_part_list.
    field-symbols:
      <source_part> type type_source_part.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>
        using key order.
      append lines of <source_part>-source_part->get_source( ) to source_table.
    endloop.
  endmethod.                    "if_source_part~get_source

  method lif_source_part~read.
    data:
      source_part_list type type_source_part_list.
    field-symbols:
      <source_part> type type_source_part.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>.
      <source_part>-source_part->read( version = version ).
    endloop.
  endmethod.                    "if_source_part~read

  method lif_source_part~get_line_index.
    data:
      line             type i value 0,
      source_part_list type type_source_part_list.
    field-symbols:
      <source_part>      type type_source_part,
      <line_index_entry> type edlineindx.

    source_part_list = me->get_source_part_list( ).
    loop at source_part_list
        assigning <source_part>
        using key order.
      append lines of <source_part>-source_part->get_line_index( ) to line_index.
    endloop.
*   Update the overall index of the new assembled line index
    loop at line_index
        assigning <line_index_entry>.
      line = line + 1.
      <line_index_entry>-index = line.
    endloop.
  endmethod.                    "lif_source_part~get_line_index

  method add_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part,
      source_part_entry    type type_source_part.

    source_part_entry-id    = get_free_source_part_entry_id( ).
    source_part_entry-source_part = source_part.
    source_part_entry-order = lines( me->source_part_list ).
    insert source_part_entry into table me->source_part_list.
    try.
        editable_source_part ?= source_part.
        set handler me->handle_source_part_deleted
            for editable_source_part.
      catch cx_sy_move_cast_error.                      "#EC NO_HANDLER
    endtry.
  endmethod.                    "add_source_part

  method get_id_by_source_part.
    field-symbols:
      <source_part_entry> type type_source_part.

    read table me->source_part_list
        with key source_part = source_part
        assigning <source_part_entry>.
    if ( sy-subrc <> 0 ).
      raise exception type lcx_source_part_unknown.
    endif.
    id = <source_part_entry>-id.
  endmethod.                    "get_id_by_source_part

  method get_source_part.
    field-symbols:
      <source_part_entry> type type_source_part.

    read table me->source_part_list
        with table key id = id
        assigning <source_part_entry>.
    if ( sy-subrc <> 0 ).
      raise exception type lcx_source_part_unknown.
    endif.
    source_part = <source_part_entry>-source_part.
  endmethod.                    "get_source_part

  method remove_source_part.
    data:
      editable_source_part type ref to lif_editable_source_part.

    try.
        editable_source_part ?= source_part.
        set handler me->handle_source_part_deleted
            for editable_source_part activation seox_false.
      catch cx_sy_move_cast_error.                      "#EC NO_HANDLER
    endtry.
    delete me->source_part_list
        where source_part = source_part.
  endmethod.                    "remove_source_part

  method get_source_part_list.
    if ( me->source_parts_initilzed = seox_false ).
      me->init_source_part_list( ).
      me->source_parts_initilzed = seox_true.
    endif.
    source_part_list = me->source_part_list.
  endmethod.                    "get_source_part_list

  method handle_source_part_deleted.
    me->remove_source_part( source_part ).
  endmethod.                    "handle_source_part_deleted

  method get_free_source_part_entry_id.
    id = lines( me->source_part_list ).
    do.
      read table me->source_part_list
          with table key id = id
          transporting no fields.
      if ( sy-subrc <> 0 ).
        return.
      endif.
      id = id + 1.
    enddo.
  endmethod.                    "get_free_source_part_entry_id

  method set_source_part_order.
    field-symbols:
      <source_part>             type type_source_part.

    read table me->source_part_list
        with table key id = id
        assigning <source_part>.
    <source_part>-order = order.
  endmethod.                    "set_source_part_order

  method reset_source_part_list.
    clear me->source_part_list.
    me->source_parts_initilzed = seox_false.
  endmethod.

endclass.                    "lcl_source_part_list IMPLEMENTATION





*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_SOURCE_PART
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_source_part implementation.

  method create_from_source.
    create object source_part.
    source_part->init( persistence = persistence settings = settings ).
    source_part->source = source.
  endmethod.                    "create_from_source

  method lif_source_part~read.
    data:
      plugins     type lif_source_part_plug=>type_plugin_table.
    field-symbols:
      <plugin> type ref to lif_source_part_plugin.

    clear me->source.
*   Delegate the read to the plugins!
    append lines of me->pre_plug->lif_source_part_plug~get_plugins( )  to plugins.
    append lines of me->post_plug->lif_source_part_plug~get_plugins( ) to plugins.
    loop at plugins
        assigning <plugin>.
      <plugin>->lif_source_part~read( version = version ).
    endloop.
  endmethod.                    "lif_source_part~read

  method lif_source_part~get_source.
    data:
      plugins     type lif_source_part_plug=>type_plugin_table.
    field-symbols:
      <plugin> type ref to lif_source_part_plugin.

*   Add pre plugins
    plugins = me->pre_plug->lif_source_part_plug~get_plugins( ).
    loop at plugins
        assigning <plugin>.
      append lines of <plugin>->lif_source_part~get_source( ) to source_table.
    endloop.
*   Add main source
    append lines of me->source to source_table.
*   Add post plugins
    plugins = me->post_plug->lif_source_part_plug~get_plugins( ).
    loop at plugins
        assigning <plugin>.
      append lines of <plugin>->lif_source_part~get_source( ) to source_table.
    endloop.
  endmethod.                    "lif_source_part~get_source


  method lif_source_part~get_line_index.
    data:
      plugin_line_index type sedi_lindex,
      line_index_entry  type edlineindx,
      source_lines      type i,
      line              type i value 0,
      plugins           type lif_source_part_plug=>type_plugin_table,
      plugin            type ref to lif_source_part_plugin.
    field-symbols:
      <line_index_entry> type edlineindx.


*   Add pre plugins' line index
    plugins = me->pre_plug->lif_source_part_plug~get_plugins( ).
    loop at plugins
        into plugin.
      append lines of plugin->lif_source_part~get_line_index( ) to line_index.
    endloop.
*   Add own line index
    source_lines = lines( me->source ).
    do source_lines times.
      clear line_index_entry.
      line_index_entry-noedit_flg = seox_true.
      append line_index_entry to line_index.
    enddo.
*   Add post plugins' line index
    plugins = me->post_plug->lif_source_part_plug~get_plugins( ).
    loop at plugins
        into plugin.
      append lines of plugin->lif_source_part~get_line_index( ) to line_index.
    endloop.
*   Set the lines for the whole source.
    loop at line_index
        assigning <line_index_entry>.
      line = line + 1.
      <line_index_entry>-index = line.
    endloop.
  endmethod.                    "lif_source_part~get_line_index

endclass.               "LCL_SOURCE_PART


*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_SOURCE_PART_PLUG
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_source_part_plug implementation.

  method create_plug.
    create object plug.
    plug->source_part = source_part.
  endmethod.                    "create_plug

  method lif_source_part_plug~add_plugin.
    append plugin to me->plugins.
  endmethod.                    "lif_source_part_plug~add_plugin

  method lif_source_part_plug~get_plugins.
    plugins = me->plugins.
  endmethod.                    "lif_source_part_plug~get_plugins

  method lif_source_part_plug~get_source_part.
    source_part = me->source_part.
  endmethod.                    "lif_source_part_plug~get_source_part

endclass.               "LCL_SOURCE_PART_PLUG

*&---------------------------------------------------------------------*
*&       Class (Implementation)  LCL_ABSTRACT_SOURCE_PART
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
class lcl_abstract_source_part implementation.

  method lif_source_part_plugin~get_plug.
    plug = me->plug.
  endmethod.                    "lif_source_part_plugin~get_plug

  method lif_source_part_plugin~set_plug.
    me->plug = plug.
  endmethod.                    "lif_Source_part_plugin~set_plug

  method init.
    me->persistence = persistence.
    me->settings    = settings.
    me->pre_plug    = lcl_source_part_plug=>create_plug( me ).
    me->post_plug   = lcl_source_part_plug=>create_plug( me ).
  endmethod.                    "init

  method lif_source_part~get_pre_plug.
    pre_plug = me->pre_plug.
  endmethod.                    "lif_source_part~get_pre_plug

  method lif_source_part~get_post_plug.
    post_plug = me->post_plug.
  endmethod.                    "lif_source_part~get_post_plug

endclass.               "LCL_ABSTRACT_SOURCE_PART