define append_to.
  append &2 to &1.
end-of-definition.

class ltcl_pp_settings_stub definition for testing.
  public section.
    interfaces if_pretty_printer_settings.
    class-methods:
      create_instance
        returning
          value(result) type ref to ltcl_pp_settings_stub.
endclass.

class ltcl_pp_settings_stub implementation.

  method create_instance.
    create object result.
  endmethod.

  method if_pretty_printer_settings~get_indent_mode.
    indent_mode = if_pretty_printer_settings=>co_indent.
  endmethod.

  method if_pretty_printer_settings~get_line_length.
    length = swbse_c_max_line_width.
  endmethod.

  method if_pretty_printer_settings~get_case_mode.
    case_mode = if_pretty_printer_settings=>co_case_mode_lower.
  endmethod.

  method if_pretty_printer_settings~get_source_type.
    source_type = 'ABAP'.
  endmethod.

endclass.


*----------------------------------------------------------------------*
*       class ltcl_source_template_01 definition
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_source_template definition for testing risk level harmless duration short.
  public section.
    types:
      ty_clif_list type standard table of seoclsname with default key.
    types:
      begin of ty_source_info_entry,
        include_name type progname,
        method_name  type seocpdname,
        line_from    type i,
        line_to      type i,
        timestamp    type xsddatetime_z,
        exposure     type seoexpose,
      end of ty_source_info_entry.
    data:
      class_key                type seoclskey,
      super_class_name         type seoclsname,
      implemented_interfaces   type ty_clif_list,
      source                   type seop_source_string,
      source_info              type hashed table of ty_source_info_entry with unique key include_name,
      no_of_method_impls_in_cs type i.
    methods:
      add_method_source_info
        importing
          class_name  type seoclsname
          method_name type seocpdname
          line_from   type i
          line_to     type i
          timestamp   type xsddatetime_z
          exposure    type seoexpose,
      add_section_source_info
        importing
          class_name type seoclsname
          exposure   type seoexpose
          line_from  type i
          line_to    type i
          timestamp  type xsddatetime_z,
      add_interface_source_info
        importing
          interface_name type seoclsname
          line_from      type i
          line_to        type i
          timestamp      type xsddatetime_z,
      add_cs_source_info
        importing
          class_name               type seoclsname
          timestamp                type xsddatetime_z
          no_of_method_impls_in_cs type i.
  private section.
    methods:
      add_source_info
        importing
          include_name type progname
          method_name  type seocpdname optional
          line_from    type i
          line_to      type i
          timestamp    type xsddatetime_z
          exposure     type seoexpose optional.
endclass.                    "ltcl_source_template_01 definition



class ltcl_pos_index_helper definition final for testing
  duration short
  risk level harmless.

  public section.
    interfaces if_oo_source_pos_index_helper.
  private section.
endclass.


class ltcl_pos_index_helper implementation.
  method if_oo_source_pos_index_helper~get_class_include_by_position.
  endmethod.

  method if_oo_source_pos_index_helper~get_position_by_component.
  endmethod.

  method if_oo_source_pos_index_helper~get_method_impl_ident_pos.
  endmethod.

  method if_oo_source_pos_index_helper~create_index.
  endmethod.

  method if_oo_source_pos_index_helper~create_index_with_scanner.
  endmethod.

  method if_oo_source_pos_index_helper~create_temp_index_with_scanner.
  endmethod.

  method if_oo_source_pos_index_helper~delete_index.
  endmethod.

  method if_oo_source_pos_index_helper~get_class_def_pos.
  endmethod.

  method if_oo_source_pos_index_helper~get_class_impl_pos.
  endmethod.

  method if_oo_source_pos_index_helper~get_form_based_pos.
  endmethod.

  method if_oo_source_pos_index_helper~get_method_impl_pos.
  endmethod.

  method if_oo_source_pos_index_helper~update_index_on_activate.
  endmethod.

  method if_oo_source_pos_index_helper~get_source_pos_index_for_class.
  endmethod.

endclass.


*----------------------------------------------------------------------*
*       class ltcl_persistence_source_fake definition
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_persistence_fake definition for testing risk level harmless duration short.
  public section.
    interfaces:
      lif_persistence_facade,
      lif_signature_provider.
    data:
      reset_generation_flag_called    type seox_boolean value seox_false read-only.
    class-methods:
      create_instance
        importing
          source_template                type ref to ltcl_source_template
          enable_recording               type seox_boolean default seox_false
          has_class_inactive_source_part type seox_boolean default seox_true
          modification_mode_enabled      type seox_boolean default seox_false
          modification_tool_log          type ref to if_clm_tool_log optional
          is_exception_class             type seox_boolean default seox_false
          value(super_class_name)        type seoclsname optional
          value(implemented_interfaces)  type ltcl_source_template=>ty_clif_list optional
          is_valid_source_modification   type seox_boolean default seox_true
        returning
          value(instance)                type ref to ltcl_persistence_fake.
    methods:
      get_method_source
        importing
          method_name   type seocpdname
        returning
          value(source) type rswsourcet,
      get_section_source
        importing
          exposure      type seoexpose
        returning
          value(source) type rswsourcet,
      rec_read_report
        importing
          include_name type progname
          version      type r3state default lif_source_part=>c_version_inactive,
      rec_insert_report
        importing
          include_name type progname
          version      type r3state default lif_source_part=>c_version_inactive,
      verify_calls,
      verify_that_method_is_deleted
        importing
          method_name type seocpdname,
      verify_authority_check
        importing
          exp_access_mode     type seok_access_mode
          exp_authority_check type seox_boolean,
      verify_modass_state_4_clif_def
        importing
          clif_name           type seoclsname
          exp_modass_disabled type seox_boolean,
      verify_modass_state_4_intf
        importing
          clif_name           type seoclsname
          exp_modass_disabled type seox_boolean,
      verify_modass_state_4_method
        importing
          method_name         type seocpdname
          exp_modass_disabled type seox_boolean,
      add_method_include
        importing
          class_name   type seoclsname
          method_name  type seocpdname
          include_name type progname,
      get_source
        importing
          name          type progname
        returning
          value(source) type rswsourcet,
      set_is_exception_class
        importing
          is_exception_class type seox_boolean,
      set_super_class_name
        importing
          super_class_name type seoclsname.
  private section.
    types:
      begin of ty_source_map_entry,
        name      type progname,
        source    type rswsourcet,
        timestamp type xsddatetime_z,
      end of ty_source_map_entry.
    types:
      begin of ty_meth_signature,
        method_key type seomtdkey,
        signature  type lif_signature_provider=>type_method_signature,
      end of ty_meth_signature.
    types:
      begin of ty_include,
        name    type progname,
        version type r3state,
      end of ty_include.
    types:
      begin of ty_record,
        read_report   type standard table of ty_include with non-unique key table_line,
        insert_report type standard table of ty_include with non-unique key table_line,
      end of ty_record.
    data:
      class_key                      type seoclskey,
      source_map                     type hashed table of ty_source_map_entry with unique key name,
      method_includes                type seop_methods_w_include,
      enable_recording               type seox_boolean,
      exp_calls                      type ty_record,
      act_calls                      type ty_record,
      method_signatures              type hashed table of ty_meth_signature with unique key method_key,
      has_class_inactive_source_part type seox_boolean,
      no_of_method_includes_in_cs    type i,
      deleted_method_impls           type sorted table of seocpdname with non-unique key table_line,
      modification_mode_enabled      type seox_boolean,
      modification_tool_log          type ref to if_clm_tool_log,
      modass_disabled_4_clif_def     type seoclsname,
      modass_disabled_4_interface    type seoclsname,
      modass_disabled_4_methods      type sorted table of seocpdname with non-unique key table_line,
      is_exception_class             type seox_boolean,
      super_class_name               type seoclsname,
      implemented_interfaces         type ltcl_source_template=>ty_clif_list,
      access_mode                    type seok_access_mode,
      authority_check                type seox_boolean,
      is_valid_source_modification   type seox_boolean.
    methods:
      add_source
        importing
          name      type progname
          source    type rswsourcet
          timestamp type xsddatetime_z,
      add_classpool_source
        importing
          class_key type seoclskey,
      get_timestamp
        importing
          name          type progname
        returning
          value(result) type xsddatetime_z
        raising
          cx_include_does_not_exist,
      init
        importing
          source_template                type ref to ltcl_source_template
          enable_recording               type seox_boolean
          has_class_inactive_source_part type seox_boolean
          modification_mode_enabled      type seox_boolean
          modification_tool_log          type ref to if_clm_tool_log
          is_exception_class             type seox_boolean
          super_class_name               type seoclsname
          implemented_interfaces         type ltcl_source_template=>ty_clif_list
          is_valid_source_modification   type seox_boolean default seox_true.
endclass.                    "ltcl_persistence_source_fake definition

*----------------------------------------------------------------------*
*       class ltcl_persistence_fake implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_persistence_fake implementation.

  method create_instance.
    create object instance.
    if ( super_class_name is not supplied ).
      super_class_name = source_template->super_class_name.
    endif.
    if ( implemented_interfaces is not supplied ).
      implemented_interfaces = source_template->implemented_interfaces.
    endif.
    instance->init( source_template                 = source_template
                    enable_recording                = enable_recording
                    has_class_inactive_source_part  = has_class_inactive_source_part
                    modification_mode_enabled       = modification_mode_enabled
                    modification_tool_log           = modification_tool_log
                    is_exception_class              = is_exception_class
                    super_class_name                = super_class_name
                    implemented_interfaces          = implemented_interfaces
                    is_valid_source_modification    = is_valid_source_modification ).
  endmethod.                    "get_instance

  method init.
    data:
      source           type rswsourcet,
      method_include   type seop_method_w_include,
      method_signature type ty_meth_signature.
    field-symbols:
      <source_info> type ltcl_source_template=>ty_source_info_entry.

    me->class_key = source_template->class_key.
    me->add_classpool_source( source_template->class_key ).
    loop at source_template->source_info assigning <source_info>.
      clear source.
      append lines of source_template->source from <source_info>-line_from to <source_info>-line_to to source.
      me->add_source( name = <source_info>-include_name source = source timestamp = <source_info>-timestamp ).
      if ( <source_info>-method_name is not initial ).
        method_include-cpdkey-clsname = source_template->class_key-clsname.
        method_include-cpdkey-cpdname = <source_info>-method_name.
        method_include-incname = <source_info>-include_name.
        insert method_include into table me->method_includes.
        method_signature-method_key-clsname = source_template->class_key-clsname.
        method_signature-method_key-mtdname = <source_info>-method_name.
        method_signature-signature-method-exposure = <source_info>-exposure.
        insert method_signature into table me->method_signatures.
      endif.
    endloop.
    me->enable_recording = enable_recording.
    me->has_class_inactive_source_part = has_class_inactive_source_part.
    me->no_of_method_includes_in_cs = source_template->no_of_method_impls_in_cs.
    me->modification_mode_enabled = modification_mode_enabled.
    me->is_exception_class = is_exception_class.
    me->super_class_name = super_class_name.
    me->implemented_interfaces = implemented_interfaces.
    me->modification_tool_log = modification_tool_log.
    me->is_valid_source_modification = is_valid_source_modification.
  endmethod.                    "init

  method add_method_include.
    data:
      method_include   type seop_method_w_include.

    method_include-cpdkey-clsname = class_name.
    method_include-cpdkey-cpdname = method_name.
    method_include-incname = include_name.
    insert method_include into table me->method_includes.
  endmethod.

  method add_source.
    data:
      source_map_entry type ty_source_map_entry.

    source_map_entry-name   = name.
    source_map_entry-source = source.
    source_map_entry-timestamp = timestamp.
    insert source_map_entry into table me->source_map.
  endmethod.                    "add_source

  method add_classpool_source.
    data:
      source       type rswsourcet,
      include_name type progname.


    include_name = cl_oo_classname_service=>get_classpool_name( class_key-clsname ).
    append |class-pool .                                    | to source.
    append |*"* class pool for class { class_key-clsname }  | to source.
    append |                                                | to source.
    append |*"* local type definitions                      | to source.
    append |include { include_name(30) }ccdef.              | to source.
    append |                                                | to source.
    append |*"* class { class_key-clsname } definition      | to source.
    append |*"* public declarations                         | to source.
    append |include { include_name(30) }cu.                 | to source.
    append |*"* protected declarations                      | to source.
    append |include { include_name(30) }co.                 | to source.
    append |*"* private declarations                        | to source.
    append |include { include_name(30) }ci.                 | to source.
    append |endclass. "{ class_key-clsname } definition     | to source.
    append |                                                | to source.
    append |*"* macro definitions                           | to source.
    append |include { include_name(30) }ccmac.              | to source.
    append |*"* local class implementation                  | to source.
    append |include { include_name(30) }ccimp.              | to source.
    append |                                                | to source.
    append |*"* test class                                  | to source.
    append |include { include_name(30) }ccau.               | to source.
    append |                                                | to source.
    append |class { class_key-clsname } implementation.     | to source.
    append |*"* method`s implementations                    | to source.
    append |  include methods.                              | to source.
    append |endclass. "{ class_key-clsname } implementation | to source.
    me->add_source( name = include_name source = source timestamp = '20090101000000' ).
  endmethod.

  method get_source.
    data:
      source_map_entry type ty_source_map_entry.

    read table me->source_map with table key name = name into source_map_entry.
    source = source_map_entry-source.
  endmethod.                    "get_source

  method get_timestamp.
    data:
      source_map_entry type ty_source_map_entry.

    read table me->source_map with table key name = name into source_map_entry.
    if ( sy-subrc <> 0 or source_map_entry-timestamp = 0 ).
      raise exception type cx_include_does_not_exist.
    endif.
    result = source_map_entry-timestamp.
  endmethod.                    "get_source

  method get_method_source.
    data:
      method_key   type seomtdkey.

    method_key-clsname = me->class_key-clsname.
    method_key-mtdname = method_name.
    source = me->get_source( me->if_oo_clif_persist_meta_data~get_method_include( method_key ) ).
  endmethod.                    "get_method_source

  method get_section_source.
    data:
      name type progname.

    case exposure.
      when seoc_exposure_public.
        name = cl_oo_classname_service=>get_pubsec_name( me->class_key-clsname ).
      when seoc_exposure_protected.
        name = cl_oo_classname_service=>get_prosec_name( me->class_key-clsname ).
*      when seoc_exposure_package.
*        name = cl_oo_classname_service=>get_paksec_name( me->class_key-clsname ).
      when seoc_exposure_private.
        name = cl_oo_classname_service=>get_prisec_name( me->class_key-clsname ).
    endcase.
    source = me->get_source( name ).
  endmethod.                    "get_section_source

  method if_oo_clif_persistence_source~insert_report.
    data:
      timestamp    type xsddatetime_z,
      record_entry type ty_include.
    field-symbols:
      <source_map_entry> type ty_source_map_entry.

    read table me->source_map with table key name = include_name assigning <source_map_entry>.
    if ( sy-subrc = 0 ).
      <source_map_entry>-source = source.
    else.
      get time stamp field timestamp.
      me->add_source( name = include_name source = source timestamp = timestamp ).
    endif.
    if ( me->enable_recording = seox_true ).
      record_entry-name    = include_name.
      record_entry-version = state.
      append record_entry to act_calls-insert_report.
    endif.
  endmethod.                    "lif_persistence_source~insert_report

  method if_oo_clif_persistence_source~delete_report.
  endmethod.

  method if_oo_clif_persistence_source~read_report.
    data:
      record_entry type ty_include.
    field-symbols:
      <include_name> type progname.

    if ( ( state = if_oo_clif_source=>co_version_inactive ) and ( me->has_class_inactive_source_part = seox_false ) ).
      "inactive version has been requested, but the class has no inactive version...
      raise exception type cx_include_does_not_exist.
    endif.
    if ( me->enable_recording = seox_true ).
      record_entry-name    = include_name.
      record_entry-version = state.
      append record_entry to act_calls-read_report.
    endif.
    source = me->get_source( include_name ).
  endmethod.                    "lif_persistence_source~read_report

  method rec_read_report.
    data:
      record_entry type ty_include.

    if ( me->enable_recording = seox_false ).
      cl_aunit_assert=>fail( 'Wrong record handling' ).
    endif.
    record_entry-name    = include_name.
    record_entry-version = version.
    append record_entry to exp_calls-read_report.
  endmethod.


  method rec_insert_report.
    data:
      record_entry type ty_include.

    if ( me->enable_recording = seox_false ).
      cl_aunit_assert=>fail( 'Wrong record handling' ).
    endif.
    record_entry-name    = include_name.
    record_entry-version = version.
    append record_entry to exp_calls-insert_report.
    " update whether the class has inactive source parts if the stored include
    " is a section or a method implementation
    if ( ( version = lif_source_part=>c_version_inactive ) and
         ( ( include_name+30(2) = 'CM' ) or
           ( include_name+30(2) = 'CU' ) or ( include_name+30(2) = 'CO' ) or
           ( include_name+30(2) = 'CO' ) or ( include_name+30(2) = 'CI' ) ) ).
      me->has_class_inactive_source_part = seox_true .
    endif.
  endmethod.

  method verify_calls.
    if ( me->enable_recording = seox_false ).
      cl_aunit_assert=>fail( 'Wrong record handling' ).
    endif.
    cl_aunit_assert=>assert_equals( exp = exp_calls act = act_calls ).
  endmethod.

  method if_oo_clif_persistence_source~read_progdir.
  endmethod.                    "lif_persistence_source~read_progdir

  method if_oo_clif_persistence_source~update_progdir.
  endmethod.                    "lif_persistence_source~update_progdir

  method if_oo_clif_persist_meta_data~delete_method_include.
    insert method_key-mtdname into table me->deleted_method_impls.
  endmethod.                    "lif_persistence_meta_data~delete_method_include

  method verify_that_method_is_deleted.
    read table me->deleted_method_impls with table key table_line = method_name transporting no fields.
    if ( sy-subrc <> 0 ).
      cl_abap_unit_assert=>fail( |Method{ method_name } was not deleted as expected.| ).
    endif.
  endmethod.

  method verify_authority_check.
    cl_abap_unit_assert=>assert_equals( msg = 'Wrong access mode has been passed during authority check' exp = exp_access_mode act = me->access_mode ).
    cl_abap_unit_assert=>assert_equals( msg = 'Wrong authority check setting' exp = exp_authority_check act = me->authority_check ).
  endmethod.

  method verify_modass_state_4_clif_def.
    data:
      act_modass_disabled type seox_boolean.

    act_modass_disabled = boolc( clif_name = me->modass_disabled_4_clif_def ).
    cl_abap_unit_assert=>assert_equals(
        msg = 'Wrong modification assistant disablement for class definition'
        exp = exp_modass_disabled
        act = act_modass_disabled ).
  endmethod.

  method verify_modass_state_4_intf.
    data:
      act_modass_disabled type seox_boolean.

    act_modass_disabled = boolc( clif_name = me->modass_disabled_4_interface ).
    cl_abap_unit_assert=>assert_equals(
        msg = 'Wrong modification assistant disablement for interface definition'
        exp = exp_modass_disabled
        act = act_modass_disabled ).
  endmethod.

  method verify_modass_state_4_method.
    data:
      act_modass_disabled type seox_boolean.

    read table me->modass_disabled_4_methods with table key table_line = method_name transporting no fields.
    act_modass_disabled = boolc( sy-subrc = 0 ).
    cl_abap_unit_assert=>assert_equals(
        msg = |Wrong modification assistant disablement for method { method_name }|
        exp = exp_modass_disabled
        act = act_modass_disabled ).
  endmethod.

  method if_oo_clif_persist_meta_data~generate_method_include.
  endmethod.                    "lif_persistence_meta_data~generate_method_include

  method if_oo_clif_persistence_source~read_timestamp_for_include.
    result = me->get_timestamp( include_name ).
  endmethod.

  method if_oo_clif_persistence_source~read_timestamp_for_class.
    data:
      cs_include_name type progname.
    field-symbols:
      <source_map_entry> type ty_source_map_entry.

    cs_include_name = cl_oo_classname_service=>get_cs_name( me->class_key-clsname ).
    loop at me->source_map assigning <source_map_entry> where name <> cs_include_name.
      if ( <source_map_entry>-timestamp > result ).
        result = <source_map_entry>-timestamp.
      endif.
    endloop.
  endmethod.

  method if_oo_clif_persistence_source~lock_cs_include.
    result = seox_true.
  endmethod.

  method if_oo_clif_persistence_source~unlock_cs_include.

  endmethod.

  method if_oo_clif_persistence_source~reset_generation_flag_in_tmdir.
    me->reset_generation_flag_called = seox_true.
  endmethod.

  method if_oo_clif_persistence_source~has_class_inactive_source_part.
    result = me->has_class_inactive_source_part.
  endmethod.

  method if_oo_clif_persist_meta_data~get_all_method_includes.
    method_includes = me->method_includes.
  endmethod.                    "lif_persistence_meta_data~get_all_method_includes

  method if_oo_clif_persist_meta_data~keep_method_order.
    result = abap_false.
  endmethod.

  method if_oo_clif_persist_meta_data~get_class_typeinfo.
    inheritance = value #( clsname = me->class_key-clsname refclsname = me->super_class_name ).
    loop at implemented_interfaces assigning field-symbol(<interface>).
      insert value seor_implementing_r( clsname = me->class_key-clsname refclsname = <interface> )
         into table implementings.
    endloop.
  endmethod.                    "lif_persistence_meta_data~get_class_typeinfo

  method if_oo_clif_persist_meta_data~get_clif_type.
    if ( clif_key-clsname(2) = 'IF' ).
      clif_type = seoc_clstype_interface.
    else.
      clif_type = seoc_clstype_class.
    endif.
  endmethod.                    "lif_persistence_meta_data~get_clif_type

  method if_oo_clif_persist_meta_data~get_interface_typeinfo.
  endmethod.                    "lif_persistence_meta_data~get_interface_typeinfo

  method if_oo_clif_persist_meta_data~get_method_include.
    field-symbols:
     <method_include> type seop_method_w_include.

    read table me->method_includes with key cpdkey = method_key assigning <method_include>.
    cl_aunit_assert=>assert_subrc( act = sy-subrc msg = 'GET METHOD INCLUDE for an unknown fake method' ).
    include_name = <method_include>-incname.
  endmethod.                    "lif_persistence_meta_data~get_method_include

  method if_oo_clif_persist_meta_data~update_class_section_meta_data.
  endmethod.                    "lif_persistence_meta_data~update_class_section_meta_data

  method if_oo_clif_persist_meta_data~update_intf_section_meta_data.
  endmethod.                    "lif_persistence_meta_data~update_intf_section_meta_data

  method if_oo_clif_persist_meta_data~get_method_data.
    field-symbols:
      <method_signature> type ty_meth_signature.

    read table me->method_signatures with table key method_key = method_key assigning <method_signature>.
    if ( sy-subrc = 0 ).
      method_data = <method_signature>-signature-method.
    endif.
  endmethod.

  method if_oo_clif_persist_meta_data~is_exception_class.
    result = me->is_exception_class.
  endmethod.

  method set_is_exception_class.
    me->is_exception_class = is_exception_class.
  endmethod.

  method lif_persistence_lifecycle~access_permission.
    me->access_mode           = access_mode.
    me->authority_check       = authority_check.
    modification_mode_enabled = me->modification_mode_enabled.
  endmethod.                    "lif_persistence_lifecycle~access_permission

  method lif_persistence_lifecycle~corr_insert.
  endmethod.                    "lif_persistence_lifecycle~corr_insert

  method lif_persistence_lifecycle~get_inactive_objects.
    object_list = object_list.
  endmethod.                    "lif_persistence_lifecycle~get_inactive_objects

  method lif_persistence_lifecycle~insert_into_working_area.
  endmethod.                    "lif_persistence_lifecycle~insert_into_working_area

  method lif_signature_provider~get_method_signature.
    field-symbols:
      <method_signature> type ty_meth_signature.

    read table me->method_signatures with table key method_key = method_key assigning <method_signature>.
    if ( sy-subrc = 0 ).
      method_signature = <method_signature>-signature.
    endif.
  endmethod.

  method lif_signature_provider~init.
  endmethod.

  method lif_signature_provider~refresh.
  endmethod.

  method if_oo_clif_persistence_source~write_no_of_method_includes.
  endmethod.

  method if_oo_clif_persistence_source~read_no_of_method_includes.
    result = me->no_of_method_includes_in_cs.
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_interface.
    result = me->modification_mode_enabled.
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_class_def.
    if me->modass_disabled_4_clif_def <> space.
      result = abap_false.
    else.
      result = me->modification_mode_enabled.
    endif.
  endmethod.

  method lif_persistence_modass~is_modass_enabled_4_method.
    read table me->modass_disabled_4_methods with table key table_line = method_key-mtdname transporting no fields.
    if sy-subrc = 0.
      result = abap_false.
    else.
      result = me->modification_mode_enabled.
    endif.
  endmethod.

  method lif_persistence_modass~check_modass_permissions.
  endmethod.

  method lif_persistence_modass~disable_modass_4_interface.
    me->modass_disabled_4_interface = class_key-clsname.
  endmethod.

  method lif_persistence_modass~disable_modass_4_class_def.
    me->modass_disabled_4_clif_def = class_key-clsname.
  endmethod.

  method lif_persistence_modass~read_sap_versions_4_class_def.
  endmethod.

  method lif_persistence_modass~read_sap_version_4_interface.
  endmethod.

  method lif_persistence_modass~disable_modass_4_method.
    insert method_key-mtdname into table me->modass_disabled_4_methods.
  endmethod.

  method lif_persistence_modass~is_clif_modified_with_modass.
    data p_entries_tab type smodi_tool_log_tab.

    result = seox_false.

    if  me->modification_tool_log is not bound.
      return.
    endif.

    me->modification_tool_log->get_entries(
      importing
        p_entries_tab =  p_entries_tab ).
    if p_entries_tab is not initial.
      result = seox_true.
    endif.
  endmethod.

  method lif_persistence_modass~read_modificationinfo_4_method.
    result = me->modification_tool_log.
  endmethod.

  method lif_persistence_modass~read_modificationinfo_4_sectn.
    result = me->modification_tool_log.
  endmethod.

  method lif_persistence_modass~save_modificationinfo_4_method.
    if me->is_valid_source_modification = seox_false.
      raise exception type cx_oo_source_save_failure.
    endif.
  endmethod.

  method if_oo_clif_persistence_source~add_suppress_generation_pragma.
    field-symbols: <source_line> type line of rswsourcet.

    read table source index 1 assigning <source_line>.
    <source_line> = |{ <source_line> } ##ADT_SUPPRESS_GENERATION|.
  endmethod.

  method if_oo_clif_persistence_source~del_suppress_generation_pragma.
    field-symbols: <source_line> type line of rswsourcet.

    read table source index 1 assigning <source_line>.
    <source_line> = substring_before( val = <source_line> sub = ` ##ADT_SUPPRESS_GENERATION` ) && substring_after( val = <source_line> sub = ` ##ADT_SUPPRESS_GENERATION` ).
    adjustment_was_executed = seox_true.
  endmethod.

  method set_super_class_name.
    me->super_class_name = super_class_name.
  endmethod.

endclass.                    "ltcl_persistence_fake implementation

*----------------------------------------------------------------------*
*       class ltcl_source_template implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_source_template implementation.

  method add_method_source_info.
    data:
      include_name type progname,
      index        type n length 3 value '001'.

    include_name = class_name.
    translate include_name(30) using ' ='.
    include_name+30(2) = 'CM'.
    loop at me->source_info transporting no fields where method_name is not initial.
      index = index + 1.
    endloop.
    include_name+32(3) = index.
    me->add_source_info( include_name = include_name method_name = method_name line_from = line_from line_to = line_to timestamp = timestamp exposure = exposure ).
  endmethod.                    "add_method_source_info

  method add_section_source_info.
    data:
      include_name type progname.

    case exposure.
      when seoc_exposure_public.
        include_name = cl_oo_classname_service=>get_pubsec_name( class_name ).
      when seoc_exposure_protected.
        include_name = cl_oo_classname_service=>get_prosec_name( class_name ).
*      when seoc_exposure_package.
*        include_name = cl_oo_classname_service=>get_paksec_name( class_name ).
      when seoc_exposure_private.
        include_name = cl_oo_classname_service=>get_prisec_name( class_name ).
    endcase.
    me->add_source_info( include_name = include_name line_from = line_from line_to = line_to timestamp = timestamp ).
  endmethod.                    "add_section_source_info

  method add_interface_source_info.
    data:
      include_name type progname.

    include_name = cl_oo_classname_service=>get_intfsec_name( interface_name ).
    me->add_source_info( include_name = include_name line_from = line_from line_to = line_to timestamp = timestamp ).
  endmethod.

  method add_cs_source_info.
    data:
      line_to      type i,
      include_name type progname.

    include_name = cl_oo_classname_service=>get_cs_name( class_name ).
    line_to = lines( me->source ).
    me->add_source_info( include_name = include_name line_from = 1 line_to = line_to timestamp = timestamp ).
    me->no_of_method_impls_in_cs = no_of_method_impls_in_cs.
  endmethod.

  method add_source_info.
    data:
      source_info_entry type ty_source_info_entry.

    source_info_entry-include_name = include_name.
    source_info_entry-method_name  = method_name.
    source_info_entry-line_from    = line_from.
    source_info_entry-line_to      = line_to.
    source_info_entry-timestamp    = timestamp.
    source_info_entry-exposure     = exposure.
    insert source_info_entry into table me->source_info.
  endmethod.                    "add_source_info

endclass.                    "ltcl_source_template_generic implementation


*----------------------------------------------------------------------*
*       class ltcl_source_template_01 definition
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_source_template_01 definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition


*----------------------------------------------------------------------*
*       class ltcl_source_template_01 implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_source_template_01 implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_WB_AU_TEMPLATE_001'.
    append_to me->source:
        'class CL_WB_AU_TEMPLATE_001 definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_WB_AU_TEMPLATE_001',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_WB_AU_TEMPLATE_001 .',
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .',
        'protected section.',
        '*"* protected components of class CL_WB_AU_TEMPLATE_001',
        '*"* do not include other source files here!!!',
        'private section.',
        '*"* private components of class CL_WB_AU_TEMPLATE_001',
        '*"* do not include other source files here!!!',
        '',
        '  data ATT01 type I .',
        'ENDCLASS.',
        '',
        '',
        '',
        'CLASS CL_WB_AU_TEMPLATE_001 IMPLEMENTATION.',
        '',
        '',
        '* <SIGNATURE>---------------------------------------------------------------------------------------+',
        '* | Instance Public Method CL_WB_AU_TEMPLATE_001->IF_WB_AU_TEMPLATE_001~METH01',
        '* +-------------------------------------------------------------------------------------------------+',
        '* | [--->] P1                             TYPE        I',
        '* +--------------------------------------------------------------------------------------</SIGNATURE>',
        'method IF_WB_AU_TEMPLATE_001~METH01.',
        '*  implem IF_WB_AU_TEMPLATE_001~METH01',
        'endmethod.',
        '',
        '',
        '* <SIGNATURE>---------------------------------------------------------------------------------------+',
        '* | Instance Public Method CL_WB_AU_TEMPLATE_001->METH01',
        '* +-------------------------------------------------------------------------------------------------+',
        '* | [<-->] P1                             TYPE        C',
        '* +--------------------------------------------------------------------------------------</SIGNATURE>',
        'method meth01.',
        '  p1 = ''TEST_WB''.',
        'endmethod.',
        'ENDCLASS.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 13 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 14 line_to = 16 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 17 line_to = 21 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_WB_AU_TEMPLATE_001~METH01' line_from = 34 line_to = 36 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'METH01' line_from = 44 line_to = 46 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20091019171900' no_of_method_impls_in_cs = 2 ).
  endmethod.                    "constructor
endclass.                    "ltcl_source_template_01 implementation


*----------------------------------------------------------------------*
*       class ltcl_class_01 definition
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_class_reading definition for testing risk level harmless duration short .
  private section.
    methods:
      setup,
      teardown raising cx_oo_access_permission.
    methods:
      read_01 for testing.
    data:
      source_object   type ref to cl_oo_clif_source,
      source_template type ref to ltcl_source_template_01.
endclass.                    "ltcl_class_01 definition


class cl_oo_clif_source definition local friends ltcl_class_reading.
*----------------------------------------------------------------------*
*       class ltcl_class_01 implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_class_reading implementation.

  method setup.
    create object me->source_template.
    me->source_object = cl_oo_clif_source=>create_instance(
        clif_name = me->source_template->class_key-clsname
        settings  = cl_oo_clif_source_settings=>create_instance( signature_enabled = seox_true )
    ).
  endmethod.                    "setup

  method teardown.
    me->source_object->access_permission( seok_access_free ).
    clear me->source_object.
    clear me->source_template.
  endmethod.                    "teardown

  method read_01.
    data:
      actual_source type seop_source_string.

    me->source_object->get_source( importing source = actual_source ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = actual_source ).
  endmethod.                                                "read_01

endclass.                    "ltcl_class_01 implementation


*----------------------------------------------------------------------*
*       class ltcl_class_02 definition
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_class_writing definition for testing risk level harmless duration short .
  private section.
    methods:
      setup,
      teardown raising cx_oo_access_permission.
    methods:
      save_method_01  for testing raising cx_oo_source_save_failure,
      save_section_01 for testing raising cx_oo_source_save_failure.
    data:
      class_key       type seoclskey,
      source_object   type ref to cl_oo_clif_source,
      source_template type ref to ltcl_source_template_01.
endclass.                    "ltcl_class_02 definition


*----------------------------------------------------------------------*
*       class ltcl_class_02 implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_class_writing implementation.

  method setup.
    data:
      test_helper type ref to cl_wb_test_helper.

    try.
        test_helper = cl_wb_test_helper=>create_instance( ).
        create object me->source_template.
        me->class_key-clsname = test_helper->copy_class( me->source_template->class_key-clsname ).
        me->source_object = cl_oo_clif_source=>create_instance(
           clif_name = me->class_key-clsname
           settings  = cl_oo_clif_source_settings=>create_instance( signature_enabled = seox_true )
        ).
        me->source_object->if_oo_clif_source~get_source( importing source = me->source_template->source ).
      catch cx_wb_test_helper_error.
        cl_aunit_assert=>abort( quit = cl_aunit_assert=>method ).
    endtry.
  endmethod.                    "setup

  method teardown.
    data:
      test_helper type ref to cl_wb_test_helper.

    if ( me->source_object is bound ).
      me->source_object->access_permission( seok_access_free ).
      clear me->source_object.
    endif.
    if (  me->class_key-clsname is not initial ).
      try.
          test_helper = cl_wb_test_helper=>create_instance( ).
          test_helper->delete_class( me->class_key-clsname ).
        catch cx_wb_test_helper_error.                  "#EC NO_HANDLER
      endtry.
    endif.
    clear me->source_template.
  endmethod.                    "teardown

  method save_method_01.
    constants:
      co_additional_source_line type string value '* Another Test',
      co_source_line            type i value 35.
    data:
      actual_method_source   type seop_source_string,
      expected_method_source type seop_source_string,
      method_key             type seocpdkey,
      include_name           type progname,
      source_position        type cl_oo_source_scanner=>type_source_position.


    insert co_additional_source_line into me->source_template->source index co_source_line.
    me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
    source_position-line = co_source_line.
    try.
        me->source_object->lock_source_part( source_position ).
        me->source_object->if_oo_clif_source~save( ).
        append_to expected_method_source:
            'method IF_WB_AU_TEMPLATE_001~METH01.',
            co_additional_source_line,
            '*  implem IF_WB_AU_TEMPLATE_001~METH01',
            'endmethod.'.
        method_key-clsname = me->class_key-clsname.
        method_key-cpdname = 'IF_WB_AU_TEMPLATE_001~METH01'.
        include_name = cl_oo_classname_service=>get_method_include( method_key ).
        read report include_name into actual_method_source state 'I'.
        cl_aunit_assert=>assert_equals( act = actual_method_source exp = expected_method_source ).
      catch cx_oo_access_permission.
        cl_aunit_assert=>abort( quit = cl_aunit_assert=>method ).
    endtry.
  endmethod.                                                "save_01

  method save_section_01.
    constants:
      co_additional_source_line type string value ' DATA ABC TYPE I.',
      co_source_line            type i value 10.
    data:
      actual_source   type seop_source_string,
      expected_source type seop_source_string,
      include_name    type progname,
      source_position type cl_oo_source_scanner=>type_source_position.


    insert co_additional_source_line into me->source_template->source index co_source_line.
    me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
    source_position-line = co_source_line.
    try.
        me->source_object->lock_source_part( source_position ).
        me->source_object->if_oo_clif_source~save( ).
        append_to expected_source:
            'class CL_WB_AU_TEMPLATE_001 definition',
            '  public',
            '  create public .',
            '',
            'public section.',
            '',
            '*"* public components of class CL_WB_AU_TEMPLATE_001',
            '*"* do not include other source files here!!!',
            '  interfaces IF_WB_AU_TEMPLATE_001 .',
            co_additional_source_line,
            '',
            '  methods METH01',
            '    changing',
            '      !P1 type C .'.
        replace all occurrences of me->source_template->class_key-clsname in table expected_source with me->class_key-clsname.
        include_name = cl_oo_classname_service=>get_pubsec_name( me->class_key-clsname ).
        read report include_name into actual_source state 'I'.
        cl_aunit_assert=>assert_equals( act = actual_source exp = expected_source ).
      catch cx_oo_access_permission.
        cl_aunit_assert=>abort( quit = cl_aunit_assert=>method ).
    endtry.
  endmethod.                                                "save_01


endclass.                    "ltcl_class_02 implementation


*----------------------------------------------------------------------*
*       class ltcl_source_temp_simple_fake definition
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_src_tmplt_class_simple definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition

*----------------------------------------------------------------------*
*       class ltcl_source_template_01 implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_src_tmplt_class_simple implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_SIMPLE_FAKE'.
    me->implemented_interfaces = value #( ( 'IF_SIMPLE_FAKE' ) ).
    append_to me->source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_SIMPLE_FAKE .',
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .',
        'protected section.',
        '*"* protected components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        'private section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  data ATT01 type I .',
        'ENDCLASS.',
        '',
        '',
        '',
        'CLASS CL_SIMPLE_FAKE IMPLEMENTATION.',
        '',
        '',
        'method IF_SIMPLE_FAKE~METH01.',
        '*  implem IF_SIMPLE_FAKE~METH01',
        'endmethod.',
        '',
        '',
        'method meth01.',
        '  p1 = ''TEST_WB''.',
        'endmethod.',
        'ENDCLASS.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 13 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 14 line_to = 16 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 17 line_to = 21 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_SIMPLE_FAKE~METH01' line_from = 29 line_to = 31 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'METH01' line_from = 34 line_to = 36 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20091019171900' no_of_method_impls_in_cs = 2 ).
  endmethod.                    "constructor
endclass.                    "ltcl_source_template_01 implementation

class ltcl_src_tmplt_class_mod definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition

*----------------------------------------------------------------------*
*       class ltcl_source_template_01 implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_src_tmplt_class_mod implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_SIMPLE_FAKE'.
    me->implemented_interfaces = value #( ( 'IF_SIMPLE_FAKE' ) ).
    append_to me->source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_SIMPLE_FAKE .',
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .',
        'protected section.',
        '*"* protected components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        'private section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  data ATT01 type I .',
        'ENDCLASS.',
        '',
        '',
        '',
        'CLASS CL_SIMPLE_FAKE IMPLEMENTATION.',
        '',
        '',
        'method IF_SIMPLE_FAKE~METH01.',
        '*{   INSERT         MO2K900749                                        1',
        '*  implem IF_SIMPLE_FAKE~METH01',
        '*}   INSERT',
        'endmethod.',
        '',
        '',
        'method meth01.',
        '  p1 = ''TEST_WB''.',
        'endmethod.',
        'ENDCLASS.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 13 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 14 line_to = 16 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 17 line_to = 21 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_SIMPLE_FAKE~METH01' line_from = 29 line_to = 31 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'METH01' line_from = 34 line_to = 36 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20091019171900' no_of_method_impls_in_cs = 2 ).
  endmethod.                    "constructor
endclass.                    "ltcl_source_template_01 implementation


class ltcl_src_tmplt_interface definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition

class ltcl_src_tmplt_interface implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'IF_FAKE'.
    append_to me->source:
        'interface IF_FAKE',
        '  public .',
        '',
        '  constants CO_STATE_CURRENT type I value 0. "#EC NOTEXT',
        '  methods ARE_LOCAL_CHANGES_ALLOWED',
        '    returning',
        '      value(LOCAL_CHANGES) type ABAP_BOOL .',
        '  methods GET_BFUNC_SWITCH_ON_TIME',
        '    importing',
        '      !BFUNC type SFW_BFUNCTION',
        '    returning',
        '      value(SWITCH_ON_TIME) type SFW_TIMESTAMP .',
        'endinterface.'.
    me->add_interface_source_info( interface_name = class_key-clsname line_from = 1  line_to = 13 timestamp = '20091019171900' ).
  endmethod.
endclass.


class ltcl_class_base definition for testing risk level harmless duration short.
  protected section.
    data:
      source_object    type ref to cl_oo_clif_source,
      persistence_fake type ref to ltcl_persistence_fake.
    methods:
      add_source_text
        importing
          source_text type string
          source_line type i,
      remove_source_text
        importing
          source_line type i.
endclass.

class cl_oo_clif_source definition local friends ltcl_class_base.
class ltcl_class_base implementation.

  method add_source_text.
    data:
      source type rswsourcet.

    source = me->source_object->source.
    insert source_text into source index source_line.
    me->source_object->if_oo_clif_source~set_source( source ).
  endmethod.                    "add_source_text

  method remove_source_text.
    data:
      source type rswsourcet.

    source = me->source_object->source.
    delete source index source_line.
    me->source_object->if_oo_clif_source~set_source( source ).
  endmethod.                    "remove_source_text

endclass.

class ltcl_class_simple definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    methods:
      setup.
    methods:
      test_read                   for testing,
      test_save_method_addition   for testing raising cx_static_check,
      test_save_method_deletion   for testing raising cx_static_check,
      test_save_delete_whole_meth for testing raising cx_static_check,
      test_save_section_addition  for testing raising cx_static_check,
      test_save_section_deletion  for testing raising cx_static_check.
    data:
      source_template  type ref to ltcl_src_tmplt_class_simple.
endclass.                    "ltcl_class_01 definition

class ltcl_class_simple implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper,
      pretty.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method test_read.
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
  endmethod.                    "test_read

  method test_save_method_addition.
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->source_object->access_permission( seok_access_modify ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 30 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
        'method IF_SIMPLE_FAKE~METH01.',
        co_source_text_addition,
        '*  implem IF_SIMPLE_FAKE~METH01',
        'endmethod.'.
    act_source = me->persistence_fake->get_method_source( 'IF_SIMPLE_FAKE~METH01' ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.                    "test_save_method_addition


  method test_save_method_deletion.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->source_object->access_permission( seok_access_modify ).
    me->source_object->read( ).
    me->remove_source_text( source_line = 35 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
        'method meth01.',
        'endmethod.'.
    act_source = me->persistence_fake->get_method_source( 'METH01' ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.                    "test_save_method_deletion

  method test_save_delete_whole_meth.
    me->source_object->access_permission( seok_access_modify ).
    me->source_object->read( ).
    me->remove_source_text( source_line = 36 ).
    me->remove_source_text( source_line = 35 ).
    me->remove_source_text( source_line = 34 ).
    me->source_object->if_oo_clif_source~save( ).
    me->persistence_fake->verify_that_method_is_deleted( 'METH01' ).
  endmethod.

  method test_save_section_addition.
    constants:
      co_source_text_addition type string value '  constants co_abc type i value 3.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->source_object->access_permission( seok_access_modify ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 10 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_SIMPLE_FAKE .',
        co_source_text_addition,
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .'.
    act_source = me->persistence_fake->get_section_source( seoc_exposure_public ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.                    "test_save_section_addition

  method test_save_section_deletion.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->source_object->access_permission( seok_access_modify ).
    me->source_object->read( ).
    me->remove_source_text( source_line = 21 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
        'private section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        ''.
    act_source = me->persistence_fake->get_section_source( seoc_exposure_private ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.                    "test_save_section_deletion

endclass.                    "ltcl_class_simple_fake implementation



class ltcl_class_lock_authority definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    methods:
      setup.
    methods:
      test_lock_default           for testing raising cx_static_check,
      test_lock_with_auth_check   for testing raising cx_static_check,
      test_lock_wo_auth_check     for testing raising cx_static_check.
    data:
      source_template  type ref to ltcl_src_tmplt_class_simple.
endclass.                    "ltcl_class_01 definition

class ltcl_class_lock_authority implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template = source_template ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method test_lock_default.
    me->source_object->lock( ).
    me->persistence_fake->verify_authority_check( exp_access_mode = seok_access_modify exp_authority_check = seox_true ).
  endmethod.

  method test_lock_with_auth_check.
    me->source_object->lock( authority_check = seox_true ).
    me->persistence_fake->verify_authority_check( exp_access_mode = seok_access_modify exp_authority_check = seox_true ).
  endmethod.

  method test_lock_wo_auth_check.
    me->source_object->lock( authority_check = seox_false ).
*   in the class-stack the 2 main-programs allowed to bypass authority-check are not found => authority-check as usual
    me->persistence_fake->verify_authority_check( exp_access_mode = seok_access_modify exp_authority_check = seox_true ).
  endmethod.

endclass.

class ltcl_class_modass_disabled definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    methods:
      setup.
    methods:
      test_save_public_section    for testing raising cx_static_check,
      test_save_private_section   for testing raising cx_static_check,
      test_save_method_impl       for testing raising cx_static_check,
      test_create_method_impl     for testing raising cx_static_check.
    data:
      source_template      type ref to ltcl_src_tmplt_class_simple.

endclass.                    "ltcl_class_01 definition


class ltcl_class_modass_disabled implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.

    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template = source_template modification_mode_enabled = seox_true ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method test_save_public_section.
    constants:
      co_source_text_addition type string value '  constants co_abc type i value 3.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    append_to exp_source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_SIMPLE_FAKE .',
        co_source_text_addition,
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .'.

    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 10 ).

    me->source_object->if_oo_clif_source~save( ).
    act_source = me->persistence_fake->get_section_source( seoc_exposure_public ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
    me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_true ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_false ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01'              exp_modass_disabled = seox_false ).

  endmethod.                    "test_save_section_addition


  method test_save_private_section.
    constants:
      co_source_text_addition type string value '  constants co_abc type i value 3.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    append_to exp_source:
         'private section.',
         '*"* private components of class CL_SIMPLE_FAKE',
         '*"* do not include other source files here!!!',
         '',
         '  data ATT01 type I .',
         co_source_text_addition.
    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 22 ).

    me->source_object->if_oo_clif_source~save( ).
    act_source = me->persistence_fake->get_section_source( seoc_exposure_private ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
    me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_true ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_false ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01'              exp_modass_disabled = seox_false ).
  endmethod.

  method test_save_method_impl.
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 30 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
        'method IF_SIMPLE_FAKE~METH01.',
        co_source_text_addition,
        '*  implem IF_SIMPLE_FAKE~METH01',
        'endmethod.'.
    act_source = me->persistence_fake->get_method_source( 'IF_SIMPLE_FAKE~METH01' ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
    me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_false ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_true ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01'              exp_modass_disabled = seox_false ).

  endmethod.

  method test_create_method_impl.
    data:
      include_name       type progname,
      exp_source_method  type rswsourcet,
      act_source_method  type rswsourcet,
      exp_source_section type rswsourcet,
      act_source_section type rswsourcet.

    append_to exp_source_method:
        'method method_new.',
        'endmethod.'.
    append_to exp_source_section:
        'private section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  data ATT01 type I .',
        'methods method_new.'.

    me->source_object->lock( ).
    me->source_object->read( ).
    include_name(30) = cl_oo_classname_service=>get_classpool_name( me->source_template->class_key-clsname ).
    include_name+30  = 'CM007'.
    me->persistence_fake->add_method_include(
        class_name   = me->source_template->class_key-clsname
        method_name  = 'METHOD_NEW'
        include_name = include_name    ).
    me->add_source_text( source_text = 'method method_new.' source_line = 28 ).
    me->add_source_text( source_text = 'endmethod.' source_line = 29 ).
    me->add_source_text( source_text = 'methods method_new.' source_line = 22 ).

    me->source_object->if_oo_clif_source~save( ).
    act_source_method = me->persistence_fake->get_method_source( 'METHOD_NEW' ).
    cl_aunit_assert=>assert_equals( exp = exp_source_method act = act_source_method ).

    act_source_section = me->persistence_fake->get_section_source( seoc_exposure_private ).
    cl_aunit_assert=>assert_equals( exp = exp_source_section act = act_source_section ).
    me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_true ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_false ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01'              exp_modass_disabled = seox_false ).
    me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD_NEW'            exp_modass_disabled = seox_true ).
  endmethod.

endclass.

class ltcl_clm_tool_log_stub definition for testing create private.
  public section.
    interfaces:
      if_clm_tool_log partially implemented.
    class-methods:
      create_instance
        importing
          smodi_entries type smodi_tool_log_tab
        returning
          value(result) type ref to ltcl_clm_tool_log_stub.
  private section.
    data:
      smodi_entries type smodi_tool_log_tab.
endclass.

class ltcl_clm_tool_log_stub implementation.

  method create_instance.
    result = new ltcl_clm_tool_log_stub( ).
    result->smodi_entries = smodi_entries.
  endmethod.

  method if_clm_tool_log~get_entries.
    p_entries_tab = me->smodi_entries.
  endmethod.

endclass.

class ltcl_class_modass_enabled definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    methods:
      my_setup
        importing
          tool_log                     type ref to if_clm_tool_log
          is_valid_source_modification type seox_boolean default seox_true.
    methods:
      test_save_public_section    for testing raising cx_static_check,
      test_save_method_impl       for testing raising cx_static_check,
      test_save_method_impl_OK    for testing raising cx_static_check.
    data:
      source_template      type ref to ltcl_src_tmplt_class_mod.

endclass.                    "ltcl_class_01 definition


class ltcl_class_modass_enabled implementation.

  method my_setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.

    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template           = source_template
                                                                   modification_mode_enabled = seox_true
                                                                   modification_tool_log     = tool_log
                                                                   is_valid_source_modification = is_valid_source_modification ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method test_save_public_section.
    constants:
      co_source_text_addition type string value '  constants co_abc type i value 3.'.
    data:
      exp_source    type rswsourcet,
      act_source    type rswsourcet,
      smodi_entries type smodi_tool_log_tab,
      smodi_entry   type smodi_tool_log_struct.

    smodi_entry-int_type  = 'INTF'.
    smodi_entry-operation = 'ALL'.
    smodi_entry-trkorr    = 'MO2K900749'.
    append smodi_entry to smodi_entries.

    data(tool_log) = ltcl_clm_tool_log_stub=>create_instance( smodi_entries = smodi_entries ).
    my_setup( tool_log = tool_log ).

    append_to exp_source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_SIMPLE_FAKE .',
        co_source_text_addition,
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .'.

    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 10 ).
    try.
        me->source_object->if_oo_clif_source~save( ).
        cl_aunit_assert=>fail(
              msg    =    'You allow to save changes in section NOT as modification'  ).
      catch cx_oo_source_save_failure.
        me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_false ).
        me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_false ).
        me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01' exp_modass_disabled = seox_false ).
    endtry.

  endmethod.                    "test_save_section_addition


  method test_save_method_impl.
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exp_source    type rswsourcet,
      act_source    type rswsourcet,
      smodi_entries type smodi_tool_log_tab,
      smodi_entry   type smodi_tool_log_struct.

    smodi_entry-int_type = 'PN'.
    smodi_entry-operation = 'MOD'.
    smodi_entry-trkorr = 'MO2K900749'.
    append smodi_entry to smodi_entries.

    data(tool_log) = ltcl_clm_tool_log_stub=>create_instance( smodi_entries = smodi_entries ).
    my_setup( tool_log = tool_log is_valid_source_modification = seox_false ).

    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 30 ).

    try.
        me->source_object->if_oo_clif_source~save( ).
        cl_aunit_assert=>fail(
          msg    =  'You allow to save changes in method NOT as modification'  ).
      catch cx_oo_source_save_failure.
        me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_false ).
        me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_false ).
        me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01'              exp_modass_disabled = seox_false ).
    endtry.

  endmethod.

  method test_save_method_impl_ok.
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exp_source    type rswsourcet,
      act_source    type rswsourcet,
      smodi_entries type smodi_tool_log_tab,
      smodi_entry   type smodi_tool_log_struct.

    smodi_entry-int_type = 'PN'.
    smodi_entry-operation = 'MOD'.
    smodi_entry-trkorr = 'MO2K900749'.
    append smodi_entry to smodi_entries.

    data(tool_log) = ltcl_clm_tool_log_stub=>create_instance( smodi_entries = smodi_entries ).
    my_setup( tool_log = tool_log is_valid_source_modification = seox_true ).

    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 31 ).

    try.
        me->source_object->if_oo_clif_source~save( ).
        me->persistence_fake->verify_modass_state_4_clif_def( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_false ).
        me->persistence_fake->verify_modass_state_4_method( method_name = 'IF_SIMPLE_FAKE~METH01' exp_modass_disabled = seox_false ).
        me->persistence_fake->verify_modass_state_4_method( method_name = 'METHOD01'              exp_modass_disabled = seox_false ).
      catch cx_oo_source_save_failure.
        cl_aunit_assert=>fail(
         msg =  'This was a valid METH change within mod. brackets, it should have been allowed'  ).
    endtry.

  endmethod.

endclass.

class ltcl_interface_modass definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    methods:
      setup.
    methods:
      test_save    for testing raising cx_static_check.
    data:
      source_template  type ref to ltcl_src_tmplt_interface.
endclass.                    "ltcl_class_01 definition


class ltcl_interface_modass implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template = source_template modification_mode_enabled = seox_true ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method test_save.
    constants:
      co_source_text_addition type string value '  constants co_abc type i value 3.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 4 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
        'interface IF_FAKE',
        '  public .',
        '',
        co_source_text_addition,
        '  constants CO_STATE_CURRENT type I value 0. "#EC NOTEXT',
        '  methods ARE_LOCAL_CHANGES_ALLOWED',
        '    returning',
        '      value(LOCAL_CHANGES) type ABAP_BOOL .',
        '  methods GET_BFUNC_SWITCH_ON_TIME',
        '    importing',
        '      !BFUNC type SFW_BFUNCTION',
        '    returning',
        '      value(SWITCH_ON_TIME) type SFW_TIMESTAMP .',
        'endinterface.'.
    me->source_object->if_oo_clif_source~get_source( importing source = act_source ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
    me->persistence_fake->verify_modass_state_4_intf( clif_name = me->source_template->class_key-clsname exp_modass_disabled = seox_true ).
  endmethod.

endclass.



class ltcl_class_pretty_print definition inheriting from ltcl_class_simple final for testing
  duration short
  risk level harmless.

  private section.
    methods:
      pretty_print_source_part for testing raising cx_static_check.
endclass.


class ltcl_class_pretty_print implementation.

  method pretty_print_source_part.
    " test pretty print implementation
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet,
      pos        type cl_source_scanner=>type_source_position.

    try.
        me->source_object->access_permission( seok_access_modify ).
      catch cx_oo_access_permission.
        cl_abap_unit_assert=>fail( 'error in access permission' ).
    endtry.
    me->source_object->read( ).

    me->remove_source_text( source_line = 31 ).
    me->add_source_text( source_text = |    ENDMETHOD.| source_line = 31 ).

    me->add_source_text( source_text = |write 'a'.| source_line = 30 ).
    me->add_source_text( source_text = |write: 'hugo'.| source_line = 31 ).

    pos-line = 31.
    pos-column = 1.
    try.
        me->source_object->pretty_print_source_part( source_position = pos ).
      catch cx_oo_clif_scan_error.
        cl_abap_unit_assert=>fail( 'Scan error during pretty print' ).
    endtry.
    try.
        me->source_object->if_oo_clif_source~save( ).
      catch cx_oo_source_save_failure.
        cl_abap_unit_assert=>fail( 'error in source save' ).
    endtry.

    append_to exp_source:
        'method if_simple_fake~meth01.',
        `  write 'a'.`,
        `  write: 'hugo'.`,
        `*  implem IF_SIMPLE_FAKE~METH01`,
        `endmethod.`.

    act_source = me->persistence_fake->get_method_source( 'IF_SIMPLE_FAKE~METH01' ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.

endclass.

*----------------------------------------------------------------------*
*       CLASS ltcl_class_exceptions DEFINITION
*       class ltcl_source_temp_package_fake definition
*
*----------------------------------------------------------------------*
class ltcl_class_exceptions definition for testing duration short risk level harmless.
  private section.
    methods:
      class_not_exists for testing.
endclass.                    "ltcl_class_exceptions definition

*----------------------------------------------------------------------*
*       class ltcl_class_exceptions implementation
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class ltcl_class_exceptions implementation.
  method class_not_exists.
    try.
        cl_oo_clif_source=>create_instance(
            clif_name = 'NOT_EXISTING_CLASS'
            settings  = cl_oo_clif_source_settings=>create_instance( )
        ).
        cl_abap_unit_assert=>fail( 'No exception has been raised' ).
      catch cx_oo_clif_not_exists.                      "#EC NO_HANDLER
    endtry.
  endmethod.                    "class_not_exists
endclass.                    "ltcl_class_exceptions implementation

class ltcl_persistence_lifecycle definition for testing duration medium risk level harmless.
  private section.
    methods access_permission_proxy_class for testing.
    methods access_permission_proxy_int for testing.
    data cut type ref to lcl_persistence_lifecycle.
endclass.

class ltcl_persistence_lifecycle implementation.
  method access_permission_proxy_class.
    " call access_permission and check that exception is raised for proxy classes
    data: clif_key type seoclskey,
          excp     type ref to cx_oo_access_permission,
          str_tab  type string_table.
    field-symbols <str> type string.
    " find a proxy class via select in vseoclass
    create object cut.
    select clsname up to 10 rows from vseoclass into table str_tab where clsproxy = abap_true.
    loop at str_tab assigning <str>.
      clif_key-clsname = <str>.
      try.
          cut->lif_persistence_lifecycle~access_permission( object_type = '' clif_key = clif_key access_mode = seok_access_modify ).
          cl_abap_unit_assert=>fail( msg = 'access permission exception not raised for proxy class.' ).
        catch cx_oo_access_permission into excp.
          cl_abap_unit_assert=>assert_equals( act = excp->if_t100_message~t100key-msgno exp = '631' ).
          cl_abap_unit_assert=>assert_equals( act = excp->if_t100_message~t100key-msgid exp = 'OO' ).
      endtry.
    endloop.
  endmethod.
  method access_permission_proxy_int.
    " call access_permission and check that exception is raised for proxy interface
    data: clif_key type seoclskey,
          excp     type ref to cx_oo_access_permission,
          str_tab  type string_table.
    field-symbols <str> type string.
    " find a proxy interface via select in vseoclass
    create object cut.
    select clsname up to 10 rows from vseointerf into table str_tab where clsproxy = abap_true.
    loop at str_tab assigning <str>.
      clif_key-clsname = <str>.
      try.
          cut->lif_persistence_lifecycle~access_permission( object_type = '' clif_key = clif_key access_mode = seok_access_modify ).
          cl_abap_unit_assert=>fail( msg = 'access permission exception not raised for proxy interface.' ).
        catch cx_oo_access_permission into excp.
          cl_abap_unit_assert=>assert_equals( act = excp->if_t100_message~t100key-msgno exp = '631' ).
          cl_abap_unit_assert=>assert_equals( act = excp->if_t100_message~t100key-msgid exp = 'OO' ).
      endtry.
    endloop.
  endmethod.
endclass.


class ltcl_src_tmplt_cs_simple definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.

class ltcl_src_tmplt_cs_simple implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_SIMPLE_FAKE'.
    me->implemented_interfaces = value #( ( 'IF_SIMPLE_FAKE' ) ).
    append_to me->source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_SIMPLE_FAKE .',
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .',
        'protected section.',
        '*"* protected components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        'private section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '',
        '  data ATT01 type I .',
        'ENDCLASS.',
        '',
        '',
        '',
        'CLASS CL_SIMPLE_FAKE IMPLEMENTATION.',
        '',
        '',
        'method IF_SIMPLE_FAKE~METH01.',
        '*  implem IF_SIMPLE_FAKE~METH01',
        'endmethod.',
        '',
        '',
        'method meth01.',
        '  p1 = ''TEST_WB''.',
        'endmethod.',
        'ENDCLASS.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 13 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 14 line_to = 16 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 17 line_to = 21 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_SIMPLE_FAKE~METH01' line_from = 29 line_to = 31 timestamp = '20091019171900' exposure = seoc_exposure_public ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'METH01' line_from = 34 line_to = 36 timestamp = '20091019171900' exposure = seoc_exposure_public ).
  endmethod.                    "constructor
endclass.



class ltcl_cs_include definition for testing risk level harmless duration short .
  private section.
    data:
      source_template  type ref to ltcl_src_tmplt_cs_simple,
      source_object    type ref to cl_oo_clif_source,
      persistence_fake type ref to ltcl_persistence_fake.
    methods:
      my_setup
        importing
          cs_include_available           type seox_boolean
          cs_include_timestamp           type xsddatetime_z optional
          version                        type r3state default if_oo_clif_source=>co_version_inactive
          has_class_inactive_source_part type seox_boolean default seox_true
          no_of_method_impls_in_cs       type i default 2.
    methods:
      test_read_from_cs              for testing,
      test_read_from_db              for testing,
      test_read_from_db_meth_deleted for testing,
      test_read_cs_not_existing      for testing,
      test_read_cs_not_existing_act  for testing,
      test_read_cs_not_existing_iact for testing,
      test_save_method_from_cs       for testing raising cx_static_check,
      test_save_method_from_db       for testing raising cx_static_check,
      test_save_if_not_locked        for testing raising cx_static_check,
      test_save_dummy_changes        for testing raising cx_static_check,
      test_import_cs_include for testing raising cx_static_check.
    methods:
      add_source_text
        importing
          source_text type string
          source_line type i.

endclass.                    "ltcl_class_01 definition

class cl_oo_clif_source definition local friends ltcl_cs_include.


class ltcl_cs_include implementation.

  method my_setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.

    create object me->source_template.
    if ( cs_include_available = seox_true ).
      me->source_template->add_cs_source_info( class_name = me->source_template->class_key-clsname timestamp = cs_include_timestamp no_of_method_impls_in_cs = no_of_method_impls_in_cs ).
    endif.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template = source_template enable_recording = seox_true has_class_inactive_source_part = has_class_inactive_source_part ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        version                 = version
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method test_read_from_cs.
*   set same timestamp as class has been changed (20091019171900)
    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20091019171900' ).

    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
    me->persistence_fake->verify_calls( ).
  endmethod.                    "test_read

  method test_read_from_db.
*   set timestamp to value before the class has been changed (< 20091019171900)
    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20080101000000' ).

    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CU' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CO' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CI' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM001' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM002' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
    me->persistence_fake->verify_calls( ).
  endmethod.

  method test_read_from_db_meth_deleted.
    " This test shall evaluate whether the data is read from database instead from
    " the CS-include if the timestamp is still valid, but the number of methods has been
    " changed due to a deletion of an interface method.
    " This deletion won't change the timestamp

    " set timestamp to value the class has been changed (20091019171900), but change
    " the number of method implementations, that are currently in CS-include
    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20091019171900' no_of_method_impls_in_cs = 3 ).

    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CU' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CO' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CI' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM001' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM002' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
    me->persistence_fake->verify_calls( ).
  endmethod.


  method test_read_cs_not_existing.
*   set timestamp to value before the class has been changed (< 20091019171900)
    me->my_setup( cs_include_available = seox_false ).

    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CU' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CO' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CI' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM001' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM002' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
    me->persistence_fake->verify_calls( ).
  endmethod.

  method test_read_cs_not_existing_act.
*   set timestamp to value before the class has been changed (< 20091019171900)
    me->my_setup( cs_include_available = seox_false version = if_oo_clif_source=>co_version_active ).

    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CU' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CO' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CI' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CM001' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CM002' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CS' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CP' version = if_oo_clif_source=>co_version_active ).
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
    me->persistence_fake->verify_calls( ).
  endmethod.

  method test_read_cs_not_existing_iact.
*   scenario: the inactive version is requested from the backend, but there is no inactive
*   version of any class part on the data base
*   => the active version must be read and cached in the cs-include
*   set timestamp to value before the class has been changed (< 20091019171900)
    me->my_setup( cs_include_available = seox_false version = if_oo_clif_source=>co_version_inactive has_class_inactive_source_part = seox_false ).

    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CU' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CO' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CI' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CM001' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CM002' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CS' version = if_oo_clif_source=>co_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CP' version = if_oo_clif_source=>co_version_active ).
    me->source_object->read( ).
    cl_aunit_assert=>assert_equals( exp = me->source_template->source act = me->source_object->source ).
    me->persistence_fake->verify_calls( ).
  endmethod.


  method test_save_method_from_cs.
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20091019171900' ).

    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CM001' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CS' ).
    me->source_object->if_oo_clif_source~lock( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 30 ).
    me->source_object->if_oo_clif_source~save( ).
    me->persistence_fake->verify_calls( ).
  endmethod.                    "test_save_method_addition

  method test_save_method_from_db.
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

*   set timestamp to value before the class has been changed (< 20091019171900)
    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20080101000000' ).

    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CU' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CO' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CI' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM001' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CM002' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CM001' ).
    me->persistence_fake->rec_insert_report( 'CL_SIMPLE_FAKE================CS' ).
    me->source_object->if_oo_clif_source~lock( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 30 ).
    me->source_object->if_oo_clif_source~save( ).
    me->persistence_fake->verify_calls( ).
  endmethod.                    "test_save_method_addition

  method test_save_if_not_locked.
    " test whether anything is stored when no lock has been set
    constants:
      co_source_text_addition type string value '  write: ''ABC''.'.
    data:
      exception               type ref to cx_oo_source_save_failure.

    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20091019171900' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CS' ).
    me->persistence_fake->rec_read_report( 'CL_SIMPLE_FAKE================CP' ).
    me->add_source_text( source_text = co_source_text_addition source_line = 30 ).
    try.
        me->source_object->if_oo_clif_source~save( ).
        cl_abap_unit_assert=>fail( 'Exception NOT_LOCKED has not been raised' ).
      catch cx_oo_source_save_failure into exception.
        cl_abap_unit_assert=>assert_equals( exp = cx_oo_source_save_failure=>not_locked act = exception->if_t100_message~t100key ).
    endtry.
    me->persistence_fake->verify_calls( ).
  endmethod.

  method test_save_dummy_changes.
    " If no section or method implementation is changed and there is
    " no further object inactive in the main source,
    " only the CS-include shall be updated in the active version
    data:
      act_source type rswsourcet.

    me->my_setup(
      cs_include_available = seox_true
      cs_include_timestamp = '20091019171900'
      has_class_inactive_source_part = seox_false ).

    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CS' version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CP' version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_insert_report(
        include_name = 'CL_SIMPLE_FAKE================CS'
        version      = lif_source_part=>c_version_active ).
    me->source_object->if_oo_clif_source~lock( ).
    " add an empty line before the fist method implementation
    me->add_source_text( source_text = '' source_line = 28 ).
    me->source_object->if_oo_clif_source~save( ).
    me->persistence_fake->verify_calls( ).
  endmethod.


  method test_import_cs_include.
*   set timestamp to value the class has been changed (20091019171900)
    me->my_setup( cs_include_available = seox_true cs_include_timestamp = '20091019171900' version = lif_source_part=>c_version_active ).

    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CS' version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_read_report( include_name = 'CL_SIMPLE_FAKE================CP' version = lif_source_part=>c_version_active ).

    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CU'    version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CO'    version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CI'    version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CM001' version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CM002' version = lif_source_part=>c_version_active ).
    me->persistence_fake->rec_insert_report( include_name = 'CL_SIMPLE_FAKE================CS'    version = lif_source_part=>c_version_active ).

    me->source_object->lock( ).
    me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
    me->source_object->import( ).
    me->source_object->unlock( ).
    me->persistence_fake->verify_calls( ).
  endmethod.                    "test_save_method_addition



  method add_source_text.
    insert source_text into me->source_template->source index source_line.
    me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
  endmethod.




endclass.

class ltcl_src_tmplt_incomplete definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.

class ltcl_src_tmplt_incomplete implementation.

  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_SIMPLE_FAKE'.
    append_to me->source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        '  public section.',
        '    data attr type i.',
        '  protected section.',
        '  private section.',
        'ENDCLASS.',
        '',
        'CLASS CL_SIMPLE_FAKE IMPLEMENTATION.',
        '',
        'ENDCLASS.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1 line_to = 6 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 7 line_to = 7 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 8 line_to = 8 timestamp = '20091019171900' ).
  endmethod.                    "constructor
endclass.


class ltcl_incomplete_source definition for testing risk level harmless duration short .
  private section.
    methods:
      setup.
    methods:
      save_fails for testing.
    data:
      source_template  type ref to ltcl_src_tmplt_class_simple,
      source_object    type ref to cl_oo_clif_source,
      persistence_fake type ref to ltcl_persistence_fake.
    methods:
      add_source_text
        importing
          source_text type string
          source_line type i.
endclass.                    "ltcl_class_01 definition

class cl_oo_clif_source definition local friends ltcl_incomplete_source.
class ltcl_incomplete_source implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to ltcl_pos_index_helper.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup

  method save_fails.
    try.
        me->add_source_text( source_text = 'meth a' source_line = 6 ).
        me->source_object->save( ).
        cl_abap_unit_assert=>fail( ).
      catch cx_oo_source_save_failure.                  "#EC NO_HANDLER
        "expected
    endtry.

  endmethod.

  method add_source_text.
    insert source_text into me->source_template->source index source_line.
    me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
  endmethod.
endclass.


class ltcl_src_tmplt_unknown_comment definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.

class ltcl_src_tmplt_unknown_comment implementation.

  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_SIMPLE_FAKE'.
    append_to me->source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '  public section.',
        '*"* protected components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '  protected section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '  private section.',
        '    methods:',
        '      m1,',
        '      m2,',
        '      m3.',
        'ENDCLASS.',
        '',
        '',
        '',
        'CLASS CL_SIMPLE_FAKE IMPLEMENTATION.',
        '',
        '',
        '  " some comment that should be',
        '  " within method implementation',
        '  method m1.',
        '  endmethod.',
        '',
        '',
        '  method m2.',
        '  endmethod. "m2' ,
        '',
        '  " some comment that should be',
        '  " within method implementation',
        '',
        '',
        '  method m3.',
        '  endmethod.',
        '',                "<-- This empty line is part of the method implementation include for method M3!!!
        'ENDCLASS.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 7  timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 8  line_to = 10 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 11 line_to = 17 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'M1' line_from = 25 line_to = 28 timestamp = '20091019171900' exposure    = seoc_exposure_private ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'M2' line_from = 31 line_to = 35 timestamp = '20091019171900' exposure    = seoc_exposure_private ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'M3' line_from = 38 line_to = 40 timestamp = '20091019171900' exposure    = seoc_exposure_private ).
  endmethod.                    "constructor
endclass.

class ltcl_comment_out_of_bounds definition for testing risk level harmless duration short .
  private section.
    methods:
      setup.
    methods:
      get_public_section for testing,
      get_protected_section for testing raising cx_static_check,
      get_private_section for testing raising cx_static_check,
      comment_before_method_impl for testing raising cx_static_check,
      comment_after_method_impl for testing raising cx_static_check,
      empty_lines_after_method_impl for testing raising cx_static_check.
    data:
      source_template  type ref to ltcl_src_tmplt_unknown_comment,
      source_object    type ref to cl_oo_clif_source,
      persistence_fake type ref to ltcl_persistence_fake,
      scanner          type ref to cl_oo_source_scanner_class.

endclass.                    "ltcl_class_01 definition

class cl_oo_clif_source definition local friends ltcl_comment_out_of_bounds.
class ltcl_comment_out_of_bounds implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to ltcl_pos_index_helper.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
    me->source_object->read( ).
    scanner ?= me->source_object->get_scanner( ).
  endmethod.                    "setup

  method get_public_section.
    data:
      exp_source_interval type cl_oo_source_scanner=>type_source_interval,
      act_source_interval type cl_oo_source_scanner=>type_source_interval,
      exp_source          type rswsourcet,
      act_source          type rswsourcet.

    exp_source_interval-begin-line   = 1.
    exp_source_interval-begin-column = 0.
    exp_source_interval-end-line   = 8.
    exp_source_interval-end-column = 0.
    act_source_interval = me->scanner->get_public_section_interval( ).
    cl_abap_unit_assert=>assert_equals( msg = 'Section interval is incorrect' exp = exp_source_interval act = act_source_interval ).

    append_to exp_source:
        'class CL_SIMPLE_FAKE definition',
        '  public',
        '  create public .',
        '',
        '*"* public components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '  public section.'.
    act_source = me->scanner->get_public_section_source( ).
    cl_abap_unit_assert=>assert_equals( msg = 'Section source is incorrect' exp = exp_source act = act_source ).
  endmethod.

  method get_protected_section.
    data:
      exp_source_interval type cl_oo_source_scanner=>type_source_interval,
      act_source_interval type cl_oo_source_scanner=>type_source_interval,
      exp_source          type rswsourcet,
      act_source          type rswsourcet.

    exp_source_interval-begin-line   = 8.
    exp_source_interval-begin-column = 0.
    exp_source_interval-end-line   = 11.
    exp_source_interval-end-column = 0.
    act_source_interval = me->scanner->get_protected_section_interval( ).
    cl_abap_unit_assert=>assert_equals( msg = 'Section interval is incorrect' exp = exp_source_interval act = act_source_interval ).

    append_to exp_source:
        '  protected section.',
        '*"* protected components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!'.
    act_source = me->scanner->get_protected_section_source( ).
    cl_abap_unit_assert=>assert_equals( msg = 'Section source is incorrect' exp = exp_source act = act_source ).
  endmethod.

  method get_private_section.
    data:
      exp_source_interval type cl_oo_source_scanner=>type_source_interval,
      act_source_interval type cl_oo_source_scanner=>type_source_interval,
      exp_source          type rswsourcet,
      act_source          type rswsourcet.

    exp_source_interval-begin-line   = 11.
    exp_source_interval-begin-column = 0.
    exp_source_interval-end-line   = 18.
    exp_source_interval-end-column = 0.
    act_source_interval = me->scanner->get_private_section_interval( ).
    cl_abap_unit_assert=>assert_equals( msg = 'Section interval is incorrect' exp = exp_source_interval act = act_source_interval ).

    append_to exp_source:
        '  private section.',
        '*"* private components of class CL_SIMPLE_FAKE',
        '*"* do not include other source files here!!!',
        '    methods:',
        '      m1,',
        '      m2,',
        '      m3.'.
    act_source = me->scanner->get_private_section_source( ).
    cl_abap_unit_assert=>assert_equals( msg = 'Section source is incorrect' exp = exp_source act = act_source ).
  endmethod.

  method comment_before_method_impl.
    data:
      exp_source_interval type cl_oo_source_scanner=>type_source_interval,
      act_source_interval type cl_oo_source_scanner=>type_source_interval,
      exp_source          type rswsourcet,
      act_source          type rswsourcet.

    exp_source_interval-begin-line   = 25.
    exp_source_interval-begin-column = 0.
    exp_source_interval-end-line   = 28.
    exp_source_interval-end-column = 12.
    act_source_interval = me->scanner->get_method_impl_interval( method_name = 'M1' ).
    cl_abap_unit_assert=>assert_equals( msg = 'Method implementation interval is incorrect' exp = exp_source_interval act = act_source_interval ).

    append_to exp_source:
        '  method m1.',
        '  " some comment that should be',
        '  " within method implementation',
        '  endmethod.'.
    act_source = me->scanner->get_method_impl_source( method_name = 'M1'  ).
    cl_abap_unit_assert=>assert_equals( msg = 'Method implementation is incorrect' exp = exp_source act = act_source ).
  endmethod.

  method comment_after_method_impl.
    data:
      exp_source_interval type cl_oo_source_scanner=>type_source_interval,
      act_source_interval type cl_oo_source_scanner=>type_source_interval,
      exp_source          type rswsourcet,
      act_source          type rswsourcet.

    exp_source_interval-begin-line   = 31.
    exp_source_interval-begin-column = 0.
    exp_source_interval-end-line   = 35.
    exp_source_interval-end-column = 16.
    act_source_interval = me->scanner->get_method_impl_interval( method_name = 'M2' ).
    cl_abap_unit_assert=>assert_equals( msg = 'Method implementation interval is incorrect' exp = exp_source_interval act = act_source_interval ).

    append_to exp_source:
        '  method m2.',
        '',
        '  " some comment that should be',
        '  " within method implementation',
        '  endmethod. "m2'.
    act_source = me->scanner->get_method_impl_source( method_name = 'M2'  ).
    cl_abap_unit_assert=>assert_equals( msg = 'Method implementation is incorrect' exp = exp_source act = act_source ).
  endmethod.

  method empty_lines_after_method_impl.
    data:
      exp_source_interval type cl_oo_source_scanner=>type_source_interval,
      act_source_interval type cl_oo_source_scanner=>type_source_interval,
      exp_source          type rswsourcet,
      act_source          type rswsourcet.

    exp_source_interval-begin-line   = 38.
    exp_source_interval-begin-column = 0.
    exp_source_interval-end-line   = 39.
    exp_source_interval-end-column = 12.
    act_source_interval = me->scanner->get_method_impl_interval( method_name = 'M3' ).
    cl_abap_unit_assert=>assert_equals( msg = 'Method implementation interval is incorrect' exp = exp_source_interval act = act_source_interval ).

    append_to exp_source:
        '  method m3.',
        '  endmethod. '.
    act_source = me->scanner->get_method_impl_source( method_name = 'M3'  ).
    cl_abap_unit_assert=>assert_equals( msg = 'Method implementation is incorrect' exp = exp_source act = act_source ).
  endmethod.

endclass.


"------------------------------------------------------------------
" test persistence_facade for versioning
"------------------------------------------------------------------


class ltcl_persistence_for_versioing definition for testing duration medium risk level harmless.
  public section.
    methods read_class_source_with_stub for testing.
endclass.

class ltcl_persistence_for_versioing implementation.
  method read_class_source_with_stub.
    data clif_source type ref to cl_oo_clif_source.
    data src_stub type ref to cl_oo_clif_src_persist_stub.
    data method_includes type cl_oo_clif_src_persist_stub=>t_class_includes.
    data method_include type cl_oo_clif_src_persist_stub=>class_include_w_source.
    data source type rswsourcet.

    "method1
    method_include-cpdkey-clsname = 'meier'.
    method_include-cpdkey-cpdname = 'method1'.
    method_include-include_name = 'meier====cm01'.
    free source.
    append 'method method1.' to  source.
    append ' "methode 1 ' to  source.
    append ' data c type i. ' to source.
    append 'endmethod.' to source.
    method_include-source = source.
    insert method_include into table method_includes.

    "method3
    method_include-cpdkey-clsname = 'meier'.
    method_include-cpdkey-cpdname = 'method3'.
    method_include-include_name = 'meier====cm03'.
    free source.
    append 'method method3.' to  source.
    append ' "methode 3 ' to  source.
    append ' data sdvc type i. ' to source.
    append 'endmethod.' to source.
    method_include-source = source.
    insert method_include into table method_includes.

    "method2
    method_include-cpdkey-clsname = 'meier'.
    method_include-cpdkey-cpdname = 'method2'.
    method_include-include_name = 'meier====cm02'.
    free source.
    append 'method method2.' to  source.
    append ' "methode 2 ' to  source.
    append ' data aaaa type i. ' to source.
    append 'endmethod.' to source.
    method_include-source = source.
    insert method_include into table method_includes.

    "public section
    method_include-cpdkey-clsname = 'meier'.
    method_include-cpdkey-cpdname = 'public section'.
    method_include-include_name = 'meier=========================CU'.
    free source.
    append 'class meier definition.' to source.
    append 'public section.' to source.
    append 'data q type i.' to source.
    method_include-source = source.
    insert method_include into table method_includes.


    create object src_stub
      exporting
        class_includes_w_source = method_includes.

    cl_oo_clif_source=>create_instance(
      exporting
        clif_name          = 'meier'
        settings           = cl_oo_clif_source_settings=>create_instance( )
        source_persistence = src_stub
        metadata_persistence = src_stub
      receiving
        result             = clif_source
    ).
    clif_source->get_source(
      importing
        source = source
    ).

    cl_abap_unit_assert=>assert_equals( exp = abap_true act = xsdbool( lines( source ) > 0 ) ).

  endmethod.
endclass.

class ltcl_oo_classname_service definition final for testing
  duration long
  risk level harmless.

  private section.
    methods:
      get_method_include for testing raising cx_static_check.
endclass.


class ltcl_oo_classname_service implementation.

  method get_method_include.
    data:
      tmdir                  type standard table of tmdir,
      method_key             type seomtdkey,
      exp_method_include     type progname,
      act_method_include     type progname,
      max_numbers_of_entries type i,
      current_entry          type i.
    field-symbols:
      <tmdir> type tmdir.

    select * from tmdir into table tmdir up to 500 rows.
    max_numbers_of_entries = lines( tmdir ).
    loop at tmdir assigning <tmdir>.
      if ( <tmdir>-methodindx > 46656 ).
        continue.
      endif.
      current_entry = sy-tabix.
      method_key-clsname = <tmdir>-classname.
      method_key-mtdname = <tmdir>-methodname.
      cl_oo_classname_service=>get_method_include(
        exporting
          mtdkey = method_key
        receiving
          result = exp_method_include
        exceptions
          others = 1 ).
      if ( sy-subrc <> 0 ).
        continue.
      endif.
      act_method_include = lcl_oo_classname_service=>get_method_include( method_key ).
      cl_abap_unit_assert=>assert_equals(
        exporting
          exp                  = exp_method_include
          act                  = act_method_include
          msg                  = |{ method_key-clsname }=>{ method_key-mtdname } (entry { current_entry }/{ max_numbers_of_entries })|
      ).
    endloop.
  endmethod.
endclass.


class ltcl_get_includes definition final for testing
  duration short
  risk level harmless.

  private section.
    data source_template type ref to ltcl_source_template_01.
    data persistence_fake type ref to ltcl_persistence_fake.
    data source_object type ref to cl_oo_clif_source.
    data scanner type ref to cl_oo_source_scanner_class.
    data act_includes type sreptab.
    data exp_source_pool type rswsourcet.
    data exp_source_public type rswsourcet.
    data exp_source_protected type rswsourcet.
    data exp_source_private type rswsourcet.
    data exp_source_method1 type rswsourcet.
    data exp_source_method2 type rswsourcet.
    methods:
      setup,
      verify_include_contained
        importing
          include_name type progname
          source       type rswsourcet,
      get_syntax_check_includes for testing raising cx_static_check,
      get_includes for testing raising cx_static_check.
endclass.

class cl_oo_clif_source definition local friends ltcl_get_includes.
class ltcl_get_includes implementation.


  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to ltcl_pos_index_helper.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
    me->source_object->read( ).
    scanner ?= me->source_object->get_scanner( ).

    append_to exp_source_public:
        'class CL_WB_AU_TEMPLATE_001 definition',
        '  public',
        '  create public .',
        '',
        'public section.',
        '*"* public components of class CL_WB_AU_TEMPLATE_001',
        '*"* do not include other source files here!!!',
        '',
        '  interfaces IF_WB_AU_TEMPLATE_001 .',
        '',
        '  methods METH01',
        '    changing',
        '      !P1 type C .'.
    append_to exp_source_protected:
        'protected section.',
        '*"* protected components of class CL_WB_AU_TEMPLATE_001',
        '*"* do not include other source files here!!!'.
    append_to exp_source_private:
        'private section.',
        '*"* private components of class CL_WB_AU_TEMPLATE_001',
        '*"* do not include other source files here!!!',
        '',
        '  data ATT01 type I .'.
    append_to exp_source_method1:
      'method IF_WB_AU_TEMPLATE_001~METH01.',
      '*  implem IF_WB_AU_TEMPLATE_001~METH01',
      'endmethod.'.
    append_to exp_source_method2:
      'method meth01.',
      '  p1 = ''TEST_WB''.',
      'endmethod.'.
    append_to exp_source_pool:
      'class-pool .                                   ',
      '*"* class pool for class CL_WB_AU_TEMPLATE_001 ',
      '                                               ',
      '*"* local type definitions                     ',
      'include CL_WB_AU_TEMPLATE_001=========ccdef.   ',
      '                                               ',
      '*"* class CL_WB_AU_TEMPLATE_001 definition     ',
      '*"* public declarations                        ',
      'include CL_WB_AU_TEMPLATE_001=========cu.      ',
      '*"* protected declarations                     ',
      'include CL_WB_AU_TEMPLATE_001=========co.      ',
      '*"* private declarations                       ',
      'include CL_WB_AU_TEMPLATE_001=========ci.      ',
      'endclass. "CL_WB_AU_TEMPLATE_001 definition    ',
      '                                               ',
      '*"* macro definitions                          ',
      'include CL_WB_AU_TEMPLATE_001=========ccmac.   ',
      '*"* local class implementation                 ',
      'include CL_WB_AU_TEMPLATE_001=========ccimp.   ',
      '                                               ',
      '*"* test class                                 ',
      'include CL_WB_AU_TEMPLATE_001=========ccau.    ',
      '                                               ',
      'class CL_WB_AU_TEMPLATE_001 implementation.    ',
      '',
      '',
      '* <SIGNATURE>---------------------------------------------------------------------------------------+',
      '* | Instance Public Method CL_WB_AU_TEMPLATE_001->IF_WB_AU_TEMPLATE_001~METH01',
      '* +-------------------------------------------------------------------------------------------------+',
      '* | [--->] P1                             TYPE        I',
      '* +--------------------------------------------------------------------------------------</SIGNATURE>'.
    append lines of exp_source_method1 to exp_source_pool.
    append_to exp_source_pool:
      '',
      '',
      '* <SIGNATURE>---------------------------------------------------------------------------------------+',
      '* | Instance Public Method CL_WB_AU_TEMPLATE_001->METH01',
      '* +-------------------------------------------------------------------------------------------------+',
      '* | [<-->] P1                             TYPE        C',
      '* +--------------------------------------------------------------------------------------</SIGNATURE>'.
    append lines of exp_source_method2 to exp_source_pool.
    append_to exp_source_pool:
      'ENDCLASS.'.
  endmethod.

  method get_syntax_check_includes.
    act_includes = me->source_object->get_syntax_check_includes( ).
    cl_abap_unit_assert=>assert_equals( exp = 4 act = lines( act_includes ) ).

    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CP' source = exp_source_pool ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CU' source = exp_source_public ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CO' source = exp_source_protected ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CI' source = exp_source_private ).
  endmethod.


  method get_includes.
    data:
      exp_source type rswsourcet.
    act_includes = me->source_object->get_includes( ).
    cl_abap_unit_assert=>assert_equals( exp = 5 act = lines( act_includes ) ).

    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CU' source = exp_source_public ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CO' source = exp_source_protected ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CI' source = exp_source_private ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CM001' source = exp_source_method1 ).
    me->verify_include_contained( include_name = 'CL_WB_AU_TEMPLATE_001=========CM002' source = exp_source_method2 ).

  endmethod.


  method verify_include_contained.
    data: act_include like line of act_includes.

    read table act_includes with key name = include_name into act_include.

    cl_abap_unit_assert=>assert_subrc( msg = |include { include_name } not found.| exp = 0 ).
    cl_abap_unit_assert=>assert_equals( msg = |Source for include { include_name } is not correct.| exp = source act = act_include-source->* ).
  endmethod.

endclass.

class ltcl_lock_source_part definition final for testing
  duration short
  risk level harmless.

  private section.
    data source_template type ref to ltcl_source_template_01.
    data persistence_fake type ref to ltcl_persistence_fake.
    data source_object type ref to cl_oo_clif_source.
    methods:
      setup,
      public_section for testing raising cx_static_check,
      wrong_source_position for testing raising cx_static_check.
endclass.

class cl_oo_clif_source definition local friends ltcl_lock_source_part.
class ltcl_lock_source_part implementation.

  method setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to ltcl_pos_index_helper.


    create object me->source_template.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
    me->source_object->read( ).
  endmethod.

  method public_section.
    data:
      source_position type cl_source_scanner=>type_source_position.

    source_position-line = 1.
    source_position-column = 1.
    cl_abap_unit_assert=>assert_equals( msg = 'Source part not locked correctly' exp = seox_false act = me->source_object->is_source_part_locked( source_position = source_position ) ).
    me->source_object->lock_source_part( source_position = source_position  ).
    cl_abap_unit_assert=>assert_equals( msg = 'Source part not locked correctly' exp = seox_true act = me->source_object->is_source_part_locked( source_position = source_position ) ).
    me->source_object->unlock_source_part( source_position = source_position  ).
    cl_abap_unit_assert=>assert_equals( msg = 'Source part not locked correctly' exp = seox_false act = me->source_object->is_source_part_locked( source_position = source_position ) ).
  endmethod.

  method wrong_source_position.
    data:
      source_position type cl_source_scanner=>type_source_position.

    source_position-line = 27.
    source_position-column = 1.
    try.
        me->source_object->is_source_part_locked( source_position = source_position ).
        cl_abap_unit_assert=>fail( msg = 'Exception has not been raised.' ).
      catch cx_oo_invalid_source_position ##no_handler.
        "expected.
    endtry.
  endmethod.


endclass.



class ltcl_src_tmplt_exception_class definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.

class ltcl_src_tmplt_exception_class implementation.

  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CX_SIMPLE_FAKE'.
    append_to me->source:
      'class CX_SIMPLE_FAKE definition                           ',
      '  public                                                        ',
      '  inheriting from cx_static_check                               ',
      '  final                                                         ',
      '  create public .                                               ',
      '  public section.                                               ',
      '    interfaces if_t100_message .                                ',
      '    methods constructor                                         ',
      '      importing                                                 ',
      '        !textid   like if_t100_message=>t100key optional        ',
      '        !previous like previous optional .                      ',
      '  protected section.                                            ',
      '  private section.                                              ',
      'endclass.                                                       ',
      '                                                                ',
      'class CX_SIMPLE_FAKE implementation.                      ',
      '  method constructor.                 ',
      '    call method super->constructor                              ',
      '      exporting                                                 ',
      '        previous = previous.                                    ',
      '    clear me->textid.                                           ',
      '    if textid is initial.                                       ',
      '      if_t100_message~t100key = if_t100_message=>default_textid.',
      '    else.                                                       ',
      '      if_t100_message~t100key = textid.                         ',
      '    endif.                                                      ',
      '  endmethod.                                                    ',
      'endclass.                                                       '.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 11  timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 12  line_to = 12 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 13 line_to = 13 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'CONSTRUCTOR'         line_from = 17 line_to = 27 timestamp = '20091019171900' exposure    = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20091019171900' no_of_method_impls_in_cs = 1 ).
  endmethod.                    "constructor
endclass.


class ltcl_src_tmplt_class_w_pragma definition inheriting from ltcl_source_template
                                           for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.

class ltcl_src_tmplt_class_w_pragma implementation.

  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CX_SIMPLE_FAKE'.
    append_to me->source:
      'class CX_SIMPLE_FAKE definition public                          ',
      '  inheriting from cx_static_check                               ',
      '  final                                                         ',
      '  create public .                                               ',
      '  public section.                                               ',
      '    interfaces if_t100_message .                                ',
      '    methods constructor                                         ',
      '      importing                                                 ',
      '        !textid   like if_t100_message=>t100key optional        ',
      '        !previous like previous optional .                      ',
      '  protected section.                                            ',
      '  private section.                                              ',
      'endclass.                                                       ',
      '                                                                ',
      'class CX_SIMPLE_FAKE implementation.                      ',
      '  method constructor ##ADT_SUPPRESS_GENERATION.                 ',
      '  endmethod.                                                    ',
      'endclass.                                                       '.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 10  timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 11  line_to = 11 timestamp = '20091019171900' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 12 line_to = 12 timestamp = '20091019171900' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'CONSTRUCTOR'         line_from = 16 line_to = 17 timestamp = '20091019171900' exposure    = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20091019171900' no_of_method_impls_in_cs = 1 ).
  endmethod.                    "constructor
endclass.


class ltcl_exception_class_fake definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    methods:
      my_setup
        importing
          is_exception_class type seox_boolean.
    methods:
      save_constructor       for testing raising cx_static_check,
      change_to_no_exception_class for testing raising cx_static_check.
    data:
      source_template  type ref to ltcl_source_template.
endclass.                    "ltcl_class_01 definition


class ltcl_exception_class_fake implementation.

  method my_setup.
    data:
      persistence_facade    type ref to lcl_persistence_facade,
      settings              type ref to cl_oo_clif_source_settings,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.

    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template    = source_template
                                                                   is_exception_class = is_exception_class
                                                                   super_class_name   = 'CX_STATIC_CHECK' ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    create object pos_index_helper_stub type ltcl_pos_index_helper.
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup


  method save_constructor.
    constants:
      co_source_text_addition type string value '*  Some change'.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    create object me->source_template type ltcl_src_tmplt_exception_class.
    me->my_setup( is_exception_class = seox_true ).
    me->source_object->lock( ).
    me->source_object->read( ).
    me->add_source_text( source_text = co_source_text_addition source_line = 18 ).
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
      '  method constructor. ##ADT_SUPPRESS_GENERATION                ',
      co_source_text_addition,
      '    call method super->constructor                              ',
      '      exporting                                                 ',
      '        previous = previous.                                    ',
      '    clear me->textid.                                           ',
      '    if textid is initial.                                       ',
      '      if_t100_message~t100key = if_t100_message=>default_textid.',
      '    else.                                                       ',
      '      if_t100_message~t100key = textid.                         ',
      '    endif.                                                      ',
      '  endmethod.                                                    '.
    act_source = me->persistence_fake->get_method_source( 'CONSTRUCTOR' ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
    cl_aunit_assert=>assert_equals( exp = seox_true act = me->persistence_fake->reset_generation_flag_called ).

    "Check whether cs include was adapted
    clear exp_source.
    append_to exp_source:
      'class CX_SIMPLE_FAKE definition                           ',
      '  public                                                        ',
      '  inheriting from cx_static_check                               ',
      '  final                                                         ',
      '  create public .                                               ',
      '  public section.                                               ',
      '    interfaces if_t100_message .                                ',
      '    methods constructor                                         ',
      '      importing                                                 ',
      '        !textid   like if_t100_message=>t100key optional        ',
      '        !previous like previous optional .                      ',
      '  protected section.                                            ',
      '  private section.                                              ',
      'endclass.                                                       ',
      '                                                                ',
      'class CX_SIMPLE_FAKE implementation.                      ',
      '  method constructor. ##ADT_SUPPRESS_GENERATION                ',
      co_source_text_addition,
      '    call method super->constructor                              ',
      '      exporting                                                 ',
      '        previous = previous.                                    ',
      '    clear me->textid.                                           ',
      '    if textid is initial.                                       ',
      '      if_t100_message~t100key = if_t100_message=>default_textid.',
      '    else.                                                       ',
      '      if_t100_message~t100key = textid.                         ',
      '    endif.                                                      ',
      '  endmethod.                                                    ',
      'endclass.                                                       '.
    act_source = me->persistence_fake->get_source( cl_oo_classname_service=>get_cs_name( me->source_template->class_key-clsname ) ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.


  method change_to_no_exception_class.
    data:
      exp_source type rswsourcet,
      act_source type rswsourcet.

    create object me->source_template type ltcl_src_tmplt_class_w_pragma.
    me->my_setup( is_exception_class = seox_true ).
    me->source_object->lock( ).
    me->source_object->read( ).
    " Remove inheritance from class (means: class is no longer an exception class)
    me->remove_source_text( source_line = 2 ).
    me->persistence_fake->set_is_exception_class( seox_false ).
    me->persistence_fake->set_super_class_name( '' ).
    " Save class
    me->source_object->if_oo_clif_source~save( ).
    append_to exp_source:
      '  method constructor.             ',
      '  endmethod.                                                    '.
    act_source = me->persistence_fake->get_method_source( 'CONSTRUCTOR' ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
    cl_aunit_assert=>assert_equals( exp = seox_true act = me->persistence_fake->reset_generation_flag_called ).

    "Check whether cs include was adapted
    clear exp_source.
    append_to exp_source:
      'class CX_SIMPLE_FAKE definition public                          ',
      '  final                                                         ',
      '  create public .                                               ',
      '  public section.                                               ',
      '    interfaces if_t100_message .                                ',
      '    methods constructor                                         ',
      '      importing                                                 ',
      '        !textid   like if_t100_message=>t100key optional        ',
      '        !previous like previous optional .                      ',
      '  protected section.                                            ',
      '  private section.                                              ',
      'endclass.                                                       ',
      '                                                                ',
      'class CX_SIMPLE_FAKE implementation.                      ',
      '  method constructor. ',
      '  endmethod.                                                    ',
      'endclass.                                                       '.
    act_source = me->persistence_fake->get_source( cl_oo_classname_service=>get_cs_name( me->source_template->class_key-clsname ) ).
    cl_aunit_assert=>assert_equals( exp = exp_source act = act_source ).
  endmethod.

endclass.


class ltcl_sort_methods_by_pos_index definition inheriting from ltcl_class_base for testing risk level harmless duration short .
  private section.
    data:
      source_template       type ref to ltcl_source_template,
      pos_index_helper_stub type ref to if_oo_source_pos_index_helper.
    methods:
      my_setup importing has_class_inactive_source_part type seox_boolean default seox_true,
      get_exp_source returning value(result) type rswsourcet.
    methods:
      sort_by_Active_if_no_inactive for testing raising cx_static_check,
      put_new_method_to_end_of_file for testing raising cx_static_check.
endclass.                    "ltcl_class_01 definition


class ltcl_sort_methods_by_pos_index implementation.

  method my_setup.
    data:
      persistence_facade type ref to lcl_persistence_facade,
      settings           type ref to cl_oo_clif_source_settings.

    create object me->source_template type ltcl_src_tmplt_cs_simple.
    me->persistence_fake = ltcl_persistence_fake=>create_instance( source_template = source_template has_class_inactive_source_part = has_class_inactive_source_part ).
    settings = cl_oo_clif_source_settings=>create_instance( ).
    pos_index_helper_stub ?= cl_abap_testdouble=>create( 'IF_OO_SOURCE_POS_INDEX_HELPER' ).
    create object me->source_object
      exporting
        clif_name               = me->source_template->class_key-clsname
        persistence             = me->persistence_fake
        settings                = settings
        signature_provider      = me->persistence_fake
        pretty_printer_settings = ltcl_pp_settings_stub=>create_instance( )
        pos_index_helper        = pos_index_helper_stub.
  endmethod.                    "setup


  method sort_by_active_if_no_inactive."sort by active index if no inactive index is available
    me->my_setup( abap_true ).

    data(include_if_simple_fake_meth01) = |{ me->source_template->class_key-clsname width = 30 pad = '=' }CM001|.
    data(include_meth01) = |{ me->source_template->class_key-clsname width = 30 pad = '=' }CM002|.
    data(source_pos_index) = value if_oo_source_pos_index_helper=>source_pos_index_tab(
      ( include_name = include_if_simple_fake_meth01 start_line = 33 )"IF_SIMPLE_FAKE~METH01
      ( include_name = include_meth01 start_line = 28 )"METH01
    ).
    cl_abap_testdouble=>configure_call( pos_index_helper_stub )->returning( value if_oo_source_pos_index_helper=>source_pos_index_tab( ) )->and_expect( )->is_called_once( ).
    pos_index_helper_stub->get_source_pos_index_for_class( class_name = me->source_template->class_key-clsname version = 'I' ).
    cl_abap_testdouble=>configure_call( pos_index_helper_stub )->returning( source_pos_index )->and_expect( )->is_called_once( ).
    pos_index_helper_stub->get_source_pos_index_for_class( class_name = me->source_template->class_key-clsname version = 'A' ).

    me->source_object->if_oo_clif_source~get_source( importing source = data(act_source) ).

    cl_aunit_assert=>assert_equals( exp = me->get_exp_source( ) act = act_source ).
    cl_abap_testdouble=>verify_expectations( pos_index_helper_stub ).
  endmethod.


  method put_new_method_to_end_of_file.
    me->my_setup( abap_true ).

    data(include_meth01) = |{ me->source_template->class_key-clsname width = 30 pad = '=' }CM002|.
    data(source_pos_index) = value if_oo_source_pos_index_helper=>source_pos_index_tab(
      ( include_name = include_meth01 start_line = 28 )"METH01
    ).                                                 "IF_SIMPLE_FAKE~METH01 not in pos_index -> method is new
    cl_abap_testdouble=>configure_call( pos_index_helper_stub )->returning( value if_oo_source_pos_index_helper=>source_pos_index_tab( ) )->and_expect( )->is_called_once( ).
    pos_index_helper_stub->get_source_pos_index_for_class( class_name = me->source_template->class_key-clsname version = 'I' ).
    cl_abap_testdouble=>configure_call( pos_index_helper_stub )->returning( source_pos_index )->and_expect( )->is_called_once( ).
    pos_index_helper_stub->get_source_pos_index_for_class( class_name = me->source_template->class_key-clsname version = 'A' ).

    me->source_object->if_oo_clif_source~get_source( importing source = data(act_source) ).

    cl_aunit_assert=>assert_equals( exp = me->get_exp_source( ) act = act_source ).
    cl_abap_testdouble=>verify_expectations( pos_index_helper_stub ).
  endmethod.


  method get_exp_source.
    append_to result:
      'class CL_SIMPLE_FAKE definition',
      '  public',
      '  create public .',
      '',
      'public section.',
      '*"* public components of class CL_SIMPLE_FAKE',
      '*"* do not include other source files here!!!',
      '',
      '  interfaces IF_SIMPLE_FAKE .',
      '',
      '  methods METH01',
      '    changing',
      '      !P1 type C .',
      'protected section.',
      '*"* protected components of class CL_SIMPLE_FAKE',
      '*"* do not include other source files here!!!',
      'private section.',
      '*"* private components of class CL_SIMPLE_FAKE',
      '*"* do not include other source files here!!!',
      '',
      '  data ATT01 type I .',
      'ENDCLASS.',
      '',
      '',
      '',
      'CLASS CL_SIMPLE_FAKE IMPLEMENTATION.',
      '',
      '',
      'method meth01.',
      '  p1 = ''TEST_WB''.',
      'endmethod.',
      '',
      '',
      'method IF_SIMPLE_FAKE~METH01.',
      '*  implem IF_SIMPLE_FAKE~METH01',
      'endmethod.',
      'ENDCLASS.'.
  endmethod.
endclass.

class ltcl_source_template_09 definition inheriting from ltcl_source_template
                                         for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition

class ltcl_source_template_09 implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_TEST_OUTER'.
    append_to me->source:
        'class cl_test_outer definition',
        '  public',
        '  final',
        '  create public .',
        '',
        '  public section.',
        '    interfaces if_test_outer.',
        '  protected section.',
        '  private section.',
        'endclass.',
        '',
        '',
        '',
        'class cl_test_outer implementation.',
        '',
        '',
        '  method if_test_inner~m1_inner.',
        '',
        '  endmethod.',
        '',
        '  method if_test_outer~m1_outer.',
        '',
        '  endmethod.',
        '',
        ' endclass.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 7 timestamp = '20210125153739' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 8 line_to = 8 timestamp = '20210125153739' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 9 line_to = 9 timestamp = '20210125153739' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_TEST_INNER~M1_INNER' line_from = 17 line_to = 19 timestamp = '20210125153739' exposure = seoc_exposure_public ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_TEST_OUTER~M1_OUTER' line_from = 21 line_to = 23 timestamp = '20210125153739' exposure = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20210125153739' no_of_method_impls_in_cs = 2 ).
  endmethod.
endclass.

class ltcl_source_template_10 definition inheriting from ltcl_source_template
                                         for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition


class ltcl_source_template_10 implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'CL_TEST_OUTER_1'.
    append_to me->source:
        'class cl_test_outer_1 definition',
        '  public',
        '  final',
        '  create public .',
        '',
        '  public section.',
        '    interfaces if_test_outer_1.',
        '  protected section.',
        '  private section.',
        'endclass.',
        '',
        '',
        '',
        'class cl_test_outer_1 implementation.',
        '  method if_test_inner_1~m1_inner_1.',
        '',
        '  endmethod.',
        '',
        '  method if_test_outer_1~m1_outer_1.',
        '',
        '  endmethod.',
        '',
        ' endclass.'.
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_public    line_from = 1  line_to = 7 timestamp = '20210126125959' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_protected line_from = 8 line_to = 8 timestamp = '20210126125959' ).
    me->add_section_source_info( class_name = class_key-clsname exposure = seoc_exposure_private   line_from = 9 line_to = 9 timestamp = '20210126125959' ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_TEST_INNER_1~M1_INNER_1' line_from = 15 line_to = 17 timestamp = '20210126125959' exposure = seoc_exposure_public ).
    me->add_method_source_info( class_name = class_key-clsname method_name = 'IF_TEST_OUTER_1~M1_OUTER_1' line_from = 19 line_to = 21 timestamp = '20210126125959' exposure = seoc_exposure_public ).
    me->add_cs_source_info( class_name = class_key-clsname timestamp = '20210126125959' no_of_method_impls_in_cs = 2 ).
  endmethod.
endclass.

class ltcl_source_template_11 definition inheriting from ltcl_source_template
                                         for testing risk level harmless duration short.
  public section.
    methods:
      constructor.
endclass.                    "ltcl_source_template_01 definition

class ltcl_source_template_11 implementation.
  method constructor.
    super->constructor( ).
    me->class_key-clsname = 'IF_TEST_OUTER'.
    append_to me->source:
        'interface IF_TEST_OUTER',
        '  public .',
        '',
        '',
        'interfaces IF_TEST_INNER .',
        '',
        '  methods M1_OUTER .',
        'endinterface.'.
  endmethod.
endclass.

class ltcl_class_ajust_implems definition for testing risk level harmless duration short .
  private section.
    methods:
      setup,
      teardown raising cx_oo_access_permission.
    methods:
      save_section for testing raising cx_oo_source_save_failure.
    data:
      class_key       type seoclskey,
      source_object   type ref to cl_oo_clif_source,
      source_template type ref to ltcl_source_template_09.
endclass.


class ltcl_class_ajust_implems implementation.

  method setup.
    data:
      test_helper type ref to cl_wb_test_helper.
    data obj_oo_utility type ref to cl_oo_clif_utility.
    data object_name           type trobj_name.

    create object me->source_template.
    try.
        test_helper = cl_wb_test_helper=>create_instance( ).
        test_helper->loop_generate_name(
          exporting
            p_loop_cnt    = 100
            p_name_length = 30
            p_obj_type    = 'CLAS'
          receiving
            p_name        = me->class_key-clsname  ).

        create object obj_oo_utility.
        obj_oo_utility->copy_class(
          exporting
            original_class    = me->source_template->class_key
            new_class         = me->class_key
            devclass          = test_helper->get_target_package( ) ).

        delete from seometarel where clsname =  me->class_key-clsname and refclsname = 'IF_TEST_INNER_INNER'.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->class_key
            version = seoc_version_inactive.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->class_key
            version = seoc_version_inactive.

        me->source_object = cl_oo_clif_source=>create_instance(
           clif_name = me->class_key-clsname
           settings  = cl_oo_clif_source_settings=>create_instance( signature_enabled = seox_false )
        ).
        me->source_object->if_oo_clif_source~get_source( importing source = me->source_template->source ).

        loop at  me->source_template->source assigning field-symbol(<fs_line>).

          if <fs_line> cs 'interfaces IF_TEST_INNER' or <fs_line> cs 'interfaces IF_TEST_INNER_INNER'.
            delete me->source_template->source index sy-tabix.
          endif.

        endloop.

      catch cx_static_check.
        cl_abap_unit_assert=>abort( 'Copy class to get the testartifact failed' ).
    endtry.
  endmethod.                    "setup

  method teardown.
    data:
      test_helper type ref to cl_wb_test_helper.

    if ( me->source_object is bound ).
      me->source_object->access_permission( seok_access_free ).
      clear me->source_object.
    endif.
    if (  me->class_key-clsname is not initial ).
      try.
          test_helper = cl_wb_test_helper=>create_instance( ).
          test_helper->delete_class( me->class_key-clsname ).
        catch cx_wb_test_helper_error.                  "#EC NO_HANDLER
      endtry.
    endif.
    clear: me->source_template, test_helper.

  endmethod.


  method save_section.
    constants:
      co_additional_source_line type string value ' DATA ABC TYPE I.',
      co_source_line            type i value 7.
    data:
      actual_source   type seop_source_string,
      expected_source type seop_source_string,
      include_name    type progname.
    data implementings type seor_implementings_r.

    insert co_additional_source_line into me->source_template->source index co_source_line.

    try.
        me->source_object->lock( ).
        me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
        me->source_object->if_oo_clif_source~save( ).

        call function 'SEO_IMPLEMENTG_READ_ALL'
          exporting
            clskey        = me->class_key
            version       = seoc_version_inactive
          importing
            implementings = implementings
          exceptions
            others        = 0.

        cl_abap_unit_assert=>assert_equals(
          exporting
            act                  =  lines( implementings  )
            exp                  =   3 ).

        if not line_exists( implementings[ refclsname = 'IF_TEST_OUTER' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_OUTER not found within implementings' ).
        endif.

        if not line_exists( implementings[ refclsname = 'IF_TEST_INNER' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_INNER not found within implementings' ).
        endif.


        if not line_exists( implementings[ refclsname = 'IF_TEST_INNER_INNER' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_INNER_INNER not found within implementings' ).
        endif.

      catch cx_oo_access_permission.
        cl_abap_unit_assert=>abort( 'Testartefact could not be locked' ).
    endtry.
  endmethod.


endclass.


class ltcl_class_ajust_implems_del definition for testing risk level harmless duration short .
  private section.
    methods:
      setup,
      teardown raising cx_oo_access_permission.
    methods:
      save_section for testing raising cx_oo_source_save_failure.
    data:
      class_key       type seoclskey,
      source_object   type ref to cl_oo_clif_source,
      source_template type ref to ltcl_source_template_10.
endclass.


class ltcl_class_ajust_implems_del implementation.

  method setup.
    data:
      test_helper type ref to cl_wb_test_helper.
    data obj_oo_utility type ref to cl_oo_clif_utility.

    create object me->source_template.
    try.
        test_helper = cl_wb_test_helper=>create_instance( ).
        test_helper->loop_generate_name(
          exporting
            p_loop_cnt    = 100
            p_name_length = 30
            p_obj_type    = 'CLAS'
          receiving
            p_name        = me->class_key-clsname  ).

        create object obj_oo_utility.
        obj_oo_utility->copy_class(
          exporting
            original_class    = me->source_template->class_key
            new_class         = me->class_key
            devclass          = test_helper->get_target_package( ) ).

        select single * from seometarel into @data(l_metarel) where clsname = @me->class_key-clsname and refclsname = 'IF_TEST_INNER_1'.
        l_metarel-refclsname = 'IF_TEST_INNER_INNER'.
        l_metarel-editorder = 3.
        insert into seometarel values @l_metarel.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->class_key
            version = seoc_version_inactive.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->class_key
            version = seoc_version_inactive.


        me->source_object = cl_oo_clif_source=>create_instance(
           clif_name = me->class_key-clsname
           settings  = cl_oo_clif_source_settings=>create_instance( signature_enabled = seox_false )
        ).
        me->source_object->if_oo_clif_source~get_source( importing source = me->source_template->source ).
        loop at  me->source_template->source assigning field-symbol(<fs_line>).

          if <fs_line> cs 'interfaces IF_TEST_INNER' or <fs_line> cs 'interfaces IF_TEST_INNER_INNER'.
            delete me->source_template->source index sy-tabix.
          endif.

        endloop.
      catch cx_static_check.
        cl_abap_unit_assert=>abort( 'Copy class to get the testartifact failed' ).
    endtry.
  endmethod.                    "setup

  method teardown.
    data:
      test_helper type ref to cl_wb_test_helper.

    if ( me->source_object is bound ).
      me->source_object->access_permission( seok_access_free ).
      clear me->source_object.
    endif.
    if (  me->class_key-clsname is not initial ).
      try.
          test_helper = cl_wb_test_helper=>create_instance( ).
          test_helper->delete_class( me->class_key-clsname ).
        catch cx_wb_test_helper_error.                  "#EC NO_HANDLER
      endtry.
    endif.
    clear: me->source_template, test_helper.

  endmethod.


  method save_section.
    constants:
      co_additional_source_line type string value ' DATA ABC TYPE I.',
      co_source_line            type i value 8.
    data:
      actual_source   type seop_source_string,
      expected_source type seop_source_string,
      include_name    type progname.
    data implementings type seor_implementings_r.

    insert co_additional_source_line into me->source_template->source index co_source_line.

    try.
        me->source_object->lock( ).
        me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
        me->source_object->if_oo_clif_source~save( ).

        call function 'SEO_IMPLEMENTG_READ_ALL'
          exporting
            clskey        = me->class_key
            version       = seoc_version_inactive
          importing
            implementings = implementings
          exceptions
            others        = 0.

        cl_abap_unit_assert=>assert_equals(
          exporting
            act                  =  lines( implementings  )
            exp                  =   2 ).


        if line_exists( implementings[ refclsname = 'IF_TEST_INNER_INNER' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_INNER_INNER was found within implementings' ).
        endif.

        if not line_exists( implementings[ refclsname = 'IF_TEST_OUTER_1' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_OUTER_1 not found within implementings' ).
        endif.

        if not line_exists( implementings[ refclsname = 'IF_TEST_INNER_1' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_INNER_1 not found within implementings' ).
        endif.

      catch cx_oo_access_permission.
        cl_abap_unit_assert=>abort( 'Testartefact could not be locked' ).
    endtry.
  endmethod.


endclass.

class ltcl_intf_ajust_compris definition for testing risk level harmless duration short .
  private section.
    methods:
      setup,
      teardown raising cx_oo_access_permission.
    methods:
      save_section for testing raising cx_oo_source_save_failure.
    data:
      intf_key        type seoclskey,
      source_object   type ref to cl_oo_clif_source,
      source_template type ref to ltcl_source_template_11.
endclass.


class ltcl_intf_ajust_compris implementation.

  method setup.
    data:
      test_helper type ref to cl_wb_test_helper.
    data obj_oo_utility type ref to cl_oo_clif_utility.
    data object_name           type trobj_name.

    create object me->source_template.
    try.
        test_helper = cl_wb_test_helper=>create_instance( ).
        test_helper->loop_generate_name(
          exporting
            p_loop_cnt    = 100
            p_name_length = 30
            p_obj_type    = 'INTF'
          receiving
            p_name        = me->intf_key-clsname  ).

        create object obj_oo_utility.

        obj_oo_utility->copy_interface(
          exporting
            original_interface            = me->source_template->class_key
            new_interface                 =  me->intf_key
            devclass                      =  test_helper->get_target_package( )
        ).

        delete from seometarel where clsname =   me->intf_key-clsname  and refclsname = 'IF_TEST_INNER_INNER'.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->intf_key
            version = seoc_version_inactive.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->intf_key
            version = seoc_version_inactive.

        me->source_object = cl_oo_clif_source=>create_instance(
           clif_name = me->intf_key-clsname
           settings  = cl_oo_clif_source_settings=>create_instance( signature_enabled = seox_false )
        ).
        me->source_object->if_oo_clif_source~get_source( importing source = me->source_template->source ).
        loop at  me->source_template->source assigning field-symbol(<fs_line_i>).

          if <fs_line_i> cs 'interfaces IF_TEST_INNER_INNER'.
            delete me->source_template->source index sy-tabix.
          endif.

        endloop.

      catch cx_static_check.
        cl_abap_unit_assert=>abort( 'Copy interface to get the testartifact failed' ).
    endtry.
  endmethod.                    "setup

  method teardown.
    data:
      test_helper type ref to cl_wb_test_helper.

    if ( me->source_object is bound ).
      me->source_object->access_permission( seok_access_free ).
      clear me->source_object.
    endif.
    if (  me->intf_key-clsname is not initial ).
      try.
          test_helper = cl_wb_test_helper=>create_instance( ).
          test_helper->delete_class( me->intf_key-clsname ).
        catch cx_wb_test_helper_error.                  "#EC NO_HANDLER
      endtry.
    endif.
    clear: me->source_template, test_helper.

  endmethod.


  method save_section.
    constants:
      co_additional_source_line type string value ' DATA ABC TYPE I.',
      co_source_line            type i value 8.
    data:
      actual_source   type seop_source_string,
      expected_source type seop_source_string,
      include_name    type progname.
    data comprisings type seor_comprisings_r.

    insert co_additional_source_line into me->source_template->source index co_source_line.

    try.
        me->source_object->lock( ).
        me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
        me->source_object->if_oo_clif_source~save( ).

        call function 'SEO_COMPRISING_READ_ALL'
          exporting
            intkey      = me->intf_key
            version     = seoc_version_inactive
          importing
            comprisings = comprisings
          exceptions
            others      = 0.

        cl_abap_unit_assert=>assert_equals(
          exporting
            act                  =  lines( comprisings  )
            exp                  =   2 ).


        if not line_exists( comprisings[ refclsname = 'IF_TEST_INNER' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_INNER not found within comprisings' ).
        endif.


        if not line_exists( comprisings[ refclsname = 'IF_TEST_INNER_INNER' ] ).
          cl_abap_unit_assert=>fail( 'IF_TEST_INNER_INNER not found within comprisings' ).
        endif.

      catch cx_oo_access_permission.
        cl_abap_unit_assert=>abort( 'Testartefact could not be locked' ).
    endtry.
  endmethod.


endclass.


class ltcl_intf_ajust_compris_del definition for testing risk level harmless duration short .
  private section.
    methods:
      setup,
      teardown raising cx_oo_access_permission.
    methods:
      save_section for testing raising cx_oo_source_save_failure.
    data:
      intf_key        type seoclskey,
      source_object   type ref to cl_oo_clif_source,
      source_template type ref to ltcl_source_template_11.
endclass.


class ltcl_intf_ajust_compris_del implementation.

  method setup.
    data:
      test_helper type ref to cl_wb_test_helper.
    data obj_oo_utility type ref to cl_oo_clif_utility.
    data object_name           type trobj_name.

    create object me->source_template.
    try.
        test_helper = cl_wb_test_helper=>create_instance( ).
        test_helper->loop_generate_name(
          exporting
            p_loop_cnt    = 100
            p_name_length = 30
            p_obj_type    = 'INTF'
          receiving
            p_name        = me->intf_key-clsname  ).

        create object obj_oo_utility.

        obj_oo_utility->copy_interface(
          exporting
            original_interface            = me->source_template->class_key
            new_interface                 =  me->intf_key
            devclass                      =  test_helper->get_target_package( )
        ).

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->intf_key
            version = seoc_version_inactive.

        call function 'SEO_BUFFER_REFRESH'
          exporting
            cifkey  = me->intf_key
            version = seoc_version_inactive.

        me->source_object = cl_oo_clif_source=>create_instance(
           clif_name = me->intf_key-clsname
           settings  = cl_oo_clif_source_settings=>create_instance( signature_enabled = seox_false )
        ).
        me->source_object->if_oo_clif_source~get_source( importing source = me->source_template->source ).
        loop at  me->source_template->source assigning field-symbol(<fs_line_i>).

          if <fs_line_i> cs 'interfaces IF_TEST_INNER_INNER'.
            delete me->source_template->source index sy-tabix.
          endif.

        endloop.

      catch cx_static_check.
        cl_abap_unit_assert=>abort( 'Copy interface to get the testartifact failed' ).
    endtry.
  endmethod.                    "setup

  method teardown.
    data:
      test_helper type ref to cl_wb_test_helper.

    if ( me->source_object is bound ).
      me->source_object->access_permission( seok_access_free ).
      clear me->source_object.
    endif.
    if (  me->intf_key-clsname is not initial ).
      try.
          test_helper = cl_wb_test_helper=>create_instance( ).
          test_helper->delete_class( me->intf_key-clsname ).
        catch cx_wb_test_helper_error.                  "#EC NO_HANDLER
      endtry.
    endif.
    clear: me->source_template, test_helper.

  endmethod.


  method save_section.
    constants:
      co_source_line            type i value 5.
    data:
      actual_source   type seop_source_string,
      expected_source type seop_source_string,
      include_name    type progname.
    data comprisings type seor_comprisings_r.

    delete me->source_template->source index co_source_line.

    try.
        me->source_object->lock( ).
        me->source_object->if_oo_clif_source~set_source( me->source_template->source ).
        me->source_object->if_oo_clif_source~save( ).

        call function 'SEO_COMPRISING_READ_ALL'
          exporting
            intkey      = me->intf_key
            version     = seoc_version_inactive
          importing
            comprisings = comprisings
          exceptions
            others      = 0.

        cl_abap_unit_assert=>assert_equals(
          exporting
            act                  =  lines( comprisings  )
            exp                  =   0 ).


      catch cx_oo_access_permission.
        cl_abap_unit_assert=>abort( 'Testartefact could not be locked' ).
    endtry.
  endmethod.


endclass.