class CL_PO_ITEM_HANDLE_MM definition
  public
  inheriting from CL_HANDLE_MM
  create public .

public section.

*"* public components of class CL_PO_ITEM_HANDLE_MM
*"* do not include other source files here!!!
  interfaces IF_ACCT_CONTAINER_MM .
  interfaces IF_DELIVERY_ADDRESS_MM .
  interfaces IF_LONGTEXTS_MM .
  interfaces IF_PURCHASE_ORDER_ITEM_MM .
  interfaces IF_PURCHASING_DMS_MM .
  interfaces IF_PURCHASING_DOCUMENT_ITEM .
  interfaces IF_SERVICES_MM .

  constants C_OBJTYP type MEPO_OBJDESC-OBJTYP value 'BUS2012_IT' ##NO_TEXT.
  class-data COMSRV type MEPOCOMSRV read-only .
  class-data MY_ITEM_PROPOSER type ref to IF_DATAPROVIDER_MM read-only .
  data MY_PO_HEADER type ref to CL_PO_HEADER_HANDLE_MM read-only .
  data PO_ITEM_NUMBER type EKPO-EBELP read-only .
  data EKPV_CHANGED type MMPUR_BOOL read-only .
  data EIPO_CHANGED type MMPUR_BOOL read-only .
  data COMSRV_CHANGED type MMPUR_BOOL read-only .
  data CONFIRMATION_HANDLE type ref to IF_MMPUR_CONF_ITEM read-only .
  data MY_SN_MANAGER type ref to IF_SERNO_MANAGER_MM .
  data MV_SUBITEMS_VISIBILITY type CHAR1 read-only .

  class-methods CHP_REFRESH_HASH_TABLE .
  methods CONSTRUCTOR
    importing
      !IM_PO_ITEM_NUMBER type EKPO-EBELP
      !IM_PO_HEADER type ref to IF_MODEL_MM optional
      !IM_PO_HEADER_ID type I optional
      !IV_ADDRESS_HANDLING_ACTIVE type ABAP_BOOL optional
      !IO_ADDRESS_HANDLER type ref to IF_MM_PUR_PO_ADDRESS_UTILITY optional
    exceptions
      FAILURE .
  methods SET_PO_ITEM_NUMBER
    importing
      !IM_PO_ITEM_NUMBER type EKPO-EBELP .
  methods GET_PO_ACCOUNTINGS
    exporting
      !EX_ACCOUNTINGS type MMPUR_MODELS .
  methods GET_PO_SUBITEMS
    importing
      !IM_UPTYP type EKPO-UPTYP optional
    exporting
      !EX_SUBITEMS type MMPUR_MODELS .
  methods GET_PO_SCHEDULES
    exporting
      !EX_SCHEDULES type MMPUR_MODELS .
  methods HAS_PO_ACCOUNTINGS
    exporting
      !EX_COUNT type I .
  methods HAS_PO_SCHEDULES
    exporting
      !EX_COUNT type I .
  methods REMOVE_PO_ACCOUNTING
    importing
      !IM_ACCOUNTING type ref to IF_MODEL_MM
    exceptions
      FAILURE .
  methods REMOVE_PO_ACCOUNTINGS
    exceptions
      FAILURE .
  methods REMOVE_PO_SCHEDULE
    importing
      !IM_SCHEDULE type ref to IF_MODEL_MM
    exceptions
      FAILURE .
  methods REMOVE_PO_SCHEDULES
    exceptions
      FAILURE .
  methods GET_DATA
    exporting
      value(EX_DATA) type MEPOITEM
    exceptions
      FAILURE .
  methods GET_DATAX
    exporting
      !EX_DATA type MEPOITEMX .
  methods SET_DATA
    importing
      value(IM_DATA) type MEPOITEM .
  methods SET_DATAX
    importing
      !IM_DATA type MEPOITEMX .
  methods REFRESH_COMSRV_DATA .
  methods REFRESH_EKPV_DATA .
  methods REFRESH_EIPO_DATA .
  methods CREATE_BATCH
    importing
      !IM_BATCH type CHARG_D optional
    exceptions
      FAILED .
  methods LOOKUP_SCHEDULE
    importing
      !IM_SCHEDULE_NUMBER type EKET-ETENR
    returning
      value(RE_SCHEDULE) type ref to CL_PO_SCHEDULE_HANDLE_MM .
  methods LOOKUP_ACCOUNTING
    importing
      !IM_ACCOUNTING_NUMBER type EKKN-ZEKKN
    returning
      value(RE_ACCOUNTING) type ref to CL_PO_ACCOUNTING_HANDLE_MM .
  methods SET_SHIPPING_DATAX
    importing
      !IM_DATA type MEPO_EKPVX .
  methods GET_SHIPPING_DATAX
    returning
      value(RE_DATA) type MEPO_EKPVX .
  methods REFRESH_EKPVX_DATA .
  methods /NFM/GET_NFM_OBJECT
    importing
      !IM_INDEX type I optional
    changing
      !MY_NE_POSITION type MMPUR_MODELS .
  methods /NFM/REMOVE_PO_NE
    exceptions
      FAILURE .
  methods SET_INVOICE_PLAN
    importing
      !IM_IP type ref to CL_MMPUR_IV_PLAN .
  methods GET_INVOICE_PLAN
    returning
      value(RE_IP) type ref to CL_MMPUR_IV_PLAN .
  methods SET_CONFIRMATION_HANDLE
    importing
      !IM_HEADER type ref to IF_MMPUR_CONF_HEADER .
  methods RESET_SUBITEMS_VISIBILITY .
  methods SET_SUBITEMS_VISIBILITY .

  methods ADD_ITEM
    redefinition .
  methods CAN_INITIATE_FLUSH
    redefinition .
  methods CHP_ADD_HASH_ENTRY
    redefinition .
  methods IF_ASYNC_SUBJECT_MM~GET_CHANGES
    redefinition .
  methods IF_ASYNC_SUBJECT_MM~RESET_CHANGES
    redefinition .
  methods IF_FIELDSELECTION_MM~FS_GET
    redefinition .
  methods IF_MESSAGE_OBJ_MM~DESCRIBE
    redefinition .
  methods REMOVE_ITEMS
    redefinition .
  methods SET_PARENT
    redefinition .
  methods SET_STATE
    redefinition .
protected section.
*"* protected components of class CL_PO_ITEM_HANDLE_MM
*"* do not include other source files here!!!

  methods FLUSH_DATA
    redefinition .
  methods GET_MAPPING
    redefinition .
private section.

  types:
*"* private components of class CL_PO_ITEM_HANDLE_MM
*"* do not include other source files here!!!
    BEGIN OF po_item_hash_entry,
     item   TYPE REF TO cl_po_item_handle_mm,
     data   TYPE mepoitem,
  END OF po_item_hash_entry .
  types:
    BEGIN OF po_itemx_hash_entry,
     item   TYPE REF TO cl_po_item_handle_mm,
     data   TYPE mepoitemx,
  END OF po_itemx_hash_entry .
  types:
    BEGIN OF po_ekpv_hash_entry,
    item   TYPE REF TO cl_po_item_handle_mm,
    data   TYPE ekpv,
  END OF po_ekpv_hash_entry .
  types:
    BEGIN OF po_ekpvx_hash_entry,
    item   TYPE REF TO cl_po_item_handle_mm,
    data   TYPE mepo_ekpvx,
    END OF po_ekpvx_hash_entry .
  types:
    BEGIN OF po_eipo_hash_entry,
     item   TYPE REF TO cl_po_item_handle_mm,
     data   TYPE mepo_eipo,
  END OF po_eipo_hash_entry .
  types:
    BEGIN OF po_acc_hash_entry,
     item   TYPE REF TO cl_po_item_handle_mm,
     data   TYPE ueskn,
END OF po_acc_hash_entry .
  types:
    BEGIN OF po_comsrv_hash_entry,
     item   TYPE REF TO cl_po_item_handle_mm,
     data   TYPE comsrv,
END OF po_comsrv_hash_entry .

  class-data:
    acc_hash_table TYPE STANDARD TABLE OF
           po_acc_hash_entry WITH NON-UNIQUE KEY item .
  class-data:
    comsrv_hash_table TYPE HASHED TABLE OF
           po_comsrv_hash_entry WITH UNIQUE KEY item .
  class-data:
    po_item_hash_table TYPE HASHED TABLE OF
           po_item_hash_entry WITH UNIQUE KEY item .
  class-data:
    po_itemx_hash_table TYPE HASHED TABLE OF
           po_itemx_hash_entry WITH UNIQUE KEY item .
  class-data:
    chp_hash_table     TYPE HASHED TABLE OF
           po_item_hash_entry WITH UNIQUE KEY item .
  class-data:
    po_ekpv_hash_table TYPE HASHED TABLE OF
           po_ekpv_hash_entry WITH UNIQUE KEY item .
  class-data:
    po_ekpvx_hash_table TYPE HASHED TABLE OF
           po_ekpvx_hash_entry WITH UNIQUE KEY item .
  class-data:
    po_eipo_hash_table TYPE HASHED TABLE OF
           po_eipo_hash_entry WITH UNIQUE KEY item .
  data MY_SCHEDULES type MMPUR_MODELS .
  data MY_ACCOUNTINGS type MMPUR_MODELS .
  class-data MY_FIELD_MAPPING type MEPO_T_METAFIELD_MAPPING .
  class-data MY_FS_TEMPLATE type TTYP_FIELDSELECTION_MM .
  data /NFM/MY_NE_POSITION type MMPUR_MODELS .
  data MY_INVOICE_PLAN type ref to CL_MMPUR_IV_PLAN .

  class-methods CHECK_PROPOSER .
  methods GET_DELIVERY_ADDRESS
    importing
      !IS_ITEM type MEPOITEM
      !IV_ADDRNUMBER_ONLY type ABAP_BOOL optional
    returning
      value(RS_ADDRESS) type IF_MM_PUR_PO_ADDRESS_UTILITY=>TY_ADDRESS_COMPLETE .
ENDCLASS.



CLASS CL_PO_ITEM_HANDLE_MM IMPLEMENTATION.


method IF_PURCHASING_DMS_MM~SET_ASSIGNMENT.

    perform MEPO_DOCUMENTS_SET_ASSIGNMENT in program saplmepo
         USING IM_DOCUMENTS.

endmethod.


method IF_PURCHASING_DMS_MM~GET_ASSIGNMENT.
    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

    perform MEPO_DOCUMENTS_GET_ASSIGNMENT in program saplmepo
         USING    l_mepoitem-ebeln
                  l_mepoitem-ebelp
                  l_mepoitem-loekz                          "689007
         CHANGING EX_OBJECT_TYPE
                  EX_OBJECT_KEY
                  EX_OPCODE
                  EX_DOCUMENTS.

  EX_PUR_DOC_NO   = l_mepoitem-ebeln.
  EX_PUR_DOC_ITEM = l_mepoitem-ebelp.
  EX_PUR_TEXT     = l_mepoitem-txz01.
endmethod.


METHOD if_purchase_order_item_mm~set_shipping_data .

  DATA: l_data_old    TYPE ekpv,
        l_data_new    TYPE ekpv,
        l_parent      TYPE REF TO cl_po_header_handle_mm,
        l_model       TYPE REF TO if_model_mm,
        l_model_entry TYPE mmpur_model_type,
        wa            LIKE LINE OF po_ekpv_hash_table.

  mmpur_dynamic_cast l_parent my_parent.
  CHECK NOT l_parent IS INITIAL.


  l_data_old = me->if_purchase_order_item_mm~get_shipping_data( ).
* initial transfer from BAPI interface (old_data always empty)
  IF l_parent->for_bapi EQ mmpur_no.
    CHECK NOT l_data_old IS INITIAL.
  ENDIF.
  l_data_new = l_data_old.

* firewall
  MOVE: im_ekpv-vstel TO l_data_new-vstel,
        im_ekpv-lprio TO l_data_new-lprio,
        im_ekpv-vsbed TO l_data_new-vsbed,
        im_ekpv-route TO l_data_new-route,
        im_ekpv-ablad TO l_data_new-ablad,
        im_ekpv-spe_auth_number  TO l_data_new-spe_auth_number,
        im_ekpv-spe_src_dlv_no   TO l_data_new-spe_src_dlv_no,
        im_ekpv-spe_src_exidv    TO l_data_new-spe_src_exidv,
        im_ekpv-spe_inspout_guid TO l_data_new-spe_inspout_guid,
        im_ekpv-spe_follow_up    TO l_data_new-spe_follow_up.

  IF cl_erp_ehp_switch_check=>spe_sfws_ci_1( ) EQ 'X'.
    MOVE : im_ekpv-spe_ext_id TO l_data_new-spe_ext_id,
           im_ekpv-spe_ext_id_item TO l_data_new-spe_ext_id_item.
  ENDIF.

* EHP5 -> changeable fields on shipping data screen
  DATA: lf_ccp_active TYPE c.
  CALL FUNCTION 'ME_CCP_ACTIVE_CHECK'
    IMPORTING
      ef_ccp_active = lf_ccp_active.
  IF cl_ops_switch_check=>mm_sfws_ci_3( ) = abap_true OR
     NOT lf_ccp_active IS INITIAL .
    MOVE: im_ekpv-ladgr TO l_data_new-ladgr,
          im_ekpv-tragr TO l_data_new-tragr.
  ENDIF.

*  RMA scenario
  move im_ekpv-vsart TO l_data_new-vsart.

* Take over loading group for direct deliveries             "v_n_1970113
  IF cl_ops_switch_check=>le_sfws_sc3( ) = 'X'
     AND /spe/cl_im_sto_for_dirdlv=>get_sto_for_dirdlv( ) = 'X'.
     MOVE: im_ekpv-ladgr TO l_data_new-ladgr,
       im_ekpv-tragr TO l_data_new-tragr.
  ENDIF.                                                    "^_n_1970113

  l_data_new-ebeln = l_parent->po_number.
  l_data_new-ebelp = me->po_item_number.

  IF l_data_new NE l_data_old.

    READ TABLE po_ekpv_hash_table INTO wa WITH TABLE KEY item = me.
    IF sy-subrc IS INITIAL.
      wa-data = l_data_new.
      MODIFY TABLE po_ekpv_hash_table FROM wa.
    ELSE.
      wa-item = me.
      wa-data = l_data_new.
      INSERT wa INTO TABLE po_ekpv_hash_table.
    ENDIF.
    ekpv_changed = mmpur_yes.

    l_model ?= me.
    READ TABLE l_parent->my_recheck_queue
               WITH KEY model = l_model  TRANSPORTING NO FIELDS.
    IF NOT sy-subrc IS INITIAL.
      l_model_entry-model = l_model.
      APPEND l_model_entry TO l_parent->my_recheck_queue.
    ENDIF.
  ENDIF.

ENDMETHOD. "IF_PURCHASE_ORDER_ITEM_MM~SET_SHIPPING_DATA


METHOD if_purchase_order_item_mm~set_foreign_trade .

  DATA: l_data        LIKE im_data,
        l_data_old    LIKE im_data,                         "841803
        l_parent      TYPE REF TO cl_po_header_handle_mm,
        l_model       TYPE REF TO if_model_mm,
        l_model_entry TYPE mmpur_model_type,
        wa            LIKE LINE OF po_eipo_hash_table,
        l_ekko        TYPE mepoheader.

  mmpur_dynamic_cast l_parent my_parent.
  CHECK NOT l_parent IS INITIAL.

  l_parent->get_data( IMPORTING ex_data = l_ekko ).

  l_data = im_data.
  l_data-po_item = po_item_number.

  l_data_old = me->if_purchase_order_item_mm~get_foreign_trade( ).
  CHECK l_data_old NE l_data.                               "841803

  READ TABLE po_eipo_hash_table INTO wa WITH TABLE KEY item = me.
  IF sy-subrc IS INITIAL.
    wa-data = l_data.
    MODIFY TABLE po_eipo_hash_table FROM wa.
  ELSE.
    wa-item = me.
    wa-data = l_data.
    INSERT wa INTO TABLE po_eipo_hash_table.
  ENDIF.
  eipo_changed = mmpur_yes.

  l_model ?= me.
  READ TABLE l_parent->my_recheck_queue
             WITH KEY model = l_model  TRANSPORTING NO FIELDS.
  IF NOT sy-subrc IS INITIAL.
    l_model_entry-model = l_model.
    APPEND l_model_entry TO l_parent->my_recheck_queue.
  ENDIF.

ENDMETHOD.                    "IF_PURCHASE_ORDER_ITEM_MM~SET_FOREIGN_TRADE


METHOD if_purchase_order_item_mm~set_data .

  DATA: l_data_old       TYPE mepoitem,
        l_datax_old      TYPE mepoitemx,
        l_data_new       TYPE mepoitem,
        l_datax_new      TYPE mepoitemx,
        l_mepotech       TYPE mepoitem_tech,
        l_parent         TYPE REF TO cl_po_header_handle_mm,
        l_model          TYPE REF TO if_model_mm,
        l_model_entry    TYPE mmpur_model_type,
        l_loekz          TYPE mepoitem-loekz,                    "848257
        l_blk_reason_id  TYPE mepoitem-blk_reason_id,
        l_blk_reason_txt TYPE mepoitem-blk_reason_txt.

  mmpur_dynamic_cast l_parent my_parent.
  CHECK NOT l_parent IS INITIAL.
  CHECK l_parent->my_ibs_firewall_on EQ mmpur_yes OR
        l_parent->my_cust_firewall_on EQ mmpur_yes.

  CALL METHOD me->get_data( IMPORTING ex_data = l_data_old ).
  CALL METHOD me->get_datax( IMPORTING ex_data = l_datax_old ).
  MOVE-CORRESPONDING l_data_old TO l_mepotech.              "#EC ENHOK

  MOVE im_data TO l_data_new.
  MOVE-CORRESPONDING l_mepotech TO l_data_new.              "#EC ENHOK
  IF l_data_new-pstyp EQ '1' OR l_data_new-pstyp EQ '9'.    "987251
    MOVE: im_data-packno TO l_data_new-packno.
  ENDIF.
  MOVE: im_data-cuobj  TO l_data_new-cuobj,
        im_data-kzkfg  TO l_data_new-kzkfg,                 "1669734
        im_data-lebre  TO l_data_new-lebre,
        im_data-abeln  TO l_data_new-abeln,                 "2118571
        im_data-abelp  TO l_data_new-abelp.

"{ Begin SET_DATA_01 ENHO ADSUB_IF_PURCHASE_ORDER_ITE000 IS-AD-SUC AD_SUB }
* DI A&D SUB
* A&D Subcon Q2005 - ch.5.4.6
* Previously the below code was created only for DFPS functionality
* S/N in STO. Since April 2005 the functionality moved out of BADI switch
* to be available for A&D subcontracting and possible other scenarios

*       begin of retrofit serial numbers in STO
*            data: l_serial_active type char1.
*
*            data: lp_badi_serial_in_sto
*                     type ref to IF_EX_BADI_SERIAL_IN_STO.
*
*            if l_serial_active is initial.
*              CALL METHOD CL_EXITHANDLER=>GET_INSTANCE
*                 EXPORTING
*                   EXIT_NAME              = 'BADI_SERIAL_IN_STO'
*                   NULL_INSTANCE_ACCEPTED = 'X'
*                CHANGING
*                  INSTANCE                = lp_badi_serial_in_sto
*                 EXCEPTIONS
*                  others                  = 9.
*
**             default: inactive
*              l_serial_active = 'N'.
*
*              if not lp_badi_serial_in_sto is initial.
*                CALL METHOD LP_BADI_SERIAL_IN_STO->IS_ACTIVE
*                  IMPORTING
*                    E_ACTIVE = l_serial_active.
*              endif.
*            endif.
*
*            if l_serial_active eq 'Y'.
**             serial numbers in STO are active

*  get ANZSN from BAPI
  IF NOT im_data-anzsn IS INITIAL.
    l_data_new-anzsn = im_data-anzsn.
  ENDIF.

*            endif. "serial numbers in STO active
*       end of retrofit serial numbers in STO
"{ End SET_DATA_01 ENHO ADSUB_IF_PURCHASE_ORDER_ITE000 IS-AD-SUC AD_SUB }

ENHANCEMENT-POINT set_data_01 SPOTS es_cl_po_item_handle_mm.
  IF l_data_old-ebeln NE space.
    l_data_new-ebeln = l_data_old-ebeln.
  ENDIF.
  IF NOT l_data_old-ebelp IS INITIAL.
    l_data_new-ebelp = l_data_old-ebelp.
  ENDIF.
  IF NOT l_data_old-refbs IS INITIAL.
    l_data_new-refbs = l_data_old-refbs.
  ENDIF.
  IF NOT l_data_old-refps IS INITIAL.
    l_data_new-refps = l_data_old-refps.
  ENDIF.

  IF l_data_new NE l_data_old.
* customer firewall
    IF l_parent->my_cust_firewall_on EQ mmpur_yes.
* rescue deletion indicator                                 "848257
      l_loekz          = l_data_new-loekz.
      l_data_new-loekz = l_data_old-loekz.
* ... and blocking reason fields (EHP5)
      l_blk_reason_id  = l_data_new-blk_reason_id.
      l_blk_reason_txt = l_data_new-blk_reason_txt.
      l_data_new-blk_reason_id  = l_data_old-blk_reason_id.
      l_data_new-blk_reason_txt = l_data_old-blk_reason_txt.
      DATA(lv_abeln) = l_data_new-abeln.
      DATA(lv_abelp) = l_data_new-abelp.
      l_data_new-abeln = l_data_old-abeln.                  "1970581
      l_data_new-abelp = l_data_old-abelp.
      CALL METHOD me->process_input_filter
        EXPORTING
          im_data     = l_data_new
          im_data_old = l_data_old
        IMPORTING
          ex_data     = l_data_new.
      l_data_new-loekz          = l_loekz.                           "848257
      l_data_new-blk_reason_id  = l_blk_reason_id.
      l_data_new-blk_reason_txt = l_blk_reason_txt.
      l_data_new-abeln = lv_abeln.                          "1970581
      l_data_new-abelp = lv_abelp.
    ENDIF.
* if process_input_filter resets changed fields no recheck has to be done
    IF l_data_new NE l_data_old.
      CALL METHOD me->set_data( im_data = l_data_new ).
      CALL METHOD me->check_badi_datax
        EXPORTING
          im_data_old  = l_data_old
          im_data_new  = l_data_new
          im_datax_old = l_datax_old
        IMPORTING
          ex_datax_new = l_datax_new.
      CALL METHOD me->set_datax( im_data = l_datax_new ).
      mmpur_dynamic_cast l_model me.
      READ TABLE l_parent->my_recheck_queue WITH KEY model = l_model TRANSPORTING NO FIELDS.
      IF NOT sy-subrc IS INITIAL.
        l_model_entry-model = l_model.
        APPEND l_model_entry TO l_parent->my_recheck_queue.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD if_purchase_order_item_mm~set_conditions .

  DATA: l_header       TYPE REF TO cl_po_header_handle_mm,
        l_model        TYPE REF TO if_model_mm,
        ls_model_entry TYPE mmpur_model_type,
        lt_conditions  TYPE mmpur_tkomv,
        lt_cond_new    TYPE mmpur_tkomv,
        lt_cond_old    TYPE mmpur_tkomv,
        l_kposn        TYPE komv-kposn.

  l_kposn = po_item_number.
  mmpur_dynamic_cast l_header my_parent.
  CHECK NOT l_header IS INITIAL.
  CHECK l_header->my_ibs_firewall_on EQ mmpur_yes OR
        l_header->my_cust_firewall_on EQ mmpur_yes.

  l_header->get_tkomv( IMPORTING ex_tkomv = lt_conditions )."995530
  IF lt_conditions[] IS INITIAL.
* maybe the buffer is still empty so we pull the conditions out of MEPO
    l_header->if_purchasing_document~get_tkomv( IMPORTING ex_tkomv = lt_conditions ).
  ENDIF.

* store old conditions for check if something's changed
  lt_cond_old = lt_conditions.

* delete old conditions
  DELETE lt_conditions WHERE kposn = l_kposn.

* insert new conditions
  CHECK NOT im_conditions IS INITIAL.
  lt_cond_new = im_conditions.
  DELETE lt_cond_new WHERE kposn NE l_kposn.
  SORT lt_cond_new.
  READ TABLE lt_conditions WITH KEY kposn = l_kposn BINARY SEARCH
             TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  INSERT lines of lt_cond_new INTO lt_conditions INDEX sy-tabix.

* has something changed?
* only then we set the conditions and fill the recheck queue
  IF lt_cond_old NE lt_conditions.
    CALL METHOD l_header->set_tkomv(
      im_tkomv = lt_conditions
      im_item_conditions_changed = mmpur_yes ).

* update recheck queue on header level
    l_model ?= me.
    READ TABLE l_header->my_recheck_queue WITH KEY model = l_model
               TRANSPORTING NO FIELDS.
    IF NOT sy-subrc IS INITIAL.
      ls_model_entry-model = l_model.
      APPEND ls_model_entry TO l_header->my_recheck_queue.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD if_purchase_order_item_mm~is_valid .
  PERFORM mepo_badi_item_is_valid IN PROGRAM saplmepo
                           USING    po_item_number
                           CHANGING re_valid.
ENDMETHOD.


METHOD if_purchase_order_item_mm~is_persistent .

  PERFORM mepo_badi_item_is_persistent IN PROGRAM saplmepo
                                  USING po_item_number
                                  CHANGING re_persistent.

ENDMETHOD.


METHOD if_purchase_order_item_mm~invalidate .

  PERFORM mepo_badi_item_invalidate IN PROGRAM saplmepo
             USING po_item_number.

ENDMETHOD.


method IF_PURCHASE_ORDER_ITEM_MM~GET_SHIPPING_DATA .

  data: wa like line of po_ekpv_hash_Table.

  read table po_ekpv_hash_Table into wa with table key item = me.
  if sy-subrc is initial.
    re_ekpv = wa-data.
  else.
    perform get_ekpv in program saplmepo using    po_item_number
                                         changing re_ekpv.
  endif.
endmethod. "IF_PURCHASE_ORDER_ITEM_MM~GET_SHIPPING_DATA


METHOD if_purchase_order_item_mm~get_serno_manager.
  DATA: l_sn_item         TYPE serno_manager_data_mm,
        l_header          TYPE REF TO cl_po_header_handle_mm,
        l_mepoheader      TYPE mepoheader,
        l_mepoitem        TYPE mepoitem.

  CHECK cl_ops_switch_check=>mm_sfws_serno( )
          EQ cl_mmpur_constants=>yes.

  IF NOT me->my_sn_manager IS BOUND.
    CALL METHOD me->get_data
      IMPORTING
        ex_data = l_mepoitem.
    mmpur_dynamic_cast1 l_header me->my_parent.
    IF NOT l_header IS INITIAL.
      CALL METHOD l_header->get_data
        IMPORTING
          ex_data = l_mepoheader.
    ENDIF.
    MOVE-CORRESPONDING l_mepoitem TO l_sn_item.
    l_sn_item-bsart = l_mepoheader-bsart.
    l_sn_item-edokn = l_mepoitem-ebeln.
    l_sn_item-edokp = l_mepoitem-ebelp.
    l_sn_item-matnr = l_mepoitem-ematn.
    l_sn_item-sernp = l_mepoitem-sernp1.
    l_sn_item-activity = im_activity.
    CALL FUNCTION 'MMPUR_GET_SERNO_MANAGER'
      EXPORTING
        im_pos     = l_sn_item
        im_pos_old = l_sn_item
      IMPORTING
        ex_manager = me->my_sn_manager
      CHANGING
        ch_anzsn   = l_mepoitem-anzsn
      EXCEPTIONS
        OTHERS     = 1.
  ENDIF.
  ex_sn_manager = me->my_sn_manager.

ENDMETHOD.


METHOD if_purchase_order_item_mm~get_schedules .

  DATA: lt_schedules    TYPE mmpur_models,
        ls_schedule     LIKE LINE OF lt_schedules,
        ls_schedule_new LIKE LINE OF re_schedules.

  CALL METHOD me->get_po_schedules
    IMPORTING
      ex_schedules = lt_schedules.
  LOOP AT lt_schedules INTO ls_schedule.
    ls_schedule_new-schedule ?= ls_schedule-model.
    APPEND ls_schedule_new TO re_schedules.
  ENDLOOP.

ENDMETHOD.


METHOD if_purchase_order_item_mm~get_previous_data .

  DATA: l_item LIKE LINE OF chp_hash_table.

  CLEAR ex_data.
  READ TABLE chp_hash_table INTO l_item WITH TABLE KEY item = me.
  IF sy-subrc IS INITIAL AND NOT l_item-data IS INITIAL.    "999401
    ex_data = l_item-data.
  ELSE.
    RAISE no_data.
  ENDIF.

ENDMETHOD.


METHOD if_purchase_order_item_mm~get_persistent_data .

  DATA: l_success TYPE mmpur_bool VALUE mmpur_no.

  PERFORM mepo_badi_item_get_pers_data IN PROGRAM saplmepo
                                               USING    po_item_number
                                               CHANGING ex_data
                                                        l_success.
  IF l_success EQ mmpur_no.
    RAISE no_data.
  ENDIF.

ENDMETHOD.


METHOD if_purchase_order_item_mm~get_history.

  PERFORM mepo_item_get_history IN PROGRAM saplmepo
                   USING
                     po_item_number
                   CHANGING
                     ex_indicators
                     ex_history
                     ex_item_totals
                     ex_grir_assignment
                     ex_history_delivery
                     ex_item_totals_delivery
                     ex_history_ma
                     ex_history_ma_totals.

ENDMETHOD.                    "IF_PURCHASE_ORDER_ITEM_MM~GET_HISTORY


METHOD if_purchase_order_item_mm~get_header .
  mmpur_dynamic_cast re_header my_parent.
ENDMETHOD.


METHOD if_purchase_order_item_mm~get_foreign_trade .

  DATA: wa LIKE LINE OF po_eipo_hash_table.

  READ TABLE po_eipo_hash_table INTO wa WITH TABLE KEY item = me.
  IF sy-subrc IS INITIAL.
    re_data = wa-data.
  ELSE.
    PERFORM get_mepo_eipo IN PROGRAM saplmepo USING    po_item_number
                                              CHANGING re_data.
  ENDIF.

ENDMETHOD.                    "IF_PURCHASE_ORDER_ITEM_MM~GET_FOREIGN_TRADE


  METHOD if_purchase_order_item_mm~get_delivery_address.

    IF is_address_handling_active( ) = abap_true.
      DATA ls_item TYPE mepoitem.
      get_data(
        IMPORTING
          ex_data =  ls_item    " Data Part
        EXCEPTIONS
          failure = 1           " Error
          OTHERS  = 2
      ).
      IF sy-subrc <> 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*       WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ELSE.
        rs_address = me->get_delivery_address( is_item = ls_item iv_addrnumber_only = iv_addrnumber_only ).
      ENDIF.
    ENDIF.

  ENDMETHOD.


METHOD if_purchase_order_item_mm~get_data .
  CALL METHOD me->get_data
    IMPORTING
      ex_data = re_data.
ENDMETHOD.                    "if_purchase_order_item_mm~get_data


METHOD if_purchase_order_item_mm~get_confirmation_handler.
  re_manager = me->confirmation_handle.
ENDMETHOD.


METHOD if_purchase_order_item_mm~get_conditions .

  DATA: l_header      TYPE REF TO cl_po_header_handle_mm,
        lt_conditions TYPE mmpur_tkomv,
        ls_cond_entry LIKE LINE OF lt_conditions,
        l_kposn       TYPE komv-kposn.

  CLEAR ex_conditions.
  mmpur_dynamic_cast l_header my_parent.
  CHECK NOT l_header IS INITIAL.

  CALL METHOD l_header->get_tkomv
    IMPORTING
      ex_tkomv = lt_conditions.

  l_kposn = po_item_number.
  READ TABLE lt_conditions WITH KEY kposn = l_kposn BINARY SEARCH
             TRANSPORTING NO FIELDS.
  IF sy-subrc IS INITIAL.
    LOOP AT lt_conditions INTO ls_cond_entry FROM sy-tabix.
      IF ls_cond_entry-kposn NE l_kposn.
        EXIT.
      ENDIF.
      APPEND ls_cond_entry TO ex_conditions.
    ENDLOOP.
  ELSE.
    PERFORM mepo_badi_get_conditions IN PROGRAM saplmepo
                                    USING    l_kposn
                                    CHANGING ex_conditions.
  ENDIF.

ENDMETHOD.


METHOD if_purchase_order_item_mm~get_accountings .

  DATA: lt_accountings    TYPE mmpur_models,
        ls_accounting     LIKE LINE OF lt_accountings,
        ls_accounting_new LIKE LINE OF re_accountings.

  CALL METHOD me->get_po_accountings
    IMPORTING
      ex_accountings = lt_accountings.
  LOOP AT lt_accountings INTO ls_accounting.
    ls_accounting_new-accounting ?= ls_accounting-model.
    APPEND ls_accounting_new TO re_accountings.
  ENDLOOP.

ENDMETHOD.


METHOD if_purchase_order_item_mm~create_schedule.

  DATA: l_schedule      TYPE REF TO cl_po_schedule_handle_mm,
        l_header        TYPE REF TO cl_po_header_handle_mm,
        ls_meposchedule TYPE meposchedule,
        l_model         TYPE REF TO if_model_mm,
        l_model_entry   TYPE mmpur_model_type.

  CREATE OBJECT l_schedule
    EXPORTING
      im_po_schedule_number = im_etenr
      im_po_item            = me
    EXCEPTIONS
      failure = 1
      OTHERS  = 2.

  CHECK sy-subrc IS INITIAL.
  re_schedule = l_schedule.

  l_header ?= my_parent.
  ls_meposchedule-ebeln = l_header->po_number.
  ls_meposchedule-ebelp = po_item_number.
  ls_meposchedule-etenr = im_etenr.
  ls_meposchedule-id = id.

  CALL METHOD l_schedule->set_data( im_data = ls_meposchedule ).

  l_model ?= me.
  READ TABLE l_header->my_recheck_queue WITH KEY model = l_model TRANSPORTING NO FIELDS.
  IF NOT sy-subrc IS INITIAL.
    l_model_entry-model = l_model.
    APPEND l_model_entry TO l_header->my_recheck_queue.
  ENDIF.

ENDMETHOD.                    "


METHOD if_purchase_order_item_mm~create_account.

  DATA: l_accounting      TYPE REF TO cl_po_accounting_handle_mm,
        l_header          TYPE REF TO cl_po_header_handle_mm,
        ls_mepoaccounting TYPE mepoaccounting,
        l_model           TYPE REF TO if_model_mm,
        l_model_entry     TYPE mmpur_model_type.

  CREATE OBJECT l_accounting
    EXPORTING
      im_po_accounting_number = im_zexkn
      im_po_item              = me
    EXCEPTIONS
      failure = 1
      OTHERS  = 2.

  CHECK sy-subrc IS INITIAL.
  re_account = l_accounting.

  l_header ?= my_parent.
  ls_mepoaccounting-ebeln = l_header->po_number.
  ls_mepoaccounting-ebelp = po_item_number.
  ls_mepoaccounting-zexkn = im_zexkn.
  ls_mepoaccounting-id = id.

  CALL METHOD l_accounting->set_data( im_data = ls_mepoaccounting ).

  l_model ?= me.
  READ TABLE l_header->my_recheck_queue WITH KEY model = l_model TRANSPORTING NO FIELDS.
  IF NOT sy-subrc IS INITIAL.
    l_model_entry-model = l_model.
    APPEND l_model_entry TO l_header->my_recheck_queue.
  ENDIF.

ENDMETHOD.                    "


METHOD IF_MESSAGE_OBJ_MM~DESCRIBE.

  RE_DESCRIPTION = SUPER->IF_MESSAGE_OBJ_MM~DESCRIBE( ).

  RE_DESCRIPTION-OBJTYP = C_OBJTYP.
  RE_DESCRIPTION-VARKEY+10(5) = PO_ITEM_NUMBER.

ENDMETHOD.


METHOD if_longtexts_mm~set_text.
  PERFORM text_set_lines IN PROGRAM saplmepo USING po_item_number
                                                   im_tdid
                                                   im_textlines.
ENDMETHOD.


  METHOD set_subitems_visibility.

ENHANCEMENT-POINT CL_PO_ITEM_HANDLE_MM_04 SPOTS ES_CL_PO_ITEM_HANDLE_MM .

ENDMETHOD.


METHOD set_state.

  CHECK state NE im_state.

  IF im_state EQ c_deleted.
    DATA: l_header TYPE REF TO cl_po_header_handle_mm.
    l_header ?= my_parent.
    CALL METHOD l_header->remove_item( me ).
  ENDIF.

  IF state EQ c_verify.
    DELETE TABLE po_item_hash_table WITH TABLE KEY item = me.
    DELETE TABLE po_itemx_hash_table WITH TABLE KEY item = me.
  ENDIF.

  CALL METHOD super->set_state( im_state ).

ENDMETHOD.


METHOD set_shipping_datax.

  DATA: wa      LIKE LINE OF po_ekpvx_hash_table.

  CHECK state NE c_deleted.

  READ TABLE po_ekpvx_hash_table INTO wa WITH TABLE KEY item = me.
  wa-data = im_data.
  IF sy-subrc IS INITIAL.
    MODIFY TABLE po_ekpvx_hash_table FROM wa.
  ELSE.
    wa-item = me.
    INSERT wa INTO TABLE po_ekpvx_hash_table.
  ENDIF.

ENDMETHOD.


METHOD SET_PO_ITEM_NUMBER.

  po_item_number = im_po_item_number.
ENDMETHOD.


METHOD SET_PARENT.


  DATA: L_ITEM TYPE REF TO CL_PO_HEADER_HANDLE_MM.

  IF NOT MY_PARENT IS INITIAL.
    RAISE ALREADY_SET.
  ELSE.
    MMPUR_DYNAMIC_CAST L_ITEM IM_PARENT.
    IF NOT L_ITEM IS INITIAL.
      MY_PARENT = L_ITEM.
    ELSE.
      RAISE CANNOT_BE_SET.
    ENDIF.
  ENDIF.

ENDMETHOD.


























METHOD set_invoice_plan.
* check EhP4 Switch of BF LOG_MMFI_P2P
  CHECK cl_ops_switch_check=>mm_sfws_ci_01( )
     EQ cl_mmpur_constants=>yes.
* set invoice plan instance
  CHECK im_ip IS BOUND.
  CLEAR my_invoice_plan.
  me->my_invoice_plan = im_ip.

ENDMETHOD.


METHOD set_datax .

  DATA: wa      LIKE LINE OF po_itemx_hash_table.

  CHECK state NE c_deleted.

  READ TABLE po_itemx_hash_table INTO wa WITH TABLE KEY item = me.
  wa-data = im_data.
  IF sy-subrc IS INITIAL.
    MODIFY TABLE po_itemx_hash_table FROM wa.
  ELSE.
    wa-item = me.
    INSERT wa INTO TABLE po_itemx_hash_table.
  ENDIF.

ENDMETHOD.                    "


METHOD set_data.

  DATA: wa      LIKE LINE OF po_item_hash_table,
        l_data  TYPE mepoitem.

  CHECK state NE c_deleted.

  wa-item = me.
  wa-data = im_data.
  wa-data-mandt = sy-mandt.       "1655101

  IF state EQ c_verify.
    MODIFY TABLE po_item_hash_table FROM wa.
  ELSE.
    IF state EQ c_available.
      CALL METHOD me->get_data
        IMPORTING
          ex_data = l_data.
    ENDIF.
* note 999401: a dummy hash entry is also needed for state 'new'
    me->chp_add_hash_entry( im_data = l_data ).
    INSERT wa INTO TABLE po_item_hash_table.
    state = c_verify.
  ENDIF.

ENDMETHOD.                    "


METHOD set_confirmation_handle.

  CHECK: im_header IS BOUND,
         me->if_purchase_order_item_mm~is_persistent( )
                               EQ cl_mmpur_constants=>yes.
  TRY.
      confirmation_handle = im_header->lookup( po_item_number ).
    CATCH cx_mmpur_not_found.
      CLEAR confirmation_handle.
  ENDTRY.

ENDMETHOD.


  METHOD reset_subitems_visibility.

ENHANCEMENT-POINT CL_PO_ITEM_HANDLE_MM_05 SPOTS ES_CL_PO_ITEM_HANDLE_MM .

ENDMETHOD.


METHOD remove_po_schedules.

  DATA: l_schedule_line LIKE LINE OF my_schedules,
        l_po_schedule   TYPE REF TO cl_po_schedule_handle_mm,
        l_hd            TYPE REF TO cl_message_handler_mm.

  CALL METHOD cl_message_handler_mm=>get_handler
                                        IMPORTING ex_handler = l_hd.

  LOOP AT my_schedules INTO l_schedule_line.

    l_po_schedule ?= l_schedule_line-model.

* remove events
    CALL METHOD l_hd->remove_by_bo( im_business_obj = l_po_schedule ).

* remove ids
    CALL METHOD cl_handle_manager_mm=>remove
                               EXPORTING im_id = l_po_schedule->id
                               EXCEPTIONS failure = 01.
    IF sy-subrc NE 0.
      RAISE failure.
    ENDIF.
    DELETE me->mth_hash WHERE model EQ l_po_schedule.      "2568712
  ENDLOOP.

  REFRESH my_schedules.

ENDMETHOD.


METHOD remove_po_schedule.

  DATA: l_sch   TYPE REF TO cl_po_schedule_handle_mm,
        l_index TYPE sy-tabix,
        l_hd    TYPE REF TO cl_message_handler_mm.

  mmpur_dynamic_cast l_sch im_schedule.
  IF l_sch IS INITIAL.
    RAISE failure.
  ENDIF.

  READ TABLE my_schedules WITH KEY model = im_schedule
             TRANSPORTING NO FIELDS.
  l_index = sy-tabix.
  IF sy-subrc NE 0.
    RAISE failure.
  ENDIF.

  DELETE my_schedules INDEX l_index.

* remove events
  CALL METHOD cl_message_handler_mm=>get_handler
                                        IMPORTING ex_handler = l_hd.
  CALL METHOD l_hd->remove_by_bo( im_business_obj = l_sch ).

* remove ids
  CALL METHOD cl_handle_manager_mm=>remove
                             EXPORTING im_id = l_sch->id
                             EXCEPTIONS failure = 01.
  IF sy-subrc NE 0.
    RAISE failure.
  ENDIF.
 DELETE me->mth_hash WHERE model EQ im_schedule.      "2568712
ENDMETHOD.


METHOD remove_po_accountings.

  DATA: l_accounting_line LIKE LINE OF my_accountings,
        l_po_accounting   TYPE REF TO cl_po_accounting_handle_mm,
        l_hd              TYPE REF TO cl_message_handler_mm.

  CALL METHOD cl_message_handler_mm=>get_handler
                                        IMPORTING ex_handler = l_hd.

  LOOP AT my_accountings INTO l_accounting_line.

    l_po_accounting ?= l_accounting_line-model.

* remove events
    CALL METHOD l_hd->remove_by_bo( im_business_obj = l_po_accounting ).

* remove ids
    CALL METHOD cl_handle_manager_mm=>remove
                               EXPORTING im_id = l_po_accounting->id
                               EXCEPTIONS failure = 01.
    IF sy-subrc NE 0.
      RAISE failure.
    ENDIF.

    DELETE me->mth_hash WHERE model EQ l_po_accounting.      "2568712

  ENDLOOP.

  REFRESH my_accountings.

ENDMETHOD.


METHOD remove_po_accounting.

  DATA: l_acc TYPE REF TO cl_po_accounting_handle_mm,
        l_index TYPE sy-tabix,
        l_hd    type ref to cl_message_handler_mm.

  mmpur_dynamic_cast l_acc im_accounting.
  IF l_acc IS INITIAL.
    RAISE failure.
  ENDIF.

  READ TABLE my_accountings WITH KEY model = im_accounting
             TRANSPORTING NO FIELDS.
  l_index = sy-tabix.
  IF sy-subrc NE 0.
    RAISE failure.
  ENDIF.

  DELETE my_accountings INDEX l_index.

* Remove events
  call method cl_message_handler_mm=>get_Handler
                                        importing ex_handler = l_hd.
  call method l_hd->remove_by_bo( im_business_obj = l_acc ).

* Remove id
  CALL METHOD cl_handle_manager_mm=>remove
                             EXPORTING im_id = l_acc->id
                             EXCEPTIONS failure = 01.
  IF sy-subrc NE 0.
    RAISE failure.
  ENDIF.
  DELETE me->mth_hash WHERE model EQ im_accounting.      "2568712
ENDMETHOD.


METHOD remove_items.

  CALL METHOD remove_po_schedules( ).

  CALL METHOD remove_po_accountings( ).

* -------Start Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM----*
 call method /nfm/remove_po_ne( ).
* -------End Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM------*

ENHANCEMENT-POINT CL_PO_ITEM_HANDLE_MM_03 SPOTS ES_CL_PO_ITEM_HANDLE_MM.
ENDMETHOD.


METHOD refresh_ekpv_data .

  DELETE TABLE po_ekpv_hash_table WITH TABLE KEY item = me.
  ekpv_changed = mmpur_no.

ENDMETHOD.                    "REFRESH_EKPV_DATA


METHOD refresh_ekpvx_data.

  DELETE TABLE po_ekpvx_hash_table WITH TABLE KEY item = me.

ENDMETHOD.


METHOD refresh_eipo_data .
  DELETE TABLE po_eipo_hash_table WITH TABLE KEY item = me.
  eipo_changed = mmpur_no.
ENDMETHOD.                    "REFRESH_EIPO_DATA


METHOD refresh_comsrv_data.


  LOOP AT acc_hash_table TRANSPORTING NO FIELDS
                         WHERE item = me.
    IF sy-subrc = 0.
      DELETE acc_hash_table INDEX sy-tabix.
    ENDIF.
  ENDLOOP.

  DELETE TABLE comsrv_hash_table WITH TABLE KEY item = me.
  CLEAR:   comsrv.
  comsrv_changed = mmpur_no.

ENDMETHOD.


METHOD lookup_schedule .

  DATA: wa         LIKE LINE OF my_schedules,
        l_schedule TYPE REF TO cl_po_schedule_handle_mm,
        l_handle   TYPE REF TO cl_handle_mm,                   "1428972
        l_parent   TYPE REF TO cl_po_header_handle_mm,         "1428972
        l_s_lookup_hash TYPE cl_handle_mm=>type_s_lookup_hash. "1428972

  CLEAR re_schedule.
  CHECK NOT im_schedule_number IS INITIAL.

  "1428972 get schedule via get_hash_entry, if this fails use old logic
  l_parent ?= me->my_parent.
  l_s_lookup_hash-ebeln = l_parent->po_number.
  l_s_lookup_hash-ebelp = me->po_item_number.
  l_s_lookup_hash-etenr = im_schedule_number.
  CALL METHOD ME->GET_HASH_ENTRY
    EXPORTING
      IS_DATA = l_s_lookup_hash
    IMPORTING
      EX_MODEL = l_handle.

  TRY.                                                         "1428972
    re_schedule ?= l_handle.
    CATCH cx_sy_move_cast_error.  "#EC *
  ENDTRY.
  IF re_schedule IS INITIAL.                                   "1428972
  LOOP AT my_schedules INTO wa.
    l_schedule ?= wa-model.
    IF l_schedule->po_schedule_number EQ im_schedule_number.
      re_schedule = l_schedule.
      EXIT.
    ENDIF.
  ENDLOOP.
  ENDIF.                                                       "1428972

ENDMETHOD.                    "LOOKUP_SCHEDULE


METHOD lookup_accounting .

  DATA: wa        LIKE LINE OF my_accountings,
        l_account TYPE REF TO cl_po_accounting_handle_mm,
        l_handle  TYPE REF TO cl_handle_mm,                    "1428972
        l_parent  TYPE REF TO cl_po_header_handle_mm,          "1428972
        l_s_lookup_hash TYPE cl_handle_mm=>type_s_lookup_hash. "1428972

  CLEAR re_accounting.
  CHECK NOT im_accounting_number IS INITIAL.

  "1428972 get acc via get_hash_entry, if this fails use old logic
  l_parent ?= me->my_parent.
  l_s_lookup_hash-ebeln = l_parent->po_number.
  l_s_lookup_hash-ebelp = me->po_item_number.
  l_s_lookup_hash-zekkn = im_accounting_number.
  CALL METHOD ME->GET_HASH_ENTRY
    EXPORTING
      IS_DATA = l_s_lookup_hash
    IMPORTING
      EX_MODEL = l_handle.

  TRY.                                                         "1428972
    re_accounting ?= l_handle.
  CATCH cx_sy_move_cast_error.  "#EC *
  ENDTRY.
  IF re_accounting IS INITIAL.
  LOOP AT my_accountings INTO wa.
    l_account ?= wa-model.
    IF l_account->po_accounting_number EQ im_accounting_number.
      re_accounting = l_account.
      EXIT.
    ENDIF.
  ENDLOOP.
  ENDIF.                                                       "1428972

ENDMETHOD.


METHOD if_services_mm~set_data.


  DATA: wa_comsrv TYPE po_comsrv_hash_entry.

  DATA: wa_acc_tab  TYPE ueskn,
        wa_acc_hash TYPE po_acc_hash_entry,
        it_acc_hash TYPE STANDARD TABLE OF po_acc_hash_entry
                    WITH NON-UNIQUE KEY item .

  LOOP AT im_acc_tab INTO wa_acc_tab.
    MOVE-CORRESPONDING wa_acc_tab TO wa_acc_hash-data.
    wa_acc_hash-item = me.
    INSERT wa_acc_hash INTO TABLE it_acc_hash.
  ENDLOOP.

  APPEND LINES OF it_acc_hash TO acc_hash_table.

  wa_comsrv-item = me.
  wa_comsrv-data = im_comsrv.
  comsrv         = im_comsrv.
  INSERT wa_comsrv INTO TABLE comsrv_hash_table.

  comsrv_changed = mmpur_yes.

endmethod.


METHOD if_services_mm~get_srv_data .

  DATA: my_esuh TYPE LINE OF mmsrv_esuh,
        lt_esuc TYPE mmsrv_esuc,                             "2605601
        ls_esuc TYPE LINE OF mmsrv_esuc,                     "2605601
        lv_arch TYPE sytabix,                               "976264
        lo_arch TYPE  REF TO cl_mmpur_archive.

  lv_arch =
    cl_mmpur_archive=>if_mmpur_archive~get_archive_handle( im_ebeln ).

  IF lv_arch IS INITIAL.
    IF im_limit EQ mmpur_no.
* get ESLL for specific package number
      CALL FUNCTION 'MS_READ_SERVICES'
        EXPORTING
          i_hpackno = im_packno
        TABLES
          t_esll    = ex_esll.
    ENDIF.

*  get Limit information for package number
    CALL FUNCTION 'MS_READ_LIMITS'
      EXPORTING
        packno          = im_packno
      IMPORTING
        e_esuh          = my_esuh
      TABLES
        limit_tab       = lt_esuc                            "2605601
      EXCEPTIONS
        no_limits_found = 1
        OTHERS          = 2.
    IF sy-subrc EQ 2.
      RAISE failure.
    ENDIF.

*   Limits ESUH
    IF my_esuh-packno NE space.
      INSERT my_esuh INTO TABLE ex_esuh.
    ENDIF.

    LOOP AT lt_esuc INTO ls_esuc.                          "^_2605601
      IF NOT ls_esuc-ebeln IS INITIAL.
        INSERT ls_esuc INTO TABLE ex_esuc.
      ENDIF.
    ENDLOOP.                                               "v_2605601

*   get account assignment information
    CALL FUNCTION 'MS_ACCOUNT_READ_ESKL'
      EXPORTING
        i_packno = im_packno
      TABLES
        t_eskl   = ex_eskl.
  ELSE.                                                     "976264
    TRY.
        cl_mmpur_archive=>if_mmpur_archive~get_archived_srv(
                                            EXPORTING im_ebeln  = im_ebeln
                                                      im_packno = im_packno
                                            IMPORTING ex_esll   = ex_esll
                                                      ex_esuh   = ex_esuh
                                                      ex_esuc   = ex_esuc
                                                      ex_eskl   = ex_eskl ).
      CATCH cx_mmpur_not_found .
        RAISE failure.
    ENDTRY.
  ENDIF.

ENDMETHOD.


METHOD if_services_mm~get_data.


  DATA: ch_return TYPE sy-subrc.

  DATA: wa_acc_tab  TYPE ueskn,
        wa_acc_hash TYPE po_acc_hash_entry,
        it_acc_tab  TYPE STANDARD TABLE OF ueskn.

  DATA: wa_comsrv TYPE po_comsrv_hash_entry.

  READ TABLE comsrv_hash_table INTO wa_comsrv
                               WITH TABLE KEY item = me.
  IF sy-subrc = 0.
    MOVE-CORRESPONDING wa_comsrv-data TO comsrv.
    "2261691
    LOOP AT acc_hash_table INTO wa_acc_hash
                           WHERE item = me.
      MOVE-CORRESPONDING wa_acc_hash-data TO wa_acc_tab.
      INSERT wa_acc_tab INTO TABLE it_acc_tab.
    ENDLOOP.
    APPEND LINES OF it_acc_tab TO ex_acc_tab.
    ex_comsrv = comsrv.
  ELSE.
* Datenbeschaffung
    PERFORM get_item_services IN PROGRAM saplmepo
                                        TABLES   ex_acc_tab
                                        USING    po_item_number
                                                 im_limit
                                        CHANGING ex_comsrv
                                                 ch_return.

    IF NOT ch_return IS INITIAL.
      RAISE illegal_data.
    ENDIF.
  ENDIF.

  SORT ex_acc_tab BY packno zekkn.                          "670392

ENDMETHOD.


METHOD IF_PURCHASING_DOCUMENT_ITEM~GET_SCHEDULE_LINES.

* ...
  DATA: l_schedules TYPE mmpur_models,
        wa_schedules LIKE LINE OF l_schedules,
        wa_obj  LIKE LINE OF re_schedule_lines.

  refresh re_schedule_lines.
  CALL METHOD get_po_schedules IMPORTING ex_schedules = l_schedules.

  LOOP AT l_schedules INTO wa_schedules.
    wa_obj-object ?= wa_schedules-model.
    APPEND wa_obj TO re_schedule_lines.
  ENDLOOP.

ENDMETHOD.


METHOD if_purchasing_document_item~get_ekpo.


  DATA: l_mepoitem TYPE mepoitem.
  CLEAR re_ekpo.

  CALL METHOD get_data( IMPORTING ex_data = l_mepoitem ).

  MOVE-CORRESPONDING l_mepoitem TO re_ekpo.                 "#EC ENHOK

ENDMETHOD.


method IF_ACCT_CONTAINER_MM~GET_DATA.
* ...
endmethod.


METHOD IF_ACCT_CONTAINER_MM~GET_COMPANY_CODE.

    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

*  hack

    re_bukrs = l_mepoitem-bukrs.
ENDMETHOD.


METHOD IF_ACCT_CONTAINER_MM~GET_CATEGORY.


    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

    re_knttp = l_mepoitem-knttp.

ENDMETHOD.


METHOD IF_ACCT_CONTAINER_MM~CREATE_ITEM.

  DATA: L_NEW_ACCOUNTING TYPE REF TO CL_PO_ACCOUNTING_HANDLE_MM.

  create object
         l_new_accounting exporting im_po_accounting_number = 0
                                    im_po_item    = me
                                    im_po_item_id = me->id.

  re_object = l_new_accounting.









ENDMETHOD.


METHOD if_acct_container_mm~create_assets.

  DATA: ls_exkn       TYPE exkn,
        l_tabix       TYPE sy-tabix,
        l_item_data   TYPE mepoitem,
        l_header_data TYPE mepoheader,
        l_header      TYPE REF TO cl_po_header_handle_mm,
        lt_items      TYPE mmpur_accounting_list,
        ls_acc_item   LIKE LINE OF lt_items,
        lt_anltab     TYPE STANDARD TABLE OF raist06 INITIAL SIZE 0,
        ls_anltab     LIKE LINE OF lt_anltab,
        l_anz_anl     TYPE i,
        l_anla        TYPE anla,
        l_anlz        TYPE anlz,
        l_nassets_max TYPE ra02s-nassets,
        l_anlkl       TYPE t023-anlkl,       "Vorschlagsanlagenklasse
        l_t023        TYPE t023,
        l_t023t       TYPE t023t.

  mmpur_dynamic_cast l_header my_parent.

  IF l_header IS INITIAL.
    RAISE failed.
  ENDIF.

  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_item_data.
  CALL METHOD l_header->get_data
    IMPORTING
      ex_data = l_header_data.

  IF l_item_data-kzvbr NE 'A'        OR
     l_item_data-pstyp EQ '9'.

    RAISE not_supported.

  ENDIF.

  IF l_item_data-bukrs EQ space.

    RAISE required_field_empty.

  ENDIF.

  IF l_item_data-matkl NE space.
    PERFORM matkl IN PROGRAM sapfmmex
                            USING    l_item_data-matkl
                            CHANGING l_t023 l_t023t.
    l_anlkl = l_t023-anlkl.
  ENDIF.

  l_anla-bukrs = l_item_data-bukrs.
  l_anla-lifnr = l_header_data-lifnr.
  l_anla-meins = l_item_data-meins.
  l_anla-txt50 = l_item_data-txz01.
  l_anla-anlkl = l_anlkl.
  l_anla-bstdt = l_header_data-bedat.
  l_anlz-werks = l_item_data-werks.

  lt_items = me->if_acct_container_mm~get_items( ).

  LOOP AT im_items INTO ls_acc_item.
    READ TABLE lt_items WITH KEY model = ls_acc_item-model
          TRANSPORTING NO FIELDS.

    IF sy-subrc NE 0.
      RAISE failed.
    ENDIF.
  ENDLOOP.

  DESCRIBE TABLE im_items LINES l_nassets_max.

  IF l_nassets_max > 99.
    RAISE too_many_accounting_models.
  ENDIF.

  CALL FUNCTION 'CREATE_ASSET'
    EXPORTING
      i_anla                     = l_anla
      i_anlz                     = l_anlz
      i_nassets                  = l_nassets_max
      i_nassets_max              = l_nassets_max
      i_dark                     = ' '
      i_nassets_fix              = ' '
      i_called_by_purchase_order = 'X'
    TABLES
      t_assets                   = lt_anltab.

  DESCRIBE TABLE lt_anltab LINES l_anz_anl.

  IF l_anz_anl = 0.
    RAISE no_assets_created.
  ENDIF.

  l_tabix = 1.

  LOOP AT lt_anltab INTO ls_anltab.

    IF l_tabix > l_nassets_max.
      EXIT.
    ENDIF.

    READ TABLE im_items INTO ls_acc_item INDEX l_tabix.

    IF sy-subrc NE 0.
      EXIT.
    ENDIF.

    ADD 1 TO l_tabix.

    ls_exkn = ls_acc_item-model->get_exkn( ).

    IF NOT ls_anltab-real_anln1 IS INITIAL.
      ls_exkn-anln1 = ls_anltab-real_anln1.
    ELSE.
      ls_exkn-anln1 = ls_anltab-temp_anln1.
    ENDIF.
    ls_exkn-anln2 = ls_anltab-anln2.

    CALL METHOD ls_acc_item-model->set_exkn( ls_exkn ).

  ENDLOOP.

  PERFORM knt_anla_verb_merken IN PROGRAM saplmepo USING 'X'.

ENDMETHOD.


METHOD HAS_PO_SCHEDULES.


  DATA: N TYPE I.

  DESCRIBE TABLE MY_SCHEDULES LINES N.
  EX_COUNT = N.

ENDMETHOD.


METHOD HAS_PO_ACCOUNTINGS.


  DATA: N TYPE I.

  DESCRIBE TABLE MY_ACCOUNTINGS LINES N.
  EX_COUNT = N.

ENDMETHOD.


METHOD get_shipping_datax.

  DATA l_hash_entry LIKE LINE OF po_ekpvx_hash_table.

  CLEAR re_data.
  CHECK state EQ c_verify.
  READ TABLE po_ekpvx_hash_table INTO l_hash_entry
             WITH TABLE KEY item = me.
  IF sy-subrc IS INITIAL.
    re_data = l_hash_entry-data.
  ENDIF.
ENDMETHOD.


METHOD get_po_subitems.

  DATA: lt_id TYPE STANDARD TABLE OF mepo_id INITIAL SIZE 0,
        ls_id LIKE LINE OF lt_id,
        wa LIKE LINE OF ex_subitems,
        l_handle TYPE REF TO cl_handle_mm.

  REFRESH ex_subitems.

  CALL FUNCTION 'MEPO_DOC_SUBITEMS_ID_GET'
       EXPORTING
            im_ebelp      = po_item_number
            im_uptyp      = im_uptyp
       TABLES
            ext_item      = lt_id.

  LOOP AT lt_id INTO ls_id.

    CALL METHOD cl_handle_manager_mm=>get
                                   EXPORTING im_id = ls_id-id
                                   IMPORTING ex_handle = l_handle.
    wa-model ?= l_handle.
    APPEND wa TO ex_subitems.

  ENDLOOP.

ENDMETHOD.


METHOD get_po_schedules.

  DATA: lt_id TYPE STANDARD TABLE OF mepo_id INITIAL SIZE 0,
        ls_id LIKE LINE OF lt_id,
        wa LIKE LINE OF ex_schedules,
        l_handle TYPE REF TO cl_handle_mm.

  REFRESH ex_schedules.

  CALL FUNCTION 'MEPO_DOC_ITEM_SCHEDULES_ID_GET'
       EXPORTING
            im_ebelp      = po_item_number
       TABLES
            ext_schedules = lt_id.

  LOOP AT lt_id INTO ls_id.

    CALL METHOD cl_handle_manager_mm=>get
                                   EXPORTING im_id = ls_id-id
                                   IMPORTING ex_handle = l_handle.
    wa-model ?= l_handle.
    APPEND wa TO ex_schedules.

  ENDLOOP.

ENDMETHOD.


METHOD GET_PO_ACCOUNTINGS.


  DATA: LT_ID TYPE STANDARD TABLE OF MEPO_ID INITIAL SIZE 0,
        LS_ID LIKE LINE OF LT_ID,
        WA LIKE LINE OF EX_ACCOUNTINGS,
        L_HANDLE TYPE REF TO CL_HANDLE_MM.

  REFRESH EX_ACCOUNTINGS.

  CALL FUNCTION 'MEPO_DOC_ITEM_ACCOUNTS_ID_GET'
       EXPORTING
            IM_EBELP     = PO_ITEM_NUMBER
       TABLES
            EXT_ACCOUNTS = LT_ID.

  LOOP AT LT_ID INTO LS_ID.

    CALL METHOD CL_HANDLE_MANAGER_MM=>GET
                                   EXPORTING IM_ID = LS_ID-ID
                                   IMPORTING EX_HANDLE = L_HANDLE.
    WA-MODEL ?= L_HANDLE.
    APPEND WA TO EX_ACCOUNTINGS.

  ENDLOOP.


ENDMETHOD.


METHOD get_mapping .

  DATA: l_mfs TYPE REF TO cl_mfs_mm,
        ls_fs LIKE LINE OF my_fs_template.

  FIELD-SYMBOLS: <mapping> LIKE LINE OF my_field_mapping.

  IF my_field_mapping[] IS INITIAL.
    l_mfs = cl_mfs_mm=>get_instance( ).
    my_field_mapping = l_mfs->lookup( im_application = 'MMPUR_PO_DOC'
                                      im_tabname     = 'EKPO' ).
    LOOP AT my_field_mapping ASSIGNING <mapping> WHERE NOT metafield IS initial.
      ls_fs-metafield = <mapping>-metafield.
      INSERT ls_fs INTO TABLE my_fs_template.
    ENDLOOP.
  ENDIF.

  ex_mapping = my_field_mapping.
  ex_fs_template = my_fs_template.

ENDMETHOD.


METHOD get_invoice_plan.
* check EhP4 Switch of BF LOG_MMFI_P2P
  CHECK cl_ops_switch_check=>mm_sfws_ci_01( )
     EQ cl_mmpur_constants=>yes.
* return invoice plan instance
  re_ip = me->my_invoice_plan.
ENDMETHOD.


  METHOD get_delivery_address.

    IF is_address_handling_active( ).

      IF is_item-adrnr IS NOT INITIAL.
        rs_address-addrnumber  = is_item-adrnr.
      ELSEIF is_item-adrn2 IS NOT INITIAL.
        rs_address-addrnumber  = is_item-adrn2.
      ELSEIF is_item-emlif IS NOT INITIAL.
        SELECT SINGLE adrnr FROM lfa1 INTO rs_address-addrnumber WHERE lifnr = is_item-emlif.
      ELSEIF is_item-kunnr IS NOT INITIAL.
        SELECT SINGLE adrnr FROM kna1 INTO rs_address-addrnumber WHERE kunnr = is_item-kunnr.

      ELSEIF is_item-lgort IS NOT INITIAL.
        CALL FUNCTION 'MM_DELIVERY_ADDRESS_PROPOSE'
          EXPORTING
            i_werks = is_item-werks
            i_lgort = is_item-lgort
          IMPORTING
            e_adrnr = rs_address-addrnumber .
        IF sy-subrc <> 0.
* Error Handling
        ENDIF.

        IF rs_address-addrnumber IS INITIAL.
          SELECT SINGLE adrnr INTO rs_address-addrnumber FROM t001w WHERE werks = is_item-werks.
        ENDIF.
      ELSEIF is_item-werks IS NOT INITIAL.
        SELECT SINGLE adrnr INTO rs_address-addrnumber FROM t001w WHERE werks = is_item-werks.
      ENDIF.

      IF NOT rs_address-addrnumber IS INITIAL.
        IF iv_addrnumber_only <> abap_true.
          rs_address = mr_address_handler->read_address( iv_address_number = |{ rs_address-addrnumber ALPHA = IN }| ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.


METHOD get_datax .
  DATA: l_hash_entry LIKE LINE OF po_itemx_hash_table,
      l_ref        TYPE REF TO data,
      lt_fcat      TYPE mepo_t_fieldcatalog,
      l_postfix    TYPE string40,
      l_prop       TYPE REF TO cl_proposer_mm,
      l_name       TYPE string40.

  FIELD-SYMBOLS: <data> TYPE mepoitem_prop,
                 <fcat> LIKE LINE OF lt_fcat,
                 <source> TYPE ANY,
                 <target> TYPE ANY.

  CLEAR ex_data.

  IF state EQ c_verify.
    READ TABLE po_itemx_hash_table INTO l_hash_entry
               WITH TABLE KEY item = me.
    IF sy-subrc IS INITIAL.
      ex_data = l_hash_entry-data.
    ENDIF.

  ELSEIF state EQ c_new.
* propose data. Note: in display or change mode the state becomes NEVER
* 'new'.
    CALL METHOD check_proposer.
    IF NOT my_item_proposer IS INITIAL.
      l_prop ?= my_item_proposer.
      lt_fcat = l_prop->get_selected_fcat( ).
      l_postfix = l_prop->get_postfix( ).
      CHECK NOT l_postfix IS INITIAL.
      CALL METHOD my_item_proposer->get_data
        IMPORTING
          ex_data = l_ref.
      IF NOT l_ref IS INITIAL.
        ASSIGN l_ref->* TO <data>.
        LOOP AT lt_fcat ASSIGNING <fcat>.
          CONCATENATE <fcat>-fieldname l_postfix INTO l_name.
          ASSIGN COMPONENT l_name OF STRUCTURE <data>
                                     TO <source>.
          CHECK sy-subrc IS INITIAL.
          ASSIGN COMPONENT <fcat>-fieldname OF STRUCTURE ex_data
                                     TO <target>.
          CHECK sy-subrc IS INITIAL.
          <target> = <source>.
        ENDLOOP.

      ENDIF.
    ENDIF.

  ENDIF.

  ex_data-ebelp_key = po_item_number.
  ex_data-item_id = id.

ENDMETHOD.                    "


METHOD get_data.

  DATA: l_hash_entry LIKE LINE OF po_item_hash_table,
        l_ref        TYPE REF TO data,
        l_header     TYPE REF TO cl_po_header_handle_mm,

        ls_matnr     TYPE LINE OF /sapsll/matnr_t,
        lt_matnr     TYPE /sapsll/matnr_t,
        ls_result    TYPE /sapsll/mm_cls_ret_s,
        lt_result    TYPE /sapsll/mm_cls_ret_st,
        lo_intra     TYPE REF TO /sapsll/cl_mm_cls_service,
        oref         TYPE REF TO /sapsll/cx_mm_cls_serv.


  FIELD-SYMBOLS: <data> TYPE mepoitem_prop.

  CLEAR ex_data.

  IF state EQ c_verify.
    READ TABLE po_item_hash_table INTO l_hash_entry
               WITH TABLE KEY item = me.
    IF sy-subrc NE 0.
      RAISE failure.
    ENDIF.
    ex_data = l_hash_entry-data.

  ELSEIF state EQ c_available.

    CALL FUNCTION 'MEPO_DOC_ITEM_GET'
      EXPORTING
        im_ebelp = po_item_number
      IMPORTING
        ex_item  = ex_data
      EXCEPTIONS
        failure  = 01.
    IF sy-subrc NE 0.
      DATA lv_dump_info TYPE string.
      lv_dump_info = cl_mm_pur_po_dump_helper=>msgid && '_' && cl_mm_pur_po_dump_helper=>msgno && '_' &&
                     cl_mm_pur_po_dump_helper=>msgv1 && '_' && cl_mm_pur_po_dump_helper=>msgv2 && '_' &&
                     cl_mm_pur_po_dump_helper=>msgv3 && '_' && cl_mm_pur_po_dump_helper=>msgv4 && '_' &&
                     cl_mm_pur_po_dump_helper=>level.
      RAISE failure.
    ELSE.

* retrieve commodity code for PO items with material master (for DISPLAY only)
      IF ex_data-stawn IS INITIAL     AND
         ex_data-matnr IS NOT INITIAL AND                   "3129216
         ex_data-werks IS NOT INITIAL AND
         ( ex_data-producttype = cl_mmpur_constants=>if_cmd_prdtype_const~material OR
           ex_data-producttype = cl_mmpur_constants=>if_cmd_prdtype_const~none ).

        REFRESH lt_matnr.
        CLEAR: ls_matnr, lt_matnr.

        ls_matnr = ex_data-matnr.                           "3129216
        APPEND ls_matnr TO lt_matnr.

        CREATE OBJECT lo_intra.

        IF NOT lo_intra IS INITIAL.
          TRY.
              CALL METHOD lo_intra->get_commodity_code_cls
                EXPORTING
                  it_matnr           = lt_matnr
                  iv_land1           = ex_data-land1
                  iv_valid_on        = ex_data-eindt
                IMPORTING
                  et_classifications = lt_result.
            CATCH /sapsll/cx_mm_cls_serv INTO oref.
          ENDTRY.
          READ TABLE lt_result INDEX 1 INTO ls_result.
          IF sy-subrc = 0.
            ex_data-stawn = ls_result-ccngn.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.

  ELSEIF state EQ c_new.
* propose data.
    CALL METHOD check_proposer.
    IF NOT my_item_proposer IS INITIAL.
      CALL METHOD my_item_proposer->get_data
        IMPORTING
          ex_data = l_ref.
      IF NOT l_ref IS INITIAL.

        ASSIGN l_ref->* TO <data>.
        CHECK sy-subrc IS INITIAL.
        MOVE-CORRESPONDING <data> TO ex_data.               "#EC ENHOK
        IF <data>-pstyp EQ '0'.
          ex_data-pstyp = space.
        ENDIF.
      ENDIF.
    ENDIF.

  ELSEIF state EQ c_deleted.
    l_header ?= my_parent.
    ex_data-mandt = sy-mandt.
    ex_data-ebeln = l_header->po_number.
    ex_data-ebelp = po_item_number.
    ex_data-loekz = 'D'.
  ELSE.
    CLEAR ex_data.
  ENDIF.

  ex_data-id = id.

ENDMETHOD.                    "get_data


METHOD FLUSH_DATA.

  raise illegal_call.
ENDMETHOD.


METHOD create_batch.

  DATA: l_header      TYPE REF TO cl_po_header_handle_mm,
        ls_mepoitem   TYPE mepoitem,
        l_header_data TYPE mepoheader,
        ls_mcha       TYPE mcha,
        ls_bncom      TYPE bncom.

  CALL METHOD me->get_data
    IMPORTING
      ex_data = ls_mepoitem.

  l_header ?= me->my_parent.

  CALL METHOD l_header->get_data( IMPORTING ex_data = l_header_data ).

  ls_mcha-matnr = ls_mepoitem-matnr.
  ls_mcha-werks = ls_mepoitem-werks.

  IF im_batch IS INITIAL.
    ls_mcha-charg = ls_mepoitem-charg.
  ELSE.
    ls_mcha-charg = im_batch.
  ENDIF.

  IF  cl_ops_switch_check=>sfsw_segmentation( ) = abap_on.
*Move Stock segment to LS_MCHA for creating Batch data with stock segment.
    MOVE ls_mepoitem-sgt_scat TO ls_mcha-sgt_scat.
  ENDIF.

  MOVE-CORRESPONDING ls_mepoitem   TO ls_bncom.             "#EC ENHOK
  MOVE-CORRESPONDING l_header_data TO ls_bncom.             "#EC ENHOK

  CALL FUNCTION 'VB_CREATE_BATCH'
    EXPORTING
      ymcha             = ls_mcha
      message_when_auto = 'X'
      x_bncom           = ls_bncom
    IMPORTING
      ymcha             = ls_mcha
    EXCEPTIONS
      error_message     = 1.

  IF sy-subrc EQ 0.
    ls_mepoitem-charg = ls_mcha-charg.
    CALL METHOD me->set_data( EXPORTING im_data = ls_mepoitem ).
  ELSE.
    RAISE failed.
  ENDIF.

ENDMETHOD.


METHOD constructor.

  DATA: l_header TYPE REF TO cl_po_header_handle_mm,
        l_handle type ref to cl_handle_mm.

  super->constructor(
      iv_address_handling_active = iv_address_handling_active
      io_address_handler         = io_address_handler " Interface for address handling in Purchase Order
      ).

  po_item_number = im_po_item_number.
  mmpur_dynamic_cast l_header im_po_header.
  IF not l_header is initial.

    CALL METHOD l_header->add_item( me ).

  ELSEIF not im_po_header_id is initial.

    CALL METHOD cl_handle_manager_mm=>get
      EXPORTING
        im_id     = im_po_header_id
      IMPORTING
        ex_handle = l_handle
      EXCEPTIONS
        failure   = 01.
    IF not sy-subrc is initial.
      RAISE failure.
    ENDIF.
    l_header ?= l_handle.
    CALL METHOD l_header->add_item( me ).
    l_header->is_address_handling_active( ).
  ELSE.
    RAISE failure.
  ENDIF.

* propagate the address handling attributes from the header to the new item created
  IF l_header->is_address_handling_active( ).
     set_address_handling( iv_address_handling_active = l_header->is_address_handling_active( ) ir_address_handler = l_header->get_address_handler( ) ).
  ENDIF.

  me->mv_rtts_name = 'MEPOITEM'.
ENDMETHOD.


METHOD CHP_REFRESH_HASH_TABLE.
  REFRESH CHP_HASH_TABLE[].
ENDMETHOD.


METHOD chp_add_hash_entry.

  DATA: l_hash_entry LIKE LINE OF chp_hash_table.

  l_hash_entry-item  = me.
  l_hash_entry-data  =  im_data.
  INSERT l_hash_entry INTO TABLE chp_hash_table.

ENDMETHOD.                    "


method CHECK_PROPOSER.

  DATA: fw TYPE REF TO cl_framework_mm,
        l_objecttype TYPE string40.

  CHECK my_item_proposer IS INITIAL.

  CALL METHOD cl_framework_mm=>get_instance IMPORTING ex_instance = fw.

  IF my_item_proposer IS INITIAL.
    l_objecttype = c_objtyp.
    my_item_proposer ?= fw->get_proposer( l_objecttype ).
  ENDIF.

endmethod.


METHOD CAN_INITIATE_FLUSH.


data: l_parent type ref to cl_po_header_handle_mm.

IF NOT my_PARENT IS INITIAL.

  l_parent ?= my_parent.
  CALL METHOD l_pARENT->CAN_INITIATE_FLUSH
          IMPORTING  EX_MODEL = EX_model
          EXCEPTIONS CANNOT_INITIATE = 1.
  IF SY-SUBRC NE 0.
    RAISE CANNOT_INITIATE.
  ENDIF.

ELSE.
  RAISE CANNOT_INITIATE.
ENDIF.

ENDMETHOD.


METHOD ADD_ITEM.


  DATA: L_SCHEDULE TYPE REF TO CL_PO_SCHEDULE_HANDLE_MM,
        L_ACCOUNTING TYPE REF TO CL_PO_ACCOUNTING_HANDLE_MM,
        L_SCHEDULE_ENTRY LIKE LINE OF MY_SCHEDULES,
        L_ACCOUNTING_ENTRY LIKE LINE OF MY_ACCOUNTINGS,
        L_PARENT TYPE REF TO CL_PO_HEADER_HANDLE_MM,           "1428972
        L_S_LOOKUP_HASH TYPE CL_HANDLE_MM=>TYPE_S_LOOKUP_HASH. "1428972

* -------Start Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM----*
  DATA: l_nfm_item  type ref to /nfm/cl_po_rohstof_handle_mm,     "/NFM/
        l_ne_data   like line of /nfm/my_ne_position.             "/NFM/
* -------End Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM------*

ENHANCEMENT-POINT CL_PO_ITEM_HANDLE_MM_01 SPOTS ES_CL_PO_ITEM_HANDLE_MM STATIC.

  MMPUR_DYNAMIC_CAST L_SCHEDULE IM_ITEM.
  IF NOT L_SCHEDULE IS INITIAL.

    L_SCHEDULE_ENTRY-MODEL = L_SCHEDULE.
    APPEND L_SCHEDULE_ENTRY TO  MY_SCHEDULES.
    CALL METHOD L_SCHEDULE->SET_PARENT( ME ).
    "Add schedule entry to hash table                          "1428972
    IF l_schedule->po_schedule_number IS NOT INITIAL.          "1428972
      CLEAR l_parent.
      l_parent ?= me->my_parent.
      L_S_LOOKUP_HASH-ebeln = l_parent->po_number.
      L_S_LOOKUP_HASH-ebelp = me->po_item_number.
      L_S_LOOKUP_HASH-etenr = l_schedule->po_schedule_number.
      L_S_LOOKUP_HASH-model = l_schedule.
      me->set_hash_entry( L_S_LOOKUP_HASH ).
     ENDIF.

  ELSE.

    MMPUR_DYNAMIC_CAST L_ACCOUNTING IM_ITEM.
    IF NOT L_ACCOUNTING IS INITIAL.

      L_ACCOUNTING_ENTRY-MODEL = L_ACCOUNTING.
      APPEND L_ACCOUNTING_ENTRY TO  MY_ACCOUNTINGS.
      CALL METHOD L_ACCOUNTING->SET_PARENT( ME ).
      "Add accounting entry to hash table                      "1428972
      IF l_accounting->po_accounting_number IS NOT INITIAL.    "1428972
      CLEAR l_parent.
      l_parent ?= me->my_parent.
      L_S_LOOKUP_HASH-ebeln = l_parent->po_number.
      L_S_LOOKUP_HASH-ebelp = me->po_item_number.
      L_S_LOOKUP_HASH-zekkn = l_accounting->po_accounting_number.
      L_S_LOOKUP_HASH-model = l_accounting.
      me->set_hash_entry( L_S_LOOKUP_HASH ).
      ENDIF.

    ELSE.
ENHANCEMENT-SECTION     CL_PO_ITEM_HANDLE_MM_02 SPOTS ES_CL_PO_ITEM_HANDLE_MM.

* -------Start Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM----*
      MMPUR_DYNAMIC_CAST l_nfm_item im_item.                      "/NFM/
      if not l_nfm_item is initial.                               "/NFM/
        l_ne_data-model = l_nfm_item.                             "/NFM/
        append l_ne_data to /nfm/my_ne_position.                  "/NFM/
        call method l_nfm_item->set_parent( me ).                 "/NFM/
      else.                                                       "/NFM/
      RAISE FAILURE.
      endif.                                                      "/NFM/
* -------End Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM------*

END-ENHANCEMENT-SECTION.
    ENDIF.
  ENDIF.

ENDMETHOD.


method /NFM/REMOVE_PO_NE.

* -------Start Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM----*
data: l_my_ne_position like line of /nfm/my_ne_position,
      l_ne_position    type ref to /nfm/cl_po_rohstof_handle_mm,
      l_hd             type ref to cl_message_handler_mm.
* -------End Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM------*

ENHANCEMENT-POINT /NFM/REMOVE_PO_NE_01 SPOTS ES_CL_PO_ITEM_HANDLE_MM STATIC.

* -------Start Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM----*
  call method cl_message_handler_mm=>get_handler
       importing ex_handler = l_hd.
  loop at /nfm/my_ne_position into l_my_ne_position.
    l_ne_position ?= l_my_ne_position-model.
*   delete data:
    call method l_ne_position->refresh_data
         exporting im_position = l_ne_position.
*   remove events:
    call method l_hd->remove_by_bo( im_business_obj = l_ne_position ).
*   remove ids:
    call method cl_handle_manager_mm=>remove
         exporting  im_id   = l_ne_position->id
         exceptions failure = 01.
    if sy-subrc ne 0.
      raise failure.
    endif.
  endloop.
  refresh /nfm/my_ne_position.
* -------End Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM------*

ENHANCEMENT-POINT /NFM/REMOVE_PO_NE_02 SPOTS ES_CL_PO_ITEM_HANDLE_MM.

endmethod.


method /NFM/GET_NFM_OBJECT.

* -------Start Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM----*
my_ne_position[] = /nfm/my_ne_position.
* -------End Application component:IS-MP-NF, Switch:/NFM/MM, Switch Description:NFM Processing MM------*

ENHANCEMENT-POINT /NFM/GET_NFM_OBJECT_01 SPOTS ES_CL_PO_ITEM_HANDLE_MM.
endmethod.


METHOD if_longtexts_mm~get_types.

  CLEAR ex_texttypes.
*  PERFORM text_get_types IN PROGRAM saplmepo USING    po_item_number
*                                             CHANGING ex_texttypes.
  CALL FUNCTION 'ME_PO_GET_TEXT_TYPE'
    EXPORTING
      iv_ebelp     = po_item_number
    CHANGING
      ct_text_type = ex_texttypes.

  IF sy-subrc <> 0.
    CLEAR ex_texttypes.
  ENDIF.

ENDMETHOD.


METHOD if_longtexts_mm~get_textobject.

  ex_tdobject = 'EKPO'.
  ex_metafield = mmmfd_item_text.

ENDMETHOD.


METHOD if_longtexts_mm~get_text.
  PERFORM text_get_lines IN PROGRAM saplmepo USING    po_item_number
                                                      im_tdid im_texttype"917290
                                             CHANGING ex_textlines
                                                      ex_text_formatted.
ENDMETHOD.


method IF_LONGTEXTS_MM~GET_MULTIPLE_TEXTS.
* empty implementation because of checkman
endmethod.


METHOD if_longtexts_mm~edit_text.
  DATA: l_tdobject TYPE tdobject.

  CALL METHOD me->if_longtexts_mm~get_textobject
    IMPORTING
      ex_tdobject = l_tdobject.

  PERFORM edit_text IN PROGRAM saplmepo
                              USING l_tdobject
                                    im_tdid
                                    po_item_number.

ENDMETHOD.


METHOD if_longtexts_mm~delete_text.

  DATA: l_tdobject TYPE tdobject,
        l_ucomm TYPE syucomm.

  CALL METHOD me->if_longtexts_mm~get_textobject
    IMPORTING
      ex_tdobject = l_tdobject.
  l_ucomm = 'TERE'.
  PERFORM copy_or_delete_text IN PROGRAM saplmepo
                                        USING l_tdobject
                                              im_tdid
                                              po_item_number
                                              l_ucomm.
ENDMETHOD.


METHOD if_longtexts_mm~adopt_text.

  DATA: l_tdobject TYPE tdobject,
        l_ucomm    TYPE syucomm.

  CALL METHOD me->if_longtexts_mm~get_textobject
    IMPORTING
      ex_tdobject = l_tdobject.
  l_ucomm = 'TECO'.
  PERFORM copy_or_delete_text IN PROGRAM saplmepo
                                            USING l_tdobject
                                                  im_tdid
                                                  po_item_number
                                                  l_ucomm.
ENDMETHOD.


METHOD if_fieldselection_mm~fs_get.

  DATA: l_schedule  TYPE eket-etenr,
        l_requester LIKE im_requested_type,
        l_sender    LIKE im_sender,
        ls_document TYPE mepo_document.


  IF NOT im_requested_type IS INITIAL.
    l_requester = im_requested_type.
  ELSE.
    l_requester = c_objtyp.
  ENDIF.
  IF NOT im_sender IS INITIAL.
    l_sender = im_sender.
  ELSE.
    l_sender = me.
  ENDIF.

  PERFORM field_selection IN PROGRAM saplmepo
                 USING    po_item_number
                          l_schedule
                          l_requester
                          l_sender
                          im_initiator
                 CHANGING ch_fieldselection.

  DATA: l_header TYPE REF TO cl_po_header_handle_mm.
  mmpur_dynamic_cast l_header my_parent.

   PERFORM mepo_xpd_get_document IN PROGRAM saplmepo
   CHANGING ls_document.

   " Begin: DIMP-IS-MILL Enhancement for FDE
  CHECK NOT l_header IS INITIAL.
  CHECK NOT me IS INITIAL.
  CALL FUNCTION '/SAPMP/ICON_DRUM_CALC_ACTIV'
    EXPORTING
      im_header         = l_header
      im_item           = me
      im_initiator      = ls_document-initiator
    CHANGING
      ch_fieldselection = ch_fieldselection.
  "END


  IF NOT l_header IS INITIAL.
    CALL FUNCTION 'MEPOBADI_FS_ITEM'
      EXPORTING
        im_header         = l_header
        im_item           = me
      CHANGING
        ch_fieldselection = ch_fieldselection
      EXCEPTIONS
        error_message     = 0.
  ENDIF.

ENDMETHOD.                    "if_fieldselection_mm~fs_get


METHOD if_delivery_address_mm~get_address_detail.

  DATA lr_header TYPE REF TO cl_po_header_handle_mm.
  mmpur_dynamic_cast1 lr_header me->my_parent.

  CALL FUNCTION 'MM_DELIVERY_ADDRESS_FOR_BAPI'
    EXPORTING
      im_ebeln = lr_header->po_number
      im_ebelp = me->po_item_number
    IMPORTING
      ex_cmmda = re_cmmda.

ENDMETHOD.


METHOD IF_DELIVERY_ADDRESS_MM~BEFORE_DIALOG.

  DATA: L_CMMDA TYPE CMMDA,
        L_DIALOG_MODE TYPE AD_MNTMD,
        L_FS_ADRNR TYPE C,
        L_FS_ADRN2 TYPE C,
        L_FS_KUNNR TYPE C,
        L_FS_EMLIF TYPE C,
        L_FS_LBLKZ TYPE C,
        L_MEPOITEM TYPE MEPOITEM.

  CALL METHOD ME->GET_DATA IMPORTING EX_DATA = L_MEPOITEM.
  PERFORM DELIVERY_ADDRESS_PBO IN PROGRAM SAPLMEPO
          USING    L_MEPOITEM-EBELN
                   L_MEPOITEM-EBELP
          CHANGING L_DIALOG_MODE
                   L_FS_ADRNR
                   L_FS_ADRN2
                   L_FS_KUNNR
                   L_FS_EMLIF
                   L_FS_LBLKZ
                   L_CMMDA.
  EX_DIALOG_MODE = L_DIALOG_MODE.
  EX_FS_ADRNR = L_FS_ADRNR.
  EX_FS_ADRN2 = L_FS_ADRN2.
  EX_FS_KUNNR = L_FS_KUNNR.
  EX_FS_EMLIF = L_FS_EMLIF.
  EX_FS_LBLKZ = L_FS_LBLKZ.
  EX_CMMDA    = L_CMMDA.


ENDMETHOD.


METHOD IF_DELIVERY_ADDRESS_MM~AFTER_DIALOG.

  DATA: L_MEPOITEM TYPE MEPOITEM,
        L_CHANGES  TYPE XFELD.

  CALL METHOD ME->GET_DATA IMPORTING EX_DATA = L_MEPOITEM.
  PERFORM DELIVERY_ADDRESS_PAI IN PROGRAM SAPLMEPO
                                          USING    L_MEPOITEM-EBELP
                                          CHANGING L_CHANGES.
  EX_CHANGES = L_CHANGES.

ENDMETHOD.


method IF_ASYNC_SUBJECT_MM~RESET_CHANGES.
  call method CHP_REFRESH_HASH_TABLE.
endmethod.


METHOD if_async_subject_mm~get_changes.

  DEFINE check_change.
    if &1 ne &2.
      l_change-metafield = &3.
      insert l_change into table ch_changelist.
      add 1 to l_special_entries.
    endif.
  END-OF-DEFINITION.

  DATA: l_change          LIKE LINE OF ch_changelist,
        l_hash_entry      LIKE LINE OF chp_hash_table,
        l_data_new        TYPE mepoitem,
        l_data_old        TYPE mepoitem,
        l_special_entries TYPE i.

  DATA: lx_brazil_active TYPE c.                          "1871470

  CLEAR l_change.
  l_change-model ?= me.
  l_change-action = im_action.

  IF im_action NE mmchp_chp_update.

    INSERT l_change INTO TABLE ch_changelist.

  ELSE.

    READ TABLE chp_hash_table INTO l_hash_entry
                                   WITH TABLE KEY item = me.
    IF sy-subrc IS INITIAL.
      l_data_old = l_hash_entry-data.
      CALL METHOD get_data IMPORTING ex_data = l_data_new
                           EXCEPTIONS failure = 01.

* checks for significant changes
* item category
      check_change l_data_new-pstyp l_data_old-pstyp mmmfd_item_cat.
* account assignment category
      check_change l_data_new-knttp l_data_old-knttp mmmfd_acctasscat.
* company code
      check_change l_data_new-bukrs l_data_old-bukrs mmmfd_comp_code.
* IR indicator
      check_change l_data_new-repos l_data_old-repos mmmfd_ir_ind.
* Material category
      check_change l_data_new-attyp l_data_old-attyp mmmfd_matl_cat.

* receiving plant                                         " note 339971
      check_change l_data_new-werks l_data_old-werks mmmfd_plant.
* document category                                       " note 339971
      check_change l_data_new-bstyp l_data_old-bstyp mmmfd_doc_cat.
* Returns item                                            " note 339971
      check_change l_data_new-retpo l_data_old-retpo mmmfd_ret_item.
* confirmation control
      check_change l_data_new-bstae l_data_old-bstae mmmfd_conf_control.
* material number                                         " note 1015644
      check_change l_data_new-ematn l_data_old-ematn mmmfd_pur_mat.

*     Check if Brazil is Active:                          "1871470
      CALL FUNCTION 'J_1BSA_COMPONENT_ACTIVE'             "1871470
        EXPORTING                                         "1871470
          bukrs = l_data_new-bukrs                        "1871470
          component = 'BR'                                "1871470
        EXCEPTIONS                                        "1871470
          component_not_active = 1.                       "1871470
                                                          "1871470
      IF sy-subrc = 0.                                    "1871470
        lx_brazil_active = 'X'.                           "1871470
      ENDIF.                                              "1871470
                                                          "1871470
      IF lx_brazil_active = 'X'.                          "1871470
*       Valuation Type:                                   "1871470
        check_change                                      "1871470
          l_data_new-bwtar                                "1871470
          l_data_old-bwtar                                "1871470
          mmmfd_val_type.                                 "1871470
      ENDIF.                                              "1871470

    ENDIF.

    IF l_special_entries IS INITIAL.
      INSERT l_change INTO TABLE ch_changelist.
    ENDIF.

  ENDIF.
ENDMETHOD.


METHOD if_acct_container_mm~set_repetition.
  DATA: l_mepoitem TYPE mepoitem.

  CALL METHOD get_data( IMPORTING ex_data = l_mepoitem ).

  CALL FUNCTION 'MEPO_DOC_ACC_SET_REPETITION'
    EXPORTING
      im_item       = l_mepoitem-ebelp
      im_on         = im_on
      im_for_all    = im_for_all_categories
    EXCEPTIONS
      error_message = 0.

ENDMETHOD.


METHOD IF_ACCT_CONTAINER_MM~SET_PART_INVOICE_INDICATOR .

    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.
    l_mepoitem-twrkz = im_twrkz.
    call method set_data exporting im_data = l_mepoitem.

ENDMETHOD.


METHOD IF_ACCT_CONTAINER_MM~SET_DISTRIBUTION_INDICATOR.


    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.
    l_mepoitem-vrtkz = im_vrtkz.
    call method set_data exporting im_data = l_mepoitem.

ENDMETHOD.


method IF_ACCT_CONTAINER_MM~SET_CATEGORY.

    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

    l_mepoitem-knttp = im_category.

    call method set_data exporting im_data = l_mepoitem.

endmethod.


METHOD IF_ACCT_CONTAINER_MM~REMOVE_ITEM.

* ...
ENDMETHOD.


method IF_ACCT_CONTAINER_MM~LOOKUP.
* nothing to do here
endmethod.


METHOD IF_ACCT_CONTAINER_MM~IS_ACTIVE.


   if me->if_acct_container_mm~get_category( ) is initial.
      re_active = mmpur_no.
   else.
      re_active = mmpur_yes.
   endif.

ENDMETHOD.


METHOD if_acct_container_mm~get_repetition.
  DATA: l_mepoitem TYPE mepoitem.

  CALL METHOD get_data( IMPORTING ex_data = l_mepoitem ).

  CALL FUNCTION 'MEPO_DOC_ACC_GET_REPETITION'
    EXPORTING
      im_item          = l_mepoitem-ebelp
    IMPORTING
      ex_on_for_this   = ex_on_for_this
      ex_on_for_others = ex_on_for_others
    EXCEPTIONS
      error_message    = 0.

ENDMETHOD.


method IF_ACCT_CONTAINER_MM~GET_QUANTITY.
    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

    re_quantity = l_mepoitem-menge.
endmethod.


METHOD IF_ACCT_CONTAINER_MM~GET_PART_INVOICE_INDICATOR .

    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

    re_twrkz = l_mepoitem-twrkz.

ENDMETHOD.


method if_acct_container_mm~get_items.


  data: lt_items type mmpur_models,
        wa like line of lt_items,
        ls_acct_item like line of re_items,
        lt_fieldselection type ttyp_fieldselection_mm,
        ls_fieldselection like line of lt_fieldselection.

  call method get_po_accountings importing ex_accountings = lt_items[].

  loop at lt_items into wa.
    ls_acct_item-model ?= wa-model.
    append ls_acct_item to re_items.
  endloop.
  if sy-subrc ne 0.
*
* no accounting models exists; check if funds management is active
*
    data: l_fm type ref to
              cl_po_accounting_handle_fm_mm.    "the bridge ekkn->ekpo

    ls_fieldselection-metafield = mmmfd_fm_active.
    insert ls_fieldselection into table lt_fieldselection.

    call method me->if_fieldselection_mm~fs_get
                changing ch_fieldselection = lt_fieldselection.

    read table lt_fieldselection into ls_fieldselection
      with key metafield = mmmfd_fm_active.

    if sy-subrc eq 0 and ls_fieldselection-fieldstatus ne '-'.
*
*     fm is active -> create a bridge object which hides
*     that fistl, fipos and geber reside in ekpo and not in ekkn
*
      create object l_fm exporting
               im_po_accounting_number = 0
               im_po_item = me.

      ls_acct_item-model ?= l_fm.
      append ls_acct_item to re_items.
    endif.
  endif.

endmethod.


METHOD IF_ACCT_CONTAINER_MM~GET_DISTRIBUTION_INDICATOR.


    data: l_mepoitem type mepoitem.

    call method get_data importing ex_data = l_mepoitem.

    re_vrtkz = l_mepoitem-vrtkz.

ENDMETHOD.


method if_acct_container_mm~get_default_view.

  data: l_t163k type t163k,
        l_knttp type knttp.

  l_knttp = me->IF_ACCT_CONTAINER_MM~GET_CATEGORY( ).

  check not l_knttp is initial.

  select single * from t163k into l_t163k where knttp = l_knttp.

  if sy-subrc eq 0.
    re_view = l_t163k-kntdy.
  endif.
endmethod.
ENDCLASS.