*"* use this source file for your ABAP unit test classes

CLASS lth_verify_method_desc DEFINITION FOR TESTING.

  PUBLIC SECTION.
    INTERFACES if_constraint.
    CLASS-METHODS:
      create
        IMPORTING
                  i_definition_include TYPE programm
                  i_visibility         TYPE if_rfac_impl_types=>ty_method_visibility DEFAULT if_rfac_impl_types=>co_method_visibility-private
                  i_is_static          TYPE abap_bool DEFAULT abap_false
        RETURNING VALUE(r_instance)    TYPE REF TO lth_verify_method_desc.

    METHODS:
      set_source_body
        IMPORTING i_source TYPE string_table,
      add_parameter
        IMPORTING
          i_direction  TYPE string
          i_name       TYPE string
          i_type       TYPE string
          i_type_type  TYPE if_rfac_impl_types=>ty_parameter_type_type
          i_occurrence TYPE string OPTIONAL
          i_by_value   TYPE abap_bool DEFAULT abap_false
          i_actual     TYPE string OPTIONAL,
      add_local
        IMPORTING
          i_local_def TYPE string,
      add_type
        IMPORTING
          i_name      TYPE string
          i_type      TYPE string
          i_type_type LIKE if_rfac_impl_types=>co_parameter_type_type-type,
      add_source_type
        IMPORTING
          i_name      TYPE string
          i_type      TYPE string
          i_type_type LIKE if_rfac_impl_types=>co_parameter_type_type-type,
      add_exception
        IMPORTING
          i_class_based TYPE abap_bool
          i_name        TYPE string
          i_resumable   TYPE abap_bool DEFAULT  abap_false,
      add_source_local
        IMPORTING
          i_local_def TYPE string,
      set_is_static
        IMPORTING
          i_is_static TYPE abap_bool.

  PRIVATE SECTION.
    DATA: exp_method_desc TYPE if_rfac_impl_types=>ts_method.



ENDCLASS.

CLASS lth_verify_method_desc IMPLEMENTATION.


  METHOD if_constraint~is_valid.

    DATA: act_method_desc TYPE if_rfac_impl_types=>ts_method,
          parameter       LIKE LINE OF exp_method_desc-exporting,
          exception       LIKE LINE OF exp_method_desc-exceptions,
          local_var       LIKE LINE OF exp_method_desc-locals,
          type            LIKE LINE OF exp_method_desc-types.

    act_method_desc = data_object.

    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-name act = act_method_desc-name ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-definition_include act = act_method_desc-definition_include ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-visibility act = act_method_desc-visibility ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-is_static act = act_method_desc-is_static ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-is_redefinition act = act_method_desc-is_redefinition ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-is_for_testing act = act_method_desc-is_for_testing ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-is_event act = act_method_desc-is_event ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-is_event_allowed act = act_method_desc-is_event_allowed ).

    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-classname act = act_method_desc-classname ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-interface_name act = act_method_desc-interface_name ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-call_include act = act_method_desc-call_include ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-call_reference act = act_method_desc-call_reference ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-call_type act = act_method_desc-call_type ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-implemention_include act = act_method_desc-implemention_include ).
    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-class_based_exceptions act = act_method_desc-class_based_exceptions ).

    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-returning act = act_method_desc-returning ).

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-importing ) act = lines( act_method_desc-importing )
                                        msg = 'number of importing parameters does not meet expectations' ).
    LOOP AT exp_method_desc-importing INTO parameter.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-importing line = parameter
                                                  msg = |expected parameter { parameter-name } is not contained in importing parameters.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-exporting ) act = lines( act_method_desc-exporting )
                                        msg = 'number of exporting parameters does not meet expectations' ).
    LOOP AT exp_method_desc-exporting INTO parameter.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-exporting line = parameter
                                                  msg = |expected parameter { parameter-name } is not contained in exporting parameters.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-changing ) act = lines( act_method_desc-changing )
                                        msg = 'number of changing parameters does not meet expectations' ).
    LOOP AT exp_method_desc-changing INTO parameter.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-changing line = parameter
                                                  msg = |expected parameter { parameter-name } is not contained in changing parameters.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-exceptions ) act = lines( act_method_desc-exceptions )
                                        msg = 'number of exceptions does not meet expectations' ).
    LOOP AT exp_method_desc-exceptions INTO exception.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-exceptions line = exception
                                                  msg = |expected exception { exception-name } is not contained in exceptions.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-locals ) act = lines( act_method_desc-locals )
                                        msg = 'number of local variable does not meet expectations' ).
    LOOP AT exp_method_desc-locals INTO local_var.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-locals line = local_var
                                                  msg = |expected variable { local_var } is not contained in local variables.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-types ) act = lines( act_method_desc-types )
                                        msg = 'number of types does not meet expectations' ).
    LOOP AT exp_method_desc-types INTO type.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-types line = type
                                                  msg = |expected type { type-name } is not contained in types.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-source_locals ) act = lines( act_method_desc-source_locals )
                                        msg = 'number of source variables does not meet expectations' ).
    LOOP AT exp_method_desc-source_locals INTO local_var.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-source_locals line = local_var
                                                  msg = |expected variable { local_var } is not contained in source variables.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = lines( exp_method_desc-source_types ) act = lines( act_method_desc-source_types )
                                        msg = 'number of source types does not meet expectations' ).
    LOOP AT exp_method_desc-source_types INTO type.
      cl_abap_unit_assert=>assert_table_contains( table = act_method_desc-source_types line = type
                                                  msg = |expected type { type-name } is not contained in source types.| ).
    ENDLOOP.

    cl_abap_unit_assert=>assert_equals( exp = exp_method_desc-body act = act_method_desc-body ).

    result = abap_true.

  ENDMETHOD.


  METHOD if_constraint~get_description.
    APPEND 'Constraint for the verification of a method description in extract method refactoring.' TO result.
  ENDMETHOD.


  METHOD create.
    CREATE OBJECT r_instance.
    r_instance->exp_method_desc-definition_include = i_definition_include.
    r_instance->exp_method_desc-is_static = i_is_static.
    r_instance->exp_method_desc-visibility = i_visibility.
  ENDMETHOD.

  METHOD set_source_body.
    exp_method_desc-body = i_source.
  ENDMETHOD.

  METHOD set_is_static.
    exp_method_desc-is_static = i_is_static.
  ENDMETHOD.

  METHOD add_parameter.

    DATA: parameter            LIKE LINE OF exp_method_desc-exporting,
          parameter_occurrence LIKE LINE OF parameter-occurrences,
          occurence_strings    TYPE string_table,
          occurrence_string    LIKE LINE OF occurence_strings.

    parameter-name = parameter-actual = i_name.
    parameter-type = i_type.
    parameter-typetype = i_type_type.
    parameter-byvalue = i_by_value.

    IF i_actual IS SUPPLIED.
      parameter-actual = i_actual.
    ENDIF.

    IF i_occurrence IS SUPPLIED.
      SPLIT i_occurrence AT '/' INTO TABLE occurence_strings.
    ENDIF.

    LOOP AT occurence_strings INTO occurrence_string.

      parameter_occurrence-start_row = segment( val = segment( val = occurrence_string index = 1 sep = '-' ) index = 1 sep = ',' ).
      parameter_occurrence-start_col = segment( val = segment( val = occurrence_string index = 1 sep = '-' ) index = 2 sep = ',' ).
      parameter_occurrence-end_row   = segment( val = segment( val = occurrence_string index = 2 sep = '-' ) index = 1 sep = ',' ).
      parameter_occurrence-end_col   = segment( val = segment( val = occurrence_string index = 2 sep = '-' ) index = 2 sep = ',' ).

      INSERT parameter_occurrence INTO TABLE parameter-occurrences.

    ENDLOOP.

    CASE i_direction.
      WHEN 'importing'.
        INSERT parameter INTO TABLE exp_method_desc-importing.
      WHEN 'exporting'.
        INSERT parameter INTO TABLE exp_method_desc-exporting.
      WHEN 'changing'.
        INSERT parameter INTO TABLE exp_method_desc-changing.
      WHEN 'returning'.
        parameter-byvalue = abap_true.
        exp_method_desc-returning = parameter.
      WHEN OTHERS.
        ASSERT 'supported lower case values:' = 'importing,exporting,changing,returning'.
    ENDCASE.


  ENDMETHOD.


  METHOD add_local.

    APPEND i_local_def TO exp_method_desc-locals.

  ENDMETHOD.


  METHOD add_type.

    DATA type_definition TYPE if_rfac_impl_types=>ts_type.

    type_definition-name     = i_name.
    type_definition-typetype = i_type_type.
    type_definition-value    = i_type.
    INSERT type_definition INTO TABLE exp_method_desc-types.

  ENDMETHOD.

  METHOD add_source_type.

    DATA type_definition TYPE if_rfac_impl_types=>ts_type.

    type_definition-name     = i_name.
    type_definition-typetype = i_type_type.
    type_definition-value    = i_type.
    INSERT type_definition INTO TABLE exp_method_desc-source_types.

  ENDMETHOD.

  METHOD add_exception.

    DATA exception LIKE LINE OF exp_method_desc-exceptions.

    exception-name = i_name.
    exception-resumable = i_resumable.
    INSERT exception INTO TABLE exp_method_desc-exceptions.
    IF exp_method_desc-class_based_exceptions = abap_true.
      ASSERT i_class_based = abap_true. "mixed class based and classic exceptions
    ENDIF.
    exp_method_desc-class_based_exceptions = i_class_based.

  ENDMETHOD.


  METHOD add_source_local.

    APPEND i_local_def TO exp_method_desc-source_locals.

  ENDMETHOD.

ENDCLASS.


CLASS ltcl_generic_abap_types_helper DEFINITION FOR TESTING DURATION SHORT RISK LEVEL HARMLESS.
  PRIVATE SECTION.
    DATA: parameter_type TYPE string,
          type_operator  TYPE string.
    METHODS: test_any FOR TESTING,
      test_csequence FOR TESTING,
      test_no_generic_type FOR TESTING,
      test_operator_type FOR TESTING,
      test_operator_type_ref_to FOR TESTING,
      test_operator_like FOR TESTING,
      test_operator_not_supported FOR TESTING.
ENDCLASS.                    "ltcl_generic_abap_types_helper DEFINITION

*----------------------------------------------------------------------*
*       CLASS ltcl_generic_abap_types_helper IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ltcl_generic_abap_types_helper IMPLEMENTATION.
  METHOD test_any.
    me->parameter_type = 'any'.
    cl_abap_unit_assert=>assert_equals( msg = |Parameter { me->parameter_type } is a generic ABAP type!| exp = abap_true act = lcl_abap_types_helper=>is_generic_type( i_parameter_type = me->parameter_type ) ).
  ENDMETHOD.                    "test_any

  METHOD test_csequence.
    me->parameter_type = 'csequence'.
    cl_abap_unit_assert=>assert_equals( msg = |Parameter { me->parameter_type } is a generic ABAP type!| exp = abap_true act = lcl_abap_types_helper=>is_generic_type( i_parameter_type = me->parameter_type ) ).
  ENDMETHOD.                    "test_csequence

  METHOD test_no_generic_type.
    me->parameter_type = 'abap_bool'.
    cl_abap_unit_assert=>assert_equals( msg = |Parameter { me->parameter_type } is not a generic ABAP type!| exp = abap_false act = lcl_abap_types_helper=>is_generic_type( i_parameter_type = me->parameter_type ) ).
  ENDMETHOD.                    "test_no_generic_type

  METHOD test_operator_type.
    me->type_operator = 'type'.
    cl_abap_unit_assert=>assert_equals( msg = |Type operator { me->type_operator } should be supported!| exp = abap_true act = lcl_abap_types_helper=>is_type_operator_supported( i_type_operator = me->type_operator ) ).
  ENDMETHOD.                    "test_operator_type

  METHOD test_operator_type_ref_to.
    me->type_operator = 'type ref to'.
    cl_abap_unit_assert=>assert_equals( msg = |Type operator { me->type_operator } should be supported!| exp = abap_true act = lcl_abap_types_helper=>is_type_operator_supported( i_type_operator = me->type_operator ) ).
  ENDMETHOD.                    "test_operator_type_ref_to

  METHOD test_operator_like.
    me->type_operator = 'like'.
    cl_abap_unit_assert=>assert_equals( msg = |Type operator { me->type_operator } should be supported!| exp = abap_true act = lcl_abap_types_helper=>is_type_operator_supported( i_type_operator = me->type_operator ) ).
  ENDMETHOD.                    "test_operator_like

  METHOD test_operator_not_supported.
    me->type_operator = 'type standard table of'.
    cl_abap_unit_assert=>assert_equals( msg = |Type operator { me->type_operator } should not be supported!| exp = abap_false act = lcl_abap_types_helper=>is_type_operator_supported( i_type_operator = me->type_operator ) ).
  ENDMETHOD.                    "test_operator_not_supported
ENDCLASS.                    "ltcl_generic_abap_types_helper IMPLEMENTATION

CLASS ltcl_rfac_selection_analyzer DEFINITION FOR TESTING INHERITING FROM th_art_contributor
DURATION LONG RISK LEVEL HARMLESS.

  PRIVATE SECTION.

    DATA: exp_method_constraint TYPE REF TO lth_verify_method_desc,
          actual_method         TYPE if_rfac_impl_types=>ts_method,
          selection_analyzer    TYPE REF TO cl_rfac_selection_analyzer.

    METHODS: prepare_with_blackboard
      RAISING
        cx_rfac_error,


      assert_method_consistency      RAISING cx_static_check,
      assert_exception               IMPORTING i_message TYPE symsgno RAISING cx_static_check,

      exc_no_selection               FOR TESTING RAISING cx_static_check,
      extraction_supported           FOR TESTING RAISING cx_static_check,
      extraction_not_supported       FOR TESTING RAISING cx_static_check,
      extract_incomplete_statement   FOR TESTING RAISING cx_static_check,
      extract_incomplete_struc_start FOR TESTING RAISING cx_static_check,
      extract_incomplete_struc_end   FOR TESTING RAISING cx_static_check,
      extract_no_locals              FOR TESTING RAISING cx_static_check,
      extract_local_read             FOR TESTING RAISING cx_static_check,
      extract_data_declaration       FOR TESTING RAISING cx_static_check,
      extract_local_changed          FOR TESTING RAISING cx_static_check,
      extract_static_method          FOR TESTING RAISING cx_static_check,
      extract_incomplete_stmnt_begin FOR TESTING RAISING cx_static_check,
      extract_imp_exp_changing       FOR TESTING RAISING cx_static_check,
      extract_returning              FOR TESTING RAISING cx_static_check,
      extract_intf_imp_exp_changing  FOR TESTING RAISING cx_static_check,
      extract_intf_exp_and_chang     FOR TESTING RAISING cx_static_check,
      extract_changing_only          FOR TESTING RAISING cx_static_check,
      extract_single_exporting       FOR TESTING RAISING cx_static_check,
      extract_glob_intf_imp_exp_ch   FOR TESTING RAISING cx_static_check,
      extract_data_decl_with_val     FOR TESTING RAISING cx_static_check,
      extract_same_name              FOR TESTING RAISING cx_static_check,
      extract_same_type              FOR TESTING RAISING cx_static_check,
      extract_old_school_exceptions  FOR TESTING RAISING cx_static_check,
      extract_invisible_exception    FOR TESTING RAISING cx_static_check,
      extract_no_invisible_exception FOR TESTING RAISING cx_static_check,
      extract_invis_old_exceptions   FOR TESTING RAISING cx_static_check,
      extract_single_line_exception  FOR TESTING RAISING cx_static_check,
      extract_local_redefinition     FOR TESTING RAISING cx_static_check,
      extract_stolen_things          FOR TESTING RAISING cx_static_check,
      extract_stolen_fields          FOR TESTING RAISING cx_static_check,
      extract_one_stolen_field       FOR TESTING RAISING cx_static_check,
      extract_constants              FOR TESTING RAISING cx_static_check,
      extract_global_redefinition    FOR TESTING RAISING cx_static_check,
      extract_case_when_selection    FOR TESTING RAISING cx_static_check,
      extract_intf_method_gl_redef   FOR TESTING RAISING cx_static_check,
      extract_intf_method_lo_redef   FOR TESTING RAISING cx_static_check,
      extract_transitive_redef       FOR TESTING RAISING cx_static_check,
      extract_only_dot               FOR TESTING RAISING cx_static_check,
      extract_parameter_generic_type FOR TESTING RAISING cx_static_check,
      extract_recursion              FOR TESTING RAISING cx_static_check,
      extract_stolen_statement       FOR TESTING RAISING cx_static_check,
      extract_stolen_data            FOR TESTING RAISING cx_static_check,
      extract_with_type_conflict     FOR TESTING RAISING cx_static_check,
      extract_adjust_table_types     FOR TESTING RAISING cx_static_check,
      extract_adjust_range_linetypes FOR TESTING RAISING cx_static_check,
      extract_statement_without_dot  FOR TESTING RAISING cx_static_check,
      extract_statement_with_dot     FOR TESTING RAISING cx_static_check,
      extract_check_without_loop     FOR TESTING RAISING cx_static_check,
      extract_check_with_loop        FOR TESTING RAISING cx_static_check,
      extract_return                 FOR TESTING RAISING cx_static_check,
      extract_exit_without_loop      FOR TESTING RAISING cx_static_check,
      extract_continue_without_loop  FOR TESTING RAISING cx_static_check,
      extract_continue_with_loop     FOR TESTING RAISING cx_static_check,
      extract_inline_declaration     FOR TESTING RAISING cx_static_check,
      extract_1st_of_3_loops_with_fs FOR TESTING RAISING cx_static_check,
      extract_changing_field_symbol  FOR TESTING RAISING cx_static_check,
      extract_inline_field_symbol    FOR TESTING RAISING cx_static_check,
      extract_component_write_read   FOR TESTING RAISING cx_static_check,
      extract_override_signature     FOR TESTING RAISING cx_static_check,
      extract_complex_like_reference FOR TESTING RAISING cx_static_check,
      extract_type_in_source_method  FOR TESTING RAISING cx_static_check,
      extract_method_method          FOR TESTING RAISING cx_static_check,
      extract_parent_child_exception FOR TESTING RAISING cx_static_check,
      extract_multiple_exceptions    FOR TESTING RAISING cx_static_check,
      extract_field_exception        FOR TESTING RAISING cx_static_check,
      extract_try_catch_raising      FOR TESTING RAISING cx_static_check,
      extract_raising_resumable      FOR TESTING RAISING cx_static_check,
      extract_inline_type_select     FOR TESTING RAISING cx_static_check,
      extract_inline_type_select_fs  FOR TESTING RAISING cx_static_check,
      extract_inline_host_var        FOR TESTING RAISING cx_static_check,
      loop_body_fs_declared_explicit FOR TESTING RAISING cx_static_check,
      loop_body_inline_fs_class_type FOR TESTING RAISING cx_static_check,
      extract_exception_not_catched FOR TESTING RAISING cx_static_check,
      extract_throw_resumable FOR TESTING RAISING cx_static_check,
      dont_extract_no_catch_exc FOR TESTING RAISING cx_static_check,
      extract_two_exceptions FOR TESTING RAISING cx_static_check,
      loop_body_inline_fs_itab_param FOR TESTING RAISING cx_static_check,
      extract_loop_assign_fs FOR TESTING RAISING cx_static_check,
      extract_2nd_of_3_loops_with_fs FOR TESTING RAISING cx_static_check,
      extract_1_of_n_loops_with_ref FOR TESTING RAISING cx_static_check,
      extract_3rd_of_3_loops_with_fs FOR TESTING RAISING cx_static_check,
      extract_loop_fs_used_after FOR TESTING RAISING cx_static_check,
      use_of_independent_inline_decl FOR TESTING RAISING cx_static_check,
      extract_first_add_returning FOR TESTING RAISING cx_static_check,
      extract_second_add_changing FOR TESTING RAISING cx_static_check,
      extract_last_add_changing FOR TESTING RAISING cx_static_check,
      dont_add_type_for_generic_fs for testing raising cx_static_check.
ENDCLASS.                    "ltcl_rfac_selection_analyzer DEFINITION

CLASS ltcl_rfac_selection_analyzer IMPLEMENTATION.

  METHOD prepare_with_blackboard.

    prepare_blackboard(  ).
    me->selection_analyzer = cl_rfac_selection_analyzer=>get_instance( i_blackboard = blackboard ).

    me->exp_method_constraint = lth_verify_method_desc=>create( i_definition_include = 'DUMMY_REPORT4SOURCE_OBJ_DOUBLE' ).

    DATA(selected_source) = cl_art_source_utility=>get_selected_code_lines( i_source_code = blackboard->get_focused_source( )
                                                                            i_users_selection = blackboard->get_pst_position4selection( ) ).
    me->exp_method_constraint->set_source_body( selected_source ).

  ENDMETHOD.

  METHOD assert_method_consistency.
    me->selection_analyzer->if_rfac_selection_analyzer~get_selection_as_method( IMPORTING e_method = me->actual_method ).
    cl_abap_unit_assert=>assert_that( act = me->actual_method exp = me->exp_method_constraint ).
  ENDMETHOD.

  METHOD assert_exception.
    TRY.
        me->selection_analyzer->if_rfac_selection_analyzer~get_selection_as_method( ).
        cl_abap_unit_assert=>fail( msg = 'Exception for unsupported selection expected!' ).
      CATCH cx_rfac_error INTO DATA(rfac_error).
        cl_abap_unit_assert=>assert_equals( msg = 'Extract Method returned exception with wrong message class.' exp = 'SRFAC_IMPL' act = rfac_error->if_t100_message~t100key-msgid ).
        cl_abap_unit_assert=>assert_equals( msg = 'Extract Method returned exception with wrong message number.' exp = i_message act = rfac_error->if_t100_message~t100key-msgno ).
    ENDTRY.
  ENDMETHOD.

  METHOD exc_no_selection.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §"print header                 ` )
      ( `    WRITE:/ '********************'.` )
      ( `    WRITE:/ '*   Invoice 4711   *'.` )
      ( `    WRITE:/ '********************'.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    TRY.

        prepare_with_blackboard(  ).

        cl_abap_unit_assert=>fail( msg = 'Source selection without selection is not supported!' ).
      CATCH cx_rfac_error INTO DATA(rfac_error).
        cl_abap_unit_assert=>assert_equals( msg = 'Source selection without selection returned exception with wrong message class.' exp = 'SRFAC_IMPL' act = rfac_error->if_t100_message~t100key-msgid ).
        cl_abap_unit_assert=>assert_equals( msg = 'Source selection without selection position returned exception with wrong message number.' exp = '018' act = rfac_error->if_t100_message~t100key-msgno ).
    ENDTRY.

  ENDMETHOD.

  METHOD extraction_supported.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §"print header                 ` )
      ( `    WRITE:/ '********************'.` )
      ( `    WRITE:/ '*   Invoice 4711   *'.` )
      ( `    WRITE:/ '********************'.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_true( selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
    " Also a second time to check caching!
    cl_abap_unit_assert=>assert_true( selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).

  ENDMETHOD.                    "extraction_supported

  METHOD extraction_not_supported.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `§     ` )
      ( `      §` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_false( selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
    me->assert_exception( i_message = '024' ).

  ENDMETHOD.                    "extraction_not_supported

  METHOD extract_no_locals.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §"print header                 ` )
      ( `    WRITE:/ '********************'.` )
      ( `    WRITE:/ '*   Invoice 4711   *'.` )
      ( `    WRITE:/ '********************'.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_incomplete_statement.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA var type i.` )
      ( `    ADD §1` )
      ( `    to var§.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    me->assert_exception( i_message = '019' ).

  ENDMETHOD.

  METHOD extract_incomplete_stmnt_begin.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA var type i.` )
      ( `    §ADD 1§` )
      ( `    to var.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    me->assert_exception( i_message = '019' ).

  ENDMETHOD.

  METHOD extract_statement_without_dot.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA var type i.` )
      ( `    §ADD 1 to var§.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    me->assert_exception( i_message = '019' ).

  ENDMETHOD.

  METHOD extract_statement_with_dot.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §me->one( ).§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_incomplete_struc_start.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §DO 5 TIMES.§` )
      ( `    ENDDO.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '020' ).

  ENDMETHOD.

  METHOD extract_incomplete_struc_end.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DO 5 TIMES.` )
      ( `    §ENDDO.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '020' ).

  ENDMETHOD.

  METHOD extract_local_read.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: outstanding TYPE i.` )
      ( `    outstanding = 5.` )
      ( `    §"print outstanding ` )
      ( `    WRITE:/ 'Amount:', outstanding.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'outstanding' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,23-2,34' ).
    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_data_declaration.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one importing i_discount type i default 0` )
      ( `                raising cx_rfac_dynamic.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: discount_is_invalid TYPE abap_bool.` )
      ( `    §"validate discount                                                ` )
      ( `    discount_is_invalid = boolc( i_discount < 0 OR i_discount > 100 ).` )
      ( `    IF discount_is_invalid = abap_true.                               ` )
      ( `      RAISE EXCEPTION TYPE cx_rfac_dynamic.                      ` )
      ( `    ENDIF.§                                                            ` )
      ( `    ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_discount' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,33-2,43/2,51-2,61' ).

    exp_method_constraint->add_exception( i_class_based = abap_true i_name = 'cx_rfac_dynamic' ).
    exp_method_constraint->add_local( 'DATA discount_is_invalid TYPE abap_bool.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_local_changed.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `  TYPES: BEGIN OF ts_item,       ` )
      ( `           name  TYPE string,    ` )
      ( `           kind  TYPE string,    ` )
      ( `           price TYPE decfloat16,` )
      ( `         END OF ts_item.         ` )
      ( `    DATA items TYPE STANDARD TABLE OF ts_item.` )
      ( `    methods one importing i_item_kind  type csequence.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: item TYPE ts_item,` )
      ( `          outstanding TYPE i.` )
      ( `    ` )
      ( `    §"calculate outstanding` )
      ( `    LOOP AT items INTO item WHERE kind = i_item_kind.` )
      ( `      IF item-price < 0.` )
      ( `        RAISE EXCEPTION TYPE cx_rfac_dynamic.` )
      ( `      ENDIF.` )
      ( `      outstanding = outstanding + item-price.` )
      ( `    ENDLOOP. " end of loop` )
      ( `    " Really, that's the end!§` )
      ( `    ` )
      ( `    WRITE:/ 'Amount:', outstanding.` )
      ( `    ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_item_kind' i_type = 'csequence' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,41-2,52' ).
    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'outstanding' i_by_value = abap_true i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '6,6-6,17/6,20-6,31' ).
    exp_method_constraint->add_local( 'DATA item TYPE lcl=>ts_item.' ).

    exp_method_constraint->add_exception( i_class_based = abap_true i_name = 'cx_rfac_dynamic' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_static_method.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    class-methods: i_am_static.` )
      ( `    CLASS-DATA: public TYPE string.` )
      ( `  protected section.` )
      ( `    DATA: protected LIKE public.` )
      ( `  private section.` )
      ( `    methods: after.` )
      ( `    DATA: private LIKE protected.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method after. endmethod.` )
      ( `  method i_am_static.` )
      ( `    data: external_id  LIKE cl_ris_action=>mv_id,   ` )
      ( `          main               TYPE REF TO lcl,              ` )
      ( `          invalid_selections TYPE REF TO cx_rfac_dynamic,` )
      ( `          another_ref        LIKE main,                         ` )
      ( `          local_ref          LIKE another_ref,                  ` )
      ( `          table_type         TYPE STANDARD TABLE OF string,     ` )
      ( `          table_type_2       TYPE STANDARD TABLE OF string,     ` )
      ( `          another_table      TYPE STANDARD TABLE OF string,     ` )
      ( `          other_table        LIKE another_table,                ` )
      ( `          more_private       LIKE private,                      ` )
      ( `          only_read          TYPE string VALUE 'only_read',     ` )
      ( `          string             TYPE string.                       ` )
      ( `    FIELD-SYMBOLS: <other_table> LIKE other_table.` )
      ( `    CREATE OBJECT main.` )
      ( `    string = 'I am Static, Man!'.` )
      ( `    INSERT string INTO TABLE table_type.` )

      ( `§    main->after( ).` )
      ( `    CREATE OBJECT invalid_selections.` )
      ( `    WRITE: / 'I am Static, Man!'.` )
      ( `    string = 'And I''m so, too!'.` )
      ( `    INSERT string INTO TABLE table_type.` )
      ( `    string = 'I am Static, Man!'.` )
      ( `    INSERT string INTO TABLE table_type_2.` )
      ( `    ASSIGN table_type_2 TO <other_table>.` )
      ( `    CREATE OBJECT local_ref.` )
      ( `    more_private = 'hallo'.` )
      ( `    external_id = if_ris_constants=>ris_application_type_search.` )
      ( `    ASSERT only_read IS NOT INITIAL.§` )

      ( `    more_private = '42'. ` )
      ( `    only_read = 'not_only_read'. ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->set_is_static( abap_true ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'main' i_type = 'lcl' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type_ref_to i_occurrence = '1,4-1,8' ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'table_type' i_type = 'ty_table_type' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '5,29-5,39' ).

*    exp_method_constraint->add_type( i_name = 'ty_other_table' i_type = 'STANDARD TABLE OF string WITH DEFAULT KEY' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).
    exp_method_constraint->add_type( i_name = 'ty_table_type' i_type = 'STANDARD TABLE OF string WITH DEFAULT KEY' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).
*    exp_method_constraint->add_type( i_name = 'ty_table_type_2' i_type = 'STANDARD TABLE OF string WITH DEFAULT KEY' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).

    exp_method_constraint->add_local( 'DATA external_id TYPE ris_application.' ).
    exp_method_constraint->add_local( 'DATA invalid_selections TYPE REF TO cx_rfac_dynamic.' ).
    exp_method_constraint->add_local( 'DATA local_ref TYPE REF TO lcl.' ).
    exp_method_constraint->add_local( 'DATA more_private TYPE string.' ).
    exp_method_constraint->add_local( 'DATA only_read TYPE string VALUE ''only_read''.' ).
    exp_method_constraint->add_local( 'DATA string TYPE string.' ).
    exp_method_constraint->add_local( 'DATA table_type_2 TYPE STANDARD TABLE OF string.' ).
    exp_method_constraint->add_local( 'FIELD-SYMBOLS <other_table> TYPE STANDARD TABLE OF string.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_imp_exp_changing.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
*      ( `    INTERFACES: interface_with_fancy_methods.` )
      ( `    METHODS: my_good_things IMPORTING i_importing TYPE i` )
      ( `                            EXPORTING e_exporting TYPE abap_bool` )
      ( `                            CHANGING  c_changing  TYPE c.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method my_good_things.` )
      ( `§    IF i_importing > 0.` )
      ( `      e_exporting = abap_true.` )
      ( `      c_changing  = 'Y'.` )
      ( `    ENDIF.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_importing' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,18' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_returning.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
*      ( `    INTERFACES: interface_with_fancy_methods.` )
      ( `    METHODS: return_my_stuff RETURNING VALUE(r_my_stuff) TYPE i.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method return_my_stuff.` )
      ( `§    DATA: forty_two TYPE i VALUE 42.` )
      ( `    r_my_stuff = forty_two.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'r_my_stuff' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,4-2,14' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_first_add_returning.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    METHODS: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: a type i.` )
      ( `    §add 1 to a.§` )
      ( `    add 1 to a.` )
      ( `    add 1 to a.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'a' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,9-1,10' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_second_add_changing.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    METHODS: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: a type i.` )
      ( `    add 1 to a.` )
      ( `    §add 1 to a.§` )
      ( `    add 1 to a.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'a' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,9-1,10' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_last_add_changing.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    METHODS: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: a type i.` )
      ( `    add 1 to a.` )
      ( `    add 1 to a.` )
      ( `    §add 1 to a.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'a' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,9-1,10' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_intf_imp_exp_changing.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `INTERFACE interface_with_fancy_methods.` )
      ( `METHODS: packed_with_all_good_things IMPORTING i_importing TYPE i` )
      ( `                                               i_kommt_rein type string` )
      ( `                                     EXPORTING e_exporting  TYPE abap_bool` )
      ( `                                     CHANGING  c_changing TYPE c,` )
      ( `         return_this                 RETURNING value(r_returning) TYPE i.` )
      ( `ENDINTERFACE.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    INTERFACES: interface_with_fancy_methods.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method interface_with_fancy_methods~packed_with_all_good_things.` )
      ( `§    IF i_importing > 0.` )
      ( `      e_exporting = abap_true.` )
      ( `      c_changing  = 'Y'.` )
      ( `    ENDIF.§` )
      ( `  endmethod.` )
      ( `  method interface_with_fancy_methods~return_this. endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_importing' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,18' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_intf_exp_and_chang.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `INTERFACE interface_with_fancy_methods.` )
      ( `METHODS: packed_with_all_good_things IMPORTING i_importing TYPE i` )
      ( `                                               i_kommt_rein type string` )
      ( `                                     EXPORTING e_exporting  TYPE abap_bool` )
      ( `                                     CHANGING  c_changing TYPE c,` )
      ( `         return_this                 RETURNING value(r_returning) TYPE i.` )
      ( `ENDINTERFACE.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    INTERFACES: interface_with_fancy_methods.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method interface_with_fancy_methods~return_this.` )
      ( `    DATA: forty_two TYPE i.` )
      ( `    FIELD-SYMBOLS: <twenty_three> TYPE i.` )
      ( `    ASSIGN forty_two TO <twenty_three>.` )

      ( `§    DATA: something_else TYPE string.` )
      ( `    <twenty_three> = 23.` )
      ( `    r_returning = <twenty_three>.§` )

      ( `    forty_two = 42.` )
      ( `    something_else = 'Something else!'.` )
      ( `  endmethod.` )
      ( `  method interface_with_fancy_methods~packed_with_all_good_things. endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'r_returning' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,4-3,15' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'something_else' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type  ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'twenty_three' i_actual = '<twenty_three>' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,4-2,18/3,18-3,32' ).

    exp_method_constraint->add_source_local( 'DATA something_else TYPE string.' ).

    me->assert_method_consistency( ).


  ENDMETHOD.

  METHOD extract_changing_only.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: change TYPE i.              ` )
      ( `    FIELD-SYMBOLS: <fs_change> TYPE i.` )
      ( `                                      ` )
      ( `    change = 1.                       ` )
      ( `                                      ` )
      ( `§    ASSIGN change TO <fs_change>.     ` )
      ( `    change = 2.§                       ` )
      ( `                                      ` )
      ( `    change = 3.                       ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'change' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,11-1,17/2,4-2,10' ).
    exp_method_constraint->add_local( 'FIELD-SYMBOLS <fs_change> TYPE i.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_single_exporting.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one importing i_discount type i default 0` )
      ( `                raising cx_rfac_dynamic.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: single_exporting TYPE i.` )
      ( `                                      ` )
      ( `§    single_exporting = 23.§           ` )
      ( `                                      ` )
      ( `    CHECK single_exporting = 42.` )
      ( `                                      ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'single_exporting' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,4-1,20' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_glob_intf_imp_exp_ch.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method th_rfac_intf_extract_method~packed_with_all_good_things.` )
      ( `§    IF i_importing > 0.      ` )
      ( `      e_exporting = abap_true.` )
      ( `      c_changing  = 'Y'.      ` )
      ( `    ENDIF.§                   ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_importing' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,18' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_data_decl_with_val.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `    methods: data_declarations.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method data_declarations.` )
      ( `    DATA: predefined_value TYPE i VALUE 42,` )
      ( `          data_is_initial  TYPE abap_bool VALUE IS INITIAL.` )
      ( `§    IF predefined_value = 42.      ` )
      ( `      data_is_initial = abap_true.` )
      ( `    ENDIF.§                   ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_local( 'DATA data_is_initial TYPE abap_bool VALUE IS INITIAL.' ).
    exp_method_constraint->add_local( 'DATA predefined_value TYPE i VALUE 42.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_same_name.
    DATA: normal_found TYPE abap_bool,
          fs_found     TYPE abap_bool.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `    methods: same_name.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method same_name.` )
      ( `    DATA: valuable_data    TYPE i,` )
      ( `          valuable_data_fs TYPE i.` )
      ( `    FIELD-SYMBOLS: <valuable_data> TYPE i.` )

      ( `    ASSIGN valuable_data TO <valuable_data>.` )
      ( `§    valuable_data_fs = <valuable_data>.` )
      ( `    <valuable_data> = 42.§` )

      ( `    valuable_data = valuable_data_fs.` )
      ( `    <valuable_data> = 23.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->selection_analyzer->if_rfac_selection_analyzer~get_selection_as_method( IMPORTING e_method = actual_method ).

    LOOP AT actual_method-exporting INTO DATA(parameter).
      IF normal_found = abap_true AND parameter-name = 'valuable_data'.
        cl_abap_unit_assert=>fail( msg = 'Duplicate parameter valuable_data!' ).
      ENDIF.
      IF fs_found = abap_true AND parameter-name = 'valuable_data_fs'.
        cl_abap_unit_assert=>fail( msg = 'Duplicate parameter valuable_data_fs!' ).
      ENDIF.
      IF parameter-name = 'valuable_data'.
        normal_found = abap_true.
        CONTINUE.
      ENDIF.
      IF parameter-name = 'valuable_data_fs'.
        fs_found = abap_true.
        CONTINUE.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD extract_same_type.
    DATA: normal_found    TYPE abap_bool.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    class-methods: i_am_static.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method i_am_static.` )
      ( `    DATA: string type string,`)
      ( `          very_very_very_very_very_long1 TYPE STANDARD TABLE OF string,`)
      ( `          very_very_very_very_very_long2 TYPE STANDARD TABLE OF string. `)

      ( `§    string = 'Long variable'.` )
      ( `     INSERT string INTO TABLE very_very_very_very_very_long1.` )
      ( `     string = 'Also long variable'.` )
      ( `     INSERT string INTO TABLE very_very_very_very_very_long2.§ ` )

      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->selection_analyzer->if_rfac_selection_analyzer~get_selection_as_method( IMPORTING e_method = actual_method ).

    LOOP AT actual_method-types INTO DATA(type_definition).
      IF normal_found = abap_true AND type_definition-name = 'ty_very_very_very_very_very_lo'.
        cl_abap_unit_assert=>fail( msg = 'Duplicate type ty_very_very_very_very_very_lo!' ).
      ENDIF.
      IF type_definition-name = 'ty_very_very_very_very_very_lo'.
        normal_found = abap_true.
        CONTINUE.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD extract_old_school_exceptions.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `    methods: old_school_exceptions EXCEPTIONS old_school_exception vaporware_exception.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method old_school_exceptions.` )
      ( `    DATA: the_duke_is_back TYPE abap_bool VALUE abap_true.` )

      ( `§    "check duke status` )
      ( `    IF the_duke_is_back EQ abap_true.` )
      ( `      RAISE old_school_exception. " Yeah, lookin' good!` )
      ( `    ELSE.` )
      ( `      MESSAGE e000(00) RAISING vaporware_exception.` )
      ( `    ENDIF.§` )

      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( i_class_based = abap_false i_name = 'old_school_exception' ).
    exp_method_constraint->add_exception( i_class_based = abap_false i_name = 'vaporware_exception' ).

    exp_method_constraint->add_local( 'DATA the_duke_is_back TYPE abap_bool VALUE ABAP_TRUE.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_invisible_exception.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: call_invisible_exception` )
      ( `      IMPORTING i_blackboard type ref to cl_art_blackboard` )
      ( `      RAISING cx_rfac_error.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method call_invisible_exception.` )
      ( `    DATA: var TYPE i.` )
      ( `§   data(obj) = cl_rfac_selection_analyzer=>get_instance( i_blackboard ).` )
      ( `    var = 42.` )
      ( `    TRY.` )
      ( `        data(obj2) = cl_rfac_selection_analyzer=>get_instance( i_blackboard ).` )
      ( `      CATCH cx_rfac_error.` )
      ( `    ENDTRY.§` )
      ( `    IF var = 42.` )
      ( `      WRITE: / 'You found the answer!'.` )
      ( `    ENDIF.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_blackboard' i_type = 'cl_art_blackboard ' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type_ref_to i_occurrence = '1,57-1,69/4,63-4,75' ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'var' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,4-2,7' i_by_value = abap_true ).
    exp_method_constraint->add_exception( i_class_based = abap_true i_name = 'cx_rfac_error' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_exception_not_catched.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: call_invisible_exception` )
      ( `      IMPORTING i_blackboard type ref to cl_art_blackboard` )
      ( `      RAISING cx_rfac_error.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method call_invisible_exception.` )
      ( `    DATA: var TYPE i.` )
      ( `§    TRY.` )
      ( `    data(obj) = cl_rfac_selection_analyzer=>get_instance( i_blackboard ).` )
      ( `    data(include) = cl_ris_include=>create( 'dummy' ).` )
      ( `    var = 42.` )
      ( `      CATCH cx_rfac_error.` )
      ( `        data bla type ref to cx_ris_include_creation_error.` )
      ( `    ENDTRY.§` )
      ( `    IF var = 42.` )
      ( `      WRITE: / 'You found the answer!'.` )
      ( `    ENDIF.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_blackboard' i_type = 'cl_art_blackboard ' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type_ref_to i_occurrence = '2,58-2,70' ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'var' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '4,4-4,7' i_by_value = abap_true ).
    exp_method_constraint->add_exception( i_class_based = abap_true i_name = 'cx_ris_include_creation_error' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_two_exceptions.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one, two raising cx_rfac_error.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `   §data(include) = cl_ris_include=>create( 'dummy' ).` )
      ( `    two( ).§` )
      ( `  endmethod.` )
      ( `  method two.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( i_class_based = abap_true i_name = 'cx_ris_include_creation_error' ).
    exp_method_constraint->add_exception( i_class_based = abap_true i_name = 'cx_rfac_error' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_no_invisible_exception.

    source_code = VALUE #(
      ( `REPORT dummy.` )

      ( `CLASS lcx_invisible_exception DEFINITION INHERITING FROM cx_static_check. ENDCLASS.` )
      ( `CLASS lcx_invisible_exception IMPLEMENTATION. ENDCLASS.` )

      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `    methods: call_invisible_exception RAISING lcx_invisible_exception cx_adt_rest,` )
      ( `             invisible_exception RAISING lcx_invisible_exception.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method call_invisible_exception.` )
      ( `    DATA: a_certain_value TYPE i.` )
      ( `    a_certain_value = 42.` )

      ( `§    IF a_certain_value = 42.` )
      ( `      WRITE: / 'You found the answer!' ##NO_TEXT.` )
      ( `    ENDIF.` )
      ( `    TRY.` )
      ( `        TRY.` )
      ( `            me->invisible_exception( ).` )
      ( `          CATCH lcx_invisible_exception.` )
      ( `        ENDTRY.` )
      ( `        me->invisible_exception( ).` )
      ( `        TRY.` )
      ( `            me->invisible_exception( ).` )
      ( `          CATCH lcx_invisible_exception.` )
      ( `        ENDTRY.` )
      ( `      CATCH lcx_invisible_exception.` )
      ( `    ENDTRY.§` )

      ( `  endmethod.` )
      ( `  method invisible_exception. endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'a_certain_value' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,22' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_invis_old_exceptions.

    source_code = VALUE #(
      ( `REPORT dummy.` )

      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `    methods: one,` )
      ( `             old_school_exceptions EXCEPTIONS old_school_exception vaporware_exception.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `` )
      ( `    DATA: a_certain_value TYPE i.` )
      ( `    a_certain_value = 42.` )

      ( `§    me->old_school_exceptions( ).` )
      ( `    a_certain_value = 23.§` )

      ( `  endmethod.` )

      ( `  method old_school_exceptions. endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_local( 'DATA a_certain_value TYPE i.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_single_line_exception.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    interfaces: th_rfac_intf_extract_method.` )
      ( `    methods: old_school_exceptions EXCEPTIONS old_school_exception vaporware_exception.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method old_school_exceptions.` )
      ( `    DATA: the_duke_is_back TYPE abap_bool VALUE abap_true.` )
      ( `    "check duke status` )
      ( `    IF the_duke_is_back EQ abap_true.` )
      ( `      §RAISE old_school_exception.§ " Yeah, lookin' good!` )
      ( `    ELSE.` )
      ( `      MESSAGE e000(00) RAISING vaporware_exception.` )
      ( `    ENDIF.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( i_class_based = abap_false i_name = 'old_school_exception' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_local_redefinition.

    "RTTI is used for analysis of method signature should be changed to use PST instead

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl_super definition.` )
      ( `  protected section.` )
      ( `    methods: one importing i_importing type i` )
      ( `                 exporting e_exporting type abap_bool` )
      ( `                 changing  c_changing type c.` )
      ( `endclass.` )
      ( `class lcl_sub definition inheriting from lcl_super.` )
      ( `  protected section.` )
      ( `    methods one redefinition.` )
      ( `endclass.` )
      ( `class lcl_sub_sub definition inheriting from lcl_sub.` )
      ( `  protected section.` )
      ( `    methods one final redefinition.` )
      ( `endclass.` )
      ( `class lcl_super implementation.` )
      ( `  method one.` )
      ( `    IF i_importing > 0.       ` )
      ( `      e_exporting = abap_true.` )
      ( `      c_changing  = 'Y'.      ` )
      ( `    ENDIF.                    ` )
      ( `  endmethod.` )
      ( `endclass.` )
      ( `class lcl_sub implementation.` )
      ( `  method one.` )
      ( `  endmethod.` )
      ( `endclass.` )
      ( `class lcl_sub_sub implementation.` )
      ( `  method one.` )
      ( `§    IF i_importing > 0.       ` )
      ( `      e_exporting = abap_true.` )
      ( `      c_changing  = 'Y'.      ` )
      ( `    ENDIF.§                    ` )
      ( `  endmethod.` )
      ( `endclass.` )

    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_importing' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,18' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing'  i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_stolen_things.

    "TODO discuss:
    "why is stolen_field actually added as returning parameter actually it could just be removed from method body and
    "and remain in source method

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    CLASS-DATA: public TYPE string.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §TYPES: ty_stolen_type         TYPE string, ` )
      ( `           ty_another_stolen_type TYPE i,      ` )
      ( `           ty_and_once_again      LIKE public. ` )
      ( `    DATA: stolen_field     TYPE ty_stolen_type,` )
      ( `          not_stolen_field TYPE ty_stolen_type.` )
      ( `    not_stolen_field = 'I will not be stolen!'.§ ` )
      ( `    DATA: another_field     TYPE ty_stolen_type,        ` )
      ( `          yet_another_field TYPE ty_another_stolen_type.` )
      ( `                                                        ` )
      ( `    stolen_field      = 'I will be stolen!'.  ` )
      ( `    yet_another_field = 42.                             ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'stolen_field' i_type = 'ty_stolen_type' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).

    exp_method_constraint->add_type( i_name = 'ty_stolen_type' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).
    exp_method_constraint->add_source_type( i_name = 'ty_another_stolen_type' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).
    exp_method_constraint->add_source_type( i_name = 'ty_and_once_again' i_type = 'public' i_type_type = if_rfac_impl_types=>co_parameter_type_type-like ).
    exp_method_constraint->add_source_local( 'DATA stolen_field TYPE ty_stolen_type.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_stolen_fields.

    "TODO discuss:
    "why is stolen_field actually added as returning parameter actually it could just be removed from method body and
    "and remain in source method

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    CLASS-DATA: public TYPE string.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    TYPES: ty_stolen_type         TYPE string, ` )
      ( `           ty_another_stolen_type TYPE i,      ` )
      ( `           ty_and_once_again      LIKE public. ` )
      ( `    §DATA: stolen_field     TYPE ty_stolen_type,` )
      ( `          not_stolen_field TYPE ty_stolen_type.` )
      ( `    not_stolen_field = 'I will not be stolen!'.§ ` )
      ( `    DATA: another_field     TYPE ty_stolen_type,        ` )
      ( `          yet_another_field TYPE ty_another_stolen_type.` )
      ( `                                                        ` )
      ( `    stolen_field      = 'I will be stolen!'.  ` )
      ( `    yet_another_field = 42.                             ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'stolen_field' i_type = 'ty_stolen_type' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).

    exp_method_constraint->add_type( i_name = 'ty_stolen_type' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).
    exp_method_constraint->add_local( 'TYPES ty_stolen_type TYPE string.' ).
    exp_method_constraint->add_source_local( 'DATA stolen_field TYPE ty_stolen_type.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_one_stolen_field.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §DATA stolen_field TYPE string.      ` )
      ( `    stolen_field = 'I will be stolen!'.§ ` )
      ( `                                         ` )
      ( `    stolen_field = 'I was stolen'.       ` )
      ( `                                         ` )
      ( `    TYPES remaining_type TYPE string.    ` )
      ( `    DATA stolen_data TYPE remaining_type.` )
      ( `    stolen_data = 'Wugga'.               ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'stolen_field' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,4-2,16' ).
    exp_method_constraint->add_source_local( 'DATA stolen_field TYPE string.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_constants.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: some_string    TYPE string,                        ` )
      ( `          another_string TYPE string,                        ` )
      ( `          an_integer     TYPE i.                             ` )
      ( `                                                             ` )
      ( `    CONSTANTS: co_first_constant  TYPE string VALUE 'myself',` )
      ( `               co_second_constant TYPE i VALUE 42.           ` )
      ( `                                                             ` )
      ( `    some_string = co_first_constant.                         ` )
      ( `§    another_string = co_first_constant.                     ` )
      ( `    an_integer = co_second_constant.§                        ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'co_first_constant' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,21-1,38' ).
    exp_method_constraint->add_local( 'CONSTANTS co_second_constant TYPE i VALUE 42.' ).
    exp_method_constraint->add_local( 'DATA an_integer TYPE i.' ).
    exp_method_constraint->add_local( 'DATA another_string TYPE string.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_global_redefinition.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `CLASS lcl DEFINITION FOR TESTING INHERITING FROM th_rfac_redefinition_subclass.` )
      ( `  PUBLIC SECTION.                                                          ` )
      ( `    METHODS: cool_method FINAL REDEFINITION.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  METHOD cool_method.                                            ` )
      ( `§    IF i_importing > 0.                                         ` )
      ( `      e_exporting = abap_true.                                   ` )
      ( `      c_changing  = 'Y'.                                         ` )
      ( `    ENDIF.§                                                      ` )
      ( `    class_attribute = abap_true.                                 ` )
      ( `  ENDMETHOD.                                                     ` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_importing' i_type = 'i' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,18' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing'  i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_case_when_selection.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA integer TYPE i.                ` )
      ( `    CONSTANTS: co_blubb TYPE i VALUE 42.` )
      ( `    integer = co_blubb.                 ` )
      ( `    CASE integer.                       ` )
      ( `      WHEN co_blubb.                    ` )
      ( `§        WRITE: / 'Gut so!'.§           ` )
      ( `      WHEN OTHERS.                      ` )
      ( `        WRITE: / 'Impossible' ##NO_TEXT.` )
      ( `    ENDCASE.                            ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_true( selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
    " Also a second time to check caching!
    cl_abap_unit_assert=>assert_true( selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).

  ENDMETHOD.

  METHOD extract_intf_method_gl_redef.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `CLASS lcl DEFINITION FOR TESTING INHERITING FROM th_rfac_redefinition_subclass.` )
      ( `  PUBLIC SECTION.                                                          ` )
      ( `    METHODS: th_rfac_intf_extract_method~packed_with_all_good_things FINAL REDEFINITION.` )
      ( `  PROTECTED SECTION.` )
      ( `    DATA: protected TYPE string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  METHOD th_rfac_intf_extract_method~packed_with_all_good_things. ` )
      ( `    DATA: variable TYPE string.                                   ` )
      ( `§    IF i_kommt_vielleicht_rein = 'blubb' ##NO_TEXT.              ` )
      ( `      e_exporting = abap_true.                                    ` )
      ( `      c_changing  = 'Y'.                                          ` )
      ( `    ENDIF.§                                                       ` )
      ( `    variable = i_kommt_vielleicht_rein.                           ` )
      ( `    protected = 'Hugo'.                                           ` )
      ( `  ENDMETHOD.                                                      ` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_kommt_vielleicht_rein' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,30' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_intf_method_lo_redef.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `INTERFACE lif.                                     ` )
      ( `  METHODS: packed_with_all_good_things IMPORTING i_importing TYPE i         ` )
      ( `                                                 i_kommt_rein type string   ` )
      ( `                                       EXPORTING e_exporting  TYPE abap_bool` )
      ( `                                       CHANGING  c_changing TYPE c.         ` )
      ( `ENDINTERFACE.                                                               ` )
      ( `class lcl_super definition.` )
      ( `  public section.` )
      ( `    interfaces lif.` )
      ( `endclass.` )
      ( `class lcl_sub definition inheriting from lcl_super.` )
      ( `  public section.` )
      ( `    methods lif~packed_with_all_good_things redefinition.` )
      ( `endclass.` )
      ( `class lcl_sub_sub definition inheriting from lcl_sub.` )
      ( `  public section.` )
      ( `    methods lif~packed_with_all_good_things final redefinition.` )
      ( `endclass.` )
      ( `class lcl_super implementation.` )
      ( `  method lif~packed_with_all_good_things.` )
      ( `    IF i_importing > 0.       ` )
      ( `      e_exporting = abap_true.` )
      ( `      c_changing  = 'Y'.      ` )
      ( `    ENDIF.                    ` )
      ( `  endmethod.` )
      ( `endclass.` )
      ( `class lcl_sub implementation.` )
      ( `  method lif~packed_with_all_good_things.` )
      ( `   " nothing` )
      ( `  endmethod.` )
      ( `endclass.` )
      ( `class lcl_sub_sub implementation.` )
      ( `  method lif~packed_with_all_good_things.` )
      ( `§    IF i_kommt_rein = 'blubb'. ` )
      ( `      e_exporting = abap_true.  ` )
      ( `      c_changing  = 'Y'.        ` )
      ( `    ENDIF.§                     ` )
      ( `  endmethod.` )
      ( `endclass.` )

    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_kommt_rein' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,7-1,19' ).
    exp_method_constraint->add_parameter( i_direction = 'exporting' i_name = 'e_exporting' i_type = 'abap_bool' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,6-2,17' ).
    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'c_changing' i_type = 'c' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '3,6-3,16' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_transitive_redef.

    source_code = VALUE #(
     ( `REPORT dummy.` )
     ( `class lcl_super definition abstract.` )
     ( `  public section.` )
     ( `    methods something_abstract ABSTRACT IMPORTING i_some_string TYPE string.` )
     ( `endclass.` )
     ( `class lcl_sub definition inheriting from lcl_super.` )
     ( `  public section.` )
     ( `    methods something_abstract redefinition.` )
     ( `endclass.` )
     ( `class lcl_super implementation.` )
     ( `endclass.` )
     ( `class lcl_sub implementation.` )
     ( `  method something_abstract.` )
     ( `§    WRITE: / 'This is evil!', i_some_string.§` )
     ( `  endmethod.` )
     ( `endclass.` )

   ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_some_string' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,30-1,43' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_only_dot.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA var type i.` )
      ( `    ADD 1 TO var§.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    assert_exception( i_message = '019' ).

  ENDMETHOD.

  METHOD loop_body_fs_declared_explicit.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA source_code type stringtab.` )
      ( `    field-symbols <code_line> type string.` )
      ( `    LOOP AT source_code assigning <code_line>.` )
      ( `      §"comment code line` )
      ( `      if <code_line> is not initial.` )
      ( `        <code_line> = '*' && <code_line>.` )
      ( `        CONDENSE <code_line>.` )
      ( `        data(count) = strlen( <code_line> ).` )
      ( `      endif.§` )
      ( `    ENDLOOP.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'changing'   i_name = 'code_line' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = '<code_line>' i_occurrence = '2,9-2,20/3,8-3,19/3,29-3,40/4,17-4,28/5,30-5,41' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD loop_body_inline_fs_class_type.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `    TYPES: BEGIN OF ts_my_type, field1 type string, field2 type i, END OF  ts_my_type.` )
      ( `    TYPES tt_my_type TYPE STANDARD TABLE OF ts_my_type WITH EMPTY KEY.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA itab type tt_my_type.` )
      ( `    LOOP AT itab assigning field-symbol(<line>).` )
      ( `      §if <line>-field1 is not initial.` )
      ( `        add 1 to <line>-field2.` )
      ( `        CONDENSE <line>-field1.` )
      ( `      endif.§` )
      ( `    ENDLOOP.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'changing'   i_name = 'line' i_type = 'lcl=>ts_my_type' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = '<line>' i_occurrence = '1,3-1,9/2,17-2,23/3,17-3,23' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD loop_body_inline_fs_itab_param.
    " itab is parameter field symbol is assigned inline
    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one importing source_code type stringtab.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    LOOP AT source_code assigning field-symbol(<code_line>).` )
      ( `      §if <code_line> is not initial.` )
      ( `        WRITE: 'correct'.` )
      ( `      else.` )
      ( `        WRITE: 'incorrect'.` )
      ( `      endif.§` )
      ( `    ENDLOOP.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'importing'   i_name = 'code_line' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = '<code_line>' i_occurrence = '1,3-1,14' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_loop_assign_fs.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one importing source_code type stringtab.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    §LOOP AT source_code assigning field-symbol(<code_line>).` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct'.` )
      ( `      else.` )
      ( `        WRITE: 'incorrect'.` )
      ( `      endif.` )
      ( `    ENDLOOP.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'importing'   i_name = 'source_code' i_type = 'stringtab' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = 'source_code' i_occurrence = '1,8-1,19' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_1st_of_3_loops_with_fs.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: string_table TYPE string_table.        ` )
      ( `                                                 ` )
      ( `    FIELD-SYMBOLS: <string_line> TYPE string.    ` )
      ( `                                                 ` )
      ( `§    LOOP AT string_table ASSIGNING <string_line>.` )
      ( `      <string_line> = 'Hugo'.          ` )
      ( `    ENDLOOP.§                                     ` )
      ( `    LOOP AT string_table ASSIGNING <string_line>.` )
      ( `      <string_line> = 'Karl'.          ` )
      ( `    ENDLOOP.                                     ` )
      ( `    LOOP AT string_table ASSIGNING <string_line>.` )
      ( `      <string_line> = 'Karl'.          ` )
      ( `    ENDLOOP.                                     ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning'   i_name = 'string_table' i_type = 'string_table' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = 'string_table' i_occurrence = '1,12-1,24' ).

    "todo could be improved so that this local is not necessary anymore
    exp_method_constraint->add_local( `FIELD-SYMBOLS <string_line> TYPE string.` ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_2nd_of_3_loops_with_fs.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one importing source_code type stringtab.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    LOOP AT source_code assigning field-symbol(<code_line>).` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `    §LOOP AT source_code assigning <code_line>.` )
      ( `      if <code_line> is not initial.` )
      ( `        <code_line> =  'correct1'.` )
      ( `      endif.` )
      ( `    ENDLOOP.§` )
      ( `    LOOP AT source_code assigning <code_line>.` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct2'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'importing'   i_name = 'source_code' i_type = 'stringtab' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = 'source_code' i_occurrence = '1,8-1,19' ).

    "todo could be improved so that this local is not necessary anymore
    exp_method_constraint->add_local( `FIELD-SYMBOLS <code_line> TYPE string.` ).
    "instead the code could be enriched by an inline declaration
*    exp_method_constraint->set_source_body( value #(
*      ( `LOOP AT source_code assigning field-symbol(<code_line>).` )
*      ( `      if <code_line> is not initial.` )
*      ( `        WRITE: 'correct1'.` )
*      ( `      endif.` )
*      ( `    ENDLOOP.` )
*    ) ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_3rd_of_3_loops_with_fs.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one changing source_code type stringtab.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    LOOP AT source_code assigning field-symbol(<code_line>).` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `    LOOP AT source_code assigning <code_line>.` )
      ( `      if <code_line> is not initial.` )
      ( `        <code_line> =  'correct1'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `    §LOOP AT source_code assigning <code_line>.` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct2'.` )
      ( `      endif.` )
      ( `    ENDLOOP.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'changing'   i_name = 'source_code' i_type = 'stringtab' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = 'source_code' i_occurrence = '1,8-1,19' ).

    "todo could be improved so that this local is not necessary anymore
    exp_method_constraint->add_local( `FIELD-SYMBOLS <code_line> TYPE string.` ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_loop_fs_used_after.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one changing source_code type stringtab.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    LOOP AT source_code assigning field-symbol(<code_line>).` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `    §LOOP AT source_code assigning <code_line>.` )
      ( `      if <code_line> is not initial.` )
      ( `        WRITE: 'correct2'.` )
      ( `      endif.` )
      ( `    ENDLOOP.§` )
      ( `    if <code_line> = 'correct2'.` )
      ( `      clear <code_line>.` )
      ( `    endif.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '026' ).


    "feature request transform statements when field symbols become parameters
    "loop assigning -> loop into
    "assign <fs> -> to variable assignment?
*    exp_method_constraint->add_parameter( i_direction = 'changing'   i_name = 'source_code' i_type = 'stringtab' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
*                                          i_actual = 'source_code' i_occurrence = '1,8-1,19' ).
*    exp_method_constraint->add_parameter( i_direction = 'exporting'   i_name = 'code_line' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
*                                          i_actual = '<code_line>' i_occurrence = '1,30-1,41/2,9-2,20' ).
*    exp_method_constraint->set_source_body( value #(
*      ( `LOOP AT source_code into code_line).` )
*      ( `      if code_line is not initial.` )
*      ( `        WRITE: 'correct1'.` )
*      ( `      endif.` )
*      ( `    ENDLOOP.` )
*    ) ).
*    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_1_of_n_loops_with_ref.

*    cl_abap_unit_assert=>skip( 'could be improved in future but is not in focus now' ).

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    data source_code type stringtab.` )
      ( `    LOOP AT source_code reference into data(ref).` )
      ( `      if ref->* is not initial.` )
      ( `        WRITE: 'correct'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `    §LOOP AT source_code reference into ref.` )
      ( `      if ref->* is not initial.` )
      ( `        ref->* =  'correct1'.` )
      ( `      endif.` )
      ( `    ENDLOOP.§` )
      ( `    LOOP AT source_code reference into ref.` )
      ( `      if ref->* is not initial.` )
      ( `        WRITE: 'correct2'.` )
      ( `      endif.` )
      ( `    ENDLOOP.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).
    exp_method_constraint->add_parameter( i_direction = 'changing'   i_name = 'source_code' i_type = 'stringtab' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = 'source_code' i_occurrence = '1,8-1,19' ).

    "todo could be improved so that this local is not necessary anymore instead the body could be transformed with an inline declaration
    exp_method_constraint->add_local( `DATA ref TYPE REF TO string.` ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_parameter_generic_type.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one importing i_generischer_typ TYPE INDEX TABLE OPTIONAL.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    DATA: string_table TYPE string_table.` )
      ( `    INSERT LINES OF i_generischer_typ INTO TABLE string_table.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'i_generischer_typ' i_type = 'index table' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '2,20-2,37' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_recursion.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: recursion IMPORTING recursive_parameter TYPE string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method recursion.` )
      ( `§    DATA: recursion TYPE i.                                       ` )
      ( `    ADD 1 TO recursion.                                            ` )
      ( `    IF recursion < 10.                                             ` )
      ( `      ##NO_TEXT me->recursion( recursive_parameter = 'Recursive' ).` )
      ( `    ENDIF.§                                                        ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'recursive_parameter' i_type = 'string' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_stolen_statement.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  public section.` )
      ( `    CLASS-DATA: public TYPE string.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    TYPES: ty_stolen_type         TYPE string, ` )
      ( `           ty_another_stolen_type TYPE i,      ` )
      ( `           ty_and_once_again      LIKE public. ` )
      ( `    DATA: stolen_field     TYPE ty_stolen_type,` )
      ( `          not_stolen_field TYPE ty_stolen_type.` )
      ( `    §not_stolen_field = 'I will not be stolen!'.§ ` )
      ( `    DATA: another_field     TYPE ty_stolen_type,        ` )
      ( `          yet_another_field TYPE ty_another_stolen_type.` )
      ( `                                                        ` )
      ( `    stolen_field      = 'I will be stolen!'.  ` )
      ( `    yet_another_field = 42.                             ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_local( 'TYPES ty_stolen_type TYPE string.' ).
    exp_method_constraint->add_local( 'DATA not_stolen_field TYPE ty_stolen_type.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_stolen_data.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA stolen_field TYPE string.      ` )
      ( `    stolen_field = 'I will be stolen!'. ` )
      ( `                                         ` )
      ( `    stolen_field = 'I was stolen'.       ` )
      ( `                                         ` )
      ( `    TYPES remaining_type TYPE string.    ` )
      ( `    §DATA stolen_data TYPE remaining_type.` )
      ( `    stolen_data = 'Wugga'.§               ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).


    exp_method_constraint->add_local( 'TYPES remaining_type TYPE string.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_with_type_conflict.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA table TYPE STANDARD TABLE OF string WITH DEFAULT KEY.` )
      ( `    APPEND 'bla' TO table.                                    ` )
      ( `§    APPEND 'fasel' TO table.                                 ` )
      ( `    APPEND 'soundso' TO table.§                               ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'changing' i_name = 'table' i_type = 'ty_table_1' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,22-1,27/2,24-2,29' ).
    exp_method_constraint->add_type( i_name = 'ty_table_1' i_type = 'STANDARD TABLE OF string WITH DEFAULT KEY' i_type_type = 'TYPE' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_adjust_table_types.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA table TYPE TABLE OF string.` )
      ( `§    APPEND 'fasel' TO table.                                 ` )
      ( `    APPEND 'soundso' TO table.§                               ` )
      ( `    APPEND 'bla' TO table.                                    ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'table' i_type = 'ty_table' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,22-1,27/2,24-2,29' ).
    exp_method_constraint->add_type( i_name = 'ty_table' i_type = 'STANDARD TABLE OF string WITH DEFAULT KEY' i_type_type = 'TYPE' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_adjust_range_linetypes.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    TYPES ty_range TYPE RANGE OF i.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: range_tab_1   TYPE RANGE OF string,          ` )
      ( `          range_tab_2   TYPE ty_range,                 ` )
      ( `          range_entry_1 LIKE LINE OF range_tab_1,      ` )
      ( `          range_entry_2 LIKE LINE OF  range_tab_2.     ` )
      ( `                                                       ` )
      ( `    range_entry_1-sign = range_entry_2-sign = 'I'.     ` )
      ( `    range_entry_1-option = range_entry_2-option = 'EQ'.` )
      ( `    range_entry_1-low = 'hello'.                       ` )
      ( `    range_entry_2-low = 12.                            ` )
      ( `                                                       ` )
      ( `§    APPEND range_entry_1 TO range_tab_1.              ` )
      ( `    APPEND range_entry_2 TO range_tab_2.§              ` )
      ( `                                                       ` )
      ( `    APPEND range_entry_1 TO range_tab_1.               ` )
      ( `    APPEND range_entry_2 TO range_tab_2.               ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '057' ).

  ENDMETHOD.

  METHOD extract_check_without_loop.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: do_it        TYPE abap_bool,                              ` )
      ( `          some_strings TYPE string_table,                           ` )
      ( `          a_string     TYPE string.                                 ` )
      ( `                                                                    ` )
      ( `    LOOP AT some_strings INTO a_string.                             ` )
      ( `§      CHECK do_it = abap_true.§                                    ` )
      ( `    ENDLOOP.                                                        ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '056' ).

  ENDMETHOD.

  METHOD extract_check_with_loop.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: do_it        TYPE abap_bool,                             ` )
      ( `          some_strings TYPE string_table,                          ` )
      ( `          a_string     TYPE string.                                ` )
      ( `                                                                   ` )
      ( `§    LOOP AT some_strings INTO a_string.                            ` )
      ( `      CHECK do_it = abap_true.                                     ` )
      ( `    ENDLOOP.§                                                       ` )
      ( `                                                                   ` )
      ( `    IF do_it = abap_true.                                          ` )
      ( `      RETURN.                                                      ` )
      ( `    ENDIF.                                                         ` )
      ( `                                                                   ` )
      ( `    IF do_it = abap_true.                                          ` )
      ( `      EXIT.                                                        ` )
      ( `    ENDIF.                                                         ` )
      ( `                                                                   ` )
      ( `    WHILE a_string = 'Narf'.                                       ` )
      ( `      IF do_it = abap_true.                                        ` )
      ( `        CONTINUE.                                                  ` )
      ( `      ENDIF.                                                       ` )
      ( `    ENDWHILE.                                                      ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_true( me->selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).

  ENDMETHOD.

  METHOD extract_return.

    source_code = VALUE #(
  ( `REPORT dummy.` )
  ( `class lcl definition.` )
  ( `  private section.` )
  ( `    methods: one.` )
  ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
  ( `endclass.` )
  ( `class lcl implementation.` )
  ( `  method one.` )
  ( `    DATA: do_it        TYPE abap_bool,                             ` )
  ( `          some_strings TYPE string_table,                          ` )
  ( `          a_string     TYPE string.                                ` )
  ( `                                                                   ` )
  ( `    LOOP AT some_strings INTO a_string.                            ` )
  ( `      CHECK do_it = abap_true.                                     ` )
  ( `    ENDLOOP.                                                       ` )
  ( `                                                                   ` )
  ( `§    IF do_it = abap_true.                                          ` )
  ( `      RETURN.                                                      ` )
  ( `    ENDIF.§                                                         ` )
  ( `                                                                   ` )
  ( `    IF do_it = abap_true.                                          ` )
  ( `      EXIT.                                                        ` )
  ( `    ENDIF.                                                         ` )
  ( `                                                                   ` )
  ( `    WHILE a_string = 'Narf'.                                       ` )
  ( `      IF do_it = abap_true.                                        ` )
  ( `        CONTINUE.                                                  ` )
  ( `      ENDIF.                                                       ` )
  ( `    ENDWHILE.                                                      ` )
  ( `  endmethod.` )
  ( `endclass.` )
).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_false( me->selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
  ENDMETHOD.

  METHOD extract_exit_without_loop.

    source_code = VALUE #(
  ( `REPORT dummy.` )
  ( `class lcl definition.` )
  ( `  private section.` )
  ( `    methods: one.` )
  ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
  ( `endclass.` )
  ( `class lcl implementation.` )
  ( `  method one.` )
  ( `    DATA: do_it        TYPE abap_bool,                             ` )
  ( `          some_strings TYPE string_table,                          ` )
  ( `          a_string     TYPE string.                                ` )
  ( `                                                                   ` )
  ( `    LOOP AT some_strings INTO a_string.                            ` )
  ( `      CHECK do_it = abap_true.                                     ` )
  ( `    ENDLOOP.                                                       ` )
  ( `                                                                   ` )
  ( `    IF do_it = abap_true.                                          ` )
  ( `      RETURN.                                                      ` )
  ( `    ENDIF.                                                         ` )
  ( `                                                                   ` )
  ( `§    IF do_it = abap_true.                                          ` )
  ( `      EXIT.                                                        ` )
  ( `    ENDIF.§                                                         ` )
  ( `                                                                   ` )
  ( `    WHILE a_string = 'Narf'.                                       ` )
  ( `      IF do_it = abap_true.                                        ` )
  ( `        CONTINUE.                                                  ` )
  ( `      ENDIF.                                                       ` )
  ( `    ENDWHILE.                                                      ` )
  ( `  endmethod.` )
  ( `endclass.` )
).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_false( me->selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
  ENDMETHOD.

  METHOD extract_continue_without_loop.

    source_code = VALUE #(
  ( `REPORT dummy.` )
  ( `class lcl definition.` )
  ( `  private section.` )
  ( `    methods: one.` )
  ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
  ( `endclass.` )
  ( `class lcl implementation.` )
  ( `  method one.` )
  ( `    DATA: do_it        TYPE abap_bool,                             ` )
  ( `          some_strings TYPE string_table,                          ` )
  ( `          a_string     TYPE string.                                ` )
  ( `                                                                   ` )
  ( `    LOOP AT some_strings INTO a_string.                            ` )
  ( `      CHECK do_it = abap_true.                                     ` )
  ( `    ENDLOOP.                                                       ` )
  ( `                                                                   ` )
  ( `    IF do_it = abap_true.                                          ` )
  ( `      RETURN.                                                      ` )
  ( `    ENDIF.                                                         ` )
  ( `                                                                   ` )
  ( `    IF do_it = abap_true.                                          ` )
  ( `      EXIT.                                                        ` )
  ( `    ENDIF.                                                         ` )
  ( `                                                                   ` )
  ( `    WHILE a_string = 'Narf'.                                       ` )
  ( `§      IF do_it = abap_true.                                        ` )
  ( `        CONTINUE.                                                  ` )
  ( `      ENDIF.§                                                       ` )
  ( `    ENDWHILE.                                                      ` )
  ( `  endmethod.` )
  ( `endclass.` )
).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_false( me->selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
  ENDMETHOD.

  METHOD extract_continue_with_loop.

    source_code = VALUE #(
  ( `REPORT dummy.` )
  ( `class lcl definition.` )
  ( `  private section.` )
  ( `    methods: one.` )
  ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
  ( `endclass.` )
  ( `class lcl implementation.` )
  ( `  method one.` )
  ( `    DATA: do_it        TYPE abap_bool,                             ` )
  ( `          some_strings TYPE string_table,                          ` )
  ( `          a_string     TYPE string.                                ` )
  ( `                                                                   ` )
  ( `    LOOP AT some_strings INTO a_string.                            ` )
  ( `      CHECK do_it = abap_true.                                     ` )
  ( `    ENDLOOP.                                                       ` )
  ( `                                                                   ` )
  ( `    IF do_it = abap_true.                                          ` )
  ( `      RETURN.                                                      ` )
  ( `    ENDIF.                                                         ` )
  ( `                                                                   ` )
  ( `    IF do_it = abap_true.                                          ` )
  ( `      EXIT.                                                        ` )
  ( `    ENDIF.                                                         ` )
  ( `                                                                   ` )
  ( `§    WHILE a_string = 'Narf'.                                       ` )
  ( `      IF do_it = abap_true.                                        ` )
  ( `        CONTINUE.                                                  ` )
  ( `      ENDIF.                                                       ` )
  ( `    ENDWHILE.§                                                      ` )
  ( `  endmethod.` )
  ( `endclass.` )
).

    prepare_with_blackboard(  ).

    cl_abap_unit_assert=>assert_true( me->selection_analyzer->if_rfac_selection_analyzer~supports_method_extraction( ) ).
  ENDMETHOD.

  METHOD extract_inline_declaration.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    DATA(inline_data) = 42.§` )
      ( `    CHECK inline_data = 42.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->set_source_body( VALUE #( (  `         inline_data  = 42.` ) ) ).

    exp_method_constraint->add_source_local( i_local_def = 'DATA inline_data TYPE i.' ).
    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'inline_data' i_type = 'i' i_by_value = abap_true i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,9-1,20' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD use_of_independent_inline_decl.

    cl_abap_unit_assert=>skip( 'work in progress' ).

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    data: itab1 type table of string, itab2 type table of string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§   loop at itab1 into DATA(inline_data).` )
      ( `     check inline_data is not initial.` )
      ( `   endloop.§` )
      ( `   loop at itab2 into inline_data.` )
      ( `     check inline_data is not initial.` )
      ( `   endloop.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_source_local( i_local_def = 'DATA inline_data TYPE string.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_changing_field_symbol.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: string_table TYPE string_table.        ` )
      ( `                                                 ` )
      ( `    FIELD-SYMBOLS: <string_line> TYPE string.    ` )
      ( `                                                 ` )
      ( `    LOOP AT string_table ASSIGNING <string_line>.` )
      ( `      <string_line> = 'Hugo'.                    ` )
      ( `    ENDLOOP.                                     ` )
      ( `§    LOOP AT string_table ASSIGNING <string_line>.` )
      ( `      <string_line> = 'Karl'.                     ` )
      ( `    ENDLOOP.§                                     ` )
      ( `    LOOP AT string_table ASSIGNING <string_line>.` )
      ( `      <string_line> = 'Karl'.                    ` )
      ( `    ENDLOOP.                                     ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'changing'   i_name = 'string_table' i_type = 'string_table' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type
                                          i_actual = 'string_table' i_occurrence = '1,12-1,24' ).

    "todo could be improved so that this local is not necessary anymore instead the source body could be transformed with an inline declaration
    exp_method_constraint->add_local( `FIELD-SYMBOLS <string_line> TYPE string.` ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_inline_field_symbol.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    CONSTANTS: co_constant TYPE i VALUE 42.                      ` )
      ( `§    ASSIGN co_constant TO FIELD-SYMBOL(<inline_field_symbol>).§ ` )
      ( `    CHECK <inline_field_symbol> = 42.                            ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '026' ).
  ENDMETHOD.

  METHOD extract_component_write_read.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: tadir TYPE tadir.            ` )
      ( `§    tadir-object = 'CLAS'.§           ` )
      ( `    tadir-obj_name = 'ONKEL_HUGO'.     ` )
      ( `    ASSERT tadir-object IS NOT INITIAL.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'tadir' i_type = 'tadir' i_by_value = abap_true i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,4-1,9' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_override_signature.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one RETURNING VALUE(r_exception) TYPE REF TO cx_rfac_error.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    CREATE OBJECT r_exception.                         ` )
      ( `§    r_exception->if_t100_message~t100key-msgno = '666'.§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'importing' i_name = 'r_exception' i_type = 'cx_rfac_error' i_type_type = if_rfac_impl_types=>co_parameter_type_type-type_ref_to i_occurrence = '1,4-1,15' ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD extract_complex_like_reference.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    DATA: liked                  TYPE string,                                          ` )
      ( `          complex_like_reference LIKE SORTED TABLE OF liked WITH UNIQUE KEY table_line.` )
      ( `                                                                                       ` )
      ( `    liked = 'I am liked!' ##NO_TEXT.                                                   ` )
      ( `    INSERT liked INTO TABLE complex_like_reference.                                    ` )
      ( `§    liked = 'I am liked, too!' ##NO_TEXT.                                             ` )
      ( `    INSERT liked INTO TABLE complex_like_reference.§                                   ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '057' ).

  ENDMETHOD.

  METHOD extract_type_in_source_method.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    TYPES: BEGIN OF my_tadir,                                                                                                ` )
      ( `             pgmid       TYPE tadir-pgmid,                                                                                   ` )
      ( `             object_type TYPE tadir-object,                                                                                  ` )
      ( `             object_name TYPE tadir-obj_name,                                                                                ` )
      ( `           END OF my_tadir.                                                                                                  ` )
      ( `    DATA: tadir_table TYPE TABLE OF my_tadir.                                                                                ` )
      ( `                                                                                                                             ` )
      ( `    LOOP AT tadir_table ASSIGNING FIELD-SYMBOL(<key>) GROUP BY ( type = <key>-object_type ) INTO DATA(tadir).                ` )
      ( `§      DATA(another_tadir) = tadir.§                                                                                         ` )
      ( `    ENDLOOP.                                                                                                                 ` )
      ( `                                                                                                                             ` )
      ( `    LOOP AT tadir_table ASSIGNING FIELD-SYMBOL(<key2>) GROUP BY ( type = <key>-object_type ) ASSIGNING FIELD-SYMBOL(<tadir>).` )
      ( `      DATA(yet_another_tadir) = <tadir>.                                                                                   ` )
      ( `    ENDLOOP.                                                                                                                 ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '058' ).

  ENDMETHOD.

  METHOD extract_method_method.

    source_code = VALUE #(
  ( `REPORT dummy.` )
  ( `class lcl definition.` )
  ( `  private section.` )
  ( `    methods: one.` )
  ( `endclass.` )
  ( `class lcl implementation.` )
  ( `  method one.` )
  ( `§        WRITE: / 'Method method!'.§` )
  ( `  endmethod.` )
  ( `endclass.` )
).

    prepare_with_blackboard(  ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_parent_child_exception.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one raising cx_rfac_invalid_parameter,` )
      ( `             two raising cx_rfac_error,` )
      ( `             three.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `  endmethod.` )
      ( `  method two.` )
      ( `  endmethod.` )
      ( `  method three.` )
      ( `§   TRY.                                          ` )
      ( `       me->one( ).                                ` )
      ( `     CATCH cx_rfac_error ##NO_HANDLER.            ` )
      ( `   ENDTRY.                                        ` )
      ( `   TRY.                                           ` )
      ( `       me->two( ).                                ` )
      ( `     CATCH cx_rfac_invalid_parameter ##NO_HANDLER.` )
      ( `   ENDTRY.§                                       ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( EXPORTING i_class_based = abap_true i_name = 'cx_rfac_error' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_multiple_exceptions.

    "TODO actually two more tests needed two exception which have a common parent and two exception which are independent

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: raising_rest RAISING cx_adt_rest,      ` )
      ( `             raising_rfac RAISING cx_rfac_adt_error,` )
      ( `             three RAISING cx_adt_rest.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method raising_rest.` )
      ( `  endmethod.` )
      ( `  method raising_rfac.` )
      ( `  endmethod.` )
      ( `  method three.` )
      ( `§    me->raising_rfac( ).` )
      ( `    me->raising_rest( ).§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( EXPORTING i_class_based = abap_true i_name = 'cx_adt_rest' ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD extract_field_exception.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§   DATA: exception TYPE REF TO cx_rfac_error.` )
      ( `   CREATE OBJECT exception.                  ` )
      ( `   RAISE EXCEPTION exception.§                ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( EXPORTING i_class_based = abap_true i_name = 'cx_rfac_error' ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD extract_try_catch_raising.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    TRY.                                                                       ` )
      ( `        IF sy-subrc = 0. RAISE EXCEPTION TYPE cx_rfac_invalid_parameter. ENDIF.` )
      ( `        RAISE EXCEPTION TYPE cx_rfac_error.                                    ` )
      ( `      CATCH cx_rfac_invalid_parameter.                                         ` )
      ( `        RAISE EXCEPTION TYPE cx_rfac_error.                                    ` )
      ( `    ENDTRY.§                                                                    ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( EXPORTING i_class_based = abap_true i_name = 'cx_rfac_error' ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD extract_raising_resumable.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    TRY.                                                        ` )
      ( `        IF sy-subrc = 0.                                        ` )
      ( `            RAISE RESUMABLE EXCEPTION TYPE cx_rfac_error.` )
      ( `        ENDIF.                                                  ` )
      ( `    ENDTRY.§                                                     ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( EXPORTING i_class_based = abap_true i_name = 'cx_rfac_error' i_resumable = abap_true ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD extract_throw_resumable.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    data(var) = cond char10( when sy-subrc = 0 then 'ok'` )
      ( `                              else throw resumable cx_rfac_error( ) ).§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->add_exception( EXPORTING i_class_based = abap_true i_name = 'cx_rfac_error' i_resumable = abap_true ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD dont_extract_no_catch_exc.

    source_code = VALUE #(
      ( `REPORT dummy.` )

      ( `CLASS lcx_no_check DEFINITION INHERITING FROM cx_no_check. ENDCLASS.` )
      ( `CLASS lcx_no_check IMPLEMENTATION. ENDCLASS.` )

      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    data(var) = cond char10( when sy-subrc = 0 then 'ok'` )
      ( `                              else throw lcx_no_check( ) ).§` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_method_consistency( ).

  ENDMETHOD.

  METHOD extract_inline_type_select.

    "TODO should be improved helper type should be created with method similar to create local var
    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    SELECT arbgb, msgnr FROM t100 INTO TABLE @DATA(partial).§` )
      ( `    LOOP AT partial INTO DATA(partial_line).` )
      ( `    ENDLOOP. ` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '058' ).
  ENDMETHOD.

  METHOD extract_inline_type_select_fs.

    source_code = VALUE #(
  ( `REPORT dummy.` )
  ( `class lcl definition.` )
  ( `  private section.` )
  ( `    methods: one.` )
  ( `    TYPES ty_table TYPE STANDARD TABLE OF string.` )
  ( `endclass.` )
  ( `class lcl implementation.` )
  ( `  method one.` )
  ( `    TYPES: BEGIN OF my_tadir,                                                                                                ` )
  ( `             pgmid       TYPE tadir-pgmid,                                                                                   ` )
  ( `             object_type TYPE tadir-object,                                                                                  ` )
  ( `             object_name TYPE tadir-obj_name,                                                                                ` )
  ( `           END OF my_tadir.                                                                                                  ` )
  ( `    DATA: tadir_table TYPE TABLE OF my_tadir.                                                                                ` )
  ( `                                                                                                                             ` )
  ( `    LOOP AT tadir_table ASSIGNING FIELD-SYMBOL(<key>) GROUP BY ( type = <key>-object_type ) INTO DATA(tadir).                ` )
  ( `      DATA(another_tadir) = tadir.                                                                                           ` )
  ( `    ENDLOOP.                                                                                                                 ` )
  ( `                                                                                                                             ` )
  ( `    LOOP AT tadir_table ASSIGNING FIELD-SYMBOL(<key2>) GROUP BY ( type = <key>-object_type ) ASSIGNING FIELD-SYMBOL(<tadir>).` )
  ( `§      DATA(yet_another_tadir) = <tadir>.§                                                                                   ` )
  ( `    ENDLOOP.                                                                                                                 ` )
  ( `  endmethod.` )
  ( `endclass.` )
).

    prepare_with_blackboard(  ).

    me->assert_exception( i_message = '058' ).

  ENDMETHOD.

  METHOD extract_inline_host_var.

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `§    SELECT SINGLE pgmid FROM tadir INTO @DATA(inline_data) WHERE object = 'CLAS' AND obj_name = 'CL_RIS_ACTION'.§` )
      ( `    CHECK inline_data = 'R3TR'.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

    prepare_with_blackboard(  ).

    exp_method_constraint->set_source_body( VALUE #( ( `    SELECT SINGLE pgmid FROM tadir INTO      @inline_data  WHERE object = 'CLAS' AND obj_name = 'CL_RIS_ACTION'.` ) ) ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'inline_data' i_type = 'tadir-pgmid' i_by_value = abap_true i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '1,46-1,57' ).
    exp_method_constraint->add_source_local( 'DATA inline_data TYPE tadir-pgmid.' ).

    me->assert_method_consistency( ).
  ENDMETHOD.

  METHOD dont_add_type_for_generic_fs.

    "motivated by internal incident https://support.wdf.sap.corp/sap/support/message/1980489931

    source_code = VALUE #(
      ( `REPORT dummy.` )
      ( `class lcl definition.` )
      ( `  private section.` )
      ( `    methods: one exporting e_flag type abap_bool.` )
      ( `    methods: two returning value(result) type ref to data.` )
      ( `endclass.` )
      ( `class lcl implementation.` )
      ( `  method one.` )
      ( `    field-symbols:` )
      ( `      <lt_data> type standard table.` )
      ( `    §data(ref_to_itab) = me->two( ).` )
      ( `    assign ref_to_itab->* to <lt_data>.` )
      ( `    if <lt_data> is not initial.` )
      ( `      e_flag = abap_true.` )
      ( `    endif.§` )
      ( `  endmethod.` )
      ( `  method two.` )
      ( `    data itab type stringtab.` )
      ( `    assign reference of itab to result.` )
      ( `  endmethod.` )
      ( `endclass.` )
    ).

     prepare_with_blackboard(  ).

    exp_method_constraint->add_parameter( i_direction = 'returning' i_name = 'e_flag' i_type = 'abap_bool' i_by_value = abap_true i_type_type = if_rfac_impl_types=>co_parameter_type_type-type i_occurrence = '4,6-4,12' ).
    exp_method_constraint->add_local( 'FIELD-SYMBOLS <lt_data> TYPE STANDARD TABLE.' ).

    me->assert_method_consistency( ).

  ENDMETHOD.

ENDCLASS.

class ltc_affected_var_abstract definition abstract inheriting from th_art_contributor for testing
  duration short
  risk level harmless.
  protected section.
    constants: none type lif_affected_variable=>param_direction value lif_affected_variable=>parameter_direction-none,
               importing type lif_affected_variable=>param_direction value lif_affected_variable=>parameter_direction-importing,
               exporting type lif_affected_variable=>param_direction value lif_affected_variable=>parameter_direction-exporting,
               changing type lif_affected_variable=>param_direction value lif_affected_variable=>parameter_direction-changing,
               returning type lif_affected_variable=>param_direction value lif_affected_variable=>parameter_direction-returning.
    DATA: affected_variables TYPE lif_affected_variable=>tab.
    methods
      exercise
        returning value(r_result) type lif_affected_variable=>tab
        RAISING cx_rfac_error.
    METHODS assert_affected_variables
      IMPORTING
        exp TYPE i.
    METHODS assert_variable_at
      IMPORTING
        index     TYPE i
        name      TYPE string
        parameter TYPE lif_affected_variable=>param_direction.
  private section.

endclass.

class cl_rfac_selection_analyzer DEFINITION local friends ltc_affected_var_abstract.
class ltc_affected_var_abstract implementation.

  method assert_variable_at.
    cl_abap_unit_assert=>assert_equals( exp = name act = affected_variables[ index ]->get_name(  ) ).
    cl_abap_unit_assert=>assert_equals( exp = parameter act = affected_variables[ index ]->get_parameter_direction(  ) ).
  endmethod.

  method assert_affected_variables.
    assert_lines( exp = exp itab = affected_variables ).
  endmethod.

  method exercise.
    prepare_blackboard(  ).
    data(selection_analyzer) = cl_rfac_selection_analyzer=>get_instance( i_blackboard = blackboard ).
    selection_analyzer->if_rfac_selection_analyzer~get_selection_as_method(  ).

    r_result = value #( for <line> in selection_analyzer->affected_variables ( <line>-affected_variable ) ).

  endmethod.

endclass.

*class ltc_affected_var_innards definition inheriting from ltc_affected_var_abstract final for testing
*  duration short
*  risk level harmless.
*
*  private section.
*    methods:
*      determine_leading_usage_access FOR TESTING RAISING cx_static_check,
*      usage_above_is_independent for testing raising cx_static_check,
*      usage_below_is_independent for testing raising cx_static_check,
*      usage_inside_is_independent for testing raising cx_static_check.
*    METHODS verify_leading_usage_access
*      IMPORTING
*        leading TYPE lif_affected_variable=>usage_access
*        next TYPE lif_affected_variable=>usage_access
*        exp  TYPE lif_affected_variable=>usage_access.
*    METHODS assert_usage_above_independent
*      IMPORTING
*        index TYPE i
*        exp   TYPE abap_bool.
*    METHODS assert_usage_below_independent
*      IMPORTING
*        index TYPE i
*        exp   TYPE abap_bool.
*    METHODS assert_usage_inside_indepndent
*      IMPORTING
*        index TYPE i
*        exp   TYPE abap_bool.
*endclass.
*
*
*class ltc_affected_var_innards implementation.
*
*   method determine_leading_usage_access.
*
*    verify_leading_usage_access( leading = lif_affected_variable=>variable_usage-read
*                                 next = lif_affected_variable=>variable_usage-read
*                                 exp  = lif_affected_variable=>variable_usage-read ).
*
*    verify_leading_usage_access( leading = lif_affected_variable=>variable_usage-write
*                                 next = lif_affected_variable=>variable_usage-write
*                                 exp  = lif_affected_variable=>variable_usage-write ).
*
*    verify_leading_usage_access( leading = lif_affected_variable=>variable_usage-read
*                                 next = lif_affected_variable=>variable_usage-write
*                                 exp  = lif_affected_variable=>variable_usage-read_and_write ).
*
*    verify_leading_usage_access( leading = lif_affected_variable=>variable_usage-write
*                                 next = lif_affected_variable=>variable_usage-read
*                                 exp  = lif_affected_variable=>variable_usage-write ).
*
*    verify_leading_usage_access( leading = lif_affected_variable=>variable_usage-read_and_write
*                                 next = lif_affected_variable=>variable_usage-write
*                                 exp  = lif_affected_variable=>variable_usage-read_and_write ).
*
*    verify_leading_usage_access( leading = lif_affected_variable=>variable_usage-write
*                                 next = lif_affected_variable=>variable_usage-read_and_write
*                                 exp  = lif_affected_variable=>variable_usage-write ).
*
*  endmethod.
*
*  METHOD verify_leading_usage_access.
*
*    data(act) = lcl_affected_variable=>determine_leading_usage( i_leading_usage_access = leading
*                                                                i_next_usage_access = next ).
*
*    cl_abap_unit_assert=>assert_equals( exp = exp act = act ).
*
*  ENDMETHOD.
*
*  method usage_above_is_independent.
*
*     source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    data: var1 type i, var2 type i. ` )
*      ( `    var1 = 1. var2 = 2.` )
*      ( `    §if var1 = 1.` )
*      ( `      var2 = 5.` )
*      ( `    endif.§` )
*      ( `    data(var3) = var1 + var2.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 2 ).
*    "var1
*    assert_usage_above_independent( index = 1 exp = abap_false ).
*    "var2
*    assert_usage_above_independent( index = 2 exp = abap_true ).
*
*  endmethod.
*
*  method usage_below_is_independent.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    data: var1 type i, var2 type i. ` )
*      ( `    var1 = 1. var2 = 2.` )
*      ( `    §if var1 = 1.` )
*      ( `      var2 = 5.` )
*      ( `    endif.§` )
*      ( `    var1 = 3.` )
*      ( `    data(var3) = var1 + var2.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 2 ).
*    "var1
*    assert_usage_below_independent( index = 1 exp = abap_true ).
*    "var2
*    assert_usage_below_independent( index = 2 exp = abap_false ).
*
*  endmethod.
*
*  method usage_inside_is_independent.
*
*     source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    data: var1 type i, var2 type i. ` )
*      ( `    var1 = 1. var2 = 2.` )
*      ( `    §var1 = 2.` )
*      ( `     var2 = 5.§` )
*      ( `    var1 = 3.` )
*      ( `    data(var3) = var1 + var2.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 2 ).
*    "var1
*    assert_usage_inside_indepndent( index = 1 exp = abap_true ).
*    "var2
*    assert_usage_inside_indepndent( index = 2 exp = abap_false ).
*
*  endmethod.
*
*
*  METHOD assert_usage_above_independent.
*    data(affected_var) = cast lcl_affected_variable( affected_variables[ index ] ).
*    cl_abap_unit_assert=>assert_equals( exp = exp act = affected_var->usages_above_are_independent(  ) ).
*  ENDMETHOD.
*
*
*  METHOD assert_usage_below_independent.
*    data(affected_var) = cast lcl_affected_variable( affected_variables[ index ] ).
*    cl_abap_unit_assert=>assert_equals( exp = exp act = affected_var->usages_below_are_independent(  ) ).
*  ENDMETHOD.
*
*
*  METHOD assert_usage_inside_indepndent.
*    data(affected_var) = cast lcl_affected_variable( affected_variables[ index ] ).
*    cl_abap_unit_assert=>assert_equals( exp = exp act = affected_var->usages_inside_are_independent(  ) ).
*  ENDMETHOD.
*
*endclass.
*
*class ltc_affected_var_no_param definition final INHERITING FROM ltc_affected_var_abstract for testing duration short risk level harmless.
*
*  private section.
*    methods:
*    whole_method_body_selected FOR TESTING RAISING cx_static_check,
*    definition_above_selection FOR TESTING RAISING cx_static_check,
*    usage_of_attribute FOR TESTING RAISING cx_static_check.
*
*endclass.
*
*class ltc_affected_var_no_param implementation.
*
*  method whole_method_body_selected.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §data var type i. ` )
*      ( `    do 10 times.` )
*      ( `      add 1 to var.` )
*      ( `      write: var, /.` )
*      ( `    ENDDO.§` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = none ).
*
*  endmethod.
*
*  method definition_above_selection.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    data var type i. ` )
*      ( `    §do 10 times.` )
*      ( `      add 1 to var.` )
*      ( `      write: var, /.` )
*      ( `    ENDDO.§` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = none ).
*
*  endmethod.
*
*  method usage_of_attribute.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    data: attribute type i.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §do 10 times.` )
*      ( `      add 1 to attribute.` )
*      ( `    ENDDO.§` )
*      ( `    write: attribute, /.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `attribute` parameter = none ).
*
*  endmethod.
*
*endclass.
*
*class ltc_affected_var_param definition final INHERITING FROM ltc_affected_var_abstract for testing duration short risk level harmless.
*
*  private section.
*    methods:
*      parameters_of_source_method for testing raising cx_static_check,
*      dr_inside_r_below_importing FOR TESTING RAISING cx_static_check,
*      dw_inside_r_below_exporting FOR TESTING RAISING cx_static_check,
*      dw_inside_rw_below_exporting FOR TESTING RAISING cx_static_check,
*      drw_inside_r_below_changing FOR TESTING RAISING cx_static_check,
*    dw_inside_w_below_none FOR TESTING RAISING cx_static_check,
*    d_above_w_inside_w_below_none FOR TESTING RAISING cx_static_check,
*    dw_above_w_inside_w_below_none FOR TESTING RAISING cx_static_check.
*
*endclass.
*
*class ltc_affected_var_param implementation.
*
*  method parameters_of_source_method.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one importing i_number type i` )
*      ( `                 exporting e_number type i` )
*      ( `                 changing  c_number type i` )
*      ( `                 returning value(r_result) type i.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §IF i_number mod 2 = 1.` )
*      ( `      r_result = i_number + 1.` )
*      ( `    ELSEIF e_number IS SUPPLIED.` )
*      ( `      r_result = i_number.` )
*      ( `    ENDIF.§` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 3 ).
*    assert_variable_at( index = 1 name = `e_number` parameter = importing ).
*    assert_variable_at( index = 2 name = `i_number` parameter = importing ).
*    assert_variable_at( index = 3 name = `r_result` parameter = exporting ).
*
*  endmethod.
*
*  method drw_inside_r_below_changing.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §data var type i. ` )
*      ( `    do 10 times.` )
*      ( `      add 1 to var.` )
*      ( `    ENDDO.§` )
*      ( `    write: var, /.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = changing ).
*
*  endmethod.
*
*  method dr_inside_r_below_importing.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §data var type i. ` )
*      ( `    write: var, /.§` )
*      ( `    write: var, /.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = importing ).
*
*  endmethod.
*
*  method dw_inside_rw_below_exporting.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §data var type i. ` )
*      ( `    var = 5.§` )
*      ( `    add 1 to var.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = exporting ).
*
*  endmethod.
*
*  method dw_inside_r_below_exporting.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §data var type i. ` )
*      ( `    var = 5.§` )
*      ( `    write: var, /.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = exporting ).
*
*  endmethod.
*
*  method dw_inside_w_below_none.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    §data var type i. ` )
*      ( `    var = 5.§` )
*      ( `    var = 7.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = none ).
*
*  endmethod.
*
*  method d_above_w_inside_w_below_none.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    data var type i. ` )
*      ( `    §var = 5.§` )
*      ( `    var = 7.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = none ).
*
*  endmethod.
*
*  method dw_above_w_inside_w_below_none.
*
*    source_code = VALUE #(
*      ( `REPORT dummy.` )
*      ( `class lcl definition.` )
*      ( `  private section.` )
*      ( `    methods: one.` )
*      ( `endclass.` )
*      ( `class lcl implementation.` )
*      ( `  method one.` )
*      ( `    data var type i. ` )
*      ( `    var = 3.` )
*      ( `    §var = 5.§` )
*      ( `    var = 7.` )
*      ( `  endmethod.` )
*      ( `endclass.` )
*    ).
*
*    affected_variables = exercise(  ).
*    assert_affected_variables( 1 ).
*    assert_variable_at( index = 1 name = `var` parameter = none ).
*
*  endmethod.
*
*endclass.