class cl_rtst_rcv_product_dpc_ext definition
  public
  inheriting from cl_rtst_rcv_product_dpc
  create public .

  public section.

    methods /iwbep/if_mgw_appl_srv_runtime~changeset_begin
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~changeset_end
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~changeset_process
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~create_deep_entity
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~create_entity
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~get_entity
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~get_entityset
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~get_expanded_entity
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~get_expanded_entityset
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~get_is_conditional_implemented
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~get_stream
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~patch_entity
        redefinition .
    methods /iwbep/if_mgw_appl_srv_runtime~update_entity
        redefinition .
  protected section.

    methods documentitems_get_entity
        redefinition .
    methods documentitems_get_entityset
        redefinition .
    methods documentitems_update_entity
        redefinition .
    methods documents_get_entity
        redefinition .
    methods documents_get_entityset
        redefinition .
    methods filters_get_entityset
        redefinition .
    methods filtervalues_get_entityset
        redefinition .
    methods globaltradeitemn_get_entityset
        redefinition .
    methods postdocumentitem_get_entity
        redefinition .
    methods postdocumentitem_get_entityset
        redefinition .
    methods postdocuments_create_entity
        redefinition .
    methods postdocuments_get_entity
        redefinition .
    methods productquantityu_get_entityset
        redefinition .
    methods products_get_entity
        redefinition .
    methods products_get_entityset
        redefinition .
    methods scaninformations_get_entity
        redefinition .
    methods settingsset_get_entity
        redefinition .
    methods stores_get_entity
        redefinition .
    methods stores_get_entityset
        redefinition .
    methods suppliers_get_entity
        redefinition .
    methods suppliers_get_entityset
        redefinition .
    methods users_get_entity
        redefinition .
    methods users_update_entity
        redefinition .
  private section.

    data gv_store_id          type cl_rtst_rcv_product_mpc=>ts_store-store_id.
    data gv_chgset_processing_is_active type abap_bool value abap_false.
    data go_application_log   type ref to cl_rtst_application_log.

ENDCLASS.



CLASS CL_RTST_RCV_PRODUCT_DPC_EXT IMPLEMENTATION.


  method users_update_entity.

    clear er_entity.

    cl_rtst_rp_user=>get_instance( )->update_entity(
      exporting
        io_tech_request_context = io_tech_request_context
        io_data_provider        = io_data_provider
      importing
        es_entity               = er_entity
        ).

  endmethod.


  method users_get_entity.

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_user=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity           = er_entity
        es_response_context = es_response_context
        ).

  endmethod.


  method suppliers_get_entityset            .

    clear et_entityset.
    clear es_response_context.

    cl_rtst_rp_supplier=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
        ).

  endmethod.


  method suppliers_get_entity.

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_supplier=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method stores_get_entityset            .

    clear et_entityset.
    clear es_response_context.

    cl_rtst_rp_store=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
        ).

  endmethod.


  method stores_get_entity.

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_store=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method settingsset_get_entity.

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_settings=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity           = er_entity
        es_response_context = es_response_context
        ).

  endmethod.


  method scaninformations_get_entity     .

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_scan_information=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method products_get_entityset         .

    clear es_response_context.

    cl_rtst_rp_product=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
    ).

  endmethod.


  method products_get_entity         .

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_product=>get_instance( )->get_entity(
          exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method productquantityu_get_entityset.

    clear et_entityset.
    clear es_response_context.

    cl_rtst_rp_prod_quantity_unit=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
        ).

  endmethod.


  method postdocuments_get_entity.

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_post_document=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method postdocuments_create_entity.

    clear er_entity.

    cl_rtst_rp_post_document=>get_instance( )->create_entity(
      exporting
        io_tech_request_context = io_tech_request_context
        io_data_provider        = io_data_provider
      importing
        es_entity               = er_entity
        ).


  endmethod.


  method postdocumentitem_get_entityset.

    clear es_response_context.

    cl_rtst_rp_post_document_item=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
    ).

  endmethod.


  method postdocumentitem_get_entity.

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_post_document_item=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method globaltradeitemn_get_entityset  .

    clear et_entityset.
    clear es_response_context.

    cl_rtst_rp_product_gtin=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
        ).

  endmethod.


  method filtervalues_get_entityset      .

    clear et_entityset.
    clear es_response_context.

    cl_rtst_rp_filter_value=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
        ).

  endmethod.


  method filters_get_entityset           .

    clear et_entityset.
    clear es_response_context.

    cl_rtst_rp_filter=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
        ).
  endmethod.


  method documents_get_entityset         .

    clear es_response_context.

    cl_rtst_rp_document=>get_instance( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
    ).

  endmethod.


  method documents_get_entity         .

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_document=>get_instance( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
        ).

  endmethod.


  method documentitems_update_entity.

    clear er_entity.

    cl_rtst_rp_factory=>get_document_item( )->update_entity(
      exporting
        io_tech_request_context = io_tech_request_context
        io_data_provider        = io_data_provider
      importing
        es_entity               = er_entity
        ).

  endmethod.


  method documentitems_get_entityset       .

    clear es_response_context.

    cl_rtst_rp_factory=>get_document_item( )->get_entityset(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        et_entityset            = et_entityset
        es_response_context     = es_response_context
    ).

  endmethod.


  method documentitems_get_entity       .

    clear er_entity.
    clear es_response_context.

    cl_rtst_rp_factory=>get_document_item( )->get_entity(
      exporting
        io_tech_request_context = io_tech_request_context
      importing
        es_entity               = er_entity
        es_response_context     = es_response_context
    ).

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~update_entity.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    if gv_store_id is initial.
      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( io_tech_request_context->get_keys( ) ).
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_name iv_subkey_ext2 = 'update_entity' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_key_tab it_navigation_path.

    try.
        super->/iwbep/if_mgw_appl_srv_runtime~update_entity(
          exporting
            iv_entity_name               = iv_entity_name
            iv_entity_set_name           = iv_entity_set_name
            iv_source_name               = iv_source_name
            io_data_provider             = io_data_provider
            it_key_tab                   = it_key_tab
            it_navigation_path           = it_navigation_path
            io_tech_request_context      = io_tech_request_context
          importing
            er_entity                    = er_entity
        ).

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'update_entity - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'update_entity - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey(  iv_subkey_ext2 = 'update_entity') ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~patch_entity.

    break-point id rtst_debug.

*   set components to be updated
    cl_rtst_rp_factory=>get_document_item( )->set_patch_components( it_patch_components = io_tech_request_context->get_components( ) ).

    /iwbep/if_mgw_appl_srv_runtime~update_entity(
      exporting
        iv_entity_name          = iv_entity_name
        iv_entity_set_name      = iv_entity_set_name
        iv_source_name          = iv_source_name
        io_data_provider        = io_data_provider
        it_key_tab              = it_key_tab
        it_navigation_path      = it_navigation_path
        io_tech_request_context = io_tech_request_context
      importing
        er_entity               = er_entity
    ).

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~get_stream.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    if gv_store_id is initial.
      data(lt_keys) = io_tech_request_context->get_keys( ).
      append lines of io_tech_request_context->get_source_keys( ) to lt_keys.
      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( lt_keys ).
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_name iv_subkey_ext2 = 'get_stream' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_key_tab it_navigation_path.

    try.

*       only product has media (product images)
        if iv_entity_name = cl_rtst_rcv_product_mpc=>gc_product.

          cl_rtst_rp_product=>get_instance( )->get_stream(
            exporting
              io_tech_request_context      = io_tech_request_context
            importing
              er_stream                    = er_stream
              es_response_context          = es_response_context
          ).

        endif.

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        if lo_busi_exc->http_status_code <> /iwbep/cx_mgw_busi_exception=>gcs_http_status_codes-not_found.
          "don't flood the log with not found exceptions
          go_application_log->add_message_from_exception( lo_busi_exc ).
        endif.
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entity - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entity - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_stream' ) ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~get_is_conditional_implemented.
    if iv_entity_set_name = 'DocumentItems'.                "#EC NOTEXT
      rv_conditional_active = abap_true.
    endif.
  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~get_expanded_entityset.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    clear er_entityset.
    clear et_expanded_clauses.
    clear et_expanded_tech_clauses.
    clear es_response_context.

    if gv_store_id is initial.
      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( io_tech_request_context->get_source_keys( ) ).
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_set_name iv_subkey_ext2 = 'get_expanded_entityset' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_filter_select_options it_order is_paging it_navigation_path it_key_tab
        iv_filter_string iv_search_string et_expanded_tech_clauses.

    try.
        case io_tech_request_context->get_entity_type_name( ).
          when cl_rtst_rcv_product_mpc=>gc_document.
            cl_rtst_rp_document=>get_instance( )->get_expanded_entityset(
              exporting
                io_tech_request_context  = io_tech_request_context
                io_expand                = io_expand
              importing
                ert_entityset            = data(ert_document_entityset)
              changing
                ct_expanded_tech_clauses = et_expanded_tech_clauses
                cs_response_context      = es_response_context
              ).
            er_entityset = ert_document_entityset.

          when cl_rtst_rcv_product_mpc=>gc_documentitem.
            cl_rtst_rp_factory=>get_document_item( )->get_expanded_entityset(
              exporting
                io_tech_request_context  = io_tech_request_context
                io_expand                = io_expand
              importing
                ert_entityset            = data(ert_documentitem_entityset)
              changing
                ct_expanded_tech_clauses = et_expanded_tech_clauses
                cs_response_context      = es_response_context
              ).
            er_entityset = ert_documentitem_entityset.

          when others.
            super->/iwbep/if_mgw_appl_srv_runtime~get_expanded_entityset(
              exporting
                iv_entity_name           = iv_entity_name
                iv_entity_set_name       = iv_entity_set_name
                iv_source_name           = iv_source_name
                it_filter_select_options = it_filter_select_options
                it_order                 = it_order
                is_paging                = is_paging
                it_navigation_path       = it_navigation_path
                it_key_tab               = it_key_tab
                iv_filter_string         = iv_filter_string
                iv_search_string         = iv_search_string
                io_expand                = io_expand
                io_tech_request_context  = io_tech_request_context
              importing
                er_entityset             = er_entityset
                et_expanded_clauses      = et_expanded_clauses
                et_expanded_tech_clauses = et_expanded_tech_clauses
                es_response_context      = es_response_context
                   ).
        endcase.

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_expanded_entityset - busi_exc' ) ##NO_TEXT
       fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_expanded_entityset - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_expanded_entityset' ) ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~get_expanded_entity.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    clear er_entity.
    clear et_expanded_clauses.
    clear et_expanded_tech_clauses.
    clear es_response_context.

    if gv_store_id is initial.
      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( io_tech_request_context->get_source_keys( ) ).
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_set_name iv_subkey_ext2 = 'get_expanded_entity' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_navigation_path it_key_tab.

    data(rv) = io_expand->compare_to_tech_names( |{ if_rtst_receive_product=>gsc_navigation_property-product }| ).  "type conversion

    try.
        case io_tech_request_context->get_entity_type_name( ).
          when cl_rtst_rcv_product_mpc=>gc_document.
            cl_rtst_rp_document=>get_instance( )->get_expanded_entity(
              exporting
                io_tech_request_context      = io_tech_request_context
                io_expand                    = io_expand
              importing
                ers_entity                   = data(ert_document_entity)
              changing
                ct_expanded_tech_clauses     = et_expanded_tech_clauses
                cs_response_context          = es_response_context
            ).

            er_entity = ert_document_entity.

          when others.
            super->/iwbep/if_mgw_appl_srv_runtime~get_expanded_entity(
          exporting
            iv_entity_name               = iv_entity_name
            iv_entity_set_name           = iv_entity_set_name
            iv_source_name               = iv_source_name
            it_key_tab                   = it_key_tab
            it_navigation_path           = it_navigation_path
            io_expand                    = io_expand
            io_tech_request_context      = io_tech_request_context
          importing
            er_entity                    = er_entity
            es_response_context          = es_response_context
            et_expanded_clauses          = et_expanded_clauses
            et_expanded_tech_clauses     = et_expanded_tech_clauses
        ).

        endcase.

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_expanded_entity - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_expanded_entity - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_expanded_entity' ) ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~get_entityset.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    if gv_store_id is initial.
      data(lt_keys) = io_tech_request_context->get_source_keys( ).
      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( lt_keys ).
    endif.

*   first appl log entry
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_name iv_subkey_ext2 = 'get_entityset' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_key_tab it_navigation_path.

    try.
        super->/iwbep/if_mgw_appl_srv_runtime~get_entityset(
          exporting
            iv_entity_name               = iv_entity_name    " Obsolete
            iv_entity_set_name           = iv_entity_set_name    " Obsolete
            iv_source_name               = iv_source_name    " Obsolete
            it_filter_select_options     = it_filter_select_options    " table of select options - Obsolete
            it_order                     = it_order    " the sorting order - Obsolete
            is_paging                    = is_paging    " paging structure - Obsolete
            it_navigation_path           = it_navigation_path    " table of navigation paths - Obsolete
            it_key_tab                   = it_key_tab    " table for name value pairs - Obsolete
            iv_filter_string             = iv_filter_string    " the filter as a string containing ANDs and ORs etc -Obsolete
            iv_search_string             = iv_search_string    " Obsolete
            io_tech_request_context      = io_tech_request_context
          importing
            er_entityset                 = er_entityset
            es_response_context          = es_response_context
        ).

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entityset - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entityset - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entityset' ) ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~get_entity.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    if gv_store_id is initial.
      data(lt_keys) = io_tech_request_context->get_keys( ).
      append lines of io_tech_request_context->get_source_keys( ) to lt_keys.

      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( lt_keys ).
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_name iv_subkey_ext2 = 'get_entity' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_key_tab it_navigation_path.

    try.
        super->/iwbep/if_mgw_appl_srv_runtime~get_entity(
          exporting
            iv_entity_name               = iv_entity_name
            iv_entity_set_name           = iv_entity_set_name
            iv_source_name               = iv_source_name
            it_key_tab                   = it_key_tab
            it_navigation_path           = it_navigation_path
            io_tech_request_context      = io_tech_request_context
          importing
            er_entity                    = er_entity
            es_response_context          = es_response_context
            ).

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entity - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entity - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'get_entity' ) ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~create_entity.

    data ls_post_document type cl_rtst_rcv_product_mpc=>ts_postdocument.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    if io_data_provider is bound.
      io_data_provider->read_entry_data( importing es_data = ls_post_document ).
    endif.

    if gv_store_id is initial.
      gv_store_id = ls_post_document-store_id.
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_name iv_subkey_ext2 = 'create_entity' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_key_tab it_navigation_path ls_post_document.

    try.
        super->/iwbep/if_mgw_appl_srv_runtime~create_entity(
          exporting
            iv_entity_name               = iv_entity_name
            iv_entity_set_name           = iv_entity_set_name
            iv_source_name               = iv_source_name
            io_data_provider             = io_data_provider
            it_key_tab                   = it_key_tab
            it_navigation_path           = it_navigation_path
            io_tech_request_context      = io_tech_request_context
          importing
            er_entity                    = er_entity
        ).

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'create_entity - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'create_entity - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey(  iv_subkey_ext2 = 'create_entity') ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~create_deep_entity.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    if gv_store_id is initial.
      gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( io_tech_request_context->get_source_keys( ) ).
    endif.

*   first log with define subkey
    log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = iv_entity_name iv_subkey_ext2 = 'create_deep_entity' ) ##NO_TEXT
      fields
        iv_entity_name iv_entity_set_name iv_source_name it_key_tab it_navigation_path.

    if iv_entity_name = cl_rtst_rcv_product_mpc=>gc_postdocument.

      try.

          cl_rtst_rp_post_document=>get_instance( )->create_deep_entity(
            exporting
              io_data_provider             = io_data_provider
              io_expand                    = io_expand
              io_tech_request_context      = io_tech_request_context
            importing
              er_deep_entity               = er_deep_entity
          ).

*     Catch the exception to write an committed(!) application log
        catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
          go_application_log->add_message_from_exception( lo_busi_exc ).
        catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
          go_application_log->add_message_from_exception( lo_tech_exc ).

      endtry.
    else.
      raise exception type /iwbep/cx_mgw_tech_exception
        exporting
          textid = /iwbep/cx_mgw_tech_exception=>method_not_implemented
          method = 'create_deep_entity'.

    endif.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'create_deep_entity - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'create_deep_entity - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey(  iv_subkey_ext2 = 'create_deep_entity') ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~changeset_process.

    data lo_action_context    type ref to /iwbep/if_mgw_req_func_import.
    data lo_entity_context    type ref to /iwbep/if_mgw_req_entity_c.
    data lv_entity_type       type /iwbep/mgw_tech_name.

    break-point id rtst_debug.

    go_application_log = cl_rtst_application_log=>get_instance( /iwbep/if_mgw_conv_srv_runtime~get_message_container( ) ).

    try.

*   Detect the Entity Type
        loop at it_changeset_request reference into data(lrs_changeset_request).
          case lrs_changeset_request->operation_type.
            when /iwbep/if_mgw_appl_types=>gcs_operation_type-execute_action.
              lo_action_context ?= lrs_changeset_request->request_context.

              if gv_store_id is initial.
*            gv_store_id = cl_rtst_utils=>get_instance( )->get_store_id( lo_action_context->get_converted_parameters( importing ) ).
              endif.

              if lv_entity_type is initial.
                lv_entity_type     = lo_action_context->get_function_return_type( ).
*           first log with define subkey
                log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = |{ lv_entity_type }| iv_subkey_ext2 = 'changeset_process' ) ##NO_TEXT
                  fields
                    lv_entity_type lrs_changeset_request->operation_type.
              endif.

              if lv_entity_type = cl_rtst_rcv_product_mpc=>gc_filtervalue.
*           changeset_begin ensures that within the changeset only FilterValue related requests will occur
                cl_rtst_rp_filter_value=>get_instance( )->changeset_process(
                  exporting
                    it_changeset_request  = it_changeset_request
                  changing
                    ct_changeset_response = ct_changeset_response
                  ).
                exit.
              else.
                raise exception type /iwbep/cx_mgw_tech_exception
                  exporting
                    textid = /iwbep/cx_mgw_tech_exception=>method_not_implemented
                    method = 'changeset_process'.
              endif.

            when /iwbep/if_mgw_appl_types=>gcs_operation_type-create_entity.
              lo_entity_context ?= lrs_changeset_request->request_context.

              if lv_entity_type is initial.
                lv_entity_type     = lo_entity_context->get_entity_type_name( ).
*           first log with define subkey
                log-point id rtst_debug subkey go_application_log->get_log_subkey( iv_store_id = gv_store_id iv_subkey_ext1 = |{ lv_entity_type }| iv_subkey_ext2 = 'changeset_process' ) ##NO_TEXT
                  fields
                    lv_entity_type lrs_changeset_request->operation_type.
              endif.

              if lv_entity_type = cl_rtst_rcv_product_mpc=>gc_postdocumentitem.
*           changeset_begin ensures that within the changeset only PostDocumentItem related requests will occur
                cl_rtst_rp_post_document_item=>get_instance( )->changeset_process(
                  exporting
                    it_changeset_request  = it_changeset_request
                  changing
                    ct_changeset_response = ct_changeset_response
                  ).
                exit.
              endif.

            when others.
              raise exception type /iwbep/cx_mgw_tech_exception
                exporting
                  textid = /iwbep/cx_mgw_tech_exception=>method_not_implemented
                  method = 'changeset_process'.
          endcase.
        endloop.

*     Catch the exception to write an committed(!) application log
      catch /iwbep/cx_mgw_busi_exception into data(lo_busi_exc).
        go_application_log->add_message_from_exception( lo_busi_exc ).
      catch /iwbep/cx_mgw_tech_exception into data(lo_tech_exc).
        go_application_log->add_message_from_exception( lo_tech_exc ).

    endtry.

*   save messages to application log
    go_application_log->save_msg_to_bal(
      iv_subobject = if_rtst_receive_product=>gc_appl_log_subobject
      iv_store_id  = gv_store_id
      ).

    if lo_busi_exc is bound or lo_tech_exc is bound.
*     persist status and application log (framework does ROLLBACK WORK because of raising an exception (see below)
      commit work.
    endif.

    if lo_busi_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'changeset_process - busi_exc' ) ##NO_TEXT
        fields lo_busi_exc->get_text( ) lo_busi_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_busi_exc.
    elseif lo_tech_exc is bound.
      log-point id rtst_error subkey go_application_log->get_log_subkey( iv_subkey_ext2 = 'changeset_process - tech_exc' ) ##NO_TEXT
        fields lo_tech_exc->get_text( ) lo_tech_exc->get_longtext( ).

      break-point id rtst_error.
      raise exception lo_tech_exc.
    endif.

    log-point id rtst_debug subkey go_application_log->get_log_subkey(  iv_subkey_ext2 = 'changeset_process') ##NO_TEXT.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~changeset_end.

    gv_chgset_processing_is_active = abap_false.
    call method super->/iwbep/if_mgw_appl_srv_runtime~changeset_end.

  endmethod.


  method /iwbep/if_mgw_appl_srv_runtime~changeset_begin.

    data lv_changeset_entity_type type /iwbep/s_mgw_operation_info-entity_type.

    set update task local.

    cv_defer_mode = abap_false.

*   Detect the Changeset and allow exactly one entity type
    loop at it_operation_info reference into data(lrs_operation_info).
      case lrs_operation_info->entity_type.
        when cl_rtst_rcv_product_mpc=>gc_filtervalue.
*****************************************************
          if lv_changeset_entity_type is initial.
*           The first "will rule them all" :-)
            lv_changeset_entity_type = lrs_operation_info->entity_type.
          elseif lv_changeset_entity_type <> lrs_operation_info->entity_type.
            raise exception type /iwbep/cx_mgw_tech_exception  "TODO
              exporting
                textid = /iwbep/cx_mgw_tech_exception=>changeset_default_violation
                method = 'changeset_begin'.
          endif.
          gv_chgset_processing_is_active = abap_true.  "only for defer_mode = false
          cv_defer_mode = abap_true.

*       when cl_rtst_rcv_product_mpc=>postdocument.
*         not really necessary as a changeset contains only one document because they shall be posted in different LUWs

        when cl_rtst_rcv_product_mpc=>gc_postdocumentitem.
*         also here a independent posting might make sense from business aspects
*         but this might not perform well...
          if lv_changeset_entity_type is initial.
*           The first "will rule them all" :-)
            lv_changeset_entity_type = lrs_operation_info->entity_type.
          elseif lv_changeset_entity_type <> lrs_operation_info->entity_type.
            raise exception type /iwbep/cx_mgw_tech_exception  "TODO
              exporting
                textid = /iwbep/cx_mgw_tech_exception=>changeset_default_violation
                method = 'changeset_begin'.
          endif.
          gv_chgset_processing_is_active = abap_true.  "only for defer_mode = false
          cv_defer_mode = abap_true.

        when others.
*****************************************************
*         Check whether others fit to first entity types
          if lv_changeset_entity_type is not initial.
            raise exception type /iwbep/cx_mgw_tech_exception "TODO: keep or not?
              exporting
                textid = /iwbep/cx_mgw_tech_exception=>method_not_implemented
                method = 'changeset_process'.
          endif.
      endcase.
    endloop.

  endmethod.
ENDCLASS.