*&---------------------------------------------------------------------*
*&  Include           LEEWA_MD_ROCI4
*&---------------------------------------------------------------------*
class LCL_OBJCOLLECTOR implementation.

*  method CONSTRUCTOR.
*   " may set self to FINSTANCE if initial,
*   " -> but no need to, for CL_GET_INSTANCE handles first Instance that was CL_GETted
*    if FINSTANCE is initial. " on first CONSTRUCTOR( )-call
*      FINSTANCE = ME.
*    endif.
*  endmethod.

  method CL_GET_INSTANCE.

*    create new Instance and keep FINSTANCE
*    -> ME+->CONSTRUCTOR( ).

    if PAR_NEW eq ABAP_TRUE.
*    create new Instance and reset FINSTANCE
      FINSTANCE = new LCL_OBJCOLLECTOR( ).
      PAR_REFERENCE ?= FINSTANCE.
    else.
*    get "default" Instance as Singleton
      if FINSTANCE is initial.
        FINSTANCE = new LCL_OBJCOLLECTOR( ).
      endif.
      PAR_REFERENCE ?= FINSTANCE.
    endif.

  endmethod.

*  method COLLECT_OBJECT.
*    ... for multi-position-purpose
*
*  endmethod.

  method SAVE_OBJECT_SV.
**** cares about: OBJ-
*     EWATAB
*     EWAOBJ
*     EWAOBJH
*     IROBJ_TAB
*     IROBJ_TSL
* not! MDATA-IPROPSD

    data:
      LFKEY type ref to TFKEY,
      LOBJNR type EOBJNR.

*    check PAR_OBJ is not initial. "use CLEAR_OBJECT( ).

    if PAR_ISCHANGED eq ABAP_UNDEFINED.
*      if PAR_OBJ = FOBJ.
*        PAR_ISCHANGED = ABAP_FALSE.
*      endif.
      PAR_ISCHANGED = FOBJ_CHANGED.
    endif.

    if PAR_ISCHANGED eq ABAP_TRUE.
**** IROBJ_TAB #->SAVE_IROBJTAB( ).
      data:
        LIROBJ_TAB_LINEREF type ref to ISU_ROBJ_TABC,
        LF_IROBJ_TAB_LINEREF type ref to ISU_ROBJ_TABC.
      data:
        LEWATAB_LINEREF type ref to ISUWA_OBJ_LINES,
        LF_EWATAB_LINEREF type ref to ISUWA_OBJ_LINES.

      if PAR_OBJ-IROBJ_TAB <> FOBJ-IROBJ_TAB.
**** work around to fix IROBJ_TAB
*        if IROBJ_TAB is created and is not changed.
*        PAR_OBJ-IROBJ_TAB = FTMP_IROBJ_TAB.
*        endif. -> but i think that wont work =>
        assign PAR_OBJ-EWATAB to field-symbol(<LEWATAB>).
        assign FOBJ-EWATAB to field-symbol(<LFEWATAB>).
        FTMP_IROBJ_TAB = PAR_OBJ-IROBJ_TAB.

        data LIROBJ_TAB_LINE type ISU_ROBJ_TABC.
        loop at FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF where OBJNR ca '$'.
          read table <LFEWATAB> reference into LF_EWATAB_LINEREF
            with key EWAOBJ-ROB     = LIROBJ_TAB_LINEREF->ROB
                     EWAOBJ-EQUNR   = LIROBJ_TAB_LINEREF->EQUNR
                     EWAOBJ-SERVLOC = LIROBJ_TAB_LINEREF->TPLNR
*                   ? EWAOBJ-SERVLOC = LIROBJ_TAB_LINEREF->SERVLOC
                     EWAOBJ-MATNR   = LIROBJ_TAB_LINEREF->MATNR.
          if SY-SUBRC is initial.
            delete FTMPRECORDS where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
            LIROBJ_TAB_LINE = LIROBJ_TAB_LINEREF->*.
            LIROBJ_TAB_LINE-OBJNR = LF_EWATAB_LINEREF->EWAOBJ-OBJNR.
            delete FTMP_IROBJ_TAB. "where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
            insert LIROBJ_TAB_LINE into table FTMP_IROBJ_TAB.
          endif.
        endloop.
**** end of workaround

*       " delete
** -> IROBJ_TAB is only on DB-Save deleted/adapted (see EWATAB -> EWAOBJs <-> EWAOBJHs)
*         loop at FFKEYS reference into LFKEY
*           where VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
*             and POSNR = PAR_OBJ-EWAOBJD-POSNR.
*           LOBJNR = LFKEY->OBJNR.
*           loop at FOBJ-IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF where OBJNR = LOBJNR.
*             read table FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF
*               with key OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR. "-OBKNR -OBZAE
*             if SY-SUBRC is not initial. "record has been deleted
*               delete FOBJ-IROBJ_TAB.
*             endif.
*           endloop.
*        endloop.
*       " update & insert ? modify FOBJ-IROBJ_TAB from FTMP_IROBJ_TAB.
        loop at FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF.
          read table FOBJ-IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF
            with key OBJNR = LIROBJ_TAB_LINEREF->OBJNR. "-OBKNR -OBZAE
          if SY-SUBRC is initial.
            if LF_IROBJ_TAB_LINEREF->* <> LIROBJ_TAB_LINEREF->*.
              LF_IROBJ_TAB_LINEREF->* = LIROBJ_TAB_LINEREF->*.
            endif.
          else.
            insert LIROBJ_TAB_LINEREF->* into table FOBJ-IROBJ_TAB. "insert
          endif.
          if LIROBJ_TAB_LINEREF->OBKNR is initial
            and LIROBJ_TAB_LINEREF->OBZAE is initial
            and LIROBJ_TAB_LINEREF->SDVERTRAG is initial
            and LIROBJ_TAB_LINEREF->POSNR is initial.
*          special case 1.) (new ServFreqHead on CONTAINER or PROP)
*         ! assuming we run PAR_OBJ with only ONE(1) POSNR we could simply use PAR_OBJ-EWAOBJD-SDVERTRAG -POSNR
*         -> if not we screw up hard => TODO: Match the OBJNR to the right -VBELN-POSNR and not the actual one
*            -> read table <LEWATAB> ... with key
*            loop at PAR_OBJ-EWATAB reference into data(L_EWATAB_LINEREF).
*              if L_EWATAB_LINEREF->EWAOBJ-OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
                FOBJCOLLECTOR->UPDATE_FKEYS(
                  exporting
                    PAR_OBJNR = LIROBJ_TAB_LINEREF->OBJNR
                    PAR_VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
                    PAR_POSNR = PAR_OBJ-EWAOBJD-POSNR
*                    PAR_OBKNR = "initial ##very needed!
                    PAR_OBZAE = LIROBJ_TAB_LINEREF->OBZAE "initial ##very needed!
                ).
              " else. continue.
*              endif.
*            endloop.
*          elseif ... . " special cases
          else. " normal way
            UPDATE_FKEYS(
              exporting
                PAR_OBJNR = LIROBJ_TAB_LINEREF->OBJNR
                PAR_VBELN = LIROBJ_TAB_LINEREF->SDVERTRAG
                PAR_POSNR = LIROBJ_TAB_LINEREF->POSNR
                PAR_OBKNR = LIROBJ_TAB_LINEREF->OBKNR
                PAR_OBZAE = LIROBJ_TAB_LINEREF->OBZAE
            ).
          endif.
        endloop.
      endif.

**** EWATAB #->SAVE_EWATAB( ).
*      data:
*        LEWATAB_LINEREF type ref to ISUWA_OBJ_LINES,
*        LF_EWATAB_LINEREF type ref to ISUWA_OBJ_LINES.

      if PAR_OBJ-EWATAB <> FOBJ-EWATAB.
*      EWAOBJ #->SAVE_EWAOBJ( ).
*       " delete
**      -> EWAOBJ is deleted when EWAOBJHs are 0 --> see SAVE
*        assign PAR_OBJ-EWATAB to field-symbol(<LEWATAB>).
*        assign FOBJ-EWATAB to field-symbol(<LFEWATAB>).
        assign PAR_OBJ-EWATAB to <LEWATAB>.
        assign FOBJ-EWATAB to <LFEWATAB>.
        "! see above !it is assumed only ONE(1) -VBELN-POSNR is handled
        " -> else ? TODO
        loop at FFKEYS reference into LFKEY
          where VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
            and POSNR = PAR_OBJ-EWAOBJD-POSNR.
          LOBJNR = LFKEY->OBJNR.
          loop at <LFEWATAB> reference into LF_EWATAB_LINEREF where EWAOBJ-OBJNR = LOBJNR.
            read table <LEWATAB> reference into LEWATAB_LINEREF
              with key EWAOBJ-OBJNR = LF_EWATAB_LINEREF->EWAOBJ-OBJNR.
            if SY-SUBRC is not initial. "record has been deleted
              clear LF_EWATAB_LINEREF->EWAOBJH. " mark as to be deleted
*              -> only mark but don't delete, for it will not be updated in "real" SAVE if deletet now
*                (-> for it cant be referenced no more)
            endif.
          endloop.
        endloop.
*       " insert & update
        loop at PAR_OBJ-EWATAB reference into LEWATAB_LINEREF.
          read table FOBJ-EWATAB reference into LF_EWATAB_LINEREF
            with key EWAOBJ-OBJNR = LEWATAB_LINEREF->EWAOBJ-OBJNR.
          if SY-SUBRC is initial. " update existing EWATAB-Entry
*          EWAOBJ #->SAVE_EWAOBJ( ).
            if LF_EWATAB_LINEREF->EWAOBJ <> LEWATAB_LINEREF->EWAOBJ.
              LF_EWATAB_LINEREF->EWAOBJ = LEWATAB_LINEREF->EWAOBJ.
            endif.
*          EWAOBJH #->SAVE_EWAOBJH( ).
            if LF_EWATAB_LINEREF->EWAOBJH <> LEWATAB_LINEREF->EWAOBJH.
              LF_EWATAB_LINEREF->EWAOBJH = LEWATAB_LINEREF->EWAOBJH.
            endif.
*          EWAOBJH_ATT #->SAVE_EWAOBJH_ATT( ). ? check AAT can be changed from EEWA_MD_RO
            if LF_EWATAB_LINEREF->EWAOBJH_AAT <> LEWATAB_LINEREF->EWAOBJH_AAT.
              LF_EWATAB_LINEREF->EWAOBJH_AAT = LEWATAB_LINEREF->EWAOBJH_AAT.
            endif.
*          UPDCLASS #->SAVE_UPDCLASS( ).
            if LF_EWATAB_LINEREF->UPDCLASS <> LEWATAB_LINEREF->UPDCLASS.
              LF_EWATAB_LINEREF->UPDCLASS = LEWATAB_LINEREF->UPDCLASS.
            endif.
          else. " insert new EWATAB-Entry
            " insert new EWAOBJ (ServFreqHead) or when beeing called for the first time
            insert LEWATAB_LINEREF->* into table FOBJ-EWATAB.
          endif.
        endloop.
*        needs the updated FKEYS
        SAVE_DB_EWATAB( PAR_EWATAB = PAR_OBJ-EWATAB ).
      endif.

**** IROBJ_TSL #->SAVE_IROBJTSL( ).
** IROBJ_TSL is relevant from screen, not from VA42
*! --> still save and load the TSLs -> they are still there, even when "marked" as deleted and no more shown
      data:
        LIROBJ_TSL_LINEREF type ref to ISU_ROBJ_TSL,
        LF_IROBJ_TSL_LINEREF type ref to ISU_ROBJ_TSL.

      if PAR_OBJ-IROBJ_TSL <> FOBJ-IROBJ_TSL.
*       " delete
        loop at FFKEYS reference into LFKEY
          where VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
            and POSNR = PAR_OBJ-EWAOBJD-POSNR.
          LOBJNR = LFKEY->OBJNR.
          loop at FOBJ-IROBJ_TSL reference into LF_IROBJ_TSL_LINEREF where OBJNR = LOBJNR.
            read table PAR_OBJ-IROBJ_TSL reference into LIROBJ_TSL_LINEREF
              with key
                OBJNR = LF_IROBJ_TSL_LINEREF->OBJNR
                LAUFNR = LF_IROBJ_TSL_LINEREF->LAUFNR
                AB = LF_IROBJ_TSL_LINEREF->AB
                BIS = LF_IROBJ_TSL_LINEREF->BIS.
            if SY-SUBRC is not initial. "record has been deleted
              delete FOBJ-IROBJ_TSL.
            endif.
          endloop.
        endloop.
*       " update & insert ? modify FOBJ-IROBJ_TSL from PAR_OBJ-IROBJ_TSL.
        loop at PAR_OBJ-IROBJ_TSL reference into LIROBJ_TSL_LINEREF.
          read table FOBJ-IROBJ_TSL reference into LF_IROBJ_TSL_LINEREF
            with key
              OBJNR = LIROBJ_TSL_LINEREF->OBJNR
              LAUFNR = LIROBJ_TSL_LINEREF->LAUFNR
              AB = LIROBJ_TSL_LINEREF->AB
              BIS = LIROBJ_TSL_LINEREF->BIS.
          if SY-SUBRC is initial.
            if LF_IROBJ_TSL_LINEREF->* <> LIROBJ_TSL_LINEREF->*.
              LF_IROBJ_TSL_LINEREF->* = LIROBJ_TSL_LINEREF->*.
            endif.
          else.
            insert LIROBJ_TSL_LINEREF->* into table FOBJ-IROBJ_TSL.
          endif.
        endloop.
      endif.
** not excluded -> IROBJ_TSL is relevant when SAVING from Screen -> adapt create and prorate EWAOBJH from IROBJ_TSL

**** ->#eval the TMPRECORDS( )
* -> "new" records were temporary and now have an OBJNR
* -> deleted records (cleared EWAOBJH) were marked as cleared and reinstalled a new tmp OBJNR
* => both cases have to be cleaned up, but tmp records that didn't get a new record remain tmp.

* extract OBJNRs for this -VBELN-POSNR
  data:
    LOBJNRS type standard table of EOBJNR,
    LDELETE_MARK type CHAR1.

*  loop at FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF.
  " -> TODO: ? how to match keys at multipos ? -> hand T_XVBAP ...
  " --> on Multicontracts -> loop all OBJs
    assign FOBJ-EWATAB to <LFEWATAB>.
    assign PAR_OBJ-EWATAB to <LEWATAB>.

    data:
      LFKEYS_DEL type TFKEYS,
      LFKEYS_INS type TFKEYS,
      LFKEY_TMP type ref to TFKEY,
      LFKEYS_OBJNRS type standard table of EOBJNR,
      LIROBJ_OBJNRS type standard table of EOBJNR.

*  handle first open --> ofcourse ALL first-opened tmp OBJNRs are NEW
    loop at FFKEYS reference into LFKEY
      where OBJNR ca '$' and VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG and POSNR = PAR_OBJ-EWAOBJD-POSNR.
      insert LFKEY->OBJNR into table LFKEYS_OBJNRS.
    endloop.
    loop at FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF where OBJNR ca '$'.
*     since special case 1.) PROPs and CONTs dont have neither any -VBELN-POSNR nor -OBKNR-OBZAE
*     -> we' considered to have opened only 1 VBELN and POSNR
      "=> all OBJNRs belong to this EWAOBJD -VBELN-POSNR elsewise loop on FFKEYS with -VBELN-POSNR
      insert LIROBJ_TAB_LINEREF->OBJNR into table LIROBJ_OBJNRS.
    endloop.
    if LFKEYS_OBJNRS <> LIROBJ_OBJNRS.
*    else."=> nothing changed -> or just opened or accidentally same
      "-> Mind the accidents: tmp records hold no persisiting data
      " -> when SAVING before SAVE and then copy the data keep in mind to transfer the changed data in the tmp record

    loop at FFKEYS reference into LFKEY
      where OBJNR ca '$' and VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG and POSNR = PAR_OBJ-EWAOBJD-POSNR.
    " what if different POSNRs have the same tmp OBJNRs $# ?
      read table FOBJ-IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF with key OBJNR = LFKEY->OBJNR.
        "<- -OBKNR-OBZAE IROBJ_TAB-VBELN and IROBJ_TAB-POSNR is only for MATNR not initial. (s.b.)
*        read table C_OBJ-IROBJ_TAB reference into data(LIROBJ_LINE_REF) with key
**         identifies SD-Position
*           OBKNR = WEWATAB-EWAOBJ-OBKNR OBZAE = WEWATAB-EWAOBJ-OBZAE "MATNR = WEWATAB-EWAOBJ-MATNR
**         identifies operand from WDFacility facts
*           OPERAND = WEWATAB-EWAOBJ-OPERAND OPLFDNR = WEWATAB-EWAOBJ-OPLFDNR
**         identifies Container(s)
*           LOGIKNR = WEWATAB-EWAOBJ-LOGIKNR EQUNR = WEWATAB-EWAOBJ-EQUNR SERVLOC = WEWATAB-EWAOBJ-SERVLOC
*           DEVGRP = WEWATAB-EWAOBJ-DEVGRP IBASE = WEWATAB-EWAOBJ-IBASE BEH_TYPE = WEWATAB-EWAOBJ-BEH_TYPE
**         identifies PROPS
*           ROB = WEWATAB-EWAOBJ-ROB.
      if SY-SUBRC is initial.
        if LF_IROBJ_TAB_LINEREF->CLEAN_PROP is not initial
          and LF_IROBJ_TAB_LINEREF->UROB is not initial.
** PROPs
          read table FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF
            with key CLEAN_PROP = LF_IROBJ_TAB_LINEREF->CLEAN_PROP UROB = LF_IROBJ_TAB_LINEREF->UROB.
        elseif LF_IROBJ_TAB_LINEREF->EQUNR is not initial
          and LF_IROBJ_TAB_LINEREF->TPLNR is not initial.
          " maybe even LF_IROBJ_TAB_LINEREF->LOGIKNR is not initial. "<- real assignment, else tmp assignment LOGIKNR is initial.
** CONTAINER
          read table FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF
            with key EQUNR = LF_IROBJ_TAB_LINEREF->EQUNR TPLNR = LF_IROBJ_TAB_LINEREF->TPLNR.
          " LOGIKNR = LF_IROBJ_TAB_LINEREF->LOGIKNR. "<- same EQUNR can not be at the same TPLNR
        elseif LF_IROBJ_TAB_LINEREF->MATNR is not initial.
** SD-Servicemat "since this critetria is somewhat week take it last
          read table FTMP_IROBJ_TAB reference into LIROBJ_TAB_LINEREF
            with key MATNR = LF_IROBJ_TAB_LINEREF->MATNR.
*        else. " I really dont know, YET. -> Maybe Error, maybe a new "feature".
        endif.
        if SY-SUBRC is initial.
          if LIROBJ_TAB_LINEREF->OBJNR ca '$'. " still a tmp record
            read table FTMPRECORDS transporting no fields
              with key
                OBJNR = LIROBJ_TAB_LINEREF->OBJNR
                VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
                POSNR = PAR_OBJ-EWAOBJD-POSNR.
            if SY-SUBRC is not initial. "this is a new tmp record
*            handle first open! ofcourse these are ALL new records here
              delete FOBJ-IROBJ_TAB where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
              delete FFKEYS where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
*            else.  "we hit an old tmp record
*              "already inserted to FFKEYS and IROBJ_TAB.
            endif.
*              read table FFKEYS reference into LFKEY_TMP
*                with key
*                  OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR
*                  VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
*                  POSNR = PAR_OBJ-EWAOBJD-POSNR.
*              if SY-SUBRC is initial.
*                insert LFKEY_TMP->* into table LFKEYS_DEL.
*              endif.
*              LFKEY_TMP->OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
*              " dont insert -> it is already inserted
*              insert LFKEY_TMP->* into table LFKEYS_INS.
*              delete FOBJ-IROBJ_TAB where OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR.
**              LF_IROBJ_TAB_LINEREF->OBJNR = LIROBJ_TAB_LINEREF->OBJNR. "set new OBJNR
**            ? even: modify LF_IROBJ_TAB_LINEREF->* from LIROBJ_TAB_LINEREF->*. "?
          else. " became a real record
*           "already inserted to FFKEYS and IROBJ_TAB. -> just delete the old records
*            -> delete the corresponding tmp record
            if LIROBJ_TAB_LINEREF->OBJNR ca '$'. " we handle the tmp entry
              delete FFKEYS where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
              delete FOBJ-IROBJ_TAB where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
            else. " we handle the real entry
*              if LF_IROBJ_TAB_LINEREF->OBJNR ca '$'.
              delete FFKEYS where OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR.
              delete FOBJ-IROBJ_TAB where OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR.
*              endif.
            endif.

*            read table FFKEYS reference into LFKEY_TMP
*              with key
*                OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR
*                VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG
*                POSNR = PAR_OBJ-EWAOBJD-POSNR.
*            if SY-SUBRC is initial.
*              insert LFKEY_TMP->* into table LFKEYS_DEL.
*            endif.
*            delete FOBJ-IROBJ_TAB where OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR.
          endif.
        endif.
       endif.
     endloop.
     CLEAR_TMPRECORDS( ).
     endif.
**** begin of work around
**** before EVAL we have to fix the screwed up IROBJ_TAB
* see CL_EEWA_RFC_SERVICE_FREQUENCY=>SAVE( ... ).
* the bugger gets confused when deleting an existing record and putting a new one (and appearance on the IROBJ_TAB is different then on the EWATAB)
* -> see to fix and delete at CL_EEWA_RFC_SERVICE_FREQUENCY=>SAVE( ... ).
* We assume EWATAB is all the truth there is, for somehow there was never an Issue/ERROR-Reported on ERONEW
**** WORK AROUND !
* here we go: starting to read the FFKEYS to be considered:
  data:
*    LOBJNRS type standard table of EOBJNR,
*    LIROBJ_TAB_LINE type ISU_ROBJ_TABC,
    LIMISSMYIROBJLINE_REFS type standard table of ref to ISU_ROBJ_TABC,
    LIGOTTOMANYIROBJLINE_REFS type standard table of ref to ISU_ROBJ_TABC,
    LIROBJ_LINEREF type ref to ISU_ROBJ_TABC.

  loop at FFKEYS reference into LFKEY where VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG and POSNR = PAR_OBJ-EWAOBJD-POSNR.
    insert LFKEY->OBJNR into table LOBJNRS.
*  we check if these FKEYS have an ENTRY on EWATAB (there can only be ONE Entry per KEY)
    read table <LFEWATAB> reference into LF_EWATAB_LINEREF with key EWAOBJ-OBJNR = LFKEY->OBJNR.
    " if we have more than one EWATAB-Entry with different OBJNRs for ONE 'Service-Object' we are realy porked!
    if SY-SUBRC is initial.
*    if so, there can definitly be no tmp Record on IROBJ_TAB
*     -> except EWATAB holds a tmp record with data (which should not be after SAVE)
      if LFKEY->OBJNR ca '$'. "never the less we check it
        " we pick up the data to our own and than delete, except our own
*        hopefully no one cares about the "real" $# tmp-record

      else. " we simply delete all '$'
        read table FOBJ-IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF
          with key
            OBJNR = LFKEY->OBJNR
*            UROB  = LF_EWATAB_LINEREF->EWAOBJ-???
*            PROP  = LF_EWATAB_LINEREF->EWAOBJ-???
            ROB   = LF_EWATAB_LINEREF->EWAOBJ-ROB
            EQUNR = LF_EWATAB_LINEREF->EWAOBJ-EQUNR
            TPLNR = LF_EWATAB_LINEREF->EWAOBJ-SERVLOC
            MATNR = LF_EWATAB_LINEREF->EWAOBJ-MATNR.
        if SY-SUBRC is initial.
          " this should rather be -> the ONE AND ONLY real record
*          so look if we have Records to spare:
          loop at FOBJ-IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF
            where "don't care what is when initial -> they just have to match
                  OBJNR      <> LFKEY->OBJNR
*              CLEAN_PROP     = LF_EWATAB_LINEREF->EWAOBJ-???
*              and PROP       = LF_EWATAB_LINEREF->EWAOBJ-???
*              and UROB       = LF_EWATAB_LINEREF->EWAOBJ-???
              and ROB        = LF_EWATAB_LINEREF->EWAOBJ-ROB
              and EQUNR      = LF_EWATAB_LINEREF->EWAOBJ-EQUNR
              and TPLNR      = LF_EWATAB_LINEREF->EWAOBJ-SERVLOC
              and MATNR      = LF_EWATAB_LINEREF->EWAOBJ-MATNR.
*              ADRNR = in someway this can be considered
*           YES: we occupie any other entry on IROBJ_TAB
*            maybe someone allready looks for it:
            read table LIMISSMYIROBJLINE_REFS into LIROBJ_LINEREF
              with key TABLE_LINE->OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR.
            if SY-SUBRC is initial. " YES so hand it over
              LF_IROBJ_TAB_LINEREF->ROB = LIROBJ_LINEREF->ROB.
              LF_IROBJ_TAB_LINEREF->EQUNR = LIROBJ_LINEREF->EQUNR.
              LF_IROBJ_TAB_LINEREF->TPLNR = LIROBJ_LINEREF->TPLNR.
              LF_IROBJ_TAB_LINEREF->MATNR = LIROBJ_LINEREF->MATNR.
              delete LIMISSMYIROBJLINE_REFS. "and release the seeker
            else. " NO so put it to the Spare-List
              insert LF_IROBJ_TAB_LINEREF into table LIGOTTOMANYIROBJLINE_REFS.
            endif.
          endloop.
        else.
          " this was recorded on EWATAB but got lost of its IROBJ_TAB-Entry
*          (maybe it's occupied by someone else?)
*          -> Looking for it:
          read table LIGOTTOMANYIROBJLINE_REFS into LIROBJ_LINEREF
            with key TABLE_LINE->OBJNR = LFKEY->OBJNR.
          if SY-SUBRC is initial. "found it -> take it back (instore own key)
            LIROBJ_LINEREF->ROB = LF_EWATAB_LINEREF->EWAOBJ-ROB.
            LIROBJ_LINEREF->EQUNR = LF_EWATAB_LINEREF->EWAOBJ-EQUNR.
            LIROBJ_LINEREF->TPLNR = LF_EWATAB_LINEREF->EWAOBJ-SERVLOC.
            LIROBJ_LINEREF->MATNR = LF_EWATAB_LINEREF->EWAOBJ-MATNR. "take it back
            delete LIGOTTOMANYIROBJLINE_REFS. "keep it to yourself
*            exit. "finish VVV (Vini Vidi Vici)
          else.
            insert LF_IROBJ_TAB_LINEREF into table LIMISSMYIROBJLINE_REFS.
          endif.
        endif.
      endif.
    else.
*    if not, we check again for tmp record status
      if LFKEY->OBJNR ca '$'.
        "if so we might have a record
        read table FOBJ-IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF
          with key OBJNR = LFKEY->OBJNR.
        "assert SY-SUBRC is initial.!
        if SY-SUBRC is initial.
        "checking the spare records first
          read table LIGOTTOMANYIROBJLINE_REFS into LIROBJ_LINEREF
            with key TABLE_LINE->ROB   = LF_IROBJ_TAB_LINEREF->ROB
                     TABLE_LINE->EQUNR = LF_IROBJ_TAB_LINEREF->EQUNR
                     TABLE_LINE->TPLNR = LF_IROBJ_TAB_LINEREF->TPLNR
                     TABLE_LINE->MATNR = LF_IROBJ_TAB_LINEREF->MATNR.
          if SY-SUBRC is initial.
          " seize it
            read table FOBJ-IROBJ_TAB reference into data(LTMP_IROBJ_TAB_LINEREF)
              with key OBJNR = LIROBJ_LINEREF->OBJNR.
            if SY-SUBRC is initial.
              LOBJNR = LIROBJ_LINEREF->OBJNR.
              move-corresponding LIROBJ_LINEREF->* to LTMP_IROBJ_TAB_LINEREF->*.
              LTMP_IROBJ_TAB_LINEREF->OBJNR = LOBJNR.
              delete LIGOTTOMANYIROBJLINE_REFS where TABLE_LINE->OBJNR = LOBJNR.
              delete FFKEYS ."where LF_IROBJ_TAB_LINEREF->OBJNR.
              delete FOBJ-IROBJ_TAB where OBJNR = LF_IROBJ_TAB_LINEREF->OBJNR.
            endif.
          else.
          " go searching
            read table <LFEWATAB> reference into LF_EWATAB_LINEREF
              with key EWAOBJ-ROB     = LF_IROBJ_TAB_LINEREF->ROB
                       EWAOBJ-EQUNR   = LF_IROBJ_TAB_LINEREF->EQUNR
                       EWAOBJ-SERVLOC = LF_IROBJ_TAB_LINEREF->TPLNR
*                     ? EWAOBJ-SERVLOC = LTMP_IROBJ_TAB_LINEREF->SERVLOC
                       EWAOBJ-MATNR   = LF_IROBJ_TAB_LINEREF->MATNR.
            if SY-SUBRC is initial.
              read table FOBJ-IROBJ_TAB reference into LTMP_IROBJ_TAB_LINEREF
                with key OBJNR = LF_EWATAB_LINEREF->EWAOBJ-OBJNR.
              if SY-SUBRC is initial.
                " could be wrong if IROBJ_TAB holds additional data
                " -> but i think IROBJ_TAB is loaded/constructed and never saved back
                move-corresponding LF_IROBJ_TAB_LINEREF->* to LTMP_IROBJ_TAB_LINEREF->*.
                LTMP_IROBJ_TAB_LINEREF->OBJNR = LF_EWATAB_LINEREF->EWAOBJ-OBJNR.
                delete FOBJ-IROBJ_TAB where OBJNR = LFKEY->OBJNR.
                delete FFKEYS. "where LFKEY->OBJNR. "(self)
              else.
                " found an entry on EWATAB but not on IROBJ_TAB
                read table FOBJ-IROBJ_TAB reference into LTMP_IROBJ_TAB_LINEREF
                  with key ROB = LF_EWATAB_LINEREF->EWAOBJ-ROB
                           EQUNR = LF_EWATAB_LINEREF->EWAOBJ-EQUNR
                           TPLNR = LF_EWATAB_LINEREF->EWAOBJ-SERVLOC
                           MATNR = LF_EWATAB_LINEREF->EWAOBJ-MATNR.
                if SY-SUBRC is initial.
                  " still marked as Dummy but actually does have an EWATAB-Record
                  LFKEY->OBJNR = LF_EWATAB_LINEREF->EWAOBJ-OBJNR.
                  LTMP_IROBJ_TAB_LINEREF->OBJNR = LF_EWATAB_LINEREF->EWAOBJ-OBJNR.
                endif.
              endif.
            endif.
          endif.
        endif.
      else.
        " if it is no tmp Record and EWATAB is empty it is all GG again
      endif.
    endif.
  endloop.
****  !!! PROBLEM !!!
* the final toss up is to fix from the tmp reordcs to the reinstalled real records the corresponding data
**  -> but we can't tell which tmp record holds the truth (past / present / future ...?)
* => Solution 1: Extend SAVE TMPRECORDS to the whole IROBJ-Record
* => Solution 2: SAVE_BEFORE_SAVE( ... to memorize IROBJ and EWATAB directly before save )
*  -> mark: -> SAVE_OBJ_SV( ) before SAVE( ) was abbondene due to we still have to sort the dummy recods accordingly
*  -> and see if IROBJ_TSL can help here
**** end of work around

**** MDATA-IPROPSD #->SAVE_IPROPSD( ).
      CL_EEWA_MISC=>TODO( ).

    endif.

*    we just saved
    SET_OBJ_CHANGED( PAR_MARK = ABAP_FALSE ).
    SET_DB_TO_SAVED( ).

  endmethod.

  method LOAD_OBJECT_SV.
    data:
      LEWATAB_LINEREF type ref to ISUWA_OBJ_LINES,
      LF_EWATAB_LINEREF type ref to ISUWA_OBJ_LINES.

* for eval only
*    data(LCANDOIT1) = EVAL_DB_EWATAB( PAR_EWATAB = FOBJ-EWATAB ).
*    data(LEWATAB) = PAR_OBJREF->EWATAB.
*    data(LCANDOIT2) = EVAL_DB_EWATAB( PAR_EWATAB = LEWATAB ).
*   if LCANDOIT eq ABAP_FALSE. -> ERROR

    case PAR_WMODE.
      when CO_OVERWRITE.
*       updates the old and inserts new (= CO_MODIFY)
*        CO_UPDATE -> updates only existing entries

        " this is likely for CO_NEW
        PAR_OBJREF->EWATAB = FOBJ-EWATAB.
        PAR_OBJREF->IROBJ_TAB = FOBJ-IROBJ_TAB.
*      " this time it is -> restores the last status
        PAR_OBJREF->IROBJ_TSL = FOBJ-IROBJ_TSL.
      when CO_MERGE.
*        inserts only new
      when CO_NEW.
*        deletes old and sets all new
      when OTHERS.

    endcase.

  endmethod.

  method LOAD_OBJECT_SV_CONTRACT.
    data:
      LOBJNR type EOBJNR,
      LOBJNRRANGE type range of EOBJNR,
      LOBJNRRNG like line of LOBJNRRANGE.

    loop at FFKEYS reference into data(LFKEY)
      where VBELN = PAR_VBELN and POSNR = PAR_POSNR.
      LOBJNRRNG-SIGN = 'I'.
      LOBJNRRNG-OPTION = 'EQ'.
      LOBJNRRNG-LOW = LFKEY->OBJNR.
      insert LOBJNRRNG into table LOBJNRRANGE.
    endloop.

    case PAR_WMODE.
      when CO_OVERWRITE.
*       updates the old and inserts new (= CO_MODIFY)

        data(LIROBJ_TAB) = FOBJ-IROBJ_TAB.
        delete LIROBJ_TAB where OBJNR not in LOBJNRRANGE.
        PAR_OBJREF->IROBJ_TAB = LIROBJ_TAB.

*      " special case  -> ServFreqHead on Container has no VBELN POSNR OBKNR OBJNR ...
*         -> SAVE to FKEYs by OBJNR and read here
*        if SY-SUBRC is initial.
          data(LEWATAB) = FOBJ-EWATAB.
          delete LEWATAB where EWAOBJ-OBJNR not in LOBJNRRANGE.
          PAR_OBJREF->EWATAB = LEWATAB.

* !--> IROBJ_TSL is not loaded on open /->no matter we simply delete them if necessary
" -> (i.e. we switched the IROBJ_TAB-Line)
          data(LIROBJ_TSL) = FOBJ-IROBJ_TSL.
          delete LIROBJ_TSL where OBJNR not in LOBJNRRANGE.
          PAR_OBJREF->IROBJ_TSL = LIROBJ_TSL.
*        else.
**          clear PAR_OBJREF->IROBJ_TAB.
**          clear PAR_OBJREF->EWATAB.
**          clear PAR_OBJREF->IROBJ_TSL.
*        endif.

      when CO_MERGE.
*        inserts only new
      when CO_NEW.
*        deletes old and sets all new
      when OTHERS.

    endcase.

  endmethod.

  method ROUTEOBJ_PREPARE_SAVE_SV.
*   handles spec cases that could occur in SAVE_CONTRACT from SV but that should not or can not be SAVEd

**** material redeclaration
*    this is the very special case when:
* -> there was contractposition with MATNR #X.
* -> then new ServFreqs were added
* -> then we change the MATNR to #Y, which can be done for the "to be added* changes can not be verrified
* -> then we save
** => saying: when saving, the transmitted MATNR must be the same as the previous one
*  ? who holds the data:
*    data(LF_IROBJ_TAB) = FOBJ-IROBJTAB.
*    delete LF_IROBJ_TAB where MATNR is initial.
*    loop at PAR_OBJ-IROBJTAB reference into LIROBJ_TAB_LINEREF where MATNR is not initial.
*      read table LF_IROBJ_TAB reference into LF_IROBJ_TAB_LINEREF with key OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
*      if SY-SUBRC is initial.
*        if LIROBJ_TAB_LINEREF->MATNR <> LF_IROBJ_TAB_LINEREF->MATNR.
*          " just override? -> redeclare too ?
*        else.
*          "do something else?
*          delete LF_IROBJ_TAB where OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
*        endif.
*      endif.
*    endloop.
*    if LF_IROBJ_TAB is not initial. "any Material redeclared
*      modify PAR_OBJ-IROBJTAB from LF_IROBJ_TAB. "transporting MATNR.
*    endif.

**** Position deletion with only tmp. Records
*   very ? who holds the data
*    loop at PAR_OBJ-IROBJ_TAB FOBJ-IROBJ_TAB T_OBJLIST or T_VISER02 and T_RIWOL
*      find OBJNR not in PAR_OBJ-IROBJ_TAB.
*      delete FOBJ-EWATAB where EWAOBJ-OBJNR = PAR_OBJ-IROBJ_TAB-OBJNR.
*      delete FOBJ-IROBJ_TAB where OBJNR = PAR_OBJ-IROBJ_TAB-OBJNR.
*    endloop.

*    data LIROBJ_TAB like line of OBJ-IROBJ_TAB.
*    loop at LOBJ-IROBJ_TAB into LIROBJ_TAB where OBJNR ca '$'.
**      OBJNR -> $ 1 tmp. entry
**      1.) -> if tmp entry delete real entry -> we deletet it and then run again
**      2.) -> if tmp entry ewaobjh is initial we opened and closed but didn't perist changes
**        -> delete ewaobj
**      A) loop at LOBJ-EWATAB into LEWATAB where -OBKNR-OBZAE is equal -SERVLOC-ROB is initial.
**
**      B) loop at LOBJ-EWATAB into LEWATAB where -OBKNR-OBZAE-VBELN-POSNR is initial -SERVLOC or-ROB is not initial.
**        if LEWATAB-EWAOBJ-OBJNR = LIROBJ_TAB-OBJNR.
**         -> its me
**        else.
**         -> its not temporary so delete
**        endif.
**      => there cannot be a real entry which has to remain, and a 'new tmp' entry
**      Test: Anlegen -> Speichern -> Löschen -> Speichern -> Anlegen -> Speichern -> ? Löschen
*    endloop.
* in case a position has been edited and redeclared we have to abort the changes
*  -> deletion of DB: EWAOBJ and EWAOBJH is performed by BAdI at SAVE_CONTRACT
** ! this has to be and remain, for the BAdI at VBAP_CHECK_DELETE can only check existing ServFreqs
*    data LMATNR type MATNR.
*    loop at LOBJ-IROBJ_TAB into LIROBJ_TAB. "? group by -VBELN-POSNR
*      at new POSNR. "loop at group ? at new group
*
*        " FOBJCOLLECTOR->SOLVE_FKEYS ( PAR_OBJNR ) ->IROBJ_TAB-Contract maybe initial
*        select single MATNR
*          from VBAP " or VBUP
*          where VBAP~VBELN = @LIROBJ_TAB-SDVERTRAG
*            and VBAP~POSNR = @LIROBJ_TAB-POSNR
*          into @LMATNR.
*
*        if LMATNR is not initial.
*          if LMATNR <> LIROBJ_TAB-MATNR.
*            loop at LOBJ-EWATAB reference into data(LEWATAB).
*    !!!! Behälterassignments to Position are marked as redeclared !!!!
**              if LEWATAB->EWAOBJ-OBJNR = LIROBJ_TAB-OBJNR.
**                delete LEWATAB.
**              endif.
*              delete LEWATAB->EWAOBJH where EWAOBJH-OBJNR = LIROBJ_TAB-OBJNR.
*              delete LEWATAB->EWAOBJH_AAT where AAT-OBJNR = LIROBJ_TAB-OBJNR.
**              delete LEWATAB->EWAOBJ where OBJNR = LIROBJ_TAB-OBJNR.
*            "... etc.
*            endloop.
*          endif.
*        endif.
*      endat.
*    endloop.
*  at this point we have no screen to work on IROBJ_TSLs
    " usually TSLs are not loaded on ISU_O_ROUTEOBJ_OPEN
*    clear LOBJ-IROBJ_TSL. "if u like handle it more gracefully on FOBJCOLLECTOR->LOAD_...( ).

  endmethod.

  method GET_IROBJ_TAB.
    PAR_IROBJ_TAB = FOBJ-IROBJ_TAB.
  endmethod.

  method SET_OBJ_CHANGED.
    FOBJ_CHANGED = PAR_MARK.
  endmethod.

  method GET_OBJ_CHANGED.
    PAR_OBJ_CHANGED = FOBJ_CHANGED.
  endmethod.

  method UPDATE_FKEYS.
    data:
      LFKEY type ref to TFKEY.

* ->#INSERT_INTO_FKEYS( PAR_OBJNR )

  if PAR_OBJNR is not initial
    and PAR_VBELN is initial
    and PAR_POSNR is initial
    and PAR_OBKNR is initial
    and PAR_OBZAE is initial.
* whole new CONTAINER or PROP entry, that has never been there before
    read table FFKEYS reference into LFKEY
      with key OBJNR = PAR_OBJNR.
    if SY-SUBRC is not initial.
      " new entry
      create data LFKEY.
      LFKEY->OBJNR = PAR_OBJNR.
      LFKEY->VBELN = PAR_VBELN.
      LFKEY->POSNR = PAR_POSNR.
      LFKEY->OBKNR = PAR_OBKNR.
      LFKEY->OBZAE = PAR_OBZAE.
      insert LFKEY->* into table FFKEYS.
*    else. "?
    endif.
  elseif PAR_OBJNR is not initial
      and PAR_VBELN is not initial
      and PAR_POSNR is not initial
      and PAR_OBKNR is initial
      and PAR_OBZAE is initial.
* add VBELN and POSNR for CONTAINER or PROP entry to FFKEYS for reference
      loop at FFKEYS reference into LFKEY
        where OBJNR = PAR_OBJNR
          and VBELN = PAR_VBELN
          and POSNR = PAR_POSNR
          and OBKNR is initial
          and OBZAE is initial.
      endloop.
      if SY-SUBRC is not initial.
        create data LFKEY.
        LFKEY->OBJNR = PAR_OBJNR.
        LFKEY->VBELN = PAR_VBELN.
        LFKEY->POSNR = PAR_POSNR.
        clear: LFKEY->OBKNR, LFKEY->OBZAE.
        insert LFKEY->* into table FFKEYS.
*        else. "?
       endif.
    endif.

*    update OBKNR (at ACTION_SAVE_SV an OBKNR is available)
" for MATNR-Pos of SD-Contract (?maybe no more necessary)
" --> after ACTION_SAVE_SV contract is closed and OBJ cleared
    if PAR_OBKNR is not initial.
      read table FFKEYS reference into LFKEY
        with key
          VBELN = PAR_VBELN
          POSNR = PAR_POSNR
          OBZAE = PAR_OBZAE.
      if SY-SUBRC is initial.
        LFKEY->OBKNR = PAR_OBKNR.
      else. " on load new entries may be available
*        insert initial line into table FFKEYS reference into LFKEY.
        create data LFKEY.
        LFKEY->VBELN = PAR_VBELN.
        LFKEY->POSNR = PAR_POSNR.
        LFKEY->OBKNR = PAR_OBKNR.
        LFKEY->OBZAE = PAR_OBZAE.
        insert LFKEY->* into table FFKEYS.
      endif.
    endif.
*    update OBJNR (after SAVE an OBJNR for ServFreq is available)
    if PAR_OBJNR is supplied
      and PAR_VBELN is not initial
      and PAR_POSNR is not initial
      and PAR_OBZAE is not initial.
      read table FFKEYS reference into LFKEY
        with key
          VBELN = PAR_VBELN
          POSNR = PAR_POSNR
          OBZAE = PAR_OBZAE.
      if SY-SUBRC is initial.
        LFKEY->OBJNR = PAR_OBJNR.
      else.
*        insert initial line into table FFKEYS reference into LFKEY.
        create data LFKEY.
        LFKEY->OBJNR = PAR_OBJNR.
        LFKEY->VBELN = PAR_VBELN.
        LFKEY->POSNR = PAR_POSNR.
        LFKEY->OBZAE = PAR_OBZAE.
        insert LFKEY->* into table FFKEYS.
      endif.
    endif.

  endmethod.

  method SOLVE_FKEYS.
    data:
      LFKEY type ref to TFKEY.

    if FFKEYS is initial.
      clear: " Error
        PAR_EVBELN,
        PAR_EPOSNR,
        PAR_EOBKNR,
        PAR_EOBZAE,
        PAR_EOBJNR.
    else.
**** request by OBJNR
      if PAR_IOBJNR is initial. "not supplied or 0
        clear: " Error
          PAR_EVBELN,
          PAR_EPOSNR,
          PAR_EOBKNR,
          PAR_EOBZAE.
      else.
        read table FFKEYS reference into LFKEY with key OBJNR = PAR_IOBJNR.
        if SY-SUBRC is initial.
          PAR_EVBELN = LFKEY->VBELN.
          PAR_EPOSNR = LFKEY->POSNR.
          PAR_EOBKNR = LFKEY->OBKNR.
          PAR_EOBZAE = LFKEY->OBZAE.
        else.
          clear: " n.a.
            PAR_EVBELN,
            PAR_EPOSNR,
            PAR_EOBKNR,
            PAR_EOBZAE.
        endif.
      endif.
*      elseif PAR_EOBJNR is supplied.
      "-> to prevent confusion with the programmer
      " --> yes, u totally could request OBJNR of some VBELN-POSNR and VBELN-POSNR of some OBJNR at once
    endif.
**** request for OTHERS
*      by OBKNR-OBZAE
    if PAR_IOBKNR is supplied and PAR_IOBZAE is not initial.
      read table FFKEYS reference into LFKEY
        with key OBKNR = PAR_IOBKNR OBZAE = PAR_IOBZAE.
      if SY-SUBRC is initial.
        PAR_EOBJNR = LFKEY->OBJNR.
        PAR_EVBELN = LFKEY->VBELN.
        PAR_EPOSNR = LFKEY->POSNR.
      else.
        clear: " n.a.
          PAR_EOBJNR,
          PAR_EVBELN,
          PAR_EPOSNR.
      endif.
*    by VBELN-POSNR-OBZAE
    elseif PAR_IVBELN is initial or PAR_IPOSNR is initial or PAR_IOBZAE is initial. "not supplied or 0
      clear: " Error
        PAR_EOBJNR,
        PAR_EOBKNR.
    else.
      read table FFKEYS reference into LFKEY
        with key VBELN = PAR_IVBELN POSNR = PAR_IPOSNR OBZAE = PAR_IOBZAE.
      if SY-SUBRC is initial.
        PAR_EOBJNR = LFKEY->OBJNR.
      else.
        clear: " n.a.
          PAR_EOBJNR,
          PAR_EOBKNR.
      endif.
    endif.

**** request both to compare both
    if PAR_ISSAMELINE is supplied.
      if PAR_IOBJNR is supplied and PAR_EOBJNR is supplied.
        if PAR_IOBJNR = PAR_EOBJNR.
          PAR_ISSAMELINE = ABAP_TRUE.
        else.
          PAR_ISSAMELINE = ABAP_FALSE.
        endif.
      else.
        PAR_ISSAMELINE = ABAP_UNDEFINED.
      endif.
    endif.

  endmethod.

  method GET_KEY_SD.
*    data:
*      LVBELN type VBELN_VA.

*    eval
*    loop at FFKEYS into data(LFKEY).
*      if LVBELN is initial.
*        LVBELN = LFKEY-VBELN.
*      else.
*        if LFKEY-VBELN <> LVBELN.
*          "!ERROR. "only one VBELN should be handled by FOBJCOLLECOTR -> or make FOBJTABLE
*        endif.
*      endif.
*    endloop.

" ? key --> EWAOBJD-OBJNR
* => replaced by requested TOBJLIST[] and VBAP[1]-TABLE_LINE
*    read table FFKEYS into data(LFKEY) index 1.
*    PAR_VBELN = LFKEY-VBELN.
*    PAR_POSNR = LFKEY-POSNR.

  endmethod.

  method REFILL_TOBJLIST.

*    loop FT_OBJLIST
*      read PAR_TOBJLIST
*      insert into if sy-subrc not initial
*    endloop
    append lines of FT_OBJLIST to PAR_TOBJLIST.
    sort PAR_TOBJLIST.
    delete adjacent duplicates from PAR_TOBJLIST.

  endmethod.

  method REFILL_TRIWOL.

    append lines of FT_RIWOL to PAR_TRIWOL.
    sort PAR_TRIWOL.
    delete adjacent duplicates from PAR_TRIWOL.

  endmethod.

  method UPDATE_TOBJLIST.

    loop at PAR_TOBJLIST reference into data(L_TOBJLIST).
      read table FT_OBJLIST reference into data(LF_TOBJLIST)
        with key
          SDAUFNR = L_TOBJLIST->SDAUFNR
          POSNR = L_TOBJLIST->POSNR
          OBZAE = L_TOBJLIST->OBZAE.
      if SY-SUBRC is initial.
        " update OBKNR
        if L_TOBJLIST->OBKNR <> LF_TOBJLIST->OBKNR. "<- is initial.
          LF_TOBJLIST->OBKNR = L_TOBJLIST->OBKNR.
        endif.
      else.
        insert L_TOBJLIST->* into table FT_OBJLIST.
      endif.
    endloop.
*    we collect all areas we have opened, we cannot not have opened an area after we opened it
*    -> no delete => if no changes were made in the area they are not saved

  endmethod.

  method UPDATE_TRIWOL.

    loop at PAR_TRIWOL reference into data(L_TRIWOL).
      read table FT_RIWOL reference into data(LF_TRIWOL)
        with key
          OBJNR = L_TRIWOL->OBJNR
          OBZAE = L_TRIWOL->OBZAE.
      if SY-SUBRC is initial.
        " update OBKNR
        if L_TRIWOL->OBKNR <> LF_TRIWOL->OBKNR. "<- is initial.
          LF_TRIWOL->OBKNR = L_TRIWOL->OBKNR.
        endif.
      else.
        insert L_TRIWOL->* into table FT_RIWOL.
      endif.
    endloop.
*    we collect all areas we have opened, we cannot not have opened an area after we opened it
*    -> no delete => if no changes were made in the area they are not saved

  endmethod.

  method SAVE_DB_EWATAB.
    data:
      LF_EWATAB_LINEREF type ref to ISUWA_OBJ_LINES,
      LEWATAB_LINEREF type ref to ISUWA_OBJ_LINES,
      LEWATAB_LINE type ISUWA_OBJ_LINES,
      LFKEY type ref to TFKEY.

*    if FDBSAVE_CALLED eq ABAP_FALSE.
*    only call once (at first entry) -> this is the very original version
      if FOBJ-EWATAB is initial.
        "this should not be but maybe we haven't saved anything to FOBJ for now
        loop at PAR_EWATAB into LEWATAB_LINE. "we put'em all
          insert LEWATAB_LINE into table FOBJ-EWATAB.
        endloop.
      else.
        loop at PAR_EWATAB reference into LEWATAB_LINEREF.
          read table FOBJ-EWATAB reference into LF_EWATAB_LINEREF
            with key EWAOBJ-OBJNR = LEWATAB_LINEREF->EWAOBJ-OBJNR.
          if SY-SUBRC is initial. "update exisiting _DB-Entry
            read table FFKEYS reference into LFKEY with key OBJNR = LEWATAB_LINEREF->EWAOBJ-OBJNR.
            if SY-SUBRC is initial.
              if LFKEY->DB_SAVED eq ABAP_FALSE.
*                no matter the data contents
*                -> if they differ we can't tell the truth -> hence FDBSAVE_CALLED
                LF_EWATAB_LINEREF->DB_EWAOBJ = LEWATAB_LINEREF->DB_EWAOBJ.
                LF_EWATAB_LINEREF->DB_EWAOBJH = LEWATAB_LINEREF->DB_EWAOBJH.
                LF_EWATAB_LINEREF->DB_EWAOBJH_AAT = LEWATAB_LINEREF->DB_EWAOBJH_AAT.
                LFKEY->DB_SAVED = ABAP_TRUE.
              endif.
            endif.
          " else. -> this should not happen, for you should clear FDBSAVE_CALLED after updating the DB
          endif.
        endloop.
      endif.
*      FDBSAVE_CALLED = ABAP_TRUE. "-> go clear if needs be, i.e. after DB-update
*    endif.

  endmethod.

  method LOAD_DB_EWATAB.
    data:
      LF_EWATAB_LINE type ref to ISUWA_OBJ_LINES,
      LEWATAB_LINE type ref to ISUWA_OBJ_LINES.

*    resets initial DB-Status of EWATAB-EWAOBJ and EWAOBJH / ..._AAT

*    for eval
    data(LDB_ISEQUAL) = EVAL_DB_EWATAB( exporting PAR_EWATAB = PAR_EWATAB ).

    " PS: Yes, deleted entries are restored! to be identified to have to be deleted
    loop at FOBJ-EWATAB reference into LF_EWATAB_LINE.
      "for now we only have 1 EWATAB-EWAOBJ
      loop at PAR_EWATAB reference into LEWATAB_LINE. "with key -EWAOBJ
        LEWATAB_LINE->DB_EWAOBJ = LF_EWATAB_LINE->DB_EWAOBJ.
        LEWATAB_LINE->DB_EWAOBJH = LF_EWATAB_LINE->DB_EWAOBJH.
        LEWATAB_LINE->DB_EWAOBJH_AAT = LF_EWATAB_LINE->DB_EWAOBJH_AAT.
      endloop.
    endloop.

  endmethod.

  method SET_DBSAVE_CALLED.
    data:
      LFKEY type ref to TFKEY.

*    FDBSAVE_CALLED = PAR_ISCALLED.
    loop at FFKEYS reference into LFKEY.
      LFKEY->DB_SAVED = ABAP_FALSE.
    endloop.

  endmethod.

  method SET_TMPRECORDS.
    data:
      LIROBJ_TAB_LINEREF type ref to ISU_ROBJ_TABC,
      LTMPRECORD type TTMPRECORD.

    loop at PAR_OBJ-IROBJ_TAB reference into LIROBJ_TAB_LINEREF where OBJNR ca '$'.
*   or EWATAB: assign fs(<LEWATAB>) loop for OBJNR
*      read table LFTMPRECORDS transporting no fields with key OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
*      if SY-SUBRC is not initial.
      LTMPRECORD-OBJNR = LIROBJ_TAB_LINEREF->OBJNR.
      LTMPRECORD-VBELN = PAR_OBJ-EWAOBJD-SDVERTRAG.
      LTMPRECORD-POSNR = PAR_OBJ-EWAOBJD-POSNR.
      insert LTMPRECORD into table FTMPRECORDS.
*      endif.
    endloop.
*    to work around->
    FTMP_IROBJ_TAB = PAR_OBJ-IROBJ_TAB.

  endmethod.

  method CLEAR_TMPRECORDS.

    clear FTMPRECORDS.

  endmethod.

  method EVAL_DB_EWATAB.
    data:
      LPAR_EWATAB_LINEREF type ref to ISUWA_OBJ_LINES,
      LDB_EWAOBJ type EWAOBJ,
      LDB_EWAOBJH type table of EWAOBJH,
      LPAR_DB_EWAOBJH type ISUWA_T_EWAOBJH,
      LPAR_DB_EWAOBJH_LINE type ISUWA_EWAOBJH,
      LPAR_DB_EWAOBJH_LINES type table of EWAOBJH.

    " for eval only
    loop at PAR_EWATAB reference into LPAR_EWATAB_LINEREF.
*      eval EWAOBJ
      select single * into corresponding fields of LDB_EWAOBJ
        from EWAOBJ
        where OBJNR = LPAR_EWATAB_LINEREF->EWAOBJ-OBJNR.
      if LDB_EWAOBJ <> LPAR_EWATAB_LINEREF->DB_EWAOBJ.
        PAR_ISEQUAL = ABAP_FALSE. return.
      endif.
*      eval EWAOBJH
      select * into corresponding fields of table LDB_EWAOBJH
        from EWAOBJH
        where OBJNR = LPAR_EWATAB_LINEREF->EWAOBJ-OBJNR.
*      EWAOBJH
      loop at LPAR_EWATAB_LINEREF->DB_EWAOBJH into LPAR_DB_EWAOBJH_LINE.
        append LPAR_DB_EWAOBJH_LINE-EWAOBJH to LPAR_DB_EWAOBJH_LINES.
      endloop.
      if LPAR_DB_EWAOBJH_LINES <> LDB_EWAOBJH.
        PAR_ISEQUAL = ABAP_FALSE. return.
      endif.
*      EWAOBJH_DATES
*      EWAOBJH_DIFFCULT
*      EWAOBJH_UPOS
*      EWAOBJH_SHARE
*      EWAOBJH_SEQUENCE

*      doesn't eval EWAOBJH_AAT
    endloop.
  endmethod.

  method SET_DB_TO_SAVED.
    data:
      LFKEY type ref to TFKEY.

    loop at FFKEYS reference into LFKEY.
      LFKEY->DB_SAVED = ABAP_TRUE.
    endloop.
  endmethod.

endclass.