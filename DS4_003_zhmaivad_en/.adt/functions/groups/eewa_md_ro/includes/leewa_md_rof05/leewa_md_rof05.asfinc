*----------------------------------------------------------------------*
***INCLUDE LEEWA_MD_ROF05 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  grid_variant_get_default
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form GRID_VARIANT_GET_DEFAULT changing RS_VARIANT type DISVARIANT.

  clear RS_VARIANT.
  RS_VARIANT-REPORT = GBILL_REPID.
*
  call function 'LVC_VARIANT_DEFAULT_GET'
    exporting
      I_SAVE     = GBILL_SAVE
    changing
      CS_VARIANT = RS_VARIANT
    exceptions
      NOT_FOUND  = 2
      others     = 4.
  if SY-SUBRC = 0.
    LS_VARI = GSBILL_VARIANT-VARIANT.
  endif.

endform.                    " grid_variant_get_default
*&---------------------------------------------------------------------*
*&      Form  grid_variant_existence
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form GRID_VARIANT_EXISTENCE changing RS_VARIANT type DISVARIANT.

  if not LS_VARI is initial.
    clear RS_VARIANT.
    move LS_VARI  to GSBILL_VARIANT-VARIANT.
    move GBILL_REPID to GSBILL_VARIANT-REPORT.
*
    call function 'LVC_VARIANT_EXISTENCE_CHECK'
      exporting
        I_SAVE     = GBILL_SAVE
      changing
        CS_VARIANT = RS_VARIANT
      exceptions
        others     = 4.
    if SY-SUBRC <> 0.
      message id SY-MSGID type SY-MSGTY number SY-MSGNO
             with SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    endif.
  else.
    clear RS_VARIANT.
    RS_VARIANT-REPORT = GBILL_REPID.
  endif.

endform.                    " grid_variant_existence
*&---------------------------------------------------------------------*
*&      Form  grid_fldcat_init
*&---------------------------------------------------------------------*
form GRID_FLDCAT_INIT changing PT_FCAT type LVC_T_FCAT.
*
  data: EDIT       type REGEN-KENNZX.
  field-symbols: <LS_FCAT>    type LVC_S_FCAT.

*&  init
  refresh PT_FCAT.

  if OBJ-CONTR-WMODE = CO_DISPLAY.
    EDIT = SPACE.
  else.
    EDIT = 'X'.
  endif.

*&  Build the fieldcat according to DDIC structure:
  call function 'LVC_FIELDCATALOG_MERGE'
    exporting
      I_STRUCTURE_NAME   = 'ISU_AAT_BILLING_HIST'
      I_BYPASSING_BUFFER = 'X'
    changing
      CT_FIELDCAT        = PT_FCAT[].

* Asugabe der FElder steuern
  loop at PT_FCAT assigning <LS_FCAT>.

    case <LS_FCAT>-FIELDNAME.
*&  Vorwärtsnavigation zum Operand ermöglichen
*      when 'OPERAND'.
*        ls_fcat-hotspot          = 'X'.
*        modify pt_fcat from ls_fcat transporting hotspot.

      when 'TEXT30'.
        <LS_FCAT>-HOTSPOT          = 'X'.
        <LS_FCAT>-SCRTEXT_L     = text-S67.
        <LS_FCAT>-SCRTEXT_M     = text-S67.
        <LS_FCAT>-SCRTEXT_S     = text-S67.
        <LS_FCAT>-SP_GROUP      = '0004'.

*&  Bezeichnung des Objekts (Behälter oder ROB)
      when 'OBJECT_TXT'.
        <LS_FCAT>-EMPHASIZE  = 'C300'.
        <LS_FCAT>-COL_POS    = '1'.
        <LS_FCAT>-SCRTEXT_L     = text-S64.
        <LS_FCAT>-SCRTEXT_M     = text-S64.
        <LS_FCAT>-SCRTEXT_S     = text-S64.
        <LS_FCAT>-SP_GROUP      = '0001'.
        <LS_FCAT>-KEY           = 'X'.

*&  Bezeichnung der Leistungsart
      when 'VTEXT'.
        <LS_FCAT>-OUTPUTLEN     = '20'.
        <LS_FCAT>-COL_POS    = '2'.
        <LS_FCAT>-SCRTEXT_L     = text-S65.
        <LS_FCAT>-SCRTEXT_M     = text-S65.
        <LS_FCAT>-SCRTEXT_S     = text-S65.
        <LS_FCAT>-SP_GROUP      = '0002'.

*&  Bezeichnung des Abfallabrechnungstyps
      when 'BILLTYPE_TXT'.
        <LS_FCAT>-OUTPUTLEN     = '20'.
        <LS_FCAT>-COL_POS    = '3'.
        <LS_FCAT>-SCRTEXT_L     = text-S66.
        <LS_FCAT>-SCRTEXT_M     = text-S66.
        <LS_FCAT>-SCRTEXT_S     = text-S66.
        <LS_FCAT>-SP_GROUP      = '0003'.

*&  Ab und Bis Datum
      when 'AB'
        or 'BIS'.
        <LS_FCAT>-OUTPUTLEN     = '9'.

*&  Abzurechnender Wert
      when 'WERT2'.
        <LS_FCAT>-OUTPUTLEN     = '10'.
        <LS_FCAT>-COL_POS    = '6'.

*&  Felder ausblenden
      when others.
        <LS_FCAT>-NO_OUT  = 'X'.
    endcase.                             " <ls_fcat>-fieldname
  endloop.                             " AT pt_fcat INTO <ls_fcat>.

endform.                    " grid_fldcat_init
*&---------------------------------------------------------------------*
*&      Form  grid_layout_init
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form GRID_LAYOUT_INIT changing RS_LAYOUT type LVC_S_LAYO.

* build layout for list display
* global display options
  RS_LAYOUT-CWIDTH_OPT = 'X'.

* customizing grid
  RS_LAYOUT-GRID_TITLE = text-100.

* selection mode
* RS_LAYOUT-SEL_MODE = SPACE.
  RS_LAYOUT-SEL_MODE = 'B'.
*  "Space = default: listbox single select
*  "    A = rows and columns (no listbox)
*  "    B = listbox single row selection
*  "    C = listbox multiple row selection
*  "    D = listbox cells selection

* exceptions
* RS_LAYOUT-EXCP_FNAME = '<gbill_outtab_field_name>'.
* RS_LAYOUT-EXCP_ROLLN = '<data-element for F1>'.
* RS_LAYOUT-EXCP_CONDS = ' '.  "condens exceptions
* RS_LAYOUT-EXCP_LED   = ' '.  "display exceptions as LEDs
*  rs_layout-excp_fname = gbill_fname_excp.
*  rs_layout-excp_led   = 'X'.

endform.                    " grid_layout_init
*&---------------------------------------------------------------------*
*&      Form  grid_create
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form GRID_CREATE.

  create object GBILL_CONT
    exporting
      CONTAINER_NAME = GBILL_CONT_NAME.
  create object GBILL_GRID
    exporting
      I_PARENT      = GBILL_CONT
      I_APPL_EVENTS = GBILL_APPL_EVENTS.

endform.                    " grid_create
*&---------------------------------------------------------------------*
*&      Form  grid_display
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form GRID_DISPLAY.

  call method GBILL_GRID->SET_TABLE_FOR_FIRST_DISPLAY
    exporting
      IS_VARIANT                    = GSBILL_VARIANT
      I_SAVE                        = GBILL_SAVE
      I_DEFAULT                     = GBILL_DEFAULT
      IS_LAYOUT                     = GSBILL_LAYOUT
      IT_SPECIAL_GROUPS             = GTBILL_GROUP
    changing
      IT_OUTTAB                     = GTBILL_OUTTAB[]
      IT_FIELDCATALOG               = GTBILL_FLDCAT[]
      IT_SORT                       = GSBILL_SORT
    exceptions
      INVALID_PARAMETER_COMBINATION = 1
      PROGRAM_ERROR                 = 2
      others                        = 3.
  if SY-SUBRC <> 0.
    message id SY-MSGID type SY-MSGTY number SY-MSGNO
            with SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  endif.

endform.                    " grid_display
*&---------------------------------------------------------------------*
*&      Form  grid_sort_init
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form GRID_SORT_INIT changing PT_SORT type LVC_T_SORT.

  data: LS_SORT like line of PT_SORT.

  clear: PT_SORT.

  clear LS_SORT.
  LS_SORT-SPOS = '1'.
  LS_SORT-FIELDNAME = 'OBJECT_TXT'.
  LS_SORT-DOWN = 'X'.
  append LS_SORT to PT_SORT.

  clear LS_SORT.
  LS_SORT-SPOS = '2'.
  LS_SORT-FIELDNAME = 'VTEXT'.
  LS_SORT-DOWN = 'X'.
  append LS_SORT to PT_SORT.

  clear LS_SORT.
  LS_SORT-SPOS = '3'.
  LS_SORT-FIELDNAME = 'BILLTYPE_TXT'.
  LS_SORT-DOWN = 'X'.
  append LS_SORT to PT_SORT.

  clear LS_SORT.
  LS_SORT-SPOS = '4'.
  LS_SORT-FIELDNAME = 'OPERAND'.
  LS_SORT-DOWN = 'X'.
  append LS_SORT to PT_SORT.

*  clear ls_sort.
*  ls_sort-spos = '5'.
*  ls_sort-fieldname = 'AB'.
*  ls_sort-down = 'X'.
*  append ls_sort to pt_sort.
*
endform.                    " grid_sort_init
*&---------------------------------------------------------------------*
*&      Form  grid_fill_bill_outtab
*&---------------------------------------------------------------------*
form GRID_FILL_BILL_OUTTAB using  X_IDATACOL  type ISU2A_DATA_COLLECTOR
                                  X_DATE      type ERCHZ-AB
                                  X_FROM      type ERCHZ-AB
                                  X_CONTRACT  type EVER-VERTRAG
                         changing XY_IBILLDATA type ISU2A_BILLING_DATA
                                  XY_OUTTAB   like GTBILL_OUTTAB.

  data: WAAT    type ISUWA_AAT_SHORT,
        WOUTTAB type ISU_AAT_BILLING_HIST,
        IOPER_W type ISU2A_IOPER_W,
        IOPER   type ISU2A_IOPER,
        WPREI_W type ISU2A_PREI_W,
        WSS     type ISU2A_SS,
        OUTTAB  like GTBILL_OUTTAB,
        WOPER2  type ISU2A_OPER,
        WPREI   type ISU2A_PREI.
  field-symbols:
    <W_OUT>    type GBILL_OUTTAB,
    <WOPER>    type ISU2A_OPER,
    <WOPER_W>  type ISU2A_OPER_W,
    <WEWATAB>  type ISUWA_OBJ_LINES,
    <IAAT>     type ISUWA_EWAOBJH_AAT,
    <WAATHIST> type EWAOBJH_AAT_HIST.

  refresh XY_OUTTAB.

* Überprüfen ob es bereits individuelle Werte zu diesem Operanden
* gibt und diese in die Ausgabetabelle stellen
  loop at OBJ-EWATAB assigning <WEWATAB>
  where EWAOBJ-OBJNR = OBJ-WA_TAB-OBJNR.
    loop at <WEWATAB>-EWAOBJH_AAT assigning <IAAT>.
      loop at <IAAT>-AAT_HIST assigning <WAATHIST>
      where AB le X_DATE
      and   BIS ge X_FROM.
        move-corresponding <WAATHIST> to WOUTTAB.
        WOUTTAB-WERT2 = <WAATHIST>-WERT1.
*       Objektbezeichnung füllen
        perform FILL_BILL_OUTTAB_TXT using OBJ
                                     changing WOUTTAB.
        append WOUTTAB to XY_OUTTAB.
      endloop.
    endloop.                  "wewatab-ewaobjh_aat
  endloop.                    "obj-ewatab

* Vergleichstabelle
  clear OUTTAB.
  OUTTAB = XY_OUTTAB[].

* Werte stehen direkt in der IOPER_W falls es sich um Faktoren handelt
* und in der IPREI_W falls es sich um Preise handelt
  IOPER_W = XY_IBILLDATA-IOPER_W.
  loop at IOPER_W assigning <WOPER_W>
  where OPTYP     <> CO_REFVALUE
  and   OPTYP     <> CO_QUANT
  and   OUTPUT    = SPACE
  and   OBJNR     = OBJ-WA_TAB-OBJNR.
    read table OUTTAB with key OBJNR = <WOPER_W>-OBJNR
                              LAUFNR = <WOPER_W>-LAUFNR
                              OPERAND = <WOPER_W>-OPERAND
                              BILLTYPE = <WOPER_W>-BILLTYPE
                              AB      = <WOPER_W>-AB
                              assigning <W_OUT>.
    if SY-SUBRC = 0.
      if <W_OUT>-WERT2 is initial.
*   Operandentypen unterschiedlich behandeln
        case <WOPER_W>-OPTYP.
          when 'TPRICE' or 'QPRICE'.
            if <WOPER_W>-STRING1 is initial.
              continue.
            else.
              read table XY_IBILLDATA-IPREI_W into WPREI_W
              with key OPERAND_W = <WOPER_W>-OPERAND_W
                       BILLTYPE = <WOPER_W>-BILLTYPE
                       AB      = <WOPER_W>-AB
                       OBJNR = <WOPER_W>-OBJNR
                       LAUFNR = <WOPER_W>-LAUFNR.
              if SY-SUBRC = 0.
                <W_OUT>-WERT2 = WPREI_W-PRICE_NEW.
              endif.
            endif.
          when 'FACTOR'.
            if <WOPER_W>-QNT_NEW is initial.
              continue.
            endif.
        endcase.
        modify XY_OUTTAB from <W_OUT> transporting WERT2
          where OBJNR = <WOPER_W>-OBJNR
          and  LAUFNR = <WOPER_W>-LAUFNR
          and  OPERAND = <WOPER_W>-OPERAND
          and  BILLTYPE = <WOPER_W>-BILLTYPE
          and  AB      = <WOPER_W>-AB.
        continue.
      else.
        continue.
      endif.
    endif.
    clear WOUTTAB.
*   Operandentypen unterschiedlich behandeln
    case <WOPER_W>-OPTYP.
      when 'TPRICE' or 'QPRICE'.
        if <WOPER_W>-STRING1 is initial.
          continue.
        else.
          read table XY_IBILLDATA-IPREI_W into WPREI_W
          with key OPERAND_W = <WOPER_W>-OPERAND_W
                   BILLTYPE = <WOPER_W>-BILLTYPE
                   AB      = <WOPER_W>-AB
                   OBJNR = <WOPER_W>-OBJNR
                   LAUFNR = <WOPER_W>-LAUFNR.
          if SY-SUBRC = 0.
            WOUTTAB-WERT2 = WPREI_W-PRICE_NEW.
          endif.
        endif.
      when 'FACTOR'.
        if <WOPER_W>-QNT_NEW is initial.
          continue.
        endif.
    endcase.

    move-corresponding <WOPER_W> to WOUTTAB.
    WOUTTAB-VERTRAG = X_CONTRACT.
    if WOUTTAB-BIS = X_DATE.
      WOUTTAB-BIS = CO_DATE_INFINITE.
      <WOPER_W>-BIS = CO_DATE_INFINITE.
    endif.
*   Objektbezeichnung füllen
    perform FILL_BILL_OUTTAB_TXT using OBJ
                                 changing WOUTTAB.

    append WOUTTAB to OUTTAB.
  endloop.                " x_ibilldata-ioper_w

* Für die Grundgebühr muss der Preis in der IOPER nachgelesen werden
* ->hier muss die Grundgebühr JE Behälter ermittelt werden ?????
  read table XY_IBILLDATA-ISS into WSS
  with key PROGRAMM = 'COMPUT22'.
  if SY-SUBRC = 0.
    IOPER = XY_IBILLDATA-IOPER.
    loop at IOPER assigning <WOPER>
    where OPERAND = WSS-EIN02.
      read table OUTTAB with key OPERAND = <WOPER>-OPERAND
                                transporting no fields.
      if SY-SUBRC = 0.
        continue.
      endif.
      clear WOUTTAB.
      move-corresponding <WOPER> to WOUTTAB.
      case <WOPER>-OPTYP.
        when 'TPRICE' or 'QPRICE'.
          if <WOPER>-STRING1 is initial.
            continue.
          else.
            read table XY_IBILLDATA-IPREI into WPREI
            with key CSNO    = <WOPER>-CSNO
                     PREIS   = <WOPER>-STRING1
                     AB      = <WOPER>-AB.
            if SY-SUBRC = 0.
              WOUTTAB-WERT2 = WPREI-PRICE_NEW.
            endif.
          endif.
        when 'FACTOR'.
          if <WOPER>-QNT_NEW is initial.
            continue.
          endif.
      endcase.
      WOUTTAB-OBJNR = OBJ-WA_TAB-OBJNR.
      WOUTTAB-VERTRAG = X_CONTRACT.
      WOUTTAB-OPERAND_W = <WOPER>-OPERAND.
      WOUTTAB-OPLFDNR_W = <WOPER>-OPLFDNR.
      if WOUTTAB-BIS = X_DATE.
        WOUTTAB-BIS = CO_DATE_INFINITE.
        <WOPER>-BIS = CO_DATE_INFINITE.
      endif.
*     Objektbezeichnung füllen
      perform FILL_BILL_OUTTAB_TXT using OBJ
                                   changing WOUTTAB.

      append WOUTTAB to OUTTAB.
    endloop.
  endif.

  sort OUTTAB by AB .
  delete adjacent duplicates from OUTTAB.
  XY_OUTTAB[] = OUTTAB.

endform.                    " grid_fill_bill_outtab
*&---------------------------------------------------------------------*
*&      Form  grid_bill_initialize
*&---------------------------------------------------------------------*
form GRID_BILL_INITIALIZE.

  if GBILL_CONT is initial.
    GBILL_REPID = SY-REPID.
    GBILL_SAVE = 'A'.
    GBILL_DEFAULT = SPACE.
    GBILL_APPL_EVENTS = ' '.

    perform GRID_VARIANT_GET_DEFAULT changing GSBILL_VARIANT.
    perform GRID_VARIANT_EXISTENCE changing GSBILL_VARIANT.
    perform GRID_FLDCAT_INIT changing GTBILL_FLDCAT[].
    perform GRID_LAYOUT_INIT changing GSBILL_LAYOUT.
* Sortierung festlegen
    perform GRID_SORT_INIT changing GSBILL_SORT.
    perform GRID_GROUP_INIT changing GTBILL_GROUP.
    perform EXCLUDE_TB_FUNCTIONS changing GTBILL_EXCLUDE[].

    perform GRID_CREATE.
    perform GRID_DISPLAY.

********
* ->Create Object to receive events and link them to handler methods.
* When the ALV Control raises the event for the specified instance
* the corresponding method is automatically called.
*
    create object GRID_EVENT_RECEIVER.
    set handler GRID_EVENT_RECEIVER->HANDLE_USER_COMMAND for GBILL_GRID.
    set handler GRID_EVENT_RECEIVER->HANDLE_HOTSPOT_CLICK for GBILL_GRID.
    set handler GRID_EVENT_RECEIVER->ON_TOOLBAR for GBILL_GRID.
*
********

*& Call method 'set_toolbar_interactive' to raise event TOOLBAR.
    call method GBILL_GRID->SET_TOOLBAR_INTERACTIVE.
  else.
*   Ausgabetabelle des ALV auffrischen
    call method GBILL_GRID->REFRESH_TABLE_DISPLAY.
  endif.

endform.                    " grid_bill_initialize
*&---------------------------------------------------------------------*
*&      Form  exclude_tb_functions
*&---------------------------------------------------------------------*
form EXCLUDE_TB_FUNCTIONS changing PT_EXCLUDE type UI_FUNCTIONS.

  data LS_EXCLUDE type UI_FUNC.

  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_INSERT_ROW.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_COPY_ROW.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_DELETE_ROW.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_APPEND_ROW.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_MOVE_ROW.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_COPY.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_CUT.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_PASTE.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_SUM.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_SUBTOT.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_LOC_PASTE_NEW_ROW.
  append LS_EXCLUDE to PT_EXCLUDE.
  LS_EXCLUDE = CL_GUI_ALV_GRID=>MC_FC_GRAPH.
  append LS_EXCLUDE to PT_EXCLUDE.

endform.                    " exclude_tb_functions
*&---------------------------------------------------------------------*
*&      Form  opvalue_maintain
*&---------------------------------------------------------------------*
*       Bearbeitung der Operandenwerte
*----------------------------------------------------------------------*
form OPVALUE_MAINTAIN using   LS_OUTTAB like line of GTBILL_OUTTAB.

  data: IAKLASSE      type ISU20_IAKLASSE,
        IRATECAT      type ISU20_IRATECAT,
        T_OPHIST      type ISU_OPHIST occurs 0,
        T_COMP_OPHIST type ISU_OPHIST occurs 0,
        W_OPHIST      type ISU_OPHIST,
        W_OPHIST2     type ISU_OPHIST,
        OPKEY         type ISU20_OPERAND_KEY,
        WEWATAB       type ISUWA_OBJ_LINES,
        IAAT          type ISUWA_EWAOBJH_AAT,
        WOPER_W       type ISU2A_OPER_W,
        WOPER         type ISU2A_OPER,
        MIN_DATE      type SY-DATUM,
        MAX_DATE      type SY-DATUM,
        RC            type SY-SUBRC,
        WROBJ_TAB     type ISU_ROBJ_TABC,
        WMODE         type REGEN-WMODE,
        WAATHIST      type EWAOBJH_AAT_HIST.

* Vor dem Aufruf der Operandenpflege müssen die notwenidgen
* Übergabestrukturen (IAKLASSE und IRATECAT) gefüllt werden
* FuBa ISU_BILLING_DATES_FOR_INSTLN besorgt die Abrechnungsdatümer der
* Anlage, falls die auch noch benötigt würden
  call function 'ISU_RATECAT_DATA_FOR_INSTLN'
    exporting
      X_ANLAGE      = IBILLDATA-ST-ANLAGE
    importing
      Y_IRATECAT    = IRATECAT
      Y_IAKLASSE    = IAKLASSE
    exceptions
      MISSING_DATA  = 1
      GENERAL_FAULT = 2
      others        = 3.
  if SY-SUBRC <> 0.
  endif.

* Key des Operanden
  OPKEY-OPERAND = LS_OUTTAB-OPERAND.
  OPKEY-OPLFDNR = LS_OUTTAB-OPLFDNR_W.    "???????

* An die Operandenpflege müssen die konkreten Werte des zu pflegenden
* Operanden übergeben werden. Diese müssen entweder aus der IOPER_W
* gezogen werden, falls der Operand noch keine individuellen Daten
* enthält oder aus der Tabelle EEWA_AAT_HIST
  read table OBJ-EWATAB[] with key EWAOBJ-OBJNR = LS_OUTTAB-OBJNR
  into WEWATAB.

  clear RC.
  read table WEWATAB-EWAOBJH_AAT into IAAT
    with key AAT-OBJNR    = LS_OUTTAB-OBJNR
             AAT-LAUFNR   = LS_OUTTAB-LAUFNR
             AAT-BILLTYPE = LS_OUTTAB-BILLTYPE.
  if SY-SUBRC = 0.
    clear T_OPHIST.
    loop at IAAT-AAT_HIST into WAATHIST
    where OPERAND    = LS_OUTTAB-OPERAND
    and BILLTYPE     = LS_OUTTAB-BILLTYPE
    and OBJNR        = LS_OUTTAB-OBJNR
    and LAUFNR       = LS_OUTTAB-LAUFNR
    and SERVICE_TYPE = LS_OUTTAB-SERVICE_TYPE
    and AB           ge LS_OUTTAB-AB
    and BIS          le LS_OUTTAB-BIS.
      move-corresponding WAATHIST to W_OPHIST.
      append W_OPHIST to T_OPHIST.
    endloop.
    if SY-SUBRC <> 0.
      RC = SY-SUBRC.
    endif.
  else.
    RC = SY-SUBRC.
  endif.

  if RC <> 0.
* Orginalwerte übernehmen
    loop at IBILLDATA-IOPER_W into WOPER_W
    where OPERAND    = LS_OUTTAB-OPERAND
    and BILLTYPE     = LS_OUTTAB-BILLTYPE
    and OBJNR        = LS_OUTTAB-OBJNR
    and LAUFNR       = LS_OUTTAB-LAUFNR
    and SERVICE_TYPE = LS_OUTTAB-SERVICE_TYPE
    and AB           = LS_OUTTAB-AB
    and BIS          = LS_OUTTAB-BIS
    and OUTPUT is initial.
      clear WOPER_W-KONDIGR.
      move-corresponding WOPER_W to W_OPHIST.
*     OPHIST enthält kein Feld QNT_NEW, daher muss der Faktor ins Feld
*     WERT1 geschrieben werden
      W_OPHIST-WERT1 =  WOPER_W-QNT_NEW.
*     Die Währung steht in der der Preis gepflegt werden soll steht in
*     der StammdatenStruktur des Abrechnungsobjekts
      W_OPHIST-WAERS = IBILLDATA-ST-TWAERS.
      append W_OPHIST to T_OPHIST.
    endloop.
*   Vielleicht handelte es sich um eine Grundgebühr die über die
*   Tariftypfakten ermittelt wird --> Werte stehen in IOPER
    if SY-SUBRC <> 0.
      loop at IBILLDATA-IOPER into WOPER
      where OPERAND    = LS_OUTTAB-OPERAND
      and AB           = LS_OUTTAB-AB
      and BIS          = LS_OUTTAB-BIS
      and OUTPUT is initial.
        move-corresponding WOPER to W_OPHIST.
        W_OPHIST-WERT1 =  WOPER-QNT_NEW.
        W_OPHIST-WAERS = IBILLDATA-ST-TWAERS.
        append W_OPHIST to T_OPHIST.
      endloop.
    endif.
  endif.

* Ab und Bis Datum als Rahmen setzen in dem Werte gepflegt werden dürfen
  describe table T_OPHIST.
  clear: MIN_DATE, MAX_DATE, W_OPHIST.
  read table T_OPHIST index 1 into W_OPHIST.
  MIN_DATE = W_OPHIST-AB.
  clear W_OPHIST.
  read table T_OPHIST index SY-TFILL into W_OPHIST.
  MAX_DATE = W_OPHIST-BIS.

* Baustein der Operandenpflege rufen. Dieser ruft anhand des
* Operandentyps das richtige Popup zur Pflege der Operandenwerte auf
* Als Vergleichstabelle wird die Struktur t_comp_ophist gefüllt
  clear T_COMP_OPHIST.
  T_COMP_OPHIST = T_OPHIST.
* Überprüfen, das Servicerhythmus nicht aus Standplatz stammt->
* diese dürfen natürlich nichtgesichert werden
  WMODE = OBJ-CONTR-WMODE.
  read table OBJ-IROBJ_TAB with key OBJNR = WEWATAB-EWAOBJ-OBJNR
             into WROBJ_TAB.
  if WROBJ_TAB-SLOC_USE = 'X'.
    WMODE = CO_DISPLAY.
  endif.
  call function 'ISU_OPVALUE_MAINTAIN'
    exporting
      X_OBJTYPE     = CO_OBJ_INSTLN
      X_WMODE       = WMODE
      X_OPKEY       = OPKEY
      X_IAKLASSE    = IAKLASSE
      X_IRATECAT    = IRATECAT
      X_MIN_DATE    = MIN_DATE
      X_MAX_DATE    = MAX_DATE
    tables
      T_OPHIST      = T_OPHIST
      T_COMP_OPHIST = T_COMP_OPHIST.

* Falls Daten geändert wurden so müssen diese nun übernommen werden
  if T_OPHIST <> T_COMP_OPHIST.
    loop at WEWATAB-EWAOBJH_AAT into IAAT
      where AAT-OBJNR  = LS_OUTTAB-OBJNR
      and AAT-LAUFNR   = LS_OUTTAB-LAUFNR
      and AAT-BILLTYPE = LS_OUTTAB-BILLTYPE
      and AAT-VERTRAG  = LS_OUTTAB-VERTRAG.
      exit.
    endloop.              " wewatab-ewaobjh_aat
    if SY-SUBRC = 0.
      loop at T_OPHIST into W_OPHIST.
*     es darf kein Eintrag ohne Preisschlüssel abgespeichert werden
        if W_OPHIST-STRING1 is initial.
          MAC_MSG_PUTX CO_MSG_INFORMATION '489' 'EWA'
                       W_OPHIST-AB W_OPHIST-BIS SPACE SPACE SPACE.
          if 1 = 2. message E489(EWA). endif.           "#EC MG_PAR_CNT
          exit.
        endif.
        move-corresponding W_OPHIST to WAATHIST.
*       den alten Preisschlüssel merken
        read table T_COMP_OPHIST into W_OPHIST2
        with key BIS = W_OPHIST-BIS.
        if SY-SUBRC = 0
        and W_OPHIST-STRING1 <> W_OPHIST2-STRING1.
          W_OPHIST-STRING2 = W_OPHIST2-STRING1.
        endif.
        WAATHIST-OBJNR = LS_OUTTAB-OBJNR.
        WAATHIST-LAUFNR = LS_OUTTAB-LAUFNR.
        WAATHIST-BILLTYPE = LS_OUTTAB-BILLTYPE.
        WAATHIST-OPERAND = LS_OUTTAB-OPERAND.
        WAATHIST-SERVICE_TYPE = LS_OUTTAB-SERVICE_TYPE.
        WAATHIST-VERTRAG = LS_OUTTAB-VERTRAG.
        read table IAAT-AAT_HIST
        with key OBJNR = WAATHIST-OBJNR
                 LAUFNR = WAATHIST-LAUFNR
                 BILLTYPE = WAATHIST-BILLTYPE
                 VERTRAG = WAATHIST-VERTRAG
                 AB = WAATHIST-AB
                 OPERAND = WAATHIST-OPERAND
                 transporting no fields.
        if SY-SUBRC = 0.
          modify IAAT-AAT_HIST index SY-TABIX from WAATHIST .
        else.
          append WAATHIST to IAAT-AAT_HIST.
        endif.
      endloop.                " t_ophist
      modify WEWATAB-EWAOBJH_AAT from IAAT
      transporting AAT_HIST
      where AAT-OBJNR  = LS_OUTTAB-OBJNR
      and AAT-LAUFNR   = LS_OUTTAB-LAUFNR
      and AAT-BILLTYPE = LS_OUTTAB-BILLTYPE
      and AAT-VERTRAG  = LS_OUTTAB-VERTRAG.
    else.
      IAAT-AAT-OBJNR = LS_OUTTAB-OBJNR.
      IAAT-AAT-LAUFNR = LS_OUTTAB-LAUFNR.
      IAAT-AAT-BILLTYPE = LS_OUTTAB-BILLTYPE.
      IAAT-AAT-VERTRAG = LS_OUTTAB-VERTRAG.
      loop at T_OPHIST into W_OPHIST.
*     es darf kein Eintrag ohne Preisschlüssel abgespeichert werden
        if W_OPHIST-STRING1 is initial.
          MAC_MSG_PUTX CO_MSG_INFORMATION '489' 'EWA'
                       W_OPHIST-AB W_OPHIST-BIS SPACE SPACE SPACE.
          if 1 = 2. message E489(EWA). endif.           "#EC MG_PAR_CNT
          exit.
        endif.
        read table T_COMP_OPHIST
        with key STRING1 = W_OPHIST-STRING1
                 AB = W_OPHIST-AB
                 BIS = W_OPHIST-BIS
                 transporting no fields.
        check SY-SUBRC <> 0.
*       den alten Preisschlüssel merken
        read table T_COMP_OPHIST into W_OPHIST2
        with key BIS = W_OPHIST-BIS.
        if SY-SUBRC = 0
        and W_OPHIST-STRING1 <> W_OPHIST2-STRING1.
          W_OPHIST-STRING2 = W_OPHIST2-STRING1.
        endif.
        move-corresponding W_OPHIST to WAATHIST.
        WAATHIST-OBJNR = LS_OUTTAB-OBJNR.
        WAATHIST-LAUFNR = LS_OUTTAB-LAUFNR.
        WAATHIST-BILLTYPE = LS_OUTTAB-BILLTYPE.
        WAATHIST-OPERAND = LS_OUTTAB-OPERAND.
        WAATHIST-SERVICE_TYPE = LS_OUTTAB-SERVICE_TYPE.
        WAATHIST-VERTRAG = LS_OUTTAB-VERTRAG.
        append WAATHIST to IAAT-AAT_HIST.
      endloop.                " t_ophist
      append IAAT to WEWATAB-EWAOBJH_AAT.
    endif.                  " sy-subrc = 0
    modify OBJ-EWATAB from WEWATAB
    transporting EWAOBJH_AAT
    where EWAOBJ-OBJNR = LS_OUTTAB-OBJNR.
  endif.

endform.                    " opvalue_maintain
*&---------------------------------------------------------------------*
*&      Form  grid_group_init
*&---------------------------------------------------------------------*
form GRID_GROUP_INIT changing PT_GROUP type LVC_T_SGRP.

  data LS_GROUP type LVC_S_SGRP.

  clear PT_GROUP.

* 1. Sortierschlüssel = Objektname
  clear LS_GROUP.
  LS_GROUP-SP_GROUP = '0001'.
  LS_GROUP-TEXT     = text-S64.
  append LS_GROUP to PT_GROUP.
* 2. Sortierschlüssel = Leistungsart
  clear LS_GROUP.
  LS_GROUP-SP_GROUP = '0001'.
  LS_GROUP-TEXT     = text-S65.
  append LS_GROUP to PT_GROUP.
* 3. Sortierschlüssel = AAT
  clear LS_GROUP.
  LS_GROUP-SP_GROUP = '0001'.
  LS_GROUP-TEXT     = text-S66.
  append LS_GROUP to PT_GROUP.
* 4. Sortierschlüssel = Operand
  clear LS_GROUP.
  LS_GROUP-SP_GROUP = '0001'.
  LS_GROUP-TEXT     = text-S67.
  append LS_GROUP to PT_GROUP.

endform.                    " grid_group_init
*&---------------------------------------------------------------------*
*&      Form  get_billing_data
*&---------------------------------------------------------------------*
form GET_BILLING_DATA.

  data: T_AAT_HIST   type ISUWA_AAT_HIST,
        IDATACOL     type ISU2A_DATA_COLLECTOR,
        BILLINGRUNNO type ERCH-BILLINGRUNNO,
        IEVER        type T_EVER,
        IELOCSD      type ISUWA_EWAELOCSDALL,
        LS_CONTRACT  type EVER-VERTRAG,
        VERTRAG      type EVER-VERTRAG,
        WA_TSL       type ISU_ROBJ_TSL,
        AB           type SY-DATUM,
        CANCELLED    type REGEN-KENNZX,
        ERROR(1).

  data: YEAR        type I,
        ACTUAL_DATE type DATS,
        NEW_DATE    type SY-DATUM.

* Ab-Datum für Abrechnungsbaustein setzen
  sort OBJ-IROBJ_TSL by OBJNR LAUFNR AB.
  read table OBJ-IROBJ_TSL into WA_TSL
  with key OBJNR = OBJ-WA_TSL-OBJNR
           LAUFNR = OBJ-WA_TSL-LAUFNR.
  if SY-SUBRC = 0.
    AB = WA_TSL-AB.
  else.
    if OBJ-WA_TSL is initial.
      read table OBJ-IROBJ_TSL index 1 into OBJ-WA_TSL.
    endif.
    AB = OBJ-WA_TSL-AB.
  endif.
  EWAOBJD-SELAB = AB.
  ACTUAL_DATE = AB.
  YEAR = EWAOBJD-SELAB+0(4).
  YEAR = YEAR + 1.
  ACTUAL_DATE+0(4) = YEAR.
  EWAOBJD-SELBIS = ACTUAL_DATE.

  call screen 195 starting at 5 15.
  check EXIT_TYPE <> CO_CANC.

* Bis-Datum für Abrechnungsbaustein setzen
  AB = EWAOBJD-SELAB.
  NEW_DATE = EWAOBJD-SELBIS.
  if EWAOBJD-SELAB is initial
  or EWAOBJD-SELBIS is initial.
    exit.
  endif.


*********************************************************************
******************** START APPLICATION LOG **************************
*********************************************************************
  clear ERROR.
* create a log where all message should be added to
  CL_EEWA_RCI_RO=>LOG_CREATE(
                    exporting I_OBJNR = EWAOBJD-OBJNR
                              I_OBJECT = CO_APPL_LOG_WASTE_BILL
                              I_SUBOBJ = 'INFO'
                    importing E_LOGHANDLE = LOG_HANDLE   ).

* PERFORM log_create USING co_appl_log_waste_bill 'INFO'.

* Add information that this is a check for adding service frequency
* data
  CL_EEWA_RCI_RO=>MSG_ADD_FREE_TEXT( I_LOGHANDLE = LOG_HANDLE
                                     I_TEXT      = text-015 ).

*   Individuelle abrechnungsdaten besorgen
  if not EWAOBJD-SERVLOC is initial.
* ->Falls der Behälter einem Standplatz zugeordnet ist, muss
*   zuerst überprüft werden, ob es mehrere Kunden (Verträge) gibt,
*   die sich den Behälter teilen
    perform GET_SERVLOC_CONTRACTS changing IEVER
                                           ERROR
                                           OBJ-IVEGER
                                           IELOCSD.
    if ERROR is initial and LINES( IEVER[] ) = 0.
      message E477(EWA) with OBJ-WA_TAB-EQUNR OBJ-WA_TAB-SERVLOC
      into G_DUMMY.
      CL_EEWA_RCI_RO=>MSG_ADD( I_PROCL = PROBCLASS_HIGH
                               I_LOGHANDLE = LOG_HANDLE ).
      ERROR = 'X'.
    endif.
    if ERROR is initial.
      perform DISPLAY_CONTRACT_LIST changing LS_CONTRACT
                                             CANCELLED
                                             IEVER.
      if not CANCELLED is initial.
        exit.
      endif.
      perform READ_BILLING_DATA using LS_CONTRACT
                                changing OBJ
                                         ERROR.
    endif.
  else.
    perform READ_BILLING_DATA using EWAOBJD-VERTRAG
                              changing OBJ
                                       ERROR.
  endif.

* Datenbeschaffung der relevanten Abrechnungsdaten über
* ISU_BILLING_CHECK. Der Baustein liefert das komplette
* Datenkonstrukt der Abrechnung mit allen Abgrenzungen zurück
* Wie reagiert der Baustein, falls keine Abrechnungsaufträge
* vorliegen???
  if not LS_CONTRACT is initial.
    VERTRAG = LS_CONTRACT.
  else.
    VERTRAG = EWAOBJD-VERTRAG.
  endif.
  if ERROR is initial.
    BILLINGRUNNO = 100. "!!!!!!!!!!!!!!
    call function 'ISU_WASTE_SIMULATE_PERIOD_BILL'
      exporting
        X_VERTRAG      = VERTRAG
        X_BEGABRPE     = AB
        X_ENDABRPE     = NEW_DATE
        X_BILLINGRUNNO = BILLINGRUNNO
        X_NO_UPDATE    = 'X'
        X_SIMULATION   = 'X'
        X_OBJNR        = OBJ-WA_TSL-OBJNR
      importing
        Y_OBJ          = IBILLDATA
        Y_SOBJ         = IDATACOL
      exceptions
        GENERAL_FAULT  = 1
        others         = 2.
    if SY-SUBRC <> 0.
*     add a simple message to log
      message id SY-MSGID type SY-MSGTY number SY-MSGNO
              with SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4 into G_DUMMY.
      CL_EEWA_RCI_RO=>MSG_ADD( I_PROCL = PROBCLASS_HIGH  I_LOGHANDLE = LOG_HANDLE ).
*     PERFORM msg_add USING probclass_high.
      ERROR = 'X'.
    else.
*     Abrechnungsdaten ins Objekt schreiben
    endif.
  endif.

*********************************************************************
******************** END OF APPLICATION LOG **************************
*********************************************************************
* display log file
  if ERROR = 'X'.
    CL_EEWA_RCI_RO=>LOGDISPLAY( I_LOGHANDLE = LOG_HANDLE ).
*   Nach der Ausgabe des Protokolls kann dieses wieder gelöscht werden
*   und zum Ausgangsbildschirm zurückgekehrt werden.
    OBJ-CONTR-USE_BILL = SPACE.
    clear: GTBILL_OUTTAB,
           GTBILL_FLDCAT,
           GSBILL_LAYOUT,
           GBILL_CONT.
    perform LOG_DELETE.
  else.
    OBJ-CONTR-USE_BILL = 'X'.
*   Mit den gefundenen Daten die Ausgabetabelle füllen
    perform GRID_FILL_BILL_OUTTAB using IDATACOL
                                        NEW_DATE
                                        AB
                                        VERTRAG
                               changing IBILLDATA
                                        GTBILL_OUTTAB.
  endif.
endform.                    " get_billing_data

*&---------------------------------------------------------------------*
*&      Form  check_end_of_billing_period
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form CHECK_END_OF_BILLING_PERIOD changing XY_OBJ type ISUWA_OBJ
                                          WA_TAB type ISU_ROBJ_TABC.

  data: WEWATAB         type ISUWA_OBJ_LINES,
        T_OBJH          type ISUWA_T_EWAOBJH,
        T_NEW_OBJH      type ISUWA_T_EWAOBJH,
        WA_OBJH         type ISUWA_EWAOBJH,
        ISHARE          type ISUWA_T_ALLOC_SHARE,
        WSHARE          type ISUWA_ALLOC_SHARE,
        LEAVE           type KENNZX,
*        SAVE_ANLAGE     type ANLAGE,
*        LAST_ENDABRPE   type ERCH-ENDABRPE,
        L_LAST_ENDABRPE type ERCH-ENDABRPE.
*        PROP_LINES      type ISUWA_PROP_LINES.


*  if not XY_OBJ-ANLAGE is initial.
*    call function 'ISU_BILLING_DATES_FOR_INSTLN'
*      exporting
*        X_ANLAGE          = XY_OBJ-ANLAGE
*      importing
*        Y_LAST_ENDABRPE   = L_LAST_ENDABRPE
*      exceptions
*        NO_CONTRACT_FOUND = 1
*        GENERAL_FAULT     = 2
*        PARAMETER_FAULT   = 3
*        others            = 4.
*    if SY-SUBRC > 1.
*      MAC_MSG_REPEAT CO_MSG_ERROR GENERAL_FAULT.
*    endif.
*  elseif not XY_OBJ-SERVLOC is initial.
** Anlagendaten wurden bereits eingelesen und stehen in
** xy_obj-mdata-ishare
*    ISHARE = XY_OBJ-MDATA-ISHARE.
*    if not WA_TAB-DEVGRP is initial or not WA_TAB-IBASE is initial.
*      loop at ISHARE into WSHARE
*      where not INSTALLATION is initial
*      and BEH_TYPE = WA_TAB-BEH_TYPE
*      and BEHGRP = WA_TAB-DEVGRP
*      and IBASE  = WA_TAB-IBASE .
**      check wshare-installation <> save_anlage.
*        SAVE_ANLAGE = WSHARE-INSTALLATION.
*        call function 'ISU_BILLING_DATES_FOR_INSTLN'
*          exporting
*            X_ANLAGE          = WSHARE-INSTALLATION
*          importing
*            Y_LAST_ENDABRPE   = LAST_ENDABRPE
*          exceptions
*            NO_CONTRACT_FOUND = 1
*            GENERAL_FAULT     = 2
*            PARAMETER_FAULT   = 3
*            others            = 4.
*        if SY-SUBRC > 1.
*          MAC_MSG_REPEAT CO_MSG_ERROR GENERAL_FAULT.
*        else.
**     das größte letzte Abrechungsdatum aller Anlagen ausfindig machen.
**     dies wird zur Abgrenzung des Servicerhythmus herangezogen
*          if LAST_ENDABRPE gt L_LAST_ENDABRPE.
**          and last_endabrpe between wshare-ab and wshare-bis.
*            L_LAST_ENDABRPE = LAST_ENDABRPE.
*          endif.
*        endif.
*      endloop.
*    else.
*      loop at ISHARE into WSHARE
*      where not INSTALLATION is initial
*      and BEH_TYPE = WA_TAB-BEH_TYPE
*      and BEHAELTER = WA_TAB-GERAET.
**        CHECK wshare-installation <> save_anlage.
*        SAVE_ANLAGE = WSHARE-INSTALLATION.
*        call function 'ISU_BILLING_DATES_FOR_INSTLN'
*          exporting
*            X_ANLAGE          = WSHARE-INSTALLATION
*          importing
*            Y_LAST_ENDABRPE   = LAST_ENDABRPE
*          exceptions
*            NO_CONTRACT_FOUND = 1
*            GENERAL_FAULT     = 2
*            PARAMETER_FAULT   = 3
*            others            = 4.
*        if SY-SUBRC > 1.
*          MAC_MSG_REPEAT CO_MSG_ERROR GENERAL_FAULT.
*        else.
**     das größte letzte Abrechungsdatum aller Anlagen ausfindig machen.
**     dies wird zur Abgrenzung des Servicerhythmus herangezogen
*          if LAST_ENDABRPE gt L_LAST_ENDABRPE.
**          and last_endabrpe between wshare-ab and wshare-bis.
*            L_LAST_ENDABRPE = LAST_ENDABRPE.
*          endif.
*        endif.
*      endloop.
*    endif.
*  elseif not XY_OBJ-ROB is initial.
** Anlagendaten wurden bereits eingelesen und stehen in
** xy_obj-mdata-ishare
*    ISHARE = XY_OBJ-MDATA-ISHARE.
*    loop at ISHARE into WSHARE
*    where not INSTALLATION is initial.
**      CHECK wshare-installation <> save_anlage.
*      SAVE_ANLAGE = WSHARE-INSTALLATION.
*      read table XY_OBJ-MDATA-IPROP index 1 into PROP_LINES.
*      check SY-SUBRC = 0.
*      read table PROP_LINES-EEWA_PROP transporting no fields
*      with key ROB = WA_TAB-ROB.
*      call function 'ISU_BILLING_DATES_FOR_INSTLN'
*        exporting
*          X_ANLAGE          = WSHARE-INSTALLATION
*        importing
*          Y_LAST_ENDABRPE   = LAST_ENDABRPE
*        exceptions
*          NO_CONTRACT_FOUND = 1
*          GENERAL_FAULT     = 2
*          PARAMETER_FAULT   = 3
*          others            = 4.
*      if SY-SUBRC > 1.
*        MAC_MSG_REPEAT CO_MSG_ERROR GENERAL_FAULT.
*      else.
**     das größte letzte Abrechungsdatum aller Anlagen ausfindig machen.
**     dies wird zur Abgrenzung des Servicerhythmus herangezogen
*        if LAST_ENDABRPE gt L_LAST_ENDABRPE.
**          and last_endabrpe between wshare-ab and wshare-bis.
*          L_LAST_ENDABRPE = LAST_ENDABRPE.
*        endif.
*      endif.
*    endloop.
*  endif.

  try.
      L_LAST_ENDABRPE = CL_EEWA_RFC_SERVICE_FREQUENCY=>GET_LAST_ABR_DATE(
        changing
          C_OBJ     = XY_OBJ               " Objektdaten des Servicerhythmus
          C_WA_TAB  = WA_TAB               " Struktur für die Technische Kopfdaten des Servicerhythmus
      ).
    catch CX_EEWA_BASE into data(LEX).
      __EXCEPTION_MSGPUTX LEX GENERAL_FAULT.
  endtry.

  check not L_LAST_ENDABRPE is initial.
  WA_TAB-BILLDATE = L_LAST_ENDABRPE.

  if SAVE_OBJ is initial.
    SAVE_OBJ = XY_OBJ-EWATAB[].
  endif.

* falls bereits abgerechnet wurde müssen alle Zeitscheiben der
* Servicerhythmen, die auf dieses Abrechnungsdatum fallen aufgeteilt
* werden
* Bei bereits abgerechneten einmaligen Leistungen wird einfach die
* bestehende Zeitscheibe blockiert
  loop at XY_OBJ-EWATAB[] into WEWATAB
  where EWAOBJ-OBJNR = WA_TAB-OBJNR.
    T_OBJH = WEWATAB-EWAOBJH.
    clear T_NEW_OBJH.
    loop at T_OBJH into WA_OBJH.
      if WA_OBJH-EWAOBJH-DAY_TYPE = CO_DAY_ONCE.
        append WA_OBJH to T_NEW_OBJH.
        continue.
      endif.
      if WA_OBJH-EWAOBJH-AB lt L_LAST_ENDABRPE
      and WA_OBJH-EWAOBJH-BIS gt L_LAST_ENDABRPE.
        perform TIMESLICE_PRORATE using WA_OBJH
                                        L_LAST_ENDABRPE
                                  changing T_NEW_OBJH.
*      "Zwischenspeicher aktualisieren:
*        ->die "veralteten" Informationen werden sonst später in die Arbeitsdaten zurückgeschrieben
        READ TABLE xy_obj-irobj_tsl REFERENCE INTO DATA(lirobj_tsl)
          WITH KEY objnr = wa_objh-ewaobjh-objnr
                   laufnr = wa_objh-ewaobjh-laufnr
                   bis = l_last_endabrpe.
        IF sy-subrc IS INITIAL.
          READ TABLE t_new_objh REFERENCE INTO DATA(lisuwa_ewaobjh)
            WITH KEY ewaobjh-objnr = wa_objh-ewaobjh-objnr
                     ewaobjh-laufnr = wa_objh-ewaobjh-laufnr
                     ewaobjh-bis = l_last_endabrpe.
          IF sy-subrc IS INITIAL.
            "! -AB = wa_objh-ewaobjh-ab = irobj_tsl-ab = t_new_objh-ewaobjh-ab
            MOVE-CORRESPONDING lisuwa_ewaobjh->ewaobjh TO lirobj_tsl->*. "konkret: -TSL_GUID aktualisieren
          ENDIF.
        "ELSE. "->nichts
*         "wenn XY_OBJ-IROBJ_TSL leer ist, nicht befüllen =>wurde falsch oder 'alternativ' geladen
        ENDIF.
      else.
        append WA_OBJH to T_NEW_OBJH.
      endif.
    endloop.
    WEWATAB-EWAOBJH = T_NEW_OBJH.
    modify XY_OBJ-EWATAB[] from WEWATAB.
  endloop.

  SAVE_BILL_OBJ = XY_OBJ-EWATAB[].

endform.                    " check_end_of_billing_period
*&---------------------------------------------------------------------*
*&      Form  timeslice_prorate
*&---------------------------------------------------------------------*
form TIMESLICE_PRORATE using    X_IEWAOBJH type ISUWA_EWAOBJH
                                X_DATE     type SY-DATUM
                       changing T_NEW_OBJH type ISUWA_T_EWAOBJH.

  data: WA_HIST     type EWAOBJH,
        T_HIST      type T_EWAOBJH,
        WA_OBJH     type ISUWA_EWAOBJH,
        PRORATE_DAY type SY-DATUM,
        LTSL_GUID   type WLGUID,
        LEX         type ref to CX_EEWA_BASE.
  field-symbols:
    <WA_DIFFC>    type EWAOBJH_DIFFCULT,
* mkahl (C5095353) - 20080422
    <WA_SEQUENCE> type EWAOBJH_SEQUENCE,
* C5122687
    <WA_DATES>    type EWAOBJH_DATES,
    <WA_UPOS>     type EWAOBJH_UPOS,
    <WA_SHARE>    type EWAOBJH_SDSHARE.

  append X_IEWAOBJH-EWAOBJH to T_HIST.
  WA_OBJH = X_IEWAOBJH.
* Ab dem Tag nach Ende der Abrechnung können wieder Änderungen
* vorgenommen werden
  PRORATE_DAY = X_DATE + 1.

  call function 'ISU_TIMESL_UC_PRORATE'
    exporting
      X_AB_FNAME    = 'AB'
      X_BIS_FNAME   = 'BIS'
      X_PRORATE_DAY = PRORATE_DAY
    tables
      T_TIMESL      = T_HIST
    exceptions
      NOT_NECESSARY = 1
      TABLE_EMPTY   = 2
      NOT_VALID     = 3
      BELOW_LIMIT   = 4
      IN_GAP        = 5
      others        = 6.
  if SY-SUBRC <> 0.
    MAC_MSG_PUTX CO_MSG_ERROR SY-MSGNO SY-MSGID SY-MSGV1
                   SY-MSGV2 SY-MSGV3 SY-MSGV4 SPACE.
  else.
    clear LTSL_GUID.
    sort T_HIST by BIS descending.
    loop at T_HIST into WA_HIST.
      WA_OBJH-EWAOBJH = WA_HIST.
* C5122687 TSL_GUID should not be copied
      read table T_NEW_OBJH transporting no fields with key EWAOBJH-TSL_GUID = WA_OBJH-EWAOBJH-TSL_GUID.
      if SY-SUBRC is initial.
        try.
            LTSL_GUID = CL_SYSTEM_UUID=>CREATE_UUID_C22_STATIC( ).
          catch CX_UUID_ERROR into data(LERROR).
            MAC_MSG_PUTX co_msg_programming_error SPACE SPACE LERROR->ERR_TEXT SPACE SPACE SPACE SPACE.
        endtry.
      else.
        LTSL_GUID = WA_OBJH-EWAOBJH-TSL_GUID.
      endif.
      WA_OBJH-EWAOBJH-TSL_GUID = LTSL_GUID.
      loop at WA_OBJH-EWAOBJH_DIFFCULT assigning <WA_DIFFC>.
        <WA_DIFFC>-BIS = WA_HIST-BIS.
        <WA_DIFFC>-TSL_GUID = LTSL_GUID.
      endloop.
* mkahl (C5095353) - 20080422
      loop at WA_OBJH-EWAOBJH_SEQUENCE assigning <WA_SEQUENCE>.
        <WA_SEQUENCE>-BIS = WA_HIST-BIS.
        <WA_SEQUENCE>-TSL_GUID = LTSL_GUID.
      endloop.
* C5122687
      loop at WA_OBJH-EWAOBJH_DATES assigning <WA_DATES>.
        <WA_DATES>-BIS = WA_HIST-BIS.
        <WA_DATES>-TSL_GUID = LTSL_GUID.
      endloop.
      loop at WA_OBJH-EWAOBJH_UPOS assigning <WA_UPOS>.
        <WA_UPOS>-BIS = WA_HIST-BIS.
        <WA_UPOS>-TSL_GUID = LTSL_GUID.
      endloop.
      loop at WA_OBJH-EWAOBJH_SHARE assigning <WA_SHARE>.
        <WA_SHARE>-BIS = WA_HIST-BIS.
        <WA_SHARE>-TSL_GUID = LTSL_GUID.
      endloop.

      if WA_OBJH-EWAOBJH-STARTDATE is not initial
        and WA_OBJH-EWAOBJH-STARTDATE not between WA_OBJH-EWAOBJH-AB and WA_OBJH-EWAOBJH-BIS.
**** todo: in case of STARTDATE > wa_objh-EWAOBJH-BIS  ---> descission is pending. Exception, no service has to be done. (set inactive? )

        try.
            WA_OBJH-EWAOBJH-STARTDATE = CL_EEWA_RFC_SERVICE_FREQUENCY=>CALCULATE_STARTDATE(
                                          PAR_EWAOBJH  = WA_OBJH-EWAOBJH
                                          PAR_DATE     = WA_OBJH-EWAOBJH-AB
                                        ).
          catch CX_EEWA_BASE into LEX.
            LEX->PUT_SYMSG( ).
            MAC_MSG_PUTX CO_MSG_ERROR SY-MSGNO SY-MSGID
              SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4 SPACE.
        endtry.
      endif.
      append WA_OBJH to T_NEW_OBJH.
    endloop.
  endif.

endform.                    " timeslice_prorate
*&---------------------------------------------------------------------*
*&      Form  check_last_billing_date
*&---------------------------------------------------------------------*
form CHECK_LAST_BILLING_DATE using    X_TSL type ISU_ROBJ_TSL
                             changing WA_TAB type ISU_ROBJ_TABC.

  clear WA_TAB-BILLED.

* Falls Zeitscheibe schon abgerechnet wurde, auf nicht eingabefähig
* setzen
  check not X_TSL-BIS is initial.
  if X_TSL-BIS le WA_TAB-BILLDATE.
    WA_TAB-BILLED = 'X'.
  endif.

endform.                    " check_last_billing_date
*&---------------------------------------------------------------------*
*&      Form  fill_bill_outtab_txt
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form FILL_BILL_OUTTAB_TXT using    X_OBJ type ISUWA_OBJ
                          changing WOUTTAB type ISU_AAT_BILLING_HIST.

  data: STR_LEN(4)    type N,
        STR_LEN2(4)   type N,
        WROBJ         type ISU_ROBJ_TABC,
        WTE221T       type TE221T,
        WSERVICETYPET type TESERVICETYPET,
        WBILLTYPET    type TEWABILLTYPET.

  statics: ITE221T       type TE221T occurs 0,
           ISERVICETYPET type TESERVICETYPET occurs 0,
           IBILLTYPET    type TEWABILLTYPET occurs 0.

*   Bezeichnung des Operanden nachlesen
  read table ITE221T with key OPERAND = WOUTTAB-OPERAND
  into WTE221T.
  if SY-SUBRC <> 0.
    call function 'ISU_DB_TE221T_SINGLE'
      exporting
        X_OPERAND = WOUTTAB-OPERAND
        X_SPRAS   = SY-LANGU
      importing
        Y_TEXT30  = WOUTTAB-TEXT30.
    WTE221T-OPERAND = WOUTTAB-OPERAND.
    WTE221T-TEXT30 = WOUTTAB-TEXT30.
    append WTE221T to ITE221T.
  else.
    WOUTTAB-TEXT30 = WTE221T-TEXT30 .
  endif.

  read table X_OBJ-IROBJ_TAB into WROBJ
                  with key OBJNR  = WOUTTAB-OBJNR.
  check SY-SUBRC = 0.
  if not WROBJ-ROB is initial.
    WOUTTAB-OBJECT_TXT = text-S63.
    STR_LEN2 = STRLEN( WROBJ-ROB ).
    if STR_LEN2 ne 0.
      STR_LEN = STRLEN( WOUTTAB-OBJECT_TXT ).
      write WROBJ-ROB to WOUTTAB-OBJECT_TXT+STR_LEN.
    endif.
  elseif not WROBJ-BEH_TYPE is initial.
    WOUTTAB-OBJECT_TXT = text-S39.
    STR_LEN2 = STRLEN( WROBJ-BEH_TYPE ).
    if STR_LEN2 ne 0.
      STR_LEN = STRLEN( WOUTTAB-OBJECT_TXT ).
      write WROBJ-BEH_TYPE to WOUTTAB-OBJECT_TXT+STR_LEN.
    endif.
    STR_LEN2 = STRLEN( WROBJ-GERAET ).
    if STR_LEN2 ne 0.
      STR_LEN = STRLEN( WOUTTAB-OBJECT_TXT ).
      write ',' to WOUTTAB-OBJECT_TXT+STR_LEN.
      STR_LEN = STR_LEN + 2.
      write WROBJ-GERAET to WOUTTAB-OBJECT_TXT+STR_LEN.
    endif.
  endif.

* Die Textfelder der Leistungsart und des AAT nachlesen
  if not WOUTTAB-BILLTYPE is initial.
    read table IBILLTYPET with key BILLTYPE = WOUTTAB-BILLTYPE
    into WBILLTYPET.
    if SY-SUBRC <> 0.
      call function 'ISU_DB_TEBILLTYPET_SINGLE'
        exporting
          X_BILLTYPE = WOUTTAB-BILLTYPE
          X_SPRAS    = SY-LANGU
        importing
          Y_VTEXT    = WOUTTAB-BILLTYPE_TXT.
      WBILLTYPET-BILLTYPE = WOUTTAB-BILLTYPE.
      WBILLTYPET-VTEXT = WOUTTAB-BILLTYPE_TXT.
      append WBILLTYPET to IBILLTYPET.
    else.
      WOUTTAB-BILLTYPE_TXT = WBILLTYPET-VTEXT.
    endif.
  endif.

  if not WOUTTAB-SERVICE_TYPE is initial.
    read table ISERVICETYPET
    with key SERVICE_TYPE = WOUTTAB-SERVICE_TYPE
    into WSERVICETYPET.
    if SY-SUBRC <> 0.
      call function 'ISU_DB_TESERVICETYPET_SINGLE'
        exporting
          X_SERVTYPE = WOUTTAB-SERVICE_TYPE
          X_SPRAS    = SY-LANGU
        importing
          Y_VTEXT    = WOUTTAB-VTEXT.
      WSERVICETYPET-SERVICE_TYPE = WOUTTAB-SERVICE_TYPE.
      WSERVICETYPET-VTEXT = WOUTTAB-VTEXT.
      append WSERVICETYPET to ISERVICETYPET.
    else.
      WOUTTAB-VTEXT = WSERVICETYPET-VTEXT.
    endif.
  endif.
endform.                    " fill_bill_outtab_txt
*&---------------------------------------------------------------------*
*&      Form  log_delete
*&---------------------------------------------------------------------*
form LOG_DELETE.

  call function 'BAL_LOG_DELETE'
    exporting
      I_LOG_HANDLE  = LOG_HANDLE
    exceptions
      LOG_NOT_FOUND = 1
      others        = 2.
  if SY-SUBRC <> 0.
    message id SY-MSGID type SY-MSGTY number SY-MSGNO
            with SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  endif.

  clear: LOG_HANDLE.

endform.                    " log_delete
*&---------------------------------------------------------------------*
*&      Form  display_contract_list
*&---------------------------------------------------------------------*
form DISPLAY_CONTRACT_LIST changing XY_CONTRACT type EVER-VERTRAG
                                    CANCELLED type KENNZX
                                    IEVER type T_EVER.

* local declarations
  data:
    IOBJKEY type EWMOBJKEY occurs 10 with header line,
    DOMNAME type DFIES-DOMNAME,
    OBJKEY  type SWOTOBJID-OBJKEY,
    IOBJREF type SWC_OBJECT occurs 5 with header line,
    WISEL   type EBASELLIST,
    ISEL    type EBASELLIST occurs 10 with header line,
    RETRY   type EBAGEN-KENNZX,
    WCOLOR  type EBACOLOR,
    SELIND  type SY-TABIX,
    RC      type SY-SUBRC,
    WEVER   type EVER.


* Objekttabelle aufbauen
  loop at IEVER into WEVER.
    clear OBJKEY.
    OBJKEY = WEVER-VERTRAG.
    SWC_CREATE_OBJECT IOBJREF 'ISUCONTRCT' OBJKEY.
    if SY-SUBRC <> 0.
      continue.
    endif.
    append IOBJREF.
  endloop.


  loop at IOBJREF.
    call function 'EBA_OBJECT_PRESENTATION'
      exporting
        X_OBJREF              = IOBJREF
      importing
        Y_OBJTYPE_DESCRIPTION = ISEL-TYPETEXT
        Y_OBJTYPE_COLOR       = WCOLOR
        Y_KEYTEXT             = ISEL-KEYTEXT
        Y_SHORTTEXT           = ISEL-TEXT
      exceptions
        OBJECT_INVALID        = 1
        GENERAL_ERROR         = 2
        others                = 3.
    if SY-SUBRC <> 0.
    endif.
    ISEL-CALLINDEX  = SY-TABIX.
    ISEL-TYPECOLOR  = WCOLOR-COLOR.
    ISEL-TYPEINTSV  = WCOLOR-INTENSIV.
    ISEL-KEYCOLOR   = WCOLOR-COLOR.
    ISEL-KEYINTSV   = WCOLOR-INTENSIV.
    ISEL-TEXTCOLOR  = WCOLOR-COLOR.
    ISEL-TEXTINTSV  = WCOLOR-INTENSIV.
    append ISEL.
  endloop.

  call function 'EBA_SELECTION_LIST'
    exporting
      X_POPUP         = 'X'
      X_SELECT_MODE   = 'S'
      X_HOTSPOT       = 'X'
      X_COMMENT1      = text-T29
      X_SUPPRESS_TYPE = ' '
    importing
      Y_SELECTIND     = SELIND
    tables
      T_SELECTLIST    = ISEL
    exceptions
      CANCELLED       = 1
      others          = 2.

  if SELIND = 0.
    CANCELLED = 'X'.
    exit.
  endif.

  read table ISEL index SELIND into WISEL.

  read table IEVER with key VERTRAG = WISEL-KEYTEXT into WEVER.
  if SY-SUBRC = 0.
    XY_CONTRACT = WEVER-VERTRAG..
    exit.
  endif.

endform.                    " display_contract_list
*&---------------------------------------------------------------------*
*&      Form  read_billing_Data
*&---------------------------------------------------------------------*
form READ_BILLING_DATA using    X_VERTRAG type EVER-VERTRAG
                       changing XY_OBJ type ISUWA_OBJ
                                ERROR type KENNZX.

  data: IAAT     type ISUWA_T_EWAOBJH_AAT,
        IEWAOBJH type ISUWA_EWAOBJH.
  field-symbols:
          <WEWATAB>    type ISUWA_OBJ_LINES.

  loop at XY_OBJ-EWATAB assigning <WEWATAB>
  where EWAOBJ-OBJNR = OBJ-WA_TAB-OBJNR.
    clear <WEWATAB>-EWAOBJH_AAT.
    read table <WEWATAB>-EWAOBJH_AAT index 1 transporting no fields.
    check SY-SUBRC <> 0.
    loop at <WEWATAB>-EWAOBJH into IEWAOBJH.
      clear IAAT.
      at new EWAOBJH-LAUFNR.
        call function 'ISU_DB_EWAOBJH_AAT_ALL'
          exporting
            X_OBJNR       = IEWAOBJH-EWAOBJH-OBJNR
            X_LAUFNR      = IEWAOBJH-EWAOBJH-LAUFNR
            X_VERTRAG     = X_VERTRAG
          importing
            Y_EWAOBJH_AAT = IAAT
          exceptions
            NOT_FOUND     = 1
            SYSTEM_ERROR  = 2
            others        = 3.
        if SY-SUBRC > 2.
          message id SY-MSGID type SY-MSGTY number SY-MSGNO
                with SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4 into G_DUMMY.
          CL_EEWA_RCI_RO=>MSG_ADD( I_PROCL = PROBCLASS_HIGH
                                   I_LOGHANDLE = LOG_HANDLE ).
*          PERFORM msg_add USING probclass_high.
          ERROR = 'X'.
        elseif SY-SUBRC = 0.
          insert lines of IAAT into table <WEWATAB>-EWAOBJH_AAT.
*         Daten merken, um Veränderungen zu registrieren
          insert lines of IAAT into table <WEWATAB>-DB_EWAOBJH_AAT.
        endif.
      endat.
    endloop.
  endloop.                    "obj-ewatab

endform.                    " read_billing_Data
*&---------------------------------------------------------------------*
*&      Form  get_servloc_contracts
*&---------------------------------------------------------------------*
form GET_SERVLOC_CONTRACTS changing IEVER type T_EVER
                                    ERROR  type KENNZX
                                    IVEGER type T_EWACONTAINER
                                    IELOCSD type ISUWA_EWAELOCSDALL.

  data: WEWACONTAINER type EWACONTAINER,
        SLOC_OBJ      type ISUWA_SERVLOC,
        VFILL         type SY-TFILL,
        SDFILL        type SY-TFILL.

  loop at IVEGER into WEWACONTAINER where EQUNR  = OBJ-WA_TAB-EQUNR
                                     or ( ( DEVGRP = OBJ-WA_TAB-DEVGRP and DEVGRP is not initial )
                                      and ( IBASE  = OBJ-WA_TAB-IBASE and IBASE is not initial ) )
                                      and AB    le OBJ-WA_TAB-BIS
                                      and BIS   ge OBJ-WA_TAB-AB.
    exit.
  endloop.

***
  call function 'ISU_SERVLOC_GET_CUSTOMER_DATA'
    exporting
*     x_v_eger       = wewacontainer
      X_MATNR        = WEWACONTAINER-MATNR
      X_SERNR        = WEWACONTAINER-GERAET
      X_DEVGRP       = WEWACONTAINER-DEVGRP
      X_IBASE        = WEWACONTAINER-IBASE
      X_DEVLOC       = WEWACONTAINER-DEVLOC
      X_AB           = WEWACONTAINER-AB
      X_BIS          = WEWACONTAINER-BIS
    changing
      XY_OBJ         = SLOC_OBJ
      XY_IEVER       = IEVER
    exceptions
      INTERNAL_ERROR = 1
      others         = 2.
  if SY-SUBRC <> 0.
    CL_EEWA_RCI_RO=>MSG_ADD( I_PROCL = PROBCLASS_HIGH
                                   I_LOGHANDLE = LOG_HANDLE ).
*   PERFORM msg_add USING probclass_high.
    ERROR = 'X'.
  endif.
  describe table IEVER lines VFILL.
  describe table SLOC_OBJ-MDATA-IELOCSD lines SDFILL.
  IELOCSD = SLOC_OBJ-MDATA-IELOCSD.
  add VFILL to SDFILL.
  if SDFILL = 0.
    message E465(EWA) with OBJ-WA_TAB-EQUNR OBJ-WA_TAB-SERVLOC
    into G_DUMMY.
    CL_EEWA_RCI_RO=>MSG_ADD( I_PROCL = PROBCLASS_HIGH
                                   I_LOGHANDLE = LOG_HANDLE ).
*    PERFORM msg_add USING probclass_high.
    ERROR = 'X'.
  endif.

endform.                    " get_servloc_contracts