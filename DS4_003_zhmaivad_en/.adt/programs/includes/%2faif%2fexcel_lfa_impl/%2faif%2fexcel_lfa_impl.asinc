*&---------------------------------------------------------------------*
*&  Include           /AIF/EXCEL_LFA_IMPL
*&---------------------------------------------------------------------*
*CLASS lcl_helper IMPLEMENTATION.
*
*  METHOD constructor.
*
*  ENDMETHOD.                    "constructor
*
*  METHOD browse_local_file_open.
*    "IMPORTING
*    "  iv_title              TYPE string
*    "  iv_filename           TYPE string
*    "  iv_extpattern          TYPE string
*    "RETURNING
*    "  value(rv_filename)    TYPE string,
*
*    DATA:
*      lt_files              TYPE filetable,
*      ls_file               TYPE file_table,
*      lv_rc                 TYPE i,
*      lv_user_action        TYPE i.
*
*    CLEAR lt_files.
*    CLEAR lv_rc.
*    CLEAR lv_user_action.
*    cl_gui_frontend_services=>file_open_dialog(
*      EXPORTING
*        window_title            = iv_title
*        default_extension       = ''
*        default_filename        = iv_filename
*        file_filter             = iv_extpattern
*      CHANGING
*        file_table              = lt_files
*        rc                      = lv_rc
*        user_action             = lv_user_action
*      EXCEPTIONS
*        file_open_dialog_failed = 1
*        cntl_error              = 2
*        error_no_gui            = 3
*        not_supported_by_gui    = 4
*        OTHERS                  = 5 ).
*    IF sy-subrc <> 0.
*      RETURN.
*    ENDIF.
*    IF lv_rc < 1.
*      RETURN.
*    ENDIF.
*    IF lv_user_action <> cl_gui_frontend_services=>action_ok.
*      RETURN.
*    ENDIF.
*    CLEAR ls_file.
*    READ TABLE lt_files INDEX 1 INTO ls_file.
*    rv_filename = ls_file-filename.
*
*  ENDMETHOD.                    "BROWSE_LOCAL_FILE_OPEN
*
*  METHOD string_to_xstring.
*    "IMPORTING
*    "  iv_input              TYPE string
*    "RETURNING
*    "  value(rv_output)      TYPE xstring,
*
*    DATA:
*      conv TYPE REF TO cl_abap_conv_out_ce.
*
*    conv = cl_abap_conv_out_ce=>create( ).
*    conv->convert( EXPORTING
*                     data   = iv_input
*                   IMPORTING
*                     buffer = rv_output ).
*
*  ENDMETHOD.                    "STRING_TO_XSTRING
*
*ENDCLASS.                    "lcl_Helper IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_default_xml IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_default_xml IMPLEMENTATION.

  METHOD string_to_xstring.
    "IMPORTING
    "  iv_input              TYPE string
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      conv TYPE REF TO cl_abap_conv_out_ce.

    conv = cl_abap_conv_out_ce=>create( ).
    conv->convert( EXPORTING
                     data   = iv_input
                   IMPORTING
                     buffer = rv_output ).

  ENDMETHOD.                    "STRING_TO_XSTRING

  METHOD get_default_rels.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                                       '
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">                          '
      '  <Relationship Id="rId3"                                                                                     '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties"'
      '                Target="docProps/app.xml"/>                                                                   '
      '  <Relationship Id="rId2"                                                                                     '
      '                Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties"  '
      '                Target="docProps/core.xml"/>                                                                  '
      '  <Relationship Id="rId1"                                                                                     '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument"     '
      '                Target="xl/workbook.xml"/>                                                                    '
      '</Relationships>                                                                                              '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).
  ENDMETHOD.                    "get_default_rels

  METHOD get_default_app.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                      '
      '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"'
      '            xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"> '
      '  <Application>Microsoft Excel</Application>                                                 '
      '  <DocSecurity>0</DocSecurity>                                                               '
      '  <ScaleCrop>false</ScaleCrop>                                                               '
      '  <HeadingPairs>                                                                             '
      '    <vt:vector size="2"                                                                      '
      '               baseType="variant">                                                           '
      '      <vt:variant>                                                                           '
      '        <vt:lpstr>Worksheets</vt:lpstr>                                                      '
      '      </vt:variant>                                                                          '
      '      <vt:variant>                                                                           '
      '        <vt:i4>1</vt:i4>                                                                     '
      '      </vt:variant>                                                                          '
      '    </vt:vector>                                                                             '
      '  </HeadingPairs>                                                                            '
      '  <TitlesOfParts>                                                                            '
      '    <vt:vector size="1"                                                                      '
      '               baseType="lpstr">                                                             '
      '      <vt:lpstr>Sheet1</vt:lpstr>                                                            '
      '    </vt:vector>                                                                             '
      '  </TitlesOfParts>                                                                           '
      '  <Company>SAP</Company>                                                                     '
      '  <LinksUpToDate>false</LinksUpToDate>                                                       '
      '  <SharedDoc>false</SharedDoc>                                                               '
      '  <HyperlinksChanged>false</HyperlinksChanged>                                               '
      '  <AppVersion>14.0300</AppVersion>                                                           '
      '</Properties>                                                                                '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_app

  METHOD get_default_app_2.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                      '
      '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"'
      '            xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"> '
      '  <Application>Microsoft Excel</Application>                                                 '
      '  <DocSecurity>0</DocSecurity>                                                               '
      '  <ScaleCrop>false</ScaleCrop>                                                               '
      '  <HeadingPairs>                                                                             '
      '    <vt:vector size="2"                                                                      '
      '               baseType="variant">                                                           '
      '      <vt:variant>                                                                           '
      '        <vt:lpstr>Worksheets</vt:lpstr>                                                      '
      '      </vt:variant>                                                                          '
      '      <vt:variant>                                                                           '
      '        <vt:i4>2</vt:i4>                                                                     '
      '      </vt:variant>                                                                          '
      '    </vt:vector>                                                                             '
      '  </HeadingPairs>                                                                            '
      '  <TitlesOfParts>                                                                            '
      '    <vt:vector size="0"                                                                      '
      '               baseType="lpstr">                                                             '
      '    </vt:vector>                                                                             '
      '  </TitlesOfParts>                                                                           '
      '  <Company>SAP</Company>                                                                     '
      '  <LinksUpToDate>false</LinksUpToDate>                                                       '
      '  <SharedDoc>false</SharedDoc>                                                               '
      '  <HyperlinksChanged>false</HyperlinksChanged>                                               '
      '  <AppVersion>14.0300</AppVersion>                                                           '
      '</Properties>                                                                                '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_app

  METHOD get_default_content_types.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                               '
      '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">                          '
      '  <Default Extension="rels"                                                                           '
      '           ContentType="application/vnd.openxmlformats-package.relationships+xml"/>                   '
      '  <Default Extension="xml"                                                                            '
      '           ContentType="application/xml"/>                                                            '
      '  <Override PartName="/xl/workbook.xml"                                                               '
      '            ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>'
      '  <Override PartName="/xl/worksheets/sheet1.xml"                                                      '
      '            ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/> '
      '  <Override PartName="/xl/theme/theme1.xml"                                                           '
      '            ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>                   '
      '  <Override PartName="/xl/styles.xml"                                                                 '
      '            ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>    '
      '  <Override PartName="/docProps/core.xml"                                                             '
      '            ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>                '
      '  <Override PartName="/docProps/app.xml"                                                              '
      '            ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>     '
      '</Types>                                                                                              '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_content_types

  METHOD get_default_content_types_2.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                                  '
      '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">                             '
      '  <Default Extension="rels"                                                                              '
      '           ContentType="application/vnd.openxmlformats-package.relationships+xml"/>                      '
      '  <Default Extension="xml"                                                                               '
      '           ContentType="application/xml"/>                                                               '
      '  <Override PartName="/xl/workbook.xml"                                                                  '
      '            ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>   '
      '  <Override PartName="/xl/theme/theme1.xml"                                                              '
      '            ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>                      '
      '  <Override PartName="/xl/styles.xml"                                                                    '
      '            ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>       '
      '  <Override PartName="/docProps/core.xml"                                                                '
      '            ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>                   '
      '  <Override PartName="/docProps/app.xml"                                                                 '
      '            ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>        '
      '  <Override PartName="/xl/sharedStrings.xml"                                                             '
      '            ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>'
      '</Types>                                                                                                 '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_content_types_2
  METHOD get_default_core.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                              '
      '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"'
      '                   xmlns:dc="http://purl.org/dc/elements/1.1/"                                       '
      '                   xmlns:dcterms="http://purl.org/dc/terms/"                                         '
      '                   xmlns:dcmitype="http://purl.org/dc/dcmitype/"                                     '
      '                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">                            '
      '  <dc:creator>Wode, Heiko</dc:creator>                                                               '
      '  <cp:lastModifiedBy>Wode, Heiko</cp:lastModifiedBy>                                                 '
      '  <dcterms:created xsi:type="dcterms:W3CDTF">2015-02-16T12:03:22Z</dcterms:created>                  '
      '  <dcterms:modified xsi:type="dcterms:W3CDTF">2015-02-16T12:04:00Z</dcterms:modified>                '
      '</cp:coreProperties>                                                                                 '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_core

  METHOD get_default_sheet.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                 '
      '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"            '
      '           xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"'
      '           xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"       '
      '           mc:Ignorable="x14ac"                                                         '
      '           xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">   '
      '  <dimension ref="A1"/>                                                                 '
      '  <sheetViews>                                                                          '
      '    <sheetView tabSelected="1"                                                          '
      '               workbookViewId="0"/>                                                     '
      '  </sheetViews>                                                                         '
      '  <sheetFormatPr defaultRowHeight="15"                                                  '
      '                 x14ac:dyDescent="0.25"/>                                               '
      '  <sheetData/>                                                                          '
      '  <pageMargins left="0.7"                                                               '
      '               right="0.7"                                                              '
      '               top="0.75"                                                               '
      '               bottom="0.75"                                                            '
      '               header="0.3"                                                             '
      '               footer="0.3"/>                                                           '
      '</worksheet>                                                                            '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_sheet

  METHOD get_default_shared_str.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>               '
      '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"'
      '     count="0"                                                        '
      '    uniqueCount="0">                                                  '
      '</sst>                                                                '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).


  ENDMETHOD.                    "get_default_shared_str

  METHOD get_default_styles.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                               '
      '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"         '
      '            xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    '
      '            mc:Ignorable="x14ac"                                                      '
      '            xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'
      '  <fonts count="1"                                                                    '
      '         x14ac:knownFonts="1">                                                        '
      '    <font>                                                                            '
      '      <sz val="11"/>                                                                  '
      '      <color theme="1"/>                                                              '
      '      <name val="Calibri"/>                                                           '
      '      <family val="2"/>                                                               '
      '      <scheme val="minor"/>                                                           '
      '    </font>                                                                           '
      '  </fonts>                                                                            '
      '  <fills count="2">                                                                   '
      '    <fill>                                                                            '
      '      <patternFill patternType="none"/>                                               '
      '    </fill>                                                                           '
      '    <fill>                                                                            '
      '      <patternFill patternType="gray125"/>                                            '
      '    </fill>                                                                           '
      '  </fills>                                                                            '
      '  <borders count="1">                                                                 '
      '    <border>                                                                          '
      '      <left/>                                                                         '
      '      <right/>                                                                        '
      '      <top/>                                                                          '
      '      <bottom/>                                                                       '
      '      <diagonal/>                                                                     '
      '    </border>                                                                         '
      '  </borders>                                                                          '
      '  <cellStyleXfs count="1">                                                            '
      '    <xf numFmtId="0"                                                                  '
      '        fontId="0"                                                                    '
      '        fillId="0"                                                                    '
      '        borderId="0"/>                                                                '
      '  </cellStyleXfs>                                                                     '
      '  <cellXfs count="1">                                                                 '
      '    <xf numFmtId="0"                                                                  '
      '        fontId="0"                                                                    '
      '        fillId="0"                                                                    '
      '        borderId="0"                                                                  '
      '        xfId="0"/>                                                                    '
      '  </cellXfs>                                                                          '
      '  <cellStyles count="1">                                                              '
      '    <cellStyle name="Normal"                                                          '
      '               xfId="0"                                                               '
      '               builtinId="0"/>                                                        '
      '  </cellStyles>                                                                       '
      '  <dxfs count="0"/>                                                                   '
      '  <tableStyles count="0"                                                              '
      '               defaultTableStyle="TableStyleMedium2"                                  '
      '               defaultPivotStyle="PivotStyleLight16"/>                                '
      '  <extLst>                                                                            '
      '    <ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}"                                 '
      '         xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main">   '
      '      <x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/>                      '
      '    </ext>                                                                            '
      '  </extLst>                                                                           '
      '</styleSheet>                                                                         '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_styles

  METHOD get_default_themes.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                 '
      '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"'
      '         name="Office Theme">                                           '
      '  <a:themeElements>                                                     '
      '    <a:clrScheme name="Office">                                         '
      '      <a:dk1>                                                           '
      '        <a:sysClr val="windowText"                                      '
      '                  lastClr="000000"/>                                    '
      '      </a:dk1>                                                          '
      '      <a:lt1>                                                           '
      '        <a:sysClr val="window"                                          '
      '                  lastClr="FFFFFF"/>                                    '
      '      </a:lt1>                                                          '
      '      <a:dk2>                                                           '
      '        <a:srgbClr val="1F497D"/>                                       '
      '      </a:dk2>                                                          '
      '      <a:lt2>                                                           '
      '        <a:srgbClr val="EEECE1"/>                                       '
      '      </a:lt2>                                                          '
      '      <a:accent1>                                                       '
      '        <a:srgbClr val="4F81BD"/>                                       '
      '      </a:accent1>                                                      '
      '      <a:accent2>                                                       '
      '        <a:srgbClr val="C0504D"/>                                       '
      '      </a:accent2>                                                      '
      '      <a:accent3>                                                       '
      '        <a:srgbClr val="9BBB59"/>                                       '
      '      </a:accent3>                                                      '
      '      <a:accent4>                                                       '
      '        <a:srgbClr val="8064A2"/>                                       '
      '      </a:accent4>                                                      '
      '      <a:accent5>                                                       '
      '        <a:srgbClr val="4BACC6"/>                                       '
      '      </a:accent5>                                                      '
      '      <a:accent6>                                                       '
      '        <a:srgbClr val="F79646"/>                                       '
      '      </a:accent6>                                                      '
      '      <a:hlink>                                                         '
      '        <a:srgbClr val="0000FF"/>                                       '
      '      </a:hlink>                                                        '
      '      <a:folHlink>                                                      '
      '        <a:srgbClr val="800080"/>                                       '
      '      </a:folHlink>                                                     '
      '    </a:clrScheme>                                                      '
      '    <a:fontScheme name="Office">                                        '
      '      <a:majorFont>                                                     '
      '        <a:latin typeface="Cambria"/>                                   '
      '        <a:ea typeface=""/>                                             '
      '        <a:cs typeface=""/>                                             '
      '        <a:font script="Jpan"                                           '
      '                typeface="ＭＳ Ｐゴシック"/>                                   '
      '        <a:font script="Hang"                                           '
      '                typeface="맑은 고딕"/>                                      '
      '        <a:font script="Hans"                                           '
      '                typeface="宋体"/>                                         '
      '        <a:font script="Hant"                                           '
      '                typeface="新細明體"/>                                       '
      '        <a:font script="Arab"                                           '
      '                typeface="Times New Roman"/>                            '
      '        <a:font script="Hebr"                                           '
      '                typeface="Times New Roman"/>                            '
      '        <a:font script="Thai"                                           '
      '                typeface="Tahoma"/>                                     '
      '        <a:font script="Ethi"                                           '
      '                typeface="Nyala"/>                                      '
      '        <a:font script="Beng"                                           '
      '                typeface="Vrinda"/>                                     '
      '        <a:font script="Gujr"                                           '
      '                typeface="Shruti"/>                                     '
      '        <a:font script="Khmr"                                           '
      '                typeface="MoolBoran"/>                                  '
      '        <a:font script="Knda"                                           '
      '                typeface="Tunga"/>                                      '
      '        <a:font script="Guru"                                           '
      '                typeface="Raavi"/>                                      '
      '        <a:font script="Cans"                                           '
      '                typeface="Euphemia"/>                                   '
      '        <a:font script="Cher"                                           '
      '                typeface="Plantagenet Cherokee"/>                       '
      '        <a:font script="Yiii"                                           '
      '                typeface="Microsoft Yi Baiti"/>                         '
      '        <a:font script="Tibt"                                           '
      '                typeface="Microsoft Himalaya"/>                         '
      '        <a:font script="Thaa"                                           '
      '                typeface="MV Boli"/>                                    '
      '        <a:font script="Deva"                                           '
      '                typeface="Mangal"/>                                     '
      '        <a:font script="Telu"                                           '
      '                typeface="Gautami"/>                                    '
      '        <a:font script="Taml"                                           '
      '                typeface="Latha"/>                                      '
      '        <a:font script="Syrc"                                           '
      '                typeface="Estrangelo Edessa"/>                          '
      '        <a:font script="Orya"                                           '
      '                typeface="Kalinga"/>                                    '
      '        <a:font script="Mlym"                                           '
      '                typeface="Kartika"/>                                    '
      '        <a:font script="Laoo"                                           '
      '                typeface="DokChampa"/>                                  '
      '        <a:font script="Sinh"                                           '
      '                typeface="Iskoola Pota"/>                               '
      '        <a:font script="Mong"                                           '
      '                typeface="Mongolian Baiti"/>                            '
      '        <a:font script="Viet"                                           '
      '                typeface="Times New Roman"/>                            '
      '        <a:font script="Uigh"                                           '
      '                typeface="Microsoft Uighur"/>                           '
      '        <a:font script="Geor"                                           '
      '                typeface="Sylfaen"/>                                    '
      '      </a:majorFont>                                                    '
      '      <a:minorFont>                                                     '
      '        <a:latin typeface="Calibri"/>                                   '
      '        <a:ea typeface=""/>                                             '
      '        <a:cs typeface=""/>                                             '
      '        <a:font script="Jpan"                                           '
      '                typeface="ＭＳ Ｐゴシック"/>                                   '
      '        <a:font script="Hang"                                           '
      '                typeface="맑은 고딕"/>                                      '
      '        <a:font script="Hans"                                           '
      '                typeface="宋体"/>                                         '
      '        <a:font script="Hant"                                           '
      '                typeface="新細明體"/>                                       '
      '        <a:font script="Arab"                                           '
      '                typeface="Arial"/>                                      '
      '        <a:font script="Hebr"                                           '
      '                typeface="Arial"/>                                      '
      '        <a:font script="Thai"                                           '
      '                typeface="Tahoma"/>                                     '
      '        <a:font script="Ethi"                                           '
      '                typeface="Nyala"/>                                      '
      '        <a:font script="Beng"                                           '
      '                typeface="Vrinda"/>                                     '
      '        <a:font script="Gujr"                                           '
      '                typeface="Shruti"/>                                     '
      '        <a:font script="Khmr"                                           '
      '                typeface="DaunPenh"/>                                   '
      '        <a:font script="Knda"                                           '
      '                typeface="Tunga"/>                                      '
      '        <a:font script="Guru"                                           '
      '                typeface="Raavi"/>                                      '
      '        <a:font script="Cans"                                           '
      '                typeface="Euphemia"/>                                   '
      '        <a:font script="Cher"                                           '
      '                typeface="Plantagenet Cherokee"/>                       '
      '        <a:font script="Yiii"                                           '
      '                typeface="Microsoft Yi Baiti"/>                         '
      '        <a:font script="Tibt"                                           '
      '                typeface="Microsoft Himalaya"/>                         '
      '        <a:font script="Thaa"                                           '
      '                typeface="MV Boli"/>                                    '
      '        <a:font script="Deva"                                           '
      '                typeface="Mangal"/>                                     '
      '        <a:font script="Telu"                                           '
      '                typeface="Gautami"/>                                    '
      '        <a:font script="Taml"                                           '
      '                typeface="Latha"/>                                      '
      '        <a:font script="Syrc"                                           '
      '                typeface="Estrangelo Edessa"/>                          '
      '        <a:font script="Orya"                                           '
      '                typeface="Kalinga"/>                                    '
      '        <a:font script="Mlym"                                           '
      '                typeface="Kartika"/>                                    '
      '        <a:font script="Laoo"                                           '
      '                typeface="DokChampa"/>                                  '
      '        <a:font script="Sinh"                                           '
      '                typeface="Iskoola Pota"/>                               '
      '        <a:font script="Mong"                                           '
      '                typeface="Mongolian Baiti"/>                            '
      '        <a:font script="Viet"                                           '
      '                typeface="Arial"/>                                      '
      '        <a:font script="Uigh"                                           '
      '                typeface="Microsoft Uighur"/>                           '
      '        <a:font script="Geor"                                           '
      '                typeface="Sylfaen"/>                                    '
      '      </a:minorFont>                                                    '
      '    </a:fontScheme>                                                     '
      '    <a:fmtScheme name="Office">                                         '
      '      <a:fillStyleLst>                                                  '
      '        <a:solidFill>                                                   '
      '          <a:schemeClr val="phClr"/>                                    '
      '        </a:solidFill>                                                  '
      '        <a:gradFill rotWithShape="1">                                   '
      '          <a:gsLst>                                                     '
      '            <a:gs pos="0">                                              '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:tint val="50000"/>                                   '
      '                <a:satMod val="300000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="35000">                                          '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:tint val="37000"/>                                   '
      '                <a:satMod val="300000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="100000">                                         '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:tint val="15000"/>                                   '
      '                <a:satMod val="350000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '          </a:gsLst>                                                    '
      '          <a:lin ang="16200000"                                         '
      '                 scaled="1"/>                                           '
      '        </a:gradFill>                                                   '
      '        <a:gradFill rotWithShape="1">                                   '
      '          <a:gsLst>                                                     '
      '            <a:gs pos="0">                                              '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:shade val="51000"/>                                  '
      '                <a:satMod val="130000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="80000">                                          '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:shade val="93000"/>                                  '
      '                <a:satMod val="130000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="100000">                                         '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:shade val="94000"/>                                  '
      '                <a:satMod val="135000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '          </a:gsLst>                                                    '
      '          <a:lin ang="16200000"                                         '
      '                 scaled="0"/>                                           '
      '        </a:gradFill>                                                   '
      '      </a:fillStyleLst>                                                 '
      '      <a:lnStyleLst>                                                    '
      '        <a:ln w="9525"                                                  '
      '              cap="flat"                                                '
      '              cmpd="sng"                                                '
      '              algn="ctr">                                               '
      '          <a:solidFill>                                                 '
      '            <a:schemeClr val="phClr">                                   '
      '              <a:shade val="95000"/>                                    '
      '              <a:satMod val="105000"/>                                  '
      '            </a:schemeClr>                                              '
      '          </a:solidFill>                                                '
      '          <a:prstDash val="solid"/>                                     '
      '        </a:ln>                                                         '
      '        <a:ln w="25400"                                                 '
      '              cap="flat"                                                '
      '              cmpd="sng"                                                '
      '              algn="ctr">                                               '
      '          <a:solidFill>                                                 '
      '            <a:schemeClr val="phClr"/>                                  '
      '          </a:solidFill>                                                '
      '          <a:prstDash val="solid"/>                                     '
      '        </a:ln>                                                         '
      '        <a:ln w="38100"                                                 '
      '              cap="flat"                                                '
      '              cmpd="sng"                                                '
      '              algn="ctr">                                               '
      '          <a:solidFill>                                                 '
      '            <a:schemeClr val="phClr"/>                                  '
      '          </a:solidFill>                                                '
      '          <a:prstDash val="solid"/>                                     '
      '        </a:ln>                                                         '
      '      </a:lnStyleLst>                                                   '
      '      <a:effectStyleLst>                                                '
      '        <a:effectStyle>                                                 '
      '          <a:effectLst>                                                 '
      '            <a:outerShdw blurRad="40000"                                '
      '                         dist="20000"                                   '
      '                         dir="5400000"                                  '
      '                         rotWithShape="0">                              '
      '              <a:srgbClr val="000000">                                  '
      '                <a:alpha val="38000"/>                                  '
      '              </a:srgbClr>                                              '
      '            </a:outerShdw>                                              '
      '          </a:effectLst>                                                '
      '        </a:effectStyle>                                                '
      '        <a:effectStyle>                                                 '
      '          <a:effectLst>                                                 '
      '            <a:outerShdw blurRad="40000"                                '
      '                         dist="23000"                                   '
      '                         dir="5400000"                                  '
      '                         rotWithShape="0">                              '
      '              <a:srgbClr val="000000">                                  '
      '                <a:alpha val="35000"/>                                  '
      '              </a:srgbClr>                                              '
      '            </a:outerShdw>                                              '
      '          </a:effectLst>                                                '
      '        </a:effectStyle>                                                '
      '        <a:effectStyle>                                                 '
      '          <a:effectLst>                                                 '
      '            <a:outerShdw blurRad="40000"                                '
      '                         dist="23000"                                   '
      '                         dir="5400000"                                  '
      '                         rotWithShape="0">                              '
      '              <a:srgbClr val="000000">                                  '
      '                <a:alpha val="35000"/>                                  '
      '              </a:srgbClr>                                              '
      '            </a:outerShdw>                                              '
      '          </a:effectLst>                                                '
      '          <a:scene3d>                                                   '
      '            <a:camera prst="orthographicFront">                         '
      '              <a:rot lat="0"                                            '
      '                     lon="0"                                            '
      '                     rev="0"/>                                          '
      '            </a:camera>                                                 '
      '            <a:lightRig rig="threePt"                                   '
      '                        dir="t">                                        '
      '              <a:rot lat="0"                                            '
      '                     lon="0"                                            '
      '                     rev="1200000"/>                                    '
      '            </a:lightRig>                                               '
      '          </a:scene3d>                                                  '
      '          <a:sp3d>                                                      '
      '            <a:bevelT w="63500"                                         '
      '                      h="25400"/>                                       '
      '          </a:sp3d>                                                     '
      '        </a:effectStyle>                                                '
      '      </a:effectStyleLst>                                               '
      '      <a:bgFillStyleLst>                                                '
      '        <a:solidFill>                                                   '
      '          <a:schemeClr val="phClr"/>                                    '
      '        </a:solidFill>                                                  '
      '        <a:gradFill rotWithShape="1">                                   '
      '          <a:gsLst>                                                     '
      '            <a:gs pos="0">                                              '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:tint val="40000"/>                                   '
      '                <a:satMod val="350000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="40000">                                          '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:tint val="45000"/>                                   '
      '                <a:shade val="99000"/>                                  '
      '                <a:satMod val="350000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="100000">                                         '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:shade val="20000"/>                                  '
      '                <a:satMod val="255000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '          </a:gsLst>                                                    '
      '          <a:path path="circle">                                        '
      '            <a:fillToRect l="50000"                                     '
      '                          t="-80000"                                    '
      '                          r="50000"                                     '
      '                          b="180000"/>                                  '
      '          </a:path>                                                     '
      '        </a:gradFill>                                                   '
      '        <a:gradFill rotWithShape="1">                                   '
      '          <a:gsLst>                                                     '
      '            <a:gs pos="0">                                              '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:tint val="80000"/>                                   '
      '                <a:satMod val="300000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '            <a:gs pos="100000">                                         '
      '              <a:schemeClr val="phClr">                                 '
      '                <a:shade val="30000"/>                                  '
      '                <a:satMod val="200000"/>                                '
      '              </a:schemeClr>                                            '
      '            </a:gs>                                                     '
      '          </a:gsLst>                                                    '
      '          <a:path path="circle">                                        '
      '            <a:fillToRect l="50000"                                     '
      '                          t="50000"                                     '
      '                          r="50000"                                     '
      '                          b="50000"/>                                   '
      '          </a:path>                                                     '
      '        </a:gradFill>                                                   '
      '      </a:bgFillStyleLst>                                               '
      '    </a:fmtScheme>                                                      '
      '  </a:themeElements>                                                    '
      '  <a:objectDefaults/>                                                   '
      '  <a:extraClrSchemeLst/>                                                '
      '</a:theme>                                                              '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_themes

  METHOD get_default_workbook.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                 '
      '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"             '
      '          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
      '  <fileVersion appName="xl"                                                             '
      '               lastEdited="5"                                                           '
      '               lowestEdited="5"                                                         '
      '               rupBuild="9303"/>                                                        '
      '  <workbookPr defaultThemeVersion="124226"/>                                            '
      '  <bookViews>                                                                           '
      '    <workbookView xWindow="360"                                                         '
      '                  yWindow="30"                                                          '
      '                  windowWidth="24915"                                                   '
      '                  windowHeight="15900"/>                                                '
      '  </bookViews>                                                                          '
      '  <sheets>                                                                              '
      '    <sheet name="Sheet1"                                                                '
      '           sheetId="1"                                                                  '
      '           r:id="rId1"/>                                                                '
      '  </sheets>                                                                             '
      '  <calcPr calcId="145621"/>                                                             '
      '</workbook>                                                                             '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_workbook

  METHOD get_default_workbook_2.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                 '
      '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"             '
      '          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
      '  <fileVersion appName="xl"                                                             '
      '               lastEdited="5"                                                           '
      '               lowestEdited="5"                                                         '
      '               rupBuild="9303"/>                                                        '
      '  <workbookPr defaultThemeVersion="124226"/>                                            '
      '  <bookViews>                                                                           '
      '    <workbookView xWindow="360"                                                         '
      '                  yWindow="30"                                                          '
      '                  windowWidth="24915"                                                   '
      '                  windowHeight="15900"/>                                                '
      '  </bookViews>                                                                          '
      '  <sheets>                                                                              '
      '  </sheets>                                                                             '
      '  <calcPr calcId="145621"/>                                                             '
      '</workbook>                                                                             '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_workbook_2
  METHOD get_default_workbook_rels.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                             '
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">                '
      '  <Relationship Id="rId3"                                                                           '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles"   '
      '                Target="styles.xml"/>                                                               '
      '  <Relationship Id="rId2"                                                                           '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme"    '
      '                Target="theme/theme1.xml"/>                                                         '
      '  <Relationship Id="rId1"                                                                           '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"'
      '                Target="worksheets/sheet1.xml"/>                                                    '
      '</Relationships>                                                                                    '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_workbook_rels

  METHOD get_default_workbook_rels_2.
    "RETURNING
    "  value(rv_output)      TYPE xstring,

    DATA:
      lv_tmp_xml            TYPE string.

    CLEAR lv_tmp_xml.
    CLEAR rv_output.
    CONCATENATE
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>                                                 '
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">                    '
      '  <Relationship Id="rId3"                                                                               '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles"       '
      '                Target="styles.xml"/>                                                                   '
      '  <Relationship Id="rId2"                                                                               '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme"        '
      '                Target="theme/theme1.xml"/>                                                             '
      '  <Relationship Id="rId4"                                                                               '
      '                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings"'
      '                Target="sharedStrings.xml"/>                                                            '
      '</Relationships>                                                                                        '
    INTO lv_tmp_xml.                                        "#EC NOTEXT
    rv_output = string_to_xstring( iv_input = lv_tmp_xml ).

  ENDMETHOD.                    "get_default_workbook_rels_2
ENDCLASS.                    "lcl_default_xml IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_typeinfo_node IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_typeinfo_node IMPLEMENTATION.

  METHOD constructor.
    "IMPORTING
    "  ir_parent       TYPE REF TO lcl_typeinfo_node
    "  is_typeinfo     TYPE lty_typeinfo_s.

    CLEAR mr_parent.
    CLEAR mt_children.
    CLEAR ms_typeinfo.
    ms_typeinfo = is_typeinfo.
    IF ir_parent IS BOUND.
      mr_parent = ir_parent.
      mr_parent->add_child( ir_child = me ).
    ENDIF.

  ENDMETHOD.                    "constructor

  METHOD create_datadescr.
    "IMPORTING
    "  iv_use_ddic           TYPE abap_bool
    "returning
    "  value(rr_datadescr)   type ref to cl_abap_datadescr,

    CLEAR rr_datadescr.
    CASE  ms_typeinfo-kind.
      WHEN cl_abap_typedescr=>kind_elem.
        rr_datadescr = create_elemdescr( iv_use_ddic = iv_use_ddic ).
      WHEN cl_abap_typedescr=>kind_struct.
        rr_datadescr = create_structdescr( iv_use_ddic = iv_use_ddic ).
      WHEN cl_abap_typedescr=>kind_table.
        rr_datadescr = create_tabledescr( iv_use_ddic = iv_use_ddic ).
    ENDCASE.

  ENDMETHOD.                    "create_datadescr

  METHOD create_tabledescr.
    "IMPORTING
    "  iv_use_ddic           TYPE abap_bool
    "returning
    "  value(rr_datadescr)   type ref to cl_abap_datadescr,

    DATA:
      lr_child     TYPE REF TO lty_typeinfo_node_s,
      lr_datadescr TYPE REF TO cl_abap_datadescr.

    CLEAR rr_datadescr.
    TRY.
        IF iv_use_ddic = abap_true AND is_ddic_type( ) = abap_true.
          rr_datadescr ?= cl_abap_typedescr=>describe_by_name( p_name = ms_typeinfo-absolute_name ).
        ELSE.
          READ TABLE mt_children INDEX 1 REFERENCE INTO lr_child.
          IF sy-subrc <> 0.
            RETURN.
          ENDIF.
          CLEAR lr_datadescr.
          lr_datadescr = lr_child->node->create_datadescr( iv_use_ddic = iv_use_ddic ).
          IF lr_datadescr IS NOT INITIAL.
            rr_datadescr ?= cl_abap_tabledescr=>create( p_line_type = lr_datadescr ).
          ENDIF.
        ENDIF.
      CATCH cx_root.
        CLEAR rr_datadescr.
    ENDTRY.


  ENDMETHOD.                    "create_tabledescr

  METHOD create_structdescr.
    "IMPORTING
    "  iv_use_ddic           TYPE abap_bool
    "returning
    "  value(rr_datadescr)   type ref to cl_abap_datadescr,

    DATA:
      ls_component  TYPE cl_abap_structdescr=>component,
      lt_components TYPE cl_abap_structdescr=>component_table,
      lr_child      TYPE REF TO lty_typeinfo_node_s.

    CLEAR rr_datadescr.
    TRY.
        IF iv_use_ddic = abap_true AND is_ddic_type( ) = abap_true.
          rr_datadescr ?= cl_abap_typedescr=>describe_by_name( p_name = ms_typeinfo-absolute_name ).
        ELSE.

          CLEAR lt_components.
          LOOP AT mt_children REFERENCE INTO lr_child.
            CLEAR ls_component.
            ls_component-name = lr_child->node->ms_typeinfo-field_name.
            ls_component-type = lr_child->node->create_datadescr( iv_use_ddic = iv_use_ddic ).
            ls_component-as_include = lr_child->node->ms_typeinfo-as_include.
            INSERT ls_component INTO TABLE lt_components.
          ENDLOOP.

          rr_datadescr = cl_abap_structdescr=>create( p_components = lt_components ).

        ENDIF.

      CATCH cx_root.
        CLEAR rr_datadescr.
    ENDTRY.

  ENDMETHOD.                    "create_structdescr

  METHOD create_elemdescr.
    "IMPORTING
    "  iv_use_ddic           TYPE abap_bool
    "returning
    "  value(rr_datadescr)   type ref to cl_abap_datadescr,

    DATA:
      lv_typekind TYPE abap_typekind,
      lv_length   TYPE i,
      lv_decimals TYPE i.

    CLEAR rr_datadescr.
    TRY.
        IF iv_use_ddic = abap_true AND is_ddic_type( ) = abap_true.
          rr_datadescr ?= cl_abap_typedescr=>describe_by_name( p_name = ms_typeinfo-absolute_name ).
        ELSE.

          CASE  ms_typeinfo-type_kind.
            WHEN cl_abap_typedescr=>typekind_num.
              rr_datadescr = cl_abap_elemdescr=>get_n( p_length = ms_typeinfo-length ).
            WHEN cl_abap_typedescr=>typekind_date.
              rr_datadescr = cl_abap_elemdescr=>get_d( ).
            WHEN cl_abap_typedescr=>typekind_packed.
              rr_datadescr = cl_abap_elemdescr=>get_p( p_length = ms_typeinfo-length p_decimals = ms_typeinfo-decimals ).
            WHEN cl_abap_typedescr=>typekind_time.
              rr_datadescr = cl_abap_elemdescr=>get_t( ).
            WHEN cl_abap_typedescr=>typekind_char.
              lv_length = ms_typeinfo-length.
              rr_datadescr = cl_abap_elemdescr=>get_c( p_length = lv_length ).
            WHEN cl_abap_typedescr=>typekind_hex.
              rr_datadescr = cl_abap_elemdescr=>get_x( p_length = ms_typeinfo-length ).
            WHEN cl_abap_typedescr=>typekind_float.
              rr_datadescr = cl_abap_elemdescr=>get_f( ).
            WHEN cl_abap_typedescr=>typekind_int.
              rr_datadescr = cl_abap_elemdescr=>get_i( ).
            WHEN cl_abap_typedescr=>typekind_int1.
              DATA:
                lv_tmp_b      TYPE int1.
              rr_datadescr ?= cl_abap_elemdescr=>describe_by_data( p_data = lv_tmp_b ).
            WHEN cl_abap_typedescr=>typekind_int2.
              DATA:
                lv_tmp_s      TYPE int2.
              rr_datadescr ?= cl_abap_elemdescr=>describe_by_data( p_data = lv_tmp_s ).
          ENDCASE.
        ENDIF.
      CATCH cx_root.
        CLEAR rr_datadescr.
    ENDTRY.

  ENDMETHOD.                    "create_elemdescr

  METHOD add_child.
    "importing
    "  ir_child       TYPE REF TO lcl_typeinfo_node

    DATA:
      lr_child        TYPE REF TO lty_typeinfo_node_s.

    APPEND INITIAL LINE TO mt_children REFERENCE INTO lr_child.
    lr_child->key = ir_child->ms_typeinfo-key.
    lr_child->node = ir_child.

  ENDMETHOD.                    "add_child

  METHOD is_ddic_type.
    "returning
    "  value(rv_ddic)        type abap_bool,

    rv_ddic = is_ddic_type_static( is_typeinfo = ms_typeinfo ).

  ENDMETHOD.                    "is_ddic_type

  METHOD is_ddic_type_static.
    "importing
    "  is_typeinfo           type lty_typeinfo_s
    "returning
    "  value(rv_ddic)        type abap_bool,

    IF is_typeinfo-absolute_name(6) = '\TYPE=' AND is_typeinfo-relative_name IS NOT INITIAL.
      rv_ddic = abap_true.
    ELSE.
      rv_ddic = abap_false.
    ENDIF.

  ENDMETHOD.                    "is_ddic_type_static

  METHOD get_absolute_type_name.
    "returning
    "  value(rv_name)        TYPE abap_abstypename,

    CLEAR rv_name.
    rv_name = ms_typeinfo-absolute_name.

  ENDMETHOD.                    "get_absolute_type_name

  METHOD get_typeinfo.
    "exporting
    "  es_typeinfo        type lty_typeinfo_s

    CLEAR es_typeinfo.
    es_typeinfo = ms_typeinfo.

  ENDMETHOD.                    "get_typeinfo

  METHOD get_linetypeinfo.
    "exporting
    "  es_typeinfo        type lty_typeinfo_s

    DATA:
      ls_typeinfo TYPE lty_typeinfo_s,
      lr_child    TYPE REF TO lty_typeinfo_node_s.

    CLEAR es_typeinfo.
    IF ms_typeinfo-kind = cl_abap_typedescr=>kind_table.

      READ TABLE mt_children INDEX 1 REFERENCE INTO lr_child.
      IF sy-subrc = 0.
        IF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_struct.
          es_typeinfo = lr_child->node->ms_typeinfo.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "get_linetypeinfo

  METHOD get_linetype_node.
    "returning
    "  value(rr_node)        TYPE REF TO lcl_typeinfo_node,
    DATA:
      lr_child            TYPE REF TO lty_typeinfo_node_s.

    IF ms_typeinfo-kind = cl_abap_typedescr=>kind_table.

      READ TABLE mt_children INDEX 1 REFERENCE INTO lr_child.
      IF sy-subrc = 0.
        IF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_struct.
          rr_node = lr_child->node.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "get_linetype_node

  METHOD get_typeinfo_of_comp.
    "IMPORTING
    "  iv_comp               TYPE abap_compname
    "EXPORTING
    "  es_typeinfo           TYPE lty_typeinfo_s,

    DATA:
      ls_typeinfo TYPE lty_typeinfo_s,
      lr_child    TYPE REF TO lty_typeinfo_node_s.

    IF iv_comp IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR es_typeinfo.
    IF ms_typeinfo-kind = cl_abap_typedescr=>kind_table.

      READ TABLE mt_children INDEX 1 REFERENCE INTO lr_child.
      IF sy-subrc = 0.
        IF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_struct.
          lr_child->node->get_typeinfo_of_comp( EXPORTING
                                                  iv_comp     = iv_comp
                                                IMPORTING
                                                  es_typeinfo = es_typeinfo ).
        ENDIF.
        RETURN.
      ENDIF.

    ELSEIF  ms_typeinfo-kind = cl_abap_typedescr=>kind_struct.

*      IF ms_typeinfo-as_include = abap_true.
*        READ TABLE mt_children INDEX 1 REFERENCE INTO lr_child.
*        IF sy-subrc = 0.
*          lr_child->node->get_typeinfo_of_comp( EXPORTING
*                                                  iv_comp     = iv_comp
*                                                IMPORTING
*                                                  es_typeinfo = es_typeinfo ).
*          RETURN.
*        ENDIF.
*      ELSE.
      LOOP AT mt_children REFERENCE INTO lr_child.
        IF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_elem.

          IF lr_child->node->ms_typeinfo-field_name = iv_comp.
            es_typeinfo = lr_child->node->ms_typeinfo.
            RETURN.
          ENDIF.
        ELSEIF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_struct
               AND lr_child->node->ms_typeinfo-as_include = abap_true.

          CLEAR ls_typeinfo.
          lr_child->node->get_typeinfo_of_comp( EXPORTING
                                                  iv_comp     = iv_comp
                                                IMPORTING
                                                  es_typeinfo = ls_typeinfo ).
          IF ls_typeinfo IS NOT INITIAL.
            es_typeinfo = ls_typeinfo.
            RETURN.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.
*  ENDIF.
  ENDMETHOD.                    "get_typeinfo_of_comp

  METHOD get_path.
    "returning
    "  value(rv_path)        type string,
    DATA:
       lv_path      TYPE string.

    CLEAR rv_path.
    IF ms_typeinfo-field_name IS INITIAL.
      IF mr_parent IS NOT INITIAL.
        rv_path = mr_parent->get_path( ).
      ENDIF.
    ELSE.
      CLEAR lv_path.
      IF mr_parent IS NOT INITIAL.
        lv_path = mr_parent->get_path( ).
        IF lv_path IS INITIAL.
          rv_path = ms_typeinfo-field_name.
        ELSE.
          CONCATENATE lv_path '-' ms_typeinfo-field_name INTO rv_path.
        ENDIF.
      ELSE.
        rv_path = ms_typeinfo-field_name.
      ENDIF.
      CONDENSE rv_path.
    ENDIF.
  ENDMETHOD.                    "get_path

ENDCLASS.                    "lcl_typeinfo_node DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_relinfo_node IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*CLASS lcl_relinfo_node IMPLEMENTATION.
*  METHOD constructor.
*    "IMPORTING
*    "  ir_parent             TYPE REF TO lcl_relinfo_node
*    "  is_hierinfo           TYPE lty_hierarchy_info_s.
*
*    DATA:
*      ls_typeinfo           TYPE lty_typeinfo_s.
*
*    CLEAR ls_typeinfo.
*    MOVE-CORRESPONDING is_hierinfo TO ls_typeinfo.
*    super->constructor( EXPORTING
*                          ir_parent   = ir_parent
*                          is_typeinfo = ls_typeinfo ).
*    CLEAR ms_relinfo.
*    MOVE-CORRESPONDING is_hierinfo TO ms_relinfo.
*
*  ENDMETHOD.                    "constructor
*
*  METHOD get_parent.
*    "returning
*    "  value(rr_parent)     type ref to lcl_relinfo_node
*
*    CLEAR rr_parent.
*    rr_parent ?= mr_parent.
*
*  ENDMETHOD.                    "get_parent
*
*  METHOD get_relinfo.
*    "EXPORTING
*    "  es_relinfo            TYPE lty_relinfo_s,
*
*    CLEAR es_relinfo.
*    es_relinfo = ms_relinfo.
*
*  ENDMETHOD.                    "get_relinfo
*
*  METHOD generate_typedef_code.
*    "exporting
*    "  et_code               type lty_code_t,
*    DATA:
*      lr_child          TYPE REF TO lty_typeinfo_node_s,
*      lv_code           TYPE lty_code_line.
*
*    "assume this is a structure.
*    CLEAR et_code.
*    CLEAR lv_code.
*    CONCATENATE 'TYPES  BEGIN OF' ms_typeinfo-relative_name '.' INTO lv_code SEPARATED BY space.
*    APPEND lv_code TO et_code.
*
*    LOOP AT mt_children REFERENCE INTO lr_child.
*      CLEAR lv_code.
*      IF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_elem.
*        CONCATENATE 'TYPES' lr_child->node->ms_typeinfo-field_name 'TYPE' lr_child->node->ms_typeinfo-relative_name '.' INTO lv_code SEPARATED BY space.
*      ELSEIF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_struct.
*        IF lr_child->node->ms_typeinfo-as_include = abap_false.
*          CONCATENATE 'TYPES' lr_child->node->ms_typeinfo-field_name 'TYPE' lr_child->node->ms_typeinfo-relative_name '.' INTO lv_code SEPARATED BY space.
*        ELSE.
*          CONCATENATE 'INCLUDE TYPE' lr_child->node->ms_typeinfo-relative_name '.' INTO lv_code SEPARATED BY space.
*        ENDIF.
*      ELSEIF lr_child->node->ms_typeinfo-kind = cl_abap_typedescr=>kind_table.
*        CONCATENATE 'TYPES' lr_child->node->ms_typeinfo-field_name 'TYPE' lr_child->node->ms_typeinfo-relative_name '.' INTO lv_code SEPARATED BY space.
*      ENDIF.
*      APPEND lv_code TO et_code.
*    ENDLOOP.
*    CONCATENATE 'TYPES  END OF' ms_typeinfo-relative_name '.' INTO lv_code SEPARATED BY space.
*    APPEND lv_code TO et_code.
*
*  ENDMETHOD.                    "generate_typedef_code
*
*ENDCLASS.                    "lcl_relinfo_node IMPLEMENTATION
*
*----------------------------------------------------------------------*
*       CLASS lcl_relinfo_tree IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*CLASS lcl_relinfo_tree IMPLEMENTATION.
*
*  METHOD constructor.
*    "importing
*    "  it_hierinfo       type lty_hierarchy_info_t.
*
*    CLEAR mr_root.
*    CLEAR mt_nodes.
*    mr_root = convert_hierinfo_to_tree( it_hierinfo = it_hierinfo ).
*
*  ENDMETHOD.                    "constructor
*
*  METHOD get_relations.
*    "IMPORTING
*    "  it_map_rel_data   TYPE lty_map_rel_to_data_t
*    "exporting
*    "  et_relations      type lty_relation_info_t,
*
*    DATA:
*      lr_tabledescr         TYPE REF TO cl_abap_tabledescr,
*      lr_datadescr          TYPE REF TO cl_abap_datadescr,
*      lr_map_rel            TYPE REF TO lty_map_rel_to_data_s,
*      lr_node               TYPE REF TO lty_relinfo_node_s,
*      lr_relation           TYPE REF TO lty_relation_s,
*      ls_relinfo            TYPE lty_relinfo_s,
*      lr_relation_info      TYPE REF TO lty_relation_info_s.
*
*    CLEAR et_relations.
*
*    LOOP AT mt_relations REFERENCE INTO lr_relation.
*
*      INSERT INITIAL LINE INTO TABLE et_relations REFERENCE INTO lr_relation_info.
*      lr_relation_info->name = lr_relation->name.
*      lr_relation_info->target_node = lr_relation->target_node.
*      CLEAR ls_relinfo.
*      lr_relation->target_node->get_relinfo( IMPORTING
*                                               es_relinfo = ls_relinfo ).
*      create_rel_fields( EXPORTING
*                           ir_node   = lr_relation->target_node
*                           iv_fields = ls_relinfo-target
*                         IMPORTING
*                           et_fields =  lr_relation_info->target_fields ).
*      lr_relation_info->target_path = lr_relation_info->target_node->get_path( ).
*      CLEAR lr_node.
*      READ TABLE mt_nodes WITH TABLE KEY key = lr_relation->source REFERENCE INTO lr_node.
*      IF sy-subrc = 0.
*        lr_relation_info->source_node = lr_node->node.
*        create_rel_fields( EXPORTING
*                             ir_node   = lr_relation_info->source_node
*                             iv_fields = ls_relinfo-source
*                           IMPORTING
*                             et_fields =  lr_relation_info->source_fields ).
*        lr_relation_info->source_path = lr_relation_info->source_node->get_path( ).
*        "would actually need some kind of other identifier, since name is not unique.
*        READ TABLE it_map_rel_data REFERENCE INTO lr_map_rel WITH KEY name = lr_relation_info->name.
*        IF sy-subrc = 0.
*          TRY.
*              CLEAR lr_tabledescr.
*              lr_tabledescr ?= cl_abap_typedescr=>describe_by_data_ref( p_data_ref = lr_map_rel->data ).
*              IF lr_tabledescr IS BOUND.
*                lr_relation_info->source_data_ttyp = lr_tabledescr->get_relative_name( ).
*                CLEAR lr_datadescr.
*                lr_datadescr = lr_tabledescr->get_table_line_type( ).
*                IF lr_datadescr IS BOUND.
*                  lr_relation_info->source_data_ltyp = lr_datadescr->get_relative_name( ).
*                ENDIF.
*              ENDIF.
*            CATCH cx_root.
*          ENDTRY.
*        ENDIF.
*      ENDIF.
*
*      generate_rel_prog( ir_relation_info = lr_relation_info ).
*    ENDLOOP.
*
*  ENDMETHOD.                    "get_relations
*
*  METHOD generate_rel_prog_simple.
*    "importing
*    "  ir_relation_info     type REF TO lty_relation_info_s
*
*    DATA:
*      ls_typeinfo             TYPE lty_typeinfo_s,
*      lv_tmp                  TYPE lty_code_line,
*      lv_num_fields           TYPE i,
*      lv_index                TYPE i,
*      lv_tab_index            TYPE i,
*      lr_rel_field_source     TYPE REF TO lty_rel_field_s,
*      lr_rel_field_target     TYPE REF TO lty_rel_field_s,
*      lv_typename             TYPE abap_typename,
*      lr_key                  TYPE REF TO data,
*      lv_code                 TYPE lty_code_line,
*      lt_code                 TYPE STANDARD TABLE OF lty_code_line,
*      lv_guid                 TYPE c LENGTH 32,
*      lv_progname             TYPE progname.
*
*    CLEAR lt_code.
*    CLEAR lv_guid.
*    TRY.
*        lv_guid = cl_system_uuid=>create_uuid_c32_static( ).
*      CATCH cx_uuid_error.
*    ENDTRY.
*
*    CONCATENATE '$$_' lv_guid INTO lv_progname.
*    CONDENSE lv_progname.
*
*    CLEAR lt_code.
*    READ REPORT 'ZHEW_SIMPLE_LOOP_TEMPLATE' INTO lt_code.
*    REPLACE FIRST OCCURRENCE OF '<report_name>' IN TABLE lt_code WITH lv_progname.
*
*    lv_tab_index = 0.
*    FIND FIRST OCCURRENCE OF '<type_def>' IN TABLE lt_code MATCH LINE lv_tab_index.
*    IF lv_tab_index <= 0.
*      RETURN.
*    ENDIF.
*    DELETE lt_code INDEX lv_tab_index.
*    LOOP AT ir_relation_info->source_fields REFERENCE INTO lr_rel_field_source.
*      "todo: support non-ddic types.
*      CLEAR lv_code.
*      CONCATENATE lr_rel_field_source->field-field_name 'TYPE' lr_rel_field_source->field-relative_name ',' INTO lv_code SEPARATED BY space.
*      INSERT lv_code INTO lt_code INDEX lv_tab_index.
*      lv_tab_index = lv_tab_index + 1.
*    ENDLOOP.
*
*    CLEAR ls_typeinfo.
*    ir_relation_info->target_node->get_typeinfo( IMPORTING
*                                                   es_typeinfo = ls_typeinfo ).
*    REPLACE FIRST OCCURRENCE OF '<table_type>' IN TABLE lt_code WITH ls_typeinfo-relative_name.
*
*    CLEAR ls_typeinfo.
*    ir_relation_info->target_node->get_linetypeinfo( IMPORTING
*                                                       es_typeinfo = ls_typeinfo ).
*    REPLACE FIRST OCCURRENCE OF '<line_type>' IN TABLE lt_code WITH ls_typeinfo-relative_name.
*
*    lv_tab_index = 0.
*    FIND FIRST OCCURRENCE OF '<where_clause>' IN TABLE lt_code MATCH LINE lv_tab_index.
*    IF lv_tab_index <= 0.
*      RETURN.
*    ENDIF.
*    DELETE lt_code INDEX lv_tab_index.
*    lv_num_fields  = 0.
*    DESCRIBE TABLE ir_relation_info->target_fields LINES lv_num_fields.
*    CLEAR lv_index.
*    LOOP AT ir_relation_info->target_fields REFERENCE INTO lr_rel_field_target.
*      lv_index = sy-tabix.
*      READ TABLE ir_relation_info->source_fields INDEX lv_index REFERENCE INTO lr_rel_field_source.
*      IF sy-subrc <> 0.
*        CONTINUE.
*      ENDIF.
*      CLEAR lv_code.
*      CLEAR lv_tmp.
*      CONCATENATE 'is_key-' lr_rel_field_source->field-field_name INTO lv_tmp.
*      CONDENSE lv_tmp.
*      CONCATENATE '    ' lr_rel_field_target->field-field_name ' = ' lv_tmp INTO lv_code SEPARATED BY space.
*      IF lv_index < lv_num_fields.
*        CONCATENATE lv_code ' and' INTO lv_code SEPARATED BY space.
*      ELSE.
*        CONCATENATE lv_code '.' INTO lv_code SEPARATED BY space.
*      ENDIF.
*      INSERT lv_code INTO lt_code INDEX lv_tab_index.
*      lv_tab_index = lv_tab_index + 1.
*    ENDLOOP.
*
*    "GENERATE SUBROUTINE POOL lt_code NAME lv_progname.
*    IF sy-subrc = 0.
*      ir_relation_info->progname = lv_progname.
*    ENDIF.
*
*  ENDMETHOD.                    "generate_rel_prog_simple
*
*  METHOD generate_rel_prog_move.
*    "importing
*    "  ir_relation_info     type REF TO lty_relation_info_s
*
*    DATA:
*      lr_line_typenode        TYPE REF TO lcl_relinfo_node,
*      ls_typeinfo             TYPE lty_typeinfo_s,
*      ls_line_typeinfo        TYPE lty_typeinfo_s,
*      lv_tmp                  TYPE lty_code_line,
*      lv_num_fields           TYPE i,
*      lv_index                TYPE i,
*      lv_tab_index            TYPE i,
*      lr_rel_field_source     TYPE REF TO lty_rel_field_s,
*      lr_rel_field_target     TYPE REF TO lty_rel_field_s,
*      lv_typename             TYPE abap_typename,
*      lr_key                  TYPE REF TO data,
*      lv_code                 TYPE lty_code_line,
*      lt_code                 TYPE lty_code_t,
*      lt_code_tmp             TYPE lty_code_t,
*      lv_guid                 TYPE c LENGTH 32,
*      lv_progname             TYPE progname.
*
*    CLEAR lt_code.
*    CLEAR lv_guid.
*    TRY.
*        lv_guid = cl_system_uuid=>create_uuid_c32_static( ).
*      CATCH cx_uuid_error.
*    ENDTRY.
*    CONCATENATE '$$_' lv_guid INTO lv_progname.
*    CONDENSE lv_progname.
*
*    CLEAR lt_code.
*    READ REPORT 'ZHEW_MOVE_LOOP_TEMPLATE' INTO lt_code.
*    REPLACE FIRST OCCURRENCE OF '<report_name>' IN TABLE lt_code WITH lv_progname.
*
*    lv_tab_index = 0.
*    FIND FIRST OCCURRENCE OF '<type_def>' IN TABLE lt_code MATCH LINE lv_tab_index.
*    IF lv_tab_index <= 0.
*      RETURN.
*    ENDIF.
*    DELETE lt_code INDEX lv_tab_index.
*    LOOP AT ir_relation_info->source_fields REFERENCE INTO lr_rel_field_source.
*      "todo: support non-ddic types.
*      CLEAR lv_code.
*      CONCATENATE lr_rel_field_source->field-field_name 'TYPE' lr_rel_field_source->field-relative_name ',' INTO lv_code SEPARATED BY space.
*      INSERT lv_code INTO lt_code INDEX lv_tab_index.
*      lv_tab_index = lv_tab_index + 1.
*    ENDLOOP.
*
*    CLEAR ls_line_typeinfo.
*    ir_relation_info->target_node->get_linetypeinfo( IMPORTING
*                                                       es_typeinfo = ls_line_typeinfo ).
*    IF lcl_typeinfo_node=>is_ddic_type_static( is_typeinfo = ls_line_typeinfo ) = abap_false.
*      lv_tab_index = 0.
*      FIND FIRST OCCURRENCE OF '<line_type>' IN TABLE lt_code MATCH LINE lv_tab_index.
*      lv_tab_index = lv_tab_index - 1.
*      IF lv_tab_index <= 0.
*        RETURN.
*      ENDIF.
*      "DELETE lt_code INDEX lv_tab_index.
*      CLEAR lt_code_tmp.
*      CLEAR lr_line_typenode.
*      lr_line_typenode ?= ir_relation_info->target_node->get_linetype_node( ).
*      lr_line_typenode->generate_typedef_code( IMPORTING
*                                                 et_code = lt_code_tmp ).
*      INSERT LINES OF lt_code_tmp INTO lt_code INDEX lv_tab_index.
*    ENDIF.
*    REPLACE FIRST OCCURRENCE OF '<line_type>' IN TABLE lt_code WITH ls_line_typeinfo-relative_name.
*
*    CLEAR ls_typeinfo.
*    ir_relation_info->target_node->get_typeinfo( IMPORTING
*                                                   es_typeinfo = ls_typeinfo ).
*    IF lcl_typeinfo_node=>is_ddic_type_static( is_typeinfo = ls_typeinfo ) = abap_false.
*
*      lv_tab_index = 0.
*      FIND FIRST OCCURRENCE OF '<table_type>' IN TABLE lt_code MATCH LINE lv_tab_index.
*      lv_tab_index = lv_tab_index - 1.
*      IF lv_tab_index <= 0.
*        RETURN.
*      ENDIF.
*      "DELETE lt_code INDEX lv_tab_index.
*      CLEAR lv_code.
*      CONCATENATE 'TYPES:' ls_typeinfo-relative_name 'TYPE STANDARD TABLE OF' ls_line_typeinfo-relative_name
*                  'WITH NON-UNIQUE DEFAULT KEY' '.' INTO lv_code SEPARATED BY space.
*      INSERT lv_code INTO lt_code INDEX lv_tab_index.
*
*    ENDIF.
*    REPLACE FIRST OCCURRENCE OF '<table_type>' IN TABLE lt_code WITH ls_typeinfo-relative_name.
*
*
*    REPLACE FIRST OCCURRENCE OF '<ds_line_type>' IN TABLE lt_code WITH ir_relation_info->source_data_ltyp.
*    REPLACE FIRST OCCURRENCE OF '<ds_table_type>' IN TABLE lt_code WITH ir_relation_info->source_data_ttyp.
*
*    lv_tab_index = 0.
*    FIND FIRST OCCURRENCE OF '<where_clause>' IN TABLE lt_code MATCH LINE lv_tab_index.
*    IF lv_tab_index <= 0.
*      RETURN.
*    ENDIF.
*    DELETE lt_code INDEX lv_tab_index.
*    lv_num_fields  = 0.
*    DESCRIBE TABLE ir_relation_info->target_fields LINES lv_num_fields.
*    CLEAR lv_index.
*    LOOP AT ir_relation_info->target_fields REFERENCE INTO lr_rel_field_target.
*      lv_index = sy-tabix.
*      READ TABLE ir_relation_info->source_fields INDEX lv_index REFERENCE INTO lr_rel_field_source.
*      IF sy-subrc <> 0.
*        CONTINUE.
*      ENDIF.
*      CLEAR lv_code.
*      CLEAR lv_tmp.
*      CONCATENATE 'is_key-' lr_rel_field_source->field-field_name INTO lv_tmp.
*      CONDENSE lv_tmp.
*      CONCATENATE '    ' lr_rel_field_target->field-field_name ' = ' lv_tmp INTO lv_code SEPARATED BY space.
*      IF lv_index < lv_num_fields.
*        CONCATENATE lv_code ' and' INTO lv_code SEPARATED BY space.
*      ELSE.
*        CONCATENATE lv_code '.' INTO lv_code SEPARATED BY space.
*      ENDIF.
*      INSERT lv_code INTO lt_code INDEX lv_tab_index.
*      lv_tab_index = lv_tab_index + 1.
*    ENDLOOP.
*
*    "GENERATE SUBROUTINE POOL lt_code NAME lv_progname.
*    IF sy-subrc = 0.
*      ir_relation_info->progname = lv_progname.
*    ENDIF.
*
*  ENDMETHOD.                    "generate_rel_prog_move
*
*  METHOD generate_rel_prog.
*    "importing
*    "  ir_relation_info     type REF TO lty_relation_info_s
*
*    DATA:
*      ls_typeinfo             TYPE lty_typeinfo_s.
*
*    CLEAR ls_typeinfo.
*    ir_relation_info->target_node->get_typeinfo( IMPORTING
*                                                   es_typeinfo = ls_typeinfo ).
*    IF ls_typeinfo-relative_name = ir_relation_info->source_data_ttyp.
*      generate_rel_prog_simple( ir_relation_info = ir_relation_info ).
*    ELSE.
*      generate_rel_prog_move( ir_relation_info = ir_relation_info ).
*    ENDIF.
*
*  ENDMETHOD.                    "generate_rel_prog
*
*  METHOD create_rel_fields.
*    "importing
*    "  ir_node            type ref to lcl_relinfo_node
*    "  iv_fields          type string,
*    "exporting
*    "  et_fields          type lty_rel_fields_t
*
*    DATA:
*      lv_index          TYPE i,
*      lv_comp           TYPE abap_compname,
*      lt_result         TYPE STANDARD TABLE OF string,
*      lv_result         TYPE string,
*      ls_field          TYPE lty_rel_field_s.
*
*    CLEAR et_fields.
*    CLEAR lt_result.
*    SPLIT iv_fields AT '+' INTO TABLE lt_result.
*    LOOP AT lt_result INTO lv_result.
*      lv_index = sy-tabix.
*      CLEAR ls_field.
*      ls_field-pos = lv_index.
*      CLEAR lv_comp.
*      lv_comp = lv_result.
*      ir_node->get_typeinfo_of_comp( EXPORTING
*                                       iv_comp     = lv_comp
*                                     IMPORTING
*                                       es_typeinfo = ls_field-field ).
*      INSERT ls_field INTO TABLE et_fields.
*    ENDLOOP.
*
*  ENDMETHOD.                    "create_rel_fields
*
*  METHOD convert_hierinfo_to_tree.
*    "IMPORTING
*    "  it_hierinfo       TYPE lty_hierarchy_info_t
*    "RETURNING
*    "  value(rr_tree)    tYPE REF TO lcl_relinfo_node.
*
*    DATA:
*      ls_nodes               TYPE lty_relinfo_node_s,
*      lr_nodes               TYPE REF TO lty_relinfo_node_s,
*      lv_index               TYPE i,
*      lr_node                TYPE REF TO lcl_relinfo_node,
*      lr_parent              TYPE REF TO lcl_relinfo_node,
*      lr_hierinfo            TYPE REF TO lty_hierarchy_info_s.
*
*    CLEAR lr_parent.
*    CLEAR lr_node.
*    CLEAR mt_nodes.
*    lv_index = 0.
*    LOOP AT it_hierinfo REFERENCE INTO lr_hierinfo.
*
*      lv_index = sy-tabix.
*      CLEAR lr_parent.
*      READ TABLE mt_nodes WITH TABLE KEY key = lr_hierinfo->parent_key REFERENCE INTO lr_nodes.
*      IF sy-subrc = 0.
*        lr_parent = lr_nodes->node.
*      ELSE.
*        CLEAR lr_parent.
*      ENDIF.
*
*      CREATE OBJECT lr_node
*        EXPORTING
*          ir_parent   = lr_parent
*          is_hierinfo = lr_hierinfo->*.
*      IF lv_index = 1.
*        rr_tree = lr_node.
*      ENDIF.
*      CLEAR ls_nodes.
*      ls_nodes-key = lr_hierinfo->key.
*      ls_nodes-node = lr_node.
*      INSERT ls_nodes INTO TABLE mt_nodes.
**      IF sy-subrc <> 0.
**        BREAK-POINT.
**      ENDIF.
*
*      DATA:
*        ls_relation         TYPE lty_relation_s.
*
*      IF lr_hierinfo->source IS NOT INITIAL AND lr_hierinfo->target IS NOT INITIAL.
*        CLEAR ls_relation.
*        ls_relation-name = lr_hierinfo->field_name.
*        ls_relation-source = lr_hierinfo->parent_key.
*        ls_relation-target_node = lr_node.
*        INSERT ls_relation INTO TABLE mt_relations.
*      ENDIF.
*    ENDLOOP.
*
*  ENDMETHOD.                    "convert_hierinfo_to_tree
*
**    data:
**      mt_relations  type lty_relations_t,
**      mr_root       type ref to lcl_relinfo_node.
*
*ENDCLASS.                    "lcl_relinfo_tree IMPLEMENTATION
*----------------------------------------------------------------------*
*       CLASS lcl_typeinfo_node DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
"lcl_typeinfo_node DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_excel_helper IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_excel_helper IMPLEMENTATION.

  METHOD class_constructor.

    DATA:
      lv_offset TYPE i,
      ls_map    TYPE mty_map_index_s,
      lv_tmp    TYPE c LENGTH 26.

    CLEAR mt_map_index.
    CLEAR mt_map_letter.
    lv_tmp = sy-abcde.

    lv_offset = 0.
    DO 26 TIMES.
      CLEAR ls_map.
      ls_map-letter = lv_tmp+lv_offset(1).
      ls_map-index = lv_offset + 1.
      "ls_map-index = lv_offset.
      INSERT ls_map INTO TABLE mt_map_index.
      INSERT ls_map INTO TABLE mt_map_letter.
      lv_offset = lv_offset + 1.
    ENDDO.

  ENDMETHOD.                    "CLASS_CONSTRUCTOR

  METHOD excelcol_to_index.
    "IMPORTING
    "  iv_col                TYPE lty_excel_col
    "RETURNING
    "  value(rv_index)       TYPE i,
    "

    DATA:
      lv_letter TYPE lty_letter,
      lv_len    TYPE i,
      lv_tmp    TYPE i,
      lv_pos    TYPE i,
      lv_exp    TYPE i,
      lv_value  TYPE i,
      lv_col    TYPE lty_excel_col.

    rv_index = 0.
    lv_col = iv_col.
    CONDENSE lv_col NO-GAPS.
    IF lv_col IS INITIAL.
      RETURN.
    ENDIF.

    lv_len = strlen( lv_col ).
    IF lv_len <= 0.
      RETURN.
    ENDIF.

    lv_value = 0.
    lv_pos = lv_len.
    lv_exp = 0.
    DO lv_len TIMES.
      lv_pos = lv_pos - 1.
      CLEAR lv_letter.
      lv_letter = lv_col+lv_pos(1).
      lv_tmp = 0.
      lv_tmp = letter_to_index( iv_letter = lv_letter ).
      lv_value = lv_value + ( ( mc_base ** lv_exp ) * lv_tmp ).
      lv_exp = lv_exp + 1.
    ENDDO.

    rv_index = lv_value.

  ENDMETHOD.                    "excelcol_to_index

  METHOD index_to_excelcol.
    "IMPORTING
    "  iv_index              TYPE i
    "RETURNING
    "  value(rv_excelcol)    TYPE lty_excel_col,

    DATA:
      lv_mod    TYPE i,
      lv_letter TYPE lty_letter,
      lv_digit  TYPE i,
      lv_value  TYPE i.

    CLEAR rv_excelcol.
    IF iv_index > mc_max_cols.
      RETURN.
    ENDIF.
    IF iv_index <= 0.
      RETURN.
    ENDIF.

    lv_value = iv_index.
    WHILE lv_value > 0.
      lv_mod = 0.
      lv_mod = ( lv_value - 1 ) MOD mc_base.
      lv_digit = lv_mod + 1.
      lv_letter = index_to_letter( iv_index = lv_digit ).
      CONCATENATE lv_letter rv_excelcol INTO rv_excelcol.
      lv_value = ( lv_value - lv_mod ) DIV mc_base.
    ENDWHILE.

  ENDMETHOD.                    "index_to_excelcol

  METHOD letter_to_index.
    "IMPORTING
    "  iv_letter           TYPE lty_letter
    "RETURNING
    "  value(rv_index)     TYPE i.

    DATA:
      lr_map      TYPE REF TO mty_map_index_s.

    rv_index = 0.
    IF iv_letter IS INITIAL.
      RETURN.
    ENDIF.
    READ TABLE mt_map_index WITH TABLE KEY letter = iv_letter REFERENCE INTO lr_map.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    rv_index = lr_map->index.

  ENDMETHOD.                    "letter_to_index

  METHOD index_to_letter.
    "IMPORTING
    "  iv_index            TYPE i
    "RETURNING
    "  value(rv_letter)    TYPE lty_letter,

    DATA:
      lr_map      TYPE REF TO mty_map_index_s.

    CLEAR rv_letter.
    IF iv_index <= 0.
      RETURN.
    ENDIF.
    READ TABLE mt_map_letter WITH TABLE KEY index = iv_index REFERENCE INTO lr_map.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    rv_letter = lr_map->letter.

  ENDMETHOD.                    "index_to_Letter

  METHOD generate_typeinfo.
    "IMPORTING
    "  it_data               TYPE ANY TABLE
    "EXPORTING
    "  et_typeinfo           TYPE lty_typeinfo_t,

    DATA:
      lv_index      TYPE i,
      lr_typeinfo   TYPE REF TO lty_typeinfo_s,
      lr_tabledescr TYPE REF TO cl_abap_tabledescr.

    CLEAR et_typeinfo.
    TRY.
        CLEAR lr_tabledescr.
        lr_tabledescr ?= cl_abap_typedescr=>describe_by_data( p_data = it_data ).

        lv_index = 1.
        INSERT INITIAL LINE INTO TABLE et_typeinfo REFERENCE INTO lr_typeinfo.
        lr_typeinfo->key = lv_index.

        add_typeinfo_attribs( EXPORTING
                                ir_type     = lr_tabledescr
                              CHANGING
                                cs_typeinfo = lr_typeinfo->* ).

        create_child_records( EXPORTING
                                ir_type          = lr_tabledescr
                                is_typeinfo      = lr_typeinfo->*
                                "iv_current_index = lv_index
                              CHANGING
                                ct_typeinfo      = et_typeinfo ).
      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.                    "generate_typeinfo

  METHOD generate_hierinfo.
    "IMPORTING
    "  it_data               TYPE ANY TABLE
    "EXPORTING
    "  et_hierinfo           TYPE lty_hierarchy_info_t,
    DATA:
      lv_index      TYPE i,
      lr_hierinfo   TYPE REF TO lty_hierarchy_info_s,
      lr_tabledescr TYPE REF TO cl_abap_tabledescr.

    CLEAR et_hierinfo.
    TRY.
        CLEAR lr_tabledescr.
        lr_tabledescr ?= cl_abap_typedescr=>describe_by_data( p_data = it_data ).

        lv_index = 1.
        INSERT INITIAL LINE INTO TABLE et_hierinfo REFERENCE INTO lr_hierinfo.
        lr_hierinfo->key = lv_index.
        add_typeinfo_attribs_h( EXPORTING
                                ir_type     = lr_tabledescr
                              CHANGING
                                cs_hierinfo = lr_hierinfo->* ).

        create_child_records_h( EXPORTING
                                  ir_type          = lr_tabledescr
                                  is_hierinfo      = lr_hierinfo->*
                                CHANGING
                                  ct_hierinfo      = et_hierinfo ).
      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.                    "generate_struct_info

  METHOD convert_typeinfo_to_tree.
    "IMPORTING
    "  it_typeinfo           TYPE lty_typeinfo_t
    "RETURNING
    "  value(rr_tree)        TYPE REF TO lcl_typeinfo_node,

    DATA:
      lt_nodes    TYPE lty_typeinfo_node_st,
      ls_nodes    TYPE lty_typeinfo_node_s,
      lr_nodes    TYPE REF TO lty_typeinfo_node_s,
      lv_index    TYPE i,
      lr_node     TYPE REF TO lcl_typeinfo_node,
      lr_parent   TYPE REF TO lcl_typeinfo_node,
      lr_typeinfo TYPE REF TO lty_typeinfo_s.

    CLEAR lr_parent.
    CLEAR lr_node.
    CLEAR lt_nodes.
    lv_index = 0.
    LOOP AT it_typeinfo REFERENCE INTO lr_typeinfo.

      lv_index = sy-tabix.
      CLEAR lr_parent.
      READ TABLE lt_nodes WITH TABLE KEY key = lr_typeinfo->parent_key REFERENCE INTO lr_nodes.
      IF sy-subrc = 0.
        lr_parent = lr_nodes->node.
      ELSE.
        CLEAR lr_parent.
      ENDIF.

      CREATE OBJECT lr_node
        EXPORTING
          ir_parent   = lr_parent
          is_typeinfo = lr_typeinfo->*.
      IF lv_index = 1.
        rr_tree = lr_node.
      ENDIF.
      CLEAR ls_nodes.
      ls_nodes-key = lr_typeinfo->key.
      ls_nodes-node = lr_node.
      INSERT ls_nodes INTO TABLE lt_nodes.
*      IF sy-subrc <> 0.
*        BREAK-POINT.
*      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "convert_typeinfo_to_tree

*  METHOD convert_hierinfo_to_tree.
*    "IMPORTING
*    "  it_hierinfo           TYPE lty_hierarchy_info_t
*    "RETURNING
*    "  value(rr_tree)        TYPE REF TO lcl_relinfo_node,
*
*    DATA:
*      lt_nodes               TYPE lty_typeinfo_node_st,
*      ls_nodes               TYPE lty_typeinfo_node_s,
*      lr_nodes               TYPE REF TO lty_typeinfo_node_s,
*      lv_index               TYPE i,
*      lr_node                TYPE REF TO lcl_relinfo_node,
*      lr_parent              TYPE REF TO lcl_relinfo_node,
*      lr_hierinfo            TYPE REF TO lty_hierarchy_info_s.
*
*    CLEAR lr_parent.
*    CLEAR lr_node.
*    CLEAR lt_nodes.
*    lv_index = 0.
*    LOOP AT it_hierinfo REFERENCE INTO lr_hierinfo.
*
*      lv_index = sy-tabix.
*      CLEAR lr_parent.
*      READ TABLE lt_nodes WITH TABLE KEY key = lr_hierinfo->parent_key REFERENCE INTO lr_nodes.
*      IF sy-subrc = 0.
*        lr_parent ?= lr_nodes->node.
*      ELSE.
*        CLEAR lr_parent.
*      ENDIF.
*
*      CREATE OBJECT lr_node
*        EXPORTING
*          ir_parent   = lr_parent
*          is_hierinfo = lr_hierinfo->*.
*      IF lv_index = 1.
*        rr_tree = lr_node.
*      ENDIF.
*      CLEAR ls_nodes.
*      ls_nodes-key = lr_hierinfo->key.
*      ls_nodes-node = lr_node.
*      INSERT ls_nodes INTO TABLE lt_nodes.
**      IF sy-subrc <> 0.
**        BREAK-POINT.
**      ENDIF.
*
*    ENDLOOP.
*
*  ENDMETHOD.                    "convert_hierinfo_to_tree

  METHOD create_data_from_tree.
    "importing
    "  ir_root        TYPE REF TO lcl_typeinfo_node
    "  iv_use_ddic    type abap_bool default abap_true
    "returning
    "  value(rr_data) type ref to data

    DATA:
      lr_datadescr            TYPE REF TO cl_abap_datadescr.

    IF ir_root IS INITIAL.
      RETURN.
    ENDIF.

    TRY.
        CLEAR lr_datadescr.
        lr_datadescr = ir_root->create_datadescr( iv_use_ddic = iv_use_ddic ).
        IF lr_datadescr IS BOUND.
          CREATE DATA rr_data TYPE HANDLE lr_datadescr.
        ENDIF.
      CATCH cx_root.
    ENDTRY.
  ENDMETHOD.                    "create_data_from_tree

  METHOD load_xlsx_file.
    "IMPORTING
    "  iv_filename           TYPE lty_filename
    "RETURNING
    "  value(rr_xlsx)        TYPE REF TO lcl_xlsx_wrapper,

    DATA:
      lv_len  TYPE i,
      lt_data TYPE lty_x_buf_t,
      lv_data TYPE xstring.

    CLEAR lt_data.
    lv_len = 0.

    cl_gui_frontend_services=>gui_upload(
      EXPORTING
        filename                = iv_filename
        filetype                = 'BIN'
      IMPORTING
        filelength              = lv_len
      CHANGING
        data_tab                = lt_data
      EXCEPTIONS
        file_open_error         = 1
        file_read_error         = 2
        no_batch                = 3
        gui_refuse_filetransfer = 4
        invalid_type            = 5
        no_authority            = 6
        unknown_error           = 7
        bad_data_format         = 8
        header_not_allowed      = 9
        separator_not_allowed   = 10
        header_too_long         = 11
        unknown_dp_error        = 12
        access_denied           = 13
        dp_out_of_memory        = 14
        disk_full               = 15
        dp_timeout              = 16
        not_supported_by_gui    = 17
        error_no_gui            = 18
        OTHERS                  = 19 ).
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    CLEAR lv_data.
    CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
      EXPORTING
        input_length = lv_len
      IMPORTING
        buffer       = lv_data
      TABLES
        binary_tab   = lt_data
      EXCEPTIONS
        failed       = 1
        OTHERS       = 2.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    rr_xlsx = lcl_xlsx_wrapper=>create_from_binary_data( iv_data = lv_data ).

  ENDMETHOD.                    "load_xlsx_file

  METHOD save_xlsx_file.
    "IMPORTING
    "  ir_xlsx              TYPE REF TO lcl_xlsx_wrapper,
    "  iv_filename           TYPE lty_filename,

    DATA:
      lv_len  TYPE i,
      lt_data TYPE lty_x_buf_t,
      lv_tmp  TYPE xstring.

    IF ir_xlsx IS INITIAL.
      RETURN.
    ENDIF.
    IF iv_filename IS INITIAL.
      RETURN.
    ENDIF.
    CLEAR lv_tmp.
    ir_xlsx->get_raw_data_to_save( IMPORTING
                                     ev_data = lv_tmp ).

    CLEAR lt_data.
    CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
      EXPORTING
        buffer        = lv_tmp
      IMPORTING
        output_length = lv_len
      TABLES
        binary_tab    = lt_data.

    CALL METHOD cl_gui_frontend_services=>gui_download
      EXPORTING
        bin_filesize            = lv_len
        filename                = iv_filename
        filetype                = 'BIN'
        confirm_overwrite       = abap_true
      CHANGING
        data_tab                = lt_data
      EXCEPTIONS
        file_write_error        = 1
        no_batch                = 2
        gui_refuse_filetransfer = 3
        invalid_type            = 4
        no_authority            = 5
        unknown_error           = 6
        header_not_allowed      = 7
        separator_not_allowed   = 8
        filesize_not_allowed    = 9
        header_too_long         = 10
        dp_error_create         = 11
        dp_error_send           = 12
        dp_error_write          = 13
        unknown_dp_error        = 14
        access_denied           = 15
        dp_out_of_memory        = 16
        disk_full               = 17
        dp_timeout              = 18
        file_not_found          = 19
        dataprovider_exception  = 20
        control_flush_error     = 21
        not_supported_by_gui    = 22
        error_no_gui            = 23
        OTHERS                  = 24.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

  ENDMETHOD.                    "save_xlsx_file

  METHOD add_typeinfo_attribs.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "CHANGING
    "  cs_typeinfo         TYPE lty_typeinfo_s,

    DATA:
      lv_char_len    TYPE i,
      lr_tabledescr  TYPE REF TO cl_abap_tabledescr,
      lr_structdescr TYPE REF TO cl_abap_structdescr.

    IF ir_type IS INITIAL.
      RETURN.
    ENDIF.
    lv_char_len = cl_abap_char_utilities=>charsize.
    cs_typeinfo-absolute_name = ir_type->absolute_name.
    cs_typeinfo-relative_name = ir_type->get_relative_name( ).
    cs_typeinfo-type_kind = ir_type->type_kind.
    CASE cs_typeinfo-type_kind.
      WHEN cl_abap_typedescr=>typekind_num.
        cs_typeinfo-length = ir_type->length / lv_char_len.
      WHEN cl_abap_typedescr=>typekind_char.
        cs_typeinfo-length = ir_type->length / lv_char_len.
      WHEN OTHERS.
        cs_typeinfo-length = ir_type->length.
    ENDCASE.
    cs_typeinfo-decimals = ir_type->decimals.
    cs_typeinfo-kind = ir_type->kind.
    TRY.
        CASE cs_typeinfo-kind.
          WHEN cl_abap_typedescr=>kind_struct.
            CLEAR lr_structdescr.
            lr_structdescr ?= ir_type.
            cs_typeinfo-struct_kind = lr_structdescr->struct_kind.
          WHEN cl_abap_typedescr=>kind_table.
            CLEAR lr_tabledescr.
            lr_tabledescr ?= ir_type.
            cs_typeinfo-table_kind = lr_tabledescr->table_kind.
        ENDCASE.
      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.                    "add_typeinfo_attibs

  METHOD add_typeinfo_attribs_h.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "CHANGING
    "  cs_hierinfo         TYPE lty_hierarchy_info_s,

    FIELD-SYMBOLS:
      <fs_typeinfo>          TYPE lty_typeinfo_s.
    DATA:
      lr_hierinfo            TYPE REF TO lty_hierarchy_info_s.

    "this will give syntax error for some reason
    "ASSIGN cs_hierinfo TO <fs_typeinfo> CASTING
    "therefore the workaround via ref-variable, which seems unnecessary at first.

    CLEAR lr_hierinfo.
    GET REFERENCE OF cs_hierinfo INTO lr_hierinfo.
    UNASSIGN <fs_typeinfo>.
    ASSIGN lr_hierinfo->* TO <fs_typeinfo> CASTING.
    IF <fs_typeinfo> IS ASSIGNED.
      add_typeinfo_attribs( EXPORTING
                              ir_type     = ir_type
                            CHANGING
                              cs_typeinfo = <fs_typeinfo> ).
    ENDIF.

  ENDMETHOD.                    "add_typeinfo_attribs_h

  METHOD create_child_records.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "  is_typeinfo         TYPE lty_typeinfo_s
    "CHANGING
    "  ct_typeinfo         TYPE lty_typeinfo_t,

    IF ir_type->kind = cl_abap_typedescr=>kind_struct.
      handle_struct( EXPORTING
                       ir_type          = ir_type
                       is_typeinfo      = is_typeinfo
                     CHANGING
                       ct_typeinfo      = ct_typeinfo ).
    ELSEIF ir_type->kind = cl_abap_typedescr=>kind_table.
      handle_table( EXPORTING
                      ir_type          = ir_type
                      is_typeinfo      = is_typeinfo
                    CHANGING
                      ct_typeinfo      = ct_typeinfo ).
    ENDIF.

  ENDMETHOD.                    "create_child_records

  METHOD handle_struct.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "  is_typeinfo         TYPE lty_typeinfo_s
    "CHANGING
    "  ct_typeinfo         TYPE lty_typeinfo_t,

    DATA:
      lv_index       TYPE i,
      lv_fieldpos    TYPE i,
      lr_typeinfo    TYPE REF TO lty_typeinfo_s,
      lr_structdescr TYPE REF TO cl_abap_structdescr,
      lr_component   TYPE REF TO cl_abap_structdescr=>component,
      lt_components  TYPE cl_abap_structdescr=>component_table.

    TRY.

        CLEAR lr_structdescr.
        lr_structdescr ?= ir_type.
        CLEAR lt_components.
        lt_components = lr_structdescr->get_components( ).
        lv_fieldpos = 0.

        LOOP AT lt_components REFERENCE INTO lr_component.

          DESCRIBE TABLE ct_typeinfo LINES lv_index.
          lv_index = lv_index + 1.
          INSERT INITIAL LINE INTO TABLE ct_typeinfo REFERENCE INTO lr_typeinfo.
          lr_typeinfo->key = lv_index.
          lr_typeinfo->parent_key = is_typeinfo-key.
          add_typeinfo_attribs( EXPORTING
                                  ir_type     = lr_component->type
                                CHANGING
                                  cs_typeinfo = lr_typeinfo->* ).
          lv_fieldpos = lv_fieldpos + 1.
          lr_typeinfo->field_pos = lv_fieldpos.
          lr_typeinfo->field_name = lr_component->name.
          lr_typeinfo->as_include = lr_component->as_include.
          IF lr_component->type->kind = cl_abap_typedescr=>kind_struct OR
            lr_component->type->kind = cl_abap_typedescr=>kind_table.

            create_child_records( EXPORTING
                                    ir_type          = lr_component->type
                                    is_typeinfo      = lr_typeinfo->*
                                    "iv_current_index = lv_index
                                  CHANGING
                                    ct_typeinfo      = ct_typeinfo ).
          ENDIF.

        ENDLOOP.

      CATCH cx_root.
        RETURN.
    ENDTRY.

  ENDMETHOD.                    "handle_struct

  METHOD handle_table.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "  is_typeinfo         TYPE lty_typeinfo_s
    "CHANGING
    "  ct_typeinfo         TYPE lty_typeinfo_t,

    DATA:
      lv_index      TYPE i,
      lr_typeinfo   TYPE REF TO lty_typeinfo_s,
      lr_linetype   TYPE REF TO cl_abap_datadescr,
      lr_tabledescr TYPE REF TO cl_abap_tabledescr.

    TRY.
        CLEAR lr_tabledescr.
        lr_tabledescr ?= ir_type.
        CLEAR lr_linetype.
        lr_linetype = lr_tabledescr->get_table_line_type( ).
        IF lr_linetype IS INITIAL.
          RETURN.
        ENDIF.
        DESCRIBE TABLE ct_typeinfo LINES lv_index.
        lv_index = lv_index + 1.
        INSERT INITIAL LINE INTO TABLE ct_typeinfo REFERENCE INTO lr_typeinfo.
        lr_typeinfo->key = lv_index.
        lr_typeinfo->parent_key = is_typeinfo-key.
        add_typeinfo_attribs( EXPORTING
                                ir_type     = lr_linetype
                              CHANGING
                                cs_typeinfo = lr_typeinfo->* ).

        IF lr_linetype->kind = cl_abap_typedescr=>kind_struct OR
          lr_linetype->kind = cl_abap_typedescr=>kind_table.

          create_child_records( EXPORTING
                                  ir_type          = lr_linetype
                                  is_typeinfo      = lr_typeinfo->*
                                  "iv_current_index = lv_index
                                CHANGING
                                  ct_typeinfo      = ct_typeinfo ).

        ENDIF.
      CATCH cx_root.
        RETURN.
    ENDTRY.

  ENDMETHOD.                    "handle_table

  METHOD create_child_records_h.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "  is_hierinfo         TYPE lty_hierarchy_info_s
    "CHANGING
    "  ct_hierinfo         TYPE lty_hierarchy_info_t,

    IF ir_type->kind = cl_abap_typedescr=>kind_struct.
      handle_struct_h( EXPORTING
                       ir_type          = ir_type
                       is_hierinfo      = is_hierinfo
                     CHANGING
                       ct_hierinfo      = ct_hierinfo ).
    ELSEIF ir_type->kind = cl_abap_typedescr=>kind_table.
      handle_table_h( EXPORTING
                      ir_type          = ir_type
                      is_hierinfo      = is_hierinfo
                    CHANGING
                      ct_hierinfo      = ct_hierinfo ).
    ENDIF.

  ENDMETHOD.                    "create_child_records_h

  METHOD handle_struct_h.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "  is_hierinfo         TYPE lty_hierarchy_info_s
    "CHANGING
    "  ct_hierinfo         TYPE lty_hierarchy_info_t,

    DATA:
      lv_index       TYPE i,
      lv_fieldpos    TYPE i,
      lr_hierinfo    TYPE REF TO lty_hierarchy_info_s,
      lr_structdescr TYPE REF TO cl_abap_structdescr,
      lr_component   TYPE REF TO cl_abap_structdescr=>component,
      lt_components  TYPE cl_abap_structdescr=>component_table.

    TRY.

        CLEAR lr_structdescr.
        lr_structdescr ?= ir_type.
        CLEAR lt_components.
        lt_components = lr_structdescr->get_components( ).
        lv_fieldpos = 0.

        LOOP AT lt_components REFERENCE INTO lr_component.

          IF ( lr_component->type->kind = cl_abap_typedescr=>kind_struct AND lr_component->as_include = abap_false )
             OR lr_component->type->kind = cl_abap_typedescr=>kind_table.

            DESCRIBE TABLE ct_hierinfo LINES lv_index.
            lv_index = lv_index + 1.
            INSERT INITIAL LINE INTO TABLE ct_hierinfo REFERENCE INTO lr_hierinfo.
            lr_hierinfo->key = lv_index.
            lr_hierinfo->parent_key = is_hierinfo-key.
            add_typeinfo_attribs_h( EXPORTING
                                      ir_type     = lr_component->type
                                    CHANGING
                                      cs_hierinfo = lr_hierinfo->* ).
            lv_fieldpos = lv_fieldpos + 1.
            lr_hierinfo->field_pos = lv_fieldpos.
            lr_hierinfo->field_name = lr_component->name.
            lr_hierinfo->as_include = lr_component->as_include.

            create_child_records_h( EXPORTING
                                      ir_type          = lr_component->type
                                      is_hierinfo      = lr_hierinfo->*
                                    CHANGING
                                      ct_hierinfo      = ct_hierinfo ).

          ELSEIF lr_component->type->kind = cl_abap_typedescr=>kind_struct AND lr_component->as_include = abap_true.

            create_child_records_h( EXPORTING
                                      ir_type          = lr_component->type
                                      is_hierinfo      = is_hierinfo
                                    CHANGING
                                      ct_hierinfo      = ct_hierinfo ).
          ENDIF.
        ENDLOOP.

      CATCH cx_root.
        RETURN.
    ENDTRY.

  ENDMETHOD.                    "handle_struct_h

  METHOD handle_table_h.
    "IMPORTING
    "  ir_type             TYPE REF TO cl_abap_typedescr
    "  is_hierinfo         TYPE lty_hierarchy_info_s
    "CHANGING
    "  ct_hierinfo         TYPE lty_hierarchy_info_t,

    DATA:
      lv_index      TYPE i,
      lr_hierinfo   TYPE REF TO lty_hierarchy_info_s,
      lr_linetype   TYPE REF TO cl_abap_datadescr,
      lr_tabledescr TYPE REF TO cl_abap_tabledescr.

    TRY.
        CLEAR lr_tabledescr.
        lr_tabledescr ?= ir_type.
        CLEAR lr_linetype.
        lr_linetype = lr_tabledescr->get_table_line_type( ).
        IF lr_linetype IS INITIAL.
          RETURN.
        ENDIF.
        DESCRIBE TABLE ct_hierinfo LINES lv_index.
        lv_index = lv_index + 1.
        INSERT INITIAL LINE INTO TABLE ct_hierinfo REFERENCE INTO lr_hierinfo.
        lr_hierinfo->key = lv_index.
        lr_hierinfo->parent_key = is_hierinfo-key.
        add_typeinfo_attribs_h( EXPORTING
                                  ir_type     = lr_linetype
                                CHANGING
                                  cs_hierinfo = lr_hierinfo->* ).

        IF lr_linetype->kind = cl_abap_typedescr=>kind_struct OR
          lr_linetype->kind = cl_abap_typedescr=>kind_table.

          create_child_records_h( EXPORTING
                                    ir_type          = lr_linetype
                                    is_hierinfo      = lr_hierinfo->*
                                  CHANGING
                                    ct_hierinfo      = ct_hierinfo ).

        ENDIF.
      CATCH cx_root.
        RETURN.
    ENDTRY.

  ENDMETHOD.                    "handle_table_h

ENDCLASS.                    "lcl_excel_helper IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_excel_wrapper IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_xlsx_wrapper IMPLEMENTATION.

  METHOD add_xml_data.
    "IMPORTING
    "  is_data               TYPE lty_xmldocs_xstr,

    DATA:
      lr_sheet    TYPE REF TO lty_sheetxml_xstr_s,
      lv_filename TYPE lty_filename.

    CLEAR lv_filename.
    lv_filename = lcl_default_xml=>mv_fname_content_type.
    mr_zip->add( name    = lv_filename
                 content = is_data-content ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_docprops '/' lcl_default_xml=>mv_fname_app INTO lv_filename.
    mr_zip->add( name    = lv_filename
                 content = is_data-app ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_sharedstr INTO lv_filename.
    mr_zip->add( name    = lv_filename
                 content = is_data-shared_strings ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_workbook INTO lv_filename.
    mr_zip->add( name    = lv_filename
                 content = is_data-workbook ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_xl__rels '/' lcl_default_xml=>mv_fname_wb_rel INTO lv_filename.
    mr_zip->add( name    = lv_filename
                 content = is_data-workbook_rels ).

    LOOP AT is_data-sheets REFERENCE INTO lr_sheet.
      CLEAR lv_filename.
      CONCATENATE lcl_default_xml=>mv_path_xl_worksheets '/' lr_sheet->sheetid '.xml' INTO lv_filename.
      CONDENSE lv_filename.
      mr_zip->add( name    = lv_filename
                   content = lr_sheet->sheet ).
    ENDLOOP.

  ENDMETHOD.                    "add_xml_data

  METHOD get_xml_data.
    "exporting
    "  es_data               TYPE lty_xmldocs_xstr,

*  BEGIN OF lty_xmldocs_xstr,
*    content                 TYPE xstring,
*    app                     TYPE xstring,
*    shared_strings          TYPE xstring,
*    sheets                  TYPE lty_sheetxml_xstr_t,
*    workbook                TYPE xstring,
*    workbook_rels           TYPE xstring,
*  END OF lty_xmldocs_xstr,

    DATA:
      lv_filename         TYPE lty_filename.

    CLEAR es_data.

    CLEAR lv_filename.
    lv_filename = lcl_default_xml=>mv_fname_content_type.
    mr_zip->get( EXPORTING
                   name    = lv_filename
                 IMPORTING
                   content = es_data-content ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_docprops '/' lcl_default_xml=>mv_fname_app INTO lv_filename.
    mr_zip->get( EXPORTING
                   name    = lv_filename
                 IMPORTING
                   content = es_data-app ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_sharedstr INTO lv_filename.
    mr_zip->get( EXPORTING
                   name    = lv_filename
                 IMPORTING
                   content = es_data-shared_strings ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_workbook INTO lv_filename.
    mr_zip->get( EXPORTING
                   name    = lv_filename
                 IMPORTING
                   content = es_data-workbook ).

    CLEAR lv_filename.
    CONCATENATE lcl_default_xml=>mv_path_xl__rels '/' lcl_default_xml=>mv_fname_wb_rel INTO lv_filename.
    mr_zip->get( EXPORTING
                   name    = lv_filename
                 IMPORTING
                   content = es_data-workbook_rels ).

    DATA:
      lt_result  TYPE match_result_tab,
      lr_result  TYPE REF TO match_result,
      ls_sheet   TYPE lty_sheetxml_xstr_s,
      lv_pattern TYPE string,
      lv_tmp     TYPE string,
      lv_len     TYPE i,
      lr_file    TYPE REF TO cl_abap_zip=>t_file.

    CONCATENATE lcl_default_xml=>mv_path_xl_worksheets '/' 'sheet' '*' '.xml' INTO lv_pattern.

    LOOP AT mr_zip->files REFERENCE INTO lr_file.
      IF lr_file->name CP lv_pattern.

        CLEAR ls_sheet.

        CLEAR lt_result.
        FIND REGEX '/sheet[[:digit:]]*.xml' IN lr_file->name RESULTS lt_result.
        READ TABLE lt_result INDEX 1 REFERENCE INTO lr_result.
        IF sy-subrc = 0.
          CLEAR lv_tmp.
          lv_tmp = lr_file->name+lr_result->offset(lr_result->length).
          SHIFT lv_tmp BY 1 PLACES LEFT.
          CONDENSE lv_tmp.
          lv_len = strlen( lv_tmp ).
          lv_len = lv_len - 4.
          lv_tmp = lv_tmp(lv_len).
          ls_sheet-sheetid = lv_tmp.
          mr_zip->get( EXPORTING
                         name    = lr_file->name
                       IMPORTING
                         content = ls_sheet-sheet ).
          ls_sheet-filename = lr_file->name.
          INSERT ls_sheet INTO TABLE es_data-sheets.
        ENDIF.


      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "get_xml_data

  METHOD get_xml_data_2.
    "EXPORTING
    "  er_content_xml        type ref to if_ixml_document
    "  es_data               TYPE lty_xmldocs_xstr,

    DATA:
      lr_exc_root TYPE REF TO cx_root,
      lv_filename TYPE lty_filename.

    TRY.

        CLEAR es_data.
        CLEAR er_content_xml.

        CLEAR lv_filename.
        lv_filename = lcl_default_xml=>mv_fname_content_type.
        " Begin of Note 2877486
*        mr_zip->get( EXPORTING
*                       name    = lv_filename
*                     IMPORTING
*                       content = es_data-content ).
        mr_zip->get(
          EXPORTING
            name    = lv_filename
          IMPORTING
            content = es_data-content
          EXCEPTIONS
            zip_index_error         = 1
            zip_decompression_error = 2
            OTHERS                  = 3 ).
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE /aif/cx_lfa_map_error.
        ENDIF.
        " End of Note 2877486
        CLEAR mr_ixml.
        CLEAR mr_stream_factory.

        mr_ixml = cl_ixml=>create( ).
        mr_stream_factory = mr_ixml->create_stream_factory( ).

        er_content_xml = create_xml_doc( es_data-content ).

        DATA:
          lr_data_root TYPE REF TO if_ixml_element,
          lr_root      TYPE REF TO if_ixml_element.

        CLEAR lr_root.
        lr_root = er_content_xml->get_root_element( ).
        IF lr_root IS INITIAL.
          RETURN.
        ENDIF.

        DATA:
          lv_len_node_list TYPE i,
          lv_index         TYPE i,
          lv_cont_type     TYPE string,
          lv_node_name     TYPE string,
          lr_child_elem    TYPE REF TO if_ixml_element,
          lr_node_list     TYPE REF TO if_ixml_node_list.

        DATA:
          lt_result  TYPE match_result_tab,
          lr_result  TYPE REF TO match_result,
          ls_sheet   TYPE lty_sheetxml_xstr_s,
          lv_pattern TYPE string,
          lv_tmp     TYPE string,
          lv_len     TYPE i.

        CLEAR lr_node_list.
        lr_node_list = lr_root->get_children( ).
        IF lr_node_list IS INITIAL.
          RETURN.
        ENDIF.

        lv_len_node_list = lr_node_list->get_length( ).
        lv_index = 0.
        WHILE lv_index < lv_len_node_list.

          lr_child_elem ?= lr_node_list->get_item( index = lv_index ).
          lv_index = lv_index + 1.
          IF lr_child_elem IS INITIAL.
            CONTINUE.
          ENDIF.
          CLEAR lv_node_name.
          lv_node_name = lr_child_elem->get_name( ).
          IF lv_node_name = 'Override'.
            CLEAR lv_cont_type.
            lv_cont_type = lr_child_elem->get_attribute( name = 'ContentType' ).
            CASE lv_cont_type.
              WHEN 'application/vnd.openxmlformats-officedocument.extended-properties+xml'.
                CLEAR lv_filename.
                lv_filename = lr_child_elem->get_attribute( name = 'PartName' ).
                SHIFT lv_filename BY 1 PLACES LEFT.
                mr_zip->get( EXPORTING
                               name    = lv_filename
                             IMPORTING
                               content = es_data-app ).
              WHEN 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml'.
                CLEAR lv_filename.
                lv_filename = lr_child_elem->get_attribute( name = 'PartName' ).
                SHIFT lv_filename BY 1 PLACES LEFT.
                mr_zip->get( EXPORTING
                               name    = lv_filename
                             IMPORTING
                               content = es_data-shared_strings ).
              WHEN 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'.
                CLEAR lv_filename.
                lv_filename = lr_child_elem->get_attribute( name = 'PartName' ).
                SHIFT lv_filename BY 1 PLACES LEFT.
                mr_zip->get( EXPORTING
                               name    = lv_filename
                             IMPORTING
                               content = es_data-workbook ).
              WHEN 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'.
                CLEAR ls_sheet.
                CLEAR lv_filename.
                lv_filename = lr_child_elem->get_attribute( name = 'PartName' ).
                ls_sheet-filename = lv_filename.
                SHIFT lv_filename BY 1 PLACES LEFT.

                CLEAR lt_result.
                FIND REGEX '/sheet[[:digit:]]*.xml' IN lv_filename RESULTS lt_result.
                READ TABLE lt_result INDEX 1 REFERENCE INTO lr_result.
                IF sy-subrc = 0.
                  CLEAR lv_tmp.
                  lv_tmp = lv_filename+lr_result->offset(lr_result->length).
                  SHIFT lv_tmp BY 1 PLACES LEFT.
                  CONDENSE lv_tmp.
                  lv_len = strlen( lv_tmp ).
                  lv_len = lv_len - 4.
                  lv_tmp = lv_tmp(lv_len).
                  ls_sheet-sheetid = lv_tmp.
                  mr_zip->get( EXPORTING
                                 name    = lv_filename
                               IMPORTING
                                 content = ls_sheet-sheet ).
                  INSERT ls_sheet INTO TABLE es_data-sheets.
                ENDIF.

            ENDCASE.

          ENDIF.
        ENDWHILE.

        CLEAR lv_filename.
        CONCATENATE lcl_default_xml=>mv_path_xl__rels '/' lcl_default_xml=>mv_fname_wb_rel INTO lv_filename.
        mr_zip->get( EXPORTING
                       name    = lv_filename
                     IMPORTING
                       content = es_data-workbook_rels ).

      CATCH cx_root INTO lr_exc_root.
        MESSAGE e046(/aif/lfa_mes) INTO lv_tmp.
        /aif/cx_lfa_map_error=>raise_message( iv_previous = lr_exc_root ).
    ENDTRY.

  ENDMETHOD.                    "get_xml_data_2

  METHOD create_from_binary_data.
    "IMPORTING
    "  iv_data               TYPE xstring
    "RETURNING
    "  value(rr_wrapper)     TYPE REF TO lcl_xlsx_wrapper,

    DATA:
      lv_tmp  TYPE string,
      lr_root TYPE REF TO cx_root.

    TRY.
        CREATE OBJECT rr_wrapper.
        rr_wrapper->mr_zip->load( zip = iv_data ).
      CATCH cx_root INTO lr_root.
        MESSAGE e044(/aif/lfa_mes) INTO lv_tmp.
        /aif/cx_lfa_map_error=>raise_message( iv_previous = lr_root ).
    ENDTRY.

  ENDMETHOD.                    "create_from_binary_data

  METHOD create_empty_xlsx_file.
    "RETURNING
    "  value(rr_wrapper)              TYPE REF TO lcl_xlsx_wrapper,

    CREATE OBJECT rr_wrapper.
    rr_wrapper->set_initial_files( ).

  ENDMETHOD.                    "create_empty_xlx_file

  METHOD create_initial_xlsx_file.
    "RETURNING
    "  value(rr_wrapper)              TYPE REF TO lcl_xlsx_wrapper,

    CREATE OBJECT rr_wrapper.
    rr_wrapper->set_initial_no_change_files( ).

  ENDMETHOD.                    "create_initial_xlsx_file
  METHOD class_constructor.

  ENDMETHOD.                    "class_constructor

  METHOD constructor.

    CLEAR mr_zip.
    CREATE OBJECT mr_zip.

  ENDMETHOD.                    "constructor

  METHOD get_raw_data_to_save.
    "EXPORTING
    "  ev_data               TYPE xstring.

    CLEAR ev_data.
    ev_data = mr_zip->save( ).

  ENDMETHOD.                    "get_raw_data_to_save

  METHOD set_initial_no_change_files.

    DATA:
      lv_filename TYPE lty_filename,
      lv_content  TYPE xstring.

    TRY.

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_docprops '/' lcl_default_xml=>mv_fname_core INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_core( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_styles INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_styles( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_xl_theme '/' lcl_default_xml=>mv_fname_theme INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_themes( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path__rels '/' lcl_default_xml=>mv_fname_dot_rels INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_rels( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.                    "set_initial_no_change_files

  METHOD create_xml_doc.
    "IMPORTING
    "  iv_content            TYPE xstring
    "RETURNING
    "  value(rr_document)    TYPE REF TO if_ixml_document,

    DATA:
      lr_stream TYPE REF TO if_ixml_istream,
      lr_parser TYPE REF TO if_ixml_parser.

    CLEAR rr_document.
    CLEAR lr_stream.
    lr_stream = mr_stream_factory->create_istream_xstring( string = iv_content ).
    rr_document = mr_ixml->create_document( ).
    lr_parser = mr_ixml->create_parser( document       = rr_document
                                        istream        = lr_stream
                                        stream_factory = mr_stream_factory ).
    lr_parser->set_normalizing( is_normalizing = abap_true ).
    IF lr_parser->parse( ) <> 0.
      CLEAR rr_document.
      RETURN.
    ENDIF.

  ENDMETHOD.                    "create_xml_doc

  METHOD set_initial_data.
    "importing
    "  iv_data              type xstring,

  ENDMETHOD.                    "set_initial_data

  METHOD set_initial_files.

    DATA:
      lv_filename TYPE lty_filename,
      lv_content  TYPE xstring.

    TRY.

        set_initial_no_change_files( ).

        CLEAR lv_filename.
        CLEAR lv_content.
        lv_filename = lcl_default_xml=>mv_fname_content_type.
        lv_content = lcl_default_xml=>get_default_content_types( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_docprops '/' lcl_default_xml=>mv_fname_app INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_app( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_sharedstr INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_shared_str( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_xl '/' lcl_default_xml=>mv_fname_workbook INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_workbook( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_xl__rels '/' lcl_default_xml=>mv_fname_wb_rel INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_workbook_rels( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

        CLEAR lv_filename.
        CLEAR lv_content.
        CONCATENATE lcl_default_xml=>mv_path_xl_worksheets '/' lcl_default_xml=>mv_fname_sheet INTO lv_filename.
        lv_content = lcl_default_xml=>get_default_sheet( ).
        mr_zip->add( name    = lv_filename
                     content = lv_content ).

      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.                    "set_initial_files

ENDCLASS.                    "lcl_excel_wrapper IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_workbook IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_workbook IMPLEMENTATION.

  METHOD constructor.

    CLEAR mt_sheets.
    CLEAR mt_sheet_file_map.
    CLEAR mt_shared_strings.

  ENDMETHOD.                    "constructor

  METHOD add_worksheet.
    "importing
    "  iv_index                type i
    "  iv_sheetname            type lty_sheetname
    "returning
    "  value(rr_sheet)         type ref to lcl_worksheet,

    DATA:
      ls_sheet      TYPE lty_sheet_s.

    CLEAR rr_sheet.
    READ TABLE mt_sheets WITH TABLE KEY name = iv_sheetname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    CLEAR ls_sheet.
    ls_sheet-name = iv_sheetname.
    ls_sheet-index = iv_index.
    CREATE OBJECT ls_sheet-sheet
      EXPORTING
        iv_name = iv_sheetname.
    INSERT ls_sheet INTO TABLE mt_sheets.
    rr_sheet = ls_sheet-sheet.

  ENDMETHOD.                    "add_worksheet

  METHOD get_worksheet.
    "importing
    "  iv_sheetname            type lty_sheetname
    "returning
    "  value(rr_sheet)         type ref to lcl_worksheet,
    DATA:
      lr_sheet_data      TYPE REF TO lty_sheet_s.

    CLEAR rr_sheet.
    CLEAR lr_sheet_data.
    READ TABLE mt_sheets REFERENCE INTO lr_sheet_data WITH TABLE KEY name = iv_sheetname.
    IF sy-subrc = 0.
      rr_sheet = lr_sheet_data->sheet.
    ENDIF.

  ENDMETHOD.                    "get_worksheet

  METHOD get_worksheet_3.
    "importing
    "  iv_sheetname            type lty_sheetname
    "returning
    "  value(rr_sheet)         type ref to lcl_worksheet,
    DATA:
      lr_sheet_xml  TYPE REF TO lty_xmlsheet_s,
      lr_sheet_data TYPE REF TO lty_sheet_s.

    CLEAR rr_sheet.
    CLEAR lr_sheet_data.
    READ TABLE mt_sheets REFERENCE INTO lr_sheet_data WITH TABLE KEY name = iv_sheetname.
    IF sy-subrc = 0.
      READ TABLE ms_xmldocs-sheets WITH KEY name = iv_sheetname REFERENCE INTO lr_sheet_xml.
      IF sy-subrc = 0.
        IF lr_sheet_xml->sheet_xstr IS NOT INITIAL.
          lr_sheet_xml->sheet = create_xml_doc( lr_sheet_xml->sheet_xstr ).
          lr_sheet_data->sheet->add_data_from_xml( it_shared_strings = mt_shared_strings
                                                   ir_document       = lr_sheet_xml->sheet ).
          CLEAR lr_sheet_xml->sheet_xstr.
        ENDIF.
      ENDIF.
      rr_sheet = lr_sheet_data->sheet.
    ENDIF.

  ENDMETHOD.                    "get_worksheet_3

  METHOD get_worksheets.
    "EXPORTING
    "  et_sheets               TYPE lty_sheet_t,

    CLEAR et_sheets.
    et_sheets = mt_sheets.

  ENDMETHOD.                    "get_worksheets

  METHOD set_binary_data_2.
    "importing
    "  ir_content_xml          TYPE REF TO if_ixml_document
    "  is_bin_data             TYPE lty_xmldocs_xstr,

    DATA:
      lr_root           TYPE REF TO cx_root,
      lv_tmp            TYPE string,
      lt_result         TYPE match_result_tab,
      lr_result         TYPE REF TO match_result,
      lr_bin_sheet      TYPE REF TO lty_sheetxml_xstr_s,
      lr_sheet_file_map TYPE REF TO lty_sheet_file_map_s,
      ls_sheet          TYPE lty_xmlsheet_s.

    TRY.

        CLEAR mr_ixml.
        CLEAR mr_stream_factory.
        CLEAR ms_xmldocs.

        mr_ixml = cl_ixml=>create( ).
        mr_stream_factory = mr_ixml->create_stream_factory( ).

        ms_xmldocs-content = ir_content_xml.
        ms_xmldocs-app  = create_xml_doc( is_bin_data-app  ).
        ms_xmldocs-shared_strings  = create_xml_doc( is_bin_data-shared_strings  ).
        ms_xmldocs-workbook  = create_xml_doc( is_bin_data-workbook ).
        ms_xmldocs-workbook_rels  = create_xml_doc( is_bin_data-workbook_rels ).

        generate_shared_strings_table( ).

        generate_file_map( ).

        LOOP AT is_bin_data-sheets REFERENCE INTO lr_bin_sheet.

          CLEAR ls_sheet.
          lv_tmp = lr_bin_sheet->filename.
          SHIFT lv_tmp BY 4 PLACES LEFT.
          "ls_sheet-filename = lr_bin_sheet->filename.
          READ TABLE mt_sheet_file_map WITH KEY filename = lv_tmp REFERENCE INTO lr_sheet_file_map.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.
          MOVE-CORRESPONDING lr_sheet_file_map->* TO ls_sheet.
          ls_sheet-sheetid_str = lr_bin_sheet->sheetid.
          ls_sheet-sheet = create_xml_doc( lr_bin_sheet->sheet ).
          INSERT ls_sheet INTO TABLE ms_xmldocs-sheets.
        ENDLOOP.

        generate_sheets_from_xml_2( ).

      CATCH cx_root INTO lr_root.
        MESSAGE e047(/aif/lfa_mes) INTO lv_tmp.
        /aif/cx_lfa_map_error=>raise_message( iv_previous = lr_root ).
    ENDTRY.

  ENDMETHOD.                    "set_binary_data_2

  METHOD set_binary_data_3.
    "importing
    "  ir_content_xml          TYPE REF TO if_ixml_document
    "  is_bin_data             TYPE lty_xmldocs_xstr,

    DATA:
      lv_tmp            TYPE string,
      lt_result         TYPE match_result_tab,
      lr_result         TYPE REF TO match_result,
      lr_bin_sheet      TYPE REF TO lty_sheetxml_xstr_s,
      lr_sheet_file_map TYPE REF TO lty_sheet_file_map_s,
      ls_sheet          TYPE lty_xmlsheet_s.

    CLEAR mr_ixml.
    CLEAR mr_stream_factory.
    CLEAR ms_xmldocs.

    mr_ixml = cl_ixml=>create( ).
    mr_stream_factory = mr_ixml->create_stream_factory( ).

    ms_xmldocs-content = ir_content_xml.
    ms_xmldocs-app  = create_xml_doc( is_bin_data-app  ).
    ms_xmldocs-shared_strings  = create_xml_doc( is_bin_data-shared_strings  ).
    ms_xmldocs-workbook  = create_xml_doc( is_bin_data-workbook ).
    ms_xmldocs-workbook_rels  = create_xml_doc( is_bin_data-workbook_rels ).

    generate_shared_strings_table( ).

    generate_file_map( ).

    LOOP AT is_bin_data-sheets REFERENCE INTO lr_bin_sheet.

      CLEAR ls_sheet.
      lv_tmp = lr_bin_sheet->filename.
      SHIFT lv_tmp BY 4 PLACES LEFT.
      "ls_sheet-filename = lr_bin_sheet->filename.
      READ TABLE mt_sheet_file_map WITH KEY filename = lv_tmp REFERENCE INTO lr_sheet_file_map.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.
      MOVE-CORRESPONDING lr_sheet_file_map->* TO ls_sheet.
      ls_sheet-sheetid_str = lr_bin_sheet->sheetid.
      "ls_sheet-sheet = create_xml_doc( lr_bin_sheet->sheet ).
      ls_sheet-sheet_xstr = lr_bin_sheet->sheet.
      INSERT ls_sheet INTO TABLE ms_xmldocs-sheets.
    ENDLOOP.

    generate_sheets_from_xml_3( ).

  ENDMETHOD.                    "set_binary_data_3

  METHOD generate_file_map.

    DATA:
      lv_path           TYPE string,
      lr_root           TYPE REF TO if_ixml_element,
      lr_element        TYPE REF TO if_ixml_element,
      lr_node_list      TYPE REF TO if_ixml_node_list,
      lv_len            TYPE i,
      lv_index          TYPE i,
      lv_tmp            TYPE string,
      lv_attr_val       TYPE string,
      lr_child_elem     TYPE REF TO if_ixml_element,
      lr_sheet_file_map TYPE REF TO lty_sheet_file_map_s,
      ls_sheet_file_map TYPE lty_sheet_file_map_s.
    DATA lv_tabix TYPE sytabix. "Note 2688056

    CLEAR mt_sheet_file_map.
    CLEAR lr_root.
    lr_root = ms_xmldocs-workbook_rels->get_root_element( ).
    IF lr_root IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR lr_node_list.
    lr_node_list = lr_root->get_children( ).
    IF lr_node_list IS INITIAL.
      RETURN.
    ENDIF.
    lv_len = lr_node_list->get_length( ).
    lv_index = 0.
    WHILE lv_index < lv_len.

      lr_child_elem ?= lr_node_list->get_item( index = lv_index ).
      lv_index = lv_index + 1.
      IF lr_child_elem IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lv_attr_val.
      lv_attr_val = lr_child_elem->get_attribute( name = 'Type' ). "#EC NOTEXT
      IF lv_attr_val <> 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet'. "#EC NOTEXT
        CONTINUE.
      ENDIF.

      CLEAR ls_sheet_file_map.
      ls_sheet_file_map-relationid = lr_child_elem->get_attribute( name = 'Id' ).
      ls_sheet_file_map-filename = lr_child_elem->get_attribute( name = 'Target' ). "#EC NOTEXT
      INSERT ls_sheet_file_map INTO TABLE mt_sheet_file_map.

    ENDWHILE.

    CLEAR lr_root.
    lr_root = ms_xmldocs-workbook->get_root_element( ).
    lv_path = '/workbook/sheets'.
    CLEAR lr_element.
    lr_element = lr_root->find_from_path( path = lv_path ).
    IF lr_element IS INITIAL.
      RETURN.
    ENDIF.
    CLEAR lr_node_list.
    lr_node_list = lr_element->get_children( ).
    IF lr_node_list IS INITIAL.
      RETURN.
    ENDIF.
    lv_len = lr_node_list->get_length( ).
    lv_index = 0.
    WHILE lv_index < lv_len.
      CLEAR lr_child_elem.
      lr_child_elem ?= lr_node_list->get_item( index = lv_index ).
      lv_index = lv_index + 1.
      IF lr_child_elem IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lv_attr_val.
      lv_attr_val = lr_child_elem->get_attribute( name = 'id' namespace = 'r' ).
      READ TABLE mt_sheet_file_map WITH TABLE KEY relationid = lv_attr_val REFERENCE INTO lr_sheet_file_map.
      lv_tabix = sy-tabix."Note 2688056
      IF sy-subrc = 0.
        lr_sheet_file_map->sheetid = lr_child_elem->get_attribute( name = 'sheetId' ).
        lr_sheet_file_map->name = lr_child_elem->get_attribute( name = 'name' ).
        CHECK mt_excel_h IS NOT INITIAL."Note 2791686
*<<<<< begin of Note 2688056
        READ TABLE mt_excel_h TRANSPORTING NO FIELDS WITH TABLE KEY excel_sheet = lr_sheet_file_map->name.
        IF sy-subrc IS NOT INITIAL.
          DELETE mt_sheet_file_map INDEX lv_tabix.
        ENDIF.
*<<<<< end of Note 2688056
      ENDIF.

    ENDWHILE.

  ENDMETHOD.                    "generate_file_map

  METHOD set_binary_data.
    "importing
    "  is_bin_data             TYPE lty_xmldocs_xstr,

    DATA:
      lv_tmp       TYPE string,
      lt_result    TYPE match_result_tab,
      lr_result    TYPE REF TO match_result,
      lr_bin_sheet TYPE REF TO lty_sheetxml_xstr_s,
      ls_sheet     TYPE lty_xmlsheet_s.

    CLEAR mr_ixml.
    CLEAR mr_stream_factory.
    CLEAR ms_xmldocs.

    mr_ixml = cl_ixml=>create( ).
    mr_stream_factory = mr_ixml->create_stream_factory( ).

    ms_xmldocs-content = create_xml_doc( is_bin_data-content ).
    ms_xmldocs-app  = create_xml_doc( is_bin_data-app  ).
    ms_xmldocs-shared_strings  = create_xml_doc( is_bin_data-shared_strings  ).

    LOOP AT is_bin_data-sheets REFERENCE INTO lr_bin_sheet.

      CLEAR ls_sheet.
      CLEAR lt_result.
      FIND REGEX '[[:digit:]]+' IN lr_bin_sheet->sheetid RESULTS lt_result.
      READ TABLE lt_result INDEX 1 REFERENCE INTO lr_result.
      IF sy-subrc = 0.
        CLEAR lv_tmp.
        lv_tmp = lr_bin_sheet->sheetid+lr_result->offset(lr_result->length).
        CONDENSE lv_tmp.
        ls_sheet-sheetid = lv_tmp.
      ELSE.
        ls_sheet-sheetid = -999.
      ENDIF.
      ls_sheet-sheet = create_xml_doc( lr_bin_sheet->sheet ).
      INSERT ls_sheet INTO TABLE ms_xmldocs-sheets.
    ENDLOOP.

    ms_xmldocs-workbook  = create_xml_doc( is_bin_data-workbook ).
    ms_xmldocs-workbook_rels  = create_xml_doc( is_bin_data-workbook_rels ).

    generate_sheets_from_xml( ).

  ENDMETHOD.                    "set_binary_data

  METHOD generate_shared_strings_table.

    DATA:
      lv_len        TYPE i,
      lv_index      TYPE i,
      lv_tmp        TYPE string,
      lr_child_elem TYPE REF TO if_ixml_element,
      lr_val_elem   TYPE REF TO if_ixml_element,
      lr_element    TYPE REF TO if_ixml_element,
      lr_node_list  TYPE REF TO if_ixml_node_list.

    "generate shared strings table.
    CLEAR mt_shared_strings.
    CLEAR lr_element.
    lr_element = ms_xmldocs-shared_strings->get_root_element( ).
    IF lr_element IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR lr_node_list.
    lr_node_list = lr_element->get_children( ).
    IF lr_node_list IS INITIAL.
      RETURN.
    ENDIF.
    lv_len = lr_node_list->get_length( ).
    lv_index = 0.
    WHILE lv_index < lv_len.

      lr_child_elem ?= lr_node_list->get_item( index = lv_index ).
      lv_index = lv_index + 1.
      IF lr_child_elem IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lr_val_elem.
      lr_val_elem ?= lr_child_elem->get_first_child( ).
      IF lr_val_elem IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lv_tmp.
      lv_tmp = lr_val_elem->get_value( ).
      CONDENSE lv_tmp.
      APPEND lv_tmp TO mt_shared_strings.

    ENDWHILE.

  ENDMETHOD.                    "generate_shared_strings_table

  METHOD generate_sheets_from_xml_2.


    DATA:
      lr_sheet     TYPE REF TO lcl_worksheet,
      lr_sheet_xml TYPE REF TO lty_xmlsheet_s,
      lv_sheet_id  TYPE string.

    LOOP AT ms_xmldocs-sheets REFERENCE INTO lr_sheet_xml.

      CLEAR lr_sheet.
      lr_sheet  = add_worksheet( iv_index = lr_sheet_xml->sheetid iv_sheetname = lr_sheet_xml->name ).
      lr_sheet->add_data_from_xml( it_shared_strings = mt_shared_strings
                                   ir_document       = lr_sheet_xml->sheet ).

    ENDLOOP.


  ENDMETHOD.                    "generate_sheets_from_xml_2

  METHOD generate_sheets_from_xml_3.

    DATA:
      lr_sheet     TYPE REF TO lcl_worksheet,
      lr_sheet_xml TYPE REF TO lty_xmlsheet_s,
      lv_sheet_id  TYPE string.

    LOOP AT ms_xmldocs-sheets REFERENCE INTO lr_sheet_xml.

      CLEAR lr_sheet.
      lr_sheet  = add_worksheet( iv_index = lr_sheet_xml->sheetid iv_sheetname = lr_sheet_xml->name ).

    ENDLOOP.

  ENDMETHOD.                    "generate_sheets_from_xml_3

  METHOD generate_sheets_from_xml.

    DATA:
      lv_len        TYPE i,
      lv_index      TYPE i,
      lv_tmp        TYPE string,
      lr_child_elem TYPE REF TO if_ixml_element,
      lr_val_elem   TYPE REF TO if_ixml_element,
      lr_element    TYPE REF TO if_ixml_element,
      lr_node_list  TYPE REF TO if_ixml_node_list.

    "generate shared strings table.
    CLEAR mt_shared_strings.
    CLEAR lr_element.
    lr_element = ms_xmldocs-shared_strings->get_root_element( ).
    IF lr_element IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR lr_node_list.
    lr_node_list = lr_element->get_children( ).
    IF lr_node_list IS INITIAL.
      RETURN.
    ENDIF.
    lv_len = lr_node_list->get_length( ).
    lv_index = 0.
    WHILE lv_index < lv_len.

      lr_child_elem ?= lr_node_list->get_item( index = lv_index ).
      lv_index = lv_index + 1.
      IF lr_child_elem IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lr_val_elem.
      lr_val_elem ?= lr_child_elem->get_first_child( ).
      IF lr_val_elem IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lv_tmp.
      lv_tmp = lr_val_elem->get_value( ).
      CONDENSE lv_tmp.
      APPEND lv_tmp TO mt_shared_strings.

    ENDWHILE.

    DATA:
      lv_sheet_name TYPE lty_sheetname,
      lr_sheet      TYPE REF TO lcl_worksheet,
      lr_sheet_xml  TYPE REF TO lty_xmlsheet_s,
      lv_sheet_id   TYPE string.

    LOOP AT ms_xmldocs-sheets REFERENCE INTO lr_sheet_xml.

      CLEAR lr_sheet.
      CLEAR lv_sheet_name.
      lv_sheet_name = get_sheet_name_from_id( lr_sheet_xml->sheetid ).
      lr_sheet  = add_worksheet( iv_index = lr_sheet_xml->sheetid iv_sheetname = lv_sheet_name ).
      lr_sheet->add_data_from_xml( it_shared_strings = mt_shared_strings
                                   ir_document       = lr_sheet_xml->sheet ).

    ENDLOOP.


  ENDMETHOD.                    "generate_sheets_from_xml

  METHOD get_sheet_name_from_id.
    "importing
    "  iv_sheet_id             type i
    "returning
    "  value(rv_sheet_name)    type string,

    DATA:
      lv_path      TYPE string,
      lr_root      TYPE REF TO if_ixml_element,
      lr_node_list TYPE REF TO if_ixml_node_list,
      lv_len       TYPE i,
      lv_index     TYPE i,
      lv_attr_val  TYPE i,
      lr_element   TYPE REF TO if_ixml_element.

    CLEAR rv_sheet_name.
    IF iv_sheet_id <= 0.
      RETURN.
    ENDIF.

    lr_root = ms_xmldocs-workbook->get_root_element( ).
    lv_path = '/workbook/sheets'.
    CLEAR lr_element.
    lr_element = lr_root->find_from_path( path = lv_path ).
    IF lr_element IS INITIAL.
      RETURN.
    ENDIF.
    CLEAR lr_node_list.
    lr_node_list = lr_element->get_children( ).
    IF lr_node_list IS INITIAL.
      RETURN.
    ENDIF.
    lv_len = lr_node_list->get_length( ).
    lv_index = 0.
    WHILE lv_index < lv_len.
      CLEAR lr_element.
      lr_element ?= lr_node_list->get_item( index = lv_index ).
      lv_index = lv_index + 1.
      IF lr_element IS INITIAL.
        CONTINUE.
      ENDIF.
      CLEAR lv_attr_val.
      lv_attr_val = lr_element->get_attribute( name = 'sheetId' ).
      IF lv_attr_val = iv_sheet_id.
        rv_sheet_name = lr_element->get_attribute( name = 'name' ).
        EXIT.
      ENDIF.
    ENDWHILE.

  ENDMETHOD.                    "get_sheet_name_from_id

  METHOD generate_xlsx_file.
    "RETURNING
    "  value(rr_xlsx)         TYPE REF TO lcl_xlsx_wrapper,

    DATA:
      lv_lines TYPE i,
      lv_index TYPE i,
      lr_sheet TYPE REF TO lty_sheet_s.

    CLEAR mt_shared_strings.
    CLEAR rr_xlsx.
    rr_xlsx = lcl_xlsx_wrapper=>create_initial_xlsx_file( ).
    create_initial_xml_docs( ).
    mv_num_strings = 0.

    DESCRIBE TABLE mt_sheets LINES lv_lines.
    LOOP AT mt_sheets REFERENCE INTO lr_sheet.

      lv_index = sy-tabix.
      generate_sheet( ir_sheet         = lr_sheet
                      iv_num_of_sheets = lv_lines ).

    ENDLOOP.

    generate_shared_strings( ).

    add_xml_docs( ir_xlsx = rr_xlsx ).

  ENDMETHOD.                    "generate_xlsx_file

  METHOD generate_sheet.
    "importing
    "  ir_sheet              type ref to lty_sheet_s
    "  iv_index              type i
    "  iv_num_of_sheets      type i

    DATA:
      lv_tmp      TYPE string,
      lv_sheet_id TYPE string.

    CLEAR lv_sheet_id.
    lv_tmp = ir_sheet->index.
    CONDENSE lv_tmp.
    CONCATENATE 'sheet' lv_tmp INTO lv_sheet_id.
    CONDENSE lv_sheet_id.

    "handle content document.
    handle_content_xml( ir_sheet    = ir_sheet
                        iv_index    = ir_sheet->index
                        iv_sheet_id = lv_sheet_id ).

    handle_workbook_rels( ir_sheet         = ir_sheet
                          iv_index         = ir_sheet->index
                          iv_sheet_id      = lv_sheet_id
                          iv_num_of_sheets = iv_num_of_sheets ).

    handle_app_xml( ir_sheet         = ir_sheet
                    iv_index         = ir_sheet->index
                    iv_sheet_id      = lv_sheet_id
                    iv_num_of_sheets = iv_num_of_sheets ).

    handle_workbook_xml( ir_sheet    = ir_sheet
                         iv_index    = ir_sheet->index
                         iv_sheet_id = lv_sheet_id ).

    handle_sheet_xml( ir_sheet    = ir_sheet
                      iv_index    = ir_sheet->index
                      iv_sheet_id = lv_sheet_id ).

  ENDMETHOD.                    "generate_sheet

  METHOD handle_sheet_xml.
    "importing
    "  ir_sheet              type ref to lty_sheet_s
    "  iv_index              type i
    "  iv_sheet_id           type string

    DATA:
      ls_sheet   TYPE lty_xmlsheet_s,
      lv_content TYPE xstring.

    CLEAR lv_content.
    CLEAR ls_sheet.
    ls_sheet-sheetid = iv_index.
    lv_content = lcl_default_xml=>get_default_sheet( ).
    ls_sheet-sheet = create_xml_doc( iv_content  = lv_content ).
    IF ls_sheet-sheet IS NOT BOUND.
      RETURN.
    ENDIF.

    DATA:
      lv_path      TYPE string,
      lr_data_root TYPE REF TO if_ixml_element,
      lr_root      TYPE REF TO if_ixml_element.

    CLEAR lr_root.
    lr_root = ls_sheet-sheet->get_root_element( ).
    CLEAR lv_path.
    lv_path = '/worksheet/sheetData'.
    lr_data_root = lr_root->find_from_path( path = lv_path ).
    IF lr_data_root IS INITIAL.
      RETURN.
    ENDIF.

    DATA:
      lr_row_elem   TYPE REF TO if_ixml_element,
      lv_tmp        TYPE string,
      lr_cell       TYPE REF TO lty_sheet_data_cell_s,
      lr_sheet_data TYPE REF TO lty_sheet_data_s.

    LOOP AT ir_sheet->sheet->mt_sheet_data REFERENCE INTO lr_sheet_data.
      "create a row.
      CLEAR lr_row_elem.
      lr_row_elem = ls_sheet-sheet->create_element_ns( name = 'row' ).
      CLEAR lv_tmp.
      lv_tmp = lr_sheet_data->row_index.
      CONDENSE lv_tmp.
      lr_row_elem->set_attribute_ns( name = 'r' value = lv_tmp ).
      lv_tmp = get_row_span( lr_sheet_data->row_data ).
      lr_row_elem->set_attribute_ns( name = 'spans' value = lv_tmp ).
      lr_data_root->append_child( new_child = lr_row_elem ).

      LOOP AT lr_sheet_data->row_data REFERENCE INTO lr_cell.
        "create cell and update string table.
*        IF lr_cell->is_numeric = abap_true.
*          create_numeric_cell( iv_row      = lr_sheet_data->row_index
*                               ir_document = ls_sheet-sheet
*                               ir_row_elem = lr_row_elem
*                               ir_cell     = lr_cell ).
*        ELSE.
        create_string_cell( iv_row      = lr_sheet_data->row_index
                            ir_document = ls_sheet-sheet
                            ir_row_elem = lr_row_elem
                            ir_cell     = lr_cell ).
*        ENDIF.
      ENDLOOP.
    ENDLOOP.


    INSERT ls_sheet INTO TABLE ms_xmldocs-sheets.

  ENDMETHOD.                    "handle_sheet_xml

  METHOD create_numeric_cell.
    "importing
    "  iv_row                 TYPE i
    "  ir_document            type REF TO if_ixml_document
    "  ir_row_elem            type ref to if_ixml_element
    "  ir_cell                type ref to lty_sheet_data_cell_s

    DATA:
      lv_tmp        TYPE string,
      lr_value_elem TYPE REF TO if_ixml_element,
      lr_cell_elem  TYPE REF TO if_ixml_element.

    lr_cell_elem = ir_document->create_element_ns( name = 'c' ).
    CLEAR lv_tmp.
    lv_tmp = iv_row.
    CONCATENATE ir_cell->col lv_tmp INTO lv_tmp.
    CONDENSE lv_tmp.
    lr_cell_elem->set_attribute_ns( name = 'r' value = lv_tmp ).
    lr_value_elem = ir_document->create_element_ns( name = 'v' ).
    CLEAR lv_tmp.
    lv_tmp = ir_cell->value.
    CONDENSE lv_tmp.
    lr_value_elem->set_value( value = lv_tmp ).
    lr_cell_elem->append_child( new_child = lr_value_elem ).
    ir_row_elem->append_child( new_child = lr_cell_elem ).

  ENDMETHOD.                    "create_numeric_cell

  METHOD create_string_cell.
    "importing
    "  iv_row                 TYPE i
    "  ir_document            type REF TO if_ixml_document
    "  ir_row_elem            type ref to if_ixml_element
    "  ir_cell                type ref to lty_sheet_data_cell_s

    DATA:
      lv_tmp        TYPE string,
      lv_strval     TYPE string,
      lr_value_elem TYPE REF TO if_ixml_element,
      lr_cell_elem  TYPE REF TO if_ixml_element.

    mv_num_strings =  mv_num_strings + 1.
    lr_cell_elem = ir_document->create_element_ns( name = 'c' ).
    CLEAR lv_tmp.
    lv_tmp = iv_row.
    CONCATENATE ir_cell->col lv_tmp INTO lv_tmp.
    CONDENSE lv_tmp.
    lr_cell_elem->set_attribute_ns( name = 'r' value = lv_tmp ).
    lr_cell_elem->set_attribute_ns( name = 't' value = 's' ).
    lr_value_elem = ir_document->create_element_ns( name = 'v' ).

    CLEAR lv_strval.
    lv_strval = ir_cell->value.
    CONDENSE lv_strval.

    CLEAR lv_tmp.
    READ TABLE mt_shared_strings WITH KEY table_line = lv_strval TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND lv_strval TO mt_shared_strings.
      lv_tmp = sy-tabix - 1.
    ELSE.
      lv_tmp = sy-tabix - 1.
    ENDIF.

    CONDENSE lv_tmp.
    lr_value_elem->set_value( value = lv_tmp ).
    lr_cell_elem->append_child( new_child = lr_value_elem ).
    ir_row_elem->append_child( new_child = lr_cell_elem ).

  ENDMETHOD.                    "create_string_cell

  METHOD get_row_span.
    "importing
    "  it_row_data            type lty_sheet_data_row_t
    "returning
    "  value(rv_span)         type string.

    DATA:
      lr_row   TYPE REF TO lty_sheet_data_cell_s,
      lv_tmp   TYPE string,
      lv_tmp_2 TYPE string,
      lv_count TYPE i.

    CLEAR rv_span.
    lv_count = 0.
    DESCRIBE TABLE it_row_data LINES lv_count.
    IF lv_count <= 0.
      RETURN.
    ENDIF.
    CLEAR lr_row.
    READ TABLE it_row_data INDEX 1 REFERENCE INTO lr_row.
    lv_tmp = lr_row->col_index.
    CONDENSE lv_tmp.
    CLEAR lr_row.
    READ TABLE it_row_data INDEX lv_count REFERENCE INTO lr_row.
    lv_tmp_2 = lr_row->col_index.
    CONDENSE lv_tmp_2.
    CONCATENATE lv_tmp ':' lv_tmp_2 INTO rv_span.
    CONDENSE rv_span.

  ENDMETHOD.                    "get_row_span

  METHOD handle_workbook_xml.
    "importing
    "  ir_sheet              type ref to lty_sheet_s
    "  iv_index              type i
    "  iv_sheet_id           type string

    DATA:
      lv_tmp       TYPE string,
      lv_relid     TYPE string,
      lv_path      TYPE string,
      lv_uri       TYPE string,
      lv_sheetname TYPE string,
      lr_element   TYPE REF TO if_ixml_element,
      lr_child     TYPE REF TO if_ixml_element,
      lr_root      TYPE REF TO if_ixml_element.


    CLEAR lr_root.
    lr_root = ms_xmldocs-workbook->get_root_element( ).

    lv_path = '/workbook/sheets'.
    lr_element = lr_root->find_from_path( path = lv_path ).
    IF lr_element IS INITIAL.
      RETURN.
    ENDIF.

    lr_child = ms_xmldocs-workbook->create_element_ns( name = 'sheet' ).
    CLEAR lv_sheetname.
    lv_sheetname = ir_sheet->name.
    lr_child->set_attribute_ns( name = 'name' value = lv_sheetname ).
    lv_tmp = iv_index.
    CONDENSE lv_tmp.
    lr_child->set_attribute_ns( name = 'sheetId' value = lv_tmp ).

    lv_relid = iv_index.
    CONDENSE lv_relid.
    CONCATENATE 'rId' lv_relid INTO lv_relid.
    CONDENSE lv_relid.
    lr_child->set_attribute_ns( name = 'id' prefix = 'r' value = lv_relid ).

    lr_element->append_child( new_child = lr_child ).

  ENDMETHOD.                    "handle_workbook_xml

  METHOD handle_app_xml.
    "importing
    "  ir_sheet              type ref to lty_sheet_s
    "  iv_index              type i
    "  iv_sheet_id           type string
    "  iv_num_of_sheets      TYPE i,

    DATA:
      lv_tmp_i     TYPE i,
      lv_tmp       TYPE string,
      lv_path      TYPE string,
      lv_sheetname TYPE string,
      lr_element   TYPE REF TO if_ixml_element,
      lr_child     TYPE REF TO if_ixml_element,
      lr_root      TYPE REF TO if_ixml_element.

    lv_path = '/Properties/TitlesOfParts/vt:vector'.

    CLEAR lr_root.
    lr_root = ms_xmldocs-app->get_root_element( ).
    CLEAR lr_element.
    lr_element = lr_root->find_from_path( path = lv_path ).
    IF lr_element IS INITIAL.
      RETURN.
    ENDIF.
    lr_child = ms_xmldocs-app->create_element_ns( name = 'lpstr' prefix = 'vt' ).
    CLEAR lv_sheetname.
    lv_sheetname = ir_sheet->name.
    lr_child->set_value( value = lv_sheetname ).
    lr_element->append_child( new_child = lr_child ).

    lv_tmp = lr_element->get_attribute_ns( name = 'size' ).
    lv_tmp_i = lv_tmp.
    lv_tmp_i = lv_tmp_i + 1.
    lv_tmp = lv_tmp_i.
    CONDENSE lv_tmp.
    lr_element->set_attribute_ns( name = 'size' value = lv_tmp ).


    DATA:
      lv_i          TYPE i,
      lv_list_index TYPE i,
      lv_len        TYPE i,
      lv_attr_val   TYPE string,
      lr_node_list  TYPE REF TO if_ixml_node_list.

    CLEAR lv_path.
    lv_path = '/Properties/HeadingPairs/vt:vector'.
    CLEAR lr_element.
    lr_element = lr_root->find_from_path( path = lv_path ).
    IF lr_element IS NOT INITIAL.

      CLEAR lr_node_list.
      lr_node_list = lr_element->get_children( ).
      lv_len = lr_node_list->get_length( ).
      lr_element ?= lr_node_list->get_item( index = 1 ).
      IF lr_element IS NOT INITIAL.
        lr_element ?= lr_element->get_first_child( ).
        IF lr_element IS NOT INITIAL.
          lr_element->set_value( value = lv_tmp ).
          lv_tmp = lr_element->get_name( ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "handle_app_xml

  METHOD handle_content_xml.
    "importing
    "  ir_sheet              type ref to lty_sheet_s
    "  iv_index              type i
    "  iv_sheet_id           type string
    DATA:
      lv_partname TYPE string,
      lr_child    TYPE REF TO if_ixml_element,
      lr_root     TYPE REF TO if_ixml_element.

    CLEAR lr_root.
    lr_root = ms_xmldocs-content->get_root_element( ).
    lr_child = ms_xmldocs-content->create_element_ns( name = 'Override' ). "#EC NOTEXT
    CLEAR lv_partname.
    CONCATENATE '/xl/worksheets/' iv_sheet_id '.xml' INTO lv_partname.
    CONDENSE lv_partname.
    lr_child->set_attribute_ns( name = 'PartName' value = lv_partname ).
    lr_child->set_attribute_ns( name = 'ContentType' value = 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml' ).
    lr_root->append_child( new_child = lr_child ).

  ENDMETHOD.                    "handle_content_xml

  METHOD handle_workbook_rels.
    "importing
    "  ir_sheet              type ref to lty_sheet_s
    "  iv_index              type i
    "  iv_sheet_id           type string
    "  iv_num_of_sheets      type i,

    DATA:
      lv_relid  TYPE string,
      lv_target TYPE string,
      lr_child  TYPE REF TO if_ixml_element,
      lr_root   TYPE REF TO if_ixml_element.

    CLEAR lr_root.
    CLEAR lv_relid.
    lv_relid = iv_index.
    CONDENSE lv_relid.
    CONCATENATE 'rId' lv_relid INTO lv_relid.
    CONDENSE lv_relid.
    lr_root = ms_xmldocs-workbook_rels->get_root_element( ).
    lr_child = ms_xmldocs-workbook_rels->create_element_ns( name = 'Relationship' ). "#EC NOTEXT
    lr_child->set_attribute_ns( name = 'Id' value = lv_relid ).
    lr_child->set_attribute_ns( name = 'Type' value = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet' ). "#EC NOTEXT
    CLEAR lv_target.
    CONCATENATE 'worksheets/' iv_sheet_id '.xml' INTO lv_target.
    CONDENSE lv_target.
    lr_child->set_attribute_ns( name = 'Target' value = lv_target ). "#EC NOTEXT
    lr_root->append_child( new_child = lr_child ).

    "todo: adjust relations ids, at first sheets then themes, styles, shared strings are handled in different method.
    DATA:
      lv_i          TYPE i,
      lv_list_index TYPE i,
      lv_len        TYPE i,
      lv_attr_val   TYPE string,
      lr_element    TYPE REF TO if_ixml_element,
      lr_node_list  TYPE REF TO if_ixml_node_list.

    IF iv_index = 1.

      CLEAR lr_node_list.
      lr_node_list = lr_root->get_children( ).
      lv_len = lr_node_list->get_length( ).
      lv_i = 0.
      lv_list_index = 0.
      DO lv_len TIMES.
        CLEAR lr_element.
        lr_element ?= lr_node_list->get_item( index = lv_list_index ).
        lv_attr_val = lr_element->get_attribute_ns( 'Target' ). "#EC NOTEXT
        IF lv_attr_val = 'theme/theme1.xml'.
          CLEAR lv_relid.
          lv_i = iv_num_of_sheets + 1.
          lv_relid = lv_i.
          CONDENSE lv_relid.
          CONCATENATE 'rId' lv_relid INTO lv_relid.
          CONDENSE lv_relid.
          lr_element->set_attribute_ns( name = 'Id' value = lv_relid ).
        ELSEIF lv_attr_val = 'styles.xml'.
          CLEAR lv_relid.
          lv_i = iv_num_of_sheets + 2.
          lv_relid = lv_i.
          CONDENSE lv_relid.
          CONCATENATE 'rId' lv_relid INTO lv_relid.
          CONDENSE lv_relid.
          lr_element->set_attribute_ns( name = 'Id' value = lv_relid ).
        ELSEIF lv_attr_val = 'sharedStrings.xml'.
          CLEAR lv_relid.
          lv_i = iv_num_of_sheets + 3.
          lv_relid = lv_i.
          CONDENSE lv_relid.
          CONCATENATE 'rId' lv_relid INTO lv_relid.
          CONDENSE lv_relid.
          lr_element->set_attribute_ns( name = 'Id' value = lv_relid ).
        ENDIF.
        lv_list_index = lv_list_index + 1.
      ENDDO.

    ENDIF.


  ENDMETHOD.                    "handle_workbook_rels

  METHOD generate_shared_strings.

    DATA:
      lv_lines    TYPE i,
      lr_child_si TYPE REF TO if_ixml_element,
      lr_child_t  TYPE REF TO if_ixml_element,
      lr_root     TYPE REF TO if_ixml_element,
      lv_string   TYPE string.

    CLEAR lr_root.
    lr_root = ms_xmldocs-shared_strings->get_root_element( ).
    LOOP AT mt_shared_strings INTO lv_string.
      CLEAR lr_child_si.
      lr_child_si = ms_xmldocs-shared_strings->create_element_ns( name = 'si' ).
      lr_root->append_child( new_child = lr_child_si ).
      lr_child_t = ms_xmldocs-shared_strings->create_element_ns( name = 't' ).
      lr_child_t->set_value( value = lv_string ).
      lr_child_si->append_child( new_child = lr_child_t ).
    ENDLOOP.
    DESCRIBE TABLE mt_shared_strings LINES lv_lines.
    CLEAR lv_string.
    lv_string = lv_lines.
    CONDENSE lv_string.
    lr_root->set_attribute_ns( name = 'uniqueCount' value = lv_string ).

    CLEAR lv_string.
    lv_string = mv_num_strings.
    CONDENSE lv_string.
    lr_root->set_attribute_ns( name = 'count' value = lv_string ).

  ENDMETHOD.                    "generate_shared_strings

  METHOD add_xml_docs.
    "IMPORTING
    "  ir_xlsx               TYPE REF TO lcl_xlsx_wrapper,

    DATA:
      lv_tmp        TYPE string,
      ls_xstr_sheet TYPE lty_sheetxml_xstr_s,
      lr_sheet      TYPE REF TO lty_xmlsheet_s,
      ls_xstr_data  TYPE lty_xmldocs_xstr.

    CLEAR ls_xstr_data.

    ls_xstr_data-content = create_raw_data( ir_document = ms_xmldocs-content ).
    ls_xstr_data-app = create_raw_data( ir_document = ms_xmldocs-app ).
    ls_xstr_data-shared_strings = create_raw_data( ir_document = ms_xmldocs-shared_strings ).

    LOOP AT ms_xmldocs-sheets REFERENCE INTO lr_sheet.
      CLEAR ls_xstr_sheet.
      lv_tmp = lr_sheet->sheetid.
      CONCATENATE 'sheet' lv_tmp INTO ls_xstr_sheet-sheetid.
      CONDENSE ls_xstr_sheet-sheetid.
      ls_xstr_sheet-sheet = create_raw_data( ir_document = lr_sheet->sheet ).
      INSERT ls_xstr_sheet INTO TABLE ls_xstr_data-sheets.
    ENDLOOP.
    "ls_xstr_data-sheet = create_raw_data( ir_document = ms_xmldocs-sheet ).
    ls_xstr_data-workbook  = create_raw_data( ir_document = ms_xmldocs-workbook  ).
    ls_xstr_data-workbook_rels = create_raw_data( ir_document = ms_xmldocs-workbook_rels ).

    ir_xlsx->add_xml_data( is_data = ls_xstr_data ).

  ENDMETHOD.                    "generate_xlsx_file

  METHOD create_raw_data.
    "importing
    "  ir_document          type ref to if_ixml_document
    "returning
    "  value(rv_data)       type xstring,

    DATA:
      lr_renderer TYPE REF TO if_ixml_renderer,
      lr_stream   TYPE REF TO if_ixml_ostream,
      lr_encoding TYPE REF TO if_ixml_encoding.

    CLEAR rv_data.
    lr_encoding = mr_ixml->create_encoding( character_set = 'UTF-8'
                                            byte_order    = 0 ).
    lr_stream = mr_stream_factory->create_ostream_xstring( string = rv_data ).
    lr_stream->set_encoding( encoding = lr_encoding ).
    lr_stream->set_pretty_print( pretty_print = abap_true ).
    lr_renderer = mr_ixml->create_renderer( document = ir_document
                                            ostream  = lr_stream ).
    lr_renderer->render( ).
    "size = xstrlen( xml_as_string ).

  ENDMETHOD.                    "create_raw_data

  METHOD create_xml_doc.
    "IMPORTING
    "  iv_content            TYPE xstring
    "RETURNING
    "  value(rr_document)    TYPE REF TO if_ixml_document,

    DATA:
      lr_stream TYPE REF TO if_ixml_istream,
      lr_parser TYPE REF TO if_ixml_parser.

    CLEAR rr_document.
    CLEAR lr_stream.
    lr_stream = mr_stream_factory->create_istream_xstring( string = iv_content ).
    rr_document = mr_ixml->create_document( ).
    lr_parser = mr_ixml->create_parser( document       = rr_document
                                        istream        = lr_stream
                                        stream_factory = mr_stream_factory ).
    lr_parser->set_normalizing( is_normalizing = abap_true ).
    IF lr_parser->parse( ) <> 0.
      CLEAR rr_document.
      RETURN.
    ENDIF.

  ENDMETHOD.                    "create_xml_doc

  METHOD create_initial_xml_docs.

    DATA:
      lv_content              TYPE xstring.

    CLEAR mr_ixml.
    CLEAR mr_stream_factory.
    CLEAR ms_xmldocs.

    mr_ixml = cl_ixml=>create( ).
    mr_stream_factory = mr_ixml->create_stream_factory( ).

    CLEAR lv_content.
    lv_content = lcl_default_xml=>get_default_content_types_2( ).
    ms_xmldocs-content = create_xml_doc( iv_content  = lv_content ).
    IF ms_xmldocs-content IS NOT BOUND.
      RETURN.
    ENDIF.

    CLEAR lv_content.
    lv_content = lcl_default_xml=>get_default_app_2( ).
    ms_xmldocs-app = create_xml_doc( iv_content  = lv_content ).
    IF ms_xmldocs-app IS NOT BOUND.
      RETURN.
    ENDIF.

    CLEAR lv_content.
    lv_content = lcl_default_xml=>get_default_shared_str( ).
    ms_xmldocs-shared_strings = create_xml_doc( iv_content  = lv_content ).
    IF ms_xmldocs-shared_strings IS NOT BOUND.
      RETURN.
    ENDIF.

    CLEAR lv_content.
    lv_content = lcl_default_xml=>get_default_workbook_2( ).
    ms_xmldocs-workbook = create_xml_doc( iv_content  = lv_content ).
    IF ms_xmldocs-workbook IS NOT BOUND.
      RETURN.
    ENDIF.

    CLEAR lv_content.
    lv_content = lcl_default_xml=>get_default_workbook_rels_2( ).
    ms_xmldocs-workbook_rels = create_xml_doc( iv_content  = lv_content ).
    IF ms_xmldocs-workbook_rels IS NOT BOUND.
      RETURN.
    ENDIF.

  ENDMETHOD.                    "create_initial_xml_docs
*<<<<< begin of Note 2688056
  METHOD set_excel_h.
    mt_excel_h = it_excel_h.
*<<<<< end of Note 2688056
  ENDMETHOD.
ENDCLASS.                    "lcl_workbook IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcl_worksheet IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_worksheet IMPLEMENTATION.

  METHOD constructor.
    "IMPORTING
    "  iv_name    TYPE lty_sheetname.

    CLEAR mt_sheet_data.
    CLEAR mv_name.
    mv_name = iv_name.

  ENDMETHOD.                    "constructor

  METHOD add_typeinfo.
    "IMPORTING
    "  iv_data         TYPE any,

  ENDMETHOD.                    "add_typeinfo

  METHOD add_columns.

  ENDMETHOD.                    "add_columns

  METHOD convert_str_to_val.
    "IMPORTING
    "  iv_str_val           TYPE lty_cell_value
    "EXPORTING
    "  ev_val               TYPE any,
    DATA:
      lv_xml              TYPE string.

    CLEAR ev_val.
    IF iv_str_val IS INITIAL.
      RETURN.
    ENDIF.
    ev_val = iv_str_val.
*    IF lv_conv_flag = mc_conv_flag-move.
*      ev_val = iv_str_val.
*    ELSEIF lv_conv_flag = mc_conv_flag-write.
*      ev_val = iv_str_val.
*    ELSEIF lv_conv_flag = mc_conv_flag-xml_trans.
*      CLEAR lv_xml.
*      CONCATENATE
*        '<asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0"><asx:values><VAL>'
*        iv_str_val
*        '</VAL></asx:values></asx:abap>' INTO lv_xml.
*      CONDENSE lv_xml.
*      CALL TRANSFORMATION id SOURCE XML lv_xml RESULT val = ev_val.
*    ENDIF.

  ENDMETHOD.                    "convert_str_to_val

  METHOD convert_val_to_str.
    "IMPORTING
    "  iv_val               TYPE any
    "EXPORTING
    "  ev_str_val           TYPE lty_cell_value,

    DATA:
      lv_xml     TYPE string,
      lv_expr    TYPE string,
      lv_off     TYPE i,
      lv_len     TYPE i,
      lv_tmp_val TYPE c LENGTH 32767.

    CLEAR ev_str_val.
    ev_str_val = iv_val.
*    IF lv_conv_flag = mc_conv_flag-move.
*      ev_str_val = iv_val.
*    ELSEIF lv_conv_flag = mc_conv_flag-write.
*      CLEAR lv_tmp_val.
*      WRITE iv_val TO lv_tmp_val.
*      ev_str_val = lv_tmp_val.
*    ELSEIF lv_conv_flag = mc_conv_flag-xml_trans.
*      CLEAR lv_xml.
*      CALL TRANSFORMATION id OPTIONS xml_header = 'no' SOURCE val = iv_val RESULT XML lv_xml.
*      CLEAR lv_expr.
*      lv_expr = '<VAL>[[:print:]]*</VAL>'.
*      FIND FIRST OCCURRENCE OF REGEX lv_expr IN lv_xml MATCH LENGTH lv_len MATCH OFFSET lv_off.
*      IF sy-subrc = 0.
*        lv_off = lv_off + 5.
*        lv_len = lv_len - 11.
*        ev_str_val = lv_xml+lv_off(lv_len).
*      ELSE.
*        FIND FIRST OCCURRENCE OF '<VAL/>' IN lv_xml MATCH LENGTH lv_len MATCH OFFSET lv_off.
*        IF sy-subrc <> 0.
*          WRITE:/ 'error converting .'.
*        ENDIF.
*      ENDIF.
**      REPLACE ALL OCCURRENCES OF '<asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0"><asx:values><VAL>' IN lv_xml WITH ''.
**      REPLACE ALL OCCURRENCES OF '</VAL></asx:values></asx:abap>' IN lv_xml WITH ''.
**      ev_str_val = lv_xml.
*      "﻿<asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0"><asx:values><VAL>200</VAL></asx:values></asx:abap>
*    ENDIF.

  ENDMETHOD.                    "convert_val_to_str

  METHOD add_data_from_xml.
    "IMPORTING
    "  it_shared_strings     TYPE lty_shared_strings_t,
    "  ir_document           TYPE REF TO if_ixml_document,

    DATA:
      lv_path           TYPE string,
      lv_row_index      TYPE i,
      lv_col_index      TYPE i,
      lv_row_length     TYPE i,
      lv_col_length     TYPE i,
      lr_row_list       TYPE REF TO if_ixml_node_list,
      lr_col_list       TYPE REF TO if_ixml_node_list,
      lr_node_col       TYPE REF TO if_ixml_node_collection,
      lr_root           TYPE REF TO if_ixml_element,
      lr_row_elem       TYPE REF TO if_ixml_element,
      lr_col_elem       TYPE REF TO if_ixml_element,
      lr_val_elem       TYPE REF TO if_ixml_element,
      lr_sheetdata_elem TYPE REF TO if_ixml_element.

    DATA:
      lv_off                 TYPE i,
      lv_len                 TYPE i,
      lv_tmp                 TYPE string,
      lv_shared_string_index TYPE i,
      ls_cell_data           TYPE lty_sheet_data_cell_s,
      ls_sheet_data          TYPE lty_sheet_data_s.

    CLEAR mt_sheet_data.
    CLEAR lr_root.
    lr_root = ir_document->get_root_element( ).
    IF lr_root IS INITIAL.
      RETURN.
    ENDIF.
    CLEAR lv_path.
    lv_path = '/worksheet/sheetData'.
    lr_sheetdata_elem = lr_root->find_from_path( path = lv_path ).
    IF lr_sheetdata_elem IS INITIAL.
      RETURN.
    ENDIF.

    CLEAR lr_row_list.
    lr_row_list = lr_sheetdata_elem->get_children( ).
    IF lr_row_list IS INITIAL.
      RETURN.
    ENDIF.
    lv_row_index = 0.
    lv_row_length = lr_row_list->get_length( ).
    WHILE lv_row_index < lv_row_length.

      CLEAR lr_row_elem.
      lr_row_elem ?= lr_row_list->get_item( index = lv_row_index ).
      lv_row_index = lv_row_index + 1.
      IF lr_row_elem IS INITIAL.
        CONTINUE.
      ENDIF.

      CLEAR ls_sheet_data.
      ls_sheet_data-row_index = lr_row_elem->get_attribute( name = 'r' ).
      CLEAR lr_col_list.
      lr_col_list = lr_row_elem->get_children( ).
      "IF lr_col_list IS INITIAL.
      "  CONTINUE.
      "ENDIF.
      lv_col_index = 0.
      lv_col_length = lr_col_list->get_length( ).
      WHILE lv_col_index < lv_col_length.

        lr_col_elem ?= lr_col_list->get_item( index = lv_col_index ).
        lv_col_index = lv_col_index + 1.
        IF lr_col_elem IS INITIAL.
          CONTINUE.
        ENDIF.
        CLEAR ls_cell_data.
        CLEAR lv_tmp.
        lv_tmp = lr_col_elem->get_attribute( name = 'r' ).
        lv_len = 0.
        lv_off = 0.
        FIND FIRST OCCURRENCE OF REGEX '[[:digit:]]' IN lv_tmp MATCH OFFSET lv_off MATCH LENGTH lv_len.
        IF sy-subrc = 0.
          ls_cell_data-col = lv_tmp(lv_off).
        ELSE.
          ls_cell_data-col = lv_tmp.
        ENDIF.
        ls_cell_data-col_index = lcl_excel_helper=>excelcol_to_index( iv_col = ls_cell_data-col ).
        CLEAR lv_tmp.
        lv_tmp = lr_col_elem->get_attribute( name = 't' ).
        CONDENSE lv_tmp.
        ls_cell_data-t = lv_tmp.
        IF lv_tmp = 's'.
          lv_shared_string_index = lr_col_elem->get_value( ).
          lv_shared_string_index = lv_shared_string_index + 1.
          READ TABLE it_shared_strings INDEX lv_shared_string_index INTO ls_cell_data-value.
          IF sy-subrc <> 0.
            CLEAR ls_cell_data-value.
          ELSE.
            ls_cell_data-sh_str_index = lv_shared_string_index.
          ENDIF.
          CONDENSE ls_cell_data-value.
        ELSE.
          CLEAR lr_node_col.
          lr_node_col = lr_col_elem->get_elements_by_tag_name( depth = 1 name = 'v' ).
          CLEAR lr_val_elem.
          lr_val_elem ?= lr_node_col->get_item( index = 0 ).
          IF lr_val_elem IS NOT INITIAL.
            ls_cell_data-value = lr_val_elem->get_value( ).
            CONDENSE ls_cell_data-value.
          ENDIF.
        ENDIF.
        "lv_shared_string_index
        INSERT ls_cell_data INTO TABLE ls_sheet_data-row_data.

      ENDWHILE.

      INSERT ls_sheet_data INTO TABLE mt_sheet_data.

    ENDWHILE.

  ENDMETHOD.                    "add_data_from_xml

  METHOD add_data.
    "IMPORTING
    "  it_data         TYPE ANY TABLE,

    IF it_data IS INITIAL.
      RETURN.
    ENDIF.

    "get field list.
    DATA:
      lt_field_list  TYPE lty_field_t,
      lr_field       TYPE REF TO lty_field_s,
      lt_symbols     TYPE abap_component_symbol_tab,
      lr_symbol      TYPE REF TO abap_simple_componentdescr,
      lr_datadescr   TYPE REF TO cl_abap_datadescr,
      lr_structdescr TYPE REF TO cl_abap_structdescr,
      lr_tabdescr    TYPE REF TO cl_abap_tabledescr.

    TRY.
        CLEAR lt_field_list.
        CLEAR lr_tabdescr.
        lr_tabdescr ?= cl_abap_typedescr=>describe_by_data( p_data = it_data ).
        lr_datadescr = lr_tabdescr->get_table_line_type( ).

        IF lr_datadescr->kind = cl_abap_typedescr=>kind_elem.

          "APPEND 'TABELE_LINE' TO lt_field_list.
          APPEND INITIAL LINE TO lt_field_list REFERENCE INTO lr_field.
          lr_field->name = 'TABLE_LINE'.
          lr_field->type_kind = lr_datadescr->type_kind.
*          IF cl_abap_typedescr=>typekind_numeric = lr_datadescr->type_kind
*            OR cl_abap_typedescr=>typekind_float = lr_datadescr->type_kind
*            OR cl_abap_typedescr=>typekind_int = lr_datadescr->type_kind
*            OR cl_abap_typedescr=>typekind_int1 = lr_datadescr->type_kind
*            OR cl_abap_typedescr=>typekind_int2 = lr_datadescr->type_kind.
*
*            lr_field->is_numeric = abap_true.
*
*          ENDIF.

        ELSE.

          CLEAR lt_symbols.
          CLEAR lr_structdescr.
          lr_structdescr ?= lr_datadescr.
          lt_symbols = lr_structdescr->get_symbols( ).
          LOOP AT lt_symbols REFERENCE INTO lr_symbol.
            "APPEND lr_symbol->name TO lt_field_list.
            APPEND INITIAL LINE TO lt_field_list REFERENCE INTO lr_field.
            lr_field->name = lr_symbol->name.
            lr_field->type_kind = lr_symbol->type->type_kind.
*            IF cl_abap_typedescr=>typekind_numeric = lr_symbol->type->type_kind
*            OR cl_abap_typedescr=>typekind_float = lr_symbol->type->type_kind
*            OR cl_abap_typedescr=>typekind_int = lr_symbol->type->type_kind
*            OR cl_abap_typedescr=>typekind_int1 = lr_symbol->type->type_kind
*            OR cl_abap_typedescr=>typekind_int2 = lr_symbol->type->type_kind.
*
*              lr_field->is_numeric = abap_true.
*
*            ENDIF.
          ENDLOOP.

        ENDIF.
      CATCH cx_root.
    ENDTRY.

    "insert row with table fields as headerline on the sheet.
    DATA:
      lv_index      TYPE i,
      ls_sheet_data TYPE lty_sheet_data_s,
      ls_cell_data  TYPE lty_sheet_data_cell_s.

    CLEAR mt_sheet_data.
    CLEAR ls_sheet_data.
    ls_sheet_data-row_index = 1.
    lv_index = 0.
    LOOP AT lt_field_list REFERENCE INTO lr_field.
      lv_index = lv_index + 1.
      CLEAR ls_cell_data.
      ls_cell_data-col_index = lv_index.
      ls_cell_data-col = lcl_excel_helper=>index_to_excelcol( iv_index = ls_cell_data-col_index ).
      ls_cell_data-value = lr_field->name.
      CONDENSE ls_cell_data-value.
      "temporary, is removed at the end for headerline.
      "ls_cell_data-is_numeric = lr_field->is_numeric.
      ls_cell_data-type_kind = lr_field->type_kind.
      INSERT ls_cell_data INTO TABLE ls_sheet_data-row_data.
    ENDLOOP.
    INSERT ls_sheet_data INTO TABLE mt_sheet_data.

    "insert data rows.
    DATA:
      lv_row_index  TYPE i,
      lr_cell_data  TYPE REF TO lty_sheet_data_cell_s,
      lr_sheet_data TYPE REF TO lty_sheet_data_s.

    READ TABLE mt_sheet_data WITH TABLE KEY row_index = 1 REFERENCE INTO lr_sheet_data.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    FIELD-SYMBOLS:
      <fs_field> TYPE any,
      <fs_line>  TYPE any,
      <fs_table> TYPE ANY TABLE.

    UNASSIGN <fs_table>.
    ASSIGN it_data TO <fs_table>.
    IF <fs_table> IS ASSIGNED.
      lv_row_index = lr_sheet_data->row_index.
      LOOP AT <fs_table> ASSIGNING <fs_line>.
        lv_row_index = lv_row_index + 1.
        CLEAR ls_sheet_data.
        ls_sheet_data-row_index = lv_row_index.
        LOOP AT lr_sheet_data->row_data REFERENCE INTO lr_cell_data.
          CLEAR ls_cell_data.
          ls_cell_data-col_index = lr_cell_data->col_index.
          ls_cell_data-col = lr_cell_data->col.
          UNASSIGN <fs_field>.

          IF lr_datadescr->kind = cl_abap_typedescr=>kind_elem.
            ASSIGN <fs_line> TO <fs_field>.
          ELSE.
            ASSIGN COMPONENT lr_cell_data->value OF STRUCTURE <fs_line> TO <fs_field>.
          ENDIF.
          IF <fs_field> IS ASSIGNED.
            convert_val_to_str( EXPORTING
                                  iv_val     = <fs_field>
                                IMPORTING
                                  ev_str_val = ls_cell_data-value ).
*            IF lr_cell_data->is_numeric = abap_false.
*              ls_cell_data-value = <fs_field>.
*            ELSE.
*              WRITE <fs_field> TO ls_cell_data-value.
*            ENDIF.
*            CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
*              EXPORTING
*                input  = <fs_field>
*              IMPORTING
*                output = ls_cell_data-value.

            CONDENSE ls_cell_data-value.
          ENDIF.
          "ls_cell_data-is_numeric = lr_cell_data->is_numeric.
          ls_cell_data-type_kind = lr_cell_data->type_kind.
          INSERT ls_cell_data INTO TABLE ls_sheet_data-row_data.
        ENDLOOP.
        INSERT ls_sheet_data INTO TABLE mt_sheet_data.
      ENDLOOP.
    ENDIF.

    "header line contains fieldnames and therefore is not numeric, therefore reset values.
    LOOP AT lr_sheet_data->row_data REFERENCE INTO lr_cell_data.
      "lr_cell_data->is_numeric = abap_false.
      lr_cell_data->type_kind = cl_abap_typedescr=>typekind_string.
    ENDLOOP.

  ENDMETHOD.                    "add_data

  METHOD get_typeinfo.

  ENDMETHOD.                    "get_typeinfo

  METHOD get_columns.

  ENDMETHOD.                    "get_columns

  METHOD get_sheet_data.
    "exporting
    "  et_sheet_data        type lty_sheet_data_t,

    CLEAR et_sheet_data.
    et_sheet_data = mt_sheet_data.

  ENDMETHOD.                    "get_sheet_data

  METHOD get_row_data.
    "IMPORTING
    "   iv_row              TYPE i
    "RETURNING
    "  value(rr_row)        TYPE REF TO lty_sheet_data_s,

    CLEAR rr_row.
    READ TABLE mt_sheet_data WITH TABLE KEY row_index = iv_row REFERENCE INTO rr_row.
    IF sy-subrc <> 0.
      CLEAR rr_row.
    ENDIF.

  ENDMETHOD.                    "get_row_data

  METHOD get_name.
    "RETURNING
    "  value(rv_name)        TYPE lty_sheetname,

    CLEAR rv_name.
    rv_name = mv_name.

  ENDMETHOD.                    "get_name

*  METHOD get_data_for_fmap.
*    "IMPORTING
*    "  iv_start_index       type i
*    "  it_fmap              TYPE zhew_excel_fmap_t
*    "  iv_index_fld_name    TYPE name_komp OPTIONAL
*    "EXPORTING
*    "  et_data              TYPE ANY TABLE,
*
*    FIELD-SYMBOLS:
*      <fs_field>             TYPE ANY,
*      <fs_row>               TYPE ANY.
*
*    DATA:
*      lt_field_list          TYPE lty_map_field_t,
*      lr_field               TYPE REF TO lty_map_field_s,
*      lt_symbols             TYPE abap_component_symbol_tab,
*      lr_symbol              TYPE REF TO abap_simple_componentdescr,
*      lr_datadescr           TYPE REF TO cl_abap_datadescr,
*      lr_structdescr         TYPE REF TO cl_abap_structdescr,
*      lr_tabdescr            TYPE REF TO cl_abap_tabledescr.
*
*    TRY.
*        CLEAR et_data.
*
*        CLEAR lt_field_list.
*        CLEAR lr_tabdescr.
*        lr_tabdescr ?= cl_abap_typedescr=>describe_by_data( p_data = et_data ).
*        lr_datadescr = lr_tabdescr->get_table_line_type( ).
*
*        IF lr_datadescr->kind = cl_abap_typedescr=>kind_elem.
*
*          APPEND INITIAL LINE TO lt_field_list REFERENCE INTO lr_field.
*          lr_field->name = 'TABLE_LINE'.
*          lr_field->type_kind = lr_datadescr->type_kind.
*
*        ELSE.
*
*          CLEAR lt_symbols.
*          CLEAR lr_structdescr.
*          lr_structdescr ?= lr_datadescr.
*          lt_symbols = lr_structdescr->get_symbols( ).
*          LOOP AT lt_symbols REFERENCE INTO lr_symbol.
*            APPEND INITIAL LINE TO lt_field_list REFERENCE INTO lr_field.
*            lr_field->name = lr_symbol->name.
*            lr_field->type_kind = lr_symbol->type->type_kind.
*          ENDLOOP.
*
*        ENDIF.
*
*        DATA:
*          lr_root             TYPE REF TO cx_root,
*          lv_err              TYPE string.
*
*        DATA:
*          lv_strukname        TYPE strukname,
*          lr_fmap             TYPE REF TO zhew_excel_fmap,
*          lr_row_data         TYPE REF TO data,
*          lv_row_index        TYPE i,
*          lr_cell_data        TYPE REF TO lty_sheet_data_cell_s,
*          lr_sheet_data       TYPE REF TO lty_sheet_data_s,
*          lr_sheet_col        TYPE REF TO lty_sheet_data_cell_s,
*          lr_sheet_cols       TYPE REF TO lty_sheet_data_s.
*
*        lv_strukname = lr_datadescr->get_relative_name( ).
*        LOOP AT lt_field_list REFERENCE INTO lr_field.
*
*          READ TABLE it_fmap WITH KEY strukname = lv_strukname fieldname = lr_field->name REFERENCE INTO lr_fmap.
*          IF sy-subrc = 0.
*            lr_field->col = lr_fmap->excel_col.
*          ELSE.
*            DELETE lt_field_list.
*          ENDIF.
*
*        ENDLOOP.
*
*        "todo: handle scenario where linetype is not structured.
*        LOOP AT mt_sheet_data REFERENCE INTO lr_sheet_data
*          WHERE row_index >= iv_start_index.
*
*          CLEAR lr_row_data.
*          CREATE DATA lr_row_data TYPE HANDLE lr_datadescr.
*          UNASSIGN <fs_row>.
*          ASSIGN lr_row_data->* TO <fs_row>.
*          IF <fs_row> IS NOT ASSIGNED.
*            RETURN.
*          ENDIF.
*
*          LOOP AT lt_field_list REFERENCE INTO lr_field.
*            UNASSIGN <fs_field>.
*            ASSIGN COMPONENT lr_field->name OF STRUCTURE <fs_row> TO <fs_field>.
*            IF <fs_field> IS NOT ASSIGNED.
*              CONTINUE.
*            ENDIF.
*            READ TABLE lr_sheet_data->row_data WITH KEY col = lr_field->col REFERENCE INTO lr_cell_data.
*            IF sy-subrc = 0.
*              TRY.
*                  convert_str_to_val( EXPORTING
*                                        iv_str_val = lr_cell_data->value
*                                      IMPORTING
*                                        ev_val     = <fs_field> ).
*                  "<fs_field> = lr_cell_data->value.
*                CATCH cx_root INTO lr_root.
*                  CLEAR lv_err.
*                  lv_err = lr_root->get_text( ).
*                  WRITE:/ lr_field->name, ' ', lv_err.
*              ENDTRY.
*            ENDIF.
*
*          ENDLOOP.
*
*          IF iv_index_fld_name IS NOT INITIAL.
*            ASSIGN COMPONENT iv_index_fld_name OF STRUCTURE <fs_row> TO <fs_field>.
*            IF <fs_field> IS ASSIGNED.
*              <fs_field> = lr_sheet_data->row_index.
*            ENDIF.
*          ENDIF.
*
*          IF <fs_row> IS NOT INITIAL.
*            INSERT <fs_row> INTO TABLE et_data.
*          ENDIF.
*        ENDLOOP.
*
*      CATCH cx_root.
*    ENDTRY.
*
*  ENDMETHOD.                    "get_data_for_fmap

  METHOD get_data.
    "EXPORTING
    "  et_data              TYPE ANY TABLE.

    FIELD-SYMBOLS:
      <fs_field> TYPE any,
      <fs_row>   TYPE any.

    DATA:
      lt_field_list  TYPE lty_map_field_t,
      lr_field       TYPE REF TO lty_map_field_s,
      lt_symbols     TYPE abap_component_symbol_tab,
      lr_symbol      TYPE REF TO abap_simple_componentdescr,
      lr_datadescr   TYPE REF TO cl_abap_datadescr,
      lr_structdescr TYPE REF TO cl_abap_structdescr,
      lr_tabdescr    TYPE REF TO cl_abap_tabledescr.

    TRY.
        CLEAR et_data.

        CLEAR lt_field_list.
        CLEAR lr_tabdescr.
        lr_tabdescr ?= cl_abap_typedescr=>describe_by_data( p_data = et_data ).
        lr_datadescr = lr_tabdescr->get_table_line_type( ).

        IF lr_datadescr->kind = cl_abap_typedescr=>kind_elem.

          APPEND INITIAL LINE TO lt_field_list REFERENCE INTO lr_field.
          lr_field->name = 'TABLE_LINE'.
          lr_field->type_kind = lr_datadescr->type_kind.

        ELSE.

          CLEAR lt_symbols.
          CLEAR lr_structdescr.
          lr_structdescr ?= lr_datadescr.
          lt_symbols = lr_structdescr->get_symbols( ).
          LOOP AT lt_symbols REFERENCE INTO lr_symbol.
            APPEND INITIAL LINE TO lt_field_list REFERENCE INTO lr_field.
            lr_field->name = lr_symbol->name.
            lr_field->type_kind = lr_symbol->type->type_kind.
          ENDLOOP.

        ENDIF.

        DATA:
          lr_root TYPE REF TO cx_root,
          lv_err  TYPE string.

        DATA:
          lr_row_data   TYPE REF TO data,
          lv_row_index  TYPE i,
          lr_cell_data  TYPE REF TO lty_sheet_data_cell_s,
          lr_sheet_data TYPE REF TO lty_sheet_data_s,
          lr_sheet_col  TYPE REF TO lty_sheet_data_cell_s,
          lr_sheet_cols TYPE REF TO lty_sheet_data_s.

        "get first row, contains list of fields.
        READ TABLE mt_sheet_data WITH TABLE KEY row_index = 1 REFERENCE INTO lr_sheet_cols.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.
        LOOP AT lt_field_list REFERENCE INTO lr_field.
          "          LOOP AT lr_sheet_cols->row_data REFERENCE INTO lr_sheet_col.
          READ TABLE lr_sheet_cols->row_data WITH KEY value = lr_field->name REFERENCE INTO lr_sheet_col.
          IF sy-subrc <> 0.
            DELETE lt_field_list.
          ELSE.
            lr_field->col = lr_sheet_col->col.
          ENDIF.
        ENDLOOP.

        "todo: handle scenario where linetype is not structured.
        LOOP AT mt_sheet_data REFERENCE INTO lr_sheet_data
          WHERE row_index > 1.

          CLEAR lr_row_data.
          CREATE DATA lr_row_data TYPE HANDLE lr_datadescr.
          UNASSIGN <fs_row>.
          ASSIGN lr_row_data->* TO <fs_row>.
          IF <fs_row> IS NOT ASSIGNED.
            RETURN.
          ENDIF.

          LOOP AT lt_field_list REFERENCE INTO lr_field.
            UNASSIGN <fs_field>.
            ASSIGN COMPONENT lr_field->name OF STRUCTURE <fs_row> TO <fs_field>.
            IF <fs_field> IS NOT ASSIGNED.
              CONTINUE.
            ENDIF.
            READ TABLE lr_sheet_data->row_data WITH KEY col = lr_field->col REFERENCE INTO lr_cell_data.
            IF sy-subrc = 0.
              TRY.
                  convert_str_to_val( EXPORTING
                                        iv_str_val = lr_cell_data->value
                                      IMPORTING
                                        ev_val     = <fs_field> ).
                  "<fs_field> = lr_cell_data->value.
                CATCH cx_root INTO lr_root.
                  CLEAR lv_err.
                  lv_err = lr_root->get_text( ).
                  WRITE:/ lr_field->name, ' ', lv_err.
              ENDTRY.
            ENDIF.

          ENDLOOP.

          INSERT <fs_row> INTO TABLE et_data.
        ENDLOOP.

      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.                    "get_data

ENDCLASS.                    "lcl_worksheet IMPLEMENTATION