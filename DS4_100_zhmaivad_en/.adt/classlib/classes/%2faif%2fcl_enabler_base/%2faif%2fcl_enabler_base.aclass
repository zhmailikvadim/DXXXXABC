class /AIF/CL_ENABLER_BASE definition
  public
  abstract
  create public .

*"* public components of class /AIF/CL_ENABLER_BASE
*"* do not include other source files here!!!
public section.

  interfaces /AIF/IF_ENABLER_BASE .

  types:
    tt_alert_idx_entries_a TYPE STANDARD TABLE OF /aif/alert_idx .

  methods HANDLE_PASSPORT_DATA_EXT
    raising
      /AIF/CX_ENABLER_BASE .
  methods ADD_SY_MESSAGE
    importing
      !IV_MSGID type SYMSGID default SY-MSGID
      !IV_MSGTY type SYMSGTY default SY-MSGTY
      !IV_MSGNO type SYMSGNO default SY-MSGNO
      !IV_MSGV1 type SYMSGV default SY-MSGV1
      !IV_MSGV2 type SYMSGV default SY-MSGV2
      !IV_MSGV3 type SYMSGV default SY-MSGV3
      !IV_MSGV4 type SYMSGV default SY-MSGV4
      !IV_IGNORE_TRACE_LEVEL type BOOLEAN optional .
  methods ADD_SINGLE_LOG_MESSAGE
    importing
      !IV_MSG_TYPE type BAPI_MTYPE optional
      !IV_MSG_ID type SYMSGID optional
      !IV_MSG_NUMBER type SYMSGNO optional
      !IV_MSG_MESSAGE type STRING optional
      !IV_MSG_MESSAGE_V1 type ANY optional
      !IV_MSG_MESSAGE_V2 type ANY optional
      !IV_MSG_MESSAGE_V3 type ANY optional
      !IV_MSG_MESSAGE_V4 type ANY optional
      !IV_MSG_VARS_CONVERT_EXTERNAL type BOOLEAN default 'X'
      !IV_MSG_PARAMETER type BAPI_PARAM optional
      !IV_MSG_ROW type BAPI_LINE optional
      !IV_MSG_FIELD type BAPI_FLD optional
      !IT_DEST_ROW_IDX_TBL type /AIF/DEST_ROW_INDEX_T optional
      !IV_DEST_ROW_CURR_TABIX type SYTABIX optional
      !IV_DETLEVEL type BALLEVEL optional
      !IV_PROBCLASS type BALPROBCL optional
      !IS_BAL_CONTEXT type /AIF/BAL_CONTEXT optional
      !IV_MSG_SOURCE type /AIF/MSG_SOURCE default 'I'
      !IV_IGNORE_TRACE_LEVEL type BOOLEAN optional .
  methods ADD_BAPIRET2_MESSAGE
    importing
      !IS_BAPIRET2_MESSAGE type BAPIRET2 optional
      !IT_DEST_ROW_IDX_TBL type /AIF/DEST_ROW_INDEX_T optional
      !IV_DEST_ROW_CURR_TABIX type SYTABIX optional
      !IV_DETLEVEL type BALLEVEL optional
      !IV_PROBCLASS type BALPROBCL optional
      !IS_BAL_CONTEXT type /AIF/BAL_CONTEXT optional
      !IV_MSG_SOURCE type /AIF/MSG_SOURCE default 'I'
      !IV_IGNORE_TRACE_LEVEL type BOOLEAN optional .
  class-methods IS_MESSAGE_ALLOWED
    importing
      !IV_TRACE_LEVEL type /AIF/TRACE_LEVEL
      !IV_MSG_SOURCE type /AIF/MSG_SOURCE default 'I'
      !IV_MSGID type SYMSGID
      !IV_MSGNO type SYMSGNO
      !IV_AIF_MSGTY type /AIF/MSGTY
      !IV_AIF_MSGCATEGORY type /AIF/MSG_CATEGORY
    returning
      value(RV_IS_ALLOWED) type BOOLEAN .
  methods IS_NEXT_INITIAL_UPDATE_CALL
    returning
      value(RV_NEXT_IS_INITIAL_CALL) type BOOLEAN .
  methods GET_PID
    returning
      value(RV_PID) type SXMSPID .
  methods ADD_BAPIRET2_MESSAGES
    importing
      !IT_BAPIRET2_MESSAGES type BAPIRET2_T
      !IV_DETLEVEL type BALLEVEL optional
      !IV_PROBCLASS type BALPROBCL optional
      !IS_BAL_CONTEXT type /AIF/BAL_CONTEXT optional
      !IV_IGNORE_TRACE_LEVEL type BOOLEAN optional
      !IV_MSG_SOURCE type /AIF/MSG_SOURCE default 'I' .
  methods ADD_MESSAGES_FROM_BALHNDL
  final
    importing
      !IV_LOG_HANDLE type BALLOGHNDL .
  methods ADD_BAL_MESSAGES
    importing
      !IT_LOG_MESSAGES type /AIF/BAL_T_MSG
      !IV_IGNORE_TRACE_LEVEL type BOOLEAN optional
      !IV_MSG_SOURCE type /AIF/MSG_SOURCE default 'I' .
  methods ADD_BAL_MESSAGE
    importing
      !IS_LOG_MESSAGE type BAL_S_MSG
      !IV_MSG_SOURCE type /AIF/MSG_SOURCE default /AIF/IF_GLOBALS=>GC_EH_MSG_SOURCE-INTERFACE
      !IV_MSG_CATEGORY type /AIF/MSG_CATEGORY optional
      !IV_IGNORE_TRACE_LEVEL type BOOLEAN optional .
  methods GET_LOG_MESSAGES
    importing
      !IV_INCLUDE_BUFFERED type BOOLEAN default SPACE
    returning
      value(RT_LOG_MESSAGES) type /AIF/BAL_T_MSG .
  methods GET_FINF
    returning
      value(RS_FINF) type /AIF/T_FINF .
  methods GET_LAST_MESSAGE_STATUS
    returning
      value(RV_STATUS) type /AIF/PROC_STATUS .
  methods GET_TRACE_LEVEL
    returning
      value(RV_TRACE_LEVEL) type /AIF/TRACE_LEVEL .
  methods GET_MSGGUID
    returning
      value(RV_GUID32) type GUID_32 .
  methods CONSTRUCTOR
    importing
      !IV_MSGGUID type GUID_32 optional
      !IV_PID type SXMSPID optional
      !IV_NS type /AIF/NS
      !IV_IFNAME type /AIF/IFNAME
      !IV_IFVERSION type /AIF/IFVERSION
      !IV_FORCE_CREATE_LOG type /AIF/BOOLEAN default ABAP_TRUE
    raising
      /AIF/CX_ENABLER_BASE .
  class-methods SAVE_BUFFERS .
  class-methods BUFFER_SINGLE_IDX_ENTRY
    importing
      !IS_SIDX_ENTRY type ANY
      !IV_SIDX_TAB_NAME type /AIF/MSG_TBL
      !IV_MSGGUID type GUID_32
      !IV_IS_RESTART type CHAR01 .
  methods SET_PID
    importing
      !IV_PID type SXMSPID .
  class-methods BUFFER_MULTI_IDX_ENTRIES
    importing
      !IT_MIDX_ENTRIES type ANY TABLE
      !IV_MIDX_TAB_NAME type /AIF/MSG_TBL
      !IV_MSGGUID type GUID_32 .
  class-methods BUFFER_ALERT_IDX_ENTRIES
    importing
      !IT_ALERT_IDX_ENTRIES type TT_ALERT_IDX_ENTRIES_A .
protected section.
*"* protected components of class /AIF/CL_ENABLER_BASE
*"* do not include other source files here!!!

  data GT_MESSAGE_BUFFER type /AIF/BAL_T_MSG .
  data GV_TRACE_LEVEL type /AIF/TRACE_LEVEL .
  data GV_LAST_MESSAGE_STATUS type /AIF/PROC_STATUS .
  data GR_LOG_STRATEGY type ref to /AIF/IF_LOGGING_ENGINE .
  data GT_LOG_MESSAGES type /AIF/BAL_T_MSG .
  data GT_MMSG_IDX type /AIF/T_MMSG_IDX_TT .
  data GV_INITIAL_CALL type BOOLEAN .
  data GV_SIDX type /AIF/MSG_TBL .
  data GV_MSGGUID type GUID_32 .
  data GV_PID type SXMSPID .
  data GS_FINF type /AIF/T_FINF .

  methods GET_MDI_DATA
    importing
      !IS_SIDX_ENTRY type ANY
      !IS_RAW_STRUCTURE type ANY optional
    returning
      value(RT_MDI_DATA) type /AIF/MDI_DATA_EXT_API_T .
  methods SUPPORTS_MDI_FRUN_INTEGRATION
    returning
      value(RV_SUPPORTS) type ABAP_BOOL .
  methods INIT_LOG_STRATEGY
    importing
      !IV_FORCE_CREATE_LOG type /AIF/BOOLEAN default ABAP_TRUE
    raising
      /AIF/CX_ENABLER_BASE .
  methods SUPPORTS_PASSPORT_DATA
    returning
      value(RV_SUPPORTS) type ABAP_BOOL .
  methods FILL_EPP_LOGICAL_KEY
    importing
      !IS_SIDX_ENTRY type ANY
    changing
      !CS_EPP_LOGICAL_KEY type /AIF/EPP_LOGICALKEYS_S .
  methods CHANGE_PASSPORT_DATA
    importing
      !IV_MSGGUID type GUID_32
      !IS_IFKEYS type /AIF/IFKEYS
      !IS_SIDX_ENTRY type ANY
      !IV_UPDATE type ABAP_BOOL
    changing
      !CS_APPL_DATA type /AIF/EPP_APPL_SPEC_DATA_S
    raising
      /AIF/CX_ENABLER_BASE .
  methods ADD_ADDITIONAL_SIDX_FLDS
    changing
      !CS_SIDX_ENTRY type ANY .
  methods PREPARE_BAPIRET2_BAL_CONTEXT
    importing
      !IV_MSG_PARAMETER type BAPI_PARAM optional
      !IV_MSG_ROW type BAPI_LINE optional
      !IV_MSG_FIELD type BAPI_FLD optional
      !IT_DEST_ROW_IDX_TBL type /AIF/DEST_ROW_INDEX_T optional
      !IV_DEST_ROW_CURR_TABIX type SYTABIX optional
    changing
      !CS_BAL_CONTEXT type /AIF/BAL_CONTEXT .
  methods CREATE_ALERT
    importing
      !IS_SIDX_ENTRY type ANY
      !IT_ALL_LOG_MESSAGES type /AIF/BAL_T_MSG
    exporting
      !ET_RECIPIENTS type /AIF/RECIPIENT_TT
      !EV_ALERT_ID type SALRTEXTID
    changing
      !CT_CURRENT_LOG_MESSAGES type /AIF/BAL_T_MSG .
  methods DETERMINE_STATUS_BY_LOG_MSGS
    importing
      !IT_LOG_MESSAGES type /AIF/BAL_T_MSG
    returning
      value(RV_STATUS_FLAG) type /AIF/PROC_STATUS .
  methods DETERMINE_INB_OUTB
  abstract
    returning
      value(RV_INB_OR_OUTB) type /AIF/INB_OUTB_FLAG .
  methods STORE_SINGLE_KEYFIELDS
    importing
      !IS_RAW_STRUCTURE type ANY optional
      !IS_SAP_STRUCTURE type ANY optional
    changing
      !CS_SIDX_ENTRY type ANY .
  methods GET_KEY_FIELD_DATA_REF
    importing
      !IS_RAW_STRUCTURE type ANY optional
      !IS_SAP_STRUCTURE type ANY optional
      !IS_KFLDS type /AIF/T_INF_KFLDS
      !IV_INB_OR_OUTB type /AIF/INB_OUTB_FLAG
    returning
      value(RR_DATA) type ref to DATA .
  methods UPDATE_ALERT_INDEX
    importing
      !IS_SIDX_ENTRY type ANY
      !IT_RECIPIENTS type /AIF/RECIPIENT_TT
      !IV_ALERT_ID type SALRTEXTID optional .
  methods GET_RECIPIENTS
    importing
      !IS_SIDX_ENTRY type ANY
    returning
      value(RT_RECIPIENTS) type /AIF/RECIPIENT_TT
    raising
      /AIF/CX_ENABLER_BASE .
  methods IS_STATUS_ERROR
    importing
      !IV_MSG_STATUS type /AIF/PROC_STATUS
    returning
      value(RV_IS_FINAL) type BOOLEAN .
  methods IS_STATUS_FINAL
    importing
      !IV_MSG_STATUS type /AIF/PROC_STATUS
    returning
      value(RV_IS_FINAL) type BOOLEAN .
  methods UPDATE_ERRORS
    importing
      !IT_CURRENT_LOG_MESSAGES type /AIF/BAL_T_MSG
    changing
      !CS_SIDX_ENTRY type ANY
    raising
      /AIF/CX_ENABLER_BASE .
  methods UPDATE_MSG_STAT
    importing
      !IS_SIDX_ENTRY type ANY optional
      !IS_SIDX_OLD_ENTRY type ANY optional
      !IV_IS_REPROCESS type BOOLEAN
      !IT_RECIPIENTS type /AIF/RECIPIENT_TT optional
    raising
      /AIF/CX_ENABLER_BASE .
  methods UPDATE_MSGGUID
    importing
      !IV_NEW_MSGGUID type GUID_32
    raising
      /AIF/CX_ENABLER_BASE .
  class-methods GENERATE_TEMP_MSGGUID
    returning
      value(RV_GUID32) type GUID_32 .
  methods GET_SINGLE_INDEX_ENTRY
    returning
      value(RR_SIDX) type ref to DATA
    raising
      /AIF/CX_ENABLER_BASE .
  methods HANDLE_PASSPORT_DATA
    importing
      !IS_SIDX_ENTRY type ANY
    raising
      /AIF/CX_ENABLER_BASE .
  methods HANDLE_MDI_DATA
    importing
      !IS_SIDX_ENTRY type ANY
      !IS_RAW_STRUCTURE type ANY optional
    raising
      /AIF/CX_ENABLER_BASE .
  methods SET_SINGLE_INDEX_ENTRY
    importing
      !IS_SIDX_ENTRY type ANY
    raising
      /AIF/CX_ENABLER_BASE .
  methods UPDATE_KEYFIELDS
    importing
      !IS_RAW_STRUCTURE type ANY optional
      !IS_SAP_STRUCTURE type ANY optional
    changing
      !CS_SIDX_ENTRY type ANY
    raising
      /AIF/CX_ENABLER_BASE .
  methods RUN_KEY_FIELD_RULE
    importing
      !IS_RAW_STRUCTURE type ANY optional
      !IS_SAP_STRUCTURE type ANY optional
      !IS_KFLDS type /AIF/T_INF_KFLDS
    changing
      !CS_SIDX_ENTRY type ANY .
  methods TRIGGER_CENTRAL_MONITORING
    importing
      !IV_OLD_STATUS type /AIF/PROC_STATUS optional
      !IV_STATUS type /AIF/PROC_STATUS
      !IS_IDX_ENTRY type ANY .
  methods TRIGGER_AUTO_REPROCESSING
    importing
      !IV_MSGGUID type GUID_32
      !IS_IFKEYS type /AIF/IFKEYS
      !IT_LOG_MESSAGES type /AIF/BAL_T_MSG
    changing
      !CS_AIFGEN type /AIF/ADMIN .
private section.

*"* private components of class /AIF/CL_ENABLER_BASE
*"* do not include other source files here!!!
  data MO_SELECTION_ENGINE type ref to /AIF/IF_SELECTION_ENGINE .
  class-data GT_SIDX_TAB_ENTRIES_INSERT type /AIF/QRFC_IDX_TABLE_ENTRIES_TT .
  class-data GT_SIDX_TAB_ENTRIES_UPDATE type /AIF/QRFC_IDX_TABLE_ENTRIES_TT .
  class-data GT_MIDX_TAB_ENTRIES_INSERT type /AIF/QRFC_IDX_TABLE_ENTRIES_TT .
  class-data GT_MIDX_TAB_ENTRIES_UPDATE type /AIF/QRFC_IDX_TABLE_ENTRIES_TT .
  class-data GT_ALERT_IDX type TT_ALERT_IDX_ENTRIES_A .

  methods INIT_SELECTION_ENGINE
    raising
      /AIF/CX_ENABLER_BASE .
  methods DETERMINE_TRACE_LEVEL
    importing
      !IV_NS type /AIF/NS
      !IV_IFNAME type /AIF/IFNAME
      !IV_IFVERSION type /AIF/IFVERSION
      !IV_SINGLE_IDX_TBL type /AIF/MSG_TBL optional
      !IV_MSGGUID type GUID_32 optional
    returning
      value(RV_TRACE_LEVEL) type /AIF/TRACE_LEVEL .
  methods DETERMINE_SINGLE_IDX_TBL
    importing
      !IV_NS type /AIF/NS
      !IV_IFNAME type /AIF/IFNAME
      !IV_IFVERSION type /AIF/IFVERSION
    returning
      value(RV_SIDX_TBL_NAME) type /AIF/MSG_TBL .
ENDCLASS.



CLASS /AIF/CL_ENABLER_BASE IMPLEMENTATION.


METHOD get_recipients.
  DATA: lt_alrt_inf         TYPE /aif/recipient_tt,

        ls_err              TYPE scx_t100key.

  CALL FUNCTION '/AIF/ALERT_DET_RECIPIENTS'
    EXPORTING
      ns                 = gs_finf-ns
      ifname             = gs_finf-ifname
      ifversion          = gs_finf-ifversion
      is_single_msg_data = is_sidx_entry
      use_buffer         = 'X'
    TABLES
      recipients         = rt_recipients
    EXCEPTIONS
      not_found          = 1
      field_not_found    = 2
      OTHERS             = 3.
  CASE sy-subrc.
    WHEN 0.
    WHEN 1.
    WHEN OTHERS.
      ls_err-msgid = sy-msgid.
      ls_err-msgno = sy-msgno.
      ls_err-attr1 = sy-msgv1.
      ls_err-attr2 = sy-msgv2.
      ls_err-attr3 = sy-msgv3.
      ls_err-attr4 = sy-msgv4.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING textid = ls_err.
  ENDCASE.


**** Fallback recipients will be added when statistics are updated and are not needed here ******

ENDMETHOD.


METHOD get_single_index_entry.

  DATA: lo_index_table_buffer TYPE REF TO /aif/if_index_table_buffer.

  lo_index_table_buffer = mo_selection_engine->get_index_table_buffer_for_msg(
      iv_msgguid    = gv_msgguid
      iv_ns         = gs_finf-ns
      iv_ifname     = gs_finf-ifname
      iv_ifversion  = gs_finf-ifversion ).

  rr_sidx = lo_index_table_buffer->get_single_idx_entry( ).

ENDMETHOD.


METHOD get_trace_level.
  rv_trace_level = gv_trace_level.
ENDMETHOD.


METHOD handle_mdi_data.

  TRY.
      IF supports_mdi_frun_integration( ) = abap_false.
        RETURN.
      ENDIF.

      FIELD-SYMBOLS <fs_sidx> TYPE /aif/std_idx_tbl.
      UNASSIGN <fs_sidx>.
      ASSIGN is_sidx_entry TO <fs_sidx> CASTING.
      IF sy-subrc <> 0.
        RETURN.
      ENDIF.

      DATA(ls_epp_logical_key) = VALUE /aif/epp_logicalkeys_s( ).
      fill_epp_logical_key( EXPORTING
                              is_sidx_entry      = is_sidx_entry
                            CHANGING
                              cs_epp_logical_key = ls_epp_logical_key ).
      IF ls_epp_logical_key IS INITIAL.
        RETURN.
      ENDIF.

      DATA(lt_mdi_data) = VALUE /aif/mdi_data_ext_api_t( ).
      lt_mdi_data = get_mdi_data( is_sidx_entry    = is_sidx_entry
                                  is_raw_structure = is_raw_structure ).
      IF lt_mdi_data IS NOT INITIAL.
        /aif/cl_mdi_data_servicre=>save_data( is_epp_logical_key = ls_epp_logical_key
                                              it_mdi_data        = lt_mdi_data  ).
        RETURN.
      ENDIF.

    CATCH cx_root INTO DATA(lr_root).
      MESSAGE w040(/aif/enabler_base) INTO /aif/cx_passport_general=>mv_dummy.
      add_sy_message( ).
  ENDTRY.

ENDMETHOD.


METHOD handle_passport_data.

  TRY.
      IF supports_passport_data( ) = abap_false.
        RETURN.
      ENDIF.

      FIELD-SYMBOLS <fs_sidx> TYPE /aif/std_idx_tbl.
      UNASSIGN <fs_sidx>.
      ASSIGN is_sidx_entry TO <fs_sidx> CASTING.
      IF sy-subrc <> 0.
        RETURN.
      ENDIF.

      DATA lr_passport TYPE REF TO /aif/cl_passport_service.
      DATA lv_update TYPE abap_bool VALUE abap_false.
      lr_passport = /aif/cl_passport_service=>create_instance( ).

      DATA(ls_epp_logical_key) = VALUE /aif/epp_logicalkeys_s( ).
      fill_epp_logical_key( EXPORTING
                              is_sidx_entry      = is_sidx_entry
                            CHANGING
                              cs_epp_logical_key = ls_epp_logical_key ).

      DATA(ls_epp) = VALUE /aif/epp_corre( ).
      lr_passport->get_aif_correl_data_for_upd( EXPORTING
                                                  is_epp_logical_key   = ls_epp_logical_key "<fs_sidx>-msgguid
                                                  is_ifkeys            = <fs_sidx>-aifkeys
                                                IMPORTING
                                                  es_epp_corre         = ls_epp
                                                  ev_update            = lv_update ).

      change_passport_data( EXPORTING
                              iv_msgguid    = <fs_sidx>-msgguid
                              is_ifkeys     = <fs_sidx>-aifkeys
                              is_sidx_entry = is_sidx_entry
                              iv_update     = lv_update
                            CHANGING
                              cs_appl_data  = ls_epp-application_data ).

      lr_passport->process_epp_correlation_data( is_epp_correlation_data = ls_epp
                                                 iv_update               = lv_update ).

    CATCH /aif/cx_passport_general INTO DATA(lr_pass_exp).
      me->add_sy_message( iv_msgid              = lr_pass_exp->if_t100_message~t100key-msgid
                          iv_msgty              = 'W'
                          iv_msgno              = lr_pass_exp->if_t100_message~t100key-msgno
                          iv_msgv1              = lr_pass_exp->mv_msgv1
                          iv_msgv2              = lr_pass_exp->mv_msgv2
                          iv_msgv3              = lr_pass_exp->mv_msgv3
                          iv_msgv4              = lr_pass_exp->mv_msgv4
                          iv_ignore_trace_level = abap_true ).

    CATCH cx_root INTO DATA(lr_root).
      MESSAGE w040(/aif/enabler_base) INTO /aif/cx_passport_general=>mv_dummy.
      add_sy_message( ).
  ENDTRY.

ENDMETHOD.


  METHOD handle_passport_data_ext.

    DATA lr_sidx_entry TYPE REF TO data.
    FIELD-SYMBOLS <fs_sidx_entry> TYPE any.

    IF supports_passport_data( ) = abap_false.
      RETURN.
    ENDIF.

    lr_sidx_entry = get_single_index_entry( ).
    IF lr_sidx_entry IS INITIAL.
      RETURN.
    ENDIF.
    UNASSIGN <fs_sidx_entry>.
    ASSIGN lr_sidx_entry->* TO <fs_sidx_entry>.
    IF <fs_sidx_entry> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    handle_passport_data( is_sidx_entry = <fs_sidx_entry> ).

  ENDMETHOD.


  METHOD init_log_strategy.

    DATA: lv_log_engine_class_name TYPE /aif/logging_engine_class,
          lv_log_subobject         TYPE balsubobj,
          lv_extno                 TYPE balnrext,
          ls_finft                 TYPE /aif/t_finft,
          ls_finft_out             TYPE /aif/t_finft,
          lv_ifdesc                TYPE balsubobjt,
          lr_dba_finf              TYPE REF TO /aif/if_dba_finf,
          lr_dba_mgr               TYPE REF TO /aif/cl_dba_reader_mgr,
          lr_log_engine_not_found  TYPE REF TO /aif/cx_aif_engine_not_found,
          lr_ballog_exc            TYPE REF TO /aif/cx_bal_log_strategy.

    lv_extno = gv_msgguid.
    CONCATENATE gs_finf-ns gs_finf-ifname INTO lv_log_subobject SEPARATED BY space.

    CLEAR ls_finft_out.
    ls_finft_out-ns = gs_finf-ns.
    ls_finft_out-ifname = gs_finf-ifname.
    ls_finft_out-ifversion = gs_finf-ifversion.

    lr_dba_mgr = /aif/cl_dba_reader_mgr=>get_instance( ).
    lr_dba_finf   = lr_dba_mgr->get_dba_finf( ).
    CLEAR ls_finft.
    TRY.
        ls_finft = lr_dba_finf->read_text_by_different_langu( ls_finft_out ).
      CATCH /aif/cx_dba_reader. " do noting
    ENDTRY.
    lv_ifdesc = ls_finft-ifdesc.

* identify the interface's logging engine
    TRY.
        CALL METHOD /aif/cl_aif_engine_factory=>get_log_engine_classname
          EXPORTING
            iv_log_engine_id      = gs_finf-log_engine_id
            iv_cust_namespace     = gs_finf-cust_ns_log
            iv_cust_log_engine_id = gs_finf-cust_log_eng_id
          RECEIVING
            rv_classname          = lv_log_engine_class_name.
      CATCH /aif/cx_aif_engine_not_found INTO lr_log_engine_not_found .
        RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_log_engine_not_found.
    ENDTRY.

    "Determine Application log lifetime
    DATA:
      lv_msg_lifetime    TYPE /aif/msg_lifetime,
      lr_global_settings TYPE REF TO /aif/cl_aif_global_settings.

    "Store value configured in interface customizing
    lv_msg_lifetime = gs_finf-msg_lifetime.

* erasure of personal data:
    IF lv_msg_lifetime IS INITIAL. "No value for Appliation Log Lifetime provided -> Use global setting
      "Get app. log lifetime value
      lr_global_settings = /aif/cl_aif_global_settings=>get_instance( ).
      IF lr_global_settings IS BOUND.
        lv_msg_lifetime = lr_global_settings->get_appl_log_lifetime( ).
        IF lv_msg_lifetime IS INITIAL."No value for Appliation Log Lifetime provided in global setting
          lv_msg_lifetime = /aif/if_appl_log_writer=>mc_default_expiration_duration.
        ENDIF.
      ENDIF.
    ENDIF.


* create logging engine
    TRY.
        CREATE OBJECT gr_log_strategy
          TYPE
            (lv_log_engine_class_name)
          EXPORTING
            iv_object                  = '/AIF/LOG'
            iv_object_text             = 'SAP Application Interface Framework' "#EC NOTEXT
            iv_extnumber               = lv_extno
            iv_subobject               = lv_log_subobject
            iv_subobject_text          = lv_ifdesc
            iv_msg_lifetime            = lv_msg_lifetime"gs_finf-msg_lifetime
            iv_repid                   = sy-repid
            iv_create_log              = abap_true
            iv_force_create_log        = iv_force_create_log
        .
      CATCH /aif/cx_bal_log_strategy INTO lr_ballog_exc.
        RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_ballog_exc.
    ENDTRY.

  ENDMETHOD.


  method init_selection_engine.

    data: lr_log_engine_not_found  type ref to /aif/cx_aif_engine_not_found.

* identify the interface's selection engine
    try.
        mo_selection_engine = /aif/cl_aif_engine_factory=>get_selection_engine(
            iv_selection_engine_id       = gs_finf-sel_engine_id
            iv_cust_namespace            = gs_finf-cust_ns_sel
            iv_cust_sel_engine_id        = gs_finf-cust_sel_eng_id ).
      catch /aif/cx_aif_engine_not_found into lr_log_engine_not_found .
        raise exception type /aif/cx_enabler_base exporting previous = lr_log_engine_not_found.
    endtry.

  endmethod.


METHOD is_message_allowed.
  DATA: lt_tl   TYPE /aif/trace_lv_def_tt.

  rv_is_allowed = 'X'.
  CHECK NOT iv_trace_level IS INITIAL.

**** We have 2 special AIF messages that are only allowed for trace level 3
***  IF iv_msg_source = /aif/if_globals=>gc_eh_msg_source-framework AND
***    iv_msgid = '/AIF/MES' AND
***    ( iv_msgno = '166' OR iv_msgno = '167' ).
***
***    IF NOT iv_trace_level = '3'.
***      rv_is_allowed = space.
***    ENDIF.
***  ELSE.
* get all the relevant trace level definitions
    CALL FUNCTION '/AIF/GET_FULL_TRACE_LV_DEF'
      EXPORTING
        iv_trace_level  = iv_trace_level
      IMPORTING
        et_trace_lv_def = lt_tl
      EXCEPTIONS
        not_defined     = 1
        OTHERS          = 2.
    IF sy-subrc IS INITIAL. " otherwise the initially set value will be returned, i.e. 'X'
      READ TABLE lt_tl TRANSPORTING NO FIELDS
        WITH TABLE KEY msg_source    = iv_msg_source
                       msg_type      = iv_aif_msgty
                       msg_category  = iv_aif_msgcategory.
      IF NOT sy-subrc IS INITIAL.
        rv_is_allowed = space.
      ENDIF.
    ENDIF.
***  ENDIF.
ENDMETHOD.


method IS_NEXT_INITIAL_UPDATE_CALL.
  rv_next_is_initial_call = gv_initial_call.
endmethod.


METHOD is_status_error.
  rv_is_final = ''.

  IF iv_msg_status = 'E' OR iv_msg_status = 'A'.
    rv_is_final = 'X'.
  ENDIF.
ENDMETHOD.


METHOD is_status_final.
  rv_is_final = ''.

  IF iv_msg_status = 'S' OR iv_msg_status = 'W' OR iv_msg_status = 'E' OR iv_msg_status = 'A'.
    rv_is_final = 'X'.
  ENDIF.
ENDMETHOD.


METHOD prepare_bapiret2_bal_context.
  DATA: lt_ddic_tree         TYPE TABLE OF /aif/ddic_tree,
        lt_rectypes          TYPE TABLE OF /aif/rectype,
        lv_rectypenr         TYPE /aif/rectypenr,
        lv_maincomponent     TYPE /aif/maincomponent.

  FIELD-SYMBOLS: <ls_dest_row_index> TYPE /aif/dest_row_index,
                 <lv_rectype>        TYPE /aif/rectype,
                 <ls_ddic_tree>      TYPE /aif/ddic_tree.

  IF NOT iv_msg_parameter IS INITIAL AND it_dest_row_idx_tbl IS SUPPLIED.

    READ TABLE it_dest_row_idx_tbl ASSIGNING <ls_dest_row_index>
        WITH KEY  tabixparent = iv_dest_row_curr_tabix
                  name        = iv_msg_parameter
                  linenr      = iv_msg_row.

    IF sy-subrc = 0.
      cs_bal_context-rectypenr     = <ls_dest_row_index>-source_data->rectypenr.
      cs_bal_context-globalrownr   = <ls_dest_row_index>-source_data->globalrownr.
      cs_bal_context-maincomponent = <ls_dest_row_index>-source_data->name.
    ENDIF.

  ELSEIF NOT iv_msg_parameter IS INITIAL AND NOT iv_msg_row IS INITIAL.

    CALL FUNCTION '/AIF/UTIL_GET_STRUCT_FIELDS'
      EXPORTING
        structname      = gs_finf-ddicstructureraw
        suppress_fields = 'X'
      IMPORTING
        ddic_tree       = lt_ddic_tree
      EXCEPTIONS
        error           = 1
        cancel          = 2
        OTHERS          = 3.
    IF sy-subrc = 0.
      " split parameter to scan table right
      SPLIT iv_msg_parameter AT '-' INTO TABLE lt_rectypes.
      " insert rectyperaw as first rectype
      IF NOT gs_finf-rectyperaw IS INITIAL.
        INSERT gs_finf-rectyperaw INTO lt_rectypes INDEX 1.
      ENDIF.
      CLEAR: lv_rectypenr, lv_maincomponent.
      LOOP AT lt_rectypes ASSIGNING <lv_rectype>.
        READ TABLE lt_ddic_tree ASSIGNING <ls_ddic_tree> WITH KEY parent = lv_rectypenr name = <lv_rectype>.
        IF sy-subrc = 0.
          lv_rectypenr     = <ls_ddic_tree>-fieldnumber.
          lv_maincomponent = <ls_ddic_tree>-name.
        ELSE.
          EXIT.
        ENDIF.
      ENDLOOP.
      cs_bal_context-rectypenr     = lv_rectypenr.
      cs_bal_context-globalrownr   = iv_msg_row.
      cs_bal_context-maincomponent = lv_maincomponent.
    ENDIF.

  ENDIF.
ENDMETHOD.


METHOD run_key_field_rule.

  CALL FUNCTION '/AIF/RUN_KEY_FIELD_RULE'
    EXPORTING
      is_raw_structure = is_raw_structure
      is_sap_structure = is_sap_structure
      is_kflds         = is_kflds
    CHANGING
      cs_sidx_entry    = cs_sidx_entry.

ENDMETHOD.


METHOD save_buffers.
*    Performance Optimization
  DATA: lt_lognumbers TYPE bal_t_lgnm.
  DATA: lr_cx_not_a_table TYPE REF TO cx_abap_not_a_table.
  DATA: lv_idx_table_name TYPE /aif/msg_tbl.

  FIELD-SYMBOLS: <ls_idx_tab_entries> TYPE /aif/qrfc_idx_table_entries_st,
                 <ls_idx_entry>       TYPE any,
                 <lt_idx_entries>     TYPE ANY TABLE,
                 <ls_lognumber>       TYPE bal_s_lgnm,
                 <lv_lognumber>       TYPE balognr.

  lt_lognumbers = /aif/cl_lognumber_buffer=>save_buffer( ).

*    replace temporary log numbers with "real" lognumbers
  LOOP AT gt_sidx_tab_entries_insert ASSIGNING <ls_idx_tab_entries>.
    ASSIGN <ls_idx_tab_entries>-idx_table_entries->* TO <lt_idx_entries>.
    LOOP AT <lt_idx_entries> ASSIGNING <ls_idx_entry>.
      ASSIGN COMPONENT /aif/if_globals=>gc_eh_fix_key_flds-lognumber OF STRUCTURE <ls_idx_entry> TO <lv_lognumber>.
      IF sy-subrc = 0.
        READ TABLE lt_lognumbers ASSIGNING <ls_lognumber> WITH KEY tmp_lognum = <lv_lognumber>. "#EC CI_SORTSEQ
        IF sy-subrc = 0.
          <lv_lognumber> = <ls_lognumber>-lognumber.
        ENDIF.
      ENDIF.
    ENDLOOP.
    TRY.
        CLEAR lv_idx_table_name.
        lv_idx_table_name = cl_abap_dyn_prg=>check_table_name_str( val      = <ls_idx_tab_entries>-idx_table_name
                                                                   packages = '' ).
      CATCH cx_abap_not_a_table.
        ASSERT 1 = 2.
      CATCH cx_abap_not_in_package.
    ENDTRY.
    INSERT (lv_idx_table_name) FROM TABLE <lt_idx_entries>.
*      TODO: Delete those entries from buffer?
  ENDLOOP.
  REFRESH: gt_sidx_tab_entries_insert.

* save index entries for update
  LOOP AT gt_sidx_tab_entries_update ASSIGNING <ls_idx_tab_entries>.
    ASSIGN <ls_idx_tab_entries>-idx_table_entries->* TO <lt_idx_entries>.
    LOOP AT <lt_idx_entries> ASSIGNING <ls_idx_entry>.
      ASSIGN COMPONENT /aif/if_globals=>gc_eh_fix_key_flds-lognumber OF STRUCTURE <ls_idx_entry> TO <lv_lognumber>.
      IF sy-subrc = 0.
        READ TABLE lt_lognumbers ASSIGNING <ls_lognumber> WITH KEY tmp_lognum = <lv_lognumber>. "#EC CI_SORTSEQ
        IF sy-subrc = 0.
          <lv_lognumber> = <ls_lognumber>-lognumber.
        ENDIF.
      ENDIF.
    ENDLOOP.
    TRY.
        CLEAR lv_idx_table_name.
        lv_idx_table_name = cl_abap_dyn_prg=>check_table_name_str( val      = <ls_idx_tab_entries>-idx_table_name
                                                                   packages = '' ).
      CATCH cx_abap_not_a_table.
        ASSERT 1 = 2.
      CATCH cx_abap_not_in_package.
    ENDTRY.
    UPDATE (lv_idx_table_name) FROM TABLE <lt_idx_entries>.
  ENDLOOP.
  REFRESH: gt_sidx_tab_entries_update.

* save buffered alert index table entries
  IF NOT gt_alert_idx[] IS INITIAL.
    INSERT /aif/alert_idx FROM TABLE gt_alert_idx ACCEPTING DUPLICATE KEYS.
    REFRESH: gt_alert_idx.
  ENDIF.


ENDMETHOD.


method SET_PID.

    gv_pid = iv_pid.

endmethod.


METHOD set_single_index_entry.

  DATA: lo_index_table_buffer TYPE REF TO /aif/if_index_table_buffer.

  lo_index_table_buffer = mo_selection_engine->get_index_table_buffer_for_msg(
      iv_msgguid    = gv_msgguid
      iv_ns         = gs_finf-ns
      iv_ifname     = gs_finf-ifname
      iv_ifversion  = gs_finf-ifversion ).

  lo_index_table_buffer->set_single_idx_entry( EXPORTING is_data = is_sidx_entry
                                                       EXCEPTIONS invalid_msgguid = 1 ). "note 2935135
  IF sy-subrc = 1.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING
        textid    = /aif/cx_enabler_base=>sidx_update_failed
        data_type = gv_sidx.
  ENDIF.
  lo_index_table_buffer->save( EXCEPTIONS invalid_msgguid = 1
                                          saving_single_idx_entry_failed = 2
                                          saving_multi_idx_entry_failed = 3 ).


  IF sy-subrc = 1 OR sy-subrc = 2.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING
        textid    = /aif/cx_enabler_base=>sidx_update_failed
        data_type = gv_sidx.
  ELSEIF sy-subrc = 3.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base.
  ENDIF.

ENDMETHOD.


METHOD store_single_keyfields.
  DATA: lt_kflds         TYPE /aif/inf_sel_mflds_tt,
        ls_kflds         TYPE /aif/t_inf_kflds,

        lv_inb_or_outb   TYPE /aif/inb_outb_flag,
        lv_fieldvalue    TYPE string,

        lr_dba_mgr       TYPE REF TO /aif/cl_dba_reader_mgr,
        lr_dba_inf_kflds TYPE REF TO /aif/if_dba_inf_kflds,
        ls_inf_kflds_out TYPE /aif/t_inf_kflds.

  FIELD-SYMBOLS: <ls_kflds>        TYPE /aif/t_inf_kflds,

                 <ls_midx_entry>   TYPE any,

                 <ls_sidx_ifkeys>  TYPE /aif/ifkeys,
                 <ls_midx_ifkeys>  TYPE /aif/ifkeys,
                 <ls_sidx_admin>   TYPE /aif/admin,
                 <ls_midx_admin>   TYPE /aif/admin,
                 <lv_sidx_msgguid> TYPE guid_32,
                 <lv_midx_msgguid> TYPE guid_32,

                 <ls_linedata>     TYPE any,
                 <lv_idx_field>    TYPE any.

  DATA lr_keyfld_data TYPE REF TO data.

  " prepare values from single index table for copying into multi/document index tables

  ASSIGN COMPONENT 'AIFKEYS' OF STRUCTURE cs_sidx_entry TO <ls_sidx_ifkeys>.
  ASSIGN COMPONENT 'ADMIN'   OF STRUCTURE cs_sidx_entry TO <ls_sidx_admin>.
  ASSIGN COMPONENT 'MSGGUID' OF STRUCTURE cs_sidx_entry TO <lv_sidx_msgguid>.

  lr_dba_mgr = /aif/cl_dba_reader_mgr=>get_instance( ).
  lr_dba_inf_kflds = lr_dba_mgr->get_dba_inf_kflds( ).

  ls_inf_kflds_out-ns = gs_finf-ns.
  ls_inf_kflds_out-ifname = gs_finf-ifname.
  ls_inf_kflds_out-ifver = gs_finf-ifversion.

  TRY.
      lt_kflds = lr_dba_inf_kflds->read_table( is_key = ls_inf_kflds_out ).

    CATCH /aif/cx_dba_reader.
      CLEAR lt_kflds.
  ENDTRY.

  DELETE lt_kflds WHERE is_multi <> ''.

  " not all keyfield types have an index table assigned -> assign it based on keyfield type: single or document
  ls_kflds-idx_table = gv_sidx.
  MODIFY lt_kflds FROM ls_kflds TRANSPORTING idx_table WHERE is_multi = ''.

  lv_inb_or_outb = me->determine_inb_outb( ).
  LOOP AT lt_kflds ASSIGNING <ls_kflds>.
    CLEAR: lv_fieldvalue.
*    " skip this keyfield if the corresponding structure is not supplied
*    IF ( <ls_kflds>-raw_or_sap = 'S'      AND lv_inb_or_outb = 'I' ) OR " S = destination structure; S + I    -> SAP structure
*       ( <ls_kflds>-raw_or_sap IS INITIAL AND lv_inb_or_outb = 'O' ).   " blank = source structure; blank + O -> SAP structure
*      CHECK is_sap_structure IS SUPPLIED AND NOT is_sap_structure IS INITIAL.
*      ASSIGN is_sap_structure TO <ls_linedata>.
*    ELSEIF ( <ls_kflds>-raw_or_sap IS INITIAL AND lv_inb_or_outb = 'I' ) OR  " S = destination structure; S + I    -> SAP structure
*           ( <ls_kflds>-raw_or_sap = 'S'      AND lv_inb_or_outb = 'O' ).
*      CHECK is_raw_structure IS SUPPLIED AND NOT is_raw_structure IS INITIAL.
*      ASSIGN is_raw_structure TO <ls_linedata>.
*    ENDIF.

    CLEAR lr_keyfld_data.
    lr_keyfld_data = get_key_field_data_ref( is_raw_structure = is_raw_structure
                                             is_sap_structure = is_sap_structure
                                             iv_inb_or_outb   = lv_inb_or_outb
                                             is_kflds         = <ls_kflds> ).
    UNASSIGN <ls_linedata>.
    IF lr_keyfld_data IS BOUND.
      ASSIGN lr_keyfld_data->* TO <ls_linedata> .
    ENDIF.
    CHECK <ls_linedata> IS ASSIGNED.
    CHECK NOT <ls_linedata> IS INITIAL.

    CALL FUNCTION '/AIF/UTIL_READ_DATA'
      EXPORTING
        data              = <ls_linedata>
        path              = <ls_kflds>-aif_fieldname
        ns                = gs_finf-ns
        ifname            = gs_finf-ifname
        ifversion         = gs_finf-ifversion
      IMPORTING
        result            = lv_fieldvalue
      EXCEPTIONS
        element_not_found = 1
        empty_table       = 2
        error_occurs      = 3
        OTHERS            = 4.
    IF sy-subrc <> 0.
      CLEAR: lv_fieldvalue. " non-disruptive: do not raise exception just because the value could not be determined
    ENDIF.

*   IF lv_fieldvalue IS NOT INITIAL.
    ASSIGN COMPONENT <ls_kflds>-fieldname OF STRUCTURE cs_sidx_entry TO <lv_idx_field>.
    IF sy-subrc = 0.
      <lv_idx_field> = lv_fieldvalue.
    ENDIF.
*   ENDIF.

  ENDLOOP.

* key field rule
  LOOP AT lt_kflds ASSIGNING <ls_kflds> WHERE is_multi = space
                                          AND is_enh_kfld = 'X'.
* field is for single selection and marked as enhanced

    CALL METHOD me->run_key_field_rule
      EXPORTING
        is_raw_structure = is_raw_structure
        is_sap_structure = is_sap_structure
        is_kflds         = <ls_kflds>
      CHANGING
        cs_sidx_entry    = cs_sidx_entry.

  ENDLOOP.

ENDMETHOD.


  METHOD supports_mdi_frun_integration.

    rv_supports = abap_false.

  ENDMETHOD.


  METHOD supports_passport_data.

    rv_supports = abap_false.

  ENDMETHOD.


  METHOD trigger_auto_reprocessing.
    IF iv_msgguid IS INITIAL OR it_log_messages IS INITIAL.
      RETURN.
    ENDIF.
    DATA(lr_log_handler) = /aif/cl_log_handler_factory=>get_log_handler( iv_msgguid ).
    lr_log_handler->set_messages( it_log_messages ).

    DATA lr_auto_rep_mgr_factory TYPE REF TO /aif/if_auto_rep_mgr_factory.
    CALL FUNCTION '/AIF/AUTO_REP_FACTORY'
      IMPORTING
        er_auto_rep_mng_factory = lr_auto_rep_mgr_factory.
    TRY.
        lr_auto_rep_mgr_factory->trigger_auto_reprocessing(
              EXPORTING
                iv_msgguid          = iv_msgguid
                is_ifkeys           = is_ifkeys
                ir_log_handler      = lr_log_handler
                iv_separate_session = abap_true
              CHANGING
                cs_aifgen           = cs_aifgen ).
      CATCH /aif/cx_auto_rep_failed.
* no handler
    ENDTRY.
  ENDMETHOD.


  METHOD trigger_central_monitoring.
    CASE iv_status.
      WHEN 'I'.
        IF iv_old_status <> iv_status.
          /aif/cl_process_observer=>s_raise_event( is_idx_entry = is_idx_entry iv_status = /aif/cl_process_observer=>gc_status_start iv_location = 'E' ).
        ENDIF.
      WHEN 'S'.
        /aif/cl_process_observer=>s_raise_event( is_idx_entry = is_idx_entry iv_status = /aif/cl_process_observer=>gc_status_finished iv_location = 'E' ).
      WHEN 'E'.
        /aif/cl_process_observer=>s_raise_event( is_idx_entry = is_idx_entry iv_status = /aif/cl_process_observer=>gc_status_error iv_location = 'E' ).
      WHEN 'A'.
        /aif/cl_process_observer=>s_raise_event( is_idx_entry = is_idx_entry iv_status = /aif/cl_process_observer=>gc_status_error iv_location = 'E' ).
      WHEN 'C'.
        /aif/cl_process_observer=>s_raise_event( is_idx_entry = is_idx_entry iv_status = /aif/cl_process_observer=>gc_status_canceled iv_location = 'E' ).
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.


METHOD update_alert_index.
  DATA: lt_alert_idx_exists        TYPE TABLE OF /aif/alert_idx,
        lt_alert_idx_update        TYPE TABLE OF /aif/alert_idx,
        lt_alert_idx_delete        TYPE TABLE OF /aif/alert_idx,
        lt_alert_idx_insert        TYPE TABLE OF /aif/alert_idx,
        ls_alert_idx               TYPE /aif/alert_idx,
        lo_db                      TYPE REF TO /aif/cl_db_control, "2173152
        lv_existed_recipientnr     TYPE i.
  FIELD-SYMBOLS: <lv_msg_guid>     TYPE guid_32,
                 <ls_recipient>    TYPE /aif/alrt_cat_str,
                 <ls_alert_exists> TYPE /aif/alert_idx,
                 <ls_aifkeys>      TYPE /aif/ifkeys.

  ASSIGN COMPONENT 'MSGGUID' OF STRUCTURE is_sidx_entry TO <lv_msg_guid>.
  CHECK sy-subrc = 0.
  ASSIGN COMPONENT 'AIFKEYS' OF STRUCTURE is_sidx_entry TO <ls_aifkeys>.
  CHECK sy-subrc = 0.
  MOVE-CORRESPONDING is_sidx_entry TO ls_alert_idx.

* check if secondary database connection is active
  lo_db = /aif/cl_db_control=>get_instance( ).              "2173152
  IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
    SELECT  mandt msgguid recipientnr ns ifname ifver nsrecip recipient create_date last_date status alert_id INTO TABLE lt_alert_idx_exists
        FROM /aif/alert_idx  WHERE msgguid = <lv_msg_guid>.
    IF sy-subrc = 0.
      DESCRIBE TABLE lt_alert_idx_exists LINES lv_existed_recipientnr.
    ELSE.
      lv_existed_recipientnr = 0.
    ENDIF.
  ELSE.
* secondary database connection
    SELECT  mandt msgguid recipientnr ns ifname ifver nsrecip recipient create_date last_date status alert_id
         INTO TABLE lt_alert_idx_exists
        FROM /aif/alert_idx  CONNECTION (lo_db->mc_db_name) WHERE msgguid = <lv_msg_guid>.
    IF sy-subrc = 0.
      DESCRIBE TABLE lt_alert_idx_exists LINES lv_existed_recipientnr.
    ELSE.
      lv_existed_recipientnr = 0.
    ENDIF.
  ENDIF.
  "Note 2692099 begin
  TRY.
      DATA(lv_recipientnr_backup) = lv_existed_recipientnr.
      SORT lt_alert_idx_exists ASCENDING BY recipientnr.
      lv_existed_recipientnr = lt_alert_idx_exists[ lv_existed_recipientnr ]-recipientnr.
    CATCH cx_sy_itab_line_not_found INTO DATA(lo_itab_line_not_found).
      lv_existed_recipientnr = lv_recipientnr_backup.
  ENDTRY.
  "Note 2692099 end
*   get deletion list for that recipients that have not been determined again
*   this case only happens when removed some recipients assignment or restart case with message category
  CLEAR lt_alert_idx_delete[].
  LOOP AT lt_alert_idx_exists ASSIGNING <ls_alert_exists> WHERE ns = <ls_aifkeys>-ns AND ifname = <ls_aifkeys>-ifname AND ifver = <ls_aifkeys>-ifver.
    READ TABLE it_recipients WITH KEY nsrecip = <ls_alert_exists>-nsrecip  recipient = <ls_alert_exists>-recipient TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND <ls_alert_exists> TO lt_alert_idx_delete.
    ENDIF.
  ENDLOOP.
*  prepare existing entries and new entries for recipients that have not been determined before
  CLEAR: lt_alert_idx_insert[], lt_alert_idx_update[].
  LOOP AT it_recipients ASSIGNING <ls_recipient>.
    READ TABLE lt_alert_idx_exists ASSIGNING <ls_alert_exists> WITH KEY ns = <ls_aifkeys>-ns  ifname = <ls_aifkeys>-ifname   ifver = <ls_aifkeys>-ifver
                                                                        nsrecip = <ls_recipient>-nsrecip  recipient = <ls_recipient>-recipient.
    IF sy-subrc = 0. " Alert entry already exists, then update this entry regards below four fields
      IF <ls_alert_exists>-create_date <> ls_alert_idx-create_date
      OR <ls_alert_exists>-last_date   <> ls_alert_idx-last_date
      OR <ls_alert_exists>-status      <> ls_alert_idx-status
      OR <ls_alert_exists>-alert_id    <> iv_alert_id.
        ls_alert_idx-recipientnr = <ls_alert_exists>-recipientnr.
        ls_alert_idx-nsrecip     = <ls_recipient>-nsrecip.
        ls_alert_idx-recipient   = <ls_recipient>-recipient.
        ls_alert_idx-alert_id    = iv_alert_id.
        APPEND ls_alert_idx TO lt_alert_idx_update.
      ENDIF.
    ELSE.           " new entry needs to be inserted.
      ls_alert_idx-recipientnr  = lv_existed_recipientnr = lv_existed_recipientnr + 1.
      ls_alert_idx-nsrecip      = <ls_recipient>-nsrecip.
      ls_alert_idx-recipient    = <ls_recipient>-recipient.
      ls_alert_idx-alert_id     = iv_alert_id.
      APPEND ls_alert_idx TO lt_alert_idx_insert.
    ENDIF.
  ENDLOOP.

  IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
*-  deletes entries for recipients that have not been determined again
    IF NOT lt_alert_idx_delete[] IS INITIAL.
      DELETE  /aif/alert_idx FROM TABLE lt_alert_idx_delete.
    ENDIF.
*-  updates existing entries
    IF NOT lt_alert_idx_update[] IS INITIAL.
      UPDATE  /aif/alert_idx FROM TABLE lt_alert_idx_update.
    ENDIF.
*-  adds entries for recipients that have not been determined before
    IF NOT lt_alert_idx_insert[] IS INITIAL.
      INSERT /aif/alert_idx FROM TABLE lt_alert_idx_insert.
    ENDIF.
  ELSE.
*-  deletes entries for recipients that have not been determined again
    IF NOT lt_alert_idx_delete[] IS INITIAL.
      DELETE  /aif/alert_idx  CONNECTION (lo_db->mc_db_name) FROM TABLE lt_alert_idx_delete.
    ENDIF.
*-  updates existing entries
    IF NOT lt_alert_idx_update[] IS INITIAL.
      UPDATE  /aif/alert_idx  CONNECTION (lo_db->mc_db_name) FROM TABLE lt_alert_idx_update.
    ENDIF.
*-  adds entries for recipients that have not been determined before
    IF NOT lt_alert_idx_insert[] IS INITIAL.
      INSERT /aif/alert_idx  CONNECTION (lo_db->mc_db_name) FROM TABLE lt_alert_idx_insert.
    ENDIF.
    IF ( NOT lt_alert_idx_delete[] IS INITIAL OR NOT lt_alert_idx_update[] IS INITIAL OR NOT lt_alert_idx_insert[] IS INITIAL )
       AND lo_db->get_commit_state( ) NE lo_db->mc_no_commit.
      COMMIT CONNECTION (lo_db->mc_db_name).
    ENDIF.
  ENDIF.
ENDMETHOD.


METHOD update_errors.
  DATA: ls_log_message               TYPE bal_s_msg,
        ls_mmsg_idx                  TYPE /aif/t_mmsg_idx,
        lv_tabix                     TYPE sytabix,

        lt_kflds                     TYPE /aif/inf_sel_mflds_tt,
        ls_kfld                      TYPE /aif/t_inf_kflds,

        lr_ballog_exc                TYPE REF TO /aif/cx_bal_log_strategy,

        lr_dba_mgr                   TYPE REF TO /aif/cl_dba_reader_mgr,
        lr_dba_inf_kflds             TYPE REF TO /aif/if_dba_inf_kflds,
        ls_inf_kflds_out             TYPE /aif/t_inf_kflds,

        lr_index_table_buffer        TYPE REF TO /aif/if_index_table_buffer,
        lt_multi_index_table_entries TYPE /aif/index_table_entries_tt.

  FIELD-SYMBOLS: <ls_aifkeys>                   TYPE /aif/ifkeys,
                 <ls_aifadmin>                  TYPE /aif/admin,
                 <ls_pid>                       TYPE sxmspid,

                 <ls_mmsg_idx>                  TYPE /aif/t_mmsg_idx,

                 <ls_multi_index_table_entries> TYPE /aif/index_table_entries,
                 <ls_multi_index_table_entry>   TYPE any,
                 <lt_entries>                   TYPE ANY TABLE,
                 <ls_midx_admin>                TYPE /aif/admin.

  ASSIGN COMPONENT 'AIFKEYS' OF STRUCTURE cs_sidx_entry TO <ls_aifkeys>.
  ASSIGN COMPONENT 'ADMIN'   OF STRUCTURE cs_sidx_entry TO <ls_aifadmin>.
*
* get secondary database connector if avialable
  DATA(lo_db) = /aif/cl_db_control=>get_instance( ).

  " 1. (Re-)Initialize global variables and message counters
  IF gv_initial_call = 'X'.
    CLEAR: gt_log_messages,
           gt_mmsg_idx.

*  For performanace reasons first check if an entry exists already, only in this case
*  try to delete the entry
    DATA: lv_guid32_temp TYPE guid_32.
    IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
      SELECT SINGLE msgguid INTO lv_guid32_temp
      FROM /aif/t_mmsg_idx
      WHERE msgguid = gv_msgguid
      AND counter = 1.
      IF sy-subrc = 0.
        DELETE FROM /aif/t_mmsg_idx WHERE msgguid = gv_msgguid.
      ENDIF.
    ELSE.
      SELECT SINGLE msgguid CONNECTION (lo_db->mc_db_name)
        INTO lv_guid32_temp
        FROM /aif/t_mmsg_idx
        WHERE msgguid = gv_msgguid
          AND counter = 1.
      IF sy-subrc EQ 0.
        DELETE FROM /aif/t_mmsg_idx CONNECTION (lo_db->mc_db_name)
              WHERE msgguid = gv_msgguid.
        IF lo_db->get_commit_state( ) NE lo_db->mc_no_commit.
          COMMIT CONNECTION (lo_db->mc_db_name).
        ENDIF.
      ENDIF.

    ENDIF.

    <ls_aifadmin>-numberoferrors   = 0.
    <ls_aifadmin>-numberofaborts   = 0.
    <ls_aifadmin>-numberofwarnings = 0.
    <ls_aifadmin>-numberofinfos    = 0.
    <ls_aifadmin>-numberofsuccess  = 0.
  ENDIF.

* Begin Note 2910967
*   For outboud web service, always re-count the numbers based on the logs,
*   otherwise, the numbers will be cumulated for each restart
  ASSIGN COMPONENT 'PID' OF STRUCTURE cs_sidx_entry TO <ls_pid>.
  IF sy-subrc = 0 AND <ls_pid> = 'WS_SENDER'.
    <ls_aifadmin>-numberoferrors   = 0.
    <ls_aifadmin>-numberofaborts   = 0.
    <ls_aifadmin>-numberofwarnings = 0.
    <ls_aifadmin>-numberofinfos    = 0.
    <ls_aifadmin>-numberofsuccess  = 0.
  ENDIF.
* End Note 2910967

  " 2. Calculate message counters for single index table entry
  LOOP AT it_current_log_messages INTO ls_log_message.
    CASE ls_log_message-msgty.
      WHEN 'E'.
        ADD 1 TO <ls_aifadmin>-numberoferrors.
      WHEN 'A'.
        ADD 1 TO <ls_aifadmin>-numberofaborts.
      WHEN 'W'.
        ADD 1 TO <ls_aifadmin>-numberofwarnings.
      WHEN 'I'.
        ADD 1 TO <ls_aifadmin>-numberofinfos.
      WHEN 'S'.
        ADD 1 TO <ls_aifadmin>-numberofsuccess.
    ENDCASE.
  ENDLOOP.

  INSERT LINES OF it_current_log_messages INTO TABLE gt_log_messages.

  " 3. Update message count in document and multi index tables
  lr_dba_mgr = /aif/cl_dba_reader_mgr=>get_instance( ).
  lr_dba_inf_kflds = lr_dba_mgr->get_dba_inf_kflds( ).

  ls_inf_kflds_out-ns = gs_finf-ns.
  ls_inf_kflds_out-ifname = gs_finf-ifname.
  ls_inf_kflds_out-ifver = gs_finf-ifversion.

  TRY.
      lt_kflds = lr_dba_inf_kflds->read_table( is_key = ls_inf_kflds_out ).

    CATCH /aif/cx_dba_reader.
      CLEAR lt_kflds.
  ENDTRY.

  DELETE lt_kflds WHERE is_multi <> ''. " Only leave multi index keyfields

  ls_kfld-idx_table = '/AIF/DOCU_ID_IDX'.
  MODIFY lt_kflds FROM ls_kfld TRANSPORTING idx_table WHERE is_multi = 'D'.

  SORT lt_kflds BY idx_table.
  DELETE ADJACENT DUPLICATES FROM lt_kflds COMPARING idx_table.

  lr_index_table_buffer = mo_selection_engine->get_index_table_buffer_for_msg( iv_ns        = me->gs_finf-ns
                                                                    iv_ifname    = me->gs_finf-ifname
                                                                    iv_ifversion = me->gs_finf-ifversion
                                                                    iv_msgguid   = me->gv_msgguid ).
  lt_multi_index_table_entries = lr_index_table_buffer->get_buffered_multi_idx_entries( ).

  LOOP AT lt_multi_index_table_entries ASSIGNING <ls_multi_index_table_entries>.

    ASSIGN <ls_multi_index_table_entries>-idx_tab_entries->* TO <lt_entries>.
    LOOP AT <lt_entries> ASSIGNING <ls_multi_index_table_entry>.
      ASSIGN COMPONENT 'ADMIN' OF STRUCTURE <ls_multi_index_table_entry> TO <ls_midx_admin>.
      <ls_midx_admin>-numberofaborts    = <ls_aifadmin>-numberofaborts.
      <ls_midx_admin>-numberoferrors    = <ls_aifadmin>-numberoferrors.
      <ls_midx_admin>-numberofwarnings  = <ls_aifadmin>-numberofwarnings.
      <ls_midx_admin>-numberofsuccess   = <ls_aifadmin>-numberofsuccess.
      <ls_midx_admin>-numberofinfos     = <ls_aifadmin>-numberofinfos.
      <ls_midx_admin>-status            = <ls_aifadmin>-status.
      "Sub-status of In-Process status for XML&STRU Engine begin
      ASSIGN COMPONENT /aif/if_globals=>gc_eh_fix_key_flds-sub_status OF STRUCTURE <ls_aifadmin> TO FIELD-SYMBOL(<fs_sub_status1>).
      ASSIGN COMPONENT /aif/if_globals=>gc_eh_fix_key_flds-sub_status OF STRUCTURE <ls_midx_admin> TO FIELD-SYMBOL(<fs_sub_status2>).
      IF sy-subrc = 0 AND <fs_sub_status1> IS ASSIGNED AND <fs_sub_status2> IS ASSIGNED.
        <fs_sub_status2> = <fs_sub_status1>.
      ENDIF.
      "Sub-status of In-Process status for XML&STRU Engine end
      <ls_midx_admin>-aif_location      = <ls_aifadmin>-aif_location.
      <ls_midx_admin>-lognumber         = <ls_aifadmin>-lognumber.
      <ls_midx_admin>-trace_level       = <ls_aifadmin>-trace_level.
      <ls_midx_admin>-tl_exp_date       = <ls_aifadmin>-tl_exp_date.
      <ls_midx_admin>-tl_exp_time       = <ls_aifadmin>-tl_exp_time.
      <ls_midx_admin>-create_user       = <ls_aifadmin>-create_user.
      <ls_midx_admin>-create_date       = <ls_aifadmin>-create_date.
      <ls_midx_admin>-create_time       = <ls_aifadmin>-create_time.
      <ls_midx_admin>-last_user         = <ls_aifadmin>-last_user.
      <ls_midx_admin>-last_date         = <ls_aifadmin>-last_date.
      <ls_midx_admin>-last_time         = <ls_aifadmin>-last_time.
      <ls_midx_admin>-end_user          = <ls_aifadmin>-end_user.
      <ls_midx_admin>-end_date          = <ls_aifadmin>-end_date.
      <ls_midx_admin>-end_time          = <ls_aifadmin>-end_time.
      <ls_midx_admin>-aif_alert_id      = <ls_aifadmin>-aif_alert_id.
    ENDLOOP.

    lr_index_table_buffer->set_multi_idx_entries( iv_tabname = <ls_multi_index_table_entries>-idx_tab_name
                                                  it_idx_tab_entries = <lt_entries> ).

  ENDLOOP.

  lr_index_table_buffer->save( EXCEPTIONS invalid_msgguid = 1
                                          saving_single_idx_entry_failed = 2
                                          saving_multi_idx_entry_failed = 3 ).

  IF sy-subrc > 1.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base.
  ENDIF.

  " 4. Now write message index information, but only if E or A messages exist and return messages is not empty
  "    Otherwise, index information is not stored. This is in compliance with the original implementation in the AIF runtime.
  IF ( <ls_aifadmin>-numberoferrors > 0 OR <ls_aifadmin>-numberofaborts > 0 ) AND NOT it_current_log_messages IS INITIAL.

    ls_mmsg_idx-aifkeys = <ls_aifkeys>.
    ls_mmsg_idx-admin   = <ls_aifadmin>.
    ls_mmsg_idx-msgguid = gv_msgguid.

    lv_tabix = lines( gt_mmsg_idx ).  " TODO: get maximum number of counter instead?
    LOOP AT it_current_log_messages INTO ls_log_message.
      READ TABLE gt_mmsg_idx ASSIGNING <ls_mmsg_idx> WITH KEY
        msgty = ls_log_message-msgty
        msgid = ls_log_message-msgid
        msgno = ls_log_message-msgno.
      IF sy-subrc IS INITIAL.  " entry already existed
        ADD 1 TO <ls_mmsg_idx>-msgcount.
      ELSE.
        ADD 1 TO lv_tabix.
        ls_mmsg_idx-counter  = lv_tabix.
        ls_mmsg_idx-msgty    = ls_log_message-msgty.
        ls_mmsg_idx-msgid    = ls_log_message-msgid.
        ls_mmsg_idx-msgno    = ls_log_message-msgno.
        ls_mmsg_idx-msgcount = 1.
        APPEND ls_mmsg_idx TO gt_mmsg_idx.
      ENDIF.
    ENDLOOP.
    IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
      MODIFY /aif/t_mmsg_idx FROM TABLE gt_mmsg_idx.
    ELSE.
      MODIFY /aif/t_mmsg_idx CONNECTION (lo_db->mc_db_name) FROM TABLE me->gt_mmsg_idx.
      IF lo_db->get_commit_state( ) NE lo_db->mc_no_commit.
        COMMIT CONNECTION (lo_db->mc_db_name).
      ENDIF.
    ENDIF.
  ENDIF.

  DATA: lv_function TYPE rs38l-name VALUE '/AIF/UPD_MMSG_VARS'.
* Update MultiMessage Variables Table /AIF/MMSG_VARS
  CALL FUNCTION 'FUNCTION_EXISTS'
    EXPORTING
      funcname           = lv_function
    EXCEPTIONS
      function_not_exist = 1
      OTHERS             = 2.
  IF sy-subrc = 0.
    CALL FUNCTION lv_function
      EXPORTING
        iv_msgguid      = gv_msgguid
        is_aif_keys     = <ls_aifkeys>
        is_aif_admin    = <ls_aifadmin>
        it_log_messages = it_current_log_messages.
  ENDIF.

  " 5. Update application log
  TRY .
      gr_log_strategy->add_bal_messages( it_current_log_messages ).
    CATCH /aif/cx_bal_log_strategy INTO lr_ballog_exc.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_ballog_exc.
  ENDTRY.
ENDMETHOD.


METHOD update_keyfields.
  DATA: lt_kflds              TYPE /aif/inf_sel_mflds_tt,
        lt_mkflds             TYPE /aif/inf_sel_mflds_tt,
        lt_temp_mkflds        TYPE /aif/inf_sel_mflds_tt,
        ls_kflds              TYPE /aif/t_inf_kflds,

        lv_fieldvalue         TYPE string,

        lr_midx_entry         TYPE REF TO data,
        lr_entries            TYPE REF TO data,
        lr_mul_key_type       TYPE REF TO data,
        lr_cx_not_a_table     TYPE REF TO cx_abap_not_a_table,
        lv_inb_or_outb        TYPE /aif/inb_outb_flag,

        lv_counter_docid      TYPE int4,
        lv_docu_deleted       TYPE boolean,
        lv_guid32_temp        TYPE guid_32,

        lo_index_table_buffer TYPE REF TO /aif/if_index_table_buffer,
        lr_dba_mgr            TYPE REF TO /aif/cl_dba_reader_mgr,
        lr_dba_inf_kflds      TYPE REF TO /aif/if_dba_inf_kflds,
        ls_inf_kflds_out      TYPE /aif/t_inf_kflds.

  FIELD-SYMBOLS: <ls_kflds>        TYPE /aif/t_inf_kflds,

                 <ls_midx_entry>   TYPE any,

                 <ls_sidx_ifkeys>  TYPE /aif/ifkeys,
                 <ls_midx_ifkeys>  TYPE /aif/ifkeys,
                 <ls_sidx_admin>   TYPE /aif/admin,
                 <ls_midx_admin>   TYPE /aif/admin,
                 <lv_sidx_msgguid> TYPE guid_32,
                 <lv_midx_msgguid> TYPE guid_32,

                 <ls_linedata>     TYPE any,
                 <lv_idx_field>    TYPE any,
                 <lt_fieldvalues>  TYPE table,
                 <lv_fieldvalue>   TYPE any,
                 <lv_fieldname>    TYPE any,
                 <lv_counter>      TYPE int4.

  DATA lr_keyfld_data TYPE REF TO data.
* get index table buffer
  lo_index_table_buffer = mo_selection_engine->get_index_table_buffer_for_msg( iv_ns        = me->gs_finf-ns
                                                                               iv_ifname    = me->gs_finf-ifname
                                                                               iv_ifversion = me->gs_finf-ifversion
                                                                               iv_msgguid   = me->gv_msgguid ).

* get keyfield access object
  lr_dba_mgr = /aif/cl_dba_reader_mgr=>get_instance( ).
  lr_dba_inf_kflds = lr_dba_mgr->get_dba_inf_kflds( ).

*  secondary database connection decission instance
  DATA(lo_db) = /aif/cl_db_control=>get_instance( ).

  lv_inb_or_outb = me->determine_inb_outb( ).

  " prepare values from single index table for copying into multi/document index tables

  ASSIGN COMPONENT 'AIFKEYS' OF STRUCTURE cs_sidx_entry TO <ls_sidx_ifkeys>.
  IF sy-subrc IS INITIAL.
    ASSIGN COMPONENT 'ADMIN'   OF STRUCTURE cs_sidx_entry TO <ls_sidx_admin>.
  ENDIF.
  IF sy-subrc IS INITIAL.
    ASSIGN COMPONENT 'MSGGUID' OF STRUCTURE cs_sidx_entry TO <lv_sidx_msgguid>.
  ENDIF.
  IF NOT sy-subrc IS INITIAL.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING
        textid = /aif/cx_enabler_base=>sidx_structure_wrong.
  ENDIF.

  ls_inf_kflds_out-ns = me->gs_finf-ns.
  ls_inf_kflds_out-ifname = me->gs_finf-ifname.
  ls_inf_kflds_out-ifver = me->gs_finf-ifversion.

  TRY .
      lt_kflds = lr_dba_inf_kflds->read_table( is_key = ls_inf_kflds_out ).

    CATCH /aif/cx_dba_reader.
      CLEAR lt_kflds.
  ENDTRY.

  " not all keyfield types have an index table assigned -> assign it based on keyfield type: single or document
  ls_kflds-idx_table = gv_sidx.
  MODIFY lt_kflds FROM ls_kflds TRANSPORTING idx_table WHERE is_multi = ''.
  ls_kflds-idx_table = '/AIF/DOCU_ID_IDX'.
  MODIFY lt_kflds FROM ls_kflds TRANSPORTING idx_table WHERE is_multi = 'D'.

  SORT lt_kflds BY is_multi idx_table.  " improves efficiency of the coming loop

  CLEAR: lv_docu_deleted, lv_counter_docid.
  LOOP AT lt_kflds ASSIGNING <ls_kflds>.
    CLEAR: lv_fieldvalue.

    " skip this keyfield if the corresponding structure is not supplied
*    IF ( <ls_kflds>-raw_or_sap = 'S'      AND lv_inb_or_outb = 'I' ) OR " S = destination structure; S + I    -> SAP structure
*       ( <ls_kflds>-raw_or_sap IS INITIAL AND lv_inb_or_outb = 'O' ).   " blank = source structure; blank + O -> SAP structure
*      CHECK is_sap_structure IS SUPPLIED AND NOT is_sap_structure IS INITIAL.
*      ASSIGN is_sap_structure TO <ls_linedata>.
*    ELSEIF ( <ls_kflds>-raw_or_sap IS INITIAL AND lv_inb_or_outb = 'I' ) OR  " S = destination structure; S + I    -> SAP structure
*           ( <ls_kflds>-raw_or_sap = 'S'      AND lv_inb_or_outb = 'O' ).
*      CHECK is_raw_structure IS SUPPLIED AND NOT is_raw_structure IS INITIAL.
*      ASSIGN is_raw_structure TO <ls_linedata>.
*    ENDIF.

    CLEAR lr_keyfld_data.
    lr_keyfld_data = get_key_field_data_ref( is_raw_structure = is_raw_structure
                                             is_sap_structure = is_sap_structure
                                             iv_inb_or_outb   = lv_inb_or_outb
                                             is_kflds         = <ls_kflds> ).
    UNASSIGN <ls_linedata>.
    IF lr_keyfld_data IS BOUND.
      ASSIGN lr_keyfld_data->* TO <ls_linedata> .
    ENDIF.
    CHECK <ls_linedata> IS ASSIGNED.
    CHECK NOT <ls_linedata> IS INITIAL.

* update the additional info like administrative data( document, multi selection)
    IF <ls_kflds>-is_multi <> ''.
      CREATE DATA lr_midx_entry TYPE (<ls_kflds>-idx_table).
      ASSIGN lr_midx_entry->* TO <ls_midx_entry>.
      ASSERT sy-subrc = 0.

      IF sy-subrc = 0.
        ASSIGN lr_midx_entry->('AIFKEYS') TO <ls_midx_ifkeys>.
      ENDIF.
      IF sy-subrc = 0.
        ASSIGN lr_midx_entry->('ADMIN')   TO <ls_midx_admin>.
      ENDIF.
      IF sy-subrc = 0.
        ASSIGN lr_midx_entry->('MSGGUID') TO <lv_midx_msgguid>.
      ENDIF.
      IF sy-subrc = 0.
        <ls_midx_ifkeys>  = <ls_sidx_ifkeys>.
        <ls_midx_admin>   = <ls_sidx_admin>.
        <lv_midx_msgguid> = <lv_sidx_msgguid>.
      ENDIF.
    ENDIF.

    CASE <ls_kflds>-is_multi.
      WHEN ' '.  " single search
        CALL FUNCTION '/AIF/UTIL_READ_DATA'
          EXPORTING
            data              = <ls_linedata>
            path              = <ls_kflds>-aif_fieldname
            ns                = gs_finf-ns
            ifname            = gs_finf-ifname
            ifversion         = gs_finf-ifversion
          IMPORTING
            result            = lv_fieldvalue
          EXCEPTIONS
            element_not_found = 1
            empty_table       = 2
            error_occurs      = 3
            OTHERS            = 4.
        IF sy-subrc <> 0.
          CLEAR: lv_fieldvalue.
        ENDIF.

*       IF lv_fieldvalue IS NOT INITIAL.

        ASSIGN COMPONENT <ls_kflds>-fieldname OF STRUCTURE cs_sidx_entry TO <lv_idx_field>.
        IF sy-subrc = 0.
          <lv_idx_field> = lv_fieldvalue.
        ENDIF.
*       ENDIF.

      WHEN 'D'.   "documentid search
        " delete old entries, but only for fields from raw structure!
        IF lv_docu_deleted IS INITIAL.
*        For performanace reasons first check if an entry exists already, only in this case
*        try to delete the entry
          TRY.
              <ls_kflds>-idx_table = cl_abap_dyn_prg=>check_table_name_str(
                                          val      = <ls_kflds>-idx_table
                                          packages = '' ).
            CATCH cx_abap_not_a_table INTO lr_cx_not_a_table.
              RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_cx_not_a_table.
            CATCH cx_abap_not_in_package.
          ENDTRY.
* check if secondary database connection is active or not
          IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
            SELECT SINGLE msgguid INTO lv_guid32_temp
            FROM (<ls_kflds>-idx_table)
            WHERE msgguid = <lv_sidx_msgguid>
            AND counter = 1.
            IF  sy-subrc = 0.
              DELETE FROM (<ls_kflds>-idx_table) WHERE msgguid = <lv_sidx_msgguid>.
            ENDIF.
          ELSE.
            SELECT SINGLE msgguid CONNECTION (lo_db->mc_db_name)
              INTO lv_guid32_temp
              FROM (<ls_kflds>-idx_table)
              WHERE msgguid = <lv_sidx_msgguid>
                AND counter = 1.
            IF sy-subrc EQ 0.
              DELETE FROM (<ls_kflds>-idx_table) CONNECTION (lo_db->mc_db_name)
               WHERE msgguid = <lv_sidx_msgguid>.
              IF lo_db->get_commit_state( ) NE lo_db->mc_no_commit.
                COMMIT CONNECTION (lo_db->mc_db_name).
              ENDIF.
            ENDIF.
          ENDIF.
          lv_docu_deleted = 'X'.
        ENDIF.

        REFRESH: lt_mkflds.
        APPEND <ls_kflds> TO lt_mkflds.

*get the new entries
        CLEAR lr_entries.
        CLEAR lr_mul_key_type.
        CALL FUNCTION '/AIF/UTIL_READ_MDATA'
          EXPORTING
            linedata          = <ls_linedata>
            kflds_list        = lt_mkflds
            table_line        = <ls_linedata>
            search_type       = 'D'
          CHANGING
            cs_current_data   = <ls_midx_entry>
            cref_mentries     = lr_entries
            cref_mul_key_type = lr_mul_key_type
          EXCEPTIONS
            element_not_found = 1
            error_occurs      = 2
            OTHERS            = 3.
        IF sy-subrc <> 0.
          CLEAR lr_entries.
          CLEAR lr_mul_key_type.
        ENDIF.

*insert the new entries
        ASSIGN lr_entries->* TO <lt_fieldvalues>.
        IF sy-subrc = 0.
          IF <lt_fieldvalues> IS NOT INITIAL.
            SORT <lt_fieldvalues>.
            DELETE ADJACENT DUPLICATES FROM <lt_fieldvalues>.
            LOOP AT <lt_fieldvalues> ASSIGNING <lv_fieldvalue>. "#EC CI_NESTED
              IF <lv_fieldvalue> IS NOT INITIAL.
                ASSIGN COMPONENT 'FIELDNAME' OF STRUCTURE <lv_fieldvalue> TO <lv_fieldname>.
                IF sy-subrc = 0.
                  <lv_fieldname> = <ls_kflds>-fieldname.
                ENDIF.
*assign counter
                lv_counter_docid = lv_counter_docid + 1.
                ASSIGN COMPONENT 'COUNTER' OF STRUCTURE <lv_fieldvalue> TO <lv_counter>.
                CHECK sy-subrc = 0.
                <lv_counter> = lv_counter_docid.
              ENDIF.
            ENDLOOP.
*update db
            IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
              INSERT /aif/docu_id_idx FROM TABLE <lt_fieldvalues>.
            ELSE.
              INSERT /aif/docu_id_idx  CONNECTION (lo_db->mc_db_name) FROM TABLE <lt_fieldvalues>.
              IF lo_db->get_commit_state( ) NE lo_db->mc_no_commit.
                COMMIT CONNECTION (lo_db->mc_db_name) .
              ENDIF.
            ENDIF.
          ENDIF.
          UNASSIGN <lt_fieldvalues>.
        ENDIF.

      WHEN 'M'.    " multiple search
        REFRESH lt_mkflds.
*collect all mkflds belonging to same idx table
        LOOP AT lt_kflds INTO ls_kflds WHERE idx_table = <ls_kflds>-idx_table.
          DELETE TABLE lt_kflds FROM ls_kflds.
          APPEND ls_kflds TO lt_mkflds.
        ENDLOOP.
        DELETE lt_mkflds WHERE aif_fieldname IS INITIAL.

        CLEAR lt_temp_mkflds.
        lt_temp_mkflds[] = lt_mkflds.
        CALL FUNCTION '/AIF/CHECK_MIDXTBL_VALID'
          EXPORTING
            is_linedata              = <ls_linedata>
            it_mkflds                = lt_temp_mkflds
          IMPORTING
            et_mkflds                = lt_mkflds
          EXCEPTIONS
            not_linear_in_indextable = 1
            error_occurs             = 2
            OTHERS                   = 3.

*get the new entries
        IF sy-subrc IS INITIAL.
          CLEAR lr_entries.
          CLEAR lr_mul_key_type.
          CALL FUNCTION '/AIF/UTIL_READ_MDATA'
            EXPORTING
              linedata          = <ls_linedata>
              kflds_list        = lt_mkflds
              table_line        = <ls_linedata>
              search_type       = 'M'
            CHANGING
              cs_current_data   = <ls_midx_entry>
              cref_mentries     = lr_entries
              cref_mul_key_type = lr_mul_key_type
            EXCEPTIONS
              element_not_found = 1
              error_occurs      = 2
              OTHERS            = 3.
          IF sy-subrc <> 0.
            CLEAR lr_entries.
            CLEAR lr_mul_key_type.
          ENDIF.
*update counter and db
          ASSIGN lr_entries->* TO <lt_fieldvalues>.
          IF sy-subrc = 0.
            SORT <lt_fieldvalues>.
            DELETE ADJACENT DUPLICATES FROM <lt_fieldvalues>.
            IF <lt_fieldvalues> IS NOT INITIAL.
              LOOP AT <lt_fieldvalues> ASSIGNING <lv_fieldvalue>. "#EC CI_NESTED
                ASSIGN COMPONENT 'MSGGUID' OF STRUCTURE <lv_fieldvalue> TO <lv_midx_msgguid>.
                CHECK <lv_midx_msgguid> IS NOT INITIAL.
                ASSIGN COMPONENT 'COUNTER' OF STRUCTURE <lv_fieldvalue> TO <lv_counter>.
                IF sy-subrc = 0.
                  <lv_counter> = sy-tabix.
                ENDIF.
              ENDLOOP.
              READ TABLE lt_mkflds INTO ls_kflds INDEX 1.
              CHECK sy-subrc = 0 AND ls_kflds-idx_table IS NOT INITIAL.

              lo_index_table_buffer->set_multi_idx_entries( iv_tabname = ls_kflds-idx_table
                                                            it_idx_tab_entries = <lt_fieldvalues> ).

            ENDIF.
            UNASSIGN <lt_fieldvalues>.
          ENDIF.
        ENDIF.
      WHEN OTHERS.
    ENDCASE.
  ENDLOOP.

* Save keyfields
  lo_index_table_buffer->save( EXCEPTIONS invalid_msgguid = 1
                                          saving_single_idx_entry_failed = 2
                                          saving_multi_idx_entry_failed = 3 ).

  IF sy-subrc > 1.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base.
  ENDIF.

* key field rule
  LOOP AT lt_kflds ASSIGNING <ls_kflds> WHERE is_multi = space
                                          AND is_enh_kfld = 'X'.
* field is for single selection and marked as enhanced

    CALL METHOD me->run_key_field_rule
      EXPORTING
        is_raw_structure = is_raw_structure
        is_sap_structure = is_sap_structure
        is_kflds         = <ls_kflds>
      CHANGING
        cs_sidx_entry    = cs_sidx_entry.

  ENDLOOP.

ENDMETHOD.


METHOD update_msgguid.
  DATA: lv_old_msgguid    TYPE guid_32,
        lt_midx_tbls      TYPE STANDARD TABLE OF /aif/msg_tbl,
        ls_midx_tbl       TYPE /aif/msg_tbl,
        lv_max_recip_nr   TYPE /aif/recipientnr,
        lv_balextno_cast  TYPE balnrext,

        lr_cx_not_a_table TYPE REF TO cx_abap_not_a_table,
        lr_ballog_exc     TYPE REF TO /aif/cx_bal_log_strategy,

        lr_dba_mgr        TYPE REF TO /aif/cl_dba_reader_mgr,
        lr_dba_inf_kflds  TYPE REF TO /aif/if_dba_inf_kflds,
        ls_inf_kflds_out  TYPE /aif/t_inf_kflds,
        lt_inf_keyfields  TYPE /aif/tt_inf_kflds,
        ls_inf_keyfield   TYPE /aif/t_inf_kflds,
        lr_exception      TYPE REF TO /aif/cx_dba_reader.

  " plausability check
  CHECK: NOT iv_new_msgguid IS INITIAL,
         NOT iv_new_msgguid = gv_msgguid.

  lv_old_msgguid = gv_msgguid.
  gv_msgguid     = iv_new_msgguid.

* secondary database connection
  DATA(lo_db) = /aif/cl_db_control=>get_instance( ).

  " update single index table
  TRY.
      gv_sidx = cl_abap_dyn_prg=>check_table_name_str(
                                  val      = gv_sidx
                                  packages = '' ).
    CATCH cx_abap_not_a_table INTO lr_cx_not_a_table.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_cx_not_a_table.
    CATCH cx_abap_not_in_package.
  ENDTRY.
  IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
    UPDATE (gv_sidx) SET msgguid = gv_msgguid WHERE msgguid = lv_old_msgguid.
  ELSE.
    UPDATE (me->gv_sidx) CONNECTION (lo_db->mc_db_name)
       SET msgguid = me->gv_msgguid
     WHERE msgguid = lv_old_msgguid.
  ENDIF.

  " update document index table
  IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
    UPDATE /aif/docu_id_idx SET msgguid = gv_msgguid WHERE msgguid = lv_old_msgguid.
  ELSE.
    UPDATE /aif/docu_id_idx CONNECTION (lo_db->mc_db_name)
       SET msgguid = me->gv_msgguid
     WHERE msgguid = lv_old_msgguid.
  ENDIF.

  " determine multi index tables
  lr_dba_mgr = /aif/cl_dba_reader_mgr=>get_instance( ).
  lr_dba_inf_kflds = lr_dba_mgr->get_dba_inf_kflds( ).

  ls_inf_kflds_out-ns = me->gs_finf-ns.
  ls_inf_kflds_out-ifname = me->gs_finf-ifname.
  ls_inf_kflds_out-ifver = me->gs_finf-ifversion.

  TRY.
      lt_inf_keyfields = lr_dba_inf_kflds->read_table( is_key = ls_inf_kflds_out ).

    CATCH /aif/cx_dba_reader.
      CLEAR lt_inf_keyfields.
  ENDTRY.

  LOOP AT lt_inf_keyfields INTO ls_inf_keyfield.
    IF ls_inf_keyfield-idx_table IS NOT INITIAL.
      READ TABLE lt_midx_tbls WITH KEY table_line = ls_inf_keyfield-idx_table TRANSPORTING NO FIELDS.
      IF sy-subrc > 0.
        APPEND ls_inf_keyfield-idx_table TO lt_midx_tbls.
      ENDIF.
    ENDIF.
  ENDLOOP.

  " udpate multi index tables
  LOOP AT lt_midx_tbls INTO ls_midx_tbl.
    TRY.
        ls_midx_tbl = cl_abap_dyn_prg=>check_table_name_str(
                                    val      = ls_midx_tbl
                                    packages = '' ).
      CATCH cx_abap_not_a_table INTO lr_cx_not_a_table.
        RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_cx_not_a_table.
      CATCH cx_abap_not_in_package.
    ENDTRY.
    IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
      UPDATE (ls_midx_tbl) SET msgguid = gv_msgguid WHERE msgguid = lv_old_msgguid.
    ELSE.
      UPDATE (ls_midx_tbl) CONNECTION (lo_db->mc_db_name)
         SET msgguid = me->gv_msgguid
       WHERE msgguid = lv_old_msgguid.
    ENDIF.
  ENDLOOP.

  IF lo_db->is_2nd_active( ) EQ lo_db->mc_false.
* update multi message index table
    UPDATE /aif/t_mmsg_idx SET msgguid = gv_msgguid WHERE msgguid = lv_old_msgguid.
* alert index table
*   outbound-inbound, should add max recipintnr to avoid duplicate key
    SELECT MAX( recipientnr ) INTO @lv_max_recip_nr FROM /aif/alert_idx WHERE msgguid = @gv_msgguid.
    IF sy-subrc = 0 AND lv_max_recip_nr > 0.
      UPDATE /aif/alert_idx SET msgguid = @gv_msgguid, recipientnr = recipientnr + @lv_max_recip_nr WHERE msgguid = @lv_old_msgguid.
    ELSE.
      UPDATE /aif/alert_idx SET msgguid = gv_msgguid WHERE msgguid = lv_old_msgguid.
    ENDIF.
  ELSE.
* update multi message index table
    UPDATE /aif/t_mmsg_idx CONNECTION (lo_db->mc_db_name)
       SET msgguid = me->gv_msgguid
     WHERE msgguid = lv_old_msgguid.
* alert index table
    SELECT MAX( recipientnr ) CONNECTION (lo_db->mc_db_name) INTO @lv_max_recip_nr FROM /aif/alert_idx WHERE msgguid = @gv_msgguid.
    IF sy-subrc = 0 AND lv_max_recip_nr > 0.
      UPDATE /aif/alert_idx CONNECTION (lo_db->mc_db_name) SET msgguid = @gv_msgguid, recipientnr = recipientnr + @lv_max_recip_nr WHERE msgguid = @lv_old_msgguid.
    ELSE.
      UPDATE /aif/alert_idx CONNECTION (lo_db->mc_db_name) SET msgguid = gv_msgguid WHERE msgguid = lv_old_msgguid.
    ENDIF.
  ENDIF.

* trigger a commit statement if requested
  IF lo_db->get_commit_state( ) NE lo_db->mc_no_commit.
    COMMIT CONNECTION (lo_db->mc_db_name) .
  ENDIF.

  " update application log
  TRY .
      lv_balextno_cast = gv_msgguid.
      gr_log_strategy->update_extid( lv_balextno_cast ).
    CATCH /aif/cx_bal_log_strategy INTO lr_ballog_exc.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_ballog_exc.
  ENDTRY.
ENDMETHOD.


METHOD update_msg_stat.
  DATA: lv_update_mode               TYPE char01,
        lv_locked                    TYPE boolean VALUE '',

        lr_temp_sidx_entry           TYPE REF TO data,
        lr_temp_sidx_old_entry       TYPE REF TO data,

        lr_msg_stat_exc              TYPE REF TO /aif/cx_message_statistics.
  FIELD-SYMBOLS: <ls_sidx_entry>     TYPE ANY,
                 <ls_sidx_old_entry> TYPE ANY.
* for HANA DB,
  CHECK sy-dbsys <> /aif/if_globals=>gc_hdb_sys.
  " require either new or old index entry:
  "   Scenario 1: new and old entry supplied -> update of statistics
  "   Scenario 2: only new entry supplied    -> initial creation (new statistics entry)
  "   Scenario 3: only old entry supplied    -> message deletion
  CHECK is_sidx_entry IS SUPPLIED OR is_sidx_old_entry IS SUPPLIED.

  IF NOT is_sidx_entry IS SUPPLIED.
    CREATE DATA lr_temp_sidx_entry TYPE (gv_sidx).
    ASSIGN lr_temp_sidx_entry->* TO <ls_sidx_entry>.
  ELSE.
    ASSIGN is_sidx_entry TO <ls_sidx_entry>.
  ENDIF.

  IF NOT <ls_sidx_entry> IS ASSIGNED.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING
        textid       = /aif/cx_enabler_base=>field_assignment_failed
        fld_sym_name = '<ls_sidx_entry>'
        data_type    = gv_sidx.
  ENDIF.

  IF NOT is_sidx_old_entry IS SUPPLIED.
    CREATE DATA lr_temp_sidx_old_entry TYPE (gv_sidx).
    ASSIGN lr_temp_sidx_old_entry->* TO <ls_sidx_old_entry>.
  ELSE.
    ASSIGN is_sidx_old_entry TO <ls_sidx_old_entry>.
  ENDIF.

  IF NOT <ls_sidx_old_entry> IS ASSIGNED.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING
        textid       = /aif/cx_enabler_base=>field_assignment_failed
        fld_sym_name = '<ls_sidx_old_entry>'
        data_type    = gv_sidx.
  ENDIF.

  " set initial rec-type for statistics update - will be overwritten based on scenario
  lv_update_mode = /aif/if_globals=>gc_rec_type-rec_type_6. " update msg status (e.g. restart or cancel)

  IF gv_initial_call = 'X'.
    IF iv_is_reprocess = 'X'. " restart or cancel
      lv_update_mode = /aif/if_globals=>gc_rec_type-rec_type_6.
    ELSE.                           " initial creation
      lv_update_mode = /aif/if_globals=>gc_rec_type-rec_type_1.
    ENDIF.
  ELSE. " enabler was called before -> former recipients can be determined from buffer
    IF it_recipients IS SUPPLIED AND NOT it_recipients IS INITIAL.
      " - from buffer / + from it_recipients
      lv_update_mode = /aif/if_globals=>gc_rec_type-rec_type_5.
    ELSE.
      " - from buffer / + redetermine
      lv_update_mode = /aif/if_globals=>gc_rec_type-rec_type_7.
    ENDIF.
  ENDIF.

  WHILE lv_locked IS INITIAL.
    CALL FUNCTION 'ENQUEUE_/AIF/MSG_STAT'
      EXPORTING
* change TE: allow parallel processing
*        mode_/aif/msg_stat = 'E'        " exclusive lock; AIF runtime report wait, also other instances of this report
        mode_/aif/msg_stat = 'S'        " exclusive lock; AIF runtime report wait, also other instances of this report
        _scope             = 1          " don't inherit to update task
        ns                 = gs_finf-ns
        ifname             = gs_finf-ifname
        ifver              = gs_finf-ifversion
        x_ns               = 'X'
        x_ifname           = 'X'
        x_ifver            = 'X'
      EXCEPTIONS
        foreign_lock       = 1
        system_failure     = 2
        OTHERS             = 3.
    IF sy-subrc = 0.
      lv_locked = 'X'.
    ELSEIF sy-subrc = 1.
      WAIT UP TO 1 SECONDS.
    ELSEIF sy-subrc = 2 OR sy-subrc = 3.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base
        EXPORTING
          textid    = /aif/cx_enabler_base=>enqueue_failed
          data_type = '/AIF/MSG_STAT'.
    ENDIF.
  ENDWHILE.

  TRY .
      /aif/cl_aif_msg_statistic_pro=>update_msg_statistic(
        iv_msgguid        = gv_msgguid
        is_idx_entry_new  = <ls_sidx_entry>
        is_idx_entry_old  = <ls_sidx_old_entry>
        iv_idx_tbl        = gv_sidx
        iv_flag_recp_type = lv_update_mode
        iv_action         = '' " unknown
        it_recipients     = it_recipients
        iv_persist        = 'X'
      ).
    CATCH /aif/cx_message_statistics INTO lr_msg_stat_exc.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base
        EXPORTING
          previous = lr_msg_stat_exc.
  ENDTRY.

  CALL FUNCTION 'DEQUEUE_/AIF/MSG_STAT'
    EXPORTING
* change TE: allow parallel processing
*      mode_/aif/msg_stat = 'E'
      mode_/aif/msg_stat = 'S'
      ns                 = gs_finf-ns
      ifname             = gs_finf-ifname
      ifver              = gs_finf-ifversion
      x_ns               = 'X'
      x_ifname           = 'X'
      x_ifver            = 'X'.
ENDMETHOD.


METHOD /aif/if_enabler_base~update.
  DATA: lr_sidx_entry           TYPE REF TO data,
        lr_sidx_old_entry       TYPE REF TO data,

        lv_is_restart           TYPE boolean VALUE '',

        lt_recipients           TYPE /aif/recipient_tt,
        lt_current_log_messages TYPE /aif/bal_t_msg,
        ls_temp_log_message     TYPE bal_s_msg,

        lr_ballog_exc           TYPE REF TO /aif/cx_bal_log_strategy.

  DATA: lt_all_log_messages TYPE /aif/bal_t_msg,
        lv_alert_id         TYPE salrtextid.
  DATA: lr_temp_raw            TYPE REF TO data.
  FIELD-SYMBOLS: <ls_raw>            TYPE any,

                 <ls_sidx_entry>     TYPE any,
                 <ls_sidx_old_entry> TYPE any,

                 <lv_msgguid>        TYPE guid_32,
                 <lv_pid>            TYPE sxmspid,
                 <lv_logical_port>   TYPE any,
                 <ls_aifkeys>        TYPE /aif/ifkeys,
                 <ls_aifadmin>       TYPE /aif/admin,
                 <ls_aifadmin_old>   TYPE /aif/admin.

* deactivate inbound agent for interfaces which are already using AIF Enabler
  /aif/cl_proxy_inbound_agent=>deactivate_implicite_enabler(
                  EXPORTING
                   iv_msgguid = CONV sxmsmguid( gv_msgguid )
                   iv_ns      = gs_finf-ns
                   iv_ifname  = gs_finf-ifname
                   iv_version = gs_finf-ifversion
                   ).

* secondary database connection setup
  DATA(lo_db) = /aif/cl_db_control=>get_instance( ).
  IF lo_db->is_2nd_active( ) EQ abap_true.
    IF iv_do_commit EQ abap_true.
      lo_db->set_commit_state( lo_db->mc_commit ).
    ELSE.
      lo_db->set_commit_state( lo_db->mc_no_commit ).
    ENDIF.
  ENDIF.

  IF NOT gv_initial_call = 'X' AND iv_wipe_log = 'X'.
    TRY .
        gr_log_strategy->clear_messages( ).
        CLEAR gt_log_messages.
      CATCH /aif/cx_bal_log_strategy INTO lr_ballog_exc.
        RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_ballog_exc.
    ENDTRY.
  ENDIF.

  " TODO: authority check, like in /AIF/FILE_PROCESS_DATA:800ff
  "       track times?

  " --------------------------------------------------------- "
  "  0. Check if msgguid needs to be updated
  "
  "     This is only the case for outbound messages that have
  "     not yet been sent and thereby received their final, real
  "     GUID.
  "
  " --------------------------------------------------------- "

  IF NOT iv_msgguid IS INITIAL.
    me->update_msgguid( iv_msgguid ).
  ENDIF.


  " --------------------------------------------------------- "
  "  1. Update message status and information in index table
  "
  "     Populate basic message meta-data in single index entry
  " --------------------------------------------------------- "

  lr_sidx_entry = me->get_single_index_entry( ).
  ASSIGN lr_sidx_entry->* TO <ls_sidx_entry>.

  CREATE DATA lr_sidx_old_entry TYPE (gv_sidx).
  ASSIGN lr_sidx_old_entry->* TO <ls_sidx_old_entry>.

  IF gv_initial_call = 'X' AND NOT <ls_sidx_entry> IS INITIAL.
    lv_is_restart = 'X'.
  ENDIF.

  MOVE <ls_sidx_entry> TO <ls_sidx_old_entry>.

  ASSIGN COMPONENT 'AIFKEYS' OF STRUCTURE <ls_sidx_entry> TO <ls_aifkeys>.
  IF sy-subrc IS INITIAL.
    ASSIGN COMPONENT 'ADMIN'   OF STRUCTURE <ls_sidx_entry> TO <ls_aifadmin>.
    IF sy-subrc IS INITIAL.
      ASSIGN COMPONENT 'MSGGUID' OF STRUCTURE <ls_sidx_entry> TO <lv_msgguid>.
    ENDIF.
  ENDIF.
  IF NOT sy-subrc IS INITIAL.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING
        textid    = /aif/cx_enabler_base=>index_table_incorrect
        data_type = gv_sidx.
  ENDIF.

  " In contrast to other components, existence of PID is not enforced.
  " ATTENTION: never use <lv_pid> without checking <lv_pid> IS ASSIGNED in this method!
  ASSIGN COMPONENT 'PID' OF STRUCTURE <ls_sidx_entry> TO <lv_pid>.

  DATA lv_tznzone TYPE  tznzone.
  IF iv_tznzone IS INITIAL.
    lv_tznzone = cl_abap_tstmp=>get_system_timezone( ).
  ELSE.
    lv_tznzone = iv_tznzone.
  ENDIF.

  GET TIME.
  IF <ls_sidx_entry> IS INITIAL. " initial creation
    <lv_msgguid>              = gv_msgguid.

    <ls_aifkeys>-ns           = gs_finf-ns.
    <ls_aifkeys>-ifname       = gs_finf-ifname.
    <ls_aifkeys>-ifver        = gs_finf-ifversion.

    <ls_aifadmin>-create_date = iv_create_date.
    <ls_aifadmin>-create_time = iv_create_time.
    <ls_aifadmin>-create_user = iv_user_name.
    <ls_aifadmin>-last_date   = iv_create_date.
    <ls_aifadmin>-last_time   = iv_create_time.
    <ls_aifadmin>-last_user   = iv_user_name.
    <ls_aifadmin>-time_zone   = lv_tznzone.
  ELSEIF gv_initial_call = 'X'.  " update (for restart / cancel)
    <ls_aifadmin>-last_date   = iv_create_date.
    <ls_aifadmin>-last_time   = iv_create_time.
    <ls_aifadmin>-last_user   = iv_user_name.
  ENDIF.

  IF <lv_pid> IS ASSIGNED.
    <lv_pid>                = gv_pid.
  ENDIF.

* if location is '8', then this is the AIF Enabler call from CALL TRANSACTION,
* and the "old" application log should be continued
  IF <ls_aifadmin>-aif_location = /aif/if_globals=>gc_message_location-before_call_transaction.
    DATA: lr_appl_log_engine TYPE REF TO /aif/cl_logging_engine_app_log,
          lv_old_log_handle  TYPE balloghndl.
    TRY.
        lr_appl_log_engine ?= gr_log_strategy.
        SELECT SINGLE log_handle INTO lv_old_log_handle
          FROM balhdr
          WHERE lognumber = <ls_aifadmin>-lognumber.
        IF sy-subrc = 0 AND NOT lv_old_log_handle IS INITIAL.
          lr_appl_log_engine->set_loghandle( iv_log_handle = lv_old_log_handle ).
        ENDIF.
      CATCH cx_root.
    ENDTRY.
  ENDIF.

* Begin of comment Note 2646569
* --Here, the <ls_sidx_entry> is NOT updated with the latest value completely, e.g. the status not updated yet
* --So FINALIZE message here is not enough

* to support restarting WS, store logical port name in index table
  ASSIGN COMPONENT 'AIF_LOGICAL_PORT' OF STRUCTURE <ls_sidx_entry> TO <lv_logical_port>.
  IF iv_logical_port IS NOT INITIAL AND <lv_logical_port> IS ASSIGNED.
    <lv_logical_port> = iv_logical_port. UNASSIGN <lv_logical_port>.
  ENDIF.

  " We need to set a location, but in the AIF Enabler there are no distinct phases like "mapping", "action", etc.
  " The location has influence on restart/cancel logic (among others).
  " The value can be supplied by caller if wished, but "mapping" is a reasonable default because it makes sure that:
  "         1. inbound messages are restarted via proxy call
  "         2. outbound messages cannot be restarted / will be restarted using correct logic
  <ls_aifadmin>-aif_location  = iv_message_aif_location.

  "to allow specific enablers to add fields to single index table via callback without having to copy the entire
  "update method (as it was done for RFC ).
  add_additional_sidx_flds( CHANGING
                              cs_sidx_entry = <ls_sidx_entry> ).
  " --------------------------------------------------------- "
  "  2. Update Key-Fields
  "
  "     update RAW key-fields if raw-structure supplied
  "     update SAP key-fields if sap-structure supplied
  "
  "     This will write the key-field values to DB!
  "     This will also populate the key-field values of
  "     the single index entry that lr_sidx_entry is pointing
  "     to, i.e. its value changes though it is only an import
  "     parameter!
  "
  " --------------------------------------------------------- "
  " if keyfields already stored, then single key-fields were selected from single index table
  IF NOT iv_keyfields_already_stored = 'X'.
    IF is_raw_structure IS SUPPLIED.
      " check if raw structure needs to be tweaked with rectype raw
      IF gs_finf-rectyperaw IS INITIAL.
        ASSIGN is_raw_structure TO <ls_raw>.
        sy-subrc = 0. " previous is not a dynamic assignment, so sy-subrc will not be set -> we need to reset
      ELSE.
        ASSIGN COMPONENT gs_finf-rectyperaw OF STRUCTURE is_raw_structure TO <ls_raw>.
        IF NOT sy-subrc IS INITIAL.
          ASSIGN is_raw_structure TO <ls_raw>.
          sy-subrc = 0. " previous is not a dynamic assignment, so sy-subrc will not be set -> we need to reset
        ENDIF.
      ENDIF.
    ELSE.
      CREATE DATA lr_temp_raw TYPE (gs_finf-ddicstructureraw).
      ASSIGN lr_temp_raw->* TO <ls_raw>.
    ENDIF.

    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base
        EXPORTING
          textid = /aif/cx_enabler_base=>raw_assignment_failed.
    ENDIF.

    me->store_single_keyfields(
      EXPORTING
        is_raw_structure = <ls_raw>
        is_sap_structure = is_sap_structure
      CHANGING
        cs_sidx_entry    = <ls_sidx_entry>
    ).
  ENDIF.

  "write sap passport relevant data.
  "do this right here, because commit will come in set_single_index_entry or at the end of
  "this method and it allows us to log errors into application log.
  handle_passport_data( is_sidx_entry = <ls_sidx_entry> ).
  handle_mdi_data( is_sidx_entry    = <ls_sidx_entry>
                   is_raw_structure = is_raw_structure ).

  APPEND LINES OF gt_message_buffer TO lt_current_log_messages.
  APPEND LINES OF it_log_messages   TO lt_current_log_messages.

  APPEND LINES OF gt_log_messages         TO lt_all_log_messages.
  APPEND LINES OF lt_current_log_messages TO lt_all_log_messages.
  IF iv_message_status_flag IS SUPPLIED AND NOT iv_message_status_flag IS INITIAL.
    <ls_aifadmin>-status      = iv_message_status_flag.
  ELSE.
    <ls_aifadmin>-status      = me->determine_status_by_log_msgs( lt_all_log_messages ).
  ENDIF.
  "Sub-status of In-Process status for XML&STRU Engine begin
  IF iv_sub_status IS SUPPLIED.
    ASSIGN COMPONENT /aif/if_globals=>gc_eh_fix_key_flds-sub_status OF STRUCTURE <ls_aifadmin> TO FIELD-SYMBOL(<fs_sub_status>).
    IF sy-subrc = 0 AND <fs_sub_status> IS ASSIGNED.
      <fs_sub_status> = iv_sub_status.
    ENDIF.
  ENDIF.
  "Sub-status of In-Process status for XML&STRU Engine end
  IF <ls_aifadmin>-status = /aif/if_globals=>gc_eh_file_status-successful
   OR <ls_aifadmin>-status = /aif/if_globals=>gc_eh_file_status-canceled.
    <ls_aifadmin>-end_date   = iv_create_date.
    <ls_aifadmin>-end_time   = iv_create_time.
    <ls_aifadmin>-end_user   = iv_user_name.
  ENDIF.

  " --------------------------------------------------------- "
  "   Automatic Reprocessing
  " --------------------------------------------------------- "
  me->trigger_auto_reprocessing( EXPORTING iv_msgguid = <lv_msgguid> it_log_messages = lt_all_log_messages is_ifkeys = <ls_aifkeys> CHANGING cs_aifgen = <ls_aifadmin> ).

*    Add message to process observer for central monitoring
  ASSIGN COMPONENT 'ADMIN'   OF STRUCTURE <ls_sidx_old_entry> TO <ls_aifadmin_old>.
  me->trigger_central_monitoring( iv_old_status = <ls_aifadmin_old>-status iv_status = <ls_aifadmin>-status  is_idx_entry = <ls_sidx_entry> ).

  " --------------------------------------------------------- "
  "  3. Raise Alerts if applicable and determine the recipients
  " --------------------------------------------------------- "

  IF me->is_status_final( <ls_aifadmin>-status ) = 'X'.

    me->create_alert(
      EXPORTING
        is_sidx_entry           = <ls_sidx_entry>
        it_all_log_messages     = lt_all_log_messages
      IMPORTING
        et_recipients           = lt_recipients
        ev_alert_id             = lv_alert_id
      CHANGING
        ct_current_log_messages = lt_current_log_messages
    ).

  ELSE.
    " we need to determine the recipients ourselves
    lt_recipients = me->get_recipients( <ls_sidx_entry> ).
    lv_alert_id   = ''.
  ENDIF.



  " --------------------------------------------------------- "
  "  4. Update Statistics and Alert Index entries
  " --------------------------------------------------------- "

  me->update_msg_stat(
    iv_is_reprocess   = lv_is_restart
    is_sidx_entry     = <ls_sidx_entry>
    is_sidx_old_entry = <ls_sidx_old_entry>
    it_recipients     = lt_recipients
  ).

  me->update_alert_index(
    is_sidx_entry     = <ls_sidx_entry>
    it_recipients     = lt_recipients
    iv_alert_id       = lv_alert_id
  ).


  " --------------------------------------------------------- "
  "  5. update log message and statistics
  "
  "  Needs to be called even if lt_return_tab is empty, since
  "  this will also update the message statistics and e.g.
  "  error counts. Will reset error counts for initial call
  "  to AIF Enabler.
  "
  "  Application log needs to be written as well, so make sure
  "  to update the lognumber in the single index entry.
  "
  " --------------------------------------------------------- "

  me->update_errors(
    EXPORTING
      it_current_log_messages = lt_current_log_messages
    CHANGING
      cs_sidx_entry           = <ls_sidx_entry>
  ).
  TRY .
      <ls_aifadmin>-lognumber = gr_log_strategy->save( ).
    CATCH /aif/cx_bal_log_strategy INTO lr_ballog_exc.
      RAISE EXCEPTION TYPE /aif/cx_enabler_base EXPORTING previous = lr_ballog_exc.
  ENDTRY.

  " now that log messages are included in application log, we can:
  CLEAR gt_message_buffer.

  " --------------------------------------------------------- "
  "  6. Write new single index entry to DB and clean-up
  " --------------------------------------------------------- "

  IF NOT iv_keyfields_already_stored = 'X'.
    me->update_keyfields(
      EXPORTING
        is_raw_structure = <ls_raw>
        is_sap_structure = is_sap_structure
      CHANGING
        cs_sidx_entry    = <ls_sidx_entry>
    ).
  ENDIF.

  " --------------------------------------------------------- "
  "  7. Save and prepare for next Enabler call
  " --------------------------------------------------------- "
* Begin of Note 2646569
* --Here, the <ls_sidx_entry> is updated with the latest value completely
* --So FINALIZE message here

****  erasure of personal data: SET value for new field PROCESSING_END_TIMESTAMP
**for the future: remove dynamic call method, replace hardcode '/AIF/ARCHIVING' to constant/AIF/IF_CONSTANTS=>MC_SEC256

  TRY.

      DATA(ls_post_proc) = VALUE /aif/post_proc_param_s( 2nd_db_active = lo_db->is_2nd_active( )
                                                         2nd_db_connection = lo_db->mc_db_name
                                                         2nd_db_commit     = lo_db->get_do_commit( )
                                                         ref_to_raw        = REF data( is_raw_structure ) ).
      /aif/cl_message_helper=>get_instance( )->finalize_message_processing( EXPORTING
                                                                              is_post_proc   = ls_post_proc
                                                                            CHANGING
                                                                              cv_message_data = <ls_sidx_entry> ).
    CATCH cx_root.
  ENDTRY.

* End of Note 2646569
  me->set_single_index_entry( <ls_sidx_entry> ).

  " reset initial call status for next update call of enabler
  " this could happen e.g. if user/customer restarts a message in a loop statement
  IF me->is_status_final( <ls_aifadmin>-status ) = 'X'.
    " next call is an initial call again
    gv_initial_call = 'X'.
  ELSE.
    gv_initial_call = ''.
  ENDIF.

  gv_last_message_status  = <ls_aifadmin>-status.
*
* commit only, if 2th database connection iS NOT active
  IF iv_do_commit = 'X' AND lo_db->is_2nd_active( ) EQ lo_db->mc_false.
    COMMIT WORK AND WAIT.
  ENDIF.
ENDMETHOD.


  METHOD add_additional_sidx_flds.


  ENDMETHOD.


METHOD add_bal_message.
  DATA: ls_bal_context    TYPE /aif/bal_context,
        lv_msg_category   TYPE /aif/msg_category,
        lv_msg_is_allowed TYPE boolean.

  IF NOT iv_msg_category IS INITIAL.
    lv_msg_category = iv_msg_category.
  " else, try to read from bal context
  ELSEIF is_log_message-context-tabname = '/AIF/BAL_CONTEXT' AND NOT is_log_message-context-value IS INITIAL.
    ls_bal_context  = is_log_message-context-value.
    lv_msg_category = ls_bal_context-msg_category.
  ENDIF.  " otherwise ls_bal_context will just remain initial, which is OK when we do not have it

  lv_msg_is_allowed = 'X'.
  IF NOT iv_ignore_trace_level = 'X'.
    lv_msg_is_allowed    = /aif/cl_enabler_base=>is_message_allowed(
      iv_trace_level     = gv_trace_level
      iv_msgid           = is_log_message-msgid
      iv_msgno           = is_log_message-msgno
      iv_aif_msgty       = is_log_message-msgty
      iv_msg_source      = iv_msg_source
      iv_aif_msgcategory = lv_msg_category
    ).
  ENDIF.

  "TODO: offer BAdI so that customer could filter messages based on e.g. interface keys (gs_finf) + message keys

  IF lv_msg_is_allowed = 'X'.
    APPEND is_log_message TO gt_message_buffer.
  ENDIF.


ENDMETHOD.


METHOD add_bal_messages.
  DATA: ls_log_message TYPE bal_s_msg.

  LOOP AT it_log_messages INTO ls_log_message.
    me->add_bal_message(
      EXPORTING
        is_log_message        = ls_log_message
        iv_ignore_trace_level = iv_ignore_trace_level
        iv_msg_source         = iv_msg_source
    ).
  ENDLOOP.
ENDMETHOD.


METHOD add_bapiret2_message.
  me->add_single_log_message(
      iv_msg_type                  = is_bapiret2_message-type
      iv_msg_id                    = is_bapiret2_message-id
      iv_msg_number                = is_bapiret2_message-number
      iv_msg_message               = CONV string( is_bapiret2_message-message ) " TODO: need to convertg -message???
      iv_msg_message_v1            = is_bapiret2_message-message_v1
      iv_msg_message_v2            = is_bapiret2_message-message_v2
      iv_msg_message_v3            = is_bapiret2_message-message_v3
      iv_msg_message_v4            = is_bapiret2_message-message_v4
      iv_msg_vars_convert_external = 'X'
      iv_msg_parameter             = is_bapiret2_message-parameter
      iv_msg_row                   = is_bapiret2_message-row
      iv_msg_field                 = is_bapiret2_message-field
      it_dest_row_idx_tbl          = it_dest_row_idx_tbl
      iv_dest_row_curr_tabix       = iv_dest_row_curr_tabix
      iv_detlevel                  = iv_detlevel
      iv_probclass                 = iv_probclass
      is_bal_context               = is_bal_context
      iv_msg_source                = iv_msg_source
      iv_ignore_trace_level        = iv_ignore_trace_level
    ).
ENDMETHOD.


METHOD ADD_BAPIRET2_MESSAGES.
  DATA: ls_message TYPE bapiret2.

  LOOP AT it_bapiret2_messages INTO ls_message.
    me->add_bapiret2_message(
      EXPORTING
        is_bapiret2_message   = ls_message
        iv_ignore_trace_level = iv_ignore_trace_level
        iv_detlevel           = iv_detlevel
        iv_probclass          = iv_probclass
        is_bal_context        = is_bal_context
        iv_msg_source         = iv_msg_source
    ).
  ENDLOOP.
ENDMETHOD.


METHOD add_messages_from_balhndl.
* define local data objects
  DATA:
    lr_search  TYPE REF TO bal_s_lfil,
    lr_msg     TYPE REF TO bal_s_msg,
    lr_loghdr  TYPE REF TO balhdr_t,
    lr_msghndl TYPE REF TO bal_t_msgh,
    ls_log     TYPE bal_s_logh,
    lt_handle  TYPE bal_t_logh.

  FIELD-SYMBOLS:
    <ls_data> TYPE balmsghndl.

  IF iv_log_handle IS INITIAL.
    RETURN.
  ENDIF.
  INSERT iv_log_handle INTO TABLE lt_handle.
* search application log in memory
  CREATE DATA lr_msghndl.
  CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
    EXPORTING
      i_t_log_handle = lt_handle
    IMPORTING
      e_t_msg_handle = lr_msghndl->*
    EXCEPTIONS
      msg_not_found  = 1
      OTHERS         = 2.
  IF sy-subrc GE 1.
    CREATE DATA lr_search.
    ls_log-sign   = 'I'.
    ls_log-option = 'EQ'.
    ls_log-low    = iv_log_handle.
    INSERT ls_log INTO TABLE lr_search->log_handle.
* search application log on database
    CREATE DATA lr_loghdr.
    CALL FUNCTION 'BAL_DB_SEARCH'
      EXPORTING
        i_s_log_filter     = lr_search->*
      IMPORTING
        e_t_log_header     = lr_loghdr->*
      EXCEPTIONS
        log_not_found      = 1
        no_filter_criteria = 2
        OTHERS             = 3.
    IF sy-subrc EQ 0.
      CALL FUNCTION 'BAL_DB_LOAD'
        EXPORTING
          i_t_log_header     = lr_loghdr->*
        IMPORTING
          e_t_msg_handle     = lr_msghndl->*
        EXCEPTIONS
          no_logs_specified  = 1
          log_not_found      = 2
          log_already_loaded = 3
          OTHERS             = 4.
      IF sy-subrc GE 1.
        CLEAR lr_msghndl->*.
      ENDIF.
    ELSE.
      RETURN.
    ENDIF.
  ENDIF.
* add messages from BAL to enabler
  CREATE DATA lr_msg.
  LOOP AT lr_msghndl->* ASSIGNING <ls_data>.
    CALL FUNCTION 'BAL_LOG_MSG_READ'
      EXPORTING
        i_s_msg_handle = <ls_data>
      IMPORTING
        e_s_msg        = lr_msg->*
      EXCEPTIONS
        log_not_found  = 1
        msg_not_found  = 2
        OTHERS         = 3.
    CHECK sy-subrc EQ 0.
    me->add_bal_message( is_log_message  = lr_msg->*
                         iv_msg_category = |FE| ).
  ENDLOOP.

ENDMETHOD.


METHOD add_single_log_message.
  DATA: lt_bal_messages TYPE /aif/bal_t_msg,
        ls_bal_context  TYPE /aif/bal_context,

        lv_msgv_string  TYPE symsgv,
        lv_msgv1        TYPE symsgv,
        lv_msgv2        TYPE symsgv,
        lv_msgv3        TYPE symsgv,
        lv_msgv4        TYPE symsgv.

  IF iv_msg_vars_convert_external = 'X'.
    lv_msgv_string = iv_msg_message_v1.
    lv_msgv1       = lv_msgv_string.
    lv_msgv_string = iv_msg_message_v2.
    lv_msgv2       = lv_msgv_string.
    lv_msgv_string = iv_msg_message_v3.
    lv_msgv3       = lv_msgv_string.
    lv_msgv_string = iv_msg_message_v4.
    lv_msgv4       = lv_msgv_string.
  ELSE.
    WRITE iv_msg_message_v1 LEFT-JUSTIFIED TO lv_msgv1.
    WRITE iv_msg_message_v2 LEFT-JUSTIFIED TO lv_msgv2.
    WRITE iv_msg_message_v3 LEFT-JUSTIFIED TO lv_msgv3.
    WRITE iv_msg_message_v4 LEFT-JUSTIFIED TO lv_msgv4.
  ENDIF.

  ls_bal_context           = is_bal_context.

  " will not overwrite values in bal context if parameter/row/field are not supplied / are initial
  me->prepare_bapiret2_bal_context(
    EXPORTING
      iv_msg_parameter       = iv_msg_parameter
      iv_msg_row             = iv_msg_row
      iv_msg_field           = iv_msg_field
      it_dest_row_idx_tbl    = it_dest_row_idx_tbl
      iv_dest_row_curr_tabix = iv_dest_row_curr_tabix
    CHANGING
      cs_bal_context         = ls_bal_context ).

  /aif/cl_logging_engine_base=>convert_single_msg_to_bal_msgs(
    EXPORTING
      iv_msg_type            = iv_msg_type
      iv_msg_id              = iv_msg_id
      iv_msg_no              = iv_msg_number
      iv_msg_string          = iv_msg_message
      iv_msg_msgv1           = lv_msgv1
      iv_msg_msgv2           = lv_msgv2
      iv_msg_msgv3           = lv_msgv3
      iv_msg_msgv4           = lv_msgv4
      iv_msg_parameter       = iv_msg_parameter
      iv_msg_row             = iv_msg_row
      iv_msg_field           = iv_msg_field
      iv_detlevel            = iv_detlevel
      iv_probclass           = iv_probclass
      is_bal_context         = ls_bal_context
      iv_msg_source          = iv_msg_source
    CHANGING
      ct_bal_messages        = lt_bal_messages
  ).

  me->add_bal_messages(
    it_log_messages       = lt_bal_messages
    iv_ignore_trace_level = iv_ignore_trace_level
    iv_msg_source         = iv_msg_source ).


ENDMETHOD.


METHOD add_sy_message.

  add_single_log_message( iv_msg_type           = iv_msgty
                          iv_msg_id             = iv_msgid
                          iv_msg_number         = iv_msgno
                          iv_msg_message_v1     = iv_msgv1
                          iv_msg_message_v2     = iv_msgv2
                          iv_msg_message_v3     = iv_msgv3
                          iv_msg_message_v4     = iv_msgv4
                          iv_ignore_trace_level = iv_ignore_trace_level ).

ENDMETHOD.


method BUFFER_ALERT_IDX_ENTRIES.
 APPEND LINES OF it_alert_idx_entries TO gt_alert_idx.
endmethod.


METHOD buffer_multi_idx_entries.
*  Performance Optimization: store sindle index table entry
  DATA: lr_sidx_entry TYPE REF TO data,
        ls_idx_tab TYPE /aif/qrfc_idx_table_entries_st,
        lv_msgguid TYPE guid_32.

  FIELD-SYMBOLS: <ls_idx_tab> TYPE /aif/qrfc_idx_table_entries_st,
                 <ls_idx_entry> TYPE ANY,
                 <lt_idx_entries> TYPE STANDARD TABLE,
                 <lv_msgguid> TYPE guid_32.

*Check if the an entry for this message does already exists in the single index
* TODO: is this check really needed? Multi index table is deleted anyway
  DATA lv_midx_tab_name TYPE /aif/msg_tbl.
  TRY.
      lv_midx_tab_name = cl_abap_dyn_prg=>check_table_name_str(
                                  val      = iv_midx_tab_name
                                  packages = '' ).
    CATCH cx_abap_not_a_table.
      ASSERT 1 = 2.
    CATCH cx_abap_not_in_package.
      lv_midx_tab_name = iv_midx_tab_name.
  ENDTRY.
  SELECT SINGLE msgguid FROM (lv_midx_tab_name) INTO lv_msgguid WHERE msgguid = iv_msgguid.
  IF sy-subrc = 0.
**    entry does already exist-->update is necessary
*      READ TABLE gt_sidx_tab_entries_update ASSIGNING <ls_idx_tab> WITH TABLE KEY idx_table_name = gv_sidx.
*      IF sy-subrc = 0.
*        ASSIGN <ls_idx_tab>-idx_table_entries->* TO <lt_idx_entries>.
**        Check if an entry for this message does already exist in the single indes table buffer
*        READ TABLE <lt_idx_entries> ASSIGNING <ls_idx_entry> WITH KEY ('MSGGUID') = gv_msgguid.
*        IF sy-subrc = 0.
*          <ls_idx_entry> = is_sidx_entry.
*        ELSE.
*          APPEND is_sidx_entry TO <lt_idx_entries>.
*        ENDIF.
*      ELSE.
*        ls_idx_tab-idx_table_name = gv_sidx.
*        CREATE DATA ls_idx_tab-idx_table_entries TYPE TABLE OF (gv_sidx).
*        ASSIGN ls_idx_tab-idx_table_entries->* TO <lt_idx_entries>.
*        APPEND INITIAL LINE TO <lt_idx_entries> ASSIGNING <ls_idx_entry>.
*        <ls_idx_entry> = is_sidx_entry.
*        INSERT ls_idx_tab INTO TABLE gt_sidx_tab_entries_update.
*      ENDIF.
  ELSE.
*   entry does not exist-->insert is necessary
    READ TABLE gt_midx_tab_entries_insert ASSIGNING <ls_idx_tab> WITH TABLE KEY idx_table_name = iv_midx_tab_name.
    IF sy-subrc = 0.
      ASSIGN <ls_idx_tab>-idx_table_entries->* TO <lt_idx_entries>.
*        Check if an entry for this message does already exist in the single indes table buffer
*        READ TABLE <lt_idx_entries> ASSIGNING <ls_idx_entry> WITH KEY ('MSGGUID') = gv_msgguid.
*        Clear "old" entries from buffer for this message
      LOOP AT <lt_idx_entries> ASSIGNING <ls_idx_entry>.
        ASSIGN COMPONENT 'MSGGUID' OF STRUCTURE <ls_idx_entry> TO <lv_msgguid>.
        IF <lv_msgguid> = iv_msgguid.
          DELETE <lt_idx_entries> INDEX sy-tabix.
        ENDIF.
      ENDLOOP.
      ls_idx_tab-idx_table_name = iv_midx_tab_name.
      GET REFERENCE OF it_midx_entries INTO ls_idx_tab-idx_table_entries.
      INSERT ls_idx_tab INTO TABLE gt_sidx_tab_entries_insert.
    ENDIF.
  ENDIF.


ENDMETHOD.


method BUFFER_SINGLE_IDX_ENTRY.

*  Performance Optimization: store sindle index table entry
    DATA: lr_sidx_entry TYPE REF TO data,
          ls_idx_tab TYPE /aif/qrfc_idx_table_entries_st,
          lv_msgguid TYPE guid_32.

  FIELD-SYMBOLS: <ls_idx_tab> TYPE /aif/qrfc_idx_table_entries_st,
                   <ls_idx_entry> TYPE any,
                   <lt_idx_entries> TYPE STANDARD TABLE.

*Check if the an entry for this message does already exists in the single index
* SELECT SINGLE msgguid FROM (iv_sidx_tab_name) INTO lv_msgguid WHERE msgguid = iv_msgguid.

    IF NOT iv_is_restart IS INITIAL.
*    entry does already exist-->update is necessary
      READ TABLE gt_sidx_tab_entries_update ASSIGNING <ls_idx_tab> WITH TABLE KEY idx_table_name = iv_sidx_tab_name.
      IF sy-subrc = 0.
        ASSIGN <ls_idx_tab>-idx_table_entries->* TO <lt_idx_entries>.
*        Check if an entry for this message does already exist in the single indes table buffer
        READ TABLE <lt_idx_entries> ASSIGNING <ls_idx_entry> WITH KEY ('MSGGUID') = iv_msgguid.
        IF sy-subrc = 0.
          <ls_idx_entry> = is_sidx_entry.
        ELSE.
          APPEND is_sidx_entry TO <lt_idx_entries>.
        ENDIF.
      ELSE.
        ls_idx_tab-idx_table_name = iv_sidx_tab_name.
        CREATE DATA ls_idx_tab-idx_table_entries TYPE TABLE OF (iv_sidx_tab_name).
        ASSIGN ls_idx_tab-idx_table_entries->* TO <lt_idx_entries>.
        APPEND INITIAL LINE TO <lt_idx_entries> ASSIGNING <ls_idx_entry>.
        <ls_idx_entry> = is_sidx_entry.
        INSERT ls_idx_tab INTO TABLE gt_sidx_tab_entries_update.
      ENDIF.
    ELSE.
*   entry does not exist-->insert is necessary
      READ TABLE gt_sidx_tab_entries_insert ASSIGNING <ls_idx_tab> WITH TABLE KEY idx_table_name = iv_sidx_tab_name.
      IF sy-subrc = 0.
        ASSIGN <ls_idx_tab>-idx_table_entries->* TO <lt_idx_entries>.
*        Check if an entry for this message does already exist in the single indes table buffer
        READ TABLE <lt_idx_entries> ASSIGNING <ls_idx_entry> WITH KEY ('MSGGUID') = iv_msgguid.
        IF sy-subrc = 0.
          <ls_idx_entry> = is_sidx_entry.
        ELSE.
          APPEND is_sidx_entry TO <lt_idx_entries>.
        ENDIF.
      ELSE.
        ls_idx_tab-idx_table_name = iv_sidx_tab_name.
        CREATE DATA ls_idx_tab-idx_table_entries TYPE TABLE OF (iv_sidx_tab_name).
        ASSIGN ls_idx_tab-idx_table_entries->* TO <lt_idx_entries>.
        APPEND INITIAL LINE TO <lt_idx_entries> ASSIGNING <ls_idx_entry>.
        <ls_idx_entry> = is_sidx_entry.
        INSERT ls_idx_tab INTO TABLE gt_sidx_tab_entries_insert.
      ENDIF.
    ENDIF.

endmethod.


  METHOD change_passport_data.

    TRY.
        IF supports_passport_data( ) = abap_false.
          RETURN.
        ENDIF.

        FIELD-SYMBOLS <fs_sidx> TYPE /aif/std_idx_tbl.
        UNASSIGN <fs_sidx>.
        ASSIGN is_sidx_entry TO <fs_sidx> CASTING.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.

        DATA lv_tznzone TYPE tznzone.
        lv_tznzone = <fs_sidx>-time_zone.
        IF lv_tznzone IS INITIAL.
          lv_tznzone = cl_abap_tstmp=>get_system_timezone( ).
        ENDIF.

        IF iv_update = abap_true.
          CONVERT DATE <fs_sidx>-last_date TIME <fs_sidx>-last_time INTO TIME STAMP cs_appl_data-last_update_timestamp TIME ZONE lv_tznzone.
        ELSE.
          CONVERT DATE <fs_sidx>-create_date TIME <fs_sidx>-create_time INTO TIME STAMP cs_appl_data-start_timestamp TIME ZONE lv_tznzone.
          CONVERT DATE <fs_sidx>-last_date TIME <fs_sidx>-last_time INTO TIME STAMP cs_appl_data-last_update_timestamp TIME ZONE lv_tznzone.
          DATA lv_direction TYPE /aif/inb_outb_flag.
          lv_direction = determine_inb_outb( ).
          IF lv_direction = 'I'.
            cs_appl_data-direction = 'INBOUND'.
          ELSEIF lv_direction = 'O'.
            cs_appl_data-direction = 'OUTBOUND'.
          ENDIF.
        ENDIF.

        "get appl. tech flag:
        DATA(lr_appl_typeinfo) = CAST /aif/if_appl_typeinfo( /aif/cl_aif_engine_factory=>get_engine( iv_ns = <fs_sidx>-ns
                                                                                                     iv_ifname = <fs_sidx>-ifname
                                                                                                     iv_ifversion = <fs_sidx>-ifver ) ).
        cs_appl_data-if_technology = lr_appl_typeinfo->get_typeinfo( ).
      CATCH cx_root INTO DATA(lr_root).
        MESSAGE w043(/aif/enabler_base) INTO /aif/cx_passport_general=>mv_dummy.
        add_sy_message( ).
    ENDTRY.

  ENDMETHOD.


METHOD constructor.
  DATA: lv_log_engine TYPE /aif/logging_engine_class,
        lr_ballog_exc TYPE REF TO /aif/cx_bal_log_strategy,
        lr_log_engine_not_found TYPE REF TO /aif/cx_aif_engine_not_found,
        lv_create_log TYPE boolean.

  IF iv_ns IS INITIAL OR iv_ifname IS INITIAL OR iv_ifversion IS INITIAL.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING textid = /aif/cx_enabler_base=>insufficient_information.
  ENDIF.

  TRY.
    gs_finf = /aif/cl_db_access_finf=>get_instance( )->read_single(
                                       iv_ns     = iv_ns
                                       iv_ifname = iv_ifname
                                       iv_ifver  = iv_ifversion ).

    CATCH /aif/cx_error_handling_general.
    RAISE EXCEPTION TYPE /aif/cx_enabler_base
      EXPORTING textid    = /aif/cx_enabler_base=>interface_not_found
                ns        = iv_ns
                ifname    = iv_ifname
                ifversion = iv_ifversion.
  ENDTRY.

  " Attention: There is no plausability check if this is an outbound interface and if it makes sense to generate a GUID
  "            Normally this is only the case for outbound messages before sending
  IF NOT iv_msgguid IS SUPPLIED OR iv_msgguid IS INITIAL.
    gv_msgguid = /aif/cl_enabler_base=>generate_temp_msgguid( ).
  ELSE.
    gv_msgguid = iv_msgguid.
  ENDIF.


  IF iv_pid IS SUPPLIED.
    gv_pid = iv_pid.
  ELSE.
    gv_pid = ''.
  ENDIF.

  " determine single index table by NS/IFNAME/IFVERSION
  gv_sidx = me->determine_single_idx_tbl( iv_ns = gs_finf-ns iv_ifname = gs_finf-ifname iv_ifversion = gs_finf-ifversion ).
  gv_trace_level      = me->determine_trace_level(
    iv_ns             = gs_finf-ns
    iv_ifname         = gs_finf-ifname
    iv_ifversion      = gs_finf-ifversion
    iv_single_idx_tbl = gv_sidx
    iv_msgguid        = gv_msgguid ).

  " create logging engine instance
  me->INIT_LOG_STRATEGY( iv_force_create_log ).

  " create selection engine instance
  me->INIT_SELECTION_ENGINE( ).

  " Initial call is used to determine whether the enabler's update method was called for the message
  " before. It is needed to conditionally execute specific coding in case the enabler is called repeatedly.
  gv_initial_call = 'X'.
  CLEAR gt_log_messages.
ENDMETHOD.


METHOD create_alert.
  DATA: lv_msgguid_cast        TYPE sxmsguid,
        lv_logsys              TYPE logsys,

        lv_lines_before        TYPE int4,
        lv_lines_after         TYPE int4,

        lt_return_messages     TYPE bapiret2_t,
        lt_new_return_messages TYPE bapiret2_t,
        lt_new_bal_messages    TYPE /aif/bal_t_msg,
        ls_temp_return_message TYPE bapiret2,
        ls_temp_log_message    TYPE bal_s_msg,

        ls_bal_context         TYPE /aif/bal_context.
  FIELD-SYMBOLS:
        <lv_logsys>            TYPE logsys.
  lv_msgguid_cast = gv_msgguid.

  " convert it_all_log_messages into bapiret2 structure for being able to call /AIF/CREATE_ALERT
  ASSIGN COMPONENT 'LOGSYS' OF STRUCTURE is_sidx_entry TO <lv_logsys>.
  IF <lv_logsys> IS ASSIGNED.
    lv_logsys = <lv_logsys>.
  ENDIF.
  lt_return_messages = /aif/cl_logging_engine_base=>convert_bal_msgs_to_bapiret2( it_bal_messages = it_all_log_messages iv_logsys = lv_logsys ).

  lv_lines_before = LINES( lt_return_messages ).
  CALL FUNCTION '/AIF/CREATE_ALERT'
    EXPORTING
      ns                 = gs_finf-ns
      ifname             = gs_finf-ifname
      ifversion          = gs_finf-ifversion
      msgguid            = lv_msgguid_cast
      is_single_msg_data = is_sidx_entry
    IMPORTING
      recipients         = et_recipients
      external_alert_id  = ev_alert_id
    TABLES
      return_tab         = lt_return_messages.

  lv_lines_after = LINES( lt_return_messages ).

  " add additional messages that were included by /AIF/CREATE_ALERT in the lt_return_messages
  " -> Only works if additional messages are APPENDed at the end of lt_return_messages
  " This requires SNOTE 1682453 to be installed
  IF lv_lines_before = lv_lines_after AND NOT ev_alert_id IS INITIAL. " case without note
    CLEAR ls_temp_log_message.
    ls_temp_log_message-msgty = 'I'.
    ls_temp_log_message-msgid = '/AIF/ALERT'.
    ls_temp_log_message-msgno = '014'.
    ls_temp_log_message-msgv1 = ev_alert_id.

    APPEND ls_temp_log_message TO ct_current_log_messages.
  ELSEIF lv_lines_after > lv_lines_before.
    CLEAR: lt_new_return_messages, lt_new_bal_messages, ls_bal_context.
    ls_bal_context-msg_category = 'O'. " msg_category, date and time is the only bal context value that is relevant for messages returned by /AIF/CREATE_ALERT
    ls_bal_context-sydate = sy-datum.
    ls_bal_context-sytime = sy-uzeit.

    WHILE lv_lines_before < lv_lines_after.
      ADD 1 TO lv_lines_before.
      READ TABLE lt_return_messages INTO ls_temp_return_message INDEX lv_lines_before.
      IF sy-subrc IS INITIAL.
        APPEND ls_temp_return_message TO lt_new_return_messages.
      ENDIF.
    ENDWHILE.

    CALL METHOD /aif/cl_logging_engine_base=>convert_bapiret2_to_bal_msgs
      EXPORTING
        it_bapiret2_messages = lt_new_return_messages
        is_bal_context       = ls_bal_context
      IMPORTING
        et_bal_messages      = lt_new_bal_messages.
    APPEND LINES OF lt_new_bal_messages TO ct_current_log_messages.
  ENDIF.
ENDMETHOD.


METHOD determine_single_idx_tbl.
  SELECT SINGLE msg_tbl INTO  rv_sidx_tbl_name FROM  /aif/t_inf_tbl
    WHERE ns = iv_ns AND ifname = iv_ifname AND ifver = iv_ifversion.
  IF sy-subrc <> 0 OR rv_sidx_tbl_name IS INITIAL.
    rv_sidx_tbl_name = '/AIF/STD_IDX_TBL'.
  ENDIF.
ENDMETHOD.


METHOD DETERMINE_STATUS_BY_LOG_MSGS.
  rv_status_flag = 'S'.
  CHECK NOT it_log_messages IS INITIAL.

* note 2148556
  READ TABLE it_log_messages TRANSPORTING NO FIELDS WITH KEY msgty = 'A'.
  IF sy-subrc IS INITIAL.
    rv_status_flag = 'A'.
  ELSE.
    READ TABLE it_log_messages TRANSPORTING NO FIELDS WITH KEY msgty = 'E'.
    IF sy-subrc IS INITIAL.
      rv_status_flag = 'E'.
* note 2148556
    ELSE.
      READ TABLE it_log_messages TRANSPORTING NO FIELDS WITH KEY msgty = 'W'.
      IF sy-subrc IS INITIAL.
        rv_status_flag = 'W'.
    " ELSE: 'S' is default (see above)
      ENDIF.
    ENDIF.
  ENDIF.
ENDMETHOD.


METHOD determine_trace_level.
  DATA: lref_tl           TYPE REF TO /aif/cl_db_access_finf_tl,
        ls_finf_tl        TYPE /aif/finf_tl,
        lv_single_idx_tbl TYPE /aif/msg_tbl,

        lv_trace_level    TYPE /aif/trace_level,
        lv_exp_date       TYPE /aif/exp_date,
        lv_exp_time       TYPE /aif/exp_time,

        lv_valid          TYPE boolean.

  rv_trace_level = /aif/if_globals=>gc_eh_default_tl.

  " message-specific trace level first
  IF iv_msgguid IS SUPPLIED AND NOT iv_msgguid IS INITIAL.
    " single index table only required on message level
    IF iv_single_idx_tbl IS SUPPLIED AND NOT iv_single_idx_tbl IS INITIAL.
      lv_single_idx_tbl = iv_single_idx_tbl.
    ELSE.
      lv_single_idx_tbl = me->determine_single_idx_tbl( iv_ns = iv_ns iv_ifname = iv_ifname iv_ifversion = iv_ifversion ).
    ENDIF.

    SELECT SINGLE trace_level tl_exp_date tl_exp_time INTO (lv_trace_level, lv_exp_date, lv_exp_time)
           FROM (lv_single_idx_tbl) WHERE msgguid = iv_msgguid.
    IF sy-subrc IS INITIAL AND lv_trace_level <> space.

      CALL FUNCTION '/AIF/IS_TRACE_LEVEL_VALID'
        EXPORTING
          iv_trace_level = lv_trace_level
        IMPORTING
          ev_valid       = lv_valid.

      IF lv_valid = 'X' AND (
           lv_exp_date IS INITIAL OR
           NOT ( lv_exp_date = sy-datum AND lv_exp_time < sy-uzeit )
        ).

        rv_trace_level = lv_trace_level.
        RETURN. " trace level already defined
      ENDIF.

      " trace level could not be defined here - move on
    ENDIF.
  ENDIF.


  " if trace level not determined based on message, determine based on interface
  lref_tl = /aif/cl_db_access_finf_tl=>get_instance( ).
  TRY.
    ls_finf_tl = lref_tl->read_single(
         iv_ns        = iv_ns
         iv_ifname    = iv_ifname
         iv_ifversion = iv_ifversion ).
  CATCH /aif/cx_error_handling_general.
    RETURN. " retain default value in case of an error
  ENDTRY.

  CALL FUNCTION '/AIF/IS_TRACE_LEVEL_VALID'
    EXPORTING
      iv_trace_level = ls_finf_tl-trace_level
    IMPORTING
      ev_valid       = lv_valid.

  IF lv_valid = 'X' AND (
        ls_finf_tl-tl_exp_date IS INITIAL OR
        NOT ( ls_finf_tl-tl_exp_date = sy-datum AND ls_finf_tl-tl_exp_time < sy-uzeit )
     ).

    rv_trace_level = ls_finf_tl-trace_level.
    RETURN. " trace level already defined
  ENDIF.

  " if trace level was not before this line, it will retain default value

ENDMETHOD.


  METHOD fill_epp_logical_key.

    TRY.

        FIELD-SYMBOLS <fs_sidx> TYPE /aif/std_idx_tbl.
        UNASSIGN <fs_sidx>.
        ASSIGN is_sidx_entry TO <fs_sidx> CASTING.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.
        cs_epp_logical_key-msgguid = <fs_sidx>-msgguid.

      CATCH cx_root INTO DATA(lr_root).
    ENDTRY.

  ENDMETHOD.


METHOD generate_temp_msgguid.
  TRY.
      rv_guid32 = cl_system_uuid=>create_uuid_c32_static( ).
    CATCH cx_uuid_error.
      CLEAR rv_guid32.
  ENDTRY.
*  CALL FUNCTION 'GUID_CREATE'
*    IMPORTING
*      ev_guid_32 = rv_guid32.
ENDMETHOD.


method GET_FINF.
  rs_finf = gs_finf.
endmethod.


METHOD get_key_field_data_ref.

  CLEAR rr_data.
  " skip this keyfield if the corresponding structure is not supplied
  IF ( is_kflds-raw_or_sap = 'S'      AND iv_inb_or_outb = 'I' ) OR " S = destination structure; S + I    -> SAP structure
     ( is_kflds-raw_or_sap IS INITIAL AND iv_inb_or_outb = 'O' ).   " blank = source structure; blank + O -> SAP structure
    CHECK is_sap_structure IS SUPPLIED AND NOT is_sap_structure IS INITIAL.
    "ASSIGN is_sap_structure TO <ls_linedata>.
    rr_data = REF data( is_sap_structure ).
  ELSEIF ( is_kflds-raw_or_sap IS INITIAL AND iv_inb_or_outb = 'I' ) OR  " S = destination structure; S + I    -> SAP structure
         ( is_kflds-raw_or_sap = 'S'      AND iv_inb_or_outb = 'O' ).
    CHECK is_raw_structure IS SUPPLIED AND NOT is_raw_structure IS INITIAL.
    "ASSIGN is_raw_structure TO <ls_linedata>.
    rr_data = REF data( is_raw_structure ).
  ENDIF.

ENDMETHOD.


method GET_LAST_MESSAGE_STATUS.
  rv_status = gv_last_message_status.
endmethod.


METHOD get_log_messages.  "#EC CI_VALPAR
  rt_log_messages = gt_log_messages.
  IF iv_include_buffered = 'X'.
    APPEND LINES OF gt_message_buffer TO rt_log_messages.
  ENDIF.
ENDMETHOD. "#EC CI_VALPAR


  METHOD get_mdi_data.

    CLEAR rt_mdi_data.

    TRY.

        IF is_sidx_entry IS INITIAL.
          RETURN.
        ENDIF.

        FIELD-SYMBOLS <fs_sidx> TYPE /aif/std_idx_tbl.
        UNASSIGN <fs_sidx>.
        ASSIGN is_sidx_entry TO <fs_sidx> CASTING.
        DATA(ls_aifkeys) = CORRESPONDING /aif/ifkeys( is_sidx_entry ).
        DATA lr_mdi_badi TYPE REF TO /aif/determine_mdi_data_badi.
        FIELD-SYMBOLS <fs_raw> TYPE any.
        UNASSIGN <fs_raw>.

        GET BADI lr_mdi_badi
          FILTERS
            ns     = ls_aifkeys-ns
            ifname = ls_aifkeys-ifname
            ifver  = ls_aifkeys-ifver.
        IF is_raw_structure IS INITIAL.

          DATA(ls_xmlparse) = VALUE /aif/xmlparse_data( ).
          "read from persistency engine.
          DATA lr_appl_engine TYPE REF TO /aif/if_application_engine.
          lr_appl_engine = /aif/cl_aif_engine_factory=>get_engine( iv_ns = ls_aifkeys-ns
                                                                   iv_ifname = ls_aifkeys-ifname
                                                                   iv_ifversion = ls_aifkeys-ifver ).
          IF lr_appl_engine IS BOUND.
            TRY.
                lr_appl_engine->read_msg_from_persistency( EXPORTING
                                                           iv_msgguid = CONV sxmsguid( <fs_sidx>-msgguid )
                                                           iv_ns = ls_aifkeys-ns
                                                           iv_ifname = ls_aifkeys-ifname
                                                           iv_ifver = ls_aifkeys-ifver
                                                           CHANGING
                                                             cs_xmlparse = ls_xmlparse ).
              CATCH /aif/cx_error_handling_general INTO DATA(lr_aif_err).
                CLEAR ls_xmlparse.
            ENDTRY.
            IF ls_xmlparse-xi_data IS BOUND.
              ASSIGN ls_xmlparse-xi_data->* TO <fs_raw>.
            ENDIF.
          ENDIF.
        ELSE.
          ASSIGN is_raw_structure TO <fs_raw>.
        ENDIF.

        CALL BADI lr_mdi_badi->get_mdi_data
          EXPORTING
            is_aif_keys      = ls_aifkeys
            is_sidx_entry    = is_sidx_entry
            is_raw_structure = <fs_raw>
          RECEIVING
            rt_mdi_data      = rt_mdi_data.

      CATCH cx_root INTO DATA(lr_root).
    ENDTRY.

  ENDMETHOD.


method GET_MSGGUID.
  rv_guid32 = gv_msgguid.
endmethod.


method GET_PID.

  rv_pid = gv_pid.

endmethod.
ENDCLASS.