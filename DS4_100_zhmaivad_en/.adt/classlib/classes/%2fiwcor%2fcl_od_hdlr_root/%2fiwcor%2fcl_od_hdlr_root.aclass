"! <p class="shorttext synchronized" lang="en">OData root handler</p>
CLASS /iwcor/cl_od_hdlr_root DEFINITION
  PUBLIC
  CREATE PUBLIC .

  PUBLIC SECTION.

*"* public components of class /IWCOR/CL_OD_HDLR_ROOT
*"* do not include other source files here!!!
    INTERFACES /iwcor/if_rest_handler .

    TYPES:
      "! <p class="shorttext synchronized" lang="en">Handle mode</p>
      handle_mode TYPE c LENGTH 1 .

    CONSTANTS:
      "! <p class="shorttext synchronized" lang="en">Handle modes</p>
      BEGIN OF gcs_handle_modes,
        complete TYPE handle_mode VALUE 'C',
        repeat   TYPE handle_mode VALUE 'R',
      END OF gcs_handle_modes .

    "! <p class="shorttext synchronized" lang="en">Request handling finished</p>
    EVENTS handle_finished .

    "! <p class="shorttext synchronized" lang="en">CONSTRUCTOR</p>
    "!
    "! @parameter io_svc_factory | <p class="shorttext synchronized" lang="en">Service factory</p>
    METHODS constructor
      IMPORTING
        !io_svc_factory TYPE REF TO /iwcor/if_od_svc_factory .
    "! <p class="shorttext synchronized" lang="en">Root handler with single / generic service implementation</p>
    "!
    "! @parameter iv_svc_classname | <p class="shorttext synchronized" lang="en">Classname</p>
    "! @parameter it_svc_parameter | <p class="shorttext synchronized" lang="en">Service constructor parameters</p>
    "! @parameter ro_root_handler  | <p class="shorttext synchronized" lang="en">Root handler</p>
    CLASS-METHODS create_with_single_service
      IMPORTING
        !iv_svc_classname      TYPE seoclsname
        !it_svc_parameter      TYPE abap_parmbind_tab OPTIONAL
      RETURNING
        VALUE(ro_root_handler) TYPE REF TO /iwcor/cl_od_hdlr_root .
    "! <p class="shorttext synchronized" lang="en">Root handler with specific service implementations</p>
    "!
    "! @parameter io_svc_factory  | <p class="shorttext synchronized" lang="en">Service factory</p>
    "! @parameter ro_root_handler | <p class="shorttext synchronized" lang="en">Root handler</p>
    CLASS-METHODS create_with_service_factory
      IMPORTING
        !io_svc_factory        TYPE REF TO /iwcor/if_od_svc_factory
      RETURNING
        VALUE(ro_root_handler) TYPE REF TO /iwcor/cl_od_hdlr_root .
    "! <p class="shorttext synchronized" lang="en">Get service name</p>
    "!
    "! @parameter iv_svc_root                 | <p class="shorttext synchronized" lang="en">Root path for service resolution</p>
    "! @parameter iv_svc_segments             | <p class="shorttext synchronized" lang="en">No. of segments for service resolution</p>
    "! @parameter iv_svc_segments_limit       | <p class="shorttext synchronized" lang="en">No. of segments that limit cross service batch calls</p>
    "! @parameter iv_path_info                | <p class="shorttext synchronized" lang="en">Path info</p>
    "! @parameter iv_script_name              | <p class="shorttext synchronized" lang="en">Script name</p>
    "! @parameter iv_script_name_expanded     | <p class="shorttext synchronized" lang="en">Script name expanded</p>
    "! @parameter iv_script_segment_parameter | <p class="shorttext synchronized" lang="en">Script segment parameter</p>
    "! @parameter ev_service_name             | <p class="shorttext synchronized" lang="en">Service name</p>
    "! @parameter ev_service_root             | <p class="shorttext synchronized" lang="en">Service root</p>
    "! @parameter ev_service_segment_data     | <p class="shorttext synchronized" lang="en">Service segment data</p>
    "! @parameter ev_resource_path            | <p class="shorttext synchronized" lang="en">Resource path</p>
    "! @raising   /iwcor/cx_od_internal_error | <p class="shorttext synchronized" lang="en">OData Server Error - Internal Error</p>
    CLASS-METHODS get_service_name
      IMPORTING
        !iv_svc_root                 TYPE string DEFAULT ''
        !iv_svc_segments             TYPE i DEFAULT 0
        !iv_svc_segments_limit       TYPE i DEFAULT 0
        !iv_path_info                TYPE string
        !iv_script_name              TYPE string
        !iv_script_name_expanded     TYPE string
        !iv_script_segment_parameter TYPE string DEFAULT ''
      EXPORTING
        VALUE(ev_service_name)       TYPE string
        !ev_service_root             TYPE string
        !ev_service_segment_data     TYPE string
        !ev_resource_path            TYPE string
      RAISING
        /iwcor/cx_od_internal_error .
    "! <p class="shorttext synchronized" lang="en">Set root path and no. of segments for service resolution</p>
    "!
    "! @parameter iv_svc_root           | <p class="shorttext synchronized" lang="en">Root path for service resolution</p>
    "! @parameter iv_svc_segments       | <p class="shorttext synchronized" lang="en">No. of segments for service resolution</p>
    "! @parameter iv_svc_segments_limit | <p class="shorttext synchronized" lang="en">No. of segments that limit cross service referencing</p>
    METHODS set_resolution_parameter
      IMPORTING
        !iv_svc_root           TYPE string DEFAULT ''
        !iv_svc_segments       TYPE i DEFAULT 0
        !iv_svc_segments_limit TYPE i DEFAULT 0 .
    "! <p class="shorttext synchronized" lang="en">Processes a REST Request depending on a handle mode</p>
    "!
    "! @parameter io_request  | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter io_context  | <p class="shorttext synchronized" lang="en">REST Context</p>
    "! @parameter iv_mode     | <p class="shorttext synchronized" lang="en">Handle mode</p>
    METHODS handle_with_mode
      IMPORTING
        !io_request  TYPE REF TO /iwcor/if_rest_request
        !io_response TYPE REF TO /iwcor/if_rest_response
        !io_context  TYPE REF TO /iwcor/if_rest_context
        !iv_mode     TYPE handle_mode .
  PROTECTED SECTION.

    "! <p class="shorttext synchronized" lang="en">Service factory</p>
    DATA mo_svc_factory TYPE REF TO /iwcor/if_od_svc_factory .
    "! <p class="shorttext synchronized" lang="en">Root path for service resolution</p>
    DATA mv_svc_root TYPE string VALUE ''.                  "#EC NOTEXT
    "! <p class="shorttext synchronized" lang="en">No. of segments for service resolution</p>
    DATA mv_svc_segments TYPE i VALUE 0.                    "#EC NOTEXT
    "! <p class="shorttext synchronized" lang="en">No. of segments that limit cross service referencing</p>
    DATA mv_svc_segments_limit TYPE i VALUE 0.              "#EC NOTEXT

    "! <p class="shorttext synchronized" lang="en">Check kernel release for kernel MESSAGE registration</p>
    "!
    "! @parameter rv_registration_check | <p class="shorttext synchronized" lang="en">Is registration possible?</p>
    METHODS check_register_kernel_release
      RETURNING
        VALUE(rv_registration_check) TYPE abap_bool .
    "! <p class="shorttext synchronized" lang="en">Dispatch to next handler</p>
    "!
    "! @parameter iv_service_name    | <p class="shorttext synchronized" lang="en">Service name</p>
    "! @parameter io_request         | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response        | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter io_context         | <p class="shorttext synchronized" lang="en">Context</p>
    "! @raising   /iwcor/cx_od_error | <p class="shorttext synchronized" lang="en">OData Error</p>
    METHODS dispatch
      IMPORTING
        !iv_service_name TYPE string OPTIONAL
        !io_request      TYPE REF TO /iwcor/if_rest_request
        !io_response     TYPE REF TO /iwcor/if_rest_response
        !io_context      TYPE REF TO /iwcor/if_od_cntxt
      RAISING
        /iwcor/cx_od_error .
    "! <p class="shorttext synchronized" lang="en">Handle runtime error</p>
    "!
    "! @parameter io_error    | <p class="shorttext synchronized" lang="en">OData Error</p>
    "! @parameter io_request  | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response | <p class="shorttext synchronized" lang="en">REST Response</p>
    METHODS handle_error
      IMPORTING
        !io_error    TYPE REF TO /iwcor/cx_od_error
        !io_request  TYPE REF TO /iwcor/if_rest_request
        !io_response TYPE REF TO /iwcor/if_rest_response .
    "! <p class="shorttext synchronized" lang="en">Handle debug request</p>
    "!
    "! @parameter io_request  | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter io_context  | <p class="shorttext synchronized" lang="en">Context</p>
    METHODS handle_debug
      IMPORTING
        !io_request  TYPE REF TO /iwcor/if_rest_request
        !io_response TYPE REF TO /iwcor/if_rest_response
        !io_context  TYPE REF TO /iwcor/if_od_cntxt .
    "! <p class="shorttext synchronized" lang="en">Handle conditions</p>
    "!
    "! @parameter io_request         | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response        | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter io_context         | <p class="shorttext synchronized" lang="en">OData context</p>
    "! @parameter rv_processed       | <p class="shorttext synchronized" lang="en">Has request been processed completely?</p>
    "! @raising   /iwcor/cx_od_error | <p class="shorttext synchronized" lang="en">OData error</p>
    METHODS handle_conditions
      IMPORTING
        !io_request         TYPE REF TO /iwcor/if_rest_request
        !io_response        TYPE REF TO /iwcor/if_rest_response
        !io_context         TYPE REF TO /iwcor/if_od_cntxt
      RETURNING
        VALUE(rv_processed) TYPE abap_bool
      RAISING
        /iwcor/cx_od_error .
    "! <p class="shorttext synchronized" lang="en">Handle runtime error from virus scan interface</p>
    "!
    "! @parameter io_exception | <p class="shorttext synchronized" lang="en">VSI Error</p>
    "! @parameter io_request   | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response  | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter ro_error     | <p class="shorttext synchronized" lang="en">Error</p>
    METHODS handle_exception_vsi
      IMPORTING
        !io_exception   TYPE REF TO cx_vsi
        !io_request     TYPE REF TO /iwcor/if_rest_request
        !io_response    TYPE REF TO /iwcor/if_rest_response
      RETURNING
        VALUE(ro_error) TYPE REF TO /iwcor/cx_od_error .
    "! <p class="shorttext synchronized" lang="en">Handle runtime error</p>
    "!
    "! @parameter io_exception | <p class="shorttext synchronized" lang="en">Runtime error</p>
    "! @parameter io_request   | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response  | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter ro_error     | <p class="shorttext synchronized" lang="en">Error</p>
    METHODS handle_exception
      IMPORTING
        !io_exception   TYPE REF TO cx_no_check
        !io_request     TYPE REF TO /iwcor/if_rest_request
        !io_response    TYPE REF TO /iwcor/if_rest_response
      RETURNING
        VALUE(ro_error) TYPE REF TO /iwcor/cx_od_error .
    "! <p class="shorttext synchronized" lang="en">Resolve service</p>
    "!
    "! @parameter io_request              | <p class="shorttext synchronized" lang="en">Request</p>
    "! @parameter io_context              | <p class="shorttext synchronized" lang="en">Context</p>
    "! @parameter ev_service_name         | <p class="shorttext synchronized" lang="en">Service name</p>
    "! @parameter ev_service_root         | <p class="shorttext synchronized" lang="en">Service root</p>
    "! @parameter ev_service_segment_data | <p class="shorttext synchronized" lang="en">Service segment data</p>
    "! @parameter ev_resource_path        | <p class="shorttext synchronized" lang="en">Resource path</p>
    "! @parameter ev_script_name          | <p class="shorttext synchronized" lang="en">Script name</p>
    "! @parameter ev_script_name_expanded | <p class="shorttext synchronized" lang="en">Script name expanded</p>
    "! @raising   /iwcor/cx_od_error      | <p class="shorttext synchronized" lang="en">OData Error</p>
    METHODS resolve_service
      IMPORTING
        !io_request              TYPE REF TO /iwcor/if_rest_request
        !io_context              TYPE REF TO /iwcor/if_rest_context
      EXPORTING
        !ev_service_name         TYPE string
        !ev_service_root         TYPE string
        !ev_service_segment_data TYPE string
        !ev_resource_path        TYPE string
        !ev_script_name          TYPE string
        !ev_script_name_expanded TYPE string
      RAISING
        /iwcor/cx_od_error .
    "! <p class="shorttext synchronized" lang="en">Handle authorization check</p>
    "!
    "! @parameter iv_service_name    | <p class="shorttext synchronized" lang="en">Qualified service name</p>
    "! @raising   /iwcor/cx_od_error | <p class="shorttext synchronized" lang="en">OData Error</p>
    METHODS handle_authority_check
      IMPORTING
        !iv_service_name TYPE string
      RAISING
        /iwcor/cx_od_error .
    "! <p class="shorttext synchronized" lang="en">Post processing</p>
    "!
    "! @parameter io_request         | <p class="shorttext synchronized" lang="en">REST Request</p>
    "! @parameter io_response        | <p class="shorttext synchronized" lang="en">REST Response</p>
    "! @parameter io_context         | <p class="shorttext synchronized" lang="en">Context</p>
    "! @raising   /iwcor/cx_od_error | <p class="shorttext synchronized" lang="en">OData error</p>
    METHODS post_process
      IMPORTING
        !io_request  TYPE REF TO /iwcor/if_rest_request
        !io_response TYPE REF TO /iwcor/if_rest_response
        !io_context  TYPE REF TO /iwcor/if_od_cntxt
      RAISING
        /iwcor/cx_od_error .
  PRIVATE SECTION.

    "! <p class="shorttext synchronized" lang="en">Get entity type of path</p>
    "!
    "! @parameter it_path                | <p class="shorttext synchronized" lang="en">Property path</p>
    "! @parameter ro_entity_type         | <p class="shorttext synchronized" lang="en">EDM entity type</p>
    "! @raising   /iwcor/cx_od_edm_error | <p class="shorttext synchronized" lang="en">EDM error</p>
    CLASS-METHODS get_path_entity_type
      IMPORTING
        !it_path              TYPE /iwcor/if_od_uri=>property_path_t
      RETURNING
        VALUE(ro_entity_type) TYPE REF TO /iwcor/if_od_edm_entity_type
      RAISING
        /iwcor/cx_od_edm_error .
*"* private components of class /IWCOR/CL_OD_HDLR_ROOT
*"* do not include other source files here!!!
    "! <p class="shorttext synchronized" lang="en">Get classname of instance</p>
    "!
    "! @parameter io_object    | <p class="shorttext synchronized" lang="en">Object instance</p>
    "! @parameter rv_classname | <p class="shorttext synchronized" lang="en">Classname</p>
    CLASS-METHODS get_classname
      IMPORTING
        !io_object          TYPE REF TO object
      RETURNING
        VALUE(rv_classname) TYPE string .
    "! <p class="shorttext synchronized" lang="en">Is etag required for request resource?</p>
    "!
    "! @parameter io_uri             | <p class="shorttext synchronized" lang="en">URI information</p>
    "! @parameter rv_etag_required   | <p class="shorttext synchronized" lang="en">Etag required</p>
    "! @raising   /iwcor/cx_od_error | <p class="shorttext synchronized" lang="en">OData error</p>
    METHODS is_etag_required
      IMPORTING
        !io_uri                 TYPE REF TO /iwcor/if_od_uri
      RETURNING
        VALUE(rv_etag_required) TYPE abap_bool
      RAISING
        /iwcor/cx_od_error .
ENDCLASS.



CLASS /IWCOR/CL_OD_HDLR_ROOT IMPLEMENTATION.


  METHOD /iwcor/if_rest_handler~handle.

    handle_with_mode( io_request = io_request io_response = io_response io_context = io_context iv_mode = gcs_handle_modes-complete ).

  ENDMETHOD.                    "/IWCOR/IF_REST_HANDLER~HANDLE


  METHOD check_register_kernel_release.

    DATA lv_kern_rel TYPE thllines-thline.

    rv_registration_check = abap_false.

    CALL FUNCTION 'TH_SAPREL4'
      IMPORTING
        kern_rel = lv_kern_rel.

    " this check is very strict, but currently the only reliable check
    IF lv_kern_rel >= '780'.
      rv_registration_check = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD constructor.
    mo_svc_factory = io_svc_factory.
  ENDMETHOD.                    "CONSTRUCTOR


  METHOD create_with_service_factory.
    CREATE OBJECT ro_root_handler
      EXPORTING
        io_svc_factory = io_svc_factory.
  ENDMETHOD.                    "CREATE_WITH_SERVICE_FACTORY


  METHOD create_with_single_service.
    DATA:
      lo_svc_factory TYPE REF TO /iwcor/cl_od_svc_factory.

    CREATE OBJECT lo_svc_factory.
    lo_svc_factory->register_service(
      iv_name = '*'
      iv_classname = iv_svc_classname
      it_parameter = it_svc_parameter ).
    CREATE OBJECT ro_root_handler
      EXPORTING
        io_svc_factory = lo_svc_factory.
  ENDMETHOD.                    "CREATE_WITH_SINGLE_SERVICE


  METHOD dispatch.

    DATA:
      lo_edm                     TYPE REF TO /iwcor/if_od_edm,
      lo_edm_error               TYPE REF TO /iwcor/cx_od_edm_error,
      lo_preference              TYPE REF TO lcl_preference,
      lo_processor               TYPE REF TO /iwcor/if_od_processor,
      lo_service                 TYPE REF TO /iwcor/if_od_svc,
      lo_uri                     TYPE REF TO /iwcor/if_od_uri,
      ls_conditions              TYPE /iwcor/rest_conditions,
      lt_parameter               TYPE tihttpnvp,
      lv_classname_used_in_macro TYPE string,
      lv_etag                    TYPE /iwcor/rest_etag_s,
      lv_etag_condensed          TYPE string,
      lv_etag_required           TYPE abap_bool,
      lv_handle                  TYPE i,
      lv_method                  TYPE string,
      lv_namespace               TYPE string,
      lv_odata_max_version       TYPE string,
      lv_odata_max_version_float TYPE f,
      lv_odata_version           TYPE string,
      lv_odata_version_float     TYPE f,
      lv_prefer                  TYPE string,
      lv_processed               TYPE abap_bool,
      lv_resource_path           TYPE string,
      lv_service_version         TYPE string,
      lv_service_version_float   TYPE f,
      lv_validate                LIKE LINE OF lo_uri->custom_query_options,
      lv_value                   TYPE string,
      lv_version                 TYPE string,
      lx_rest_parser_error       TYPE REF TO /iwcor/cx_rest_parser_error.


    " authority check
    start_rt_measurement io_context lv_handle me 'HANDLE_AUTHORITY_CHECK'.
    handle_authority_check( iv_service_name ).
    stop_rt_measurement io_context lv_handle.

    " create service
    start_rt_measurement io_context lv_handle mo_svc_factory 'CREATE_SERVICE'.
    lo_service = mo_svc_factory->create_service( iv_service_name ).
    stop_rt_measurement io_context lv_handle.

    IF lo_service IS NOT BOUND.
      RAISE EXCEPTION TYPE /iwcor/cx_od_not_found.
    ENDIF.
    io_context->set_object( iv_name   = /iwcor/cl_od_cntxt=>gc_object_service
                            io_object = lo_service ).

    " Get entity data model
    lo_edm = lo_service->get_entity_data_model( ).

    " Get OData-MaxVersion
    lv_value = io_request->get_header_field( 'OData-MaxVersion' ). "#EC NOTEXT
    IF lv_value IS NOT INITIAL.
      FIND REGEX '^([[:digit:]]+\.[[:digit:]]+)(?:;.*)?$' IN lv_value SUBMATCHES lv_version ##REGEX_POSIX.

      IF sy-subrc = 0.
        lv_odata_max_version = lv_version.
        io_context->set_parameter( iv_name  = /iwcor/cl_od_cntxt=>gc_param_odata_max_version
                                   iv_value = lv_odata_max_version ).

      ELSE.
        RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
          EXPORTING
            textid  = /iwcor/cx_od_version_error=>max_version_cannot_be_parsed
            version = lv_value.

      ENDIF.

    ENDIF.

    " OData-MaxVersion negotiation
    IF lv_odata_max_version IS NOT INITIAL.
      lv_odata_max_version_float = lv_odata_max_version.

      IF lv_odata_max_version_float < /iwcor/if_od_edm=>gc_odata_version_40.
        RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
          EXPORTING
            textid  = /iwcor/cx_od_version_error=>max_version_not_supported
            version = lv_odata_max_version.

      ENDIF.
      "Inheritance of the Version handling V4.01 in Batch (BLI https://sapjira.wdf.sap.corp/browse/ODATALIBRARIES-240
      "Can be released if OData V4.01 is released.
*    ELSE.
*      io_context->get_parameter(
*        EXPORTING
*          iv_name                = '~parent'    " Name
*        IMPORTING
*          ev_value               =  ls_context_batch ).  " Value
*
*      lo_context_batch ?= ls_context_batch-instance.
*      lo_context_batch->get_parameter( EXPORTING iv_name  = '~odata_max_version'
*                                       IMPORTING ev_value = lv_odata_max_version ).
*
*      IF lv_odata_max_version IS NOT INITIAL.
*        lv_odata_max_version_float = lv_odata_max_version.
*        IF lv_odata_max_version_float < /iwcor/if_od_edm=>gc_odata_version_40.
*          RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
*            EXPORTING
*              textid  = /iwcor/cx_od_version_error=>max_version_not_supported
*              version = lv_odata_max_version.
*        ENDIF.
*      ENDIF.
    ENDIF.

    " Get OData-Version
    lv_value = io_request->get_header_field( 'OData-Version' ). "#EC NOTEXT
    IF lv_value IS NOT INITIAL.
      FIND REGEX '^([[:digit:]]+\.[[:digit:]]+)(?:;.*)?$' IN lv_value SUBMATCHES lv_version ##REGEX_POSIX.

      IF sy-subrc = 0.
        lv_odata_version = lv_version.
        io_context->/iwcor/if_rest_context~set_parameter( iv_name = /iwcor/cl_od_cntxt=>gc_param_odata_version iv_value = lv_odata_version ).

      ELSE.
        RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
          EXPORTING
            textid  = /iwcor/cx_od_version_error=>version_cannot_be_parsed
            version = lv_value.

      ENDIF.

    ENDIF.

    " OData-Version negotiation
    IF lv_odata_version IS NOT INITIAL.
      lv_odata_version_float = lv_odata_version.

      IF lv_odata_version_float <> /iwcor/if_od_edm=>gc_odata_version_40 AND
         lv_odata_version_float <> /iwcor/if_od_edm=>gc_odata_version_401.
        RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
          EXPORTING
            textid  = /iwcor/cx_od_version_error=>version_not_supported
            version = lv_odata_version.

      ENDIF.

    ENDIF.

    " Get Service Version
    lv_service_version = lo_service->get_version( ).

    " Service Version negotiation
    IF lv_service_version IS NOT INITIAL.
      lv_service_version_float = lv_service_version.

      IF lv_service_version_float <> /iwcor/if_od_edm=>gc_odata_version_40 AND
         lv_service_version_float <> /iwcor/if_od_edm=>gc_odata_version_401.
        RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
          EXPORTING
            textid  = /iwcor/cx_od_version_error=>version_not_supported
            version = lv_odata_version.

      ENDIF.

    ENDIF.


    " Set URI
    start_rt_measurement_static io_context lv_handle '/IWCOR/CL_OD_URI_FACADE' 'PARSE_URI'.

    TRY.
        lv_resource_path = io_context->get_resource_path( ).
        lt_parameter     = io_request->get_uri_query_parameters( ).
        lv_method        = io_request->get_method( ).

        lo_uri = /iwcor/cl_od_uri_facade=>parse_uri(
          io_edm             = lo_edm
          iv_resource_path   = lv_resource_path
          it_query_parameter = lt_parameter
          iv_http_method     = lv_method
          io_context         = io_context ).

      CATCH /iwcor/cx_od_edm_error INTO lo_edm_error.
        stop_rt_measurement io_context lv_handle.
        RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error
          EXPORTING
            previous = lo_edm_error.

      CLEANUP.
        IF lo_uri IS BOUND.
          io_context->set_object( iv_name = /iwcor/cl_od_cntxt=>gc_object_uri io_object = lo_uri ).
        ENDIF.
        stop_rt_measurement io_context lv_handle.

    ENDTRY.
    stop_rt_measurement io_context lv_handle.

    io_context->set_object( iv_name   = /iwcor/cl_od_cntxt=>gc_object_uri
                            io_object = lo_uri ).
    io_context->set_parameter( iv_name  = 'query_parameters'
                               iv_value = lt_parameter ).   "#EC NOTEXT


    " Set validation flag for primitive type value serialization
    READ TABLE lo_uri->custom_query_options WITH TABLE KEY name = 'sap-no-validate' INTO lv_validate TRANSPORTING value. "#EC NOTEXT
    TRANSLATE lv_validate-value TO UPPER CASE.
    IF lv_validate-value = abap_true OR lv_validate-value = 'TRUE'.
      odedm_data=>validate = abap_false.
    ENDIF.

    " Header OData-Isolation; V4.0 protocol/8.2.6
    lv_value = io_request->get_header_field( 'OData-Isolation' ). "#EC NOTEXT
    IF lv_value IS NOT INITIAL.
      IF to_lower( lv_value )  = 'snapshot'.                "#EC NOTEXT
        RAISE EXCEPTION TYPE /iwcor/cx_od_precond_failed.

      ELSE.
        RAISE EXCEPTION TYPE /iwcor/cx_od_bad_request_info
          EXPORTING
            textid = /iwcor/cx_od_bad_request_info=>invalid_isolation_value.

      ENDIF.

    ENDIF.

    " Prefer header handling
    lv_prefer = io_request->get_header_field( 'Prefer' ).   "#EC NOTEXT
    CREATE OBJECT lo_preference
      EXPORTING
        iv_header_prefer = lv_prefer.
    io_context->set_object( iv_name   = /iwcor/cl_od_cntxt=>gc_object_preference
                            io_object = lo_preference ).

    " Get service specific processor for the given context
    lo_processor = lo_service->get_processor( io_context ).
    IF lo_processor IS NOT BOUND.
      RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error.
    ENDIF.


    " Extract conditions from request
    TRY.
        ls_conditions = /iwcor/cl_rest_cond_utils=>get_conditions_single( io_request ).

      CATCH BEFORE UNWIND /iwcor/cx_rest_parser_error INTO lx_rest_parser_error.
        RAISE EXCEPTION TYPE /iwcor/cx_od_bad_request
          EXPORTING
            previous = lx_rest_parser_error.

    ENDTRY.

    io_context->set_parameter( iv_name  = /iwcor/cl_od_cntxt=>gc_param_conditions
                               iv_value = ls_conditions ).

    " Is etag required for current request resource?
    lv_etag_required = is_etag_required( lo_uri ).
    io_context->set_parameter( iv_name  = /iwcor/cl_od_cntxt=>gc_param_is_etag_required
                               iv_value = lv_etag_required ).

    IF ls_conditions IS INITIAL.
      " No etags in modification request but etag required -> 428 Precondition Required
      IF  lv_etag_required = abap_true
      AND ( lv_method = /iwcor/if_rest_request=>gc_method_put
         OR lv_method = /iwcor/if_rest_request=>gc_method_delete
         OR lv_method = /iwcor/if_rest_request=>gc_method_merge
         OR lv_method = /iwcor/if_rest_request=>gc_method_patch
         OR lv_method = /iwcor/if_rest_request=>gc_method_post ).

        RAISE EXCEPTION TYPE /iwcor/cx_od_precond_required.

      ENDIF.

    ELSE.
      lv_processed = handle_conditions( io_request  = io_request
                                        io_response = io_response
                                        io_context  = io_context ).

    ENDIF.


    " Request processing
    IF lv_processed <> abap_true.
      start_rt_measurement io_context lv_handle lo_processor 'PROCESS'.
      lo_processor->process( io_request  = io_request
                             io_response = io_response
                             io_context  = io_context ).
      stop_rt_measurement io_context lv_handle.

    ENDIF.

    " Post processing
    post_process( io_request  = io_request
                  io_response = io_response
                  io_context  = io_context ).

  ENDMETHOD.                    "DISPATCH


  METHOD get_classname.
    DATA:
      lv_classname TYPE string.
    lv_classname = cl_abap_classdescr=>get_class_name( io_object ).
    FIND REGEX '^\\[[:alpha:]]+=(.*)$' IN lv_classname SUBMATCHES rv_classname ##REGEX_POSIX.
    IF sy-subrc <> 0.
      rv_classname = lv_classname.
    ENDIF.
  ENDMETHOD.                    "GET_CLASSNAME


  METHOD get_path_entity_type.

    DATA:
      lv_lines        TYPE i,
      lo_property     TYPE REF TO /iwcor/if_od_uri_prop,
      lo_property_nav TYPE REF TO /iwcor/if_od_uri_prop_nav,
      lo_typed        TYPE REF TO /iwcor/if_od_edm_typed.

    lv_lines = lines( it_path ).
    WHILE lv_lines > 0.
      READ TABLE it_path INDEX lv_lines INTO lo_property.
      lv_lines = lv_lines - 1.
      IF lo_property->kind = /iwcor/if_od_edm_type=>kind_navigation.
        lo_property_nav ?= lo_property.
        lo_typed ?= lo_property_nav->/iwcor/if_od_uri_prop~property->get_type( ).
        TRY.
            ro_entity_type ?= lo_typed->get_type( ).
          CATCH cx_sy_move_cast_error.                  "#EC NO_HANDLER
        ENDTRY.
        EXIT.
      ENDIF.
    ENDWHILE.

  ENDMETHOD.


  METHOD get_service_name.

    " Service resolution based on optional application root path.
    " If no application root is supplied, ~script_name_expanded is used as the application root.
    " The service name can be resolved out of multiple path segments (1 to 9).
    " If the number of service name segments is not supplied, the service name is the last segment of the application root.
    DATA lv_script_name_expanded TYPE string.
    DATA lv_path_expanded        TYPE string.
    DATA lv_svc_root             TYPE string.
    DATA lv_regex                TYPE string.
    DATA lv_svc_segments_nsp     TYPE c.
    DATA lv_svc_segments_name    TYPE c.
    DATA lv_svc_namespace        TYPE string.
    IF iv_script_name_expanded CS iv_svc_root AND sy-fdpos = 0 AND " Script name expanded must start with root path
       iv_svc_segments >= 0 AND iv_svc_segments <= 9 AND           " No. of segments must be between 0 and 9
       iv_svc_segments_limit >= 0 AND                              " No. of segments limit must be >= 0
       iv_svc_segments_limit <= iv_svc_segments.                   " No. of segments limit must be <= No. of segments
      IF iv_script_segment_parameter IS INITIAL.
        lv_script_name_expanded = iv_script_name_expanded.
      ELSE.
        CONCATENATE iv_script_name_expanded ';' iv_script_segment_parameter INTO lv_script_name_expanded.
      ENDIF.
      CONCATENATE lv_script_name_expanded iv_path_info INTO lv_path_expanded.
      IF iv_svc_root = ''.
        lv_svc_root = iv_script_name_expanded.
      ELSE.
        lv_svc_root = iv_svc_root.
      ENDIF.
      IF iv_svc_segments = 0.
        FIND REGEX '^((?:/[^/]+)*)(/[^/]+)$' IN lv_svc_root IGNORING CASE SUBMATCHES lv_svc_root ##REGEX_POSIX. " Cut off last segment from root path -> service name in next regex
        lv_svc_segments_nsp = 0.
        lv_svc_segments_name = 1.
      ELSE.
        lv_svc_segments_nsp = iv_svc_segments - 1.
        lv_svc_segments_name = iv_svc_segments - lv_svc_segments_nsp.
      ENDIF.

      CONCATENATE '^' lv_svc_root '((?:/[^/]+){' lv_svc_segments_nsp '})(/[^/]+){' lv_svc_segments_name '}(/.*)?' INTO lv_regex.

      FIND REGEX lv_regex IN lv_path_expanded IGNORING CASE SUBMATCHES lv_svc_namespace ev_service_name ev_resource_path ##REGEX_POSIX.

      IF sy-subrc = 0.
        CONCATENATE lv_svc_root lv_svc_namespace ev_service_name '/' INTO ev_service_root.
        SPLIT ev_service_name AT ';' INTO ev_service_name ev_service_segment_data.
        REPLACE iv_script_name_expanded IN ev_service_root WITH iv_script_name. " REPLACEMENT OFFSET lv_offset.
        IF lv_svc_namespace IS INITIAL.
          ev_service_name = ev_service_name+1. " Remove leading slash
        ELSE.
          CONCATENATE lv_svc_namespace+1 ev_service_name INTO ev_service_name.
        ENDIF.
      ENDIF.

      IF ev_resource_path CS '%24'.
        REPLACE '%24' IN ev_resource_path WITH '$'.
      ENDIF.

    ENDIF.



  ENDMETHOD.                    "GET_SERVICE_NAME


  METHOD handle_authority_check.                            "#EC NEEDED
  ENDMETHOD.                    "HANDLE_AUTHORITY_CHECK


  METHOD handle_conditions.

    DATA:
      lv_resource_path           TYPE string,
      lo_edm                     TYPE REF TO /iwcor/if_od_edm,
      lt_segment                 TYPE string_table,
      lo_service                 TYPE REF TO /iwcor/if_od_svc,
      lo_processor               TYPE REF TO /iwcor/if_od_processor,
      ls_conditions              TYPE /iwcor/rest_conditions,
      lv_etag_required           TYPE abap_bool,
      lv_method                  TYPE string,
      lv_handle                  TYPE i,
      lv_conditional_status      TYPE i,
      lv_existing                TYPE abap_bool VALUE abap_true,
      lv_modification_date       TYPE timestamp,
      ls_etag                    TYPE /iwcor/rest_etag_s,
      lv_status                  TYPE i,
      lo_request                 TYPE REF TO /iwcor/if_rest_request,
      lo_response                TYPE REF TO /iwcor/if_rest_response,
      lo_entity                  TYPE REF TO /iwcor/if_rest_entity,
      ld_conditional_info        TYPE REF TO /iwcor/if_od_cntxt=>conditional_info_s,
      lo_not_found               TYPE REF TO /iwcor/cx_od_not_found, "#EC NEEDED
      lo_http_error              TYPE REF TO /iwcor/cx_od_http_error,
      lv_http_error_class        TYPE abap_abstypename,
      lo_new_exception           TYPE REF TO /iwcor/cx_od_http_error,
      lo_error                   TYPE REF TO cx_root,
      lo_uri                     TYPE REF TO /iwcor/if_od_uri,
      lo_uri_orig                TYPE REF TO /iwcor/if_od_uri,
      lv_uri                     TYPE string,
      lt_parameter               TYPE tihttpnvp,
      lt_header_field            TYPE tihttpnvp,
      lv_classname_used_in_macro TYPE string,
      ls_bound_action_info       TYPE /iwcor/if_od_uri=>bound_action_info_s.

    " Get service, processor and conditions
    lo_service = io_context->get_service( ).
    lo_processor = lo_service->get_processor( io_context ).
    ls_conditions = io_context->get_conditions( ).

    " http method
    lv_method = io_request->get_method( ).

    " set conditional info in context
    CREATE DATA ld_conditional_info.
    CASE lv_method.
      WHEN /iwcor/if_rest_message=>gc_method_get.
        ld_conditional_info->operation = /iwcor/if_od_svc_proc=>gc_operation_read.
      WHEN /iwcor/if_rest_message=>gc_method_put OR
           /iwcor/if_rest_message=>gc_method_merge OR
           /iwcor/if_rest_message=>gc_method_patch.
        ld_conditional_info->operation = /iwcor/if_od_svc_proc=>gc_operation_update.
      WHEN /iwcor/if_rest_message=>gc_method_delete.
        ld_conditional_info->operation = /iwcor/if_od_svc_proc=>gc_operation_delete.
      WHEN /iwcor/if_rest_message=>gc_method_post.
        lo_uri = io_context->get_uri( ).
        ls_bound_action_info = lo_uri->bound_action_info.
        IF ls_bound_action_info IS NOT INITIAL.
          ld_conditional_info->operation = /iwcor/if_od_svc_proc=>gc_operation_boundaction.
          lv_resource_path = io_context->get_resource_path( ).
          SPLIT lv_resource_path AT '/' INTO TABLE lt_segment.
          sy-tabix = lines( lt_segment ).
          DELETE lt_segment INDEX sy-tabix.
          CONCATENATE LINES OF lt_segment INTO lv_resource_path SEPARATED BY '/'.
          lo_service = io_context->get_service( ).
          lo_edm = lo_service->get_entity_data_model( ).
          lo_uri = /iwcor/cl_od_uri_facade=>parse_uri(
              io_edm             = lo_edm
              iv_resource_path   = lv_resource_path
              iv_http_method     = 'GET'
              io_context         = io_context ).
          lo_uri_orig = io_context->get_uri( ).
          io_context->set_object( iv_name = /iwcor/cl_od_cntxt=>gc_object_uri io_object = lo_uri ).
        ELSE.
          RAISE EXCEPTION TYPE /iwcor/cx_od_proc_error
            EXPORTING
              textid = /iwcor/cx_od_proc_error=>conditional_header_not_allowed
              method = lv_method.
        ENDIF.

      WHEN OTHERS.
        RAISE EXCEPTION TYPE /iwcor/cx_od_proc_error
          EXPORTING
            textid = /iwcor/cx_od_proc_error=>conditional_header_not_allowed
            method = lv_method.
    ENDCASE.
    ld_conditional_info->request = io_request.
    ld_conditional_info->incomplete = abap_false.
    io_context->set_data( iv_name = /iwcor/cl_od_cntxt=>gc_param_conditional_info id_value = ld_conditional_info ).

    " request
    IF lv_method = 'GET' OR lv_method = 'HEAD'.
      lo_request = io_request.
    ELSE.
      lt_parameter = io_request->get_header_fields( ).
      lo_request = /iwcor/cl_rest_message_builder=>create_request(
        iv_method = 'GET'
        iv_uri = lv_uri
        it_header_field = lt_parameter ).
    ENDIF.

    " response
    lo_response = /iwcor/cl_rest_message_builder=>create_response( ).

    " conditional get request in order to retrieve current "ETag" and "Last-Modified" header
    TRY.
        start_rt_measurement io_context lv_handle lo_processor 'PROCESS'.
        lo_processor->process( io_request = lo_request io_response = lo_response io_context = io_context ).
        stop_rt_measurement io_context lv_handle.
        lv_conditional_status = lo_response->get_status( ).
        IF lv_conditional_status = /iwcor/cl_rest_status_code=>gc_client_error_not_found.
          lv_existing = abap_false.
        ELSE.
          lv_existing = abap_true.
        ENDIF.
        ls_etag = lo_response->get_etag( ).
        lo_entity = lo_response->get_entity( ).
        IF lo_entity IS BOUND.
          lv_modification_date = lo_entity->get_modification_date( ).
        ENDIF.
      CATCH /iwcor/cx_od_not_found INTO lo_not_found.
        " not existing resources are considered in handle_conditions
        lv_conditional_status = /iwcor/cl_rest_status_code=>gc_client_error_not_found.
        lv_existing = abap_false.
      CATCH /iwcor/cx_od_http_error INTO lo_http_error.
        " forward http error exception (to get this source position in the stacktrace)
        lv_http_error_class = cl_abap_classdescr=>get_class_name( lo_http_error ).
        CREATE OBJECT lo_new_exception TYPE (lv_http_error_class)
          EXPORTING
            previous = lo_http_error.
        RAISE EXCEPTION lo_new_exception.
      CATCH cx_root INTO lo_error.
        RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error
          EXPORTING
            previous = lo_error.
    ENDTRY.

    " restore context
    io_context->remove_parameter( /iwcor/cl_od_cntxt=>gc_param_conditional_info ).
    IF lo_uri_orig IS BOUND.
      io_context->set_object( iv_name  = /iwcor/cl_od_cntxt=>gc_object_uri io_object = lo_uri_orig ).
    ENDIF.

    " Check if If-Match header is required for request resource
    lv_etag_required = io_context->is_etag_required( ).
    IF lv_etag_required = abap_true AND
       ( lv_existing = abap_true AND ls_conditions-if_match IS INITIAL ) AND
       ( lv_method = /iwcor/if_rest_request=>gc_method_put OR
         lv_method = /iwcor/if_rest_request=>gc_method_delete OR
         lv_method = /iwcor/if_rest_request=>gc_method_merge OR
         lv_method = /iwcor/if_rest_request=>gc_method_patch ).
      RAISE EXCEPTION TYPE /iwcor/cx_od_precond_required.
    ENDIF.

    " handle conditions
    IF lv_status IS INITIAL.
      /iwcor/cl_rest_cond_utils=>handle_conditions(
        EXPORTING
          iv_method            = lv_method
          iv_existing          = lv_existing
          is_etag              = ls_etag
          iv_modification_date = lv_modification_date
          iv_status_code       = lv_conditional_status
        IMPORTING
          ev_status_code       = lv_status
        CHANGING
          cs_conditions        = ls_conditions ).
    ENDIF.

    " now interpret the result of the conditional handling
    IF lv_status IS INITIAL.
      " Reuse response from conditional request (otherwise leave request processing to caller)
      IF ld_conditional_info->incomplete = abap_false AND ( lv_method = 'GET' OR lv_method = 'HEAD' ).
        start_rt_measurement_static io_context lv_handle '/IWCOR/CL_REST_COND_UTILS' 'COPY_RESPONSE'.
        /iwcor/cl_rest_cond_utils=>copy_response( EXPORTING io_source_response = lo_response io_target_response = io_response ).
        stop_rt_measurement io_context lv_handle.
        rv_processed = abap_true.
      ENDIF.
    ELSE.
      " lv_status code can only be 304, 412 or 404
      CASE lv_status.
        WHEN /iwcor/cl_rest_status_code=>gc_redirection_not_modified.
          IF lo_response IS BOUND.
            lt_header_field = lo_response->get_header_fields( ).
          ENDIF.
          RAISE EXCEPTION TYPE /iwcor/cx_od_not_modified
            EXPORTING
              header_fields = lt_header_field.
        WHEN /iwcor/cl_rest_status_code=>gc_client_error_precond_failed.
          RAISE EXCEPTION TYPE /iwcor/cx_od_precond_failed.
        WHEN /iwcor/cl_rest_status_code=>gc_client_error_not_found.
          RAISE EXCEPTION TYPE /iwcor/cx_od_not_found.
        WHEN OTHERS.
          RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error.
      ENDCASE.
    ENDIF.

  ENDMETHOD.


  METHOD handle_debug.
    DATA:
      ld_runtime_measurements TYPE REF TO /iwcor/cl_od_cntxt=>runtime_measurement_t,
      ld_runtime_measurement  TYPE REF TO /iwcor/cl_od_cntxt=>runtime_measurement_s,
      ls_runtime_measurement  TYPE /iwcor/cl_od_cntxt=>runtime_measurement_s,
      lo_rest_context         TYPE REF TO /iwcor/if_rest_context,
      lv_time                 TYPE i,
      lo_debug                TYPE REF TO /iwcor/if_rest_handler.

    " get parent context
    TRY.
        lo_rest_context ?= io_context->get_object( /iwcor/cl_od_cntxt=>gc_object_parent ).
      CATCH cx_sy_move_cast_error.
        CLEAR lo_rest_context.
    ENDTRY.

    " get runtime measurement table
    io_context->/iwcor/if_rest_context~get_parameter( EXPORTING iv_name = 'runtime_measurements' IMPORTING ev_value = ld_runtime_measurements ). "#EC NOTEXT
    IF ld_runtime_measurements IS NOT BOUND.
      CREATE DATA ld_runtime_measurements.
      io_context->/iwcor/if_rest_context~set_parameter( iv_name = 'runtime_measurements' iv_value = ld_runtime_measurements ). "#EC NOTEXT
    ELSE.
      " stop all pending runtime measurements
      GET RUN TIME FIELD lv_time.
      LOOP AT ld_runtime_measurements->* REFERENCE INTO ld_runtime_measurement.
        IF ld_runtime_measurement->time_stop IS INITIAL.
          ld_runtime_measurement->time_stop = lv_time.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF lo_rest_context IS BOUND.
      " stop runtime measurement for root handler
      GET RUN TIME FIELD ls_runtime_measurement-time_stop.
      lo_rest_context->get_parameter( EXPORTING iv_name = 'root_handler_time_start' IMPORTING ev_value = ls_runtime_measurement-time_start ). "#EC NOTEXT
      ls_runtime_measurement-classname = '/IWCOR/CL_OD_HDLR_ROOT'. "#EC NOTEXT
      ls_runtime_measurement-method = '/IWCOR/IF_REST_HANDLER~HANDLE'. "#EC NOTEXT
      INSERT ls_runtime_measurement INTO TABLE ld_runtime_measurements->*.
      " stop runtime measurement for http handler
      GET RUN TIME FIELD ls_runtime_measurement-time_stop.
      lo_rest_context->get_parameter( EXPORTING iv_name = 'http_handler_time_start' IMPORTING ev_value = ls_runtime_measurement-time_start ). "#EC NOTEXT
      ls_runtime_measurement-classname = '/IWCOR/CL_OD_HDLR_HTTP'. "#EC NOTEXT
      ls_runtime_measurement-method = 'IF_HTTP_EXTENSION~HANDLE_REQUEST'. "#EC NOTEXT
      INSERT ls_runtime_measurement INTO TABLE ld_runtime_measurements->*.
    ENDIF.

    " create handler and dispatch
    CREATE OBJECT lo_debug TYPE /iwcor/cl_od_hdlr_debug.
    lo_debug->handle( io_request = io_request io_response = io_response io_context = io_context ).
  ENDMETHOD.                    "HANDLE_DEBUG


  METHOD handle_error.
    DATA:
*      lv_format TYPE string,
*      lv_header_accept TYPE string,
      lv_content_type  TYPE string,
*      lt_content_type TYPE string_table,
*      lo_parser_error TYPE REF TO /iwcor/cx_rest_parser_error,
      lv_status_code   TYPE i,
      lo_entity        TYPE REF TO /iwcor/if_rest_entity,
      lo_exception     TYPE REF TO cx_root,
      lo_error         TYPE REF TO /iwcor/cx_od_error,
      lo_http_error    TYPE REF TO /iwcor/cx_od_http_error,
      lv_error_binary  TYPE xstring,
      lo_vsi_error     TYPE REF TO /iwcor/cx_od_vsi_error,
      lo_error_message TYPE REF TO /iwcor/cx_od_error_message,
      lo_od_exception  TYPE REF TO /iwcor/cx_od_exception.  "#EC NEEDED

    " http status code
    TRY.
        " http error
        lo_http_error ?= io_error.
        lv_status_code = lo_http_error->get_http_status_code( ).
      CATCH cx_sy_move_cast_error.
        TRY.
            " vsi error
            lo_vsi_error ?= io_error.
            CASE lo_vsi_error->textid.
              WHEN /iwcor/cx_od_vsi_error=>infection OR /iwcor/cx_od_vsi_error=>content_scanning_failed.
                lv_status_code = /iwcor/cl_rest_status_code=>gc_client_error_bad_request.
              WHEN OTHERS.
                lv_status_code = /iwcor/cl_rest_status_code=>gc_server_error_internal.
            ENDCASE.
          CATCH cx_sy_move_cast_error.
            lv_status_code = /iwcor/cl_rest_status_code=>gc_server_error_internal.
        ENDTRY.
    ENDTRY.

    " find error
    lo_exception = lo_error = io_error.
    WHILE lo_exception->previous IS BOUND.
      lo_exception = lo_exception->previous.
      TRY.
          lo_error_message ?= lo_exception.
          lo_error = lo_error_message.
          " the first error message wins
          EXIT.
        CATCH cx_sy_move_cast_error.
          TRY.
              lo_od_exception ?= lo_exception.
            CATCH cx_sy_move_cast_error.
              TRY.
                  lo_error ?= lo_exception.
                CATCH cx_sy_move_cast_error.
                  CONTINUE.
              ENDTRY.
          ENDTRY.
      ENDTRY.
    ENDWHILE.

    " negotiate content type
*    lv_format = io_request->get_uri_query_parameter( iv_name = '$format' iv_encoded = abap_false ).
*    CASE lv_format.
*      WHEN /iwcor/if_od_uri=>gc_format_xml.
*        lv_content_type = /iwcor/if_rest_media_type=>gc_appl_xml.
*      WHEN /iwcor/if_od_uri=>gc_format_json.
*        lv_content_type = /iwcor/if_rest_media_type=>gc_appl_json.
*      WHEN OTHERS.
*        APPEND /iwcor/if_rest_media_type=>gc_appl_xml  TO lt_content_type.
*        APPEND /iwcor/if_rest_media_type=>gc_appl_json TO lt_content_type.
*        lv_header_accept = io_request->get_header_field( if_http_header_fields=>accept ).
*        TRY.
*            lv_content_type = /iwcor/cl_rest_http_utils=>negotiate_content_type(
*              iv_header_accept          = lv_header_accept
*              it_supported_content_type = lt_content_type ).
*          CATCH /iwcor/cx_rest_parser_error INTO lo_parser_error.
*            lv_content_type = /iwcor/if_rest_media_type=>gc_appl_xml.
*        ENDTRY.
*    ENDCASE.
    " at the moment only JSON error responses are supported
    lv_content_type = /iwcor/if_rest_media_type=>gc_appl_json.

    " write response entity
    lo_entity = io_response->create_entity( ).
    lv_error_binary = lo_error->serialize( lv_content_type ).
    lo_entity->set_binary_data( lv_error_binary ).
    CONCATENATE lv_content_type ';odata.metadata=minimal' INTO lv_content_type.
    lo_entity->set_content_type( lv_content_type ).
    lo_entity->set_content_language( sy-langu ).
    " error responses are defined in odata version 4.0
    io_response->set_header_field( iv_name = 'OData-Version' iv_value = '4.0' ). "#EC NOTEXT
    IF lv_status_code = /iwcor/cl_rest_status_code=>gc_client_error_precond_reqrd.
      io_response->set_status( iv_status = lv_status_code iv_reason_phrase = 'Precondition Required' ). "#EC NOTEXT
    ELSE.
      io_response->set_status( lv_status_code ).
    ENDIF.

  ENDMETHOD.                    "HANDLE_ERROR


  METHOD handle_exception.
    DATA:
      lo_error TYPE REF TO /iwcor/cx_od_error.

    IF io_exception->previous IS BOUND.
      TRY.
          lo_error ?= io_exception->previous.
        CATCH cx_sy_move_cast_error.
          CREATE OBJECT lo_error TYPE /iwcor/cx_od_internal_error
            EXPORTING
              previous = io_exception.
      ENDTRY.
    ELSE.
      CREATE OBJECT lo_error TYPE /iwcor/cx_od_internal_error
        EXPORTING
          previous = io_exception.
    ENDIF.
    handle_error( io_request = io_request io_response = io_response io_error = lo_error ).
    ro_error = lo_error.
  ENDMETHOD.                    "HANDLE_EXCEPTION


  METHOD handle_exception_vsi.
    DATA:
      lo_vsi_error TYPE REF TO /iwcor/cx_od_vsi_error.

    CASE io_exception->textid.
      WHEN cx_vsi=>virus_exception.
        CREATE OBJECT lo_vsi_error
          EXPORTING
            textid   = /iwcor/cx_od_vsi_error=>infection
            previous = io_exception.
      WHEN cx_vsi=>scanner_error.
        CREATE OBJECT lo_vsi_error
          EXPORTING
            textid   = /iwcor/cx_od_vsi_error=>content_scanning_failed
            previous = io_exception.
      WHEN OTHERS.
        CREATE OBJECT lo_vsi_error
          EXPORTING
            previous = io_exception.
    ENDCASE.
    handle_error( io_request = io_request io_response = io_response io_error = lo_vsi_error ).
    ro_error = lo_vsi_error.
  ENDMETHOD.                    "HANDLE_EXCEPTION_VSI


  METHOD handle_with_mode.

    DATA:
      lv_time                        TYPE i,
      lv_scheme_authority            TYPE string,
      lv_script_name_absolute        TYPE string,
      lv_query_string                TYPE string,
      lv_resource_path               TYPE string,
      lv_path_info                   TYPE string,
      lv_location                    TYPE string,
      lv_service_root                TYPE string,
      lv_service_root_absolute       TYPE string,
      lv_service_name                TYPE string,
      lv_service_segment_data        TYPE string,
      lv_script_name                 TYPE string,
      lv_script_name_expanded        TYPE string,
      lo_context                     TYPE REF TO /iwcor/if_od_cntxt,
      lv_query_parameter             TYPE string,
      ld_query_parameter             TYPE REF TO ihttpnvp,
      lt_query_parameter             TYPE tihttpnvp,
      lv_debug                       TYPE abap_bool VALUE abap_false,
      lt_header_field                TYPE tihttpnvp,
      lo_error                       TYPE REF TO /iwcor/cx_od_error,
      lo_not_modified_exception      TYPE REF TO /iwcor/cx_od_not_modified,
      lo_redirect_location_exception TYPE REF TO /iwcor/cx_od_redirect_location,
      lo_redirection_exception       TYPE REF TO /iwcor/cx_od_redirection,
      lo_vsi_exception               TYPE REF TO cx_vsi,
      lo_exception                   TYPE REF TO cx_no_check,
      lo_od_exception                TYPE REF TO /iwcor/cx_od_exception,
      lo_http_error                  TYPE REF TO /iwcor/cx_od_http_error,
      lo_vsi_error                   TYPE REF TO /iwcor/cx_od_vsi_error,
      lo_root                        TYPE REF TO cx_root,
      " content reference resolution
      lo_entity                      TYPE REF TO /iwcor/if_rest_entity,
      lv_content_id                  TYPE string,
      lv_navigation_path             TYPE string,
      ld_content_reference           TYPE REF TO /iwcor/if_od_cntxt=>content_reference_s,
      ld_content_references          TYPE REF TO /iwcor/if_od_cntxt=>content_reference_t,
      " segment parameter processing
      lt_nv                          TYPE tihttpnvp,
      ls_nv                          TYPE ihttpnvp,
      lt_string                      TYPE string_table,
      ld_string                      TYPE REF TO string,
      lv_http_status_code            TYPE i,
      lo_service                     TYPE REF TO /iwcor/if_od_svc,
      lo_processor                   TYPE REF TO /iwcor/if_od_processor,
      lv_handle                      TYPE i,
      lv_classname_used_in_macro     TYPE string.

    " Check for allowed handle modes
    ASSERT iv_mode = gcs_handle_modes-complete OR iv_mode = gcs_handle_modes-repeat.

    IF iv_mode = gcs_handle_modes-complete.

      " check sap-ds-debug query parameter
      lv_query_parameter = io_request->get_uri_query_parameter( iv_name    = 'sap-ds-debug' "#EC NOTEXT
                                                                iv_encoded = abap_false ).
      IF lv_query_parameter = 'true' OR lv_query_parameter = 'html' OR lv_query_parameter = 'download'
          OR lv_query_parameter = 'json'.
        CALL FUNCTION 'SYSTEM_DEBUG_AUTHORITY_CHECK'
          IMPORTING
            flag_authority = lv_debug.
        IF lv_debug = abap_true.
          GET RUN TIME FIELD lv_time.
          io_context->set_parameter( iv_name  = 'root_handler_time_start' "#EC NOTEXT
                                     iv_value = lv_time ).
        ENDIF.
      ENDIF.

    ENDIF.

    " register handler for application A-MESSAGE's raised by kernel module;
    " registration depends on kernel release
    IF check_register_kernel_release( ).
      CALL 'BEHV_EXEC' ID 'OP' FIELD 5 ID 'ENABLE' FIELD 2.
    ENDIF.

    TRY.

        IF io_context IS NOT BOUND.
          RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error.
        ENDIF.

        IF iv_mode = gcs_handle_modes-complete.

          " remove 'path_info' setting: this is of importance in batch processing:
          " - in a changeset, all operations *SHARE* the same context (due to content-id-refs)
          " - here it is unknown, if we are in a changeset operation or not
          " - in a previous changeset operation, the 'path_info' remains in the shared context, hence is wrong;
          "   therefore we MUST reset this previous 'path_info' and rely on the request URI;
          " - there are two options:
          "   1. set 'path_info' to the actual request *OR*
          "   2. remove the 'path_info' from the context so that the request-URI gets used
          " - Note: In method /IWCOR/CL_OD_HDLR_ROOT->RESOLVE_SERVICE, the 'path_info' setting overrides the request URI setting!!!
          io_context->remove_parameter( 'path_info' ).      "#EC NOTEXT

          " path info
          lv_path_info = io_request->get_uri_path( ).



          " replace content references in path info for batch processing
          FIND REGEX '^(/[^$]*)?\$([^/]+)(/.*)?' IN lv_path_info SUBMATCHES lv_service_root lv_content_id lv_navigation_path ##REGEX_POSIX.
          IF sy-subrc = 0.
            ld_content_references ?= io_context->get_parameter_reference( /iwcor/cl_od_cntxt=>gc_param_content_references ).
            IF ld_content_references IS BOUND.
              READ TABLE ld_content_references->* WITH KEY id = lv_content_id REFERENCE INTO ld_content_reference.

              IF  sy-subrc = 0
              AND ld_content_reference->*-uri IS NOT INITIAL "This means most likely, that a content ID of a "later" operation is referenced
              AND lv_content_id <> 'batch' AND lv_content_id <> 'crossjoin'  " If Content-Id equals to one of these top-level system resources then the
              AND lv_content_id <> 'all'   AND lv_content_id <> 'entity'     " reference remains unchanged. This means that e.g. 'all' cannot be used
              AND lv_content_id <> 'root'  AND lv_content_id <> 'id'         " for content referencing, because the reference for the newly created
              AND lv_content_id <> 'metadata'.                               " resource would be '$all', which is a valid top-level system resource.
                CONCATENATE lv_service_root ld_content_reference->uri lv_navigation_path INTO lv_path_info.
                io_context->set_parameter( iv_name = 'path_info' iv_value = lv_path_info ). "#EC NOTEXT
                " store referenced Content-Id in content reference entry
                lo_entity = io_request->get_entity( ).
                READ TABLE ld_content_references->* WITH TABLE KEY entity = lo_entity REFERENCE INTO ld_content_reference.
                IF sy-subrc = 0.
                  ld_content_reference->ref_id = lv_content_id.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.

          " extract cgi parameter from context
          io_context->get_parameter( EXPORTING iv_name = 'scheme_authority' IMPORTING  ev_value = lv_scheme_authority ). "#EC NOTEXT
          IF lv_scheme_authority IS INITIAL.
            io_context->get_parameter( EXPORTING iv_name = 'script_name_absolute' IMPORTING  ev_value = lv_script_name_absolute ). "#EC NOTEXT
            IF lv_script_name_absolute IS NOT INITIAL.
              FIND REGEX '^((?:[^:/?#]+:)?//[^/?#]*)' IN lv_script_name_absolute SUBMATCHES lv_scheme_authority ##REGEX_POSIX.
            ENDIF.
          ENDIF.

          " find the service name
          resolve_service(
            EXPORTING
              io_request              = io_request
              io_context              = io_context
            IMPORTING
              ev_service_name         = lv_service_name
              ev_service_root         = lv_service_root
              ev_service_segment_data = lv_service_segment_data
              ev_resource_path        = lv_resource_path
              ev_script_name          = lv_script_name
              ev_script_name_expanded = lv_script_name_expanded ).



          " this handler may be skipped
          DATA lv_flow_rc TYPE i.
          io_context->get_parameter( EXPORTING iv_name = 'flow_rc' IMPORTING ev_value = lv_flow_rc ). "#EC NOTEXT
          IF lv_flow_rc > 0.
            RETURN.
          ENDIF.

          IF lv_scheme_authority IS NOT INITIAL.
            CONCATENATE lv_scheme_authority lv_service_root INTO lv_service_root_absolute.
          ELSE.
            lv_service_root_absolute = lv_service_root.
          ENDIF.

          IF lv_service_root IS INITIAL.
            RAISE EXCEPTION TYPE /iwcor/cx_od_not_found.
          ENDIF.

          " create odata context
          CREATE OBJECT lo_context TYPE /iwcor/cl_od_cntxt
            EXPORTING
              iv_debug  = lv_debug
              io_parent = io_context.

          lo_context->set_parameter( iv_name = 'service_root'           iv_value = lv_service_root ). "#EC NOTEXT
          lo_context->set_parameter( iv_name = 'service_root_absolute'  iv_value = lv_service_root_absolute ). "#EC NOTEXT
          lo_context->set_parameter( iv_name = 'service_name'           iv_value = lv_service_name ). "#EC NOTEXT
          lo_context->set_parameter( iv_name = 'resource_path'          iv_value = lv_resource_path ). "#EC NOTEXT
          lo_context->set_parameter( iv_name = 'script_name'            iv_value = lv_script_name ). "#EC NOTEXT
          lo_context->set_parameter( iv_name = 'script_name_expanded'   iv_value = lv_script_name_expanded ). "#EC NOTEXT

          IF lv_resource_path IS INITIAL.
            lt_query_parameter = io_request->get_uri_query_parameters( ).
            IF lt_query_parameter IS INITIAL.
              lv_location = lv_service_root_absolute.
            ELSE.
              LOOP AT lt_query_parameter REFERENCE INTO ld_query_parameter.
                IF lv_query_string IS INITIAL.
                  CONCATENATE ld_query_parameter->name '=' ld_query_parameter->value INTO lv_query_string.
                ELSE.
                  CONCATENATE lv_query_string '&' ld_query_parameter->name '=' ld_query_parameter->value INTO lv_query_string.
                ENDIF.
              ENDLOOP.
              CONCATENATE lv_service_root_absolute '?' lv_query_string INTO lv_location.
            ENDIF.
            RAISE EXCEPTION TYPE /iwcor/cx_od_temporary_redirec
              EXPORTING
                location = lv_location.
          ELSE.

            lo_context->set_parameter( iv_name = /iwcor/cl_od_cntxt=>gc_param_svc_root iv_value = mv_svc_root ).
            lo_context->set_parameter( iv_name = /iwcor/cl_od_cntxt=>gc_param_svc_segments iv_value = mv_svc_segments ).
            lo_context->set_parameter( iv_name = /iwcor/cl_od_cntxt=>gc_param_svc_segments_limit iv_value = mv_svc_segments_limit ).

            "process segment parameters
            IF lv_service_segment_data IS NOT INITIAL.
              SPLIT lv_service_segment_data AT ';' INTO TABLE lt_string.
              LOOP AT lt_string REFERENCE INTO ld_string.
                IF ld_string->* IS NOT INITIAL.
                  SPLIT ld_string->* AT '=' INTO ls_nv-name ls_nv-value.
                ENDIF.
                APPEND ls_nv TO lt_nv.
              ENDLOOP.
              lo_context->set_parameter( iv_name  = 'service_segment_parameter' "#EC NOTEXT
                                         iv_value = lt_nv ).
            ENDIF.

            dispatch(
              iv_service_name = lv_service_name
              io_request  = io_request
              io_response = io_response
              io_context  = lo_context ).
          ENDIF.

        ELSE.

          lo_context ?= io_context.
          IF lo_context IS NOT BOUND.
            RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error.
          ENDIF.

          " Get service
          lo_service ?= lo_context->get_object( /iwcor/cl_od_cntxt=>gc_object_service ).
          IF lo_service IS NOT BOUND.
            RAISE EXCEPTION TYPE /iwcor/cx_od_not_found.
          ENDIF.

          " Get service specific processor for the given context
          lo_processor = lo_service->get_processor( lo_context ).
          IF lo_processor IS NOT BOUND.
            RAISE EXCEPTION TYPE /iwcor/cx_od_internal_error.
          ENDIF.

          " Request processing
          start_rt_measurement lo_context lv_handle lo_processor 'PROCESS'.
          lo_processor->process( io_request = io_request io_response = io_response io_context = lo_context ).
          stop_rt_measurement lo_context lv_handle.

          " Post processing
          post_process( io_request = io_request io_response = io_response io_context = lo_context ).

        ENDIF.

      CATCH /iwcor/cx_od_not_modified INTO lo_not_modified_exception.
        lt_header_field = lo_not_modified_exception->header_fields.
        DELETE lt_header_field WHERE name = if_http_header_fields_sap=>server_protocol.
        DELETE lt_header_field WHERE name = if_http_header_fields=>content_type.
        io_response->set_header_fields( lt_header_field ).
        lv_http_status_code = lo_not_modified_exception->get_http_status_code( ).
        io_response->set_status( lv_http_status_code ).
        lo_root = lo_not_modified_exception.
      CATCH /iwcor/cx_od_redirect_location INTO lo_redirect_location_exception.
        io_response->set_header_field( iv_name = if_http_header_fields=>location iv_value = lo_redirect_location_exception->location ).
        lv_http_status_code = lo_redirect_location_exception->get_http_status_code( ).
        io_response->set_status( lv_http_status_code ).
        lo_root = lo_redirect_location_exception.
      CATCH /iwcor/cx_od_redirection INTO lo_redirection_exception.
        lv_http_status_code = lo_redirection_exception->get_http_status_code( ).
        io_response->set_status( lv_http_status_code ).
        lo_root = lo_redirection_exception.
      CATCH cx_vsi INTO lo_vsi_exception.
        lo_error = handle_exception_vsi( io_request = io_request io_response = io_response io_exception = lo_vsi_exception ).
        IF lo_error IS BOUND.
          lo_root = lo_error.
        ELSE.
          lo_root = lo_vsi_exception.
        ENDIF.
      CATCH cx_no_check INTO lo_exception.
        lo_error = handle_exception( io_request = io_request io_response = io_response io_exception = lo_exception ).
        IF lo_error IS BOUND.
          lo_root = lo_error.
        ELSE.
          lo_root = lo_exception.
        ENDIF.
      CATCH /iwcor/cx_od_exception INTO lo_od_exception.
        CREATE OBJECT lo_error TYPE /iwcor/cx_od_internal_error
          EXPORTING
            previous = lo_od_exception.
        handle_error( io_request = io_request io_response = io_response io_error = lo_error ).
        lo_root = lo_error.
      CATCH /iwcor/cx_od_error INTO lo_error.
        TRY.
            " http error
            lo_http_error ?= lo_error.
          CATCH cx_sy_move_cast_error.
            TRY.
                " vsi error
                lo_vsi_error ?= lo_error.
                CASE lo_vsi_error->textid.
                  WHEN /iwcor/cx_od_vsi_error=>infection OR /iwcor/cx_od_vsi_error=>content_scanning_failed.
                    CREATE OBJECT lo_http_error TYPE /iwcor/cx_od_bad_request
                      EXPORTING
                        previous = lo_error.
                  WHEN OTHERS.
                    CREATE OBJECT lo_http_error TYPE /iwcor/cx_od_internal_error
                      EXPORTING
                        previous = lo_error.
                ENDCASE.
              CATCH cx_sy_move_cast_error.
                CREATE OBJECT lo_http_error TYPE /iwcor/cx_od_internal_error
                  EXPORTING
                    previous = lo_error.
            ENDTRY.
            lo_error = lo_http_error.
        ENDTRY.
        handle_error( io_request = io_request io_response = io_response io_error = lo_error ).
        lo_root = lo_error.
    ENDTRY.

    " request handling finished
    RAISE EVENT handle_finished.

    " handle debug request
    IF lo_context IS BOUND AND lo_context->debug = abap_true.
      lo_context->set_object( iv_name = /iwcor/cl_od_cntxt=>gc_object_error io_object = lo_root ).
      handle_debug( io_request = io_request io_response = io_response io_context = lo_context ).
    ENDIF.

  ENDMETHOD.


  METHOD is_etag_required.

    DATA:
      lr_bound_function    TYPE REF TO /iwcor/if_od_uri=>bound_function_path_info_s,
      lt_parameter_name    TYPE string_table,
      lv_parameter_name    TYPE string,
      lo_binding_parameter TYPE REF TO /iwcor/if_od_edm_parameter,
      lo_function          TYPE REF TO /iwcor/if_od_edm_function,
      lo_return_type       TYPE REF TO /iwcor/if_od_edm_return_type,
      lo_entity_type       TYPE REF TO /iwcor/if_od_edm_entity_type,
      lo_entity_type_path  TYPE REF TO /iwcor/if_od_edm_entity_type,
      lv_lines             TYPE i,
      ld_control_mapping   TYPE REF TO /iwcor/if_od_edm_entity_type=>control_mapping_s,
      lr_property_path     LIKE LINE OF io_uri->property_path,
      lo_property          TYPE REF TO /iwcor/if_od_edm_property,
      ld_property_mapping  TYPE REF TO /iwcor/if_od_edm_mappable=>mapping_s.


    IF io_uri->uri_type = /iwcor/if_od_uri=>gc_type_entity OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_comp_coll OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_comp OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_prim_coll OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_prim OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_prim_val OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_prim_stream OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_media_stream OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_entity OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_entity_set OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_prim OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_prim_stream OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_prim_coll OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_comp OR
       io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_comp_coll.


      IF io_uri->bound_functions_path IS NOT INITIAL.
        lv_lines = lines( io_uri->bound_functions_path ).
        READ TABLE io_uri->bound_functions_path INDEX lv_lines INTO lr_bound_function.
        lo_return_type = lr_bound_function->function->get_return_type( ).
        TRY.
            lo_entity_type ?= lo_return_type->get_type( ).
          CATCH cx_sy_move_cast_error.                  "#EC NO_HANDLER
        ENDTRY.
        IF lr_bound_function->property_path IS NOT INITIAL.
          lo_entity_type_path = get_path_entity_type( lr_bound_function->property_path ).
          IF lo_entity_type_path IS BOUND.
            lo_entity_type = lo_entity_type_path.
          ENDIF.
        ENDIF.

      ELSE.
        IF io_uri->entity_set_info-entity_set IS BOUND.
          lo_entity_type = io_uri->entity_set_info-entity_set->get_entity_type( ).
        ELSEIF io_uri->function_import_info-function_import IS BOUND.
          lt_parameter_name = /iwcor/cl_od_uri_helper=>get_parameter_names( it_parameter = io_uri->function_import_info-parameters ).
          lo_function = io_uri->function_import_info-function_import->get_function( it_parameter_name = lt_parameter_name ).
          lo_return_type = lo_function->get_return_type( ).
          TRY.
              lo_entity_type ?= lo_return_type->get_type( ).
            CATCH cx_sy_move_cast_error.                "#EC NO_HANDLER
          ENDTRY.
        ELSEIF io_uri->singleton_info-singleton IS BOUND.
          lo_entity_type = io_uri->singleton_info-singleton->get_type( ).
        ENDIF.
        IF io_uri->property_path IS NOT INITIAL.
          lo_entity_type_path = get_path_entity_type( io_uri->property_path ).
          IF lo_entity_type_path IS BOUND.
            lo_entity_type = lo_entity_type_path.
          ENDIF.
        ENDIF.
      ENDIF.


      IF lo_entity_type IS BOUND.
        ld_control_mapping = lo_entity_type->get_control_mapping( ).
        IF io_uri->uri_type = /iwcor/if_od_uri=>gc_type_media_stream.
          " does entity type have a mapping for a media ETag?
          IF ld_control_mapping->media_etag IS NOT INITIAL.
            rv_etag_required = abap_true.
          ENDIF.

        ELSEIF io_uri->uri_type = /iwcor/if_od_uri=>gc_type_prop_prim_stream.
          lv_lines = lines( io_uri->property_path ).
          READ TABLE io_uri->property_path INDEX lv_lines INTO lr_property_path.
          lo_property ?= lr_property_path->property.
          ASSERT lo_property IS BOUND.

          ld_property_mapping = lo_property->/iwcor/if_od_edm_mappable~get_mapping( ).
          IF ld_property_mapping IS NOT INITIAL AND ld_property_mapping->etag IS NOT INITIAL.
            rv_etag_required = abap_true.
          ELSEIF ld_control_mapping->etag IS NOT INITIAL.
            rv_etag_required = abap_true.
          ENDIF.

        ELSE.
          " on bound action processing:
          " no etag is required if action is bound to an entity collection (do a check on the binding parameter)
          " [note: URI parsing has already validated the resource path including EDM artefacts, so here we operate on validated EDM data]
          IF ( io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_entity OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_entity_set OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_prim OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_prim_stream OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_prim_coll OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_comp OR
               io_uri->uri_type = /iwcor/if_od_uri=>gc_type_ba_prop_comp_coll ).
            lt_parameter_name = io_uri->bound_action_info-action->get_parameter_names( ).
            lv_parameter_name = lt_parameter_name[ 1 ].
            lo_binding_parameter = io_uri->bound_action_info-action->get_parameter( lv_parameter_name ).
            IF NOT ( lo_binding_parameter->get_type( )->kind = /iwcor/if_od_edm_type=>kind_entity AND
                     lo_binding_parameter->is_collection( ) ).
              IF ld_control_mapping->etag IS NOT INITIAL.
                rv_etag_required = abap_true.
              ENDIF.
            ENDIF.
          ELSE.
            " does entity type have a mapping for an ETag?
            IF ld_control_mapping->etag IS NOT INITIAL.
              rv_etag_required = abap_true.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.


  METHOD post_process.

    DATA:
      lo_service                 TYPE REF TO /iwcor/if_od_svc,
      lv_method                  TYPE string,
      lv_odata_max_version       TYPE string,
      lv_odata_max_version_float TYPE f,
      lv_service_version         TYPE string,
      lv_current_version         TYPE string,
      lv_current_version_float   TYPE f,
      lv_etag_required           TYPE abap_bool,
      ls_etag                    TYPE /iwcor/rest_etag_s,
      lv_status                  TYPE i,
      lo_preference              TYPE REF TO lcl_preference,
      lv_preference_applied      TYPE string.

    lv_method = io_request->get_method( ).
    io_context->get_parameter( EXPORTING iv_name = /iwcor/cl_od_cntxt=>gc_param_is_etag_required IMPORTING ev_value = lv_etag_required ).
    io_context->get_parameter( EXPORTING iv_name = /iwcor/cl_od_cntxt=>gc_param_odata_max_version IMPORTING ev_value = lv_odata_max_version ).
    IF lv_odata_max_version IS NOT INITIAL.
      lv_odata_max_version_float = lv_odata_max_version.
    ENDIF.
    lo_service ?= io_context->get_object( /iwcor/cl_od_cntxt=>gc_object_service ).
    lv_service_version = lo_service->get_version( ).

    " Check if ETag header is required (if not 204 NO CONTENT response status)
    IF lv_method = /iwcor/if_rest_request=>gc_method_get OR
       lv_method = /iwcor/if_rest_request=>gc_method_head.
      IF lv_etag_required = abap_true.
        ls_etag = io_response->get_etag( ).
        lv_status = io_response->get_status( ).
        IF lv_status <> /iwcor/cl_rest_status_code=>gc_success_no_content AND ls_etag IS INITIAL.
          RAISE EXCEPTION TYPE /iwcor/cx_od_conditional_error
            EXPORTING
              textid = /iwcor/cx_od_conditional_error=>etag_missing_in_response.
        ENDIF.
      ENDIF.
    ENDIF.

    " Preference-Applied header handling
    lo_preference ?= io_context->get_preference( ).
    lv_preference_applied = lo_preference->get_preference_applied( ).
    IF lv_preference_applied IS NOT INITIAL.
      io_response->set_header_field( iv_name = 'Preference-Applied' iv_value = lv_preference_applied ). "#EC NOTEXT
    ENDIF.

    " Set OData-Version response header
    lv_current_version = io_response->get_header_field( 'OData-Version' ). "#EC NOTEXT
    lv_current_version_float = lv_current_version.
    IF lv_current_version IS NOT INITIAL AND lv_odata_max_version IS NOT INITIAL AND lv_current_version_float > lv_odata_max_version_float.
      RAISE EXCEPTION TYPE /iwcor/cx_od_version_error
        EXPORTING
          version = lv_current_version.
    ENDIF.
    IF lv_current_version IS INITIAL OR
       lv_current_version_float > /iwcor/if_od_edm=>gc_odata_version_401.
      io_response->set_header_field( iv_name = 'OData-Version' iv_value = lv_service_version ). "#EC NOTEXT
    ENDIF.

  ENDMETHOD.


  METHOD resolve_service.
    DATA:
      ld_value                    TYPE REF TO string,
      lv_path_info                TYPE string,
      lv_script_segment_parameter TYPE string.

    " path info
    ld_value ?= io_context->get_parameter_reference( 'path_info' ). "#EC NOTEXT
    IF ld_value IS BOUND.
      lv_path_info = ld_value->*.
    ELSE.
      lv_path_info = io_request->get_uri_path( ).
    ENDIF.

    " script name
    CLEAR ld_value.
    ld_value ?= io_context->get_parameter_reference( 'script_name' ). "#EC NOTEXT
    IF ld_value IS BOUND.
      ev_script_name = ld_value->*.
    ELSE.
      ev_script_name = io_request->get_header_field( if_http_header_fields_sap=>script_name ).
    ENDIF.

    " script name expanded
    CLEAR ld_value.
    ld_value ?= io_context->get_parameter_reference( 'script_name_expanded' ). "#EC NOTEXT
    IF ld_value IS BOUND.
      ev_script_name_expanded = ld_value->*.
    ELSE.
      ev_script_name_expanded = io_request->get_header_field( if_http_header_fields_sap=>script_name_expanded ).
      IF ev_script_name_expanded IS INITIAL.
        ev_script_name_expanded = ev_script_name.
      ENDIF.
    ENDIF.

    lv_script_segment_parameter = io_request->get_header_field( '~script_segment_parameter' ).

    /iwcor/cl_od_hdlr_root=>get_service_name(
      EXPORTING
        iv_svc_root                 = mv_svc_root
        iv_svc_segments             = mv_svc_segments
        iv_svc_segments_limit       = mv_svc_segments_limit
        iv_path_info                = lv_path_info
        iv_script_name              = ev_script_name
        iv_script_name_expanded     = ev_script_name_expanded
        iv_script_segment_parameter = lv_script_segment_parameter
      IMPORTING
        ev_service_name             = ev_service_name
        ev_service_root             = ev_service_root
        ev_service_segment_data     = ev_service_segment_data
        ev_resource_path            = ev_resource_path ).

  ENDMETHOD.                    "RESOLVE_SERVICE


  METHOD set_resolution_parameter.
    mv_svc_root = iv_svc_root.
    mv_svc_segments = iv_svc_segments.
    mv_svc_segments_limit = iv_svc_segments_limit.
  ENDMETHOD.
ENDCLASS.