class CL_ABAP_BEHV_HANDLER_PROJ definition
  public
  inheriting from CL_ABAP_BEHV_HANDLER_GENERIC
  create public .

public section.

  types:
    begin of t_actv_idxs,
         base_idx type i,
         proj_idx type i,
       end of t_actv_idxs .
  types:
    tt_actv_idxs
    type standard table of t_actv_idxs .
  types:
    tt_actv_idxs_sorted
    type sorted table of t_actv_idxs with unique key base_idx .

  data M_PROJ_ROOT type ABP_ROOT_ENTITY_NAME read-only .

*  data M_BDEF_HEAD type CL_ABAP_BEHV_LOAD=>T_HEAD read-only.
  methods CONSTRUCTOR
    importing
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !IS_DRAFT type ABP_BEHV_FLAG .
  methods PREPARE
    importing
      !KIND type ABP_BEHV_KIND
      value(JOB) type ref to CL_ABAP_BEHV_JOB_BASE
      !SAVER type ref to CL_ABAP_BEHV_SAVER_PROJ optional
      value(PRECEDING_HANDLER) type ref to CL_ABAP_BEHV_HANDLER_PROJ optional .
  class-methods MAP_TO_BASE_JOB
    importing
      !KIND type ABP_BEHV_KIND
      value(JOB) type ref to CL_ABAP_BEHV_JOB_BASE
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !IS_DRAFT type ABP_BEHV_FLAG optional
      !MAP_INSTANCES type SYCHAR01 default 'X'
    exporting
      value(BASE_JOB) type ref to CL_ABAP_BEHV_JOB_BASE
      !ALL_ACTV_IDXS type TT_ACTV_IDXS_SORTED
      !OUT_ACTV_IDXS type TT_ACTV_IDXS .
  class-methods MAP_FROM_BASE_JOB
    importing
      !KIND type ABP_BEHV_KIND
      !BASE_LOG type ref to CL_ABAP_BEHV_LOG
      !BASE_JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !OUT_ACTV_IDXS type TT_ACTV_IDXS optional .
  class-methods MAP_RESULTS_FROM_BASE
    importing
      !KIND type ABP_BEHV_KIND
      !BASE_JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !OUT_ACTV_IDXS type TT_ACTV_IDXS .
  class-methods MAP_FROM_BASE_PARAMS
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_PARAMS type CL_ABAP_BEHV_CTRL=>TT_HANDLER_PARAM
      !BASE_STDPAR type CL_ABAP_BEHAVIOR_HANDLER=>T_STD_PARAM
    exporting
      !PROJ_PARAMS type CL_ABAP_BEHV_CTRL=>TT_HANDLER_PARAM
      !PROJ_STDPAR type CL_ABAP_BEHAVIOR_HANDLER=>T_STD_PARAM .
  class-methods MAP_TO_BASE_RESPONSES
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !PROJ_PARAMS type CL_ABAP_BEHV_CTRL=>TT_HANDLER_PARAM
      !PROJ_STDPAR type CL_ABAP_BEHAVIOR_HANDLER=>T_STD_PARAM
    changing
      !BASE_PARAMS type CL_ABAP_BEHV_CTRL=>TT_HANDLER_PARAM
      !BASE_STDPAR type CL_ABAP_BEHAVIOR_HANDLER=>T_STD_PARAM .
  class-methods CREATE_WITH_OTHER_BDEF
    importing
      !BDEF_NAME type ABP_ROOT_ENTITY_NAME
      !SRC_DATA type ref to DATA
    exporting
      !RES_DATA type ref to DATA .
  class-methods TRANSFER_TO_PROJ_LOG
    importing
      !KIND type IF_ABAP_BEHV_LOG=>T_KIND
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_ENTITY type ABP_ENTITY_NAME
      !BASE_INSTANCES type INDEX TABLE
      !FLAVOR type IF_ABAP_BEHV_LOG=>T_FLAVOR
      !LOG_ALSO_BASE_DATA type SYCHAR01 optional
      !PROJ_LOG type ref to IF_ABAP_BEHV_LOG .
  class-methods TRANSFER_STRUC_TO_PROJ_LOG
    importing
      !KIND type IF_ABAP_BEHV_LOG=>T_KIND
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_RESPONSE type DATA
      !LOG type ref to IF_ABAP_BEHV_LOG .
  methods ADD_AUGMENT_ACTIVITIES
    changing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
  methods ADD_INSTANCE_REFS
    importing
      !INST_REFS type CL_ABAP_BEHV_CTRL=>TT_GENREF
      !BDEF type STRING .
  methods ADD_AUGMENT_FAILED
    importing
      !FAILED type DATA .
  methods LOG_FAILED_AND_RELATED
    importing
      !KIND type IF_ABAP_BEHV_LOG=>T_KIND default IF_ABAP_BEHV_LOG=>FAILED
      !PROJ_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_ROOT type ABP_ROOT_ENTITY_NAME
      !BASE_FAILED type ABP_BEHV_RESPONSE_TAB optional
      !BASE_FAILED_STRUC type ref to DATA optional
      !PROJ_LOG type ref to IF_ABAP_BEHV_LOG optional
      !AUGM_GENREFS type CL_ABAP_BEHV_CTRL=>TT_GENREF
    changing
      !PROJ_FAILED_STRUC type DATA optional .
  methods REMOVE_FAILED_FROM_ACTIVITIES
    importing
      !ENTITY type ABP_ENTITY_NAME
      !FAILED_INSTANCES type INDEX TABLE
      !CLONE_INSTANCES type SYCHAR01 optional
    changing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB
      !INSTANCES_REMOVED type SYCHAR01 optional .
  methods REMOVE_FAILEDS_FROM_ACTIVITIES
    importing
      !FAILED_ENTITIES type CL_ABAP_BEHV_LOG=>TT_LOG_ENTITY
      !CLONE_INSTANCES type SYCHAR01 optional
    exporting
      !INSTANCES_REMOVED type SYCHAR01
    changing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
  methods REMOVE_EMPTY_ACTIVITIES
    changing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
  methods HAS_ACTIVE_REQUEST
    importing
      !PROJ_ACT_IDX type I
    returning
      value(HAS_REQUEST) type SYCHAR01 .
  methods CALL_AUGMENT
    importing
      value(JOB) type ref to CL_ABAP_BEHV_JOB_BASE .
  methods CALL_PRECHECK
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE .
"      !ORIG_ACTV type ref to ABP_BEHV_ACTIVITIES optional
  methods CHECK_AUGMENT
    importing
      !ENTITY_NAME type ABP_ENTITY_NAME
      !OPERATION type ABP_BEHV_OP_MODIFY optional
      !SUB_NAME type ABP_ELEMENT_NAME optional
      !INSTANCES type ref to DATA optional
      !RELATING_BY type ABP_BEHV_RELATING_TAB
    changing
      !CC_OK type SYCHAR01 optional
    returning
      value(DUMMY) type INT4 .

  methods EXECUTE
    redefinition .
protected section.

  types:
    begin of T_AUGM_ACTV_FRESH,
           realnew type abp_behv_activities_tab,  " activity not in original job
           seminew type ABP_BEHV_ACTIVITIES_TAB,       " new instances for activity in original job
         end of T_AUGM_ACTV_FRESH .

  data M_BASE_JOB type ref to CL_ABAP_BEHV_JOB_BASE .
  data M_AUGM_ROOT type ABP_ROOT_ENTITY_NAME .
  data M_AUGM_JOB type ref to CL_ABAP_BEHV_JOB .
  data M_AUGM_ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
  data M_AUGM_GENREFS type CL_ABAP_BEHV_CTRL=>TT_GENREF .
  data M_AUGM_FAILED type ref to DATA .
  data M_AUGM_DONE type SYCHAR01 .
  data:
    M_AUGM_HANDLER_NAMES type hashed table of string with unique key table_line .
  data M_LAST_JOBTOKEN type XSDUUID_RAW .
private section.

  types:
    tt_idx type standard table of i with non-unique key table_line .
  types:
    begin of t_idx_idxs,
      idx  type i,
      idxs type tt_idx,
    end of t_idx_idxs .
  types T_TRACE_HIER type CL_ABAP_BEHV_CTRL=>T_TRACE_HIER .
  types T_TEXT type IF_SXT_TYPES=>TY_MESSAGE .
  types:
    begin of cache_iida_line, " line type for Is Implicit Draft Action chache
      entity type abp_entity_name,
      action type abp_action_name,
      begin of info,
        is_implicit_draft_action type abap_boolean,
        is_draft_action_edit type abap_boolean,
        is_draft_action_activate type abap_boolean,
        is_static_action type abap_boolean,
      end of info,
    end of cache_iida_line .

  data M_ALL_ACTV_IDXS type TT_ACTV_IDXS_SORTED .
  data M_OUT_ACTV_IDXS type TT_ACTV_IDXS .
  data M_SAVER type ref to CL_ABAP_BEHV_SAVER_PROJ .
  data M_AUGM_INFO type TT_AUGM_INFO .
  data M_AUGM_ORIG_INFO type TT_AUGM_INFO .
  data M_AUGM_ORIG_JOB type ref to CL_ABAP_BEHV_JOB_BASE.
  data M_IS_DRAFT type ABP_BEHV_FLAG .
  class-data KEYS_CREATE type TT_KEY_INFO .
  class-data KEYS_UPDATE type TT_KEY_INFO .
  class-data KEYS_CBA_SRC_EXCL_PID type TT_KEY_INFO .
  class-data KEYS_CBA_SRC_INCL_PID type TT_KEY_INFO .
  class-data KEYS_CBA_TRG type TT_KEY_INFO .
  class-data KEYS_FAILED_WITH_CID type TT_KEY_INFO .
  class-data KEYS_FAILED_WITH_CID_REF type TT_KEY_INFO .
  class-data KEYS_CID_CID type TT_KEY_INFO .
  class-data KEYS_CID_CID_REF type TT_KEY_INFO .
  class-data KEYS_ACTION type TT_KEY_INFO .
  constants C_XTRACE like CL_ABAP_BEHV_TRACER=>C_XTRACE value CL_ABAP_BEHV_TRACER=>C_XTRACE ##NO_TEXT.
  " Texts for use in TRACE (intentionally in "Technical English")
  constants TEXT_001 type T_TEXT value 'ABAP Projection Handler' ##NO_TEXT.
  constants TEXT_002 type T_TEXT value 'Augment' ##NO_TEXT.
  constants TEXT_003 type T_TEXT value 'Lock Augment Instances' ##NO_TEXT.
  constants TEXT_004 type T_TEXT value 'Remove Failed Instances' ##NO_TEXT.
  constants TEXT_005 type T_TEXT value 'Add Augment Activities' ##NO_TEXT.

  class-data base_absname  type string.
  class-data intf_absname  type string.
  class-data base_fullname type string.
  class-data intf_fullname type string.
  class-data base_full_ref type ref to data.
  class-data intf_full_ref type ref to data.

  data:
    meta_cache type sorted table of cache_iida_line with unique key entity action .
  data:
    m_augm_actv_in_base type hashed table of i with unique key table_line .
  data:
    m_base_actv_in_augm type hashed table of i with unique key table_line .
  data M_AUGM_ACTV_FRESH type T_AUGM_ACTV_FRESH .
  data M_PROJ_ENAMES type ref to DATA .

  methods EVALUATE_FAILED
    importing
      !FAILED_ENTITIES type CL_ABAP_BEHV_LOG=>TT_LOG_ENTITY
      !BASE_LOG type ref to IF_ABAP_BEHV_LOG optional
      !MASTER_KEYMAP type CL_ABAP_BEHV_CTRL=>TT_RELATION_KEY_MAPPING optional
      !KIND type SYCHAR01
    changing
      !NEW_ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB
      !BASE_INSTANCES_REMOVED type SYCHAR01 .
  methods MERGE_FAILED
    importing
      !SRC type CL_ABAP_BEHV_LOG=>TT_LOG_ENTITY
    changing
      !DST type CL_ABAP_BEHV_LOG=>TT_LOG_ENTITY .
  methods REDUCE_AUG_BY_GLBL_PERM
    importing
      !AUG_ROOT type ABP_ROOT_ENTITY_NAME
      !PERM_JOB type ref to CL_ABAP_BEHV_PJOB
    changing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
  methods REMOVE_FAILED_FROM_INSTANCES
    importing
      !FAILED_INSTANCES type INDEX TABLE
      !CLONE_INSTANCES type SYCHAR01 optional
      !KEYS type TT_KEY_INFO
    changing
      !R_INSTANCES type ref to DATA
      !INSTANCES_REMOVED type SYCHAR01 optional .
  methods PREPARE_AUGMENT
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB .
  methods EXECUTE_AUGMENT .
  methods AUGMENT_BASE_ACTIVITY
    importing
      !BASE_ACTV type ref to ABP_BEHV_ACTIVITIES
    changing
      !SEMINEW_ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
  class-methods INIT_AUGMENT_KEYS .
  methods COLLECT_FAILED_IDXS
    importing
      !FAILED_STRUC type DATA
      !PROJ_ENTITY type ABP_ENTITY_NAME
      !PROJ_DATA type INDEX TABLE
      !PROJ_ENAMES type DATA
    exporting
      !FAILED_IDXS type TT_IDX .
  methods REMOVE_FAILED_IDXS
    changing
      !FAILED_IDXS type TT_IDX
      !BASE_DATA type INDEX TABLE .
  methods PERM_AND_LOCK_NEW_AUG_INSTS
    importing
      !BASE_LOG type ref to IF_ABAP_BEHV_LOG
      !KIND type SYCHAR01
    changing
      !BASE_INSTANCES_REMOVED type SYCHAR01 .
  methods DETERMINE_KEYS_FOR_ACTV
    importing
      !ACTIVITY type ABP_BEHV_ACTIVITIES
      !INSTANCES type INDEX TABLE
    returning
      value(KEYS) type TT_KEY_INFO .
  methods BUILD_FOR_GLOBAL_PERMISSIONS
    importing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB
    returning
      value(JOB) type ref to CL_ABAP_BEHV_PJOB .
  class-methods COMP_NAME_BY_ACTV
    importing
      !ACTV type ABP_BEHV_ACTIVITIES
    returning
      value(COMP_STR) type STRING .
  methods INST_PERM_NEW_AUG_INSTS
    importing
      !BASE_LOG type ref to IF_ABAP_BEHV_LOG
      !KIND type SYCHAR01
    changing
      !BASE_INSTANCES_REMOVED type SYCHAR01 .
  methods BUILD_FOR_INSTANCE_PERMISSIONS
    importing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB
    returning
      value(JOB) type ref to CL_ABAP_BEHV_PJOB .
  methods REDUCE_AUG_BY_INST_PERM
    importing
      !AUG_ROOT type ABP_ROOT_ENTITY_NAME
      !PERM_JOB type ref to CL_ABAP_BEHV_PJOB
    changing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB  ##NEEDED.
  methods IS_IMPLICIT_DRAFT_ACTION
    importing
      !ENTITY type ABP_ENTITY_NAME
      !ACTION type ABP_ACTION_NAME
    returning
      value(IS_IMPLICIT_DRAFT_ACTION) type ABAP_BOOLEAN .
  methods INIT_AUGMENT .
  methods MAP_BASE_FAILED_REPORTED
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE .
  methods MAP_PROJ_INSTANCES
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !PROJ_IDX type I
      !BASE_IDX type I .
  methods BUILD_FOR_LOCK
    importing
      !ROOT type ABP_ROOT_ENTITY_NAME
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB
      !LOG type ref to IF_ABAP_BEHV_LOG
    exporting
      !KEY_MAP type CL_ABAP_BEHV_CTRL=>TT_RELATION_KEY_MAPPING
    returning
      value(JOB) type ref to CL_ABAP_BEHV_JOB .
  methods NEW_META_CACHE_ENTRY
    importing
      !ENTITY type ABP_ENTITY_NAME
      !ACTION type ABP_ACTION_NAME
    returning
      value(CACHE_ENTRY) type ref to CACHE_IIDA_LINE .
  methods IS_DRAFT_EDIT
    importing
      !ENTITY type ABP_ENTITY_NAME
      !ACTION type ABP_ACTION_NAME
    returning
      value(IS_DRAFT_ACTION_EDIT) type ABAP_BOOLEAN .
  methods IS_STATIC_ACTION
    importing
      !ENTITY type ABP_ENTITY_NAME
      !ACTION type ABP_ACTION_NAME
    returning
      value(IS_STATIC_ACTION) type ABAP_BOOLEAN .
  methods GET_META_INFO
    importing
      !ENTITY type ABP_ENTITY_NAME
      !ACTION type ABP_ACTION_NAME
    returning
      value(CACHE_INFO) type CACHE_IIDA_LINE-INFO .
ENDCLASS.



CLASS CL_ABAP_BEHV_HANDLER_PROJ IMPLEMENTATION.


  method IS_STATIC_ACTION.

    read table meta_cache with table key entity = entity action = action
      reference into data(cache_entry).
    if cache_entry is initial.
      cache_entry = new_meta_cache_entry( entity = entity action = action ).
    endif.
    is_static_action = cache_entry->info-is_static_action.

  endmethod.


method log_failed_and_related.

  data l_base_failed like base_failed.
  data l_proj_log    type ref to if_abap_behv_log.
  data op_failed     type abp_behv_op.
  data key_failed    type seckeyname.
  data wh_eq_failed  type string.
  data proj          type ref to data.
  data rela_insts    type tt_entity_instances.

  field-symbols <proj_data>   type index table.
  field-symbols <base_data>   type index table.
  field-symbols <rela>        type cl_abap_behv_load=>t_relat_ext.
  field-symbols <resp>        type abp_behv_response.
  field-symbols <pi>          type data.
  field-symbols <rela_inst>   type t_entity_instances.
  field-symbols <rela_data>   type index table.
  field-symbols <rela_line>   type data.

  " This method is called both by PROJ_HANDLER and PROJ_SAVER.
  " There are technical differences (esp. existence of %CID), but the algorithm is basically shared.
  " - PROJ_HANDLER supplies BASE_FAILED table and PROJ_LOG object
  " - PROJ_SAVER   supplies BASE_FAILED_STRUC and PROJ_FAILED_STRUC
  assert base_failed is supplied equiv base_failed_struc is not supplied.
  assert proj_log    is supplied equiv proj_failed_struc is not supplied.

  if base_failed_struc is not supplied.
    l_base_failed = base_failed.
  else.
    " called from saver with FAILED structure: transform to table
    data(base_enames) = |({ base_root width = 30 pad = '=' }BD)ENTITYNAME| ##NUMBER_OK.
    assign (base_enames) to field-symbol(<base_enames>).
    assign base_failed_struc->* to field-symbol(<base_failed_struc>).
    do.
      assign component sy-index of structure <base_failed_struc> to <base_data>.
      if sy-subrc <> 0.  exit.  endif.  " all done
      check <base_data> is not initial.
      assign component sy-index of structure <base_enames> to field-symbol(<ename>).
      insert value #( root_name = base_root entity_name = <ename> entries = ref #( <base_data> ) )
       into table l_base_failed.
    enddo.
  endif.

  if l_base_failed is initial.
    return.
  endif.

  if proj_log is supplied.
    l_proj_log = proj_log.
  else.
    " create "log-to-structure" object to keep algorithm uniform for saver call
    l_proj_log = cl_abap_behv_log=>create_for_failed( root = proj_root
                                         ref_failed = ref #( proj_failed_struc ) ).
  endif.

  if kind = if_abap_behv_log=>failed.
    op_failed    = cl_abap_behvdescr=>op_failed.
    key_failed   = kn-cid.
    wh_eq_failed = |{ fn-cid } = <PI>-{ fn-cid } AND { fn-pky } = <PI>-{ fn-pky }|.
  else.
    op_failed    = cl_abap_behvdescr=>op_failed_late.
    key_failed   = kn-entity.
    wh_eq_failed = |{ fn-key } = <PI>-{ fn-key }|.
  endif.


  if augm_genrefs is not initial.

    " (*R1*) Collect all related proj instances from all failed base instances
    "       (the same proj instance can be related from various base entities!)
    loop at l_base_failed assigning <resp>.
      assign <resp>-entries->* to <base_data>.  check <base_data> is not initial.
      check line_exists( augm_genrefs[ ref_from-entity = <resp>-entity_name ] ).
*    GET_RELA_FOR_TRG <resp>-entity_name proj_root.  " assign <rela> only if possible
      loop at <base_data> assigning field-symbol(<base_line>).
        data(base_line) = sy-tabix.
        cl_abap_behv_job=>serialize_key( exporting instance = <base_line>
                                         importing key      = data(base_key) " for dyn where
                                                   cid      = data(base_cid) ) ##NEEDED.
        " collect all related PROJ instances (deserialized keys) for this BASE instance
        data(where) = cond #( when kind = if_abap_behv_log=>failed_late
                                or base_cid is initial
                              then `REF_FROM-ENTITY = <RESP>-ENTITY_NAME ` &
                                  `AND REF_FROM-KEY = BASE_KEY`
                              else `REF_FROM-ENTITY = <RESP>-ENTITY_NAME ` &
                                  `AND REF_FROM-KEY = BASE_KEY ` &
                                  `AND REF_FROM-CID = BASE_CID` ).
        loop at augm_genrefs using key primary_key assigning field-symbol(<ar>) where (where).
          " <ar>-REF_TO is a PROJ instance related to this BASE instance
          data(to_entity) = conv abp_entity_name( <ar>-ref_to-entity ).  " related projection entity
          assign rela_insts[ entity = to_entity ] to <rela_inst>.
          if sy-subrc <> 0.
            proj = cl_abap_behvdescr=>create_data( p_name = to_entity
                                                   p_op   = op_failed ).
            insert value #( entity = to_entity instances = proj ) into table rela_insts assigning <rela_inst>.
          endif.
          assign <rela_inst>-instances->* to <rela_data>.
          " duplicates are eliminated later in (*R2*)
          insert initial line into table <rela_data> assigning <rela_line>.
          " It is NOT adequate to transfer %FAIL-CAUSE and %OP from a failed BASE to a related PROJ instance!
          cl_abap_behv_job=>deserialize_key( exporting key      = <ar>-ref_to-key
                                                       cid      = <ar>-ref_to-cid
                                             changing  instance = <rela_line> ).
        endloop.
        " remove related instance from failed
        if sy-subrc = 0.
          delete <base_data> index base_line.
        endif.
      endloop.
    endloop.

    " --- (*R2*) Eliminate duplicates and send all collected instances to log
    loop at rela_insts assigning <rela_inst>.
      assign <rela_inst>-instances->* to <rela_data>.
      if kind = if_abap_behv_log=>failed.
        if lines( <rela_data> ) > 1.
          sort <rela_data> by (fn-cid) (fn-tky).       "#EC CI_SORTLOOP
          delete adjacent duplicates from <rela_data> comparing (fn-cid) (fn-tky).
        endif.
      else.
        sort <rela_data> by (fn-tky).                  "#EC CI_SORTLOOP
        delete adjacent duplicates from <rela_data> comparing (fn-tky).
      endif.
    endloop.

  endif. " relating instances from augmentation

* === Map BASE FAILED to PROJ FAILED

  loop at l_base_failed assigning <resp>.
    assign <resp>-entries->* to <base_data>.        check <base_data> is not initial.
    get_rela_for_trg <resp>-entity_name proj_root.  check <rela> is assigned.
    proj = cl_abap_behvdescr=>create_data( p_name = <rela>-source_entity
                                           p_op   = op_failed ).
    assign proj->* to <proj_data>.
    to_proj '!' <proj_data> <base_data> <resp>-entity_name cl_abap_behv_ctrl=>d010behv_op-virtual-failed.

    " (*R3*) Instances of this PROJ entity were related to by augmentation
    "        Filter these (duplicate) instances out of transformed-BASE response
    assign rela_insts[ entity = <rela>-source_entity ] to <rela_inst>.
    if sy-subrc = 0.
      assign <rela_inst>-instances->* to <rela_data>.
      loop at <proj_data> assigning <pi>.
        delete <rela_data> using key (key_failed) where (wh_eq_failed).
      endloop.
    endif.

    l_proj_log->add( root_name   = proj_root
                     entity_name = <rela>-source_entity
                     kind        = kind
                     flavor      = if_abap_behv_log=>projection
                     instances   = <proj_data> ).

  endloop.

  " --- (*R4*) Add reducesed related failed
  loop at rela_insts assigning <rela_inst>.
    l_proj_log->add( root_name   = proj_root
                     entity_name = <rela_inst>-entity
                     kind        = kind
                     flavor      = if_abap_behv_log=>projection
                     instances   = <rela_inst>-instances->* ).
  endloop.

endmethod.


  method MAP_BASE_FAILED_REPORTED.

  field-symbols <rela> type cl_abap_behv_load=>t_relat_ext.
  field-symbols <failed_entities> type abp_behv_response_tab.
  data(base_log_std) = cast cl_abap_behv_log( m_base_job->log ).
  assign base_log_std->failed_entities to <failed_entities>.

* === Map BASE FAILED to [RELATED] PROJ FAILED
  if <failed_entities> is not initial.
    " (AUGM_in_PRCH) M_AUGM_ACTIVITIES will be re-used in 'M'odify => must be reduced
    if m_augm_activities is not initial.
      remove_faileds_from_activities( exporting failed_entities = <failed_entities>
                                      changing  activities      = m_augm_activities ).
    endif.
    get_rela_for_src m_proj_root.
    log_failed_and_related(
     exporting proj_root    = m_proj_root
               base_root    = <rela>-target_entity
               proj_log     = job->log
               augm_genrefs = m_augm_genrefs
               base_failed  = <failed_entities> ).
  endif.

  if m_saver is not initial.
    m_saver->m_augm_genrefs = m_augm_genrefs.  " to be used for LATE failed-relating
    clear m_saver.  " not needed anymore
  endif.

* === Map BASE REPORTED to PROJ REPORTED
  if base_log_std is bound. " READ, PERMISSIONS etc.
    loop at base_log_std->reported_entities assigning field-symbol(<resp>).
      transfer_to_proj_log( kind           = if_abap_behv_log=>reported
                            proj_root      = m_proj_root
                            base_root      = <resp>-root_name
                            base_entity    = <resp>-entity_name
                            base_instances = <resp>-entries->*
                            flavor         = if_abap_behv_log=>projection
                            log_also_base_data = 'X'
                            proj_log       = job->log ).
    endloop.
  endif.

  endmethod.


method MAP_FROM_BASE_JOB.

"if kind ca 'MRFGaJi'.
  map_RESULTS_FROM_BASE(  base_job = base_job  job = job  kind = kind  out_actv_idxs = out_actv_idxs ).
"endif.

if job->log is initial.
  return.  " EML not receiving any responses
endif.

loop at base_log->failed_entities assigning field-symbol(<response>).
  transfer_to_proj_log(
      kind           = if_abap_behv_log=>failed
      proj_root      = proj_root
      base_root      = <response>-root_name
      base_entity    = <response>-entity_name
      base_instances = <response>-entries->*
      flavor         = if_abap_behv_log=>unspecific
      proj_log       = job->log ).
endloop.

loop at base_log->mapped_entities assigning <response>.
  transfer_to_proj_log(
      kind           = if_abap_behv_log=>mapped
      proj_root      = proj_root
      base_root      = <response>-root_name
      base_entity    = <response>-entity_name
      base_instances = <response>-entries->*
      flavor         = if_abap_behv_log=>unspecific
      proj_log       = job->log ).
endloop.

loop at base_log->reported_entities assigning <response>.
  transfer_to_proj_log(
      kind           = if_abap_behv_log=>reported
      proj_root      = proj_root
      base_root      = <response>-root_name
      base_entity    = <response>-entity_name
      base_instances = <response>-entries->*
      flavor         = if_abap_behv_log=>unspecific
      proj_log       = job->log ).
endloop.

endmethod.


  method map_proj_instances.

    data trg_entity type abp_entity_name.
    data trg_failed_idxs   type hashed table of t_idx_idxs with unique key idx.

    field-symbols <proj_data> type index table.
    field-symbols <base_data> type index table.
    field-symbols <trg_data>  type index table.

    assign job->activities[ proj_idx ] to field-symbol(<proj_actv>).
    data(base_actv) = ref #( m_base_job->activities[ base_idx ] ).

    assign <proj_actv>-instances->* to <proj_data>.
    assign base_actv->instances->* to <base_data>.
    assign m_augm_failed->* to field-symbol(<augm_failed>).

    if <augm_failed> is assigned.

      if <proj_actv>-op = cl_abap_behv_ctrl=>op-create_ba.
        " --- Collect (indices of) PROJ CBA target instances which AUGM returned in FAILED
        "     Instances are removed from BASE table below (PROJ may be readonly!)
        clear trg_entity.
        loop at <proj_data> assigning field-symbol(<pi>).
          data(fidx) = value t_idx_idxs( idx = sy-tabix ).
          assign component fn-target of structure <pi> to <trg_data>.
          if trg_entity is initial.
            data(absname) = cl_abap_behvdescr=>get_abs_typename_from_data_ref( ref #( <trg_data> ) ).
            trg_entity = substring_before( val = substring_after( val = absname sub = `\ENTITY=` ) sub = `\` ).
          endif.
          if <trg_data> is initial.
            insert fidx into table trg_failed_idxs.
          else.
            collect_failed_idxs( exporting failed_struc = <augm_failed>
                                           proj_entity  = trg_entity
                                           proj_data    = <trg_data>
                                           proj_enames  = m_proj_enames->*
                                 importing failed_idxs  = fidx-idxs ).
            if fidx-idxs is not initial.
              insert fidx into table trg_failed_idxs.
            endif.
          endif.
        endloop.
      endif.
      " --- Collect (indices of) PROJ instances which AUGM returned in FAILED
      "     Instances are removed from BASE table below (PROJ may be readonly!)
      collect_failed_idxs( exporting failed_struc = <augm_failed>
                                     proj_entity  = <proj_actv>-entity_name
                                     proj_data    = <proj_data>
                                     proj_enames  = m_proj_enames->*
                           importing failed_idxs  = data(failed_idxs) ).
    endif.

    to_base '!' <proj_data> <base_data> base_actv->entity_name base_actv->op.

    if <augm_failed> is assigned.
      if trg_failed_idxs is not initial.
        " Remove BASE CBA target instances corresponding to augm-failed PROJ CBA target instances
        loop at trg_failed_idxs assigning field-symbol(<fidx>).
          assign <base_data>[ <fidx>-idx ] to field-symbol(<bi>).
          assign component fn-target of structure <bi> to <trg_data>.
          remove_failed_idxs( changing base_data   = <trg_data>
                                       failed_idxs = <fidx>-idxs ).
          if <trg_data> is initial.
            insert <fidx>-idx into table failed_idxs. " -> complete removal of CBA line below
          endif.
        endloop.
        clear trg_failed_idxs.
      endif.
      if failed_idxs is not initial.
        " Remove BASE instances corresponding to augm-failed PROJ instances (by index hi-to-lo)
        remove_failed_idxs( changing base_data   = <base_data>
                                     failed_idxs = failed_idxs ).
        clear failed_idxs.
      endif.
      if <base_data> is initial.
        "delete <base_hdlr>-params.
        return.  " _all_ instances of current parameter table failed in augmentation
      endif.
    endif.

    if line_exists( m_base_actv_in_augm[ table_line = base_idx ] ).
      " --- Merge AUGM changes into BASE activity (but keep new instances separate)
      augment_base_activity( exporting base_actv          = base_actv
                             changing  seminew_activities = m_augm_actv_fresh-seminew ).
    endif.


  endmethod.


method MAP_RESULTS_FROM_BASE.

field-symbols <proj_data> type index table.
field-symbols <base_data> type index table.

loop at out_actv_idxs assigning field-symbol(<idxs>).

  assign base_job->activities[ <idxs>-base_idx ] to field-symbol(<base_actv>).
  assign job->activities[      <idxs>-proj_idx ] to field-symbol(<proj_actv>).

  if   <base_actv>-links is not initial
   and <proj_actv>-links is not initial.  " may be initial if not requested via intf
    if kind na 'FGaJi' and <base_actv>-op na 'AE'.  " data is *input* in these cases (REQUEST)
      assign <proj_actv>-links->* to <proj_data>.
      assign <base_actv>-links->* to <base_data>.
      to_proj '!' <proj_data> <base_data> <base_actv>-entity_name <base_actv>-op.
    endif.
  endif.

  if   <base_actv>-results is not initial
   and <proj_actv>-results is not initial.  " may be initial if not requested via intf
    if kind ca 'GJi'. "some operations have structure result
      assign <proj_actv>-results->* to field-symbol(<proj_data_stru>).
      assign <base_actv>-results->* to field-symbol(<base_data_stru>).
      to_proj '!' <proj_data_stru> <base_data_stru> <base_actv>-entity_name <base_actv>-op.
    else.
      assign <proj_actv>-results->* to <proj_data>.
      assign <base_actv>-results->* to <base_data>.
      " mode '?': no map form exists if target is foreign; then just MOVE-CORRESPONDING
      to_proj '?' <proj_data> <base_data> <base_actv>-entity_name <base_actv>-op.
    endif.
  endif.

endloop.

endmethod.


method map_to_base_job.

  field-symbols <proj_data> type data.
  field-symbols <base_data> type data.
  field-symbols <actv>      type abp_behv_activities.

  data rela            type ref to cl_abap_behv_load=>t_relat_ext.
  data base_idx        type i.
  data base_activities type abp_behv_activities_tab.
  data base_features   type abp_behv_features_tab.
  data base_gfeatures  type abp_behv_global_permission_tab.
  data base_auths      type abp_behv_authorization_tab.
  data base_gauths     type abp_behv_global_permission_tab.
  data base_perms      type abp_behv_permissions_tab.
  data base_log        type ref to cl_abap_behv_log.

  clear: base_job, out_actv_idxs, all_actv_idxs.

  " === Map activities
  loop at job->activities assigning <actv>.
    data(actv_idx) = sy-tabix.
    data(actv_opt) = cond #( when kind = 'i' then 'i' else <actv>-op ).  " for PERMISSIONS type: 'i' (not 'P')

    " DRAFT/ACTIVE activities are handled by separate PROJECTION handlers
    check is_draft is not supplied or <actv>-is_draft = is_draft.

    rela = cl_abap_behv_load=>get_relation( source_entity = <actv>-entity_name
                                            kind          = cl_abap_behv_load=>c_relation_base
                                            original_root = proj_root ).
    check rela is not initial.
    if rela->source_root <> proj_root.
      " in a request with >= 2 projections, each proj handler must pick only 'its' activities!
      continue.
    endif.

    data(base_actv) = value abp_behv_activities( op          = <actv>-op
                                                 entity_name = rela->target_entity
                                                 full        = cond #( when <actv>-full = 'L' then space else 'X' )
    " INSTANCES may be left empty (see below), but the IS_DRAFT property is
    " needed for handler determination -> preserve IS_DRAFT explicitly in base activity:
                                                 is_draft    = <actv>-is_draft
                                               ).
    if <actv>-op ca 'AE'.  " map action/function name to base
      base_actv-sub_name = value #( rela->base_actions[ local_name = <actv>-sub_name ]-other_name
                                    optional ).
      " projection-local action has no map in base -> irrelevant
      check base_actv-sub_name is not initial.
    elseif <actv>-op ca 'ON'.  " map association name to base
      base_actv-sub_name = value #( rela->base_assocs[ local_name = <actv>-sub_name ]-other_name
                                    default <actv>-sub_name ).
    endif.

    " == Map INSTANCES
    if kind na 'GJ'.  " GLOBAL FEATURES/AUTHORIZATION
      assign <actv>-instances->* to <proj_data>.
      if sy-subrc = 0 and <proj_data> is not initial.
        data(abstype) = cl_abap_behvdescr=>get_abs_typename(
          p_name     = base_actv-entity_name
          p_op       = actv_opt
          p_sub_name = base_actv-sub_name
          p_kind     = if_abap_behv=>typekind-import ).
        try.
            create data base_actv-instances type (abstype).
          catch cx_sy_create_data_error into data(exc).
            if kind ca 'aF'.  " instance AUTHORIZATION/FEATURES
              continue.  " may occur for projection-local operation
            endif.
            raise exception exc.
        endtry.
        assign base_actv-instances->* to <base_data>.
        if map_instances is not initial and <proj_data> is assigned.
          to_base '!' <proj_data> <base_data> base_actv-entity_name base_actv-op.
        endif.
      elseif kind <> 'i'. " ONLY GLOBAL ... => no INSTANCES->* => no reduction
        continue.
      endif.
    endif.

    " == Map LINKS
    if <actv>-links is not initial.
      data(p_kind) = cond #( when kind ca 'FGaJi' or <actv>-op ca 'AE'
                             then if_abap_behv=>typekind-request
                             else if_abap_behv=>typekind-link ).
      if kind ca 'FGaJi'. " instance/global AUTHORIZATION/FEATURES
        abstype = cl_abap_behvdescr=>get_abs_typename(
            p_name     = base_actv-entity_name
            p_op       = actv_opt
            p_sub_name = base_actv-sub_name
            p_kind     = p_kind ).
        try.
            create data base_actv-links type (abstype).
          catch cx_sy_create_data_error.
            continue. "base does not support a projection local request
        endtry.
      else.
        base_actv-links = cl_abap_behvdescr=>create_data(
          p_name     = base_actv-entity_name
          p_op       = actv_opt
          p_sub_name = base_actv-sub_name
          p_kind     = p_kind ).
      endif.
      assign <actv>-links->*    to <proj_data>.
      assign base_actv-links->* to <base_data>.
      if p_kind = if_abap_behv=>typekind-request.
        " REQUEST is *input* for FEATURES/AUTHORIZATION and ACTION/FUNCTION
        if kind ca 'FGaJi'.
          to_base '!' <proj_data> <base_data> base_actv-entity_name base_actv-op.
        else.
          " mode '?': no map form exists if action/function REQUEST structure is equal; then just MOVE
          to_base '?' <proj_data> <base_data> base_actv-entity_name base_actv-op.
        endif.
      endif.
    endif.

    " Map RESULTS
    if <actv>-results is not initial.
      base_actv-results = cl_abap_behvdescr=>create_data(
        p_name     = base_actv-entity_name
        p_op       = actv_opt
        p_sub_name = base_actv-sub_name
        p_kind     = if_abap_behv=>typekind-result ).
    endif.

    " map line index in PROJ activities to line index in BASE activities
    if kind = 'F'.
      data(base_feat) = corresponding abp_behv_features( base_actv mapping features = links ).
      insert base_feat into table base_features.  base_idx = lines( base_features ).
    elseif kind = 'G'.
      data(base_gfeat) = corresponding abp_behv_global_permissions( base_actv mapping request = links result = results ).
      insert base_gfeat into table base_gfeatures.  base_idx = lines( base_gfeatures ).
    elseif kind = 'a'.
      data(base_auth) = corresponding abp_behv_authorization( base_actv mapping authorization = links ). "results = results ).
      insert base_auth into table base_auths.  base_idx = lines( base_auths ).
    elseif kind = 'J'.
      data(base_gauth) = corresponding abp_behv_global_permissions( base_actv mapping request = links result = results ).
      insert base_gauth into table base_gauths.  base_idx = lines( base_gauths ).
    elseif kind = 'i'.
      data(base_perm) = corresponding abp_behv_permissions( base_actv mapping request = links results = results ).
      insert base_perm into table base_perms.  base_idx = lines( base_perms ).
    else.
      insert base_actv into table base_activities.  base_idx = lines( base_activities ).
    endif.

    data(idx_pair) = value t_actv_idxs( base_idx = base_idx proj_idx = actv_idx ).
    if all_actv_idxs is supplied.
      insert idx_pair into table all_actv_idxs.
    endif.
    if out_actv_idxs is supplied and ( <actv>-links is not initial or <actv>-results is not initial ).
      insert idx_pair into table out_actv_idxs.
    endif.

  endloop.

  " === Create BASE job
  base_log = cl_abap_behv_job_base=>create_base_log( proj_root = proj_root proj_log = job->log ).
  case kind.

    when 'M' or 'L' or 'P'.  " ########## MODIFY or LOCK or PRECHECK
      data(base_job_modf) = cl_abap_behv_job=>create( log = base_log ).
      base_job = base_job_modf.
      base_job_modf->add_changes_tab( changes                = base_activities
                                      accept_instances_empty = xsdbool( map_instances is initial ) ).  " (AUGM_in_PRCH)
      base_job->m_level = cl_abap_behv_job_base=>modify_base.

    when 'R'.         " ########## READ
      data(base_job_read) = cl_abap_behv_rjob=>create( log = base_log ).
      base_job = base_job_read.
      base_job_read->add_retrievals_tab( base_activities ).
      base_job->m_level = cl_abap_behv_job_base=>read_base.  " for CLEANUP registration

    when 'F'.         " ########## INSTANCE FEATURES
      data(base_job_feat) = cl_abap_behv_fjob=>create( log = base_log for_permissions = job->m_for_permissions ).
      base_job = base_job_feat.
      base_job_feat->add_requests_tab( base_features ).
      base_job->m_level = cl_abap_behv_job_base=>read_base.  " for CLEANUP registration

    when 'a'.         " ########## INSTANCE AUTHORIZATION
      data(base_job_auth) = cl_abap_behv_ajob=>create( log = base_log for_permissions = job->m_for_permissions ).
      base_job = base_job_auth.
      base_job_auth->add_requests_tab( base_auths ).
      base_job->m_level = cl_abap_behv_job_base=>read_base.  " for CLEANUP registration

    when 'G'.         " ########## GLOBAL FEATURES
      data(base_job_gfeat) = cl_abap_behv_gfjob=>create( log = base_log for_permissions = job->m_for_permissions ).
      base_job = base_job_gfeat.
      base_job_gfeat->add_requests_tab( base_gfeatures ).
*    base_job->m_level = cl_abap_behv_job_base=>read_base.

    when 'J'.         " ########## GLOBAL AUTHORIZATION
      data(base_job_gauth) = cl_abap_behv_gajob=>create( log = base_log for_permissions = job->m_for_permissions ).
      base_job = base_job_gauth.
      base_job_gauth->add_requests_tab( base_gauths ).
*    base_job->m_level = cl_abap_behv_job_base=>read_base.

    when 'i'.         " ########## PERMISSIONS
      data(base_job_perm) = cl_abap_behv_pjob=>create( attrs_from = job log = base_log ).
      base_job = base_job_perm.
      base_job_perm->add_requests_tab( base_perms ).
*    base_job->m_level = cl_abap_behv_job_base=>read_base.

  endcase.

  base_job->m_from_projection = proj_root.
  base_job->m_in_local_mode   = job->m_in_local_mode.
  base_job->m_privileged      = job->m_privileged.
  rela = cl_abap_behv_load=>get_relation( source_entity = proj_root
                                          kind          = cl_abap_behv_load=>c_relation_base_intf
                                          original_root = proj_root ).
  if rela is not initial.
    base_job->m_from_interface = rela->target_entity.
  endif.

endmethod.


  method MERGE_FAILED.

    field-symbols:
      <src_failed_entries> type index table,
      <dst_failed_entries> type index table.

    loop at src assigning  field-symbol(<src_failed>) where entries is not initial.
      assign <src_failed>-entries->* to <src_failed_entries>.
      assert sy-subrc is initial.
      read table dst
        with table key root_name = <src_failed>-root_name entity_name = <src_failed>-entity_name
        assigning field-symbol(<dst_failed>).
      if sy-subrc is not initial.
        insert <src_failed> into table dst assigning <dst_failed>.
        assert sy-subrc is initial.
        create data <dst_failed>-entries like <src_failed_entries>.
        assert sy-subrc is initial.
      endif.
      assign <dst_failed>-entries->* to <dst_failed_entries>.
      assert sy-subrc is initial.
      insert lines of <src_failed_entries> into table <dst_failed_entries>.
    endloop.

  endmethod.


  method new_meta_cache_entry.

    cl_abap_behv_load=>get_load( exporting entity = entity importing actions = data(actions) ).
    read table actions with table key owner_entity = entity name = action
      assigning field-symbol(<action>).
    assert sy-subrc is initial.
    insert
      value #(
        entity = entity
        action = action
        info = value #(
          is_implicit_draft_action = cond #(
            when <action>-properties-kind = cl_abap_behv_load=>c_action_activate or
                 <action>-properties-kind = cl_abap_behv_load=>c_action_discard or
                 <action>-properties-kind = cl_abap_behv_load=>c_action_resume or
                 ( <action>-properties-kind = cl_abap_behv_load=>c_action_determine and
                   <action>-name = 'PREPARE' )
                 then abap_true else abap_false )
          is_draft_action_edit = cond #(
            when <action>-properties-kind = cl_abap_behv_load=>c_action_edit
                 then abap_true else abap_false )
          is_draft_action_activate = cond #(
            when <action>-properties-kind = cl_abap_behv_load=>c_action_activate
                 then abap_true else abap_false )
          is_static_action = <action>-properties-is_static ) )
      into table meta_cache
      reference into cache_entry.
    assert sy-subrc is initial.

  endmethod.


method perm_and_lock_new_aug_insts.

  data new_activities type abp_behv_activities_tab.

  " reduce real new by permissions for lock job
  " instance table (REF TO !!!) is copied lazy at reduce_*
  data(reduced_realnew) = m_augm_actv_fresh-realnew.

  " === Build a GLOBAL PERMISSIONS job for the augmentation instances; remember master-dependent relationships
  " === and reduce RealNew if permissions failed
  " only uses really new
  if reduced_realnew is not initial.
    build_for_global_permissions( exporting activities = reduced_realnew
                                  receiving job        = data(perm_job) ).
    if perm_job is bound.
      cl_abap_behv_ctrl=>call_permissions( perm_job ).
      reduce_aug_by_glbl_perm( exporting aug_root   = m_augm_root
                                         perm_job   = perm_job
                               changing  activities = reduced_realnew ).
      data(perm_log) = cast cl_abap_behv_log( perm_job->log ).
      " accumulate failed
      data(failed_entities) = perm_log->failed_entities.
      " add reported to base log (only global messages)
      loop at perm_log->reported_entities assigning field-symbol(<reported>).
        base_log->add( kind = if_abap_behv_log=>reported
                       root_name = <reported>-root_name
                       entity_name = <reported>-entity_name
                       instances = <reported>-entries->* ).
      endloop.
    endif.
  endif.

  " === Build a LOCK job for the augmentation instances; remember master-dependent relationships
  " add semi new activities for lock
  " Instances from 'new' and 'old' activities are locked together
  " first only really new activities needed for permissions
  " for semi new activities the permissions check was executed by base
  new_activities = value #( ( lines of reduced_realnew ) " locks only for permissions OK
                            ( lines of m_augm_actv_fresh-seminew ) ).
  data(lock_log) = cl_abap_behv_log=>create( ).
  build_for_lock( exporting root       = m_augm_root
                            activities = new_activities
                            log        = lock_log
                  importing key_map    = data(master_keymap)
                  receiving job        = data(lock_job) ).
  if lock_job is not initial.
    data(th) = cond t_trace_hier( when cl_abap_behv_tracer=>xtrace_level >= c_xtrace-default then value #(
      nest = cl_abap_behv_tracer=>tracer->trace_beg( message = |{ text_003 }|
       object = conv #( text_001 )  procedure = 'LOCK_NEW_AUGMENT_INSTANCES' ) ) ).
    " === Execute LOCK job, receive failures into local log
    lock_job->log = lock_log.
    cl_abap_behv_ctrl=>get_handlers( exporting job           = lock_job
                                     importing lock_handlers = data(lock_handlers) ).
    loop at lock_handlers assigning field-symbol(<hdlr>).
      cl_abap_behv_ctrl=>call_handler( handler = <hdlr>-handler
                                       root    = <hdlr>-root
                                       params  = ref #( <hdlr>-params )
                                       job     = lock_job ).
    endloop.
    data(lock_job_behv) =  cast cl_abap_behv_log( lock_job->log ).
    " failed
    merge_failed( exporting src = lock_job_behv->failed_entities
                  changing dst = failed_entities ).
    "reported
    loop at lock_job_behv->reported_entities assigning field-symbol(<lock_repo>).
      base_log->add( kind = if_abap_behv_log=>reported
                     root_name = <lock_repo>-root_name
                     entity_name = <lock_repo>-entity_name
                     instances = <lock_repo>-entries->* ).
    endloop.
  endif.

  " now restore new activities for remove step
  new_activities = value #( ( lines of m_augm_actv_fresh-realnew )
                            ( lines of m_augm_actv_fresh-seminew ) ).

  " evaluate job log from global permissions and lock job
  if failed_entities is not initial.

    evaluate_failed(
      exporting failed_entities = failed_entities
                master_keymap = master_keymap
                base_log = base_log
                kind = kind
      changing new_activities = new_activities
               base_instances_removed = base_instances_removed ).

  endif. " failures

  if th is not initial.
    cl_abap_behv_tracer=>tracer->trace_end( hierarchy_number = th-nest ).
  endif.

endmethod.


method PREPARE.

data map_instances type sychar01 value 'X'.

m_saver = saver.

if_IS_AUGMENTING kind.  " (AUGM_in_PRCH)

  clear m_augm_done.

  if preceding_handler is not initial.
    assert kind = 'M'.
    if preceding_handler->m_last_jobtoken = job->m_token.
      " A preceding Precheck has run (a Precheck is defined for BASE).
      " Augment was executed then. Use its activities and don't run Augment again.
      SET_AUGM_MEMBERS me preceding_handler.
      CLEAR_AUGM_MEMBERS preceding_handler.
      m_augm_done = preceding_handler->m_augm_done.
      m_augm_handler_names = preceding_handler->m_augm_handler_names.
    else.
      " Job token mismatch?! Discard preceding handler and its augment activities
      CLEAR_AUGM_MEMBERS preceding_handler.
      clear preceding_handler.
    endif.
  endif.

" [M]odify: delay INSTANCES mapping until handler invocation (to exploit resolved %CID_REFs)
" [P]recheck: must behave just like Modify to enable Augment-in-Precheck
  clear map_instances.

endif.

map_to_base_job( exporting kind          = kind
                           job           = job
                           proj_root     = m_proj_root
                           is_draft      = m_is_draft
                           map_instances = map_instances
                 importing base_job      = m_base_job
                           all_actv_idxs = m_all_actv_idxs
                           out_actv_idxs = m_out_actv_idxs ).

if map_instances is initial.
  " delayed INSTANCES mapping would make content determination (CHECK_CONTENT)
  " fail, so inherit PROJ->M_CONTENT to BASE
  " (else would lead to creation of active+draft saver instead of just active or draft):
  m_base_job->m_content = job->m_content.
endif.

endmethod.


method PREPARE_AUGMENT.

types: begin of t_trig,
         operation   type abp_behv_op,
         entity      type abp_entity_name,
         sub_name    type abp_behv_activities-sub_name,
         used_in_job type c length 1,
       end of t_trig.

data augm_trigs type hashed table of t_trig with unique key operation entity sub_name.
data trig type t_trig.

clear: m_augm_job, m_augm_activities, m_augm_failed.

" If augmented implementations exist, they have already been selected; extract triggers:
loop at job->augm_behavior assigning field-symbol(<behv>)
 where operation ca cl_abap_behv_ctrl=>op_chars_augmenting.  "#EC CI_SORTSEQ
  trig-operation = <behv>-operation.
  trig-entity    = <behv>-entity.
  trig-sub_name  = cond #( when <behv>-operation ca cl_abap_behv_ctrl=>op_chars_w_sub then <behv>-op_info ).
  insert trig into table augm_trigs.
endloop.

if augm_trigs is initial.
  return.
endif.

" Build augmentation job from activities which have augmenting behavior
loop at job->activities assigning field-symbol(<actv>) where op ca cl_abap_behv_ctrl=>op_chars_augmentable and is_draft = me->m_is_draft.
  data(augm_op) = <actv>-op.
  translate augm_op using cl_abap_behv_ctrl=>op_ch_real_to_augm.
  assign augm_trigs[ operation = augm_op entity = <actv>-entity_name sub_name = <actv>-sub_name ] to field-symbol(<trig>).
  if sy-subrc <> 0.
    continue.
  endif.
  <trig>-used_in_job = 'X'.
  if m_augm_job is initial.
    " Augmentation job writes to the same log as the original job
    " => FAILED/REPORTED from the exit (i.e. filled during GET_HANDLERS) reach the consumer
    m_augm_job = cl_abap_behv_job=>create( log = job->log ).
  endif.
  m_augm_job->add_changes( entity_name = <actv>-entity_name
                           operation   = augm_op
                           sub_name    = <actv>-sub_name
                           is_draft    = me->m_is_draft
                           instances   = <actv>-instances ).
endloop.

if m_augm_job is initial.
  return.
endif.

" Add augmenting behavior to augmentation job
loop at job->augm_behavior assigning <behv>. " where operation ca cl_abap_behv_ctrl=>op_chars_augmenting.
  if value #( augm_trigs[ operation = <behv>-operation
                          entity = <behv>-entity
                          sub_name = cond #( when <behv>-operation ca cl_abap_behv_ctrl=>op_chars_w_sub then <behv>-op_info ) ]-used_in_job optional ) is not initial.
    insert <behv> into table m_augm_job->behavior.
  endif.
endloop.

cast cl_abap_behv_job_base( m_augm_job )->m_level = cl_abap_behv_job_base=>modify_augm.  " skips behavior retrieval

endmethod.


  method REDUCE_AUG_BY_GLBL_PERM.

    loop at activities assigning field-symbol(<aug_actv>).

      " find perm activity for aug activity
      read table perm_job->activities with key entity_name = <aug_actv>-entity_name
        assigning field-symbol(<perm_actv>).
      assert sy-subrc is initial.

      " get perm res for op
      data(comp_str) = comp_name_by_actv( <aug_actv> ).
      data(res_str) = |{ cl_abap_behv=>co_techfield_name-global }-{ comp_str }|.
      assign <perm_actv>-results->(res_str) to field-symbol(<res_comp>).
      assert sy-subrc is initial.

      " check, reduce and set failed and cause,
      " and remove failed instances
      if <res_comp> is not initial.
        field-symbols <inst_tab> type index table.
        field-symbols <failed_tab> type index table.
        assign <aug_actv>-instances->* to <inst_tab>.
        if sy-subrc is initial.
          " move unauthorized/diabled inst to failed
          data(failed_tab_ref) = cl_abap_behvdescr=>create_data(
                                   p_name = <aug_actv>-entity_name
                                   p_op = cl_abap_behvdescr=>op_failed ).

          assign failed_tab_ref->* to <failed_tab>.
          move-corresponding <inst_tab> to <failed_tab> .
          if <res_comp> = if_abap_behv=>perm-o-unauthorized.
            data(failed_cause) = if_abap_behv=>cause-unauthorized.
          else.
            failed_cause = if_abap_behv=>cause-disabled.
          endif.
          " check for implicit draft action
          if <aug_actv>-op = cl_abap_behv_ctrl=>op-action.
            data(is_implicit_draft) =
              is_implicit_draft_action( entity = <aug_actv>-entity_name action = <aug_actv>-sub_name ).
          endif.
          " set implicit draft, cid, and cause
          loop at <failed_tab> assigning field-symbol(<failed>).
            " set implicit draft
            if is_implicit_draft = abap_true.
              assign component cl_abap_behv=>co_techfield_name-is_draft of structure <failed>
                to field-symbol(<is_draft>).
              if sy-subrc is initial.
                <is_draft> = if_abap_behv=>mk-on.
              endif.
            endif.
            " set CID
            assign <inst_tab>[ sy-tabix ] to field-symbol(<inst>).
            assert sy-subrc is initial.
            assign component cl_abap_behv=>co_techfield_name-cid_ref of structure <inst>
              to field-symbol(<cid_ref>).
            if sy-subrc is initial.
              assign component cl_abap_behv=>co_techfield_name-cid of structure <failed>
                to field-symbol(<cid>).
              assert sy-subrc is initial.
              <cid> = <cid_ref>.
            endif.
            " set cause
            assign component comp_str of structure <failed> to field-symbol(<failed_mk>).
            assert sy-subrc is initial.
            <failed_mk> = if_abap_behv=>mk-on.
            field-symbols <fail_info> type if_abap_behv=>t_failinfo.
            assign component cl_abap_behv=>co_techfield_name-fail of structure <failed>
              to <fail_info>.
            assert sy-subrc is initial.
            <fail_info>-cause = failed_cause.
          endloop.
          " add failed to joyned log for perm and lock
          perm_job->log->add(
            root_name   = aug_root
            entity_name = <aug_actv>-entity_name
            kind        = if_abap_behv_log=>failed
            instances   = <failed_tab> ).
          " only remove instances => no lock
          " activity is remove later, if instances is empty
          " do not delete intances from tab because they are not cloned
          " create new empty internal table and set reference
          create data <aug_actv>-instances like <inst_tab>.
        endif.
      endif.

    endloop.

  endmethod.


  method reduce_aug_by_inst_perm.

    loop at perm_job->activities assigning field-symbol(<perm_actv>).

      " check for instance results
      field-symbols <perm_res_inst> type index table.
      assign <perm_actv>-results->(cl_abap_behv=>co_techfield_name-instances)
        to <perm_res_inst>.
      check sy-subrc is initial and <perm_res_inst> is not initial.

      " convert instance results to failed
      field-symbols <failed_tab> type index table.
      data(failed_tab_ref) = cl_abap_behvdescr=>create_data(
                               p_name = <perm_actv>-entity_name
                               p_op = cl_abap_behvdescr=>op_failed ).
      assign failed_tab_ref->* to <failed_tab>.
      move-corresponding <perm_res_inst> to <failed_tab>.

      field-symbols <read_only_array> type x.
      unassign <read_only_array>.
      loop at <failed_tab> assigning field-symbol(<failed>).
        data(failed_tab_idx) = sy-tabix.
        " convert permissions to mark and derive cause
        field-symbols: <failed_x> type x.
        assign component cl_abap_behv=>co_techfield_name-op
          of structure <failed> to <failed_x> casting.
        assert sy-subrc is initial.
        " check for failed operations
        if <failed_x> is not initial.
          replace all occurrences of substring if_abap_behv=>perm-o-unauthorized
            in <failed_x> with if_abap_behv=>mk-on replacement count data(rcnt)
            in byte mode.
          if rcnt = 0.
            replace all occurrences of substring if_abap_behv=>perm-o-disabled
              in <failed_x> with if_abap_behv=>mk-on replacement count rcnt
              in byte mode.
            if rcnt > 0.
              data(failed_cause) = if_abap_behv=>cause-disabled.
            else.
              assert fields <perm_actv>-entity_name <failed_x> condition 1 = 0.
            endif.
          else.
            failed_cause = if_abap_behv=>cause-unauthorized.
          endif.
        else.
          " check for read only fields
          " get result
          assign component cl_abap_behv=>co_techfield_name-field
            of structure <perm_res_inst>[ failed_tab_idx ] to <failed_x> casting.
          assert sy-subrc is initial.
          " prepare read only mask
          if <read_only_array> is not assigned.
            data read_only_array_ref type ref to data.
            create data read_only_array_ref like <failed_x>.
            assign read_only_array_ref->* to <read_only_array>.
            assert sy-subrc is initial.
          endif.
          clear <read_only_array> with if_abap_behv=>perm-f-read_only in byte mode.
          " check
          <read_only_array> = <failed_x> bit-and <read_only_array>.
          if <read_only_array> is not initial.
            assign component cl_abap_behv=>co_techfield_name-update of structure <failed>
              to field-symbol(<update>).
            assert sy-subrc is initial.
            <update> = if_abap_behv=>mk-on.
            failed_cause = if_abap_behv=>cause-readonly.
          endif.
          if failed_cause <> if_abap_behv=>cause-readonly.
            " no unauth/disabled operation and no read only found => remove instance from failed
            delete <failed_tab> index failed_tab_idx.
            continue.
          endif.
        endif.
        " set cause
        field-symbols <fail_info> type if_abap_behv=>t_failinfo.
        assign component cl_abap_behv=>co_techfield_name-fail
          of structure <failed> to <fail_info>.
        assert sy-subrc is initial.
        <fail_info>-cause = failed_cause.
      endloop.

      " add instances to failed
      perm_job->log->add(
        root_name   = aug_root
        entity_name = <perm_actv>-entity_name
        kind        = if_abap_behv_log=>failed
        instances   = <failed_tab> ).

    endloop.

  endmethod.


method REMOVE_EMPTY_ACTIVITIES.

field-symbols <instances> type index table.

loop at activities assigning field-symbol(<actv>).
  assign <actv>-instances->* to <instances>.
  if <instances> is initial.
    delete activities.
  endif.
endloop.

endmethod.


method REMOVE_FAILEDS_FROM_ACTIVITIES.

field-symbols <ifails> type index table.

clear instances_removed.

loop at failed_entities assigning field-symbol(<efail>).

  assign <efail>-entries->* to <ifails>.

  REMOVE_FAILED_FROM_ACTIVITIES( exporting entity            = <efail>-entity_name
                                           failed_instances  = <ifails>
                                           clone_instances   = clone_instances
                                 changing  activities        = activities
                                           instances_removed = instances_removed ).

endloop.

if instances_removed is not initial.
  REMOVE_EMPTY_ACTIVITIES( changing activities = activities ).
endif.

endmethod.


method REMOVE_FAILED_FROM_ACTIVITIES.

* Called from LOCK_NEW_AUGMENT_INSTANCES
* - with the union of 'real-new' and 'semi-new' activities
* - with base activities if there are RELATED instances for failed instances
* Called from REMOVE_FAILEDS_FROM_ACTIVITIES, from CL_ABAP_BEHV_CTRL=>CALL_PRECHECKERS
* - with PROJ activities to be reduced before mapping to BASE

data assocs         type cl_abap_behv_load=>tt_assoc.
data clon_instances type ref to data.
field-symbols <assoc>          type cl_abap_behv_load=>t_assoc.
field-symbols <work_instances> type index table.
field-symbols <targ_instances> type index table.
field-symbols <clon_instances> type index table.

init_augment_keys( ).

" Trace the removed instances only in "main" call (the one which supplies the parameter)
data(tl_old) = cl_abap_behv_tracer=>xtrace_level.
if instances_removed is not supplied.
  clear cl_abap_behv_tracer=>xtrace_level. " trace off for REMOVE_FAILED_FROM_INSTANCES
endif.

loop at activities assigning field-symbol(<actv>)
 where entity_name = entity or op = cl_abap_behv_ctrl=>op-create_ba.  "#EC CI_ANYSEQ

  data(clone_curr_instances) = clone_instances.
  data(inst_removed) = ' '.
  assign <actv>-instances->* to <work_instances>.
  check <work_instances> is not initial.

  if <actv>-entity_name = entity.
    data(wkeys) = determine_keys_for_actv( activity = <actv>
                                           instances = <work_instances> ).
    REMOVE_FAILED_FROM_INSTANCES( exporting failed_instances  = failed_instances
                                            clone_instances   = clone_curr_instances
                                            keys              = wkeys
                                  changing  r_instances       = <actv>-instances
                                            instances_removed = inst_removed ).
    if inst_removed is not initial.  instances_removed = 'X'.  endif.
  endif.

  if <actv>-op <> cl_abap_behv_ctrl=>op-create_ba.
    continue.
  endif.

  " === Check that current CBA target entity is the entity being reduced
  assign assocs[ source_entity = <actv>-entity_name name = <actv>-sub_name ] to <assoc>.
  if sy-subrc <> 0.
    cl_abap_behv_load=>get_load( exporting entity = <actv>-entity_name
                                 importing associations = data(new_assocs) ).
    insert lines of new_assocs into table assocs.
    assign assocs[ source_entity = <actv>-entity_name name = <actv>-sub_name ] to <assoc>.
  endif.
  if sy-subrc <> 0 or <assoc>-target_entity <> entity.
    continue.
  endif.
  clone_curr_instances = xsdbool( clone_curr_instances is not initial and inst_removed is initial ).

  " === Reduce all %TARGET tables in current CBA activity
  data(work_idx) = 1.
  data(repeat) = 'X'.
  while repeat is not initial.  " may have to repeat (once) due to lazy cloning
    clear repeat.
    loop at <work_instances> from work_idx assigning field-symbol(<work_inst>).
      work_idx = sy-tabix.
      assign component cl_abap_behv=>co_techfield_name-target of structure <work_inst>
       to <targ_instances>.
      inst_removed = ' '.
      data(r_tinstances) = ref #( <targ_instances> ).
      if <targ_instances> is not initial.
        REMOVE_FAILED_FROM_INSTANCES( exporting failed_instances  = failed_instances
                                                clone_instances   = clone_curr_instances
                                                keys              = keys_create
                                     changing   r_instances       = r_tinstances
                                                instances_removed = inst_removed ).
        check inst_removed is not initial.
      "else.
        " Instances already removed by SADL ... remove operation [or even activity] below
      endif.
      instances_removed = 'X'.  " -> caller info
      assign r_tinstances->* to field-symbol(<reduced_targ_instances>).
      if clone_curr_instances is initial.
        if <reduced_targ_instances> is initial.
          delete <work_instances>.  " remove complete CBA operation
        endif.
        continue.  " done with this CBA, since no clone is required
      endif.
      " === Clone the whole CBA table
      create data clon_instances like <work_instances>. assign clon_instances->* to <clon_instances>.
      <clon_instances> = <work_instances>.
      clear clone_curr_instances.
      if <reduced_targ_instances> is initial.
        delete <clon_instances> index work_idx.  " remove complete CBA operation
      else.
        assign <clon_instances>[ work_idx ] to field-symbol(<clon_inst>).
        assign component cl_abap_behv=>co_techfield_name-target of structure <clon_inst>
         to field-symbol(<clon_targ_instances>).
        <clon_targ_instances> = <reduced_targ_instances>.
        work_idx += 1.  " process remainder (if any) of cloned table
      endif.
      if <clon_instances> is initial.
        delete activities.  " remove complete activity
      else.
        <actv>-instances = clon_instances.
        assign clon_instances->* to <work_instances>.
        repeat = 'X'.  " do 2nd 'while' iteration, starting at work_idx
      endif.
      exit.

    endloop.
  endwhile.

endloop.

cl_abap_behv_tracer=>xtrace_level = tl_old.  " restore

endmethod.


method REMOVE_FAILED_FROM_INSTANCES.

constants tl_rem_inst type if_sxt_types=>ty_trace_level value c_xtrace-expert.

data clon_instances type ref to data.

field-symbols <work_instances> type index table.
field-symbols <clon_instances> type index table.

data(clone_curr_instances) = clone_instances.
assign r_instances->* to <work_instances>.

if cl_abap_behv_tracer=>xtrace_level >= tl_rem_inst.
  data orig_instances type ref to data.  create data orig_instances like <work_instances>.
  field-symbols <orig_instances> type index table.  assign orig_instances->* to <orig_instances>.
  <orig_instances> = <work_instances>.
endif.

loop at failed_instances assigning field-symbol(<bi>).

  loop at keys assigning field-symbol(<key>).
    " use the where condition with <BI>-%CID, not <BI>-%CID_REF
    data(where) = cond #( when <key>-where_f is not initial
                          then <key>-where_f else <key>-where ).

    if clone_curr_instances is not initial.
      " clone only if instance will be deleted
      loop at <work_instances> using key (<key>-name) transporting no fields where (where).
        exit.
      endloop.
      if sy-subrc <> 0.
        continue.  " no instance to delete in this table
      endif.
      create data clon_instances like <work_instances>.
      assign clon_instances->* to <clon_instances>.
      <clon_instances> = <work_instances>.
      r_instances = clon_instances.
      assign r_instances->* to <work_instances>.
      clear clone_curr_instances.  " clone each table at most once
    endif.

    delete <work_instances> using key (<key>-name) where (where).
    if sy-subrc = 0.
      instances_removed = 'X'.  " -> caller info
    endif.

  endloop.
endloop.

if cl_abap_behv_tracer=>xtrace_level >= tl_rem_inst.
  if lines( <orig_instances> ) > lines( <work_instances> ).
    data lost_instances type ref to data.  create data lost_instances like <work_instances>.
    field-symbols <lost_instances> type index table.  assign lost_instances->* to <lost_instances>.
    data(w_idx) = 1.
    loop at <orig_instances> assigning field-symbol(<orig>).
      assign <work_instances>[ w_idx ] to field-symbol(<work>).
      if sy-subrc = 0 and <orig> = <work>.
        w_idx += 1.  continue.
      endif.
      insert <orig> into table <lost_instances>.
    endloop.
    if cl_abap_behv_tracer=>xtrace_level >= tl_rem_inst.
      cl_abap_behv_tracer=>tracer->trace( trace_level = tl_rem_inst
        message   = |{ text_004 } ({ lines( <lost_instances> ) })|
        object    = conv #( text_001 )
        procedure = 'REMOVE_FAILED_FROM_INSTANCES'
        content   = <lost_instances> ).
    endif.
  endif.
endif.

endmethod.


method REMOVE_FAILED_IDXS.

" Remove BASE instances corresponding to augm-failed PROJ instances (by index hi-to-lo)
sort failed_idxs descending. "#EC CI_SORTLOOP
delete adjacent duplicates from failed_idxs.

loop at failed_idxs into data(data_idx).
  delete base_data index data_idx.
endloop.

endmethod.


  method IS_IMPLICIT_DRAFT_ACTION.

    read table meta_cache with table key entity = entity action = action
      reference into data(cache_entry).
    if cache_entry is initial.
      cache_entry = new_meta_cache_entry( entity = entity action = action ).
    endif.
    is_implicit_draft_action = cache_entry->info-is_implicit_draft_action.

  endmethod.


method add_augment_activities.

  data iref type ref to data.

  if activities is not initial.
*   and not cl_feature_toggle=>is_active( if_rap_feature_toggle_ids=>c_incompatible_changes-in_release_2105 ).
    " check draft in sync with base job
    data content type cl_abap_behv_job=>t_content.
    call 'BEHV_EXEC' id 'OP' field 2
      id 'ACTIVITIES' field activities id 'OVERALL' field content. "#EC CI_CCALL
    if content = cl_abap_behv_job=>content_illegal or
       ( me->m_is_draft = if_abap_behv=>mk-on and content <> cl_abap_behv_job=>content_draft ) or
       ( me->m_is_draft = if_abap_behv=>mk-off and content <> cl_abap_behv_job=>content_active ).
      loop at activities assigning field-symbol(<err>) where is_draft <> me->m_is_draft.
        " static actions are agnostic
        if not ( <err>-op = cl_abap_behvdescr=>op_action and
                 is_static_action( entity = <err>-entity_name action = <err>-sub_name ) ).
          raise shortdump type cx_abap_behv_runtime_error
            message e011 with <err>-entity_name <err>-op
            exporting entity    = <err>-entity_name
                      operation = <err>-op
                      tadir_key = cl_abap_behv_ctrl=>get_caller( ).
        endif.
      endloop.
    endif.
  endif.

  loop at activities assigning field-symbol(<actv>).
    check <actv>-instances is not initial.
    assign <actv>-instances->* to field-symbol(<orig_instances>).
    check <orig_instances> is not initial.

    " only activities on the base BO are allowed
    if <actv>-entity_name <> m_augm_root.
      data(actv_root) = cl_abap_behvdescr=>get_root( exporting p_entity = <actv>-entity_name ).
      if actv_root <> m_augm_root.
        raise shortdump type cx_abap_behv_runtime_error
          message e011 with <actv>-entity_name <actv>-op
          exporting "textid    = cx_abap_behv_runtime_error=>operation_illegal
                    entity    = <actv>-entity_name
                    operation = <actv>-op
                    tadir_key = cl_abap_behv_ctrl=>get_caller( ).
      endif.
    endif.

    " must clone instances, else would (probably) dangle in later processing
    create data iref like <orig_instances>.
    assign iref->* to field-symbol(<copy_instances>).
    <copy_instances> = <orig_instances>.
    insert value #( base <actv> instances = iref ) into table m_augm_activities.

  endloop.

  if cl_abap_behv_tracer=>xtrace_level >= c_xtrace-default.
    cl_abap_behv_tracer=>tracer->trace(
      message   = |{ text_005 } ({ lines( m_augm_activities ) })|
      object    = conv #( text_001 )
      procedure = 'ADD_AUGMENT_ACTIVITIES'
      content   = m_augm_activities ).
  endif.

endmethod.


method ADD_AUGMENT_FAILED.

field-symbols <augm_failed>   type data.
field-symbols <old_instances> type index table.
field-symbols <new_instances> type index table.

if m_augm_failed is initial.
  create data m_augm_failed like failed.
  assign m_augm_failed->* to <augm_failed>.
  <augm_failed> = failed.
  return.
endif.

assign m_augm_failed->* to <augm_failed>.

do.
  assign component sy-index of structure failed to <new_instances>.
  if sy-subrc <> 0.  exit.  endif.
  if <new_instances> is not initial.
    assign component sy-index of structure <augm_failed> to <old_instances>.
    append lines of <new_instances> to <old_instances>.
  endif.
enddo.

endmethod.


method ADD_INSTANCE_REFS.

if bdef <> m_proj_root.
  raise shortdump type cx_abap_behv_runtime_error
    message e038 with bdef m_proj_root
    exporting entity = conv #( bdef  ).
endif.

insert lines of inst_refs into table m_augm_genrefs.

endmethod.


method AUGMENT_BASE_ACTIVITY.

data ai_ref  type ref to data.
data bic_aic type xstring.

field-symbols <key>      type t_key_info.
field-symbols <key_trg>  type t_key_info.
field-symbols <base_tab> type index table.
field-symbols <augm_tab> type index table.
field-symbols <augm>     type abp_behv_activities.
field-symbols <aic>      type x.
field-symbols <bic>      type x.
field-symbols <aitrg>    type index table.
field-symbols <aiti>     type data.
field-symbols <bitrg>    type index table.
field-symbols <biti>     type data.
field-symbols <ai_red>   type data.
field-symbols <new_tab>  type index table.


define REDUCE_AUGM_BY_CTRL.  "&1: <ai>; &2: <bi>; <aic>/<bic>: %CONTROL structs
  if <bic> z <aic>.
    " no BASE flags are set in AUGM %CONTROL: use AUGM instance fully
    assign &1 to <ai_red>.
  else.
    " blank out AUGM flags that are set in BASE
    if ai_ref is initial.  create data ai_ref like &1.  endif.
    assign ai_ref->* to <ai_red>.
    <ai_red> = &1.  " clone instance (<ai> may be read-only)
    assign component aicx " fn-CONTROL
     of structure <ai_red> to <aic> casting.
    bic_aic = <bic> bit-and <aic>.
    call 'BEHV_EXEC' id 'OP' field 6 id 'FLAGS' field bic_aic id 'INSTANCES' field &4
     id 'OPERATION' field &3-op id 'PROJ_ROOT' field m_proj_root
     id 'HANDLERS' field m_augm_handler_names.  "#EC CI_CCALL
    <aic> = <aic> bit-and bit-not <bic>.
  endif.
  if <aic> is not initial.  " else: AUGMentation flags completely blanked out
    bic_aic = <bic> bit-or <aic>.  " rescue value due to bug in CORRESPONDING (sets <bic> = <aic>)
    &2 = corresponding #( base ( &2 ) <ai_red> using control ).
    <bic> = bic_aic.
  endif.
end-of-definition.



" Find the AUGM activity (if any) for the given BASE activity and 'merge' it
loop at m_augm_activities assigning <augm>
 where op          = base_actv->op
   and entity_name = base_actv->entity_name
   and sub_name    = base_actv->sub_name.

  assign m_augm_info[ idx = sy-tabix ] to field-symbol(<info>). " pre-computed key info for instance table

  assign <augm>-instances->*     to <augm_tab>.
  assign base_actv->instances->* to <base_tab>.

  " Both %CONTROL and %TARGET are the last component in the respective line types
  assign <augm_tab>[ 1 ] to field-symbol(<ai>).
  describe field <ai> type data(_aityp) components data(aicx) ##NEEDED.
  assign <base_tab>[ 1 ] to field-symbol(<bi>).
  describe field <bi> type data(_bityp) components data(bicx) ##NEEDED.

  if <augm>-op = cl_abap_behv_ctrl=>op-CREATE_BA.
    " %CONTROL is the last component in the %TARGET line types
    data(aitx) = aicx.
    assign component aitx " fn-TARGET
     of structure <ai> to <aitrg>.
    loop at <aitrg> assigning <aiti>.
      describe field <aiti> type _aityp components aicx.  exit.
    endloop.
    data(bitx) = bicx.
    assign component bitx " fn-TARGET
     of structure <bi> to <bitrg>.
    loop at <bitrg> assigning <biti>.
      describe field <biti> type _bityp components bicx.  exit.
    endloop.
  endif.

  clear ai_ref.

  " === Merge AUGMentation instances with existing BASE instances of this activity
  loop at <base_tab> assigning <bi>.
    loop at <info>-keys assigning <key>. " key-based searches (dep. on operation) in augmentation table
      loop at <augm_tab> assigning <ai> using key (<key>-name) where (<key>-where).

        " --- Instance occurs as <ai> in AUGMentation and as <bi> in BASE: must 'merge'
        insert sy-tabix into table <key>-in_base.

        if <augm>-op = cl_abap_behv_ctrl=>op-CREATE_BA.
          data(keys) = keys_cba_trg.
          assign component bitx " fn-TARGET
           of structure <bi> to <bitrg>.
          assign component aitx " fn-TARGET
           of structure <ai> to <aitrg>.

          loop at <bitrg> assigning <biti>.
            loop at keys assigning <key_trg>.
              loop at <aitrg> assigning <aiti> using key (<key_trg>-name) where (<key_trg>-where).
                insert sy-tabix into table <key_trg>-in_base.
                assign component bicx " fn-CONTROL
                 of structure <biti> to <bic> casting.
                assign component aicx " fn-CONTROL
                 of structure <aiti> to <aic> casting.
                REDUCE_AUGM_BY_CTRL <aiti> <biti> <augm> <base_tab>.
              endloop.
            endloop.
          endloop.

          " === Append 'new' AUGMentation target instances to (existing) BASE instance %TARGET table
          loop at keys assigning <key_trg>.
            check lines( <key_trg>-in_base ) < lines( <aitrg> ).
            loop at <aitrg> assigning <aiti> using key (<key_trg>-name) where (<key_trg>-part).
              if not line_exists( <key_trg>-in_base[ table_line = sy-tabix ] ).
                insert <aiti> into table <bitrg>.
              endif.
            endloop.
          endloop.

        else.  " <augm>-op = cl_abap_behv_ctrl=>op-UPDATE|CREATE
          assign component bicx " fn-CONTROL
           of structure <bi> to <bic> casting.
          assign component aicx " fn-CONTROL
           of structure <ai> to <aic> casting.
          " BASE instance <bi> is AUGMented as <ai>: check if %CONTROL flags overlap
          REDUCE_AUGM_BY_CTRL <ai> <bi> <augm> <base_tab>.
        endif.

      endloop.
    endloop.
  endloop.

  " === Identify and collect 'seminew' AUGMentation instances
  "     (i.e.: new instances for existing existing BASE activity)
  if <info>-done is initial.  " [prevent addition to multiple equal BASE activities]
    loop at <info>-keys assigning <key>.
      check lines( <key>-in_base ) < lines( <augm_tab> ).
      loop at <augm_tab> assigning <ai> using key (<key>-name) where (<key>-part).
        if not line_exists( <key>-in_base[ table_line = sy-tabix ] ).
          if <new_tab> is not assigned.
            insert <augm> into table seminew_activities assigning field-symbol(<seminew_actv>).
            create data <seminew_actv>-instances like <augm_tab>.
            assign <seminew_actv>-instances->* to <new_tab>.
          endif.
          insert <ai> into table <new_tab>.
        endif.
      endloop.
    endloop.
    <info>-done = 'X'.
  endif.

endloop.  " at M_AUGM_ACTIVITIES for base activity

endmethod.


  method build_for_global_permissions.

    data perm_req_tab type abp_behv_permissions_tab.

    loop at activities assigning field-symbol(<actv>).

      " get or create new request
      read table perm_req_tab with key entity_name = <actv>-entity_name
        assigning field-symbol(<perm_req>).
      if sy-subrc is not initial.
        insert value #( entity_name = <actv>-entity_name
                        request = cl_abap_behvdescr=>create_data(
                                    p_name = <actv>-entity_name
                                    p_op   = cl_abap_behvdescr=>op_permission
                                    p_kind = if_abap_behv=>typekind-request )
                        results = cl_abap_behvdescr=>create_data(
                                    p_name = <actv>-entity_name
                                    p_op   = cl_abap_behvdescr=>op_permission
                                    p_kind = if_abap_behv=>typekind-result ) )
          into table perm_req_tab
          assigning <perm_req>.
      endif.

      " set requested
      data(comp_str) = comp_name_by_actv( <actv> ).
      assign <perm_req>-request->(comp_str) to field-symbol(<req_comp>).
      assert sy-subrc is initial.
      <req_comp> = if_abap_behv=>mk-on.

    endloop.

    " create job if request is not empty
    if perm_req_tab is not initial.
      job = cl_abap_behv_pjob=>create(
              permissions_only = if_abap_behv=>permissions_only-global
              attrs_from       = m_base_job
              before_modify    = abap_true ).
      job->add_requests_tab( perm_req_tab ).
    endif.

  endmethod.


  method build_for_instance_permissions.

    types:
      begin of key_tab,
        control type xstring,
        keys    type ref to data,
      end of key_tab.

    data:
      control      type xstring,
      key_tab_tab  type sorted table of key_tab with unique key control,
      perm_req_tab type abp_behv_permissions_tab.

    field-symbols:
      <x>          type x,
      <keys>       type index table,
      <actv_insts> type index table.

    loop at activities assigning field-symbol(<actv>)
      " no instance permissions for create
      where op <> if_abap_behv=>op-m-create and instances is not initial.

      " no instance permissions for static actions
      if <actv>-op = if_abap_behv=>op-m-action and
         is_static_action( entity = <actv>-entity_name action = <actv>-sub_name ).
        continue.
      endif.

      " no instances -> no instance permissions
      assign <actv>-instances->* to <actv_insts>.
      if <actv_insts> is initial.
        continue.
      endif.

      " initialization of local variables
      clear key_tab_tab.

      " convert operation keys to permissions keys
      loop at <actv_insts> assigning field-symbol(<actv_inst>).
        " ignore instances with CID_REF or CID (draft actions !!!)
        assign component cl_abap_behv=>co_techfield_name-cid_ref
          of structure <actv_inst> to field-symbol(<cid_ref_cid>).
        if sy-subrc is not initial.
          assign component cl_abap_behv=>co_techfield_name-cid
            of structure <actv_inst> to <cid_ref_cid>.
        endif.
        if sy-subrc is initial and <cid_ref_cid> is not initial.
          continue.
        endif.
        " build field control for update
        if <actv>-op = if_abap_behv=>op-m-update.
          assign component cl_abap_behv=>co_techfield_name-control of structure <actv_inst>
            to <x> casting.
          assert sy-subrc is initial.
          control = <x>.
        else.
          clear control.
        endif.
        " get key tab for control
        read table key_tab_tab with table key control = control
          assigning field-symbol(<key_tab>).
        if sy-subrc is not initial.
          insert value #(
            control = control
            keys = cl_abap_behvdescr=>create_data(
                     p_name = <actv>-entity_name
                     p_op   = cl_abap_behvdescr=>op_permission ) )
            into table key_tab_tab assigning <key_tab>.
          assert sy-subrc is initial.
        endif.
        " insert key
        assign <key_tab>-keys->* to <keys>.
        assert sy-subrc is initial.
        append initial line to <keys> assigning field-symbol(<key>).
        move-corresponding <actv_inst> to <key>.
      endloop.

      " no instances no permissions activity
      if key_tab_tab is initial.
        continue.
      endif.

      " check for implicit draft action, and update draft flag
      if <actv>-op = cl_abap_behv_ctrl=>op-action and
         is_implicit_draft_action( entity = <actv>-entity_name action = <actv>-sub_name ).
        assert lines( key_tab_tab ) = 1. " partitions only update
        assign key_tab_tab[ 1 ]-keys->* to <keys>.
        assert sy-subrc is initial.
        loop at <keys> assigning <key>.
          assign component cl_abap_behv=>co_techfield_name-is_draft of structure <key>
                to field-symbol(<is_draft>).
          if sy-subrc is initial.
            <is_draft> = if_abap_behv=>mk-on.
          endif.
        endloop.
      endif.

      loop at key_tab_tab assigning <key_tab>.
        assign <key_tab>-keys->* to <keys>.

        " normalize kyes for set compare, see below
        delete adjacent duplicates from <keys> using key ('ENTITY').
        sort <keys> by ('%KEY'). "#EC CI_SORTLOOP

        " get or create new request
        data(perm_req_tab_entry_found) = abap_false.
        loop at perm_req_tab assigning field-symbol(<perm_req>)
          where entity_name = <actv>-entity_name.
          " READ cannot be used because there is no support for ->*
          " optimization: different modifies on the same set !!!!
          check <keys> = <perm_req>-instances->*.
          perm_req_tab_entry_found = abap_true.
          exit.
        endloop.
        if perm_req_tab_entry_found = abap_false.
          insert value #( entity_name = <actv>-entity_name
                          request = cl_abap_behvdescr=>create_data(
                                      p_name = <actv>-entity_name
                                      p_op   = cl_abap_behvdescr=>op_permission
                                      p_kind = if_abap_behv=>typekind-request )
                          instances = <key_tab>-keys
                          results = cl_abap_behvdescr=>create_data(
                                      p_name = <actv>-entity_name
                                      p_op   = cl_abap_behvdescr=>op_permission
                                      p_kind = if_abap_behv=>typekind-result ) )
            into table perm_req_tab
            assigning <perm_req>.
        endif.

        " set operation requested
        assign <perm_req>-request->* to field-symbol(<requested>).
        data(comp_str) = comp_name_by_actv( <actv> ).
        assign component comp_str  of structure <requested>
         to field-symbol(<req_comp>).
        assert sy-subrc is initial.
        <req_comp> = if_abap_behv=>mk-on.
        " set fields requested
        if <key_tab>-control is not initial.
          assign component cl_abap_behv=>co_techfield_name-field of structure <requested>
            to <x> casting.
          assert sy-subrc is initial.
          <x> = <x> bit-or <key_tab>-control.
        endif.

      endloop. " at key_tab_tab

    endloop. " at activities

    " create job if request is not empty
    if perm_req_tab is not initial.
      job = cl_abap_behv_pjob=>create(
              permissions_only = if_abap_behv=>permissions_only-instance
              attrs_from       = m_base_job
              before_modify    = abap_true ).
      job->add_requests_tab( perm_req_tab ).
    endif.

  endmethod.


method build_for_lock.

  types:
    begin of t_lock,
      entity_name type abp_entity_name,
      op          type abp_behv_op_modify,
      instances   type ref to data,
    end of t_lock.

  data locks     type sorted table of t_lock with unique key entity_name op.
  data lock_name type abp_entity_name.
  data key_map_entry like line of key_map.

  field-symbols <rela>           type cl_abap_behv_load=>t_relat.
  field-symbols <actv_instances> type index table.
  field-symbols <lock_instances> type index table.
  field-symbols <targ_instances> type index table.
  field-symbols <targ_mapping>   type index table.

  cl_abap_behv_load=>get_load( exporting entity = root  all = 'X'
                               importing entities  = data(entities)
                                         relations = data(relations) ).
  delete relations where kind na 'Ll'.
  clear key_map.

  loop at activities assigning field-symbol(<actv>)
      where op <> cl_abap_behv_ctrl=>op-create. " CREATE instances are not locked
    " DRAFT instances are not locked but draft action EDIT works on ACTIVE
    data(lock_op) =
      cond #( when <actv>-op = cl_abap_behv_ctrl=>op-action and
                   is_draft_edit( entity = <actv>-entity_name action = <actv>-sub_name )
              then cl_abap_behvdescr=>op_lock_edit
              else cl_abap_behvdescr=>op_lock ).
    if <actv>-is_draft is not initial and lock_op = cl_abap_behvdescr=>op_lock.
      continue.
    endif.

    assign entities[ name = <actv>-entity_name ] to field-symbol(<entity>).
    assert sy-subrc = 0.
    assign <actv>-instances->* to <actv_instances>.

    if <entity>-properties-is_lock_master is not initial.
      lock_name = <actv>-entity_name.
      " <actv_instances> are to be locked
    else.
      unassign <rela>.
      " ("LOOP AT" because "READ TABLE" does not support "ca" operator)
      loop at relations using key primary_key assigning <rela>
          where source_entity = <actv>-entity_name and kind ca 'Ll'.
        exit.
      endloop.
      check <rela> is assigned.

      lock_name = <rela>-target_entity.

      data(targ_instances) = cl_abap_behvdescr=>create_data(
                              p_root = root
                              p_name = lock_name
                              p_op   = lock_op ).
      assign targ_instances->* to <targ_instances>.

      cl_abap_behv_ctrl=>read_relation_key_mapping(
          exporting root       = root
                    relation   = <rela>
                    "attrs_from = ???
                    log        = log
                    source     = <actv_instances>
          importing mapping    = key_map_entry ).
      insert key_map_entry into table key_map.

      assign key_map_entry-target->* to <targ_mapping>.
      move-corresponding <targ_mapping> to <targ_instances>.

      sort <targ_instances> by table_line.             "#EC CI_SORTLOOP
      delete adjacent duplicates from <targ_instances> comparing table_line.
      assign <targ_instances> to <actv_instances>.
    endif.

    check <actv_instances> is assigned and <actv_instances> is not initial.

    assign locks[ entity_name = lock_name
                  op = lock_op
                ] to field-symbol(<lock>).
    if sy-subrc = 0.
      assign <lock>-instances->* to <lock_instances>.
      <lock_instances> = corresponding #( base ( <lock_instances> ) <actv_instances> ).
    else.
      insert value #( entity_name = lock_name
                      op          = lock_op
                      instances   = cl_abap_behvdescr=>create_data(
                                     p_root = root
                                     p_name = lock_name
                                     p_op   = lock_op ) )
        into table locks assigning <lock>.
      assign <lock>-instances->* to <lock_instances>.
      <lock_instances> = corresponding #( <actv_instances> ).
    endif.

  endloop. " at activities

  " remove initial entries (how come?)
  loop at locks assigning <lock>.
    data(sytabix) = sy-tabix.
    assign <lock>-instances->* to <lock_instances>.
    delete <lock_instances> where ('TABLE_LINE IS INITIAL').
    if <lock_instances> is initial.
      delete locks index sytabix.
    else.
      delete adjacent duplicates from <lock_instances> using key ('ENTITY').
    endif.
  endloop.

  if locks is not initial.
    job = cl_abap_behv_job=>create( is_indirect = 'X' ).
    loop at locks assigning <lock>.
      job->add_changes( entity_name = <lock>-entity_name
                        operation   = <lock>-op
                        instances   = <lock>-instances ).
    endloop.
  endif.

endmethod.


method call_augment.

  data rela            type ref to cl_abap_behv_load=>t_relat_ext.

  clear: me->m_out_actv_idxs,
         me->m_all_actv_idxs,
         me->m_base_job,
         me->m_saver.

  clear_augm_members me.

*   === Check if relevant augmented behavior exists
  prepare_augment( cast #( job ) ).

  if m_augm_job is not initial.
    " === Execute AUGMentation job now to fill M_AUGM_ACTIVITIES
    rela = cl_abap_behv_load=>get_relation( source_entity = m_proj_root kind = 'B' ).
    m_augm_root = rela->target_entity.
    m_augm_orig_job = job.
    clear m_augm_orig_info.
    execute_augment( ).
    clear: m_augm_orig_job, m_augm_orig_info.
    m_last_jobtoken = job->m_token.
  endif.

endmethod.


method CALL_PRECHECK.

  field-symbols <par>         type cl_abap_behv_ctrl=>t_handler_param.
  field-symbols <base_data>   type index table.
  field-symbols <base_actv>   type abp_behv_activities.
  field-symbols <augm_data>   type index table.

  data base_idx type i.
  data proj_idx type i.

  data base_actv_changed type sychar01.

  data(base_log) = cast cl_abap_behv_log( m_base_job->log ).

* === Merge/add AUGMentation into BASE activities
  clear m_augm_info.
  init_augment( ).

* === Get BASE handlers
  cl_abap_behv_ctrl=>get_handlers( exporting job      = me->m_base_job
                                             kind     = 'P'
                                   importing handlers = data(base_handlers) ).

  " --- INSTANCES mapping just before base handler invocation (was delayed in PREPARE)
  "     Reason: %CID_REF substitution in the PROJECTION data (by SADL logger, below)
  "     is automatically transported to the next BASE handler's INSTANCES.
  loop at m_base_job->activities reference into data(base_actv).
    base_idx = sy-tabix.
    assign base_actv->instances->* to <base_data>.
    assert sy-subrc is initial.
    if <base_data> is initial.
      proj_idx = value #( m_all_actv_idxs[ base_idx = base_idx ]-proj_idx optional ).
      if proj_idx = 0.
        assert 1 = 0.
        " this was a new activity added by augment, but all its instances were removed
        " (due to lock failure) -> remove param (and possibly the whole handler call, below)
        "          delete <base_hdlr>-params.
        "          continue.
      endif.
      map_proj_instances( exporting
        job = job
        base_idx = base_idx
        proj_idx = proj_idx ).
    endif.
  endloop.

  " === Lock all 'new' AUGM instances (failures get inserted into base_log)
  if m_augm_actv_fresh is not initial.
    " (AUGM_in_PRCH): Actual locking may have been done in 'P'recheck already
    perm_and_lock_new_aug_insts(
       exporting base_log               = base_log
                 kind                   = 'P'
       changing  base_instances_removed = base_actv_changed ).
    if m_augm_actv_fresh-seminew is not initial.
      " Add (successfully locked) 'semi-new' instances to corresponding base tables
      " ('real-new' instances AUGM_ACTV_FRESH-REALNEW are already in base job)
      loop at m_base_job->activities assigning <base_actv>.
        assign m_augm_actv_fresh-seminew[ op = <base_actv>-op
          entity_name = <base_actv>-entity_name  sub_name = <base_actv>-sub_name ]
          to field-symbol(<new_actv>).
        check sy-subrc = 0.
        assign <new_actv>-instances->*  to <augm_data>.
        assign <base_actv>-instances->* to <base_data>.
        insert lines of <augm_data> into table <base_data>.
      endloop.
    endif.
*    clear augm_actv_fresh.  " no longer needed
  endif.

* === Execute BASE job
  loop at base_handlers assigning field-symbol(<base_hdlr>).

    " Remove parameters that were emptied by lock failures in augmentation
    loop at <base_hdlr>-params assigning <par>.
      assign <par>-instances->* to <base_data>.
      if <base_data> is initial.
        delete <base_hdlr>-params.
      endif.
    endloop.

    " _all_ instance tables completely failed due to augmentation
    if <base_hdlr>-params is not initial.

      data(smsg_log) = cast cl_abap_behv_log( cl_abap_behv_log=>create( ) ).

      data(prev_p_b_job) = cl_abap_behv_job_base=>curr_p_b_job.
      cl_abap_behv_job_base=>curr_p_b_job = m_base_job.

      cl_abap_behv_ctrl=>call_handler( handler  = <base_hdlr>-handler
                                       root     = <base_hdlr>-root
                                       params   = ref #( <base_hdlr>-params )
                                       job      = m_base_job
                                       smsg_log = smsg_log ).

      cl_abap_behv_job_base=>curr_p_b_job = prev_p_b_job.

      " no mapped in precheck
      assert base_log->mapped_entities is initial.

      if smsg_log->reported_entities is not initial.
        " now the delayed state messages (after %CID handling of MAPPED response)
        data(smsg_handler) = cl_rap_bhv_msg_handler_factory=>get_state_message_handler( ).
        loop at smsg_log->reported_entities assigning field-symbol(<smsg>).
          assign <smsg>-entries->* to <base_data>.
          smsg_handler->add( iv_entity_name = <smsg>-entity_name
                             it_instances   = <base_data>
                             io_log         = job->log ).
        endloop.
      endif.
      clear smsg_log.

      " _all_ instance tables completely failed due to augmentation
    endif.

  endloop.

  " === instance permissions for all 'new' AUGM instances (failures get inserted into base_log)
  if m_augm_activities is not initial.
  " build for all intances in m_augm_activities, read only check must be
  " done for all update instances, up until now only update is relevant
  " because create has no instzance checks and there are no other
  " augmenting possibilities,
  " if this changes then extra logic is needed here
*    cl_abap_behv_load=>get_load( exporting entity = m_proj_root importing head = data(proj_root_head) ).
*    if proj_root_head-with_managed_checks = cl_abap_behv_load=>c_enabled or
*       not cl_feature_toggle=>is_active( if_rap_feature_toggle_ids=>c_incompatible_changes-in_release_2108 ).
      inst_perm_new_aug_insts(
         exporting base_log               = base_log
                   kind                   = 'P'
         changing  base_instances_removed = base_actv_changed ).
*    endif.
  endif.

  " Augmenting always done in precheck (after all base habdler have been called)
  clear m_augm_info.
  m_augm_done = abap_true.

* === Map BASE FAILED to [RELATED] PROJ FAILED
  map_base_failed_reported( job ).

endmethod.


method COLLECT_FAILED_IDXS.

field-symbols <fail_tab> type index table.
field-symbols <keys>     type tt_key_info.

clear failed_idxs.

init_augment_keys( ).

do.
  " (sub-optimal:) linear search for entity-name of current PROJ activity
  assign component sy-index of structure proj_enames to field-symbol(<ename>).
  if sy-subrc <> 0.  exit.  endif.
  if <ename> <> proj_entity.  continue.  endif.  " wrong entity name
  assign component sy-index of structure failed_struc to <fail_tab>.
  if <fail_tab> is initial.
    exit.  " no failed for this entity
  endif.
  assign proj_data[ 1 ] to field-symbol(<pi>).
  assign component fn-CID_REF of structure <pi> to field-symbol(<comp>).
  if sy-subrc = 0.
    assign keys_failed_with_cid_ref to <keys>.
  else.
    assign keys_failed_with_cid to <keys>.
  endif.
  loop at proj_data assigning <pi>.
    data(data_idx) = sy-tabix.
    loop at <keys> assigning field-symbol(<key>).
      loop at <fail_tab> using key (<key>-name) transporting no fields where (<key>-where).
        insert data_idx into table failed_idxs.  " remove this index from BASE below
      endloop.
    endloop.
  endloop.
  exit.
enddo.

endmethod.


  method comp_name_by_actv.

    case actv-op.
      when cl_abap_behv_ctrl=>op-create.
        comp_str = cl_abap_behv=>co_techfield_name-create.
      when cl_abap_behv_ctrl=>op-update.
        comp_str = cl_abap_behv=>co_techfield_name-update.
      when cl_abap_behv_ctrl=>op-delete.
        comp_str = cl_abap_behv=>co_techfield_name-delete.
      when cl_abap_behv_ctrl=>op-action.
        comp_str = |{ cl_abap_behv=>co_techfield_name-action }-{ actv-sub_name }|.
      when cl_abap_behv_ctrl=>op-create_ba.
        comp_str = |{ cl_abap_behv=>co_techfield_name-assoc }-{ actv-sub_name }|.
      when others.
        assert 1 = 0.
    endcase.

  endmethod.


  method CONSTRUCTOR.

    super->constructor( ).

    me->m_proj_root = proj_root.
    me->m_is_draft = is_draft.

    data(proj_enames_bd) = |{ m_proj_root width = 30 pad = '=' }BD| ##NUMBER_OK.
    perform _ in program (proj_enames_bd) if found.
    data(proj_enames_string) = |({ proj_enames_bd })ENTITYNAME|.
    assign (proj_enames_string) to field-symbol(<proj_enames>).
    me->m_proj_enames = ref #( <proj_enames> ).

  endmethod.


method determine_keys_for_actv.

  case activity-op.

    when cl_abap_behv_ctrl=>op-create.
      keys = keys_create.

    when cl_abap_behv_ctrl=>op-update.
      keys = keys_update.

    when cl_abap_behv_ctrl=>op-delete.
      " delete has same keys like update
      keys = keys_update.

    when cl_abap_behv_ctrl=>op-create_ba.
      keys = keys_cba_src_excl_pid.
      if instances is not initial.
        assign instances[ 1 ] to field-symbol(<ai>).
        assign component fn-pid of structure <ai> to field-symbol(<comp>).
        if sy-subrc = 0.
          keys = keys_cba_src_incl_pid.
        endif.
      endif.

    when cl_abap_behv_ctrl=>op-action.
      data(meta_info) = get_meta_info( entity = activity-entity_name action = activity-sub_name ).
      if meta_info-is_draft_action_edit = abap_true or
         meta_info-is_draft_action_activate = abap_true.
        " draft EDIT and ACTIVATE are like CREATE
        keys = keys_create.
      elseif meta_info-is_static_action = abap_true or
             meta_info-is_implicit_draft_action = abap_true.
        " all other draft actions like static, they do not have %CID_REF
        keys = keys_cid_cid.
      else.
        keys = keys_action.
      endif.

    when others.
      " unsupported
      assert 1 = 0.

  endcase.

endmethod.


  method EVALUATE_FAILED.

    types: begin of t_failmap,
             base_entity type abp_entity_name,
             bfails      type ref to data,  " table of base failed instances
             pfail       type ref to data,  " proj failed instance
             pkey        type ref to data,  " proj key only
             bkey        type ref to data,  " base key only
           end of t_failmap.

    data efails         type tt_entity_instances.
    data failmap        type hashed table of t_failmap with unique key base_entity.

    field-symbols <efail>            type t_entity_instances.
    field-symbols <ifails>           type index table.
    field-symbols <failed_instances> type index table.
    field-symbols <bfails>           type index table.
    field-symbols <rela>             type cl_abap_behv_load=>t_relat_ext.
    field-symbols <keymap_target>    type standard table.
    field-symbols <keymap_source>    type standard table.
    define get_efail_and_ifails.
      assign efails[ entity = &1 ] to <efail>.
      if sy-subrc <> 0.
        insert value #( entity = &1 ) into table efails assigning <efail>.
        <efail>-instances = cl_abap_behvdescr=>create_data(
                             p_name = &1
                             p_op   = cl_abap_behvdescr=>op_failed ).
      endif.
      assign <efail>-instances->* to <ifails>.
    end-of-definition.

    " all failed are removed from base
    base_instances_removed = abap_true.

    " Locking of some 'new' AUGM instances (or their masters) has failed.
    " Use master_keymap (built during lock-job construction above) to map failed
    " masters back to the actual AUGM (dependent) instances.
    " After the subsequent BASE handler call, M_AUGM_GENREFS will be used to
    " map these instances back to related instances from the PROJ request (along
    " with instances that failed during the actual BASE modify call).

    " === Collect all (direct and dependent) failed instances per entity
    loop at failed_entities assigning field-symbol(<failed>).
      assign <failed>-entries->* to <failed_instances>.
*    " --- (i) Directly failed instances
      get_efail_and_ifails <failed>-entity_name.
      insert lines of <failed_instances> into table <ifails>.
      " --- (ii) Dependent instances. These are the ones which (may) have
      "          a mapping back to PROJ instances via M_AUGM_GENREFS
      loop at master_keymap assigning field-symbol(<keymap_entry>) where target_entity = <failed>-entity_name.
        assign <keymap_entry>-target->* to <keymap_target>.
        data keymap_target_line type ref to data.
        create data keymap_target_line like line of <keymap_target>.
        assign keymap_target_line->* to field-symbol(<keymap_target_line>).
        assign <keymap_entry>-source->* to <keymap_source>.

        loop at <failed_instances> assigning field-symbol(<failed_instance>).
          move-corresponding <failed_instance> to <keymap_target_line>.
          loop at <keymap_target> using key primary_key assigning field-symbol(<dep>)
           where ('TABLE_LINE = <KEYMAP_TARGET_LINE>').
            read table <keymap_source> index sy-tabix assigning field-symbol(<dep_source>).
            assert sy-subrc = 0.
            get_efail_and_ifails <keymap_entry>-source_entity.
            insert initial line into table <ifails> assigning field-symbol(<i>).
            move-corresponding <failed_instance> to <i>. " copy CAUSE etc.
            move-corresponding <dep_source>      to <i>. " copy KEY and CID
          endloop.
        endloop.

      endloop.
    endloop.

    " === Failed instances: Condense, log in BASE and remove from AUGM activities
    "    (log even those which are "only masters" of actual [lock-dependent] instances)
    loop at efails assigning <efail>.
      assign <efail>-instances->* to <ifails>.
      sort <ifails> by table_line. "#EC CI_SORTLOOP (shut up pseudo genius)
      delete adjacent duplicates from <ifails> comparing table_line.
      if base_log is not initial.
        base_log->add( kind        = if_abap_behv_log=>failed
                       root_name   = m_augm_root
                       entity_name = <efail>-entity
                       instances   = <ifails> ).
      endif.
      remove_failed_from_activities( exporting entity           = <efail>-entity
                                               failed_instances = <ifails>
                                     changing  activities       = new_activities ).
      if kind = 'P'.
        " (AUGM_in_PRCH) M_AUGM_ACTIVITIES will be re-used in 'M'odify => must be reduced too
        remove_failed_from_activities( exporting entity           = <efail>-entity
                                                 failed_instances = <ifails>
                                       changing  activities       = m_augm_activities ).
      endif.
      if m_augm_genrefs is initial
       or not line_exists( m_augm_genrefs[ ref_from-entity = <efail>-entity ] ).
        continue.
      endif.

      " === Collect RELATED instances for FAILED instances of this BASE entity, and map them to BASE
      loop at <ifails> assigning field-symbol(<ifail>).
        cl_abap_behv_job=>serialize_key( exporting instance = <ifail>
                                         importing key      = data(fail_key) ).
        loop at m_augm_genrefs using key primary_key assigning field-symbol(<ar>)
         where ref_from-entity = <efail>-entity
           and ref_from-key    = fail_key.

          data(proj_entity) = conv abp_entity_name( <ar>-ref_to-entity ).
          get_rela_for_src proj_entity.  check <rela> is assigned.
          assign failmap[ base_entity = <rela>-target_entity ] to field-symbol(<failmap>).
          if sy-subrc <> 0.
            " create helper variables for base entity (only once)
            insert value #( base_entity = <rela>-target_entity ) into table failmap assigning <failmap>.
            <failmap>-pfail = cl_abap_behvdescr=>create_data( p_name = <rela>-source_entity
                               p_op = cl_abap_behvdescr=>op_failed  p_structure = 'X' ).
            <failmap>-bfails = cl_abap_behvdescr=>create_data( p_name = <rela>-target_entity
                               p_op = cl_abap_behvdescr=>op_failed ).
            <failmap>-pkey = cl_abap_behvdescr=>create_data( p_name = <rela>-source_entity
                               p_op = cl_abap_behvdescr=>op_lock  p_structure = 'X' ).
            <failmap>-bkey = cl_abap_behvdescr=>create_data( p_name = <rela>-target_entity
                               p_op = cl_abap_behvdescr=>op_lock  p_structure = 'X' ).
          endif.
          assign <failmap>-pfail->*  to field-symbol(<pfail>).
          assign <failmap>-pkey->*   to field-symbol(<pkey>).
          assign <failmap>-bkey->*   to field-symbol(<bkey>).
          assign <failmap>-bfails->* to              <bfails>.

          cl_abap_behv_job=>deserialize_key( exporting key      = <ar>-ref_to-key
                                                       cid      = <ar>-ref_to-cid
                                             changing  instance = <pfail> ).
          " there is no direct map: PROJ-FAILED to BASE-FAILED; must go via KEY
          <pkey> = corresponding #( <pfail> ).
          to_base '!' <pkey> <bkey> <efail>-entity cl_abap_behv_ctrl=>d010behv_op-real-lock.
          insert initial line into table <bfails> assigning field-symbol(<bfail>).
          " set key
          <bfail> = corresponding #( <bkey> ).
          " set CID
          assign component cl_abap_behv=>co_techfield_name-cid of structure <bfail> to field-symbol(<bfail_cid>).
          assert sy-subrc is initial.
          <bfail_cid> = <ar>-ref_to-cid.
        endloop.
      endloop.

    endloop.

    " === Remove collected RELATED instances from BASE activities
    loop at failmap assigning <failmap>.
      assign <failmap>-bfails->* to <bfails>.
      sort <bfails> by table_line.                     "#EC CI_SORTLOOP
      delete adjacent duplicates from <bfails> comparing table_line.
      remove_failed_from_activities( exporting entity            = <failmap>-base_entity
                                               failed_instances  = <bfails>
                                     changing  activities        = m_base_job->activities
                                               instances_removed = base_instances_removed ).
    endloop.

    " === Remove new activities which failed completely (no remaining instances)
    remove_empty_activities( changing activities = m_augm_actv_fresh-realnew ).
    remove_empty_activities( changing activities = m_augm_actv_fresh-seminew ).
    if kind = 'P'.  " see conditional call of REMOVE_FAILED_FROM_ACTIVITIES above
      remove_empty_activities( changing activities = m_augm_activities ).
    endif.


  endmethod.


method execute.

  " special execute method for precheck of base for projections
  " see execute_precheck
  assert kind <> 'P'.

  field-symbols <par>         type cl_abap_behv_ctrl=>t_handler_param.
  field-symbols <base_data>   type index table.
  field-symbols <base_actv>   type abp_behv_activities.
  field-symbols <augm_data>   type index table.

  data base_idx type i.
  data proj_idx type i.

  data base_actv_changed type sychar01.

  data(base_log) = cast cl_abap_behv_log( m_base_job->log ).

* === Merge/add AUGMentation into BASE activities
  clear m_augm_info.
  if m_augm_activities is not initial.
    init_augment( ).
    if m_augm_actv_fresh-realnew is not initial.
      CHK_AUGM_COMPLIANT m_augm_actv_fresh-realnew.  " MANDCREA check for "realnew" instances
    endif.
  endif.


* === Get BASE handlers
  data base_handlers type cl_abap_behv_ctrl=>tt_handler.

  field-symbols <base_unhd> type cl_abap_behv_job_base=>tt_activity_idx .
  field-symbols <proj_unhd> type cl_abap_behv_job_base=>tt_activity_idx .
  if kind = 'L'.
    cl_abap_behv_ctrl=>get_handlers( exporting job           = me->m_base_job
                                     importing lock_handlers = base_handlers ).
    assign me->m_base_job->unhandled_activities_lock to <base_unhd>.
    assign            job->unhandled_activities_lock to <proj_unhd>.
  else.
    if m_saver is initial.
      cl_abap_behv_ctrl=>get_handlers( exporting job      = me->m_base_job
                                       importing handlers = base_handlers ).
    else.
      cl_abap_behv_ctrl=>get_handlers( exporting job      = me->m_base_job
                                       importing handlers = base_handlers
                                                 savers   = data(base_savers) ).
      " NOTE - There may be more than one base saver:
      " A mixed (DRAFT/ACTIVE) job on PROJECTION of an UNMANAGED entity with BSP-DRAFT results in
      " - one PROJECTION saver, having two base savers:
      " - one UNMANAGED saver (for the ACTIVE instances)
      " - one MANAGED saver (for the DRAFT instances)
      if m_saver->m_base_savers is initial.
        m_saver->m_base_savers = base_savers.
      else.
        loop at base_savers assigning field-symbol(<base_saver>).
          insert <base_saver> into table m_saver->m_base_savers.
        endloop.
      endif.
    endif.
    assign me->m_base_job->unhandled_activities to <base_unhd>.
    assign            job->unhandled_activities to <proj_unhd>.
  endif.

* === Execute BASE job
  loop at base_handlers assigning field-symbol(<base_hdlr>).

    if_is_augmenting kind.  " (AUGM_in_PRCH)
    " --- INSTANCES mapping just before base handler invocation (was delayed in PREPARE)
    "     Reason: %CID_REF substitution in the PROJECTION data (by SADL logger, below)
    "     is automatically transported to the next BASE handler's INSTANCES.
      loop at <base_hdlr>-params assigning <par>.
        assign <par>-instances->* to <base_data>.
        assert sy-subrc is initial.
        if <base_data> is initial.
          proj_idx = value #( m_all_actv_idxs[ base_idx = <par>-actv_idx ]-proj_idx optional ).
          if proj_idx = 0.
            " this was a new activity added by augment, but all its instances were removed
            " (due to lock failure) -> remove param (and possibly the whole handler call, below)
            delete <base_hdlr>-params.
            continue.
          endif.
          map_proj_instances( exporting
            job = job
            base_idx = <par>-actv_idx
            proj_idx = proj_idx ).
          if <base_data> is initial.
            delete <base_hdlr>-params.
          endif.
        endif.
      endloop.
    endif.

  " === Lock all 'new' AUGM instances (failures get inserted into base_log)
  " (AUGM_in_PRCH): Actual locking may have been done in 'P'recheck already
  if m_augm_actv_fresh-seminew is not initial.
    CHK_AUGM_COMPLIANT m_augm_actv_fresh-seminew.  " MANDCREA check for "seminew" instances
    " Add (successfully locked) 'semi-new' instances to corresponding base tables
    " ('real-new' instances AUGM_ACTV_FRESH-REALNEW are already in base job)
    loop at m_base_job->activities assigning <base_actv>.
      assign m_augm_actv_fresh-seminew[ op = <base_actv>-op
        entity_name = <base_actv>-entity_name  sub_name = <base_actv>-sub_name ]
        to field-symbol(<new_actv>).
      check sy-subrc = 0.
      assign <new_actv>-instances->*  to <augm_data>.
      assign <base_actv>-instances->* to <base_data>.
      insert lines of <augm_data> into table <base_data>.
    endloop.
  endif.

  if base_actv_changed is not initial.
    " Remove parameters that were emptied by lock failures in augmentation
    loop at <base_hdlr>-params assigning <par>.
      assign <par>-instances->* to <base_data>.
      if <base_data> is initial.
        delete <base_hdlr>-params.
      endif.
    endloop.
  endif.

  " _all_ instance tables completely failed due to augmentation
  if <base_hdlr>-params is not initial.

    data(smsg_log) = cast cl_abap_behv_log( cl_abap_behv_log=>create( ) ).

    data(prev_p_b_job) = cl_abap_behv_job_base=>curr_p_b_job.
    cl_abap_behv_job_base=>curr_p_b_job = m_base_job.

    cl_abap_behv_ctrl=>call_handler( handler  = <base_hdlr>-handler
                                     root     = <base_hdlr>-root
                                     params   = ref #( <base_hdlr>-params )
                                     job      = m_base_job
                                     smsg_log = smsg_log ).

    cl_abap_behv_job_base=>curr_p_b_job = prev_p_b_job.

* === Map BASE responses to PROJ responses (MAPPED) - necessary after each handler invocation
    loop at base_log->mapped_entities assigning field-symbol(<response>).
      " Here: %CID_REF substitution in PROJ job; usable in next TO_BASE above, for subsequent handlers
      transfer_to_proj_log(
          kind           = if_abap_behv_log=>mapped
          proj_root      = stdpar-root
          base_root      = <response>-root_name
          base_entity    = <response>-entity_name
          base_instances = <response>-entries->*
          flavor         = if_abap_behv_log=>projection
          log_also_base_data = 'X'
          proj_log       = job->log ).
    endloop.
    base_log->clear_mapped( ).

    if smsg_log->reported_entities is not initial.
      " now the delayed state messages (after %CID handling of MAPPED response)
      data(smsg_handler) = cl_rap_bhv_msg_handler_factory=>get_state_message_handler( ).
      loop at smsg_log->reported_entities assigning field-symbol(<smsg>).
        assign <smsg>-entries->* to <base_data>.
        smsg_handler->add( iv_entity_name = <smsg>-entity_name
                           it_instances   = <base_data>
                           io_log         = job->log ).
      endloop.
    endif.
    clear smsg_log.

  " _all_ instance tables completely failed due to augmentation
  endif.

endloop.

" Note: <base_unhd> entries may be created by a base handler CL_ABAP_BEHV_MISSING_HANDLER
if <base_unhd> is assigned and <proj_unhd> is assigned.
  loop at <base_unhd> into base_idx.
    assign me->m_all_actv_idxs[ base_idx = base_idx ] to field-symbol(<idx_pair>).
    check sy-subrc = 0.
    insert <idx_pair>-proj_idx into table <proj_unhd>.
  endloop.
endif.

" Augmenting always done in precheck (after all base handlers have been called)
clear: m_augm_info, m_augm_actv_fresh, m_augm_activities, m_augm_failed.  " not needed anymore

* === Map BASE results to PROJ results
map_results_from_base( kind          = kind
                       base_job      = m_base_job
                       job           = job
                       out_actv_idxs = m_out_actv_idxs ).

* === Map BASE FAILED to [RELATED] PROJ FAILED
map_base_failed_reported( job ).

endmethod.


method EXECUTE_AUGMENT.

data(th) = cond t_trace_hier( when cl_abap_behv_tracer=>xtrace_level >= c_xtrace-extended then value #(
  let _dummy = cl_abap_behv_tracer=>tracer->add_header_properties(
   value #( ( name = 'BEHV' value = 'Augment' ) ) ) in ##NO_TEXT
  nest = cl_abap_behv_tracer=>tracer->trace_beg(
   trace_level = c_xtrace-extended  message = |{ text_002 }|
   object = conv #( text_001 )  procedure = 'EXECUTE_AUGMENT' ) ) ).

cl_abap_behv_ctrl=>get_handlers( exporting job      = m_augm_job
                                 importing handlers = data(augm_handlers) ).

" Switch to special EML handling during augmentation job execution
" (EML will come back into ADD_AUGMENT_ACTIVITIES, not go to SADL)
data(prev_proj_hdlr) = cl_abap_behv_ctrl=>curr_proj_hdlr.
cl_abap_behv_ctrl=>curr_proj_hdlr = me.

try.

clear m_augm_handler_names.
loop at augm_handlers assigning field-symbol(<augm_hdlr>).
  data(descr) = cl_abap_objectdescr=>describe_by_object_ref( <augm_hdlr>-handler ).
  insert conv #( descr->absolute_name ) into table m_augm_handler_names.
  cl_abap_behv_ctrl=>call_handler( handler = <augm_hdlr>-handler
                                   root    = <augm_hdlr>-root
                                   params  = ref #( <augm_hdlr>-params )
                                   job     = m_augm_job ).
endloop.

cleanup.
  clear m_augm_job.
  cl_abap_behv_ctrl=>curr_proj_hdlr = prev_proj_hdlr.
endtry.

clear m_augm_job.
cl_abap_behv_ctrl=>curr_proj_hdlr = prev_proj_hdlr.

if th is not initial.
  cl_abap_behv_tracer=>tracer->trace_end( hierarchy_number = th-nest ).
endif.

endmethod.


  method GET_META_INFO.

    read table meta_cache with table key entity = entity action = action
      reference into data(cache_entry).
    if cache_entry is initial.
      cache_entry = new_meta_cache_entry( entity = entity action = action ).
    endif.
    cache_info = cache_entry->info.

  endmethod.


  method HAS_ACTIVE_REQUEST.
    loop at m_all_actv_idxs   assigning field-symbol(<pair>) where proj_idx = proj_act_idx.
      if line_exists( m_base_job->activities[ <pair>-base_idx ] ).
        assign m_base_job->activities[ <pair>-base_idx ] to FIELD-SYMBOL(<base_acitivity>).
        assign <base_acitivity>-links->* to field-symbol(<base_req>).
        if <base_req> is not initial.
          has_request = 'X'.
          return.
        endif.
      endif.
    endloop.
  endmethod.


  method INIT_AUGMENT.

  field-symbols <augm_data>   type index table.
  clear:
    M_AUGM_ACTV_IN_BASE,
    M_BASE_ACTV_IN_AUGM,
    M_AUGM_ACTV_FRESH.

  init_augment_keys( ).
  " collect AUGMentation activities that exist also as BASE activities
  loop at m_base_job->activities reference into data(base_actv).
    data(base_idx) = sy-tabix.
    loop at m_augm_activities assigning field-symbol(<augm>)
     where op          = base_actv->op
       and entity_name = base_actv->entity_name
       and sub_name    = base_actv->sub_name.
      data(augm_idx) = sy-tabix.
      insert augm_idx into table m_augm_actv_in_base.
      insert base_idx into table m_base_actv_in_augm.
      assign <augm>-instances->* to <augm_data>.
      insert value #( idx = augm_idx ) into table m_augm_info
       assigning field-symbol(<info>).
      check sy-subrc = 0.  " <> 0 for repeated base activity (unlikely)
      <info>-keys = determine_keys_for_actv( activity = <augm>
                                             instances = <augm_data> ).
    endloop.  " at M_AUGM_ACTIVITIES for <BASE_ACTV>
  endloop.  " at M_BASE_JOB->ACTIVITIES

  " Set IS_DRAFT flag correctly in (new) AUGM activities (essential for handler determination)
  data a_content type cl_abap_behv_job_base=>t_content.
  call 'BEHV_EXEC' id 'OP' field 2
    id 'ACTIVITIES' field m_augm_activities id 'OVERALL' field a_content. "#EC CI_CCALL
  if m_base_job->m_content = cl_abap_behv_job_base=>content_unknown.
    m_base_job->m_content = a_content.
  elseif m_base_job->m_content <> a_content and a_content <> cl_abap_behv_job_base=>content_unknown.
    m_base_job->m_content = cl_abap_behv_job_base=>content_mixed.
  endif.

  loop at m_augm_activities assigning <augm>.
    augm_idx = sy-tabix.
    if not line_exists( m_augm_actv_in_base[ table_line = augm_idx ] ).
      " Add completely 'new' AUGMentation activities to intermediate storage
      insert <augm> into table m_augm_actv_fresh-realnew.
      " ... and to BASE job, for handler determination (may be later reduced by lock failures)
      insert <augm> into table m_base_job->activities.
    endif.
  endloop.

  endmethod.


method INIT_AUGMENT_KEYS.

if keys_create is not initial.
  return.
endif.

data(CID_empty)        = |{ fn-CID } = ``|.
data(CID_filled)       = |{ fn-CID } > ``|.
data(CID_REF_empty)    = |{ fn-CID_REF } = ``|.
data(CID_REF_filled)   = |{ fn-CID_REF } > ``|.
data(w_CID_EQ)         = |{ fn-CID } = <BI>-{ fn-CID } AND { CID_filled }|.
data(w_CID_REF_EQ)     = |{ fn-CID_REF } = <BI>-{ fn-CID_REF } AND { CID_REF_filled }|.
data(w_CID_REF_EQ_CID) = |{ fn-CID_REF } = <BI>-{ fn-CID } AND { CID_REF_filled }|.

* NOTE: Multiple WHEREs used for an operation must be disjoint, partitioned by PART.

" --- For use with BASE instances (<BI>)

" Keys to use for Create: %CID filled; %CID empty + %KEY
keys_create = value #(
    name = kn-CID
  ( part  = CID_filled
    where = w_CID_EQ )
  ( part  = CID_empty
    where = |{ CID_empty } AND { fn-KEY } = <BI>-{ fn-KEY }| )
).

" Key to use for Update: %CID_REF filled; %CID_REF empty + %TKY
keys_update = value #(
    name = kn-CID
  ( part    = CID_REF_filled
    where   = w_CID_REF_EQ
    where_f = w_CID_REF_EQ_CID )
  ( part    = CID_REF_empty
    where   = |{ CID_REF_empty } AND { fn-TKY } = <BI>-{ fn-TKY }| )
).

" Keys to use for CBA source (having no %PID): %CID_REF filled; %CID_REF empty + %KEY
keys_cba_src_excl_pid = value #(
    name = kn-CID
  ( part    = CID_REF_filled
    where   = w_CID_REF_EQ
    where_f = w_CID_REF_EQ_CID )
  ( part    = CID_REF_empty
    where   = |{ CID_REF_empty } AND { fn-KEY } = <BI>-{ fn-KEY }| )
).

" Keys to use for CBA source (having a %PID): %CID_REF filled; %CID_REF empty + %PKY
keys_cba_src_incl_pid = value #(
    name = kn-CID
  ( part    = CID_REF_filled
    where   = w_CID_REF_EQ
    where_f = w_CID_REF_EQ_CID )
  ( part    = CID_REF_empty
    where   = |{ CID_REF_empty } AND { fn-PKY } = <BI>-{ fn-PKY }| )
).

" Keys to use for CBA target: %CID filled; %CID empty + %KEY
keys_cba_trg = value #(
    name = kn-CID
  ( part  = CID_filled
    where = |{ fn-CID } = <BITI>-{ fn-CID } AND { CID_filled }| )
  ( part  = CID_empty
    where = |{ CID_empty } AND { fn-KEY } = <BITI>-{ fn-KEY }| )
).

" Key to use for Type-with-CID vs. Failed: %CID filled
keys_cid_cid = value #(
    name = kn-CID
  ( part  = CID_filled
    where = w_CID_EQ )
).

" Key to use for Type-with-CID_REF vs. Failed: %CID_REF filled
keys_cid_cid_ref = value #(
    name = kn-CID
  ( part  = CID_REF_filled
    where = w_CID_REF_EQ_CID )
).

" Key to use for Action: %CID_REF filled; %CID_REF empty + %TKY
keys_action = value #(
    name = kn-CID
  ( part    = CID_REF_filled
    where   = w_CID_REF_EQ
    where_f = w_CID_REF_EQ_CID )
  ( part    = CID_REF_empty
    where   = |{ CID_REF_empty } AND { fn-TKY } = <BI>-{ fn-TKY }| )
).

" --- For use with PROJ instances (<PI>)

" Key to use for Failed vs. Type-with-CID: %CID filled; %CID empty + %KEY
keys_failed_with_cid = value #(
    name = kn-CID
  ( part  = CID_filled
    where = |{ fn-CID } = <PI>-{ fn-CID } AND { CID_filled }| )
  ( part  = CID_empty
    where = |{ CID_empty } AND { fn-KEY } = <PI>-{ fn-KEY }| )
).

" Key to use for Failed vs. Type-with-CID_REF: %CID filled; %CID empty + %KEY
keys_failed_with_cid_ref = value #(
    name = kn-CID
  ( part  = CID_filled
    where = |{ fn-CID } = <PI>-{ fn-CID_REF } AND { CID_filled }| )
  ( part  = CID_empty
    where = |{ CID_empty } AND { fn-KEY } = <PI>-{ fn-KEY }| )
).

endmethod.


method inst_perm_new_aug_insts.

  data(new_activities) = value abp_behv_activities_tab(
    ( lines of m_augm_actv_fresh-realnew )
    ( lines of m_augm_actv_fresh-seminew ) ).

  " evaluate base job log with failed from base prechecks
  data(base_log_cl) = cast cl_abap_behv_log( base_log ).
  if base_log_cl->failed_entities is not initial.
    evaluate_failed(
      exporting failed_entities = base_log_cl->failed_entities
                kind = kind
      changing new_activities = new_activities
               base_instances_removed = base_instances_removed ).

  endif. " failures

  " build for all instances in m_augm_activities, read only check must be
  " done for all update instances, up until now only update is relevant
  " because create has no instance checks and there are no other
  " augmenting possibilities,
  " if this changes then extra logic is needed here
  build_for_instance_permissions( exporting activities = m_augm_activities
                                  receiving job        = data(perm_job) ).

  if perm_job is bound.
    cl_abap_behv_ctrl=>call_permissions( perm_job ).
    reduce_aug_by_inst_perm( exporting aug_root   = m_augm_root
                                       perm_job   = perm_job
                             changing  activities = new_activities ).
    data(failed_entities) = cast cl_abap_behv_log( perm_job->log )->failed_entities.
    data(reported_entities) = cast cl_abap_behv_log( perm_job->log )->reported_entities.
  endif.

  " failed from instance permissions and lock job
  if failed_entities is not initial.

    evaluate_failed(
      exporting failed_entities = failed_entities
                base_log = base_log
                kind = kind
      changing new_activities = new_activities
               base_instances_removed = base_instances_removed ).

  endif. " failures

  " reported from instance permissions and lock job
  loop at reported_entities assigning field-symbol(<reported>).
    base_log->add( kind = if_abap_behv_log=>reported
                   root_name = <reported>-root_name
                   entity_name = <reported>-entity_name
                   instances = <reported>-entries->* ).
  endloop.

endmethod.


method CHECK_AUGMENT.

data ref type ref to data.

field-symbols <rela> type cl_abap_behv_load=>t_relat_ext.
field-symbols <instances> type index table.
field-symbols <base_instances> type index table.
field-symbols <proj_instances> type index table.
field-symbols <orig_instances> type index table.
field-symbols <keys> type tt_key_info.

dummy = 0. " - always -

assert M_AUGM_ORIG_JOB is not initial.  " set in CALL_AUGMENT

get_rela_for_trg entity_name m_proj_root.
check <rela> is assigned.  " ASSERT?

assign instances->* to <instances>.

if relating_by is initial.
  " all augm instances must be implicitly related
  assign <instances> to <base_instances>.
else.
  " augm instances with relating entry 0 must be implicitly related
  loop at relating_by transporting no fields where table_line = 0.
    if ref is initial.
      create data ref like <instances>.  assign ref->* to <base_instances>.
    endif.
    insert <instances>[ sy-tabix ] into table <base_instances>.
  endloop.
  if <base_instances> is not assigned.
    return.  " ok, done
  endif.
endif.

CREATE_WITH_OTHER_ENTITY intf base m_proj_root <rela>-SOURCE_ENTITY ref instances .
assign ref->* to <proj_instances>.
<proj_instances> = corresponding #( <base_instances> mapping to entity ).
sort <proj_instances> by table_line.
delete adjacent duplicates from <proj_instances> comparing table_line.

" <PROJ_INSTANCES> =  instances that must be present in an original activity

init_augment_keys( ).

loop at <proj_instances> assigning field-symbol(<bi>).  " <BI> is used in WHERE strings
  data(inst_ok) = 0.

  " search <BI> in all original activities (by %CID / by key, depending on operation)
  loop at M_AUGM_ORIG_JOB->activities assigning field-symbol(<actv>) where instances is not initial.
    assign <actv>-instances->* to <orig_instances>.
    check <orig_instances> is not initial.
    data(actv_idx) = sy-tabix.
    if  <actv>-op          eq cl_abap_behv_ctrl=>op-ACTION  " actions never match by key
     or <actv>-op          ne operation
     or <actv>-entity_name ne <rela>-SOURCE_ENTITY.
      " mismatch of operation: search only for CID (in %CID or %CID_REF)
      assign <orig_instances>[ 1 ] to field-symbol(<oi>).
      assign component fn-CID_REF of structure <oi> to field-symbol(<oc>).
      if sy-subrc = 0.
        assign keys_cid_cid_ref to <keys>.
      else.
        assign keys_cid_cid to <keys>.
      endif.
    else.
      " match of operation: search with all applicable 2ndary keys
      assign M_AUGM_ORIG_INFO[ idx = actv_idx ] to field-symbol(<key_info>).
      if sy-subrc <> 0.
        insert value #( idx = actv_idx ) into table M_AUGM_ORIG_INFO assigning <key_info>.
        <key_info>-keys = determine_keys_for_actv( activity  = <actv>
                                                   instances = <orig_instances> ).
      endif.
      assign <key_info>-keys to <keys>.
    endif.

    loop at <keys> assigning field-symbol(<key>).
      data(where) = cond #( when <key>-where_f is not initial then <key>-where_f else <key>-where ).
      loop at <orig_instances> transporting no fields using key (<key>-name) where (where).
        inst_ok = 1.  exit.
      endloop.
      if inst_ok = 1.  exit.  endif.
    endloop.

    if inst_ok = 1.  exit.  endif.
  endloop. " at M_AUGM_ORIG_JOB->ACTIVITIES

  if inst_ok = 0.
    clear cc_ok.  return.  " unrelated instance found (one violation is enough)
  endif.

endloop. " at <PROJ_INSTANCES>

endmethod.


method CREATE_WITH_OTHER_BDEF.

CREATE_WITH_OTHER_BDEF intf base bdef_name res_data src_data.

endmethod.


  method IS_DRAFT_EDIT.

    read table meta_cache with table key entity = entity action = action
      reference into data(cache_entry).
    if cache_entry is initial.
      cache_entry = new_meta_cache_entry( entity = entity action = action ).
    endif.
    is_draft_action_edit = cache_entry->info-is_draft_action_edit.

  endmethod.


method MAP_FROM_BASE_PARAMS.

" --- (*XVI*) used for extensibility-via-interface ---

" NB: "CORRESPONDING / MAPPING TO ENTITY" in this routine uses the reverse (non-standard) direction

data sub_name type abp_behv_activities-sub_name.

field-symbols <base_data> type data.
field-symbols <intf_data> type data.
field-symbols <base_full> type data.
field-symbols <intf_full> type data.
field-symbols <rela>      type cl_abap_behv_load=>t_relat_ext.

clear: proj_params, proj_stdpar.

" Note: PROJ_STDPAR-ROOT must be set to BASE, not to INTF.
" - Even though the extension works "using" INTF, it implements BASE
" - If the extension uses LOCAL MODE, it only works with BASE
proj_stdpar-root = base_stdpar-root.
*proj_stdpar-root = proj_root.  " wrong

proj_stdpar-r_image = base_stdpar-r_image.

cl_abap_behv_load=>get_relation( source_entity = proj_root
                                 kind          = cl_abap_behv_load=>c_relation_base
                                 original_root = proj_root ).

loop at base_params assigning field-symbol(<par>).

  insert <par> into table proj_params assigning field-symbol(<intf_par>).  " for PARAM_IDX etc.
  assign job->activities[ <par>-actv_idx ] to field-symbol(<actv>).

  get_rela_for_trg <actv>-entity_name proj_root.
  assert <rela> is assigned.
  sub_name = <actv>-sub_name.

  data(actv_op) = conv abp_behv_op( translate( val = <actv>-op from = `xy` to = `AE` ) ).

  if actv_op ca 'ON'.  " map association name from base (renaming in interface extension supported)
    sub_name = value #( <rela>-base_assocs[ key base other_name = sub_name ]-local_name
                        default sub_name ).
  elseif actv_op ca 'AE'.  " map action/function name from base
    sub_name = value #( <rela>-base_actions[ key base other_name = sub_name ]-local_name
                        optional ).
  endif.

  if <par>-instances is not initial.
    cl_abap_behvdescr=>create_data( exporting p_name     = <rela>-SOURCE_ENTITY
                                              p_root     = proj_root
                                              p_op       = actv_op
                                              p_sub_name = sub_name
                                    receiving p_data     = <intf_par>-instances ).
    assign: <intf_par>-instances->* to <intf_data>, <par>-instances->* to <base_data>.
    <intf_data> = corresponding #( <base_data> mapping to entity ).
  endif.

  if <par>-results is not initial.
    if actv_op ca cl_abap_behv_ctrl=>op_chars_w_grp.
      CREATE_WITH_OTHER_ENTITY intf base proj_root <rela>-SOURCE_ENTITY
                               <intf_par>-results <par>-results.
    else.
      cl_abap_behvdescr=>create_data( exporting p_name     = <rela>-SOURCE_ENTITY
                                                p_root     = proj_root
                                                p_op       = actv_op
                                                p_sub_name = sub_name
                                                p_kind     = if_abap_behv=>typekind-result
                                      receiving p_data     = <intf_par>-results ).
    endif.
  endif.

  if <par>-links is not initial.
    if actv_op ca cl_abap_behv_ctrl=>op_chars_w_grp.
      CREATE_WITH_OTHER_ENTITY intf base proj_root <rela>-SOURCE_ENTITY
                               <intf_par>-links <par>-links.
      assign: <intf_par>-links->* to <intf_data>, <par>-links->* to <base_data>.
      " this wouldn't work because there are no mapping forms for GROUPs:
      "<intf_data> = corresponding #( <base_data> mapping to entity ).
      CREATE_FULL_FOR_GROUP base.
      CREATE_FULL_FOR_GROUP intf.
      assign: intf_full_ref->* to <intf_full>, base_full_ref->* to <base_full>.
      <base_full> = corresponding #( deep <base_data> ).
      <intf_full> = corresponding #( <base_full> mapping to entity ).
      <intf_data> = corresponding #( deep <intf_full> ).
    else.
      cl_abap_behvdescr=>create_data( exporting p_name     = <rela>-SOURCE_ENTITY
                                                p_root     = proj_root
                                                p_op       = actv_op
                                                p_sub_name = sub_name
                                                p_kind     = if_abap_behv=>typekind-link
                                      receiving p_data     = <intf_par>-links ).
    endif.
  endif.

  if base_stdpar-r_failed is not initial.
    CREATE_WITH_OTHER_BDEF intf base proj_root proj_stdpar-r_FAILED   base_stdpar-r_FAILED.
  endif.

  if base_stdpar-r_mapped is not initial.
    CREATE_WITH_OTHER_BDEF intf base proj_root proj_stdpar-r_MAPPED   base_stdpar-r_MAPPED.
  endif.

  if base_stdpar-r_reported is not initial.
    CREATE_WITH_OTHER_BDEF intf base proj_root proj_stdpar-r_REPORTED base_stdpar-r_REPORTED.
  endif.

endloop.

endmethod.


method MAP_TO_BASE_RESPONSES.

" --- (*XVI*) used for extensibility-via-interface ---

" NB: "CORRESPONDING / MAPPING FROM ENTITY" here uses the reverse (non-standard) direction

field-symbols <base_data> type data.
field-symbols <intf_data> type data.
field-symbols <base_full> type data.
field-symbols <intf_full> type data.

assert lines( proj_params ) = lines( base_params ).

* --- Result Parameters

loop at base_params assigning field-symbol(<par>).

  assign proj_params[ sy-tabix ] to field-symbol(<intf_par>).
  assign job->activities[ <par>-actv_idx ] to field-symbol(<actv>).

  if <par>-results is not initial.
    assign: <intf_par>-results->* to <intf_data>, <par>-results->* to <base_data>.
    if <actv>-op na cl_abap_behv_ctrl=>op_chars_w_grp.
      <base_data> = corresponding #( <intf_data> mapping from entity ).
    else.
      GET_ABSNAME base <par>-results.       CREATE_FULL_FOR_GROUP base.
      GET_ABSNAME intf <intf_par>-results.  CREATE_FULL_FOR_GROUP intf.
      assign: intf_full_ref->* to <intf_full>, base_full_ref->* to <base_full>.
      <intf_full> = corresponding #( deep <intf_data> ).
      <base_full> = corresponding #( <intf_full> mapping from entity ).
      <base_data> = corresponding #( deep <base_full> ).
    endif.
  endif.

  if <par>-links is not initial
   and <actv>-op = cl_abap_behv_ctrl=>op-READ_BA.  " else LINKS is input
    assign: <intf_par>-links->* to <intf_data>, <par>-links->* to <base_data>.
    <base_data> = corresponding #( <intf_data> mapping from entity ).
  endif.

endloop.


* --- Responses

" NB: Forms EP_FAILED[_LATE] etc. execute the reverse (non-standard) direction

define TO_BASE_RESP.
  if proj_stdpar-r_&1 is not initial.
    assign proj_stdpar-r_&1->* to <intf_data>.
    if <intf_data> is not initial.
      assign base_stdpar-r_&1->* to <base_data>.
      if late = '?'.
        GET_ABSNAME intf proj_stdpar-r_&1.
        late = xsdbool( contains( val = intf_absname end = `_LATE` ) ).
      endif.
      if late = 'X'.
        perform EP_&1_LATE in program (prog) using <intf_data> ' ' changing <base_data>.
      else.
        perform EP_&1 in program (prog) using <intf_data> ' ' changing <base_data>.
      endif.
    endif.
  endif.
end-of-definition.

data(prog) = conv program( proj_root ).
overlay prog with '==============================BD'.

data late type sychar01 value '?'.

TO_BASE_RESP FAILED.

TO_BASE_RESP MAPPED.

TO_BASE_RESP REPORTED.


endmethod.


method TRANSFER_STRUC_TO_PROJ_LOG.

field-symbols <base_resp> type index table.

data(rela) = cl_abap_behv_load=>get_relation( source_entity = proj_root
                                              kind          = cl_abap_behv_load=>c_relation_base
                                              original_root = proj_root ).
if rela->target_entity <> base_root.
  return.
endif.

data(base_enames) = |({ base_root width = 30 pad = '=' }BD)ENTITYNAME| ##NUMBER_OK.
assign (base_enames) to field-symbol(<base_enames>).

do.
  assign component sy-index of structure base_response to <base_resp>.
  if sy-subrc <> 0.  exit.  endif.
  check <base_resp> is not initial.
  assign component sy-index of structure <base_enames> to field-symbol(<base_ename>).
  TRANSFER_TO_PROJ_LOG(
      kind           = if_abap_behv_log=>mapped
      proj_root      = proj_root
      base_root      = base_root
      base_entity    = <base_ename>
      base_instances = <base_resp>
      flavor         = if_abap_behv_log=>projection
      log_also_base_data = ' '
      proj_log       = log ).
enddo.

endmethod.


  method transfer_to_proj_log.
    field-symbols <proj_instances> type index table.
    field-symbols <rela>           type cl_abap_behv_load=>t_relat_ext.
    data op type abp_behv_op.

    check base_instances is not initial.
    if kind <> if_abap_behv_log=>reported or base_entity is not initial. " REPORTED allows empty BASE_ENTITY, see below

      get_rela_for_trg base_entity proj_root.
      check <rela> is assigned.

      case kind.
        when if_abap_behv_log=>mapped.   op = cl_abap_behv_ctrl=>d010behv_op-virtual-mapped.
        when if_abap_behv_log=>failed.   op = cl_abap_behv_ctrl=>d010behv_op-virtual-failed.
        when if_abap_behv_log=>reported. op = cl_abap_behv_ctrl=>d010behv_op-virtual-reported.
        when others. assert 0 = 1.
      endcase.

      data(proj_instances) = cl_abap_behvdescr=>create_data( p_name = <rela>-source_entity p_op = op ).
      assign proj_instances->* to <proj_instances>.

      to_proj '!' <proj_instances> base_instances base_entity op.

      proj_log->add( kind        = kind
                     root_name   = proj_root
                     entity_name = <rela>-source_entity
                     instances   = <proj_instances>
                     flavor      = flavor ).

    elseif base_instances[ 1 ] is instance of if_abap_behv_message.
      " FOREIGN in base -> FOREIGN in projection
      proj_log->add( root_name   = proj_root
                     entity_name = ''
                     kind        = if_abap_behv_log=>reported
                     flavor      = flavor
                     instances   = base_instances ).
    endif.

    if log_also_base_data is not initial.
      " kludge: also log BASE in PROJECTION job; needed for later CONVERT KEY
      proj_log->add( kind        = kind
                     root_name   = base_root
                     entity_name = base_entity
                     instances   = base_instances
                     flavor      = if_abap_behv_log=>base ).
    endif.
  endmethod.
ENDCLASS.