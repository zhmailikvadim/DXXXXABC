class CL_PO_HEADER_HANDLE_MM definition
  public
  inheriting from CL_HANDLE_MM
  create public .

*"* public components of class CL_PO_HEADER_HANDLE_MM
*"* do not include other source files here!!!
public section.
  type-pools MMCHP .
  class CL_PROCESS_STATE_MM definition load .

  interfaces IF_DCM_ADAPTER .
  interfaces IF_LONGTEXTS_MM .
  interfaces IF_OBSERVER_MM .
  interfaces IF_OUTPUT_MM .
  interfaces IF_PARTNERS_MM .
  interfaces IF_PURCHASE_ORDER_MM .
  interfaces IF_PURCHASING_DOCUMENT .
  interfaces IF_RELEASABLE_MM .
  interfaces IF_RELEASE_STATE_MM .
  interfaces IF_UNIQUE_INSTANCE_MM .

  constants C_OBJTYP type MEPO_OBJDESC-OBJTYP value 'BUS2012_HD' ##NO_TEXT.
  class-data STRATEGY_MANAGER type ref to IF_RELEASE_STRATEGY_MANAGER_MM read-only .
  class-data MY_HEADER_PROPOSER type ref to IF_DATAPROVIDER_MM read-only .
  data PO_NUMBER type EKKO-EBELN .
  data MY_RECHECK_QUEUE type MMPUR_MODELS .
  data MY_IBS_FIREWALL_ON type MMPUR_BOOL .
  data MY_CUST_FIREWALL_ON type MMPUR_BOOL .
  data FOR_BAPI type MMPUR_BOOL .
  data FOR_API type MMPUR_BOOL .
  data HAS_HIERARCHY type MMPUR_BOOL .
  data FOR_POHANDLER type MMPUR_BOOL .
  data POSTED type MMPUR_BOOL read-only .
  data EIKP_CHANGED type MMPUR_BOOL .
  data NO_MESSAGING type MMPUR_BOOL .
  data NO_MESSAGE_REQ type MMPUR_BOOL .
  data NO_AUTHORITY type MMPUR_BOOL .
  data NO_PRICE_FROM_PO type MMPUR_BOOL .
  class-data MY_BAPI type MMPUR_BOOL .
  data FOR_ME59N type MMPUR_BOOL .

  class-methods CLASS_CONSTRUCTOR .
  class-methods CHP_REFRESH_HASH_TABLE .
  methods PO_PREPARE_CREATION
    importing
      !IM_NO_AUTH_CHECK type MMPUR_BOOL default MMPUR_NO
    exceptions
      NO_AUTHORITY .
  methods CONSTRUCTOR
    importing
      !IM_PO_NUMBER type EKKO-EBELN optional
      !IV_ADDRESS_HANDLING_ACTIVE type ABAP_BOOL optional
      !IO_ADDRESS_HANDLER type ref to IF_MM_PUR_PO_ADDRESS_UTILITY optional
    preferred parameter IM_PO_NUMBER
    exceptions
      FAILURE .
  methods SET_PO_NUMBER
    importing
      !IM_PO_NUMBER type EKKO-EBELN
      !IM_GOS type ref to CL_GOS_MANAGER optional .
  methods GET_DATA
    exporting
      value(EX_DATA) type MEPOHEADER
    exceptions
      FAILURE .
  methods GET_DATAX
    exporting
      !EX_DATA type MEPOHEADERX .
  methods SET_DATA
    importing
      value(IM_DATA) type MEPOHEADER .
  methods SET_DATAX
    importing
      !IM_DATA type MEPOHEADERX .
  methods PO_READ
    importing
      !IM_TCODE type SY-TCODE
      !IM_TRTYP type T160-TRTYP
      !IM_AKTYP type CHAR1
      !IM_PO_NUMBER type EKKO-EBELN
      !IM_DOCUMENT type MEPO_DOCUMENT optional
      !IM_GOS type ref to CL_GOS_MANAGER optional
    exporting
      !EX_RESULT type MMPUR_BOOL .
  methods PO_CLOSE .
  methods PO_INITIALIZE
    importing
      !IM_DOCUMENT type MEPO_DOCUMENT optional .
  methods HAS_CHANGED
    returning
      value(RET_CHANGED) type MMPUR_BOOL .
  methods GET_TRANSACTION_STATE
    exporting
      !EX_TRTYP type T160-TRTYP
      !EX_AKTYP type CHAR1
      !EX_TCODE type SY-TCODE
      !EX_UNCOMPLETE type MMPUR_BOOL
      !EX_PARKING_ALLOWED type MMPUR_BOOL
      !EX_PARKING_ALLOWED_FINAL type MMPUR_BOOL
      !EX_NEUDRUCK type MMPUR_BOOL
      !EX_UNCOMPLETETYPE type MEMORYTYPE
      !EX_PARKHOLD_ACTIVE type MMPUR_BOOL
    changing
      !CH_T160D type T160D optional .
  methods SET_TRANSACTION_STATE
    importing
      !IM_TRTYP type T160-TRTYP
      !IM_AKTYP type CHAR1
      !IM_TCODE type SY-TCODE .
  methods PO_POST
    importing
      !IM_UNCOMPLETE type MMPUR_BOOL default MMPUR_NO
      !IM_NO_COMMIT type MMPUR_BOOL default MMPUR_NO
      !IM_COMMIT_WAIT type MMPUR_BOOL default MMPUR_NO
      !IM_UNCOMPLETETYPE type MEMORYTYPE default MMPUR_NO
    exceptions
      FAILURE .
  methods PO_CHECK
    importing
      !IM_UNCOMPLETE type MMPUR_BOOL default MMPUR_NO
      !IM_UNCOMPLETETYPE type MEMORYTYPE default MMPUR_NO
      !IM_INACTIVE_DOC type ABAP_BOOL default ' '
    preferred parameter IM_UNCOMPLETE
    returning
      value(RET_SEVERITY) type I
    exceptions
      CANCELLED .
  methods PO_CANCEL
    importing
      value(SKIP_POPUP) type C
    returning
      value(RET_SEVERITY) type I .
  methods PO_UNCANCEL
    importing
      value(SKIP_POPUP) type C
    returning
      value(RET_SEVERITY) type I .
  methods GET_TKOMV
    exporting
      !EX_TKOMV type MMPUR_TKOMV
      !EX_ITEM_CONDITIONS_CHANGED type MMPUR_BOOL
      !EX_HEADER_CONDITIONS_CHANGED type MMPUR_BOOL
      !EX_HEADER_CALCULATION_TYPE type KOMV-KSTEU .
  methods SET_TKOMV
    importing
      !IM_TKOMV type MMPUR_TKOMV
      !IM_ITEM_CONDITIONS_CHANGED type MMPUR_BOOL optional
      !IM_HEADER_CONDITIONS_CHANGED type MMPUR_BOOL optional
      !IM_HEADER_CALCULATION_TYPE type MMPUR_BOOL optional .
  methods REFRESH_TKOMV .
  methods LOOKUP
    importing
      !IM_ITEM_NUMBER type EKPO-EBELP
    returning
      value(RE_ITEM) type ref to CL_PO_ITEM_HANDLE_MM .
  methods EXPAND_FROM_REQUISITIONS
    importing
      !IM_HEADER type MEPOHEADER
    changing
      !CH_REQUISITIONS type MEREQ_T_EBAN_MEM optional
      !CH_REQUISITION_ACCOUNTINGS type MEREQ_T_EBKN optional
      !CH_REQ_ITEMS type MMPUR_REQUISITION_ITEMS optional
      !CH_REQ_ACCOUNTINGS type MMPUR_ACCOUNTING_LIST optional
    exceptions
      FAILURE .
  methods GET_ITEMS_WITH_REQUISITION
    importing
      !IM_BANFN type BANFN
      !IM_BNFPO type BNFPO
    exporting
      !ET_ITEMS type MMPUR_SUBITEMS .
  methods CHP_ADD_CHANGELIST
    importing
      !IM_CHANGELIST type MMCHP_CHP_LIST .
  methods REFRESH_EIKP_DATA .
  methods GET_GOS_MANAGER
    returning
      value(RE_MANAGER) type ref to CL_GOS_MANAGER .
  methods SET_REVAL_ATTRIBUTES
    importing
      !IM_NO_VERSION type MMPUR_BOOL default MMPUR_NO
      !IM_NO_RELEASE type MMPUR_BOOL default MMPUR_NO
    preferred parameter IM_NO_VERSION .
  methods GET_REVAL_ATTRIBUTES
    exporting
      !EX_NO_VERSION type MMPUR_BOOL
      !EX_NO_RELEASE type MMPUR_BOOL .
  methods SET_CONFIRMATION_HANDLE
    importing
      !IM_CONFIRMATION type ref to IF_MMPUR_CONF_HEADER .
  methods IS_ORDRSP
    returning
      value(RV_ACTIVE) type MMPUR_BOOL .
  class-methods SET_RESWK_PARAM_VALUE
    importing
      !IV_PARAM type WERKS_D .
  methods SET_HIERARCHY_FIELD
    importing
      !IS_HIERARCHY type BOOLEAN .
  methods GET_HIERARCHY_FIELD
    returning
      value(RV_HIERARCHY) type BOOLEAN .
  methods IS_INTERACTIVE_MODE_ACTIVE
    returning
      value(IV_ACTIVE) type ABAP_BOOL .
  methods ENABLE_INTERACTIVE_MODE .
  methods DISABLE_INTERACTIVE_MODE .

  methods ADD_ITEM
    redefinition .
  methods CAN_INITIATE_FLUSH
    redefinition .
  methods CHP_ADD_HASH_ENTRY
    redefinition .
  methods CHP_REGISTER
    redefinition .
  methods GET_ITEMS
    redefinition .
  methods IF_ASYNC_SUBJECT_MM~GET_CHANGES
    redefinition .
  methods IF_ASYNC_SUBJECT_MM~RESET_CHANGES
    redefinition .
  methods IF_FIELDSELECTION_MM~FS_GET
    redefinition .
  methods IF_FLUSH_TRANSPORT_MM~START
    redefinition .
  methods IF_MESSAGE_OBJ_MM~DESCRIBE
    redefinition .
  methods SET_PARENT
    redefinition .
  methods SET_STATE
    redefinition .
protected section.
*"* protected components of class CL_PO_HEADER_HANDLE_MM
*"* do not include other source files here!!!

  methods FLUSH_DATA
    redefinition .
  methods GET_MAPPING
    redefinition .
private section.
*"* private components of class CL_PO_HEADER_HANDLE_MM
*"* do not include other source files here!!!

  types:
    BEGIN OF po_header_hash_entry,
      header TYPE REF TO cl_po_header_handle_mm,
      data   TYPE mepoheader,
    END OF po_header_hash_entry .
  types:
    BEGIN OF po_headerx_hash_entry,
      header TYPE REF TO cl_po_header_handle_mm,
      data   TYPE mepoheaderx,
    END OF po_headerx_hash_entry .
  types:
    BEGIN OF lty_badi_queue_entry,
      varkey TYPE char32,
      handle TYPE REF TO cl_handle_mm,
    END OF lty_badi_queue_entry .
  types:
    lty_badi_queue TYPE SORTED TABLE OF lty_badi_queue_entry
                   WITH UNIQUE KEY varkey .
  types:
    BEGIN OF po_changelist_entry,
      header     TYPE REF TO cl_po_header_handle_mm,
      changelist TYPE mmchp_chp_list,
    END OF po_changelist_entry .
  types:
    BEGIN OF po_eikp_hash_entry,
      header TYPE REF TO cl_po_header_handle_mm,
      data   TYPE mepo_eikp,
    END OF po_eikp_hash_entry .
  types:
    BEGIN OF po_loekz_info,
      ebelp     TYPE ekpo-ebelp,
      loekzx(1),
    END OF po_loekz_info .
  types:
    BEGIN OF po_supplier_addr_hash_entry,
      header TYPE REF TO cl_po_header_handle_mm,
      data   TYPE mepoaddressdata,
    END OF po_supplier_addr_hash_entry .
  types:
    BEGIN OF po_supplierx_addr_hash_entry,
      header TYPE REF TO cl_po_header_handle_mm,
      datax  TYPE mepoaddressdatax,
    END OF po_supplierx_addr_hash_entry .

  class-data:
    po_header_chp_table         TYPE SORTED TABLE OF
                     po_changelist_entry WITH UNIQUE KEY header .
  class-data:
    po_header_hash_table        TYPE SORTED TABLE OF
                   po_header_hash_entry WITH UNIQUE KEY header .
  class-data:
    po_headerx_hash_table       TYPE SORTED TABLE OF
                   po_headerx_hash_entry WITH UNIQUE KEY header .
  class-data:
    chp_hash_table              TYPE SORTED TABLE OF
                   po_header_hash_entry WITH UNIQUE KEY header .
  class-data:
    po_eikp_hash_table          TYPE SORTED TABLE OF
                   po_eikp_hash_entry WITH UNIQUE KEY header .
  class-data:
    po_supplier_addr_hash_table TYPE SORTED TABLE OF
                   po_supplier_addr_hash_entry WITH UNIQUE KEY header .
  class-data:
    po_supplierx_addr_hash_table TYPE SORTED TABLE OF
                   po_supplierx_addr_hash_entry WITH UNIQUE KEY header .
  data MY_BADI_QUEUE type LTY_BADI_QUEUE .
  data PO_TKOMV_HASH_TABLE type MMPUR_TKOMV .
  data ITEM_CONDITIONS_CHANGED type MMPUR_BOOL .
  data HEADER_CONDITIONS_CHANGED type MMPUR_BOOL .
  data HEADER_CALCULATION_TYPE type KOMV-KSTEU .
  data MY_161 type T161 .
  class-data MY_FIELD_MAPPING type MEPO_T_METAFIELD_MAPPING .
  class-data MY_FS_TEMPLATE type TTYP_FIELDSELECTION_MM .
  data MY_ITERATION_COUNT type I .
  data:
    my_po_loekz_info TYPE TABLE OF po_loekz_info .
  data MY_PARTNERS type MMPUR_T_MMPA .
  data MY_GOS_MANAGER type ref to CL_GOS_MANAGER .
  data FM_REVAL_NO_VERSION type MMPUR_BOOL .
  data FM_REVAL_NO_RELEASE type MMPUR_BOOL .
  data MY_CONFIRMATION_HANDLE type ref to IF_MMPUR_CONF_HEADER .
  data MV_ORDRSP type MMPUR_BOOL .

  methods GET_SUPPLIER_ADDRESS
    importing
      !IS_HEADER type MEPOHEADER
      !IV_ADDRNUMBER_ONLY type ABAP_BOOL optional
    returning
      value(RS_ADDRESS) type IF_MM_PUR_PO_ADDRESS_UTILITY=>TY_ADDRESS_COMPLETE .
  methods COPY_SERVICES .
  class-methods CHECK_PROPOSER .
  methods SET_UPDATE_FOR_GOS
    for event COMMIT_REQUIRED of CL_GOS_SERVICE .
  methods REFRESH_RWIN .
ENDCLASS.



CLASS CL_PO_HEADER_HANDLE_MM IMPLEMENTATION.


METHOD if_release_state_mm~release.

  DATA: l_strategy TYPE REF TO if_release_strategy_mm,
        l_frgzu       TYPE ekko-frgzu,
        l_indicator   TYPE ekko-frgke,
        l_is_released TYPE mmpur_bool,
        lt_codes      TYPE merel_t_codes,
        l_code        LIKE LINE OF lt_codes,
        l_header      TYPE mepoheader.

  CALL METHOD get_data
    IMPORTING
      ex_data = l_header.

  MOVE: l_header-frgzu     TO l_frgzu,
        l_header-frgke     TO l_indicator.

  IF l_header-frgrl EQ space.
    l_is_released = mmpur_yes.
  ELSE.
    l_is_released = mmpur_no.
  ENDIF.

***  PO-FLEX-WFL
  IF cl_mm_pur_po_flex_wfl_helper=>gv_scn_wfl_po IS NOT INITIAL.
    l_header-frgrl = ' '.
    PERFORM set_release_state IN PROGRAM saplmepo USING l_header-frggr
                                                        l_header-frgsx
                                                        l_header-frgke
                                                        l_header-frgzu
                                                        l_header-frgrl.
    RETURN.
  ENDIF.
***  END PO-FLEX-WFL

    l_strategy = if_release_state_mm~get_strategy( ).
    CHECK NOT l_strategy IS INITIAL.


  IF im_all EQ  mmpur_no.
*- exactly one release code
    CALL METHOD l_strategy->propagate_state
      EXPORTING
        im_frgco             = im_code
        im_reset             = mmpur_no
      CHANGING
        ch_frgzu             = l_frgzu
        ch_frgke             = l_indicator
        ch_released          = l_is_released
      EXCEPTIONS
        no_authority         = 1
        prerequisite_missing = 2
        already_released     = 3
        not_released         = 4
        not_responsible      = 5
        illegal_call         = 6
        illegal_indicator    = 7
        OTHERS               = 8.

    CASE sy-subrc.
      WHEN 1. RAISE no_authority.
      WHEN 2. RAISE prerequisite_missing.
      WHEN 3. RAISE already_released.
      WHEN 5. RAISE not_responsible.
      WHEN 6. RAISE illegal_call.
      WHEN 7. RAISE illegal_indicator.
      WHEN 8. RAISE illegal_call.
    ENDCASE.
  ELSE.
*- release for all possible release codes
    DO.
      lt_codes = l_strategy->get_codes_for_release( l_frgzu ).
      READ TABLE lt_codes INTO l_code WITH KEY authority = 0.
      IF sy-subrc IS INITIAL.
        CALL METHOD l_strategy->propagate_state
          EXPORTING
            im_frgco             = l_code-rel_code
            im_reset             = mmpur_no
          CHANGING
            ch_frgzu             = l_frgzu
            ch_frgke             = l_indicator
            ch_released          = l_is_released
          EXCEPTIONS
            no_authority         = 1
            prerequisite_missing = 2
            already_released     = 3
            not_released         = 4
            not_responsible      = 5
            illegal_call         = 6
            illegal_indicator    = 7
            OTHERS               = 8.

        CASE sy-subrc.
          WHEN 1. RAISE no_authority.
          WHEN 2. RAISE prerequisite_missing.
          WHEN 3. RAISE already_released.
          WHEN 5. RAISE not_responsible.
          WHEN 6. RAISE illegal_call.
          WHEN 7. RAISE illegal_indicator.
          WHEN 8. RAISE illegal_call.
        ENDCASE.
      ELSE.
        EXIT.                                               "from do.
      ENDIF.
    ENDDO.
  ENDIF.
  l_header-frgzu = l_frgzu.
  l_header-frgke = l_indicator.
  IF l_is_released = mmpur_yes.
    l_header-frgrl = ' '.
  ELSE.
    l_header-frgrl = 'X'.
  ENDIF.

  PERFORM set_release_state IN PROGRAM saplmepo USING l_header-frggr
                                                      l_header-frgsx
                                                      l_header-frgke
                                                      l_header-frgzu
                                                      l_header-frgrl.


ENDMETHOD.                    "IF_RELEASE_STATE_MM~RELEASE


METHOD if_release_state_mm~is_released.

  DATA: l_header TYPE mepoheader.

  CALL METHOD get_data IMPORTING ex_data = l_header.

  IF l_header-frgrl IS INITIAL.
    re_released = mmpur_yes.
  ELSE.
    re_released = mmpur_no.
  ENDIF.

ENDMETHOD.


METHOD if_release_state_mm~get_strategy.

  CALL METHOD me->if_releasable_mm~get_data
    IMPORTING
      ex_strategy = re_strategy.

ENDMETHOD.                    "IF_RELEASE_STATE_MM~GET_STRATEGY


METHOD if_release_state_mm~get_state.

  DATA: l_strategy   TYPE REF TO if_release_strategy_mm,
        l_header     TYPE mepoheader,
        l_codes      LIKE re_codes.

* the strategy object is known by the releasable only
  CALL METHOD me->if_releasable_mm~get_data IMPORTING
                             ex_strategy = l_strategy.

  IF NOT l_strategy IS INITIAL.

    CALL METHOD get_data IMPORTING ex_data = l_header.

    l_codes = l_strategy->get_codes_from_state(
                                     im_frgzu = l_header-frgzu ).
  ENDIF.

  re_codes = l_codes.

ENDMETHOD.


METHOD if_release_state_mm~get_indicator.

  DATA: l_header TYPE mepoheader,
        l_desc   LIKE ex_indicator_desc.

  CALL METHOD get_data IMPORTING ex_data = l_header.

  ex_indicator = l_header-frgke.

  IF ex_indicator_desc IS REQUESTED.

    CLEAR ex_indicator_desc.
    SELECT SINGLE frget FROM t16fe INTO l_desc WHERE
                                       spras EQ sy-langu AND
                                       frgke EQ l_header-frgke.
    IF sy-subrc IS INITIAL.
      ex_indicator_desc = l_desc.
    ENDIF.

  ENDIF.

ENDMETHOD.


METHOD if_release_state_mm~can_reset_release .

  DATA: lt_codes   TYPE merel_t_codes,
        l_strategy TYPE REF TO if_release_strategy_mm,
        l_header   TYPE mepoheader.

  CALL METHOD get_data
    IMPORTING
      ex_data = l_header.

  l_strategy = if_release_state_mm~get_strategy( ).
  CHECK NOT l_strategy IS INITIAL.

  lt_codes = l_strategy->get_codes_from_state( l_header-frgzu ).
  READ TABLE lt_codes WITH KEY authority = 0 TRANSPORTING NO FIELDS.
  IF sy-subrc IS INITIAL.
    re_allowed = mmpur_yes.
  ENDIF.

ENDMETHOD.                    "IF_RELEASE_STATE_MM~CAN_RESET_RELEASE


METHOD if_release_state_mm~can_release .

  DATA: lt_codes   TYPE merel_t_codes,
        l_strategy TYPE REF TO if_release_strategy_mm,
        l_header   TYPE mepoheader.

  CALL METHOD get_data
    IMPORTING
      ex_data = l_header.

  l_strategy = if_release_state_mm~get_strategy( ).
  CHECK NOT l_strategy IS INITIAL.

  lt_codes = l_strategy->get_codes_for_release( l_header-frgzu ).
  READ TABLE lt_codes WITH KEY authority = 0 TRANSPORTING NO FIELDS.
  IF sy-subrc IS INITIAL.
    re_allowed = mmpur_yes.
  ENDIF.

ENDMETHOD.                    "IF_RELEASE_STATE_MM~CAN_RELEASE


METHOD if_releasable_mm~reject .

  DATA: l_trtyp        TYPE trtyp,
        l_header       TYPE mepoheader,
        l_severity     TYPE i,
        l_strategy     TYPE REF TO if_release_strategy_mm,
        lt_models      TYPE mmpur_models,
        l_models_entry LIKE LINE OF lt_models.


  CALL METHOD me->get_transaction_state( IMPORTING ex_trtyp = l_trtyp ).

  IF l_trtyp NE 'H' AND l_trtyp NE 'V'.
    MESSAGE e816(me) WITH 'Reject' RAISING failed.          "#EC NOTEXT
  ENDIF.

  IF im_reset EQ mmpur_no.
* Rejection
    l_severity = me->po_check( ).
    IF l_severity EQ mmpur_event_e.
      MESSAGE e002(mepo) RAISING failed.
    ENDIF.
    CALL METHOD me->get_data( IMPORTING ex_data = l_header ).

***  PO-FLEX-WFL
    CALL METHOD cl_mm_pur_po_flex_wfl_helper=>read_workflow_customizing
      EXPORTING
        iv_doc_type = l_header-bsart.
    IF cl_mm_pur_po_flex_wfl_helper=>gv_scn_wfl_po IS INITIAL.
***  END PO-FLEX-WFL
      l_strategy = if_release_state_mm~get_strategy( ).
      IF l_strategy IS INITIAL.
       IF l_header-procstat NE '26'.
        MESSAGE e298(me) WITH l_header-ebeln RAISING failed.
        ENDIF.
      ENDIF.
***  PO-FLEX-WFL
    ENDIF.
***  END PO-FLEX-WFL

    IF cl_process_state_mm=>is_allowed(
                   im_bstyp   = l_header-bstyp
                   im_state   = l_header-procstat
                   im_process = cl_process_state_mm=>c_pr_set_rej )
                                                        EQ mmpur_no.
      MESSAGE e805(mepo) WITH l_header-procstat RAISING failed.
    ENDIF.
    l_header-procstat = cl_process_state_mm=>c_rejected.
    CALL METHOD set_data( l_header ).
* process model
    l_models_entry-model ?= me.
    APPEND l_models_entry TO lt_models.
    CALL METHOD flush_data( lt_models ).
  ELSE.
*- Reset Rejection
    CALL METHOD me->get_data( IMPORTING ex_data = l_header ).
    IF cl_process_state_mm=>is_allowed(
                 im_bstyp   = l_header-bstyp
                 im_state   = l_header-procstat
                 im_process = cl_process_state_mm=>c_pr_reset_rej )
                                                      EQ mmpur_no.
      MESSAGE e806(mepo) WITH l_header-procstat RAISING failed.
    ENDIF.
    l_header-procstat = cl_process_state_mm=>c_active.
    CALL METHOD set_data( l_header ).
* process model
    l_models_entry-model ?= me.
    APPEND l_models_entry TO lt_models.
    CALL METHOD flush_data( lt_models ).
    l_severity = me->po_check( ).
  ENDIF.

ENDMETHOD.


METHOD if_releasable_mm~is_reset_rel_allowed .

  DATA: l_trtyp    TYPE trtyp,
        l_header   TYPE mepoheader,
        l_document TYPE mepo_document.

  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp = l_trtyp.

  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_header.

  PERFORM mepo_xpd_get_document IN PROGRAM saplmepo CHANGING l_document.

  IF ( l_trtyp EQ 'H' OR l_trtyp EQ 'V' ) AND
     l_document-initiator-initiator EQ mmpur_initiator_rel AND
     cl_process_state_mm=>is_allowed(
         im_bstyp   = l_header-bstyp
         IM_STATE   = L_HEADER-PROCSTAT
         im_process = cl_process_state_mm=>c_pr_reset_release )
                                                       EQ mmpur_yes.
    re_allowed = if_release_state_mm~can_reset_release( ).
  ENDIF.

ENDMETHOD.                    "IF_RELEASABLE_MM~IS_RESET_REL_ALLOWED


METHOD if_releasable_mm~is_reset_rej_allowed .

  DATA: l_trtyp  TYPE trtyp,
        l_header TYPE mepoheader.

  re_allowed = mmpur_no.

  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp = l_trtyp.
  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_header.

  IF ( l_trtyp EQ 'H' OR l_trtyp EQ 'V' ) AND
     cl_process_state_mm=>is_allowed(
        im_bstyp   = l_header-bstyp
        IM_STATE   = L_HEADER-PROCSTAT
        im_process = cl_process_state_mm=>c_pr_reset_rej ) EQ mmpur_yes.
    re_allowed = mmpur_yes.
  ENDIF.

ENDMETHOD.                    "IF_RELEASABLE_MM~IS_RESET_REJ_ALLOWED


METHOD if_releasable_mm~is_release_allowed .

  DATA: l_trtyp    TYPE trtyp,
        l_header   TYPE mepoheader,
        l_document TYPE mepo_document.

  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp = l_trtyp.

  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_header.

  PERFORM mepo_xpd_get_document IN PROGRAM saplmepo CHANGING l_document.

  IF ( l_trtyp EQ 'H' OR l_trtyp EQ 'V' ) AND
     l_document-initiator-initiator EQ mmpur_initiator_rel AND
     cl_process_state_mm=>is_allowed(
         im_bstyp   = l_header-bstyp
         IM_STATE   = L_HEADER-PROCSTAT
         im_process = cl_process_state_mm=>c_pr_release ) EQ mmpur_yes.
    re_allowed = if_release_state_mm~can_release( ).
  ENDIF.

ENDMETHOD.                    "IF_RELEASABLE_MM~IS_RELEASE_ALLOWED


METHOD if_releasable_mm~is_rejection_allowed .

  DATA: l_trtyp    TYPE trtyp,
        l_header   TYPE mepoheader,
        l_document TYPE mepo_document.

  re_allowed = mmpur_no.

  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp = l_trtyp.
  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_header.

  PERFORM mepo_xpd_get_document IN PROGRAM saplmepo CHANGING l_document.

  IF ( l_trtyp EQ 'H' OR l_trtyp EQ 'V' ) AND
     l_document-initiator-initiator EQ mmpur_initiator_rel AND
     cl_process_state_mm=>is_allowed(
         im_bstyp   = l_header-bstyp
         IM_STATE   = L_HEADER-PROCSTAT
         im_process = cl_process_state_mm=>c_pr_set_rej ) EQ mmpur_yes.
    re_allowed = if_release_state_mm~can_release( ).

  ENDIF.

ENDMETHOD.                    "IF_RELEASABLE_MM~IS_REJECTION_ALLOWED


  METHOD if_releasable_mm~initiate_release_new_wfl.
  ENDMETHOD.


METHOD if_releasable_mm~initiate_release .

  DATA: l_header             TYPE mepoheader,
        l_neudruck           TYPE mmpur_bool,
        l_trtyp              TYPE trtyp,
        l_severity           TYPE i,
        l_strategy           TYPE REF TO if_release_strategy_mm.

  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp    = l_trtyp
      ex_neudruck = l_neudruck.

  IF l_trtyp NE 'H' AND l_trtyp NE 'V'.
    MESSAGE e816(me) WITH 'Initiate_Release' RAISING failed.
  ENDIF.

  l_severity = me->po_check( ).
  IF l_severity EQ mmpur_event_e.
    MESSAGE e002(mepo) RAISING failed.
  ENDIF.

  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_header.

***  PO-FLEX-WFL
  CALL METHOD cl_mm_pur_po_flex_wfl_helper=>read_workflow_customizing
    EXPORTING
      iv_doc_type     = l_header-bsart.
  IF cl_mm_pur_po_flex_wfl_helper=>gv_scn_wfl_po IS INITIAL.
***  END PO-FLEX-WFL

    l_strategy = if_release_state_mm~get_strategy( ).
    IF l_strategy IS INITIAL.
       IF l_header-procstat NE '26'.
      MESSAGE e298(me) WITH l_header-ebeln RAISING failed.
        ENDIF.
    ENDIF.

***  PO-FLEX-WFL
  ENDIF.
***  END PO-FLEX-WFL

  IF im_reset EQ mmpur_no.
    IF cl_process_state_mm=>is_allowed(
                   im_bstyp   = l_header-bstyp
                   im_state   = l_header-procstat
                   im_process = cl_process_state_mm=>c_pr_release )
       EQ mmpur_no.
      MESSAGE e800(mepo) WITH l_header-procstat RAISING failed.
    ENDIF.
    CALL METHOD if_release_state_mm~release
      EXPORTING
        im_code              = im_code
        im_all               = im_all
      EXCEPTIONS
        no_authority         = 1
        prerequisite_missing = 2
        already_released     = 3
        not_responsible      = 4
        illegal_call         = 5
        illegal_indicator    = 6
        OTHERS               = 7.
    IF NOT sy-subrc IS INITIAL.
      CASE sy-subrc.
        WHEN 1. MESSAGE e241(me) WITH im_code RAISING failed.
        WHEN 2. MESSAGE e102(me) RAISING failed.
        WHEN 3. MESSAGE e103(me) WITH l_header-ebeln RAISING failed.
        WHEN 4. MESSAGE e104(me) RAISING failed.
        WHEN OTHERS.
          MESSAGE e816(me) WITH 'Initiate_Release'
          RAISING failed.
      ENDCASE.
    ENDIF.
  ELSE.
    IF cl_process_state_mm=>is_allowed(
                im_bstyp   = l_header-bstyp
                im_state   = l_header-procstat
                im_process = cl_process_state_mm=>c_pr_reset_release )
       EQ mmpur_no.
      MESSAGE e801(mepo) WITH l_header-procstat RAISING failed.
    ENDIF.
    CALL METHOD if_release_state_mm~reset_release
      EXPORTING
        im_code           = im_code
        im_all            = im_all
        im_statu          = l_neudruck
      EXCEPTIONS
        no_authority      = 1
        not_released      = 2
        not_responsible   = 3
        illegal_call      = 4
        illegal_indicator = 5
        po_printed        = 7                               "640242
        OTHERS            = 8.
    IF sy-subrc <> 0.
      CASE sy-subrc.
        WHEN 1. MESSAGE e241(me) WITH im_code RAISING failed.
        WHEN 2. MESSAGE e105(me) RAISING failed.
        WHEN 3. MESSAGE e104(me) RAISING failed.
        WHEN 5. MESSAGE e108(me) RAISING failed.
        WHEN 7. MESSAGE e175(me) RAISING failed.
        WHEN OTHERS.
          MESSAGE e816(me) WITH 'Initiate_Release'
          RAISING failed.
      ENDCASE.
    ENDIF.
  ENDIF.

ENDMETHOD.                    "IF_RELEASABLE_MM~INITIATE_RELEASE


METHOD if_releasable_mm~get_responsible .

  DATA: l_header      TYPE mepoheader,
        l_ekko        TYPE ekko.

  CHECK NOT im_code IS INITIAL.
  CALL METHOD me->get_data
    IMPORTING
      ex_data = l_header.
  CHECK NOT l_header-frggr IS INITIAL.
  MOVE-CORRESPONDING l_header TO l_ekko.                    "#EC *

  CALL FUNCTION 'ME_REL_GET_RESPONSIBLE_EKKO'
    EXPORTING
      im_ekko   = l_ekko
      im_code   = im_code
    IMPORTING
      ex_actors = re_actortab
    EXCEPTIONS
      OTHERS    = 0.

ENDMETHOD.                    "IF_RELEASABLE_MM~GET_RESPONSIBLE


METHOD if_releasable_mm~get_data.

  DATA: l_header    TYPE mepoheader,
        l_strategy  TYPE REF TO if_release_strategy_mm,
        l_state     TYPE REF TO if_release_state_mm.

  CALL METHOD get_data IMPORTING ex_data = l_header.

  IF NOT l_header-frggr IS INITIAL AND
     NOT l_header-frgsx IS INITIAL.

    IF strategy_manager IS INITIAL.

      CALL FUNCTION 'MEREL_GET_MANAGER'
           IMPORTING
                ex_manager = strategy_manager.

    ENDIF.

    l_strategy = strategy_manager->get_strategy(
                                     im_group        = l_header-frggr
                                     im_rel_strategy = l_header-frgsx ).
    IF NOT l_strategy IS INITIAL.
      l_state ?= me.
    ENDIF.
  ENDIF.

  ex_strategy = l_strategy.
  ex_state    = l_state.

ENDMETHOD.


METHOD if_purchasing_document~get_tkomv.

  CALL FUNCTION 'MEPO_DOC_TKOMV_GET'
       IMPORTING
            ex_tkomv = ex_tkomv.

ENDMETHOD.


METHOD if_purchasing_document~get_partners.

* ...
  DATA: l_mepoheader TYPE mepoheader,
        l_ekko TYPE ekko.

  CALL METHOD get_data
    IMPORTING
      ex_data = l_mepoheader.

  MOVE-CORRESPONDING l_mepoheader TO l_ekko.                "#EC *

  CALL FUNCTION 'MM_PARTNERS_FOR_MESSAGING'
    EXPORTING
      application = 'P'
      vorga       = 'F'
      neupr       = 'X'
      iekko       = l_ekko
    TABLES
      part        = re_part.


ENDMETHOD.


METHOD if_purchasing_document~get_items.


  DATA: l_items TYPE mmpur_models,
        wa_item LIKE LINE OF l_items,
        wa_obj  LIKE LINE OF re_items.

  CALL METHOD get_items IMPORTING ex_items = l_items.

  LOOP AT l_items INTO wa_item.
    wa_obj-object ?= wa_item-model.
    APPEND wa_obj TO re_items.
  ENDLOOP.

ENDMETHOD.


METHOD if_purchasing_document~get_ekko.


  DATA: l_mepoheader TYPE mepoheader.

  CALL METHOD get_data
    IMPORTING
      ex_data = l_mepoheader.

  MOVE-CORRESPONDING l_mepoheader TO re_ekko.               "#EC *

ENDMETHOD.


METHOD if_purchase_order_mm~set_foreign_trade .

  DATA:   l_model       TYPE REF TO if_model_mm,
          l_model_entry TYPE mmpur_model_type,
          wa            LIKE LINE OF po_eikp_hash_table,
          l_data_old    LIKE im_data.                       "841803

  l_data_old = me->if_purchase_order_mm~get_foreign_trade( ).
  CHECK l_data_old NE im_data.                              "841803

  READ TABLE po_eikp_hash_table INTO wa WITH TABLE KEY header = me.
  IF sy-subrc IS INITIAL.
    wa-data = im_data.
    MODIFY TABLE po_eikp_hash_table FROM wa.
  ELSE.
    wa-header = me.
    wa-data = im_data.
    INSERT wa INTO TABLE po_eikp_hash_table.
  ENDIF.
  eikp_changed = mmpur_yes.

  l_model ?= me.
  READ TABLE me->my_recheck_queue
             WITH KEY model = l_model TRANSPORTING NO FIELDS.
  IF NOT sy-subrc IS INITIAL.
    l_model_entry-model = l_model.
    APPEND l_model_entry TO me->my_recheck_queue.
  ENDIF.

ENDMETHOD.                    "IF_PURCHASE_ORDER_MM~SET_FOREIGN_TRADE


METHOD if_purchase_order_mm~set_data .

  DATA: l_data_old    TYPE mepoheader,
        l_datax_old   TYPE mepoheaderx,
        l_data_new    TYPE mepoheader,
        l_datax_new   TYPE mepoheaderx,
        l_mepotech    TYPE mepoheader_tech,
        l_model       TYPE REF TO if_model_mm,
        l_model_entry TYPE mmpur_model_type.

  CHECK my_ibs_firewall_on EQ mmpur_yes OR
        my_cust_firewall_on EQ mmpur_yes.

  CALL METHOD me->get_data( IMPORTING ex_data = l_data_old ).
  CALL METHOD me->get_datax( IMPORTING ex_data = l_datax_old ).
  MOVE-CORRESPONDING l_data_old TO l_mepotech.              "#EC *

  MOVE im_data TO l_data_new.
  MOVE-CORRESPONDING l_mepotech TO l_data_new.              "#EC *
  IF NOT l_data_old-ebeln IS INITIAL.
    l_data_new-ebeln = l_data_old-ebeln.
  ENDIF.

  IF l_data_new NE l_data_old.
* customer firewall
    IF my_cust_firewall_on EQ mmpur_yes.
      CALL METHOD me->process_input_filter
        EXPORTING
          im_data     = l_data_new
          im_data_old = l_data_old
        IMPORTING
          ex_data     = l_data_new.
    ENDIF.
* if process_input_filter resets changed fields no recheck has to be done
    IF l_data_new NE l_data_old.
      CALL METHOD me->set_data( im_data = l_data_new ).
      CALL METHOD me->check_badi_datax
        EXPORTING
          im_data_old  = l_data_old
          im_data_new  = l_data_new
          im_datax_old = l_datax_old
        IMPORTING
          ex_datax_new = l_datax_new.
      CALL METHOD me->set_datax( im_data = l_datax_new ).
      mmpur_dynamic_cast l_model me.
      READ TABLE my_recheck_queue WITH KEY model = l_model TRANSPORTING NO FIELDS.
      IF NOT sy-subrc IS INITIAL.
        l_model_entry-model = l_model.
        APPEND l_model_entry TO my_recheck_queue.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD if_purchase_order_mm~set_conditions .

  DATA: l_model        TYPE REF TO if_model_mm,
        ls_model_entry TYPE mmpur_model_type,
        lt_conditions  TYPE mmpur_tkomv,
        lt_cond_new    TYPE mmpur_tkomv,
        l_kposn        TYPE komv-kposn.

  CHECK me->my_ibs_firewall_on EQ mmpur_yes OR
        me->my_cust_firewall_on EQ mmpur_yes.

  CALL METHOD me->get_tkomv
    IMPORTING
      ex_tkomv = lt_conditions.

* delete old conditions
  DELETE lt_conditions WHERE kposn = l_kposn.

* insert new conditions
  CHECK NOT im_conditions IS INITIAL.
  lt_cond_new = im_conditions.
  DELETE lt_cond_new WHERE kposn NE l_kposn.
  SORT lt_cond_new.
  READ TABLE lt_conditions WITH KEY kposn = l_kposn BINARY SEARCH
             TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  INSERT LINES OF lt_cond_new INTO lt_conditions INDEX sy-tabix.
  CALL METHOD me->set_tkomv(
    im_tkomv = lt_conditions
    im_header_conditions_changed = mmpur_yes ).

* update recheck queue on header level
  l_model ?= me.
  READ TABLE me->my_recheck_queue WITH KEY model = l_model
             TRANSPORTING NO FIELDS.
  IF NOT sy-subrc IS INITIAL.
    ls_model_entry-model = l_model.
    APPEND ls_model_entry TO me->my_recheck_queue.
  ENDIF.

ENDMETHOD.                    "IF_PURCHASE_ORDER_MM~SET_CONDITIONS


METHOD if_purchase_order_mm~set_changed .

  DATA: l_trtyp TYPE trtyp.

  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp = l_trtyp.
  IF l_trtyp NE 'A'.
    PERFORM mepo_set_vbupdkz IN PROGRAM saplmepo USING 'X' ' '.
  ENDIF.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~is_valid .

  PERFORM mepo_badi_header_is_valid IN PROGRAM saplmepo
                            CHANGING re_valid.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~is_persistent .

  PERFORM mepo_badi_header_is_persistent IN PROGRAM saplmepo
                            CHANGING re_persistent.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~is_changeable .

  PERFORM mepo_badi_header_is_changeable IN PROGRAM saplmepo
                            CHANGING re_changeable.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~invalidate .

  PERFORM mepo_badi_header_invalidate IN PROGRAM saplmepo.

ENDMETHOD.                    "


METHOD set_update_for_gos .                                 "1020056

  CHECK me->my_gos_manager IS BOUND.
  me->if_purchase_order_mm~set_changed( ).

ENDMETHOD.


METHOD SET_TRANSACTION_STATE.


CALL FUNCTION 'MEPO_DOC_SET_TRANSACTION_STATE'
     EXPORTING
          IM_TRTYP = im_trtyp
          IM_AKTYP = im_aktyp
          IM_TCODE = im_tcode.

ENDMETHOD.


METHOD SET_TKOMV.


  PO_TKOMV_HASH_TABLE[]        = IM_TKOMV[].
  IF NOT IM_ITEM_CONDITIONS_CHANGED IS INITIAL.
    ITEM_CONDITIONS_CHANGED      = IM_ITEM_CONDITIONS_CHANGED.
  ENDIF.
  IF NOT IM_HEADER_CONDITIONS_CHANGED IS INITIAL.
    HEADER_CONDITIONS_CHANGED    = IM_HEADER_CONDITIONS_CHANGED.
  ENDIF.
  IF NOT IM_HEADER_CALCULATION_TYPE IS INITIAL.
    HEADER_CALCULATION_TYPE      = IM_HEADER_CALCULATION_TYPE.
  ENDIF.

ENDMETHOD.


METHOD set_state.

  CHECK state NE im_state.

* the 'verify' state is removed. Existing hash table entries have to
* be removed
  IF state EQ c_verify.
    DELETE TABLE po_header_hash_table WITH TABLE KEY header = me.
    DELETE TABLE po_headerx_hash_table WITH TABLE KEY header = me.
  ENDIF.

* define the handle as an observer of the header proposer whenever the
* state changes to 'new'.
  IF im_state EQ c_new.
    CALL METHOD check_proposer.
    IF NOT my_header_proposer IS INITIAL.
      SET HANDLER me->if_observer_mm~handle_subject_changed FOR
          my_header_proposer.
    ENDIF.
  ENDIF.

* undefine the handle as an observer whenever the state changes from
* 'new'
  IF state EQ c_new.
    CALL METHOD check_proposer.
    IF NOT my_header_proposer IS INITIAL.
      SET HANDLER me->if_observer_mm~handle_subject_changed FOR
          my_header_proposer ACTIVATION space.
    ENDIF.
  ENDIF.

  CALL METHOD super->set_state( im_state ).

ENDMETHOD.                    "


method SET_REVAL_ATTRIBUTES.
* Funds Management Revaluation of commitments when changing WKURS
*  set release strategy switch
  fm_reval_no_release = im_no_release.
*  set version managment switch
  fm_reval_no_version = im_no_version.

endmethod.


  method SET_RESWK_PARAM_VALUE.

    DATA: ls_header_data TYPE mepoheader.

    IF iv_param EQ space.
      CALL FUNCTION 'MEPO_DOC_HEADER_GET'
        IMPORTING
          ex_ekko = ls_header_data.
    ENDIF.

    IF ls_header_data-reswk IS NOT INITIAL.
      SET PARAMETER ID 'PO_RESWK' FIELD ls_header_data-reswk.
    ELSE.
      SET PARAMETER ID 'PO_RESWK' FIELD iv_param.
    ENDIF.

  endmethod.


METHOD SET_PO_NUMBER.

  PO_NUMBER = IM_PO_NUMBER.
  my_gos_manager = im_gos.                                  "913251
  IF my_gos_manager IS BOUND.                               "1020056
    SET HANDLER set_update_for_gos FOR ALL INSTANCES.       "1020056
  ENDIF.
ENDMETHOD.


METHOD SET_PARENT.

  RAISE CANNOT_BE_SET.
ENDMETHOD.


  METHOD set_hierarchy_field.

    DATA(lv_active) = cl_mm_pur_po_utilities=>is_po_item_hier_swf_active( ).
    IF lv_active = abap_true.
      has_hierarchy = is_hierarchy.
    ENDIF.

  ENDMETHOD.


METHOD set_datax .

  DATA: wa      LIKE LINE OF po_headerx_hash_table.

  CHECK state NE c_deleted.

  READ TABLE po_headerx_hash_table INTO wa WITH TABLE KEY header = me.
  wa-data = im_data.
  IF sy-subrc IS INITIAL.
    MODIFY TABLE po_headerx_hash_table FROM wa.
  ELSE.
    wa-header = me.
    INSERT wa INTO TABLE po_headerx_hash_table.
  ENDIF.

ENDMETHOD.                    "


METHOD set_data.

  DATA: wa      LIKE LINE OF po_header_hash_table,
        l_data  TYPE mepoheader.

  CHECK state NE c_deleted.

  wa-header = me.
  wa-data = im_data.

  IF state EQ c_verify.
    MODIFY TABLE po_header_hash_table FROM wa.
  ELSE.
    IF state EQ c_available.
      CALL METHOD me->get_data
        IMPORTING
          ex_data = l_data.
    ENDIF.
* note 999401: a dummy hash entry is also needed for state 'new'
    me->chp_add_hash_entry( im_data = l_data ).
    INSERT wa INTO TABLE po_header_hash_table.
    CALL METHOD set_state( im_state = c_verify ).
  ENDIF.

ENDMETHOD.                    "


METHOD set_confirmation_handle.

  DATA lo_item  TYPE REF TO cl_po_item_handle_mm.
  FIELD-SYMBOLS
       <item> TYPE mmpur_model_type.

  CHECK im_confirmation IS BOUND.
  my_confirmation_handle = im_confirmation.
  LOOP AT me->my_items ASSIGNING <item>.
    mmpur_dynamic_cast1 lo_item <item>-model.
    lo_item->set_confirmation_handle( my_confirmation_handle ).
  ENDLOOP.

ENDMETHOD.


METHOD REFRESH_TKOMV.


  REFRESH PO_TKOMV_HASH_TABLE[].
  CLEAR: ITEM_CONDITIONS_CHANGED,
         HEADER_CONDITIONS_CHANGED,
         HEADER_CALCULATION_TYPE.

ENDMETHOD.


method REFRESH_RWIN.
*- Note 1121068: Refresh of internal tables in the accounting application
*-               which are registered in TRWPR table (commitment update)

*  define local type
  TYPES: BEGIN OF lty_trwin,
          function TYPE trwpr-function,
         END OF lty_trwin.

  DATA: l_fisc_year  TYPE bkpf-gjahr,
        lt_trwin     TYPE STANDARD TABLE OF lty_trwin.

  FIELD-SYMBOLS: <trwin> TYPE lty_trwin.

* call rwin_check
    CALL FUNCTION 'RWIN_CHECK'
      EXPORTING
        gjahr         = l_fisc_year
        process       = 'BEST    '
        event         = 'INITPROC'
      TABLES
        tkomp         = lt_trwin
      EXCEPTIONS
        error_message = 0
        OTHERS        = 0.

* call RWIN function modules.
    LOOP AT lt_trwin ASSIGNING <trwin>.
      CALL FUNCTION <trwin>-function
        EXPORTING
          i_flg_document_switched = cl_mmpur_constants=>yes
          i_flg_unlock            = cl_mmpur_constants=>yes.    "2809772
    ENDLOOP.

endmethod.


METHOD refresh_eikp_data .

  DELETE TABLE po_eikp_hash_table WITH TABLE KEY header = me.
  eikp_changed = mmpur_no.

ENDMETHOD.                    "REFRESH_EIKP_DATA


METHOD po_uncancel .
  DATA : l_models         TYPE mmpur_models,
         ls_model         LIKE LINE OF l_models,
         l_item           TYPE REF TO cl_po_item_handle_mm,
         l_header_data    TYPE mepoheader,
         ls_item_data     TYPE mepoitem,
         l_header_datax   TYPE mepoheaderx,
         l_answer         TYPE c,
         wa_loekz_info    LIKE LINE OF my_po_loekz_info.

*  CLEAR ret_severity.
*----------------------------------------------------------------------*
* get all items
*----------------------------------------------------------------------*

  l_models = my_items.

  IF skip_popup IS INITIAL.
    CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
      EXPORTING
        defaultoption = 'N'
        diagnosetext1 = text-001
        diagnosetext2 = text-007
        diagnosetext3 = text-008
        textline1     = text-004
        titel         = text-006
      IMPORTING
        answer        = l_answer.
  ELSE.
* without Popup allways do the change
    l_answer = 'J'.
  ENDIF.
  IF l_answer = 'J'.
* loekz on PO_ITEM level can only be reseted in case we know
* the old status before canceling . the old status is only known if the
* cancelling was done before in the same processing session
    IF my_po_loekz_info IS NOT INITIAL.
      LOOP AT l_models INTO ls_model.
        mmpur_dynamic_cast l_item ls_model-model.
        l_item ?= ls_model-model.
        IF l_item IS BOUND AND l_item->po_item_number IS NOT INITIAL.
          l_item->get_data( IMPORTING ex_data = ls_item_data ).
          LOOP AT my_po_loekz_info INTO wa_loekz_info
              WHERE ebelp EQ ls_item_data-ebelp.
            IF wa_loekz_info-loekzx = ' '.
              ls_item_data-loekz = ' '.
            ENDIF.
          ENDLOOP.
          l_item->set_data( ls_item_data ).
        ENDIF.
      ENDLOOP.
    ENDIF.
* if we do not know the old status only the header loekz will
* be reseted
    me->get_data( IMPORTING ex_data = l_header_data ).
    CLEAR l_header_data-loekz.
    me->set_data( im_data = l_header_data ).

    me->get_datax( IMPORTING ex_data = l_header_datax ).
    l_header_datax-loekz = cl_mmpur_constants=>yes.
    me->set_datax( im_data = l_header_datax ).

    IF l_models[] IS NOT INITIAL.
      me->flush_data( EXPORTING im_models = l_models ).
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD po_read.

  INCLUDE mm_messages_mac.

  DATA: l_po_number TYPE ekko-ebeln,
        gf_name     TYPE c LENGTH 128.

  FIELD-SYMBOLS: <subrc>  TYPE sy-subrc.


  IF im_po_number NE space.
    l_po_number = im_po_number.
  ELSE.
    l_po_number = po_number.
  ENDIF.
*
* in case of EDI Order Acknowledgement -> set MV_ORDRSP
  IF im_aktyp EQ cl_mmpur_constants=>trtyp_t.               "1742741
    me->mv_ordrsp = cl_mmpur_constants=>yes.
  ENDIF.
*
* authority check on transaction code disabled
* If called via CALL TRANSACTION, this check is already done by basis
* (see note 358122)
* restriction of T-code authority check to Enjoy only
  IF for_bapi IS INITIAL AND for_api IS INITIAL.
* tcode authorization
    IF NOT im_tcode IS INITIAL.
      CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
        EXPORTING
          tcode  = im_tcode
        EXCEPTIONS
          ok     = 0
          not_ok = 1
          OTHERS = 2.
      IF sy-subrc NE 0.
        MESSAGE e172(00) WITH im_tcode INTO gl_dummy.
        mmpur_message_forced 'E' '00' '172' im_tcode '' '' ''.
        ex_result = mmpur_no.
        CALL METHOD set_state( im_state = c_available ).
        EXIT.
      ENDIF.
    ENDIF.
  ENDIF.

  CALL FUNCTION 'MEPO_DOC_READ'
    EXPORTING
      im_ebeln          = l_po_number
      im_tcode          = im_tcode
      im_trtyp          = im_trtyp
      im_id             = id
      im_document       = im_document
      im_no_messaging   = no_messaging
      im_no_message_req = no_message_req
      im_no_authority   = no_authority
      iv_objtyp         = c_objtyp
    EXCEPTIONS
      error_message     = 1
      OTHERS            = 2.

  IF NOT sy-subrc IS INITIAL.
    mmpur_message_forced sy-msgty sy-msgid sy-msgno sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    CALL METHOD po_initialize.
    ex_result = mmpur_no.

  ELSE.
    po_number = l_po_number.
    ex_result = mmpur_yes.
  ENDIF.

  IF cl_ops_switch_check=>sfsw_segmentation( ) EQ abap_on.
    CALL METHOD cl_po_header_handle_mm=>set_reswk_param_value
      EXPORTING
        iv_param = space.
  ENDIF.

*---------------------------------------------------------*
* ARUN Purchasee Order / confirmation object instantiation
*---------------------------------------------------------*
  IF cl_switch_check_allocation_run=>sfsw_allocation_run( ) = abap_true.
    "Arun instance intilization - PO
    PERFORM instantiate_arun_po_instance
                                IN PROGRAM saplmepo
                                USING      me
                                           im_trtyp.
    "Arun instance intilization - conf
    PERFORM instantiate_arun_cf_instance
                                 IN PROGRAM saplmepo
                                 USING      me
                                            im_trtyp.
  ENDIF.

* even in the case of a failure we have to change the state to available
  CALL METHOD set_state( im_state = c_available ).

* store information whether the mode was switched to DISPLAY
* Ths is needed to update the GOS Manager accordingly
  DATA lv_switch2display TYPE mmpur_bool VALUE mmpur_no.

*--------------------------------------------------------------------*
* BAdI
*--------------------------------------------------------------------*
  IF ex_result EQ mmpur_yes.
    DATA: l_trtyp        TYPE trtyp,
          l_display_only TYPE mmpur_bool VALUE mmpur_no.
    CALL METHOD me->get_transaction_state
      IMPORTING
        ex_trtyp = l_trtyp.
    CALL FUNCTION 'MEPOBADI_OPEN'
      EXPORTING
        im_trtyp        = l_trtyp
        im_header       = me
      CHANGING
        ch_valid        = ex_result
        ch_display_only = l_display_only
      EXCEPTIONS
        error_message   = 1
        OTHERS          = 2.

    IF NOT sy-subrc IS INITIAL.
      mmpur_message_forced sy-msgty sy-msgid sy-msgno sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ex_result = mmpur_no.
    ENDIF.
    IF ex_result EQ mmpur_no.
      CALL METHOD po_initialize.
    ELSEIF l_display_only EQ mmpur_yes.
      CALL METHOD set_transaction_state(
          im_trtyp = cl_mmpur_constants=>anz
          im_aktyp = 'A'
          im_tcode = 'ME23N' ).
      IF im_trtyp NE cl_mmpur_constants=>anz.
*     mode has been changed to DISPLAY
        lv_switch2display = mmpur_yes.
      ENDIF.
    ENDIF.
  ENDIF.

*--------------------------------------------------------------------*
* Generic object services manager
*--------------------------------------------------------------------*
  me->my_gos_manager = im_gos.                              "913251
  IF me->my_gos_manager IS BOUND.                           "1020056
    SET HANDLER set_update_for_gos FOR ALL INSTANCES.       "1020056
  ENDIF.

********Changes for EDIT PO During Approval *******************
*  IF im_trtyp NE cl_mmpur_constants=>anz.
** in case new workflow is activ:
** - if PO is in approval -> only DISPLAY mode
*    check_program_loaded_glb rm_mepo_gui.
*    IF sy-subrc = 0.
*      DATA(lv_header) = if_purchase_order_mm~get_data( ).
*
*      CALL METHOD cl_mm_pur_po_flex_wfl_helper=>read_workflow_customizing
*        EXPORTING
*          iv_doc_type = lv_header-bsart.
*      IF cl_mm_pur_po_flex_wfl_helper=>gv_scn_wfl_po EQ abap_true.
*        IF lv_header-procstat = cl_process_state_mm=>c_release_active
*        AND lv_header-frgrl EQ abap_true.
*
**   unlock the PO in case the change-modus is not allowed
*          CALL FUNCTION 'MM_DEQUEUE_DOCUMENT'
*            EXPORTING
*              i_ebeln = lv_header-ebeln.
*
*          MESSAGE i173(mepo) WITH im_tcode INTO gl_dummy.
*          mmpur_message 'I' 'MEPO' '173' lv_header-ebeln '' '' ''.
*          CALL METHOD set_transaction_state(
*              im_trtyp = cl_mmpur_constants=>anz
*              im_aktyp = 'A'
*              im_tcode = 'ME23N' ).
**         mode has been changed to DISPLAY
*          lv_switch2display = mmpur_yes.
*        ENDIF.
*      ENDIF.
*    ELSE.
*      lv_header = if_purchase_order_mm~get_data( ).
*
*      CALL METHOD cl_mm_pur_po_flex_wfl_helper=>read_workflow_customizing
*        EXPORTING
*          iv_doc_type = lv_header-bsart.
*      IF  cl_mm_pur_po_flex_wfl_helper=>gv_scn_wfl_po EQ abap_true  AND
*          'ME29N' <> im_tcode  AND im_trtyp = 'V' AND im_aktyp = 'V'.
*        IF lv_header-procstat = cl_process_state_mm=>c_release_active
*           AND lv_header-frgrl EQ abap_true.
*          CALL FUNCTION 'MM_DEQUEUE_DOCUMENT'
*            EXPORTING
*              i_ebeln = lv_header-ebeln.
*
*          MESSAGE i173(mepo) WITH im_tcode INTO gl_dummy.
*          mmpur_message 'I' 'MEPO' '173' lv_header-ebeln '' '' ''.
*          CALL METHOD set_transaction_state(
*              im_trtyp = cl_mmpur_constants=>anz
*              im_aktyp = 'A'
*              im_tcode = 'ME23N' ).
**         mode has been changed to DISPLAY
*          lv_switch2display = mmpur_yes.
*        ENDIF.
*      ENDIF.
*    ENDIF.
*  ENDIF.

*----------------------------------------------------------------------*
* release operation
*----------------------------------------------------------------------*
  IF im_document-initiator-initiator EQ mmpur_initiator_rel AND
    im_document-trtyp NE cl_mmpur_constants=>anz.           "665079

    DATA: l_releasable TYPE REF TO if_releasable_mm.
    mmpur_dynamic_cast1 l_releasable me.
    IF l_releasable->is_release_allowed( )   EQ mmpur_no AND
       l_releasable->is_reset_rel_allowed( ) EQ mmpur_no.
      MESSAGE i823(mepo) WITH l_po_number INTO gl_dummy.
      mmpur_message 'I' 'MEPO' '823' l_po_number '' '' ''.  "#EC *
    ENDIF.
    IF cl_ops_switch_check=>ops_sfws_sc_advret1( ) = abap_true.
      IF l_releasable->is_release_allowed( )   EQ mmpur_yes OR
         l_releasable->is_reset_rel_allowed( ) EQ mmpur_yes.
        CALL FUNCTION 'MSR_SET_DATA'
          EXPORTING
            iv_releasable = abap_true.
      ENDIF.
    ENDIF.
  ENDIF.


  "{ Begin EHP604_PO_READ_01 ENHO ADSUB_PO_READ_01 IS-AD-SUC AD_SUB }
* ADSUB EHP604 TT 08.01.11
  DATA: lt_items         TYPE purchase_order_items,
        ls_item          TYPE purchase_order_item,
        lr_item          TYPE REF TO cl_po_item_handle_mm,
        lt_schedules     TYPE mmpur_models,
        ls_schedule      LIKE LINE OF lt_schedules,
        lr_schedule      TYPE REF TO cl_po_schedule_handle_mm,
        lv_sn_extend     TYPE mmpur_sn_extend,
        lv_sn_extend_old TYPE mmpur_sn_extend,
        ls_mepoitem      TYPE mepoitem,
        ls_ekpo          TYPE ekpo.

  lt_items = if_purchase_order_mm~get_items( ).
  LOOP AT lt_items INTO ls_item.
    lr_item ?= ls_item-item.
    lr_item->get_data( IMPORTING ex_data = ls_mepoitem ).
    MOVE-CORRESPONDING ls_mepoitem TO ls_ekpo.

    CHECK ls_ekpo-serru CA cl_adsub_constants=>serru_recursive. "DT1278517 -081205

    CALL FUNCTION 'ADSUB_GET_MAIN_REWORK_MATERIAL'
      EXPORTING
        is_ekpo      = ls_ekpo
      IMPORTING
        es_sn_extend = lv_sn_extend_old.

    lr_item->get_po_schedules( IMPORTING ex_schedules = lt_schedules ).

    LOOP AT lt_schedules INTO ls_schedule.
      lr_schedule ?= ls_schedule-model.

      TRY.
          lr_schedule->if_purchase_order_schedule_mm~get_serial_no(
             IMPORTING
               re_extend = lv_sn_extend ).
        CATCH cx_mmpur_not_found.
      ENDTRY.

      IF lv_sn_extend IS INITIAL.
        lr_schedule->if_purchase_order_schedule_mm~set_serial_no(
         EXPORTING
           im_extend = lv_sn_extend_old ).
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  "{ End EHP604_PO_READ_01 ENHO ADSUB_PO_READ_01 IS-AD-SUC AD_SUB }

* in case the PO was created from external system, it should not be changeable in S/4,
* except for approval
  DATA: ls_header TYPE mepoheader.

  ls_header = if_purchase_order_mm~get_data( ).
  IF ls_header-statu = 'N'.
    IF im_tcode NE 'ME29N' AND for_bapi IS INITIAL.

      IF im_trtyp NE cl_mmpur_constants=>anz.
        MESSAGE i895(mepo) INTO gl_dummy.
        mmpur_message 'I' 'MEPO' '895' '' '' '' ''.

* unlock the PO in case the change-modus is not allowed
        CALL FUNCTION 'MM_DEQUEUE_DOCUMENT'
          EXPORTING
            i_ebeln = ls_header-ebeln.
*       mode has been changed to DISPLAY
        lv_switch2display = mmpur_yes.
      ENDIF.

      CALL METHOD set_transaction_state(
          im_trtyp = cl_mmpur_constants=>anz
          im_aktyp = 'A'
          im_tcode = 'ME23N' ).

    ENDIF.
  ENDIF.

*----------------------------------------------------------------------*
* address handling for storing address data when reading purchase order
*----------------------------------------------------------------------*
  IF is_address_handling_active( ) = abap_true.
*   Determine and put the supplier address to the internal buffer for synchronizating at saving the address data changes
    me->set_address( if_purchase_order_mm~get_supplier_address( )  ).
    LOOP AT lt_items INTO ls_item WHERE item IS INSTANCE OF cl_po_item_handle_mm.
      lr_item ?= ls_item-item.
*     Determine and put the delivery address to the internal buffer for synchronizating at saving the address data changes
      CHECK lr_item->is_address_handling_active( ).
      lr_item->set_address( lr_item->if_purchase_order_item_mm~get_delivery_address( ) ).
    ENDLOOP.
  ENDIF.

*------------------------------------------------------------------------*
* Item hierarchies
*------------------------------------------------------------------------*
  IF cl_mm_pur_po_utilities=>is_po_item_hier_swf_active( ) = abap_true.

    DATA ls_item_data TYPE mepoitem.
    DATA(lv_hier_po) =  cl_mm_po_hierarchy=>is_hierarchy_po(
       EXPORTING
         io_po_hdr        =  me   ).             " Handle of a Purchasing Document
    IF lv_hier_po = abap_true.

      me->set_hierarchy_field( is_hierarchy =  lv_hier_po ).

* set the hierarchy level for each of the items of this PO
      LOOP AT lt_items INTO ls_item WHERE item IS INSTANCE OF cl_po_item_handle_mm.
        lr_item ?= ls_item-item.
        lr_item->get_data( IMPORTING ex_data = ls_item_data ).
        cl_mm_po_hierarchy=>set_hierarchy_level(
          EXPORTING
            is_item       =  ls_item_data                " Purchase Order Item
            io_po_header  =  me     ).           " Handle of a Purchasing Document
* set the depth if it is an itemset
        IF ls_item_data-upvor = 'C'.
          DATA(lt_children) = cl_mm_po_hierarchy=>get_copied_items(
            EXPORTING
              io_po_header    =   me               " Handle of a Purchasing Document
              iv_copied_item  =   ls_item_data-ebelp   ).            " Item Number of Purchasing Document

        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.


*--------------------------------------------------------------------*
* Generic object services manager
*
* mode has been switched to DISPLAY -> GOS manager needs to be updated accordingly
* this prevents e.g. that create attachment is not active in case PO is in approval or created from external system
*--------------------------------------------------------------------*
  IF lv_switch2display = mmpur_yes.
    IF me->my_gos_manager IS BOUND.
      me->my_gos_manager->set_rw_mode( cl_mmpur_constants=>anz ).
    ENDIF.
  ENDIF.

ENHANCEMENT-POINT ehp604_po_read_01 SPOTS es_mepocl.
ENDMETHOD.                    "


METHOD po_prepare_creation .

  DATA: l_ref   TYPE REF TO data,
        l_bsart TYPE ekko-bsart,
        l_bedat TYPE ekko-bedat,
        l_dummy TYPE c LENGTH 72.                           "#EC *

  FIELD-SYMBOLS: <data> TYPE mepoheader_prop.

* authority check on transaction code disabled
* If called via CALL TRANSACTION, this check is already done by basis
* (see note 358122)
* restriction of T-code authority check to Enjoy only
  IF for_bapi IS INITIAL AND for_api IS INITIAL.
    IF im_no_auth_check EQ mmpur_no.
* tcode authorization
      CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
        EXPORTING
          tcode  = 'ME21N'
        EXCEPTIONS
          ok     = 0
          not_ok = 1
          OTHERS = 2.
      IF sy-subrc NE 0.
        MESSAGE e172(00) WITH 'ME21N' INTO l_dummy.
        CALL METHOD cl_message_mm=>create
          EXPORTING
            im_msgid         = sy-msgid
            im_msgty         = sy-msgty
            im_msgno         = sy-msgno
            im_msgv1         = sy-msgv1
            im_msgv2         = sy-msgv2
            im_msgv3         = sy-msgv3
            im_msgv4         = sy-msgv4
            im_force_collect = mmpur_yes
          EXCEPTIONS
            failure          = 0
            dialog           = 0.

        RAISE no_authority.
      ENDIF.
    ENDIF.
  ENDIF.

* transaction state
  CALL METHOD me->set_transaction_state
    EXPORTING
      im_trtyp = 'H'
      im_aktyp = 'H'
      im_tcode = 'ME21N'.

* EFB-Parameter
  PERFORM init_efube IN PROGRAM saplmepo.

* update sapmm06e, table T161 for field selection purposes
  CALL METHOD check_proposer.
  IF NOT my_header_proposer IS INITIAL.

    CALL METHOD my_header_proposer->get_data
      IMPORTING
        ex_data = l_ref.
    ASSIGN l_ref->* TO <data>.
    PERFORM mepo_default_topline IN PROGRAM saplmepo
                              USING    <data>-bsart
                              CHANGING l_bsart
                                       l_bedat.
  ENDIF.

*--------------------------------------------------------------------*
* BAdI
*--------------------------------------------------------------------*
  DATA: l_valid        TYPE mmpur_bool VALUE mmpur_yes,
        l_display_only TYPE mmpur_bool VALUE mmpur_no.
  CALL FUNCTION 'MEPOBADI_OPEN'
    EXPORTING
      im_trtyp        = 'H'
      im_header       = me
    CHANGING
      ch_valid        = l_valid
      ch_display_only = l_display_only
    EXCEPTIONS
      error_message   = 0.

ENDMETHOD.                    "


METHOD po_post.

  DATA: l_result       TYPE sy-subrc,
        l_po_number    TYPE ekko-ebeln,
        l_msg_handler  TYPE REF TO cl_message_handler_mm,
        l_msg_conf_old TYPE melog_s_handler_config,       "832427
        l_msg_conf_new TYPE melog_s_handler_config.

  CALL METHOD cl_message_mm=>set_current_business_obj
    EXPORTING
      im_business_obj = me.

  CALL METHOD cl_message_mm=>set_current_context(
    mmcnt_post ).

  CALL METHOD cl_message_handler_mm=>get_handler
    IMPORTING
      ex_handler = l_msg_handler.

  l_msg_conf_old = l_msg_handler->get_configuration( ).     "832427
  l_msg_conf_new = l_msg_conf_old.
  CLEAR l_msg_conf_new-events_for_dialog.
  CALL METHOD l_msg_handler->set_configuration( l_msg_conf_new ).

  CALL METHOD l_msg_handler->remove_by_bo
    EXPORTING
      im_business_obj = me
      im_context      = mmcnt_post
      im_include_child_objects = mmpur_yes.                 "832427

  CALL METHOD l_msg_handler->new_sequence.
  CALL METHOD l_msg_handler->cleanup.

  CALL FUNCTION 'MEPO_DOC_POST'
    EXPORTING
      im_commit_wait    = im_commit_wait
      im_no_commit      = im_no_commit
      im_uncomplete     = im_uncomplete
      im_uncompletetype = im_uncompletetype                  "Park&Hold
    IMPORTING
      ex_ebeln       = l_po_number
    EXCEPTIONS
      invalid_call   = 1
      error_message  = 2
      OTHERS         = 3.
  l_result = sy-subrc.

  CALL METHOD l_msg_handler->set_configuration( l_msg_conf_old )."832427
  CALL METHOD cl_message_mm=>set_current_context( 0 ).
  CALL METHOD l_msg_handler->cleanup( ).

  IF NOT l_po_number IS INITIAL.
    po_number = l_po_number.
  ENDIF.

  IF l_result <> 0.
    IF l_result EQ 1.
      MESSAGE a816(me) WITH 'po_post'.
    ELSE.
*
* a desaster occured: rollback work
*
* 1179830 - cleanup for Sales order document flow
      CALL FUNCTION 'SD_DOCUMENT_FLOW_INIT'       "1179830
        EXPORTING                                 "1179830
          i_vbtyp_n = IF_SD_DOC_CATEGORY=>PURCHASE_ORDER.                        "1179830

      ROLLBACK WORK.
    ENDIF.
    RAISE failure.
  ENDIF.

  posted = mmpur_yes.

ENDMETHOD.                    "po_post


METHOD po_initialize.

  DATA: l_hd TYPE REF TO cl_message_handler_mm,
        fw TYPE REF TO cl_framework_mm.

  TRY.
      cl_fot_tdt_btt_code=>handler->set( iv_btt_code = cl_fot_tdt_btt_code=>mc_btt_code-mm_purch_order ).
    CATCH cx_fot_tdt_root INTO DATA(lx_tdt).
*      MESSAGE lx_tdt.
  ENDTRY.


 IF is_address_handling_active( ) = abap_true.
*   reset address memory (when the last PO ran into an error, the
*   address is still in the memory)
         CALL FUNCTION 'ADDR_MEMORY_CLEAR'
            EXPORTING
              force              = 'X'
            EXCEPTIONS
              unsaved_data_exist = 0
              internal_error     = 0
              OTHERS             = 0.
          IF sy-subrc <> 0.
          ENDIF.
  ENDIF.

  CALL FUNCTION 'MEPO_DOC_INITIALIZE'.

  CALL FUNCTION 'MEPO_DOC_SET_TRANSACTION_STATE'
    EXPORTING
      im_trtyp = 'A'
      im_aktyp = 'A'
      im_tcode = 'ME23N'.

  PERFORM mepo_xpd_set_document IN PROGRAM saplmepo
      USING im_document.

*---------------------------------------------------------*
* ARUN Purcahse Order / confirmation object instantiation
*---------------------------------------------------------*
 "Arun instance intilization - PO
  PERFORM instantiate_arun_po_instance
                              IN PROGRAM saplmepo
                              USING      me
                                         im_document-trtyp.
  "Arun instance intilization - conf
  PERFORM instantiate_arun_cf_instance
                               IN PROGRAM saplmepo
                               USING      me
                                          im_document-trtyp.

*---------------------------------------------------------*

  CALL METHOD remove_items.
  CALL METHOD cl_message_handler_mm=>get_handler
    IMPORTING
      ex_handler = l_hd.
  CALL METHOD l_hd->remove_by_bo( im_business_obj = me ).
  CALL METHOD l_hd->cleanup( ).

  CLEAR: po_number.

  CALL METHOD set_state( im_state = c_new ).

* clean up hash tables.
  DELETE TABLE: po_header_hash_table WITH TABLE KEY header = me,
                po_headerx_hash_table WITH TABLE KEY header = me,
                po_supplier_addr_hash_table WITH TABLE KEY header = me.

* clean up of framework's change protocol list
  CALL METHOD cl_framework_mm=>get_instance
    IMPORTING
      ex_instance = fw.
  CALL METHOD fw->chp_reset_list( ).

ENDMETHOD.                    "


METHOD po_close.

  DATA: l_hd        TYPE REF TO cl_message_handler_mm,
        l_text_name TYPE thead-tdname,
        l_pos       TYPE serno_manager_data_mm,
        lt_managers TYPE serno_manager,
        l_managers  TYPE LINE OF serno_manager,
        lo_factory  TYPE REF TO if_mmpur_history_factory.

* Call RWIN interface to inform about end of document process.          "1121068
  CALL METHOD me->refresh_rwin( EXCEPTIONS OTHERS = 0 ).

  CALL FUNCTION 'MEPOBADI_CLOSE'
    EXPORTING
      im_header     = me
    EXCEPTIONS
      error_message = 0.

* clean up text memory                           "594632
  l_text_name(10) = po_number.
  CALL FUNCTION 'DELETE_TEXT_FROM_CATALOG'
    EXPORTING
      object    = 'EKKO      '
      name      = l_text_name
      id        = '*'
      language  = '*'
    EXCEPTIONS
      not_found = 0
      OTHERS    = 0.

  l_text_name+10 = '*'.
  CALL FUNCTION 'DELETE_TEXT_FROM_CATALOG'
    EXPORTING
      object    = 'EKPO      '
      name      = l_text_name
      id        = '*'
      language  = '*'
    EXCEPTIONS
      not_found = 0
      OTHERS    = 0.

* clean up serno manager table
  l_pos-edokn = po_number.
  l_pos-bstyp = cl_mmpur_constants=>bstyp_f.
  CALL FUNCTION 'MMPUR_GET_SERNO_MANAGER'
    EXPORTING
      im_pos_old        = l_pos
      im_finish         = cl_mmpur_constants=>yes
    CHANGING
      ch_managers       = lt_managers
    EXCEPTIONS
      invalid_doctyp    = 0
      no_serno_profil   = 0
      conversions_error = 0
      OTHERS            = 0.
  LOOP AT lt_managers INTO l_managers.
    IF l_managers IS BOUND.
      CALL METHOD l_managers->close(
        EXPORTING
          im_bstyp = l_pos-bstyp
          im_edokn = l_pos-edokn ).
      EXIT.
    ENDIF.
  ENDLOOP.
* cleanup purchase order history
  TRY.
    CALL FUNCTION 'MMHIPO_GET_FACTORY'
      IMPORTING
        eo_factory = lo_factory.
    IF lo_factory->lookup( me->po_number ) IS BOUND.
      lo_factory->close( me->po_number ).
      free lo_factory.
    ENDIF.
    CATCH cx_root.
  ENDTRY.

  CALL FUNCTION 'ME_COMPONENTS_REFRESH'.                    "3070901

* clean up message handler
  CALL METHOD cl_message_handler_mm=>get_handler
    IMPORTING
      ex_handler = l_hd.

  CALL METHOD remove_items.
  CALL METHOD l_hd->remove_by_bo( im_business_obj = me ).
  CALL METHOD l_hd->cleanup( ).
  CALL METHOD cl_handle_manager_mm=>remove( me->id ).
* Free the GOS manager
  IF my_gos_manager IS BOUND.                               "913251
    my_gos_manager->unpublish( ).
    CLEAR my_gos_manager.
  ENDIF.
*
* free SRM contract converter
  cl_mmbsi_cc_conv=>cleanup( ).                             "1620881

* cleanup database utility
  IF for_me59n EQ mmpur_no.
    cl_mmpur_out_db_utility=>cleanup( ).                      "2038808
  ENDIF.

* destructor archive handle
  CALL METHOD
    cl_mmpur_archive=>if_mmpur_archive~close_archive( me->po_number ).

  CALL METHOD set_state( im_state = c_new ).

* clean up hash table.
  DELETE TABLE po_header_hash_table WITH TABLE KEY header = me.
  DELETE TABLE po_headerx_hash_table WITH TABLE KEY header = me.

* clean up item/schedule/accounting hash table              "1428972
  DELETE me->mth_hash WHERE ebeln = me->po_number OR ebeln is initial.

* check if ATP BULK processing is enabled
  IF cl_mm_pur_po_atp_bulk_proc=>if_mm_pur_po_atp_bulk_proc~is_atp_bulk_processing_enabled( ) = abap_true.
*   clear all buffers which where used for the ATP bulk processing
    cl_mm_pur_po_atp_bulk_factory=>get_instance( )->clear_buffers( ).
  ENDIF.

ENDMETHOD.                    "


METHOD po_check.
* define local data objects
  DATA: lo_handler                 TYPE REF TO cl_message_handler_mm,
        lo_req                     TYPE REF TO if_purchase_requisition,
        lo_item                    TYPE REF TO if_purchase_requisition_item,
        lo_const                   TYPE REF TO cl_mmpur_constants,
        lr_subitem                 TYPE REF TO mmpur_subitem_type,

        lt_subitems                TYPE mmpur_subitems,
        lt_models                  TYPE mmpur_models,
        l_models                   TYPE mmpur_models,
        lt_recheck                 TYPE mmpur_models,
        lt_events                  TYPE mmpur_event_list,

        ls_msg_old                 TYPE melog_s_handler_config,
        ls_msg_new                 TYPE melog_s_handler_config,
        ls_header                  TYPE mepoheader,
        ls_header_old              TYPE mepoheader,
        ls_req_head                TYPE mereq_header,
        ls_req_item                TYPE mereq_item,
        ls_model                   TYPE mmpur_model_type,
        l_model                    TYPE mmpur_model_type,


        lv_uncomplete              TYPE mmpur_bool,
        lv_result                  TYPE sy-subrc,
        lv_events                  TYPE mmpur_bool,
        lv_failed                  TYPE mmpur_bool,
        lv_failed_cloud
                      TYPE mmpur_bool,
        lv_hold                    TYPE mmpur_bool,
        lv_park                    TYPE mmpur_bool,

        lo_cloud_check_badi
                      TYPE REF TO bd_mmpur_final_check_po,
        lt_messages                TYPE mmpur_t_messages,
        ls_messages                TYPE mmpur_s_message,
        ls_purchaseorder
                      TYPE mmpur_s_purchaseorder,
        ls_purchaseorder_db
                      TYPE mmpur_s_purchaseorder,
        lt_purchaseorderitem
                      TYPE mmpur_t_purchaseorderitem,
        lt_purchaseorderitem_db
                      TYPE mmpur_t_purchaseorderitem,
        ls_purchaseorderitem       TYPE mmpur_s_purchaseorderitem,
        lt_purordscheduleline
                      TYPE mmpur_t_purchaseorderschedline,
        ls_purordscheduleline      TYPE mmpur_s_purchaseorderschedline,
        lt_purordaccountassignmt
                      TYPE mmpur_t_purordaccountassignmt,
        ls_purordaccountassignmt   TYPE mmpur_s_purordaccountassignmt,
        ls_b_purchaseorder         TYPE if_ex_mmpur_final_check_po=>b_mmpur_s_purchaseorder,
        ls_b_purchaseorder_db      TYPE if_ex_mmpur_final_check_po=>b_mmpur_s_purchaseorder,
        ls_b_purchaseorderitem     TYPE if_ex_mmpur_final_check_po=>b_mmpur_s_purchaseorderitem,
        lt_b_purchaseorderitem     TYPE if_ex_mmpur_final_check_po=>b_mmpur_t_purchaseorderitem,
        lt_b_purchaseorderitem_db  TYPE if_ex_mmpur_final_check_po=>b_mmpur_t_purchaseorderitem,
        lt_b_purordscheduleline    TYPE if_ex_mmpur_final_check_po=>b_mmpur_t_purchorderschedline,
        ls_b_purordscheduleline    TYPE if_ex_mmpur_final_check_po=>b_mmpur_s_purchorderschedline,
        lt_b_purordaccountassignmt TYPE if_ex_mmpur_final_check_po=>b_mmpur_t_purordaccassignmt,
        ls_b_purordaccountassignmt TYPE if_ex_mmpur_final_check_po=>b_mmpur_s_purordaccassignmt,
        lt_b_messages              TYPE if_ex_mmpur_final_check_po=>b_mmpur_t_messages,
        ls_b_messages              TYPE if_ex_mmpur_final_check_po=>b_mmpur_s_messages.

*
  CLEAR ret_severity.
  lo_const = cl_mmpur_constants=>get_instance( ).
* call finalize to enable the possibility for changing data
  CLEAR me->my_recheck_queue.
  CALL FUNCTION 'MEPOBADI_FINALIZE'
    EXPORTING
      im_header     = me
    EXCEPTIONS
      error_message = 0
      OTHERS        = 0.
  IF lines( me->my_recheck_queue ) GE 1.
    lt_recheck = me->my_recheck_queue.
    me->if_flush_transport_mm~start( lt_recheck ).
  ENDIF.
* get messgae handler
  cl_message_handler_mm=>get_handler( IMPORTING ex_handler = lo_handler ).
* create a new sequence
  lo_handler->new_sequence( ).
* get configuration
  ls_msg_old = lo_handler->get_configuration( ).
  ls_msg_new = ls_msg_old.
  CLEAR ls_msg_new-events_for_dialog.
  lo_handler->set_configuration( ls_msg_new ).

*----------------------------------------------------------------------*
* phase 1: checks on item level
*----------------------------------------------------------------------*
  IF im_uncomplete     EQ lo_const->no  OR
*   JFMIP: Do checks also for parked documents.
*   This is specifically necessary to check held documents that
*   are now supposed to be parked.                            "Park&Hold
     im_uncompletetype EQ lo_const->park.           "Park&Hold

*- get items with error -----------------------------------------------*
    me->get_transaction_state( IMPORTING ex_uncomplete = lv_uncomplete ).
    IF lv_uncomplete EQ lo_const->yes.
* previous state was uncomplete: we have to get all items with error --*
      me->get_items( EXPORTING im_items_with_error = lo_const->yes
                     IMPORTING ex_items            = l_models ).
      l_model-model = me.
      INSERT l_model INTO TABLE l_models.
    ELSE.
* check only items with enqueue errors --------------------------------*
      me->get_items( EXPORTING im_enq_err_mat = lo_const->yes
                               im_enq_err_con = lo_const->yes
                     IMPORTING ex_items       = l_models ).
    ENDIF.
* additionally check all items with faulty requisition references.
    CALL FUNCTION 'MEREQS_STATISTICS_FINAL_CHECKS'
      IMPORTING
        ex_items      = lt_models
      EXCEPTIONS
        error_message = 0
        OTHERS        = 0.
    LOOP AT lt_models INTO ls_model.
      mmpur_dynamic_cast1 lo_item ls_model-model.
      CHECK lo_item IS BOUND.
      lo_req  = lo_item->get_requisition( ).
      ls_req_head = lo_req->get_data( ).
      ls_req_item = lo_item->get_data( ).
      get_items_with_requisition(
                       EXPORTING im_banfn = ls_req_head-banfn
                                 im_bnfpo = ls_req_item-bnfpo
                       IMPORTING et_items = lt_subitems ).
      LOOP AT lt_subitems REFERENCE INTO lr_subitem.
        READ TABLE l_models WITH KEY model = lr_subitem->model
                   TRANSPORTING NO FIELDS.
        CHECK sy-subrc GT 0.
        l_model-model = lr_subitem->model.
        INSERT l_model INTO TABLE l_models.
      ENDLOOP.
    ENDLOOP.

    IF lines( l_models ) GE 1.
      me->if_flush_transport_mm~start( l_models ).          "1120469
    ENDIF.

  ENDIF.
*
*----------------------------------------------------------------------*
* preparations for message handling
*----------------------------------------------------------------------*
  cl_message_mm=>set_current_business_obj( im_business_obj = me ).
  cl_message_mm=>set_current_context( mmcnt_final_checks ).
*
  IF im_uncomplete EQ lo_const->no.
* this must only take place in the case of non-parked documents
    lo_handler->remove_by_bo( im_business_obj          = me
                              im_context               = mmcnt_final_checks
                              im_include_child_objects = lo_const->yes ).
    lo_handler->remove_by_bo( im_business_obj          = me
                              im_context               = mmcnt_user_exit
                              im_include_child_objects = lo_const->yes ).
  ELSE.                                                     "^2781794
    IF me->for_bapi EQ lo_const->yes AND
       im_uncompletetype EQ lo_const->park.
      CALL METHOD lo_handler->remove_by_bo
        EXPORTING
          im_business_obj           = me
          im_context                = mmcnt_final_checks
          im_include_child_objects  = lo_const->yes.

    ENDIF.                                                  "v2781794
  ENDIF.

  lo_handler->cleanup( ).
*
*----------------------------------------------------------------------*
* change protocol preparations
*----------------------------------------------------------------------*
  me->get_data( IMPORTING ex_data = ls_header_old ).
  me->chp_add_hash_entry( ls_header_old ).


* Registering Identity Manager, allowing to read data from MEPOs memory
* for exmpale for Workflow Simulation
  cl_identity_manager_mm=>register( EXPORTING im_obj = me ).

*
*----------------------------------------------------------------------*
* Check method
*----------------------------------------------------------------------*

  CALL FUNCTION 'MEPO_DOC_CHECK'
    EXPORTING
      im_uncomplete     = im_uncomplete
      im_uncompletetype = im_uncompletetype                  "Park&Hold
      im_inactive_doc   = im_inactive_doc                    "Draft Check = 'X'
    EXCEPTIONS
      invalid_call      = 1
      cancelled         = 2
      error_message     = 3
      OTHERS            = 4.
  lv_result = sy-subrc.
  IF lv_result GE 1.
    IF lv_result EQ 1.
      MESSAGE a816(me) WITH 'PO_CHECK'.
    ELSEIF lv_result EQ 3 OR lv_result EQ 4.
      cl_message_mm=>create(
        EXPORTING  im_msgid         = sy-msgid
                   im_msgty         = sy-msgty
                   im_msgno         = sy-msgno
                   im_msgv1         = sy-msgv1
                   im_msgv2         = sy-msgv2
                   im_msgv3         = sy-msgv3
                   im_msgv4         = sy-msgv4
                   im_force_collect = lo_const->yes
        EXCEPTIONS failure          = 0
                   dialog           = 0 ).

    ENDIF.
    ret_severity = mmpur_event_e.
  ELSEIF lv_result EQ 0 AND me->for_bapi EQ lo_const->yes.
    CLEAR lt_events.
    lo_handler->getlist( EXPORTING im_event_type = mmpur_event_e
                            IMPORTING ex_events  = lt_events ).
    IF lines( lt_events ) GE 1.
      ret_severity = mmpur_event_e.                         "2046602
    ENDIF.
  ENDIF.

* Check external links
  DATA(lo_ext_link_handler) = cl_mm_pur_po_ext_links=>get_instance( ).
  DATA(rv_failure) = lo_ext_link_handler->check_links( ).
  IF rv_failure = abap_true.
    ret_severity = mmpur_event_e.
  ENDIF.

* Deregistering Identity Manager
  CALL METHOD cl_identity_manager_mm=>unregister
    EXPORTING
      im_obj = me
    EXCEPTIONS
      OTHERS = 0.

*
*----------------------------------------------------------------------*
* BAdi ME_PROCESS_PO(_CUST)->CHECK
*----------------------------------------------------------------------*
  IF im_uncomplete IS INITIAL.                                "Park&Hold
    CLEAR: lv_hold, lv_park.
  ELSEIF im_uncompletetype EQ lo_const->park.
    lv_hold = lo_const->no.
    lv_park = lo_const->yes.
  ELSEIF im_uncompletetype EQ lo_const->hold OR
         im_uncompletetype IS INITIAL.
    lv_park = lo_const->no.
    lv_hold = lo_const->yes.
  ENDIF.

  TRY.
      GET BADI lo_cloud_check_badi.
    CATCH cx_badi.
  ENDTRY.

  cl_mm_pur_gfn_me_map=>map_from_me_po_to_gfn_po( EXPORTING
                                                    io_handler = me
                                                  IMPORTING
                                                    es_purchaseorder          = ls_purchaseorder
                                                    es_purchaseorder_db       = ls_purchaseorder_db
                                                    et_purchaseorderitems     = lt_purchaseorderitem
                                                    et_purchaseorderitems_db  = lt_purchaseorderitem_db
                                                    et_purordschedulelines    = lt_purordscheduleline
                                                    et_purordaccountassignmts = lt_purordaccountassignmt ).

  MOVE-CORRESPONDING ls_purchaseorder TO ls_b_purchaseorder.
  MOVE-CORRESPONDING ls_purchaseorder TO ls_b_purchaseorder-include. "2639984
  MOVE-CORRESPONDING ls_purchaseorder_db TO ls_b_purchaseorder_db.
  MOVE-CORRESPONDING ls_purchaseorder_db TO ls_b_purchaseorder_db-include. "2639984
  LOOP AT lt_purchaseorderitem INTO ls_purchaseorderitem.
    MOVE-CORRESPONDING ls_purchaseorderitem TO ls_b_purchaseorderitem.
    MOVE-CORRESPONDING ls_purchaseorderitem TO ls_b_purchaseorderitem-include. "2639984
    APPEND ls_b_purchaseorderitem TO lt_b_purchaseorderitem.
  ENDLOOP.
  LOOP AT lt_purchaseorderitem_db INTO ls_purchaseorderitem.
    MOVE-CORRESPONDING ls_purchaseorderitem TO ls_b_purchaseorderitem.
    MOVE-CORRESPONDING ls_purchaseorderitem TO ls_b_purchaseorderitem-include. "2639984
    APPEND ls_b_purchaseorderitem TO lt_b_purchaseorderitem_db.
  ENDLOOP.
  LOOP AT lt_purordscheduleline INTO ls_purordscheduleline.
    MOVE-CORRESPONDING ls_purordscheduleline TO ls_b_purordscheduleline.
    APPEND ls_b_purordscheduleline TO lt_b_purordscheduleline.
  ENDLOOP.
  LOOP AT lt_purordaccountassignmt INTO ls_purordaccountassignmt.
    MOVE-CORRESPONDING ls_purordaccountassignmt TO ls_b_purordaccountassignmt.
    APPEND ls_b_purordaccountassignmt TO lt_b_purordaccountassignmt.
  ENDLOOP.

  TRY.
      CALL BADI lo_cloud_check_badi->check
        EXPORTING
          purchaseorder              = ls_b_purchaseorder
          purchaseorder_db           = ls_b_purchaseorder_db
          purchaseorderitems         = lt_b_purchaseorderitem
          purchaseorderitems_db      = lt_b_purchaseorderitem_db
          purchaseorderschedulelines = lt_b_purordscheduleline
          purchaseorderaccounting    = lt_b_purordaccountassignmt
        CHANGING
          messages                   = lt_b_messages.
    CATCH cx_ble_runtime_error.
  ENDTRY.

  LOOP AT lt_b_messages INTO ls_b_messages.
    MOVE-CORRESPONDING ls_b_messages TO ls_messages.
    "Currently it is not possible to use se91 messages in cloud BADIs
    "once it is possible not the fixed messageid and the fixed messagenumber is necessary anymore
    ls_messages-messageid = 'MEPO'.
    ls_messages-messagenumber = '250'.
    APPEND ls_messages TO lt_messages.
  ENDLOOP.

  LOOP AT lt_messages INTO DATA(ls_message).
    cl_message_mm=>create(
    EXPORTING  im_msgid         = ls_message-messageid
               im_msgty         = ls_message-messagetype
               im_msgno         = ls_message-messagenumber
               im_msgv1         = ls_message-messagevariable1
               im_msgv2         = ls_message-messagevariable2
               im_msgv3         = ls_message-messagevariable3
               im_msgv4         = ls_message-messagevariable4
               im_force_collect = lo_const->yes
    EXCEPTIONS failure          = 0
               dialog           = 0 ).
    IF ls_message-messagetype = 'E' OR
       ls_message-messagetype = 'A'.
      lv_failed_cloud = lo_const->yes.
    ENDIF.
  ENDLOOP.

  CALL FUNCTION 'MEPOBADI_CHECK'
    EXPORTING
      im_header     = me
      im_hold       = lv_hold                                  "Park&Hold
      im_park       = lv_park                                  "Park&Hold
    CHANGING
      ch_failed     = lv_failed
    EXCEPTIONS
      error_message = 1
      OTHERS        = 2.
  IF sy-subrc GE 1.
    cl_message_mm=>create(
      EXPORTING  im_msgid         = sy-msgid
                 im_msgty         = sy-msgty
                 im_msgno         = sy-msgno
                 im_msgv1         = sy-msgv1
                 im_msgv2         = sy-msgv2
                 im_msgv3         = sy-msgv3
                 im_msgv4         = sy-msgv4
                 im_force_collect = lo_const->yes
      EXCEPTIONS failure          = 0
                 dialog           = 0 ).
    lv_failed = lo_const->yes.
  ENDIF.
  IF lv_failed_cloud = lo_const->yes.
    lv_failed = lo_const->yes.
  ENDIF.

  IF lv_failed EQ lo_const->yes.
    ret_severity = mmpur_event_e.
    PERFORM fluss_setzen IN PROGRAM saplmecom1 USING '20'.
  ENDIF.

  IF ret_severity IS INITIAL.
    lv_events = lo_handler->has_new_events( ).
    IF lv_events EQ lo_const->yes.
      ret_severity = mmpur_event_w.
    ENDIF.
  ENDIF.

  cl_message_mm=>set_current_context( 0 ).
  lo_handler->set_configuration( ls_msg_old ).
  lo_handler->cleanup( ).
*----------------------------------------------------------------------*
* Change protocol header level
*----------------------------------------------------------------------*
  me->get_data( IMPORTING ex_data = ls_header ).
  IF ls_header NE ls_header_old.
    me->chp_register( mmchp_chp_update ).
  ENDIF.

ENDMETHOD.                    "


METHOD po_cancel .

  TYPES: BEGIN OF loekz_info,
           ebelp  TYPE ekpo-ebelp,
           loekzx TYPE c LENGTH 1,
         END OF loekz_info.

  DATA : l_models         TYPE mmpur_models,
         ls_model         LIKE LINE OF l_models,
         l_item           TYPE REF TO cl_po_item_handle_mm,
         l_header_data    TYPE mepoheader,
         ls_item_data     TYPE mepoitem,
         l_header_datax   TYPE mepoheaderx,
         ls_item_datax    TYPE mepoitemx,
         l_answer         TYPE c,
         wa_loekz_info    LIKE LINE OF my_po_loekz_info.

  CLEAR ret_severity.
  CLEAR my_po_loekz_info.
  REFRESH my_po_loekz_info.
*----------------------------------------------------------------------*
* get all items
*----------------------------------------------------------------------*

  l_models = my_items.

  IF skip_popup IS INITIAL.
    CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'           "#EC *
      EXPORTING
        defaultoption = 'N'
        diagnosetext1 = text-001
        diagnosetext2 = text-002
        diagnosetext3 = text-003
        textline1     = text-004
        titel         = text-005
      IMPORTING
        answer        = l_answer.
  ELSE.
* without Popup allways do the change
    l_answer = 'J'.
  ENDIF.
  IF l_answer = 'J'.
    LOOP AT l_models INTO ls_model.
      mmpur_dynamic_cast l_item ls_model-model.
      l_item ?= ls_model-model.
      IF l_item IS BOUND AND
          NOT l_item->po_item_number IS INITIAL.
        l_item->get_data( IMPORTING ex_data = ls_item_data ).
        wa_loekz_info-ebelp = ls_item_data-ebelp.
* store the status of the PO_ITEM in case of recancelling
* in the same session
        IF ls_item_data-loekz EQ space.
          ls_item_data-loekz = 'L'.
          wa_loekz_info-loekzx = ' '.
          IF me->for_bapi EQ mmpur_yes.
            ls_item_datax-ebelp_key = ls_item_data-ebelp.
            ls_item_datax-ebelp = mmpur_yes.
            ls_item_datax-loekz = mmpur_yes.
            l_item->set_datax( ls_item_datax ).
          ENDIF.
        ELSE.
          wa_loekz_info-loekzx = 'X'.
        ENDIF.
        APPEND wa_loekz_info TO my_po_loekz_info.
        l_item->set_data( ls_item_data ).
      ENDIF.
    ENDLOOP.

    me->get_data( IMPORTING ex_data = l_header_data ).
    l_header_data-loekz = 'C'.
    me->set_data( im_data = l_header_data ).

    me->get_datax( IMPORTING ex_data = l_header_datax ).
    l_header_datax-loekz = 'X'.
    me->set_datax( im_data = l_header_datax ).

    IF me->for_bapi EQ mmpur_yes.
      ls_model-model ?= me.
      APPEND ls_model TO l_models.
    ENDIF.

    IF NOT l_models[] IS INITIAL.
      me->flush_data( EXPORTING im_models = l_models ).
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD lookup.

  DATA: wa      LIKE LINE OF my_items,
        l_item  TYPE REF TO cl_po_item_handle_mm,
        l_handle TYPE REF TO cl_handle_mm,                     "1428972
        l_s_lookup_hash TYPE cl_handle_mm=>type_s_lookup_hash. "1428972

  CLEAR re_item.
  CHECK NOT im_item_number IS INITIAL.

  "1428972 get reference via get_hash_entry, if this fails use old logic
  l_s_lookup_hash-ebeln = me->po_number.
  l_s_lookup_hash-ebelp = im_item_number.

  CALL METHOD ME->GET_HASH_ENTRY
    EXPORTING
      is_data = l_s_lookup_hash
    IMPORTING
      EX_MODEL = l_handle.

  TRY.                                                         "1428972
    re_item ?= l_handle.
    CATCH cx_sy_move_cast_error.  "#EC *
  ENDTRY.
  if re_item is initial.                                       "1428972
  LOOP AT my_items INTO wa.
    l_item ?= wa-model.
    IF l_item->po_item_number EQ im_item_number.
      re_item = l_item.
      EXIT.
    ENDIF.
  ENDLOOP.
  endif.                                                       "1428972

ENDMETHOD.                    "LOOKUP


METHOD is_ordrsp.
*--------------------------------------------------------------------*
* Order Acknowlegement Process Validation - note 1742741
*--------------------------------------------------------------------*
* define local data objects
  DATA: lo_const  TYPE REF TO cl_mmpur_constants,
        lv_ordrsp TYPE sy-repid VALUE 'SAPLMMPUR_EINM',     "#EC *
        lv_ordrsparb TYPE sy-repid VALUE 'CL_ARBFND_INBOUND=============CP'. "#EC *  "2143451
*
  lo_const = cl_mmpur_constants=>get_instance( ).
  rv_active = lo_const->no.
  IF me->mv_ordrsp EQ lo_const->yes
    AND ( cl_mmpur_bapi_po=>check_repid_loaded( lv_ordrsp ) EQ lo_const->yes OR
          cl_mmpur_bapi_po=>check_repid_loaded( lv_ordrsparb ) EQ lo_const->yes ).  "2143451
    rv_active = lo_const->yes.
  ENDIF.

ENDMETHOD.


METHOD IF_UNIQUE_INSTANCE_MM~GET_KEY.


*  data: l_ekko type mepoheader.

*   call method get_data importing ex_data = l_ekko.

   CONCATENATE 'PO/' po_number INTO EX_KEY.

ENDMETHOD.


METHOD if_release_state_mm~reset_release.

  DATA: l_strategy    TYPE REF TO if_release_strategy_mm,
        l_frgzu       TYPE ekko-frgzu,
        l_indicator   TYPE ekko-frgke,
        l_is_released TYPE mmpur_bool,
        l_header      TYPE mepoheader.

  me->get_data( IMPORTING ex_data = l_header ).

  MOVE: l_header-frgzu     TO l_frgzu,
        l_header-frgke     TO l_indicator.

  IF l_header-frgrl EQ space.
    l_is_released = cl_mmpur_constants=>yes.
  ELSE.
    l_is_released = cl_mmpur_constants=>no.
  ENDIF.

  l_strategy = if_release_state_mm~get_strategy( ).
  CHECK l_strategy IS BOUND.

  CALL METHOD l_strategy->propagate_state
    EXPORTING
      im_frgco             = im_code
      im_reset             = cl_mmpur_constants=>yes
    CHANGING
      ch_frgzu             = l_frgzu
      ch_frgke             = l_indicator
      ch_released          = l_is_released
    EXCEPTIONS
      no_authority         = 1
      prerequisite_missing = 2
      already_released     = 3
      not_released         = 4
      not_responsible      = 5
      illegal_call         = 6
      illegal_indicator    = 7
      OTHERS               = 8.

  CASE sy-subrc.
    WHEN 1. RAISE no_authority.
    WHEN 4. RAISE not_released.
    WHEN 5. RAISE not_responsible.
    WHEN 6. RAISE illegal_call.
    WHEN 7. RAISE illegal_indicator.
    WHEN 8. RAISE illegal_call.
  ENDCASE.

  IF im_statu EQ 'X'.
    RAISE po_printed.
  ENDIF.

  l_header-frgzu = l_frgzu.
  l_header-frgke = l_indicator.
  IF l_is_released = cl_mmpur_constants=>yes.
    l_header-frgrl = ' '.
  ELSE.
    l_header-frgrl = 'X'.
  ENDIF.

  PERFORM set_release_state IN PROGRAM saplmepo USING l_header-frggr
                                                      l_header-frgsx
                                                      l_header-frgke
                                                      l_header-frgzu
                                                      l_header-frgrl.

ENDMETHOD.                    "IF_RELEASE_STATE_MM~RESET_RELEASE


  METHOD if_release_state_mm~release_new_workflow.
  ENDMETHOD.


  METHOD if_purchase_order_mm~get_supplier_address.

    IF is_address_handling_active( ).
      DATA ls_header TYPE mepoheader.
      get_data(
        IMPORTING
          ex_data = ls_header       " Document Header
        EXCEPTIONS
          failure = 1                " Error
          OTHERS  = 2
      ).
      IF sy-subrc <> 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*       WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ELSE.
        rs_address = me->get_supplier_address(  is_header  = ls_header
                                                iv_addrnumber_only = iv_addrnumber_only
                                              ).
      ENDIF.
    ENDIF.

  ENDMETHOD.


method IF_DCM_ADAPTER~IS_COMPLETE_VERSION_ALLOWED .

  data: l_adapter type ref to if_dcm_adapter.

  CALL FUNCTION 'MEPO_DOC_DCM_MANAGER_GET'
    IMPORTING
      EX_ADAPTER       = l_adapter.

  if not l_adapter is initial.
    re_bool = l_adapter->IS_complete_VERSION_ALLOWED( ).
  else.
    re_bool = mmpur_no.
  endif.

endmethod.


method IF_DCM_ADAPTER~GET_MANAGER .

  CALL FUNCTION 'MEPO_DOC_DCM_MANAGER_GET'
    IMPORTING
      EX_MGR           = re_mgr.

endmethod.


METHOD if_async_subject_mm~reset_changes.
  CALL METHOD chp_refresh_hash_table.
ENDMETHOD.


METHOD if_async_subject_mm~get_changes.

  DEFINE check_change.
    if &1 ne &2.
      l_change-metafield = &3.
      insert l_change into table ch_changelist.
      add 1 to l_special_entries.
    endif.
  END-OF-DEFINITION.

  DATA: l_change          LIKE LINE OF ch_changelist,
        l_hash_entry      LIKE LINE OF chp_hash_table,
        l_data_new        TYPE mepoheader,
        l_data_old        TYPE mepoheader,
        l_special_entries TYPE i.

  CLEAR l_change.
  l_change-model ?= me.
  l_change-action = im_action.

  IF im_action NE mmchp_chp_update.

    INSERT l_change INTO TABLE ch_changelist.

  ELSE.

    READ TABLE chp_hash_table INTO l_hash_entry
                                   WITH TABLE KEY header = me.
    IF sy-subrc IS INITIAL.
      l_data_old = l_hash_entry-data.
      CALL METHOD get_data
        IMPORTING
          ex_data = l_data_new.

* checks for significant changes

* document type
      check_change l_data_new-bsart l_data_old-bsart mmmfd_doc_typ.
* vendor
      check_change l_data_new-lifnr l_data_old-lifnr mmmfd_vendor.
* suppl. vendor
      check_change l_data_new-llief l_data_old-llief mmmfd_goods_suppl.
* supplying plant
      check_change l_data_new-reswk l_data_old-reswk mmmfd_suppl_plnt.
* company code
      check_change l_data_new-bukrs l_data_old-bukrs mmmfd_comp_code.
* Calculation procedure
      check_change l_data_new-kalsm l_data_old-kalsm mmmfd_procedure.
* purchasing org
      check_change l_data_new-ekorg l_data_old-ekorg mmmfd_purch_org.
* purchasing grp
      check_change l_data_new-ekgrp l_data_old-ekgrp mmmfd_pur_group.
* country
      check_change l_data_new-lands l_data_old-lands mmmfd_taxr_cntry.
* header import                                             "1828637
      check_change l_data_new-exnum l_data_old-exnum mmmfd_header_import.
* release group
      check_change l_data_new-frggr l_data_old-frggr mmmfd_rel_group.
* release strategy
      check_change l_data_new-frgsx l_data_old-frgsx mmmfd_rel_strat.
* release state
      check_change l_data_new-frgzu l_data_old-frgzu mmmfd_rel_ind.

    ENDIF.

    IF l_special_entries IS INITIAL.
      INSERT l_change INTO TABLE ch_changelist.
    ENDIF.

* other change list entries
    DATA: ls_entry LIKE LINE OF po_header_chp_table.

    READ TABLE po_header_chp_table INTO ls_entry
         WITH TABLE KEY header = me.

    IF sy-subrc IS INITIAL.
      APPEND LINES OF ls_entry-changelist TO ch_changelist.
    ENDIF.

  ENDIF.
ENDMETHOD.                    "if_async_subject_mm~get_changes


METHOD HAS_CHANGED .


CALL FUNCTION 'MEPO_DOC_GET_TRANSACTION_STATE'
     IMPORTING
          EX_CHANGED = ret_changed.

ENDMETHOD.


METHOD get_transaction_state.

  DATA: l_holding_allowed_ph       TYPE mmpur_bool,
        l_holding_allowed_final_ph TYPE mmpur_bool,
        l_parking_allowed_ph       TYPE mmpur_bool,
        l_parking_allowed_final_ph TYPE mmpur_bool,
        l_dummy                    TYPE mmpur_bool.


  CALL FUNCTION 'MEPO_DOC_GET_TRANSACTION_STATE'
    IMPORTING
      ex_trtyp                    = ex_trtyp
      ex_aktyp                    = ex_aktyp
      ex_tcode                    = ex_tcode
      ex_uncomplete               = ex_uncomplete
      ex_uncompletetype           = ex_uncompletetype           "Park&Hold
      ex_parking_allowed          = ex_parking_allowed
      ex_parking_allowed_final    = ex_parking_allowed_final
      ex_holding_allowed_ph       = l_holding_allowed_ph        "Park&Hold
      ex_holding_allowed_final_ph = l_holding_allowed_final_ph  "Park&Hold
      ex_parking_allowed_ph       = l_parking_allowed_ph        "Park&Hold
      ex_parking_allowed_final_ph = l_parking_allowed_final_ph  "Park&Hold
      ex_parkhold_active          = ex_parkhold_active          "Park&Hold
      ex_neudruck                 = ex_neudruck.

ENHANCEMENT-SECTION     604ENH_CL_PO_HEADER_HANDLE_01 SPOTS ES_CL_PO_HEADER_HANDLE_MM.
  IF ex_parking_allowed IS REQUESTED OR
     ex_parking_allowed_final IS REQUESTED.

*   behavior for ex_parking_allowed must be unchanged:                "Park&Hold
*   ex_parking_allowed provides info for holding                      "Park&Hold
    PERFORM mepo_parking_allowed_cust IN PROGRAM saplmepo
                  CHANGING ex_parking_allowed
                           l_dummy.

    IF ex_parking_allowed EQ mmpur_no.
      ex_parking_allowed_final = mmpur_no.
    ENDIF.

  ENDIF.
END-ENHANCEMENT-SECTION.

  IF ch_t160d IS REQUESTED.                                 "514141
    PERFORM get_t160d IN PROGRAM saplmepo CHANGING ch_t160d. "514141
  ENDIF.                                                    "514141

ENDMETHOD.


METHOD GET_TKOMV.

  EX_TKOMV[]                   = PO_TKOMV_HASH_TABLE[].
  EX_ITEM_CONDITIONS_CHANGED   = ITEM_CONDITIONS_CHANGED.
  EX_HEADER_CONDITIONS_CHANGED = HEADER_CONDITIONS_CHANGED.
  EX_HEADER_CALCULATION_TYPE   = HEADER_CALCULATION_TYPE.
ENDMETHOD.


  METHOD get_supplier_address.

    IF is_header-adrnr IS NOT INITIAL.
      rs_address-addrnumber = is_header-adrnr.
    ELSEIF is_header-lifnr IS NOT INITIAL.
      SELECT SINGLE adrnr FROM lfa1 INTO rs_address-addrnumber WHERE lifnr = is_header-lifnr.
    ELSEIF is_header-kunnr IS NOT INITIAL.
      SELECT SINGLE adrnr FROM kna1 INTO rs_address-addrnumber WHERE kunnr = is_header-kunnr.
    ELSEIF is_header-reswk IS NOT INITIAL.
      SELECT SINGLE adrnr INTO rs_address-addrnumber FROM t001w WHERE werks = is_header-reswk.
    ENDIF.

*    IF is_header-adrnr IS INITIAL.
** only select address for non CPD supplier
*      SELECT SINGLE adrnr INTO rs_address-addrnumber FROM lfa1 WHERE lifnr = is_header-lifnr AND xcpdk = ''.
*    ELSE.
*      rs_address-addrnumber = is_header-adrnr.
*    ENDIF.

    IF NOT rs_address-addrnumber IS INITIAL.
      IF iv_addrnumber_only <> abap_true.
        rs_address = mr_address_handler->read_address( iv_address_number = |{ rs_address-addrnumber ALPHA = IN }| ).
      ENDIF.
    ENDIF.

  ENDMETHOD.


method GET_REVAL_ATTRIBUTES.
 ex_no_version = fm_reval_no_version.
  ex_no_release = fm_reval_no_release.
endmethod.


METHOD get_mapping .

  DATA: l_mfs TYPE REF TO cl_mfs_mm,
        ls_fs LIKE LINE OF my_fs_template.

  FIELD-SYMBOLS: <mapping> LIKE LINE OF my_field_mapping.

  IF my_field_mapping[] IS INITIAL.
    l_mfs = cl_mfs_mm=>get_instance( ).
    my_field_mapping = l_mfs->lookup( im_application = 'MMPUR_PO_DOC'
                                      im_tabname     = 'EKKO' ).
    LOOP AT my_field_mapping ASSIGNING <mapping>.
      CHECK <mapping>-metafield IS NOT INITIAL.
      ls_fs-metafield = <mapping>-metafield.
      INSERT ls_fs INTO TABLE my_fs_template.
    ENDLOOP.
  ENDIF.

  ex_mapping = my_field_mapping.
  ex_fs_template = my_fs_template.

ENDMETHOD.


METHOD get_items_with_requisition.

  PERFORM mepo_reban_lookup_ids IN PROGRAM saplmepo
                                          USING im_banfn
                                                im_bnfpo
                                          CHANGING
                                                et_items.

ENDMETHOD.


METHOD get_items.

  DATA: lt_id TYPE STANDARD TABLE OF mepo_id INITIAL SIZE 0,
        ls_id LIKE LINE OF lt_id,
        wa LIKE LINE OF ex_items,
        l_handle TYPE REF TO cl_handle_mm.

  REFRESH ex_items.

  CALL FUNCTION 'MEPO_DOC_ITEMS_ID_GET'
       EXPORTING
            im_items_with_error = im_items_with_error
            im_enq_err_mat      = im_enq_err_mat
            im_enq_err_con      = im_enq_err_con
       TABLES
            ext_item            = lt_id.

  LOOP AT lt_id INTO ls_id.

    CALL METHOD cl_handle_manager_mm=>get
                                   EXPORTING im_id = ls_id-id
                                   IMPORTING ex_handle = l_handle.
    wa-model ?= l_handle.
    APPEND wa TO ex_items.

  ENDLOOP.

ENDMETHOD.


  method GET_HIERARCHY_FIELD.
    rv_hierarchy = has_hierarchy.
  endmethod.


method get_gos_manager .                                    "913251

  check me->for_bapi eq ' '.
  re_manager = me->my_gos_manager.

endmethod.


METHOD get_datax .

  DATA: l_hash_entry LIKE LINE OF po_headerx_hash_table,
        l_ref        TYPE REF TO data,
        lt_fcat      TYPE mepo_t_fieldcatalog,
        l_postfix    TYPE string40,
        l_prop       TYPE REF TO cl_proposer_mm.

  FIELD-SYMBOLS: <data>   TYPE mepoheader_prop,
                 <fcat>   LIKE LINE OF lt_fcat,
                 <source> TYPE ANY,
                 <target> TYPE ANY.


  CLEAR ex_data.

  IF state EQ c_verify.
    READ TABLE po_headerx_hash_table INTO l_hash_entry
               WITH TABLE KEY header = me.
    IF sy-subrc IS INITIAL.
      ex_data = l_hash_entry-data.
    ENDIF.

  ELSEIF state EQ c_new.
* propose data. Note: in display or change mode the state becomes NEVER
* 'new'.
    CALL METHOD me->check_proposer( ).
    IF my_header_proposer IS BOUND.
      l_prop ?= my_header_proposer.
      lt_fcat = l_prop->get_selected_fcat( ).
      l_postfix = l_prop->get_postfix( ).
      CHECK NOT l_postfix IS INITIAL.
      me->my_header_proposer->get_data( IMPORTING ex_data = l_ref ).
      IF l_ref IS BOUND.
        ASSIGN l_ref->* TO <data>.
        LOOP AT lt_fcat ASSIGNING <fcat>.
          ASSIGN COMPONENT <fcat>-fieldname OF STRUCTURE <data>
                                     TO <source>.
          CHECK sy-subrc IS INITIAL.
          ASSIGN COMPONENT <fcat>-fieldname OF STRUCTURE ex_data
                                     TO <target>.
          CHECK sy-subrc IS INITIAL.
          IF NOT <source> IS INITIAL.
            <target> = mmpur_yes.
          ENDIF.
        ENDLOOP.

      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.                    "


METHOD get_data .

  DATA: l_hash_entry LIKE LINE OF po_header_hash_table,
        l_ref        TYPE REF TO data.

  FIELD-SYMBOLS: <data> TYPE mepoheader_prop.

  CLEAR ex_data.

  IF state EQ c_verify.
    READ TABLE po_header_hash_table INTO l_hash_entry
               WITH TABLE KEY header = me.
    IF sy-subrc NE 0.
      RAISE failure.
    ENDIF.
    ex_data = l_hash_entry-data.

  ELSEIF state EQ c_available.

    CALL FUNCTION 'MEPO_DOC_HEADER_GET'
      IMPORTING
        ex_ekko = ex_data.

  ELSEIF state EQ c_new.
* propose data. Note: in display or change mode the state becomes NEVER
* 'new'.
    CALL METHOD check_proposer.
    IF NOT my_header_proposer IS INITIAL.
      CALL METHOD my_header_proposer->get_data
        IMPORTING
          ex_data = l_ref.
      IF NOT l_ref IS INITIAL.
        ASSIGN l_ref->* TO <data>.
        MOVE-CORRESPONDING <data> TO ex_data.               "#EC *
* provide a value for BSAKZ: important for the tompline GUI view
        IF ex_data-bsart NE my_161-bsart.
          CLEAR my_161-bsart.
          SELECT SINGLE * FROM t161 INTO my_161 WHERE
                       bstyp EQ 'F' AND
                       bsart EQ ex_data-bsart.
        ENDIF.
        ex_data-bsakz = my_161-bsakz.

      ENDIF.
    ENDIF.

  ELSE.
    CLEAR ex_data.
  ENDIF.

  ex_data-id = me->id.
  IF ex_data-bstyp IS INITIAL.
    ex_data-bstyp = cl_mmpur_constants=>bstyp_f.
  ENDIF.

ENDMETHOD.


METHOD flush_data.

  DATA: l_model_entry               LIKE LINE OF im_models,
        l_po_header_handle          TYPE REF TO cl_po_header_handle_mm,
        l_po_item_handle            TYPE REF TO cl_po_item_handle_mm,
        l_po_schedule_handle        TYPE REF TO cl_po_schedule_handle_mm,
        l_po_accounting_handle      TYPE REF TO cl_po_accounting_handle_mm,

        l_dcm_manager               TYPE REF TO if_revision_manager_dcm,
        l_dcm_item                  TYPE REF TO if_revision_item_dcm,

        l_header_received           TYPE mmpur_bool,
        l_received                  TYPE mmpur_bool,

        l_ekko                      TYPE mepoheader,
        l_ekkox                     TYPE mepoheaderx,

        lt_items                    TYPE STANDARD TABLE OF mepoitem
                         INITIAL SIZE 0,
        ls_item                     LIKE LINE OF lt_items,
        lt_itemsx                   TYPE STANDARD TABLE OF mepoitemx
                         INITIAL SIZE 0,
        ls_itemx                    LIKE LINE OF lt_itemsx,

        lt_schedules                TYPE STANDARD TABLE OF meposchedule
                         INITIAL SIZE 0,
        ls_schedule                 LIKE LINE OF lt_schedules,
        lt_schedulesx               TYPE STANDARD TABLE OF meposchedulex
                         INITIAL SIZE 0,
        ls_schedulex                LIKE LINE OF lt_schedulesx,

        lt_accountings              TYPE STANDARD TABLE OF mepoaccounting
                         INITIAL SIZE 0,
        ls_accounting               LIKE LINE OF lt_accountings,
        lt_accountingsx             TYPE STANDARD TABLE OF mepoaccountingx
                         INITIAL SIZE 0,
        ls_accountingx              LIKE LINE OF lt_accountingsx,

        lt_komv                     TYPE mmpur_tkomv,
        l_header_conditions_changed TYPE mmpur_bool,
        l_header_calculation_type   TYPE komv-ksteu,
        lt_comsrv                   TYPE STANDARD TABLE OF mepocomsrv
                              INITIAL SIZE 0,
        l_comsrv                    TYPE mepocomsrv,
        lt_acc_tab                  TYPE mmpur_acc_tab,
        lt_ekpv                     TYPE STANDARD TABLE OF ekpv,
        ls_ekpv                     LIKE LINE OF lt_ekpv,
        lt_ekpvx                    TYPE STANDARD TABLE OF mepo_ekpvx,
        ls_ekpvx                    LIKE LINE OF lt_ekpvx,
        lt_eipo                     TYPE STANDARD TABLE OF mepo_eipo,
        ls_eipo                     LIKE LINE OF lt_eipo,
        ls_eikp                     TYPE mepo_eikp,
        l_aktyp                     TYPE char1,
        l_hd                        TYPE REF TO cl_message_handler_mm.

*-----------------------------------------------------------------------
* zentraler Update
*-----------------------------------------------------------------------

*-----------------------------------------------------------------------
* Schnittstelle verarbeiten
* - Datenbeschaffung aus Konsolidierungscache via get_data()
* - Konsolidierungscache zurücksetzen via set_state()
*-----------------------------------------------------------------------

  l_header_received = mmpur_no.
  l_received        = mmpur_no.

* Conditions

  CALL METHOD get_tkomv
    IMPORTING
      ex_tkomv                     = lt_komv
      ex_header_conditions_changed = l_header_conditions_changed
      ex_header_calculation_type   = l_header_calculation_type.

  CALL METHOD refresh_tkomv.
  IF NOT lt_komv[] IS INITIAL.
    l_received        = mmpur_yes.
  ENDIF.

* foreign trade header data
  IF eikp_changed EQ mmpur_yes.
    ls_eikp = me->if_purchase_order_mm~get_foreign_trade( ).
    CALL METHOD me->refresh_eikp_data( ).
    l_received = mmpur_yes.
  ENDIF.

  LOOP AT im_models INTO l_model_entry.
* Kopf
    mmpur_dynamic_cast l_po_header_handle l_model_entry-model.

    IF NOT l_po_header_handle IS INITIAL.

      CHECK l_po_header_handle->state NE c_deleted.
      l_header_received = mmpur_yes.
      l_received        = mmpur_yes.
      CALL METHOD l_po_header_handle->get_data
        IMPORTING
          ex_data = l_ekko
        EXCEPTIONS                                          "891356
          failure = 01.
      CHECK sy-subrc IS INITIAL.
      CALL METHOD l_po_header_handle->get_datax
        IMPORTING
          ex_data = l_ekkox.
      CALL METHOD l_po_header_handle->set_state( c_available ).
      CONTINUE.
    ENDIF.

*- items --------------------------------------------------------------*

    mmpur_dynamic_cast l_po_item_handle l_model_entry-model.
    IF NOT l_po_item_handle IS INITIAL.

* Services
      IF l_po_item_handle->comsrv_changed EQ mmpur_yes.
        CALL METHOD l_po_item_handle->if_services_mm~get_data
          IMPORTING
            ex_comsrv    = l_comsrv
            ex_acc_tab   = lt_acc_tab
          EXCEPTIONS                                        "891356
            failure      = 01
            illegal_data = 02.
        CHECK sy-subrc IS INITIAL.
        APPEND l_comsrv TO lt_comsrv.
        CALL METHOD l_po_item_handle->refresh_comsrv_data.
        l_received = mmpur_yes.
      ENDIF.
* Shipping_data
      IF l_po_item_handle->ekpv_changed EQ mmpur_yes.
        ls_ekpv = l_po_item_handle->if_purchase_order_item_mm~get_shipping_data( ).
        ls_ekpvx = l_po_item_handle->get_shipping_datax( ).
        APPEND ls_ekpv TO lt_ekpv.
        APPEND ls_ekpvx TO lt_ekpvx.
        CALL METHOD l_po_item_handle->refresh_ekpv_data( ).
        CALL METHOD l_po_item_handle->refresh_ekpvx_data( ).
        l_received = mmpur_yes.
      ENDIF.
* Foreign trade item data
      IF l_po_item_handle->eipo_changed EQ mmpur_yes.
        ls_eipo = l_po_item_handle->if_purchase_order_item_mm~get_foreign_trade( ).
        APPEND ls_eipo TO lt_eipo.
        CALL METHOD l_po_item_handle->refresh_eipo_data( ).
        l_received = mmpur_yes.
      ENDIF.

* item data
      CHECK l_po_item_handle->state NE c_deleted.
      l_received        = mmpur_yes.
      CALL METHOD l_po_item_handle->get_data
        IMPORTING
          ex_data = ls_item
        EXCEPTIONS                                          "891356
          failure = 01.
      CHECK sy-subrc IS INITIAL.
      APPEND ls_item TO lt_items.
      CALL METHOD l_po_item_handle->get_datax
        IMPORTING
          ex_data = ls_itemx.
      APPEND ls_itemx TO lt_itemsx.
      CALL METHOD l_po_item_handle->set_state( c_available ).
      CONTINUE.

    ENDIF.

*- Schedules ----------------------------------------------------------*

    mmpur_dynamic_cast l_po_schedule_handle l_model_entry-model.
    IF NOT l_po_schedule_handle IS INITIAL.

      CHECK l_po_schedule_handle->state NE c_deleted.
      l_received        = mmpur_yes.
      CALL METHOD l_po_schedule_handle->get_data
        IMPORTING
          ex_data = ls_schedule
        EXCEPTIONS                                          "891356
          failure = 01.
      CHECK sy-subrc IS INITIAL.
      APPEND ls_schedule TO lt_schedules.
      CALL METHOD l_po_schedule_handle->get_datax
        IMPORTING
          ex_data = ls_schedulex.
      APPEND ls_schedulex TO lt_schedulesx.
      CALL METHOD l_po_schedule_handle->set_state( c_available ).
      CONTINUE.
    ENDIF.

* Kontierung

    mmpur_dynamic_cast l_po_accounting_handle l_model_entry-model.
    IF NOT l_po_accounting_handle IS INITIAL.


      CHECK l_po_accounting_handle->state NE c_deleted.
      l_received        = mmpur_yes.
      CALL METHOD l_po_accounting_handle->get_data
        IMPORTING
          ex_data = ls_accounting
        EXCEPTIONS                                          "891356
          failure = 01.
      CHECK sy-subrc IS INITIAL.
      APPEND ls_accounting TO lt_accountings.
      CALL METHOD l_po_accounting_handle->get_datax
        IMPORTING
          ex_data = ls_accountingx.
      APPEND ls_accountingx TO lt_accountingsx.
      CALL METHOD l_po_accounting_handle->set_state( c_available ).
      CONTINUE.
    ENDIF.
* DCM manager header/item
    mmpur_dynamic_cast l_dcm_manager l_model_entry-model.
    IF NOT l_dcm_manager IS INITIAL.
      l_received        = mmpur_yes.
      CONTINUE.
    ENDIF.

    mmpur_dynamic_cast l_dcm_item l_model_entry-model.
    IF NOT l_dcm_item IS INITIAL.
      l_received        = mmpur_yes.
      CONTINUE.
    ENDIF.

  ENDLOOP.

*
* Check Document
*
  CHECK l_received EQ mmpur_yes.

* Header aus der Schnittstelle?
  IF l_header_received EQ mmpur_no.
    CALL METHOD get_data
      IMPORTING
        ex_data = l_ekko
      EXCEPTIONS                                            "891356
        failure = 01.
    CHECK sy-subrc IS INITIAL.
    CALL METHOD chp_add_hash_entry( im_data = l_ekko ).
    CALL METHOD chp_register(
        im_action = mmchp_chp_update
        im_handle = me ).
    CALL METHOD set_state( c_available ).
  ENDIF.
  l_ekko-id = id.


* Registering Identity Manager, allowing to read data from MEPOs memory
* for example during accounting checks
  cl_identity_manager_mm=>register( EXPORTING im_obj = me ).

*
* Check Document
*
  CALL METHOD get_transaction_state
    IMPORTING
      ex_aktyp = l_aktyp.

* note 973156 (EBELN should be deleted from SORT)
* if not sorted the binary search in PO_PROCESS will fail
  SORT: lt_items STABLE BY ebelp, lt_itemsx STABLE BY ebelp_key,
        lt_schedules    STABLE BY ebelp etenr,              "893531
        lt_schedulesx   STABLE BY ebelp_key etenr_key,
        lt_accountings  STABLE BY ebelp zexkn,
        lt_accountingsx STABLE BY ebelp_key zekkn_key,
        lt_ekpv         STABLE BY ebelp, lt_ekpvx BY ebelp_key,
        lt_eipo         STABLE BY po_item,
        lt_comsrv       STABLE BY packno,
        lt_acc_tab      STABLE BY packno zekkn.


  CALL FUNCTION 'MEPO_DOC_PROCESS'
    EXPORTING
      im_ekko                      = l_ekko
      im_ekkox                     = l_ekkox
      im_eikp                      = ls_eikp
      im_aktyp                     = l_aktyp
      im_header_conditions_changed = l_header_conditions_changed
      im_calculation_type          = l_header_calculation_type
      im_bapi                      = for_bapi
      im_pohandler                 = for_pohandler
      im_me59n                     = for_me59n
      im_no_messaging              = no_messaging
      im_no_message_req            = no_message_req
      im_no_authority              = no_authority
      im_no_price_from_po          = no_price_from_po
    TABLES
      cht_items                    = lt_items
      imt_itemsx                   = lt_itemsx
      cht_schedules                = lt_schedules
      imt_schedulesx               = lt_schedulesx
      cht_conditions               = lt_komv
      cht_accountings              = lt_accountings
      imt_accountingsx             = lt_accountingsx
      cht_service_data             = lt_comsrv
      cht_service_accountings      = lt_acc_tab
      cht_ekpv                     = lt_ekpv
      imt_ekpvx                    = lt_ekpvx
      cht_eipo                     = lt_eipo
    EXCEPTIONS
      invalid_call                 = 1
      invalid_activity_type        = 2
      error_message                = 3
      OTHERS                       = 4.

*-----------------------------------------------------------------------
* Error Handling
*-----------------------------------------------------------------------
  IF sy-subrc <> 0.
*   For dump analysis temporarly store some information
    cl_mm_pur_po_dump_helper=>msgid = sy-msgid.
    cl_mm_pur_po_dump_helper=>msgno = sy-msgno.
    cl_mm_pur_po_dump_helper=>msgv1 = sy-msgv1.
    cl_mm_pur_po_dump_helper=>msgv2 = sy-msgv2.
    cl_mm_pur_po_dump_helper=>msgv3 = sy-msgv3.
    cl_mm_pur_po_dump_helper=>msgv4 = sy-msgv4.
    cl_mm_pur_po_dump_helper=>level = 'MEPO_DOC_PROCESS'.

    IF sy-subrc NE 1 AND sy-subrc NE 2.

      CALL METHOD cl_message_mm=>create
        EXPORTING
          im_msgid         = sy-msgid
          im_msgty         = sy-msgty
          im_msgno         = sy-msgno
          im_msgv1         = sy-msgv1
          im_msgv2         = sy-msgv2
          im_msgv3         = sy-msgv3
          im_msgv4         = sy-msgv4
          im_force_collect = mmpur_yes
        EXCEPTIONS
          failure          = 01
          dialog           = 02.

    ENDIF.
  ENDIF.

  CALL METHOD cl_message_handler_mm=>get_handler
    IMPORTING
      ex_handler = l_hd.
  CALL METHOD l_hd->cleanup.

* Deregistering Identity Manager
  CALL METHOD cl_identity_manager_mm=>unregister
    EXPORTING
      im_obj = me
    EXCEPTIONS
      OTHERS = 0.

* Abschlussarbeiten: Referenz Dienstleistung

  CALL METHOD copy_services( ).

ENDMETHOD.                    "


METHOD expand_from_requisitions .

  DATA: lt_models          TYPE mmpur_models,
        ls_model           LIKE LINE OF lt_models,
        l_evopa            TYPE t160v-evopa,
        l_t160v            TYPE t160v,
        l_item             TYPE REF TO cl_po_item_handle_mm,
        l_item_data        TYPE mepoitem,
        l_item_datax       TYPE mepoitemx,
        ls_requisition     LIKE LINE OF ch_requisitions,
        ls_headerx         TYPE mepoheaderx.

  CALL FUNCTION 'MEPO_DOC_INIT_CALL'
    EXPORTING
      im_header          = im_header
    CHANGING
      ch_requisitions    = ch_requisitions
      ch_req_accountings = ch_requisition_accountings
    EXCEPTIONS
      error_message      = 1
      OTHERS             = 2.

  IF sy-subrc NE 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 RAISING failure.
  ENDIF.

  GET PARAMETER ID 'EVO' FIELD l_evopa.
  SELECT SINGLE * FROM t160v INTO l_t160v WHERE evopa = l_evopa.

  IF state EQ c_new AND NOT im_header IS INITIAL.
    CALL METHOD me->get_datax
      IMPORTING
        ex_data = ls_headerx.
    CALL METHOD me->set_data
      EXPORTING
        im_data = im_header.
    CALL METHOD me->set_datax
      EXPORTING
        im_data = ls_headerx.

    ls_model-model ?= me.
    APPEND ls_model TO lt_models.
* items
    IF l_t160v-euezu NE space.
      LOOP AT ch_requisitions INTO ls_requisition.
        CREATE OBJECT l_item
              EXPORTING  im_po_item_number = 0
                         im_po_header = me
              EXCEPTIONS failure = 01.

        IF sy-subrc NE 0.
          MESSAGE a816(me) WITH 'expand_from_requisitions'.
        ENDIF.

        CALL METHOD l_item->get_data
          IMPORTING
            ex_data = l_item_data.
        CALL METHOD l_item->get_datax
          IMPORTING
            ex_data = l_item_datax.
        l_item_data-banfn = ls_requisition-banfn.
        l_item_data-bnfpo = ls_requisition-bnfpo.
        CALL METHOD l_item->set_data
          EXPORTING
            im_data = l_item_data.
        CALL METHOD l_item->set_datax
          EXPORTING
            im_data = l_item_datax.
        ls_model-model ?= l_item.
        APPEND ls_model TO lt_models.
      ENDLOOP.
    ENDIF.

* process models
    CALL METHOD me->if_flush_transport_mm~start( im_models = lt_models ).

  ENDIF.

ENDMETHOD.                    "expand_from_requisitions


METHOD copy_services.

  TYPES: BEGIN OF lty_todo,
           ebelp     TYPE ekpo-ebelp,
           model     TYPE REF TO if_model_mm,
           valid     TYPE mmpur_bool,
         END OF lty_todo.

  DATA: lt_copy_services   TYPE mmpur_t_valid_models,
        l_mepocomsrv       TYPE mepocomsrv,
        lt_acc_tab         TYPE mmpur_acc_tab,
        lt_todo            TYPE SORTED TABLE OF lty_todo
                                WITH UNIQUE KEY ebelp,
        ls_todo            LIKE LINE OF lt_todo,
        l_comsrv           TYPE comsrv,
        l_models           TYPE mmpur_models,
        l_models_entry     LIKE LINE OF l_models,
        l_item             TYPE REF TO cl_po_item_handle_mm.

  FIELD-SYMBOLS: <wa> LIKE LINE OF lt_copy_services.

  PERFORM get_copy_services IN PROGRAM saplmepo
           CHANGING lt_copy_services.
  CHECK NOT lt_copy_services IS INITIAL.

* note 806341: some kernels provide us with an arbitrary
* sequence in lt_copy_services. Therefore we sort according
* to ebelp.
  LOOP AT lt_copy_services ASSIGNING <wa> WHERE valid = ' '.
    mmpur_dynamic_cast l_item <wa>-model.
    CHECK NOT l_item IS INITIAL.
    ls_todo-ebelp = l_item->po_item_number.
    ls_todo-model = <wa>-model.
    ls_todo-valid = <wa>-valid.
    INSERT ls_todo INTO TABLE lt_todo.
  ENDLOOP.
  CHECK NOT lt_todo IS INITIAL.

  LOOP AT lt_todo INTO ls_todo.

    mmpur_dynamic_cast l_item ls_todo-model.

    READ TABLE lt_copy_services ASSIGNING <wa>
               WITH TABLE KEY model = ls_todo-model.
* end of note 806341


    CALL METHOD l_item->if_services_mm~get_data
      IMPORTING
        ex_comsrv  = l_mepocomsrv
        ex_acc_tab = lt_acc_tab
      EXCEPTIONS
        OTHERS     = 1.

    CHECK sy-subrc IS INITIAL.

    CHECK l_comsrv-packno IS INITIAL.

    <wa>-valid = 'X'.
    PERFORM set_copy_services IN PROGRAM saplmepo
              CHANGING lt_copy_services.


    MOVE-CORRESPONDING l_mepocomsrv TO l_comsrv.

    CALL FUNCTION 'MS_SERVICE_PACKAGE'
      EXPORTING
        comsrv         = l_comsrv
        dirty_kz       = l_mepocomsrv-dirty
        edit           = l_mepocomsrv-edit
        origin         = l_mepocomsrv-origin
        limitdef       = space
        without_screen = space
      IMPORTING
        comsrv         = l_comsrv
        dirty_package  = l_mepocomsrv-dirty_package
        empty_package  = l_mepocomsrv-empty_package
      TABLES
        acc_tab        = lt_acc_tab
      EXCEPTIONS
        OTHERS         = 2.
    IF sy-subrc EQ 0 AND l_mepocomsrv-empty_package EQ space.

      MOVE-CORRESPONDING l_comsrv TO l_mepocomsrv.
      CALL METHOD l_item->if_services_mm~set_data
        EXPORTING
          im_comsrv  = l_mepocomsrv
          im_acc_tab = lt_acc_tab.
      CLEAR l_models.
      l_models_entry-model ?= l_item.
      APPEND l_models_entry TO l_models.
      CALL METHOD me->flush_data( l_models ).
      EXIT.

    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD constructor.

  super->constructor( iv_address_handling_active = iv_address_handling_active
                      io_address_handler         = io_address_handler
                    ).
  mv_address_handling_active = iv_address_handling_active.
  po_number = im_po_number.

  me->mv_rtts_name = 'MEPOHEADER_DATA' ##NO_TEXT.           "1355577
ENDMETHOD.


METHOD class_constructor .

  CALL FUNCTION 'MEPOBADI_INITIALIZE'
    EXCEPTIONS
      error_message = 0.

ENDMETHOD.                    "


METHOD chp_register .

  DATA: l_handle       TYPE REF TO cl_handle_mm,
        ls_description TYPE mepo_objdesc,
        ls_badi_queue  LIKE LINE OF my_badi_queue.

  CALL METHOD super->chp_register
    EXPORTING
      im_action = im_action
      im_handle = im_handle.

*--------------------------------------------------------------------*
* BAdI
*--------------------------------------------------------------------*
  IF im_handle IS INITIAL.
    l_handle = me.
  ELSE.
    l_handle = im_handle.
  ENDIF.
  ls_description       = l_handle->if_message_obj_mm~describe( ).
  ls_badi_queue-varkey = ls_description-varkey.
  ls_badi_queue-handle = l_handle.
  INSERT ls_badi_queue INTO TABLE my_badi_queue.

ENDMETHOD.                    "


METHOD chp_refresh_hash_table.

  REFRESH chp_hash_table[].
  REFRESH po_header_chp_table[].

ENDMETHOD.                    "CHP_REFRESH_HASH_TABLE


METHOD chp_add_hash_entry.

  DATA: l_hash_entry LIKE LINE OF chp_hash_table.

  l_hash_entry-header = me.
  l_hash_entry-data  =  im_data.
  INSERT l_hash_entry INTO TABLE chp_hash_table.

ENDMETHOD.                    "


METHOD chp_add_changelist .

  DATA: ls_entry LIKE LINE OF po_header_chp_table.

  READ TABLE po_header_chp_table INTO ls_entry
      WITH TABLE KEY header = me.

  IF sy-subrc IS INITIAL.
    APPEND LINES OF im_changelist TO ls_entry-changelist.
    MODIFY TABLE po_header_chp_table FROM ls_entry.
  ELSE.
    ls_entry-header = me.
    ls_entry-changelist = im_changelist.
    INSERT ls_entry INTO TABLE po_header_chp_table.
  ENDIF.

ENDMETHOD.                    "CHP_ADD_CHANGELIST


METHOD check_proposer.

  DATA: fw TYPE REF TO cl_framework_mm,
        l_objecttype TYPE string40.

  CHECK my_header_proposer IS INITIAL.

  CALL METHOD cl_framework_mm=>get_instance IMPORTING ex_instance = fw.

  IF my_header_proposer IS INITIAL.
    l_objecttype = c_objtyp.
    my_header_proposer ?= fw->get_proposer( l_objecttype ).
  ENDIF.

ENDMETHOD.


METHOD CAN_INITIATE_FLUSH.

  EX_MODEL = ME.
ENDMETHOD.


METHOD ADD_ITEM.


  DATA: L_ITEM TYPE REF TO CL_PO_ITEM_HANDLE_MM,
        l_s_lookup_hash TYPE CL_HANDLE_MM=>type_s_lookup_hash. "1428972

  MMPUR_DYNAMIC_CAST L_ITEM IM_ITEM.
  if not l_item is initial.
    CALL METHOD SUPER->ADD_ITEM( L_ITEM ).
    if l_item->po_item_number is not initial.                  "1428972
      l_s_lookup_hash-ebeln = me->PO_NUMBER.
      l_s_lookup_hash-ebelp = l_item->po_item_number.
      l_s_lookup_hash-model = l_item.
      me->set_hash_entry( l_s_lookup_hash ).
    endif.
  else.
    raise failure.
  endif.
ENDMETHOD.


METHOD if_purchase_order_mm~get_previous_data .

  DATA: l_header LIKE LINE OF chp_hash_table.

  CLEAR ex_data.
  READ TABLE chp_hash_table INTO l_header WITH TABLE KEY header = me.
  IF sy-subrc IS INITIAL AND NOT l_header-data IS INITIAL.  "999401
    ex_data = l_header-data.
  ELSE.
    RAISE no_data.
  ENDIF.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~get_persistent_data .

  DATA: l_success TYPE mmpur_bool VALUE mmpur_no.

  PERFORM mepo_badi_header_get_pers_data IN PROGRAM saplmepo
                                               CHANGING ex_data
                                                        l_success.
  IF l_success EQ mmpur_no.
    RAISE no_data.
  ENDIF.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~get_items .

  DATA: lt_items    TYPE mmpur_models,
        ls_item     LIKE LINE OF lt_items,
        ls_item_new LIKE LINE OF re_items.

  CALL METHOD get_items
    IMPORTING
      ex_items = lt_items.
  LOOP AT lt_items INTO ls_item.
    ls_item_new-item ?= ls_item-model.
    APPEND ls_item_new TO re_items.
  ENDLOOP.

ENDMETHOD.                    "


METHOD if_purchase_order_mm~get_foreign_trade .

  DATA: wa LIKE LINE OF po_eikp_hash_table.

  READ TABLE po_eikp_hash_table INTO wa WITH TABLE KEY header = me.
  IF sy-subrc IS INITIAL.
    re_data = wa-data.
  ELSE.
    PERFORM get_mepo_eikp IN PROGRAM saplmepo CHANGING re_data.
  ENDIF.

ENDMETHOD.                    "IF_PURCHASE_ORDER_MM~GET_FOREIGN_TRADE


METHOD if_purchase_order_mm~get_data .

  me->get_data( IMPORTING ex_data = re_data ).

ENDMETHOD.                    "


METHOD if_purchase_order_mm~get_confirmation_handle.
  re_handle = me->my_confirmation_handle.
ENDMETHOD.


METHOD if_purchase_order_mm~get_conditions .

  DATA: ls_cond_entry TYPE komv,
        l_kposn       TYPE komv-kposn.

  CLEAR ex_conditions.

  READ TABLE po_tkomv_hash_table WITH KEY kposn = l_kposn BINARY SEARCH
             TRANSPORTING NO FIELDS.
  IF sy-subrc IS INITIAL.
    LOOP AT po_tkomv_hash_table INTO ls_cond_entry FROM sy-tabix.
      IF ls_cond_entry-kposn NE l_kposn.
        EXIT.
      ENDIF.
      APPEND ls_cond_entry TO ex_conditions.
    ENDLOOP.
  ELSE.
    PERFORM mepo_badi_get_conditions IN PROGRAM saplmepo
                                USING    l_kposn
                                CHANGING ex_conditions.
  ENDIF.

ENDMETHOD.                    "IF_PURCHASE_ORDER_MM~GET_CONDITIONS


METHOD if_purchase_order_mm~create_item .

  DATA(lr_item) = NEW cl_po_item_handle_mm(  im_po_item_number = im_ebelp
                                             im_po_header = me
                                             iv_address_handling_active = iv_address_handling_active
                                             io_address_handler = io_address_handler
                                           ).
  IF NOT lr_item IS BOUND. RETURN. ENDIF.
  lr_item->set_data( im_data = VALUE #( id = id ebeln = po_number ebelp = im_ebelp ) ).

  DATA(lr_model) = CAST if_model_mm( me ).
  IF NOT line_exists( me->my_recheck_queue[ model = lr_model ] ).
    APPEND VALUE #( model = lr_model ) TO me->my_recheck_queue.
  ENDIF.

  re_item = lr_item.


ENDMETHOD.                    "


METHOD if_partners_mm~set_data.
* set partner
  my_partners = im_mmpa.
* further parameters are not considered.
ENDMETHOD.


METHOD if_partners_mm~get_data.
* extract attribute my_partners
  ex_mmpa = my_partners.

ENDMETHOD.


METHOD if_output_mm~preview.

  DATA l_ekko  TYPE mepoheader.
*--------------------------------------------------------------------*
*  erst die eigene Konsistenz sicherstellen
*--------------------------------------------------------------------*
  CALL METHOD get_data( IMPORTING ex_data = l_ekko ).

  cl_identity_manager_mm=>register( EXPORTING im_obj = me ).

*--------------------------------------------------------------------*
* FB aufrufen für Preview
*--------------------------------------------------------------------*
  PERFORM:
   lesen_nachrichten         IN PROGRAM saplmepo, "wegen Ändern->Anzeigen
   nachricht_erzeugen        IN PROGRAM saplmepo USING space,
   delivery_addr_numbers_get IN PROGRAM saplmepo.
  l_ekko-ebeln = po_number.
  PERFORM display_purchase_document
     IN PROGRAM saplmedruck
     USING l_ekko-ebeln l_ekko-bstyp 'X'.                   "855263
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  CALL METHOD cl_identity_manager_mm=>unregister
    EXPORTING
      im_obj = me
    EXCEPTIONS
      OTHERS = 0.

ENDMETHOD.


METHOD if_output_mm~overview.

* ...
  DATA: l_mepoheader TYPE mepoheader,
        l_ekko       TYPE ekko,
        l_trtyp      TYPE t160-trtyp,
        l_aktyp      TYPE char1,                            "#EC *
        l_tcode      TYPE sy-tcode,
        l_updat      TYPE c LENGTH 1.
*--------------------------------------------------------------------*
*  erst die eigene Konsistenz sicherstellen
*--------------------------------------------------------------------*
  CALL METHOD get_data( IMPORTING ex_data = l_mepoheader ).
  MOVE-CORRESPONDING l_mepoheader TO l_ekko.                "#EC *
  me->get_transaction_state( IMPORTING ex_trtyp = l_trtyp
                                       ex_aktyp = l_aktyp
                                       ex_tcode = l_tcode ).

  cl_identity_manager_mm=>register( EXPORTING im_obj = me ).

*--------------------------------------------------------------------*
* Schnittstelle für Nachrichtenpopup aufrufen
*--------------------------------------------------------------------*
  PERFORM:
     lesen_nachrichten  IN PROGRAM saplmepo, "wegen Ändern->Anzeigen
     nachricht_erzeugen IN PROGRAM saplmepo USING space.    "457872
  l_ekko-ebeln = po_number.                                 "317351
  CALL FUNCTION 'ME_MESSAGES_MAINTAIN'
    EXPORTING
      ix_b_object  = 'BUS2012'
      ix_nachrappl = 'EF'
      ix_trtyp     = l_trtyp
      ix_vorga     = 'F'
      ix_ekko      = l_ekko
      ix_preview   = space
    IMPORTING
      ex_updat     = l_updat
      ex_fcode     = l_tcode.
  re_tcode = l_tcode.
  IF NOT l_updat IS INITIAL.                                " 394245
    l_updat = 'Y'.                                          " 394245
  ENDIF.                                                    " 394245
  PERFORM:
    mepo_set_vbupdkz       IN PROGRAM saplmepo
                                USING l_updat 'Y',          "394245
    mepo_nachricht_pruefen IN PROGRAM saplmepo.

  cl_identity_manager_mm=>unregister( EXPORTING  im_obj = me
                                      EXCEPTIONS OTHERS = 0 ).

ENDMETHOD.                    "IF_OUTPUT_MM~OVERVIEW


METHOD if_observer_mm~handle_subject_changed.

  DATA: lt_changelist     TYPE mmchp_chp_list,
        l_list_entry      LIKE LINE OF lt_changelist.

  CHECK:
    state        EQ c_new,
    sender       EQ my_header_proposer,
    changelist[] IS NOT INITIAL.

  LOOP AT changelist INTO l_list_entry.
    l_list_entry-model = me.
    INSERT l_list_entry INTO TABLE lt_changelist.
  ENDLOOP.

* update sapmm06e, table T161 for field selection purposes
  CALL METHOD po_prepare_creation
    EXCEPTIONS
      OTHERS = 0.

* synchronize observers (frontend)
  RAISE EVENT if_subject_mm~changed
                       EXPORTING changelist = lt_changelist.

ENDMETHOD.


METHOD IF_MESSAGE_OBJ_MM~DESCRIBE.

  RE_DESCRIPTION = SUPER->IF_MESSAGE_OBJ_MM~DESCRIBE( ).

  RE_DESCRIPTION-OBJTYP = C_OBJTYP.
  RE_DESCRIPTION-VARKEY+0(10) = PO_NUMBER.

ENDMETHOD.


METHOD if_longtexts_mm~set_text.
  DATA: l_ebelp TYPE ekpo-ebelp.
  PERFORM text_set_lines IN PROGRAM saplmepo USING l_ebelp
                                                   im_tdid
                                                   im_textlines.

ENDMETHOD.


METHOD if_longtexts_mm~get_types.
  DATA: l_ebelp TYPE ekpo-ebelp.
  PERFORM text_get_types IN PROGRAM saplmepo USING    l_ebelp
                                             CHANGING ex_texttypes.

ENDMETHOD.


METHOD if_longtexts_mm~get_textobject.

  ex_tdobject = 'EKKO'.
  ex_metafield = mmmfd_header_text.

ENDMETHOD.


METHOD if_longtexts_mm~get_text.
  DATA: l_ebelp TYPE ekpo-ebelp.
  PERFORM text_get_lines IN PROGRAM saplmepo USING     l_ebelp
                                                       im_tdid im_texttype"917290
                                              CHANGING ex_textlines
                                                       ex_text_formatted.
ENDMETHOD.


method IF_LONGTEXTS_MM~GET_MULTIPLE_TEXTS.
* empty implementation because of checkman
endmethod.


METHOD if_longtexts_mm~edit_text.
  DATA: l_tdobject TYPE tdobject,
        l_ebelp    TYPE ekpo-ebelp.

  CALL METHOD me->if_longtexts_mm~get_textobject
    IMPORTING
      ex_tdobject = l_tdobject.

  PERFORM edit_text IN PROGRAM saplmepo
                              USING l_tdobject
                                    im_tdid
                                    l_ebelp.

ENDMETHOD.


METHOD if_longtexts_mm~delete_text.

  DATA: l_tdobject TYPE tdobject,
        l_ucomm TYPE syucomm,
        l_ebelp TYPE ekpo-ebelp.

  CALL METHOD me->if_longtexts_mm~get_textobject
    IMPORTING
      ex_tdobject = l_tdobject.
  l_ucomm = 'TERE'.
  PERFORM copy_or_delete_text IN PROGRAM saplmepo
                                        USING l_tdobject
                                              im_tdid
                                              l_ebelp
                                              l_ucomm.

ENDMETHOD.


METHOD if_longtexts_mm~adopt_text.

  DATA: l_tdobject TYPE tdobject,
        l_ucomm    TYPE syucomm,
        l_ebelp    TYPE ekpo-ebelp.

  CALL METHOD me->if_longtexts_mm~get_textobject
    IMPORTING
      ex_tdobject = l_tdobject.
  l_ucomm = 'TECO'.
  PERFORM copy_or_delete_text IN PROGRAM saplmepo
                                            USING l_tdobject
                                                  im_tdid
                                                  l_ebelp
                                                  l_ucomm.
ENDMETHOD.


METHOD if_flush_transport_mm~start .

  DATA: l_trtyp           TYPE trtyp,
        l_recheck_queue   LIKE my_recheck_queue,
        l_collect_handles LIKE my_recheck_queue,
        l_msg_handler     TYPE REF TO cl_message_handler_mm, "#EC NEEDED
        l_header          TYPE REF TO if_purchase_order_mm,
        l_item            TYPE REF TO if_purchase_order_item_mm,
        l_item_handle     TYPE REF TO cl_po_item_handle_mm,
        l_schedule        TYPE REF TO if_purchase_order_schedule_mm,
        l_account         TYPE REF TO if_purchase_order_account_mm,
        l_dummy           TYPE c LENGTH 128,                "#EC *
        l_rc              TYPE sy-subrc.

  FIELD-SYMBOLS: <queue> LIKE LINE OF my_badi_queue.

  CLEAR: my_badi_queue, my_recheck_queue.

  ADD 1 TO my_iteration_count.

* Step 1: execute standard business logic
  CALL METHOD super->if_flush_transport_mm~start
    EXPORTING
      im_models    = im_models
    EXCEPTIONS
      illegal_call = 1
      error        = 2.

  IF NOT sy-subrc IS INITIAL.
    SUBTRACT 1 FROM my_iteration_count.
    CASE sy-subrc.
      WHEN 1. RAISE illegal_call.
      WHEN 2. RAISE error.
    ENDCASE.
  ENDIF.

* Step 2: execute extensions from IBS or Add-Ons
  CALL METHOD me->get_transaction_state
    IMPORTING
      ex_trtyp = l_trtyp.
  IF NOT my_badi_queue IS INITIAL AND
     l_trtyp NE 'A' AND
     my_iteration_count LT 10.
* in cases where the iteration count becomes higher that 10
* we stop here

    CLEAR my_recheck_queue.                                 "EhP4 OM

    LOOP AT my_badi_queue ASSIGNING <queue>.
* header
      mmpur_dynamic_cast l_header <queue>-handle.
      IF NOT l_header IS INITIAL.
        CALL FUNCTION 'MEPOBADI_PROCESS_HEADER'
          EXPORTING
            im_header     = l_header
            im_count      = my_iteration_count
          EXCEPTIONS
            error_message = 1
            error         = 1
            OTHERS        = 2.
        l_rc = sy-subrc.
        IF NOT l_rc IS INITIAL.
          CALL METHOD l_header->invalidate( ).
        ENDIF.
      ENDIF.
*item
      mmpur_dynamic_cast l_item <queue>-handle.
      IF NOT l_item IS INITIAL.
        CALL FUNCTION 'MEPOBADI_PROCESS_ITEM'
          EXPORTING
            im_item       = l_item
            im_count      = my_iteration_count
          EXCEPTIONS
            error_message = 1
            error         = 1
            OTHERS        = 2.
        l_rc = sy-subrc.
        IF NOT l_rc IS INITIAL.
          CALL METHOD l_item->invalidate( ).
        ENDIF.
* remove reference from the item table
        mmpur_dynamic_cast l_item_handle l_item.
        IF NOT l_item_handle IS INITIAL.                    "2502803
          PERFORM mepo_badi_item_removeref IN PROGRAM saplmepo
                                        USING l_item_handle->po_item_number.
        ENDIF.
      ENDIF.
* schedule
      mmpur_dynamic_cast l_schedule <queue>-handle.
      IF NOT l_schedule IS INITIAL.
        CALL FUNCTION 'MEPOBADI_PROCESS_SCHEDULE'
          EXPORTING
            im_schedule   = l_schedule
            im_count      = my_iteration_count
          EXCEPTIONS
            error_message = 1
            error         = 1
            OTHERS        = 2.
        l_rc = sy-subrc.
        IF NOT l_rc IS INITIAL.
          CALL METHOD l_schedule->invalidate( ).
        ENDIF.
      ENDIF.
* accounting
      mmpur_dynamic_cast l_account <queue>-handle.
      IF NOT l_account IS INITIAL.
        CALL FUNCTION 'MEPOBADI_PROCESS_ACCOUNT'
          EXPORTING
            im_account    = l_account
            im_count      = my_iteration_count
          EXCEPTIONS
            error_message = 1
            error         = 1
            OTHERS        = 2.
        l_rc = sy-subrc.
        IF NOT l_rc IS INITIAL.
          CALL METHOD l_account->invalidate( ).
        ENDIF.
      ENDIF.

      IF NOT l_rc IS INITIAL.
        CALL METHOD cl_message_mm=>create
          EXPORTING
            im_msgid         = sy-msgid
            im_msgty         = sy-msgty
            im_msgno         = sy-msgno
            im_msgv1         = sy-msgv1
            im_msgv2         = sy-msgv2
            im_msgv3         = sy-msgv3
            im_msgv4         = sy-msgv4
            im_force_collect = mmpur_yes
          EXCEPTIONS
            OTHERS           = 0.
      ENDIF.

    ENDLOOP.

    my_ibs_firewall_on = my_cust_firewall_on = mmpur_no.

  ELSEIF my_iteration_count GE 10.

* we have to stop here and throw an error
    me->if_purchase_order_mm~invalidate( ).
    CLEAR: my_badi_queue, my_recheck_queue.
* initialization message handling
    cl_message_mm=>set_current_business_obj( im_business_obj = me ).
    cl_message_mm=>set_current_context( im_context = 5 ).
    cl_contextfield_mm=>set_current_field( 0 ).
* message handling
    MESSAGE e151(mepo) INTO l_dummy.
    cl_message_mm=>create( EXPORTING    im_msgid         = sy-msgid
                                        im_msgty         = sy-msgty
                                        im_msgno         = sy-msgno
                                        im_msgv1         = sy-msgv1
                                        im_msgv2         = sy-msgv2
                                        im_msgv3         = sy-msgv3
                                        im_msgv4         = sy-msgv4
                                        im_force_collect = mmpur_yes
                           EXCEPTIONS   OTHERS           = 0 ).

  ENDIF.

* Step 3: Recheck if the extension changed any business object
  IF NOT my_recheck_queue IS INITIAL.

    cl_mm_pur_po_atp_bulk_factory=>get_instance( )->set_collect_result_indicator( abap_false ).

    l_recheck_queue = my_recheck_queue.
    CALL METHOD me->if_flush_transport_mm~start
      EXPORTING
        im_models    = l_recheck_queue
      EXCEPTIONS
        illegal_call = 1
        error        = 2.

    IF NOT sy-subrc IS INITIAL.
      SUBTRACT 1 FROM my_iteration_count.
      CASE sy-subrc.
        WHEN 1. RAISE illegal_call.
        WHEN 2. RAISE error.
      ENDCASE.
    ENDIF.

  ELSE.
*   should be only executed for enabled channels (eg. BAPI)
    IF cl_mm_pur_po_atp_bulk_proc=>if_mm_pur_po_atp_bulk_proc~is_atp_bulk_processing_enabled( ) = abap_true.
      DATA(lo_atp_bulk) = cl_mm_pur_po_atp_bulk_factory=>get_instance( ).
      IF lo_atp_bulk IS BOUND.
*       The result of the ATP bulk call has to be collected and processed in an additional round trip over the business logic.
*       This is triggered here by checking if the my_recheck_queue is empty. If so, we add all schedule handles to the my_recheck_queue
*       In this additional roundtrip there should be no bulk call of the ATP anymore but only the postprocessing of the ATP results.
*       This is controlled by an indicator which is set to ABAP_TRUE in ->set_collect_result_indicator( abap_true )
*       This should be done only once, so in the next roundtrip we check if this indicator is abap_true. If so, processing is done and iteration is stopped.
        IF lo_atp_bulk->are_result_tables_filled( ) = abap_true.
          IF lo_atp_bulk->get_collect_result_indicator( ) = abap_false.
            CLEAR l_item_handle.
*           set indicator for executing ATP bulk post-processing logic
            lo_atp_bulk->set_collect_result_indicator( abap_true ).
            IF my_items IS NOT INITIAL.
              LOOP AT my_items ASSIGNING FIELD-SYMBOL(<lf_item_handle>).
                mmpur_dynamic_cast l_item_handle <lf_item_handle>-model.
                l_item_handle->get_po_schedules( IMPORTING ex_schedules = DATA(lt_schedules) ).
                APPEND LINES OF lt_schedules TO l_collect_handles.
                CLEAR lt_schedules.
              ENDLOOP.
              CLEAR l_recheck_queue.
              l_recheck_queue = l_collect_handles.
              CALL METHOD me->if_flush_transport_mm~start
                EXPORTING
                  im_models    = l_recheck_queue
                EXCEPTIONS
                  illegal_call = 1
                  error        = 2.
              IF NOT sy-subrc IS INITIAL.
                SUBTRACT 1 FROM my_iteration_count.
                CASE sy-subrc.
                  WHEN 1. RAISE illegal_call.
                  WHEN 2. RAISE error.
                ENDCASE.
              ENDIF.
            ENDIF.
          ELSE.
            lo_atp_bulk->set_collect_result_indicator( abap_false ).
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  SUBTRACT 1 FROM my_iteration_count.

  IF my_iteration_count IS INITIAL.                         "946284
    PERFORM mepo_protected_reset IN PROGRAM saplmepo.
  ENDIF.

ENDMETHOD.


METHOD if_fieldselection_mm~fs_get.

  DATA: l_item      TYPE ekpo-ebelp,
        l_schedule  TYPE eket-etenr,
        l_requester LIKE im_requested_type,
        l_sender    LIKE im_sender.

  IF NOT im_requested_type IS INITIAL.
    l_requester = im_requested_type.
  ELSE.
    l_requester = c_objtyp.
  ENDIF.
  IF NOT im_sender IS INITIAL.
    l_sender = im_sender.
  ELSE.
    l_sender = me.
  ENDIF.


  PERFORM field_selection IN PROGRAM saplmepo
                 USING    l_item
                          l_schedule
                          l_requester
                          l_sender
                          im_initiator
                 CHANGING ch_fieldselection.
* DIMP IS MILL ENHANCEMENTS FOR FDE
  PERFORM field_selection_mill IN PROGRAM saplmegui  " FOR HIDING/UNHIDING MILL FIELD AND BUTTONS
                 USING    l_item
                          l_schedule
                          l_requester
                          l_sender
                          im_initiator
                 CHANGING ch_fieldselection.
* DIMP IS MILL ENHANCEMENTS FOR FDE

  CALL FUNCTION 'MEPOBADI_FS_HEADER'
    EXPORTING
      im_header         = me
    CHANGING
      ch_fieldselection = ch_fieldselection
    EXCEPTIONS
      error_message     = 0.

ENDMETHOD.                    "


method IF_DCM_ADAPTER~SET_CHANGED .

  data: l_adapter type ref to if_dcm_adapter.

  CALL FUNCTION 'MEPO_DOC_DCM_MANAGER_GET'
    IMPORTING
      EX_ADAPTER       = l_adapter.

  check not l_adapter is initial.

  call method l_adapter->set_changed.

endmethod.


method IF_DCM_ADAPTER~IS_UNCOMPLETE_VERSION_ALLOWED .
*new with dcm
  data: l_adapter type ref to if_dcm_adapter.

  CALL FUNCTION 'MEPO_DOC_DCM_MANAGER_GET'
    IMPORTING
      EX_ADAPTER       = l_adapter.

  if not l_adapter is initial.
    re_bool = l_adapter->IS_uncomplete_VERSION_ALLOWED( ).
  else.
    re_bool = mmpur_no.
  endif.

endmethod.


method IF_DCM_ADAPTER~IS_NEW_VERSION_ALLOWED .

  data: l_adapter type ref to if_dcm_adapter.

  CALL FUNCTION 'MEPO_DOC_DCM_MANAGER_GET'
    IMPORTING
      EX_ADAPTER       = l_adapter.

  if not l_adapter is initial.

    re_bool = l_adapter->IS_NEW_VERSION_ALLOWED( ).

  else.

    re_bool = mmpur_no.

  endif.

endmethod.


method IF_DCM_ADAPTER~IS_DELETION_ALLOWED .
* check if the actual version can be deleted

data: l_adapter type ref to if_dcm_adapter.

  CALL FUNCTION 'MEPO_DOC_DCM_MANAGER_GET'
    IMPORTING
      EX_ADAPTER       = l_adapter.

  if not l_adapter is initial.

    re_bool = l_adapter->IS_deletion_ALLOWED( ).

  else.

    re_bool = mmpur_no.

  endif.

endmethod.


  METHOD disable_interactive_mode.

    set_interactive_mode( iv_interactive_mode = abap_false ).

  ENDMETHOD.


  METHOD enable_interactive_mode.

    set_interactive_mode( iv_interactive_mode = abap_true ).

  ENDMETHOD.


  METHOD if_releasable_mm~set_requester_comments.
  ENDMETHOD.


  METHOD is_interactive_mode_active.

    iv_active = get_interactive_mode( ).

  ENDMETHOD.
ENDCLASS.