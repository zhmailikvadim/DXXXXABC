class CL_FPM_FLOORPLAN_ASSIST definition
  public
  inheriting from CL_WD_COMPONENT_ASSISTANCE
  abstract
  create public .

public section.

  types:
    BEGIN OF  s_change_flags,
        hcp_changed            TYPE wdy_boolean,
        toolbar_changed        TYPE wdy_boolean,
        rop_changed            TYPE wdy_boolean,
        dt_mode_changed        TYPE wdy_boolean,
        uibb_container_changed TYPE wdy_boolean,
      END OF s_change_flags .
  types:
    BEGIN OF s_navigation_step,
        source_plug_name          TYPE string,
        target_component_name     TYPE string,
        target_component_usage    TYPE string,
        target_view_name          TYPE string,
        target_embedding_position TYPE string,
        usage                     TYPE REF TO if_wd_component_usage,
      END OF s_navigation_step .
  types:
    t_navigation_step TYPE STANDARD TABLE OF s_navigation_step WITH NON-UNIQUE DEFAULT KEY .
  types:
    BEGIN OF s_uibb_hier,
        parent_component       TYPE fpm_component_name,
        parent_interface_view  TYPE fpm_view_name,
        parent_config_key      TYPE wdy_config_key,
        parent_instance_id     TYPE fpm_instance_id,
        child_component        TYPE fpm_component_name,
        child_interface_view   TYPE fpm_view_name,
        child_config_key       TYPE wdy_config_key,
        child_instance_id      TYPE fpm_instance_id,
        child_needs_stretching TYPE fpm_needs_stretching,
        within_current_event   TYPE abap_bool,
      END OF s_uibb_hier .
  types:
    BEGIN OF ty_s_view_navigation_steps,
        view_controller   TYPE REF TO if_wd_view_controller,
        source_usage_name TYPE string,
        navigation_steps  TYPE t_navigation_step,
      END OF ty_s_view_navigation_steps .
  types:
    ty_t_view_navigation_steps TYPE STANDARD TABLE OF ty_s_view_navigation_steps
                                            WITH NON-UNIQUE DEFAULT KEY .
  types:
    BEGIN OF t_dialog_component_usage,
        usage_level      TYPE string,
        component_usage  TYPE REF TO if_wd_component_usage,
        window           TYPE REF TO if_wd_window,
        dialog_window_id TYPE fpm_dialog_window_id,
      END OF t_dialog_component_usage .
  types:
    t_uibb_hier TYPE STANDARD TABLE OF s_uibb_hier .

  data MO_ADAPTATION_MANAGER type ref to CL_FPM_ADAPT_MANAGER .
  data MO_COMPONENT type ref to IF_WD_COMPONENT .
  data MO_FEEDLET_CONNECTOR type ref to CL_FPM_FEEDLET_CONNECTOR .
  data MO_FLOORPLAN_DATA type ref to CL_FPM_CONTEXT_MANAGER .
  data MO_FPM type ref to CL_FPM read-only .
  data MO_MESSAGE_MANAGER type ref to IWCI_FPM_MESSAGE_MANAGER .
  data MS_CHANGE_FLAGS_ROUNDTRIP type S_CHANGE_FLAGS .
  data:
    mt_dialog_component_usages TYPE STANDARD TABLE OF t_dialog_component_usage .
  data MT_VIEW_NAVIGATION_STEPS type TY_T_VIEW_NAVIGATION_STEPS .
  data MV_CONTROL_PARAMETERS_FINAL type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data MV_HIDE_CLOSE_BUTTON type WDY_BOOLEAN .
  data MV_HIDE_MESSAGE_AREA type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data MV_INIT_VIEW_COUNTER type I value 0 ##NO_TEXT.
  data MV_IS_MULTI_STRETCHED type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data MV_LOGOFF_ON_CLOSE type FPM_LOGOFF_ON_CLOSE .
  data MV_MAXIMUM_MESSAGES_SIZE type I .
  data MV_MESSAGE_AREA_DESIGN type FPM_MESSAGE_AREA_DESIGN .
  data MV_NEEDS_TERMINATION type WDY_BOOLEAN read-only value ABAP_FALSE ##NO_TEXT.
  data MV_SHOW_MESSAGE_LOG type ABAP_BOOL value ABAP_FALSE ##NO_TEXT.
  data MV_TOOLBAR_LOCATION_TYPE type FPM_TOOLBAR_LOCATION_TYPE value 'G' ##NO_TEXT.

  events SPECIAL_WDA_EVENT
    exporting
      value(WDA_EVENT) type STRING
      value(FPM) type ref to IF_FPM .

  methods KEEP_MESSAGES
    importing
      !IO_ACTION type ref to IF_WD_ACTION .
  methods ADD_WINDOW_TO_STACK
    importing
      !IO_WINDOW type ref to IF_WD_WINDOW .
  methods ADJUST_CONTAINER_LAYOUT
    importing
      !IO_VIEW type ref to IF_WD_VIEW .
  methods CHECK_IF_CLOSE_AVAILABLE
    returning
      value(RV_CLOSE_SUPPORTED) type ABAP_BOOL .
  methods CLEAR_COMPOSITE_SLOTS .
  methods CLOSE_APPLICATION
    importing
      !IO_WD_ACTION type ref to IF_WD_ACTION optional .
  methods CLOSE_DIALOG
    importing
      !IO_EVENT type ref to CL_FPM_EVENT
      !IV_EVENT_FAILED type BOOLE_D
      !IO_WD_API type ref to IF_WD_COMPONENT
    changing
      !CV_CURRENT_DIALOG_WINDOW_LEVEL type I
      !CV_CURRENT_DIALOG_WINDOW_ID type FPM_DIALOG_WINDOW_ID .
  methods CLOSE_DIALOG_INTERNAL
    importing
      !IV_ACTION_ID type STRING
      !IV_ACTION_TYPE type FPM_ACTION_TYPE default IF_FPM_CONSTANTS=>GC_ACTION_TYPE-STANDARD
      !IV_CURRENT_DIALOG_WINDOW_ID type FPM_DIALOG_WINDOW_ID .
  methods CREATE_SUPPORT_MESSAGE .
  methods EXIT_SIDE_PANEL
    importing
      !IO_VIEW_CONTROLLER type ref to IF_WD_VIEW_CONTROLLER .
  methods FORWARD_WDEVENT_FLP_NAVIGATION
    importing
      !IO_WD_EVENT type ref to CL_WD_CUSTOM_EVENT .
  methods GET_ACTIVE_WINDOW
    returning
      value(RO_WINDOW) type ref to IF_WD_WINDOW .
  methods GET_COMPOSITE_UIBBS
    importing
      !IO_EVENT type ref to CL_FPM_EVENT
      !IV_COLLAPSED_UIBB_PROC_MODE type FPM_COLLAPSED_UIBB_PROC_MODE optional
    exporting
      !RV_IS_STRETCHED type BOOLE_D
    changing
      !CT_UIBB type FPM_T_UIBB_KEY .
  methods GET_EMBEDMENT_LEVEL
    importing
      !IS_UIBB_ID type FPM_S_UIBB_ID
    returning
      value(RV_LEVEL) type I .
  methods GET_FLOORPLAN_TEXTS
    importing
      !IV_TEXT_ID type STRING
    returning
      value(R_TEXT) type STRING .
  methods GET_HIDE_MESSAGE_AREA
    returning
      value(RV_HIDE_MESSAGE_AREA) type ABAP_BOOL .
  methods GET_MSG_AREA_SETTINGS
    importing
      !IO_FPM_NODE_ROOT type ref to IF_FPM_NODE
    exporting
      !EV_MAXIMUM_MESSAGES_SIZE type I
      !EV_SHOW_MESSAGE_LOG type WDY_BOOLEAN
      !EV_DISPLAY_EMPTY_LINES type WDY_BOOLEAN
      !EV_MESSAGE_AREA_DESIGN type FPM_MESSAGE_AREA_DESIGN
      !EV_MESSAGE_AREA_DISPLAY type FPM_MESSAGE_AREA_DISPLAY
      !EV_CONDENSE_IDENTICAL_MSG type FPM_CONDENSE_IDENTICAL_MSG .
  methods GET_PARENT_OF_EVENT_SRC_UIBB
    importing
      !IO_EVENT type ref to CL_FPM_EVENT
      !IT_UIBB type ANY TABLE
      !IV_IN_CURRENT_EVENT_LOOP_ONLY type ABAP_BOOL default ABAP_TRUE
    exporting
      !EV_PARENT_UIBB_FOUND type ABAP_BOOL
      !ES_PARENT_UIBB_KEY type CL_FPM_EVENT=>TY_S_UIBB_KEY
      !EV_PARENT_UIBB_DEF_DETL_PAGE type FPM_DEFAULT_DETAILS_PAGE
      !EV_PARENT_UIBB_DEF_EDIT_PAGE type FPM_DEFAULT_EDIT_PAGE .
  methods GET_TRANSIENT_STATE
    returning
      value(RV_TRANSIENT_STATE) type FPM_TRANSIENT_STATE .
  methods GET_UI_GUIDELINE_VERSION
    returning
      value(RV_UI_GUIDELINE_VERSION) type FPM_GUIDELINE_VERSION .
  methods HANDLE_APP_PARAMS .
  methods HANDLE_ERROR
    importing
      !IV_MSGID type SYMSGID
      !IV_MSGNO type SYMSGNO .
  methods HANDLE_URL_PARAMS
    importing
      !IO_EVENT type ref to CL_WD_CUSTOM_EVENT .
  methods INITIALIZE_ADAPTATION_HANDLING
    importing
      !IO_USAGE type ref to IF_WD_COMPONENT_USAGE
      !IO_CONTEXT type ref to IF_WD_CONTEXT_NODE
      !IO_COMPONENT type ref to IF_WD_COMPONENT .
  methods INITIALIZE_FEEDLET_CONNECTOR .
  methods INITIALIZE_FLOORPLAN
    importing
      !IO_FLOORPLAN_COMPONENT type ref to IF_WD_COMPONENT
      !IO_FLOORPLAN_COMP_CONTROLLER type ref to OBJECT
      !IO_IDR_COMPONENT_USAGE type ref to IF_WD_COMPONENT_USAGE optional
    exporting
      !EO_FPM type ref to CL_FPM
      !EO_FPM_FLOORPLAN_RUNTIME_API type ref to OBJECT
      !EO_FPM_RUNTIME_INFO_OBJECT type ref to OBJECT
      !EO_APP_CC_USAGE type ref to IF_WD_COMPONENT_USAGE
      !EO_EMPTY_COMPONENT_USAGE_GROUP type ref to IF_WD_COMPONENT_USAGE_GROUP
      !ES_IDR_UIBB_KEY_ADAPTED type FPM_S_UIBB_KEY
      !EV_IS_VALID_CONFIGURATION type ABAP_BOOL .
  methods INITIALIZE_INSTANCE_STYLING .
  methods INIT_SIDE_PANEL
    importing
      !IO_VIEW_CONTROLLER type ref to IF_WD_VIEW_CONTROLLER
      !IV_PORTAL_EVENT_ACTION type STRING default 'PORTAL_EVENT_CANVAS' .
  methods IS_FOOTER_NOTIF_ICON_REQUIRED
    importing
      !IO_FOOTER_TOOLBAR type ref to CL_WD_TOOLBAR
    returning
      value(RV_RESULT) type ABAP_BOOL .
  methods IS_FOOTER_TOOLBAR_REQUIRED
    returning
      value(RV_RESULT) type ABAP_BOOL .
  methods IS_HEADER_NOTIF_ICON_REQUIRED
    importing
      !IO_PAGE_HEADER type ref to CL_WD_PAGE_HEADER
      !IO_VIEW type ref to IF_WD_VIEW optional
      !IV_FLOORPLAN_STATE type FPM_FLOORPLAN_STATE optional
      !IV_TITLE_HIDDEN type ABAP_BOOL default ABAP_FALSE
    returning
      value(RV_RESULT) type ABAP_BOOL .
  methods IS_HEADER_TOOLBAR_REQUIRED
    returning
      value(RV_RESULT) type ABAP_BOOL .
  methods IS_PRINT_ENABLED
    returning
      value(RV_PRINT_ENABLED) type ABAP_BOOL .
  methods LAUNCH_APP_HIERARCHY_BROWSER .
  methods LAUNCH_CONFIGURATION_EDITOR
    importing
      !IO_WD_CONTEXT_ELEMENT type ref to IF_WD_CONTEXT_ELEMENT optional .
  methods MESSAGE_NAVIGATION
    importing
      !IO_WDEVENT type ref to CL_WD_CUSTOM_EVENT .
  methods MODIFY_COMPOSITE_VIEW_ASSEMBLY
    importing
      !IO_EVENT type ref to CL_FPM_EVENT
      !IV_EVENT_FAILED type BOOLE_D .
  methods NAVIGATE
    importing
      !IO_VIEW_CONTROLLER_API type ref to IF_WD_VIEW_CONTROLLER
      !IV_SOURCE_USAGE_NAME type STRING
      !IV_SOURCE_WINDOW_NAME type STRING default 'FPM_WINDOW'
      !IV_TARGET_PLUG_NAME type STRING default 'DEFAULT'
    changing
      !CT_STEP type T_NAVIGATION_STEP .
  methods OPEN_DIALOG
    importing
      !IO_EVENT type ref to CL_FPM_EVENT
      !IV_EVENT_FAILED type BOOLE_D
      !IT_CURRENT_DIALOG_UIBB_KEYS type FPM_T_UIBB_KEY
      !IT_CURRENT_DIALOG_UIBBS type FPM_T_UIBB
      !IS_WINDOW_PROPERTIES_INTERNAL type FPM_S_CONTENT_AREA_PROPERTIES
      !IV_MAX_MESSAGE_SIZE type I
      !IV_SHOW_LOG type XFELD
      !IO_MESSAGE_MANAGER type ref to IWCI_FPM_MESSAGE_MANAGER
      !IO_MAIN_VIEW_CONTROLLER type ref to IF_WD_VIEW_CONTROLLER
      !IO_WD_API type ref to IF_WD_COMPONENT
      !IS_CURRENT_DIALOG_PROPERTIES type FPM_S_DIALOG_BOX_PROPERTIES
    exporting
      !EO_DIALOG_WINDOW type ref to IF_WD_WINDOW
    changing
      !CV_CURRENT_DIALOG_WINDOW_LEVEL type I
      !CV_CURRENT_DIALOG_WINDOW_ID type FPM_DIALOG_WINDOW_ID .
  methods OPEN_HELP_CENTER .
  methods OPEN_SIDE_PANEL
    importing
      !IO_WD_ACTION type ref to IF_WD_ACTION optional .
  methods PREPARE_WORK_PROTECTION .
  methods PROCESS_ASYNC_EVENT
    importing
      !IO_EVENT type ref to CL_WD_CUSTOM_EVENT .
  methods RAISE_SPECIAL_WDA_EVENT
    importing
      !IV_WDA_EVENT type STRING .
  methods SET_EVENT_PARAM_PARENT_UIBB
    importing
      !IT_UIBB type ANY TABLE
    changing
      !CO_EVENT type ref to CL_FPM_EVENT .
  methods SET_FPM_INSTANCE
    importing
      !IO_FPM type ref to IF_FPM .
  methods SET_MSG_AREA_DISPLAY_ATTR
    importing
      !IO_WD_WINDOW_CONTROLLER type ref to IF_WD_WINDOW_CONTROLLER .
  methods SET_MSG_MAPPER_SETTINGS
    importing
      !IO_FPM_NODE_ROOT type ref to IF_FPM_NODE optional .
  methods STYLE_UIELEMENT
    importing
      !IV_PROPERTY_STRING type STRING
      !IO_UIELEMENT type ref to CL_WD_UIELEMENT .
  methods TERMINATE
    importing
      !IS_T100 type SYMSG optional
      !IV_SUPPRESS_MESSAGE type ABAP_BOOL default ABAP_FALSE
      !IV_DISPLAY_ERROR_PAGE type ABAP_BOOL default ABAP_FALSE .
  methods TOGGLE_MODE
    importing
      !IO_WD_ACTION type ref to IF_WD_ACTION optional
      !IO_WD_CONTEXT type ref to IF_WD_CONTEXT_NODE optional .
  methods TOGGLE_QUICK_HELP .
protected section.

  types:
    BEGIN OF ty_s_ext_navigation,
      id                 TYPE fpm_external_navigation_id,
      category           TYPE fpm_external_navigation_categ,
      role               TYPE fpm_s_navigation_key-key1,
      instance           TYPE fpm_s_navigation_key-key2,
      text               TYPE fpm_text,
      tooltip            TYPE fpm_tooltip,
      enabled            TYPE fpm_enabled,
      visibility         TYPE fpm_visibility,
      instance_style             TYPE fpm_instance_style,
      show_folders               TYPE fpm_show_folders,
      consider_first_folder_only TYPE fpm_consider_first_folder_only,
      maximum_folder_level       TYPE fpm_maximum_folder_level,
      show_icons                 TYPE fpm_show_icons,
      show_separators            TYPE fpm_show_separators,
      action_type                TYPE fpm_action_type,
      wd_context_element TYPE REF TO if_wd_context_element,
    END OF ty_s_ext_navigation .
  types:
    ty_t_ext_navigation TYPE STANDARD TABLE OF ty_s_ext_navigation
                               WITH NON-UNIQUE DEFAULT KEY .
  types:
    BEGIN OF s_uibb,
      component            TYPE string,
      config_key           TYPE wdy_config_key,
      instance_id          TYPE fpm_instance_id,
      is_composite         TYPE boole_d,
      is_quickview_source  TYPE boole_d,
      within_current_event TYPE boole_d,
      interface            TYPE REF TO iwci_if_fpm_composite_comp,
      qv_source_interface  TYPE REF TO iwci_if_fpm_quickview_source,
    END OF s_uibb .
  types:
    t_uibbs TYPE STANDARD TABLE OF s_uibb WITH DEFAULT KEY .

  data MO_CHIP_INTEGRATION type ref to CL_FPM_CHIP_INTEGRATION .
  data MO_INSTANCE_STYLE_MANAGER type ref to CL_FPM_INSTANCE_STYLE_MANAGER .
  data MT_UIBBS type T_UIBBS .
  data MT_UIBB_HIER type T_UIBB_HIER .
  data MV_UI_GUIDELINE_VERSION_EXTERN type FPM_GUIDELINE_VERSION value SPACE ##NO_TEXT.

  methods ADAPT_TB_BUTTON_CHOICE_DESIGN
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IV_IS_FIRST_ELEMENT type ABAP_BOOL
      !IV_IS_ANY_ELEMENT_EMPHASIZED type ABAP_BOOL
      !IV_DESIGN type FPM_BUTTON_CHOICE_DESIGN
    exporting
      !EV_DESIGN type FPM_BUTTON_CHOICE_DESIGN .
  methods ADAPT_TB_TOGGLE_BUTTON_DESIGN
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IV_IS_FIRST_ELEMENT type ABAP_BOOL
      !IV_IS_ANY_ELEMENT_EMPHASIZED type ABAP_BOOL
      !IV_DESIGN type FPM_TOGGLE_BUTTON_DESIGN
    exporting
      !EV_DESIGN type FPM_TOGGLE_BUTTON_DESIGN .
  methods ADAPT_TOOLBAR_BUTTON_DESIGN
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IV_IS_FIRST_ELEMENT type ABAP_BOOL
      !IV_IS_ANY_ELEMENT_EMPHASIZED type ABAP_BOOL
      !IV_DESIGN type FPM_TOOLBAR_BUTTON_DESIGN
    exporting
      !EV_DESIGN type FPM_TOOLBAR_BUTTON_DESIGN .
  methods ADAPT_TOOLBAR_ELEMENT_ALIGNMNT
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IV_TOOLBAR_ELEMENT_TYPE type FPM_TB_ELEMENT_TYPE
      !IV_ALIGNMENT type FPM_TOOLBAR_ELEMENT_ALIGNMENT
    exporting
      !EV_ALIGNMENT type FPM_TOOLBAR_ELEMENT_ALIGNMENT .
  methods ADAPT_TOOLBAR_ELEMENT_PROPS
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IV_FRAMEWORK_FUNCTION type ABAP_BOOL default ABAP_FALSE
      !IV_TEXT type FPM_TEXT
      !IV_IMAGE type FPM_IMAGE
      !IV_IMAGE_PATH type STRING optional
      !IV_TOOLTIP type FPM_TOOLTIP
      !IV_TOOLTIP_PATH type STRING optional
      !IV_EVENT_ID type FPM_EVENT_ID optional
      !IV_ENABLED type FPM_ENABLED default ABAP_TRUE
    exporting
      !EV_TEXT type FPM_TEXT
      !EV_IMAGE type FPM_IMAGE
      !EV_IMAGE_PATH type STRING
      !EV_TOOLTIP type FPM_TOOLTIP
      !EV_TOOLTIP_PATH type STRING .
  methods ADAPT_TOOLBAR_PROPS
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IV_ACCESSIBILITY_DESCR type WDY_MD_TRANSLATABLE_TEXT optional
      !IV_DESIGN type WDUI_TOOLBAR_DESIGN optional
      !IV_HIDE_IF_EMPTY type ABAP_BOOL default ABAP_FALSE
      !IV_ITEM_OVERFLOW type WDUI_ITEM_OVERFLOW optional
    exporting
      !EV_ACCESSIBILITY_DESCR type WDY_MD_TRANSLATABLE_TEXT
      !EV_DESIGN type WDUI_TOOLBAR_DESIGN
      !EV_HIDE_IF_EMPTY type ABAP_BOOL
      !EV_ITEM_OVERFLOW type WDUI_ITEM_OVERFLOW .
  methods CONVERT_CONFIG_KEY
    importing
      !IS_CONFIG_KEY type WDY_CONFIG_KEY
      !IV_INSTANCE_ID type FPM_INSTANCE_ID
      !IV_TO_ADAPTED type ABAP_BOOL default ABAP_FALSE
    returning
      value(RS_CONFIG_KEY) type WDY_CONFIG_KEY .
  methods EXIT_SIDE_PANEL_INTERNAL
    importing
      !IO_VIEW_CONTROLLER type ref to IF_WD_VIEW_CONTROLLER .
  methods FORWARD_LOCAL_EDIT_EVENT
    importing
      !IO_EVENT type ref to CL_FPM_EVENT .
  methods GET_APP_HIERARCHY_BUTTON_ATTR
    exporting
      !EV_VISIBILITY type WDUI_VISIBILITY
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_CONFIGURE_BUTTON_ATTR
    exporting
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_CONFIGURE_PAGE_BUTTON_ATTR
    exporting
      !EV_VISIBILITY type WDUI_VISIBILITY
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_EXT_NAV_ACTION_NAME
    importing
      !IV_EXT_NAVIGATION_CATEGORY type FPM_EXTERNAL_NAVIGATION_CATEG
    returning
      value(RV_ACTION_NAME) type STRING .
  methods GET_EXT_NAV_MENUS_FROM_CTXT
    importing
      !IO_FPM_ND_EXTERNAL_NAVIGATION type ref to IF_FPM_NODE
    exporting
      !ET_EXT_NAVIGATION type TY_T_EXT_NAVIGATION .
  methods GET_FLOORPLAN_APPLICATION_NODE
    returning
      value(RO_ND_APPLICATION) type ref to IF_WD_CONTEXT_NODE .
  methods GET_HELP_BUTTON_ATTR
    exporting
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_LOGOFF_ON_CLOSE
    returning
      value(RV_LOGOFF_ON_CLOSE) type FPM_LOGOFF_ON_CLOSE .
  methods GET_NODE_NAME_APPLICATION
  abstract
    returning
      value(RV_NODE_NAME) type STRING .
  methods GET_OVERLAY_MODE_ATTR
    exporting
      !EV_VISIBILITY type WDUI_VISIBILITY
      !EV_ENABLED type ABAP_BOOL
      !EV_ACTIVE type ABAP_BOOL
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_PRINT_BUTTON_ATTR
    exporting
      !EV_VISIBILITY type WDUI_VISIBILITY
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_QUICK_HELP_MODE_ATTR
    exporting
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING
      !EV_IMAGE type STRING .
  methods GET_SIDE_PANEL_LINK_ATTR
    exporting
      !EV_VISIBILITY type WDUI_VISIBILITY
      !EV_ENABLED type ABAP_BOOL
      !EV_TEXT type STRING
      !EV_TOOLTIP type STRING .
  methods GET_TOOLBAR_LOCATION_TYPE
    returning
      value(RV_TOOLBAR_LOCATION_TYPE) type FPM_TOOLBAR_LOCATION_TYPE .
  methods GET_UI_ELEMENT_ID_FOR_EXT_NAV
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION
      !IV_EXT_NAVIGATION_CATEGORY type FPM_EXTERNAL_NAVIGATION_CATEG
      !IV_IS_FOCUS_REQUEST type ABAP_BOOL default ABAP_FALSE
    returning
      value(RV_UI_ELEMENT_ID) type STRING .
  methods GET_WORK_PROTECT_MODE
    returning
      value(RV_WORK_PROTECT_MODE) type STRING .
  methods INITIALIZE_APP_CC
    returning
      value(RO_APP_CC_USAGE) type ref to IF_WD_COMPONENT_USAGE .
  methods INITIALIZE_APP_PARAMETERS .
  methods INITIALIZE_CHIP_INTEGRATION .
  methods INITIALIZE_CONF_COMP_USAGE .
  methods INITIALIZE_CONTEXT_MANAGER
    importing
      !IO_WD_CONTEXT_NODE type ref to IF_WD_CONTEXT_NODE optional .
  methods INITIALIZE_FLOORPLAN_HANDLER
    importing
      !IO_FLOORPLAN_COMP_CONTROLLER type ref to OBJECT
    returning
      value(RO_FLOORPLAN_HANDLER) type ref to CL_FPM_FLOORPLAN_INTERNAL .
  methods INITIALIZE_FPM_RUNTIME
    importing
      !IO_FLOORPLAN_COMP_CONTROLLER type ref to OBJECT
    returning
      value(RO_FPM) type ref to CL_FPM .
  methods INITIALIZE_IDR
    importing
      !IO_WD_COMPONENT_USAGE type ref to IF_WD_COMPONENT_USAGE
    returning
      value(RS_IDR_UIBB_KEY_ADAPTED) type FPM_S_UIBB_KEY .
  methods INITIALIZE_MESSAGE_MANAGER .
  methods CLEAR_DISPLAYED_UIBBS .
  methods INITIALIZE_RAT .
  methods INITIALIZE_RUNTIME_API
    returning
      value(RO_FPM_FLOORPLAN_RUNTIME_API) type ref to OBJECT .
  methods INITIALIZE_RUNTIME_INFO_OBJECT
    returning
      value(RO_FPM_RUNTIME_INFO_OBJECT) type ref to OBJECT .
  methods INIT_SIDE_PANEL_INTERNAL
    importing
      !IO_VIEW_CONTROLLER type ref to IF_WD_VIEW_CONTROLLER
      !IV_PORTAL_EVENT_ACTION type STRING .
  methods IS_MULTI_STRETCHED
    returning
      value(RV_IS_MULTI_STRETCHED) type ABAP_BOOL .
  methods IS_VALID_CONFIGURATION
    returning
      value(RV_RESULT) type ABAP_BOOL .
  methods ON_CLOSE_OF_SIDE_PANEL
    for event CLOSE_REQUESTED of IF_WD_SIDE_PANEL_API .
  methods RENDER_EXT_NAVIGATION_MENUS
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION
      !IO_TOOLBAR type ref to CL_WD_TOOLBAR
      !IO_FPM_ND_EXTERNAL_NAVIGATION type ref to IF_FPM_NODE
      !IO_FPM_HCT_UI_ASSIST type ref to CL_FPM_HCT_UI_ASSIST optional
      !IV_ADD_SEPARATOR type ABAP_BOOL default ABAP_TRUE
    exporting
      !EV_TOOLBAR_ELEMENTS_ADDED type ABAP_BOOL .
  methods RENDER_SIDE_PANEL_LINK
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IO_PARENT_CONTAINER type ref to CL_WD_UIELEMENT_CONTAINER optional
      !IO_TOOLBAR type ref to CL_WD_TOOLBAR optional
      !IO_ND_SIDE_PANEL_LINK_PROPS type ref to IF_WD_CONTEXT_NODE optional .
  methods RENDER_TITLE_CONTENT
    importing
      !IV_TOOLBAR_LOCATION type FPM_TOOLBAR_LOCATION optional
      !IO_TITLE_CONTENT_CONTAINER type ref to CL_WD_UIELEMENT_CONTAINER
      !IO_ND_SIDE_PANEL_LINK_PROPS type ref to IF_WD_CONTEXT_NODE optional .
  methods TRIGGER_LPD_NAVIGATION
    importing
      !IV_LPD_ROLE type FPM_S_NAVIGATION_KEY-KEY1
      !IV_LPD_INSTANCE type FPM_S_NAVIGATION_KEY-KEY2
      !IV_LPD_APPLICATION_ID type IF_FPM_NAVIGATION=>S_TARGET-KEY .
private section.

  types:
    BEGIN OF s_container_layout,
        component_name         TYPE string,
        view_name              TYPE string,
        id                     TYPE string,
        height                 TYPE string,
        width                  TYPE string,
        layout_height          TYPE string,
        layout_width           TYPE string,
        stretched_vertically   TYPE wdy_boolean,
        stretched_horizontally TYPE wdy_boolean,
      END OF s_container_layout .
  types:
    t_container_layout TYPE STANDARD TABLE OF s_container_layout .

  data MT_CONTAINER_LAYOUT type T_CONTAINER_LAYOUT .
  data MT_DISPLAYED_UIBB type T_NAVIGATION_STEP .
  data MT_UIBBS_BEFORE type T_UIBBS .
  data MT_UIBB_HIER_BEFORE type T_UIBB_HIER .
  data:
    mt_window_stack TYPE standard table of REF TO if_wd_window .
  data MV_DIALOG_USAGE_GROUP type ref to IF_WD_COMPONENT_USAGE_GROUP .

  methods GET_CONFIG_MSG_AREA_SETTINGS
    importing
      !IO_FPM_NODE_ROOT type ref to IF_FPM_NODE
    exporting
      !EV_MAXIMUM_MESSAGES_SIZE type I
      !EV_SHOW_MESSAGE_LOG type WDY_BOOLEAN
      !EV_MESSAGE_AREA_DESIGN type FPM_MESSAGE_AREA_DESIGN
      !EV_MESSAGE_AREA_DISPLAY type FPM_MESSAGE_AREA_DISPLAY
      !EV_CONDENSE_IDENTICAL_MSG type FPM_CONDENSE_IDENTICAL_MSG .
  methods GET_CONFIG_MSG_MAPPER_SETTINGS
    importing
      !IO_FPM_NODE_ROOT type ref to IF_FPM_NODE
    returning
      value(RS_CONFIG_MSG_MAPPER_SETTINGS) type FPMFP_S_MM_DEFINITION .
  methods REMOVE_WINDOW_FROM_STACK
    importing
      !IO_WINDOW type ref to IF_WD_WINDOW .
  methods SET_MSG_MAPPER_SETTINGS_INT
    importing
      !IV_ENABLE_MAPPING type FPMFP_S_MM_DEFINITION-ENABLE_MAPPING optional
      !IV_GENERALIZATION_TYPE type FPMFP_S_MM_DEFINITION-GENERALIZATION_TYPE optional
      !IV_ENABLE_LOGGING type FPMFP_S_MM_DEFINITION-ENABLE_LOGGING optional
      !IV_LOG_GENERALIZATION type FPMFP_S_MM_DEFINITION-LOG_GENERALIZATION optional
      !IV_LOG_HIDE type FPMFP_S_MM_DEFINITION-LOG_HIDE optional
      !IV_HIDE_ON_GENERALIZATION type FPMFP_S_MM_DEFINITION-HIDE_ON_GENERALIZATION optional .
ENDCLASS.



CLASS CL_FPM_FLOORPLAN_ASSIST IMPLEMENTATION.


METHOD ADAPT_TB_BUTTON_CHOICE_DESIGN.


* Initialize exporting parameters
* (Do not clear the exporting parameters here!
*  Otherwise, clearing an export parameter EV_* would immediately clear the importing parameter IV_*
*  if the importing parameter is the same as the exporting parameter in the calling method, because
*  the parameters are passed by reference to the method and not by value.)
  ev_design = iv_design.

  IF ev_design IS SUPPLIED.
*   Determine whether the design should be 'Emphasized'
*   (The commented lines are only required in the case that the first toolbar element should be emphasized always when using guideline FIORI,
*    independent of whether the toolbar is enforced to be in the header or footer only)
    IF ev_design                    = if_fpm_constants=>gc_button_choice_design-standard    AND
       iv_is_first_element          = abap_true                                             AND
       iv_is_any_element_emphasized = abap_false                                            AND
       get_ui_guideline_version( )  = if_fpm_constants_internal=>gc_guideline_version-fiori AND
       ( "mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-header and iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-header OR
         "mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-footer and iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer OR
         ( mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-guideline AND iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer ) ).
      ev_design = if_fpm_constants=>gc_button_choice_design-emphasized.
      RETURN.
    ENDIF.
*   Determine whether the design should be 'Transparent'
    IF ev_design                   = if_fpm_constants=>gc_button_choice_design-standard    AND
       get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori AND
       iv_toolbar_location         IS INITIAL.
      ev_design = if_fpm_constants=>gc_button_choice_design-transparent.
      RETURN.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD adapt_tb_toggle_button_design.


* Initialize exporting parameters
* (Do not clear the exporting parameters here!
*  Otherwise, clearing an export parameter EV_* would immediately clear the importing parameter IV_*
*  if the importing parameter is the same as the exporting parameter in the calling method, because
*  the parameters are passed by reference to the method and not by value.)
  ev_design = iv_design.

  IF ev_design IS SUPPLIED.
*   Determine whether the design should be 'Emphasized'
*   (The commented lines are only required in the case that the first button element should be emphasized always when using guideline FIORI,
*    independent of whether the toolbar is enforced to be in the header or footer only)
    IF ev_design                    = if_fpm_constants=>gc_toggle_button_design-standard    AND
       iv_is_first_element          = abap_true                                             AND
       iv_is_any_element_emphasized = abap_false                                            AND
       get_ui_guideline_version( )  = if_fpm_constants_internal=>gc_guideline_version-fiori AND
       ( "mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-header and iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-header OR
         "mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-footer and iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer OR
         ( mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-guideline AND iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer ) ).
      ev_design = if_fpm_constants=>gc_toggle_button_design-emphasized.
      RETURN.
    ENDIF.
*   Determine whether the design should be 'Transparent'
    IF ev_design                   = if_fpm_constants=>gc_toggle_button_design-standard    AND
       get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori AND
       iv_toolbar_location         IS INITIAL.
      ev_design = if_fpm_constants=>gc_toggle_button_design-transparent.
      RETURN.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD adapt_toolbar_button_design.


* Initialize exporting parameters
* (Do not clear the exporting parameters here!
*  Otherwise, clearing an export parameter EV_* would immediately clear the importing parameter IV_*
*  if the importing parameter is the same as the exporting parameter in the calling method, because
*  the parameters are passed by reference to the method and not by value.)
  ev_design = iv_design.

  IF ev_design IS SUPPLIED.
*   Determine whether the design should be 'Emphasized'
*   (The commented lines are only required in the case that the first toolbar element should be emphasized always when using guideline FIORI,
*    independent of whether the toolbar is enforced to be in the header or footer only)
    IF ev_design                    = if_fpm_constants=>gc_toolbar_button_design-standard   AND
       iv_is_first_element          = abap_true                                             AND
       iv_is_any_element_emphasized = abap_false                                            AND
       get_ui_guideline_version( )  = if_fpm_constants_internal=>gc_guideline_version-fiori AND
       ( "mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-header and iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-header OR
         "mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-footer and iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer OR
         ( mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-guideline AND iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer ) ).
      ev_design = if_fpm_constants=>gc_toolbar_button_design-emphasized.
      RETURN.
    ENDIF.
*   Determine whether the design should be 'Transparent'
    IF ev_design                   = if_fpm_constants=>gc_toolbar_button_design-standard   AND
       get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori AND
       iv_toolbar_location         IS INITIAL.
      ev_design = if_fpm_constants=>gc_toolbar_button_design-transparent.
      RETURN.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD adapt_toolbar_element_alignmnt.


* Initialize exporting parameters
* (Do not clear the exporting parameters here!
*  Otherwise, clearing an export parameter EV_* would immediately clear the importing parameter IV_*
*  if the importing parameter is the same as the exporting parameter in the calling method, because
*  the parameters are passed by reference to the method and not by value.)
  ev_alignment = iv_alignment.

  IF ev_alignment IS SUPPLIED.
    CASE iv_toolbar_element_type.
      WHEN if_fpm_constants=>gc_toolbar_element_type-button.
        IF get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
          IF mv_toolbar_location_type =  if_fpm_constants=>gc_toolbar_location_type-guideline  AND "required only in the case that the alignment should be unchanged when using guideline FIORI and the toolbar is enforced to be in the header or footer only
             iv_toolbar_location      =  if_fpm_constants_internal=>gc_toolbar_location-footer AND
             ev_alignment             <> if_fpm_constants=>gc_toolbar_element_alignment-right.
            ev_alignment = if_fpm_constants=>gc_toolbar_element_alignment-right.
          ENDIF.
        ENDIF.
      WHEN OTHERS.
        RETURN.
    ENDCASE.
  ENDIF.


ENDMETHOD.


METHOD adapt_toolbar_element_props.


  DATA:
    lo_application TYPE REF TO if_wd_application.

  DATA:
    lv_component_name TYPE string,
    lv_is_rtl         TYPE abap_bool,
    lv_text           TYPE string.


* Initialize exporting parameters
* (Do not clear the exporting parameters here!
*  Otherwise, clearing an export parameter EV_* would immediately clear the importing parameter IV_*
*  if the importing parameter is the same as the exporting parameter in the calling method, because
*  the parameters are passed by reference to the method and not by value.)
  ev_text         = iv_text.
  ev_image        = iv_image.
  ev_image_path   = iv_image_path.
  ev_tooltip      = iv_tooltip.
  ev_tooltip_path = iv_tooltip_path.

* Do not change the order in which the various blocks are processed!!!

  IF ev_text IS SUPPLIED OR ev_image IS SUPPLIED OR ev_tooltip IS SUPPLIED.
    IF iv_framework_function = abap_true. "independent of the UI guideline, framework functions with image or image path do not have a text
      IF ev_image IS NOT INITIAL OR ev_image_path IS NOT INITIAL.
        CLEAR ev_text.
      ENDIF.
    ELSEIF get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
      IF ( iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-header OR
           iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer OR
           iv_toolbar_location IS INITIAL AND iv_event_id = if_fpm_constants=>gc_event-local_edit ).
        IF iv_framework_function = abap_false.
          IF ev_text IS INITIAL.
            ev_text = ev_tooltip.
            IF ev_text IS INITIAL AND ev_image IS NOT INITIAL.
              CLEAR lv_component_name.
              lv_is_rtl = abap_false.
              IF mo_component IS BOUND.
                lv_component_name = mo_component->get_component_info( )->get_name( ).
                lo_application = mo_component->get_application( ).
                IF lo_application IS BOUND.
                  lv_is_rtl = lo_application->get_is_rtl( ).
                ENDIF.
              ENDIF.
              cl_wdr_utilities=>construct_mime_url( EXPORTING i_component_name = lv_component_name
                                                              i_mime_source    = ev_image
                                                              i_is_rtl         = lv_is_rtl
                                                    IMPORTING e_short_text     = ev_text ).
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  IF ev_image IS SUPPLIED OR ev_image_path IS SUPPLIED.
    IF get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
      IF ( iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-header OR
           iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer OR
           iv_toolbar_location IS INITIAL AND iv_event_id = if_fpm_constants=>gc_event-local_edit ).
        IF iv_framework_function = abap_false.
          IF ev_text IS NOT INITIAL.
            CLEAR ev_image.
            CLEAR ev_image_path.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  IF ev_tooltip IS SUPPLIED.
    IF get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
      IF ( iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-header OR
           iv_toolbar_location = if_fpm_constants_internal=>gc_toolbar_location-footer OR
           iv_toolbar_location IS INITIAL AND iv_event_id = if_fpm_constants=>gc_event-local_edit ).
        IF ev_text = ev_tooltip.
          CLEAR ev_tooltip.
        ENDIF.
      ENDIF.
    ENDIF.
    IF iv_framework_function = abap_true. "independent of the UI guideline, framework functions do not explicitly set a tooltip if it is the same as the image tooltip
      IF ev_tooltip IS NOT INITIAL.
        IF ev_text IS INITIAL AND ev_image IS NOT INITIAL.
          CLEAR lv_component_name.
          lv_is_rtl = abap_false.
          IF mo_component IS BOUND.
            lv_component_name = mo_component->get_component_info( )->get_name( ).
            lo_application = mo_component->get_application( ).
            IF lo_application IS BOUND.
              lv_is_rtl = lo_application->get_is_rtl( ).
            ENDIF.
          ENDIF.
          cl_wdr_utilities=>construct_mime_url( EXPORTING i_component_name = lv_component_name
                                                          i_mime_source    = ev_image
                                                          i_is_rtl         = lv_is_rtl
                                                IMPORTING e_short_text     = lv_text ).
          IF lv_text = ev_tooltip.
            CLEAR ev_tooltip.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD adapt_toolbar_props.


* Initialize exporting parameters
* (Do not clear the exporting parameters here!
*  Otherwise, clearing an export parameter EV_* would immediately clear the importing parameter IV_*
*  if the importing parameter is the same as the exporting parameter in the calling method, because
*  the parameters are passed by reference to the method and not by value.)
  ev_accessibility_descr = iv_accessibility_descr.
  ev_design              = iv_design.
  ev_hide_if_empty       = iv_hide_if_empty.
  ev_item_overflow       = iv_item_overflow.

  IF ev_accessibility_descr IS SUPPLIED.
    CASE iv_toolbar_location.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-header.
        ev_accessibility_descr = get_floorplan_texts( iv_text_id = 'PAGE_HEADER_TOOLBAR' ).
      WHEN if_fpm_constants_internal=>gc_toolbar_location-footer.
        ev_accessibility_descr = get_floorplan_texts( iv_text_id = 'PAGE_FOOTER_TOOLBAR' ).
      WHEN OTHERS.
*       do nothing
    ENDCASE.
  ENDIF.

  IF ev_design IS SUPPLIED.
    CASE iv_toolbar_location.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-header.
        IF get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
          ev_design = cl_wd_toolbar=>e_design-header.
        ELSE.
          IF iv_design IS NOT SUPPLIED.
            ev_design = cl_wd_toolbar=>e_design-standard.
          ENDIF.
        ENDIF.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-footer.
        ev_design = cl_wd_toolbar=>e_design-footer.
      WHEN OTHERS.
        IF iv_design IS NOT SUPPLIED.
          ev_design = cl_wd_toolbar=>e_design-standard.
        ENDIF.
    ENDCASE.
  ENDIF.

  IF ev_hide_if_empty IS SUPPLIED.
    CASE iv_toolbar_location.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-header.
        ev_hide_if_empty = abap_true.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-footer.
        ev_hide_if_empty = abap_true.
      WHEN OTHERS.
        IF iv_hide_if_empty IS NOT SUPPLIED.
          ev_hide_if_empty = abap_false.
        ENDIF.
    ENDCASE.
  ENDIF.

  IF ev_item_overflow IS SUPPLIED. "currently not dependent on UI guideline of toolbar location
    CASE iv_toolbar_location.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-header.
        ev_item_overflow = cl_wd_toolbar=>e_item_overflow-menu.
      WHEN if_fpm_constants_internal=>gc_toolbar_location-footer.
        ev_item_overflow = cl_wd_toolbar=>e_item_overflow-menu.
      WHEN OTHERS.
        IF iv_item_overflow IS NOT SUPPLIED.
          ev_item_overflow = cl_wd_toolbar=>e_item_overflow-wrapping.
        ENDIF.
    ENDCASE.
  ENDIF.


ENDMETHOD.


METHOD add_window_to_stack.


  APPEND io_window TO mt_window_stack.


ENDMETHOD.


METHOD adjust_container_layout.


* Determine component and view name.
  DATA: lo_component TYPE REF TO if_wd_component.
  lo_component = io_view->if_wd_controller~get_component( ).

  DATA: lo_component_info TYPE REF TO if_wd_rr_component.
  lo_component_info = lo_component->get_component_info( ).

  DATA: lv_component_name TYPE string,
        lv_view_name      TYPE string.
  lv_component_name = lo_component_info->name.
  lv_view_name = io_view->if_wd_controller~name.

  DATA: lo_aca_api TYPE REF TO cl_fpm_aca.
  lo_aca_api = cl_fpm_aca=>get_instance( ).

  FIELD-SYMBOLS: <fs_container_layout_aca> LIKE LINE OF lo_aca_api->mt_container_layout,
                 <fs_container_layout>     LIKE LINE OF mt_container_layout.


  LOOP AT lo_aca_api->mt_container_layout ASSIGNING <fs_container_layout_aca>
                                                 WHERE view_name = lv_view_name.
    APPEND INITIAL LINE TO mt_container_layout ASSIGNING <fs_container_layout>.
    <fs_container_layout>-component_name = lv_component_name.
    <fs_container_layout>-view_name = lv_view_name.
    MOVE-CORRESPONDING <fs_container_layout_aca> TO <fs_container_layout>.
  ENDLOOP.

* method is only used for analysis purposes!
* mt_container _layout should always be initial!
  IF mt_container_layout IS INITIAL.
    RETURN.
  ENDIF.


  DATA: lo_uielement     TYPE REF TO cl_wd_uielement,
        lo_tc            TYPE REF TO cl_wd_uielement_container,
        lo_layout_data   TYPE REF TO cl_wd_layout_data,
        lo_layout        TYPE REF TO cl_wd_layout,
        lo_matrix_layout TYPE REF TO cl_wd_matrix_layout,
        lo_matrix_data   TYPE REF TO cl_wd_matrix_data,
        lo_grid_layout   TYPE REF TO cl_wd_grid_layout,
        lo_grid_data     TYPE REF TO cl_wd_grid_data,
        lv_blank         TYPE string.
  FIELD-SYMBOLS: <fs_layout> LIKE LINE OF mt_container_layout.
  LOOP AT mt_container_layout ASSIGNING <fs_layout>
                         WHERE component_name = lv_component_name AND
                                    view_name = lv_view_name.
    lo_uielement ?= io_view->get_element( <fs_layout>-id ).
    CHECK lo_uielement IS BOUND.
    lo_layout_data = lo_uielement->get_layout_data( ).
    IF lo_layout_data IS BOUND.
      IF lo_layout_data->_definition_name = 'MATRIX_DATA' OR lo_layout_data->_definition_name = 'MATRIX_HEAD_DATA'.
        lo_matrix_data ?= lo_layout_data.
        lo_matrix_data->set_width( <fs_layout>-layout_width ).
        lo_matrix_data->set_height( <fs_layout>-layout_height ).
      ELSEIF lo_layout_data->_definition_name = 'GRID_DATA'.
        lo_grid_data ?= lo_layout_data.
        lo_grid_data->set_width( <fs_layout>-layout_width ).
        lo_grid_data->set_height( <fs_layout>-layout_height ).
      ENDIF.
    ENDIF.
    CASE lo_uielement->_definition_name.
      WHEN 'TRANSPARENT_CONTAINER' OR
           'LAYOUT_CONTAINER'.
        lo_tc ?= lo_uielement.
        lo_tc->bind_width( lv_blank ).
        lo_tc->bind_height( lv_blank ).
        lo_tc->set_width( <fs_layout>-width ).
        lo_tc->set_height( <fs_layout>-height ).
        lo_layout = lo_tc->get_layout( ).
        IF lo_layout IS BOUND.
          IF lo_layout->_definition_name = 'MATRIX_LAYOUT'.
            lo_matrix_layout ?= lo_layout.
            lo_matrix_layout->set_stretched_vertically( <fs_layout>-stretched_vertically ).
            lo_matrix_layout->set_stretched_horizontally( <fs_layout>-stretched_horizontally ).
          ELSEIF lo_layout->_definition_name = 'GRID_LAYOUT'.
            lo_grid_layout ?= lo_layout.
            lo_grid_layout->set_stretched_vertically( <fs_layout>-stretched_vertically ).
            lo_grid_layout->set_stretched_horizontally( <fs_layout>-stretched_horizontally ).
          ENDIF.
        ENDIF.
      WHEN 'VIEW_CONTAINER_UIELEMENT'.
        CONTINUE.
      WHEN OTHERS.
        CONTINUE.
    ENDCASE.
  ENDLOOP.


ENDMETHOD.


METHOD check_if_close_available.


  DATA:
    lt_key TYPE if_fpm_parameter=>t_keys.

  DATA:
    lv_hide_close TYPE string.


* Initialize returning parameter
  rv_close_supported = abap_false.

* Check WD application settings
  IF mo_component IS BOUND.
    rv_close_supported = mo_component->get_application( )->get_is_close_window_supported( ).
    IF rv_close_supported = abap_false.
      RETURN.
    ENDIF.
  ENDIF.

* Return if there if no FPM instance
  IF mo_fpm IS NOT BOUND.
    RETURN.
  ENDIF.

* New logic for close button: Close button is only rendered when parameter
* FPM_HIDE_CLOSE is set to space (reversal of default behaviour)
  lt_key = mo_fpm->if_fpm~mo_app_parameter->get_keys( ).
  READ TABLE lt_key
             TRANSPORTING NO FIELDS
             WITH KEY table_line = if_fpm_constants=>gc_app_params-hide_close_button.
  IF sy-subrc <> 0.
    rv_close_supported = abap_false.
    RETURN.
  ENDIF.

* Check URL parameter 'FPM_HIDE_CLOSE'
  mo_fpm->if_fpm~mo_app_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-hide_close_button
                                              IMPORTING ev_value = lv_hide_close ).
  IF lv_hide_close = abap_true.
    rv_close_supported = abap_false.
    RETURN.
  ENDIF.


ENDMETHOD.


METHOD clear_composite_slots.


  FIELD-SYMBOLS:
    <ls_uibb> LIKE LINE OF mt_uibbs.


  LOOP AT mt_uibbs ASSIGNING <ls_uibb>
                   WHERE is_composite = abap_true.
    <ls_uibb>-interface ?= mo_fpm->mo_component_manager->get_component_interface( iv_component_name = <ls_uibb>-component
                                                                                  is_config_key     = <ls_uibb>-config_key
                                                                                  iv_instance_id    = <ls_uibb>-instance_id ).
    IF <ls_uibb>-interface IS BOUND.
      <ls_uibb>-interface->clear_slots( ).
    ELSE.
      DELETE mt_uibbs.
    ENDIF.
  ENDLOOP.


ENDMETHOD.


  method CLEAR_DISPLAYED_UIBBS.
    clear mt_displayed_uibb.
  endmethod.


METHOD close_application.


  DATA:
    lo_fpm_event TYPE REF TO cl_fpm_event.

  DATA:
    lv_action_type TYPE fpm_action_type VALUE if_fpm_constants=>gc_action_type-standard.


* Determine action type for the FPM event
  IF io_wd_action IS BOUND.
    IF io_wd_action->is_validating = abap_false.
      lv_action_type = if_fpm_constants=>gc_action_type-validation_independent.
    ENDIF.
  ENDIF.

* Create FPM event
  lo_fpm_event = cl_fpm_event=>create_by_id( iv_event_id    = if_fpm_constants=>gc_event-close
                                             iv_action_type = lv_action_type ).

* Raise FPM event
  mo_fpm->if_fpm~raise_event( lo_fpm_event ).


ENDMETHOD.


METHOD close_dialog.
  "Lets hanlde the OK button. Okay means the following.
  "start the event loop for the okay button.
  "Get the event id that has is connected to this pop-op.


  DATA: ls_dialog_cmp_usage            TYPE cl_fpm_floorplan_assist=>t_dialog_component_usage,
        lo_window                      TYPE REF TO if_wd_window,
        lo_level_usage                 TYPE REF TO if_wd_component_usage,
        lv_propose_dialog_window_level TYPE string.


  "Check if the event is valid.
  CHECK io_event->mv_event_id EQ cl_fpm_event=>gc_event_close_dialog_box
    AND iv_event_failed EQ abap_false.

  DATA: lo_event_params TYPE REF TO if_fpm_parameter.
  lo_event_params = io_event->mo_event_data.
  CALL METHOD lo_event_params->get_value
    EXPORTING
      iv_key   = if_fpm_constants=>gc_proposed_dialog_level
    IMPORTING
      ev_value = lv_propose_dialog_window_level.

  "for values < 0, we start again from 0
  IF lv_propose_dialog_window_level LT 0.
    lv_propose_dialog_window_level = 0.
  ENDIF.

  "set the proposed dialog window level to current dialog window level
  cv_current_dialog_window_level = lv_propose_dialog_window_level.

  "its a stack so the top means the current dialog always.
  "Since it is a stack we will need to now move vice-versa.
  DATA: lv_stack_size     TYPE i,
        lv_stack_position TYPE i,
        lv_current_index  TYPE i.
  DESCRIBE TABLE mt_dialog_component_usages LINES lv_stack_size.
  lv_stack_position = lv_stack_size - cv_current_dialog_window_level.

  CLEAR lv_current_index.
  lv_current_index = lv_stack_position + 1.
  READ TABLE mt_dialog_component_usages INTO ls_dialog_cmp_usage
    INDEX   lv_current_index.
  IF sy-subrc EQ 0.
    IF ls_dialog_cmp_usage-dialog_window_id IS INITIAL.
      RETURN.
    ENDIF.
    cv_current_dialog_window_id = ls_dialog_cmp_usage-dialog_window_id.
  ELSE.
    CLEAR cv_current_dialog_window_id.
  ENDIF.

  READ TABLE mt_dialog_component_usages INTO ls_dialog_cmp_usage
    INDEX   lv_stack_position.

  IF ls_dialog_cmp_usage        IS INITIAL OR
     ls_dialog_cmp_usage-window IS NOT BOUND.
    RETURN.
  ENDIF.

  lo_window = ls_dialog_cmp_usage-window.

  "Now that the event processing is done for the dialog. Close it.
  lo_window->close( ).

  remove_window_from_stack( lo_window ).

  "We will also need to set the message manager of the parent window/component.
  DATA: lv_level_c                     TYPE c,
        ls_usage                       TYPE string,
        lo_dialog_interface_controller TYPE REF TO iwci_fpm_dialog_component,
        lo_fpm_message_manager         TYPE REF TO cl_fpm_message_manager,
        lo_wd_message_manager          TYPE REF TO if_wd_message_manager,
        lo_api_controller              TYPE REF TO if_wd_controller.

  CLEAR lo_level_usage.
  lv_level_c = cv_current_dialog_window_level.

  lo_fpm_message_manager = mo_fpm->mo_message_manager.
  "Check if we are still in dialogs or if we are in the main screen now.
  IF cv_current_dialog_window_level GT 0. "We are in dialogs.
    CONCATENATE 'level ' lv_level_c INTO ls_usage ##NO_TEXT.
    lo_level_usage  = mv_dialog_usage_group->get_component_usage( ls_usage ).
    IF lo_level_usage IS NOT INITIAL.
      lo_dialog_interface_controller ?= lo_level_usage->get_interface_controller( ).
      lo_wd_message_manager = lo_dialog_interface_controller->get_message_manager( ).
    ELSE. "Set the main view's message manager.
      lo_api_controller ?= io_wd_api.
      CALL METHOD lo_api_controller->get_message_manager
        RECEIVING
          message_manager = lo_wd_message_manager.
    ENDIF.
  ELSE. "We are on the main screen
    lo_api_controller ?= io_wd_api.
    CALL METHOD lo_api_controller->get_message_manager
      RECEIVING
        message_manager = lo_wd_message_manager.
  ENDIF.
  lo_fpm_message_manager->set_wd_message_manager( lo_wd_message_manager ).


ENDMETHOD.


METHOD close_dialog_internal.

  "Lets handle the OK button. Okay means the following.
  "start the event loop for the okay button.
  "Get the event id that has is connected to this pop-op.

  "We first start the event loop to get the event loop to get the UIBB data and to
  "trigger all the PAI and PBO blocks of the existing UIBBs.


  DATA:
    lo_event          TYPE REF TO cl_fpm_event,
    lo_fpm_event_data TYPE REF TO if_fpm_parameter.

  DATA:
    lv_is_validating TYPE boole_d VALUE abap_true.


  CASE iv_action_type.
    WHEN if_fpm_constants=>gc_action_type-standard.
      lv_is_validating = abap_true.
    WHEN if_fpm_constants=>gc_action_type-validation_independent.
      lv_is_validating = abap_false.
  ENDCASE.

* Pass the id of the dialog window for two reasons.
*   1. We will need to use it while processin the get_uibb
*   2. For the applications in case they need to perfrom any PAI activities before the dialog opens.
  CREATE OBJECT lo_fpm_event_data TYPE cl_fpm_parameter.

  lo_fpm_event_data->set_value( EXPORTING iv_key   = if_fpm_constants=>gc_dialog_box-in_dialog_mode_key
                                          iv_value = 'X' ).

  lo_fpm_event_data->set_value( EXPORTING iv_key   = if_fpm_constants=>gc_dialog_box-id
                                          iv_value = iv_current_dialog_window_id ).

  lo_fpm_event_data->set_value( EXPORTING iv_key   = if_fpm_constants=>gc_dialog_box-dialog_buton_key
                                          iv_value = iv_action_id ).

  CREATE OBJECT lo_event
    EXPORTING
      iv_event_id      = cl_fpm_event=>gc_event_close_dialog_box
      iv_is_validating = lv_is_validating
      io_event_data    = lo_fpm_event_data.

* Raise the event to logically trigger the change of the UIBB list
  mo_fpm->if_fpm~raise_event( lo_event ).


ENDMETHOD.


METHOD convert_config_key.

  DATA:
    lo_adpat_man    TYPE REF TO cl_fpm_adapt_manager,
    ls_config_key_i TYPE fpm_s_config_key,
    ls_config_key_o TYPE fpm_s_config_key.


*----- default: unchanged
  rs_config_key = is_config_key.

*----- starters
  IF mo_fpm IS NOT BOUND.
    RETURN.
  ENDIF.

*----- do nothing if no adaptation
  IF mo_fpm->if_fpm~mo_adaptation_manager IS NOT BOUND.
    RETURN.
  ENDIF.

*----- save a micro second
  IF iv_to_adapted = abap_false.
    IF is_config_key-config_type <> if_wd_config_constants=>c_config_type_verticalization.
      RETURN.
    ENDIF.
  ENDIF.

*----- cast to class
  lo_adpat_man ?= mo_fpm->if_fpm~mo_adaptation_manager.

*----- replace
  ls_config_key_i-config_key = is_config_key.
  ls_config_key_i-instance_id = iv_instance_id.
  IF iv_to_adapted = abap_true.
    CALL METHOD lo_adpat_man->get_adapted_config_key
      EXPORTING
        is_config_key = ls_config_key_i
      IMPORTING
        es_config_key = ls_config_key_o.
  ELSE.
    CALL METHOD lo_adpat_man->get_unadapted_config_key
      EXPORTING
        is_config_key = ls_config_key_i
      IMPORTING
        es_config_key = ls_config_key_o.
  ENDIF.
  rs_config_key =  ls_config_key_o-config_key.

ENDMETHOD.


METHOD create_support_message.


  DATA: lt_attachment   TYPE cl_wd_support_cim_handler=>tt_attachments,
        ls_attachment   LIKE LINE OF lt_attachment,
        ls_runtime_info TYPE fpm_s_runtime_info.


  ls_runtime_info = mo_fpm->get_runtime_info( ).

  CALL TRANSFORMATION id SOURCE runtime_info = ls_runtime_info
                         RESULT XML ls_attachment-data.

  ls_attachment-filename = 'FPM_RUNTIME_INFO.XML'.
  ls_attachment-title    = ls_attachment-filename.

  DATA: lv_mimetype TYPE w3conttype.
  CALL FUNCTION 'SDOK_MIMETYPE_GET'
    EXPORTING
      extension = 'XML'
    IMPORTING
      mimetype  = lv_mimetype.

  ls_attachment-mimetype = lv_mimetype.
  APPEND ls_attachment TO lt_attachment.

  cl_wd_support_cim_handler=>create_message( lt_attachment ).


ENDMETHOD.


METHOD exit_side_panel.


*----- only for one fpm instance
  CHECK mo_fpm = cl_fpm_factory=>get_instance( ).

  SET HANDLER on_close_of_side_panel FOR ALL INSTANCES ACTIVATION abap_false.

*----- internal method to delegate in redefinitions
  exit_side_panel_internal( io_view_controller ).


ENDMETHOD.


METHOD exit_side_panel_internal.


*----- ignore by default
  RETURN.


ENDMETHOD.


METHOD forward_local_edit_event.

  DATA:
    ls_uibb_hier  LIKE LINE OF mt_uibb_hier,
    lt_uibb_key   TYPE fpm_t_uibb_id,
    ls_uibb_key   LIKE LINE OF lt_uibb_key,
    ls_root       LIKE ls_uibb_key,
    ls_config_key TYPE wdy_config_key.

  FIELD-SYMBOLS:
    <ls_uibb_key> LIKE LINE OF lt_uibb_key.


*----- only relevant in global read-only mode
  IF mo_fpm->get_edit_mode( abap_true ) <> if_fpm_constants=>gc_edit_mode-read_only.
    RETURN.
  ENDIF.

*----- only local edit events
  IF io_event->mv_event_id = if_fpm_constants=>gc_event-local_edit
  OR io_event->mv_is_implicit_edit = abap_true.

*----- start condition
    ls_uibb_hier-parent_component = io_event->ms_source_uibb-component.
    ls_uibb_hier-parent_config_key-config_id = io_event->ms_source_uibb-config_id.
    ls_uibb_hier-parent_config_key-config_type = io_event->ms_source_uibb-config_type.
    ls_uibb_hier-parent_config_key-config_var = io_event->ms_source_uibb-config_var.
    ls_uibb_hier-parent_instance_id = io_event->ms_source_uibb-instance_id.
    ls_uibb_hier-parent_interface_view = io_event->ms_source_uibb-interface_view.
    ls_uibb_hier-parent_config_key = convert_config_key(
      is_config_key = ls_uibb_hier-parent_config_key
      iv_instance_id = ls_uibb_hier-parent_instance_id
      iv_to_adapted = abap_true ).

*----- get root
    DO.
      READ TABLE mt_uibb_hier
        WITH KEY
          child_component = ls_uibb_hier-parent_component
          child_config_key = ls_uibb_hier-parent_config_key
          child_instance_id = ls_uibb_hier-parent_instance_id
          child_interface_view = ls_uibb_hier-parent_interface_view
        INTO ls_uibb_hier.
      IF sy-subrc <> 0.
        EXIT.
      ENDIF.
    ENDDO.

    ls_uibb_key-component = ls_uibb_hier-parent_component.
    ls_uibb_key-config_key = ls_uibb_hier-parent_config_key.
    ls_uibb_key-instance_id = ls_uibb_hier-parent_instance_id.
    ls_uibb_key-window_name = ls_uibb_hier-parent_interface_view.
    APPEND ls_uibb_key TO lt_uibb_key.
    ls_root = ls_uibb_key.
  ENDIF.

*----- only local edit events of if at least one uibb is in edit mode
  IF io_event->mv_event_id = if_fpm_constants=>gc_event-local_edit
  OR io_event->mv_is_implicit_edit = abap_true
  OR io_event->mv_event_id <> if_fpm_constants=>gc_event-edit
  AND mo_fpm->get_edit_mode( abap_false ) = if_fpm_constants=>gc_edit_mode-edit.

*----- set all (new!) children of editable composites in edit mode if necessary
    LOOP AT mt_uibb_hier INTO ls_uibb_hier.
      ls_uibb_key-component = ls_uibb_hier-parent_component.
      ls_uibb_key-config_key = ls_uibb_hier-parent_config_key.
      ls_uibb_key-instance_id = ls_uibb_hier-parent_instance_id.
      ls_uibb_key-window_name = ls_uibb_hier-parent_interface_view.

*----- either local edit event root children or children of uibbs in edit mode
      IF ls_uibb_key <> ls_root.

*----- check edit state with unadapted config key
        ls_uibb_key-config_key = convert_config_key(
          is_config_key = ls_uibb_key-config_key
          iv_instance_id = ls_uibb_key-instance_id
          iv_to_adapted = abap_false ).
        CHECK mo_fpm->if_fpm~get_uibb_edit_mode(
          is_uibb_instance_key = ls_uibb_key-instance_key
          iv_window_name = ls_uibb_key-window_name ) = if_fpm_constants=>gc_edit_mode-edit.
      ENDIF.
      ls_uibb_key-component = ls_uibb_hier-child_component.
      ls_uibb_key-config_key = ls_uibb_hier-child_config_key.
      ls_uibb_key-instance_id = ls_uibb_hier-child_instance_id.
      ls_uibb_key-window_name = ls_uibb_hier-child_interface_view.

*----- check edit state with unadapted config key
      ls_config_key = ls_uibb_key-config_key.
      ls_uibb_key-config_key = convert_config_key(
        is_config_key = ls_uibb_key-config_key
        iv_instance_id = ls_uibb_key-instance_id
        iv_to_adapted = abap_false ).
      CHECK mo_fpm->if_fpm~get_uibb_edit_mode(
        is_uibb_instance_key = ls_uibb_key-instance_key
        iv_window_name = ls_uibb_key-window_name ) <> if_fpm_constants=>gc_edit_mode-edit.

*----- store adapted keys of edit mode newcomers (where condition below!)
      ls_uibb_key-config_key = ls_config_key.
      APPEND ls_uibb_key TO lt_uibb_key.
    ENDLOOP.
    SORT lt_uibb_key.
    DELETE ADJACENT DUPLICATES FROM lt_uibb_key.

*----- collect all descendants ( deep nesting )
    LOOP AT lt_uibb_key ASSIGNING <ls_uibb_key>.
      LOOP AT mt_uibb_hier INTO ls_uibb_hier
        WHERE parent_component = <ls_uibb_key>-component
          AND parent_config_key = <ls_uibb_key>-config_key
          AND parent_instance_id = <ls_uibb_key>-instance_id
          AND parent_interface_view = <ls_uibb_key>-window_name.
        ls_uibb_key-component = ls_uibb_hier-child_component.
        ls_uibb_key-config_key = ls_uibb_hier-child_config_key.
        ls_uibb_key-instance_id = ls_uibb_hier-child_instance_id.
        ls_uibb_key-window_name = ls_uibb_hier-child_interface_view.

*----- check edit state with unadapted config key
        ls_config_key = ls_uibb_key-config_key.
        ls_uibb_key-config_key = convert_config_key(
          is_config_key = ls_uibb_key-config_key
          iv_instance_id = ls_uibb_key-instance_id
          iv_to_adapted = abap_false ).

*------ avoid duplicates
        READ TABLE lt_uibb_key BINARY SEARCH TRANSPORTING NO FIELDS
          WITH KEY
            table_line = ls_uibb_key.
        CHECK sy-subrc <> 0.

        CHECK mo_fpm->if_fpm~get_uibb_edit_mode(
          is_uibb_instance_key = ls_uibb_key-instance_key
          iv_window_name = ls_uibb_key-window_name ) <> if_fpm_constants=>gc_edit_mode-edit.

*----- store adapted keys of edit mode newcomers (where condition above!)
        ls_uibb_key-config_key = ls_config_key.
        APPEND ls_uibb_key TO lt_uibb_key.
      ENDLOOP.

*----- finally convert back to unadapted keys
      CHECK mo_fpm->if_fpm~mo_adaptation_manager IS BOUND.
      <ls_uibb_key>-config_key = convert_config_key(
        is_config_key = <ls_uibb_key>-config_key
        iv_instance_id = <ls_uibb_key>-instance_id
        iv_to_adapted = abap_false ).
    ENDLOOP.
  ENDIF.

*----- only local edit events
  IF io_event->mv_event_id = if_fpm_constants=>gc_event-local_edit
  OR io_event->mv_is_implicit_edit = abap_true.

*----- only need the others
    DELETE lt_uibb_key
     WHERE component   = io_event->ms_source_uibb-component
       AND config_id   = io_event->ms_source_uibb-config_id
       AND config_type = io_event->ms_source_uibb-config_type
       AND config_var  = io_event->ms_source_uibb-config_var
       AND instance_id = io_event->ms_source_uibb-instance_id
       AND window_name = io_event->ms_source_uibb-interface_view.
  ENDIF.

*----- attach table of descendants to event
  io_event->mo_event_data->set_value(
    iv_key = cl_fpm_event=>gc_event_param_comp_desc
    iv_value = lt_uibb_key ).

ENDMETHOD.


METHOD forward_wdevent_flp_navigation.


  DATA(lo_flp_navigation) = CAST cl_fpm_flp_navigation( mo_fpm->if_fpm~get_flp_navigation( ) ).
  lo_flp_navigation->forward_result_event( io_wd_event = io_wd_event ).


ENDMETHOD.


METHOD get_active_window.


  READ TABLE mt_window_stack INTO ro_window INDEX lines( mt_window_stack ).


ENDMETHOD.


METHOD get_app_hierarchy_button_attr.


  DATA:
    lo_pers_manager TYPE REF TO if_wd_personalization.

  DATA:
    lv_is_expert_mode TYPE abap_bool VALUE abap_false.


* Initialize exporting parameters
  ev_visibility = cl_wd_uielement=>e_visible-none.
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.

* Determine application hierarchy button text, tooltip, and visibility
  IF ev_visibility IS SUPPLIED OR
     ev_text       IS SUPPLIED OR
     ev_tooltip    IS SUPPLIED.
    IF mo_component IS BOUND.
      lo_pers_manager = mo_component->get_personalization_manager( ).
      cl_fpm_config_editor=>display_editor_link( EXPORTING io_pers_manager   = lo_pers_manager
                                                 IMPORTING ev_is_expert_mode = lv_is_expert_mode ).
    ENDIF.
    IF ev_visibility IS SUPPLIED.
      IF lv_is_expert_mode = abap_true AND cl_uics_feature=>is_s4h_cloud( ) EQ abap_false.
        ev_visibility = cl_wd_uielement=>e_visible-visible.
      ELSE.
        ev_visibility = cl_wd_uielement=>e_visible-none.
      ENDIF.
    ENDIF.
    IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
      ev_text    = get_floorplan_texts( iv_text_id = 'APP_HIERARCHY' ).
      ev_tooltip = ev_text.
    ENDIF.
  ENDIF.

* Determine image
  ev_image = if_fpm_constants_internal=>gc_image-multiple_node.


ENDMETHOD.


METHOD get_composite_uibbs.


  DATA:
    lo_usage TYPE REF TO if_wd_component_usage,
    lr_uibb  TYPE REF TO data.

  DATA:
    lt_uibb_child                LIKE ct_uibb,
    lt_uibb_hier                 LIKE mt_uibb_hier,
    lt_non_composite_uibb        LIKE ct_uibb,
    lt_collapsed_composite_uibb  LIKE ct_uibb,
    lt_collapsed_uibb_hier       LIKE mt_uibb_hier,
    lts_collapsed_composite_uibb LIKE lt_collapsed_composite_uibb,
    lts_collapsed_uibb_hier      TYPE SORTED TABLE OF s_uibb_hier
                                      WITH UNIQUE KEY child_component child_interface_view child_config_key child_instance_id,
    lts_uibb_key_hiearchy_level  TYPE SORTED TABLE OF cl_fpm_event=>ty_s_uibb_key
                                      WITH UNIQUE KEY component interface_view config_id config_type config_var instance_id,
    lts_uibb_key_parent          LIKE lts_uibb_key_hiearchy_level.

  DATA:
    ls_uibb_key                 TYPE fpm_s_uibb_config_key,
    ls_collapsed_composite_uibb LIKE LINE OF lt_collapsed_composite_uibb.

  DATA:
    lv_is_stretched               TYPE boole_d,
    lv_tabix                      LIKE sy-tabix,
    lv_is_relevant_for_event_loop TYPE abap_bool,
    lv_top_most_parent_uibb_found TYPE abap_bool.

  FIELD-SYMBOLS:
    <ls_uibb_ext>       LIKE LINE OF ct_uibb,
    <ls_uibb_ext_child> LIKE LINE OF lt_uibb_child,
    <ls_collapsed_uibb> LIKE LINE OF lt_collapsed_composite_uibb,
    <ls_uibb_hier>      LIKE LINE OF mt_uibb_hier,
    <ls_uibb>           LIKE LINE OF mt_uibbs.


* Initialize exporting parameters
  rv_is_stretched = abap_false.

* In the global table of all (up to now) processed UIBBs, clear the indicator that shows whether a UIBB is involved in the
* current event loop
  LOOP AT mt_uibbs ASSIGNING <ls_uibb>.
    <ls_uibb>-within_current_event = abap_false.
  ENDLOOP.

* In the global hierarchy table of all (up to now) processed composite UIBBs parent-child relations, clear the indicator
* that shows whether a UIBB is involved in the current event loop
  LOOP AT mt_uibb_hier ASSIGNING <ls_uibb_hier>.
    <ls_uibb_hier>-within_current_event = abap_false.
  ENDLOOP.

* Process current UIBBs; determine composite UIBBs and add their child UIBBs
  LOOP AT ct_uibb ASSIGNING <ls_uibb_ext>.
    READ TABLE mt_uibbs ASSIGNING <ls_uibb>
                        WITH KEY component   = <ls_uibb_ext>-component
                                 config_key  = <ls_uibb_ext>-config_key
                                 instance_id = <ls_uibb_ext>-instance_id.
    IF sy-subrc <> 0.
*     Create new entry in the global table of processed UIBBs
      CREATE DATA lr_uibb LIKE <ls_uibb>.
      ASSIGN lr_uibb->* TO <ls_uibb>.
      <ls_uibb>-component    = <ls_uibb_ext>-component.
      <ls_uibb>-config_key   = <ls_uibb_ext>-config_key.
      <ls_uibb>-instance_id  = <ls_uibb_ext>-instance_id.
      <ls_uibb>-is_composite = cl_fpm_utils=>is_composite_uibb( iv_component_name = <ls_uibb>-component ).
      APPEND <ls_uibb> TO mt_uibbs ASSIGNING <ls_uibb>.
    ENDIF.
*   Mark UIBB as involved in the current event loop
    <ls_uibb>-within_current_event = abap_true.
*   Process special logic in the case that the current UIBB is a composite UIBBs
    IF <ls_uibb>-is_composite = abap_true.
*     The currently processed UIBB is a composite UIBB
*     Delete the current parent-child relations for the current composite UIBB from the global composite UIBB hierarchy table
      DELETE mt_uibb_hier WHERE parent_component      = <ls_uibb_ext>-component      AND
                                parent_interface_view = <ls_uibb_ext>-interface_view AND
                                parent_config_key     = <ls_uibb_ext>-config_key     AND
                                parent_instance_id    = <ls_uibb_ext>-instance_id.
*     Determine the new child UIBBs for the current composite UIBB
      CLEAR lo_usage.
      mo_fpm->if_fpm~attach_component_to_usage( EXPORTING iv_component_name  = <ls_uibb>-component
                                                          is_config_key      = <ls_uibb>-config_key
                                                          iv_instance_id     = <ls_uibb>-instance_id
                                                          io_component_usage = lo_usage ).
      <ls_uibb>-interface ?= mo_fpm->mo_component_manager->get_component_interface( iv_component_name = <ls_uibb>-component
                                                                                    is_config_key     = <ls_uibb>-config_key
                                                                                    iv_instance_id    = <ls_uibb>-instance_id ).
      CLEAR lt_uibb_child.
      <ls_uibb>-interface->get_uibbs( EXPORTING co_event = io_event
                                      IMPORTING et_uibb  = lt_uibb_child ).
*     Build a local UIBB hierarchy table with the parent-child relations for the current composite UIBB;
*     in addition, adapt the child UIBB table and determine whether there is at least one child UIBB for which the
*     stretching indicator is set)
      CLEAR lt_uibb_hier.
      lv_is_stretched = abap_false.
      LOOP AT lt_uibb_child ASSIGNING <ls_uibb_ext_child>.
*       ... adapt hidden state of the child UIBBs according to its parent, if the child UIBB is not maximized
        IF <ls_uibb_ext>-hidden <> if_fpm_constants=>gc_hidden-not_hidden.
          ls_uibb_key = mo_fpm->if_fpm~get_maximized_uibb( ).
          IF ls_uibb_key-component      <> <ls_uibb_ext_child>-component      OR
             ls_uibb_key-interface_view <> <ls_uibb_ext_child>-interface_view OR
             ls_uibb_key-config_key     <> <ls_uibb_ext_child>-config_key     OR
             ls_uibb_key-instance_id    <> <ls_uibb_ext_child>-instance_id.
            <ls_uibb_ext_child>-hidden = <ls_uibb_ext>-hidden.
          ENDIF.
        ENDIF.
*       ... adapt the collapsed state of the child UIBB according to its parent
        IF <ls_uibb_ext>-collapsed = abap_true.
          <ls_uibb_ext_child>-collapsed = <ls_uibb_ext>-collapsed.
        ENDIF.
*       ... add parent-child relation to the local UIBB hierarchy table for the current composite UIBB
        APPEND INITIAL LINE TO lt_uibb_hier ASSIGNING <ls_uibb_hier>.
        <ls_uibb_hier>-parent_component       = <ls_uibb_ext>-component.
        <ls_uibb_hier>-parent_interface_view  = <ls_uibb_ext>-interface_view.
        <ls_uibb_hier>-parent_config_key      = <ls_uibb_ext>-config_key.
        <ls_uibb_hier>-parent_instance_id     = <ls_uibb_ext>-instance_id.
        <ls_uibb_hier>-child_component        = <ls_uibb_ext_child>-component.
        <ls_uibb_hier>-child_interface_view   = <ls_uibb_ext_child>-interface_view.
        <ls_uibb_hier>-child_config_key       = <ls_uibb_ext_child>-config_key.
        <ls_uibb_hier>-child_instance_id      = <ls_uibb_ext_child>-instance_id.
        <ls_uibb_hier>-child_needs_stretching = <ls_uibb_ext_child>-needs_stretching.
        <ls_uibb_hier>-within_current_event   = abap_true.
        IF <ls_uibb_hier>-child_needs_stretching = if_fpm_constants=>gc_stretching-needed.
          lv_is_stretched = abap_true.
        ENDIF.
      ENDLOOP.
*     Set the stretching indicators in the parent hierarchy of the current composite UIBB in the global UIBB hierarchy table
*     if there is at least one child UIBB for which the stretching indicator is set;
*     in addition, determine the returning parameter for strething
      IF lv_is_stretched = abap_true.
        rv_is_stretched = abap_true.
        CLEAR ls_uibb_key.
        MOVE-CORRESPONDING <ls_uibb_ext>            TO ls_uibb_key.
        MOVE-CORRESPONDING <ls_uibb_ext>-config_key TO ls_uibb_key.
        DO.
          READ TABLE mt_uibb_hier
                     ASSIGNING <ls_uibb_hier>
                     WITH KEY child_component              = ls_uibb_key-component
                              child_interface_view         = ls_uibb_key-interface_view
                              child_config_key-config_id   = ls_uibb_key-config_id
                              child_config_key-config_type = ls_uibb_key-config_type
                              child_config_key-config_var  = ls_uibb_key-config_var
                              child_instance_id            = ls_uibb_key-instance_id
                              within_current_event         = abap_true.
          IF sy-subrc = 0.
            <ls_uibb_hier>-child_needs_stretching = if_fpm_constants=>gc_stretching-needed.
            CLEAR ls_uibb_key.
            ls_uibb_key-component      = <ls_uibb_hier>-parent_component.
            ls_uibb_key-interface_view = <ls_uibb_hier>-parent_interface_view.
            ls_uibb_key-config_id      = <ls_uibb_hier>-parent_config_key.
            ls_uibb_key-instance_id    = <ls_uibb_hier>-parent_instance_id.
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.
      ENDIF.
*     Append the child UIBBs of the current composite UIBB to the table of UIBBs which are relevant in the current event loop
*     (these child UIBBs will be processed later in the surrounding LOOP)
      APPEND LINES OF lt_uibb_child TO ct_uibb.
*     Append the local UIBB hierarchy table for the current composite UIBB to the global UIBB hierarchy table
      APPEND LINES OF lt_uibb_hier TO mt_uibb_hier.
*     If lazy load is active, store the current composite UIBB in a local table LT_COLLAPSED_COMPOSITE_UIBB if it is collapsed
*     or if its parent is already in that local table (the latter is the case if the top-most parent composite UIBB of the
*     current composite UIBB is collapsed); additionally, store the parent-child relations of the current composite UIBB in a
*     local hierarchy table LT_COLLAPSED_UIBB_HIER (for collapsed composite UIBBs and their child hierarchies) in this case.
*     In the end, the local table LT_COLLAPSED_COMPOSITE_UIBB contains collapsed composite UIBBs or composite UIBBs with a
*     collapsed top-most parent composite UIBB. The local hierarchy table LT_COLLAPSED_UIBB_HIER can theoretically contain the
*     following parent-child relations, disregarding the fact that only the top-most parent UIBB can currently have a collapsed
*     state in the OVP:
*       1) Entries with a collapsed parent composite UIBB:
*       - collapsed composite UIBB - collapsed composite UIBB             (the entries where the composite child UIBB has no relevant children and is not a wire source will be deleted later in line 370)
*       - collapsed composite UIBB - non-collapsed composite UIBB         (the entries where the composite child UIBB has no relevant children and is not a wire source will be deleted later in line 370)
*       - collapsed composite UIBB - collapsed non-composite UIBB         (the entries where the non-composite child UIBB is not a wire source will be deleted later in line 235)
*       - collapsed composite UIBB - non-collapsed non-composite UIBB     (the entries where the non-composite child UIBB is not a wire source will be deleted later in line 235)
*       2) Entries with a non-collapsed direct parent composite UIBB but with a collapsed top-most parent composite UIBB:
*       - non-collapsed composite UIBB - collapsed composite UIBB         (the entries where the composite child UIBB has no relevant children and is not a wire source will be deleted later in line 370)
*       - non-collapsed composite UIBB - non-collapsed composite UIBB     (the entries where the composite child UIBB has no relevant children and is not a wire source will be deleted later in line 370)
*       - non-collapsed composite UIBB - collapsed non-composite UIBB     (the entries where the non-composite child UIBB is not a wire source will be deleted later in line 235)
*       - non-collapsed composite UIBB - non-collapsed non-composite UIBB (the entries where the non-composite child UIBB is not a wire source will be deleted later in line 235)
      IF iv_collapsed_uibb_proc_mode = if_fpm_constants=>gc_collapsed_uibb_proc_mode-defer_participation.
        READ TABLE lt_collapsed_uibb_hier
                   TRANSPORTING NO FIELDS
                   WITH KEY child_component      = <ls_uibb_ext>-component
                            child_interface_view = <ls_uibb_ext>-interface_view
                            child_config_key     = <ls_uibb_ext>-config_key
                            child_instance_id    = <ls_uibb_ext>-instance_id
                            within_current_event = abap_true.
        IF sy-subrc = 0 OR <ls_uibb_ext>-collapsed = abap_true.
          APPEND <ls_uibb_ext> TO lt_collapsed_composite_uibb.
          APPEND LINES OF lt_uibb_hier TO lt_collapsed_uibb_hier.
        ENDIF.
      ENDIF.
    ELSE.
*     The currently processed UIBB is a non-composite UIBB; store it in a local table of non-composite UIBBs
      IF iv_collapsed_uibb_proc_mode = if_fpm_constants=>gc_collapsed_uibb_proc_mode-defer_participation.
        APPEND <ls_uibb_ext> TO lt_non_composite_uibb.
      ENDIF.
    ENDIF.
  ENDLOOP.

* Forward local edit event to composite descendants
  forward_local_edit_event( io_event ).

* Return in the case that lazy loading is not active
  IF iv_collapsed_uibb_proc_mode <> if_fpm_constants=>gc_collapsed_uibb_proc_mode-defer_participation.
    RETURN.
  ENDIF.

* ----- Lazy Load Handling -------------------------------------------------------------------------------------

* Step 1:
* For non-composite UIBBs, determine whether they are relevant for the event loop at all.
* If not, delete them from the changing table CT_UIBB.
* A non-composite UIBB is relevant for the event loop if
*  - lazy load is not active, i.e. the processing mode for collapsed UIBBs is not set to 'D', or
*  - the UIBB is expanded and not a child of a collapsed parent composite UIBB, or
*  - the UIBB is a wire source
  LOOP AT lt_non_composite_uibb ASSIGNING <ls_uibb_ext>.
    lv_is_relevant_for_event_loop = abap_true.
    READ TABLE lt_collapsed_uibb_hier
               ASSIGNING <ls_uibb_hier>
               WITH KEY child_component      = <ls_uibb_ext>-component
                        child_interface_view = <ls_uibb_ext>-interface_view
                        child_config_key     = <ls_uibb_ext>-config_key
                        child_instance_id    = <ls_uibb_ext>-instance_id
                        within_current_event = abap_true.
    IF sy-subrc = 0.
*     The non-composite UIBB is a child of a collapsed parent or of a collapsed top-most parent composite UIBB;
*     check whether it is a wire source
      lv_tabix = sy-tabix.
      IF mo_fpm->is_wire_source( <ls_uibb_ext> ) = abap_false.
*       The non-composite UIBB is not a wire source and therefore not relevant for the event loop;
*       delete its local parent relation
        lv_is_relevant_for_event_loop = abap_false.
        DELETE lt_collapsed_uibb_hier INDEX lv_tabix.
      ENDIF.
    ELSEIF <ls_uibb_ext>-collapsed = abap_true.
*     The non-composite UIBB is collapsed and either no child UIBB or a child of a non-collapsed top-most parent composite UIBB;
*     check whether it is a wire source
      IF mo_fpm->is_wire_source( <ls_uibb_ext> ) = abap_false.
*       The non-composite UIBB is not a wire source and therefore not relevant for the event loop
        lv_is_relevant_for_event_loop = abap_false.
      ENDIF.
    ENDIF.
*   If the non-composite UIBB is not relevant for the event loop delete it from table CT_UIBB
    IF lv_is_relevant_for_event_loop = abap_false.
      READ TABLE ct_uibb
                 TRANSPORTING NO FIELDS
                 WITH KEY table_line = <ls_uibb_ext>.
      CHECK sy-subrc = 0.
      lv_tabix = sy-tabix.
      DELETE ct_uibb INDEX lv_tabix.
*     Adapt indicator in the global UIBB table whether the UIBB is relevant for the event loop
      READ TABLE mt_uibbs
                 ASSIGNING <ls_uibb>
                 WITH KEY component   = <ls_uibb_ext>-component
                          config_key  = <ls_uibb_ext>-config_key
                          instance_id = <ls_uibb_ext>-instance_id.
      IF sy-subrc = 0.
        <ls_uibb>-within_current_event = abap_false.
      ENDIF.
    ENDIF.
  ENDLOOP.

* Step 2:
* For the final processing, the composite UIBBs in the local table LT_COLLAPSED_COMPOSITE_UIBB must be processed
* in a reverse order regarding their hierarchy level because the composite UIBB hierarchy in the local table
* LT_COLLAPSED_UIBB_HIER must be evaluated level-wise from the leafs to the root. Therefore, sort the table
* LT_COLLAPSED_COMPOSITE_UIBB now appropriately, based on the hierarchy information in LT_COLLAPSED_UIBB_HIER.
* However, in the special case that LT_COLLAPSED_UIBB_HIER is empty the order of the composite UIBBs in the
* table LT_COLLAPSED_COMPOSITE_UIBB doesn't matter.
  IF lt_collapsed_uibb_hier IS INITIAL.
    lts_collapsed_composite_uibb = lt_collapsed_composite_uibb.
  ELSE.
    lts_collapsed_uibb_hier = lt_collapsed_uibb_hier.
    CLEAR lts_collapsed_composite_uibb.
    DO.
*     Process next composite UIBB hierarchy level; exit if there is no composite UIBB anymore to be processed
      IF lines( lt_collapsed_composite_uibb ) = 0.
        EXIT.
      ENDIF.
*     Determine all composite UIBBs that are top-most parents currently in the local table LT_COLLAPSED_COMPOSITE UIBB
*     of composite UIBBs and append them to the local sorted table of composite UIBBs LTS_COLLAPSED_COMPOSITE UIBB.
*     (In principle, all composite UIBBs of the same top-level in the current hierarchy are determined)
      CLEAR lts_uibb_key_hiearchy_level. "Clear top-most parent composite UIBBs of currently processed hierarchy level
      CLEAR lts_uibb_key_parent.
      LOOP AT lt_collapsed_composite_uibb ASSIGNING <ls_collapsed_uibb>.
*       Determine new top-most parent composite UIBB
        lv_top_most_parent_uibb_found = abap_false.
        CLEAR ls_uibb_key.
        MOVE-CORRESPONDING <ls_collapsed_uibb> TO ls_uibb_key.
        MOVE-CORRESPONDING <ls_collapsed_uibb>-config_key TO ls_uibb_key.
        DO.
*         If a top-most parent composite UIBB of the currently processed hierarchy level was found delete it from the
*         local table of composite UIBBs and insert it into the to the sorted local table of composite UIBBs;
*         in addition, store this top-most parent composite UIBB of the currently processed hierarchy level
          IF lv_top_most_parent_uibb_found = abap_true.
            READ TABLE lt_collapsed_composite_uibb
                       INTO ls_collapsed_composite_uibb
                       WITH KEY component      = ls_uibb_key-component
                                interface_view = ls_uibb_key-interface_view
                                config_key     = ls_uibb_key-config_key
                                instance_id    = ls_uibb_key-instance_id.
            IF sy-subrc = 0.
              DELETE lt_collapsed_composite_uibb INDEX sy-tabix.
              INSERT ls_collapsed_composite_uibb INTO lts_collapsed_composite_uibb INDEX 1.
              INSERT ls_uibb_key INTO TABLE lts_uibb_key_hiearchy_level.
            ENDIF.
          ENDIF.
*         Exit in the case that the current parent composite UIBB was already processed;
*         otherwise append the current parent composite UIBB to the temporary table of already processed UIBBs
          READ TABLE lts_uibb_key_parent
                     TRANSPORTING NO FIELDS
                     WITH TABLE KEY table_line = ls_uibb_key.
          IF sy-subrc = 0.
            EXIT.
          ELSE.
            INSERT ls_uibb_key INTO TABLE lts_uibb_key_parent.
          ENDIF.
*         Exit in the case that the top-most parent composite UIBB was found
          IF lv_top_most_parent_uibb_found = abap_true.
            EXIT.
          ENDIF.
*         Determine parent UIBB
          READ TABLE lts_collapsed_uibb_hier
                     ASSIGNING <ls_uibb_hier>
                     WITH TABLE KEY child_component      = ls_uibb_key-component
                                    child_interface_view = ls_uibb_key-interface_view
                                    child_config_key     = ls_uibb_key-config_key
                                    child_instance_id    = ls_uibb_key-instance_id.
          IF sy-subrc = 0.
            CLEAR ls_uibb_key.
            ls_uibb_key-component      = <ls_uibb_hier>-parent_component.
            ls_uibb_key-interface_view = <ls_uibb_hier>-parent_interface_view.
            ls_uibb_key-config_key     = <ls_uibb_hier>-parent_config_key.
            ls_uibb_key-instance_id    = <ls_uibb_hier>-parent_instance_id.
          ELSE.
            lv_top_most_parent_uibb_found = abap_true.
          ENDIF.
        ENDDO.
      ENDLOOP.
*     Delete child relations of all top-most parent composite UIBBs of the currently processed hierarchy level from the
*     sorted local composite UIBB hierarchy table LTS_COLLAPSED_COMPOSITE_UIBB
      LOOP AT lts_collapsed_uibb_hier ASSIGNING <ls_uibb_hier>.
        READ TABLE lts_uibb_key_hiearchy_level
                   TRANSPORTING NO FIELDS
                   WITH TABLE KEY component      = <ls_uibb_hier>-parent_component
                                  interface_view = <ls_uibb_hier>-parent_interface_view
                                  config_id      = <ls_uibb_hier>-parent_config_key-config_id
                                  config_type    = <ls_uibb_hier>-parent_config_key-config_type
                                  config_var     = <ls_uibb_hier>-parent_config_key-config_var
                                  instance_id    = <ls_uibb_hier>-parent_instance_id.
        IF sy-subrc = 0.
          DELETE lts_collapsed_uibb_hier.
        ENDIF.
      ENDLOOP.
    ENDDO.
  ENDIF.

* Step 3:
* Ensure that the table CT_UIBB of UIBBs that are relevant for the event loop does not contain collapsed composite UIBBs
* without any relevant children. For this, delete all entries from the local UIBB hierarchy table LT_COLLAPSED_UIBB_HIER
* (for collapsed composite UIBBs and their child hierarchies) where the child UIBB is a composite UIBB that is not a wire
* source and has no relevant child UIBBs; delete those composite UIBBs from the table CT_UIBB since they are not relevant
* for the event loop.
* (Please note that, if a child UIBB of a composite UIBB is a wire source, the composite UIBB itself needs not to be
*  a wire source as well, technically, but it should be processed in the event loop in order to be on the safe side)
  LOOP AT lts_collapsed_composite_uibb ASSIGNING <ls_collapsed_uibb>.
    READ TABLE lt_collapsed_uibb_hier
               TRANSPORTING NO FIELDS
               WITH KEY parent_component      = <ls_collapsed_uibb>-component
                        parent_interface_view = <ls_collapsed_uibb>-interface_view
                        parent_config_key     = <ls_collapsed_uibb>-config_key
                        parent_instance_id    = <ls_collapsed_uibb>-instance_id.
    CHECK sy-subrc <> 0. "composite UIBB must not have children that are relevant for the event loop
    CHECK mo_fpm->is_wire_source( <ls_collapsed_uibb> ) = abap_false. "composite UIBB must not be a wire source
*   The composite UIBB has no relevant child UIBBs and is not a wire source;
*   its parent relation is therefore not relevant and can be deleted;
    DELETE lt_collapsed_uibb_hier
           WHERE child_component      = <ls_collapsed_uibb>-component      AND
                 child_interface_view = <ls_collapsed_uibb>-interface_view AND
                 child_config_key     = <ls_collapsed_uibb>-config_key     AND
                 child_instance_id    = <ls_collapsed_uibb>-instance_id.
*   The composite UIBB is not relevant for the event loop -> delete it from table CT_UIBB
    READ TABLE ct_uibb
               TRANSPORTING NO FIELDS
               WITH KEY table_line = <ls_collapsed_uibb>.
    CHECK sy-subrc = 0.
    lv_tabix = sy-tabix.
    DELETE ct_uibb INDEX lv_tabix.
*   Adapt indicator in the global UIBB and global composite hierarchy table whether the UIBB is relevant for the event loop
    READ TABLE mt_uibbs
               ASSIGNING <ls_uibb>
               WITH KEY component   = <ls_collapsed_uibb>-component
                        config_key  = <ls_collapsed_uibb>-config_key
                        instance_id = <ls_collapsed_uibb>-instance_id.
    IF sy-subrc = 0.
      <ls_uibb>-within_current_event = abap_false.
    ENDIF.
    READ TABLE mt_uibb_hier
               ASSIGNING <ls_uibb_hier>
               WITH KEY child_component      = <ls_collapsed_uibb>-component
                        child_config_key     = <ls_collapsed_uibb>-config_key
                        child_instance_id    = <ls_collapsed_uibb>-instance_id
                        within_current_event = abap_true.
    IF sy-subrc = 0.
      <ls_uibb_hier>-within_current_event = abap_false.
    ENDIF.
  ENDLOOP.


ENDMETHOD.


METHOD get_configure_button_attr.


  DATA:
    lo_pers_manager TYPE REF TO if_wd_personalization.

  DATA:
    lv_is_admin_mode  TYPE abap_bool VALUE abap_false,
    lv_is_expert_mode TYPE abap_bool VALUE abap_false.


* Initialize exporting parameters
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.

* Determine configure/ customize button text and tooltip
  IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
    IF mo_component IS BOUND.
      lo_pers_manager = mo_component->get_personalization_manager( ).
      cl_fpm_config_editor=>display_editor_link( EXPORTING io_pers_manager   = lo_pers_manager
                                                 IMPORTING ev_is_admin_mode  = lv_is_admin_mode
                                                           ev_is_expert_mode = lv_is_expert_mode ).
    ENDIF.
    IF lv_is_admin_mode = abap_true.
      ev_text = get_floorplan_texts( iv_text_id = 'CUSTOMIZE' ).
    ELSEIF lv_is_expert_mode = abap_true.
      ev_text = get_floorplan_texts( iv_text_id = 'CONFIGURE' ).
    ENDIF.
    ev_tooltip = ev_text.
  ENDIF.

* Determine configure/ customize button image
  ev_image = if_fpm_constants_internal=>gc_image-tb_settings.


ENDMETHOD.


METHOD get_configure_page_button_attr.


  DATA:
    lo_pers_manager TYPE REF TO if_wd_personalization.

  DATA:
    lv_is_admin_mode  TYPE abap_bool VALUE abap_false,
    lv_is_expert_mode TYPE abap_bool VALUE abap_false.


* Initialize exporting parameters
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.
  ev_visibility = cl_wd_uielement=>e_visible-none.

* Determine configure/ customize page button text, tooltip, and visibility
  IF ev_visibility IS SUPPLIED OR
     ev_text       IS SUPPLIED OR
     ev_tooltip    IS SUPPLIED.
    IF mo_component IS BOUND.
      lo_pers_manager = mo_component->get_personalization_manager( ).
      cl_fpm_config_editor=>display_editor_link( EXPORTING io_pers_manager   = lo_pers_manager
                                                 IMPORTING ev_is_admin_mode  = lv_is_admin_mode
                                                           ev_is_expert_mode = lv_is_expert_mode ).
    ENDIF.
    IF ev_visibility IS SUPPLIED.
      IF lv_is_admin_mode = abap_true OR lv_is_expert_mode = abap_true.
        ev_visibility = cl_wd_uielement=>e_visible-visible.
      ELSE.
        ev_visibility = cl_wd_uielement=>e_visible-none.
      ENDIF.
    ENDIF.
    IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
      IF lv_is_admin_mode = abap_true.
        ev_text = get_floorplan_texts( iv_text_id = 'CUSTOMIZE_PAGE' ).
      ELSEIF lv_is_expert_mode = abap_true.
        ev_text = get_floorplan_texts( iv_text_id = 'CONFIGURE_PAGE' ).
      ENDIF.
      ev_tooltip = ev_text.
    ENDIF.
  ENDIF.

* Determine configure/ customize page button image
  ev_image = if_fpm_constants_internal=>gc_image-tb_settings.


ENDMETHOD.


METHOD get_config_msg_area_settings.


  DATA:
    lo_nd_application_settings TYPE REF TO if_fpm_node,
    lo_el_application_settings TYPE REF TO if_fpm_element.


* Initialize exporting parameters
  CLEAR: ev_maximum_messages_size,
         ev_message_area_design,
         ev_message_area_display.
  ev_show_message_log       = abap_false.
  ev_condense_identical_msg = abap_false.

  lo_nd_application_settings = io_fpm_node_root->get_child_node( name = if_fpm_constants_internal=>gc_nodes-application_settings ).
  IF lo_nd_application_settings IS NOT BOUND.
    RETURN.
  ENDIF.
  lo_el_application_settings = lo_nd_application_settings->get_element(  ).
  IF lo_el_application_settings IS NOT BOUND.
    RETURN.
  ENDIF.

* Get maximum messages size
  IF ev_maximum_messages_size IS SUPPLIED.
    lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-maximum_messages_size
                                               IMPORTING value = ev_maximum_messages_size ).
  ENDIF.

* Get show message log indicator
  IF ev_show_message_log IS SUPPLIED.
    lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-show_message_log
                                               IMPORTING value = ev_show_message_log ).
  ENDIF.

* Get message area design
  IF ev_message_area_design IS SUPPLIED.
    lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-fpm_message_area_design
                                               IMPORTING value = ev_message_area_design ).
  ENDIF.

* Get message area display
  IF ev_message_area_display IS SUPPLIED.
    lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-fpm_message_area_display
                                               IMPORTING value = ev_message_area_display ).
  ENDIF.

* Get condense identical messages
  IF ev_condense_identical_msg IS SUPPLIED.
    lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-condense_identical_msg
                                               IMPORTING value = ev_condense_identical_msg ).
  ENDIF.


ENDMETHOD.


METHOD get_config_msg_mapper_settings.


  DATA:
    lo_nd_msg_mapper_settings TYPE REF TO if_fpm_node,
    lo_el_msg_mapper_settings TYPE REF TO if_fpm_element.


  lo_nd_msg_mapper_settings = io_fpm_node_root->get_child_node( name = if_fpm_constants_internal=>gc_nodes-msg_mapper_setting ).
  IF lo_nd_msg_mapper_settings IS NOT BOUND.
    RETURN.
  ENDIF.
  lo_el_msg_mapper_settings = lo_nd_msg_mapper_settings->get_element(  ).
  IF lo_el_msg_mapper_settings IS NOT BOUND.
    RETURN.
  ENDIF.

  lo_el_msg_mapper_settings->get_attributes( IMPORTING attributes = rs_config_msg_mapper_settings ).


ENDMETHOD.


METHOD get_embedment_level.

* This method returns the embedding level of a UIBB:
* 2: UIBB embedded directly in floorplan configuration
* 3: UIBB embedded directly in a composite UIBB,
*    which is embedded directly in a floorplan configuration
* 4: UIBB which is embedded in a composite, which is embedded in a composite,
*    which is embedded in the floorplan
* ...


  rv_level = 2.

  DATA(ls_max_uibb) = mo_fpm->if_fpm~get_maximized_uibb( ).

  IF is_uibb_id-component   = ls_max_uibb-component      AND
     is_uibb_id-window_name = ls_max_uibb-interface_view AND
     is_uibb_id-config_key  = ls_max_uibb-config_key     AND
     is_uibb_id-instance_id = ls_max_uibb-instance_id.
    RETURN.
  ENDIF.

  DATA(ls_child) = is_uibb_id.
  DO.
    READ TABLE mt_uibb_hier
               ASSIGNING FIELD-SYMBOL(<ls_uibb_hier>)
               WITH KEY child_component       = ls_child-component
                        child_interface_view  = ls_child-window_name
                        child_config_key      = ls_child-config_key
                        child_instance_id     = ls_child-instance_id.
    IF sy-subrc = 0 AND <ls_uibb_hier> IS NOT INITIAL.
      rv_level = rv_level + 1.
      IF <ls_uibb_hier>-parent_component      = ls_max_uibb-component      AND
         <ls_uibb_hier>-parent_interface_view = ls_max_uibb-interface_view AND
         <ls_uibb_hier>-parent_config_key     = ls_max_uibb-config_key     AND
         <ls_uibb_hier>-parent_instance_id    = ls_max_uibb-instance_id.
*       The parent UIBB is the maximized UIBB
        EXIT.
      ENDIF.
      ls_child-component   = <ls_uibb_hier>-parent_component.
      ls_child-window_name = <ls_uibb_hier>-parent_interface_view.
      ls_child-config_key  = <ls_uibb_hier>-parent_config_key.
      ls_child-instance_id = <ls_uibb_hier>-parent_instance_id.
    ELSE.
*     No further parent
      EXIT.
    ENDIF.
  ENDDO.


ENDMETHOD.


METHOD GET_EXT_NAV_ACTION_NAME.


  CASE iv_ext_navigation_category.
    WHEN if_fpm_constants=>gc_external_navigation_categ-related_links OR
         if_fpm_constants=>gc_external_navigation_categ-you_can_also.
      rv_action_name = if_fpm_constants_internal=>gc_wd_action-external_navigation.
    WHEN OTHERS.
      ASSERT CONDITION 0 = 1.
  ENDCASE.


ENDMETHOD.


METHOD GET_EXT_NAV_MENUS_FROM_CTXT.


* Initialize exporting parameters
  CLEAR et_ext_navigation.

  RETURN.


ENDMETHOD.


METHOD get_floorplan_application_node.


  DATA:
    lo_wd_context_root_node TYPE REF TO if_wd_context_node.

  DATA:
    lv_node_name TYPE string.


* Initialize returning parameter
  CLEAR ro_nd_application.

* Ensure that context node can be determined
  ASSERT mo_component IS BOUND.

* Get root node of WD context
  lo_wd_context_root_node = mo_component->get_context( )->root_node.
  ASSERT lo_wd_context_root_node IS BOUND.

* Get name of application context node of floorplan component
  lv_node_name = get_node_name_application( ).
  ASSERT lv_node_name IS NOT INITIAL.

* Get application context node of floorplan component
  ro_nd_application = lo_wd_context_root_node->get_child_node( name = lv_node_name ).


ENDMETHOD.


METHOD get_floorplan_texts.


  CASE iv_text_id.
    WHEN 'APP_HIERARCHY'.
      r_text = text-113.
    WHEN 'APPLICATION_HELP'.
      r_text = text-207.
    WHEN 'CONFIGURE'.
      r_text = text-117.
    WHEN 'CONFIGURE_PAGE'.
      r_text = text-111.
    WHEN 'CREATE_SUPPORT_MESSAGE'.
      r_text = text-205.
    WHEN 'CUSTOMIZE'.
      r_text = text-118.
    WHEN 'CUSTOMIZE_PAGE'.
      r_text = text-114.
    WHEN 'DISPLAY_QUICK_HELP'.
      r_text = text-203.
    WHEN 'HELP'.
      r_text = text-201.
    WHEN 'HELP_CENTER'.
      r_text = text-202.
    WHEN 'HIDE_CONFIGURABLE_AREAS'.
      r_text = text-109.
    WHEN 'HIDE_CUSTOMIZABLE_AREAS'.
      r_text = text-116.
    WHEN 'HIDE_QUICK_HELP'.
      r_text = text-204.
    WHEN 'PAGE_HEADER_TOOLBAR'.
      r_text = text-301.
    WHEN 'PAGE_FOOTER_TOOLBAR'.
      r_text = text-302.
    WHEN 'PERSONALIZE'.
      r_text = text-112.
    WHEN 'PRINT'.
      r_text = text-119.
    WHEN 'SETTINGS'.
      r_text = cl_wd_utilities=>get_otr_text_by_alias( alias = 'APB_FPM_CORE/PERSONALIZE').
    WHEN 'SHOW_CONFIGURABLE_AREAS'.
      r_text = text-110.
    WHEN 'SHOW_CUSTOMIZABLE_AREAS'.
      r_text = text-115.
    WHEN OTHERS.
      CLEAR r_text.
      RETURN.
  ENDCASE.


ENDMETHOD.


METHOD get_help_button_attr.


* Initialize exporting parameters
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.

* Determine quick help mode text and tooltip
  IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
    ev_text    = get_floorplan_texts( iv_text_id = 'HELP' ).
    ev_tooltip = ev_text.
  ENDIF.

* Determine quick help mode image
  ev_image = if_fpm_constants_internal=>gc_image-help.


ENDMETHOD.


METHOD get_hide_message_area.


  DATA:
    lt_parameter_keys TYPE if_fpm_parameter=>t_keys.


* Initialize returning parameter
  rv_hide_message_area = abap_false.

* Determine visibility of message area from Application/ URL parameter
  IF mo_fpm IS BOUND.
    lt_parameter_keys = mo_fpm->if_fpm~mo_app_parameter->get_keys( ).
    READ TABLE lt_parameter_keys
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-hide_message_area.
    IF sy-subrc = 0.
*     Visibility of message area set via Application/ URL parameter
      mo_fpm->if_fpm~mo_app_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-hide_message_area
                                                  IMPORTING ev_value = rv_hide_message_area ).
      RETURN.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD get_logoff_on_close.


  DATA:
    lo_fpm_nd_root             TYPE REF TO if_fpm_node,
    lo_fpm_el_root             TYPE REF TO if_fpm_element,
    lo_nd_info_root            TYPE REF TO if_wd_context_node_info,
    lo_nd_application_settings TYPE REF TO if_fpm_node,
    lo_el_application_settings TYPE REF TO if_fpm_element.


* Initialize returning parameter
  CLEAR rv_logoff_on_close.

* Determine from configuration
  lo_fpm_nd_root = me->mo_floorplan_data->get_fpm_root_node( ).
  IF lo_fpm_nd_root IS NOT BOUND.
    RETURN.
  ENDIF.
  lo_fpm_el_root = lo_fpm_nd_root->get_element( ).
  IF lo_fpm_el_root IS NOT BOUND.
    RETURN.
  ENDIF.
  lo_nd_info_root = lo_fpm_nd_root->get_ref_wd_context_node( )->get_node_info( ).
  IF lo_nd_info_root IS NOT BOUND.
    RETURN.
  ENDIF.
  IF lo_nd_info_root->has_attribute( name = if_fpm_constants=>gc_app_params-logoff_on_close ) = abap_true.
    lo_fpm_el_root->get_attribute( EXPORTING name  = if_fpm_constants=>gc_app_params-logoff_on_close
                                   IMPORTING value = rv_logoff_on_close ).
  ELSE.
    lo_nd_application_settings = lo_fpm_el_root->get_child_node( if_fpm_constants_internal=>gc_nodes-application_settings ).
    IF lo_nd_application_settings IS NOT BOUND.
      RETURN.
    ENDIF.
    lo_el_application_settings = lo_nd_application_settings->get_element( ).
    IF lo_el_application_settings IS NOT BOUND.
      RETURN.
    ENDIF.
    lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants=>gc_app_params-logoff_on_close
                                               IMPORTING value = rv_logoff_on_close ).
  ENDIF.


ENDMETHOD.


METHOD get_msg_area_settings.


  DATA:
    lo_parameter TYPE REF TO if_fpm_parameter.

  DATA:
    lt_parameter_key TYPE if_fpm_parameter=>t_keys.


* Initialize exporting parameters
  CLEAR: ev_maximum_messages_size,
         ev_message_area_design,
         ev_message_area_display.
  ev_show_message_log       = abap_false.
  ev_display_empty_lines    = abap_false.
  ev_condense_identical_msg = abap_false.

  IF io_fpm_node_root IS NOT BOUND.
    RETURN.
  ENDIF.

* Get message mapper settings from floorplan configuration context
  get_config_msg_area_settings( EXPORTING io_fpm_node_root          = io_fpm_node_root
                                IMPORTING ev_maximum_messages_size  = ev_maximum_messages_size
                                          ev_show_message_log       = ev_show_message_log
                                          ev_message_area_design    = ev_message_area_design
                                          ev_message_area_display   = ev_message_area_display
                                          ev_condense_identical_msg = ev_condense_identical_msg ).

* Determine message area settings from application/Url parameters and set new values
  IF mo_fpm IS BOUND.
    lo_parameter = mo_fpm->if_fpm~mo_app_parameter.
  ENDIF.
  IF lo_parameter IS BOUND.
*   Determine message area settings from application/Url parameters
    lt_parameter_key = lo_parameter->get_keys( ).
*   Maximum messages size
    IF ev_maximum_messages_size IS SUPPLIED.
      READ TABLE lt_parameter_key
                 TRANSPORTING NO FIELDS
                 WITH KEY table_line = if_fpm_constants=>gc_app_params-maximum_messages_size.
      IF sy-subrc = 0.
        lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-maximum_messages_size
                                 IMPORTING ev_value = ev_maximum_messages_size ).
      ENDIF.
    ENDIF.
*   Show message log
    IF ev_show_message_log IS SUPPLIED.
      READ TABLE lt_parameter_key
                 TRANSPORTING NO FIELDS
                 WITH KEY table_line = if_fpm_constants=>gc_app_params-show_message_log.
      IF sy-subrc = 0.
        lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-show_message_log
                                 IMPORTING ev_value = ev_show_message_log ).
      ENDIF.
    ENDIF.
*   Display empty lines
    IF ev_display_empty_lines IS SUPPLIED.
      READ TABLE lt_parameter_key
                 TRANSPORTING NO FIELDS
                 WITH KEY table_line = if_fpm_constants=>gc_app_params-message_area_size.
      IF sy-subrc = 0.
        lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-message_area_size
                                 IMPORTING ev_value = ev_display_empty_lines ).
      ENDIF.
    ENDIF.
*   Message area design
    IF ev_message_area_design IS SUPPLIED.
      READ TABLE lt_parameter_key
                 TRANSPORTING NO FIELDS
                 WITH KEY table_line = if_fpm_constants=>gc_app_params-message_area_design.
      IF sy-subrc = 0.
        lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-message_area_design
                                 IMPORTING ev_value = ev_message_area_design ).
      ENDIF.
    ENDIF.
*   Message area display
    IF ev_message_area_display IS SUPPLIED.
      READ TABLE lt_parameter_key
                 TRANSPORTING NO FIELDS
                 WITH KEY table_line = if_fpm_constants=>gc_app_params-message_area_display.
      IF sy-subrc = 0.
        lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-message_area_display
                                 IMPORTING ev_value = ev_message_area_display ).
      ENDIF.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD get_overlay_mode_attr.


  DATA:
    lo_pers_manager TYPE REF TO if_wd_personalization.

  DATA:
    lv_is_admin_mode  TYPE abap_bool VALUE abap_false,
    lv_is_expert_mode TYPE abap_bool VALUE abap_false.


* Initialize exporting parameters
  ev_visibility = cl_wd_uielement=>e_visible-none.
  ev_enabled = abap_false.
  ev_active  = abap_false.
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.

* Determine overlay mode text, tooltip, and visibility
  IF ev_visibility IS SUPPLIED OR
     ev_text       IS SUPPLIED OR
     ev_tooltip    IS SUPPLIED.
    IF mo_component IS BOUND.
      lo_pers_manager = mo_component->get_personalization_manager( ).
      cl_fpm_config_editor=>display_editor_link( EXPORTING io_pers_manager   = lo_pers_manager
                                                 IMPORTING ev_is_admin_mode  = lv_is_admin_mode
                                                           ev_is_expert_mode = lv_is_expert_mode ).
    ENDIF.
    IF ev_visibility IS SUPPLIED.
      IF lv_is_admin_mode = abap_true OR lv_is_expert_mode = abap_true.
        ev_visibility = cl_wd_uielement=>e_visible-visible.
      ELSE.
        ev_visibility = cl_wd_uielement=>e_visible-none.
      ENDIF.
    ENDIF.
    IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
      IF lv_is_admin_mode = abap_true.
        IF mo_fpm IS BOUND AND
           mo_fpm->mv_designtime_mode = abap_true AND
           get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
          ev_text = get_floorplan_texts( iv_text_id = 'HIDE_CUSTOMIZABLE_AREAS' ).
        ELSE.
          ev_text = get_floorplan_texts( iv_text_id = 'SHOW_CUSTOMIZABLE_AREAS' ).
        ENDIF.
      ELSEIF lv_is_expert_mode = abap_true.
        IF mo_fpm IS BOUND AND
           mo_fpm->mv_designtime_mode = abap_true AND
           get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori.
          ev_text = get_floorplan_texts( iv_text_id = 'HIDE_CONFIGURABLE_AREAS' ).
        ELSE.
          ev_text = get_floorplan_texts( iv_text_id = 'SHOW_CONFIGURABLE_AREAS' ).
        ENDIF.
      ENDIF.
      ev_tooltip = ev_text.
    ENDIF.
  ENDIF.

* Determine overlay mode enabled/disabled state
  IF ev_enabled IS SUPPLIED AND mo_fpm IS BOUND.
    ev_enabled = mo_fpm->mv_configurable_uibb_existing.
  ENDIF.

* Determine overlay mode active/inactive state
  IF ev_active IS SUPPLIED AND mo_fpm IS BOUND.
    ev_active = mo_fpm->mv_designtime_mode.
  ENDIF.

* Determine overlay mode image
  ev_image = if_fpm_constants_internal=>gc_image-detailed_settings.


ENDMETHOD.


METHOD get_parent_of_event_src_uibb.


  DATA:
    ls_uibb_key_parent LIKE es_parent_uibb_key,
    ls_uibb_key        LIKE ls_uibb_key_parent,
    ls_config_key      TYPE wdy_config_key,
    ls_config_key_cba  TYPE fpm_s_config_key.

  FIELD-SYMBOLS:
    <ls_uibb_hier>          LIKE LINE OF mt_uibb_hier,
    <ls_uibb>               TYPE any,
    <lv_uibb_key_component> TYPE any.


* Initialize export parameters
  ev_parent_uibb_found = abap_false.
  CLEAR: es_parent_uibb_key,
         ev_parent_uibb_def_detl_page,
         ev_parent_uibb_def_edit_page.

* Return if there is no UIBB key on the FPM event
  IF io_event->ms_source_uibb IS INITIAL.
    RETURN.
  ENDIF.

  ls_uibb_key_parent = io_event->ms_source_uibb.

* Get the context-based adapted UIBB configuration key
  IF me->mo_adaptation_manager IS BOUND.
    CLEAR ls_config_key_cba.
    MOVE-CORRESPONDING ls_uibb_key_parent TO ls_config_key_cba.
    me->mo_adaptation_manager->get_adapted_config_key( EXPORTING is_config_key = ls_config_key_cba
                                                       IMPORTING es_config_key = ls_config_key_cba ).
    IF ls_config_key_cba-config_id = cl_fpm_adapt_manager=>gc_hidden_uibb.
      RETURN.
    ENDIF.
    MOVE-CORRESPONDING ls_config_key_cba TO ls_uibb_key_parent.
  ENDIF.

* Search (first-level) parent UIBB of the UIBB that triggered the event
* in list of composite child UIBBs
  MOVE-CORRESPONDING ls_uibb_key_parent TO ls_config_key.
  DO.
    READ TABLE mt_uibb_hier
               ASSIGNING <ls_uibb_hier>
               WITH KEY child_component      = ls_uibb_key_parent-component
                        child_interface_view = ls_uibb_key_parent-interface_view
                        child_config_key     = ls_config_key
                        child_instance_id    = ls_uibb_key_parent-instance_id
                        within_current_event = abap_true.
    IF sy-subrc <> 0 AND iv_in_current_event_loop_only = abap_false.
      READ TABLE mt_uibb_hier
                 ASSIGNING <ls_uibb_hier>
                 WITH KEY child_component      = ls_uibb_key_parent-component
                          child_interface_view = ls_uibb_key_parent-interface_view
                          child_config_key     = ls_config_key
                          child_instance_id    = ls_uibb_key_parent-instance_id
                          within_current_event = abap_false.
    ENDIF.
    IF sy-subrc = 0.
      CLEAR ls_uibb_key_parent.
      ls_uibb_key_parent-component      = <ls_uibb_hier>-parent_component.
      ls_uibb_key_parent-interface_view = <ls_uibb_hier>-parent_interface_view.
      ls_uibb_key_parent-instance_id    = <ls_uibb_hier>-parent_instance_id.
      ls_config_key                     = <ls_uibb_hier>-parent_config_key.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
  MOVE-CORRESPONDING ls_config_key TO ls_uibb_key_parent.

* Get the context-based unadapted UIBB configuration key
  IF me->mo_adaptation_manager IS BOUND.
    CLEAR ls_config_key_cba.
    MOVE-CORRESPONDING ls_uibb_key_parent TO ls_config_key_cba.
    me->mo_adaptation_manager->get_unadapted_config_key( EXPORTING is_config_key = ls_config_key_cba
                                                         IMPORTING es_config_key = ls_config_key_cba ).
    MOVE-CORRESPONDING ls_config_key_cba TO ls_uibb_key_parent.
  ENDIF.

* Find determined parent UIBB in table of (first-level) UIBBs
  LOOP AT it_uibb ASSIGNING <ls_uibb>.
    CLEAR ls_uibb_key.
*   Get component
    ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-comp
                     OF STRUCTURE <ls_uibb>
                     TO <lv_uibb_key_component>.
    CHECK sy-subrc = 0.
    ls_uibb_key-component = <lv_uibb_key_component>.
*   Get interface view
    ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-intfview
                     OF STRUCTURE <ls_uibb>
                     TO <lv_uibb_key_component>.
    CHECK sy-subrc = 0.
    ls_uibb_key-interface_view = <lv_uibb_key_component>.
*   Get configuration ID
    ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-configid
                     OF STRUCTURE <ls_uibb>
                     TO <lv_uibb_key_component>.
    CHECK sy-subrc = 0.
    ls_uibb_key-config_id = <lv_uibb_key_component>.
*   Get configuration type
    ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-configty
                     OF STRUCTURE <ls_uibb>
                     TO <lv_uibb_key_component>.
    CHECK sy-subrc = 0.
    ls_uibb_key-config_type = <lv_uibb_key_component>.
*   Get configuration variant
    ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-configvar
                     OF STRUCTURE <ls_uibb>
                     TO <lv_uibb_key_component>.
    CHECK sy-subrc = 0.
    ls_uibb_key-config_var = <lv_uibb_key_component>.
*   Get Instance Id
    ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-instance_id
                     OF STRUCTURE <ls_uibb>
                     TO <lv_uibb_key_component>.
    CHECK sy-subrc = 0.
    ls_uibb_key-instance_id = <lv_uibb_key_component>.
*   Return if the event source UIBB is the current UIBB itself
    IF ls_uibb_key = ls_uibb_key_parent.
*     (First-level) parent UIBB of UIBB that triggered the event has been found
      ev_parent_uibb_found = abap_true.
      es_parent_uibb_key   = ls_uibb_key.
      IF ev_parent_uibb_def_detl_page IS SUPPLIED.
        ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-default_details_page
                         OF STRUCTURE <ls_uibb>
                         TO <lv_uibb_key_component>.
        IF sy-subrc = 0.
          ev_parent_uibb_def_detl_page = <lv_uibb_key_component>.
        ENDIF.
      ENDIF.
      IF ev_parent_uibb_def_edit_page IS SUPPLIED.
        ASSIGN COMPONENT if_fpm_constants_internal=>gc_attributes-default_edit_page
                         OF STRUCTURE <ls_uibb>
                         TO <lv_uibb_key_component>.
        IF sy-subrc = 0.
          ev_parent_uibb_def_edit_page = <lv_uibb_key_component>.
        ENDIF.
      ENDIF.
      RETURN.
    ENDIF.
  ENDLOOP.


ENDMETHOD.


METHOD get_print_button_attr.


* Initialize exporting parameters
  ev_visibility = cl_wd_uielement=>e_visible-none.
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.

* Determine print button visibility
  IF ev_visibility IS SUPPLIED.
    IF is_print_enabled( ) = abap_true.
      ev_visibility = cl_wd_uielement=>e_visible-visible.
    ELSE.
      ev_visibility = cl_wd_uielement=>e_visible-none.
    ENDIF.
  ENDIF.

* Determine print button text and tooltip
  IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
    ev_text    = get_floorplan_texts( iv_text_id = 'PRINT' ).
    ev_tooltip = ev_text.
  ENDIF.

* Determine print button image
  ev_image = if_fpm_constants_internal=>gc_image-print.


ENDMETHOD.


METHOD get_quick_help_mode_attr.


  DATA:
    lv_is_quick_help_active TYPE abap_bool VALUE abap_false.


* Initialize exporting parameters
  CLEAR: ev_text,
         ev_tooltip,
         ev_image.

* Determine quick help mode text and tooltip
  IF ev_text IS SUPPLIED OR ev_tooltip IS SUPPLIED.
    IF mo_component IS BOUND.
      lv_is_quick_help_active = mo_component->get_application( )->get_show_explanation( ).
    ENDIF.
    IF lv_is_quick_help_active = abap_true.
      ev_text = get_floorplan_texts( iv_text_id = 'HIDE_QUICK_HELP' ).
    ELSE.
      ev_text = get_floorplan_texts( iv_text_id = 'DISPLAY_QUICK_HELP' ).
    ENDIF.
    ev_tooltip = ev_text.
  ENDIF.

* Determine quick help mode image
  ev_image = if_fpm_constants_internal=>gc_image-help.


ENDMETHOD.


METHOD get_side_panel_link_attr.


* Initialize exporting parameters
  ev_visibility = cl_wd_uielement=>e_visible-none.
  ev_enabled    = abap_false.
  CLEAR: ev_text,
         ev_tooltip.

* Return if there is no side panel integration
  IF mo_chip_integration IS NOT BOUND.
    RETURN.
  ENDIF.

* Check side panel state
  mo_chip_integration->check_side_panel_state( ).

* Determine side panel link attributes
  IF mo_chip_integration->mv_sp_link_active = abap_true.
    ev_visibility = cl_wd_uielement=>e_visible-visible.
    IF mo_chip_integration->mv_sp_open = abap_false.
      ev_enabled = abap_true.
    ENDIF.
  ENDIF.
  ev_text    = mo_chip_integration->mv_sp_link_text.
  ev_tooltip = mo_chip_integration->mv_sp_link_tooltip.


ENDMETHOD.


METHOD get_toolbar_location_type.


  DATA:
    lo_nd_info_root            TYPE REF TO if_wd_context_node_info,
    lo_fpm_nd_root             TYPE REF TO if_fpm_node,
    lo_fpm_el_root             TYPE REF TO if_fpm_element,
    lo_nd_application_settings TYPE REF TO if_fpm_node,
    lo_el_application_settings TYPE REF TO if_fpm_element.


* Initialize returning parameter
  CLEAR rv_toolbar_location_type.

* Determine toolbar location type from application-/url-parameters
  IF mo_fpm IS BOUND.
    READ TABLE mo_fpm->if_fpm~mo_app_parameter->get_keys( )
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-toolbar_location.
    IF sy-subrc = 0.
*     Toolbar location set via Application/ URL parameter
      mo_fpm->if_fpm~mo_app_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-toolbar_location
                                                  IMPORTING ev_value = rv_toolbar_location_type ).
*     Set the toolbar location type appropriately in the case that it is not specified explicitly
      IF rv_toolbar_location_type IS INITIAL.
        rv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-guideline.
      ENDIF.
      RETURN.
    ENDIF.
  ENDIF.

* Determine toolbar location type from configuration
  IF mo_floorplan_data IS BOUND.
    lo_fpm_nd_root = mo_floorplan_data->get_fpm_root_node( ).
    IF lo_fpm_nd_root IS NOT BOUND.
      RETURN.
    ENDIF.
    lo_fpm_el_root = lo_fpm_nd_root->get_element( ).
    IF lo_fpm_el_root IS NOT BOUND.
      RETURN.
    ENDIF.
    lo_nd_info_root = lo_fpm_nd_root->get_ref_wd_context_node( )->get_node_info( ).
    IF lo_nd_info_root IS NOT BOUND.
      RETURN.
    ENDIF.
    IF lo_nd_info_root->has_attribute( name = if_fpm_constants_internal=>gc_attributes-toolbar_location ) = abap_true.
*     OVP: Toolbar location type attribute is on root node
      lo_fpm_el_root->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-toolbar_location
                                     IMPORTING value = rv_toolbar_location_type ).
    ELSE.
*     OIF, GAF: Toolbar location type attribute is on application settings node
      lo_nd_application_settings = lo_fpm_el_root->get_child_node( if_fpm_constants_internal=>gc_nodes-application_settings ).
      IF lo_nd_application_settings IS NOT BOUND.
        RETURN.
      ENDIF.
      lo_el_application_settings = lo_nd_application_settings->get_element( ).
      IF lo_el_application_settings IS NOT BOUND.
        RETURN.
      ENDIF.
      lo_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-toolbar_location
                                                 IMPORTING value = rv_toolbar_location_type ).
    ENDIF.
  ENDIF.

* Set the toolbar location type appropriately in the case that it is not specified explicitly
  IF rv_toolbar_location_type IS INITIAL.
    rv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-guideline.
  ENDIF.


ENDMETHOD.


METHOD get_transient_state.


  DATA:
    lo_fpm_nd_root                 TYPE REF TO if_fpm_node,
    lo_fpm_nd_application_settings TYPE REF TO if_fpm_node,
    lo_fpm_el_application_settings TYPE REF TO if_fpm_element.

  DATA:
    lv_transient_state TYPE fpm_transient_state.


* Initialize returning parameter
  CLEAR rv_transient_state.

  lo_fpm_nd_root = mo_floorplan_data->get_fpm_root_node( ).
  lo_fpm_nd_application_settings = lo_fpm_nd_root->get_child_node( name = if_fpm_constants_internal=>gc_nodes-application_settings ).
  lo_fpm_el_application_settings = lo_fpm_nd_application_settings->get_element(  ).
  lo_fpm_el_application_settings->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-transient_state
                                                 IMPORTING value = lv_transient_state ).
  CASE lv_transient_state.
    WHEN ''. "Initial as this might be the older schema before EhP1.
      rv_transient_state = if_fpm_constants_internal=>gc_transient_non_transient.
    WHEN if_fpm_constants_internal=>gc_transient_non_transient.
      rv_transient_state = if_fpm_constants_internal=>gc_transient_non_transient.
    WHEN if_fpm_constants_internal=>gc_transient_transient.
      rv_transient_state = if_fpm_constants_internal=>gc_transient_transient.
    WHEN OTHERS. "Treated as non-transient, too
      rv_transient_state = if_fpm_constants_internal=>gc_transient_non_transient.
  ENDCASE.


ENDMETHOD.


METHOD get_ui_element_id_for_ext_nav.


  RETURN.


ENDMETHOD.


METHOD get_ui_guideline_version.

  IF mv_ui_guideline_version_extern IS NOT INITIAL.
    rv_ui_guideline_version = mv_ui_guideline_version_extern.
    RETURN.
  ENDIF.

  IF mo_fpm IS BOUND.
    rv_ui_guideline_version = mo_fpm->mv_guideline.
  ELSE. "FLUID
    rv_ui_guideline_version = if_fpm_constants_internal=>gc_guideline_version-fiori.
  ENDIF.

ENDMETHOD.


METHOD get_work_protect_mode.


  DATA:
    lt_parameter_keys TYPE if_fpm_parameter=>t_keys.


* Initialize returning parameter
  rv_work_protect_mode = abap_false.

* Determine work protect mode from Application/ URL parameter
  IF mo_fpm IS BOUND.
    lt_parameter_keys = mo_fpm->if_fpm~mo_app_parameter->get_keys( ).
    READ TABLE lt_parameter_keys
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-work_protect_mode.
    IF sy-subrc = 0.
*     Work protect mode set via Application/ URL parameter
      mo_fpm->if_fpm~mo_app_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-work_protect_mode
                                                  IMPORTING ev_value = rv_work_protect_mode  ).
      RETURN.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD handle_app_params.


* Get work protect mode
  IF mo_fpm IS BOUND.
    mo_fpm->mv_work_protect_mode = get_work_protect_mode( ).
  ENDIF.

* Get logoff on save
  mv_logoff_on_close = get_logoff_on_close( ).

* Get toolbar location
  mv_toolbar_location_type = get_toolbar_location_type( ).

* Get multi-stretching indicator
  mv_is_multi_stretched = is_multi_stretched( ).

* Set message mapper settings
  set_msg_mapper_settings( mo_floorplan_data->get_fpm_root_node( ) ).

* Get message area settings
  get_msg_area_settings( EXPORTING io_fpm_node_root         = mo_floorplan_data->get_fpm_root_node( )
                         IMPORTING ev_maximum_messages_size = mv_maximum_messages_size
                                   ev_message_area_design   = mv_message_area_design "might be changed later in method SET_MSG_AREA_DISPLAY_ATTR
                                   ev_show_message_log      = mv_show_message_log ).

* Get visibility of message area
  mv_hide_message_area = get_hide_message_area( ).


ENDMETHOD.


METHOD handle_error.


  DATA:
    lo_error_details TYPE REF TO if_fpm_error_details.

  DATA:
    ls_t100 TYPE symsg.


  ls_t100-msgid = iv_msgid.
  ls_t100-msgno = iv_msgno.

  cl_fpm_error_factory=>create_from_t100(
    EXPORTING
      is_t100           = ls_t100
    RECEIVING
       ro_error_details = lo_error_details ).

  mo_fpm->if_fpm~display_error_page(
    EXPORTING
      io_error_details = lo_error_details ).


ENDMETHOD.


METHOD handle_url_params.


  DATA:
    lo_parameter_url TYPE REF TO if_fpm_parameter,
    lo_parameter_app TYPE REF TO if_fpm_parameter.

  DATA:
    lt_keys TYPE if_fpm_parameter=>t_keys.

  DATA:
    lv_key   LIKE LINE OF lt_keys,
    lv_value TYPE string.


  lo_parameter_app = mo_fpm->if_fpm~mo_app_parameter.
  lo_parameter_url = cl_fpm_parameter=>create_by_wdevent( io_event ).

* Mix static app parameters with URL parameters
  lt_keys = lo_parameter_url->get_keys( ).
  LOOP AT lt_keys INTO lv_key.
    lo_parameter_url->get_value( EXPORTING iv_key   = lv_key
                                 IMPORTING ev_value = lv_value ).
    lo_parameter_app->set_value( iv_key   = lv_key
                                 iv_value = lv_value ).
  ENDLOOP.
  IF sy-subrc = 0.
    lo_parameter_app->set_value( iv_key   = if_fpm_constants=>gc_app_params-url_parameter
                                 iv_value = lo_parameter_url ).
  ENDIF.

* Process FPM application parameters
  handle_app_params( ).


ENDMETHOD.


METHOD initialize_adaptation_handling.


* Determine adaptation schema
  DATA lo_nd_config_data TYPE REF TO if_wd_context_node.
  DATA lo_el_config_data TYPE REF TO if_wd_context_element.
  DATA lv_schema TYPE fpm_adaptation_schema.
  DATA: lv_floorplan TYPE fpm_floorplan,
        lv_string    TYPE string.


  lv_string = io_component->get_component_info( )->get_name( ).
  lv_floorplan = lv_string+14.

* navigate from <CONTEXT> to <CONFIG_DATA> via lead selection
  lo_nd_config_data = io_context->get_child_node( name = 'CONFIG_DATA' ).
  lo_el_config_data = lo_nd_config_data->get_element( ).

* get single attribute
  lo_el_config_data->get_attribute(
    EXPORTING
      name =  `SCHEMA`
    IMPORTING
      value = lv_schema ).

  IF NOT lv_schema IS INITIAL.
*   No schema => no adaptations => skip adaptation handling

*   initialize adaptation manager
    CREATE OBJECT mo_adaptation_manager
      EXPORTING
        iv_schema_id = lv_schema.

*   Determine application parameters
    DATA: lo_application_api  TYPE REF TO if_wd_application,
          lo_application_info TYPE REF TO if_wd_rr_application.

    lo_application_api  = io_component->get_application( ).
    lo_application_info = lo_application_api->get_application_info( ).

    DATA: lt_app_params TYPE wdrr_application_parameters.
    lt_app_params = lo_application_info->get_application_parameters( ).

*   add device type
    TRY.
        DATA: lv_device_type TYPE fpm_device_type.
        lv_device_type = io_component->get_application( )->get_client_information( )->get_device_type( ).
        DATA: ls_app_params LIKE LINE OF lt_app_params.
        ls_app_params-name = if_fpm_constants=>gc_app_params-device_type.
        ls_app_params-value = lv_device_type.
        APPEND ls_app_params TO lt_app_params.
      CATCH cx_wdr_client_inspector ##NO_HANDLER.

    ENDTRY.
*   inform adaptation manager about initial context
    mo_adaptation_manager->set_context_from_app_params( it_app_params = lt_app_params io_component = io_component ).

  ENDIF.

* try to find original floorplan configuration
  DATA: lo_pers TYPE REF TO if_wd_personalization.
  lo_pers = io_component->get_personalization_manager( ).
  DATA: lt_variants TYPE wdr_pers_variants.
  lv_string = lv_floorplan.
  lt_variants = lo_pers->get_variants_for_subcomponent( subcomponent_usage = lv_string ).

* check for adapted configuration
  DATA: ls_key_adapted  TYPE fpm_s_config_key,
        ls_conf_adapted TYPE wdy_config_key,
        ls_key_orig     TYPE fpm_s_config_key.

  FIELD-SYMBOLS: <fs_variant> LIKE LINE OF lt_variants.
  READ TABLE lt_variants ASSIGNING <fs_variant> INDEX 1.

  IF sy-subrc = 0.
    MOVE-CORRESPONDING <fs_variant> TO ls_key_orig.
    IF mo_adaptation_manager IS BOUND.
      mo_adaptation_manager->get_adapted_config_key(
                    EXPORTING is_config_key = ls_key_orig
                    IMPORTING es_config_key = ls_key_adapted ).

      MOVE-CORRESPONDING ls_key_adapted TO ls_conf_adapted.
    ELSE.
      MOVE-CORRESPONDING ls_key_orig TO ls_conf_adapted.
    ENDIF.
  ENDIF.

  CONCATENATE 'FPM_' lv_floorplan '_COMPONENT' INTO lv_string.
  io_usage->create_component(
                 component_name = lv_string
                 configuration_id = ls_conf_adapted
                 assistance_class = me ).


ENDMETHOD.


METHOD initialize_app_cc.


  DATA:
    lo_nd_application     TYPE REF TO if_wd_context_node,
    lo_nd_app_specific_cc TYPE REF TO if_wd_context_node,
    lo_el_app_specific_cc TYPE REF TO if_wd_context_element,
    lo_component_info     TYPE REF TO if_wd_rr_component,
    lo_usage_group        TYPE REF TO if_wd_component_usage_group,
    lo_class_descr        TYPE REF TO cl_abap_classdescr.

  DATA:
    lt_child           TYPE wdr_context_child_info_map,
    lt_interface_names TYPE string_table,
    lt_intf            TYPE abap_intfdescr_tab.

  DATA:
    ls_app_specific_cc TYPE fpm_s_uibb_instance_key,
    ls_runtime_info    TYPE fpm_s_runtime_info,
    ls_config_key      TYPE wdy_config_key.

  DATA:
    lv_intf_name          TYPE string,
    lv_component_name     TYPE string,
    lv_comp               TYPE wdy_component_name,
    lv_app_cc_initialized TYPE abap_bool,
    lv_classname          TYPE seoclsname.


* Initialize returning parameter
  CLEAR ro_app_cc_usage.

* Ensure that the AppCC can be initialized
  ASSERT mo_fpm IS BOUND.

* Get context node for floorplan application
  lo_nd_application = get_floorplan_application_node( ).
  IF lo_nd_application IS NOT BOUND.
    RETURN.
  ENDIF.

* Check whether context node for AppCC exists
* (This check must be done because otherwise it would dump, e.g. in the case of the UCW that does not have this node)
  lt_child = lo_nd_application->get_node_info( )->get_child_nodes( ).
  READ TABLE lt_child
             TRANSPORTING NO FIELDS
             WITH TABLE KEY name = if_fpm_constants_internal=>gc_nodes-app_specific_cc.
  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

* Get context node for AppCC
  lo_nd_app_specific_cc = lo_nd_application->get_child_node( name = if_fpm_constants_internal=>gc_nodes-app_specific_cc ).
  IF lo_nd_app_specific_cc IS NOT BOUND.
    RETURN.
  ENDIF.

* Get context element for AppCC
  lo_el_app_specific_cc = lo_nd_app_specific_cc->get_element(  ).
  IF lo_el_app_specific_cc IS NOT BOUND.
    RETURN.
  ENDIF.

* Get AppCC key from context
  lo_el_app_specific_cc->get_static_attributes( IMPORTING static_attributes = ls_app_specific_cc ).
  IF ls_app_specific_cc IS INITIAL.
    RETURN.
  ENDIF.

* Get runtime information
  ls_runtime_info = mo_fpm->if_fpm~get_runtime_info( ).

* Determine AppCC interface name for the floorplan
  CONCATENATE 'IF_FPM_' ls_runtime_info-floorplan '_CONF_EXIT' INTO lv_intf_name.
  CONDENSE lv_intf_name NO-GAPS.

* Check whether AppCC component exists
  MOVE-CORRESPONDING ls_app_specific_cc TO ls_config_key.
  lv_component_name = ls_app_specific_cc-component.
  lv_comp = lv_component_name.
  IF cl_wdy_md_component=>check_existency( name   = lv_comp
                                           active = 'X' ) = abap_true.
*   Check whether the component that is stored in IS_APP_SPECIFIC_CC (derived from floorplan configuration) implements the AppCC interface
    lo_component_info = mo_component->get_component_info( ).
    lt_interface_names = lo_component_info->get_impl_interfaces_for_cmp( component_name = lv_component_name ).
    READ TABLE lt_interface_names
               TRANSPORTING NO FIELDS
               WITH KEY table_line = lv_intf_name.
    IF sy-subrc = 0.
*     AppCC is a real AppCC
      lo_usage_group = mo_component->create_cmp_usage_group( name            = 'APP_CC_USAGES'
                                                             used_component  = lv_intf_name ).
      ro_app_cc_usage = lo_usage_group->add_component_usage( 'APP_CC_USAGE' ).
      lv_app_cc_initialized = abap_true.
    ENDIF.
  ENDIF.

* Check whether AppCC is just an Application Controller or whether it is an ABAP OO class
  IF lv_app_cc_initialized = abap_false.
    READ TABLE lt_interface_names
               TRANSPORTING NO FIELDS
               WITH KEY table_line = 'IF_FPM_APP_CONTROLLER'.
    IF sy-subrc = 0.
*     AppCC is only Application Controller
    ELSE.
*     lv_component_name is no valid WD component => maybe it's a valid ABAP OO class
      lv_classname = lv_component_name.
      cl_abap_classdescr=>describe_by_name(
        EXPORTING
          p_name         =  lv_classname
        RECEIVING
          p_descr_ref    =  DATA(lo_descr)
        EXCEPTIONS
          type_not_found = 1
          OTHERS         = 2 ).
      IF sy-subrc = 0.
*       AppCC is a valid ABAP OO class
        lo_class_descr ?= lo_descr.
      ELSE.
*       AppCC entry is invalid
        mo_fpm->if_fpm~mo_message_manager->report_t100_message( EXPORTING iv_msgid       = if_fpm_constants_internal=>gc_message_id-core
                                                                          iv_msgno       = '303'
                                                                          io_component   = me
                                                                          iv_parameter_1 = |{ lv_classname }|
                                                                          iv_parameter_2 = |{ lv_intf_name }| ).
        CLEAR lv_component_name.
      ENDIF.
      IF lo_class_descr IS BOUND.
        lt_intf = lo_class_descr->interfaces.
        READ TABLE lt_intf
                   TRANSPORTING NO FIELDS
                   WITH TABLE KEY name = lv_intf_name.      "#EC WARNOK
        IF sy-subrc <> 0.
          READ TABLE lt_intf
                     TRANSPORTING NO FIELDS
                     WITH TABLE KEY name = 'IF_FPM_APP_CONTROLLER'.
        ENDIF.
        IF sy-subrc = 0.
*         AppCC class is a real AppCC or an Application Controller (calls to it have to be delegated through a generic FPM AppCC component)
          lv_component_name = 'FPM_GENERIC_APP_CC'.
          CLEAR ls_config_key.
          lo_usage_group = mo_component->create_cmp_usage_group( name            = 'APP_CC_USAGES'
                                                                 used_component  = lv_intf_name ).
          ro_app_cc_usage = lo_usage_group->add_component_usage( 'APP_CC_USAGE' ).
        ELSE.
*         AppCC class does not implement the relevant FPM interfaces
          CLEAR lv_component_name.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

* Attach AppC component
  IF lv_component_name IS NOT INITIAL.
    mo_fpm->mo_component_manager->attach_component_to_usage( iv_component_name  = lv_component_name
                                                             is_config_key      = ls_config_key
                                                             io_component_usage = ro_app_cc_usage
                                                             iv_appcc_oo_class  = lv_classname ).
  ENDIF.


ENDMETHOD.


METHOD initialize_app_parameters.


  DATA:
    lo_application_api  TYPE REF TO if_wd_application,
    lo_application_info TYPE REF TO if_wd_rr_application,
    lo_fpm_parameter    TYPE REF TO cl_fpm_parameter.

  DATA:
    lt_application_parameter TYPE wdrr_application_parameters.

  FIELD-SYMBOLS:
    <ls_application_parameter> LIKE LINE OF lt_application_parameter.


* Ensure that the FPM application parameters can be initialized
  ASSERT mo_fpm IS BOUND AND mo_component IS BOUND.

* Get WD application parameters
  lo_application_api       = mo_component->get_application( ).
  lo_application_info      = lo_application_api->get_application_info( ).
  lt_application_parameter = lo_application_info->get_application_parameters( ).

* Create FPM application parameter object
  CREATE OBJECT lo_fpm_parameter.

* Copy WD application parameters to FPM application parameter object
  LOOP AT lt_application_parameter ASSIGNING <ls_application_parameter>.
    lo_fpm_parameter->if_fpm_parameter~set_value( iv_key   = <ls_application_parameter>-name
                                                  iv_value = <ls_application_parameter>-value ).
  ENDLOOP.

* Store FPM application parameter object
  mo_fpm->set_app_parameter( lo_fpm_parameter ).


ENDMETHOD.


METHOD initialize_chip_integration.


* Ensure that the chip integration (side panel) can be initialized
  ASSERT mo_floorplan_data IS BOUND.

* Initialize chip integration (side panel)
  CREATE OBJECT mo_chip_integration
    EXPORTING
      io_context_node = mo_floorplan_data->get_context_root_node( )->get_context( )->root_node.


ENDMETHOD.


METHOD initialize_conf_comp_usage.


  DATA:
    lo_nd_application     TYPE REF TO if_wd_context_node,
    lo_nd_conf_comp_usage TYPE REF TO if_wd_context_node,
    lo_conf_comp_usage    TYPE REF TO cl_fpm_uibb_conf_comp_usage.


* Ensure that the configuration component usage can be intialized
  ASSERT mo_fpm IS BOUND.

* Get context node for floorplan application
  lo_nd_application = get_floorplan_application_node( ).
  IF lo_nd_application IS NOT BOUND.
    RETURN.
  ENDIF.

* Get context node for configuration component usage
  lo_nd_conf_comp_usage = lo_nd_application->get_child_node( name = if_fpm_constants_internal=>gc_nodes-conf_comp_usage ).
  IF lo_nd_application IS NOT BOUND.
    RETURN.
  ENDIF.

* Initialize configurable component usages
  CREATE OBJECT lo_conf_comp_usage.
  lo_conf_comp_usage->if_fpm_uibb_conf_comp_usage~set_conf_comp_usage_node( lo_nd_conf_comp_usage ).
  mo_fpm->set_conf_comp_usage( lo_conf_comp_usage ).


ENDMETHOD.


METHOD initialize_context_manager.


  DATA:
    lo_wd_context_node TYPE REF TO if_wd_context_node.


* Determine relevant WD context node
  IF io_wd_context_node IS BOUND.
    lo_wd_context_node = io_wd_context_node.
  ELSE.
    lo_wd_context_node = get_floorplan_application_node( ).
  ENDIF.
  ASSERT lo_wd_context_node IS BOUND.

* Copy WD configuration context to an FPM specific context by means of the FPM Context Manager
  CREATE OBJECT mo_floorplan_data
    EXPORTING
      io_wd_context_root_node = lo_wd_context_node.

* Store FPM Context Manager reference in the WD context in order to enable wiring
  IF lo_wd_context_node->get_context( )->root_node->get_node_info( )->has_attribute( name = if_fpm_constants_internal=>gc_attributes-floorplan_data_ref ).
    lo_wd_context_node->get_context( )->root_node->set_attribute( name  = if_fpm_constants_internal=>gc_attributes-floorplan_data_ref
                                                                  value = mo_floorplan_data ).
  ENDIF.


ENDMETHOD.


METHOD initialize_feedlet_connector.

* Ensure that the feedlet connector can be initialized
  ASSERT mo_fpm IS BOUND.

* Instanciate feedlet connector
  CREATE OBJECT mo_feedlet_connector
    EXPORTING
      io_fpm            = mo_fpm
      io_floorplan_data = mo_floorplan_data.

ENDMETHOD.


METHOD initialize_floorplan.


* Initialize exporting parameters
  CLEAR: eo_fpm,
         eo_fpm_floorplan_runtime_api,
         eo_fpm_runtime_info_object,
         eo_app_cc_usage,
         eo_empty_component_usage_group,
         es_idr_uibb_key_adapted.
  ev_is_valid_configuration = abap_false.

* Ensure that importing data is provided
  ASSERT io_floorplan_component IS BOUND AND io_floorplan_comp_controller IS BOUND.

* Store floorplan component
  mo_component = io_floorplan_component.

* Initialize FPM context manager
  initialize_context_manager( ).

* Initialize FPM runtime
  eo_fpm = initialize_fpm_runtime( io_floorplan_comp_controller = io_floorplan_comp_controller ).

* Initialize application parameters
  initialize_app_parameters( ).

* Initialize FPM Runtime Analysis Tool (RAT)
* (This must be done before any RAT data can be traced, in particular before the floorplan runtime API
*  or AppCC is used)
  initialize_rat( ).

* Initialize chip integration (side panel)
  initialize_chip_integration( ).

* Initialize instance styling
  initialize_instance_styling( ).

* Initialize feedlet connector
  initialize_feedlet_connector( ).

* Initialize floorplan runtime API
  eo_fpm_floorplan_runtime_api = initialize_runtime_api( ).

* Initialize floorplan runtime info object
* (This should (but needs not to) be done after the application parameters have been initialized.
*  The application parameters are just required in order to get the correct client environment in
*  the FPM runtime info object. The FPM runtime info object itself is used to get the floorplan
*  runtime info object. However, the client environment is not necessary for the latter)
  eo_fpm_runtime_info_object = initialize_runtime_info_object( ).

* Initialize message manager
  initialize_message_manager( ).

* Initialize configurable component
  initialize_conf_comp_usage( ).

* Create usage group for empty components
  eo_empty_component_usage_group = mo_component->create_cmp_usage_group( name           = 'EMTPY_USAGES'
                                                                         used_component = if_fpm_constants_internal=>gc_components-empty_comp ).

* Initialize IDR
  es_idr_uibb_key_adapted = initialize_idr( io_wd_component_usage = io_idr_component_usage ).

* Initialize AppCC
  eo_app_cc_usage = initialize_app_cc( ).

* Check whether valid configuration ID has been provided
  IF ev_is_valid_configuration IS SUPPLIED.
    ev_is_valid_configuration = is_valid_configuration( ).
  ENDIF.


ENDMETHOD.


METHOD initialize_floorplan_handler.


  RETURN.


ENDMETHOD.


METHOD initialize_fpm_runtime.


  DATA:
    lo_floorplan_internal TYPE REF TO cl_fpm_floorplan_internal.


* Instanciate handler for communication between FPM runtime and floorplan component
  lo_floorplan_internal = initialize_floorplan_handler( EXPORTING io_floorplan_comp_controller = io_floorplan_comp_controller ).
  ASSERT lo_floorplan_internal IS BOUND.

* Create FPM runtime
  CREATE OBJECT mo_fpm
    EXPORTING
      io_floorplan          = lo_floorplan_internal
      io_adaptation_manager = mo_adaptation_manager.

* Forward FPM runtime instance to floorplan communication handler
  lo_floorplan_internal->set_fpm_instance( mo_fpm ).

* Return FPM runtime instance
  ro_fpm = mo_fpm.


ENDMETHOD.


METHOD initialize_idr.


  RETURN.


ENDMETHOD.


METHOD initialize_instance_styling.


* Ensure that instance styling can be initialized
  IF mo_component IS NOT BOUND.
    RETURN.
  ENDIF.

* Instanciate instance style manager
  DATA(lo_application) = mo_component->get_application( ).
  mo_instance_style_manager = cl_fpm_instance_style_manager=>get_instance( lo_application ).


ENDMETHOD.


METHOD initialize_message_manager.


  DATA:
    lo_usage_group        TYPE REF TO if_wd_component_usage_group,
    lo_message_area_usage TYPE REF TO if_wd_component_usage,
    lo_multi_inst         TYPE REF TO iwci_if_fpm_multi_instantiable.


* Ensure that message manager can be initialized
  ASSERT mo_component IS BOUND.

* Create message manager
  lo_usage_group = mo_component->create_cmp_usage_group( name           = 'MESSAGE_AREA_USAGES'
                                                         used_component = if_fpm_constants_internal=>gc_components-message_manager ).
  lo_message_area_usage = lo_usage_group->add_component_usage( 'MESSAGE_AREA_USAGE' ).
  lo_message_area_usage->create_component( if_fpm_constants_internal=>gc_components-message_manager ).

* Store the message manager component reference for use in dialogs and pass FPM instance to it
  mo_message_manager ?= lo_message_area_usage->get_interface_controller( ).
  lo_multi_inst ?= mo_message_manager.
  lo_multi_inst->fpm_initialize( mo_fpm ).


ENDMETHOD.


METHOD initialize_rat.


  DATA:
    lo_rat_parameter TYPE REF TO if_fpm_parameter.


* Ensure that the RAT (Runtime Analysis Tool) can be initialized
  IF cl_fpm_rat=>mo_instance IS NOT BOUND.
    RETURN.
  ENDIF.
  ASSERT mo_component IS BOUND.

* Attach component to the RAT
  cl_fpm_rat=>mo_instance->attach_component( io_fpm       = mo_fpm
                                             io_component = mo_component ).

* Save the floorplan data reference in the RAT
  IF mo_floorplan_data IS BOUND.
    lo_rat_parameter = cl_fpm_rat=>mo_instance->get_data( iv_component_id = mo_component->get_id( ) ).
    lo_rat_parameter->set_value( EXPORTING iv_key   = cl_fpm_rat=>gc_key-floorplan_data
                                           iv_value = mo_floorplan_data ).
  ENDIF.


ENDMETHOD.


METHOD initialize_runtime_api.


  RETURN.


ENDMETHOD.


METHOD initialize_runtime_info_object.


  DATA:
    ls_runtime_info TYPE fpm_s_runtime_info.


* Initialize floorplan runtime info object
  CLEAR ro_fpm_runtime_info_object.

* Get runtime information
  IF mo_fpm IS BOUND.
    ls_runtime_info = mo_fpm->if_fpm~get_runtime_info( ).
    ro_fpm_runtime_info_object = ls_runtime_info-floorplan_info.
  ENDIF.


ENDMETHOD.


METHOD init_side_panel.


*----- only for one fpm instance
  CHECK mo_fpm = cl_fpm_factory=>get_instance( ).

*----- internal method to delgate in redefinitions
  init_side_panel_internal(
    io_view_controller = io_view_controller
    iv_portal_event_action = iv_portal_event_action ).

  SET HANDLER on_close_of_side_panel FOR ALL INSTANCES.


ENDMETHOD.


METHOD init_side_panel_internal.


*----- ignore by default
  RETURN.


ENDMETHOD.


METHOD is_footer_notif_icon_required.


* Initialize returning parameter
  rv_result = abap_false.

  IF io_footer_toolbar IS BOUND                 AND
     is_footer_toolbar_required( ) = abap_true  AND
     mv_hide_message_area          = abap_false AND
     mv_message_area_design        = if_fpm_constants_internal=>gc_message_area_design-notification_icon.
    rv_result = abap_true.
  ENDIF.


ENDMETHOD.


METHOD is_footer_toolbar_required.


* Initialize returning parameter
  rv_result = abap_false.

  IF mv_toolbar_location_type = if_fpm_constants=>gc_toolbar_location_type-footer OR
     ( mv_toolbar_location_type    = if_fpm_constants=>gc_toolbar_location_type-guideline AND
       get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori ).
    rv_result = abap_true.
  ENDIF.


ENDMETHOD.


METHOD is_header_notif_icon_required.


* Initialize returning parameter
  rv_result = abap_false.

  IF io_page_header IS BOUND AND
     io_page_header->get_visible( ) = cl_wd_uielement=>e_visible-visible AND
     is_header_toolbar_required( )  = abap_true                          AND
     is_footer_toolbar_required( )  = abap_false                         AND
     iv_title_hidden                = abap_false                         AND
     mv_message_area_design = if_fpm_constants_internal=>gc_message_area_design-notification_icon.
    rv_result = abap_true.
  ENDIF.


ENDMETHOD.


METHOD is_header_toolbar_required.


* Initialize returning parameter
  rv_result = abap_false.

  IF mv_toolbar_location_type <> if_fpm_constants=>gc_toolbar_location_type-footer.
    rv_result = abap_true.
  ENDIF.


ENDMETHOD.


METHOD is_multi_stretched.


  DATA:
    lt_parameter_keys TYPE if_fpm_parameter=>t_keys.


* Initialize returning parameter
  rv_is_multi_stretched = abap_true.

* Determine multi-stretching indicator from Application/ URL parameter
  IF mo_fpm IS BOUND.
    lt_parameter_keys = mo_fpm->if_fpm~mo_app_parameter->get_keys( ).
    READ TABLE lt_parameter_keys
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-multi_stretched.
    IF sy-subrc = 0.
*     Multi-stretching indicator set via Application/ URL parameter
      mo_fpm->if_fpm~mo_app_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-multi_stretched
                                                  IMPORTING ev_value = rv_is_multi_stretched  ).
      RETURN.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD is_print_enabled.


* Initialize returning parameter
  rv_print_enabled = abap_false.


ENDMETHOD.


METHOD is_valid_configuration.


  DATA:
    lo_wd_personalization TYPE REF TO if_wd_personalization.

  DATA:
    ls_config_key TYPE wdy_config_key.


* Initialize returning parameter
  rv_result = abap_false.

* Ensure that configuration can be checked
  ASSERT mo_component IS BOUND.

  lo_wd_personalization = mo_component->get_personalization_manager( ).
  lo_wd_personalization->get_state( IMPORTING original_config_key = ls_config_key ).
  IF ls_config_key-config_id IS NOT INITIAL AND ls_config_key-config_type = if_wd_config_constants=>c_config_type_general.
    rv_result = abap_true.
    RETURN.
  ENDIF.

  IF mo_adaptation_manager IS BOUND AND ls_config_key-config_type = if_wd_config_constants=>c_config_type_verticalization.
    rv_result = abap_true.
    RETURN.
  ENDIF.


ENDMETHOD.


  method keep_messages.

    check io_action is bound.
    if io_action->name = 'FLP_NAVIGATION'.
      io_action->set( keep_messages = abap_true ).
    endif.

  endmethod.


METHOD launch_app_hierarchy_browser.


  DATA:
    lo_navigate_to TYPE REF TO if_fpm_navigate_to.

  DATA:
    lt_message TYPE fpm_t_t100_messages,
    lt_param   TYPE apb_lpd_t_params.

  DATA:
    ls_url_fields TYPE fpm_s_launch_url,
    ls_param      TYPE apb_lpd_s_params,
    ls_rt_info    TYPE fpm_s_runtime_info.

  DATA:
    lv_error TYPE boole_d VALUE abap_false.

  DATA:
    lv_config_type TYPE wdy_config_type.

  FIELD-SYMBOLS:
    <ls_message> LIKE LINE OF lt_message.


* Fill Url fields for navigation
  cl_wd_utilities=>construct_wd_url( EXPORTING application_name = if_fpm_constants_internal=>gc_components-hierarchy_browser
                                     IMPORTING out_absolute_url = ls_url_fields-url ).

* sap theme
  DATA(lv_param_value) = cl_wd_runtime_services=>get_url_parameter( name = if_fpm_hct_constants=>gc_url_parameter-sap_theme ).
  IF lv_param_value IS NOT INITIAL.
    ls_param-key = if_fpm_hct_constants=>gc_url_parameter-sap_theme.
    ls_param-value = lv_param_value.
    APPEND ls_param TO lt_param.
  ENDIF.

* acc mode
  lv_param_value = cl_wd_runtime_services=>get_url_parameter( name = if_fpm_hct_constants=>gc_url_parameter-sap_acc ).
  IF lv_param_value IS NOT INITIAL.
    ls_param-key = if_fpm_hct_constants=>gc_url_parameter-sap_acc.
    ls_param-value = lv_param_value.
    APPEND ls_param TO lt_param.
  ENDIF.

* sap language
  CLEAR ls_param.
  ls_param-key = 'sap-language'.                            "#EC NOTEXT
  ls_param-value = sy-langu.
  APPEND ls_param TO lt_param.

* config id
  CLEAR ls_param.
  ls_param-key = 'CONFIG_ID'.
  ls_rt_info = mo_fpm->if_fpm~get_runtime_info( ).
  IF ls_rt_info-config_id IS INITIAL.
    ls_param-value = ls_rt_info-fp_config_id.
    lv_config_type = if_wd_config_constants=>c_config_type_general.
  ELSE.
    ls_param-value = ls_rt_info-config_id.
    lv_config_type = if_wd_config_constants=>c_config_type_appl.
  ENDIF.
  APPEND ls_param TO lt_param.

* config type
  CLEAR ls_param.
  ls_param-key = 'CONFIG_TYPE'.
  ls_param-value = lv_config_type.
  APPEND ls_param TO lt_param.
  ls_url_fields-parameter          = lt_param.
  ls_url_fields-use_suspend_resume = abap_false.

* Launch Url
  lo_navigate_to = mo_fpm->if_fpm~get_navigate_to( ).
  lo_navigate_to->launch_url( EXPORTING is_url_fields = ls_url_fields
                              IMPORTING et_messages   = lt_message
                                        ev_error      = lv_error ).

* Process messages
  IF lv_error = abap_true.
    LOOP AT lt_message ASSIGNING <ls_message>.
      mo_fpm->if_fpm~mo_message_manager->report_t100_message( EXPORTING iv_msgid       = <ls_message>-msgid
                                                                        iv_msgno       = <ls_message>-msgno
                                                                        io_component   = mo_component
                                                                        iv_severity    = <ls_message>-severity
                                                                        iv_lifetime    = <ls_message>-lifetime
                                                                        iv_parameter_1 = <ls_message>-parameter_1
                                                                        iv_parameter_2 = <ls_message>-parameter_2
                                                                        iv_parameter_3 = <ls_message>-parameter_3
                                                                        iv_parameter_4 = <ls_message>-parameter_4 ).
    ENDLOOP.
  ENDIF.


ENDMETHOD.


METHOD launch_configuration_editor.


* Launch configuration editor
  cl_fpm_config_editor=>launch_editor( io_pers_manager           = mo_component->get_personalization_manager( )
                                       iv_component              = mo_component->get_component_info( )->get_name( )
                                       io_fpm                    = mo_fpm
                                       io_target_context_element = io_wd_context_element ).


ENDMETHOD.


METHOD message_navigation.


  mo_message_manager->on_navigate( io_wdevent ).


ENDMETHOD.


METHOD modify_composite_view_assembly.


  FIELD-SYMBOLS:
    <ls_uibb> LIKE LINE OF mt_uibbs.


* In case of a failed event restore the 'Before' image of UIBB table and composite UIBB hierarchy table
  IF iv_event_failed = abap_false.
    mt_uibbs_before[]     = mt_uibbs[].
    mt_uibb_hier_before[] = mt_uibb_hier[].
  ELSE.
    mt_uibbs[]     = mt_uibbs_before[].
    mt_uibb_hier[] = mt_uibb_hier_before[].
  ENDIF.

* Get view assembly of 'valid' composite UIBBs
  LOOP AT mt_uibbs ASSIGNING <ls_uibb>
                   WHERE is_composite = abap_true.
    <ls_uibb>-interface ?= mo_fpm->mo_component_manager->get_component_interface( iv_component_name = <ls_uibb>-component
                                                                                  is_config_key     = <ls_uibb>-config_key
                                                                                  iv_instance_id    = <ls_uibb>-instance_id ).
    IF <ls_uibb>-interface IS BOUND.
      <ls_uibb>-interface->modify_view_assembly( io_event                    = io_event
                                                 iv_event_failed             = iv_event_failed
                                                 iv_is_part_of_current_event = <ls_uibb>-within_current_event ).
    ELSE.
      DELETE mt_uibbs.
    ENDIF.
  ENDLOOP.


ENDMETHOD.


METHOD navigate.

* Optimize navigation by eliminating all navigation steps, where at
* the end the same UIBB is displayed in the same container
  DATA: lt_last TYPE t_navigation_step.
  FIELD-SYMBOLS: <fs_step> LIKE LINE OF ct_step,
                 <fs_uibb> LIKE LINE OF mt_displayed_uibb,
                 <fs_last> LIKE LINE OF ct_step.

  IF ct_step IS INITIAL.
    RETURN.
  ENDIF.

* First get a list of the UIBBs displayed after navigation is done!
  DATA: lt_step TYPE t_navigation_step.
  lt_step = ct_step.
  SORT lt_step STABLE BY target_embedding_position.
  LOOP AT lt_step ASSIGNING <fs_step>.
    IF sy-tabix = 1.
      ASSIGN <fs_step> TO <fs_last>.
      CONTINUE.
    ENDIF.
    IF <fs_last>-target_embedding_position NE <fs_step>-target_embedding_position.
      APPEND <fs_last> TO lt_last.
    ENDIF.
    ASSIGN <fs_step> TO <fs_last>.
  ENDLOOP.
  APPEND <fs_step> TO lt_last.

* Now we have the after image in lt_last
  LOOP AT lt_last ASSIGNING <fs_last>.
    READ TABLE mt_displayed_uibb WITH KEY target_embedding_position = <fs_last>-target_embedding_position
      ASSIGNING <fs_uibb> BINARY SEARCH.
    IF sy-subrc = 0 AND
       <fs_uibb>-target_component_name = <fs_last>-target_component_name   AND
       <fs_uibb>-target_component_usage = <fs_last>-target_component_usage AND
       <fs_uibb>-target_view_name = <fs_last>-target_view_name             AND
       <fs_uibb>-usage = <fs_last>-usage.
*     After navigation same UIBB gets displayed => cancel navigation for this position
      DELETE ct_step WHERE target_embedding_position = <fs_last>-target_embedding_position.
    ELSEIF sy-subrc = 0 AND <fs_uibb>-target_component_name = 'FPM_EMPTY_COMP'.
*     Hidden target location get's visible again
      ms_change_flags_roundtrip-uibb_container_changed = abap_true.
    ELSEIF sy-subrc NE 0.
*     New target location needed
      ms_change_flags_roundtrip-uibb_container_changed = abap_true.
    ENDIF.
  ENDLOOP.

  LOOP AT ct_step ASSIGNING <fs_step>.
    io_view_controller_api->prepare_dynamic_navigation(
               source_window_name          = iv_source_window_name
               source_vusage_name          = iv_source_usage_name
               source_plug_name            = <fs_step>-source_plug_name
               target_component_name       = <fs_step>-target_component_name
               target_component_usage      = <fs_step>-target_component_usage
               target_view_name            = <fs_step>-target_view_name
               target_plug_name            = iv_target_plug_name
               target_embedding_position   = <fs_step>-target_embedding_position ).
    io_view_controller_api->fire_plug( <fs_step>-source_plug_name ).
*   Update table of displayed UIBBs
    READ TABLE mt_displayed_uibb WITH KEY target_embedding_position = <fs_step>-target_embedding_position
      ASSIGNING <fs_uibb> BINARY SEARCH.
    IF sy-subrc = 0.
      MOVE-CORRESPONDING <fs_step> TO <fs_uibb>.
    ELSE.
      INSERT <fs_step> INTO mt_displayed_uibb INDEX sy-tabix.
    ENDIF.
  ENDLOOP.


ENDMETHOD.


METHOD on_close_of_side_panel.

  DATA lv_close_side_panel_event TYPE string.

  mo_fpm->if_fpm~mo_app_parameter->get_value(
    EXPORTING
      iv_key   = if_fpm_constants=>gc_app_params-event_on_side_panel_close
     IMPORTING
       ev_value = lv_close_side_panel_event
  ).

  IF NOT lv_close_side_panel_event IS INITIAL.
    IF lv_close_side_panel_event = 'X'.
      lv_close_side_panel_event = 'FPM_SIDE_PANEL_CLOSE'.
    ENDIF.
    DATA lv_event_id TYPE fpm_event_id.
    lv_event_id = lv_close_side_panel_event.
    mo_fpm->if_fpm~raise_event_by_id( lv_event_id ).
  ENDIF.

ENDMETHOD.


method open_dialog.
  "This method is clled from different floorpalns to open the Dialog Box.
  data lo_window_manager type ref to if_wd_window_manager.
  data lo_window type ref to if_wd_window.
  data lv_usage type string.
  data ls_dialog_component_usage type t_dialog_component_usage.
  data lo_level_usage type ref to if_wd_component_usage.
  data lo_dialog_interface_controller type ref to iwci_fpm_dialog_component.
  data lv_level_c type c.
  data lo_event_params type ref to if_fpm_parameter.
  data lv_current_dialog_window_id type fpm_dialog_window_id.
  data ls_dialog_window_properties type fpm_s_dialog_box_properties.
  "Updated Dialog Box properties
  data ls_updated_dialog_props type fpm_s_dialog_box_properties.
  "Support for OTR Text
  data lv_otr_prefix_length type i.
  data lv_otr_alias type string.
  data lo_msg_mgr type ref to if_fpm_message_manager.
  data lv_propose_dialog_window_level type string.
  data lv_dialog_height type string.
  data lv_dialog_width type string.

  "React only if the event is to open the dialog window.
  check io_event->mv_event_id eq cl_fpm_event=>gc_event_open_dialog_box
    and iv_event_failed eq abap_false.

  "Get reference to message manager to raise exception if the user chooses a wrong button set
  lo_msg_mgr = mo_fpm->mo_message_manager.

  "We need to now process the highest level of the dialog. It can be done
  "Process the level of the dialog. Get the data from the event.
  lo_event_params = io_event->mo_event_data.

  call method lo_event_params->get_value
    exporting
      iv_key   = if_fpm_constants=>gc_dialog_box-id
    importing
      ev_value = lv_current_dialog_window_id.
  cv_current_dialog_window_id = lv_current_dialog_window_id.

  call method lo_event_params->get_value
    exporting
      iv_key   = if_fpm_constants=>gc_proposed_dialog_level
    importing
      ev_value = lv_propose_dialog_window_level.

* for values < 1, we start again from 1
  if lv_propose_dialog_window_level lt 1.
    lv_propose_dialog_window_level = 1.
  endif.

  "set the proposed dialog level to current dialog window level.
  cv_current_dialog_window_level = lv_propose_dialog_window_level.

  call method lo_event_params->get_value
    exporting
      iv_key   = if_fpm_constants=>gc_dialog_box-dialog_box_properties
    importing
      ev_value = ls_dialog_window_properties.

***We get the usage from the WD component as importing parameter or create usage here.
***and delete the importing paratmeter mr_dialog_usage also from comp controller**
**  Initialize the usages.
  if mv_dialog_usage_group is initial. "First time
    mv_dialog_usage_group = io_wd_api->create_cmp_usage_group(
        name           = 'DIALOG_WINDOW_EXTERNAL_USAGE_GROUP'
        used_component = 'FPM_DIALOG_COMPONENT'
    ).
  endif.
  "Convert integer to c(1): will work only for cv_current_dialog_window_level < 10
  assert cv_current_dialog_window_level lt 10.
  lv_level_c = cv_current_dialog_window_level.
  concatenate 'level' lv_level_c into lv_usage ##NO_TEXT.
  condense lv_usage no-gaps.
  "First check if we need to create a new instance or if we have it already.
  lo_level_usage  = mv_dialog_usage_group->get_component_usage( lv_usage ).
  if lo_level_usage is initial.
    lo_level_usage = mv_dialog_usage_group->add_component_usage(
      name               = lv_usage
      lifecycle_control  = if_wd_rr_component_usage=>create_on_demand
      embedding_position = lv_usage
      used_component = 'FPM_DIALOG_COMPONENT'
  ).
    lo_level_usage->create_component( component_name = if_fpm_constants_internal=>gc_components-dialog ).
  endif.

  lo_dialog_interface_controller ?= lo_level_usage->get_interface_controller( ).
  lo_dialog_interface_controller->initialize(
    exporting
      iv_current_level = cv_current_dialog_window_level
      it_uibbs = it_current_dialog_uibbs
      is_dialog_box_properties = is_current_dialog_properties
      is_window_properties_internal = is_window_properties_internal
      io_message_manager = io_message_manager
      io_fpm = mo_fpm
      io_floorplan_data = mo_floorplan_data ).

  "Use the message manager instance for this dialog component.
  data: lo_fpm_message_manager type ref to cl_fpm_message_manager.
  lo_fpm_message_manager ?= mo_fpm->if_fpm~mo_message_manager.
  lo_fpm_message_manager->set_wd_message_manager( lo_dialog_interface_controller->get_message_manager( ) ).

  lo_window_manager = io_wd_api->get_window_manager( ).
  call method lo_window_manager->create_window_for_cmp_usage
    exporting
      interface_view_name  = 'FPM_DIALOG_WINDOW'
      component_usage_name = lv_usage
      title                = lv_usage
    receiving
      window               = lo_window.

  eo_dialog_window = lo_window.

  ls_dialog_component_usage-component_usage = lo_level_usage.
  ls_dialog_component_usage-usage_level = lv_usage.
  ls_dialog_component_usage-window = lo_window.
  ls_dialog_component_usage-dialog_window_id = lv_current_dialog_window_id.

  "Check if the level is re-visited then modify else insert.
  data: lv_stack_size type i.
  describe table mt_dialog_component_usages lines lv_stack_size.
  if cv_current_dialog_window_level > lv_stack_size. "It a new level for the first time.
    insert ls_dialog_component_usage into mt_dialog_component_usages index 1.
  else. "We only need to update the window reference.
    "Modify at the right index.
    data: lv_index_modifiable type i.
    read table mt_dialog_component_usages with key usage_level = lv_usage transporting no fields.
    assert sy-subrc eq 0.
    lv_index_modifiable = sy-tabix.
    modify mt_dialog_component_usages index lv_index_modifiable
    from ls_dialog_component_usage.
  endif.

  "Set all the properties if they are present. The first priority goes to the properties of the event as these are
  "passesd via the API. If the properties of the event are balnk then the Context Node properties are set.

  "Set the OTR Attributes for tooltip.
  lv_otr_prefix_length = strlen( if_fpm_cfg_constants=>gc_otr_prefix ).
  "Set the button tool tip
  if ls_dialog_window_properties-tool_tip_for_cancel_button is not initial.
    if find( val = ls_dialog_window_properties-tool_tip_for_cancel_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-tool_tip_for_cancel_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_cancel_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_cancel_button = ls_dialog_window_properties-tool_tip_for_cancel_button.
    endif.
  elseif is_current_dialog_properties-tool_tip_for_cancel_button is not initial.
    if find( val = is_current_dialog_properties-tool_tip_for_cancel_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-tool_tip_for_cancel_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_cancel_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_cancel_button = is_current_dialog_properties-tool_tip_for_cancel_button.
    endif.
  endif.

  if ls_dialog_window_properties-tool_tip_for_close_button is not initial.
    if find( val = ls_dialog_window_properties-tool_tip_for_close_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-tool_tip_for_close_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_close_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_close_button = ls_dialog_window_properties-tool_tip_for_close_button.
    endif.
  elseif is_current_dialog_properties-tool_tip_for_close_button is not initial.
    if find( val = is_current_dialog_properties-tool_tip_for_close_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-tool_tip_for_close_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_close_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_close_button = is_current_dialog_properties-tool_tip_for_close_button.
    endif.
  endif.

  if ls_dialog_window_properties-tool_tip_for_ok_button is not initial.
    if find( val = ls_dialog_window_properties-tool_tip_for_ok_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-tool_tip_for_ok_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_ok_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_ok_button = ls_dialog_window_properties-tool_tip_for_ok_button.
    endif.
  elseif is_current_dialog_properties-tool_tip_for_ok_button is not initial.
    if find( val = is_current_dialog_properties-tool_tip_for_ok_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-tool_tip_for_ok_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_ok_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_ok_button = is_current_dialog_properties-tool_tip_for_ok_button.
    endif.
  endif.

* For Yes button tooltip
  if ls_dialog_window_properties-tool_tip_for_yes_button is not initial.
    if find( val = ls_dialog_window_properties-tool_tip_for_yes_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-tool_tip_for_yes_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_yes_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_yes_button = ls_dialog_window_properties-tool_tip_for_yes_button.
    endif.
  elseif is_current_dialog_properties-tool_tip_for_yes_button is not initial.
    if find( val = is_current_dialog_properties-tool_tip_for_yes_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-tool_tip_for_yes_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_yes_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_yes_button = is_current_dialog_properties-tool_tip_for_yes_button.
    endif.
  endif.

* For No button tooltip
  if ls_dialog_window_properties-tool_tip_for_no_button is not initial.
    if find( val = ls_dialog_window_properties-tool_tip_for_no_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-tool_tip_for_no_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_no_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_no_button = ls_dialog_window_properties-tool_tip_for_no_button.
    endif.
  elseif is_current_dialog_properties-tool_tip_for_no_button is not initial.
    if find( val = is_current_dialog_properties-tool_tip_for_no_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-tool_tip_for_no_button+lv_otr_prefix_length.
      ls_updated_dialog_props-tool_tip_for_no_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-tool_tip_for_no_button = is_current_dialog_properties-tool_tip_for_no_button.
    endif.
  endif.

* Set the buttons dynamically.
* Check if the button set is passed else pass the default set.
  if ls_dialog_window_properties-button_set is not initial.
    ls_updated_dialog_props-button_set = ls_dialog_window_properties-button_set.
  elseif is_current_dialog_properties-button_set is not initial.
    ls_updated_dialog_props-button_set = is_current_dialog_properties-button_set.
  else.
*   If no values then no button
    ls_updated_dialog_props-button_set = 1.
  endif.

* Set the OTR Attributes for Text.
  lv_otr_prefix_length = strlen( if_fpm_cfg_constants=>gc_otr_prefix ).

  if ls_dialog_window_properties-text_for_close_button is not initial.
    if find( val = ls_dialog_window_properties-text_for_close_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-text_for_close_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_close_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_close_button = ls_dialog_window_properties-text_for_close_button.
    endif.
  elseif is_current_dialog_properties-text_for_close_button is not initial.
    if find( val = is_current_dialog_properties-text_for_close_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-text_for_close_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_close_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_close_button = is_current_dialog_properties-text_for_close_button.
    endif.
  endif.

  if ls_dialog_window_properties-text_for_ok_button is not initial.
    if find( val = ls_dialog_window_properties-text_for_ok_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-text_for_ok_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_ok_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_ok_button = ls_dialog_window_properties-text_for_ok_button.
    endif.
  elseif is_current_dialog_properties-text_for_ok_button is not initial.
    if find( val = is_current_dialog_properties-text_for_ok_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-text_for_ok_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_ok_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_ok_button = is_current_dialog_properties-text_for_ok_button.
    endif.
  endif.

* For Yes Button
  if ls_dialog_window_properties-text_for_yes_button is not initial.
    if find( val = ls_dialog_window_properties-text_for_yes_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-text_for_yes_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_yes_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_yes_button = ls_dialog_window_properties-text_for_yes_button.
    endif.
  elseif is_current_dialog_properties-text_for_yes_button is not initial.
    if find( val = is_current_dialog_properties-text_for_yes_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-text_for_yes_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_yes_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_yes_button = is_current_dialog_properties-text_for_yes_button.
    endif.
  endif.

* For No Button
  if ls_dialog_window_properties-text_for_no_button is not initial.
    if find( val = ls_dialog_window_properties-text_for_no_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-text_for_no_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_no_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_no_button = ls_dialog_window_properties-text_for_no_button.
    endif.
  elseif is_current_dialog_properties-text_for_no_button is not initial.
    if find( val = is_current_dialog_properties-text_for_no_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-text_for_no_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_no_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_no_button = is_current_dialog_properties-text_for_no_button.
    endif.
  endif.

* For Cancel Button
  if ls_dialog_window_properties-text_for_cancel_button is not initial.
    if find( val = ls_dialog_window_properties-text_for_cancel_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-text_for_cancel_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_cancel_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_cancel_button = ls_dialog_window_properties-text_for_cancel_button.
    endif.
  elseif is_current_dialog_properties-text_for_cancel_button is not initial.
    if find( val = is_current_dialog_properties-text_for_cancel_button
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-text_for_cancel_button+lv_otr_prefix_length.
      ls_updated_dialog_props-text_for_cancel_button = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-text_for_cancel_button = is_current_dialog_properties-text_for_cancel_button.
    endif.
  else.
    ls_updated_dialog_props-text_for_cancel_button = text-002.
  endif.

  if cv_current_dialog_window_level  < if_fpm_constants_internal=>gc_maximum_dialog_levels.
    case ls_updated_dialog_props-button_set.
      when 1.
*     No buttons
      when 2.
        lo_window->set_button_kind( if_wd_window=>co_buttons_close ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_close
             button_text = ls_updated_dialog_props-text_for_close_button
             tooltip = ls_updated_dialog_props-tool_tip_for_close_button
             action_name = 'CLOSE'
             action_view = io_main_view_controller
             is_default_button = abap_true
             ).
      when 3.
*       OK, Cancel - OK is default button
        lo_window->set_button_kind( if_wd_window=>co_buttons_okcancel ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_ok
             button_text = ls_updated_dialog_props-text_for_ok_button
             tooltip = ls_updated_dialog_props-tool_tip_for_ok_button
             action_name = 'OK'
             action_view = io_main_view_controller
             is_default_button = abap_true
             ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_cancel
             button_text = ls_updated_dialog_props-text_for_cancel_button
             tooltip = ls_updated_dialog_props-tool_tip_for_cancel_button
             action_name = 'CANCEL'
             action_view = io_main_view_controller
             ).
      when 4.
*       OK, Cancel - no default button
        lo_window->set_button_kind( if_wd_window=>co_buttons_okcancel ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_ok
             button_text = ls_updated_dialog_props-text_for_ok_button
             tooltip = ls_updated_dialog_props-tool_tip_for_ok_button
             action_name = 'OK'
             action_view = io_main_view_controller
             ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_cancel
             button_text = ls_updated_dialog_props-text_for_cancel_button
             tooltip = ls_updated_dialog_props-tool_tip_for_cancel_button
             action_name = 'CANCEL'
             action_view = io_main_view_controller
             ).
      when 5.
        lo_window->set_button_kind( if_wd_window=>co_buttons_yesnocancel ).
        lo_window->subscribe_to_button_event(
          exporting
             button = '7'
             button_text = ls_updated_dialog_props-text_for_yes_button
             tooltip = ls_updated_dialog_props-tool_tip_for_yes_button
             action_name = 'YES'
             action_view = io_main_view_controller
             ).
        lo_window->subscribe_to_button_event(
          exporting
             button = '8'
             button_text = ls_updated_dialog_props-text_for_no_button
             tooltip = ls_updated_dialog_props-tool_tip_for_no_button
             action_name = 'NO'
             action_view = io_main_view_controller
             ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_cancel
             button_text = ls_updated_dialog_props-text_for_cancel_button
             tooltip = ls_updated_dialog_props-tool_tip_for_cancel_button
             action_name = 'CANCEL'
             action_view = io_main_view_controller
             ).
      when others." only 3 levels of dialog is allowed.
        lo_msg_mgr->raise_t100_exception(
          exporting
            iv_msgid       = if_fpm_constants_internal=>gc_message_id-core
            iv_msgno       = '727'
        ).
    endcase.
  else.
    "Pop up is at the final level. If the user has specified the button set the default it to close else no buttons
    if ls_updated_dialog_props-button_set is not initial.
      "If the button set value is 1 then there are no buttons but for the rest of the values this level will only have the close button
      if ls_updated_dialog_props-button_set <> 1.
        lo_window->set_button_kind( if_wd_window=>co_buttons_close ).
        lo_window->subscribe_to_button_event(
          exporting
             button = if_wd_window=>co_button_close
             tooltip = ls_updated_dialog_props-tool_tip_for_close_button
             action_name = 'CLOSE'
             action_view = io_main_view_controller
             is_default_button = abap_true
             ).
      endif.
    endif.
  endif.

  "For the X close button in the dialog box window we will register it with the close event.
  "On the last level of dialog ,it makes sense to have only one button.
  lo_window->set_on_close_action(
    exporting
       view = io_main_view_controller
       action_name = 'CLOSE'
       ).

  "Set Window title
  if ls_dialog_window_properties-title is not initial.
    if find( val = ls_dialog_window_properties-title
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = ls_dialog_window_properties-title+lv_otr_prefix_length.
      ls_updated_dialog_props-title = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-title = ls_dialog_window_properties-title.
    endif.
  elseif is_current_dialog_properties-title is not initial.
    if find( val = is_current_dialog_properties-title
             sub = if_fpm_cfg_constants=>gc_otr_prefix ) = 0.
      lv_otr_alias = is_current_dialog_properties-title+lv_otr_prefix_length.
      ls_updated_dialog_props-title = cl_wd_utilities=>get_otr_text_by_alias( lv_otr_alias ).
    else.
      ls_updated_dialog_props-title = is_current_dialog_properties-title.
    endif.
  else.
    clear ls_updated_dialog_props-title.
  endif.
  lo_window->set_window_title(
    exporting
      title = ls_updated_dialog_props-title
  ).
  "set the height and width of dialog box
  if is_current_dialog_properties-width is not initial.
    lv_dialog_width = is_current_dialog_properties-width.
  elseif  ls_dialog_window_properties-width is not initial.
    lv_dialog_width = ls_dialog_window_properties-width .
  endif.
  if is_current_dialog_properties-height is not initial.
    lv_dialog_height = is_current_dialog_properties-height.
  elseif  ls_dialog_window_properties-width is not initial.
    lv_dialog_height = ls_dialog_window_properties-height .
  endif.
  lo_window->set_window_size( width  = lv_dialog_width
                              height = lv_dialog_height ).

* Open the dialog window
  lo_window->set_close_in_any_case( abap_false ).
  lo_window->set_message_display_mode( 1 ). "Display messages only for the relevant windows.
  lo_window->open( ).

  add_window_to_stack( lo_window ).

endmethod.


METHOD open_help_center.


  mo_component->get_application( )->open_help_center( ).


ENDMETHOD.


METHOD open_side_panel.


  DATA:
    lo_fpm_event TYPE REF TO cl_fpm_event.

  DATA:
    lv_action_type TYPE fpm_action_type VALUE if_fpm_constants=>gc_action_type-standard.


* Determine action type for the FPM event
  IF io_wd_action IS BOUND.
    IF io_wd_action->is_validating = abap_false.
      lv_action_type = if_fpm_constants=>gc_action_type-validation_independent.
    ENDIF.
  ENDIF.

* Create FPM event
  lo_fpm_event = cl_fpm_event=>create_by_id( iv_event_id    = if_fpm_constants=>gc_event-open_side_panel
                                             iv_action_type = lv_action_type ).

* Raise FPM event
  mo_fpm->if_fpm~raise_event( lo_fpm_event ).


ENDMETHOD.


METHOD prepare_work_protection.


* Set dirty state temporarily
* (This is needed for WD actions without FPM event to fake a client-side work-protection)
  mo_fpm->set_dirty_temp( ).


ENDMETHOD.


METHOD process_async_event.


  DATA: lv_id TYPE wdr_notification_id.


  lv_id = io_event->get_string( 'NOTIFICATION_ID' ).

  IF NOT lv_id IS INITIAL.
    DATA: lo_event TYPE REF TO cl_fpm_event.
    lo_event = mo_fpm->get_async_event( lv_id ).

    IF lo_event IS BOUND.
      lo_event->mv_framework_event = abap_true.
      me->mo_fpm->if_fpm~raise_event( lo_event ).
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD raise_special_wda_event.


  RAISE EVENT special_wda_event
    EXPORTING
      wda_event = iv_wda_event
      fpm       = mo_fpm.


ENDMETHOD.


METHOD remove_window_from_stack.


  READ TABLE mt_window_stack ASSIGNING FIELD-SYMBOL(<window>) INDEX lines( mt_window_stack ).

  ASSERT <window> = io_window.
  DELETE mt_window_stack INDEX lines( mt_window_stack ).


ENDMETHOD.


METHOD render_ext_navigation_menus.


  CONSTANTS:
    BEGIN OF lc_ext_nav_menu_uielement_type,
      button_choice TYPE c LENGTH 2 VALUE 'BC',
      link_choice   TYPE c LENGTH 2 VALUE 'LC',
      menu_button   TYPE c LENGTH 2 VALUE 'MB',
    END OF lc_ext_nav_menu_uielement_type.

  TYPES:
    BEGIN OF ty_s_ext_navigation_item,
      id         TYPE fpm_external_navigation_id,
      type       TYPE fpm_navigation_target_type,
      key        TYPE string,
      parent_key TYPE string,
      text       TYPE fpm_text,
      image      TYPE fpm_image,
      enabled    TYPE fpm_enabled,
      visible         TYPE abap_bool,
      hierarchy_level TYPE i,
    END OF ty_s_ext_navigation_item .
  TYPES:
    ty_t_ext_navigation_item TYPE STANDARD TABLE OF ty_s_ext_navigation_item
                                  WITH NON-UNIQUE DEFAULT KEY .

  TYPES:
    BEGIN OF ty_s_menu,
      key  TYPE string,
      menu TYPE REF TO cl_wd_menu,
    END OF ty_s_menu.
  TYPES:
    ty_t_menu TYPE SORTED TABLE OF ty_s_menu
                   WITH UNIQUE KEY key.

  DATA:
    lo_navigation            TYPE REF TO if_fpm_navigation,
    lo_toolbar_button_choice TYPE REF TO cl_wd_toolbar_btn_choice,
    lo_toolbar_link_choice   TYPE REF TO cl_wd_toolbar_link_choice,
    lo_toolbar_menu_button   TYPE REF TO cl_wd_toolbar_menu_button,
    lo_root_menu             TYPE REF TO cl_wd_menu,
    lo_menu                  TYPE REF TO cl_wd_menu,
    lo_menu_action_item      TYPE REF TO cl_wd_menu_action_item,
    lo_menu_separator        TYPE REF TO cl_wd_menu_separator,
    lo_separator_left        TYPE REF TO cl_wd_toolbar_separator.

  DATA:
    lt_ext_navigation      TYPE ty_t_ext_navigation,
    lt_ext_navigation_item TYPE ty_t_ext_navigation_item,
    lt_parent_key_visible         TYPE SORTED TABLE OF string
                                       WITH UNIQUE KEY table_line,
    lt_parent_key_visible_current LIKE lt_parent_key_visible,
    lt_parent_key_visible_new     LIKE lt_parent_key_visible,
    lt_parameter                  TYPE wdr_name_value_list,
    lt_menu                TYPE ty_t_menu.

  DATA:
    ls_ext_navigation_item LIKE LINE OF lt_ext_navigation_item,
    ls_navigation_key      TYPE fpm_s_navigation_key,
    ls_parameter           LIKE LINE OF lt_parameter,
    ls_menu                LIKE LINE OF lt_menu.

  DATA:
    lv_first_folder_key            LIKE ls_ext_navigation_item-key,
    lv_new_visible_parent_found    TYPE abap_bool,
    lv_ext_nav_menu_uielement_type TYPE c LENGTH 2 VALUE lc_ext_nav_menu_uielement_type-menu_button,
    lv_ext_navigation_item_key_enc TYPE string,
    lv_toolbar_element_id          TYPE string,
    lv_menu_id                     TYPE string,
    lv_menu_action_item_id         TYPE string,
    lv_menu_separator_id           TYPE string,
    lv_text                        TYPE fpm_text,
    lv_tooltip                     TYPE fpm_tooltip,
    lv_image                       TYPE fpm_image,
    lv_hide_if_no_visible_opt      TYPE abap_bool,
    lv_menu_action_item_visible    TYPE abap_bool,
    lv_separator_possible          TYPE abap_bool,
    lv_separator_added             TYPE abap_bool VALUE abap_false,
    lv_tabix                       LIKE sy-tabix.

  FIELD-SYMBOLS:
    <lo_menu>                     LIKE LINE OF lt_menu,
    <ls_ext_navigation>           LIKE LINE OF lt_ext_navigation,
    <ls_ext_navigation_item>      LIKE LINE OF lt_ext_navigation_item,
    <ls_ext_navigation_item_prnt> LIKE LINE OF lt_ext_navigation_item,
    <ls_ext_navigation_item_next> LIKE LINE OF lt_ext_navigation_item,
    <ls_navigation_target>        LIKE LINE OF if_fpm_navigation=>mt_targets,
    <lv_ext_navigation_item_key>  LIKE <ls_ext_navigation_item>-key.


* Initialize exporting paameters
  ev_toolbar_elements_added = abap_false.

* Return if there is no FPM node for external navigation
  IF io_fpm_nd_external_navigation IS NOT BOUND.
    RETURN.
  ENDIF.

* Get external navigation menus from FPM context
  get_ext_nav_menus_from_ctxt( EXPORTING io_fpm_nd_external_navigation = io_fpm_nd_external_navigation
                               IMPORTING et_ext_navigation             = lt_ext_navigation ).

* Add toolbar elements for external navigation
  LOOP AT lt_ext_navigation ASSIGNING <ls_ext_navigation>.
*   Adapt visibility of the external navigation menu (The default visibility should be '02' which is ensured by the context attribute default value but not by the config writer API)
    IF <ls_ext_navigation>-visibility IS INITIAL.
      <ls_ext_navigation>-visibility = if_fpm_constants=>gc_visibility-visible.
    ENDIF.
*   Adapt toolbar element properties
    adapt_toolbar_element_props( EXPORTING iv_toolbar_location = iv_toolbar_location
                                           iv_text             = <ls_ext_navigation>-text
                                           iv_image            = space
                                           iv_tooltip          = <ls_ext_navigation>-tooltip
                                 IMPORTING ev_text             = lv_text
                                           ev_tooltip          = lv_tooltip ).
*   Create toolbar element ID
    lv_toolbar_element_id = get_ui_element_id_for_ext_nav( iv_toolbar_location        = iv_toolbar_location
                                                           iv_ext_navigation_category = <ls_ext_navigation>-category ).
    IF lv_toolbar_element_id IS INITIAL.
      CONTINUE.
    ENDIF.
*   Get the external navigation menu items (from the corresponding Launchpad in LPD_CUST) (works only at runtime but not at design time)
*   (The external navigation menu items that are retrieved must already have the correct order to be able to render the hierarchy later on)
    CLEAR: lt_ext_navigation_item,
           lt_parent_key_visible.
    IF mo_fpm IS BOUND.
      CLEAR ls_navigation_key.
      ls_navigation_key-key1 = <ls_ext_navigation>-role.
      ls_navigation_key-key2 = <ls_ext_navigation>-instance.
      lo_navigation = mo_fpm->if_fpm~get_navigation( is_key = ls_navigation_key ).
      LOOP AT lo_navigation->mt_targets ASSIGNING <ls_navigation_target>.
        CLEAR ls_ext_navigation_item.
        ls_ext_navigation_item-id         = <ls_ext_navigation>-id.
        ls_ext_navigation_item-type       = <ls_navigation_target>-entry_type.
        ls_ext_navigation_item-key        = <ls_navigation_target>-key.
        ls_ext_navigation_item-parent_key = <ls_navigation_target>-parent.
        ls_ext_navigation_item-text       = <ls_navigation_target>-text.
        ls_ext_navigation_item-image      = <ls_navigation_target>-icon_path.
        IF <ls_navigation_target>-entry_type = if_fpm_constants=>gc_navigation_target_type-application.
          ls_ext_navigation_item-enabled  = <ls_navigation_target>-enable.
        ELSE.
          ls_ext_navigation_item-enabled  = abap_false.
        ENDIF.
        ls_ext_navigation_item-visible    = <ls_navigation_target>-visible.
        APPEND ls_ext_navigation_item TO lt_ext_navigation_item.
      ENDLOOP.
    ENDIF.
*   Determine the hierachy levels and store the parent navigation menu item keys (folder keys) that contain at least one visible
*   navigation menu item of type 'APP' (applications). Note that a parent navigation menu item (folder) will be treated as being
*   invisible in the case that it must not be considered because only the first folder is relevant.
*   (The table of relevant visible folder keys will be used later for correcting the visibility of those folders that contain only
*    invisible or no applications or that need not to be considered because their parents are not relevant)
    CLEAR lv_first_folder_key.
    LOOP AT lt_ext_navigation_item ASSIGNING <ls_ext_navigation_item>.
*     ... Determine hierarchy level
      IF <ls_ext_navigation_item>-parent_key IS INITIAL.
        <ls_ext_navigation_item>-hierarchy_level = 1.
        IF <ls_ext_navigation>-consider_first_folder_only = abap_true.
          IF <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-folder AND lv_first_folder_key IS INITIAL.
            lv_first_folder_key = <ls_ext_navigation_item>-key.
          ELSE.
            <ls_ext_navigation_item>-visible = abap_false.
          ENDIF.
        ENDIF.
      ELSE.
        READ TABLE lt_ext_navigation_item
                   ASSIGNING <ls_ext_navigation_item_prnt>
                   WITH KEY id  = <ls_ext_navigation_item>-id
                            key = <ls_ext_navigation_item>-parent_key.
        CHECK sy-subrc = 0.
        <ls_ext_navigation_item>-hierarchy_level = <ls_ext_navigation_item_prnt>-hierarchy_level + 1.
        IF <ls_ext_navigation_item_prnt>-visible = abap_false.
          <ls_ext_navigation_item>-visible = abap_false.
        ENDIF.
      ENDIF.
*     ... Store the parent key of the current entry if the former is not initial and the latter of type 'APP' (application) and visible
      IF <ls_ext_navigation_item>-type       = if_fpm_constants=>gc_navigation_target_type-application AND
         <ls_ext_navigation_item>-visible    = abap_true AND
         <ls_ext_navigation_item>-parent_key IS NOT INITIAL.
        INSERT <ls_ext_navigation_item>-parent_key INTO TABLE lt_parent_key_visible.
      ENDIF.
    ENDLOOP.
*   Correct the visibility of those external navigation menu item parents that only contain inactive applications
    IF lt_parent_key_visible IS NOT INITIAL.
*     ... Get the further relevant external navigation menu item parents
      lt_parent_key_visible_current = lt_parent_key_visible.
      DO.
        CLEAR lt_parent_key_visible_new.
        LOOP AT lt_parent_key_visible_current ASSIGNING <lv_ext_navigation_item_key>.
          READ TABLE lt_ext_navigation_item
                     ASSIGNING <ls_ext_navigation_item>
                     WITH KEY id  = <ls_ext_navigation>-id
                              key = <lv_ext_navigation_item_key>.
          IF sy-subrc = 0 AND <ls_ext_navigation_item>-parent_key IS NOT INITIAL.
            INSERT <ls_ext_navigation_item>-parent_key INTO TABLE lt_parent_key_visible_new.
          ENDIF.
        ENDLOOP.
        lv_new_visible_parent_found = abap_false.
        LOOP AT lt_parent_key_visible_new ASSIGNING <lv_ext_navigation_item_key>.
          INSERT <lv_ext_navigation_item_key> INTO TABLE lt_parent_key_visible.
          IF sy-subrc = 0.
            lv_new_visible_parent_found = abap_true.
          ELSE.
            DELETE lt_parent_key_visible_new.
          ENDIF.
        ENDLOOP.
        IF lv_new_visible_parent_found = abap_false.
          EXIT.
        ENDIF.
        lt_parent_key_visible_current = lt_parent_key_visible_new.
      ENDDO.
*     ... Correct the visibility of the external navigation menu item parents and their visible children
*         (The latter can only be external navigation menu items of type 'CLB' (column break) or 'SEP' (separator)
      LOOP AT lt_ext_navigation_item ASSIGNING <ls_ext_navigation_item>
                                     WHERE id = <ls_ext_navigation>-id.
        IF <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-folder.
          READ TABLE lt_parent_key_visible
                     TRANSPORTING NO FIELDS
                     WITH TABLE KEY table_line = <ls_ext_navigation_item>-key.
          IF sy-subrc <> 0.
            <ls_ext_navigation_item>-visible = abap_false.
          ENDIF.
        ELSEIF <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-column_break OR
               <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-separator.
          IF <ls_ext_navigation_item>-parent_key IS NOT INITIAL.
            READ TABLE lt_parent_key_visible
                       TRANSPORTING NO FIELDS
                       WITH TABLE KEY table_line = <ls_ext_navigation_item>-parent_key.
            IF sy-subrc <> 0.
              <ls_ext_navigation_item>-visible = abap_false.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.
*   Determine whether the toolbar element for the external navigation menu should be set invisible in the case that there is no visible menu action item
    lv_hide_if_no_visible_opt = xsdbool( mo_fpm IS BOUND ). "enforce rendering a visible toolbar element in the configuration editor since there is no possibility to get the visibility of the menu action items
*   Create a toolbar separator that will be added later in order to separate the other toolbar elements from the external navigation menus
*   (The toolbar separator will only be ceated if there is at least one visible external navigation menu. This check for visible external
*    navigation menus is not necessarily required as the (in)visibility of the menu action items of an external navigation menu might lead
*    to the invisibility of the whole external navigation menu.
*    Additional remark: The toolbar separator will be suppressed automatically by Unified Rendering if all external navigation menus will
*                       be hidden because of no visible items)
    IF iv_add_separator = abap_true AND lv_separator_added = abap_false.
      IF io_toolbar->get_toolbar_items( ) IS NOT INITIAL.
        READ TABLE lt_ext_navigation
                   TRANSPORTING NO FIELDS
                   WITH KEY visibility = cl_wd_uielement=>e_visible-visible.
        IF sy-subrc = 0.
          lo_separator_left = cl_wd_toolbar_separator=>new_toolbar_separator( EXPORTING id = 'FPM_CA_EXT_NAVIGATION_SEPARATOR_' && lv_toolbar_element_id ).
        ENDIF.
      ENDIF.
    ENDIF.
*   Create toolbar element
    CASE lv_ext_nav_menu_uielement_type.
      WHEN lc_ext_nav_menu_uielement_type-button_choice.
        lo_toolbar_button_choice = cl_wd_toolbar_btn_choice=>new_toolbar_btn_choice( EXPORTING enabled                = <ls_ext_navigation>-enabled
                                                                                               hide_if_no_visible_opt = lv_hide_if_no_visible_opt
                                                                                               id                     = lv_toolbar_element_id
                                                                                               repeat_selected_action = abap_false
                                                                                               text                   = lv_text
                                                                                               tooltip                = lv_tooltip
                                                                                               visible                = <ls_ext_navigation>-visibility ).
      WHEN lc_ext_nav_menu_uielement_type-link_choice.
        lo_toolbar_link_choice = cl_wd_toolbar_link_choice=>new_toolbar_link_choice( EXPORTING enabled                = <ls_ext_navigation>-enabled
                                                                                               hide_if_no_visible_opt = lv_hide_if_no_visible_opt
                                                                                               id                     = lv_toolbar_element_id
                                                                                               text                   = lv_text
                                                                                               tooltip                = lv_tooltip
                                                                                               visible                = <ls_ext_navigation>-visibility ).
      WHEN lc_ext_nav_menu_uielement_type-menu_button.
        lo_toolbar_menu_button = cl_wd_toolbar_menu_button=>new_toolbar_menu_button( EXPORTING enabled = <ls_ext_navigation>-enabled
                                                                                               id      = lv_toolbar_element_id
                                                                                               text    = lv_text
                                                                                               tooltip = lv_tooltip
                                                                                               visible = <ls_ext_navigation>-visibility ).
        lo_root_menu = cl_wd_menu=>new_menu( EXPORTING id = |{ lv_toolbar_element_id }| && '_TOP_LEVEL_MENU' ).
        lo_toolbar_menu_button->set_menu( the_menu = lo_root_menu ).
        IF <ls_ext_navigation>-show_folders = abap_true.
          CLEAR lt_menu.
          CLEAR ls_menu.
          ls_menu-menu = lo_root_menu.
          INSERT ls_menu INTO TABLE lt_menu.
        ENDIF.
      WHEN OTHERS.
        ASSERT 0 = 1.
    ENDCASE.
*   Process toolbar element items (external navigation menu items)
    lv_menu_action_item_visible = abap_false.
    LOOP AT lt_ext_navigation_item ASSIGNING <ls_ext_navigation_item>
                                   WHERE id = <ls_ext_navigation>-id.
      lv_tabix = sy-tabix.
*     Check visibility of external navigation menu item
      CHECK <ls_ext_navigation_item>-visible = abap_true. "Just to ensure that only the visible items are rendered; the algorithm would also work without this check
*     Check type of external navigation menu item
      CHECK <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-application OR
            ( <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-folder AND <ls_ext_navigation>-show_folders = abap_true ) OR
            ( ( <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-column_break OR <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-separator ) AND
              <ls_ext_navigation>-show_separators = abap_true ).
*     Check hierarchy level of external navigation menu item
      CHECK <ls_ext_navigation>-maximum_folder_level <= 0 OR
            ( <ls_ext_navigation_item>-type <> if_fpm_constants=>gc_navigation_target_type-folder AND <ls_ext_navigation_item>-hierarchy_level <= <ls_ext_navigation>-maximum_folder_level + 1 ) OR
            ( <ls_ext_navigation_item>-type  = if_fpm_constants=>gc_navigation_target_type-folder AND <ls_ext_navigation_item>-hierarchy_level <= <ls_ext_navigation>-maximum_folder_level ).
*     Adapt toolbar button choice sub item properties
      adapt_toolbar_element_props( EXPORTING iv_toolbar_location = iv_toolbar_location
                                             iv_text             = <ls_ext_navigation_item>-text
                                             iv_image            = <ls_ext_navigation_item>-image
                                             iv_tooltip          = space
                                   IMPORTING ev_text             = lv_text
                                             ev_image            = lv_image ).
      IF <ls_ext_navigation>-show_icons = 'X'.
        lv_image = <ls_ext_navigation_item>-image.
      ELSEIF <ls_ext_navigation>-show_icons = '-'.
        CLEAR lv_image.
      ENDIF.
*     Encode external navigation item key (Required as it is used for the creation of UI element IDs which might contain forbidden characters)
      lv_ext_navigation_item_key_enc = cl_fpm_utils=>encode_ui_element_id( iv_uielement_id = <ls_ext_navigation_item>-key ).
*     Process external navigation menu item, depending on its type
      IF ( lv_ext_nav_menu_uielement_type  <> lc_ext_nav_menu_uielement_type-menu_button AND
           <ls_ext_navigation>-show_folders = abap_true                                  AND
           <ls_ext_navigation_item>-type   = if_fpm_constants=>gc_navigation_target_type-folder ) OR
         <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-application.
*       Create menu action item
        CONCATENATE lv_toolbar_element_id '_'
                    lv_ext_navigation_item_key_enc
                    INTO lv_menu_action_item_id.
        lo_menu_action_item = cl_wd_menu_action_item=>new_menu_action_item( EXPORTING enabled      = <ls_ext_navigation_item>-enabled
                                                                                      id           = lv_menu_action_item_id
                                                                                      image_source = lv_image
                                                                                      on_action    = get_ext_nav_action_name( iv_ext_navigation_category = <ls_ext_navigation>-category )
                                                                                      text         = lv_text
                                                                                      visible      = <ls_ext_navigation_item>-visible ).
*       Map action parameters
        IF <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-application.
          CLEAR lt_parameter.
          CLEAR ls_parameter.
          ls_parameter-name  = if_fpm_constants_internal=>gc_ext_navigation_event_param-external_navigation_id.
          ls_parameter-value = <ls_ext_navigation>-id.
          APPEND ls_parameter TO lt_parameter.
          CLEAR ls_parameter.
          ls_parameter-name  = if_fpm_constants_internal=>gc_ext_navigation_event_param-lpd_role.
          ls_parameter-value = <ls_ext_navigation>-role.
          APPEND ls_parameter TO lt_parameter.
          CLEAR ls_parameter.
          ls_parameter-name  = if_fpm_constants_internal=>gc_ext_navigation_event_param-lpd_instance.
          ls_parameter-value = <ls_ext_navigation>-instance.
          APPEND ls_parameter TO lt_parameter.
          CLEAR ls_parameter.
          ls_parameter-name  = if_fpm_constants_internal=>gc_ext_navigation_event_param-lpd_navigation_target_key.
          ls_parameter-value = <ls_ext_navigation_item>-key.
          APPEND ls_parameter TO lt_parameter.
          CLEAR ls_parameter.
          ls_parameter-name  = if_fpm_constants_internal=>gc_attributes-action_type.
          ls_parameter-value = <ls_ext_navigation>-action_type.
          APPEND ls_parameter TO lt_parameter.
          lo_menu_action_item->map_on_action( lt_parameter ).
        ENDIF.
*       Add menu action item to parent
        CASE lv_ext_nav_menu_uielement_type.
          WHEN lc_ext_nav_menu_uielement_type-button_choice.
            lo_toolbar_button_choice->add_choice( lo_menu_action_item ).
          WHEN lc_ext_nav_menu_uielement_type-link_choice.
            lo_toolbar_link_choice->add_choice( lo_menu_action_item ).
          WHEN lc_ext_nav_menu_uielement_type-menu_button.
            IF <ls_ext_navigation>-show_folders = abap_true.
              READ TABLE lt_menu
                       ASSIGNING <lo_menu>
                       WITH TABLE KEY key = <ls_ext_navigation_item>-parent_key.
            IF sy-subrc = 0.
              <lo_menu>-menu->add_item( the_item = lo_menu_action_item ).
              ENDIF.
            ELSE.
              lo_root_menu->add_item( the_item = lo_menu_action_item ).
            ENDIF.
        ENDCASE.
*       Store whether the menu action item is visible
        IF <ls_ext_navigation_item>-visible = abap_true.
          lv_menu_action_item_visible = abap_true.
        ENDIF.
*       Store whether a separator as next visible external navigation menu item would make sense
        IF lv_separator_possible = abap_false.
          lv_separator_possible = boolc( <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-application AND <ls_ext_navigation_item>-visible = abap_true ).
        ENDIF.
      ELSEIF lv_ext_nav_menu_uielement_type = lc_ext_nav_menu_uielement_type-menu_button AND
             <ls_ext_navigation_item>-type  = if_fpm_constants=>gc_navigation_target_type-folder.
*       Create menu
        CONCATENATE lv_toolbar_element_id '_'
                    lv_ext_navigation_item_key_enc
                    INTO lv_menu_id.
        lo_menu = cl_wd_menu=>new_menu( EXPORTING id           = lv_menu_id
                                                  image_source = lv_image
                                                  title        = <ls_ext_navigation_item>-text
                                                  visible      = <ls_ext_navigation_item>-visible ).
        READ TABLE lt_menu
                   ASSIGNING <lo_menu>
                   WITH TABLE KEY key = <ls_ext_navigation_item>-parent_key.
        IF sy-subrc = 0.
          <lo_menu>-menu->add_item( the_item = lo_menu ).
          CLEAR ls_menu.
          ls_menu-key  = <ls_ext_navigation_item>-key.
          ls_menu-menu = lo_menu.
          INSERT ls_menu INTO TABLE lt_menu.
        ENDIF.
*       Store whether a separator as next visible external navigation menu item would make sense
        IF <ls_ext_navigation_item>-visible = abap_true.
          lv_separator_possible = abap_false.
        ENDIF.
      ELSEIF <ls_ext_navigation>-show_separators = abap_true AND
             ( <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-column_break OR <ls_ext_navigation_item>-type = if_fpm_constants=>gc_navigation_target_type-separator ).
*       Set the external navigation menu item invisible in the case that the next visible external navigation menu item is of type 'CLB' (column break) or 'SEP' (separator) as well
        IF lv_separator_possible = abap_false.
          <ls_ext_navigation_item>-visible = abap_false.
        ELSE.
          LOOP AT lt_ext_navigation_item FROM ( lv_tabix + 1 )
                                         ASSIGNING <ls_ext_navigation_item_next>
                                         WHERE id = <ls_ext_navigation>-id.
            CHECK <ls_ext_navigation_item_next>-visible = abap_true.
            IF <ls_ext_navigation_item_next>-type = if_fpm_constants=>gc_navigation_target_type-application OR
               ( <ls_ext_navigation_item_next>-type = if_fpm_constants=>gc_navigation_target_type-folder AND <ls_ext_navigation>-show_folders = abap_true ).
              EXIT.
            ELSEIF <ls_ext_navigation_item_next>-type = if_fpm_constants=>gc_navigation_target_type-column_break OR
                   <ls_ext_navigation_item_next>-type = if_fpm_constants=>gc_navigation_target_type-separator.
              <ls_ext_navigation_item>-visible = abap_false.
              EXIT.
            ENDIF.
          ENDLOOP.
        ENDIF.
*       Check visibility of external navigation menu item
        CHECK <ls_ext_navigation_item>-visible = abap_true. "Just to ensure that only the visible items are rendered; the algorithm would also work without this check
*       Create menu separator
        IF lv_ext_nav_menu_uielement_type = lc_ext_nav_menu_uielement_type-menu_button. "Separators will currently only be considered in menu buttons
          CONCATENATE lv_toolbar_element_id '_'
                      lv_ext_navigation_item_key_enc
                      INTO lv_menu_separator_id.
          lo_menu_separator = cl_wd_menu_separator=>new_menu_separator( EXPORTING id      = lv_menu_separator_id
                                                                                  visible = <ls_ext_navigation_item>-visible ).
          IF <ls_ext_navigation>-show_folders = abap_true.
            READ TABLE lt_menu
                       ASSIGNING <lo_menu>
                       WITH TABLE KEY key = <ls_ext_navigation_item>-parent_key.
            IF sy-subrc = 0.
              <lo_menu>-menu->add_item( the_item = lo_menu_separator ).
            ENDIF.
          ELSE.
            lo_root_menu->add_item( the_item = lo_menu_separator ).
          ENDIF.
*         Store whether a separator as next visible external navigation menu item would make sense
          lv_separator_possible = boolc( <ls_ext_navigation_item>-visible = abap_false AND lv_separator_possible = abap_true ).
        ENDIF.
      ENDIF.
    ENDLOOP.
*   Do not add the toolbar element for the external navigation menu in the case that there is no visible menu action item
*   (This check is only required in the case of rendering the external navigation menu as menu button because a menu button has no property HIDE_IF_NO_VISIBLE_OPT which could be set appropriately)
    IF lv_ext_nav_menu_uielement_type = lc_ext_nav_menu_uielement_type-menu_button AND
       lv_hide_if_no_visible_opt      = abap_true AND
       lv_menu_action_item_visible    = abap_false.
      CONTINUE.
    ENDIF.
*   Style toolbar element
    CASE lv_ext_nav_menu_uielement_type.
      WHEN lc_ext_nav_menu_uielement_type-button_choice.
        style_uielement( EXPORTING iv_property_string = <ls_ext_navigation>-instance_style
                                   io_uielement       = lo_toolbar_button_choice ).
      WHEN lc_ext_nav_menu_uielement_type-link_choice.
        style_uielement( EXPORTING iv_property_string = <ls_ext_navigation>-instance_style
                                   io_uielement       = lo_toolbar_link_choice ).
      WHEN lc_ext_nav_menu_uielement_type-menu_button.
        style_uielement( EXPORTING iv_property_string = <ls_ext_navigation>-instance_style
                                   io_uielement       = lo_toolbar_menu_button ).
    ENDCASE.
*   Add toolbar element (and separator if necessary)
    IF lo_separator_left IS BOUND.
      io_toolbar->add_toolbar_item( the_toolbar_item = lo_separator_left ).
      lv_separator_added = abap_true.
    ENDIF.
    CASE lv_ext_nav_menu_uielement_type.
      WHEN lc_ext_nav_menu_uielement_type-button_choice.
        io_toolbar->add_toolbar_item( the_toolbar_item = lo_toolbar_button_choice ).
      WHEN lc_ext_nav_menu_uielement_type-link_choice.
        io_toolbar->add_toolbar_item( the_toolbar_item = lo_toolbar_link_choice ).
      WHEN lc_ext_nav_menu_uielement_type-menu_button.
        io_toolbar->add_toolbar_item( the_toolbar_item = lo_toolbar_menu_button ).
    ENDCASE.
    ev_toolbar_elements_added = abap_true.
*   In the case of the FLUID design time mode add the WD context element to the DTA (Design Time Area)
    IF io_fpm_hct_ui_assist IS BOUND.
      io_fpm_hct_ui_assist->add_element_to_dta( iv_view_element_id = lv_toolbar_element_id
                                                io_element_ref     = <ls_ext_navigation>-wd_context_element
                                                iv_tags            = if_fpm_hct_repository=>gc_floorplan_tbar_rev
                                                iv_is_drag_handle  = abap_true ).
    ENDIF.
  ENDLOOP.


ENDMETHOD.


METHOD render_side_panel_link.


  RETURN.


ENDMETHOD.


METHOD render_title_content.


  DATA:
    lt_child_uielement TYPE cl_wd_uielement=>tt_uielement.

  DATA:
    lv_visibility TYPE wdui_visibility VALUE cl_wd_uielement=>e_visible-none.

  FIELD-SYMBOLS:
    <ls_child_uielement> LIKE LINE OF lt_child_uielement.


* Return if there is no title container
  IF io_title_content_container IS NOT BOUND.
    RETURN.
  ENDIF.

* Render link for side panel
  IF get_ui_guideline_version( ) <> if_fpm_constants_internal=>gc_guideline_version-fiori.
    render_side_panel_link( EXPORTING iv_toolbar_location         = iv_toolbar_location
                                      io_parent_container         = io_title_content_container
                                      io_nd_side_panel_link_props = io_nd_side_panel_link_props ).
  ENDIF.

* Set visibility of title content container
  lt_child_uielement = io_title_content_container->get_children( ).
  LOOP AT lt_child_uielement ASSIGNING <ls_child_uielement>.
    IF <ls_child_uielement>->get_visible( ) = cl_wd_uielement=>e_visible-visible.
      lv_visibility = cl_wd_uielement=>e_visible-visible.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF io_title_content_container->get_visible( ) <> lv_visibility.
    io_title_content_container->set_visible( lv_visibility ).
  ENDIF.


ENDMETHOD.


METHOD set_event_param_parent_uibb.


  DATA:
    ls_parent_uibb_key TYPE cl_fpm_event=>ty_s_uibb_key.

  DATA:
    lv_parent_uibb_found TYPE abap_bool.


  me->get_parent_of_event_src_uibb(
    EXPORTING
      io_event             = co_event
      it_uibb              = it_uibb
    IMPORTING
      ev_parent_uibb_found = lv_parent_uibb_found
      es_parent_uibb_key   = ls_parent_uibb_key ).

  IF lv_parent_uibb_found = abap_true.
    co_event->mo_event_data->set_value( iv_key   = if_fpm_constants=>gc_event_param-parent_uibb
                                        iv_value = ls_parent_uibb_key ).
  ENDIF.


ENDMETHOD.


METHOD set_fpm_instance.


  mo_fpm ?= io_fpm.


ENDMETHOD.


METHOD set_msg_area_display_attr.


  DATA:
    lo_wd_message_area TYPE REF TO if_wd_message_area.

  DATA:
    lv_display_empty_lines    TYPE wdy_boolean,
    lv_message_area_display   TYPE fpm_message_area_display,
    lv_condense_identical_msg TYPE fpm_condense_identical_msg,
    lv_show_only_current      TYPE xfeld,
    lv_design                 TYPE i,
    lv_display                TYPE i.


* Get message area settings
  get_msg_area_settings( EXPORTING io_fpm_node_root          = mo_floorplan_data->get_fpm_root_node( )
                         IMPORTING ev_maximum_messages_size  = mv_maximum_messages_size
                                   ev_show_message_log       = mv_show_message_log
                                   ev_display_empty_lines    = lv_display_empty_lines
                                   ev_message_area_design    = mv_message_area_design
                                   ev_message_area_display   = lv_message_area_display
                                   ev_condense_identical_msg = lv_condense_identical_msg ).

* Set display attributes for message area
* ... show only current messages or whole message log
  lv_show_only_current = xsdbool( mv_show_message_log = abap_false ).
* ... message area design
  IF mv_message_area_design IS INITIAL.
    mv_message_area_design = if_fpm_constants_internal=>gc_message_area_design-default.
  ENDIF.
  IF ( get_ui_guideline_version( ) = if_fpm_constants_internal=>gc_guideline_version-fiori OR mv_message_area_design = if_fpm_constants_internal=>gc_message_area_design-notification_icon ) AND
     mv_show_message_log = abap_false.
    mv_message_area_design = if_fpm_constants_internal=>gc_message_area_design-notification_icon.
  ELSEIF mv_show_message_log = abap_true.
*   ... use plain design to have the message log
    mv_message_area_design = if_fpm_constants_internal=>gc_message_area_design-plain.
  ENDIF.
  lv_design = mv_message_area_design.
* ... message area display
  lv_display = lv_message_area_display.
  IF lv_display IS INITIAL.
    lv_display = 1.
  ENDIF.
* ... set display attributes
  lo_wd_message_area = io_wd_window_controller->get_message_area( ).
  IF lo_wd_message_area IS BOUND.
    IF mv_maximum_messages_size > 0.
      lo_wd_message_area->set_display_attributes( i_for_all_instances      = abap_true
                                                  i_msg_lines_visible      = mv_maximum_messages_size
                                                  i_show_only_current      = lv_show_only_current
                                                  i_display_empty_lines    = lv_display_empty_lines
                                                  i_design                 = lv_design
                                                  i_display                = lv_display
                                                  i_condense_identical_msg = lv_condense_identical_msg ).
    ELSE.
      lo_wd_message_area->set_display_attributes( i_for_all_instances      = abap_true
                                                  i_msg_lines_visible      = 3 "According to GL2.0
                                                  i_show_only_current      = lv_show_only_current
                                                  i_display_empty_lines    = lv_display_empty_lines
                                                  i_design                 = lv_design
                                                  i_display                = lv_display
                                                  i_condense_identical_msg = lv_condense_identical_msg ).
    ENDIF.
*   Server side message navigation will work only, if compression of identical messages is turned on
    mo_fpm->mo_message_manager->enable_message_navigation( iv_enable = lv_condense_identical_msg ).
  ENDIF.


ENDMETHOD.


METHOD set_msg_mapper_settings.


  DATA:
    lo_parameter TYPE REF TO if_fpm_parameter.

  DATA:
    lt_parameter_key TYPE if_fpm_parameter=>t_keys.

  DATA:
    ls_config_msg_mapper_settings TYPE fpmfp_s_mm_definition.


* Get message mapper settings from floorplan configuration context
  IF io_fpm_node_root IS BOUND.
    ls_config_msg_mapper_settings = get_config_msg_mapper_settings( io_fpm_node_root = io_fpm_node_root ).
  ENDIF.

* Determine message mapper settings from application/Url parameters and update values if they will not be set anyway
  IF mo_fpm IS BOUND.
    lo_parameter = mo_fpm->if_fpm~mo_app_parameter.
  ENDIF.
  IF lo_parameter IS BOUND.
    lt_parameter_key = lo_parameter->get_keys( ).
*   Enable mapping
    READ TABLE lt_parameter_key
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-enable_message_map.
    IF sy-subrc = 0.
      lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-enable_message_map
                               IMPORTING ev_value = ls_config_msg_mapper_settings-enable_mapping ).
      IF io_fpm_node_root IS NOT BOUND.
        set_msg_mapper_settings_int( EXPORTING iv_enable_mapping = ls_config_msg_mapper_settings-enable_mapping ).
      ENDIF.
    ENDIF.
*   Generalization type
    READ TABLE lt_parameter_key
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-generalization_type.
    IF sy-subrc = 0.
      lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-generalization_type
                               IMPORTING ev_value = ls_config_msg_mapper_settings-generalization_type ).
      IF io_fpm_node_root IS NOT BOUND.
        set_msg_mapper_settings_int( EXPORTING iv_generalization_type = ls_config_msg_mapper_settings-generalization_type ).
      ENDIF.
    ENDIF.
*   Enable logging
    READ TABLE lt_parameter_key
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-always_log.
    IF sy-subrc = 0.
      lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-always_log
                               IMPORTING ev_value = ls_config_msg_mapper_settings-enable_logging ).
      IF io_fpm_node_root IS NOT BOUND.
        set_msg_mapper_settings_int( EXPORTING iv_enable_logging = ls_config_msg_mapper_settings-enable_logging ).
      ENDIF.
    ENDIF.
*   Log generalization
    READ TABLE lt_parameter_key
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-log_on_generalization.
    IF sy-subrc = 0.
      lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-log_on_generalization
                               IMPORTING ev_value = ls_config_msg_mapper_settings-log_generalization ).
      IF io_fpm_node_root IS NOT BOUND.
        set_msg_mapper_settings_int( EXPORTING iv_log_generalization = ls_config_msg_mapper_settings-log_generalization ).
      ENDIF.
    ENDIF.
*   Log hide
    READ TABLE lt_parameter_key
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-log_on_hide.
    IF sy-subrc = 0.
      lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-log_on_hide
                               IMPORTING ev_value = ls_config_msg_mapper_settings-log_hide ).
      IF io_fpm_node_root IS NOT BOUND.
        set_msg_mapper_settings_int( EXPORTING iv_log_hide = ls_config_msg_mapper_settings-log_hide ).
      ENDIF.
    ENDIF.
*   Hide on generalization
    READ TABLE lt_parameter_key
               TRANSPORTING NO FIELDS
               WITH KEY table_line = if_fpm_constants=>gc_app_params-hide_on_generalization.
    IF sy-subrc = 0.
      lo_parameter->get_value( EXPORTING iv_key   = if_fpm_constants=>gc_app_params-hide_on_generalization
                               IMPORTING ev_value = ls_config_msg_mapper_settings-hide_on_generalization ).
      IF io_fpm_node_root IS NOT BOUND.
        set_msg_mapper_settings_int( EXPORTING iv_hide_on_generalization = ls_config_msg_mapper_settings-hide_on_generalization ).
      ENDIF.
    ENDIF.
  ENDIF.

* Set new message mapper settings
  IF io_fpm_node_root IS BOUND.
    set_msg_mapper_settings_int( EXPORTING iv_enable_mapping         = ls_config_msg_mapper_settings-enable_mapping
                                           iv_generalization_type    = ls_config_msg_mapper_settings-generalization_type
                                           iv_enable_logging         = ls_config_msg_mapper_settings-enable_logging
                                           iv_log_generalization     = ls_config_msg_mapper_settings-log_generalization
                                           iv_log_hide               = ls_config_msg_mapper_settings-log_hide
                                           iv_hide_on_generalization = ls_config_msg_mapper_settings-hide_on_generalization ).
  ENDIF.


ENDMETHOD.


METHOD set_msg_mapper_settings_int.


  DATA:
    ls_msg_mapper_attribute LIKE LINE OF mo_fpm->mo_message_manager->gt_msg_mapper_attributes.

  FIELD-SYMBOLS:
    <ls_msg_mapper_attribute> LIKE ls_msg_mapper_attribute.


  IF mo_fpm IS NOT BOUND.
    RETURN.
  ENDIF.

  IF iv_enable_mapping IS SUPPLIED.
    READ TABLE mo_fpm->mo_message_manager->gt_msg_mapper_attributes
               ASSIGNING <ls_msg_mapper_attribute>
               WITH KEY name = if_fpm_constants=>gc_app_params-enable_message_map.
    IF sy-subrc = 0.
      <ls_msg_mapper_attribute>-value = iv_enable_mapping.
    ELSE.
      CLEAR ls_msg_mapper_attribute.
      ls_msg_mapper_attribute-name  = if_fpm_constants=>gc_app_params-enable_message_map.
      ls_msg_mapper_attribute-value = iv_enable_mapping.
      APPEND ls_msg_mapper_attribute TO mo_fpm->mo_message_manager->gt_msg_mapper_attributes.
    ENDIF.
  ENDIF.

  IF iv_generalization_type IS SUPPLIED.
    READ TABLE mo_fpm->mo_message_manager->gt_msg_mapper_attributes
               ASSIGNING <ls_msg_mapper_attribute>
               WITH KEY name = if_fpm_constants=>gc_app_params-generalization_type.
    IF sy-subrc = 0.
      <ls_msg_mapper_attribute>-value = iv_generalization_type.
    ELSE.
      CLEAR ls_msg_mapper_attribute.
      ls_msg_mapper_attribute-name  = if_fpm_constants=>gc_app_params-generalization_type.
      ls_msg_mapper_attribute-value = iv_generalization_type.
      APPEND ls_msg_mapper_attribute TO mo_fpm->mo_message_manager->gt_msg_mapper_attributes.
    ENDIF.
  ENDIF.

  IF iv_enable_logging IS SUPPLIED.
    READ TABLE mo_fpm->mo_message_manager->gt_msg_mapper_attributes
               ASSIGNING <ls_msg_mapper_attribute>
               WITH KEY name = if_fpm_constants=>gc_app_params-always_log.
    IF sy-subrc = 0.
      <ls_msg_mapper_attribute>-value = iv_enable_logging.
    ELSE.
      CLEAR ls_msg_mapper_attribute.
      ls_msg_mapper_attribute-name  = if_fpm_constants=>gc_app_params-always_log.
      ls_msg_mapper_attribute-value = iv_enable_logging.
      APPEND ls_msg_mapper_attribute TO mo_fpm->mo_message_manager->gt_msg_mapper_attributes.
    ENDIF.
  ENDIF.

  IF iv_log_generalization IS SUPPLIED.
    READ TABLE mo_fpm->mo_message_manager->gt_msg_mapper_attributes
               ASSIGNING <ls_msg_mapper_attribute>
               WITH KEY name = if_fpm_constants=>gc_app_params-log_on_generalization.
    IF sy-subrc = 0.
      <ls_msg_mapper_attribute>-value = iv_log_generalization.
    ELSE.
      CLEAR ls_msg_mapper_attribute.
      ls_msg_mapper_attribute-name  = if_fpm_constants=>gc_app_params-log_on_generalization.
      ls_msg_mapper_attribute-value = iv_log_generalization.
      APPEND ls_msg_mapper_attribute TO mo_fpm->mo_message_manager->gt_msg_mapper_attributes.
    ENDIF.
  ENDIF.

  IF iv_log_hide IS SUPPLIED.
    READ TABLE mo_fpm->mo_message_manager->gt_msg_mapper_attributes
               ASSIGNING <ls_msg_mapper_attribute>
               WITH KEY name = if_fpm_constants=>gc_app_params-log_on_hide.
    IF sy-subrc = 0.
      <ls_msg_mapper_attribute>-value = iv_log_hide.
    ELSE.
      CLEAR ls_msg_mapper_attribute.
      ls_msg_mapper_attribute-name  = if_fpm_constants=>gc_app_params-log_on_hide.
      ls_msg_mapper_attribute-value = iv_log_hide.
      APPEND ls_msg_mapper_attribute TO mo_fpm->mo_message_manager->gt_msg_mapper_attributes.
    ENDIF.
  ENDIF.

  IF iv_hide_on_generalization IS SUPPLIED.
    READ TABLE mo_fpm->mo_message_manager->gt_msg_mapper_attributes
               ASSIGNING <ls_msg_mapper_attribute>
               WITH KEY name = if_fpm_constants=>gc_app_params-hide_on_generalization.
    IF sy-subrc = 0.
      <ls_msg_mapper_attribute>-value = iv_hide_on_generalization.
    ELSE.
      CLEAR ls_msg_mapper_attribute.
      ls_msg_mapper_attribute-name  = if_fpm_constants=>gc_app_params-hide_on_generalization.
      ls_msg_mapper_attribute-value = iv_hide_on_generalization.
      APPEND ls_msg_mapper_attribute TO mo_fpm->mo_message_manager->gt_msg_mapper_attributes.
    ENDIF.
  ENDIF.


ENDMETHOD.


METHOD style_uielement.


  DATA:
    lv_component_name TYPE string.


* Return if there is no UI element to style or no style manager
  IF io_uielement IS NOT BOUND OR mo_instance_style_manager IS NOT BOUND.
    RETURN.
  ENDIF.

* Get component name
  IF mo_component IS BOUND.
    lv_component_name = mo_component->get_component_info( )->get_name( ).
  ENDIF.

* Style UI element
  mo_instance_style_manager->style_uielement( EXPORTING iv_property_string = iv_property_string
                                                        io_uielement       = io_uielement
                                                        iv_component_name  = lv_component_name ).


ENDMETHOD.


METHOD terminate.


  DATA:
    lo_error_details   TYPE REF TO if_fpm_error_details,
    lo_message_manager TYPE REF TO if_wd_message_manager.

  DATA:
    ls_t100_message TYPE symsg.


* Set termination indicator
  mv_needs_termination = abap_true.

* Return if the message should be suppressed
  IF iv_suppress_message = abap_true.
    RETURN.
  ENDIF.

* Fill message structure
  IF is_t100 IS INITIAL.
    IF mo_component IS BOUND.
      ls_t100_message-msgty = if_fpm_guibb_constants=>gc_severity-error.
      ls_t100_message-msgid = if_fpm_constants_internal=>gc_message_id-core.
      ls_t100_message-msgno = '110'.
      ls_t100_message-msgv1 = mo_component->get_application( )->get_application_info( )->get_name( ).
    ELSE.
      ls_t100_message-msgty = if_fpm_guibb_constants=>gc_severity-error.
      ls_t100_message-msgid = if_fpm_constants_internal=>gc_message_id-core.
      ls_t100_message-msgno = '113'.
    ENDIF.
  ELSE.
    ls_t100_message = is_t100.
  ENDIF.

* Call error page or report message
  IF mo_fpm IS BOUND AND iv_display_error_page = abap_true.
    lo_error_details = cl_fpm_error_factory=>create_from_t100( is_t100 = ls_t100_message ).
    mo_fpm->if_fpm~display_error_page( io_error_details = lo_error_details ).
  ELSEIF mo_component IS BOUND.
    lo_message_manager = mo_component->get_message_manager( ).
    IF lo_message_manager IS BOUND.
      lo_message_manager->report_t100_message( msgid               = ls_t100_message-msgid
                                               msgno               = ls_t100_message-msgno
                                               msgty               = ls_t100_message-msgty
                                               p1                  = ls_t100_message-msgv1
                                               p2                  = ls_t100_message-msgv2
                                               p3                  = ls_t100_message-msgv3
                                               p4                  = ls_t100_message-msgv4
                                               is_permanent        = abap_true
                                               scope_permanent_msg = cl_wdr_message_manager=>if_wd_message_manager~co_msg_scope_component
                                               component           = mo_component ).
    ENDIF.
  ELSE.
    ASSERT 0 = 1.
  ENDIF.


ENDMETHOD.


METHOD toggle_mode.


  DATA:
    lo_nd_info           TYPE REF TO if_wd_context_node_info,
    lo_nd_info_view_data TYPE REF TO if_wd_context_node_info,
    lo_nd_view_data      TYPE REF TO if_wd_context_node,
    lo_el_view_data      TYPE REF TO if_wd_context_element,
    lo_fpm_event         TYPE REF TO cl_fpm_event.

  DATA:
    lt_child_node TYPE wdr_context_child_info_map.

  DATA:
    lv_designtime_mode_active_old TYPE wdy_boolean,
    lv_designtime_mode_active_new TYPE wdy_boolean,
    lv_action_type                TYPE fpm_action_type VALUE if_fpm_constants=>gc_action_type-standard.


* Set new designtime mode
  lv_designtime_mode_active_new = xsdbool( mo_fpm->mv_designtime_mode = abap_false ).

* Set new design time mode in WD context
  IF io_wd_context IS BOUND.
    lo_nd_info = io_wd_context->get_node_info( ).
    IF lo_nd_info IS NOT BOUND.
      RETURN.
    ENDIF.
    lt_child_node = lo_nd_info->get_child_nodes( ).
    READ TABLE lt_child_node
               TRANSPORTING NO FIELDS
               WITH TABLE KEY name = if_fpm_constants_internal=>gc_attributes-view_data.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    lo_nd_view_data = io_wd_context->get_child_node( name = if_fpm_constants_internal=>gc_attributes-view_data ).
    IF lo_nd_view_data IS NOT BOUND.
      RETURN.
    ENDIF.
    lo_nd_info_view_data = lo_nd_view_data->get_node_info( ).
    IF lo_nd_info_view_data IS NOT BOUND OR lo_nd_info_view_data->has_attribute( name = if_fpm_constants_internal=>gc_attributes-designtime_mode ) = abap_false.
      RETURN.
    ENDIF.
    lo_el_view_data = lo_nd_view_data->get_element( ).
    IF lo_el_view_data IS NOT BOUND.
      RETURN.
    ENDIF.
    lo_el_view_data->get_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-designtime_mode
                                    IMPORTING value = lv_designtime_mode_active_old ).
    IF lv_designtime_mode_active_old <> lv_designtime_mode_active_new.
      lo_el_view_data->set_attribute( EXPORTING name  = if_fpm_constants_internal=>gc_attributes-designtime_mode
                                                value = lv_designtime_mode_active_new ).
    ENDIF.
  ENDIF.

* Determine action type for the FPM event
  IF io_wd_action IS BOUND.
    IF io_wd_action->is_validating = abap_false.
      lv_action_type = if_fpm_constants=>gc_action_type-validation_independent.
    ENDIF.
  ENDIF.

* Raise event for the change of the design time mode
  lo_fpm_event = cl_fpm_event=>create_by_id( iv_event_id    = if_fpm_constants=>gc_event-switch_mode
                                             iv_action_type = lv_action_type ).
  lo_fpm_event->mo_event_data->set_value( EXPORTING iv_key   = if_fpm_constants=>gc_event_param-designtime_mode
                                                    iv_value = lv_designtime_mode_active_new ).
  mo_fpm->if_fpm~raise_event( lo_fpm_event ).


ENDMETHOD.


METHOD toggle_quick_help.


  DATA:
    lv_show_explanation TYPE abap_bool.


* Toggle activity status of Quick Help
  lv_show_explanation = xsdbool( mo_component->get_application( )->get_show_explanation( ) = abap_false ).
  mo_component->get_application( )->set_show_explanation( lv_show_explanation ).


ENDMETHOD.


METHOD trigger_lpd_navigation.


  DATA:
    lo_navigation TYPE REF TO if_fpm_navigation.

  DATA:
    ls_navigation_key TYPE fpm_s_navigation_key.


* Return if there is no valid navigation target
  IF iv_lpd_role           IS INITIAL OR
     iv_lpd_instance       IS INITIAL OR
     iv_lpd_application_id IS INITIAL.
    RETURN.
  ENDIF.

* Get navigation instance
  CLEAR ls_navigation_key.
  ls_navigation_key-key1 = iv_lpd_role.
  ls_navigation_key-key2 = iv_lpd_instance.
  lo_navigation = mo_fpm->if_fpm~get_navigation( is_key = ls_navigation_key ).
  IF lo_navigation IS NOT BOUND.
    RETURN.
  ENDIF.

* Trigger navigation
  lo_navigation->navigate( iv_target_key = iv_lpd_application_id ).


ENDMETHOD.
ENDCLASS.