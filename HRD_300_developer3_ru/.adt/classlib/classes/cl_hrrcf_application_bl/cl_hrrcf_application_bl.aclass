class CL_HRRCF_APPLICATION_BL definition
  public
  final
  create private .

public section.
  type-pools RSDS .

  interfaces IF_HRRCF_CONSTANTS .

  aliases DELETE
    for IF_HRRCF_CONSTANTS~DELETE_OPERATION .
  aliases FALSE
    for IF_HRRCF_CONSTANTS~FALSE .
  aliases HIGH_DATE
    for IF_HRRCF_CONSTANTS~HIGH_DATE .
  aliases INSERT
    for IF_HRRCF_CONSTANTS~INSERT_OPERATION .
  aliases LOW_DATE
    for IF_HRRCF_CONSTANTS~LOW_DATE .
  aliases MODIFY
    for IF_HRRCF_CONSTANTS~MODIFY_OPERATION .
  aliases MSGCL_ADMIN
    for IF_HRRCF_CONSTANTS~MSGCL_ADMIN .
  aliases MSGCL_USER
    for IF_HRRCF_CONSTANTS~MSGCL_USER .
  aliases TRUE
    for IF_HRRCF_CONSTANTS~TRUE .

  constants C_DRAFT type RCF_APPLICATION_STATUS value '0'. "#EC NOTEXT
  constants C_IN_PROCESS type RCF_APPLICATION_STATUS value '1'. "#EC NOTEXT
  constants C_WITHDRAWN type RCF_APPLICATION_STATUS value '2'. "#EC NOTEXT
  constants C_REJECTED type RCF_APPLICATION_STATUS value '3'. "#EC NOTEXT
  constants C_TO_BE_HIRED type RCF_APPLICATION_STATUS value '4'. "#EC NOTEXT
  constants CO_OTYPE type OTYPE value 'ND'. "#EC NOTEXT
  constants CO_SOURCE_REGISTERED type RCF_TECH_APPL_SOURCE value ' '. "#EC NOTEXT
  constants CO_SOURCE_UNREGISTERED type RCF_TECH_APPL_SOURCE value 'U'. "#EC NOTEXT
  constants CO_SOURCE_MANUAL type RCF_TECH_APPL_SOURCE value 'M'. "#EC NOTEXT

  methods CHANGE_APPLICATION_INFO
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !P_APPL_STATUS type RCF_APPLICATION_STATUS optional
      !P_APPL_DATE type RCF_APPLICATION_DATE optional
      !P_APPL_COVER_LETTER type RCF_ITF_DESCRIPTION optional
      !P_PINST_GUID type RCF_PINST_GUID optional
      !P_TECH_APPL_SOURCE type RCF_TECH_APPL_SOURCE optional
      !P_REASON_CODE type RCF_REASON_CODE optional
      !P_APPL_SOURCE type RCF_APPL_SOURCE optional
      !P_APPL_SOURCE_INFO type RCF_APPL_SOURCE_INFO optional
      !P_SCLAS type SCLAS optional
      !P_SOBID type SOBID optional
      !P_EXPIRATION_DATE type RCF_EXPIRATION_DATE optional
      !P_APPL_SOURCE_PERNR type PERNR_D optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods CHANGE_APPLICATION_STATUS
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !P_NEW_STATUS type RCF_APPLICATION_STATUS
      !P_CHECK_ONLY type BOOLE_D default SPACE
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods CHECK_APPL_EXISTENCE
    importing
      !PS_POST_HROBJECT type HROBJECT
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !PS_APPL_HROBJECT type HROBJECT
      !P_APPL_STATUS type RCF_APPLICATION_STATUS_SEL
      !P_IS_OPEN type BOOLE_D
    raising
      CX_HRRCF .
  methods CHECK_AUTHORISATION_DOVR
    importing
      !APPL_HROBJECT type HROBJECT
    raising
      CX_HRRCF .
  methods CONSTRUCTOR .
  methods CREATE_APPLICATION
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !P_PINST_GUID type RCF_PINST_GUID
      !P_APPL_STATUS type RCF_APPLICATION_STATUS default '1'
      !P_APPL_DATE type RCF_APPLICATION_DATE default SY-DATUM
      !P_APPL_COVER_LETTER type RCF_ITF_DESCRIPTION optional
      !P_LANGU type SPRAS default SY-LANGU
      !P_TECH_APPL_SOURCE type RCF_TECH_APPL_SOURCE
      !P_REASON_CODE type RCF_REASON_CODE optional
      !P_SCLAS type SCLAS optional
      !P_SOBID type SOBID optional
      !P_APPL_SOURCE type RCF_APPL_SOURCE optional
      !P_APPL_SOURCE_INFO type RCF_APPL_SOURCE_INFO optional
    exporting
      !PO_APPLICATION type ref to CL_HRRCF_CANDIDATE_APPLICATION
      !PO_CANDIDACY type ref to CL_HRRCF_CANDIDACY
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods CREATE_REC_TEAM_BY_DEFAULT
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !PS_REQ_HROBJECT type HROBJECT optional
      !P_CHECK_ONLY type BOOLE_D default SPACE
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods DELETE_DRAFT_APPLICATION
    importing
      !APPL_HROBJECT type HROBJECT
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods DEQUEUE_APPLICATION
    importing
      !PS_APPL_HROBJECT type HROBJECT
    raising
      CX_HRRCF .
  methods ENQUEUE_APPLICATION
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods GET_APPLICATIONS_OF_SEL
    importing
      !P_APPL_STATUS type RCF_SELECTED_STATUS optional
      !P_USER type SYUNAME optional
      !P_ROLE type RCF_ROLE optional
      !P_BEGDA type BEGDATUM optional
      !P_ENDDA type ENDDATUM optional
      !P_WITHOUT_FURTHER_ASSIGN type BOOLE_D default FALSE
      !P_APPL_SOURCE type RCF_APPL_SOURCE optional
    exporting
      !PT_APPLICATIONS type RCF_T_HROBJECT
    raising
      CX_HRRCF .
  methods GET_APPLICATIONS_OF_SELECTION
    importing
      !P_APPL_STATUS type RCF_SELECTED_STATUS optional
      !P_USER type SYUNAME optional
      !P_ROLE type RCF_ROLE optional
      !P_BEGDA type BEGDATUM optional
      !P_ENDDA type ENDDATUM optional
      !P_WITHOUT_FURTHER_ASSIGN type BOOLE_D default FALSE
      !P_APPL_SOURCE type RCF_APPL_SOURCE optional
    exporting
      !PT_APPLICATIONS type RCF_T_HROBJECT
    raising
      CX_HRRCF .
  methods GET_APPLICATION_INFO_X
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !X_PI_INFO_REQUIRED type BOOLE_D default TRUE
    exporting
      !PS_APPL_INFO_X type RCF_S_LIST_APPLICATIONS_X .
  methods GET_APPLICATION_INFO_X2
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !P_NR_CDCY_NOT_REQUESTED type BOOLE_D optional
    exporting
      !PS_APPL_INFO_X type RCF_S_LIST_APPLICATIONS_X .
  methods GET_APPLICATION_LIST_X
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !PS_REQ_HROBJECT type HROBJECT optional
    exporting
      !PT_APPLICATIONS_X type RCF_T_LIST_APPLICATIONS_X
    raising
      CX_HRRCF .
  methods GET_APPLICATION_STATUS
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !P_STATUS type RCF_APPLICATION_STATUS
      !P_STATUS_TXT type DDTEXT
      !P_REASON_CODE type RCF_REASON_CODE
      !P_REASON_CODE_TXT type RCF_REASON_CODE_TXT
    raising
      CX_HRRCF .
  methods GET_APPLICATION_STATUS_LIST
    returning
      value(PT_STATUS_LIST) type DDFIXVALUES
    raising
      CX_HRRCF .
  methods GET_APPL_COVER_LETTER
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !P_LANGU type SPRAS default SY-LANGU
    exporting
      !PS_APPL_DESCRIPTION type RCF_S_ITF_DESCRIPTION
    raising
      CX_HRRCF .
  methods GET_APPL_CREATE_DATE
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !P_CREATE_DATE type DATS .
  methods GET_APPL_DOCUMENTS
    importing
      !APPL_HROBJECT type HROBJECT
    exporting
      !DOCUMENTS type RCF_T_QA_ACTIVITY_TXT
    raising
      CX_HRRCF .
  methods GET_APPL_OPERATIVE_DATE
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !P_APPL_DATE type RCF_APPLICATION_DATE .
  methods GET_AUDIT_TRAIL
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !PT_AUDIT_TRAIL type RCF_T_AUDIT_TRAIL
      !PT_VERSION_INFO type RCF_T_VERSION_AUDIT_TRAIL
    raising
      CX_HRRCF .
  methods GET_CANDIDACY
    importing
      !PS_APPL_HROBJECT type HROBJECT
    returning
      value(PS_CDCY_HROBJECT) type HROBJECT
    raising
      CX_HRRCF .
  methods GET_CANDIDATE
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !P_CAND_HROBJECT type HROBJECT
      !P_CAND_NAME type BU_NAME1TX
      !P_CAND_DESCRIPTION type BU_DESCRIP
      !P_EMPLOYEEID type PERNR_D
      !P_IS_EMPLOYEE type BOOLE_D
      !P_USER type SYUNAME
    raising
      CX_HRRCF .
  class-methods GET_INSTANCE
    returning
      value(RETURN) type ref to CL_HRRCF_APPLICATION_BL .
  methods GET_NR_APPL
    importing
      !PS_REQ_HROBJECT type HROBJECT optional
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_NR_APPL type INT4
      !P_NR_APPL_OPEN type INT4
      !P_NR_APPL_NO_DRAFT type INT4
      !P_NR_APPL_IN_PROCESS type INT4
    raising
      CX_HRRCF .
  methods GET_REQUISITION
    importing
      !PS_APPL_HROBJECT type HROBJECT
    returning
      value(PS_REQ_HROBJECT) type HROBJECT
    raising
      CX_HRRCF .
  methods GET_STATUS_HISTORY
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !PT_STATUS_HISTORY type RCF_T_STATUS_HISTORY
    raising
      CX_HRRCF .
  methods SUBMIT_APPLICATION
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !PS_CDCY_HROBJECT type HROBJECT optional
      !P_CHECK_ONLY type BOOLE_D default SPACE
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods UPDATE_COVER_LETTER
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !P_APPL_COVER_LETTER type RCF_ITF_DESCRIPTION
    exporting
      !P_APPL_DESC type RCF_APPLICATION_DESCRIPTION
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods GET_STATUS_RESPONSIBLE
    importing
      value(PS_APPL_HROBJECT) type HROBJECT
      !P_STATUS type RCF_APPLICATION_STATUS
    exporting
      !P_RES_SCLAS type SCLAS
      !P_RES_SOBID type SOBID
    raising
      CX_HRRCF .
  methods GET_APPLICATIONS
    importing
      !PS_CAND_HROBJECT type HROBJECT
      !P_LANGU type SPRAS default SY-LANGU
    exporting
      !PT_APPLICATIONS type RCF_T_CAND_APPL_LIST
    raising
      CX_HRRCF .
  methods GET_APPLICATION_SOURCE
    importing
      !PS_APPL_HROBJECT type HROBJECT
      !P_LANGU type SPRAS default SY-LANGU
    exporting
      !PS_APPLICATION_SOURCE type RCF_S_APPLICATION_SOURCE
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods GET_OPEN_CANDIDACY
    importing
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !PS_CDCY_HROBJECT type HROBJECT
    raising
      CX_HRRCF .
  methods FETCH_CANDIDATES
    importing
      !PT_APPL_HROBJECT type RCF_T_HROBJECT
    exporting
      !PT_APPL_CAND type RCF_T_APPL_CAND .
  methods GET_APPL_LIST
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !PT_APPLICATIONS type RCF_T_HROBJECT optional
    exporting
      !PT_APPL_LIST type RCF_T_LIST_APPLICATIONS_X .
  methods CLEAR_BUFFER_TABS .
  class-methods ON_APPL_ACTIVITY_CHANGED
    importing
      !IR_INFOTYPE type ref to CL_HRRCF_INFOTYPE
      !IT_BEFORE_IMAGE type WPLOG_TAB .
  methods GET_EXT_APPLICATION_LIST
    exporting
      !P_EXT_APPLICATION_LIST type RCF_T_APPLICATION_ID_LIST .
  methods IS_APPL_OF_CURRENT_USER
    importing
      !IS_APPL type HROBJECT
    returning
      value(RV_FOR_CURRENT_USER) type BOOLE_D .
  methods CHECK_APPL_DUPLICATE
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !PS_APPL_HROBJECT type HROBJECT
    exporting
      !P_IS_OPEN type BOOLE_D .
protected section.
*"* protected components of class CL_HRRCF_APPLICATION_BL
*"* do not include other source files here!!!
private section.

*"* private components of class CL_HRRCF_APPLICATION_BL
*"* do not include other source files here!!!
  class-data INSTANCE type ref to CL_HRRCF_APPLICATION_BL .
  data REF_CDCY_BL type ref to CL_HRRCF_CANDIDACY_BL .
  data REF_PINST_BL type ref to CL_HRRCF_POSTING_INST_BL .
  data REF_APPL_WL type ref to CL_HRRCF_APPLICATION_WL .
  data GT_POST_TXT type LT_POSTING_TXT .
  data GT_5122 type LT_5122 .
  data GT_REQLIST type LT_REQLIST .

  methods FILTER_OUT_FURTH_ASSIGN
    changing
      !PT_APPL_HROBJECT type RCF_T_HROBJECT
    raising
      CX_HRRCF .
  class-methods BUILD_FROMCLAUSE
    importing
      !PT_SELECTIONS type RSDS_TRANGE
    exporting
      !P_FROM_CLAUSE type STRING
    raising
      CX_HRRCF_WORKLIST .
  class-methods BUILD_WHERECLAUSE
    importing
      !PT_SELECTIONS type RSDS_TRANGE
    exporting
      !PT_WHERE_CLAUSE type RSDS_WHERE_TAB
    raising
      CX_HRRCF_WORKLIST .
  class-methods TRANSFORM_SELECTIONS
    importing
      !P_APPL_STATUS type RCF_SELECTED_STATUS optional
      !P_USER type SYUNAME optional
      !P_ROLE type RCF_ROLE optional
      !P_BEGDA type BEGDATUM optional
      !P_ENDDA type ENDDATUM optional
      !P_APPL_SOURCE type RCF_APPL_SOURCE optional
    exporting
      !PT_SELECTIONS type RSDS_TRANGE
      !PT_MEMBER type RCF_T_MEMBER .
  methods FETCH_APPLICATIONS
    importing
      !P_APPL_STATUS type RCF_SELECTED_STATUS optional
      !P_USER type SYUNAME optional
      !P_ROLE type RCF_ROLE optional
      !P_BEGDA type BEGDATUM optional
      !P_ENDDA type ENDDATUM optional
      !P_APPL_SOURCE type RCF_APPL_SOURCE optional
    exporting
      !PT_APPL_HROBJECT type RCF_T_HROBJECT
    raising
      CX_HRRCF .
  class-methods ADD_SPECIFIC_WHERE_CLAUSE
    importing
      !P_ROLE type RCF_ROLE optional
      !P_USER type SYUNAME optional
    changing
      !PT_WHERE_CLAUSE type RSDS_WHERE_TAB .
  class-methods ADD_SPECIFIC_WHERE_SELECTION
    importing
      !P_ROLE type RCF_ROLE optional
      !P_USER type SY-UNAME default SY-UNAME
    exporting
      !PT_SELECTIONS type RSDS_TRANGE .
  class-methods MAINTAIN_RD_DOC_STATISTICS
    importing
      !IS_HROBJECT type HROBJECT
    raising
      CX_HRRCF .
ENDCLASS.



CLASS CL_HRRCF_APPLICATION_BL IMPLEMENTATION.


METHOD add_specific_where_clause.

  DATA:
      lv_where_clause   TYPE rsdswhere,
      lt_where_clause   TYPE rsds_where_tab,
      lt_f_in_w_clause  TYPE rsds_where_tab,
      lt_selections     TYPE rsds_trange,
      lv_from_clause    TYPE string.

  FIELD-SYMBOLS:
      <where_clause> TYPE rsdswhere.


  LOOP AT pt_where_clause ASSIGNING <where_clause>.
    AT FIRST.
      lv_where_clause = <where_clause>.
      CONCATENATE '(' lv_where_clause INTO <where_clause> SEPARATED BY space.
    ENDAT.

    AT LAST.
      lv_where_clause = <where_clause>.
      CONCATENATE lv_where_clause ')' INTO <where_clause> SEPARATED BY space.
    ENDAT.
  ENDLOOP.

* Fill lv_where_clause with 'OR' part
  CLEAR lv_where_clause.
  CONCATENATE 'OR' '( B~sobid IN ( SELECT DISTINCT M~objid' "#EC NOTEXT
    INTO lv_where_clause SEPARATED BY space.
  APPEND lv_where_clause TO pt_where_clause.

* Build small from clause
  CLEAR lv_where_clause.
  CONCATENATE 'FROM' '( hrp5152 AS M'                       "#EC NOTEXT
    INTO lv_where_clause SEPARATED BY space.
  APPEND lv_where_clause TO lt_f_in_w_clause.

  CLEAR lv_where_clause.
  CONCATENATE 'JOIN' 'hrp5151 AS N'                         "#EC NOTEXT
    INTO lv_where_clause SEPARATED BY space.
  APPEND lv_where_clause TO lt_f_in_w_clause.

  CLEAR lv_where_clause.
  CONCATENATE 'ON' 'N~plvar = M~plvar'                      "#EC NOTEXT
    INTO lv_where_clause SEPARATED BY space.
  APPEND lv_where_clause TO lt_f_in_w_clause.

  CLEAR lv_where_clause.
  CONCATENATE 'AND' 'N~otjid = M~otjid'                     "#EC NOTEXT
    INTO lv_where_clause SEPARATED BY space.
  APPEND lv_where_clause TO lt_f_in_w_clause.

  CLEAR lv_where_clause.
  CONCATENATE 'AND' 'N~status = `1` )'                      "#EC NOTEXT
    INTO lv_where_clause SEPARATED BY space.
  APPEND lv_where_clause TO lt_f_in_w_clause.

  APPEND LINES OF lt_f_in_w_clause TO pt_where_clause.

* Fill lt_selections
  CALL METHOD cl_hrrcf_application_bl=>add_specific_where_selection
    EXPORTING
      p_role        = p_role
      p_user        = p_user
    IMPORTING
      pt_selections = lt_selections.

  TRY.
      CALL METHOD cl_hrrcf_application_bl=>build_whereclause
        EXPORTING
          pt_selections   = lt_selections
        IMPORTING
          pt_where_clause = lt_where_clause.

* Add final bracket
      CLEAR lv_where_clause.
      LOOP AT lt_where_clause ASSIGNING <where_clause>.
        AT FIRST.
          REPLACE FIRST OCCURRENCE OF '(' IN <where_clause> WITH 'WHERE'.
          REPLACE FIRST OCCURRENCE OF ')' IN <where_clause> WITH space.
        ENDAT.

        AT LAST.
          lv_where_clause = <where_clause>.
          CONCATENATE lv_where_clause ')' INTO <where_clause> SEPARATED BY space.
        ENDAT.
      ENDLOOP.

      APPEND LINES OF lt_where_clause TO pt_where_clause.

    CATCH cx_hrrcf_worklist.
  ENDTRY.

ENDMETHOD.


METHOD add_specific_where_selection.

* Author: PEV

  DATA: ls_wl_field_sel TYPE rcf_s_wl_sel_pv,
        lt_wl_field_sel TYPE rcf_t_wl_sel_pv,
        ls_selections   TYPE rsds_range,
        ls_rsds_frange  TYPE rsds_frange,
        ls_selopt       TYPE rsdsselopt,
        ls_selection    TYPE rsds_range,
        lv_hrp_tabname  TYPE tabname,
        lv_plvar        TYPE plvar.


*-- 1. Selection of HR objects from HRP5152
  CLEAR: lv_hrp_tabname, ls_selection.
  CONCATENATE 'HRP' '5152' INTO lv_hrp_tabname.

*  plan variant
  CLEAR: ls_selopt, ls_rsds_frange.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = lv_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

  ls_selopt-sign      = 'I'.
  ls_selopt-option = 'EQ'.
  ls_selopt-low       = lv_plvar.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = 'PLVAR'.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*   object type
  CLEAR: ls_selopt, ls_rsds_frange.

  ls_selopt-sign      = 'I'.
  ls_selopt-option = 'EQ'.
  ls_selopt-low       = 'NG'.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = 'OTYPE'.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*   sclas
  CLEAR: ls_selopt, ls_rsds_frange.

  ls_selopt-sign      = 'I'.
  ls_selopt-option = 'EQ'.
  ls_selopt-low       = 'US'.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = 'SCLAS'.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*   sobid
  CLEAR: ls_selopt, ls_rsds_frange.

  ls_selopt-sign      = 'I'.
  ls_selopt-option = 'EQ'.
  ls_selopt-low       = p_user.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = 'SOBID'.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

  IF p_role IS NOT INITIAL.
*   role
    CLEAR: ls_selopt, ls_rsds_frange.

    ls_selopt-sign      = 'I'.
    ls_selopt-option = 'EQ'.
    ls_selopt-low       = p_role.

    APPEND ls_selopt TO ls_rsds_frange-selopt_t.

    ls_rsds_frange-fieldname = 'ROLE'.

    APPEND ls_rsds_frange TO ls_selection-frange_t.
  ENDIF.

* final assignment
* append to selection table
  ls_selection-tablename = lv_hrp_tabname.
  APPEND ls_selection TO pt_selections.

ENDMETHOD.


METHOD build_fromclause.

* Author: PEV
* This method builds the FROM-Clause of a SELECT-Statement
*  Criteria:
*  - the A~table should be listed first in pt_selections
*  - all tables are joined with plvar and otjid in order to use indexes

  DATA:  lv_tabname     TYPE tabname,
         ls_selection   TYPE rsds_range,
         lv_prefix(1)   TYPE c,
         lv_plvar_prf_l TYPE string,
         lv_otjid_prf_l TYPE string,
         lv_plvar_prf_r TYPE string,
         lv_otjid_prf_r TYPE string.


  LOOP AT pt_selections INTO ls_selection.

    lv_tabname = ls_selection-tablename.

    CASE sy-tabix.
      WHEN '1'.
        lv_prefix = 'A'.
        CONCATENATE p_from_clause
                    lv_tabname 'as' lv_prefix
                    INTO p_from_clause SEPARATED BY space.
        CONTINUE.
      WHEN '2'.
        lv_prefix = 'B'.
      WHEN '3'.
        lv_prefix = 'C'.
      WHEN '4'.
        lv_prefix = 'D'.
      WHEN '5'.
        lv_prefix = 'E'.
      WHEN '6'.
        lv_prefix = 'F'.
      WHEN OTHERS.
*       too many tables for JOIN-Conditition
        IF 1 = 2.
*       for where-used list only
          MESSAGE e208(hrrcf0001).
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf_worklist
         EXPORTING
           textid         = cx_hrrcf_worklist=>too_many_join_tables
           message_type   = 'E'
           message_class  = msgcl_admin
           message_number = '208'.

    ENDCASE.

    CONCATENATE 'A~' 'plvar' INTO lv_plvar_prf_l.
    CONCATENATE lv_prefix '~' 'plvar' INTO lv_plvar_prf_r.

    CONCATENATE 'A~' 'otjid' INTO lv_otjid_prf_l.
    CONCATENATE lv_prefix '~' 'otjid' INTO lv_otjid_prf_r.

    CONCATENATE p_from_clause
                    'JOIN'
                    lv_tabname
                    'as' lv_prefix 'on' lv_plvar_prf_l '=' lv_plvar_prf_r
                    'and' lv_otjid_prf_l '=' lv_otjid_prf_r

          INTO p_from_clause SEPARATED BY space.

  ENDLOOP.

ENDMETHOD.


METHOD build_whereclause.

* Author: PEV
* This method builds the WHERE-Clause of a SELECT-Statement

  DATA: l_frange        TYPE rsds_frange,
        lv_prefix(2)    TYPE c,
        lv_sel_opt      TYPE rsdsselopt,
        lv_where_clause TYPE rsdswhere,
        lt_selections   TYPE rsds_trange,
        lv_operator     TYPE string,
        lv_mes_par1     TYPE sy-msgv1,
        lv_low          TYPE string,
        lv_high         TYPE string.

*  CONSTANTS:
*          c_semicolon   TYPE abap_typekind VALUE ```.


  FIELD-SYMBOLS:
    <ls_rsds_range> TYPE rsds_range,
    <ls_frange>     TYPE rsds_frange,
    <ls_where>      TYPE rsdswhere.


  lt_selections = pt_selections.

* substitute tables by prefixes
  LOOP AT lt_selections ASSIGNING <ls_rsds_range>.
*   determine the prefix
    CASE sy-tabix.
      WHEN '1'.
        lv_prefix = 'A~'.
      WHEN '2'.
        lv_prefix = 'B~'.
      WHEN '3'.
        lv_prefix = 'C~'.
      WHEN '4'.
        lv_prefix = 'D~'.
      WHEN '5'.
        lv_prefix = 'E~'.
      WHEN '6'.
        lv_prefix = 'F~'.
      WHEN OTHERS.
*       too many tables for JOIN-Conditition
        IF 1 = 2.
*       for where-used list only
          MESSAGE e208(hrrcf0001).
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf_worklist
         EXPORTING
           textid         = cx_hrrcf_worklist=>too_many_join_tables
           message_type   = 'E'
           message_class  = msgcl_admin
           message_number = '208'.
    ENDCASE.

    LOOP AT <ls_rsds_range>-frange_t ASSIGNING <ls_frange>.
      CONCATENATE lv_prefix <ls_frange>-fieldname
                  INTO <ls_frange>-fieldname.
      IF sy-subrc = 4.
*       field name too long
        IF 1 = 2.
*       for where-used list only
          MESSAGE e209(hrrcf0001) WITH <ls_frange>-fieldname.
        ENDIF.

        lv_mes_par1 = <ls_frange>-fieldname.

        RAISE EXCEPTION TYPE cx_hrrcf_worklist
         EXPORTING
           textid         = cx_hrrcf_worklist=>too_many_join_tables
           message_type   = 'E'
           message_class  = msgcl_admin
           message_number = '209'
           message_par1   = lv_mes_par1.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

* add brackets
  LOOP AT lt_selections ASSIGNING <ls_rsds_range>.
    LOOP AT <ls_rsds_range>-frange_t INTO l_frange. "ASSIGNING <ls_frange>.
*     only one select option allowed
      CLEAR: lv_sel_opt, lv_operator, lv_low, lv_high.

      READ TABLE l_frange-selopt_t INTO lv_sel_opt INDEX 1.
      TRANSLATE lv_sel_opt-option TO UPPER CASE.          "#EC SYNTCHAR

      lv_low = lv_sel_opt-low.
      IF lv_low(1) NE '!'.
        CONCATENATE '`' lv_low '`' INTO lv_low.
      ELSE.
        REPLACE '!' IN lv_low WITH space.
      ENDIF.
      IF lv_sel_opt-option EQ 'BT'.
        lv_operator = 'BETWEEN'.
        lv_high     = lv_sel_opt-high.
        CONCATENATE '`' lv_high '`' INTO lv_high.
        CONCATENATE 'AND' lv_high INTO lv_high SEPARATED BY space.
      ELSE.
        lv_operator = lv_sel_opt-option.
      ENDIF.

      CONCATENATE '(' l_frange-fieldname lv_operator INTO lv_where_clause SEPARATED BY space.
      CONCATENATE lv_where_clause lv_low lv_high ')' INTO lv_where_clause SEPARATED BY space.
      APPEND lv_where_clause TO pt_where_clause.
    ENDLOOP.
  ENDLOOP.

* add logical operation 'AND'
  LOOP AT pt_where_clause ASSIGNING <ls_where>.
    IF sy-tabix > 1.
*     concatenate the where clause with 'AND'
      CONCATENATE 'AND' <ls_where>-line INTO <ls_where> SEPARATED BY space.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD change_application_info.

* Author: HGB
* Additions: AS, PEV

* This methods updates the application information on infotype 5132.

  DATA: lo_exception   TYPE REF TO cx_hrrcf,
        lo_appl_info   TYPE REF TO cl_hrrcf_appl_information,
        lt_appl_info   TYPE TABLE OF p5132,
        ls_appl_info   TYPE p5132,
        l_message_par1 TYPE symsgv,
        l_operation    TYPE rcf_opera.


  CLEAR pt_return.

  TRY.
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.

      CALL METHOD lo_appl_info->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_appl_info.

      READ TABLE lt_appl_info INDEX 1 INTO ls_appl_info.
      IF sy-subrc NE 0.
        IF 1 EQ 2.
          MESSAGE e176(hrrcf0001) WITH ps_appl_hrobject-objid.
*         There are no records of IT5132 available for application &1
        ENDIF.
        l_message_par1 = ps_appl_hrobject-objid.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            hrobject       = ps_appl_hrobject
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '176'
            message_par1   = l_message_par1.
      ENDIF.

      IF p_appl_cover_letter IS SUPPLIED AND
         p_appl_cover_letter IS NOT INITIAL.
        CALL METHOD lo_appl_info->update_text
          EXPORTING
            text            = p_appl_cover_letter
            fieldname       = 'APPL_DESC'
          CHANGING
            infotype_record = ls_appl_info.
        l_operation = modify.
      ENDIF.

      IF p_appl_status IS SUPPLIED AND
         p_appl_status NE ls_appl_info-appl_status.
        ls_appl_info-appl_status = p_appl_status.
        l_operation = insert.
      ENDIF.


      IF p_appl_date IS SUPPLIED AND
         p_appl_date NE ls_appl_info-appl_date.
        ls_appl_info-appl_date = p_appl_date.
        l_operation = insert.
      ENDIF.

      IF p_appl_date IS SUPPLIED AND
         p_appl_date IS INITIAL.
        ls_appl_info-appl_date = sy-datum.
      ENDIF.

      IF p_pinst_guid IS SUPPLIED AND
         p_pinst_guid NE ls_appl_info-pinst_guid.
        ls_appl_info-pinst_guid = p_pinst_guid.
        l_operation = insert.
      ENDIF.

      IF p_tech_appl_source IS SUPPLIED AND
         p_tech_appl_source NE ls_appl_info-tech_appl_source.
        ls_appl_info-tech_appl_source = p_tech_appl_source.
        l_operation = insert.
      ENDIF.

      IF p_reason_code IS SUPPLIED AND
         p_reason_code NE ls_appl_info-reason_code.
        ls_appl_info-reason_code = p_reason_code.
        l_operation = insert.
      ENDIF.

      IF p_appl_source IS SUPPLIED AND
         p_appl_source NE ls_appl_info-appl_source.
        ls_appl_info-appl_source = p_appl_source.
        l_operation = insert.
      ENDIF.
      IF p_appl_source_info IS SUPPLIED AND
         p_appl_source_info NE ls_appl_info-appl_source_info.
        ls_appl_info-appl_source_info = p_appl_source_info.
        l_operation = insert.
      ENDIF.

      IF p_sclas IS SUPPLIED AND
         p_sclas NE ls_appl_info-sclas.
        ls_appl_info-sclas = p_sclas.
        l_operation = insert.
      ENDIF.

      IF p_sobid IS SUPPLIED AND
         p_sobid NE ls_appl_info-sobid.
        ls_appl_info-sobid = p_sobid.
        l_operation = insert.
      ENDIF.

      IF p_appl_source_pernr IS SUPPLIED AND
         p_appl_source_pernr NE ls_appl_info-appl_src_pernr.
        ls_appl_info-appl_src_pernr = p_appl_source_pernr.
        l_operation = insert.
      ENDIF.

      IF p_expiration_date IS SUPPLIED AND
        p_expiration_date NE ls_appl_info-expiration_date.
        ls_appl_info-expiration_date = p_expiration_date.
        l_operation = insert.
      ENDIF.

* update or insert record
      CASE l_operation.
        WHEN insert.
          CALL METHOD lo_appl_info->insert_record
            IMPORTING
              return          = pt_return
            CHANGING
              infotype_record = ls_appl_info.

        WHEN modify.
          CALL METHOD lo_appl_info->update_record
            IMPORTING
              return          = pt_return
            CHANGING
              infotype_record = ls_appl_info.

        WHEN OTHERS.
*         Do nothing if application information has not changed
      ENDCASE.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD change_application_status.
*
* Author   : RH
* Additions: AS, HGB
*
* This method changes the status of the application.
*
  DATA: lo_exception        TYPE REF TO cx_hrrcf,
        lo_application_info TYPE REF TO cl_hrrcf_appl_information.
*
  TRY.
    CALL METHOD cl_hrrcf_simple_main_object=>refresh_rcf_buffer( ).
*     get instance of application information
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_application_info.
*
*     change status
      CALL METHOD lo_application_info->change_status
        EXPORTING
          p_new_status = p_new_status
          check_only   = p_check_only
        IMPORTING
          pt_return    = pt_return.
*
*   exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD check_appl_duplicate.

* Data Declaration
  DATA : lo_candidate        TYPE REF TO cl_hrrcf_candidate,
         lo_application      TYPE REF TO cl_hrrcf_candidate_application,
         lo_appl_info        TYPE REF TO cl_hrrcf_appl_information,
         lo_ex               TYPE REF TO cx_root,
         lt_appl_info        TYPE TABLE OF p5132,
         lt_appl_list        TYPE rcf_t_application,
         ls_appl_info        TYPE          p5132,
         lv_pinst_guid       TYPE  rcf_pinst_guid,
         lv_ref_pinst_guid   TYPE  rcf_pinst_guid,
         lv_app_status       TYPE  rcf_application_status.

  TRY .
* Get Candidate
      IF ps_cand_hrobject IS SUPPLIED .
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
* Get Candidate from sy-uname if candidate id is not supplied
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.

      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.

      CALL METHOD lo_appl_info->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_appl_info.

* Get Posting GUID of the existing application
      READ TABLE lt_appl_info INDEX 1 INTO ls_appl_info.
      IF sy-subrc IS INITIAL.
        lv_ref_pinst_guid = ls_appl_info-pinst_guid .
      ENDIF .

* Get list of applications
      CALL METHOD lo_candidate->get_applications
        IMPORTING
          application_list = lt_appl_list.

* Get PINST_GUID of every application and compare it to REF_PINST_GUID
      LOOP AT lt_appl_list INTO lo_application.
        CLEAR lv_pinst_guid.

        IF lo_application->id NE ps_appl_hrobject-objid .

          CALL METHOD lo_application->get_application_status
            EXPORTING
              p_date   = sy-datum
            IMPORTING
              p_status = lv_app_status.

          IF lv_app_status EQ '1'.
            CALL METHOD lo_application->get_pinst_guid
              IMPORTING
                p_pinst_guid = lv_pinst_guid.

            IF lv_pinst_guid EQ lv_ref_pinst_guid.
              p_is_open = abap_true.
              RETURN.
            ENDIF.
          ENDIF.

        ENDIF.

      ENDLOOP.

    CATCH cx_hrrcf INTO lo_ex.

  ENDTRY.

ENDMETHOD.


METHOD check_appl_existence.
*
* Author   : BM
* Additions: AS, HGB
*
* This method finds out if there is already an application of the
* candidate for the given posting which is not in status draft,
* rejected or withdrawn (i.e. an "open" application).
*
  DATA: lo_posting          TYPE REF TO cl_hrrcf_posting,
        lo_candidate        TYPE REF TO cl_hrrcf_candidate,
        lo_application      TYPE REF TO cl_hrrcf_candidate_application,
        lo_appl_information TYPE REF TO cl_hrrcf_appl_information,
        lo_exception        TYPE REF TO cx_hrrcf,
        lt_posting_list     TYPE rcf_t_posting,
        lt_appl_list        TYPE rcf_t_application,
        lt_appl_info        TYPE lt_appl_info,
        ls_appl_info        TYPE ls_appl_info.
*
  CLEAR: ps_appl_hrobject,
         p_appl_status,
         p_is_open.
*
  TRY.
*     get candidate
      IF ps_cand_hrobject IS NOT INITIAL.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
*     get list of applications
      CALL METHOD lo_candidate->get_applications
        IMPORTING
          application_list = lt_appl_list.
*
*     for every application check if the associated posting
*     is the posting in question
      LOOP AT lt_appl_list INTO lo_application .
*
*       get posting
        CALL METHOD lo_application->get_postings
          IMPORTING
            posting_list = lt_posting_list.
*
************************************************************
        IF lt_posting_list IS NOT INITIAL.
************************************************************
          READ TABLE lt_posting_list INDEX 1 INTO lo_posting.
          IF sy-subrc NE 0.
            TRY.
                IF 1 = 2.
                  MESSAGE e064(hrrcf0001) WITH lo_application->id.
*               There is no posting for this application &1
                ENDIF.
                RAISE EXCEPTION TYPE cx_hrrcf
                  EXPORTING
                    hrobject       = lo_application->hrobject
                    message_type   = 'E'
                    message_class  = msgcl_admin
                    message_number = '064'.
              CATCH cx_hrrcf INTO lo_exception .
                CALL METHOD
                  cl_hrrcf_exception_handler=>write_exception_log
                  EXPORTING
                    ex = lo_exception.
                CONTINUE .
            ENDTRY.
          ENDIF.
*
          IF lo_posting->hrobject EQ ps_post_hrobject.
*         get application hrobject and status
            ls_appl_info-hrobject    = lo_application->hrobject.
            ls_appl_info-create_date = lo_application->create_date.
*
            CALL METHOD lo_application->get_application_status
              IMPORTING
                p_status = ls_appl_info-status.
*
            APPEND ls_appl_info TO lt_appl_info.
          ENDIF.
************************************************************
        ENDIF.
************************************************************
      ENDLOOP.
*
*     processing is finished if there is no application yet
      CHECK ls_appl_info IS NOT INITIAL.
*
*     else, get relevant application
      SORT lt_appl_info BY create_date hrobject DESCENDING.
*
      LOOP AT lt_appl_info INTO ls_appl_info WHERE status EQ c_draft.
        EXIT.
      ENDLOOP.
      IF sy-subrc NE 0.
        LOOP AT lt_appl_info INTO ls_appl_info
          WHERE status EQ c_in_process OR status EQ c_to_be_hired.
          EXIT.
        ENDLOOP.
        IF sy-subrc NE 0.
          LOOP AT lt_appl_info INTO ls_appl_info
            WHERE status EQ c_withdrawn OR status EQ c_rejected.
            EXIT.
          ENDLOOP.
        ENDIF.
      ENDIF.
*
*     set exporting parameters
      IF sy-subrc EQ 0.
        ps_appl_hrobject = ls_appl_info-hrobject.
        p_appl_status    = ls_appl_info-status.
*
        IF ( p_appl_status NE c_draft ) AND
           ( p_appl_status NE c_withdrawn ) AND
           ( p_appl_status NE c_rejected ).
          p_is_open = true.
        ENDIF.
      ENDIF.
*
*   exception handling
    CATCH cx_hrrcf INTO lo_exception .
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD check_authorisation_dovr .
* author Detlef

  DATA oref TYPE REF TO cx_hrrcf.

  DATA lt_application TYPE rcf_t_application.
  DATA lo_application TYPE REF TO cl_hrrcf_candidate_application.

  DATA lt_posting TYPE rcf_t_posting.
  DATA lo_posting TYPE REF TO cl_hrrcf_posting.

  DATA lt_requisition TYPE rcf_t_requisition.
  DATA lo_requisition TYPE REF TO cl_hrrcf_requisition.

  DATA lo_rec_team_bl TYPE REF TO cl_hrrcf_rec_team_bl.
  DATA l_user         TYPE syuname.

* check generic authorisation
  AUTHORITY-CHECK OBJECT 'P_RCF_VIEW'
           ID 'RCF_VIEW' FIELD 'APPL_DOVR'.
*
  IF sy-subrc NE 0.
* Check if Object is assigned to User
*
* a) application -> application team
* b) application -> posting -> requisition -> recruitment team
*
*
*
**************************************************************
* a) application -> application team
    TRY.
*
        CLEAR lo_rec_team_bl.
*
        lo_rec_team_bl = cl_hrrcf_rec_team_bl=>get_instance( ).

*       get responsible recruiters for this application
        l_user = sy-uname.
        IF lo_rec_team_bl->check_user_in_rec_team( ps_hrobject = appl_hrobject
                                                   p_user      = l_user        ) = true.

* User calls profile of application in charge
          RETURN.
        ENDIF.
*
      CATCH cx_hrrcf INTO oref.
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = oref.
    ENDTRY.
*
*
**************************************************************
* b) application -> posting -> requisition -> recruitment team
*
    TRY.
*
* get application
*
        CALL METHOD cl_hrrcf_candidate_application=>get
          EXPORTING
            id          = appl_hrobject-objid
          IMPORTING
            application = lo_application.
*
        IF lo_application IS BOUND.
*
* get posting
          CALL METHOD lo_application->get_postings
            IMPORTING
              posting_list = lt_posting.
          READ TABLE lt_posting INDEX 1
                                INTO lo_posting.
          IF sy-subrc = 0.
* get requisition
            CALL METHOD lo_posting->get_requisitions
              IMPORTING
                requisition_list = lt_requisition.
            READ TABLE lt_requisition INDEX 1
                                  INTO lo_requisition.
            IF sy-subrc = 0.
* get recruitment team
              CLEAR lo_rec_team_bl.
*
              lo_rec_team_bl = cl_hrrcf_rec_team_bl=>get_instance( ).

*       get responsible recruiters for this application
              l_user = sy-uname.
              IF lo_rec_team_bl->check_user_in_rec_team( ps_hrobject = lo_requisition->hrobject
                                                         p_user      = l_user        ) = true.
* User calls profile of application in charge
                RETURN.
              ENDIF.
*
            ENDIF.
          ENDIF.
        ENDIF.

      CATCH cx_hrrcf INTO oref.
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = oref.
    ENDTRY.
*  NOT AUTHORIZED
*
    TRY.

        IF 1 EQ 0.
          MESSAGE e158(hrrcf0001).
*   Keine Berechtigung zum Anzeigen der Datenübersicht
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf_authority
          EXPORTING
            textid = cx_hrrcf_authority=>cx_no_authority_for_bsp
*         PREVIOUS =
            hrobject = appl_hrobject
*         INFOTYPE =
            message_type = 'E'
            message_class = 'HRRCF0001'
            message_number = '158'     .

      CATCH cx_hrrcf INTO oref.

        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = oref.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            previous = oref.

    ENDTRY.

  ENDIF.

ENDMETHOD.


method CLEAR_BUFFER_TABS.

  CLEAR : gt_post_txt,
          gt_5122,
          gt_reqlist.

endmethod.


METHOD constructor .

  ref_cdcy_bl = cl_hrrcf_candidacy_bl=>get_instance( ).

  ref_appl_wl = cl_hrrcf_application_wl=>get_instance( ).

ENDMETHOD.


METHOD create_application.
*
* Author   : SGS
* Additions: AS, HGB
*
* This methods creates an application and links it to the candidate
* and the posting. In addition it also creates a candidacy or links
* an existing one.
*
  DATA: lo_candidate      TYPE REF TO cl_hrrcf_candidate,
        lo_posting        TYPE REF TO cl_hrrcf_posting,
        lo_requisition    TYPE REF TO cl_hrrcf_requisition,
        lo_rec_team_req   TYPE REF TO cl_hrrcf_rec_team,
        lo_rec_team_appl  TYPE REF TO cl_hrrcf_rec_team,
        lo_appl_info      TYPE REF TO cl_hrrcf_appl_information,
        lo_cdcy_bl        TYPE REF TO cl_hrrcf_candidacy_bl,
        lo_exception      TYPE REF TO cx_hrrcf,
        lt_return         TYPE bapirettab,
        ls_return         TYPE bapiret2,
        lt_values         TYPE ddfixvalues,
        ls_value          TYPE ddfixvalue,
        lt_requisitions   TYPE rcf_t_requisition,
        ls_p5132          TYPE p5132,
        ls_hrobject       TYPE hrobject,
        l_appl_status_txt TYPE symsgv,
        l_cdcy_status     TYPE rcf_candidacy_status,
        lo_trxlist_admin  TYPE REF TO if_hrrcf_trxlist_deltaindex.                "INS NOTE 1483945
*
  CLEAR: po_application,
         po_candidacy,
         pt_return.
*
* check pinst guid and only continue with when valid
  me->ref_pinst_bl = cl_hrrcf_posting_inst_bl=>get_instance( ).
  CALL METHOD me->ref_pinst_bl->check_posting_instance_guid
    EXPORTING
      p_pinst_guid = p_pinst_guid.
* check application status and map to candidacy status
  CASE p_appl_status.
    WHEN c_draft.
      l_cdcy_status = cl_hrrcf_candidacy_bl=>c_draft.
    WHEN c_in_process.
      l_cdcy_status = cl_hrrcf_candidacy_bl=>c_in_process.
    WHEN c_rejected.
      l_cdcy_status = cl_hrrcf_candidacy_bl=>c_rejected.
    WHEN OTHERS.
*     get application status text
      TRY.
          CALL METHOD cl_hrrcf_services_general=>get_domain_value_list
            EXPORTING
              p_domain_name = 'RCF_APPLICATION_STATUS'
            IMPORTING
              pt_valuelist  = lt_values.
          READ TABLE lt_values
            INTO ls_value WITH KEY low = p_appl_status.
          IF sy-subrc EQ 0.
            l_appl_status_txt = ls_value-ddtext.
          ELSE.
            l_appl_status_txt = p_appl_status.
          ENDIF.
        CATCH cx_hrrcf.
          l_appl_status_txt = p_appl_status.
      ENDTRY.
*     generate return message and do not create application
      IF 1 EQ 2.
        MESSAGE e177(hrrcf0001) WITH l_appl_status_txt.
*       Unable to create application in status &1
      ENDIF.
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = msgcl_admin
          number = '177'
          par1   = l_appl_status_txt
        IMPORTING
          return = ls_return.
      APPEND ls_return TO pt_return.
      RETURN.
  ENDCASE.
*
* create application
  TRY.
*     create application object
      CALL METHOD cl_hrrcf_candidate_application=>create
        IMPORTING
          application = po_application
          return      = lt_return.
*
      APPEND LINES OF lt_return TO pt_return.
      CHECK pt_return IS INITIAL.
*
*     link the application to the candidate
      IF ps_cand_hrobject IS NOT INITIAL.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      CALL METHOD po_application->assign_candidate
        EXPORTING
          candidate = lo_candidate
        IMPORTING
          return    = lt_return.
*
      APPEND LINES OF lt_return TO pt_return.
*
*     link the application to the posting
      CALL METHOD cl_hrrcf_posting_instance=>get_record_by_guid
        EXPORTING
          pinst_guid     = p_pinst_guid
        IMPORTING
          posting_object = ls_hrobject.
*
      CALL METHOD cl_hrrcf_posting=>get
        EXPORTING
          id      = ls_hrobject-objid
        IMPORTING
          posting = lo_posting.
*
      CALL METHOD po_application->assign_posting
        EXPORTING
          posting = lo_posting
        IMPORTING
          return  = lt_return.
*
      APPEND LINES OF lt_return TO pt_return.
*
*     get related requisition
      CALL METHOD lo_posting->get_requisitions
        IMPORTING
          requisition_list = lt_requisitions.
*
      READ TABLE lt_requisitions INDEX 1 INTO lo_requisition.
      IF sy-subrc NE 0.
        TRY.
            IF 1 = 2.
              MESSAGE e059(hrrcf0001).
*             There is no requisition for this posting
            ENDIF.
            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                hrobject       = lo_posting->hrobject
                message_type   = 'E'
                message_class  = msgcl_admin
                message_number = '059'.
          CATCH cx_hrrcf INTO lo_exception .
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_exception.
        ENDTRY.
      ENDIF.
*
*     create candidacy or link existing one
      lo_cdcy_bl = cl_hrrcf_candidacy_bl=>get_instance( ).
*
      CALL METHOD lo_cdcy_bl->create_candidacy
        EXPORTING
          ps_cand_hrobject     = lo_candidate->hrobject
          ps_req_hrobject      = lo_requisition->hrobject
          ps_appl_hrobject     = po_application->hrobject
          p_cdcy_status        = l_cdcy_status
          p_appl_status        = p_appl_status
          p_cdcy_status_reason = p_reason_code "xdp
        IMPORTING
          po_candidacy         = po_candidacy
          pt_return            = lt_return.
*
      APPEND LINES OF lt_return TO pt_return.

      IF cl_hrrcf_switch_check=>hrerc_sfws_ui_enh_02( ) EQ false.
*     maintain recruitment team if application is created 'In process'
        IF p_appl_status EQ c_in_process OR p_appl_status EQ c_rejected.
          CALL METHOD create_rec_team_by_default
            EXPORTING
              ps_appl_hrobject = po_application->hrobject
              ps_req_hrobject  = lo_requisition->hrobject
            IMPORTING
              pt_return        = lt_return.
*
          APPEND LINES OF lt_return TO pt_return.
        ENDIF.
      ENDIF.
*     store application status, date technical application source, application source
      MOVE sy-datum      TO ls_p5132-begda.
      MOVE high_date     TO ls_p5132-endda.
      MOVE p_appl_status TO ls_p5132-appl_status.
      MOVE p_reason_code TO ls_p5132-reason_code.
      MOVE p_tech_appl_source TO ls_p5132-tech_appl_source.
      MOVE p_sclas TO ls_p5132-sclas.
      MOVE p_sobid TO ls_p5132-sobid.
      MOVE p_appl_source TO ls_p5132-appl_source.
      MOVE p_appl_source_info TO ls_p5132-appl_source_info.

      IF p_appl_status NE c_draft.
        MOVE p_appl_date TO ls_p5132-appl_date.
      ENDIF.

      MOVE p_pinst_guid  TO ls_p5132-pinst_guid.
*
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = po_application->hrobject
        IMPORTING
          instance = lo_appl_info.

*     store cover letter if supplied
      IF p_appl_cover_letter IS SUPPLIED.
        CALL METHOD lo_appl_info->update_text
          EXPORTING
            text            = p_appl_cover_letter
            fieldname       = 'APPL_DESC'
          CHANGING
            infotype_record = ls_p5132.
      ENDIF.
*
*     relationship replication
      ls_p5132-canid = lo_candidate->hrobject-objid.
      ls_p5132-pstid = ls_hrobject-objid.
*
      CALL METHOD lo_appl_info->insert_record
        IMPORTING
          return          = lt_return
        CHANGING
          infotype_record = ls_p5132.
*
      APPEND LINES OF lt_return TO pt_return.

      CALL METHOD cl_hrrcf_trxlist_admin=>get_instance                            "INS NOTE 1483945
        IMPORTING                                                                 "INS NOTE 1483945
          eo_trxlist_admin = lo_trxlist_admin.                                    "INS NOTE 1483945

      CALL METHOD lo_trxlist_admin->push_changes                                  "INS NOTE 1483945
        EXPORTING                                                                 "INS NOTE 1483945
          is_hrobject = po_application->hrobject.                                 "INS NOTE 1483945 + Add. Correction PVA

*   exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD create_rec_team_by_default.

* Author: HGB

* This method creates the recruitment team for the given application
* by copying the recruitment team of either the given requisition or
* the requisition associated with the application.

  DATA: lo_rec_team_req  TYPE REF TO cl_hrrcf_rec_team,
        lo_rec_team_appl TYPE REF TO cl_hrrcf_rec_team,
        lo_exception     TYPE REF TO cx_hrrcf,
        ls_req_hrobject  TYPE hrobject,
        lt_return        TYPE bapirettab,
        lt_rec_team_req  TYPE TABLE OF p5131,
        ls_rec_team_req  TYPE p5131,
        ls_rec_team_appl TYPE p5131.

  CLEAR pt_return.

  TRY.
*     get requisition, if necessary
      IF ps_req_hrobject IS INITIAL.
        ls_req_hrobject = get_requisition( ps_appl_hrobject ).
      ELSE.
        ls_req_hrobject = ps_req_hrobject.
      ENDIF.

*     get recruitment team of requisition
      CALL METHOD cl_hrrcf_rec_team=>get_instance
        EXPORTING
          ps_hrobject = ls_req_hrobject
        IMPORTING
          po_instance = lo_rec_team_req.

      CALL METHOD lo_rec_team_req->get_records_by_date
        IMPORTING
          infotype_records = lt_rec_team_req.

*     create recruitment team of application as a copy
      CALL METHOD cl_hrrcf_rec_team=>get_instance
        EXPORTING
          ps_hrobject = ps_appl_hrobject
        IMPORTING
          po_instance = lo_rec_team_appl.

      LOOP AT lt_rec_team_req INTO ls_rec_team_req.
        MOVE-CORRESPONDING ls_rec_team_req TO ls_rec_team_appl.
        MOVE sy-datum  TO ls_rec_team_appl-begda.
        MOVE high_date TO ls_rec_team_appl-endda.

        CALL METHOD lo_rec_team_appl->insert_record
          EXPORTING
            check_only      = p_check_only
          IMPORTING
            return          = lt_return
          CHANGING
            infotype_record = ls_rec_team_appl.

        APPEND LINES OF lt_return TO pt_return.
      ENDLOOP.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD delete_draft_application .

  DATA : lo_exception TYPE REF TO cx_hrrcf .

  CLEAR return .
  REFRESH return .

  TRY.

      CALL METHOD cl_hrrcf_delete_manager=>delete_draft_application
        EXPORTING
          hrobject = appl_hrobject
        IMPORTING
          return   = return.

    CATCH cx_hrrcf INTO lo_exception .
      cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).

      RAISE EXCEPTION TYPE cx_hrrcf .

  ENDTRY.

ENDMETHOD.


method dequeue_application .
*
* Author: AS
*
* This method dequeues an application.
*
  data: lo_exception   type ref to cx_hrrcf,
        lo_application type ref to cl_hrrcf_candidate_application.
*
  try.
*
* get application
      call method cl_hrrcf_candidate_application=>get
        exporting
          id          = ps_appl_hrobject-objid
        importing
          application = lo_application.
*
* dequeue
      lo_application->dequeue( ).
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf.
  endtry.
*
endmethod.


method enqueue_application .
*
* Author: AS
*
* This method enqueues an application.
*
  data: lo_exception   type ref to cx_hrrcf,
        lo_application type ref to cl_hrrcf_candidate_application.
*
  try.
*
* get application
      call method cl_hrrcf_candidate_application=>get
        exporting
          id          = ps_appl_hrobject-objid
        importing
          application = lo_application.
*
* enqueue
      call method lo_application->enqueue
        importing
          return = pt_return.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf.
  endtry.
*
endmethod.


METHOD fetch_applications .

* Author: PEV

* This method reads applications in a mass fetch (higher performance).
*  Selection criteria: status, user, role, date, appl source.

  DATA: lt_appl_hrobject TYPE rcf_t_hrobject,
        lt_selections    TYPE rsds_trange,
        ls_selections    TYPE rsds_range,
        ls_rsds_frange   TYPE rsds_frange,
        ls_selopt        TYPE rsdsselopt,
        lv_from_clause   TYPE string,
        lt_where_clause  TYPE rsds_where_tab,
        lt_member        TYPE rcf_t_member.

  DATA: lo_exception     TYPE REF TO cx_root.


* transform and build selections for JOIN-Condition
  CALL METHOD cl_hrrcf_application_bl=>transform_selections
    EXPORTING
      p_appl_status = p_appl_status
      p_user        = p_user
      p_role        = p_role
      p_begda       = p_begda
      p_endda       = p_endda
      p_appl_source = p_appl_source
    IMPORTING
      pt_selections = lt_selections
      pt_member     = lt_member.

* build FROM-clause
  CALL METHOD cl_hrrcf_application_bl=>build_fromclause
    EXPORTING
      pt_selections = lt_selections
    IMPORTING
      p_from_clause = lv_from_clause.

* build WHERE-clause
  CALL METHOD cl_hrrcf_application_bl=>build_whereclause
    EXPORTING
      pt_selections   = lt_selections
    IMPORTING
      pt_where_clause = lt_where_clause.

* SELECT statement
  TRY.
      SELECT DISTINCT a~plvar a~otype a~objid            "#EC CI_DYNTAB
             INTO CORRESPONDING FIELDS OF TABLE lt_appl_hrobject
             FROM (lv_from_clause)
             FOR ALL ENTRIES IN lt_member
             WHERE (lt_where_clause).                  "#EC CI_DYNWHERE

    CATCH cx_sy_dynamic_osql_semantics INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
         previous = lo_exception.
  ENDTRY.

  SORT lt_appl_hrobject.
  DELETE ADJACENT DUPLICATES FROM lt_appl_hrobject.

  pt_appl_hrobject[] = lt_appl_hrobject[].

ENDMETHOD.


METHOD fetch_candidates.
* Author: PEV

  DATA:
    lt_cond      TYPE hrtb_cond,
    ls_cond      TYPE hrcond,
    lt_1001      TYPE STANDARD TABLE OF p1001,
    ls_appl_cand TYPE rcf_s_appl_cand.
  FIELD-SYMBOLS:
    <ls_1001>    TYPE p1001.
*

  ls_cond-field = 'SCLAS'.
  ls_cond-opera = 'EQ'.
  ls_cond-low   = 'NA'.
  APPEND ls_cond
      TO lt_cond.

  clear ls_cond.
  ls_cond-field = 'SUBTY'.
  ls_cond-opera = 'EQ'.
  ls_cond-low   = 'B651'.
  APPEND ls_cond
      TO lt_cond.

  CALL METHOD cl_hrrcf_object_buffer=>get_1001
    EXPORTING
      pt_i1000 = pt_appl_hrobject
      pt_icond = lt_cond
    IMPORTING
      pt_e1001 = lt_1001.

  LOOP AT lt_1001
       ASSIGNING <ls_1001>.
    ls_appl_cand-appl_hrobject-plvar = <ls_1001>-plvar.
    ls_appl_cand-appl_hrobject-otype = <ls_1001>-otype.
    ls_appl_cand-appl_hrobject-objid = <ls_1001>-objid.

    ls_appl_cand-cand_hrobject-plvar = <ls_1001>-plvar.
    ls_appl_cand-cand_hrobject-otype = <ls_1001>-sclas.
    ls_appl_cand-cand_hrobject-objid = <ls_1001>-sobid.
    APPEND ls_appl_cand
        TO pt_appl_cand.
  ENDLOOP.


ENDMETHOD.


METHOD filter_out_furth_assign.

* ... to be changed...
* Author: PEV

  DATA: lt_appl_cand     TYPE rcf_t_appl_cand,
        ls_appl_cand     TYPE rcf_s_appl_cand,
        lt_cand_cdcy     TYPE rcf_t_cand_cdcy,
        ls_cand_cdcy     TYPE rcf_s_cand_cdcy,
        ls_cand_hrobject TYPE hrobject,
        lt_cand_hrobject TYPE rcf_t_hrobject,
        ls_cdcy_hrobject TYPE hrobject,
        lt_cdcy_hrobject TYPE rcf_t_hrobject,
        lt_appl_cdcy     TYPE rcf_t_appl_cdcy,
        ls_appl_hrobject TYPE hrobject,
        lv_cdcy_status   TYPE rcf_candidacy_status.

  FIELD-SYMBOLS:
        <cand_cdcy>      TYPE rcf_s_cand_cdcy,
        <ls_appl_cand>   TYPE rcf_s_appl_cand.
*

  TRY.
* get all related candidates
      CALL METHOD me->fetch_candidates
        EXPORTING
          pt_appl_hrobject = pt_appl_hrobject
        IMPORTING
          pt_appl_cand     = lt_appl_cand.

* fetch candidacies
      LOOP AT        lt_appl_cand
           ASSIGNING <ls_appl_cand>.
        APPEND <ls_appl_cand>-cand_hrobject
            TO lt_cand_hrobject.
      ENDLOOP.

      CALL METHOD me->ref_cdcy_bl->fetch_candidacies  "exchange?
        EXPORTING
          pt_cand_hrobject = lt_cand_hrobject
        IMPORTING
          pt_cand_cdcy     = lt_cand_cdcy.

* remove leading candidacies (unperformant!)
      LOOP AT pt_appl_hrobject INTO ls_appl_hrobject.

*       get leading candidacy
        CALL METHOD me->get_candidacy
          EXPORTING
            ps_appl_hrobject = ls_appl_hrobject
          RECEIVING
            ps_cdcy_hrobject = ls_cdcy_hrobject.

        READ TABLE lt_appl_cand INTO ls_appl_cand
        WITH KEY appl_hrobject = ls_appl_hrobject.

        LOOP AT lt_cand_cdcy ASSIGNING <cand_cdcy>
         WHERE cand_hrobject = ls_appl_cand-cand_hrobject.
          IF <cand_cdcy>-cdcy_hrobject <> ls_cdcy_hrobject.

* now proceed with business logic
            CALL METHOD me->ref_cdcy_bl->get_candidacy_status
              EXPORTING
                ps_cdcy_hrobject = <cand_cdcy>-cdcy_hrobject
              IMPORTING
                p_status         = lv_cdcy_status.

            IF lv_cdcy_status EQ '0' OR   "In process
               lv_cdcy_status EQ '3'.     "To be hired

              DELETE pt_appl_hrobject.
              EXIT.
            ENDIF.

          ENDIF.
        ENDLOOP.

      ENDLOOP.

    CATCH cx_hrrcf.
* todo...
  ENDTRY.

ENDMETHOD.


METHOD get_applications .
*
* Author: AS
*
  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.
  DATA lo_application TYPE REF TO cl_hrrcf_candidate_application.
  DATA lt_applications TYPE rcf_t_application.
  DATA ls_application TYPE rcf_s_cand_appl_list.
  DATA lo_appl_info TYPE REF TO cl_hrrcf_appl_information.
  DATA lt_p5132_txt TYPE rcf_t_appl_information_txt.
  DATA ls_p5132_txt TYPE rcf_s_appl_information_txt.
  DATA lo_ex TYPE REF TO cx_hrrcf.
  DATA lt_posting_list TYPE rcf_t_posting.
  DATA lo_posting TYPE REF TO cl_hrrcf_posting.
  DATA lo_post_info TYPE REF TO cl_hrrcf_posting_information.
  DATA lt_p5121 TYPE rcf_t_posting_information.
  DATA ls_p5121 TYPE p5121.
  DATA lo_pinst TYPE REF TO cl_hrrcf_posting_instance.
  DATA ls_p5122 TYPE p5122.
*
  TRY.
*
* get candidate
      CALL METHOD cl_hrrcf_candidate=>get
        EXPORTING
          id        = ps_cand_hrobject-objid
        IMPORTING
          candidate = lo_candidate.
*
* get applications
      CALL METHOD lo_candidate->get_applications
        IMPORTING
          application_list = lt_applications.
*
* get additional information
      LOOP AT lt_applications INTO lo_application.
*
        CLEAR ls_application.
*
        TRY.
*
            ls_application-appl_hrobject = lo_application->hrobject.
*
            CALL METHOD cl_hrrcf_appl_information=>get_instance
              EXPORTING
                hrobject = lo_application->hrobject
              IMPORTING
                instance = lo_appl_info.
            CALL METHOD lo_appl_info->get_records_by_date_with_text
              EXPORTING
                language       = p_langu
              IMPORTING
                pt_appl_info_t = lt_p5132_txt.
            READ TABLE lt_p5132_txt INDEX 1 INTO ls_p5132_txt.
            ls_application-application_status          = ls_p5132_txt-appl_status.
            ls_application-appl_status_txt      = ls_p5132_txt-status_txt.
            ls_application-application_date            = ls_p5132_txt-appl_date.
*
            CALL METHOD lo_application->get_pinst_guid
              EXPORTING
                p_date       = sy-datum
              IMPORTING
                p_pinst_guid = ls_application-pinst_guid.
*
            CALL METHOD lo_application->get_postings
              IMPORTING
                posting_list = lt_posting_list.
            READ TABLE lt_posting_list INDEX 1 INTO lo_posting.
            CALL METHOD cl_hrrcf_posting_information=>get_instance
              EXPORTING
                hrobject = lo_posting->hrobject
              IMPORTING
                instance = lo_post_info.
            CALL METHOD lo_post_info->get_records_by_date
              EXPORTING
                date             = sy-datum
              IMPORTING
                infotype_records = lt_p5121.
            READ TABLE lt_p5121 INDEX 1 INTO ls_p5121.

            CALL METHOD lo_post_info->read_text
              EXPORTING
                langu           = p_langu
                fieldname       = 'HEADER'
                infotype_record = ls_p5121
              IMPORTING
                text            = ls_application-posting_header.

*checks if header is initial
            IF ls_application-posting_header IS INITIAL.
*
              CALL METHOD cl_hrrcf_posting_instance=>get_record_by_guid
                EXPORTING
                  pinst_guid       = ls_application-pinst_guid
                IMPORTING
                  instance         = lo_pinst
                  posting_instance = ls_p5122.
              ls_application-ref_code = ls_p5122-external_code.
              ls_application-pinst_status   = ls_p5122-status.

* Added by ALIV: 15/12/2006
* FOR: XSS scenario -> My Applications.

*       get posting instance header
              CALL METHOD lo_pinst->read_frozen_post_and_requi
                EXPORTING
                  posting_instance_record = ls_p5122
                IMPORTING
                  post_header             = ls_application-posting_header.

*  If posting header text is initial.
              IF ls_application-posting_header IS INITIAL.
                CONCATENATE lo_posting->hrobject-otype
                            lo_posting->hrobject-objid
                       INTO ls_application-posting_header.
              ENDIF.
            ENDIF.

** Added//.
*
            APPEND ls_application TO pt_applications.
*
          CATCH cx_root.
        ENDTRY.
*
      ENDLOOP.
*
*   exception handling
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD get_applications_of_sel .

* Author: PEV
  DATA: lo_exception TYPE REF TO cx_hrrcf.


  CLEAR: pt_applications.

  TRY.
      CALL METHOD me->fetch_applications
        EXPORTING
          p_appl_status    = p_appl_status
          p_user           = p_user
          p_role           = p_role
          p_begda          = p_begda
          p_endda          = p_endda
          p_appl_source    = p_appl_source
        IMPORTING
          pt_appl_hrobject = pt_applications.

      IF p_without_further_assign = true.
        CALL METHOD me->filter_out_furth_assign
          CHANGING
            pt_appl_hrobject = pt_applications.
      ENDIF.

* exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD get_applications_of_selection .
*
* Additions: AS/PEV/XRG
*
* This method reads application with regards to someselection criteria:
*  role, user, status, application date period.
*
  DATA ls_resp_person TYPE rcf_s_appl_responsible.
  DATA lt_application_id TYPE rcf_t_application_id_list.
  DATA lv_appl_id TYPE rcf_application.
  DATA ls_appl_hrobject TYPE hrobject.
  DATA lv_plvar TYPE plvar.
  DATA lv_otype TYPE otype.
  DATA lo_appl_info TYPE REF TO cl_hrrcf_appl_information.
  DATA lt_p5132 TYPE TABLE OF p5132.
  DATA ls_p5132 TYPE p5132.
  DATA: lv_status TYPE rcf_application_status,
        lv_create_date TYPE dats.
*      lv_appl_date type dats.
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA ls_appl_info_x TYPE rcf_s_list_applications_x.
*
  CLEAR: pt_applications.
  TRY.
* hrobject
      CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
        EXPORTING
          set_default_plvar = 'X'
        IMPORTING
          act_plvar         = lv_plvar
        EXCEPTIONS
          no_active_plvar   = 0
          OTHERS            = 0.
*
      lv_otype = cl_hrrcf_candidate_application=>my_otype.
*
* get applications for responsible person
      IF ( p_user IS SUPPLIED ) AND ( p_role IS SUPPLIED ).
        IF p_user IS NOT INITIAL.
          MOVE 'US' TO ls_resp_person-sclas .
        ENDIF.
        MOVE p_user TO ls_resp_person-sobid .
        CALL METHOD cl_hrrcf_rec_team=>get_appl_for_resp_person
          EXPORTING
            p_role              = p_role
            ps_appl_responsible = ls_resp_person
          IMPORTING
            pt_appl_list        = lt_application_id.
      ENDIF.

* -- delete duplicates
      SORT lt_application_id.
      DELETE ADJACENT DUPLICATES FROM lt_application_id.

* sort out status and selection date
      LOOP AT lt_application_id INTO lv_appl_id.
        CLEAR ls_appl_hrobject.
        ls_appl_hrobject-plvar = lv_plvar.
        ls_appl_hrobject-otype = lv_otype.
        ls_appl_hrobject-objid = lv_appl_id.
        TRY.
            CALL METHOD cl_hrrcf_appl_information=>get_instance
              EXPORTING
                hrobject = ls_appl_hrobject
              IMPORTING
                instance = lo_appl_info.
            CALL METHOD lo_appl_info->get_records_by_date
              IMPORTING
                infotype_records = lt_p5132.
            READ TABLE lt_p5132 INDEX 1 INTO ls_p5132 .
            lv_status     = ls_p5132-appl_status.
          CATCH cx_hrrcf .
*       no application available or some inconsistency
            DELETE lt_application_id.
            CONTINUE.
        ENDTRY.
        IF ( p_appl_source IS SUPPLIED  ) AND
           ( p_appl_source IS NOT INITIAL ) AND
           ( p_appl_source NE ls_p5132-appl_source ).
          DELETE lt_application_id.
          CONTINUE.
        ENDIF.
        IF lv_status IS INITIAL.
          DELETE lt_application_id.
          CONTINUE.
        ELSEIF ( p_appl_status IS SUPPLIED ) AND
               ( p_appl_status IS NOT INITIAL ) AND
               ( lv_status NE p_appl_status ).
          DELETE lt_application_id.
          CONTINUE.
        ENDIF.

*        CALL METHOD me->get_appl_create_date
*          EXPORTING
*            ps_appl_hrobject = ls_appl_hrobject
*          IMPORTING
*            p_create_date    = lv_create_date.

*        lv_create_date = ls_p5132-begda.
*        lv_appl_date = ls_p5132-appl_date.
         lv_create_date = ls_p5132-appl_date.

        IF p_begda IS NOT INITIAL.
          IF ( p_endda IS INITIAL ) AND ( p_begda NE lv_create_date ).
            DELETE lt_application_id.
            CONTINUE.
          ELSEIF ( p_endda IS NOT INITIAL ) AND
                 ( ( lv_create_date LT p_begda ) OR ( lv_create_date GT p_endda ) ).
            DELETE lt_application_id.
            CONTINUE.
          ENDIF.
        ENDIF.

*       Eliminate application with further assignments
        IF p_without_further_assign = true.
          CALL METHOD me->get_application_info_x
            EXPORTING
              ps_appl_hrobject   = ls_appl_hrobject
              x_pi_info_required = false
            IMPORTING
              ps_appl_info_x     = ls_appl_info_x.
          IF ls_appl_info_x-further_appls = true.
            DELETE lt_application_id.
            CONTINUE.
          ENDIF.
        ENDIF.

        APPEND ls_appl_hrobject TO pt_applications.

      ENDLOOP.
*
* exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
*
ENDMETHOD.


METHOD get_application_info_x.

* Author   : RH
* Additions: AS, PEV, HGB, XRG

* This method reads additional information regarding the application

  DATA lo_post_info        TYPE REF TO cl_hrrcf_posting_information.
  DATA lo_post_inst        TYPE REF TO cl_hrrcf_posting_instance.
  DATA lo_exception        TYPE REF TO cx_hrrcf.
  DATA ls_appl_info_x      TYPE rcf_s_list_applications_x.
  DATA ls_t77rcf_applsrc   TYPE t77rcf_applsrc.
  DATA ls_t77rcf_applsty_t TYPE t77rcf_applsty_t.
  DATA lt_p5121            TYPE rcf_t_posting_information.
  DATA ls_p5121            TYPE p5121.
  DATA ls_p5122            TYPE p5122.
  DATA ls_t77rcf_applsty   TYPE t77rcf_applsty.
  DATA lv_otr_alias        TYPE string.
  DATA lv_text             TYPE string.
  DATA lv_pinst_text       TYPE string.


  TRY.
*     get additional information necessary for the Applications list
      CALL METHOD me->get_application_info_x2
        EXPORTING
          ps_appl_hrobject = ps_appl_hrobject
        IMPORTING
          ps_appl_info_x   = ls_appl_info_x.

      CHECK ls_appl_info_x IS NOT INITIAL.

*     get appl.source type from the Application Source
*     (as we don't have the info in the Application infotype)
      IF ls_appl_info_x-appl_source IS NOT INITIAL.
        CALL METHOD cl_hrrcf_t77rcf_applsrc=>read_record
          EXPORTING
            appl_source    = ls_appl_info_x-appl_source
          IMPORTING
            t77rcf_applsrc = ls_t77rcf_applsrc.

        TRY.
            CALL METHOD cl_hrrcf_t77rcf_applsty=>read_description
              EXPORTING
                langu            = sy-langu
                appl_source_type = ls_t77rcf_applsrc-appl_source_type
              IMPORTING
                t77rcf_applsty_t = ls_t77rcf_applsty_t.

            ls_appl_info_x-appl_source_type     = ls_t77rcf_applsty_t-appl_source_type.
            ls_appl_info_x-appl_source_type_txt = ls_t77rcf_applsty_t-description.
          CATCH cx_hrrcf_customizing.
*           no description maintained -> Read OTR text of application source type
            CALL METHOD cl_hrrcf_t77rcf_applsty=>read_record
              EXPORTING
                appl_source_type = ls_t77rcf_applsrc-appl_source_type
              IMPORTING
                t77rcf_applsty   = ls_t77rcf_applsty.

            lv_otr_alias = ls_t77rcf_applsty-appl_stype_otr.
            IF lv_otr_alias IS NOT INITIAL.
              CALL METHOD cl_hrrcf_services_general=>get_otr_text
                EXPORTING
                  p_alias = lv_otr_alias
                RECEIVING
                  p_text  = lv_text.
              ls_appl_info_x-appl_source_type_txt = lv_text.
            ENDIF.
        ENDTRY.
      ENDIF.

*     get posting header
      IF ls_appl_info_x-posting_header IS INITIAL.

      CALL METHOD cl_hrrcf_posting_information=>get_instance
        EXPORTING
          hrobject = ls_appl_info_x-posting_hrobject
        IMPORTING
          instance = lo_post_info.

      CALL METHOD lo_post_info->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_p5121.

      READ TABLE lt_p5121 INDEX 1 INTO ls_p5121.

      CALL METHOD lo_post_info->read_text
        EXPORTING
          fieldname       = 'HEADER'
          infotype_record = ls_p5121
        IMPORTING
          text            = ls_appl_info_x-posting_header.
      ENDIF.

       IF ( x_pi_info_required EQ true ) OR ( ls_appl_info_x-posting_header IS INITIAL
        ).
*       get posting instance external code and status
        CALL METHOD cl_hrrcf_posting_instance=>get_record_by_guid
          EXPORTING
            pinst_guid       = ls_appl_info_x-pinst_guid
          IMPORTING
            instance         = lo_post_inst
            posting_instance = ls_p5122.

        ls_appl_info_x-reference_code = ls_p5122-external_code.
        ls_appl_info_x-pinst_status   = ls_p5122-status.

*       get posting instance header
        CALL METHOD lo_post_inst->read_frozen_post_and_requi
          EXPORTING
            posting_instance_record = ls_p5122
          IMPORTING
            post_header             = lv_pinst_text.

        IF lv_pinst_text IS INITIAL.
          IF ls_appl_info_x-posting_header IS NOT INITIAL.
            ls_appl_info_x-pinst_header = ls_appl_info_x-posting_header.
          ELSE.
            CONCATENATE ls_appl_info_x-posting_hrobject-otype
                    ls_appl_info_x-posting_hrobject-objid
               INTO ls_appl_info_x-posting_header.
            ls_appl_info_x-pinst_header = ls_appl_info_x-posting_header.
          ENDIF.
        ELSE.
          ls_appl_info_x-pinst_header = lv_pinst_text.
          IF ls_appl_info_x-posting_header IS INITIAL.
            ls_appl_info_x-posting_header = ls_appl_info_x-pinst_header.
          ENDIF.
        ENDIF.

      ENDIF.

*     move data to exporting parameter
      ps_appl_info_x = ls_appl_info_x.

*   exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.

ENDMETHOD.


METHOD get_application_info_x2.

* Author: HGB
* Additions: PEV (performance enhancements)

* This method reads additional information regarding the application,
* as necessary for the Applications list

  DATA lo_application      TYPE REF TO cl_hrrcf_candidate_application.
  DATA lo_appl_information TYPE REF TO cl_hrrcf_appl_information.
  DATA lo_candidate        TYPE REF TO cl_hrrcf_candidate.
  DATA lo_posting          TYPE REF TO cl_hrrcf_posting.
  DATA lo_requisition      TYPE REF TO cl_hrrcf_requisition.
  DATA lo_requisition_info TYPE REF TO cl_hrrcf_requisition_info.
  DATA lo_exception        TYPE REF TO cx_hrrcf.
  DATA ls_appl_info_x      TYPE rcf_s_list_applications_x.
  DATA lt_p5132_txt        TYPE rcf_t_appl_information_txt.
  DATA ls_p5132_txt        TYPE rcf_s_appl_information_txt.
  DATA lt_candidate_list   TYPE rcf_t_candidate.
  DATA lt_posting_list     TYPE rcf_t_posting.
  DATA lt_requisition_list TYPE rcf_t_requisition.
  DATA lt_p5125            TYPE rcf_t_requisition_info.
  DATA ls_p5125            TYPE p5125.
  DATA ls_cdcy_hrobject    TYPE hrobject.
  DATA l_nr_in_process     TYPE int4.
  DATA l_nr_to_be_hired    TYPE int4.
  DATA l_cdcy_status       TYPE rcf_candidacy_status.
  DATA l_msgv1             TYPE symsgv.

  CLEAR ps_appl_info_x.

  TRY.
*     get application
      CALL METHOD cl_hrrcf_candidate_application=>get
        EXPORTING
          id          = ps_appl_hrobject-objid
        IMPORTING
          application = lo_application.

      CALL METHOD lo_application->get_pinst_guid
        EXPORTING
          p_date       = sy-datum
        IMPORTING
          p_pinst_guid = ls_appl_info_x-pinst_guid.

      CHECK ls_appl_info_x-pinst_guid IS NOT INITIAL.

      ls_appl_info_x-appl_hrobject = ps_appl_hrobject.

*     get application information
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_information.

      IF lo_appl_information IS NOT BOUND.
        TRY.
            l_msgv1 = lo_application->id.
            IF 1 EQ 2.
              MESSAGE e176(hrrcf0001) WITH l_msgv1.
*             No records of IT5132 available for this application &1
            ENDIF.
            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                hrobject       = lo_application->hrobject
                message_type   = 'E'
                message_class  = msgcl_admin
                message_number = '176'
                message_par1   = l_msgv1.
          CATCH cx_hrrcf INTO lo_exception.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_exception.
            EXIT.
        ENDTRY.
      ENDIF.

      CALL METHOD lo_appl_information->get_records_by_date_with_text
        IMPORTING
          pt_appl_info_t = lt_p5132_txt.

      READ TABLE lt_p5132_txt INDEX 1 INTO ls_p5132_txt.

      ls_appl_info_x-appl_status          = ls_p5132_txt-appl_status.
      ls_appl_info_x-appl_status_txt      = ls_p5132_txt-status_txt.
      ls_appl_info_x-appl_date            = ls_p5132_txt-appl_date.
      ls_appl_info_x-reason_code          = ls_p5132_txt-reason_code.
      ls_appl_info_x-reason_code_txt      = ls_p5132_txt-reason_code_txt.
      ls_appl_info_x-tech_appl_source     = ls_p5132_txt-tech_appl_source.
      ls_appl_info_x-tech_appl_source_txt = ls_p5132_txt-tech_appl_source_txt.
      ls_appl_info_x-appl_source          = ls_p5132_txt-appl_source.
      ls_appl_info_x-appl_source_txt      = ls_p5132_txt-appl_source_txt.
      ls_appl_info_x-appl_source_info     = ls_p5132_txt-appl_source_info.
      ls_appl_info_x-sclas                = ls_p5132_txt-sclas.
      ls_appl_info_x-sobid                = ls_p5132_txt-sobid.
      ls_appl_info_x-appl_src_pernr       = ls_p5132_txt-appl_src_pernr.

*     get candidate
      CALL METHOD lo_application->get_candidates
        IMPORTING
          candidate_list = lt_candidate_list.

      READ TABLE lt_candidate_list INDEX 1 INTO lo_candidate.

      IF lo_candidate IS NOT BOUND.
        TRY.
            l_msgv1 = lo_application->id.
            IF 1 EQ 2.
              MESSAGE e067(hrrcf0001) WITH l_msgv1.
*             There is no candidate assigned to the application &1
            ENDIF.
            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                hrobject       = lo_application->hrobject
                message_type   = 'E'
                message_class  = msgcl_admin
                message_number = '067'
                message_par1   = l_msgv1.
          CATCH cx_hrrcf INTO lo_exception.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_exception.
            EXIT.
        ENDTRY.
      ENDIF.

      ls_appl_info_x-cand_hrobject = lo_candidate->hrobject.
      IF lo_candidate->centraldataperson-fullname IS NOT INITIAL.
        ls_appl_info_x-cand_name =
          lo_candidate->centraldataperson-fullname.
      ELSE.
        CONCATENATE lo_candidate->hrobject-otype
                    lo_candidate->hrobject-objid
               INTO ls_appl_info_x-cand_name.
      ENDIF.
      ls_appl_info_x-is_employee = lo_candidate->is_employee( ).
      "WG/N2202046
      ls_appl_info_x-employeeid  = lo_candidate->GET_EMPLOYEE_ID( )."employeeid.

*     get posting
      CALL METHOD lo_application->get_postings
        IMPORTING
          posting_list = lt_posting_list.

      READ TABLE lt_posting_list INDEX 1 INTO lo_posting.

      IF lo_posting IS NOT BOUND.
        TRY.
            l_msgv1 = lo_application->id.
            IF 1 EQ 2.
              MESSAGE e064(hrrcf0001) WITH l_msgv1.
*             There is no posting for this application &1
            ENDIF.
            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                hrobject       = lo_application->hrobject
                message_type   = 'E'
                message_class  = msgcl_admin
                message_number = '064'
                message_par1   = l_msgv1.
          CATCH cx_hrrcf INTO lo_exception.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_exception.
            EXIT.
        ENDTRY.
      ENDIF.

      ls_appl_info_x-posting_hrobject = lo_posting->hrobject.

*     get requisition
      CALL METHOD lo_posting->get_requisitions
        IMPORTING
          requisition_list = lt_requisition_list.

      READ TABLE lt_requisition_list INDEX 1 INTO lo_requisition.

      IF lo_requisition IS NOT BOUND.
        TRY.
            IF 1 EQ 2.
              MESSAGE e059(hrrcf0001).
*             There is no requisition for this posting
            ENDIF.
            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                hrobject       = lo_posting->hrobject
                message_type   = 'E'
                message_class  = msgcl_admin
                message_number = '059'.
          CATCH cx_hrrcf INTO lo_exception.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_exception.
            EXIT.
        ENDTRY.
      ENDIF.

      ls_appl_info_x-req_hrobject = lo_requisition->hrobject.

*     get requisition information
      CALL METHOD cl_hrrcf_requisition_info=>get_instance
        EXPORTING
          hrobject = lo_requisition->hrobject
        IMPORTING
          instance = lo_requisition_info.

      CALL METHOD lo_requisition_info->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_p5125.

      READ TABLE lt_p5125 INDEX 1 INTO ls_p5125.

      ls_appl_info_x-req_header = ls_p5125-header.
      ls_appl_info_x-req_alias  = ls_p5125-req_alias.
      IF ls_p5125-req_type = '1'. "Check if it is an application group
        ls_appl_info_x-posting_header = ls_p5125-header.
      ENDIF.

      IF p_nr_cdcy_not_requested EQ false.
*     get further candidacies w/ status 'In process' or 'To be hired'
        CALL METHOD me->ref_cdcy_bl->get_nr_cdcy
          EXPORTING
            ps_cand_hrobject = ls_appl_info_x-cand_hrobject
          IMPORTING
            p_nr_cdcy_open   = l_nr_in_process
            p_nr_cdcy_hired  = l_nr_to_be_hired.

        ls_appl_info_x-nr_cdcy_open = l_nr_in_process + l_nr_to_be_hired.

        CALL METHOD me->get_candidacy
          EXPORTING
            ps_appl_hrobject = ls_appl_info_x-appl_hrobject
          RECEIVING
            ps_cdcy_hrobject = ls_cdcy_hrobject.

        CALL METHOD me->ref_cdcy_bl->get_candidacy_status
          EXPORTING
            ps_cdcy_hrobject = ls_cdcy_hrobject
          IMPORTING
            p_status         = l_cdcy_status.

        IF l_cdcy_status EQ '0' OR   "In process
           l_cdcy_status EQ '3'.     "To be hired
          SUBTRACT 1 FROM ls_appl_info_x-nr_cdcy_open.
        ENDIF.
        IF ls_appl_info_x-nr_cdcy_open GT 0.
          ls_appl_info_x-further_appls = true.
        ELSE.
          ls_appl_info_x-further_appls = false.
        ENDIF.
      ENDIF.

*     move data to exporting parameter
      ps_appl_info_x = ls_appl_info_x.

*   exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.

ENDMETHOD.


method get_application_list_x .
*
* Author   : RH
* Additions: AS
*
* This method reads the applications of a candidate or a requistion
* plus additional information.
*
  data: lo_exception   type ref to cx_hrrcf,
        lo_candidate   type ref to cl_hrrcf_candidate,
        lo_requisition type ref to cl_hrrcf_requisition,
        lo_posting type ref to cl_hrrcf_posting,
        lo_application type ref to cl_hrrcf_candidate_application.
*
  data: lt_posting_list type rcf_t_posting,
        lt_application_list type rcf_t_application,
        lt_appl_all type rcf_t_application.
*
  data: ls_applications_x type rcf_s_list_applications_x.
*
  try.
*
*     candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
        call method lo_candidate->get_applications
          importing
            application_list = lt_appl_all.
*
*     requisition
      elseif ps_req_hrobject is supplied.
        call method cl_hrrcf_requisition=>get
          exporting
            id          = ps_req_hrobject-objid
          importing
            requisition = lo_requisition.
        call method lo_requisition->get_postings
          importing
            posting_list = lt_posting_list.
        loop at lt_posting_list into lo_posting.
          refresh lt_application_list.
          call method lo_posting->get_applications
            importing
              application_list = lt_application_list.
          append lines of lt_application_list to lt_appl_all.
        endloop.
      endif.
*
*     get additional information
      loop at lt_appl_all into lo_application.
        clear ls_applications_x.
        call method get_application_info_x
          exporting
            ps_appl_hrobject = lo_application->hrobject
          importing
            ps_appl_info_x   = ls_applications_x.
        if ls_applications_x is not initial .
          append ls_applications_x to pt_applications_x.
        endif .
      endloop.
*
*   exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


METHOD get_application_source .
*
* Author: AS
*
  DATA lo_appl_info TYPE REF TO cl_hrrcf_appl_information.
  DATA lt_appl_info TYPE rcf_t_appl_information_txt.
  DATA ls_appl_info TYPE rcf_s_appl_information_txt.
  DATA lv_message_par1 TYPE symsgv.
  DATA ls_t77rcf_applsrc TYPE t77rcf_applsrc.
  DATA ls_t77rcf_applsty_t TYPE t77rcf_applsty_t.
  DATA ls_t77rcf_applsty   TYPE t77rcf_applsty.
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lv_otr_alias TYPE string.
  DATA lv_text      TYPE string.
*
  CLEAR ps_application_source.
  REFRESH pt_return.
*
  TRY.
*
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.
*
      CALL METHOD lo_appl_info->get_records_by_date_with_text
        EXPORTING
          date           = sy-datum
          language       = p_langu
        IMPORTING
          pt_appl_info_t = lt_appl_info.
*
      READ TABLE lt_appl_info INDEX 1 INTO ls_appl_info.
      IF sy-subrc NE 0.
        IF 1 EQ 2.
          MESSAGE e176(hrrcf0001) WITH ps_appl_hrobject-objid.
*         There are no records of IT5132 available for application &1
        ENDIF.
        lv_message_par1 = ps_appl_hrobject-objid.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            hrobject       = ps_appl_hrobject
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '176'
            message_par1   = lv_message_par1.
      ENDIF.
*
      ps_application_source-appl_source = ls_appl_info-appl_source.
      ps_application_source-appl_source_info = ls_appl_info-appl_source_info.
      ps_application_source-appl_source_txt = ls_appl_info-appl_source_txt.
*
      CALL METHOD cl_hrrcf_t77rcf_applsrc=>read_record
        EXPORTING
          appl_source    = ls_appl_info-appl_source
        IMPORTING
          t77rcf_applsrc = ls_t77rcf_applsrc.
      ps_application_source-appl_source_type = ls_t77rcf_applsrc-appl_source_type.
*
      TRY.
          CALL METHOD cl_hrrcf_t77rcf_applsty=>read_description
            EXPORTING
              langu            = p_langu
              appl_source_type = ls_t77rcf_applsrc-appl_source_type
            IMPORTING
              t77rcf_applsty_t = ls_t77rcf_applsty_t.

        CATCH cx_hrrcf_customizing.
*           no description maintained -> Read OTR text of application source type
          CALL METHOD cl_hrrcf_t77rcf_applsty=>read_record
            EXPORTING
              appl_source_type = ls_t77rcf_applsrc-appl_source_type
            IMPORTING
              t77rcf_applsty   = ls_t77rcf_applsty.

          lv_otr_alias = ls_t77rcf_applsty-appl_stype_otr.
          IF lv_otr_alias IS NOT INITIAL.
            CALL METHOD cl_hrrcf_services_general=>get_otr_text
              EXPORTING
                p_alias = lv_otr_alias
              RECEIVING
                p_text  = lv_text.
            ls_t77rcf_applsty_t-description = lv_text.
          ENDIF.
      ENDTRY.

      ps_application_source-appl_source_type_txt = ls_t77rcf_applsty_t-description.
*
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
*
ENDMETHOD.


method get_application_status .
*
* Autor: AS
*
* This method reads the status of the application + reason code.
*
  data: lo_exception    type ref to cx_hrrcf.
  data lo_application type ref to cl_hrrcf_candidate_application.
*
  try.
*
      call method cl_hrrcf_candidate_application=>get
        exporting
          id          = ps_appl_hrobject-objid
        importing
          application = lo_application.
*
      call method lo_application->get_application_status
        exporting
          p_date            = sy-datum
          p_langu           = sy-langu
        importing
          p_status          = p_status
          p_status_txt      = p_status_txt
          p_reason_code     = p_reason_code
          p_reason_code_txt = p_reason_code_txt.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


METHOD get_application_status_list.
*
* Author   : RH
* Additions: AS
*
* This method reads the list of possible stuses for the application.
*
  DATA lo_exception TYPE REF TO cx_hrrcf.
*
  TRY.
      CALL METHOD cl_hrrcf_services_general=>get_domain_value_list
        EXPORTING
          p_domain_name = 'RCF_APPLICATION_STATUS'
        IMPORTING
          pt_valuelist  = pt_status_list.
*
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
*
* Delete status which are not needed for recruiter
  DELETE pt_status_list WHERE low EQ c_draft.
*  DELETE pt_status_list WHERE low EQ c_withdrawn.
*
ENDMETHOD.


method get_appl_cover_letter .
*
* Autor: Ricarda Hönisch
* Additions: AS
*
* This method reads the application cover letter
*
  data lo_appl_info type ref to cl_hrrcf_appl_information.
  data lt_p5132 type table of p5132.
  data ls_p5132 type p5132.
  data lo_exception type ref to cx_hrrcf.
*
  try.
*
* get application information
      call method cl_hrrcf_appl_information=>get_instance
        exporting
          hrobject = ps_appl_hrobject
        importing
          instance = lo_appl_info.
*
      call method lo_appl_info->get_records_by_date
        importing
          infotype_records = lt_p5132.
*
      read table lt_p5132 index 1 into ls_p5132.
*
* read cover letter
      call method lo_appl_info->read_text
        exporting
          fieldname       = 'APPL_DESC'
          infotype_record = ls_p5132
          langu           = p_langu
          use_fallback    = true
        importing
          text            = ps_appl_description-description
          langu_tab       = ps_appl_description-langu_tab
          doc_langu       = ps_appl_description-doc_langu.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


METHOD get_appl_create_date .

  DATA: lo_application TYPE REF TO cl_hrrcf_candidate_application,
        lo_exception TYPE REF TO cx_hrrcf.

* get instance of application and application information
  TRY.
      CALL METHOD cl_hrrcf_candidate_application=>get
        EXPORTING
          id          = ps_appl_hrobject-objid
        IMPORTING
          application = lo_application.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.

  p_create_date = lo_application->create_date.

ENDMETHOD.


METHOD get_appl_documents .

*Author: BM
*  indirect url:  (restrictions in smartforms)

  FIELD-SYMBOLS: <docs> TYPE rcf_s_qa_activity_txt.
  DATA:  ls_docs TYPE rcf_s_qa_activity_txt,
         lt_docs TYPE rcf_t_qa_activity_txt,
        lo_exception TYPE REF TO cx_hrrcf.

  TYPES: BEGIN OF ty_url,
           name(80),
           url TYPE string,
         END   OF ty_url.

  DATA lt_url TYPE TABLE OF ty_url.
  DATA ls_url TYPE          ty_url.

  DATA lv_url  TYPE string.

*     get questionnaires
  CALL METHOD cl_hrrcf_qa_bl=>get_documents_appl_ovr
    EXPORTING
      ps_appl_hrobject   = appl_hrobject
    IMPORTING
      pt_qa_activity_txt = lt_docs.

  LOOP AT lt_docs ASSIGNING <docs>.
    MOVE-CORRESPONDING: <docs> TO ls_docs.
    APPEND ls_docs TO documents.
  ENDLOOP.

ENDMETHOD.


METHOD get_appl_list.
 "N_1500926 -> Method created for Candidate's Application list performance improvement
*N_1706655 -> Parameter 'pt_applications' is added for BSP dashboard performance issue.
* Only fields relevant for dashboard is fetched if parameter 'pt_applications' is supplied

  " Data Declaration

  " Local Internal tables
  DATA : lt_applist       TYPE STANDARD TABLE OF applist,
         lt_appls         TYPE STANDARD TABLE OF appls,
         lt_otjid         TYPE STANDARD TABLE OF t_otjid,
         lt_nd_na         TYPE STANDARD TABLE OF hrp1001,
         lt_na            TYPE rcf_t_hrobject,
         lt_p5125         TYPE STANDARD TABLE OF hrp5125,
         lt_appl_list2    TYPE rcf_t_list_applications_x,
         lt_postings      TYPE STANDARD TABLE OF postlist,
         lt_p5121         TYPE rcf_t_posting_information,
         lt_status_texts  TYPE  ddfixvalues,
         lt_req_type      TYPE  ddfixvalues,
         lt_appl_list     TYPE rcf_t_list_applications_x,
         lt_cand_info     TYPE rcf_t_esa_cand_basic_data.

  " Local Structures
  DATA : ls_applist         TYPE applist,
         ls_appls           TYPE appls,
         ls_status_text     TYPE ddfixvalue,
         ls_req_type        TYPE ddfixvalue,
         ls_postings        TYPE postlist,
         ls_post_txt        TYPE t_posting_txt,
         ls_p5121           TYPE p5121,
         ls_p5122           TYPE p5122,
         ls_p5125           TYPE hrp5125,
         ls_5122            TYPE t_5122,
         ls_t77rcf_applsrc   TYPE t77rcf_applsrc,
         ls_t77rcf_applsty_t TYPE t77rcf_applsty_t,
         ls_otjid           TYPE otjid,
         ls_applications_x  TYPE rcf_s_list_applications_x,
         ls_applications    TYPE hrobject,
         ls_hrobject        TYPE hrobject,
         ls_hrp1001         TYPE hrp1001,
         ls_appl_list       TYPE rcf_s_list_applications_x ,
         ls_reqlist         TYPE t_reqlist,
         ls_cand_info       TYPE rcf_s_esa_cand_basic_data.

  " Local objects
  DATA : lo_ex           TYPE REF TO cx_root .
  DATA : lo_post_info    TYPE REF TO cl_hrrcf_posting_information.
  DATA : lo_post_inst    TYPE REF TO cl_hrrcf_posting_instance.

  " Local variables
  DATA : plvar TYPE plvar.
  DATA : ls_t77rcf_applsrc_t TYPE t77rcf_applsrc_t.

  DATA l_nr_in_process     TYPE int4. "PVA1926668
  DATA l_nr_to_be_hired    TYPE int4. "PVA1926668

  TRY.
*  Read status text
      CALL METHOD cl_hrrcf_services_general=>get_domain_value_list
        EXPORTING
          p_domain_name = 'RCF_APPLICATION_STATUS'
          p_language    = sy-langu
        IMPORTING
          pt_valuelist  = lt_status_texts.

*  Read Requisition type text
       CALL METHOD cl_hrrcf_services_general=>get_domain_value_list
        EXPORTING
          p_domain_name = 'RCF_REQUISITION_TYPE'
          p_language    = sy-langu
        IMPORTING
          pt_valuelist  = lt_req_type.

* Get plan version
      CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
        EXPORTING
          set_default_plvar = 'X'
        IMPORTING
          act_plvar         = plvar
        EXCEPTIONS
          no_active_plvar   = 0
          OTHERS            = 0.

        IF pt_applications IS SUPPLIED AND NOT pt_applications IS INITIAL.                "N 1791935

          LOOP AT pt_applications INTO ls_applications.
            CONCATENATE 'ND' ls_applications-objid INTO ls_otjid.
            APPEND ls_otjid TO lt_otjid.
          ENDLOOP.

* Get the list of candidates
          SELECT * FROM HRP1001
                   INTO TABLE lt_nd_na
                   FOR ALL ENTRIES IN lt_otjid
                   WHERE plvar = plvar AND
                         otjid = lt_otjid-otjid AND
                         subty = 'B651' AND
                         endda GE sy-datum.

          LOOP AT lt_nd_na INTO ls_hrp1001.
            ls_hrobject-plvar = ls_hrp1001-plvar.
            ls_hrobject-otype = 'NA'.
            ls_hrobject-objid = ls_hrp1001-sobid.
            APPEND ls_hrobject TO lt_na.
          ENDLOOP.

* Get Candidate information
          CALL METHOD cl_hrrcf_candidate_admin_bl=>get_cand_name
            EXPORTING
              pt_candidates = lt_na
            IMPORTING
              pt_cand_info  = lt_cand_info.

* Get Application information
          SELECT objid appl_status appl_date pinst_guid appl_source appl_source_info
               INTO CORRESPONDING FIELDS OF TABLE lt_appls
               FROM hrp5132
               FOR ALL ENTRIES IN lt_otjid
               WHERE plvar = plvar AND
                     otjid = lt_otjid-otjid AND
                     endda ge sy-datum.

          SORT lt_nd_na by plvar otype objid.
          SORT lt_cand_info by cand_objid.
        ELSE.
*  Join HRP1001 and HRP5132 to get the application list
          SELECT h1~sobid h2~appl_date h2~appl_status h2~pinst_guid
                 INTO CORRESPONDING FIELDS OF TABLE lt_applist
                 FROM hrp1001 AS h1
                 INNER JOIN hrp5132 AS h2 ON h2~objid = h1~sobid
                 WHERE h1~otype = 'NA' AND
                       h1~objid = ps_cand_hrobject-objid AND
                       h1~plvar = plvar AND
                       h1~rsign = 'A' AND
                       h1~relat = '651' AND
                       h1~istat = '1'   AND
                       h1~priox = ' '  AND
                       h1~begda LE sy-datum AND
                       h1~endda GE sy-datum AND
                       h1~sclas = 'ND'  AND
                       h2~plvar = plvar AND
                       h2~otype = 'ND' AND
                       h2~begda LE sy-datum  AND
                       h2~endda GE sy-datum .
        ENDIF.


        IF pt_applications IS SUPPLIED.
          LOOP AT lt_appls INTO ls_appls.

            ls_applist-sobid       = ls_appls-objid.
            ls_applist-appl_date   = ls_appls-appl_date.
            ls_applist-appl_status = ls_appls-appl_status.
            ls_applist-pinst_guid  = ls_appls-pinst_guid.

            APPEND ls_applist TO lt_applist.

            CLEAR: ls_appl_list,
                   ls_appls.

          ENDLOOP.
        ENDIF.

" Convert the data type of sobid suitable for join
        LOOP AT lt_applist INTO ls_applist.

*        Move hrobject id
            ls_appl_list-appl_hrobject-plvar = plvar.
            ls_appl_list-appl_hrobject-otype = 'ND'.
            ls_appl_list-appl_hrobject-objid = ls_applist-sobid.
            ls_appl_list-appl_objid = ls_applist-sobid.
            ls_appl_list-pinst_guid  = ls_applist-pinst_guid.
            APPEND ls_appl_list TO lt_appl_list2.

            CLEAR: ls_appl_list,
                   ls_applist.

          ENDLOOP.

*  Join HRP1001 and HRP5121
        IF NOT lt_appl_list2 IS INITIAL.
          SELECT h1~objid h1~sobid
              INTO CORRESPONDING FIELDS OF TABLE lt_postings
              FROM hrp1001 AS h1
              INNER JOIN hrp5121 AS h2 ON h2~objid = h1~sobid
              FOR ALL ENTRIES IN lt_appl_list2
              WHERE h1~plvar = plvar AND
                      h1~otype = 'ND' AND
                      h1~objid = lt_appl_list2-appl_objid AND
                      h1~rsign = 'A' AND
                      h1~relat = '653' AND
                      h1~istat = '1'   AND
                      h1~priox = ' '  AND
                      h1~begda LE sy-datum AND
                      h1~endda GE sy-datum AND
                      h1~sclas = 'NC' AND
                      h2~plvar = plvar AND
                      h2~otype = 'NC' AND
                      h2~begda LE sy-datum AND
                      h2~endda GE sy-datum .
        ENDIF.

*    Fetch data from HRP5122
        IF NOT lt_applist IS INITIAL.
          SELECT plvar
                 otype
                 objid
                 external_code
                 status
                 pinst_guid
                 FROM hrp5122 INTO CORRESPONDING FIELDS OF TABLE gt_5122
                 FOR ALL ENTRIES IN lt_applist
                 WHERE plvar = plvar AND
                       otype = 'NC' AND
                       pinst_guid = lt_applist-pinst_guid.
          IF sy-subrc EQ 0.
            SORT gt_5122 BY pinst_guid.
          ENDIF.
        ENDIF.

"  Populate the posting text for each postings
* Populate the posting text buffer if it is empty
        IF gt_post_txt IS INITIAL.
          LOOP AT  lt_postings INTO ls_postings.

            ls_hrobject-plvar = plvar.
            ls_hrobject-otype = 'NC'.
            ls_hrobject-objid = ls_postings-sobid.

*    copy posting hrobject
            ls_post_txt-post_hrobject = ls_hrobject.

*    copy application hrobject
            ls_post_txt-appl_hrobject-plvar = plvar.
            ls_post_txt-appl_hrobject-otype = 'ND'.
            ls_post_txt-appl_hrobject-objid = ls_postings-objid.

            IF pt_applications IS INITIAL.

*       get posting header
              CALL METHOD cl_hrrcf_posting_information=>get_instance
                EXPORTING
                  hrobject = ls_hrobject
                IMPORTING
                  instance = lo_post_info.

              CALL METHOD lo_post_info->get_records_by_date
                EXPORTING
                  date             = sy-datum
                IMPORTING
                  infotype_records = lt_p5121.

              READ TABLE lt_p5121 INDEX 1 INTO ls_p5121.

              CALL METHOD lo_post_info->read_text
                EXPORTING
                  fieldname       = 'HEADER'
                  infotype_record = ls_p5121
                IMPORTING
                  text            = ls_post_txt-txt.

            ENDIF.

            APPEND  ls_post_txt TO gt_post_txt.

            CLEAR :ls_post_txt, ls_hrobject.

          ENDLOOP.
        ENDIF.

        SORT gt_post_txt BY appl_hrobject.

        IF NOT gt_post_txt IS INITIAL.
          SELECT h1~objid h1~sobid
              INTO CORRESPONDING FIELDS OF TABLE gt_reqlist
              FROM hrp1001 AS h1
              INNER JOIN hrp5125 AS h2 ON h2~objid = h1~sobid
              FOR ALL ENTRIES IN gt_post_txt
             WHERE h1~plvar = plvar   AND
                      h1~otype = 'NC' AND
                      h1~objid = gt_post_txt-post_hrobject-objid AND
                      h1~rsign = 'A' AND
                      h1~relat = '652' AND
                      h1~istat = '1'   AND
                      h1~priox = ' '  AND
                      h1~begda LE sy-datum AND
                      h1~endda GE sy-datum AND
                      h1~sclas = 'NB'  AND
                      h2~plvar = plvar AND
                      h2~otype = 'NB' AND
                      h2~begda LE sy-datum AND
                      h2~endda GE sy-datum .
          IF sy-subrc EQ 0.
            SORT gt_reqlist BY objid.
            CLEAR lt_otjid.
            LOOP AT gt_reqlist INTO ls_reqlist.
             CONCATENATE 'NB' ls_reqlist-sobid INTO ls_otjid.
             APPEND ls_otjid TO lt_otjid.
            ENDLOOP.

            SELECT * FROM hrp5125
                     INTO TABLE lt_p5125
                     FOR ALL ENTRIES IN lt_otjid
                     WHERE plvar = plvar AND
                           otjid = lt_otjid-otjid.

            SORT lt_p5125 by plvar otype objid.

          ENDIF.
        ENDIF.

*  Copy to final internal table
      LOOP AT lt_applist INTO ls_applist.

*      Move hrobject id
        ls_appl_list-appl_hrobject-plvar = plvar.
        ls_appl_list-appl_hrobject-otype = 'ND'.
        ls_appl_list-appl_hrobject-objid = ls_applist-sobid.
        ls_appl_list-appl_objid          = ls_applist-sobid.                              "N 1791935

*      Move application date
        ls_appl_list-appl_date = ls_applist-appl_date.

*      Move application status and status text
        ls_appl_list-appl_status = ls_applist-appl_status.

        READ TABLE lt_appls INTO ls_appls WITH KEY objid = ls_appl_list-appl_hrobject-objid.
*     Read Application source information
        IF ls_appls-appl_source IS NOT INITIAL.
          CALL METHOD cl_hrrcf_t77rcf_applsrc=>read_record
           EXPORTING
             appl_source    = ls_appls-appl_source
           IMPORTING
             t77rcf_applsrc = ls_t77rcf_applsrc.

          TRY.
           CALL METHOD cl_hrrcf_t77rcf_applsrc=>read_description
             EXPORTING
               appl_source      = ls_appls-appl_source
               langu            = sy-langu
               use_fallback     = true
             IMPORTING
               t77rcf_applsrc_t = ls_t77rcf_applsrc_t.

           CALL METHOD cl_hrrcf_t77rcf_applsty=>read_description
             EXPORTING
               langu            = sy-langu
               appl_source_type = ls_t77rcf_applsrc-appl_source_type
             IMPORTING
               t77rcf_applsty_t = ls_t77rcf_applsty_t.

            ls_appl_list-appl_source_txt     = ls_t77rcf_applsrc_t-description. "PVA1847023 "PVA1926668
            ls_appl_list-appl_source_type     = ls_t77rcf_applsty_t-appl_source_type.
            ls_appl_list-appl_source_type_txt = ls_t77rcf_applsty_t-description.
          CATCH cx_hrrcf.
          ENDTRY.

        ENDIF.

        READ TABLE lt_status_texts INTO ls_status_text
                                   WITH KEY low = ls_applist-appl_status
                                       ddlanguage = sy-langu.
        IF sy-subrc EQ 0.
          ls_appl_list-appl_status_txt = ls_status_text-ddtext.
        ENDIF.


*      Move Posting instance GUID
        ls_appl_list-pinst_guid  = ls_applist-pinst_guid.

*       get posting instance external code and status
        IF NOT ls_applist-pinst_guid IS INITIAL.
          READ TABLE gt_5122 INTO ls_5122 WITH KEY pinst_guid = ls_applist-pinst_guid
                                            BINARY SEARCH.
          IF sy-subrc EQ 0.
            ls_appl_list-reference_code = ls_5122-external_code.
            ls_appl_list-pinst_status   = ls_5122-status.
          ENDIF.
        ENDIF.

*      Move posting text
        READ TABLE gt_post_txt INTO ls_post_txt WITH KEY
                            appl_hrobject  = ls_appl_list-appl_hrobject
                            BINARY SEARCH.
        IF sy-subrc EQ 0.
          ls_appl_list-pinst_header = ls_post_txt-txt.
*   Copy Requisition hrobject
          READ TABLE gt_reqlist INTO ls_reqlist WITH KEY objid = ls_post_txt-post_hrobject-objid
                                                    BINARY SEARCH.
          IF sy-subrc EQ 0.
            ls_appl_list-req_hrobject-plvar = plvar.
            ls_appl_list-req_hrobject-otype = 'NB'.
            ls_appl_list-req_hrobject-objid = ls_reqlist-sobid.

            READ TABLE lt_p5125 INTO ls_p5125 WITH KEY plvar = plvar
                                                       otype = 'NB'
                                                       objid = ls_appl_list-req_hrobject-objid
                                                       BINARY SEARCH.
            IF sy-subrc EQ 0.
* Requisition header
             ls_appl_list-req_header = ls_p5125-header.

            ENDIF.

* Requisition type text
            READ TABLE lt_req_type INTO ls_req_type
                                      WITH KEY low = ls_p5125-req_type
                                       ddlanguage = sy-langu.
            IF sy-subrc EQ 0.
             ls_appl_list-req_alias = ls_req_type-ddtext.
            ENDIF.

          ENDIF.
        ENDIF.

*        IF pt_applications IS INITIAL.                                                   "N 1791935
         IF ls_post_txt-txt IS INITIAL.
           CALL METHOD cl_hrrcf_posting_instance=>get_record_by_guid
             EXPORTING
               pinst_guid       = ls_applist-pinst_guid
             IMPORTING
               instance         = lo_post_inst
               posting_instance = ls_p5122.

*        get posting instance header
           CALL METHOD lo_post_inst->read_frozen_post_and_requi
             EXPORTING
               posting_instance_record = ls_p5122
             IMPORTING
               post_header             = ls_appl_list-pinst_header.
         ENDIF.
*        ELSE.                                                                            "N 1791935

* Get Candidate information
           READ TABLE lt_nd_na INTO ls_hrp1001 WITH KEY plvar = plvar
                                                        otype = 'ND'
                                                        objid = ls_appl_list-appl_hrobject-objid
                                                        BINARY SEARCH.
           IF sy-subrc EQ 0 .
            ls_appl_list-cand_hrobject-plvar = plvar.
            ls_appl_list-cand_hrobject-otype = 'NA'.
            ls_appl_list-cand_hrobject-objid = ls_hrp1001-sobid.

* Get Employee id and candidate name
            READ TABLE lt_cand_info INTO ls_cand_info WITH KEY cand_objid = ls_appl_list-cand_hrobject-objid.
            ls_appl_list-cand_name = ls_cand_info-fullname.
            ls_appl_list-employeeid = ls_cand_info-pernr.
            IF ls_appl_list-employeeid IS NOT INITIAL AND ls_appl_list-employeeid <> '00000000'.  "PVA1847023
              ls_appl_list-is_employee = 'X'.
            ENDIF.
            "START PVA1926668
            CALL METHOD me->ref_cdcy_bl->get_nr_cdcy
              EXPORTING
                ps_cand_hrobject = ls_appl_list-cand_hrobject
              IMPORTING
                p_nr_cdcy_open   = l_nr_in_process
                p_nr_cdcy_hired  = l_nr_to_be_hired.
            ls_appl_list-nr_cdcy_open = l_nr_in_process + l_nr_to_be_hired.
            IF ls_appl_list-appl_status EQ '1' OR   "In process
               ls_appl_list-appl_status EQ '4'.     "To be hired
              SUBTRACT 1 FROM ls_appl_list-nr_cdcy_open.
            ENDIF.
            IF ls_appl_list-nr_cdcy_open GT 0.
              ls_appl_list-further_appls = true.
            ELSE.
              ls_appl_list-further_appls = false.
            ENDIF.
            "END PVA1926668
           ENDIF.

*        ENDIF.                                                                           "N 1791935

        APPEND ls_appl_list TO lt_appl_list.

        CLEAR: ls_appl_list,
               ls_applist,
               ls_status_text,
               ls_5122,
               ls_p5122,
               ls_post_txt,
               lo_post_inst,
               ls_reqlist,
               ls_appls,
               ls_hrp1001,
               ls_cand_info,
               ls_p5125,
               l_nr_in_process,               "PVA1926668
               l_nr_to_be_hired.              "PVA1926668

      ENDLOOP.



    CATCH cx_root INTO lo_ex .
*      add_exception( lo_ex ) .
  ENDTRY.
      CLEAR gt_post_txt. "PVA1847023
*     Export the results
      pt_appl_list = lt_appl_list.

ENDMETHOD.


METHOD get_appl_operative_date .

  DATA: lo_appl_info TYPE REF TO cl_hrrcf_appl_information,
        lo_exception TYPE REF TO cx_hrrcf,
        lt_appl_info TYPE        rcf_t_appl_information,
        ls_appl_info TYPE        p5132.


  TRY.
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.

      CALL METHOD lo_appl_info->get_records_by_date
        IMPORTING
          infotype_records = lt_appl_info.

      READ TABLE lt_appl_info INDEX 1 INTO ls_appl_info.
        p_appl_date =  ls_appl_info-appl_date.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.

ENDMETHOD.


METHOD get_audit_trail.

* Author: HGB

  DATA: lo_application TYPE REF TO cl_hrrcf_candidate_application,
        lo_ex          TYPE REF TO cx_hrrcf.

  CLEAR: pt_audit_trail,
         pt_version_info.

  TRY.
      CALL METHOD cl_hrrcf_candidate_application=>get
        EXPORTING
          id          = ps_appl_hrobject-objid
        IMPORTING
          application = lo_application.

      CALL METHOD lo_application->get_audit_trail
        IMPORTING
          pt_audit_trail  = pt_audit_trail
          pt_version_info = pt_version_info.

    CATCH cx_hrrcf INTO lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD get_candidacy.

* Author: HGB

* This method gets the candidacy originally associated with
* the application.

  DATA lo_appl_info  TYPE REF TO cl_hrrcf_appl_information.
  DATA lo_ex         TYPE REF TO cx_hrrcf.

  CLEAR ps_cdcy_hrobject.

  TRY.

      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.

      CALL METHOD lo_appl_info->get_leading_cdcy
        RECEIVING
          ps_cdcy_hrobject = ps_cdcy_hrobject.

*   handle exceptions
    CATCH cx_hrrcf INTO lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD get_candidate.
*
* Authors  : CS / AS
* Additions: HGB
*
* This methods determines the candidate related to the application
* with name, employee indicator and employee id.
*
  DATA: lo_candidate      TYPE REF TO cl_hrrcf_candidate,
        lo_application    TYPE REF TO cl_hrrcf_candidate_application,
        lo_exception      TYPE REF TO cx_hrrcf,
        lt_candidate_list TYPE rcf_t_candidate.
*
  TRY.
*
*     get instance of application
      CALL METHOD cl_hrrcf_candidate_application=>get
        EXPORTING
          id          = ps_appl_hrobject-objid
        IMPORTING
          application = lo_application.
*
*     get related candidate
      CALL METHOD lo_application->get_candidates
        IMPORTING
          candidate_list = lt_candidate_list.
*
      READ TABLE lt_candidate_list INDEX 1 INTO lo_candidate.
      IF sy-subrc NE 0.
        IF 1 = 2.
          MESSAGE e067(hrrcf0001) WITH lo_application->id.
*         There is no candidate assigned to the application &1
        ENDIF.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            hrobject       = lo_application->hrobject
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '067'.
      ENDIF.
*
*     hrobject
      IF p_cand_hrobject IS SUPPLIED.
        p_cand_hrobject = lo_candidate->hrobject.
      ENDIF.
*
*     candidate name
      IF p_cand_name IS SUPPLIED.
        p_cand_name = lo_candidate->centraldataperson-fullname.
      ENDIF.
*
*     candidate description
      IF p_cand_description IS SUPPLIED.
        CALL METHOD lo_candidate->get_cand_description
          IMPORTING
            cand_description = p_cand_description.
*
        IF p_cand_description IS INITIAL.
          CONCATENATE lo_candidate->hrobject-otype
                      lo_candidate->hrobject-objid
                 INTO p_cand_description.
        ENDIF.
      ENDIF.
*
*     employee indicator
      IF p_is_employee IS SUPPLIED.
        p_is_employee = lo_candidate->is_employee( ).
      ENDIF.
*
*     employee id
      IF p_employeeid IS SUPPLIED.
        IF p_is_employee EQ true.
          p_employeeid = lo_candidate->employeeid.
        ELSE.
          CLEAR p_employeeid.
        ENDIF.
      ENDIF.

*     user id
      IF p_user IS SUPPLIED.
        p_user = lo_candidate->user.
      ENDIF.
*
*   exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD get_ext_application_list.

  DATA: lo_exception TYPE REF TO cx_hrrcf.
  DATA: ls_application TYPE hrobject.
  DATA: lv_is_employee TYPE boole_d.
  DATA: lt_hrobjects TYPE TABLE OF hrpe_txobj.
  data: ls_object type hrpe_txobj.
*  TRY.
*      CALL METHOD me->fetch_applications
*        IMPORTING
*          pt_appl_hrobject = lt_applications.
*    CATCH cx_hrrcf .
*  ENDTRY.

  CALL FUNCTION 'RH_READ_ALL_OBJECTS_FOR_OTYPE'
    EXPORTING
      plvar              = '01'
      otype              = 'ND'
*   BEGDA              = '19000101'
*   ENDDA              = '99991231'
*   STATUS             = '1'
*   WITH_STEXT         = 'X'
   TABLES
     objects            = lt_hrobjects
*   OBJECTSTIME        =
* EXCEPTIONS
*   PLVAR_NEEDED       = 1
*   OTYPE_NEEDED       = 2
*   OTHERS             = 3
            .
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.


  LOOP AT lt_hrobjects INTO ls_object.
    ls_application-plvar = ls_object-plvar.
    ls_application-otype = ls_object-otype.
    ls_application-objid = ls_object-objid.
    TRY.
        CALL METHOD me->get_candidate
          EXPORTING
            ps_appl_hrobject = ls_application
          IMPORTING
            p_is_employee    = lv_is_employee.
      CATCH cx_hrrcf .
    ENDTRY.
    IF lv_is_employee EQ false.
      APPEND ls_application-objid TO p_ext_application_list.
    ENDIF.
  ENDLOOP.
ENDMETHOD.


method GET_INSTANCE .
*
* Author: Andrea Sadreameli
*
  if not instance is bound.
    create object instance.
  endif.
*
  return = instance.
*
endmethod.                    "GET_INTERNAL


method get_nr_appl .
*
* Author: AS
* Additions: CS
*
*This method reads the number of (open = in process / to be hired)
*applications of the specified candidate or requisition.
*
  data: lo_exception   type ref to cx_hrrcf,
        lo_application type ref to cl_hrrcf_candidate_application,
        lo_requisition type ref to cl_hrrcf_requisition,
        lo_candidate type ref to cl_hrrcf_candidate,
        lo_posting type ref to cl_hrrcf_posting,
        lo_appl_information type ref to cl_hrrcf_appl_information.
*
  data: lt_applications     type rcf_t_application,
        lt_appl_all type rcf_t_application,
        lt_posting_list type rcf_t_posting,
        lt_p5132 type table of p5132.
*
  data: ls_p5132 type p5132.
*
  data: lv_status type rcf_application_status.
*
  clear: p_nr_appl,
         p_nr_appl_open,
         p_nr_appl_in_process,
         p_nr_appl_no_draft.
*
  try.
*
* candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
        call method lo_candidate->get_applications
          importing
            application_list = lt_appl_all.
*
* requisition
      elseif ps_req_hrobject is supplied.
        call method cl_hrrcf_requisition=>get
          exporting
            id          = ps_req_hrobject-objid
          importing
            requisition = lo_requisition.
        call method lo_requisition->get_postings
          importing
            posting_list = lt_posting_list.
        loop at lt_posting_list into lo_posting.
          refresh lt_applications.
          call method lo_posting->get_applications
            importing
              application_list = lt_applications.
          append lines of lt_applications to lt_appl_all.
        endloop.
      endif.
*
* number all applications
      describe table lt_appl_all lines p_nr_appl.
*
* number of open applications / number of applications not in draft
      loop at lt_appl_all into lo_application.
        call method cl_hrrcf_appl_information=>get_instance
          exporting
            hrobject = lo_application->hrobject
          importing
            instance = lo_appl_information.
*
        call method lo_appl_information->get_records_by_date
          importing
            infotype_records = lt_p5132.
        read table lt_p5132 index 1 into ls_p5132 .
*
        lv_status     = ls_p5132-appl_status.
* get number of open applications
        if lv_status eq c_in_process or lv_status eq c_to_be_hired.
          p_nr_appl_open = p_nr_appl_open + 1.
        endif.
* get number of applications which are in process
        if lv_status eq c_in_process.
          p_nr_appl_in_process = p_nr_appl_in_process + 1.
        endif.
* get number of applications which are not in draft
        if lv_status ne c_draft.
          p_nr_appl_no_draft = p_nr_appl_no_draft + 1.
        endif.

      endloop.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


method GET_OPEN_CANDIDACY.
* Author: VSD
* This method returns any open candidacy (a recruiter proposal) which doesn't have any application
* for the current requisition
*
  data: lo_cdcy_bl       type ref to cl_hrrcf_candidacy_bl,
        lt_candidacies   type rcf_t_list_candidacies_x,
        ls_candidacy     type rcf_s_list_candidacies_x,
        ls_appl_info_x2  type rcf_s_list_applications_x,
        lo_ex            type ref to cx_hrrcf.

  clear ps_cdcy_hrobject.

  try.

      call method me->get_application_info_x2
        EXPORTING
          ps_appl_hrobject = ps_appl_hrobject
        IMPORTING
          ps_appl_info_x   = ls_appl_info_x2.
*
      call method cl_hrrcf_candidacy_bl=>get_instance
        RECEIVING
          return = lo_cdcy_bl.
*
      call method lo_cdcy_bl->get_candidacy_list_x
        EXPORTING
          ps_cand_hrobject = ls_appl_info_x2-cand_hrobject
        IMPORTING
          pt_candidacies_x = lt_candidacies.
*

      loop at lt_candidacies into ls_candidacy.
        check ls_candidacy-appl_hrobject is initial and
              ls_candidacy-req_hrobject eq ls_appl_info_x2-req_hrobject and
              ls_candidacy-cdcy_status eq lo_cdcy_bl->c_in_process.
        ps_cdcy_hrobject = ls_candidacy-cdcy_hrobject.
        return.
      endloop.

    catch cx_hrrcf into lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      raise exception type cx_hrrcf
        exporting
          previous = lo_ex.
  endtry.

endmethod.


method get_requisition .
*
* Author: AS
*
* This methods determines the requisition related to the application.
*
  data lo_posting type ref to cl_hrrcf_posting.
  data lo_application type ref to cl_hrrcf_candidate_application.
  data lo_requisition type ref to cl_hrrcf_requisition.
  data lo_exception type ref to cx_hrrcf.
  data lt_postings type rcf_t_posting.
  data lt_requisitions type rcf_t_requisition.
  data l_msgv type symsgv.
*
  clear ps_req_hrobject.
*
  try.
*
*     get instance of application
      call method cl_hrrcf_candidate_application=>get
        exporting
          id          = ps_appl_hrobject-objid
        importing
          application = lo_application.
*
*     get related posting
      call method lo_application->get_postings
        importing
          posting_list = lt_postings.
*
      read table lt_postings index 1 into lo_posting.
      if sy-subrc ne 0.
        try.
            if 1 = 2.
              message e173(hrrcf0001) with lo_application->id.
*             There is no posting assigned to the application &1
            endif.
            l_msgv = lo_application->id.
            raise exception type cx_hrrcf
              exporting
                hrobject       = lo_application->hrobject
                message_type   = 'E'
                message_class  = msgcl_admin
                message_number = '173'
                message_par1   = l_msgv.
          catch cx_hrrcf into lo_exception .
            call method cl_hrrcf_exception_handler=>write_exception_log
              exporting
                ex = lo_exception.
        endtry.
        return.
      endif.
*
*     get related requsition
      call method lo_posting->get_requisitions
        importing
          requisition_list = lt_requisitions.
      read table lt_requisitions index 1 into lo_requisition.
      if sy-subrc = 0.
        ps_req_hrobject = lo_requisition->hrobject.
      else.
        if 1 = 2.
          message e059(hrrcf0001).
*         There is no requisition for this posting
        endif.
        raise exception type cx_hrrcf
          exporting
            hrobject       = lo_posting->hrobject
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '059'.
      endif.
*
*   exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


method get_status_history .
*
* Author : AS
*
* This method reads the status history of the posting.
*
  data lt_fieldlog type rcf_t_fieldlog.
*
  data ls_fieldlog type rcf_s_fieldlog.
  data ls_status_history type rcf_s_status_history.
  data ls_log_data type rcf_s_fieldlog_data.
*
  data lo_ex type ref to cx_hrrcf.
  data lo_application type ref to cl_hrrcf_candidate_application.
*
  refresh pt_status_history.
*
  try.
*
* Get the instance.
      call method cl_hrrcf_candidate_application=>get
        exporting
          id          = ps_appl_hrobject-objid
        importing
          application = lo_application.
*
* get status_history
      call method lo_application->get_status_reason_history
        importing
          field_log = lt_fieldlog.
*
      loop at lt_fieldlog into ls_fieldlog.
        clear ls_status_history.
*       change date
        ls_status_history-change_date = ls_fieldlog-date.
*       change time
        ls_status_history-change_time = ls_fieldlog-time.
*       fullname
        ls_status_history-fullname = ls_fieldlog-user.
*       status
        clear ls_log_data.
        read table ls_fieldlog-log_data into ls_log_data
          with key fieldname = 'APPL_STATUS'.
        ls_status_history-status = ls_log_data-fieldvalue.
        ls_status_history-status_txt = ls_log_data-fielddescription.
*       reason code
        clear ls_log_data.
        read table ls_fieldlog-log_data into ls_log_data
          with key fieldname = 'REASON_CODE'.
        ls_status_history-reason_code = ls_log_data-fieldvalue.
        ls_status_history-reason_code_txt = ls_log_data-fielddescription.
*
        append ls_status_history to pt_status_history.
      endloop.
*
* exception handling
    catch cx_hrrcf into lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      raise exception type cx_hrrcf
        exporting
          previous = lo_ex.
  endtry.
*
endmethod.


METHOD get_status_responsible.

* Author: PEV
* This method returns the responsible of a status change
*  following 3 options:
*  1. Read application status change activity owner or
*  2. Read last candidacy status change activity owner or
*  3. Read application status change user
* Problems: changes within the same day can't be handled properly


  DATA: lt_t77rcf_act2stat    TYPE t77rcf_act2stat_tab,
        wa_act2stat           TYPE t77rcf_act2stat,
        lt_activity_list      TYPE rcf_t_list_activities_x,
        lt_cdcy_activity_list TYPE rcf_t_list_activities_x,
        ls_stat_act_list      TYPE rcf_s_list_activities_x,
        lt_candidacies        TYPE rcf_t_candidacy,
        lt_status_history     TYPE rcf_t_status_history,
        ls_status_history     TYPE rcf_s_status_history,
        lt_appl_info          TYPE TABLE OF p5132,
        ls_appl_info          TYPE p5132,
        lv_date               TYPE sy-datum,
        lv_cdcy_status        TYPE rcf_act2status.

  DATA: lo_application        TYPE REF TO cl_hrrcf_candidate_application,
        lo_candidacy          TYPE REF TO cl_hrrcf_candidacy,
        lo_appl_info          TYPE REF TO cl_hrrcf_appl_information,
        lo_exception          TYPE REF TO cx_hrrcf.


*-- 1. read activity type for status change on application object ---
  CLEAR lt_t77rcf_act2stat[].
  CLEAR wa_act2stat.

  CALL METHOD cl_hrrcf_t77rcf_act2stat=>read_act_by_status
    EXPORTING
      p_otype            = co_otype
      p_object_status    = p_status
    IMPORTING
      pt_t77rcf_act2stat = lt_t77rcf_act2stat.


* read application status change activity
  CLEAR lt_activity_list[].
  IF ps_appl_hrobject-otype IS INITIAL.
    ps_appl_hrobject-otype = co_otype.
  ENDIF.

  TRY.
      CALL METHOD cl_hrrcf_activity_factory=>get_activity_list
        EXPORTING
          in_hrobject      = ps_appl_hrobject
        IMPORTING
          pt_activity_list = lt_activity_list.

      SORT lt_activity_list BY date_executed last_changed DESCENDING.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.

  LOOP AT lt_t77rcf_act2stat INTO wa_act2stat.
    CLEAR ls_stat_act_list.

    READ TABLE lt_activity_list WITH KEY
      act_type = wa_act2stat-act_type
    INTO ls_stat_act_list.

    IF sy-subrc = 0.
      EXIT.
    ENDIF.

  ENDLOOP.

  IF ls_stat_act_list IS NOT INITIAL.
    p_res_sclas = ls_stat_act_list-res_sclas.
    p_res_sobid = ls_stat_act_list-res_sobid.
    RETURN.
  ENDIF.

*-- 2. read activity type for status change on candidacy object ---
  CLEAR lt_t77rcf_act2stat[].
  CLEAR wa_act2stat.

  CASE p_status.
    WHEN '0'.
      lv_cdcy_status = '4'.
    WHEN '1'.
      lv_cdcy_status = '0'.
    WHEN '2'.
      lv_cdcy_status = '1'.
    WHEN '3'.
      lv_cdcy_status = '2'.
    WHEN '4'.
      lv_cdcy_status = '3'.
    WHEN OTHERS.
  ENDCASE.

  CALL METHOD cl_hrrcf_t77rcf_act2stat=>read_act_by_status
    EXPORTING
      p_otype            = ref_cdcy_bl->co_otype
      p_object_status    = lv_cdcy_status
    IMPORTING
      pt_t77rcf_act2stat = lt_t77rcf_act2stat.

* get instance of application
  TRY.
      CALL METHOD cl_hrrcf_candidate_application=>get
        EXPORTING
          id          = ps_appl_hrobject-objid
        IMPORTING
          application = lo_application.

* get candidacies for the application
      CALL METHOD lo_application->get_candidacies
        IMPORTING
          candidacy_list = lt_candidacies.

* get activities for the candidacies
      CLEAR lt_activity_list[].
      CLEAR lt_cdcy_activity_list[].
      LOOP AT lt_candidacies INTO lo_candidacy.
        CALL METHOD cl_hrrcf_activity_factory=>get_activity_list
          EXPORTING
            in_hrobject      = lo_candidacy->hrobject
          IMPORTING
            pt_activity_list = lt_cdcy_activity_list.
        IF lt_cdcy_activity_list IS NOT INITIAL.
          APPEND LINES OF lt_cdcy_activity_list TO lt_activity_list.
          CLEAR lt_cdcy_activity_list.
        ENDIF.
      ENDLOOP.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.

* sort combined activity list
  SORT lt_activity_list BY date_executed last_changed DESCENDING.

  LOOP AT lt_t77rcf_act2stat INTO wa_act2stat.
    CLEAR ls_stat_act_list.

*   read first candidacy status change activity
*   problem: there can be more than one per day -> read time stamp
    READ TABLE lt_activity_list WITH KEY
      act_type = wa_act2stat-act_type
    INTO ls_stat_act_list.

    IF sy-subrc = 0.
      EXIT.
    ENDIF.

  ENDLOOP.

  IF ls_stat_act_list IS NOT INITIAL.
    p_res_sclas = ls_stat_act_list-res_sclas.
    p_res_sobid = ls_stat_act_list-res_sobid.
    RETURN.
  ENDIF.

*-- 3. read status history of application and get last changed by user -
* get status_history
  TRY.
      CLEAR lt_status_history[].
      CALL METHOD me->get_status_history
        EXPORTING
          ps_appl_hrobject  = ps_appl_hrobject
        IMPORTING
          pt_status_history = lt_status_history.


      READ TABLE lt_status_history INTO ls_status_history
      WITH KEY status = p_status.

      IF sy-subrc <> 0.
        RETURN.
      ENDIF.

      CLEAR lo_appl_info.
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.

* ... get records...
      IF ls_status_history-change_date IS NOT INITIAL.
        lv_date = ls_status_history-change_date.
      ELSE.
        lv_date = sy-datum.
      ENDIF.

      CALL METHOD lo_appl_info->get_records_by_date
        EXPORTING
          date             = lv_date
        IMPORTING
          infotype_records = lt_appl_info.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.

  READ TABLE lt_appl_info INTO ls_appl_info WITH KEY
  appl_status = p_status.

  IF ls_appl_info IS NOT INITIAL.
    p_res_sclas = 'US'.
    p_res_sobid = ls_appl_info-uname.
    RETURN.
  ELSE.
    p_res_sclas = 'US'.
    p_res_sobid = sy-uname.
  ENDIF.

ENDMETHOD.


METHOD is_appl_of_current_user.
* -------------------------------------------------------------------
* This method checks, whether an Application HROBJECT actually
* belongs to the user who is currently logged in.
* -------------------------------------------------------------------

  DATA: l_uname TYPE syuname.

  DATA  ls_candidate TYPE hrobject.
  DATA  l_cp_p      TYPE subtyp VALUE 'B209'.
  DATA  lv_lines    TYPE i.
  DATA  ls_hrobjid  TYPE hrobject.
  DATA  ls_cand     TYPE hrobject.
  DATA  ls_p1001    TYPE p1001.
  DATA  lo_cand1 TYPE REF TO cl_hrrcf_candidate.
  DATA  lo_cand2 TYPE REF TO cl_hrrcf_candidate.
  DATA  lo_ex    TYPE REF TO cx_root.
  DATA  lt_hri1001  TYPE p1001tab.

  TRY.
      CALL METHOD me->get_candidate
        EXPORTING
          ps_appl_hrobject = is_appl
        IMPORTING
          p_user           = l_uname.
    CATCH cx_hrrcf.
  ENDTRY.

  TRY.
  CALL METHOD me->get_candidate
    EXPORTING
      ps_appl_hrobject   = is_appl
    IMPORTING
      p_cand_hrobject    = ls_candidate .
   CATCH cx_hrrcf .
  ENDTRY.

  TRY.
   CALL METHOD cl_hrrcf_candidate=>get
     EXPORTING
       id        = ls_candidate-objid
     IMPORTING
       candidate = lo_cand1.
  CATCH cx_root INTO lo_ex.
*     write exception to slg1
      cl_hrrcf_exception_handler=>write_exception_log( ex = lo_ex ).
  ENDTRY.

* Note 1570225 - Code to handle Multiple employement scenario
  IF lo_cand1 IS BOUND.
    IF NOT lo_cand1->personid IS INITIAL.
      ls_hrobjid-plvar = ls_candidate-plvar.
      ls_hrobjid-otype = 'CP'.
      ls_hrobjid-objid = lo_cand1->personid.

      CALL METHOD cl_hrrcf_object_buffer=>read_relationship
          EXPORTING
            pv_isubty    = l_cp_p
            ps_ihrobject = ls_hrobjid
          IMPORTING
            pt_erelation = lt_hri1001.

      DESCRIBE TABLE lt_hri1001 LINES lv_lines.

      IF ( NOT lt_hri1001 IS INITIAL ) AND
         ( lv_lines > 1 ).
        LOOP AT lt_hri1001 INTO ls_p1001.

            ls_cand-objid = ls_p1001-sobid.

            IF ( NOT lo_cand1->employeeid IS INITIAL ) AND
               ( lo_cand1->employeeid EQ ls_cand-objid ).
             CONTINUE.
            ENDIF.

            TRY.
             CALL METHOD cl_hrrcf_candidate=>get
               EXPORTING
                 employeeid  = ls_cand-objid
               IMPORTING
                 candidate   = lo_cand2.
            CATCH cx_root INTO lo_ex.
*     write exception to slg1
            cl_hrrcf_exception_handler=>write_exception_log( ex = lo_ex ).
            ENDTRY.

            IF lo_cand2 IS BOUND.
              rv_for_current_user = abap_true.
              RETURN.
            ENDIF.

            CLEAR : lo_cand2,ls_p1001.

        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDIF.

  IF l_uname = sy-uname.
    rv_for_current_user = abap_true.
  ELSE.
    rv_for_current_user = abap_false.
  ENDIF.

ENDMETHOD.


method MAINTAIN_RD_DOC_STATISTICS.

  DATA:
    ls_doc_stat TYPE rcf_s_qa_doc_statistics.

  CALL METHOD cl_hrrcf_qa_bl=>get_doc_statistics
    EXPORTING
      is_hrobject   = is_hrobject
      iv_read_cand_qas_x = abap_true
    IMPORTING
      es_statistics = ls_doc_stat.

  CALL METHOD cl_hrrcf_t77rcf_rd_at=>modify_doc_statistics
    EXPORTING
      is_hrobject   = is_hrobject
      is_statistics = ls_doc_stat.

endmethod.


METHOD on_appl_activity_changed.

  FIELD-SYMBOLS:
    <ls_wplog>       TYPE wplog,
    <ls_general>     TYPE rcf_s_act_infotype_general,
    <lo_cdcy>        TYPE REF TO cl_hrrcf_candidacy.

  DATA:
    lo_appl_bl       TYPE REF TO cl_hrrcf_application_bl,
    lv_appl_status   TYPE rcf_application_status,
    ls_cdcy_hrobject TYPE hrobject,
    lo_abstract_act  TYPE REF TO cl_hrrcf_abstract_activity,
    lt_after_image   TYPE wplog_tab,
    ls_before_image  TYPE wplog,
    ls_after_image   TYPE wplog,
    lv_before_idx    TYPE i,
    lv_after_idx     TYPE i,
    ls_pnnnn         TYPE rcf_s_act_infotype_general,
    lt_new           TYPE rcf_t_act_infotype_general,
    ls_new           TYPE rcf_s_act_infotype_general,
    lt_old           TYPE rcf_t_act_infotype_general,
    lo_ex            TYPE REF TO cx_root.

  TRY.
      CALL METHOD cl_hrrcf_application_bl=>get_instance
        RECEIVING
          return = lo_appl_bl.

      CALL METHOD lo_appl_bl->get_application_status
        EXPORTING
          ps_appl_hrobject = ir_infotype->hrobject
        IMPORTING
          p_status         = lv_appl_status.

*--   Get original candidacy for changes to process assignment
      CALL METHOD lo_appl_bl->get_candidacy
        EXPORTING
          ps_appl_hrobject = ir_infotype->hrobject
        RECEIVING
          ps_cdcy_hrobject = ls_cdcy_hrobject.

      lo_abstract_act ?= ir_infotype.

      CALL METHOD lo_abstract_act->get_records
        IMPORTING
          infotype_records = lt_after_image.

      LOOP AT lt_after_image ASSIGNING <ls_wplog>.
        CLEAR ls_pnnnn.
        CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
          EXPORTING
            wplog = <ls_wplog>
          IMPORTING
            pnnnn = ls_pnnnn.
        APPEND ls_pnnnn TO lt_new.
      ENDLOOP.

      LOOP AT it_before_image ASSIGNING <ls_wplog>.
        CLEAR ls_pnnnn.
        CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
          EXPORTING
            wplog = <ls_wplog>
          IMPORTING
            pnnnn = ls_pnnnn.
        APPEND ls_pnnnn TO lt_old.
      ENDLOOP.

      LOOP AT lt_new ASSIGNING <ls_general>.
        READ TABLE lt_old WITH KEY act_guid = <ls_general>-act_guid
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
*--       Inserted record found
          CALL METHOD cl_hrrcf_candidacy_bl=>change_process_by_activity
            EXPORTING
              iv_act_guid      = <ls_general>-act_guid
              is_cdcy_hrobject = ls_cdcy_hrobject.

*--       Disregard draft applications with respect to storage in redundant data
          IF lv_appl_status <> '0'.
            CALL METHOD cl_hrrcf_activity_bl=>maintain_rd_last_act
              EXPORTING
                is_hrobject    = ir_infotype->hrobject
                iv_opera       = insert
                is_act_general = <ls_general>.
          ENDIF.

        ENDIF.
      ENDLOOP.

*--   Disregard draft applications with respect to storage in redundant data
      CHECK lv_appl_status <> '0'.

      LOOP AT lt_old ASSIGNING <ls_general>.
        lv_before_idx = sy-tabix.
        READ TABLE lt_new WITH KEY act_guid = <ls_general>-act_guid
              INTO ls_new.
        IF sy-subrc = 0.
          lv_after_idx = sy-tabix.
*--       Compare wplogs
          READ TABLE it_before_image INDEX lv_before_idx INTO ls_before_image.
          READ TABLE lt_after_image INDEX lv_after_idx INTO ls_after_image.
          IF ls_before_image <> ls_after_image.
*--         Changed record found.
            CALL METHOD cl_hrrcf_activity_bl=>maintain_rd_last_act
              EXPORTING
                is_hrobject    = ir_infotype->hrobject
                iv_opera       = modify
                is_act_general = ls_new.
          ENDIF.
        ELSE.
*--       Deleted record found
          CALL METHOD cl_hrrcf_activity_bl=>maintain_rd_last_act
            EXPORTING
              is_hrobject = ir_infotype->hrobject
              iv_opera    = delete.
        ENDIF.
      ENDLOOP.

      IF <ls_general> IS ASSIGNED AND <ls_general>-act_cat = '07'.
        CALL METHOD cl_hrrcf_application_bl=>maintain_rd_doc_statistics
          EXPORTING
            is_hrobject = ir_infotype->hrobject.
      ENDIF.

    CATCH cx_root INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
  ENDTRY.

ENDMETHOD.


METHOD submit_application.

* Author: HGB
* Additions: VSD
*
* On Submit of application, if the application is in status Draft and If there exists any Open Candidacy,
* link the newly submitted application to the Open candidacy and delete the Draft Candidacy.

  DATA: lo_cdcy_bl         TYPE REF TO cl_hrrcf_candidacy_bl,
        lo_ex              TYPE REF TO cx_root,
        lt_qa_activity_txt TYPE rcf_t_qa_activity_txt,
        ls_qa_activity_txt TYPE rcf_s_qa_activity_txt,
        lt_return          TYPE bapirettab,
        ls_return          TYPE bapiret2,
        lt_values          TYPE ddfixvalues,
        ls_value           TYPE ddfixvalue,
        ls_cdcy_hrobject   TYPE hrobject,
        l_appl_status      TYPE rcf_application_status,
        lt_cellvalue       TYPE rcf_t_qa_cellval,
        l_appl_status_txt  TYPE symsgv.

  DATA: ls_open_cdcy_hrobject TYPE hrobject,
        lo_appl               TYPE REF TO cl_hrrcf_candidate_application,
        lo_open_cdcy          TYPE REF TO cl_hrrcf_candidacy,
        lo_cdcy               TYPE REF TO cl_hrrcf_candidacy.

  DATA: lo_cdcy_info TYPE REF TO cl_hrrcf_candidacy_information.

  CLEAR pt_return.

  TRY.
*-    Get candidacy, if necessary
      IF ps_cdcy_hrobject IS INITIAL.
        ls_cdcy_hrobject = get_candidacy( ps_appl_hrobject ).
      ELSE.
        ls_cdcy_hrobject = ps_cdcy_hrobject.
      ENDIF.

*-    Check if all obligatory questionnaires have been answered
      CALL METHOD cl_hrrcf_qa_bl=>check_rec_plan_activities_done
        EXPORTING
          ps_cdcy_hrobject   = ls_cdcy_hrobject
        IMPORTING
          pt_qa_activity_txt = lt_qa_activity_txt
          pt_return          = lt_return.

      APPEND LINES OF lt_return TO pt_return.
      LOOP AT lt_return TRANSPORTING NO FIELDS
        WHERE type EQ 'E' OR type EQ 'A'.
        RETURN.
      ENDLOOP.

*     Check if application status in 'Draft'
      CALL METHOD me->get_application_status
        EXPORTING
          ps_appl_hrobject = ps_appl_hrobject
        IMPORTING
          p_status         = l_appl_status.

      IF l_appl_status NE me->c_draft.
*       Get application status text
        TRY.
            CALL METHOD cl_hrrcf_services_general=>get_domain_value_list
              EXPORTING
                p_domain_name = 'RCF_APPLICATION_STATUS'
              IMPORTING
                pt_valuelist  = lt_values.
            READ TABLE lt_values
              INTO ls_value WITH KEY low = l_appl_status.
            IF sy-subrc EQ 0.
              l_appl_status_txt = ls_value-ddtext.
            ELSE.
              l_appl_status_txt = l_appl_status.
            ENDIF.
          CATCH cx_hrrcf.
            l_appl_status_txt = l_appl_status.
        ENDTRY.
*       Generate return message and do not submit application
        IF 1 EQ 2.
          MESSAGE e179(hrrcf0001) WITH l_appl_status_txt.
*         Unable to resubmit an application in status &1
        ENDIF.
        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = msgcl_admin
            number = '179'
            par1   = l_appl_status_txt
          IMPORTING
            return = ls_return.
        APPEND ls_return TO pt_return.
        RETURN.
      ELSE.
*       Find the open candidacy with out application (a recruiter proposal)
        TRY.
            CALL METHOD me->get_open_candidacy
              EXPORTING
                ps_appl_hrobject = ps_appl_hrobject
              IMPORTING
                ps_cdcy_hrobject = ls_open_cdcy_hrobject.

            IF ls_open_cdcy_hrobject IS NOT INITIAL AND p_check_only EQ false.
*-            Get the Open Candidacy instance
              CALL METHOD cl_hrrcf_candidacy=>get
                EXPORTING
                  id        = ls_open_cdcy_hrobject-objid
                IMPORTING
                  candidacy = lo_open_cdcy.

              IF lo_open_cdcy IS BOUND.

                call method cl_hrrcf_candidate_application=>get                  "N 1762734
                  EXPORTING                                                      "N 1762734
                    id          = ps_appl_hrobject-objid                         "N 1762734
                  IMPORTING                                                      "N 1762734
                    application = lo_appl.                                       "N 1762734

                if lo_appl is bound.                                             "N 1762734

*-              Assign the Open Candidacy to the Application                     "N 1762734
                  call method lo_appl->assign_candidacy                          "N 1762734
                    EXPORTING                                                    "N 1762734
                      candidacy = lo_open_cdcy                                   "N 1762734
                    IMPORTING                                                    "N 1762734
                      return    = lt_return.                                     "N 1762734
                  append lines of lt_return to pt_return.                        "N 1762734
                else.                                                            "N 1762734
                  raise exception type cx_hrrcf.                                 "N 1762734
                endif.                                                           "N 1762734

                LOOP AT lt_return TRANSPORTING NO FIELDS                         "N 1762734
                  WHERE type EQ 'E' OR type EQ 'A'.                              "N 1762734
                  RETURN.                                                        "N 1762734
                ENDLOOP.                                                         "N 1762734
                CLEAR lt_return.                                                 "N 1762734

*-              Copy Questionnaires from Draft Candidacy to Open Candidacy
                TRY.
                    CALL METHOD cl_hrrcf_qa_bl=>copy_qa_activity
                      EXPORTING
                        ps_from_cdcy_hrobject = ls_cdcy_hrobject
                        ps_to_cdcy_hrobject   = ls_open_cdcy_hrobject
                      IMPORTING
                        pt_return             = lt_return.
                    APPEND LINES OF lt_return TO pt_return.
                  CATCH cx_hrrcf INTO lo_ex.
                    cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
                    RAISE EXCEPTION TYPE cx_hrrcf
                      EXPORTING
                        previous = lo_ex.
                ENDTRY.
*
                LOOP AT lt_return TRANSPORTING NO FIELDS
                  WHERE type EQ 'E' OR type EQ 'A'.
                  RETURN.
                ENDLOOP.
                CLEAR lt_return.

*                call method cl_hrrcf_candidate_application=>get                 "N 1762734
*                  EXPORTING                                                     "N 1762734
*                    id          = ps_appl_hrobject-objid                        "N 1762734
*                  IMPORTING                                                     "N 1762734
*                    application = lo_appl.                                      "N 1762734
*
*                if lo_appl is bound.                                            "N 1762734
*
**-              Assign the Open Candidacy to the Application                    "N 1762734
*                  call method lo_appl->assign_candidacy                         "N 1762734
*                    EXPORTING                                                   "N 1762734
*                      candidacy = lo_open_cdcy                                  "N 1762734
*                    IMPORTING                                                   "N 1762734
*                      return    = lt_return.                                    "N 1762734
*                  append lines of lt_return to pt_return.                       "N 1762734
*                else.                                                           "N 1762734
*                  raise exception type cx_hrrcf.                                "N 1762734
*                endif.                                                          "N 1762734
              ENDIF.
*
*              LOOP AT lt_return TRANSPORTING NO FIELDS                          "N 1762734
*                WHERE type EQ 'E' OR type EQ 'A'.                               "N 1762734
*                RETURN.                                                         "N 1762734
*              ENDLOOP.                                                          "N 1762734
*              CLEAR lt_return.                                                  "N 1762734
*             Relation replication
              CALL METHOD cl_hrrcf_candidacy_information=>get_instance
                EXPORTING
                  hrobject = ls_open_cdcy_hrobject
                IMPORTING
                  instance = lo_cdcy_info.
              call method lo_cdcy_info->set_relations
                exporting
                  appid = ps_appl_hrobject-objid
                importing
                  pt_return = lt_return.
*
*-            DELETE the Draft Candidacy
              CALL METHOD cl_hrrcf_candidacy=>get
                EXPORTING
                  id        = ls_cdcy_hrobject-objid
                IMPORTING
                  candidacy = lo_cdcy.

              CALL METHOD lo_cdcy->delete
                IMPORTING
                  return = lt_return.
              APPEND LINES OF lt_return TO pt_return.
*
              LOOP AT lt_return TRANSPORTING NO FIELDS
                WHERE type EQ 'E' OR type EQ 'A'.
                RETURN.
              ENDLOOP.
              CLEAR lt_return.
              MOVE ls_open_cdcy_hrobject TO ls_cdcy_hrobject.
              CALL METHOD cl_hrrcf_qa_bl=>get_activities_txt            "N_1524200
                EXPORTING
                  ps_hrobject        = ls_cdcy_hrobject
                  p_status           = 1
                  p_visible          = true
                IMPORTING
                  pt_qa_activity_txt = lt_qa_activity_txt.              "N_1524200
            ENDIF.
          CATCH cx_hrrcf INTO lo_ex.
            cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                previous = lo_ex.
        ENDTRY.
      ENDIF.

      IF cl_hrrcf_switch_check=>hrerc_sfws_ui_enh_02( ) = false.
*       Copy recruitment team of requisition to application
        CALL METHOD create_rec_team_by_default
          EXPORTING
            ps_appl_hrobject = ps_appl_hrobject
            p_check_only     = p_check_only
          IMPORTING
            pt_return        = lt_return.

        APPEND LINES OF lt_return TO pt_return.
        LOOP AT lt_return TRANSPORTING NO FIELDS
          WHERE type EQ 'E' OR type EQ 'A'.
          RETURN.
        ENDLOOP.
      ENDIF.

*     Change application status from 'Draft' to 'In process'
      CALL METHOD change_application_status
        EXPORTING
          ps_appl_hrobject = ps_appl_hrobject
          p_new_status     = me->c_in_process
          p_check_only     = p_check_only
        IMPORTING
          pt_return        = lt_return.

      APPEND LINES OF lt_return TO pt_return.
      LOOP AT lt_return TRANSPORTING NO FIELDS
        WHERE type EQ 'E' OR type EQ 'A'.
        RETURN.
      ENDLOOP.

*     Change candidacy status from 'Draft' to 'In process', if necessary
      lo_cdcy_bl = cl_hrrcf_candidacy_bl=>get_instance( ).

      CALL METHOD lo_cdcy_bl->change_candidacy_status
        EXPORTING
          ps_cdcy_hrobject = ls_cdcy_hrobject
          p_new_status     = lo_cdcy_bl->c_in_process
          p_check_only     = p_check_only
        IMPORTING
          pt_return        = lt_return.

      APPEND LINES OF lt_return TO pt_return.
      LOOP AT lt_return TRANSPORTING NO FIELDS
        WHERE type EQ 'E' OR type EQ 'A'.
        RETURN.
      ENDLOOP.

*-    Set activity status 'Done' for all questionnaires.
*-    This has to be done, after status of candidacy has been changed
*-    into 'in process' as an event handler for activities will be
*-    triggered. The handler will react only, if the candidacy is not
*-    in status draft.
      IF p_check_only EQ false.
        DELETE lt_qa_activity_txt WHERE status EQ '1'. "Done

        LOOP AT lt_qa_activity_txt INTO ls_qa_activity_txt.
          IF ls_qa_activity_txt-qa_doc_guid IS INITIAL.
*-          No document is filled -> generate a blank one
            CALL METHOD cl_hrrcf_qa_bl=>prepare_document_new
              EXPORTING
                p_template_id = ls_qa_activity_txt-qa_tpl_objid
              IMPORTING
                p_document_id = ls_qa_activity_txt-qa_doc_guid.
            CALL METHOD cl_hrrcf_qa_bl=>save_document
              EXPORTING
                p_activity_guid = ls_qa_activity_txt-act_guid
                p_document_id   = ls_qa_activity_txt-qa_doc_guid
                pt_cellvalue    = lt_cellvalue.        "Empty table
          ENDIF.
          CALL METHOD cl_hrrcf_qa_bl=>set_document_completed
            EXPORTING
              p_activity_guid = ls_qa_activity_txt-act_guid.
        ENDLOOP.
      ENDIF.

*   Handle exceptions
    CATCH cx_root INTO lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_ex.
  ENDTRY.

ENDMETHOD.


METHOD transform_selections.

* Author: PEV
* This method transforms and builds the selection criteria.
* Attention: not more than 6 tables are allowed (because of the limits in the JOIN-condition)

  DATA: ls_selections   TYPE rsds_range,
        ls_rsds_frange  TYPE rsds_frange,
        ls_selopt       TYPE rsdsselopt,
        ls_selection    TYPE rsds_range,
        lv_hrp_tabname  TYPE tabname,
        lv_plvar        TYPE plvar,
        lv_option       TYPE tvarv_opti,
        lv_high_value   TYPE rsdsselopt-high,
        lv_low          TYPE rsdsselopt-low,
        ls_member       TYPE rcf_s_member,
        lt_member       TYPE TABLE OF rcf_s_member,
        lv_user         TYPE sy-uname,
        lrt_role        TYPE rsds_selopt_t.

  FIELD-SYMBOLS:
        <selection>     TYPE rsds_range.

  CONSTANTS: c_object_it_tab TYPE infotyp         VALUE '1000',
             c_team_it_tab   TYPE infotyp         VALUE '5131',
             c_appl_it_tab   TYPE infotyp         VALUE '5132',
             c_include_value TYPE rsdsselopt-sign   VALUE 'I',
             c_exclude_value TYPE rsdsselopt-sign   VALUE 'E',
             c_option_eq     TYPE rsdsselopt-option VALUE 'EQ',
             c_option_bt     TYPE rsdsselopt-option VALUE 'BT',
             c_option_le     TYPE rsdsselopt-option VALUE 'LE',
             c_option_ge     TYPE rsdsselopt-option VALUE 'GE',
             c_text_plvar    TYPE fieldname       VALUE 'PLVAR',
             c_text_otype    TYPE fieldname       VALUE 'OTYPE',
             c_text_begda    TYPE fieldname       VALUE 'BEGDA',
             c_text_endda    TYPE fieldname       VALUE 'ENDDA',
             c_text_sobid    TYPE fieldname       VALUE 'SOBID',
             c_text_sclas    TYPE fieldname       VALUE 'SCLAS',
             c_text_role     TYPE fieldname       VALUE 'ROLE',
             c_text_us       TYPE fieldname       VALUE 'US',
             c_text_appl_status TYPE fieldname    VALUE 'APPL_STATUS',
             c_text_appl_source TYPE fieldname    VALUE 'APPL_SOURCE',
             c_text_appl_date   TYPE fieldname    VALUE 'APPL_DATE'.


  REFRESH pt_selections.

**-- 1. Selection of HR objects
*  CLEAR: lv_hrp_tabname, ls_selection.
*  CONCATENATE 'HRP' c_object_it_tab INTO lv_hrp_tabname.
*
**  plan variant
*  CLEAR: ls_selopt, ls_rsds_frange.
*
  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = lv_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.
*
*  ls_selopt-sign   = c_include_value.
*  ls_selopt-option = c_option_eq.
*  ls_selopt-low    = lv_plvar.
*  ls_selopt-high   = ''.
*
*  APPEND ls_selopt TO ls_rsds_frange-selopt_t.
*
*  ls_rsds_frange-fieldname = c_text_plvar.
*
*  APPEND ls_rsds_frange TO ls_selection-frange_t.
*
**  object type
*  CLEAR: ls_selopt, ls_rsds_frange.
*
*  ls_selopt-sign   = c_include_value.
*  ls_selopt-option = c_option_eq.
*  ls_selopt-low    = cl_hrrcf_candidate_application=>my_otype.
*  ls_selopt-high   = ''.
*
*  APPEND ls_selopt TO ls_rsds_frange-selopt_t.
*
*  ls_rsds_frange-fieldname = c_text_otype.
*
*  APPEND ls_rsds_frange TO ls_selection-frange_t.
*
***  creation date
**  IF ( p_begda IS SUPPLIED ) AND ( p_begda IS NOT INITIAL ).
**    CLEAR: ls_selopt, ls_rsds_frange.
**
**    IF ( p_endda IS INITIAL ).
**      lv_option = c_option_eq.
**      lv_high_value = ''.
**    ELSE.
**      lv_option = c_option_bt.
**      lv_high_value = p_endda.
**    ENDIF.
**
**    ls_selopt-sign   = c_include_value.
**    ls_selopt-option = lv_option.
**    ls_selopt-low    = p_begda.
**    ls_selopt-high   = lv_high_value.
**
**    APPEND ls_selopt TO ls_rsds_frange-selopt_t.
**
**    ls_rsds_frange-fieldname = c_text_begda.
**
**    APPEND ls_rsds_frange TO ls_selection-frange_t.
**  ENDIF.
*
** append to selection table
*  ls_selection-tablename = lv_hrp_tabname.
*  APPEND ls_selection TO pt_selections.

*-- 2. Selection of user and role in support team
  CLEAR: lv_hrp_tabname, ls_selection.
  CONCATENATE 'HRP' c_team_it_tab INTO lv_hrp_tabname.

*  sclas
  CLEAR: ls_selopt, ls_rsds_frange.

  ls_selopt-sign   = c_include_value.
  ls_selopt-option = c_option_eq.
*  ls_selopt-low    = c_text_us.
  ls_selopt-low    = '!lt_member-sclas'.  "!: no token, but variable
  ls_selopt-high   = ''.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = c_text_sclas.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*  sobid
  CLEAR: ls_selopt, ls_rsds_frange.

  IF ( p_user IS SUPPLIED ) AND ( p_user IS NOT INITIAL ).
    lv_user = p_user.
  ELSE.
    lv_user = sy-uname.
  ENDIF.

  ls_selopt-sign   = c_include_value.
  ls_selopt-option = c_option_eq.
  ls_selopt-low    = '!lt_member-sobid'.  "!: no token, but variable
  ls_selopt-high   = ''.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = c_text_sobid.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*  role
  IF ( p_role IS SUPPLIED ) AND ( p_role IS NOT INITIAL ).
    CLEAR: ls_selopt, ls_rsds_frange.

    ls_selopt-sign   = c_include_value.
    ls_selopt-option = c_option_eq.
    ls_selopt-low    = '!lt_member-role'.  "!: no token, but variable
    ls_selopt-high   = ''.

    APPEND ls_selopt TO ls_rsds_frange-selopt_t.

    ls_rsds_frange-fieldname = c_text_role.

    APPEND ls_rsds_frange TO ls_selection-frange_t.

*  fill range table with role
    ls_selopt-low = p_role.
    APPEND ls_selopt TO lrt_role.

  ENDIF.

* append to selection table
  ls_selection-tablename = lv_hrp_tabname.
  APPEND ls_selection TO pt_selections.

*-- 3. Selection of application information
  CLEAR: lv_hrp_tabname, ls_selection.
  CONCATENATE 'HRP' c_appl_it_tab INTO lv_hrp_tabname.

*  only current record
*  begda
  CLEAR: ls_selopt, ls_rsds_frange.

  ls_selopt-sign   = c_include_value.
  ls_selopt-option = c_option_le.
  ls_selopt-low    = sy-datum.
  ls_selopt-high   = ''.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = c_text_begda.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*  endda
  CLEAR: ls_selopt, ls_rsds_frange.

  ls_selopt-sign   = c_include_value.
  ls_selopt-option = c_option_ge.
  ls_selopt-low    = sy-datum.
  ls_selopt-high   = ''.

  APPEND ls_selopt TO ls_rsds_frange-selopt_t.

  ls_rsds_frange-fieldname = c_text_endda.

  APPEND ls_rsds_frange TO ls_selection-frange_t.

*  application status
  IF ( p_appl_status IS SUPPLIED ) AND ( p_appl_status IS NOT INITIAL ).
    CLEAR: ls_selopt, ls_rsds_frange.

    ls_selopt-sign   = c_include_value.
    ls_selopt-option = c_option_eq.
    ls_selopt-low    = p_appl_status.
    ls_selopt-high   = ''.

    APPEND ls_selopt TO ls_rsds_frange-selopt_t.

    ls_rsds_frange-fieldname = c_text_appl_status.

    APPEND ls_rsds_frange TO ls_selection-frange_t.
  ENDIF.

*  application source
  IF ( p_appl_source IS SUPPLIED ) AND ( p_appl_source IS NOT INITIAL ).
    CLEAR: ls_selopt, ls_rsds_frange.

    ls_selopt-sign   = c_include_value.
    ls_selopt-option = c_option_eq.
    ls_selopt-low    = p_appl_source.
    ls_selopt-high   = ''.

    APPEND ls_selopt TO ls_rsds_frange-selopt_t.

    ls_rsds_frange-fieldname = c_text_appl_source.

    APPEND ls_rsds_frange TO ls_selection-frange_t.
  ENDIF.

*  application date
  IF ( p_begda IS SUPPLIED ) AND ( p_begda IS NOT INITIAL ).
    CLEAR: ls_selopt, ls_rsds_frange.

    IF ( p_endda IS INITIAL ).
      lv_option = c_option_eq.
      lv_high_value = ''.
    ELSE.
      lv_option = c_option_bt.
      lv_high_value = p_endda.
    ENDIF.

    ls_selopt-sign   = c_include_value.
    ls_selopt-option = lv_option.
    ls_selopt-low    = p_begda.
    ls_selopt-high   = lv_high_value.

    APPEND ls_selopt TO ls_rsds_frange-selopt_t.

    ls_rsds_frange-fieldname = c_text_appl_date.

    APPEND ls_rsds_frange TO ls_selection-frange_t.
  ENDIF.

* append to selection table
  ls_selection-tablename = lv_hrp_tabname.
  APPEND ls_selection TO pt_selections.

*-- 4. Fill member tab
* add also current user
  CLEAR ls_member.
  ls_member-sclas = c_text_us.
  ls_member-sobid = lv_user.
  ls_member-role  = p_role.

  APPEND ls_member TO pt_member.

  SELECT DISTINCT m~otype m~objid
  INTO TABLE lt_member
               FROM ( hrp5152 AS m JOIN hrp5151 AS n

                      ON n~plvar = m~plvar AND
                         n~otjid = m~otjid AND
                         n~status = '1' )

               WHERE m~plvar  = lv_plvar   AND
                     m~otype  = 'NG'       AND
                     m~begda  LE sy-datum  AND
                     m~endda  GE sy-datum  AND
                     m~role   IN lrt_role  AND
                     m~sclas  = 'US'       AND
                     m~sobid  = p_user.

  APPEND LINES OF lt_member TO pt_member.

ENDMETHOD.


METHOD update_cover_letter.

* Author: HGB

* This method updates the cover letter of an existing application.

  DATA: lo_ex          TYPE REF TO cx_hrrcf,
        lo_appl_info   TYPE REF TO cl_hrrcf_appl_information,
        lt_appl_info   TYPE TABLE OF p5132,
        ls_appl_info   TYPE p5132,
        l_message_par1 TYPE symsgv,
        ls_return      TYPE bapiret2.

  CLEAR: p_appl_desc,
         pt_return.

  TRY.
      CALL METHOD cl_hrrcf_appl_information=>get_instance
        EXPORTING
          hrobject = ps_appl_hrobject
        IMPORTING
          instance = lo_appl_info.

      CALL METHOD lo_appl_info->get_records_by_date
        EXPORTING
          date             = sy-datum
        IMPORTING
          infotype_records = lt_appl_info.

      READ TABLE lt_appl_info INDEX 1 INTO ls_appl_info.
      IF sy-subrc NE 0.
        IF 1 EQ 2.
          MESSAGE e176(hrrcf0001) WITH ps_appl_hrobject-objid.
*         There are no records of IT5132 available for application &1
        ENDIF.
        l_message_par1 = ps_appl_hrobject-objid.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            hrobject       = ps_appl_hrobject
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '176'
            message_par1   = l_message_par1.
      ENDIF.
      TRY.
          CALL METHOD lo_appl_info->update_text
            EXPORTING
              text            = p_appl_cover_letter
              fieldname       = 'APPL_DESC'
            CHANGING
              infotype_record = ls_appl_info.
        CATCH cx_hrrcf INTO lo_ex.
*-        Write to the log
          CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
            EXPORTING
              ex = lo_ex.
          IF 1 EQ 2.
            MESSAGE e200(hrrcf0002).
*         At the moment server is busy, data is not saved. Please try again later.
          ENDIF.
          CALL FUNCTION 'BALW_BAPIRETURN_GET2'
            EXPORTING
              type   = 'E'
              cl     = 'HRRCF0002'
              number = '200'
            IMPORTING
              return = ls_return.
          APPEND ls_return TO pt_return.
          RETURN.
      ENDTRY.
*
      CALL METHOD lo_appl_info->update_record
        IMPORTING
          return          = pt_return
        CHANGING
          infotype_record = ls_appl_info.

      p_appl_desc = ls_appl_info-appl_desc.

    CATCH cx_hrrcf INTO lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.
ENDCLASS.