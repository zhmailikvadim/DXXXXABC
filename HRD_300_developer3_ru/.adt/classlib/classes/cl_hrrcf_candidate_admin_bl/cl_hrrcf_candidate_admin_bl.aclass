class CL_HRRCF_CANDIDATE_ADMIN_BL definition
  public
  final
  create private .

public section.

  interfaces IF_HRRCF_CONSTANTS .

  class-data SV_ASSURE_ACTIVE_PERNR_BY_DFLT type BOOLE_D read-only .

  methods CONSTRUCTOR .
  class-methods GET_CAND_EMPLOYEE_IDS
    importing
      !IS_CAND_HROBJECT type HROBJECT optional
      value(IV_EMPLOYEE_ID) type HROBJECT-OBJID optional
      value(IV_UNAME) type SYUNAME default SY-UNAME
      value(IV_KEYDATE) type SYDATUM default SY-DATUM
      !IV_EMPTY_PERNR_IF_NO_ACTIVE type BOOLE_D default ABAP_FALSE
    exporting
      !ET_INACTIVE_EMPLOYEE_ID type RCF_T_PERNR
      !ET_ACTIVE_EMPLOYEE_ID type RCF_T_PERNR
      !EV_LATEST_ACTIVE_EMPLOYEE_ID type PERNR_D
    raising
      CX_HRRCF .
  methods ASSIGN_TARGET_GROUP
    importing
      !P_NEW_TARGET_GROUP type RCF_TARGET_GRP
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CHANGE_ALIAS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !PS_ALIAS type BAPIALIAS
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods CHANGE_CANDIDATE_STATUS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !P_NEW_STATUS type RCF_CAND_STATUS
      !IM_V_DEREGISTER type BOOLE_D optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CHANGE_CAND_PERNR
    importing
      !P_PERNR type PERNR_D
      !P_USER type SYUNAME
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CHANGE_PASSWORD
    importing
      !P_CURRENT_PASSWORD type BAPIPWD
      !P_NEW_PASSWORD type BAPIPWD
    raising
      CX_HRRCF .
  methods CHANGE_PRIVACY_PROFILE_STATUS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !P_NEW_STATUS type RCF_CAND_STATUS
      !P_PRIVACY_STATUS type RCF_PRIVACY_STATEMENT
      !P_CHECK_ONLY type BOOLE_D optional
      !P_PRIVACY_VERSION type RCF_PRIVACY_VER optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CHANGE_VERIFICATION_STATUS
    importing
      !IS_CANDIDATE_HROBJECT type HROBJECT
      !IV_VERIFICATION_STATUS type RCF_VERIFICATION_STATUS
    exporting
      !ET_MESSAGES type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CHECK_EMAIL_EXISTENCE
    importing
      !IV_EMAIL_ADDRESS type AD_SMTPADR
    exporting
      !ET_RETURN type BAPIRETTAB
      !ES_CAND_HROBJECT type HROBJECT
    raising
      CX_HRRCF .
  class-methods CHECK_PASSWORD
    importing
      !P_CURRENT_PASSWORD type BAPIPWD
      !P_NEW_PASSWORD type BAPIPWD
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods CHECK_REL_OBJECT
    importing
      !PS_REL_OBJECT type RCF_S_REL_OBJECT
    returning
      value(REL_OBJECT_EXISTS) type BOOLE_D .
  class-methods CHECK_SUGR_EXISTENCE
    importing
      !P_SUGR type XUCLASS
    returning
      value(P_SUGR_EXISTS) type BOOLE_D .
  class-methods CHECK_USER_EXISTENCE
    importing
      !P_USER type SYUNAME optional
      !P_PERNR type PERNR_D optional
    exporting
      !PS_CAND_HROBJECT type HROBJECT
    raising
      CX_HRRCF .
  class-methods CREATE_USER
    importing
      !PS_CENTRALDATAPERSON type BAPIBUS1006_CENTRAL_PERSON
      !PS_CENTRAL_DATA type BAPIBUS1006_CENTRAL
      !P_EMAIL type AD_SMTPADR
      !P_PERNR type PERNR_D
      !P_USER type SYUNAME
      !P_PVT_EMAIL type AD_SMTPADR optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods DELETE_CANDIDATE
    importing
      !CAND_HROBJECT type HROBJECT
    exporting
      !RETURN_MESSAGE type RCF_RETURN_MESSAGE .
  class-methods DELETE_PREF_DATA_OVER
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    raising
      CX_HRRCF .
  class-methods DEQUEUE_CANDIDATE
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !IV_ENQMODE type ENQMODE default 'E'
      !IV_SCOPE type DDENQSCOPE default '2'
    preferred parameter PS_CAND_HROBJECT
    raising
      CX_HRRCF .
  methods DEREGISTER
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !RETURN_MESSAGE type RCF_RETURN_MESSAGE
    raising
      CX_HRRCF .
  class-methods CHECK_CAND_CSL_LOCK
    importing
      !IS_CAND_HROBJECT type HROBJECT
    exporting
      !EV_ALREADY_LOCKED type BOOLE_D
      !ET_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods ENQUEUE_CANDIDATE
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !IV_ENQMODE type ENQMODE default 'E'
      !IV_SCOPE type DDENQSCOPE default '2'
    returning
      value(PT_RETURN) type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods GET_CANDIDATE
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !P_USER type SYUNAME default SY-UNAME
      !P_EMPLOYEE_ID type PERNR_D optional
      !P_PARTNER type BU_PARTNER optional
      !ALIAS type BAPIALIAS optional
      !IV_ASSURE_ACTIVE_PERNR type BOOLE_D optional
    exporting
      !P_CAND_NAME type BU_NAME1TX
      !P_EMPLOYEEID type PERNR_D
      !P_EMPLOYEEID_TAB type RCF_T_PERNR
      !P_IS_EMPLOYEE type BOOLE_D
      !P_CAND_HROBJECT type HROBJECT
      !P_UNAME type SYUNAME
      !P_ALIAS type BAPIALIAS
      !P_CAND_DESCRIPTION type BU_DESCRIP
      !P_CAND_FNAME type BU_NAMEP_F
      !P_CAND_LNAME type BU_NAMEP_L
    raising
      CX_HRRCF .
  class-methods GET_CANDIDATE_APPL
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_APPL_LIST type RCF_T_APPLICATION
    raising
      CX_HRRCF .
  class-methods GET_CANDIDATE_BY_EMPLOYEE_ID
    importing
      !P_EMPLOYEE_ID type PERNR_D
    exporting
      !P_CAND_NAME type BU_NAME1TX
      !P_EMPLOYEEID type PERNR_D
      !P_IS_EMPLOYEE type BOOLE_D
      !P_CAND_HROBJECT type HROBJECT
      !P_UNAME type SYUNAME
      !P_ALIAS type BAPIALIAS
      !P_CAND_DESCRIPTION type BU_DESCRIP
    raising
      CX_HRRCF .
  class-methods GET_CANDIDATE_CLASSIFICATION
    importing
      !PS_CAND_HROBJECT type HROBJECT
      !P_LANGU type SPRAS default SY-LANGU
    exporting
      !P_CLASSIFICATION type RCF_CAND_CLASSIFICATION
      !P_CLASSIF_TXT type STEXT
    raising
      CX_HRRCF .
  class-methods GET_CANDIDATE_PROFILE
    importing
      !PS_CAND_HROBJECT type HROBJECT
    exporting
      !PT_CAND_AUDIT_TRAIL type RCF_T_CANDIDATE_AUDIT_TRAIL
    raising
      CX_HRRCF .
  methods GET_CANDIDATE_STATUS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !P_LANGU type SPRAS default SY-LANGU
    exporting
      !P_STATUS type RCF_CAND_STATUS
      !P_STATUS_TXT type DDTEXT
    raising
      CX_HRRCF .
  class-methods GET_CAND_ALIAS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !PS_ALIAS type BAPIALIAS
    raising
      CX_HRRCF .
  class-methods GET_CAND_AUDIT_TRAIL
    importing
      !PS_CAND_HROBJECT type HROBJECT
    exporting
      !PT_CAND_AUDIT_TRAIL type RCF_T_CANDIDATE_AUDIT_TRAIL
    raising
      CX_HRRCF .
  class-methods GET_CAND_EMAILID
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_EMAILDATA type RCF_S_EMAILDATA_BP
    raising
      CX_HRRCF .
  class-methods GET_CAND_FORMATTED_RESUME
    importing
      !PS_CAND_HROBJECT type HROBJECT
      !P_LANGUAGE type SYLANGU optional
    returning
      value(P_FORMATTED_RESUME) type P5134
    raising
      CX_HRRCF .
  class-methods GET_CAND_HAS_RESUME
    importing
      !IS_CAND_HROBJECT type HROBJECT
    exporting
      !EV_HAS_RESUME type BOOLE_D
      !ET_MESSAGE type BAPIRETTAB .
  class-methods GET_CAND_NOTES
    importing
      !IS_CAND_HROBJECT type HROBJECT
    exporting
      !ET_NOTES type RCF_T_CAND_NOTES
    raising
      CX_HRRCF .
  class-methods GET_CAND_RESUME_1_RECENT
    importing
      !PS_CAND_HROBJECT type HROBJECT
      !P_LANGUAGE type SYLANGU optional
    returning
      value(P_RESUME) type P5134
    raising
      CX_HRRCF .
  class-methods GET_CAND_ROLE
    importing
      !P_USER type SYUNAME
    exporting
      !P_ROLE type RCF_ROLE
    raising
      CX_HRRCF .
  class-methods GET_CAND_SETTINGS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !PS_USER_SETTINGS type BAPIDEFAUL
    raising
      CX_HRRCF .
  class-methods GET_DEL_CAND_INFO
    importing
      !P_PARTNER type BU_PARTNER optional
      !P_HROBJECT type HROBJECT optional
    exporting
      !PS_DEL_CAND_INFO type RCF_S_DEL_CAND_INFO
      !P_IS_DEREGISTERED type BOOLE_D
    raising
      CX_HRRCF .
  class-methods GET_HASNOTES_FOR_CANDIDATES
    importing
      !IT_CAND_LIST type RCF_T_HROBJECT
    exporting
      !ET_CAND_HASNOTES_LIST type RCF_T_CAND_HASNOTES .
  class-methods GET_INSTANCE
    returning
      value(P_INSTANCE) type ref to CL_HRRCF_CANDIDATE_ADMIN_BL .
  class-methods GET_LAST_LOGIN_DATE
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_DATE type SYDATUM
      !P_CR_DATE type SYDATUM
    raising
      CX_HRRCF .
  class-methods GET_PREF_DATA_OVER
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_PREF_DATA_OVER type RCF_VALUE
    raising
      CX_HRRCF .
  class-methods GET_PRIVACY_STATUS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_PRIVACY_STATUS type RCF_PRIVACY_STATEMENT
      !P_PRIVACY_VERSION type RCF_PRIVACY_VER
    raising
      CX_HRRCF .
  class-methods GET_QA_DOCUMENTS
    importing
      !IS_CAND_HROBJECT type HROBJECT
      !IV_QA_TEMPLATE_ID type RCF_QA_TPL_OBJID optional
    exporting
      !ET_DOCUMENTS type RCF_T_QA .
  class-methods GET_SETTINGS
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !PS_USER_SETTINGS type BAPIDEFAUL
    raising
      CX_HRRCF .
  methods GET_TARGET_GROUP
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !P_TARGET_GROUP type RCF_TARGET_GRP
    raising
      CX_HRRCF .
  class-methods GET_USERGROUPS
    importing
      !P_USER type SY-UNAME
    exporting
      !PT_USERGROUP type RCF_T_REL_OBJECT
    raising
      CX_HRRCF_ADDRESS_SERVICE .
  class-methods GET_USER_FROM_USERGROUP
    importing
      !PS_USERGROUP type RCF_S_REL_OBJECT
    exporting
      !PT_USER type RCF_T_REL_OBJECT .
  class-methods GET_VERIFICATION_STATUS
    importing
      !IS_CANDIDATE_HROBJECT type HROBJECT
    exporting
      !EV_VERIFICATION_STATUS type RCF_VERIFICATION_STATUS
    raising
      CX_HRRCF .
  class-methods INSERT_NOTE_FOR_CANDIDATE
    importing
      !IS_CAND_HROBJECT type HROBJECT
      !IV_NOTE type STRING
    raising
      CX_HRRCF .
  class-methods IS_CAND_OF_CURRENT_USER
    importing
      !IS_CAND type HROBJECT
    returning
      value(RV_IS_CURRENT_USER) type BOOLE_D .
  class-methods COMPARE_ROLE
    importing
      !IV_USERNAME type BAPIBNAME-BAPIBNAME
      !IV_ROLE type RCF_ROLE
    exporting
      !EV_MATCH type BOOLE_D .
  class-methods IS_DEREGISTERED
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
    returning
      value(P_IS_DEREGISTERED) type BOOLE_D
    raising
      CX_HRRCF .
  class-methods IS_PERNR_VALID
    importing
      !EMPLOYEEID type PERNR_D
    exporting
      !IS_VALID type BOOLE_D .
  class-methods MAINTAIN_CAND_ROLE
    importing
      !P_USER type SYUNAME
      !P_ROLE type RCF_ROLE
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods MAINTAIN_CAND_SETTINGS
    importing
      !PS_DEFAULTS type BAPIDEFAUL
      !PS_DEFAULTSX type BAPIDEFAX
      !PS_CAND_HROBJECT type HROBJECT optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods MAINTAIN_PREF_DATA_OVER
    importing
      !PS_CAND_HROBJECT type HROBJECT optional
      !P_PREF_DATA_OVER type RCF_VALUE
    raising
      CX_HRRCF .
  class-methods ON_CAND_ACTIVITY_CHANGED
    importing
      !IR_INFOTYPE type ref to CL_HRRCF_INFOTYPE
      !IT_BEFORE_IMAGE type WPLOG_TAB .
  class-methods ASSURE_ACTIVE_EMPLOYEE_ID
    importing
      value(IV_KEYDATE) type DATUM default SY-DATUM
      !IV_PERNR_FIELD_NAME type FIELDNAME default 'PERNR'
      !IV_EMPTY_PERNR_IF_NO_ACTIVE type BOOLE_D default ABAP_FALSE
    changing
      !CT_TAB type TABLE optional
      !CT_MESSAGES type BAPIRETTAB optional
      !CV_PERNR type PERNR_D optional .
  class-methods REGISTER
    importing
      !PS_CENTRALDATAPERSON type BAPIBUS1006_CENTRAL_PERSON optional
      !PS_CENTRALDATA type BAPIBUS1006_CENTRAL optional
      !P_EMAIL type AD_SMTPADR optional
      !P_ALIAS type BAPIALIAS optional
      !P_PRIVACY_STATUS type BOOLE_D optional
      !P_PASSWORD type BAPIPWD optional
      !P_SELF_REG type BOOLE_D default IF_HRRCF_CONSTANTS~FALSE
      !P_VERIFICATION_STATUS type RCF_VERIFICATION_STATUS default '0'
      !IV_EA_FLAG type BOOLE_D optional
      !P_PRIVACY_VERSION type RCF_PRIVACY_VER optional
    exporting
      !PT_RETURN type BAPIRETTAB
      !P_GENERATED_PASSWORD type BAPIPWD
      !PO_CANDIDATE type ref to CL_HRRCF_CANDIDATE
    raising
      CX_HRRCF .
  class-methods REGISTER_APPLICANT
    importing
      !P_LASTNAME type AD_NAMELAS
      !P_FIRSTNAME type AD_NAMEFIR optional
      !P_MIDDLENAME type AD_NAMEMID optional
      !P_EMAIL type AD_SMTPADR
      !P_PRIVACY_STATUS type RCF_PRIVACY_STATEMENT optional
      !P_ALIAS type BAPIALIAS optional
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods SEND_NEW_VERIFICATION_MAIL
    importing
      !IV_CAND_HROBJECT type HROBJECT
      !IV_APPL_EXISTS type BOOLE_D
    exporting
      !ET_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods GET_CAND_NAME
    importing
      !PT_CANDIDATES type RCF_T_HROBJECT
    exporting
      !PT_CAND_INFO type RCF_T_ESA_CAND_BASIC_DATA .
  class-methods SEND_PASSWORD_VIA_EMAIL
    importing
      !P_USE_LONG_USER_NAME type STRING
      !P_USER_NAME type STRING
      !P_EMAIL_ADDRESS type STRING
    exporting
      !PT_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods SWITCH_USER
    importing
      !P_ALIAS type BAPIALIAS
      !P_PASSWORD type BAPIPWD
    raising
      CX_HRRCF .
  class-methods CHECK_CAND_ENQUEUE
    importing
      !IS_CAND_HROBJECT type HROBJECT
    exporting
      !EV_LOCK_COUNTER type I
      !EV_USER type SY-UNAME
      !ET_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods GET_PICTURE_URL
    importing
      !IS_CAND_HROBJECT type HROBJECT
    exporting
      !EV_PICTURE_URL type SAEURI .
  class-methods SET_CAND_ID_TO_MEMORY
    importing
      !IT_CAND_OBJID type HRBAS_HROBJID_TABLE
    exporting
      !EV_MEM_ID type TEXT10 .
  class-methods GET_USER_FULLNAME
    importing
      !PT_REC_TEAM type RCF_T_REC_TEAM
      !P_LANGU type SPRAS optional
    exporting
      !PT_REC_TEAM_TXT type RCF_T_REC_TEAM_TXT .
  class-methods SET_SWITCH_ASSURE_ACTIVE_PERNR
    importing
      !IV_TOGGLE type BOOLE_D default ABAP_FALSE .
  class-methods GET_CAND_PVT_EMAIL
    importing
      !IM_S_HROBJECT type HROBJECT
    exporting
      !EX_S_EMAILDATA type RCF_S_EMAILDATA_BP
    raising
      CX_HRRCF .
  class-methods CHECK_BUPA_AUTH
    importing
      !PT_CANDIDATES type RCF_T_HROBJECT
      !P_ONLY_BLOCKED type BOOLE_D optional
    exporting
      !PT_EXCL_CANDIDATES type RCF_T_HROBJECT .
protected section.
*"* protected components of class CL_HRRCF_CANDIDATE_ADMIN_BL
*"* do not include other source files here!!!
private section.

*"* private components of class CL_HRRCF_CANDIDATE_ADMIN_BL
*"* do not include other source files here!!!
  aliases DELETE
    for IF_HRRCF_CONSTANTS~DELETE_OPERATION .
  aliases FALSE
    for IF_HRRCF_CONSTANTS~FALSE .
  aliases HIGH_DATE
    for IF_HRRCF_CONSTANTS~HIGH_DATE .
  aliases INSERT
    for IF_HRRCF_CONSTANTS~INSERT_OPERATION .
  aliases LOW_DATE
    for IF_HRRCF_CONSTANTS~LOW_DATE .
  aliases MODIFY
    for IF_HRRCF_CONSTANTS~MODIFY_OPERATION .
  aliases MSGCL_ADMIN
    for IF_HRRCF_CONSTANTS~MSGCL_ADMIN .
  aliases MSGCL_USER
    for IF_HRRCF_CONSTANTS~MSGCL_USER .
  aliases TRUE
    for IF_HRRCF_CONSTANTS~TRUE .

  class-data MY_INSTANCE type ref to CL_HRRCF_CANDIDATE_ADMIN_BL .

  class-methods CHECK_USER_TYPE
    importing
      !P_USER_NAME type USR02-BNAME
    exporting
      !PS_RETURN type BAPIRET2 .
ENDCLASS.



CLASS CL_HRRCF_CANDIDATE_ADMIN_BL IMPLEMENTATION.


method ASSIGN_TARGET_GROUP .
*
* Author: AS
*
* This method assigns a target group ro a candidate.
*
  data ls_ci type p5102.
  data lt_ci type table of p5102.
  data lo_exception type ref to cx_hrrcf.
  data lo_candidate type ref to cl_hrrcf_candidate.
  data lo_ci type ref to cl_hrrcf_candidate_info.
*
  clear: pt_return. refresh pt_return.
*
  try.
*
* get candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
      else.
        call method cl_hrrcf_candidate=>get
          exporting
            user      = sy-uname
          importing
            candidate = lo_candidate.
      endif.
*
* get candidate info
      call method cl_hrrcf_candidate_info=>get_instance
        exporting
          hrobject = lo_candidate->hrobject
        importing
          instance = lo_ci.
*
* get current record
      call method lo_ci->get_records_by_date
        exporting
          date             = sy-datum
        importing
          infotype_records = lt_ci.
*
      read table lt_ci into ls_ci index 1.
*
* change target group
        move p_new_target_group to ls_ci-tgroup.
        move sy-datum to ls_ci-begda.

        call method lo_ci->insert_record
          importing
            return          = pt_return
          changing
            infotype_record = ls_ci.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


METHOD assure_active_employee_id .
  "WG/N2202046
  DATA lo_ex TYPE REF TO cx_hrrcf.
  DATA lv_msg_string    TYPE string.
  DATA ls_msg LIKE LINE OF ct_messages.
  DATA lt_pernr TYPE TABLE OF pernr_d.

  FIELD-SYMBOLS <line> TYPE ANY.
  FIELD-SYMBOLS <pernr> TYPE pernr_d.

  IF NOT cv_pernr IS INITIAL.
    INSERT cv_pernr INTO TABLE lt_pernr.
    assure_active_employee_id(
     EXPORTING
       iv_keydate            = iv_keydate
       iv_empty_pernr_if_no_active = iv_empty_pernr_if_no_active
       iv_pernr_field_name = space
     CHANGING
       ct_tab              = lt_pernr
       ct_messages         = ct_messages ).
    READ TABLE lt_pernr INDEX 1 INTO cv_pernr.
  ENDIF.

  LOOP AT ct_tab ASSIGNING <line>.
    IF iv_pernr_field_name IS INITIAL.
      ASSIGN <line> TO <pernr>.
    ELSE.
      ASSIGN COMPONENT iv_pernr_field_name OF STRUCTURE <line> TO <pernr>.
    ENDIF.

    TRY.
        get_cand_employee_ids(
           EXPORTING
            IV_EMPTY_PERNR_IF_NO_ACTIVE  = IV_EMPTY_PERNR_IF_NO_ACTIVE
            iv_employee_id               = <pernr>
            iv_keydate                   = iv_keydate
           IMPORTING
            ev_latest_active_employee_id = <pernr> ).

      CATCH cx_hrrcf INTO lo_ex.
        CLEAR <pernr>.
        cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
        MESSAGE e001(hrrcf0005) INTO lv_msg_string.
        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = sy-msgty
            cl     = sy-msgid
            number = sy-msgno
          IMPORTING
            return = ls_msg.
        APPEND ls_msg TO ct_messages.
    ENDTRY.
  ENDLOOP.

ENDMETHOD.


METHOD change_alias.

*This method allows an external candidate to change their alias.

  CONSTANTS lv_aliasx TYPE bapialiasx VALUE 'X'.

  DATA: lt_return     TYPE bapirettab,
        lo_ex         TYPE REF TO cx_hrrcf,
        lv_user       TYPE syuname,
        lo_candidate  TYPE REF TO cl_hrrcf_candidate,
        par1          LIKE sy-msgv1,
        ls_return     TYPE bapiret2,
        ls_user_logon TYPE uslogond,
        ls_bapi_logon TYPE bapilogond,
        lv_bname      TYPE bapibname-bapibname,
        ls_hrobject   TYPE hrobject,
        ls_p5102      TYPE p5102,
        lt_cand       TYPE TABLE OF p5102,
        ls_cand       TYPE p5102,
        lo_cand_information  TYPE REF TO cl_hrrcf_candidate_info,
        lv_tz TYPE ttzz-tzone,
        lv_current_timestamp TYPE timestamp,
        lv_attempts TYPE rcf_no_attempts,
        lv_current_date        TYPE d,
        lv_current_time        TYPE t,
        lv_last_attempt_date   TYPE d,
        lv_last_attempt_time   TYPE t.

  lv_tz = sy-zonlo.
  GET TIME STAMP FIELD lv_current_timestamp.

  IF ps_cand_hrobject IS SUPPLIED.
    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
    ls_hrobject = ps_cand_hrobject.
  ELSE.
    lv_user = sy-uname.
    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        user        = sy-uname
      IMPORTING
        candidate = lo_candidate.
    ls_hrobject = lo_candidate->hrobject.
  ENDIF.

  CHECK ls_hrobject IS NOT INITIAL.
  SELECT SINGLE * from hrp5102 INTO CORRESPONDING FIELDS OF ls_p5102 WHERE plvar = ls_hrobject-plvar AND
                                                     otype = ls_hrobject-otype AND
                                                     objid = ls_hrobject-objid AND
                                                     begda <= sy-datum AND
                                                     endda >= sy-datum.
  IF sy-subrc <> 0.
    RETURN.
  ENDIF.
  lv_attempts = ls_p5102-attempts.
  CONVERT TIME STAMP ls_p5102-attempted_on TIME ZONE lv_tz INTO DATE lv_last_attempt_date TIME lv_last_attempt_time.
IF lv_last_attempt_date < sy-datum.
   CALL FUNCTION 'SUSR_USER_BNAME_FROM_ALIAS'
     EXPORTING
       alias          = ps_alias
     EXCEPTIONS
       no_bname_found = 1
       OTHERS         = 2.
    IF sy-subrc EQ 0.
      par1 = ps_alias-useralias.
      IF 1 EQ 0.
       MESSAGE e012(hrrcf0002) WITH par1.
*       The alias & is already in use. Please try again with a new alias.
      ENDIF.

      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = 012
          par1   = par1
        IMPORTING
          return = ls_return.
      APPEND ls_return TO pt_return.
      lv_attempts = 1.
      CALL METHOD cl_hrrcf_candidate_info=>get_instance
        EXPORTING
          hrobject = ls_hrobject
        IMPORTING
          instance = lo_cand_information.
      lo_cand_information->get_records_by_date(
        exporting
          date             = sy-datum
        importing
          infotype_records = lt_cand ).

      read table lt_cand index 1 into ls_cand.

      if sy-subrc is not initial.

        par1 = ls_hrobject.

        if 1 = 2.
          message e073(hrrcf0001) with par1.
        endif.

        raise exception type cx_hrrcf
          exporting
            message_type   = 'E'
            message_class  = 'HRRCF0001'
            message_number = 073
            message_par1   = par1.

      endif.

      ls_cand-attempts = lv_attempts.
      ls_cand-attempted_on = lv_current_timestamp.

      lo_cand_information->update_record(
        importing
          return          = lt_return
        changing
          infotype_record = ls_cand ).

      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO pt_return.
      ENDIF.
     ELSE.
*change alias

      CALL FUNCTION 'SUSR_USER_LOGONDATA_GET'
        EXPORTING
          user_name      = lv_user
        IMPORTING
          user_logondata = ls_user_logon.

      MOVE-CORRESPONDING ls_user_logon TO ls_bapi_logon.

      CALL FUNCTION 'SUSR_BAPI_USER_CHANGE'
        EXPORTING
          username  = lv_user
          logondata = ls_bapi_logon
          no_checks = 'X'
          alias     = ps_alias
          aliasx    = lv_aliasx
        TABLES
          return    = lt_return.

      "  delete errors of type E and A
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        TRY.
            IF 1 = 0.
              MESSAGE e121(hrrcf0001) WITH 'CL_HRRCF_CANDIDATE_ADMIN_BL'
                                  'CHANGE_ALIAS'.
            ENDIF.

      "  An error occurred while changing data
            RAISE EXCEPTION TYPE cx_hrrcf_personalization
              EXPORTING
                textid         = cx_hrrcf_personalization=>cx_per_set_data
                message_type   = 'E'
                message_class  = 'HRRCF0001'
                message_number = '121'
                message_par1   = 'CL_HRRCF_CANDIDATE_ADMIN_BL'
                message_par2   = 'CHANGE_ALIAS'.

          CATCH cx_hrrcf_personalization INTO lo_ex.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_ex.
            RAISE EXCEPTION TYPE cx_hrrcf .

        ENDTRY.
       ENDIF.
      ENDIF.
ELSE.
   "only possible value should be equal to sy-datum
    CHECK lv_last_attempt_date = sy-datum.
  IF lv_attempts < 3.
   CALL FUNCTION 'SUSR_USER_BNAME_FROM_ALIAS'
     EXPORTING
       alias          = ps_alias
     EXCEPTIONS
       no_bname_found = 1
       OTHERS         = 2.
    IF sy-subrc EQ 0.
      par1 = ps_alias-useralias.
      IF 1 EQ 0.
       MESSAGE e012(hrrcf0002) WITH par1.
*       The alias & is already in use. Please try again with a new alias.
      ENDIF.

      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = 012
          par1   = par1
        IMPORTING
          return = ls_return.
      APPEND ls_return TO pt_return.
      lv_attempts = lv_attempts + 1.
      CALL METHOD cl_hrrcf_candidate_info=>get_instance
        EXPORTING
          hrobject = ls_hrobject
        IMPORTING
          instance = lo_cand_information.
      lo_cand_information->get_records_by_date(
        exporting
          date             = sy-datum
        importing
          infotype_records = lt_cand ).

      read table lt_cand index 1 into ls_cand.

      if sy-subrc is not initial.

        par1 = ls_hrobject.

        if 1 = 2.
          message e073(hrrcf0001) with par1.
        endif.

        raise exception type cx_hrrcf
          exporting
            message_type   = 'E'
            message_class  = 'HRRCF0001'
            message_number = 073
            message_par1   = par1.

      endif.

      ls_cand-attempts = lv_attempts.
      ls_cand-attempted_on = lv_current_timestamp.

      lo_cand_information->update_record(
        importing
          return          = lt_return
        changing
          infotype_record = ls_cand ).

      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO pt_return.
      ENDIF.
     ELSE.
*change alias

      CALL FUNCTION 'SUSR_USER_LOGONDATA_GET'
        EXPORTING
          user_name      = lv_user
        IMPORTING
          user_logondata = ls_user_logon.

      MOVE-CORRESPONDING ls_user_logon TO ls_bapi_logon.

      CALL FUNCTION 'SUSR_BAPI_USER_CHANGE'
        EXPORTING
          username  = lv_user
          logondata = ls_bapi_logon
          no_checks = 'X'
          alias     = ps_alias
          aliasx    = lv_aliasx
        TABLES
          return    = lt_return.

      "  delete errors of type E and A
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        TRY.
            IF 1 = 0.
              MESSAGE e121(hrrcf0001) WITH 'CL_HRRCF_CANDIDATE_ADMIN_BL'
                                  'CHANGE_ALIAS'.
            ENDIF.

      "  An error occurred while changing data
            RAISE EXCEPTION TYPE cx_hrrcf_personalization
              EXPORTING
                textid         = cx_hrrcf_personalization=>cx_per_set_data
                message_type   = 'E'
                message_class  = 'HRRCF0001'
                message_number = '121'
                message_par1   = 'CL_HRRCF_CANDIDATE_ADMIN_BL'
                message_par2   = 'CHANGE_ALIAS'.

          CATCH cx_hrrcf_personalization INTO lo_ex.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_ex.
            RAISE EXCEPTION TYPE cx_hrrcf .

        ENDTRY.
       ENDIF.
      ENDIF.

   ELSEIF lv_attempts >= 3.
      IF 1 = 0.
        MESSAGE e012(hrrcf0002) WITH par1.
      ENDIF.
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = '333'
          par1   = par1
        IMPORTING
          return = ls_return.
      APPEND ls_return TO pt_return.

   ENDIF.

ENDIF.

ENDMETHOD.


method change_candidate_status .
*
* Author: SGS
* Additions: AS
*
* This method changes the status of the candidate.
*
  data lo_ci type ref to cl_hrrcf_candidate_info.
  data lo_exception type ref to cx_hrrcf.
  data lo_candidate type ref to cl_hrrcf_candidate.
*
  clear: pt_return. refresh pt_return.
*
  try.
*
* get candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
      else.
        call method cl_hrrcf_candidate=>get
          exporting
            user      = sy-uname
          importing
            candidate = lo_candidate.
      endif.
*
* get candidate info
      call method cl_hrrcf_candidate_info=>get_instance
        exporting
          hrobject = lo_candidate->hrobject
        importing
          instance = lo_ci.
*
* change status
      call method lo_ci->change_status
        exporting
          p_new_status = p_new_status
          im_v_deregister = im_v_deregister
        importing
          pt_return    = pt_return.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


METHOD change_cand_pernr .
*Author:BM
*This method delimits the present employe id and assigns a new employee
*id to the candidate

  DATA: lo_candidate TYPE REF TO cl_hrrcf_candidate,
*        lo_cand TYPE REF TO cl_hrrcf_candidate,
        lo_exception TYPE REF TO cx_hrrcf,
        lv_exists TYPE boole_d,
        lv_par LIKE sy-msgv1,
        ls_return TYPE bapiret2,
        ls_cand_hrobject TYPE hrobject.

  TRY.

*get candidate object

      CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user        = p_user
          IMPORTING
            candidate = lo_candidate.


      CALL METHOD cl_hrrcf_candidate_admin_bl=>check_user_existence
        EXPORTING
          p_pernr          = p_pernr
        IMPORTING
          ps_cand_hrobject = ls_cand_hrobject.
      .

      CHECK NOT lo_candidate IS INITIAL.

*check if pernr exists
      IF NOT ls_cand_hrobject IS  INITIAL.

*pernr exists.check if pernr is not same as the user pernr
        IF NOT ( lo_candidate->employeeid EQ p_pernr ).

*Error:pernr assigned to another candidate

          lv_par = p_pernr.
          CALL FUNCTION 'BALW_BAPIRETURN_GET2'     "create user message
         EXPORTING
           type   = 'E'
           cl     = 'HRRCF0002'
           number = 076
           par1 = lv_par
         IMPORTING
           return = ls_return
         EXCEPTIONS
           OTHERS = 2.
          APPEND ls_return TO pt_return.
          RETURN.
        ENDIF.


      ELSE.

*delimit employee

        CALL METHOD lo_candidate->delimit_employee
          IMPORTING
            return = pt_return.

        CHECK pt_return IS INITIAL.
*assign new employee
        CALL METHOD lo_candidate->assign_employee
          EXPORTING
            employeeid = p_pernr.
      ENDIF.

    CATCH cx_hrrcf_infotype_operation INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf
      .

  ENDTRY.


ENDMETHOD.


method change_password .
*
* Additions: AS
*
* This method changes the password of the current user
* The method should be used only in combination with
* method CHECK_PASSWORD to achive a proper error handling
  data lo_exception       type ref to cx_hrrcf.
  data l_current_password type xubcode.
  data l_new_password     type xubcode.
*
  move p_new_password to l_new_password.
  move p_current_password to l_current_password.
*
  call function 'SUSR_USER_CHANGE_PASSWORD_RFC'
    exporting
      bname                = sy-uname
      password             = l_current_password
      new_password         = l_new_password
    exceptions
      change_not_allowed   = 1
      password_not_allowed = 2
      internal_error       = 3
      canceled_by_user     = 4
      others               = 5.
*
  if sy-subrc <> 0.
    try.
      if 1 = 0.
        message e157(hrrcf0001).
*   Fehler während der Passwortänderung
      endif.
      raise exception type cx_hrrcf_registration
        exporting
          textid = cx_hrrcf_registration=>password_change
          message_type   = 'E'
          message_class  = 'HRRCF0001'
          message_number = '157'
          .
      catch cx_hrrcf into lo_exception.
        call method cl_hrrcf_exception_handler=>write_exception_log
          exporting
            ex = lo_exception.
        raise exception type cx_hrrcf.
    endtry.
  endif.
*
  CALL FUNCTION 'SUSR_USER_BUFFERS_CLEAR'.
*
endmethod.


method change_privacy_profile_status .
*
* Author: CS
* Additions: AS, PEV
*
* This method changes the status of the profile and the privacy status.
*
  data lo_ci type ref to cl_hrrcf_candidate_info.
  data lo_exception type ref to cx_hrrcf.
  data lo_candidate type ref to cl_hrrcf_candidate.
  data is_available type boole_d.
  data lv_privacy_status type rcf_privacy_statement.

  data: lo_cand_info type ref to cl_hrrcf_candidate_info.

*
  clear: pt_return. refresh pt_return.
*
* only if privacy status is flaged and new status is released maintain
* both (profile status and privacy status)

  check p_privacy_status is not initial.

  try.
* get candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
      else.
        call method cl_hrrcf_candidate=>get
          exporting
            user      = sy-uname
          importing
            candidate = lo_candidate.
      endif.

* check if something is stored in HRP5102
      call method cl_hrrcf_candidate_admin_bl=>get_privacy_status
        exporting
          ps_cand_hrobject = lo_candidate->hrobject
        importing
          p_privacy_status = lv_privacy_status.

      if lv_privacy_status is not initial.
        is_available = true.
      else.
        is_available = false.
      endif.
*****

* get candidate info
      call method cl_hrrcf_candidate_info=>get_instance
        exporting
          hrobject = lo_candidate->hrobject
        importing
          instance = lo_ci.
*
*     IF NOT p_new_status IS INITIAL.
* change profile status
      call method lo_ci->change_status
        exporting
          p_new_status = p_new_status
          check_only   = p_check_only
        importing
          pt_return    = pt_return.
*     ENDIF.
*
* if flag was set not necessary to save it again
      if is_available eq false or p_privacy_version IS NOT INITIAL .
* set privacy status
        call method lo_ci->set_privacy_status
          exporting
            p_privacy_status = p_privacy_status
            p_privacy_version = p_privacy_version
            check_only       = p_check_only
          importing
            pt_return        = pt_return.
      endif.

*     if SWITCH is turned on update the HRP5102's Last_updated_by and Last_updated_on fields
      if ( pt_return is initial ) and
         ( cl_hrrcf_switch_check=>hrerc_sfws_ui_ses_01( ) eq abap_true ).

        call method cl_hrrcf_candidate_info=>get_instance
          exporting
            hrobject = ps_cand_hrobject
          importing
            instance = lo_cand_info.

        call method lo_cand_info->update_of_profile
          exporting
            check_only = p_check_only
          importing
            return     = pt_return.

      endif.

*   exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.

endmethod.


method change_verification_status.

  data: lo_cand_info type ref to cl_hrrcf_candidate_info,
        lt_cand      type table of p5102,
        ls_cand      type p5102,
        lv_msg_par1  type symsgv.

  clear: et_messages.

  cl_hrrcf_candidate_info=>get_instance(
    exporting
      hrobject = is_candidate_hrobject
    importing
      instance = lo_cand_info ).

  lo_cand_info->get_records_by_date(
    exporting
      date             = sy-datum
    importing
      infotype_records = lt_cand ).

  read table lt_cand index 1 into ls_cand.

  if sy-subrc is not initial.

    lv_msg_par1 = is_candidate_hrobject.

    if 1 = 2.
      message e073(hrrcf0001) with lv_msg_par1.
    endif.

    raise exception type cx_hrrcf
      exporting
        message_type   = 'E'
        message_class  = 'HRRCF0001'
        message_number = 073
        message_par1   = lv_msg_par1.

  endif.

  ls_cand-verification = iv_verification_status.

  lo_cand_info->update_record(
    importing
      return          = et_messages
    changing
      infotype_record = ls_cand ).

endmethod.


METHOD check_bupa_auth.

* Data declaration
  TYPES : BEGIN OF t_na,
           otjid TYPE otjid,
          END OF t_na.

  TYPES : BEGIN OF t_na_cp,
           otjid TYPE otjid,
           varyf TYPE varyf,
           objid TYPE hrobjid,
          END OF t_na_cp.

  TYPES : BEGIN OF t_cp_bp,
         otjid TYPE otjid,
         objid TYPE hrobjid,
         sobid TYPE sobid,
        END OF t_cp_bp.

  TYPES : BEGIN OF t_bupa,
           cp     TYPE hrobjid,
           partner TYPE bu_partner,
        END OF t_bupa.

  DATA: lt_na TYPE STANDARD TABLE OF t_na,
        lt_na_cp     TYPE STANDARD TABLE OF t_na_cp,
        lt_cp_bp     TYPE STANDARD TABLE OF t_cp_bp,
        lt_bupa      TYPE STANDARD TABLE OF   t_bupa,
        lt_partners TYPE bu_partner_t,
        lt_partners_excl TYPE bu_partner_t.

  DATA : ls_hrobject TYPE hrobject,
         ls_na    TYPE t_na,
         ls_bupa  TYPE t_bupa,
         ls_cp_bp TYPE t_cp_bp,
         ls_na_cp TYPE t_na_cp,
         ls_return  TYPE bapiret2.


  DATA : lv_plvar TYPE plvar,
         lv_indx       TYPE i.

  DATA : lt_bup_xt TYPE BUP_XPCPT_T,
         ls_bup_xt TYPE BUP_S_XPCPT.


  LOOP AT pt_candidates INTO ls_hrobject.

    CONCATENATE 'NA' ls_hrobject-objid INTO ls_na.
    APPEND ls_na TO lt_na.

  ENDLOOP.

  IF ls_hrobject-plvar is INITIAL.
    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
     IMPORTING
       ACT_PLVAR               = lv_plvar
     EXCEPTIONS
       NO_ACTIVE_PLVAR         = 1
       OTHERS                  = 2.
  ELSE.
    lv_plvar = ls_hrobject-plvar.
  ENDIF.

* Fetch Central person using candidate objects
  SELECT objid
         otjid
         varyf
         FROM hrp1001
         INTO CORRESPONDING FIELDS OF TABLE lt_na_cp
         FOR ALL ENTRIES IN lt_na
         WHERE plvar = lv_plvar AND
               otjid = lt_na-otjid AND
               subty = 'A650' AND
               endda GE sy-datum.


* Fetch Business partners using Central person
  SELECT objid
         otjid
         sobid
         FROM hrp1001
         INTO CORRESPONDING FIELDS OF TABLE lt_cp_bp
         FOR ALL ENTRIES IN lt_na_cp
         WHERE plvar = lv_plvar AND
               otjid = lt_na_cp-varyf AND
               subty = 'B207' AND
               endda GE sy-datum.

  LOOP AT lt_cp_bp INTO ls_cp_bp.
    ls_bupa-cp      = ls_cp_bp-objid.
    ls_bupa-partner = ls_cp_bp-sobid.
    APPEND ls_bupa TO lt_bupa.
    APPEND ls_bupa-partner TO lt_partners.
  ENDLOOP.

  DELETE ADJACENT DUPLICATES FROM lt_bupa COMPARING ALL FIELDS.


  IF p_only_blocked EQ abap_true.
    CALL FUNCTION 'BUPA_XPCPT_GET'
     EXPORTING
       IT_PARTNER            = lt_partners
       IV_ONLY_BLOCKED       = 'X'
     IMPORTING
       ET_XPCPT              = lt_bup_xt.

    LOOP AT lt_bupa INTO ls_bupa.
    lv_indx = sy-tabix.
    READ TABLE lt_bup_xt WITH KEY partner = ls_bupa-partner
                               TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      ls_cp_bp-sobid = ls_bupa-partner.
      READ TABLE lt_cp_bp INTO ls_cp_bp WITH KEY sobid = ls_cp_bp-sobid.
      IF sy-subrc EQ 0.
        READ TABLE lt_na_cp INTO ls_na_cp WITH KEY varyf = ls_cp_bp-otjid.
        IF sy-subrc EQ 0.
          ls_hrobject-plvar = lv_plvar.
          ls_hrobject-otype = 'NA'.
          ls_hrobject-objid = ls_na_cp-objid.

          APPEND ls_hrobject TO pt_excl_candidates.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

  ELSE.
   CALL FUNCTION 'BUPA_DP_AUTHCHECK_MASS'
    EXPORTING
      it_partner  = lt_partners
    IMPORTING
      et_partners = lt_partners_excl
      ev_return   = ls_return.

  LOOP AT lt_bupa INTO ls_bupa.
    lv_indx = sy-tabix.
    READ TABLE lt_partners_excl WITH KEY partner = ls_bupa-partner
                               TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      ls_cp_bp-sobid = ls_bupa-partner.
      READ TABLE lt_cp_bp INTO ls_cp_bp WITH KEY sobid = ls_cp_bp-sobid.
      IF sy-subrc EQ 0.
        READ TABLE lt_na_cp INTO ls_na_cp WITH KEY varyf = ls_cp_bp-otjid.
        IF sy-subrc EQ 0.
          ls_hrobject-plvar = lv_plvar.
          ls_hrobject-otype = 'NA'.
          ls_hrobject-objid = ls_na_cp-objid.

          APPEND ls_hrobject TO pt_excl_candidates.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
  ENDIF.



ENDMETHOD.


METHOD check_cand_csl_lock.

  DATA: lv_plogsys         TYPE csl_de-eols,
        lv_enqueueargument TYPE csl_de-eoargs,
        ls_return          TYPE bapiret2,
        ls_msgtext         TYPE natxt.

  DATA: lo_exception              TYPE REF TO cx_hrrcf.


  CLEAR et_return.

  CONCATENATE sy-mandt is_cand_hrobject INTO lv_enqueueargument.

  CALL FUNCTION 'CSLEO_ENQUEUE'
    EXPORTING
      plogsys           = lv_plogsys
      pddicenqobj       = 'EHPLOGIE'
      penqueueargstring = lv_enqueueargument
*     PMONINFO          = ' '
      pactivation       = 'LCT'
      pscope            = '1'
*     PWAIT             = ' '
*     PCOLLECT          = ' '
*     PEOCOLS           = ' '
*     PEOCOUS           = ' '
    EXCEPTIONS
      foreign_lock      = 1
      no_connection     = 2
      inconsistency     = 3
      OTHERS            = 4.

  IF sy-subrc = 1.
    ev_already_locked = true.

    MESSAGE e001(hrrcf0002)
WITH 'NA' is_cand_hrobject-objid INTO ls_msgtext.

    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = sy-msgty
        cl     = sy-msgid
        number = sy-msgno
        par1   = sy-msgv1
        par2   = sy-msgv2
      IMPORTING
        return = ls_return.
    APPEND ls_return TO et_return.
    RETURN.
  ELSEIF sy-subrc IS NOT INITIAL.
    TRY.
        RAISE EXCEPTION TYPE cx_hrrcf_csl
          EXPORTING
            hrobject = is_cand_hrobject.

      CATCH cx_hrrcf_csl INTO lo_exception.
        cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).
        RAISE EXCEPTION TYPE cx_hrrcf.
    ENDTRY.
  ELSE.
* Dequeue again
    CALL FUNCTION 'CSLEO_DEQUEUE'
      EXPORTING
        plogsys           = lv_plogsys
        pddicenqobj       = 'EHPLOGIE'
        penqueueargstring = lv_enqueueargument
*       PMONINFO          = ' '
*       PACTIVATION       = ' '
*       PSCOPE            =
*       PSYNCHRON         = ' '
      EXCEPTIONS
        no_lock           = 1
        inconsistency     = 2
        OTHERS            = 3.

    IF sy-subrc <> 0.
      TRY.
          RAISE EXCEPTION TYPE cx_hrrcf_csl
            EXPORTING
              hrobject = is_cand_hrobject.

        CATCH cx_hrrcf_csl INTO lo_exception.
          cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).
          RAISE EXCEPTION TYPE cx_hrrcf.
      ENDTRY.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD check_cand_enqueue.

* Author: PEV
* This method checks the candidate lock.

  DATA: lo_ex        TYPE REF TO cx_hrrcf,
        lo_candidate TYPE REF TO cl_hrrcf_candidate.

  DATA: ls_return    TYPE bapiret2.


  TRY.
      IF is_cand_hrobject IS NOT INITIAL.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = is_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.

      CALL METHOD lo_candidate->enqueue
        EXPORTING
          iv_enqmode = 'V'
          iv_scope   = '1'
        IMPORTING
          ev_counter = ev_lock_counter
          return     = et_return.

      IF et_return IS NOT INITIAL.
        READ TABLE et_return INTO ls_return WITH KEY type = 'E'.
        ev_user = ls_return-message_v3.
      ELSE.
        ev_user = sy-uname.
      ENDIF.

* exception handling
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid   = cx_hrrcf_maintain_object=>enqueue_failed
          hrobject = is_cand_hrobject.
  ENDTRY.

ENDMETHOD.


method check_email_existence.

* NOTE: This message is only relevant to check the e-mail address of an external candidate.

  data: lo_ex                           type ref to cx_hrrcf,
        lo_cand                         type ref to cl_hrrcf_candidate,
        lt_bupa                         type rcf_t_bu_partner,
        ls_return                       type bapiret2,
        lv_bupa                         type bu_partner,
        lv_alias                        type bapialias,
        lv_number                       type i,
        lv_message                      type string.

  try.

      clear: et_return,
             es_cand_hrobject.

      lt_bupa = cl_hrrcf_address_service=>get_bupa_by_email( iv_email_address ).

      describe table lt_bupa lines lv_number.

*     the e-mail address does not exist, so raise a message
      if lv_number eq 0.

        message e172(hrrcf0002) into lv_message.
*       Die angegebene E-Mail-Adresse ist uns nicht bekannt

        call function 'BALW_BAPIRETURN_GET2'
          exporting
            type   = 'E'
            cl     = 'HRRCF0002'
            number = '172'
          importing
            return = ls_return.
        append ls_return to et_return.

*     the e-mail address is unique, so do further checks
      elseif lv_number eq 1.

        read table lt_bupa into lv_bupa index 1.

        cl_hrrcf_candidate=>get(
          exporting
            partner   = lv_bupa
          importing
            candidate = lo_cand ).

*       there is no candidate linked with the e-mail address, so raise a message
        if lo_cand is initial.

          message e174(hrrcf0002) into lv_message.
*         Zu der angegebenen E-Mail-Adresse gibt es keinen Benutzer

          call function 'BALW_BAPIRETURN_GET2'
            exporting
              type   = 'E'
              cl     = 'HRRCF0002'
              number = '174'
            importing
              return = ls_return.
          append ls_return to et_return.

*       there is a candidate, but check if it is linked with an alias
        else.

          lo_cand->get_cand_alias(
            receiving
              ps_alias = lv_alias ).

*         there is no alias, so raise a message
          if lv_alias is initial.

            message e174(hrrcf0002) into lv_message.
*           Zu der angegebenen E-Mail-Adresse gibt es keinen Benutzer

            call function 'BALW_BAPIRETURN_GET2'
              exporting
                type   = 'E'
                cl     = 'HRRCF0002'
                number = '174'
              importing
                return = ls_return.
            append ls_return to et_return.

*         everything is fine, so return the candidate's HR object
          else.

            es_cand_hrobject = lo_cand->hrobject.

          endif.

        endif.

*     the e-mail address is not unique, so raise a message
      else.

        message e173(hrrcf0002) into lv_message.
*       Die angegebene E-Mail-Adresse ist nicht eindeutig

        call function 'BALW_BAPIRETURN_GET2'
          exporting
            type   = 'E'
            cl     = 'HRRCF0002'
            number = '173'
          importing
            return = ls_return.
        append ls_return to et_return.

      endif.

*   raise exception only if the caught exception is not related to a not existing person
    catch cx_hrrcf into lo_ex .
      if lo_ex->textid ne cx_hrrcf_maintain_object=>central_person_not_exist.
        cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
        raise exception type cx_hrrcf.
      endif.
  endtry.

endmethod.


METHOD check_password .
*
* Author Bilash Biswas 20020827
* Additions: AS
*
* This method checks if the password the user has selected meets the formal check requirements and also if the two
* passwords are identical.
*
  DATA: rc                    LIKE sy-subrc.
  DATA: msgid                 LIKE sy-msgid.
  DATA: msgno                 LIKE sy-msgno.
  DATA:
    lv_msgv1                  TYPE symsgv,
    lv_msgv2                  TYPE symsgv,
    lv_msgv3                  TYPE symsgv,
    lv_msgv4                  TYPE symsgv.
  DATA: ls_return             TYPE bapiret2.
  DATA: lo_exception          TYPE REF TO cx_hrrcf.
*
* does new password differ from current
  IF p_current_password <> p_new_password.
    IF 1 EQ 0.
      MESSAGE e013(hrrcf0002).
    ENDIF.
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'E'
        cl     = 'HRRCF0002'
        number = 013
      IMPORTING
        return = ls_return.
    APPEND ls_return TO pt_return.
    RETURN.
  ENDIF.
*
* formal check
  CALL FUNCTION 'PASSWORD_FORMAL_CHECK'
    EXPORTING
      password       = p_new_password
    IMPORTING
      rc             = rc
      msgid          = msgid
      msgno          = msgno
      msgv1          = lv_msgv1
      msgv2          = lv_msgv2
      msgv3          = lv_msgv3
      msgv4          = lv_msgv4
    EXCEPTIONS
      internal_error = 1
      OTHERS         = 2.
*
  IF sy-subrc <> 0.
    TRY.
        RAISE EXCEPTION TYPE cx_hrrcf_registration
        EXPORTING
          textid = cx_hrrcf_registration=>password_change
          message_type   = 'E'
          message_class  = 'HRRCF0001'
          message_number = '121'
          message_par1   = 'CL_HRRCF_REGISTER_BL'
          message_par2   = 'CHECK_PASSWORD'.
      CATCH cx_hrrcf INTO lo_exception.
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_exception.
        RAISE EXCEPTION TYPE cx_hrrcf_registration.
    ENDTRY.
*
  ELSEIF rc <> 0 .
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'E'
        cl     = msgid
        number = msgno
        par1   = lv_msgv1
        par2   = lv_msgv2
        par3   = lv_msgv3
        par4   = lv_msgv4
      IMPORTING
        return = ls_return.
    APPEND ls_return TO pt_return.
    RETURN.
  ENDIF.
*
ENDMETHOD.


METHOD check_rel_object.

* Author: PEV.

  DATA: ls_cand_hrobject TYPE hrobject,
        lv_user          TYPE sy-uname,
        lv_sugr          TYPE xuclass.
*  DATA  lo_candidate     TYPE REF TO cl_hrrcf_candidate.


  CASE ps_rel_object-sclas.

    WHEN 'US'.
*     check user existence
      lv_user = ps_rel_object-sobid.

      TRY.
          CALL METHOD cl_hrrcf_candidate_admin_bl=>check_user_existence
            EXPORTING
              p_user           = lv_user
            IMPORTING
              ps_cand_hrobject = ls_cand_hrobject.
        CATCH cx_hrrcf .
      ENDTRY.

      IF NOT ls_cand_hrobject IS INITIAL.
        rel_object_exists = true.
      ELSE.
        rel_object_exists = false.
      ENDIF.

    WHEN 'UG'.  " User group
*     check user group existence
      lv_sugr = ps_rel_object-sobid.
      rel_object_exists = cl_hrrcf_candidate_admin_bl=>check_sugr_existence( lv_sugr ).

    WHEN OTHERS.
* not supported yet

  ENDCASE.

ENDMETHOD.


method CHECK_SUGR_EXISTENCE.

* Author: PEV
* Checks user group from USGRP


  CALL FUNCTION 'SUSR_USERGROUP_EXISTANCE_CHECK'
    EXPORTING
      usergroup            = p_sugr
    EXCEPTIONS
      usergroup_exists     = 1
      usergroup_not_exists = 2
      OTHERS               = 3.

  IF sy-subrc EQ 1.
    p_sugr_exists = true.
  ENDIF.

endmethod.


METHOD check_user_existence .
*Author:BM
*This method checks if the user already exists in the e-recruiting
*system

  DATA: ls_return TYPE bapiret2,
  lo_candidate TYPE REF TO cl_hrrcf_candidate.
*user check
  IF p_user IS SUPPLIED.

    CALL FUNCTION 'BAPI_USER_EXISTENCE_CHECK'
      EXPORTING
        username = p_user
      IMPORTING
        return   = ls_return.

    TRY.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = p_user
          IMPORTING
            candidate = lo_candidate.
      CATCH cx_hrrcf .
*no reaction,existence check only
    ENDTRY.
  ENDIF.

*pernr check
  IF p_pernr IS SUPPLIED.

    TRY.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            employeeid = p_pernr
          IMPORTING
            candidate  = lo_candidate.
      CATCH cx_hrrcf .
*no reaction,existence check only
    ENDTRY.
  ENDIF.

  IF NOT lo_candidate IS INITIAL.

    ps_cand_hrobject = lo_candidate->hrobject.
  ELSE.
    CLEAR ps_cand_hrobject.
  ENDIF..

ENDMETHOD.


METHOD check_user_type.

* Author: PEV
  DATA: ls_uslogond TYPE uslogond.

* check user type
  CALL FUNCTION 'SUSR_USER_LOGONDATA_GET'
    EXPORTING
      user_name           = p_user_name
    IMPORTING
      user_logondata      = ls_uslogond
    EXCEPTIONS
      user_name_not_exist = 1
      OTHERS              = 2.

  IF sy-subrc <> 0.
    IF 1 = 2 .
      MESSAGE e045(hrrcf0002).
*     Kein registierter Benutzer für die Angaben vorhanden
    ENDIF .
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'I'
        cl     = 'HRRCF0002'
        number = '045'
      IMPORTING
        return = ps_return.
    RETURN.
  ENDIF.

  CASE ls_uslogond-ustyp.
    WHEN 'B' OR 'L' OR 'S'.
      IF 1 = 2 .
        MESSAGE e123(hrrcf0002).
*     Kein Dialog- bzw. Kommunikationsbenutzer für die Angaben vorhanden
      ENDIF .
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'I'
          cl     = 'HRRCF0002'
          number = '123'
        IMPORTING
          return = ps_return.
      RETURN.

    WHEN OTHERS.
  ENDCASE.

ENDMETHOD.


METHOD compare_role.

  DATA : ls_role      TYPE t77rcf_role ,
         ls_ref_user  TYPE bapirefus,
         lt_return    TYPE bapiret2_tab,
         lo_ex TYPE REF TO cx_root.

  TRY .
* Read the customizing table t77rcf_role to get the reference user for the role
      CALL METHOD cl_hrrcf_t77rcf_role=>get_role
        EXPORTING
          role        = iv_role
        IMPORTING
          t77rcf_role = ls_role.

      IF ( ls_role-refus IS NOT INITIAL ) AND
         ( iv_username IS NOT INITIAL ).
* Get the reference user assigned to the candidate
        CALL FUNCTION 'BAPI_USER_GET_DETAIL'
          EXPORTING
            username = iv_username
          IMPORTING
            ref_user = ls_ref_user
          TABLES
            return   = lt_return.

* Compare the customizing entry against user master record
        IF NOT ls_ref_user IS INITIAL.
         IF ls_ref_user EQ ls_role-refus.
           ev_match = abap_true. "Match
         ELSE.
           ev_match = abap_false. "No Match
         ENDIF.
        ENDIF.
      ENDIF.

    CATCH cx_root INTO lo_ex.

  ENDTRY.


ENDMETHOD.


method CONSTRUCTOR.
endmethod.


method create_user .
*
* Author: BM
* Additions: AS
*
*This method creates a new e-recruting user and is a funtionality of
*the admin tool. Creation is delegated to hrrcf_cand_from_ee_ale and
*employee and candidate objects are created along with the information
*in the Infotypes

  data:
    ls_plogi type hrplogi,
    ls_pnnnn type hrobjsdata,
    lt_pnnnn type hrobjsdata_tab,
    ls_e1p0000             type e1p0000,
    ls_e1p0001             type e1p0001,
    ls_e1p0002             type e1p0002,
    ls_e1p0105             type e1p0105,
    ls_errors type hrale_err,
    lt_errors type hrale_err_tab,
    ls_return type bapiret2,
    lt_return type table of bapiret2,
*    lo_candidate type ref to cl_hrrcf_candidate,
    lo_employee type ref to cl_hrrcf_employee,
    ls_ref_user     type bapirefus,
    ls_ref_userx    type bapirefusx,
    lo_exception type ref to cx_hrrcf,
    plans  type plans,
    l_semid type objektid,
    l_subrc type sysubrc.

  clear pt_return.refresh pt_return.


  perform re77s0 in program
                      mstt77s0
                   using
                      'PLOGI'
                      'PRELI'
                      l_semid
                      l_subrc.

  if l_subrc ne 0.
*    CLEAR l_semid.
    l_semid = '99999999' .
  endif.
  plans = l_semid.

  ls_plogi-otype     =  'P'        .
  ls_plogi-objid     =  p_pernr    .

* -----------------------------------------------------  IT 0000
  ls_e1p0000-pernr      =  p_pernr    .
  ls_e1p0000-begda      =  sy-datum   .
  ls_e1p0000-endda      =  '99991231' .
  ls_e1p0000-stat2      =  '3'        .

  ls_pnnnn-segnam       =  'E1P0000'  .
  ls_pnnnn-sdata        = ls_e1p0000  .

  append ls_pnnnn to lt_pnnnn.
* -----------------------------------------------------  0000

* -----------------------------------------------------  IT 0001
  if plans cn '0 '.
    ls_e1p0001-pernr      =  p_pernr    .
    ls_e1p0001-begda      =  sy-datum   .
    ls_e1p0001-endda      =  '99991231' .
    ls_e1p0001-plans      =  plans    .

    ls_pnnnn-segnam       =  'E1P0001'  .
    ls_pnnnn-sdata        = ls_e1p0001  .

    append ls_pnnnn to lt_pnnnn.
  endif.
* -----------------------------------------------------  0001

* -----------------------------------------------------  IT 0002
*first name,lastname
  ls_e1p0002-pernr      =  p_pernr    .
  ls_e1p0002-begda      =  sy-datum   .
  ls_e1p0002-endda      =  '99991231' .
  ls_e1p0002-vorna_40   =  ps_centraldataperson-firstname    .
  ls_e1p0002-nachn_40   =  ps_centraldataperson-lastname     .

  ls_pnnnn-segnam       =  'E1P0002'  .
  ls_pnnnn-sdata        = ls_e1p0002  .

  append ls_pnnnn to lt_pnnnn.
* -----------------------------------------------------  0002

* -----------------------------------------------------  IT 0105
* User
  ls_e1p0105-pernr      =  p_pernr    .
  ls_e1p0105-begda      =  sy-datum   .
  ls_e1p0105-endda      =  '99991231' .
  ls_e1p0105-subty      =  '0001'     .
  ls_e1p0105-usrid      =  p_user     .

  ls_pnnnn-segnam       =  'E1P0105'  .
  ls_pnnnn-sdata        = ls_e1p0105  .

  append ls_pnnnn to lt_pnnnn.
* -----------------------------------------------------  IT 0105

* -----------------------------------------------------  0105
* e-mail address

  ls_e1p0105-pernr      =  p_pernr    .
  ls_e1p0105-begda      =  sy-datum   .
  ls_e1p0105-endda      =  '99991231' .
  ls_e1p0105-subty      =  '0010'     .
  ls_e1p0105-usrid_long =  p_email    .

  ls_pnnnn-segnam       =  'E1P0105'  .
  ls_pnnnn-sdata        = ls_e1p0105  .

  append ls_pnnnn to lt_pnnnn.

  IF p_pvt_email is SUPPLIED.                         "N 2610757
  ls_e1p0105-pernr      =  p_pernr    .
  ls_e1p0105-begda      =  sy-datum   .
  ls_e1p0105-endda      =  '99991231' .
  ls_e1p0105-subty      =  '0030'     .
  ls_e1p0105-usrid_long =  p_pvt_email.

  ls_pnnnn-segnam       =  'E1P0105'  .
  ls_pnnnn-sdata        = ls_e1p0105  .

  append ls_pnnnn to lt_pnnnn.
  ENDIF.                                                "N 2610757


* -----------------------------------------------------  0105
*create user, employee and candidate
  try.

      call method cl_hrrcf_employee_inbound=>hrrcf_cand_from_ee_ale
        exporting
          ls_plogi = ls_plogi
          lt_pnnnn = lt_pnnnn
          external_commit = space                     "N_1511881
        importing
          t_errors = lt_errors.

      if not lt_errors is initial.
        loop at lt_errors into ls_errors.

          call function 'BALW_BAPIRETURN_GET2'
            exporting
              type   = ls_errors-msgty
              cl     = ls_errors-msgid
              number = ls_errors-msgno
              par1   = ls_errors-msgv1
              par2   = ls_errors-msgv2
              par3   = ls_errors-msgv3
              par4   = ls_errors-msgv4
            importing
              return = ls_return.

          append ls_return to pt_return.
        endloop.
      endif.
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
  endtry.

  if lt_errors is initial.

    try.
        call method cl_hrrcf_employee=>get
          exporting
            user     = p_user
          importing
            employee = lo_employee.
      catch cx_hrrcf.
* no reaction, existence check only (xdp)
    endtry.
  endif.

endmethod.


METHOD delete_candidate .

  DATA : lo_exception TYPE REF TO cx_hrrcf ,
         lt_return TYPE bapirettab,
         ls_return TYPE bapiret2 .

  CLEAR return_message .

  TRY.

      CALL METHOD cl_hrrcf_delete_manager=>delete_candidate
        EXPORTING
          hrobject = cand_hrobject
        IMPORTING
          return   = lt_return.

*   Get return message
      IF lt_return IS NOT INITIAL.
        READ TABLE lt_return INDEX 1 INTO ls_return.
        return_message = ls_return-message.
      ENDIF.

    CATCH cx_hrrcf INTO lo_exception .
      cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).
      return_message = cl_bsp_runtime=>get_otr_text(
        'paoc_rcf_ui/internal_error' ).

  ENDTRY.

ENDMETHOD.


method DELETE_PREF_DATA_OVER .

*Author:BM

*This method deletes the preferred data format of a candidate.

  DATA : lo_ex TYPE REF TO cx_hrrcf,
  lv_user TYPE syuname,
  lo_candidate TYPE REF TO cl_hrrcf_candidate.


  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
  ELSE .
    lv_user = sy-uname.
  ENDIF.



* delete the preferred data overview format

  TRY.

      CALL METHOD cl_hrrcf_pers_admin=>delete_pref_data_overview
        EXPORTING
          p_user           = lv_user.


    CATCH cx_hrrcf_personalization INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf .

  ENDTRY.


endmethod.


METHOD dequeue_candidate.
*
* Author: AS
*
* This method dequeues a candidate.
*
  DATA lo_ex TYPE REF TO cx_hrrcf.
  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.
*
  TRY.
*
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      CALL METHOD lo_candidate->dequeue
        EXPORTING
          iv_enqmode = iv_enqmode
          iv_scope   = iv_scope.
*
* exception handling
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
*
ENDMETHOD.


METHOD deregister .

* Additions: PEV

* This method deregisters a candidate.

  DATA:
    ls_hrobject   TYPE hrobject,
    lv_objkey     TYPE swo_typeid.

  DATA:
      lo_candidate  TYPE REF TO cl_hrrcf_candidate,
      lo_ex_hrrcf   TYPE REF TO cx_hrrcf,
      lo_ex_main    TYPE REF TO cx_hrrcf_maintain_object.


* Refresh RCF buffer to exclude the deregistered candidates
  CALL METHOD cl_hrrcf_simple_main_object=>refresh_rcf_buffer.

  TRY.
      IF NOT ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate_admin_bl=>get_candidate
          IMPORTING
            p_cand_hrobject = ls_hrobject.
      ELSE.
        ls_hrobject = ps_cand_hrobject.
      ENDIF.

      CALL METHOD cl_hrrcf_candidate=>get
        EXPORTING
          id        = ls_hrobject-objid
        IMPORTING
          candidate = lo_candidate.

      IF lo_candidate->is_deregistered( ) EQ true.
*       raise message
        return_message = cl_hrrcf_services_general=>get_otr_text(
             'paoc_rcf_ui/cand_already_deregistered' ).
        RETURN.
      ELSE.

       TRY.                                                              "N_1717098
        CALL METHOD cl_hrrcf_spt_change_pointer=>delete_change_pointer
          EXPORTING
            hrobject = ls_hrobject .
         CATCH cx_hrrcf_search_profil .
       ENDTRY.                                                           "N_1717098

        MOVE ls_hrobject TO lv_objkey.

        CALL FUNCTION 'SWE_EVENT_CREATE'
          EXPORTING
            objtype           = 'ERC_CAND'
            objkey            = lv_objkey
            event             = 'CANDIDATEDEREGISTER'
*        TABLES
*          event_container   = lt_evt_container
          EXCEPTIONS
            objtype_not_found = 1
            OTHERS            = 2.
        IF sy-subrc <> 0.
          TRY.
              RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
                EXPORTING
                  textid =
                    cx_hrrcf_maintain_object=>business_object_repository
                  hrobject = ls_hrobject
                  message_type = sy-msgty
                  message_class = sy-msgid
                  message_number = sy-msgno
                  message_par1 = sy-msgv1
                  message_par2 = sy-msgv2
                  message_par3 = sy-msgv3
                  message_par4 = sy-msgv4.

            CATCH cx_hrrcf_maintain_object INTO lo_ex_main.
              CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
                EXPORTING
                  ex = lo_ex_main.
              RAISE EXCEPTION TYPE cx_hrrcf.
          ENDTRY.
        ENDIF.
        COMMIT WORK.

      ENDIF.

    CATCH cx_hrrcf INTO lo_ex_hrrcf.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex_hrrcf.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD enqueue_candidate.

* Author: AS
* Additions: PEV
* This method enqueues a candidate.

  DATA lo_ex TYPE REF TO cx_hrrcf.
  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.


  CLEAR pt_return[].
  TRY.
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      CALL METHOD lo_candidate->enqueue
        EXPORTING
          iv_enqmode = iv_enqmode
          iv_scope   = iv_scope
        IMPORTING
          return     = pt_return.
*
* exception handling
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          textid   = cx_hrrcf_maintain_object=>enqueue_failed
          hrobject = ps_cand_hrobject.
  ENDTRY.
*
ENDMETHOD.


METHOD get_candidate .
*
* Author: MB
* Additions: AS
*
* This methods determines the basic informations about candidate
* with name, is_employee and employeeid.
*
  DATA: lo_candidate    TYPE REF TO cl_hrrcf_candidate,
        lo_exception    TYPE REF TO cx_hrrcf.
*
  TRY.
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSEIF p_employee_id IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            employeeid = p_employee_id
          IMPORTING
            candidate  = lo_candidate.
      ELSEIF p_partner IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            partner   = p_partner
          IMPORTING
            candidate = lo_candidate.
      ELSEIF alias IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            alias     = alias
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = p_user
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      p_cand_hrobject = lo_candidate->hrobject.
      IF NOT lo_candidate->centraldataperson-fullname IS INITIAL.
        p_cand_name     = lo_candidate->centraldataperson-fullname.
        p_cand_fname    = lo_candidate->centraldataperson-firstname. "N 1974247
        p_cand_lname    = lo_candidate->centraldataperson-lastname. "N 1974247
      ELSE .
        CONCATENATE lo_candidate->hrobject-otype
                    lo_candidate->hrobject-objid
        INTO p_cand_name.
      ENDIF .
      p_is_employee      = lo_candidate->is_employee( ).
      p_employeeid       = lo_candidate->employeeid.
      p_employeeid_tab[] = lo_candidate->get_personnel_assignments( ).
      p_uname         = lo_candidate->user.
      IF p_alias IS SUPPLIED.
        p_alias         = lo_candidate->get_cand_alias( ).
      ENDIF.
      IF p_cand_description IS SUPPLIED.
        CALL METHOD lo_candidate->get_cand_description
          IMPORTING
            cand_description = p_cand_description.

        IF p_cand_description IS INITIAL .
          CONCATENATE lo_candidate->hrobject-otype
                      lo_candidate->hrobject-objid
          INTO p_cand_description.
        ENDIF .
      ENDIF.

      "WG/N2202046
      IF ( p_is_employee = abap_true AND
             p_employeeid IS REQUESTED OR
             p_employeeid_tab IS REQUESTED ).
        IF iv_assure_active_pernr = abap_true
          OR ( NOT iv_assure_active_pernr IS SUPPLIED
      "context switch: requests the active PERNR instead of
      "just the first PERNR found (could be used in contexts where the
      "GET_CANDIDATE is at the bottom of a deep call-stack and there is
      "no posibility to add an parameter to all the corresponding method
      "interfaces)
             AND sv_assure_active_pernr_by_dflt = abap_true ).
          TRY .
              lo_candidate->get_employee_ids(
                IMPORTING
                  et_active_id        = p_employeeid_tab[]
                  ev_latest_active_id = p_employeeid  ).
            CATCH cx_hrrcf INTO lo_exception.
              RAISE EXCEPTION lo_exception.
          ENDTRY.
        ENDIF.
      ENDIF.

* exception handling
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD get_candidate_appl .
*
* Additions: SGS
*
* This method reads the applications of the candidate.
*
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.
  DATA lt_appl_list TYPE rcf_t_application .
  DATA lo_appl TYPE LINE OF rcf_t_application .
  DATA lv_status TYPE rcf_application_status .
*
  CLEAR : p_appl_list .
*
  TRY.
*
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      CALL METHOD lo_candidate->get_applications
        IMPORTING
          application_list = lt_appl_list.
*
      LOOP AT lt_appl_list INTO lo_appl .

        CALL METHOD lo_appl->get_application_status
          IMPORTING
            p_status = lv_status.

        IF lv_status NE '0' .
          APPEND lo_appl TO p_appl_list .
        ENDIF .

      ENDLOOP .

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .

  ENDTRY.
*
ENDMETHOD.


METHOD get_candidate_by_employee_id.
*
* This methods determines the basic informations about candidate
* with name, is_employee and employeeid.
*
  DATA: lo_candidate    TYPE REF TO cl_hrrcf_candidate,
        lo_exception    TYPE REF TO cx_hrrcf.
*
  TRY.
      CALL METHOD cl_hrrcf_candidate=>get
        EXPORTING
          employeeid = p_employee_id
        IMPORTING
          candidate  = lo_candidate.

      IF lo_candidate IS BOUND.

        p_cand_hrobject = lo_candidate->hrobject.
        IF NOT lo_candidate->centraldataperson-fullname IS INITIAL.
          p_cand_name     = lo_candidate->centraldataperson-fullname.
        ELSE .
          CONCATENATE lo_candidate->hrobject-otype
                      lo_candidate->hrobject-objid
          INTO p_cand_name.
        ENDIF .
        IF p_is_employee IS SUPPLIED.
          p_is_employee   = lo_candidate->is_employee( ).
        ENDIF.
        p_employeeid    = lo_candidate->employeeid.
        p_uname         = lo_candidate->user.
        IF p_alias IS SUPPLIED.
          p_alias         = lo_candidate->get_cand_alias( ).
        ENDIF.
        IF p_cand_description IS SUPPLIED.
          CALL METHOD lo_candidate->get_cand_description
            IMPORTING
              cand_description = p_cand_description.

          IF p_cand_description IS INITIAL .
            CONCATENATE lo_candidate->hrobject-otype
                        lo_candidate->hrobject-objid
            INTO p_cand_description.
          ENDIF .
        ENDIF.

      ENDIF.
*
* exception handling
    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD get_candidate_classification .
*
* This method reads the overall classification of the candidate.
*
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lo_cand_info TYPE REF TO cl_hrrcf_candidate_info.
  DATA lt_cand_txt TYPE rcf_t_cand_info_text .
  DATA ls_cand_txt TYPE rcf_s_cand_info_text .
*
  TRY.
*
      CALL METHOD cl_hrrcf_candidate_info=>get_instance
        EXPORTING
          hrobject = ps_cand_hrobject
        IMPORTING
          instance = lo_cand_info.
*
      CALL METHOD lo_cand_info->get_records_by_date_with_text
        EXPORTING
          p_language     = p_langu
        IMPORTING
          pt_cand_info_t = lt_cand_txt.

      READ TABLE lt_cand_txt INDEX 1 INTO ls_cand_txt.

      IF sy-subrc IS NOT INITIAL.
        IF 1 = 2.                      "Only for where used list
          MESSAGE e073(hrrcf0001) WITH 'CANDIDATE'.
        ENDIF.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
            message_type = 'E'
            message_class = 'HRRCF0001'
            message_number = 073
            message_par1   = 'CANDIDATE' .

      ENDIF.

      p_classification = ls_cand_txt-classification.
      p_classif_txt = ls_cand_txt-classification_txt .

*
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD get_candidate_profile.
  DATA:
   lo_exception        TYPE REF TO cx_hrrcf,
   lo_candidate        TYPE REF TO cl_hrrcf_candidate,
   lt_candidacies      TYPE rcf_t_candidacy,
   lt_version_info     TYPE rcf_t_version_audit_trail,
   ls_cand_audit_trail TYPE rcf_s_candidate_audit_trail.
  FIELD-SYMBOLS:
   <lo_candidacy>      TYPE REF TO cl_hrrcf_candidacy,
   <ls_version_info>   TYPE rcf_s_version_audit_trail.
*

  CLEAR pt_cand_audit_trail.
  IF ps_cand_hrobject-otype <> 'NA'.
    RETURN.
  ENDIF.

  TRY.
      CALL METHOD cl_hrrcf_candidate=>get
        EXPORTING
          id        = ps_cand_hrobject-objid
        IMPORTING
          candidate = lo_candidate.
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
  ENDTRY.

  IF NOT ( lo_candidate IS BOUND ).
    RETURN.
  ENDIF.

  CALL METHOD lo_candidate->get_candidacy
    IMPORTING
      candidacy_list = lt_candidacies.

  LOOP AT        lt_candidacies
       ASSIGNING <lo_candidacy>.
    TRY.
        CALL METHOD <lo_candidacy>->get_candidate_profiles
          IMPORTING
            pt_eversion_info = lt_version_info.
      CATCH cx_hrrcf INTO lo_exception.
        cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).
        CONTINUE.
    ENDTRY.

    LOOP AT        lt_version_info
         ASSIGNING <ls_version_info>.
      CLEAR ls_cand_audit_trail.
      ls_cand_audit_trail-appl_hrobject = <lo_candidacy>->hrobject.
      MOVE-CORRESPONDING <ls_version_info>
                      TO ls_cand_audit_trail.
      APPEND ls_cand_audit_trail
          TO pt_cand_audit_trail.
    ENDLOOP.

  ENDLOOP.

ENDMETHOD.


METHOD get_candidate_status .
*
* Additions: AS
*
* This method reads the status of the candidate.
*
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.
*
  TRY.
*
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      CALL METHOD lo_candidate->get_candidate_status
        EXPORTING
          p_langu      = p_langu
        IMPORTING
          p_status     = p_status
          p_status_txt = p_status_txt.
*
    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf .
  ENDTRY.
*
ENDMETHOD.


METHOD get_cand_alias .
*Author:BM
*This method gets the candidate alias

  DATA :lt_return TYPE bapirettab,
        lv_user TYPE syuname,
        lo_candidate TYPE REF TO cl_hrrcf_candidate,
        lo_ex TYPE REF TO cx_hrrcf.


  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
  ELSE .
    lv_user = sy-uname.
  ENDIF.


*  CALL FUNCTION 'BAPI_USER_GET_DETAIL'
*    EXPORTING
*      username = lv_user
*    IMPORTING
*      alias    = ps_alias
*    TABLES
*      return   = lt_return.

CALL FUNCTION 'SUSR_USER_READ'
  EXPORTING
    user_name                  = lv_user
*   WITH_TEXT                  =
 IMPORTING
   ALIAS                      = ps_alias
 EXCEPTIONS
   USER_NAME_NOT_EXISTS       = 1
   INTERNAL_ERROR             = 2
   OTHERS                     = 3
          .
IF sy-subrc <> 0.

*delete errors of type E and A
*  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
*  IF NOT lt_return IS INITIAL.
    TRY.
        IF 1 = 0.
          MESSAGE e121(hrrcf0001) WITH 'CL_HRRCF_CANDIDATE_ADMIN_BL'
                              'GET_CAND_ALIAS'  .
        ENDIF.

*An error occurred while changing data
        RAISE EXCEPTION TYPE cx_hrrcf_personalization
             EXPORTING
                  textid =
                   cx_hrrcf_personalization=>cx_per_get_data
                   message_type   = 'E'
                   message_class  = 'HRRCF0001'
                   message_number = '121'
                   message_par1   = 'CL_HRRCF_CANDIDATE_ADMIN_BL'
                   message_par2   = 'GET_CAND_ALIAS' .

      CATCH cx_hrrcf_personalization INTO lo_ex.
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_ex.
        RAISE EXCEPTION TYPE cx_hrrcf .


    ENDTRY.
    CLEAR ps_alias.

  ENDIF.

ENDMETHOD.


METHOD get_cand_audit_trail.

  FIELD-SYMBOLS:
        <lo_application>    TYPE REF TO cl_hrrcf_candidate_application,
        <ls_version_info>   TYPE rcf_s_version_audit_trail.

  DATA: lo_exception        TYPE REF TO cx_hrrcf,
        lt_applications     TYPE rcf_t_application,
        lt_version_info     TYPE rcf_t_version_audit_trail,
        ls_cand_audit_trail TYPE rcf_s_candidate_audit_trail.

  CLEAR pt_cand_audit_trail.

  TRY.
      CALL METHOD cl_hrrcf_candidate_admin_bl=>get_candidate_appl
        EXPORTING
          ps_cand_hrobject = ps_cand_hrobject
        IMPORTING
          p_appl_list      = lt_applications.

      LOOP AT lt_applications ASSIGNING <lo_application>.

        CALL METHOD <lo_application>->get_audit_trail
          IMPORTING
            pt_version_info = lt_version_info.

        LOOP AT lt_version_info ASSIGNING <ls_version_info>.

          CLEAR ls_cand_audit_trail.
          ls_cand_audit_trail-appl_hrobject = <lo_application>->hrobject.
          MOVE-CORRESPONDING <ls_version_info> TO ls_cand_audit_trail.
          APPEND ls_cand_audit_trail TO pt_cand_audit_trail.

        ENDLOOP.

      ENDLOOP.

    CATCH cx_hrrcf INTO lo_exception.
      cl_hrrcf_exception_handler=>write_exception_log( lo_exception ).
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.

ENDMETHOD.


METHOD get_cand_emailid .
*
* Author: SGS
*
* This method provides the e-mail data of candidate.
*
  DATA: lv_bp       TYPE bu_partner,
        lo_candidate TYPE REF TO cl_hrrcf_candidate,
        lo_ex        TYPE REF TO cx_hrrcf,
        lo_exception TYPE REF TO cx_hrrcf,
        mess_par TYPE sy-msgv1 ,
        lo_bas TYPE REF TO cl_hrrcf_address_service.
*
  CLEAR: p_emaildata.
*
  TRY.
*
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      lv_bp = lo_candidate->partner .

      CALL METHOD cl_hrrcf_address_service=>get_instance
        EXPORTING
          businesspartner = lv_bp
        IMPORTING
          instance        = lo_bas.

      IF lo_bas IS INITIAL .
        mess_par = lo_candidate->user.
        IF 1 EQ 0.                       "neccessary for where-used-list
          MESSAGE e113(hrrcf0001)
                  WITH mess_par.       "no address available
        ENDIF.
        CREATE OBJECT lo_exception
          EXPORTING
            textid         =
              cx_hrrcf_address_service=>cx_hrrcf_address_service
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '113'
            message_par1   = mess_par .

        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_exception.
        RAISE EXCEPTION TYPE cx_hrrcf.
      ENDIF.

      CALL METHOD lo_bas->get_preferred_contact_data
        IMPORTING
          emaildata = p_emaildata.
*
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
*
ENDMETHOD.


METHOD get_cand_employee_ids.
  DATA lo_cand TYPE REF TO cl_hrrcf_candidate.
  DATA lv_earliest_inactive_id TYPE pernr_d.
  data lv_string type string.

  "leading zeroes
  lv_string = iv_employee_id.
  iv_employee_id = lv_string.

  cl_hrrcf_candidate=>get(
   EXPORTING
     id           = is_cand_hrobject-objid
     employeeid   = iv_employee_id
     user         = iv_uname
   IMPORTING
     candidate    =  lo_cand ).

  IF lo_cand->is_employee( ) = abap_false.
    RAISE EXCEPTION TYPE cx_hrrcf
      EXPORTING
        textid = cx_hrrcf=>access_without_candidate.
  ELSE.
    lo_cand->get_employee_ids(
      EXPORTING
        iv_keydate                   = iv_keydate
      IMPORTING
        ev_latest_active_id = ev_latest_active_employee_id
        et_active_id        = et_active_employee_id
        et_inactive_id      = et_inactive_employee_id
        ev_earliest_inactive_id = lv_earliest_inactive_id ).

    IF ev_latest_active_employee_id IS INITIAL AND
       iv_empty_pernr_if_no_active = abap_false.
      lv_string = lo_cand->employeeid.
      ev_latest_active_employee_id = lv_string.
    ENDIF.

  ENDIF.
ENDMETHOD.


METHOD get_cand_formatted_resume.

*-------------------------------------------------------------------
* Specification
* S1. Exception -> Write in CL_HRRCF_EXCEPTION_HANDLER->
*     WRITE_EXCEPTION_LOG
* S2. All attachments, maintained from candidate profile, are assigned
*     subtyp C_SUBTY_CAND_PROFILE
* S3a Read the last changed (AEDTM) resume having P_LANGUAGE.
*   b Read the last changed resume independently from P_LANGUAGE if no
*     resume fulfills S3a. condition.
*-------------------------------------------------------------------

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA ls_candidate         TYPE hrobject.

  DATA lv_att_type_fmtd_rsm TYPE rcf_attachment_type.
  DATA lo_attachment        TYPE REF TO cl_hrrcf_attachments.

  DATA lt_attachment        TYPE rcf_t_attachments.
  DATA ls_attachment        TYPE p5134.

  DATA lv_language          TYPE sylangu.

  DATA ld_index             TYPE sytabix.

* S2
  CONSTANTS c_subty_cand_profile TYPE subty VALUE '0001'.

  CLEAR p_formatted_resume.

  ls_candidate = ps_cand_hrobject.

  TRY.

      TRY .
          CALL METHOD cl_hrrcf_t77rcf_atttype=>read_fmtd_rsm_atttype
            RECEIVING
              p_attachment_type = lv_att_type_fmtd_rsm.
        CATCH cx_hrrcf INTO lo_exception.
*       Do nothing -- Formatted Resume attachment type 'F' is not a required customizing entry
      ENDTRY.

      IF   ls_candidate IS INITIAL
        OR lv_att_type_fmtd_rsm IS INITIAL.
        EXIT.
      ENDIF.

      CALL METHOD cl_hrrcf_attachments=>get_instance
        EXPORTING
          hrobject = ls_candidate
        IMPORTING
          instance = lo_attachment.

      CALL METHOD lo_attachment->get_records_by_subtype
        EXPORTING
*       DATE              =
* S2
          subtype           = c_subty_cand_profile
        IMPORTING
          infotype_records  = lt_attachment.
*     CATCH CX_HRRCF .

* S3
      ld_index = 1.
      IF p_language IS NOT INITIAL.
        READ TABLE lt_attachment INTO p_formatted_resume
              WITH KEY att_type = lv_att_type_fmtd_rsm
                       language = p_language.
        IF p_formatted_resume-att_type = lv_att_type_fmtd_rsm.
          ld_index = sy-tabix + 1.
          lv_language = p_language.
        ENDIF.
      ENDIF.

      LOOP AT lt_attachment INTO ls_attachment FROM ld_index
                           WHERE att_type = lv_att_type_fmtd_rsm
*-- Performance
                             AND aedtm   >= p_formatted_resume-aedtm.
        IF     lv_language IS NOT INITIAL
           AND lv_language <> ls_attachment-language.
          CONTINUE.
        ENDIF.

        IF ls_attachment-aedtm >= p_formatted_resume-aedtm.
          p_formatted_resume = ls_attachment.
        ENDIF.
      ENDLOOP.

    CATCH cx_hrrcf INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION lo_exception.
  ENDTRY.

ENDMETHOD.


METHOD get_cand_has_resume.

  DATA: ls_orig_rsm_p5134   TYPE p5134,
        ls_fmtd_rsm_p5134   TYPE p5134,
        ls_message          TYPE bapiret2,
        lo_ex               TYPE REF TO cx_hrrcf.


*--   Initialize exporting parameters
  CLEAR: ev_has_resume,
         et_message[].

  TRY.
*--   Get latest original resume attachment
      CALL METHOD cl_hrrcf_candidate_admin_bl=>get_cand_resume_1_recent
        EXPORTING
          ps_cand_hrobject = is_cand_hrobject
          p_language       = sy-langu
        RECEIVING
          p_resume         = ls_orig_rsm_p5134.


*--   Get latest formatted resume attachment
      CALL METHOD cl_hrrcf_candidate_admin_bl=>get_cand_formatted_resume
        EXPORTING
          ps_cand_hrobject   = is_cand_hrobject
          p_language         = sy-langu
        RECEIVING
          p_formatted_resume = ls_fmtd_rsm_p5134.


*--   When both original and formatted resumes are available
      IF ( ls_orig_rsm_p5134 IS NOT INITIAL ) OR ( ls_fmtd_rsm_p5134 IS NOT INITIAL ).

        ev_has_resume = abap_true.

*--   When no resume is available
      ELSE.
        ev_has_resume = abap_false..
      ENDIF.


*-- Generic error handling
    CATCH cx_hrrcf INTO lo_ex.                           "#EC CATCH_ALL
*     Write exception to SLG1 log
      cl_hrrcf_exception_handler=>write_exception_log( ex = lo_ex ).

*     To be found by where-used list
      IF 1 = 0.
        MESSAGE e000(hrrcf0002).
      ENDIF.

*     Convert exception into BAPI return parameter
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = '000' "Internal Error
        IMPORTING
          return = ls_message.

      APPEND ls_message TO et_message.


  ENDTRY.

ENDMETHOD.


METHOD get_cand_name.

* N_1706655 -> Method created for mass fetch of candidate fullname, Pernr etc.
* Can be enhanced based on the requirement

* Data declaration
  TYPES : BEGIN OF t_na,
           otjid TYPE otjid,
          END OF t_na.

  TYPES : BEGIN OF t_bupa,
           cp     TYPE hrobjid,
           partner TYPE bu_partner,
          END OF t_bupa.

  TYPES : BEGIN OF t_na_cp,
           otjid TYPE otjid,
           varyf TYPE varyf,
           objid TYPE hrobjid,
          END OF t_na_cp.

  TYPES : BEGIN OF t_cp_bp,
           otjid TYPE otjid,
           objid TYPE hrobjid,
           sobid TYPE sobid,
          END OF t_cp_bp.

  TYPES : BEGIN OF t_adrp,
           persnumber TYPE adrp-persnumber,
           name_text TYPE ad_namtext,
          END OF t_adrp.

  TYPES : BEGIN OF t_but020,
           id TYPE bu_partner,
           addr TYPE adrc-addrnumber,
          END OF t_but020.

  TYPES : BEGIN OF t_adrc,
           addrnumber TYPE adrc-addrnumber,
           post_code1 TYPE ad_pstcd1,
           region TYPE regio,
           city1 TYPE ad_city1,
           country TYPE land1,
          END OF t_adrc.

  TYPES : BEGIN OF t_hrp5110,
           objid TYPE objektid,
           addnumber TYPE ad_addrnum,
          END OF t_hrp5110.

  DATA :  lt_na_cp     TYPE STANDARD TABLE OF t_na_cp,
          lt_cp_bp     TYPE STANDARD TABLE OF t_cp_bp,
          lt_cp_p      TYPE STANDARD TABLE OF t_cp_bp,
          lt_na        TYPE STANDARD TABLE OF t_na,
          lt_bupa      TYPE STANDARD TABLE OF t_bupa,
          lt_but000    TYPE TABLE OF but000,
          lt_adrp      TYPE TABLE OF t_adrp,
          lt_but020    TYPE TABLE OF t_but020,
          lt_adrc      TYPE TABLE OF t_adrc,
          lt_hrp5110   TYPE TABLE OF t_hrp5110.

  DATA :  ls_hrobject    TYPE hrobject,
          ls_na          TYPE t_na,
          ls_bupa        TYPE t_bupa,
          ls_na_cp       TYPE t_na_cp,
          ls_adrp        TYPE t_adrp,
          ls_cp_bp       TYPE t_cp_bp,
          ls_cp_p        TYPE t_cp_bp,
          ls_but020      TYPE t_but020,
          ls_but020_tmp  TYPE t_but020,
          ls_but000      TYPE but000,
          ls_adrc        TYPE t_adrc,
          ls_hrp5110     TYPE t_hrp5110,
          ls_cand_info   TYPE rcf_s_esa_cand_basic_data.

  DATA : lt_partners TYPE bu_partner_t,
         lt_partners_excl TYPE bu_partner_t,
         ls_return  TYPE bapiret2.

  DATA :  lv_plvar   TYPE plvar.
  DATA    lv_indx       TYPE i.
  DATA    lv_addrs      TYPE szad_field-addr_short.
  DATA    lv_adrs2      TYPE adrs2.

  TRY .

      CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
        EXPORTING
          set_default_plvar = 'X'
        IMPORTING
          act_plvar         = lv_plvar
        EXCEPTIONS
          no_active_plvar   = 0
          OTHERS            = 0.

      LOOP AT pt_candidates INTO ls_hrobject.

        CONCATENATE 'NA' ls_hrobject-objid INTO ls_na.
        APPEND ls_na TO lt_na.

      ENDLOOP.

* Fetch Central person using candidate objects
      SELECT objid
             otjid
             varyf
             FROM hrp1001
             INTO CORRESPONDING FIELDS OF TABLE lt_na_cp
             FOR ALL ENTRIES IN lt_na
             WHERE plvar = lv_plvar AND
                   otjid = lt_na-otjid AND
                   subty = 'A650' AND
                   endda GE sy-datum.

* Fetch Business partners using Central person
      SELECT objid
             otjid
             sobid
             FROM hrp1001
             INTO CORRESPONDING FIELDS OF TABLE lt_cp_bp
             FOR ALL ENTRIES IN lt_na_cp
             WHERE plvar = lv_plvar AND
                   otjid = lt_na_cp-varyf AND
                   subty = 'B207' AND
                   endda GE sy-datum.

* Fetch Employee number using central person
      SELECT objid
             otjid
             sobid
             FROM hrp1001
             INTO CORRESPONDING FIELDS OF TABLE lt_cp_p
             FOR ALL ENTRIES IN lt_na_cp
             WHERE plvar = lv_plvar AND
                   otjid = lt_na_cp-varyf AND
                   subty = 'B209' AND
                   endda GE sy-datum.

      LOOP AT lt_cp_bp INTO ls_cp_bp.
        ls_bupa-cp      = ls_cp_bp-objid.
        ls_bupa-partner = ls_cp_bp-sobid.
        APPEND ls_bupa TO lt_bupa.
        APPEND ls_bupa-partner TO lt_partners.
      ENDLOOP.

      DELETE ADJACENT DUPLICATES FROM lt_bupa COMPARING ALL FIELDS.

      CALL FUNCTION 'BUPA_DP_AUTHCHECK_MASS'
       EXPORTING
         IT_PARTNER                = lt_partners
       IMPORTING
         ET_PARTNERS               = lt_partners_excl
         EV_RETURN                 = ls_return .

      LOOP AT lt_bupa INTO ls_bupa.
        lv_indx = sy-tabix.
        READ TABLE lt_partners_excl WITH KEY partner = ls_bupa-partner
                                   TRANSPORTING NO FIELDS.
        IF sy-subrc EQ 0.
         DELETE lt_bupa INDEX lv_indx.
        ENDIF.
      ENDLOOP.

      IF NOT lt_bupa IS INITIAL.
* Get Business partner details
        SELECT * FROM but000 INTO TABLE lt_but000
               FOR ALL ENTRIES IN lt_bupa
               WHERE partner = lt_bupa-partner.
      ENDIF.

* Get Address number using Business partner
      SELECT partner
             addrnumber FROM but020
             INTO TABLE lt_but020
             FOR ALL ENTRIES IN lt_bupa
             WHERE partner = lt_bupa-partner.

* Get Address number from E-Rec table
      SELECT objid
             addrnumber01
             FROM hrp5110
             INTO TABLE lt_hrp5110
             FOR ALL ENTRIES IN lt_na
             WHERE addrnumber01 <> ' ' AND
                   plvar = lv_plvar AND
                   otjid = lt_na-otjid AND
                   subty = '0000'.

* Fetch Address details from ADRC,ADRP ( Business address services )
      IF lt_but020[] IS NOT INITIAL.
        SELECT addrnumber
             post_code1
             region
             city1
             country
             FROM adrc INTO TABLE lt_adrc
             FOR ALL ENTRIES IN lt_but020
             WHERE addrnumber = lt_but020-addr AND
                   pers_addr = 'X' AND
                   date_from <= sy-datum AND
                   date_to >= sy-datum.
      ENDIF.
      SORT lt_adrc BY addrnumber.

      IF lt_but000[] IS NOT INITIAL.
      SELECT persnumber
             name_text
             FROM adrp INTO TABLE lt_adrp
             FOR ALL ENTRIES IN lt_but000
            WHERE persnumber = lt_but000-persnumber AND
                  date_from <= sy-datum AND
                  date_to >= sy-datum.
      ENDIF.

* Sort Inernal tables
      SORT lt_na_cp.
      SORT lt_cp_bp.
      SORT lt_cp_p.
      SORT lt_bupa.
      SORT lt_but000 BY partner.
      SORT lt_but020 BY id addr.
      SORT lt_hrp5110 BY addnumber.
      SORT lt_adrp BY persnumber.
      SORT lt_adrc BY addrnumber.

      LOOP AT lt_na INTO ls_na.

        READ TABLE lt_na_cp INTO ls_na_cp WITH KEY otjid = ls_na BINARY SEARCH.
        READ TABLE lt_cp_bp INTO ls_cp_bp WITH KEY otjid = ls_na_cp-varyf BINARY SEARCH.
        READ TABLE lt_bupa  INTO ls_bupa  WITH KEY cp = ls_cp_bp-objid BINARY SEARCH.
        READ TABLE lt_but000 INTO ls_but000 WITH KEY partner = ls_bupa-partner BINARY SEARCH.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
        CLEAR: ls_but020, ls_adrp, ls_adrc.
        READ TABLE lt_adrp INTO ls_adrp WITH KEY persnumber = ls_but000-persnumber BINARY SEARCH.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
        READ TABLE lt_but020 INTO ls_but020 WITH KEY id = ls_but000-partner BINARY SEARCH.
        IF sy-subrc = 0.
          lv_indx = sy-tabix + 1.
          DO.
            READ TABLE lt_but020 INTO ls_but020_tmp INDEX lv_indx.
            IF sy-subrc <> 0.
              EXIT.
            ENDIF.
            IF ls_but020_tmp-id <> ls_but020-id.
              EXIT.
            ELSE.
              READ TABLE lt_hrp5110 INTO ls_hrp5110 WITH KEY addnumber = ls_but020-addr BINARY SEARCH.
              IF sy-subrc = 0.
                EXIT.
              ELSE.
                ls_but020-addr = ls_but020_tmp-addr.
              ENDIF.
            ENDIF.
            lv_indx = lv_indx + 1.
          ENDDO.
          READ TABLE lt_adrc INTO ls_adrc WITH KEY addrnumber = ls_but020-addr BINARY SEARCH.
          lv_adrs2-name_pers = ls_adrp-name_text.
          lv_adrs2-post_code1 = ls_adrc-post_code1.
          lv_adrs2-region = ls_adrc-region.
          lv_adrs2-city1 = ls_adrc-city1.
          lv_adrs2-country = ls_adrc-country .

          CALL FUNCTION 'ADDRESS_INTO_PRINTFORM'
            EXPORTING
              address_2          = lv_adrs2
              address_type       = '2'
              iv_nation_space    = 'X'
            IMPORTING
              address_short_form = lv_addrs.
        ELSE.
          lv_addrs = ls_adrp-name_text.
        ENDIF.

        READ TABLE lt_cp_p INTO ls_cp_p WITH KEY objid = ls_cp_bp-objid BINARY SEARCH.
        IF sy-subrc EQ 0.
          ls_cand_info-pernr = ls_cp_p-sobid.
        ENDIF.

        ls_cand_info-cand_objid = ls_na_cp-objid.
        ls_cand_info-fullname = lv_addrs.

        APPEND ls_cand_info TO pt_cand_info.

        CLEAR : ls_cand_info,
                ls_hrobject,
                ls_na,
                ls_bupa,
                ls_na_cp ,
                ls_adrp,
                ls_cp_bp,
                ls_cp_p ,
                ls_but020 ,
                ls_but020_tmp  ,
                ls_but000,
                ls_adrc  ,
                ls_hrp5110  ,
                ls_cand_info .

      ENDLOOP.

    CATCH cx_hrrcf.

  ENDTRY.
ENDMETHOD.


METHOD get_cand_notes.

  DATA:
    lo_candidate TYPE REF TO cl_hrrcf_candidate.

  CALL METHOD cl_hrrcf_candidate=>get
    EXPORTING
      id        = is_cand_hrobject-objid
    IMPORTING
      candidate = lo_candidate.

  CALL METHOD lo_candidate->get_notes
    IMPORTING
      et_notes = et_notes.

ENDMETHOD.


METHOD get_cand_pvt_email.
* This method provides the private e-mail data of candidate.

***************** Local reference(lo_*) declaration ******************
  DATA: lo_candidate      TYPE REF TO cl_hrrcf_candidate,
        lo_bas            TYPE REF TO cl_hrrcf_address_service,
        lo_ex             TYPE REF TO cx_hrrcf,
        lo_exception      TYPE REF TO cx_hrrcf,
        lo_add_exception  TYPE REF TO cx_hrrcf_address_service,

***************** Local variable(lv_*) declaration ******************
        lv_bp             TYPE bu_partner,
        lv_mess_par       TYPE sy-msgv1.


  CLEAR: ex_s_emaildata.
*
  TRY.
*
      IF im_s_hrobject IS NOT INITIAL.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = im_s_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      lv_bp = lo_candidate->partner .

      CALL METHOD cl_hrrcf_address_service=>get_instance
        EXPORTING
          businesspartner = lv_bp
        IMPORTING
          instance        = lo_bas.

      IF lo_bas IS INITIAL .
        lv_mess_par = lo_candidate->user.
        IF 1 EQ 0.                       "neccessary for where-used-list
          MESSAGE e113(hrrcf0001)
                  WITH lv_mess_par.       "no address available
        ENDIF.
        CREATE OBJECT lo_exception
          EXPORTING
            textid         = cx_hrrcf_address_service=>cx_hrrcf_address_service
            message_type   = 'E'
            message_class  = msgcl_admin
            message_number = '113'
            message_par1   = lv_mess_par.

        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_exception.
        RAISE EXCEPTION TYPE cx_hrrcf.
      ENDIF.

      CALL METHOD lo_bas->get_private_email
        EXPORTING
          im_s_hrobject  = im_s_hrobject
        IMPORTING
          ex_s_emaildata = ex_s_emaildata.

    CATCH cx_hrrcf_address_service INTO lo_add_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_add_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.

    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
ENDMETHOD.


METHOD get_cand_resume_1_recent .
*-------------------------------------------------------------------
* Template me->get_candidate( ).
*-------------------------------------------------------------------
* Specification
* S1. Exception -> Write in CL_HRRCF_EXCEPTION_HANDLER->
*     WRITE_EXCEPTION_LOG
* S2. All attachments, maintained from candidate profile, are assigned
*     subtyp C_SUBTY_CAND_PROFILE
* S3a Read the last changed (AEDTM) resume having P_LANGUAGE.
*   b Read the last changed resume independently from P_LANGUAGE if no
*     resume fulfills S3a. condition.
*-------------------------------------------------------------------
  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA ls_candidate       TYPE hrobject.

  DATA lv_att_type_resume TYPE rcf_attachment_type.
  DATA lo_attachment      TYPE REF TO cl_hrrcf_attachments.

  DATA lt_attachment      TYPE rcf_t_attachments.
  DATA ls_attachment      TYPE p5134.

  DATA lv_language        TYPE sylangu.

  DATA ld_index           TYPE sytabix.

* S2
  CONSTANTS c_subty_cand_profile TYPE subty VALUE '0001'.

  CLEAR p_resume.

  ls_candidate = ps_cand_hrobject.

  TRY.
      CALL METHOD cl_hrrcf_t77rcf_atttype=>read_resume_atttype
        RECEIVING
          p_attachment_type = lv_att_type_resume.
*   CATCH cx_hrrcf_customizing.

      IF   ls_candidate IS INITIAL
        OR lv_att_type_resume IS INITIAL.
        EXIT.
      ENDIF.

      CALL METHOD cl_hrrcf_attachments=>get_instance
        EXPORTING
          hrobject = ls_candidate
        IMPORTING
          instance = lo_attachment.

      CALL METHOD lo_attachment->get_records_by_subtype
        EXPORTING
*       DATE              =
* S2
          subtype           = c_subty_cand_profile
        IMPORTING
          infotype_records  = lt_attachment.
*     CATCH CX_HRRCF .

* S3
      ld_index = 1.
      IF p_language IS NOT INITIAL.
        READ TABLE lt_attachment INTO p_resume
              WITH KEY att_type = lv_att_type_resume
                       language = p_language.
        IF p_resume-att_type = lv_att_type_resume.
          ld_index = sy-tabix + 1.
          lv_language = p_language.
        ENDIF.
      ENDIF.

      LOOP AT lt_attachment INTO ls_attachment FROM ld_index
                           WHERE att_type = lv_att_type_resume
*-- Performance
                             AND aedtm   >= p_resume-aedtm.
        IF     lv_language IS NOT INITIAL
           AND lv_language <> ls_attachment-language.
          CONTINUE.
        ENDIF.

        IF ls_attachment-aedtm >= p_resume-aedtm.
          p_resume = ls_attachment.
        ENDIF.
      ENDLOOP.

    CATCH cx_hrrcf INTO lo_exception.
*   CATCH cx_hrrcf_customizing INTO lo_exception.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
*     RAISE EXCEPTION TYPE cx_hrrcf.
      RAISE EXCEPTION lo_exception.
  ENDTRY.
ENDMETHOD.


METHOD get_cand_role.
*Author:BM

*This method obtains the candidate role from the reference user

  DATA : ls_refuser   TYPE bapirefus,
         lt_role_list TYPE TABLE OF t77rcf_role,
         ls_role      TYPE t77rcf_role,
         lo_ex        TYPE REF TO cx_hrrcf,
         lt_return    TYPE bapirettab,
         ls_return    TYPE bapiret2.

*retrieve reference user
  CALL FUNCTION 'SUSR_USER_REFUSER_GET'
    EXPORTING
      user_name           = p_user
    IMPORTING
      refuser             = ls_refuser
    EXCEPTIONS
      user_name_not_exist = 1
      OTHERS              = 2.

  IF sy-subrc EQ 0.

*get role
    TRY.
        CALL METHOD cl_hrrcf_t77rcf_role=>get_role_with_ref_user
          EXPORTING
            refuser     = ls_refuser
          IMPORTING
            t77rcf_role = ls_role.

      CATCH cx_hrrcf_customizing INTO lo_ex .
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_ex.
        RAISE EXCEPTION TYPE cx_hrrcf .
    ENDTRY.

    p_role = ls_role-role.

  ELSE.

*for where used list
    IF 1 = 0.
      MESSAGE e155(hrrcf0001).
*   user does not exist
    ENDIF.

    TRY.
        RAISE EXCEPTION TYPE cx_hrrcf_registration
          EXPORTING
            textid         = cx_hrrcf_registration=>cx_hrrcf_registration
            message_type   = 'E'
            message_class  = 'HRRCF0001'
            message_number = '155'.

      CATCH cx_hrrcf_registration INTO lo_ex .
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_ex.
        RAISE EXCEPTION TYPE cx_hrrcf .
    ENDTRY.

  ENDIF.

ENDMETHOD.


METHOD get_cand_settings .
*Author:BM

*This method retrieves the user settings(date format, decial format and
*printer options) for a particular user

  DATA :lo_ex TYPE REF TO cx_hrrcf,
  lv_user TYPE syuname,
  lo_candidate TYPE REF TO cl_hrrcf_candidate,
  ls_user_settings type bapidefaul.


  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
  ELSE .
    lv_user = sy-uname.
  ENDIF.

*read defaults
  TRY.
      CALL METHOD cl_hrrcf_user_settings=>read_defaults
        EXPORTING
          p_user      = lv_user
        IMPORTING
          ps_defaults = ps_user_settings.
    CATCH cx_hrrcf_personalization INTO lo_ex .
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf .


  ENDTRY.



ENDMETHOD.


method get_del_cand_info .

  data : lo_ex            type ref to cx_hrrcf,
         ls_emaildata     type rcf_s_emaildata_bp,
         ls_del_cand_info type rcf_s_del_cand_info,
         lv_alias         type bapialias.


  clear : ps_del_cand_info.

  try.

      if p_partner is supplied.

        call method cl_hrrcf_candidate_admin_bl=>get_candidate
          exporting
            p_partner          = p_partner
          importing
            p_cand_hrobject    = ls_del_cand_info-cand_hrobject
            p_uname            = ls_del_cand_info-cand_user
            p_cand_description = ls_del_cand_info-cand_name_address
            p_alias            = lv_alias.

      elseif p_hrobject is supplied.

        call method cl_hrrcf_candidate_admin_bl=>get_candidate
          exporting
            ps_cand_hrobject   = p_hrobject
          importing
            p_cand_hrobject    = ls_del_cand_info-cand_hrobject
            p_uname            = ls_del_cand_info-cand_user
            p_cand_description = ls_del_cand_info-cand_name_address
            p_alias            = lv_alias.

      else.

        return.

      endif.

      ls_del_cand_info-user_alias = lv_alias-useralias.

      call method cl_hrrcf_candidate_admin_bl=>get_cand_emailid
        exporting
          ps_cand_hrobject = ls_del_cand_info-cand_hrobject
        importing
          p_emaildata      = ls_emaildata.

      move ls_emaildata-e_mail to ls_del_cand_info-e_mail .

      call method cl_hrrcf_candidate_admin_bl=>get_last_login_date
        exporting
          ps_cand_hrobject = ls_del_cand_info-cand_hrobject
        importing
          p_date           = ls_del_cand_info-last_login.

      move ls_del_cand_info to ps_del_cand_info .

      call method cl_hrrcf_candidate_admin_bl=>is_deregistered
        exporting
          ps_cand_hrobject  = ls_del_cand_info-cand_hrobject
        receiving
          p_is_deregistered = p_is_deregistered.

    catch cx_hrrcf into lo_ex.

      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_ex.

      raise exception type cx_hrrcf.

  endtry.

endmethod.


METHOD GET_HASNOTES_FOR_CANDIDATES.

  CALL METHOD cl_hrrcf_t77rcf_candnotes=>get_hasnotes_for_candidates
    EXPORTING
      it_cand_list          = it_cand_list
    IMPORTING
      et_cand_hasnotes_list = et_cand_hasnotes_list.

ENDMETHOD.


method GET_INSTANCE .

  CLEAR p_instance.

  IF NOT my_instance IS BOUND.
    CREATE OBJECT my_instance.
  ENDIF.

  p_instance = my_instance.

endmethod.


method get_last_login_date .
*
* Additions: AS
*
* This method provides the date on that the candidate last logged in.
*
  data:
    l_user       type syuname,
    lo_candidate type ref to cl_hrrcf_candidate,
    lo_ex        type ref to cx_hrrcf.
*
  clear: p_date.
*
  try.
*
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
        l_user = lo_candidate->user.
      else.
        l_user = sy-uname.
      endif.
*
      call method cl_hrrcf_usr02=>get_last_login
        exporting
          p_user = l_user
        importing
          p_date = p_date
          p_cr_date = p_cr_date.                                    "N 2030028
*
    catch cx_hrrcf into lo_ex.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_ex.
      raise exception type cx_hrrcf.
  endtry.
*
endmethod.


METHOD get_picture_url.

  DATA ls_t77s0                 TYPE        t77s0.
  DATA lv_rfc_dest              TYPE        rfcdest.
  DATA lo_employee              TYPE REF TO cl_hrrcf_employee.
  DATA lt_personnel_assignments TYPE        rcf_t_pernr.
  DATA lv_pernr                 TYPE        pernr_d.
  DATA lv_dummy_picture         TYPE        boole_d.
  DATA lv_return                TYPE        bapiret2.
  DATA lo_cand_bupa_bl          TYPE REF TO cl_hrrcf_candidate_bupa_bl.
  DATA ls_centraldata_person    TYPE        bapibus1006_central_person.
  DATA lv_sex                   TYPE        bu_sexid.
  DATA lo_ex                    TYPE REF TO cx_root.
  DATA lv_mime_path             TYPE        string.
  DATA lo_mime_repository       TYPE REF TO if_mr_api.
  DATA ls_url                   TYPE        sdokcomurl.
  DATA ls_loio                  TYPE        skwf_io.
  DATA ls_phio                  TYPE        skwf_io.
  DATA ls_physical_object       TYPE        sdokobject.
  DATA lt_urls                  TYPE        sdokcompurls.

* Constants
  CONSTANTS: lc_icon_uri        TYPE string VALUE '/SAP/PUBLIC/BUSINESSSUITE/TM/ICONS/',
             lc_female_mime_pic TYPE string VALUE 'female.jpg',
             lc_male_mime_pic   TYPE string VALUE 'male.jpg'.

* 1.) Retrieve destination of the HR System:
  CALL METHOD cl_hr_t77s0=>read
    EXPORTING
      grpid = 'RECFA'
      semid = 'HRRFC'
    RECEIVING
      t77s0 = ls_t77s0.

  lv_rfc_dest = ls_t77s0-gsval.

* 2.1) if HR destination is maintained: get pernr and picture url
  IF lv_rfc_dest IS NOT INITIAL.
    TRY.
        cl_hrrcf_employee=>get(
          EXPORTING
            candidateid = is_cand_hrobject-objid
          IMPORTING
            employee    = lo_employee ).
      CATCH cx_hrrcf INTO lo_ex.
*     do nothing
    ENDTRY.

    IF lo_employee IS BOUND. " candidate is employee => get the picture of the employee
      lt_personnel_assignments = lo_employee->get_personnel_assignments( ).
      lv_dummy_picture = abap_false.
    ELSE.     "candidate is not an employee => no picture available for candidates => get dummy picture
      lv_dummy_picture = abap_true.
    ENDIF.

    IF lt_personnel_assignments IS NOT INITIAL.
      READ TABLE lt_personnel_assignments INTO lv_pernr INDEX 1.
*       Call function module to fetch picture:
      CALL FUNCTION 'HRMSS_RFC_EP_READ_PHOTO_URI'
        DESTINATION lv_rfc_dest
        EXPORTING
          pernr  = lv_pernr
        IMPORTING
          uri    = ev_picture_url
          return = lv_return.

*   Check for foto availability
      IF lv_return-number = 000. " foto is available
        lv_dummy_picture = abap_false.
      ELSE.       " foto is not available => get dummy picture
        lv_dummy_picture = abap_true.
      ENDIF.
    ENDIF.
  ELSE.  " if HR destination is not maintained => get dummy picture
    lv_dummy_picture = abap_true.
  ENDIF.

* 3.) get URL to dummy picture
  IF  lv_dummy_picture = abap_true.
*     Read gender to decide which default foto should be displayed (male or female)
    TRY.
        CALL METHOD cl_hrrcf_candidate_bupa_bl=>get_instance
          RECEIVING
            return = lo_cand_bupa_bl.

        IF lo_cand_bupa_bl IS BOUND.
          CALL METHOD lo_cand_bupa_bl->get_pers_data
            EXPORTING
              ps_cand_hrobject     = is_cand_hrobject
            IMPORTING
              ps_centraldataperson = ls_centraldata_person.
          lv_sex = ls_centraldata_person-sex.
        ENDIF.

      CATCH cx_root INTO lo_ex.
*     write exception to slg1
        cl_hrrcf_exception_handler=>write_exception_log( ex = lo_ex ).
    ENDTRY.

    CASE lv_sex.
      WHEN '1'.
        CONCATENATE lc_icon_uri lc_female_mime_pic INTO lv_mime_path.
      WHEN '2'.
        CONCATENATE lc_icon_uri lc_male_mime_pic INTO lv_mime_path.
      WHEN OTHERS.
        CONCATENATE lc_icon_uri lc_male_mime_pic INTO lv_mime_path.
    ENDCASE.

    lo_mime_repository = cl_mime_repository_api=>get_api( ).
    CALL METHOD lo_mime_repository->properties
      EXPORTING
        i_url              = lv_mime_path
      IMPORTING
        e_loio             = ls_loio
        e_phio             = ls_phio
      EXCEPTIONS
        parameter_missing  = 1
        error_occured      = 2
        not_found          = 3
        permission_failure = 4
        OTHERS             = 5.
    IF sy-subrc = 0.
      MOVE-CORRESPONDING ls_phio TO ls_physical_object.
      CALL FUNCTION 'SDOK_PHIO_GET_URL_FOR_GET'
        EXPORTING
          object_id                  = ls_physical_object
          web_applic_server_url_only = 'X'
          url_used_at                = 'F'
        IMPORTING
          urls                       = lt_urls
        EXCEPTIONS
          not_existing               = 1
          not_authorized             = 2
          no_content                 = 3
          bad_storage_type           = 4
          no_urls_available          = 5
          OTHERS                     = 6.
      IF sy-subrc = 0.
        READ TABLE lt_urls INTO ls_url INDEX 1.
        IF ls_url IS NOT INITIAL.
          ev_picture_url = ls_url-url.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD get_pref_data_over .

*Author:BM

*This method retrieves the preferred data format of a candidate.

*  DATA : lo_ex TYPE REF TO cx_hrrcf,
  DATA : lv_user TYPE syuname,
  lo_candidate TYPE REF TO cl_hrrcf_candidate,
  lv_pref_data_over TYPE rcf_value.

  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
  ELSE .
    lv_user = sy-uname.
  ENDIF.



* retrieve the preferred data overview format

*This method retrieves the preferred data overview for a user

  CALL METHOD cl_pers_admin=>get_data
    EXPORTING
      p_pers_key          = 'HRRCF_PREF_DATA_OVER_FORMAT'
      p_uname             = lv_user
    IMPORTING
      p_pers_data         = lv_pref_data_over
    EXCEPTIONS
      pers_key_not_found  = 1
      data_type_error     = 2
      no_data_found       = 3
      user_does_not_exist = 4
      not_set_to_default  = 5
      OTHERS              = 6.


  IF sy-subrc <> 0.

**   necessary for where-used list
*    MESSAGE e121(hrrcf0001) WITH 'CL_HRRCF_PERS_ADMIN'
*                               'READ_PREF_DATA_OVERVIEW'  .
*
**An error occurred while getting data
*    RAISE EXCEPTION TYPE cx_hrrcf_personalization
*         EXPORTING
*           textid =
*               cx_hrrcf_personalization=>cx_per_get_data
*               message_type   = 'E'
*               message_class  = 'HRRCF0001'
*               message_number = '121'
*               message_par1   = 'CL_HRRCF_PERS_ADMIN'
*               message_par2   = 'READ_PREF_DATA_OVERVIEW' .

    CLEAR p_pref_data_over.

  ELSE.
    p_pref_data_over = lv_pref_data_over .
  ENDIF.


*  TRY.
*
*      CALL METHOD cl_hrrcf_pers_admin=>read_pref_data_overview
*        EXPORTING
*          p_user           = lv_user
*        IMPORTING
*          p_pref_data_over = p_pref_data_over.
*
*
*
*    CATCH cx_hrrcf_personalization INTO lo_ex.
*      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
*        EXPORTING
*          ex = lo_ex.
*      RAISE EXCEPTION TYPE cx_hrrcf .
*
*  ENDTRY.

ENDMETHOD.


method GET_PRIVACY_STATUS .
* author: CS
* This method reads the target group of a candidate.
*
  data ls_ci type p5102.
  data lt_ci type table of p5102.
  data lo_exception type ref to cx_hrrcf.
  data lo_candidate type ref to cl_hrrcf_candidate.
  data lo_ci type ref to cl_hrrcf_candidate_info.
*
  try.
*
* get candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
      else.
        call method cl_hrrcf_candidate=>get
          exporting
            user      = sy-uname
          importing
            candidate = lo_candidate.
      endif.
*
* get candidate info
      call method cl_hrrcf_candidate_info=>get_instance
        exporting
          hrobject = lo_candidate->hrobject
        importing
          instance = lo_ci.
*
* get current record
      call method lo_ci->get_records_by_date
        exporting
          date             = sy-datum
        importing
          infotype_records = lt_ci.
*
      read table lt_ci into ls_ci index 1.
*
  p_privacy_status = ls_ci-PRIVACY_STATUS.
  p_privacy_version = ls_ci-privacy_version.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.

endmethod.


method get_qa_documents.

  DATA: lt_documents           TYPE rcf_t_qa,
        lt_templates           TYPE TABLE OF rcf_qa_tpl_objid,
        lv_template            TYPE rcf_qa_tpl_objid,
        lv_qa_tpl_objid_before TYPE rcf_qa_tpl_objid,
        lv_plvar               TYPE plvar,
        lv_tpl_hrobject        TYPE hrobject,
        ls_tpl_basic_info      TYPE rcf_s_qa_tpl_basic_info,
        ls_document            TYPE p5141.

  CLEAR: et_documents.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    IMPORTING
      act_plvar       = lv_plvar
    EXCEPTIONS
      no_active_plvar = 1
      OTHERS          = 2.

  IF sy-subrc EQ 0.
  cl_hrrcf_act_qa=>get_document_info_for_object(
    exporting
      is_hrobject       = is_cand_hrobject
      iv_qa_template_id = iv_qa_template_id
    IMPORTING
      et_document_info  = lt_documents ).

    SORT lt_documents BY plvar otype objid qa_tpl_objid.

* As only documents of category 'Evaluable Information' shall be indexed, we need to get rid of documents/templates that belong to category 'EEO'
    LOOP AT lt_documents INTO ls_document.
      IF ls_document-qa_tpl_objid EQ lv_qa_tpl_objid_before.
        CONTINUE.
      ELSEIF ls_document-qa_tpl_objid NE lv_qa_tpl_objid_before.
        CONCATENATE lv_plvar 'VA' ls_document-qa_tpl_objid INTO lv_tpl_hrobject.
        TRY.
            CALL METHOD cl_hrrcf_qa_bl=>get_template_basic_info
              EXPORTING
                p_template_hrobject = lv_tpl_hrobject
              IMPORTING
                p_tpl_basic_info    = ls_tpl_basic_info.
          CATCH cx_hrrcf.
        ENDTRY.
        IF ls_tpl_basic_info-qatype NE 'E'.
          APPEND ls_document-qa_tpl_objid TO lt_templates.
        ENDIF.
        lv_qa_tpl_objid_before = ls_document-qa_tpl_objid.
      ENDIF.
    ENDLOOP.

    LOOP AT lt_templates INTO lv_template.
      LOOP AT lt_documents INTO ls_document
        WHERE qa_tpl_objid EQ lv_template.
        APPEND ls_document TO et_documents.
      ENDLOOP.
    ENDLOOP.

  ENDIF.

endmethod.


method GET_SETTINGS .

*Author:BM

*This method retrieves the user settings(date format, decial format and
*printer options) for a particular user

  DATA :lo_ex TYPE REF TO cx_hrrcf,
  lv_user TYPE syuname,
  lo_candidate TYPE REF TO cl_hrrcf_candidate,
  ls_user_settings type bapidefaul,
  lv_is_employee type boole_d.                              "note 1365367


  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
    IF lv_user IS INITIAL.                                  "note 1365367
       lv_is_employee = lo_candidate->is_employee( ).
       IF lv_is_employee = ' '.
         lv_user = sy-uname.
       ENDIF.
    ENDIF.
  ELSE .
    lv_user = sy-uname.
  ENDIF.

*read defaults
  TRY.

*Replacing GET_USER_SETTINGS by S.K  as this method directly uses SUSR_USER_READ which is deprecated.
*Replacing with READ_DEFAULTS since BAPI_USER_GET_DETAIL have to be used for retrieving
*user settings
*      CALL METHOD cl_hrrcf_user_settings=>get_user_settings
*        EXPORTING
*          p_user      = lv_user
*        IMPORTING
*          ps_defaults = ps_user_settings.

        CALL METHOD cl_hrrcf_user_settings=>read_defaults
          EXPORTING
            p_user      = lv_user
          IMPORTING
            ps_defaults = ps_user_settings.

    CATCH cx_hrrcf_personalization INTO lo_ex .
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf .


  ENDTRY.

endmethod.


method get_target_group .
*
* Author: AS
*
* This method reads the target group of a candidate.
*
  data ls_ci type p5102.
  data lt_ci type table of p5102.
  data lo_exception type ref to cx_hrrcf.
  data lo_candidate type ref to cl_hrrcf_candidate.
  data lo_ci type ref to cl_hrrcf_candidate_info.
*
  try.
*
* get candidate
      if ps_cand_hrobject is supplied.
        call method cl_hrrcf_candidate=>get
          exporting
            id        = ps_cand_hrobject-objid
          importing
            candidate = lo_candidate.
      else.
        call method cl_hrrcf_candidate=>get
          exporting
            user      = sy-uname
          importing
            candidate = lo_candidate.
      endif.
*
* get candidate info
      call method cl_hrrcf_candidate_info=>get_instance
        exporting
          hrobject = lo_candidate->hrobject
        importing
          instance = lo_ci.
*
* get current record
      call method lo_ci->get_records_by_date
        exporting
          date             = sy-datum
        importing
          infotype_records = lt_ci.
*
      read table lt_ci into ls_ci index 1.
*
  p_target_group = ls_ci-tgroup.
*
* exception handling
    catch cx_hrrcf into lo_exception.
      call method cl_hrrcf_exception_handler=>write_exception_log
        exporting
          ex = lo_exception.
      raise exception type cx_hrrcf .
  endtry.
*
endmethod.


METHOD get_usergroups.

  DATA: lt_groups     TYPE TABLE OF bapigroups,
        ls_group      TYPE bapigroups,
        lt_objid_list TYPE rcf_t_object_id_list,
        lv_objid      TYPE hrobjid,
        lt_return     TYPE bapirettab,
        ls_return     TYPE bapiret2,
        ls_rel_object TYPE rcf_s_rel_object.


  CLEAR pt_usergroup.
* read the SUGR user group 'UG'
  CALL FUNCTION 'BAPI_USER_GET_DETAIL'
    EXPORTING
      username = p_user
    TABLES
      return   = lt_return
      groups   = lt_groups.

  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.   "No W or S
  IF NOT lt_return IS INITIAL.
*   fatal error
    READ TABLE lt_return WITH KEY type = 'A'
                              INTO ls_return.
    IF sy-subrc EQ 0 .
      RAISE EXCEPTION TYPE cx_hrrcf_address_service
        EXPORTING
          textid =
             cx_hrrcf_address_service=>cx_address_add_failure
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF .
*   User error
    READ TABLE lt_return WITH KEY type = 'E'
                          TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      EXIT.  "change control flow
    ENDIF.
  ENDIF .

  CHECK lt_groups IS NOT INITIAL.

  LOOP AT lt_groups INTO ls_group.
    ls_rel_object-sclas = 'UG'.
    ls_rel_object-sobid = ls_group-usergroup.

    APPEND ls_rel_object TO pt_usergroup.
  ENDLOOP.

ENDMETHOD.


METHOD get_user_from_usergroup.

  DATA: lv_usergroup    TYPE usgrp_user-usergroup,
        lt_user         TYPE TABLE OF usgrps_usr,
        ls_user         TYPE usgrps_usr,
        ls_rel_obj_user TYPE rcf_s_rel_object.


  CHECK ps_usergroup-sclas EQ 'UG'.

  lv_usergroup = ps_usergroup-sobid.

  CALL FUNCTION 'SUSR_USER_GROUP_USERS_GET'
    EXPORTING
      usergroup = lv_usergroup
    TABLES
      users     = lt_user.

  ls_rel_obj_user-sclas = 'US'.
  LOOP AT lt_user INTO ls_user.
    ls_rel_obj_user-sobid = ls_user.
    APPEND ls_rel_obj_user TO pt_user.
  ENDLOOP.

ENDMETHOD.


METHOD get_user_fullname.
* Added via note 1723140
* Changed via note 1794186
  DATA: lt_user_tmp TYPE rcf_t_rec_team,
        ls_user_tmp TYPE p5131.

  DATA: ls_rec_team TYPE p5131,
        ls_rec_team_txt TYPE rcf_s_rec_team_txt.

  DATA: lv_uname TYPE syuname.

  DATA: lo_mass_access TYPE REF TO if_hrrcf_candidate_mass_access.

  DATA: lt_users       TYPE rcf_t_user,
        lt_users_name  TYPE rcf_t_user_list,
        ls_users_name  TYPE rcf_s_user_list.

  LOOP AT pt_rec_team INTO ls_user_tmp.
    lv_uname = ls_user_tmp-sobid.
    APPEND lv_uname TO lt_users.
    CLEAR lv_uname.
  ENDLOOP.

  SORT lt_users.
  DELETE ADJACENT DUPLICATES FROM lt_users.

* Get the reference to mass access object
  CALL METHOD cl_hrrcf_mass_access=>get_instance
    IMPORTING
      eo_candidate_mass_access = lo_mass_access.

* Get the list of fullnames using user name
  CALL METHOD lo_mass_access->get_cand_fullname
    EXPORTING
      pt_users    = lt_users
      ps_language = p_langu
    IMPORTING
      pt_username = lt_users_name.

  SORT lt_users_name BY user.

* Assign full names to output table.
  LOOP AT pt_rec_team INTO ls_rec_team .
    MOVE-CORRESPONDING ls_rec_team TO ls_rec_team_txt.
    lv_uname = ls_rec_team-sobid.

    READ TABLE lt_users_name INTO ls_users_name
      WITH KEY user = lv_uname BINARY SEARCH.

    IF sy-subrc = 0.
      ls_rec_team_txt-fullname = ls_users_name-fullname.
      CLEAR ls_users_name.
    ENDIF.

    APPEND ls_rec_team_txt TO pt_rec_team_txt.
    CLEAR ls_rec_team_txt.
  ENDLOOP.
ENDMETHOD.


method get_verification_status.

  data: lo_cand_info type ref to   cl_hrrcf_candidate_info,
        lt_cand      type table of p5102,
        ls_cand      type p5102,
        lt_cand_txt  type rcf_t_cand_info_text,
        ls_cand_txt  type rcf_s_cand_info_text,
        ls_ret2      type bapiret2,
        lv_msg_par1  type symsgv,
        lv_verification type rcf_verification_status.

  clear: ev_verification_status.

  cl_hrrcf_candidate_info=>get_instance(
    exporting
      hrobject = is_candidate_hrobject
    importing
      instance = lo_cand_info ).

  lo_cand_info->get_records_by_date(
    exporting
      date             = sy-datum
    importing
      infotype_records = lt_cand ).

  IF lt_cand IS NOT INITIAL.
    read table lt_cand index 1 into ls_cand.
    if sy-subrc is not initial.
      lv_msg_par1 = is_candidate_hrobject.
      if 1 = 2.
        message e073(hrrcf0001) with is_candidate_hrobject.
      endif.
      raise exception type cx_hrrcf
        exporting
          message_type   = 'E'
          message_class  = 'HRRCF0001'
          message_number = 073
          message_par1   = lv_msg_par1.
    endif.
    ev_verification_status = ls_cand-verification.
  ELSE.
    SELECT SINGLE verification FROM hrp5102 INTO lv_verification
      WHERE plvar = is_candidate_hrobject-plvar AND otype = is_candidate_hrobject-otype AND objid = is_candidate_hrobject-objid.
    if sy-subrc is not initial.
     lv_msg_par1 = is_candidate_hrobject.
     raise exception type cx_hrrcf
       exporting
         message_type   = 'E'
         message_class  = 'HRRCF0001'
         message_number = 036
         message_par1   = lv_msg_par1.
    endif.
    ev_verification_status = lv_verification.
  ENDIF.

endmethod.


METHOD insert_note_for_candidate.

  DATA:
    lo_candidate TYPE REF TO cl_hrrcf_candidate.

  CALL METHOD cl_hrrcf_candidate=>get
    EXPORTING
      id        = is_cand_hrobject-objid
    IMPORTING
      candidate = lo_candidate.

  CALL METHOD lo_candidate->insert_note
    EXPORTING
      iv_note = iv_note.

ENDMETHOD.


METHOD is_cand_of_current_user.
* -------------------------------------------------------------------
* This method checks, whether a Candidate HROBJECT actually
* belongs to the user who is currently logged in.
* -------------------------------------------------------------------

  DATA: l_uname TYPE syuname.

  DATA  l_cp_p      TYPE subtyp VALUE 'B209'.
  DATA  lv_lines    TYPE i.
  DATA  ls_hrobjid  TYPE hrobject.
  DATA  ls_cand     TYPE hrobject.
  DATA  ls_p1001    TYPE p1001.
  DATA  lo_cand1 TYPE REF TO cl_hrrcf_candidate.
  DATA  lo_cand2 TYPE REF TO cl_hrrcf_candidate.
  DATA  lo_ex    TYPE REF TO cx_root.
  DATA  lt_hri1001  TYPE p1001tab.

  TRY.
      CALL METHOD get_candidate
        EXPORTING
          ps_cand_hrobject = is_cand
        IMPORTING
          p_uname          = l_uname.
    CATCH cx_hrrcf.
  ENDTRY.

  TRY.
   CALL METHOD cl_hrrcf_candidate=>get
     EXPORTING
       id        = is_cand-objid
     IMPORTING
       candidate = lo_cand1.
  CATCH cx_root INTO lo_ex.
*     write exception to slg1
      cl_hrrcf_exception_handler=>write_exception_log( ex = lo_ex ).
  ENDTRY.

* Note 1570225 - Code to handle Multiple employement scenario
  IF lo_cand1 IS BOUND.
    IF NOT lo_cand1->personid IS INITIAL.
      ls_hrobjid-plvar = is_cand-plvar.
      ls_hrobjid-otype = 'CP'.
      ls_hrobjid-objid = lo_cand1->personid.

      CALL METHOD cl_hrrcf_object_buffer=>read_relationship
          EXPORTING
            pv_isubty    = l_cp_p
            ps_ihrobject = ls_hrobjid
          IMPORTING
            pt_erelation = lt_hri1001.

      DESCRIBE TABLE lt_hri1001 LINES lv_lines.

      IF ( NOT lt_hri1001 IS INITIAL ) AND
         ( lv_lines > 1 ).
        LOOP AT lt_hri1001 INTO ls_p1001.

            ls_cand-objid = ls_p1001-sobid.

            IF ( NOT lo_cand1->employeeid IS INITIAL ) AND
               ( lo_cand1->employeeid EQ ls_cand-objid ).
             CONTINUE.
            ENDIF.

            TRY.
             CALL METHOD cl_hrrcf_candidate=>get
               EXPORTING
                 employeeid  = ls_cand-objid
               IMPORTING
                 candidate   = lo_cand2.
            CATCH cx_root INTO lo_ex.
*     write exception to slg1
            cl_hrrcf_exception_handler=>write_exception_log( ex = lo_ex ).
            ENDTRY.

            IF lo_cand2 IS BOUND.
              rv_is_current_user = abap_true.
              RETURN.
            ENDIF.

            CLEAR : lo_cand2,ls_p1001.

        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDIF.

  IF l_uname = sy-uname.
    rv_is_current_user = abap_true.
  ELSE.
    rv_is_current_user = abap_false.
  ENDIF.

ENDMETHOD.


METHOD is_deregistered.
*
* Author: HGB
*
* This method checks if a candidate is deregistered.
*
  DATA: lo_candidate TYPE REF TO cl_hrrcf_candidate,
        lo_ex        TYPE REF TO cx_hrrcf.
*
  p_is_deregistered = false.
*
  TRY.
*
      IF ps_cand_hrobject IS SUPPLIED.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            id        = ps_cand_hrobject-objid
          IMPORTING
            candidate = lo_candidate.
      ELSE.
        CALL METHOD cl_hrrcf_candidate=>get
          EXPORTING
            user      = sy-uname
          IMPORTING
            candidate = lo_candidate.
      ENDIF.
*
      CALL METHOD lo_candidate->is_deregistered
        RECEIVING
          p_deregistered = p_is_deregistered.
*
*   Exception handling
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
*
ENDMETHOD.


method IS_PERNR_VALID.

  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.
  DATA lv_is_employee TYPE boole_d.
  is_valid = abap_false.

  TRY.
      CALL METHOD cl_hrrcf_candidate=>get(
                    EXPORTING employeeid = employeeid
                    IMPORTING candidate  = lo_candidate ).
      lv_is_employee = lo_candidate->is_employee( ).

      is_valid = lv_is_employee.
    CATCH cx_root.
      is_valid = abap_false.
  ENDTRY.

ENDMETHOD.


METHOD maintain_cand_role .
*Author:BM
*This method assigns the role to the specific user.This method is used
*by the administrator tool as a part of user maintenance.

  DATA ls_role         TYPE t77rcf_role.
  DATA ls_ref_user     TYPE bapirefus.
  DATA ls_ref_userx    TYPE bapirefusx.
  DATA ls_return       TYPE bapiret2.
  DATA lt_return       TYPE TABLE OF bapiret2.

  DATA lo_exception      TYPE REF TO  cx_hrrcf .

  CHECK NOT p_user IS INITIAL.
  CHECK NOT p_role IS INITIAL.
  TRY.

*   Get the reference user for the corresp 'role'.
      CALL METHOD cl_hrrcf_t77rcf_role=>get_role
        EXPORTING
          role        = p_role
        IMPORTING
          t77rcf_role = ls_role.                    "Contains refuser

      IF NOT ls_role-refus IS INITIAL.

        ls_ref_user-ref_user = ls_role-refus.
        ls_ref_userx-ref_user = 'X' .

*   assign role to the user
        CALL FUNCTION 'BAPI_USER_CHANGE'
          EXPORTING
            username  = p_user
            ref_user  = ls_ref_user
            ref_userx = ls_ref_userx
          TABLES
            return    = lt_return.
*keep only A and E type messages
        DELETE lt_return WHERE type NE 'E' AND type NE 'A'.

        IF NOT lt_return IS INITIAL.
          APPEND LINES OF lt_return TO pt_return.
        ENDIF.
      ENDIF.

    CATCH cx_hrrcf INTO lo_exception.
    CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf.

  ENDTRY.

ENDMETHOD.


METHOD maintain_cand_settings .

*Author:BM

*This method saves the user settings(date format, decial format and
*printer options) for a particular user

  DATA :lo_ex TYPE REF TO cx_hrrcf,
  lv_user TYPE syuname,
  lo_candidate TYPE REF TO cl_hrrcf_candidate,
  lt_return TYPE bapirettab.


  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
  ELSE .
    lv_user = sy-uname.
  ENDIF.


*maintain default settings
  TRY.

      CALL METHOD cl_hrrcf_user_settings=>maintain_defaults
        EXPORTING
          p_user       = lv_user
          ps_defaults  = ps_defaults
          ps_defaultsx = ps_defaultsx
        IMPORTING
          pt_return    = lt_return.

      IF NOT lt_return IS INITIAL.
        pt_return = lt_return.
      ELSE.
        CLEAR pt_return.
      ENDIF.

    CATCH cx_hrrcf_personalization INTO lo_ex .
      CLEAR pt_return.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
      RAISE EXCEPTION TYPE cx_hrrcf .

  ENDTRY.

ENDMETHOD.


METHOD maintain_pref_data_over .
*Author:BM

*This method maintains the preferred data overview format of a candidate

*  DATA :lo_ex TYPE REF TO cx_hrrcf,
  DATA : lv_user TYPE syuname,
  lo_candidate TYPE REF TO cl_hrrcf_candidate.


  IF ps_cand_hrobject IS SUPPLIED.

    CALL METHOD cl_hrrcf_candidate=>get
      EXPORTING
        id        = ps_cand_hrobject-objid
      IMPORTING
        candidate = lo_candidate.

    lv_user = lo_candidate->user.
  ELSE .
    lv_user = sy-uname.
  ENDIF.


* maintain the preferred data overview format
*---------------------------------------------------

*This methods sets the pref_data_overview for the user

  CALL METHOD cl_pers_admin=>set_data
    EXPORTING
      p_pers_key          = 'HRRCF_PREF_DATA_OVER_FORMAT'
      p_uname             = lv_user
      p_pers_data         = p_pref_data_over
    EXCEPTIONS
      pers_key_not_found  = 1
      data_type_error     = 2
      user_does_not_exist = 3
      not_set_to_default  = 4
      OTHERS              = 5.

*error in setting the data overview

  IF sy-subrc <> 0.

    IF 1 EQ 2.
*   necessary for where-used list
      MESSAGE e121(hrrcf0001) WITH 'CL_HRRCF_PERS_ADMIN'
                                 'MAINTAIN_PREF_DATA_OVERVIEW'  .
    ENDIF.
*An error occurred while getting data

    RAISE EXCEPTION TYPE cx_hrrcf_personalization
          EXPORTING
            textid =
                cx_hrrcf_personalization=>cx_per_set_data
            message_type   = 'E'
            message_class  = 'HRRCF0001'
            message_number = '121'
            message_par1   = 'CL_HRRCF_PERS_ADMIN'
            message_par2   = 'MAINTAIN_PREF_DATA_OVERVIEW'.

  ENDIF.

*
*  TRY.
*      CALL METHOD cl_hrrcf_pers_admin=>maintain_pref_data_overview
*        EXPORTING
*          p_user           = lv_user
*          p_pref_data_over = p_pref_data_over.
*
*    CATCH cx_hrrcf_personalization INTO lo_ex.
*      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
*        EXPORTING
*          ex = lo_ex.
*      RAISE EXCEPTION TYPE cx_hrrcf .
*
*  ENDTRY.


ENDMETHOD.


METHOD on_cand_activity_changed.

  FIELD-SYMBOLS:
    <ls_wplog>       TYPE wplog,
    <ls_general>     TYPE rcf_s_act_infotype_general.

  DATA:
    lo_abstract_act  TYPE REF TO cl_hrrcf_abstract_activity,
    lt_after_image   TYPE wplog_tab,
    ls_before_image  TYPE wplog,
    ls_after_image   TYPE wplog,
    lv_before_idx    TYPE i,
    lv_after_idx     TYPE i,
    ls_pnnnn         TYPE rcf_s_act_infotype_general,
    lt_new           TYPE rcf_t_act_infotype_general,
    ls_new           TYPE rcf_s_act_infotype_general,
    lt_old           TYPE rcf_t_act_infotype_general,
    lo_ex            TYPE REF TO cx_root.

  TRY.
      lo_abstract_act ?= ir_infotype.

      CALL METHOD lo_abstract_act->get_records
        IMPORTING
          infotype_records = lt_after_image.

      LOOP AT lt_after_image ASSIGNING <ls_wplog>.
        CLEAR ls_pnnnn.
        CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
          EXPORTING
            wplog = <ls_wplog>
          IMPORTING
            pnnnn = ls_pnnnn.
        APPEND ls_pnnnn TO lt_new.
      ENDLOOP.

      LOOP AT it_before_image ASSIGNING <ls_wplog>.
        CLEAR ls_pnnnn.
        CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
          EXPORTING
            wplog = <ls_wplog>
          IMPORTING
            pnnnn = ls_pnnnn.
        APPEND ls_pnnnn TO lt_old.
      ENDLOOP.

      LOOP AT lt_new ASSIGNING <ls_general>.
        READ TABLE lt_old WITH KEY act_guid = <ls_general>-act_guid
            TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
*--       Inserted record found
          CALL METHOD cl_hrrcf_activity_bl=>maintain_rd_last_act
            EXPORTING
              is_hrobject    = ir_infotype->hrobject
              iv_opera       = insert
              is_act_general = <ls_general>.
        ENDIF.
      ENDLOOP.

      LOOP AT lt_old ASSIGNING <ls_general>.
        lv_before_idx = sy-tabix.
        READ TABLE lt_new WITH KEY act_guid = <ls_general>-act_guid
              INTO ls_new.
        IF sy-subrc = 0.
          lv_after_idx = sy-tabix.
*--       Compare wplogs
          READ TABLE it_before_image INDEX lv_before_idx INTO ls_before_image.
          READ TABLE lt_after_image INDEX lv_after_idx INTO ls_after_image.
          IF ls_before_image <> ls_after_image.
*--         Changed record found.
            CALL METHOD cl_hrrcf_activity_bl=>maintain_rd_last_act
              EXPORTING
                is_hrobject    = ir_infotype->hrobject
                iv_opera       = modify
                is_act_general = ls_new.
          ENDIF.
        ELSE.
*--       Deleted record found
          CALL METHOD cl_hrrcf_activity_bl=>maintain_rd_last_act
            EXPORTING
              is_hrobject = ir_infotype->hrobject
              iv_opera    = delete.
        ENDIF.
      ENDLOOP.

    CATCH cx_root INTO lo_ex.
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = lo_ex.
  ENDTRY.

ENDMETHOD.


method register .
*
* Additions: AS, CS
*
* This method registers a candidate
*
  data lo_register            type ref to cl_hrrcf_candidate_register.
*  DATA lo_exception           TYPE REF TO cx_hrrcf.
  data lt_return              type bapirettab.
  data: lv_rfc_dest           type rfcdest.

  if p_self_reg eq true    and
     p_password is initial.
*   Preliminary; should not occur
    raise exception type cx_hrrcf.
  endif.
*
  create object lo_register.
*
  call method lo_register->register_external
    exporting
      centraldataperson     = ps_centraldataperson
      centraldata           = ps_centraldata
      p_email               = p_email
      p_alias               = p_alias
      p_password            = p_password
      p_privacy_status      = p_privacy_status
      p_self_reg            = p_self_reg
      p_verification_status = p_verification_status
      iv_ea_flag            = iv_ea_flag
      p_privacy_version     = p_privacy_version
    importing
      pt_return             = pt_return.

* Check if any errors occured:
  loop at pt_return transporting no fields where type = 'A' or
                                                 type = 'E'.
    return.
  endloop.

* web dynpro user interface is used for candidates
  if cl_hrrcf_services_general=>check_usage_wd_ui( ) = abap_true.
    call method cl_hrrcf_services_general=>get_ui_destination
      receiving
        rv_rfc_dest = lv_rfc_dest.

    if lv_rfc_dest is not initial and lv_rfc_dest ne 'NONE'.

      check lo_register->candidate is bound.

      call function 'HRRCF_WD_CREATE_FRONTEND_USER'
        destination lv_rfc_dest
        exporting
          iv_user               = lo_register->candidate->user
          iv_alias              = lo_register->alias
          iv_firstname          = ps_centraldataperson-firstname
          iv_lastname           = ps_centraldataperson-lastname
          iv_middlename         = ps_centraldataperson-middlename
          iv_email              = p_email
          iv_password           = lo_register->password
        exceptions
          system_failure        = 1
          communication_failure = 2
          registration_error    = 3
          others                = 4.

      if sy-subrc <> 0.
*       at least we tried to create it :-(
      endif.

      call function 'RFC_CONNECTION_CLOSE'                  "XEK1170522
        exporting                                           "XEK1170522
          destination = lv_rfc_dest.                        "XEK1170522
    endif.

  endif.

* Start N_2628870
* FIORI user interface is used for candidates
  IF cl_hrrcf_services_general=>check_usage_fiori_ui( ) = abap_true.

      CHECK lo_register->candidate IS BOUND.

      CALL FUNCTION 'HRRCF_FIO_CREATE_FRONTEND_USER'
        EXPORTING
          iv_user               = lo_register->candidate->user
          iv_alias              = lo_register->alias
          iv_firstname          = ps_centraldataperson-firstname
          iv_lastname           = ps_centraldataperson-lastname
          iv_middlename         = ps_centraldataperson-middlename
          iv_email              = p_email
          iv_password           = lo_register->password
        IMPORTING
          et_messages           = lt_return
        EXCEPTIONS
          system_failure        = 1
          communication_failure = 2
          registration_error    = 3
          others                = 4.

      IF sy-subrc <> 0.
*       at least we tried to create it :-(
      ENDIF.
      APPEND LINES OF lt_return TO pt_return.
  ENDIF.
* End N_2628870

  p_generated_password = lo_register->password.
  po_candidate = lo_register->candidate.
*
endmethod.


METHOD register_applicant .

* Additions: AS, PEV

* This method registers an applicant.
*  and sets the logon language as the preferred language

  DATA: lo_register          TYPE REF TO cl_hrrcf_candidate_register,
        lo_exception         TYPE REF TO cx_hrrcf.
  DATA: ls_centraldataperson TYPE        bapibus1006_central_person,
        lt_return            TYPE        bapirettab,
        ls_return            TYPE        bapiret2.


  TRY.
      CREATE OBJECT lo_register.

      MOVE p_lastname TO ls_centraldataperson-lastname.
      MOVE p_firstname TO ls_centraldataperson-firstname.
      MOVE p_middlename TO ls_centraldataperson-middlename.
*     Setting the default correspondance language
      MOVE sy-langu TO ls_centraldataperson-correspondlanguage.

*     register
      CALL METHOD lo_register->register_external
        EXPORTING
          centraldataperson = ls_centraldataperson
          p_email           = p_email
          p_privacy_status  = p_privacy_status
          p_alias           = p_alias
        IMPORTING
          pt_return         = lt_return.

      APPEND LINES OF lt_return TO pt_return.

      CHECK pt_return IS INITIAL .

*     switch to named user
      CALL FUNCTION 'SUSR_INTERNET_USERSWITCH'
        EXPORTING
          alias                       = lo_register->alias
          password                    = lo_register->password
        EXCEPTIONS
          current_user_not_servicetyp = 1
          more_than_one_mode          = 2
          internal_error              = 3
          OTHERS                      = 4.

      IF sy-subrc <> 0.
        TRY.
            RAISE EXCEPTION TYPE cx_hrrcf_registration
          EXPORTING
            textid =
                cx_hrrcf_registration=>user_switch
                message_type = sy-msgty
                message_class = sy-msgid
                message_number = sy-msgno
                message_par1 = sy-msgv1
                message_par2 = sy-msgv2
                message_par3 = sy-msgv3
                message_par4 = sy-msgv4.
          CATCH cx_hrrcf INTO lo_exception.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_exception.
            RAISE EXCEPTION TYPE cx_hrrcf_registration.
        ENDTRY.
      ENDIF.

*   exception handling
    CATCH cx_hrrcf INTO lo_exception.
      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
          previous = lo_exception .
  ENDTRY.

ENDMETHOD.


METHOD send_new_verification_mail.

  DATA: ls_return TYPE        bapiret2,
        lo_cand   TYPE REF TO cl_hrrcf_candidate,
        lo_ex     TYPE REF TO cx_hrrcf.

  REFRESH et_return.

  TRY.
* Get candidate
      CALL METHOD cl_hrrcf_candidate=>get
        EXPORTING
          id        = iv_cand_hrobject-objid
        IMPORTING
          candidate = lo_cand.

* Trigger workflow for sending a new verification mail
      IF lo_cand IS BOUND.
* Check user type
        CALL METHOD cl_hrrcf_candidate_admin_bl=>check_user_type
          EXPORTING
            p_user_name = lo_cand->user
          IMPORTING
            ps_return   = ls_return.

        IF ls_return IS NOT INITIAL.
          APPEND ls_return TO et_return.
          RETURN.
        ENDIF.

        lo_cand->new_verif_mail_requested(
          EXPORTING
            iv_appl_exists = iv_appl_exists ).

      ELSE.
        IF 1 = 2 .
          MESSAGE e045(hrrcf0002).
*     Kein registierter Benutzer für die Angaben vorhanden
        ENDIF .
        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'I'
            cl     = 'HRRCF0002'
            number = '045'
          IMPORTING
            return = ls_return.
        APPEND ls_return TO et_return.
        RETURN.
      ENDIF.
    CATCH cx_hrrcf_maintain_object INTO lo_ex.
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      RAISE EXCEPTION TYPE cx_hrrcf.
  ENDTRY.
ENDMETHOD.


METHOD send_password_via_email .

* Additions: AS
* Additions: FR  multiple Bupa's
*            PEV basic authorizations

  DATA ls_return TYPE        bapiret2.
  DATA lo_cand   TYPE REF TO cl_hrrcf_candidate.
  DATA lo_ex     TYPE REF TO cx_hrrcf.
  DATA lt_bupa   TYPE        rcf_t_bu_partner.
  DATA lv_bupa   TYPE        bu_partner.
*  DATA lo_bas    TYPE REF TO cl_hrrcf_address_service.
  DATA lv_alias  TYPE        bapialias.
  DATA lv_user   TYPE        uname.
  DATA lv_email  TYPE        bapibus1006_comm-e_mail.
  DATA lv_number TYPE        i.
  DATA lv_par1   TYPE        symsgv.
  DATA lv_par2   TYPE        symsgv.
  DATA lv_refus_match TYPE   boole_d.

  REFRESH pt_return.

  TRY.
* get candidate
      IF p_user_name CN ' '.
        IF p_use_long_user_name EQ true.
          lv_alias = p_user_name.
          CALL METHOD cl_hrrcf_candidate=>get
            EXPORTING
              alias     = lv_alias
            IMPORTING
              candidate = lo_cand.
        ELSE.
          lv_user = p_user_name.
          CALL METHOD cl_hrrcf_candidate=>get
            EXPORTING
              user      = lv_user
            IMPORTING
              candidate = lo_cand.
        ENDIF.
      ENDIF.

* check consistency
      IF p_email_address IS NOT INITIAL.
        IF lo_cand IS BOUND.
          lv_email = p_email_address.
          lt_bupa = cl_hrrcf_address_service=>get_bupa_by_email(
          lv_email ).
          READ TABLE lt_bupa WITH KEY table_line = lo_cand->partner
                             TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            lv_par1 = p_user_name.
            lv_par2 = p_email_address.
            IF 1 = 2 .
              MESSAGE e027(hrrcf0002) WITH lv_par1 lv_par2.
*Benutzername und E-Mail-Adresse gehören nicht zum selben Benutzer
            ENDIF .
            CALL FUNCTION 'BALW_BAPIRETURN_GET2'
              EXPORTING
                type   = 'I'
                cl     = 'HRRCF0002'
                number = '027'
                par1   = lv_par1
                par2   = lv_par2
              IMPORTING
                return = ls_return.
            APPEND ls_return TO pt_return.
            RETURN.
          ENDIF.
        ELSE.
* no user name / alias supplied -> check only based on email
          lv_email = p_email_address.
          lt_bupa = cl_hrrcf_address_service=>get_bupa_by_email(
          lv_email ).
          DESCRIBE TABLE lt_bupa LINES lv_number.
* check whether email is used only once
          IF lv_number EQ 1.
            READ TABLE lt_bupa INTO lv_bupa INDEX 1.
            CALL METHOD cl_hrrcf_candidate=>get
              EXPORTING
                partner   = lv_bupa
              IMPORTING
                candidate = lo_cand.

* check external / internal call
            IF p_use_long_user_name EQ true.
*            external call
              CALL METHOD lo_cand->get_cand_alias
                RECEIVING
                  ps_alias = lv_alias.

              CALL METHOD cl_hrrcf_candidate_admin_bl=>compare_role  "N_1568421
                EXPORTING
                  iv_username = lo_cand->user
                  iv_role     = '0005'
                IMPORTING
                  ev_match    = lv_refus_match.                      "N_1568421
*

              IF lv_alias IS INITIAL.
                IF 1 = 2 .
                  MESSAGE e045(hrrcf0002).
*     Kein registierter Benutzer für die Angaben vorhanden
                ENDIF .
                CALL FUNCTION 'BALW_BAPIRETURN_GET2'
                  EXPORTING
                    type   = 'I'
                    cl     = 'HRRCF0002'
                    number = '045'
                  IMPORTING
                    return = ls_return.
                APPEND ls_return TO pt_return.
                RETURN.

              ENDIF.

              IF lv_refus_match EQ abap_false.                      "N_1568421
                IF 1 = 2 .
                  MESSAGE e045(hrrcf0002).
*     Kein registierter Benutzer für die Angaben vorhanden
                ENDIF .
                CALL FUNCTION 'BALW_BAPIRETURN_GET2'
                  EXPORTING
                    type   = 'I'
                    cl     = 'HRRCF0002'
                    number = '045'
                  IMPORTING
                    return = ls_return.
                APPEND ls_return TO pt_return.
                RETURN.

              ENDIF.                                               "N_1568421

            ELSE.
*            internal call
*              CALL METHOD lo_cand->get_cand_alias       "PVA 1845794
*                RECEIVING
*                  ps_alias = lv_alias.
*
*              IF lv_alias IS INITIAL.
*                IF 1 = 2 .
*                  MESSAGE e045(hrrcf0002).
**     Kein registierter Benutzer für die Angaben vorhanden
*                ENDIF .
*                CALL FUNCTION 'BALW_BAPIRETURN_GET2'
*                  EXPORTING
*                    type   = 'I'
*                    cl     = 'HRRCF0002'
*                    number = '045'
*                  IMPORTING
*                    return = ls_return.
*                APPEND ls_return TO pt_return.
*                RETURN.
*              ENDIF.
            ENDIF.
          ELSE.
* prevent changing the password of the wrong user
            IF 1 = 2 .
              MESSAGE e079(hrrcf0002).
* E-Mail ist nicht eindeutig. Bitte zusätzlich Benutzername angeben
            ENDIF .
            CALL FUNCTION 'BALW_BAPIRETURN_GET2'
              EXPORTING
                type   = 'I'
                cl     = 'HRRCF0002'
                number = '079'
              IMPORTING
                return = ls_return.
            APPEND ls_return TO pt_return.
          ENDIF.
        ENDIF.
      ENDIF.

* raise exception only if the caught exception is not related to a not
* existing person.
    CATCH cx_hrrcf INTO lo_ex .
      IF lo_ex->textid NE
                cx_hrrcf_maintain_object=>central_person_not_exist.
        cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
        RAISE EXCEPTION TYPE cx_hrrcf.
      ENDIF.
  ENDTRY.

* trigger workflow for password change
  IF lo_cand IS BOUND.

* check user type
    CALL METHOD cl_hrrcf_candidate_admin_bl=>check_user_type
      EXPORTING
        p_user_name = lo_cand->user
      IMPORTING
        ps_return   = ls_return.

    IF ls_return IS NOT INITIAL.
      APPEND ls_return TO pt_return.
      RETURN.
    ENDIF.

    TRY.
        lo_cand->new_password_requested( ).

      CATCH cx_hrrcf_maintain_object INTO lo_ex.
        cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
        RAISE EXCEPTION TYPE cx_hrrcf.
    ENDTRY.
  ELSE.
    IF 1 = 2 .
      MESSAGE e045(hrrcf0002).
*     Kein registierter Benutzer für die Angaben vorhanden
    ENDIF .
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'I'
        cl     = 'HRRCF0002'
        number = '045'
      IMPORTING
        return = ls_return.
    APPEND ls_return TO pt_return.
    RETURN.
  ENDIF.

ENDMETHOD.


METHOD SET_CAND_ID_TO_MEMORY.

  DATA lt_hras_hrobjid TYPE hrbas_hrobjid_table.

  lt_hras_hrobjid = it_cand_objid.

* set candidate OBJIDs into memory
  CALL FUNCTION 'HRTMC_SET_PERSON_DATA'
    EXPORTING
      it_personids     = lt_hras_hrobjid
      iv_no_auth_check = abap_true
      iv_otype         = 'NA'
    IMPORTING
      ev_mem_id        = ev_mem_id.

ENDMETHOD.


METHOD SET_SWITCH_ASSURE_ACTIVE_PERNR.
  "WG/N2202046
  STATICS sr_already_set TYPE REF TO boole_d.
  IF NOT sr_already_set IS BOUND.
    "do not overwrite if already set
    sv_assure_active_pernr_by_dflt = iv_toggle.
    CREATE DATA sr_already_set.
  ENDIF.

ENDMETHOD.


METHOD switch_user .
*
* Author Bilash Biswas 20020802
* Additions: AS
* Additions: FR
*
* This method makes a switch from an internet user to the created user.
*
  DATA lo_exception  TYPE REF TO   cx_hrrcf.
  DATA lt_return     TYPE TABLE OF bapiret2 .
  DATA ls_return     TYPE          bapiret2 .

*
  CALL FUNCTION 'SUSR_INTERNET_USERSWITCH'
    EXPORTING
      alias                       = p_alias
      password                    = p_password
    TABLES
      return                      = lt_return
    EXCEPTIONS
      current_user_not_servicetyp = 1
      more_than_one_mode          = 2
      internal_error              = 3
      OTHERS                      = 4.
*
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'. "No W or S
  IF NOT lt_return IS INITIAL.
    READ TABLE lt_return INTO ls_return INDEX 1.
* user doesn't have an option to react so do not bubble
* up the return message
    IF sy-subrc = 0 .
      RAISE EXCEPTION TYPE   cx_hrrcf_registration
        EXPORTING
          textid = cx_hrrcf_registration=>user_switch
          message_type = ls_return-type
          message_class = ls_return-id
          message_number = ls_return-number
          message_par1 = ls_return-message_v1
          message_par2 = ls_return-message_v2
          message_par3 = ls_return-message_v3
          message_par4 = ls_return-message_v4.
    ENDIF .
  ENDIF .

  IF sy-subrc <> 0.
    TRY.
        RAISE EXCEPTION TYPE cx_hrrcf_registration
      EXPORTING
        textid =
            cx_hrrcf_registration=>user_switch
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.
      CATCH cx_hrrcf INTO lo_exception.
        CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
          EXPORTING
            ex = lo_exception.
        RAISE EXCEPTION TYPE cx_hrrcf_registration.
    ENDTRY.
  ENDIF.
*
ENDMETHOD.
ENDCLASS.