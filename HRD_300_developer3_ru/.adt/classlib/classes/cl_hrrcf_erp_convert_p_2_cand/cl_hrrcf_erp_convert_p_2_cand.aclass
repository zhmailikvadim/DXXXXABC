class CL_HRRCF_ERP_CONVERT_P_2_CAND definition
  public
  final
  create public .

*"* public components of class CL_HRRCF_ERP_CONVERT_P_2_CAND
*"* do not include other source files here!!!
public section.

  interfaces IF_HRRCF_CONSTANTS .

  methods ADD_EMPLOYEES_TO_SYNC
    changing
      !ET_PERNR type RCF_T_PERNRTAB .
  class-methods DETERMINE_USER_EXT_CE
    importing
      !IT_PERSONNEL_ASSIGNMENTS type RCF_T_PERNR
    exporting
      !EV_USER type SYUNAME
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods DO_POST_PROCESSING
    importing
      !IV_BP_NUMBER type BU_PARTNER
      !IV_HR_PERNR type PERNR_D
      !IV_CP type HROBJECT
    changing
      !ET_ERRORS type BAPIRET2_T .
  methods DO_POST_PROCESSING_SHELL
    importing
      !IV_BP_NUMBER type BU_PARTNER
      !IV_HR_PERNR type PERNR_D
      !IV_CP type HROBJECT
    changing
      !ET_ERRORS type BAPIRET2_T .
  methods EXTRACT_IDOC_ITDATA_TO_TABLES
    importing
      !LS_PLOGI type HRPLOGI
      !LT_PNNNN type HROBJSDATA_TAB
    exporting
      !E1P0000 type RCF_T_E1P0000
      !E1P0001 type RCF_T_E1P0001
      !E1P0002 type RCF_T_E1P0002
      !E1P0105 type RCF_T_E1P0105
      !E1P1001 type RCF_T_E1P1001
      !E1P0006 type RCF_T_E1P0006
      !E1P1001Q type RCF_T_E1P1001
      !IS_ACTIVE type BOOLE_D
      !LT_TEMP_P_STAT type T77RCF_P_STAT_TAB .
  methods MAINTAIN_CONTACT_AND_USER_DATA
    importing
      !IV_HR_PERNR type PERNR_D
      !IV_EXTERNAL_COMMIT type BOOLE_D default SPACE
      !IS_P0105 type E1P0105
      !IV_BUPA type BU_PARTNER
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods MAP_ADDITIONAL_FIELDS
    importing
      !IS_E1P0000 type E1P0000
      !IS_E1P0001 type E1P0001
      !IS_E1P0002 type E1P0002
      !IS_E1P0006 type E1P0006
    changing
      !ES_BP_CENTRAL type BAPIBUS1006_CENTRAL
      !ES_BP_CENTRAL_X type BAPIBUS1006_CENTRAL_X
      !ES_BP_PERSON type BAPIBUS1006_CENTRAL_PERSON
      !ES_BP_PERSON_X type BAPIBUS1006_CENTRAL_PERSON_X
      !ES_BP_ADDRESS type BAPIBUS1006_ADDRESS
      !ES_BP_ADDRESS_X type BAPIBUS1006_ADDRESS_X
      !ES_BP_TEL type BAPIADTEL
      !ES_BP_TEL_X type BAPIADTELX
      !ES_BP_FAX type BAPIADFAX
      !ES_BP_FAX_X type BAPIADFAXX
      !ES_BP_SMTP type BAPIADSMTP
      !ES_BP_SMTP_X type BAPIADSMTX .
  methods MERGE_SKILLS_AT_NA_FROM_HR
    importing
      !IV_HR_PERNR type PERNR_D
      !IS_HROBJECT type HROBJECT
    exporting
      !ET_ERRORS type BAPIRET2_T
    raising
      CX_HRRCF .
  methods PP_UPDATE_FROM_PA_INFOTYPE
    importing
      !IV_HR_PERNR type PERNR_D
      !IS_PA_INFOTYPE type E1P0000
      !IO_EMPLOYEE type ref to CL_HRRCF_EMPLOYEE
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods UPDATE_FROM_PA_INFOTYPE
    importing
      !IV_HR_PERNR type PERNR_D
      !IS_PA_INFOTYPE type E1P0000
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods UPDATE_NA_AFTER_CP_EXCHANGE
    importing
      !IM_CANDIDATE_ID type HROBJID
    raising
      CX_HRRCF_MAINTAIN_OBJECT
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
protected section.
*"* protected components of class CL_HRRCF_ERP_CONVERT_P_2_CAND
*"* do not include other source files here!!!
private section.

  aliases FALSE
    for IF_HRRCF_CONSTANTS~FALSE .
  aliases HIGH_DATE
    for IF_HRRCF_CONSTANTS~HIGH_DATE .
  aliases LOW_DATE
    for IF_HRRCF_CONSTANTS~LOW_DATE .
  aliases TRUE
    for IF_HRRCF_CONSTANTS~TRUE .

  data EMPLOYEE type ref to CL_HRRCF_EMPLOYEE .
  constants C_SUBTY_EMAIL type SUBTYP value '0010' ##NO_TEXT.
  constants GC_HRALXSYNC type SYCPROG value 'HRALXSYNC' ##NO_TEXT.

  methods CHECK_BP_EXCHANGE_REQUIRED
    importing
      !BP_HR type BU_PARTNER
    exporting
      !BP_EREC type BU_PARTNER .
  methods CHECK_USER_CHANGE_REQUIRED
    importing
      !IS_E1P0105 type E1P0105
    exporting
      !ET_ERRORS type BAPIRET2_T
      !ET_USER_NAME type BAPIBNAME-BAPIBNAME
      !ET_MAINTENANCE_MODE type CHAR10 .
  methods CONVERT_EXCEPTION
    importing
      !IO_EX type ref to CX_HRRCF
    exporting
      !PT_ERRORS type BAPIRET2_T .
  methods DO_POST_PROCESSING_CE
    importing
      !IV_BP_NUMBER type BU_PARTNER
      !IV_HR_PERNR type PERNR_D
      !IV_CP type HROBJECT
    changing
      !ET_ERRORS type BAPIRET2_T .
  methods DO_POST_PROCESSING_SA
    importing
      !IV_BP_NUMBER type BU_PARTNER
      !IV_HR_PERNR type PERNR_D
      !IV_CP type HROBJECT
    changing
      !ET_ERRORS type BAPIRET2_T .
  methods EXC_DATA_FROM_BPEREC_2_BPHR
    importing
      !BP_EREC type BU_PARTNER
      !BP_HR type BU_PARTNER
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods GET_IT0000_RECORDS
    importing
      !IV_PERNR type PERNR_D
    exporting
      !PT_E1P0000 type HROBJSDATA_TAB
    raising
      CX_HRRCF .
  methods GET_IT0105_RECORDS
    importing
      !IV_PERNR type PERNR_D
    exporting
      !PT_E1P0105 type HROBJSDATA_TAB
    raising
      CX_HRRCF .
  methods GET_USER_SUBTYPE
    returning
      value(RETURN) type SUBTYP .
  methods HR_READ_INFOTYPE
    importing
      value(IMP_PERNR) type PERNR_D
      value(IMP_BEGDA) type BEGDA
      value(IMP_ENDDA) type ENDDA
      value(IMP_PLVAR) type PLVAR
    exporting
      !E1P0000 type E1P0000
      !E1P0001 type E1P0001
      !E1P0002 type E1P0002
      !E1P0006 type E1P0006
      !E1P0105 type E1P0105
      !E1P1001 type E1TP1001 .
  methods MAINTAIN_EMAIL
    importing
      !IV_EMAIL type AD_SMTPADR
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods MAINTAIN_IS_INACTIVE_FLAG
    importing
      !IV_HR_PERNR type PERNR_D
    exporting
      !ET_ERRORS type BAPIRET2_T
    raising
      CX_HRRCF .
  methods MAINTAIN_USER_DATA
    importing
      !IV_MAINTAINCE_MODE type CHAR10
      !IV_USER_NAME type BAPIBNAME-BAPIBNAME
      !IV_EMAIL type AD_SMTPADR
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods PP_CREATE_CANDIDATE
    importing
      !IV_HR_PERNR type PERNR_D
      !IV_CP type HROBJECT
      !IV_BP_NUMBER type BU_PARTNER
    exporting
      !ET_RETURN type BAPIRETTAB
      !ES_EMPL_CAND type T77RCF_EMPL_CAND
    raising
      CX_HRRCF .
  methods PP_DETERMINE_USER
    importing
      !IV_HR_PERNR type PERNR_D optional
      !IT_E1P0000 type RCF_T_E1P0000
    exporting
      !ET_E1P0105 type RCF_T_E1P0105
    raising
      CX_HRRCF .
  methods PP_EXTERNAL_CANDICATE_EXIST
    importing
      !IV_BP_NUMBER type BU_PARTNER
      !IS_EMPL_CAND type T77RCF_EMPL_CAND
    raising
      CX_HRRCF .
  methods PP_FIND_EMPLOYEE_CANDIDATE
    importing
      !IV_CP type HROBJECT
    exporting
      !ES_EMPL_CAND type T77RCF_EMPL_CAND .
  methods PP_GET_E_MAIL
    importing
      !IV_BP_NUMBER type BU_PARTNER
      !IV_HR_PERNR type PERNR_D
    exporting
      !EV_EMAIL type AD_SMTPADR
    raising
      CX_HRRCF .
  methods PP_GET_IT0000_RECORDS
    importing
      !IT_PERSONNEL_ASSIGNMENTS type RCF_T_PERNR optional
    exporting
      !ET_E1P0000 type RCF_T_E1P0000
    raising
      CX_HRRCF .
  methods PP_INIT
    importing
      !IV_HR_PERNR type PERNR_D
      !IV_BP_NUMBER type BU_PARTNER
      !IV_CP type HROBJECT
    exporting
      !EV_RETURN type BOOLE_D .
  methods PP_MAINTAIN_IS_INACTIVE_FLAG
    importing
      !IT_E1P0000 type RCF_T_E1P0000
    exporting
      !ET_ERRORS type BAPIRET2_T
    raising
      CX_HRRCF .
  methods PP_NO_EXTERNAL_CANDICATE_EXIST
    importing
      !IV_HR_PERNR type PERNR_D
      !IV_BP_NUMBER type BU_PARTNER
      !IV_EMAIL type AD_SMTPADR
    exporting
      !ET_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods PP_SYNC_AVAIL_INFOTYPES
    importing
      !IV_HR_PERNR type PERNR_D
      !IV_BP_NUMBER type BU_PARTNER
      !IT_E1P0105 type RCF_T_E1P0105
      !IV_EMAIL type AD_SMTPADR
    exporting
      !ET_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods PP_UPDATE_CANDIDATE
    importing
      !IV_HR_PERNR type PERNR_D
      !IV_BP_NUMBER type BU_PARTNER
    exporting
      !ET_RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  methods PROCESS_USER_EMAIL
    importing
      !IT_E1P0105 type RCF_T_E1P0105
      !IV_EMAIL type AD_SMTPADR
    exporting
      !ET_ERRORS type BAPIRET2_T .
  methods SYNCH_ADDRESS_AND_COMM
    importing
      !IV_BP_NUMBER type BU_PARTNER
    exporting
      !ET_RETURN type BAPIRET2_T
    raising
      CX_HRRCF_ADDRESS_SERVICE .
  methods UPDATE_COMM_DATA
    importing
      !IV_BP type BU_PARTNER
      !IV_PERNR type PERNR_D
    exporting
      !ET_RETURN type BAPIRETTAB .
  methods CHECK_CREATE_CAND_INFO
    exporting
      !ET_ERRORS type BAPIRET2_T
    raising
      CX_HRRCF .
  methods ADJUST_SUP_TEAM_GRP
    importing
      !HROBJECT type HROBJECT .
ENDCLASS.



CLASS CL_HRRCF_ERP_CONVERT_P_2_CAND IMPLEMENTATION.


method ADD_EMPLOYEES_TO_SYNC.

* If you have installed within your ERP System ECC 5.0 or higher the
* complete suite, but You do not want to run SAP E-Recruiting in this
* instance you have at activate the following statement to stop the
* E-Recruiting specific processing.

* check 1 = 0.

endmethod.


METHOD adjust_sup_team_grp.
* Method introduced with Note 2543079

*-- Type declaration
  TYPES: BEGIN OF rec_team_stru,
         mandt TYPE mandt,
         plvar TYPE plvar,
         otype TYPE otype,
         objid TYPE hrobjid,
         subty TYPE subtyp,
         istat TYPE istat_d,
         begda TYPE begdatum,
         endda TYPE enddatum,
         varyf TYPE varyf,
         seqnr TYPE seqnr,
         role  TYPE rcf_role,
         sclas TYPE sclas,
         sobid TYPE sobjid,
         lead  TYPE rcf_lead,
       END OF rec_team_stru.

*-- Data declaration
  DATA : lv_user       TYPE sy-uname.

  DATA : ls_p5131      TYPE p5131,
         ls_user       TYPE rcf_s_sgr_responsible,
         ls_p5152      TYPE p5152,
         ls_sgr_list   TYPE hrobject,
         ls_sgr_team   TYPE rcf_s_sgr_team_txt,
         ls_object     TYPE hrobject,
         ls_relation   TYPE p1001.

  DATA : lt_p5131      TYPE STANDARD TABLE OF p5131,
         lt_rec_lead   TYPE TABLE OF rec_team_stru,
         lt_return     TYPE bapirettab,
         lt_return2    TYPE bapirettab,
         lt_sgr_team   TYPE rcf_t_sgr_team_txt,
         lt_sgr_list   TYPE rcf_t_hrobject,
         lt_object     TYPE hrobject_tab,
         lt_relation   TYPE p1001tab.

  DATA : lo_rec_team_bl TYPE REF TO cl_hrrcf_rec_team_bl,
         lo_supp_bl     TYPE REF TO cl_hrrcf_supp_group_bl,
         lo_candidate   TYPE REF TO cl_hrrcf_candidate,
         lo_exr         TYPE REF TO cx_root,
         lo_ex          TYPE REF TO cx_hrrcf.

  CONSTANTS :  lc_cp_us TYPE subtyp VALUE 'B208'.

  FIELD-SYMBOLS: <rec_lead> TYPE rec_team_stru.

*-- Ensure that this coding is not processed in case Switch is not activated.
  CHECK NOT cl_hrrcf_switch_check=>hrerc_sfws_sc_enh_03( ) IS INITIAL.

*-- ALE integration shall run only in stand alone systems
  CHECK cl_hrrcf_system_check=>is_standalone = if_hrrcf_constants=>true.

  TRY.
*-- Check if the existing CP has a valid Candidate object
      TRY.
          CALL METHOD cl_hrrcf_candidate=>get
            EXPORTING
              id        = hrobject-objid
            IMPORTING
              candidate = lo_candidate.
        CATCH cx_hrrcf INTO lo_ex.
          cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      ENDTRY.

      CHECK lo_candidate IS BOUND.

      IF lo_candidate->user IS INITIAL AND
         lo_candidate->personid IS NOT INITIAL.

        ls_object-plvar = hrobject-plvar.
        ls_object-otype = 'CP'.
        ls_object-objid = lo_candidate->personid.

        APPEND ls_object TO lt_object.

        CALL FUNCTION 'RH_READ_INFTY_1001'
         EXPORTING
            with_stru_auth         = ' '
            istat                  = '1'
            subty                  = lc_cp_us
            begda                  = if_hrrcf_constants=>low_date
            endda                  = if_hrrcf_constants=>high_date
            sort                   = ' '
            with_ev                = 'X'
          TABLES
            i1001                  = lt_relation
            OBJECTS                = lt_object
         EXCEPTIONS
            nothing_found          = 0
            wrong_condition        = 2
            wrong_parameters       = 3
            OTHERS                 = 4.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.

        SORT lt_relation BY begda DESCENDING.
        READ TABLE lt_relation INTO ls_relation INDEX 1.

        lv_user = ls_relation-sobid.

      ELSE.

        lv_user = lo_candidate->user.

      ENDIF.


      CHECK lv_user IS NOT INITIAL.
*-------------------------------------------------*
*--Start of Step ->Support teams Deletion
*-------------------------------------------------*
*--Get all the support team, talent group records for the old user
      SELECT  mandt plvar otype objid subty istat
                  begda endda varyf seqnr role sclas sobid lead
                 INTO CORRESPONDING FIELDS OF TABLE lt_rec_lead
                 FROM hrp5131
                 WHERE plvar = hrobject-plvar     AND
                       otype IN ('NB','NF')       AND
                       begda LE sy-datum          AND
                       endda GE sy-datum          AND
                       sclas EQ 'US'              AND
                       sobid EQ lv_user.

      LOOP AT lt_rec_lead ASSIGNING <rec_lead>.
        MOVE-CORRESPONDING <rec_lead> TO ls_p5131.
        ls_p5131-infty = '5131'.
        APPEND ls_p5131 TO lt_p5131.
      ENDLOOP.

*-- Lead Recruiter and Hiring Manager should not be deleted
*-- Use the Adjust support team solution instead
      DELETE lt_p5131 WHERE lead = 'X'.

      IF lo_rec_team_bl IS NOT BOUND.
        CALL METHOD cl_hrrcf_rec_team_bl=>get_instance
          RECEIVING
            return = lo_rec_team_bl.
      ENDIF.

      TRY.
*--  Perform batch Db operation
          CALL METHOD lo_rec_team_bl->maintain_multiple_rec_teams
            EXPORTING
              p_operation      = 'D'
            IMPORTING
              return           = lt_return
            CHANGING
              infotype_records = lt_p5131.
        CATCH cx_hrrcf_infotype_operation INTO lo_ex.
          cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      ENDTRY.
*-- End of Step ->Support teams Deletion

*------------------------------------------------*
*   Start of Step : Support Groups Deletion
*------------------------------------------------*
      CALL METHOD cl_hrrcf_supp_group_bl=>get_instance
        RECEIVING
          return = lo_supp_bl.

      ls_user-sclas = 'US'.
      ls_user-sobid = lv_user.

*-- Get the list of support groups for the user
      TRY.
          CALL METHOD lo_supp_bl->get_supp_groups_for_user
            EXPORTING
              ps_user     = ls_user
            IMPORTING
              pt_sgr_list = lt_sgr_list.
        CATCH cx_hrrcf INTO lo_ex.
          cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
      ENDTRY.

      LOOP AT lt_sgr_list INTO ls_sgr_list.
*-- Reads Members of Support Group
        TRY.
            CALL METHOD lo_supp_bl->get_supp_group_team
              EXPORTING
                ps_supp_group = ls_sgr_list
              IMPORTING
                pt_sgr_team   = lt_sgr_team.
          CATCH cx_hrrcf INTO lo_ex.
            cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
        ENDTRY.

*-- Replace the old user with new user in the support group
        LOOP AT lt_sgr_team INTO ls_sgr_team WHERE sobid = lv_user.

          MOVE-CORRESPONDING ls_sgr_team TO ls_p5152.

          TRY.
              CALL METHOD lo_supp_bl->maintain_supp_group_team
                EXPORTING
                  ps_5152     = ls_p5152
                  ps_begda    = ls_sgr_team-begda
                  ps_endda    = ls_sgr_team-endda
                  p_operation = 'D'
                  ps_hrobject = ls_sgr_list
                  p_do_checks = ' '
                IMPORTING
                  pt_return   = lt_return2.

            CATCH cx_hrrcf INTO lo_ex.
              cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
          ENDTRY.

          CLEAR : ls_sgr_team , ls_p5152.

        ENDLOOP.


      ENDLOOP.
    CATCH cx_root INTO lo_exr.
      cl_hrrcf_exception_handler=>write_exception_log( lo_exr ).
  ENDTRY.
*--  End of Step  ->Support Groups Deletion

ENDMETHOD.


METHOD check_bp_exchange_required.

  TYPES :
     BEGIN OF address_struc,
       channel TYPE rcf_comm_channel,
       addrnr TYPE ad_addrnum,
       cons_number TYPE ad_consnum,
       available TYPE rcf_comm_available,
     END OF address_struc .

  DATA lt_return              TYPE bapirettab.
*  DATA ls_return              TYPE bapiret2.

*  DATA ls_hrobject TYPE hrobject.
  DATA lo_contact_rules TYPE REF TO cl_hrrcf_contact_rules.
  DATA lt_infty_record TYPE wplog_tab .
  DATA lt_5110_records TYPE rcf_t_contact_rules.
  DATA ls_p5110 TYPE p5110.
  DATA infty_struc    TYPE          address_struc .
  DATA ls_addrnum     TYPE          bapibus1006_addresses_int .
  DATA ls_addressdata TYPE          rcf_s_addressdata_bp .
  DATA lt_addressdata TYPE TABLE OF rcf_s_addressdata_bp .

  DATA ls_but020 TYPE but020.

  DATA lt_addrnum     TYPE TABLE OF bapibus1006_addresses_int .


* get records of IT5110 assigned to candidate
  CALL METHOD cl_hrrcf_contact_rules=>get_instance
    EXPORTING
      hrobject = me->employee->candidate->hrobject
    IMPORTING
      instance = lo_contact_rules.

  TRY.
      CALL METHOD lo_contact_rules->get_records_by_subtype
        EXPORTING
          date             = sy-datum
          subtype          = '0000'
        IMPORTING
          infotype_records = lt_infty_record.
    CATCH cx_hrrcf .                                    "#EC NO_HANDLER
* we will see
  ENDTRY.

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = lt_infty_record
    IMPORTING
      pnnnn_tab = lt_5110_records.

  READ TABLE lt_5110_records INTO ls_p5110 INDEX 1.

  CLEAR infty_struc .
  DO 10 TIMES : VARYING infty_struc-addrnr
                FROM ls_p5110-addrnumber01 NEXT
                ls_p5110-addrnumber02
                VARYING infty_struc-channel
                FROM ls_p5110-channel01 NEXT
                ls_p5110-channel02
                VARYING infty_struc-cons_number
                FROM ls_p5110-consnumber01 NEXT
                ls_p5110-consnumber02
                VARYING infty_struc-available
                FROM ls_p5110-available01 NEXT
                ls_p5110-available02 .
    IF ls_addrnum-addrnumber EQ infty_struc-addrnr .
      MOVE infty_struc-channel TO ls_addressdata-channel .
      MOVE infty_struc-available TO
                ls_addressdata-availability .
      APPEND ls_addressdata TO lt_addressdata .
      EXIT .
    ENDIF .
  ENDDO .

  CHECK lt_addressdata IS NOT INITIAL.

*   Get all the address numbers from the Businesspartner by HR
  CALL FUNCTION 'BUPA_ADDRESSES_GET'
    EXPORTING
      iv_partner   = bp_hr
    TABLES
      et_addresses = lt_addrnum
      et_return    = lt_return.
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.     "No W or S


  LOOP AT lt_addrnum INTO ls_addrnum.

    READ TABLE lt_addressdata WITH KEY addrnr = ls_addrnum-addrnumber
    TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.
* BP from HR and candidate data form IT5110 have a match
* -> no need to exchange the BP
      RETURN.
    ENDIF.

  ENDLOOP.

* no match so exchange BP and determine old BP via but020
  READ TABLE lt_addressdata INTO ls_addressdata INDEX 1.

  SELECT SINGLE * FROM but020 INTO ls_but020
  WHERE addrnumber = ls_addressdata-addrnr.

  bp_erec = ls_but020-partner.


ENDMETHOD.


METHOD CHECK_CREATE_CAND_INFO.
* this method is used to check whether for an already existing
* candidate the required infotype 5102 already exists
* -> if it does not exist we create the missing record     "MELN1617853
  DATA lo_cand_info           TYPE REF TO cl_hrrcf_candidate_info.
  DATA ls_p5102               TYPE p5102.
  DATA lt_p5102               TYPE TABLE OF p5102.


  CLEAR et_errors.

  CALL METHOD cl_hrrcf_candidate_info=>get_instance
    EXPORTING
      hrobject = employee->candidate->hrobject
    IMPORTING
      instance = lo_cand_info.

* check whether IT5102 exists
  CALL METHOD lo_cand_info->get_records
    IMPORTING
      infotype_records = lt_p5102.

  IF lt_p5102 IS INITIAL.
    CLEAR ls_p5102.
    ls_p5102-begda  = employee->candidate->create_date.
    ls_p5102-endda  = high_date.
    ls_p5102-status = '0'.     " not seeking

    CALL METHOD lo_cand_info->insert_record
      EXPORTING
        check_only      = space
      IMPORTING
        return          = et_errors
      CHANGING
        infotype_record = ls_p5102.
  ENDIF.

ENDMETHOD.


METHOD check_user_change_required.

  DATA lv_user           TYPE bapibname-bapibname.
  DATA ls_error          TYPE bapiret2.
  DATA lv_error_par2     TYPE symsgv.
  DATA lv_error_par1     TYPE symsgv.
  DATA lo_candidate_tmp  TYPE REF TO cl_hrrcf_candidate.
  DATA lo_ex             TYPE REF TO cx_hrrcf.

  CLEAR et_maintenance_mode.
* The varaible may have the following values:
* 'nu':    (new user) based on IT0105 should be created
* 'nuaus': (new user and assign US): (Not supported)
*          New user needs to be created. Since IT0105 doesn't
*          exist we would need to create one IT0105-record afterwards
*          which isn't a good idea.
*          Instead we write a message to the log and leave the varaible
*          initial.
* '':      see comment for 'nuaus'
*          This value is also set if the user in IT0105 is assigned to
*          another candidate
* 'cp':    (check profile): Based on IT0105 a user is found and not
*          assigned to another candidate

* Get the user name from IT 105, if available.
  IF is_e1p0105 IS NOT INITIAL.       "User exists in IT
*
    IF NOT is_e1p0105-usrid IS INITIAL.
      lv_user = is_e1p0105-usrid.
    ELSEIF NOT is_e1p0105-usrid_long IS INITIAL.
      lv_user = is_e1p0105-usrid_long.
    ENDIF.
*   Check if this user already exists in e-Recruiting
    CALL FUNCTION 'BAPI_USER_EXISTENCE_CHECK'
      EXPORTING
        username = lv_user
      IMPORTING
        return   = ls_error.
*
    IF ls_error-number EQ '124'.    "User does not exist
      et_user_name = lv_user.
* New user need's to be created
      et_maintenance_mode = 'nu'.
      RETURN.
    ENDIF.
*
  ELSE.
* No username available in IT 105. Create own user
**********************************************************************
* In the integrated system we must not 'invent' a user
* So we simply write a message to the log
**********************************************************************
    IF 1 = 2.
      MESSAGE e215(hrrcf0001) WITH '&' '&'.
*   Kandidat &1 mit der Personalnummer &2 hat keinen Benutzer im
*   infotyp 0105
    ENDIF.
    lv_error_par1 = me->employee->candidate->id.
    lv_error_par2 = me->employee->employeeid.

    TRY.
        RAISE EXCEPTION TYPE cx_hrrcf
             EXPORTING
*                hrobject       = ls_hrobject
*                infotype       = <ls_infty_record>
                message_type   = 'E'
                message_class  = 'HRRCF0001'
                message_number = '215'
                message_par1   = lv_error_par1
                message_par2   = lv_error_par2.
*                message_par3   = ls_error-msgv3
*                message_par4   = ls_error-msgv4      .
      CATCH cx_hrrcf INTO lo_ex.
        cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
        RETURN.
    ENDTRY.
*
*    lv_user = 'EE00000000'.
*    WRITE me->pernr TO lv_user+2(8).
**   Check if this user already exists in e-Recruiting
*    CALL FUNCTION 'BAPI_USER_EXISTENCE_CHECK'
*      EXPORTING
*        username = lv_user
*      IMPORTING
*        return   = ls_error.
**
*    IF ls_error-number EQ '124'.    "User does not exist
*      et_user_name = lv_user.
** New user need's to be created and assigned via a relation
*      et_maintenance_mode = 'nuaus'.
*      RETURN.
*    ENDIF.
*
  ENDIF.
*
*   Check if the user(id) is already assigned to an employee
  TRY.
      CALL METHOD cl_hrrcf_candidate=>get
        EXPORTING
          user      = lv_user
        IMPORTING
          candidate = lo_candidate_tmp.
    CATCH cx_hrrcf.                                     "#EC NO_HANDLER
* no reaction, existence check only
  ENDTRY.
*
  IF lo_candidate_tmp IS BOUND.
    IF lo_candidate_tmp->personid NE me->employee->personid.
* employee object and user in question do not match the same candidate
      lv_error_par1 = lv_user.
      lv_error_par2 = lo_candidate_tmp->id.

      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0001'
          number = '050'
          par1   = lv_error_par1
          par2   = lv_error_par2
        IMPORTING
          return = ls_error.
      APPEND ls_error TO et_errors.
      RETURN.
    ENDIF.
*
* just check if the user has the required E-Recruiting profile
    et_user_name        = lv_user.
    et_maintenance_mode = 'cp'.
*
  ENDIF.
*

ENDMETHOD.


METHOD convert_exception.
  CALL METHOD cl_hrrcf_services_general=>map_exception_hy_to_bapiretab
    EXPORTING
      io_ex     = io_ex
    IMPORTING
      pt_errors = pt_errors.
ENDMETHOD.


METHOD determine_user_ext_ce.
  DATA:
    lt_e1p0000                   TYPE rcf_t_e1p0000,
    lt_e1p0105                   TYPE TABLE OF e1p0105,
    ls_e1p0105                   TYPE e1p0105,
    lo_hrsync_to_cand            TYPE REF TO cl_hrrcf_erp_convert_p_2_cand.

  CHECK cl_hrrcf_system_check=>is_standalone = false.

* Create instance
  CREATE OBJECT lo_hrsync_to_cand.

* Read the IT0000 need to set the Active/Inavtive flag and ***********
* to determine the user in CE ****************************************
**********************************************************************
  TRY.
      CALL METHOD lo_hrsync_to_cand->pp_get_it0000_records
        EXPORTING
          it_personnel_assignments = it_personnel_assignments
        IMPORTING
          et_e1p0000               = lt_e1p0000.

      CALL METHOD lo_hrsync_to_cand->pp_determine_user
        EXPORTING
          it_e1p0000 = lt_e1p0000
        IMPORTING
          et_e1p0105 = lt_e1p0105.

* This method return always one USER
      READ TABLE lt_e1p0105 INDEX 1
        INTO ls_e1p0105.

      IF NOT ls_e1p0105-usrid  IS INITIAL.
        ev_user = ls_e1p0105-usrid.
      ELSEIF   NOT ls_e1p0105-usrid_long IS INITIAL.
        ev_user = ls_e1p0105-usrid_long.
      ENDIF.

    CATCH cx_hrrcf.
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation.
  ENDTRY.
ENDMETHOD.


METHOD DO_POST_PROCESSING.


  CONSTANTS c_hralxsync       TYPE sycprog VALUE 'HRALXSYNC'.
*
  DATA lv_email               TYPE ad_smtpadr.
  DATA ls_centraldata         TYPE bapibus1006_central.
  DATA ls_centraldataperson   TYPE bapibus1006_central_person.
  DATA ls_p0105               TYPE hrobjsdata.
  DATA ls_e1p0105             TYPE e1p0105.
  DATA ls_p5102               TYPE p5102 .
  DATA ls_empl_cand           TYPE t77rcf_empl_cand.
  DATA lt_return              TYPE bapirettab.
  DATA lt_p0105               TYPE hrobjsdata_tab.
  DATA lt_e1p0105             TYPE TABLE OF e1p0105.
  DATA lo_ex                  TYPE REF TO cx_hrrcf.
  DATA lo_cand_info           TYPE REF TO cl_hrrcf_candidate_info.
  DATA lo_ext_cand            TYPE REF TO cl_hrrcf_candidate.

*
* This method should run only in a system, where HR and ERP run together
  IF cl_hrrcf_system_check=>is_standalone = true.
    RETURN.
  ENDIF.
*
* We create/update candidates only for PERNR, not CP
  IF iv_hr_pernr  IS INITIAL OR
     iv_bp_number IS INITIAL.
    RETURN.
  ENDIF.
*
  CLEAR: me->employee.
*
* SET LUW-Mode to avoid 'COMMIT WORK' in E-recruiting framework
  cl_hrrcf_simple_main_object=>set_luw_mode( ).
*

  TRY.
*
      CALL METHOD me->get_it0105_records
        EXPORTING
          iv_pernr   = iv_hr_pernr
        IMPORTING
          pt_e1p0105 = lt_p0105.
*
      LOOP AT lt_p0105 INTO  ls_p0105.
        ls_e1p0105 = ls_p0105-sdata.
        IF ls_e1p0105-subty EQ c_subty_email.        "E-mail-assignmet
          IF NOT ls_e1p0105-usrid_long IS INITIAL.
            lv_email = ls_e1p0105-usrid_long.
          ELSE.
            lv_email = ls_e1p0105-usrid.
          ENDIF.
        ENDIF.
        APPEND ls_e1p0105 TO lt_e1p0105.
      ENDLOOP.
*
* Check if this employee(with this EE Id) already exists in EREC
      TRY.
          CALL METHOD cl_hrrcf_employee=>get
            EXPORTING
              employeeid = iv_hr_pernr
            IMPORTING
              employee   = me->employee.
        CATCH cx_hrrcf.                                 "#EC NO_HANDLER
* no reaction, existence check only
      ENDTRY.
*
      IF me->employee IS INITIAL.
* For that PERNR no NA exists
* BP exists for that PERNR, either on DB or just created.
*
* Now we must check if the PERNR was created with a relationship to an
* external candidate. In this case we must not create a new NA but
* assign the old (external) to the new CP (and therefore P)

        CALL METHOD cl_hrrcf_t77rcf_empl_cand=>read_record
          EXPORTING
            pv_employee_id = iv_hr_pernr
          IMPORTING
            ps_record      = ls_empl_cand.
*
        IF ls_empl_cand IS INITIAL.
*
* Since BP isn't created before the employee is hired, not only
* a candidate but also an employee must be created
* centraldataperson and centraldata are mandatory. However,
* since BP exists we do not need to fill these structures, since
* inside of the create-method no BP-update happens
* E-MAIL is optional. If the candidate is created during PA40
* (hire date <= sy-datum) IT0105/0010 isn't maintained when the
* 'employee' is created. However, when the hire date is reached the
* customer must run HRALXSYNC to create BP (and NA). HRALXSYNC is also
* used to create NA if E-Recruiting starts to run in an already
* productive HR environmanet. In both cases IT0105/0010 may exist
* and should be taken into account.
*
          CALL METHOD cl_hrrcf_employee=>create
            EXPORTING
              centraldataperson = ls_centraldataperson
              centraldata       = ls_centraldata
              employeeid        = iv_hr_pernr
              e_mail            = lv_email
              partner           = iv_bp_number
              external_commit   = true
            IMPORTING
              employee          = me->employee
              return            = lt_return.
*
*       Keep only errors of type E or A. Delete the rest.
          DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
          IF NOT lt_return IS INITIAL.
            APPEND LINES OF lt_return TO et_errors.
            RETURN.
          ENDIF.
*
* Together with the object also IT5102 must be created
          CALL METHOD cl_hrrcf_candidate_info=>get_instance
            EXPORTING
              hrobject = me->employee->candidate->hrobject
            IMPORTING
              instance = lo_cand_info.
*
*       Create candidate information
          CLEAR ls_p5102.
*       In general ls_e1p0000-begda would be better for BEGDA,
*       but IT1000 also starts with sy-datum...
          ls_p5102-begda  = sy-datum.
          ls_p5102-endda  = high_date.
          ls_p5102-status = '0'.     " not seeking
          CLEAR lt_return.
*
          CALL METHOD lo_cand_info->insert_record
            EXPORTING
              check_only      = space
            IMPORTING
              return          = lt_return
            CHANGING
              infotype_record = ls_p5102.
*
*       Keep only errors of type E or A. Delete the rest.
          DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
          IF NOT lt_return IS INITIAL.
            APPEND LINES OF lt_return TO et_errors.
            RETURN.
          ENDIF.

        ELSE.                      " i.e. ls_empl_cand is not initial.
* We know that for the imported PERNR no NA exist. Additionally we
* know that the PERNR was hired due to a data transfer, i.e. an
* external candidate exists.
          CALL METHOD cl_hrrcf_candidate=>get
            EXPORTING
              id        = ls_empl_cand-candidate_id
            IMPORTING
              candidate = lo_ext_cand.
*
          lo_ext_cand->exchange_cp_with_hr(
            employeeid = ls_empl_cand-employee_id
            partnerid  = iv_bp_number             ).
*
          CALL METHOD cl_hrrcf_employee=>get
            EXPORTING
              candidateid = ls_empl_cand-candidate_id
*             employeeid  = ls_empl_cand-employee_id
            IMPORTING
              employee   = me->employee.
*
        ENDIF.                     " ls_empl_cand is initial.
*
**********************************************************************
*   IT0000
*   Set 'inactive'-flag according to IT0000-STAT2
        CALL METHOD me->maintain_is_inactive_flag
          EXPORTING
            iv_hr_pernr = iv_hr_pernr
          IMPORTING
            et_errors   = lt_return.
*
*       Keep only errors of type E or A. Delete the rest.
        DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
        IF NOT lt_return IS INITIAL.
          APPEND LINES OF lt_return TO et_errors.
          RETURN.
        ENDIF.
*
        IF sy-cprog EQ c_hralxsync.
* In the case of HRALXSYNC also an update of address, the user,
* user authorization and HR-Skills should be checked
*
**********************************************************************
*   IT0006
*   The update of the address at the BP is done. To make it available
*   in E-Recruiting infotype 5110 must be synchronised
*
          CALL METHOD me->synch_address_and_comm
            EXPORTING
              iv_bp_number = iv_bp_number
            IMPORTING
              et_return    = et_errors.
*
          CHECK et_errors IS INITIAL.
*
**********************************************************************
*   IT0105 // user ID and email
*
          CALL METHOD me->process_user_email
            EXPORTING
              it_e1p0105 = lt_e1p0105
              iv_email   = lv_email
            IMPORTING
              et_errors  = et_errors.
*
          CHECK et_errors IS INITIAL.
*
*********************************************************************
* Initial HR-Skills upload from Person to internal candidate
          CALL METHOD me->merge_skills_at_na_from_hr
                EXPORTING
                  iv_hr_pernr = iv_hr_pernr
                  is_hrobject = me->employee->candidate->hrobject
                IMPORTING
                  et_errors   = et_errors.
        ENDIF.
*
      ELSE.  "if employee is initial.
        IF sy-cprog EQ c_hralxsync.
*       The BAdI is called from HRALXSYNC (and not inside IT-framework)
*       So we should check the employee based on all available infotypes
*       and update it if necessary ('repair-mode')
*
**********************************************************************
*     IT0000
* Check existence of IT5102 and possibly create it
          CALL METHOD me->check_create_cand_info           "MELN1617853
            IMPORTING
              et_errors  = lt_return.

*       Keep only errors of type E or A. Delete the rest.
          DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
          IF NOT lt_return IS INITIAL.
            APPEND LINES OF lt_return TO et_errors.
            RETURN.
          ENDIF.

* Set 'inactive'-flag according to IT0000-STAT2
          CLEAR lt_return.
          CALL METHOD me->maintain_is_inactive_flag
            EXPORTING
              iv_hr_pernr = iv_hr_pernr
            IMPORTING
              et_errors   = lt_return.
*
*       Keep only errors of type E or A. Delete the rest.
          DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
          IF NOT lt_return IS INITIAL.
            APPEND LINES OF lt_return TO et_errors.
            RETURN.
          ENDIF.
*
**********************************************************************
*     IT0001
* In Stand-Alone-System we try to assign the defaut position to CP.
* Since we must not do this inside ERP...
*  ==> no action for IT0001
*
**********************************************************************
*     IT0002
* In Stand-Alone-System we use the data to update the BP. Inside ERP
* BP is updated directly, at least for internal candidates
*  ==> no action for IT0002
*
**********************************************************************
*     IT0006
* In Stand-Alone-System we use IT0006 to update the address via
* business partner. Inside ERP BP is updated directly. However to make
* use of the address in EREC we need an entry in HRP5110
*
          CALL METHOD me->synch_address_and_comm
            EXPORTING
              iv_bp_number = iv_bp_number
            IMPORTING
              et_return    = et_errors.
*
          CHECK et_errors IS INITIAL.
*
**********************************************************************
*     IT0105
* In IT0105 we have two information, one regarding the user assignment
* and one regarding the e-mail assignment.
*
          CALL METHOD me->process_user_email
            EXPORTING
              it_e1p0105 = lt_e1p0105
              iv_email   = lv_email
            IMPORTING
              et_errors  = et_errors.
*
          CHECK et_errors IS INITIAL.
*
**********************************************************************
*     HR-Skills
* First, we need to check, if the candidate has set the flag is_inactive eq false.
* Which means, that the candidate is an active employee.
* Active employee, then read the HR-Skills (1001 with subtype 032) and merge them
* with the candidate skills
          CALL METHOD me->merge_skills_at_na_from_hr
                EXPORTING
                  iv_hr_pernr = iv_hr_pernr
                  is_hrobject = me->employee->candidate->hrobject
                IMPORTING
                  et_errors   = et_errors.

        ELSE.                                               "#EC NEEDED
*       i.e. calling program is not HRALXSYNC
*       Do nothing at this place since all possible updates should be
*       done directly within the BAdI of IT-framework (
*         HRPAD00INFTY   HR_INTEGRAT_TO_EREC
*         HRPAD00INFTYBL HRRCF_HRPAD00INFTYBL_01
*         HRBAS00INFTY   HRRCF00_STORE_HRQUAL         ).
        ENDIF.

      ENDIF. "IF me->employee IS INITIAL.

*
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_ex
        IMPORTING
          pt_errors = et_errors.
*
*     Make sure that exception is also written to SLG1
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
  ENDTRY.
*
* Enable the possibility to write data to data base with COMMIT WORK
  IF et_errors IS INITIAL.
    cl_hrrcf_simple_main_object=>confirm_luw( true ).
*
* If necessary remove also the employee-candidate-pointer
    IF NOT ls_empl_cand IS INITIAL.
      cl_hrrcf_t77rcf_empl_cand=>delete_record(
                     ls_empl_cand-employee_id ).
    ENDIF.
  ELSE.
* Since there is at least one error we won't write buffer to Database,
* but clear the bufffer.
    CALL FUNCTION 'RH_CLEAR_BUFFER'.
    CALL FUNCTION 'RH_CLEAR_PLOG_TAB'.
  ENDIF.

ENDMETHOD.


METHOD do_post_processing_ce.

  DATA:
    ls_empl_cand           TYPE t77rcf_empl_cand,
    lo_ex                  TYPE REF TO cx_hrrcf,
    ev_return              TYPE boole_d.

** Init Post Processing************************************
***********************************************************
  CALL METHOD me->pp_init
    EXPORTING
      iv_hr_pernr  = iv_hr_pernr
      iv_bp_number = iv_bp_number
      iv_cp        = iv_cp
    IMPORTING
      ev_return    = ev_return.

  IF ev_return = true.
    RETURN.
  ENDIF.

  TRY.
** Check if this employee (Central Person) already exists *
***********************************************************
      TRY.
          CALL METHOD cl_hrrcf_employee=>get
            EXPORTING
              personid = iv_cp-objid
            IMPORTING
              employee = me->employee.
        CATCH cx_hrrcf.                                 "#EC NO_HANDLER
* no reaction, existence check only
      ENDTRY.


      IF me->employee IS INITIAL.
******** Create Candidate**********************************
***********************************************************
        CALL METHOD me->pp_create_candidate
          EXPORTING
            iv_hr_pernr  = iv_hr_pernr
            iv_cp        = iv_cp
            iv_bp_number = iv_bp_number
          IMPORTING
            et_return    = et_errors
            es_empl_cand = ls_empl_cand.

      ELSE.  "if employee is initial.
********Update Candidate***********************************
***********************************************************
        CALL METHOD me->pp_update_candidate
          EXPORTING
            iv_hr_pernr  = iv_hr_pernr
            iv_bp_number = iv_bp_number
          IMPORTING
            et_return    = et_errors.

*       adjust user name if name has been changed
        CALL METHOD me->employee->change_cp_us_name "WAR2328503
          EXPORTING
            external_commit = true.

      ENDIF.
*
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_ex
        IMPORTING
          pt_errors = et_errors.
*
*     Make sure that exception is also written to SLG1
      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
  ENDTRY.
*
* Enable the possibility to write data to data base with COMMIT WORK
  IF et_errors IS INITIAL.
    cl_hrrcf_simple_main_object=>confirm_luw( true ).
*
* If necessary remove also the employee-candidate-pointer
    IF NOT ls_empl_cand IS INITIAL.
      cl_hrrcf_t77rcf_empl_cand=>delete_record(
                     ls_empl_cand-employee_id ).
    ENDIF.
  ELSE.
* Since there is at least one error we won't write buffer to Database,
* but clear the bufffer.
    CALL FUNCTION 'RH_CLEAR_BUFFER'.
    CALL FUNCTION 'RH_CLEAR_PLOG_TAB'.
  ENDIF.
ENDMETHOD.


METHOD do_post_processing_sa.
  DATA: lt_p5580         TYPE TABLE OF p5580,
        lt_p5586         TYPE TABLE OF p5586,
        ls_extracted_cp  TYPE rcf_s_ale_ee_inbound_extract,
        ls_return        TYPE bapiret2,
        lv_plvar         TYPE objec-plvar,
        lx_oref         TYPE REF TO cx_hrrcf.

  IF iv_cp IS INITIAL. RETURN. ENDIF.
*   get all data for CP
  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = lv_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

  CALL FUNCTION 'RH_READ_INFTY'
    EXPORTING
      authority            = space
      infty                = '5580'
      istat                = '1'
      plvar                = lv_plvar
      otype                = 'CP'
      objid                = iv_cp-objid
    TABLES
      innnn                = lt_p5580
    EXCEPTIONS
      all_infty_with_subty = 1
      nothing_found        = 0
      no_objects           = 3
      wrong_condition      = 4
      OTHERS               = 5.
  IF sy-subrc NE '0'.
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = sy-msgty
        cl     = sy-msgid
        number = sy-msgno
        par1   = sy-msgv1
        par2   = sy-msgv2
        par3   = sy-msgv3
        par4   = sy-msgv4
      IMPORTING
        return = ls_return.
    APPEND ls_return TO et_errors.
    RETURN.
  ENDIF.
  CALL FUNCTION 'RH_READ_INFTY'
    EXPORTING
      authority            = space
      infty                = '5586'
      istat                = '1'
      plvar                = lv_plvar
      otype                = 'CP'
      objid                = iv_cp-objid
      begda                = sy-datum             "INS NOTE 0001304909
    TABLES
      innnn                = lt_p5586
    EXCEPTIONS
      all_infty_with_subty = 1
      nothing_found        = 0
      no_objects           = 3
      wrong_condition      = 4
      OTHERS               = 5.
  IF sy-subrc NE '0'.
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = sy-msgty
        cl     = sy-msgid
        number = sy-msgno
        par1   = sy-msgv1
        par2   = sy-msgv2
        par3   = sy-msgv3
        par4   = sy-msgv4
      IMPORTING
        return = ls_return.
    APPEND ls_return TO et_errors.
    RETURN.
  ENDIF.

  ls_extracted_cp-central_person_id = iv_cp.
  ls_extracted_cp-it_p5580          = lt_p5580.
  ls_extracted_cp-it_p5586          = lt_p5586.
  TRY.
      CALL METHOD cl_hrrcf_ale_ee_inbound=>process_cp_to_e_recruitment
        EXPORTING
          is_extracted_cp    = ls_extracted_cp
          iv_external_commit = 'X'
          iv_hrsync_bp       = iv_bp_number.

    CATCH cx_hrrcf INTO lx_oref.

* Some exceptions returned in e-recruiting are not related                  "INS Note 0001460529
* directly with error messages. These are placed directly into SLG1         "INS Note 0001460529
      IF lx_oref->message_type   IS INITIAL OR                              "INS Note 0001460529
         lx_oref->message_class  IS INITIAL OR                              "INS Note 0001460529
         lx_oref->message_number IS INITIAL.                                "INS Note 0001460529

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'                                "INS Note 0001460529
          EXPORTING                                                         "INS Note 0001460529
            type   = 'E'                                                    "INS Note 0001460529
            cl     = 'HRRCF0001'                                            "INS Note 0001460529
            number = '000'                                                  "INS Note 0001460529
          IMPORTING                                                         "INS Note 0001460529
            return = ls_return.                                             "INS Note 0001460529

      ELSE.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = lx_oref->message_type
          cl     = lx_oref->message_class
          number = lx_oref->message_number
          par1   = lx_oref->message_par1
          par2   = lx_oref->message_par2
          par3   = lx_oref->message_par3
          par4   = lx_oref->message_par4
        IMPORTING
          return = ls_return.

      ENDIF.                                                                "INS Note 0001460529

      APPEND ls_return TO et_errors.


      RETURN.
  ENDTRY.
ENDMETHOD.


METHOD do_post_processing_shell.

  IF cl_hrrcf_switch_check=>hrerc_sfws_sc_enh_02( ) IS INITIAL.
    CALL METHOD me->do_post_processing
      EXPORTING
        iv_bp_number = iv_bp_number
        iv_hr_pernr  = iv_hr_pernr
        iv_cp        = iv_cp
      CHANGING
        et_errors    = et_errors.
  ELSE.
*   now we are in the CE enabled case
    IF cl_hrrcf_system_check=>is_standalone = false.
      CALL METHOD me->do_post_processing_ce
        EXPORTING
          iv_bp_number = iv_bp_number
          iv_hr_pernr  = iv_hr_pernr
          iv_cp        = iv_cp
        CHANGING
          et_errors    = et_errors.
    ELSE.
      IF sy-cprog = 'HRALXSYNC'.  "only when called from report HRALXSYNC!
        CALL METHOD me->do_post_processing_sa
          EXPORTING
            iv_bp_number = iv_bp_number
            iv_hr_pernr  = iv_hr_pernr
            iv_cp        = iv_cp
          CHANGING
            et_errors    = et_errors.
      ENDIF.
    ENDIF.
  ENDIF.
ENDMETHOD.


METHOD exc_data_from_bperec_2_bphr .

  DATA lt_return TYPE bapiret2_t .
  DATA lo_ex     TYPE REF TO cx_hrrcf.

  TRY.
      CALL METHOD me->employee->candidate->copy_bp_data
        EXPORTING
          partner = bp_erec
        IMPORTING
          return  = lt_return.
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO et_errors.
        RETURN.
      ENDIF.

    CATCH cx_hrrcf INTO lo_ex .

      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_ex
        IMPORTING
          pt_errors = et_errors.

  ENDTRY.

ENDMETHOD.


method EXTRACT_IDOC_ITDATA_TO_TABLES.
* Structures
  DATA ls_pnnnn               TYPE hrobjsdata.
  DATA ls_e1p0000             TYPE e1p0000.
  DATA ls_e1p0001             TYPE e1p0001.
  DATA ls_e1p0002             TYPE e1p0002.
  DATA ls_e1p0105             TYPE e1p0105.
  DATA ls_e1p1001             TYPE e1p1001.
  DATA ls_e1p0006             TYPE e1p0006.
  DATA ls_temp_p_stat         TYPE t77rcf_p_stat.

* Variables
  DATA set_active_flag TYPE boole_d VALUE space.

* tables

  LOOP AT lt_pnnnn INTO ls_pnnnn.
    CASE ls_pnnnn-segnam.
      WHEN 'E1P0000'.                             "Actions
        ls_e1p0000 = ls_pnnnn-sdata.
        CHECK ls_e1p0000-endda GE sy-datum.
        APPEND ls_e1p0000 TO e1p0000.

        IF ls_e1p0000-begda LE sy-datum .
*         This is a current record to be Processed now
          set_active_flag = 'X' .
          IF ls_e1p0000-stat2 NE '3'.               "Not Active EE
            is_active = space.
          ELSE.
            is_active = 'X'.
          ENDIF.
        ELSE .
*         Make entry into internal table. This is future record.
*         move l_employeeid, ls_e1p0000-begda and is_active based
*         on ls_e1p0000-stat2 field into the table t77rcf_p_stat.
          MOVE sy-mandt TO ls_temp_p_stat-mandt .
          MOVE ls_plogi-objid TO ls_temp_p_stat-employee_id .
          MOVE ls_e1p0000-begda TO ls_temp_p_stat-processing_date .
          IF ls_e1p0000-stat2 NE '3' .
            MOVE 'X' TO ls_temp_p_stat-is_inactive .
          ELSE .
            MOVE space TO ls_temp_p_stat-is_inactive .
          ENDIF .
          APPEND ls_temp_p_stat TO lt_temp_p_stat .
        ENDIF .

      WHEN 'E1P0001'.                             "Org.Assignment
        ls_e1p0001 = ls_pnnnn-sdata.
        CHECK ls_e1p0001-endda GE sy-datum.
        APPEND ls_e1p0001 TO e1p0001.
      WHEN 'E1P0002'.                             "Personal Data
        ls_e1p0002 = ls_pnnnn-sdata.
        CHECK ls_e1p0002-endda GE sy-datum.
        APPEND ls_e1p0002 TO e1p0002.
      WHEN 'E1P0105'.                             "Communications
        ls_e1p0105 = ls_pnnnn-sdata.
        CHECK ls_e1p0105-subty = '0001'           "SAP-Username
        OR    ls_e1p0105-subty = '0010'.          "Email-Id
        CHECK ls_e1p0105-endda GE sy-datum.
        APPEND ls_e1p0105 TO e1p0105.
      WHEN 'E1P1001'.                             "Relations
        ls_e1p1001 = ls_pnnnn-sdata.
        CHECK ls_e1p1001-endda GE sy-datum.
        CHECK ls_e1p1001-rsign = 'B'
        AND   ls_e1p1001-relat = '008'          "Only occupation
        OR    ls_e1p1001-relat = '031'          "requirements
        OR    ls_e1p1001-relat = '032'.         "qualifications
        APPEND ls_e1p1001 TO e1p1001.
      WHEN 'E1P0006'.                             "Address
        ls_e1p0006 = ls_pnnnn-sdata.
        CHECK ls_e1p0006-subty = '1   '.          "Permanent Address
        CHECK ls_e1p0006-endda GE sy-datum.
        APPEND ls_e1p0006 TO e1p0006.
      WHEN 'OTHERS'.
        CONTINUE.
    ENDCASE.                                      "Infotype
  ENDLOOP.                                        "AT lt_pnnnn - IDOC

endmethod.


METHOD get_it0000_records.
*
  CONSTANTS hr_read_infotype         TYPE rs38l_fnam
              VALUE 'HR_READ_INFOTYPE'.
  CONSTANTS convert_p0000_to_e1p0000 TYPE rs38l_fnam
              VALUE 'CONVERT_P0000_TO_E1P0000'.
*
  DATA ls_pnnnn            TYPE hrobjsdata.
  DATA ls_e1p0000          TYPE e1p0000.
*
  DATA lt_error            TYPE STANDARD TABLE OF  hrale_err.
  DATA ls_error            TYPE                    hrale_err.
  DATA lo_ex               TYPE REF TO             cx_hrrcf.
*
  DATA lr_infty_record_tab TYPE REF TO data.
  DATA lr_infty_record     TYPE REF TO data.
*
  FIELD-SYMBOLS <lt_infty_record> TYPE STANDARD TABLE.
  FIELD-SYMBOLS <ls_infty_record> TYPE ANY.
*
* systemcheck first because HR DDIC types are not always there
  CHECK cl_hrrcf_system_check=>is_standalone = false.
*
  CREATE DATA lr_infty_record_tab TYPE ('PRELP_TAB').
  ASSIGN lr_infty_record_tab->* TO <lt_infty_record>.
*
  CREATE DATA lr_infty_record TYPE ('PRELP').
  ASSIGN lr_infty_record->* TO <ls_infty_record>.
*
  CLEAR <ls_infty_record>.
  CLEAR <lt_infty_record>.
*
  CALL FUNCTION hr_read_infotype                            "#EC EXISTS
    EXPORTING
      pernr           = iv_pernr
      infty           = '0000'
    TABLES
      infty_tab       = <lt_infty_record>
    EXCEPTIONS
      infty_not_found = 1
      OTHERS          = 2.
  IF sy-subrc <> 0.
    RAISE EXCEPTION TYPE cx_hrrcf
       EXPORTING
*        hrobject = ls_hrobject
        infotype       = <ls_infty_record>
        message_type   = sy-msgty
        message_class  = sy-msgid
        message_number = sy-msgno
        message_par1   = sy-msgv1
        message_par2   = sy-msgv2
        message_par3   = sy-msgv3
        message_par4   = sy-msgv4.
  ENDIF.
*
  LOOP AT <lt_infty_record> INTO <ls_infty_record>.
*
    CALL FUNCTION convert_p0000_to_e1p0000                  "#EC EXISTS
      EXPORTING
        pnnnn_data = <ls_infty_record>
      TABLES
        error_tab  = lt_error
      CHANGING
        sdata_data = ls_e1p0000.
*
    IF lt_error IS INITIAL.
      IF ls_e1p0000-endda GE sy-datum.
        ls_pnnnn-sdata   = ls_e1p0000.
        ls_pnnnn-segnam  = 'E1P0000'.
        APPEND ls_pnnnn TO pt_e1p0000.
      ENDIF.
    ELSE.
      LOOP AT lt_error INTO ls_error.
* write ALL messages to the log
        TRY.
            RAISE EXCEPTION TYPE cx_hrrcf
               EXPORTING
*                hrobject = ls_hrobject
                infotype       = <ls_infty_record>
                message_type   = sy-msgty
                message_class  = sy-msgid
                message_number = sy-msgno
                message_par1   = sy-msgv1
                message_par2   = sy-msgv2
                message_par3   = sy-msgv3
                message_par4   = sy-msgv4.
          CATCH cx_hrrcf INTO lo_ex.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_ex.
        ENDTRY.
      ENDLOOP.
*
* raise only one message (last one)
      RAISE EXCEPTION TYPE cx_hrrcf
         EXPORTING
*          hrobject       = ls_hrobject
          infotype       = <ls_infty_record>
          message_type   = ls_error-msgty
          message_class  = ls_error-msgid
          message_number = ls_error-msgno
          message_par1   = ls_error-msgv1
          message_par2   = ls_error-msgv2
          message_par3   = ls_error-msgv3
          message_par4   = ls_error-msgv4.
    ENDIF.
*
  ENDLOOP.
*
ENDMETHOD.


METHOD get_it0105_records.
  CONSTANTS hr_read_infotype TYPE rs38l_fnam VALUE 'HR_READ_INFOTYPE'.
  CONSTANTS convert_p0105_to_e1p0105
       TYPE rs38l_fnam VALUE 'CONVERT_P0105_TO_E1P0105'.

*systemcheck first because HR DDIC types are not always where
  CHECK cl_hrrcf_system_check=>is_standalone = false.

*
  DATA ls_hrobject TYPE hrobject.
  DATA ls_pnnnn TYPE hrobjsdata.
*
  DATA lt_error TYPE STANDARD TABLE OF  hrale_err.
  DATA ls_error TYPE                    hrale_err.
  DATA lo_ex    TYPE REF TO             cx_hrrcf.
*
  DATA lr_infty_record_tab TYPE REF TO data.
  FIELD-SYMBOLS <lt_infty_record> TYPE STANDARD TABLE.
*
  CREATE DATA lr_infty_record_tab TYPE ('PRELP_TAB').
  ASSIGN lr_infty_record_tab->* TO <lt_infty_record>.
*
  DATA lr_infty_record TYPE REF TO data.
  FIELD-SYMBOLS <ls_infty_record> TYPE ANY.
*
  CREATE DATA lr_infty_record TYPE ('PRELP').
  ASSIGN lr_infty_record->* TO <ls_infty_record>.

  DATA ls_e1p0105 TYPE e1p0105.

  CLEAR <ls_infty_record>.
  CLEAR <lt_infty_record>.
*
  CALL FUNCTION hr_read_infotype                            "#EC EXISTS
    EXPORTING
      pernr           = iv_pernr
      infty           = '0105'
    TABLES
      infty_tab       = <lt_infty_record>
    EXCEPTIONS
      infty_not_found = 1
      OTHERS          = 2.
  IF sy-subrc <> 0.
    RAISE EXCEPTION TYPE cx_hrrcf
       EXPORTING
        hrobject = ls_hrobject
        infotype = <ls_infty_record>
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4      .
  ENDIF.
*
  LOOP AT <lt_infty_record> INTO <ls_infty_record>.
*
    CALL FUNCTION convert_p0105_to_e1p0105                  "#EC EXISTS
      EXPORTING
        pnnnn_data = <ls_infty_record>
      TABLES
        error_tab  = lt_error
      CHANGING
        sdata_data = ls_e1p0105.
*
    IF lt_error IS INITIAL.
      IF ls_e1p0105-endda GE sy-datum.
        ls_pnnnn-sdata = ls_e1p0105.
        ls_pnnnn-segnam = 'E1P0105'.
        APPEND ls_pnnnn TO pt_e1p0105.
      ENDIF.
    ELSE.
      LOOP AT lt_error INTO ls_error.
* write ALL messages to the log
        TRY.
            RAISE EXCEPTION TYPE cx_hrrcf
               EXPORTING
                hrobject = ls_hrobject
                infotype = <ls_infty_record>
                message_type = ls_error-msgty
                message_class = ls_error-msgid
                message_number = ls_error-msgno
                message_par1 = ls_error-msgv1
                message_par2 = ls_error-msgv2
                message_par3 = ls_error-msgv3
                message_par4 = ls_error-msgv4      .
          CATCH cx_hrrcf INTO lo_ex.
            CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
              EXPORTING
                ex = lo_ex.
        ENDTRY.
      ENDLOOP.
* raise only one message (last one)
      RAISE EXCEPTION TYPE cx_hrrcf
         EXPORTING
          hrobject = ls_hrobject
          infotype = <ls_infty_record>
          message_type = ls_error-msgty
          message_class = ls_error-msgid
          message_number = ls_error-msgno
          message_par1 = ls_error-msgv1
          message_par2 = ls_error-msgv2
          message_par3 = ls_error-msgv3
          message_par4 = ls_error-msgv4      .
    ENDIF.

  ENDLOOP.

ENDMETHOD.


METHOD get_user_subtype.
*
  CONSTANTS rh_get_hr_user_subty  TYPE rs38l_fnam
              VALUE 'RH_GET_HR_USER_SUBTY'.
*
  DATA lo_ex TYPE REF TO cx_hrrcf.
*
* systemcheck first because HR DDIC types are not always there
  CHECK cl_hrrcf_system_check=>is_standalone = false.
*
* Determine subtype of IT0105 whith the user assignment
  CALL FUNCTION rh_get_hr_user_subty                        "#EC EXISTS
    EXPORTING
      mandt                 = sy-mandt
    IMPORTING
      hr_subty              = return
    EXCEPTIONS
      subtype_not_available = 1
      OTHERS                = 2.
  IF sy-subrc <> 0.
    return = '0001'.                      "Standard for user assignment
    TRY.
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
*            TEXTID         =
*            PREVIOUS       =
*            HROBJECT       =
*            INFOTYPE       =
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.
      CATCH cx_hrrcf INTO lo_ex.
        cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
    ENDTRY.
  ENDIF.
*
ENDMETHOD.


METHOD hr_read_infotype.

  DATA:
    et_errors        TYPE bapiret2_t,
    lv_function_name TYPE tfdir-funcname,
    ls_ifdir         TYPE tfdir.
*
  lv_function_name = 'HCM_MAP_PNNNN_TO_E1PNNNN'.
*
  SELECT SINGLE * FROM  tfdir INTO ls_ifdir
         WHERE funcname = lv_function_name.
*
  IF sy-subrc = 0.
    CALL FUNCTION lv_function_name
      EXPORTING
        pernr           = imp_pernr
      IMPORTING
        e1p0000         = e1p0000
        e1p0001         = e1p0001
        e1p0002         = e1p0002
        e1p0006         = e1p0006
        et_errors     = et_errors
      TABLES
        e1p1001       = e1p1001
      EXCEPTIONS
        error_message = 1.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
*
  ENDIF.
*
ENDMETHOD.


METHOD maintain_contact_and_user_data.

* Data declaration
  DATA lo_ex                  TYPE REF TO cx_hrrcf.

* Tables
  DATA lt_return              TYPE bapirettab.

* structures
  DATA lv_email               TYPE ad_smtpadr.

* Variables
  DATA lt_bp_email            TYPE TABLE OF bapiadsmtp.
  DATA ls_bp_standard_email   TYPE bapiadsmtp.
  DATA lo_cand_info           TYPE REF TO cl_hrrcf_candidate_info. "WAR1868050
  CLEAR me->employee.

* Check if this employee(with this EE Id) already exists in RCF
  TRY.
      CALL METHOD cl_hrrcf_employee=>get
        EXPORTING
          employeeid = iv_hr_pernr
        IMPORTING
          employee   = me->employee.
    CATCH cx_hrrcf.                                     "#EC NO_HANDLER
* no reaction, existence check only
  ENDTRY.

  TRY.
      IF NOT me->employee IS INITIAL.

*       Determine subtype of IT0105 whith the user assignment
*        lv_user_subty = get_user_subtype( ).

        CASE is_p0105-subty.

*          USER DATA
*          WHEN lv_user_subty.             "usually 0001

*          User changes can only be done in the Report HRALXSYNC, as we
*          can't do this in the new infotype framework(ITF). In the new
*          ITF it is not possible to set up a commit work in between. But
*          user changes causes a commit work. That is the reason, why we
*          don't do a user change in the infotype BAdIs.
*          Therefore run Report HRALXSYNC.

*            CALL METHOD me->check_user_change_required
*              EXPORTING
*                is_e1p0105          = is_p0105
*              IMPORTING
*                et_errors           = et_errors
*                et_user_name        = lv_user
*                et_maintenance_mode = lv_maintenance_mode.
*
*            CHECK et_errors IS INITIAL.
*            IF NOT lv_maintenance_mode IS INITIAL.
*              CALL METHOD me->maintain_user_data
*                EXPORTING
*                  iv_maintaince_mode = lv_maintenance_mode
*                  iv_user_name       = lv_user
*                  iv_email           = lv_email
*                IMPORTING
*                  et_errors          = et_errors.
*              CHECK et_errors IS INITIAL.
*            ENDIF.

*         EMAIL DATA
          WHEN '0010'.
* No CE Read from IT105***********************************************
**********************************************************************
            IF cl_hrrcf_system_check=>is_ce_enabled = false.

              IF NOT is_p0105-usrid_long IS INITIAL.
                lv_email = is_p0105-usrid_long.
              ELSE.
                lv_email = is_p0105-usrid.
              ENDIF.

            ELSE.
* CE anbled***********************************************************
* Read standard email information from BO*****************************
**********************************************************************
              CALL FUNCTION 'BAPI_BUPA_ADDRESS_GETDETAIL'
                EXPORTING
                  businesspartner = iv_bupa
                TABLES
                  bapiadsmtp      = lt_bp_email.

              READ TABLE lt_bp_email  INTO ls_bp_standard_email
                                      WITH KEY std_no = 'X'.

              lv_email = ls_bp_standard_email-e_mail.

            ENDIF.
* Check if e-mail has changed*****************************************
**********************************************************************
            IF lv_email NE me->employee->e_mail.

              CALL METHOD me->employee->change_e_mail
                EXPORTING
                  e_mail          = lv_email
                  external_commit = iv_external_commit "WAR1540502
                IMPORTING
                  return          = lt_return.
*           Keep only errors of type E or A. Delete the rest.
              DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
              IF NOT lt_return IS INITIAL.
                APPEND LINES OF lt_return TO et_errors.
                RETURN.
              ENDIF.

            ENDIF.

          WHEN '0030'.                           "WAR1868050
*           handle private email
            IF NOT is_p0105-usrid_long IS INITIAL.
              lv_email = is_p0105-usrid_long.
            ELSE.
              lv_email = is_p0105-usrid.
            ENDIF.

            CALL METHOD cl_hrrcf_candidate_info=>get_instance
              EXPORTING
                hrobject = me->employee->candidate->hrobject
              IMPORTING
                instance = lo_cand_info.

            CALL METHOD lo_cand_info->update_private_email
              EXPORTING
                ps_email           = lv_email
                pv_external_commit = iv_external_commit
                iv_bupa_upd        = abap_true.                       "N_2374452

        ENDCASE.
      ELSE.     "IF sy-subrc = 0.
        RETURN.
      ENDIF.   "  IF NOT employee IS INITIAL.

    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_ex
        IMPORTING
          pt_errors = et_errors.

      cl_hrrcf_exception_handler=>write_exception_log( lo_ex ).
  ENDTRY.


ENDMETHOD.


METHOD maintain_email.
* For internal candidates check for e-mail update
* Since me->employee->change_e_mail also updates the e-mail of the
* user (SU01) it is mandatory to call method process_user before
*
  DATA:
    lt_return TYPE        bapirettab,
    lt_ret    TYPE        bapiret2_t,
    lo_ex     TYPE REF TO cx_hrrcf_maintain_object.
*
  IF NOT me->employee IS INITIAL.
*
    IF me->employee->candidate->is_employee( ) EQ true     AND
       me->employee->e_mail                    NE iv_email.
*
      TRY.
          CALL METHOD me->employee->change_e_mail
            EXPORTING
              e_mail          = iv_email
              external_commit = true
            IMPORTING
              return          = lt_return.

        CATCH cx_hrrcf_maintain_object INTO lo_ex.
          CALL METHOD me->convert_exception
            EXPORTING
              io_ex     = lo_ex
            IMPORTING
              pt_errors = lt_ret.
          APPEND LINES OF lt_ret TO lt_return.
      ENDTRY.
*
*       Keep only errors of type E or A. Delete the rest.
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO et_errors.
        RETURN.
      ENDIF.
*
    ENDIF.
*
  ENDIF.
*
ENDMETHOD.


METHOD maintain_is_inactive_flag.
*
  DATA lv_is_employee         TYPE boole_d.
  DATA lv_emp_inactive        TYPE rcf_employee_inactive.
*
  DATA ls_p0000               TYPE hrobjsdata.
  DATA ls_e1p0000             TYPE e1p0000.
  DATA ls_p_stat              TYPE t77rcf_p_stat .
*
  DATA lt_p0000               TYPE hrobjsdata_tab.
  DATA lt_p_stat              TYPE t77rcf_p_stat_tab .
*
  DATA lo_cand_info           TYPE REF TO cl_hrrcf_candidate_info.
*
  CLEAR et_errors.
*
* Read IT0000 to set flag 'IS_INACTIVE' in IT5102 and
* entries in T77RCF_P_STAT for future records.
  CALL METHOD me->get_it0000_records
    EXPORTING
      iv_pernr   = iv_hr_pernr
    IMPORTING
      pt_e1p0000 = lt_p0000.
*
  IF lt_p0000 IS INITIAL.
*       Must not occur
    RAISE EXCEPTION TYPE cx_hrrcf.
  ENDIF.
*
  lv_is_employee = me->employee->candidate->is_employee( ).
*
  LOOP AT lt_p0000 INTO ls_p0000.
    ls_e1p0000 = ls_p0000-sdata.
    IF ls_e1p0000-endda LT sy-datum.
*     Record in the past, don't take care
    ELSEIF ls_e1p0000-begda LE sy-datum.
* Current record, check if HRP5102-is_inactive flag on DB needs to be
* changed
      IF  ( lv_is_employee   EQ true  AND
            ls_e1p0000-stat2 NE '3'       )  OR
          ( lv_is_employee   EQ false AND
            ls_e1p0000-stat2 EQ '3'       ).

        IF ls_e1p0000-stat2 = '3'.
          lv_emp_inactive = false.
        ELSE.
          lv_emp_inactive = true.

*         Remove the Email Address                                                  "INS NOTE 0001323296
          CALL METHOD employee->change_e_mail                                       "INS NOTE 0001323296
            EXPORTING                                                               "INS NOTE 0001323296
              e_mail          = space                                               "INS NOTE 0001323296
              external_commit = abap_true                                           "INS NOTE 0001323296
            IMPORTING                                                               "INS NOTE 0001323296
              return          = et_errors.                                          "INS NOTE 0001323296

          IF NOT et_errors IS INITIAL.
            RETURN.
          ENDIF.

*         remove the telephone number
          CALL METHOD employee->change_telephone_data      "MELN2148461
            EXPORTING
              telephone_no    = space
              external_commit = abap_true
            IMPORTING
              return          = et_errors.

          IF NOT et_errors IS INITIAL.
            RETURN.
          ENDIF.
        ENDIF.

        CALL METHOD cl_hrrcf_candidate_info=>get_instance
          EXPORTING
            hrobject = employee->candidate->hrobject
          IMPORTING
            instance = lo_cand_info.

        CALL METHOD lo_cand_info->set_is_inactive_flag
          EXPORTING
            is_inactive = lv_emp_inactive
          IMPORTING
            return      = et_errors.

        IF NOT et_errors IS INITIAL.
          RETURN.
        ENDIF.
        IF lv_emp_inactive = true.                                              "N_2543079
          me->adjust_sup_team_grp( hrobject = employee->candidate->hrobject ).  "N_2543079
        ENDIF.                                                                  "N_2543079
      ENDIF.
*
    ELSE.
*     future record
      CLEAR ls_p_stat.
      ls_p_stat-employee_id     = iv_hr_pernr.
      ls_p_stat-processing_date = ls_e1p0000-begda.
      IF ls_e1p0000-stat2 = '3'. "Employee will be active==> int cand
        ls_p_stat-is_inactive     = false.
      ELSE.                      "Employee won't be active==> ext cand
        ls_p_stat-is_inactive     = true.
      ENDIF.
      APPEND ls_p_stat TO lt_p_stat .
    ENDIF.
*
  ENDLOOP.
*
* Adjust the table T77RCF_P_STAT as per internal table lt_p_stat
* In the integrated system we have all records of IT0000 available.
* Therfore we should delete the records in T77RCF_P_STAT to make
* sure that only those records are stored, which are relevant for the
* future

* Here, in this case (integrated scenario I1 "EREC@ERP") it is fine
* to delete all records for the current employee from T77RCF_P_STAT
* as in the above LOOP all existing IT0000-records between LOW_DATE
* and HIGH_DATE have been evaluated
* -> LT_P_STAT contains all existing future actions        "MELN1609859
  cl_hrrcf_t77rcf_p_stat=>delte_all_records_for_ee( iv_hr_pernr ).
*
* Write all future records to T77RCF_P_STAT
  IF NOT lt_p_stat IS INITIAL.
    cl_hrrcf_t77rcf_p_stat=>insert_records( lt_p_stat ).
  ENDIF.
*
ENDMETHOD.


METHOD maintain_user_data.
*
  CONSTANTS c_usertype            TYPE xuustyp    VALUE 'C'.
  CONSTANTS c_cand_int_role       TYPE rcf_role   VALUE '0001'.
  CONSTANTS c_cand_ext_role       TYPE rcf_role   VALUE '0005'.
  CONSTANTS c_bapiupdate_x        TYPE bapirefusx VALUE 'X'.
  CONSTANTS c_cand_int_class      TYPE rcf_candidate_class VALUE 'I'.
  CONSTANTS c_cand_ext_class      TYPE rcf_candidate_class VALUE 'E'.

  DATA lv_alias                   TYPE bapialias.
  DATA lv_is_employee             TYPE boole_d.
*
  DATA ls_logondata               TYPE bapilogond.
  DATA ls_address                 TYPE bapiaddr3.
  DATA ls_passwd                  TYPE bapipwd.
  DATA ls_role_int                TYPE t77rcf_role.
  DATA ls_role_ext                TYPE t77rcf_role.
  DATA ls_check_role              TYPE t77rcf_role.
  DATA ls_bapi_refuser            TYPE bapirefus.
  DATA ls_ref_user                TYPE bapirefus.
  DATA ls_ref_user_activitygroup  TYPE bapiagr.
  DATA ls_return                  TYPE bapiret2.
  DATA lv_cand_class_new          TYPE rcf_candidate_class.
  DATA lv_update_needed_in_ui     TYPE boole_d.
  DATA lv_update_needed_in_bl     TYPE boole_d.
  DATA lv_create_needed_in_ui     TYPE boole_d.
  DATA lv_create_needed_in_bl     TYPE boole_d.
  DATA ls_uclass                  TYPE bapiuclass.          "WAR1835027
  DATA ls_defaults                TYPE bapidefaul.          "WAR1835027
  DATA lv_ui_user_deletion_needed TYPE boole_d.
  DATA lv_mode                    TYPE char01.
  DATA lv_dest                    TYPE string VALUE 'NONE'.
*
  DATA lt_current_user_activitygroup  TYPE TABLE OF bapiagr.
  DATA lt_ref_user_activitygroup      TYPE TABLE OF bapiagr.
  DATA lt_enhanced_activitygroup      TYPE TABLE OF bapiagr.
  DATA lt_return                      TYPE          bapirettab.
  DATA lt_errors_tmp                  TYPE          hrale_err_tab.
*
  DATA lo_ex                          TYPE REF TO   cx_hrrcf.
*
  FIELD-SYMBOLS
       <errors>                       TYPE          hrale_err.
*
* Get reference user for role internal and external candidate
  TRY.
*   Get the reference user for the internal 'role'.
      CALL METHOD cl_hrrcf_t77rcf_role=>get_role
        EXPORTING
          role        = c_cand_int_role
        IMPORTING
          t77rcf_role = ls_role_int.            "Contains refuser
*   Get the reference user for the external 'role'.
      CALL METHOD cl_hrrcf_t77rcf_role=>get_role
        EXPORTING
          role        = c_cand_ext_role
        IMPORTING
          t77rcf_role = ls_role_ext.            "Contains refuser
*
    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_ex
        IMPORTING
          pt_errors = et_errors.
      RETURN.
  ENDTRY.

* A new user needs to be created. In this case we simply assign the
* appropriate reference user, but not the activity groups
  IF iv_maintaince_mode = 'nu'     OR
     iv_maintaince_mode = 'nuaus'.
*
    MOVE-CORRESPONDING me->employee->centraldataperson TO ls_address.
*
*     Create a password.
    CALL FUNCTION 'SUSR_GENERATE_PASSWORD'
*      EXPORTING
*       DOWNWARDS_COMPATIBLE       =
     IMPORTING
       password                   = ls_passwd-bapipwd
     EXCEPTIONS
       generator_error            = 1
       OTHERS                     = 2.
*
    IF sy-subrc <> 0.
      IF 1 = 2.
        MESSAGE e121(hrrcf0001) WITH '&' '&'.
*   Es ist eine Ausnahme in der Klasse &1 und in der Methode &2
*   aufgetreten
      ENDIF.
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0001'
          number = '121'
          par1   = 'CL_HRRCF_ERP_CONVERT_P_2_CAND'
          par2   = 'MAINTAIN_USER_DATA'
        IMPORTING
          return = ls_return.
*
      APPEND ls_return TO et_errors.
      RETURN.
    ENDIF.
*
    CHECK et_errors IS INITIAL.
*
* prepare e-mail for user
    IF NOT iv_email IS INITIAL.
      ls_address-e_mail = iv_email.
    ENDIF.
*
* Depending on the status of the employee we assign
* the reference user of either the internal or external candidate
    IF me->employee->candidate->is_employee( ) EQ true.
      ls_bapi_refuser-ref_user = ls_role_int-refus.
      lv_cand_class_new = c_cand_int_class.   "internal
    ELSE.
      ls_bapi_refuser-ref_user = ls_role_ext-refus.
      lv_cand_class_new = c_cand_ext_class.   "external.
    ENDIF.

    CALL METHOD cl_hrrcf_user_wd_sync=>create_user_needed_in         "MELN1618643
      EXPORTING
        iv_username            = iv_user_name
      IMPORTING
        ev_create_needed_in_ui = lv_create_needed_in_ui
        ev_create_needed_in_bl = lv_create_needed_in_bl.

    IF lv_create_needed_in_bl = true.

      CALL FUNCTION 'BAPI_USER_GET_DETAIL'       "{WAR1835027
        EXPORTING
          username              = ls_bapi_refuser-ref_user
        IMPORTING
          logondata             = ls_logondata
          defaults              = ls_defaults
          uclass                = ls_uclass
        TABLES
          return                = lt_return.

      CLEAR lt_return.
      ls_logondata-gltgv = sy-datum.
      ls_logondata-gltgb = high_date.
      ls_logondata-ustyp = c_usertype.           "}WAR1835027

*     Create User
      CALL FUNCTION 'BAPI_USER_CREATE1'
        EXPORTING
          username                = iv_user_name
          logondata               = ls_logondata
          password                = ls_passwd
          defaults                = ls_defaults             "WAR1835027
          address                 = ls_address
          ref_user                = ls_bapi_refuser
          uclass                  = ls_uclass               "WAR1835027
          force_system_assignment = 'X'
        TABLES
          return                  = lt_return.
*
*     Keep only errors of type E or A. Delete the rest.
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO et_errors.
        RETURN.
      ENDIF.
    ENDIF.

    IF lv_create_needed_in_ui = true.
      TRY.
*         Create user authorization also in front-end system
          CALL METHOD cl_hrrcf_user_wd_sync=>maintain_frontend_user  "MELN1618643
            EXPORTING
              iv_user            = iv_user_name
              is_central_person  = me->employee->centraldataperson
              iv_email           = iv_email
              iv_password        = ls_passwd
              iv_candidate_class = lv_cand_class_new
            IMPORTING
              et_messages        = lt_return.

        CATCH cx_hrrcf INTO lo_ex.
          CALL METHOD me->convert_exception
            EXPORTING
              io_ex     = lo_ex
            IMPORTING
              pt_errors = et_errors.
          RETURN.
      ENDTRY.

*     Keep only errors of type E or A. Delete the rest.
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO et_errors.
        RETURN.
      ENDIF.
    ENDIF.

* We cannot create the user together with the alias, since we don't
* know if the alias already exists. So we may use the already
* existing method...
    IF me->employee->candidate->is_employee( ) EQ false.
      TRY.
          CALL METHOD cl_hrrcf_employee_inbound=>change_user_alias
            EXPORTING
              p_employeeid = me->employee->employeeid
            IMPORTING
              pt_errors    = lt_errors_tmp.
        CATCH cx_hrrcf INTO lo_ex.
          CALL METHOD me->convert_exception
            EXPORTING
              io_ex     = lo_ex
            IMPORTING
              pt_errors = et_errors.
          RETURN.
      ENDTRY.
      DELETE lt_errors_tmp WHERE msgty NE 'E' AND msgty NE 'A'.
      IF NOT lt_errors_tmp IS INITIAL.
        LOOP AT lt_errors_tmp ASSIGNING <errors>.
          ls_return-id         = <errors>-msgid.
          ls_return-number     = <errors>-msgno.
          ls_return-type       = <errors>-msgty.
          ls_return-message_v1 = <errors>-msgv1.
          ls_return-message_v2 = <errors>-msgv2.
          ls_return-message_v3 = <errors>-msgv3.
          ls_return-message_v4 = <errors>-msgv4.
          APPEND ls_return TO et_errors.
        ENDLOOP.
        RETURN.
      ENDIF.
    ENDIF.
*
  ENDIF.

  IF iv_maintaince_mode = 'nuaus'.                          "#EC NEEDED
*
** the need to insert record in IT0105, should be left for the HR Admin
** we simple as the generated User via relations.
*    TRY.
*        CALL METHOD me->employee->assign_user
*          EXPORTING
*            userid = iv_user_name.
*
*      CATCH cx_hrrcf_infotype_operation INTO lo_ex .
*
*        CALL METHOD me->convert_exception
*          EXPORTING
*            io_ex     = lo_ex
*          IMPORTING
*            pt_errors = et_errors.
*
*    ENDTRY.
*
  ENDIF.

* check if user profiles are sufficent
  IF iv_maintaince_mode = 'cp'.

    CALL FUNCTION 'BAPI_USER_GET_DETAIL'
      EXPORTING
        username       = iv_user_name
      IMPORTING
        ref_user       = ls_ref_user
        alias          = lv_alias
      TABLES
        activitygroups = lt_current_user_activitygroup
        return         = lt_return.
*
*     Keep only errors of type E or A. Delete the rest.
    DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
    IF NOT lt_return IS INITIAL.
      APPEND LINES OF lt_return TO et_errors.
      RETURN.
    ENDIF.
*
* Update of reference user possible if
* ls_ref_user is initial                         or
* ls_ref_user is external and should be internal or
* ls_ref_user is internal and should be external
*
    lv_is_employee = me->employee->candidate->is_employee( ).
*
    IF ( ls_ref_user-ref_user IS INITIAL               ) OR
       ( lv_is_employee       EQ true              AND
         ls_ref_user-ref_user EQ ls_role_ext-refus     ) OR
       ( lv_is_employee       EQ false             AND
         ls_ref_user-ref_user EQ ls_role_int-refus      ).

* Depending on the status of the employee we assign
* the reference user of either the internal or external candidate
      IF lv_is_employee EQ true.
        ls_ref_user-ref_user = ls_role_int-refus.
        ls_check_role = ls_role_int.
        lv_cand_class_new = c_cand_int_class.   "internal
      ELSE.
        ls_ref_user-ref_user = ls_role_ext-refus.
        ls_check_role = ls_role_ext.
        lv_cand_class_new = c_cand_ext_class.   "external.

        IF lv_alias IS INITIAL.
* We cannot create the user together with the alias, since we don't
* know if the alias already exists. So we may use the already
* existing method...
          IF me->employee->candidate->is_employee( ) EQ false.
            TRY.
                CALL METHOD cl_hrrcf_employee_inbound=>change_user_alias
                  EXPORTING
                    p_employeeid = me->employee->employeeid
                  IMPORTING
                    pt_errors    = lt_errors_tmp.
              CATCH cx_hrrcf INTO lo_ex.
                CALL METHOD me->convert_exception
                  EXPORTING
                    io_ex     = lo_ex
                  IMPORTING
                    pt_errors = et_errors.
                RETURN.
            ENDTRY.
            DELETE lt_errors_tmp WHERE msgty NE 'E' AND msgty NE 'A'.
            IF NOT lt_errors_tmp IS INITIAL.
              LOOP AT lt_errors_tmp ASSIGNING <errors>.
                ls_return-id         = <errors>-msgid.
                ls_return-number     = <errors>-msgno.
                ls_return-type       = <errors>-msgty.
                ls_return-message_v1 = <errors>-msgv1.
                ls_return-message_v2 = <errors>-msgv2.
                ls_return-message_v3 = <errors>-msgv3.
                ls_return-message_v4 = <errors>-msgv4.
                APPEND ls_return TO et_errors.
              ENDLOOP.
              RETURN.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

*     check whether user authorizations need to be adjusted
      CALL METHOD cl_hrrcf_user_wd_sync=>update_user_needed_in       "MELN1618643
        EXPORTING
          iv_username            = iv_user_name
          is_new_role            = ls_check_role
        IMPORTING
          ev_update_needed_in_ui = lv_update_needed_in_ui
          ev_update_needed_in_bl = lv_update_needed_in_bl.

      IF lv_update_needed_in_bl = true.
*   Assign reference user as defined in T77RCF_ROLES
        CALL FUNCTION 'BAPI_USER_CHANGE'
          DESTINATION lv_dest                              "MELN2148461
          EXPORTING
            username              = iv_user_name
            ref_user              = ls_ref_user
            ref_userx             = c_bapiupdate_x
          TABLES
            return                = lt_return
          EXCEPTIONS
            system_failure        = 1
            communication_failure = 2
            OTHERS                = 3.
        IF sy-subrc <> 0.
          DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
        ENDIF.
*
*     Keep only errors of type E or A. Delete the rest.
        DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
        IF NOT lt_return IS INITIAL.
          APPEND LINES OF lt_return TO et_errors.
          RETURN.
        ENDIF.
      ENDIF.

      IF lv_update_needed_in_ui = abap_true.
        lv_mode = 'M'.

      ELSEIF lv_cand_class_new = c_cand_int_class.
*       check whether frontend user needs to be deleted
        CALL METHOD cl_hrrcf_user_wd_sync=>check_ui_user_deletion_needed     "MELN1791915
          EXPORTING
            iv_username                = iv_user_name
          IMPORTING
            ev_ui_user_deletion_needed = lv_ui_user_deletion_needed.
        IF lv_ui_user_deletion_needed = abap_true.
          lv_mode = 'D'.
        ENDIF.
      ENDIF.

      IF NOT lv_mode IS INITIAL.
        TRY.
*           Change User authorization also in front-end system
            CALL METHOD cl_hrrcf_user_wd_sync=>maintain_frontend_user  "MELN1618643
              EXPORTING
                iv_user            = iv_user_name
                is_central_person  = me->employee->centraldataperson
                iv_email           = iv_email
                iv_candidate_class = lv_cand_class_new
                iv_mode            = lv_mode                           "MELN1791915
              IMPORTING
                et_messages        = lt_return.

          CATCH cx_hrrcf INTO lo_ex.
            CALL METHOD me->convert_exception
              EXPORTING
                io_ex     = lo_ex
              IMPORTING
                pt_errors = et_errors.
            RETURN.
        ENDTRY.

*       Keep only errors of type E or A. Delete the rest.
        DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
        IF NOT lt_return IS INITIAL.
          APPEND LINES OF lt_return TO et_errors.
          RETURN.
        ENDIF.
      ENDIF.

    ELSEIF ls_ref_user-ref_user NE ls_role_int-refus     AND
           ls_ref_user-ref_user NE ls_role_ext-refus.
* Together with the first IF-statement the following coding is
* processed only if the assigned reference user
* - isn't initial
* - isn't external for active employees
* - isn't internal for inactive employees
* - isn't external
* - isn't internal
* Or in other words: The reference user cannot be exchanged and
* we need to give the authorization by merging the activity groups
*
      IF lv_is_employee EQ true.
* Get activity groups of the internal candidate
        CALL FUNCTION 'BAPI_USER_GET_DETAIL'
          EXPORTING
            username       = ls_role_int-refus
          TABLES
            activitygroups = lt_ref_user_activitygroup
            return         = lt_return.
      ELSE.
* Get activity groups of the external candidate
        CALL FUNCTION 'BAPI_USER_GET_DETAIL'
          EXPORTING
            username       = ls_role_ext-refus
          TABLES
            activitygroups = lt_ref_user_activitygroup
            return         = lt_return.
      ENDIF.
*     Keep only errors of type E or A. Delete the rest.
      DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
      IF NOT lt_return IS INITIAL.
        APPEND LINES OF lt_return TO et_errors.
        RETURN.
      ENDIF.
*
      LOOP AT lt_ref_user_activitygroup INTO ls_ref_user_activitygroup.
        READ TABLE lt_current_user_activitygroup
             WITH KEY agr_name = ls_ref_user_activitygroup-agr_name
            TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          ls_ref_user_activitygroup-from_dat = sy-datum.
          ls_ref_user_activitygroup-to_dat   = high_date.
          APPEND ls_ref_user_activitygroup TO lt_enhanced_activitygroup.
        ENDIF.
      ENDLOOP.
*
      IF NOT lt_enhanced_activitygroup IS INITIAL.

        APPEND LINES OF lt_current_user_activitygroup TO
           lt_enhanced_activitygroup.

        CALL FUNCTION 'SUSR_BAPI_USER_ACTGROUPS_ASSIG'     "MELN1829515
          EXPORTING
            username       = iv_user_name
            bapi_mode      = 'X'
          TABLES
            activitygroups = lt_enhanced_activitygroup
            return         = lt_return.

*   Keep only errors of type E or A. Delete the rest.
        DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
        IF NOT lt_return IS INITIAL.
          APPEND LINES OF lt_return TO et_errors.
          RETURN.
        ENDIF.
      ENDIF.
*
* Assign ALIAS if the user will be an external candidate

      IF lv_is_employee EQ false   AND
         lv_alias       IS INITIAL.
*
* We cannot create the user together with the alias, since we don't
* know if the alias already exists. So we may use the already
* existing method...
        IF me->employee->candidate->is_employee( ) EQ false.
          TRY.
              CALL METHOD cl_hrrcf_employee_inbound=>change_user_alias
                EXPORTING
                  p_employeeid = me->employee->employeeid
                IMPORTING
                  pt_errors    = lt_errors_tmp.
            CATCH cx_hrrcf INTO lo_ex.
              CALL METHOD me->convert_exception
                EXPORTING
                  io_ex     = lo_ex
                IMPORTING
                  pt_errors = et_errors.
              RETURN.
          ENDTRY.
          DELETE lt_errors_tmp WHERE msgty NE 'E' AND msgty NE 'A'.
          IF NOT lt_errors_tmp IS INITIAL.
            LOOP AT lt_errors_tmp ASSIGNING <errors>.
              ls_return-id         = <errors>-msgid.
              ls_return-number     = <errors>-msgno.
              ls_return-type       = <errors>-msgty.
              ls_return-message_v1 = <errors>-msgv1.
              ls_return-message_v2 = <errors>-msgv2.
              ls_return-message_v3 = <errors>-msgv3.
              ls_return-message_v4 = <errors>-msgv4.
              APPEND ls_return TO et_errors.
            ENDLOOP.
            RETURN.
          ENDIF.
        ENDIF.
      ENDIF.
*
    ELSE.                                                   "#EC NEEDED
*   Do nothing, since the reference user of the user is the same as
*   defined in T77RCF_ROLES
    ENDIF.
  ENDIF. "  IF iv_maintaince_mode = 'cp'.
*
ENDMETHOD.


METHOD map_additional_fields.

* If you have installed within your ERP System ECC 5.0 or higher the
* complete suite, but You do not want to run SAP E-Recruiting in this
* instance you have at activate the following statement to stop the
* E-Recruiting specific processing.

* check 1 = 0.


ENDMETHOD.


METHOD merge_skills_at_na_from_hr.
  CONSTANTS: c_begda          TYPE begda VALUE '19000101',
             c_endda          TYPE endda VALUE '99991231'.
  DATA lv_active_plvar        TYPE plvar.
  DATA lv_pernr_sobid         TYPE sobid.
  DATA ls_quali               TYPE p5105.
  DATA ls_relat_q_to_p        TYPE hrpe_profq.
  DATA ls_quali_insert        TYPE p5105.
  DATA lt_db_qualis_na        TYPE TABLE OF p5105.
  DATA lt_quali_insert        TYPE TABLE OF p5105.
  DATA ls_pernr               TYPE hrsobid.
  DATA lt_hr_q_profile        TYPE TABLE OF hrpe_profq.
  DATA lt_pernr               TYPE TABLE OF hrsobid.
  DATA ls_return              TYPE bapiret2.
  DATA lt_return              TYPE bapirettab.
  DATA lo_bl                  TYPE REF TO cl_hrrcf_candidate_infotype_bl.
  DATA lv_hrqua               TYPE gsval.                             "INS Note 1248334
  DATA lv_subrc               TYPE sy-subrc.                          "INS Note 1248334
  DATA lt_assignments         TYPE rcf_t_pernr.
  DATA ls_assignment          TYPE pernr_d.

* Determine of the HR qualifications need to be synchronized          "BEG INS Note 1248334
* with e-Recruitment.
* RECFA HRQUA = ' '
* You do not distribute the qualifications for employees from your
* HR system in the SAP E-Recruiting system.
  CALL METHOD cl_hr_t77s0=>read_gsval
    EXPORTING
      grpid       = 'RECFA'
      semid       = 'HRQUA'
    IMPORTING
      returnvalue = lv_hrqua
      subrc       = lv_subrc.

* If the value HRQUA has been found (lv_subrc EQ 0) and
* if it is initial. the HR qualifications need to be ignored
  IF lv_hrqua IS INITIAL AND lv_subrc EQ 0.
    RETURN.
  ENDIF.                                                              "END INS Note 1248334


* If iv_hr_pernr is not initial, then move it to lv_pernr_sobid.
  lv_pernr_sobid = iv_hr_pernr.


  lv_active_plvar = cl_hrrcf_general_bl=>get_plvar( ).

  IF lv_active_plvar IS INITIAL.
    MESSAGE e217(hrrcf0001).
*   Es existiert keine aktive Planvariante
    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'E'
        cl     = 'HRRCF0001'
        number = 217
      IMPORTING
        return = ls_return.
    APPEND ls_return TO lt_return.
    APPEND LINES OF lt_return TO et_errors.

  ELSE.
    IF NOT ( cl_hrcce_quali_switch_check=>hrcce_sfws_check_ce_ge( ) EQ 'X' AND
             cl_hrcce_quali_switch_check=>hrcce_sfws_check_all( ) EQ 'X' ).

      lt_assignments = employee->get_personnel_assignments( ).   "MELN1519062
      ls_pernr-plvar = lv_active_plvar.
      ls_pernr-otype = 'P'.
      LOOP AT lt_assignments INTO ls_assignment.
        ls_pernr-sobid = ls_assignment.
        APPEND ls_pernr TO lt_pernr.
      ENDLOOP.
    ENDIF.

    CALL FUNCTION 'RHPP_Q_PROFILE_READ'
*      EXPORTING                                 "WAR1519062
*        begda            = '19000101'           "WAR1519062
*        endda            = '99991231'           "WAR1519062
      TABLES
        OBJECTS          = lt_pernr
        profile          = lt_hr_q_profile
      EXCEPTIONS
        no_authority     = 1
        wrong_otype      = 2
        object_not_found = 3
        undefined        = 4
        OTHERS           = 5.
    CASE sy-subrc.
      WHEN 0.
        IF NOT is_hrobject IS INITIAL.
*         consolidate Qs -> keep only the Q with the highest proficiency  "MELN1519062
          SORT lt_hr_q_profile BY plvar otype ttype tbjid istat profcy DESCENDING.
          DELETE ADJACENT DUPLICATES FROM lt_hr_q_profile
                 COMPARING plvar otype ttype tbjid istat.
*         Create Instance
          lo_bl = cl_hrrcf_candidate_infotype_bl=>get_instance( ).
          TRY.
*         READ E-Recruiting-Skills from candidate(NA)
              CALL METHOD lo_bl->get_cand_qualification_data
                EXPORTING
                  ps_cand_hrobject  = is_hrobject
                IMPORTING
                  pt_qualifications = lt_db_qualis_na.
            CATCH cx_hrrcf.
              CLEAR lt_db_qualis_na.
          ENDTRY.

*         Delete all E-Recruiting Qualis
          READ TABLE lt_db_qualis_na INDEX 1 TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            lo_bl = cl_hrrcf_candidate_infotype_bl=>get_instance( ).
            CLEAR ls_quali.
            LOOP AT lt_db_qualis_na INTO ls_quali.
              CALL METHOD lo_bl->maintain_cand_qualification
                EXPORTING
                  p_operation      = 'D'
                  ps_qualification = ls_quali
                  ps_cand_hrobject = is_hrobject
                IMPORTING
                  pt_return        = lt_return.
            ENDLOOP.
*           Keep only errors of type E or A. Delete the rest.
            DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
            IF NOT lt_return IS INITIAL.
              APPEND LINES OF lt_return TO et_errors.
              RETURN.
            ENDIF.
          ENDIF.   "if sy-subrc = 0.

*     Now merge the Skills: If HR-Skills at a person exists, than
*     merge the HR-Skills to the candidate profile (infotype 5105).
*     TRY.
          READ TABLE lt_hr_q_profile INDEX 1 TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.                   "HR Skills exists
            CLEAR ls_relat_q_to_p.
            LOOP AT lt_hr_q_profile INTO ls_relat_q_to_p.
*             ls_quali_insert-mandt         = ls_relat_q_to_p-mandt.
              ls_quali_insert-plvar         = ls_relat_q_to_p-plvar.
              ls_quali_insert-otype         = is_hrobject-otype.  "NA
              ls_quali_insert-objid         = is_hrobject-objid.  "NA-objid
              ls_quali_insert-infty         = '5105'.
              ls_quali_insert-subty         = '   '.
              ls_quali_insert-istat         = ls_relat_q_to_p-istat.
*             ls_quali_insert-priox         = ls_relat_q_to_p-priox.
              ls_quali_insert-begda         = c_begda.
              ls_quali_insert-endda         = c_endda.
*             ls_quali_insert-seqnr         = ls_relat_q_to_p-seqnr.
              ls_quali_insert-aedtm         = ls_relat_q_to_p-aedtm.
              ls_quali_insert-uname         = ls_relat_q_to_p-uname.
*             ls_quali_insert-reasn         = ls_relat_q_to_p-reasn.
*             ls_quali_insert-histo         = ls_relat_q_to_p-histo.
*             ls_quali_insert-itxnr         = ls_relat_q_to_p-itxnr.
              ls_quali_insert-q_object_type = ls_relat_q_to_p-ttype.
              ls_quali_insert-q_object_id   = ls_relat_q_to_p-tbjid.
              ls_quali_insert-proficiency   = ls_relat_q_to_p-profcy.
              APPEND ls_quali_insert TO lt_quali_insert.
            ENDLOOP.

            lo_bl = cl_hrrcf_candidate_infotype_bl=>get_instance( ).
            TRY.
                CLEAR ls_quali.
                LOOP AT lt_quali_insert INTO ls_quali.
                  CALL METHOD lo_bl->maintain_cand_qualification
                    EXPORTING
                      p_operation      = 'I'
                      ps_qualification = ls_quali
                      ps_cand_hrobject = is_hrobject
                   IMPORTING
                      pt_return        = lt_return.
                ENDLOOP.
*           Keep only errors of type E or A. Delete the rest.
                DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
                IF NOT lt_return IS INITIAL.
                  APPEND LINES OF lt_return TO et_errors.
                  RETURN.
                ENDIF.
              CATCH cx_hrrcf.
                RETURN.
            ENDTRY.
          ENDIF.        "IF sy-subrc = 0.
        ENDIF.          "IF NOT is_hrobject IS INITIAL.
    ENDCASE.
  ENDIF.            "IF sy-subrc <> 0.

ENDMETHOD.


METHOD pp_create_candidate.
  DATA:
    ls_empl_cand           TYPE t77rcf_empl_cand,
    lt_e1p0105             TYPE TABLE OF e1p0105,
    lv_email               TYPE ad_smtpadr,
    lt_e1p0000             TYPE rcf_t_e1p0000.

* Get the standard e-mail address of the employee*********************
* From IT105 no CE or from BP in case of CE***************************
**********************************************************************
  CALL METHOD me->pp_get_e_mail
    EXPORTING
      iv_bp_number = iv_bp_number
      iv_hr_pernr  = iv_hr_pernr
    IMPORTING
      ev_email     = lv_email.

* For that PERNR no NA exists***************************************
* BP exists for that PERNR, either on DB or just created.***********
* Now we must check if the PERNR was created with a relationship to an
* external candidate. In this case we must not create a new NA but**
* assign the old (external) to the new CP (and therefore P)*********
********************************************************************
  CALL METHOD me->pp_find_employee_candidate
    EXPORTING
      iv_cp        = iv_cp
    IMPORTING
      es_empl_cand = ls_empl_cand.


  es_empl_cand = ls_empl_cand .

  IF ls_empl_cand IS INITIAL.
*   if no Employee Candidate has been found, a new need to be created*
**********************************************************************
    CALL METHOD me->pp_no_external_candicate_exist
      EXPORTING
        iv_hr_pernr  = iv_hr_pernr
        iv_bp_number = iv_bp_number
        iv_email     = lv_email
      IMPORTING
        et_return    = et_return.

    CHECK et_return IS INITIAL.

  ELSE.
*   If a candidate has been found, assign the CP to the candidate*****
**********************************************************************
    CALL METHOD me->pp_external_candicate_exist
      EXPORTING
        iv_bp_number = iv_bp_number
        is_empl_cand = ls_empl_cand.

  ENDIF.
* Read the IT0000 need to set the Active/Inavtive flag and ***********
* to determine the user in CE ****************************************
**********************************************************************
  CALL METHOD me->pp_get_it0000_records
    IMPORTING
      et_e1p0000 = lt_e1p0000.

* Set 'inactive'-flag according to IT0000-STAT2***********************
**********************************************************************
  CALL METHOD me->pp_maintain_is_inactive_flag
    EXPORTING
      it_e1p0000 = lt_e1p0000
    IMPORTING
      et_errors  = et_return.

* Keep only errors of type E or A. Delete the rest.
  DELETE et_return WHERE type NE 'E' AND type NE 'A'.
  CHECK et_return IS INITIAL.

  IF sy-cprog EQ cl_hrrcf_erp_convert_p_2_cand=>gc_hralxsync.

*   In the case of HRALXSYNC also an update of address, the user,*****
*   user authorization and HR-Skills should be checked****************
**********************************************************************
    CALL METHOD me->pp_determine_user
      EXPORTING
        iv_hr_pernr = iv_hr_pernr
        it_e1p0000  = lt_e1p0000
      IMPORTING
        et_e1p0105  = lt_e1p0105.


    CALL METHOD me->pp_sync_avail_infotypes
      EXPORTING
        iv_hr_pernr  = iv_hr_pernr
        iv_bp_number = iv_bp_number
        it_e1p0105   = lt_e1p0105
        iv_email     = lv_email
      IMPORTING
        et_return    = et_return.

  ENDIF.
ENDMETHOD.


METHOD PP_DETERMINE_USER.

  DATA:
    lt_p0105                   TYPE hrobjsdata_tab,
    ls_p0105                   TYPE hrobjsdata,
    ls_e1p0105                 TYPE e1p0105,
    lt_e1p0105_all             TYPE rcf_t_e1p0105,
    lt_e1p0000                 TYPE rcf_t_e1p0000,
    ls_e1p0000                 TYPE e1p0000,
    lv_user_subty              TYPE subtyp.

* Note 1566478
* CE anbled CONCEPT****************************************************
* The oldest USER that have an active workagreement IT0000 ***********
**********************************************************************
    lt_e1p0000[] = it_e1p0000[].
    SORT lt_e1p0000 BY begda.

* Get subtype of user (usually 0001)
    lv_user_subty = get_user_subtype( ).

*   Get the IT105 only for the active workagreements
****************************************************
    LOOP AT lt_e1p0000 INTO ls_e1p0000
      WHERE
        begda LE sy-datum      AND
        endda GE sy-datum.

      CLEAR lt_p0105.
      CALL METHOD me->get_it0105_records
        EXPORTING
          iv_pernr   = ls_e1p0000-pernr
        IMPORTING
          pt_e1p0105 = lt_p0105.

*     Get all entries that contains a USER
      LOOP AT lt_p0105 INTO  ls_p0105.
        ls_e1p0105 = ls_p0105-sdata.
        CHECK ls_e1p0105-subty = lv_user_subty.
        IF NOT ls_e1p0105-usrid      IS INITIAL OR
           NOT ls_e1p0105-usrid_long IS INITIAL.
*         USER FOUND
          APPEND ls_e1p0105 TO lt_e1p0105_all.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

*   Get the Oldest user sorted first by BEGDA and later by PERNR
    SORT lt_e1p0105_all BY begda pernr.
    CLEAR ls_e1p0105.
    READ TABLE lt_e1p0105_all INDEX 1
      INTO ls_e1p0105.

    IF sy-subrc = 0.
      APPEND ls_e1p0105 TO et_e1p0105.
    ENDIF.

ENDMETHOD.


METHOD pp_external_candicate_exist.
  DATA:
    lo_ext_cand            TYPE REF TO cl_hrrcf_candidate.

* We know that for the imported PERNR no NA exist. Additionally we
* know that the PERNR was hired due to a data transfer, i.e. an
* external candidate exists.
  CALL METHOD cl_hrrcf_candidate=>get
    EXPORTING
      id        = is_empl_cand-candidate_id
    IMPORTING
      candidate = lo_ext_cand.

  lo_ext_cand->exchange_cp_with_hr(
    employeeid = is_empl_cand-employee_id
    partnerid  = iv_bp_number             ).
*
  CALL METHOD cl_hrrcf_employee=>get
    EXPORTING
      candidateid = is_empl_cand-candidate_id
    IMPORTING
      employee    = me->employee.

ENDMETHOD.


METHOD pp_find_employee_candidate.
  DATA:
    ls_object   TYPE hrobject,
    lt_relation TYPE TABLE OF p1001,
    ls_relation TYPE p1001,
    lv_pernr    TYPE pernr_d,
    lv_plvar    TYPE plvar.

  CONSTANTS:
    lc_cp_p      TYPE subtyp VALUE 'B209'.

  CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
    EXPORTING
      set_default_plvar = 'X'
    IMPORTING
      act_plvar         = lv_plvar
    EXCEPTIONS
      no_active_plvar   = 0
      OTHERS            = 0.

  ls_object-plvar = lv_plvar.
  ls_object-otype = 'CP'.
  ls_object-objid = iv_cp.

  CALL METHOD cl_hrrcf_object_buffer=>read_relationship
    EXPORTING
      pv_isubty    = lc_cp_p
      pv_iwith_ev  = 'X'
      ps_ihrobject = ls_object
    IMPORTING
      pt_erelation = lt_relation.

  LOOP AT lt_relation INTO ls_relation
    WHERE sclas = 'P'.

    lv_pernr = ls_relation-sobid.

    CALL METHOD cl_hrrcf_t77rcf_empl_cand=>read_record
      EXPORTING
        pv_employee_id = lv_pernr
      IMPORTING
        ps_record      = es_empl_cand.

    IF NOT es_empl_cand IS INITIAL.
      EXIT.
    ENDIF.

  ENDLOOP.


ENDMETHOD.


METHOD PP_GET_E_MAIL.

  DATA:
    lt_p0105                   TYPE hrobjsdata_tab,
    ls_p0105                   TYPE hrobjsdata,
*    lt_et_e1p0105              TYPE RCF_T_E1P0105,
    ls_e1p0105                 TYPE e1p0105,
    lt_bp_email                TYPE TABLE OF bapiadsmtp,
    ls_bp_standard_email       TYPE bapiadsmtp.

* No CE Read from IT105***********************************************
**********************************************************************
  IF cl_hrrcf_system_check=>is_ce_enabled = false.

** Read IT 0105 to get the emails Address******************
***********************************************************
    CALL METHOD me->get_it0105_records
      EXPORTING
        iv_pernr   = iv_hr_pernr
      IMPORTING
        pt_e1p0105 = lt_p0105.

    LOOP AT lt_p0105 INTO  ls_p0105.
      ls_e1p0105 = ls_p0105-sdata.
      IF ls_e1p0105-subty EQ c_subty_email.        "E-mail-assignmet
        IF NOT ls_e1p0105-usrid_long IS INITIAL.
          ev_email = ls_e1p0105-usrid_long.
        ELSE.
          ev_email = ls_e1p0105-usrid.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ELSE.
* CE anbled***********************************************************
* Read standard email information from BO*****************************
**********************************************************************
    CALL FUNCTION 'BAPI_BUPA_ADDRESS_GETDETAIL'
      EXPORTING
        businesspartner = iv_bp_number
      TABLES
        bapiadsmtp      = lt_bp_email.

    READ TABLE lt_bp_email  INTO ls_bp_standard_email
                            WITH KEY std_no = 'X'.

    ev_email = ls_bp_standard_email-e_mail.

  ENDIF.

ENDMETHOD.


METHOD pp_get_it0000_records.
  DATA:
   lt_personnel_assignments TYPE rcf_t_pernr,
   lv_personnel_assignment  TYPE pernr_d,
   lt_p0000_hrobjsdata      TYPE hrobjsdata_tab,
   ls_p0000_hrobjsdata      TYPE hrobjsdata,
   ls_e1p0000               TYPE e1p0000.

* If the list of Personell Assigments is supplied use it*************
*********************************************************************
  IF it_personnel_assignments IS SUPPLIED.
    APPEND LINES OF it_personnel_assignments TO lt_personnel_assignments.
  ELSE.
* Get list of Personell Assigments.**********************************
*********************************************************************
    CALL METHOD me->employee->get_personnel_assignments
      RECEIVING
        et_personnel_assignments = lt_personnel_assignments.

  ENDIF.
  LOOP AT lt_personnel_assignments INTO lv_personnel_assignment.
    CLEAR lt_p0000_hrobjsdata.
* Read IT0000 to set flag 'IS_INACTIVE' in IT5102-*******************
*********************************************************************
    CALL METHOD me->get_it0000_records
      EXPORTING
        iv_pernr   = lv_personnel_assignment
      IMPORTING
        pt_e1p0000 = lt_p0000_hrobjsdata.

    LOOP AT lt_p0000_hrobjsdata INTO ls_p0000_hrobjsdata.
      ls_e1p0000 = ls_p0000_hrobjsdata-sdata.
      APPEND ls_e1p0000 TO et_e1p0000 .
    ENDLOOP.

  ENDLOOP.

  IF et_e1p0000 IS INITIAL.
*       Must not occur
    RAISE EXCEPTION TYPE cx_hrrcf.
  ENDIF.
ENDMETHOD.


METHOD pp_init.

* This method should run only in a system, where HR and ERP run together
  IF cl_hrrcf_system_check=>is_standalone = true.
    ev_return = true.
    RETURN.
  ENDIF.
*
* For this implementation all the characters need to be in system*********
* Centeral Persol, PERNR and BP are needed.*******************************
**************************************************************************
  IF iv_hr_pernr  IS INITIAL OR
     iv_cp        IS INITIAL OR
     iv_bp_number IS INITIAL.
    ev_return = true.
    RETURN.
  ENDIF.
*
  CLEAR: me->employee.
*
* SET LUW-Mode to avoid 'COMMIT WORK' in E-recruiting framework
  cl_hrrcf_simple_main_object=>set_luw_mode( ).
*
ENDMETHOD.


METHOD pp_maintain_is_inactive_flag.
* integrated scenario I1 "EREC@ERP" -> standalone = false
* BF HCM_ERC_CI_3 is ACTIVE
* CE is enabled
* called from BADI HRSYNC_P

  DATA:
    lv_is_employee           TYPE boole_d,
    lv_is_active             TYPE boole_d,
    lv_set_active_flag       TYPE boole_d,
    ls_e1p0000               TYPE e1p0000,
    lo_cand_info             TYPE REF TO cl_hrrcf_candidate_info,
    lt_e1p0000               TYPE rcf_t_e1p0000.

  CLEAR et_errors.


  lv_is_employee = me->employee->candidate->is_employee( ).

* Analyse the actual status of IT***********************************
*********************************************************************

  LOOP AT it_e1p0000 INTO ls_e1p0000
    WHERE
      begda LE sy-datum.

*   Old work agreements are not considered
    CHECK ls_e1p0000-endda GE sy-datum.

    lv_set_active_flag = true.

    IF ls_e1p0000-stat2 NE '3'.
      lv_is_active = false.
    ELSE.
      lv_is_active = true.
      EXIT.
    ENDIF.
  ENDLOOP.

* Check how is the actual e-recreuitment Status lv_is_employee
* with the new status lv_deactivate_employee
* If the status didnt change, do nathing
  IF  ( lv_is_employee  EQ true  AND lv_is_active  EQ false ) OR
      ( lv_is_employee  EQ false AND lv_is_active  EQ true ) AND
        lv_set_active_flag = true.

    CALL METHOD cl_hrrcf_candidate_info=>get_instance
      EXPORTING
        hrobject = employee->candidate->hrobject
      IMPORTING
        instance = lo_cand_info.

    IF lv_is_active = true.
      CALL METHOD lo_cand_info->set_is_inactive_flag
        EXPORTING
          is_inactive = false
        IMPORTING
          return      = et_errors.
    ELSE.
      CALL METHOD lo_cand_info->set_is_inactive_flag
        EXPORTING
          is_inactive = true
        IMPORTING
          return      = et_errors.
    ENDIF.

*   Keep only errors of type E or A. Delete the rest.
    DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
    IF NOT et_errors IS INITIAL.
      RETURN.
    ENDIF.
  ENDIF.

* Work Agreements that start in the future will be handled by the****
* daily background job of HRALXSYNC which is mandatory in case BF****
* HCM_ERC_CI_3 is active -> see note 1779471*************************
* therefore, T77RCF_P_STAT-usage has been removed and already********
* existing entries are deleted for all work agreements***************
  lt_e1p0000 = it_e1p0000.
  SORT lt_e1p0000 BY pernr.
  DELETE ADJACENT DUPLICATES FROM lt_e1p0000 COMPARING pernr.

  LOOP AT lt_e1p0000 INTO ls_e1p0000.                      "MELN1777933
    cl_hrrcf_t77rcf_p_stat=>delte_all_records_for_ee( ls_e1p0000-pernr ).
  ENDLOOP.

ENDMETHOD.


METHOD PP_NO_EXTERNAL_CANDICATE_EXIST.
  DATA:
    ls_centraldata         TYPE bapibus1006_central,
    ls_centraldataperson   TYPE bapibus1006_central_person,
    lo_cand_info           TYPE REF TO cl_hrrcf_candidate_info,
    ls_p5102               TYPE p5102 .

* Since BP isn't created before the employee is hired, not only
* a candidate but also an employee must be created
* centraldataperson and centraldata are mandatory. However,
* since BP exists we do not need to fill these structures, since
* inside of the create-method no BP-update happens
* E-MAIL is optional. If the candidate is created during PA40
* (hire date <= sy-datum) IT0105/0010 isn't maintained when the
* 'employee' is created. However, when the hire date is reached the
* customer must run HRALXSYNC to create BP (and NA). HRALXSYNC is also
* used to create NA if E-Recruiting starts to run in an already
* productive HR environmanet. In both cases IT0105/0010 may exist
* and should be taken into account.

  CALL METHOD cl_hrrcf_employee=>create
    EXPORTING
      centraldataperson = ls_centraldataperson
      centraldata       = ls_centraldata
      employeeid        = iv_hr_pernr
      e_mail            = iv_email
      partner           = iv_bp_number
      external_commit   = true
    IMPORTING
      employee          = me->employee
      return            = et_return.

*       Keep only errors of type E or A. Delete the rest.
  DELETE et_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT et_return IS INITIAL.
    RETURN.
  ENDIF.


* Together with the object also IT5102 must be created
  CALL METHOD cl_hrrcf_candidate_info=>get_instance
    EXPORTING
      hrobject = me->employee->candidate->hrobject
    IMPORTING
      instance = lo_cand_info.

* Create candidate information
  CLEAR ls_p5102.
* In general ls_e1p0000-begda would be better for BEGDA,
* but IT1000 also starts with sy-datum...
  ls_p5102-begda  = sy-datum.
  ls_p5102-endda  = high_date.
  ls_p5102-status = '0'.     " not seeking
  CLEAR et_return.

  CALL METHOD lo_cand_info->insert_record
    EXPORTING
      check_only      = space
    IMPORTING
      return          = et_return
    CHANGING
      infotype_record = ls_p5102.

* Keep only errors of type E or A. Delete the rest.
  DELETE et_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT et_return IS INITIAL.
    RETURN.
  ENDIF.
ENDMETHOD.


METHOD pp_sync_avail_infotypes.

**********************************************************************
*   IT0006
* In Stand-Alone-System we use IT0006 to update the address via
* business partner. Inside ERP BP is updated directly. However to make
* use of the address in EREC we need an entry in HRP5110
*
  CALL METHOD me->synch_address_and_comm
    EXPORTING
      iv_bp_number = iv_bp_number
    IMPORTING
      et_return    = et_return.

  CHECK et_return IS INITIAL.
***********************************************************************
* IT0105 // user ID and email
* In IT0105 we have two information, one regarding the user assignment
* and one regarding the e-mail assignment.
  CALL METHOD me->process_user_email
    EXPORTING
      it_e1p0105 = it_e1p0105
      iv_email   = iv_email
    IMPORTING
      et_errors  = et_return.
*
  CHECK et_return IS INITIAL.

*********************************************************************
* Initial HR-Skills upload from Person to internal candidate
* First, we need to check, if the candidate has set the flag is_inactive eq false.
* Which means, that the candidate is an active employee.
* Active employee, then read the HR-Skills (1001 with subtype 032) and merge them
* with the candidate skills
  CALL METHOD me->merge_skills_at_na_from_hr
        EXPORTING
          iv_hr_pernr = iv_hr_pernr
          is_hrobject = me->employee->candidate->hrobject
        IMPORTING
          et_errors   = et_return.
ENDMETHOD.


METHOD pp_update_candidate.
* The BAdI is called from HRALXSYNC (and not inside IT-framework)**
* So we should check the employee based on all available infotypes**
* and update it if necessary ('repair-mode')************************
********************************************************************
  DATA:
    lt_e1p0105             TYPE TABLE OF e1p0105,
    lv_email               TYPE ad_smtpadr,
    lt_e1p0000             TYPE rcf_t_e1p0000.


  IF sy-cprog EQ cl_hrrcf_erp_convert_p_2_cand=>gc_hralxsync.
* Get the standard e-mail address of the employee*********************
* From IT105 no CE or from BP in case of CE***************************
**********************************************************************
    CALL METHOD me->pp_get_e_mail
      EXPORTING
        iv_bp_number = iv_bp_number
        iv_hr_pernr  = iv_hr_pernr
      IMPORTING
        ev_email     = lv_email.

* Check existence of IT5102 and possibly create it********************
**********************************************************************
    CALL METHOD me->check_create_cand_info                 "MELN1617853
      IMPORTING
        et_errors  = et_return.

* Keep only errors of type E or A. Delete the rest.
    DELETE et_return WHERE type NE 'E' AND type NE 'A'.
    CHECK et_return IS INITIAL.

* Read the IT0000 need to set the Active/Inavtive flag and ***********
* to determine the user in CE ****************************************
**********************************************************************
    CALL METHOD me->pp_get_it0000_records
      IMPORTING
        et_e1p0000 = lt_e1p0000.

* Set 'inactive'-flag according to IT0000-STAT2***********************
**********************************************************************
    CALL METHOD me->pp_maintain_is_inactive_flag
      EXPORTING
        it_e1p0000 = lt_e1p0000
      IMPORTING
        et_errors  = et_return.

* Keep only errors of type E or A. Delete the rest.
    DELETE et_return WHERE type NE 'E' AND type NE 'A'.
    CHECK et_return IS INITIAL.

*   In the case of HRALXSYNC also an update of address, the user,***
*   user authorization and HR-Skills should be checked**************
********************************************************************
    CALL METHOD me->pp_determine_user
      EXPORTING
        iv_hr_pernr = iv_hr_pernr
        it_e1p0000  = lt_e1p0000
      IMPORTING
        et_e1p0105  = lt_e1p0105.

    CALL METHOD me->pp_sync_avail_infotypes
      EXPORTING
        iv_hr_pernr  = iv_hr_pernr
        iv_bp_number = iv_bp_number
        it_e1p0105   = lt_e1p0105
        iv_email     = lv_email
      IMPORTING
        et_return    = et_return.

  ENDIF.
ENDMETHOD.


METHOD pp_update_from_pa_infotype.
* integrated scenario I1 "EREC@ERP" -> standalone = false
* called from masterdata application (e.g. PA30, HCM P&F)
* BF HCM_ERC_CI_2 (switch HRERC_SFWS_SC_ENH_02) is active

  DATA:
    lo_cand_info                  TYPE REF TO cl_hrrcf_candidate_info,
    lv_work_agreement_inactive    TYPE rcf_employee_inactive,
    lo_ex                         TYPE REF TO cx_hrrcf,
    lt_e1p0000                    TYPE rcf_t_e1p0000,
    lv_status_changed             TYPE boole_d,
    lv_email                      TYPE ad_smtpadr,
    lv_email_status_chng          TYPE boole_d.

  CLEAR et_errors.
  me->employee = io_employee.

  TRY.
*     Check existence of IT5102 and possibly create it
      CALL METHOD me->check_create_cand_info               "MELN1617853
        IMPORTING
          et_errors  = et_errors.

*     Keep only errors of type E or A. Delete the rest.
      DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
      IF NOT et_errors IS INITIAL.
        RETURN.
      ENDIF.

      IF is_pa_infotype-endda LT sy-datum.
*       Record in the past, don't take care
        RETURN.

      ELSEIF is_pa_infotype-begda LE sy-datum.
        CALL METHOD cl_hrrcf_candidate_info=>get_instance
          EXPORTING
            hrobject = me->employee->candidate->hrobject
          IMPORTING
            instance = lo_cand_info.

*    1- Check if the work agreemet is active or not
        IF is_pa_infotype-stat2 = '3'.
          lv_work_agreement_inactive = false.
        ELSE.
          lv_work_agreement_inactive = true.
        ENDIF.

*    2- Employee becomes Inactive
        IF lv_work_agreement_inactive              EQ true AND
           me->employee->candidate->is_employee( ) EQ true.

*         We supose first that the status need to be changed
          lv_status_changed = true.

*    2.1- Read the IT0000 need to set the Active/Inavtive flag
          CALL METHOD me->pp_get_it0000_records
            IMPORTING
              et_e1p0000 = lt_e1p0000.

*    2.2- Check if there are other active agreements in IT PA0000
          LOOP AT lt_e1p0000 TRANSPORTING NO FIELDS
            WHERE
              begda LE sy-datum    AND
              endda GE sy-datum    AND
              pernr NE iv_hr_pernr AND
              stat2 EQ '3'.

*      2.3- Employee ist active, and there is another active work agreement.
*           Do not change the status
            lv_status_changed   = false.
            EXIT.
          ENDLOOP.

          IF sy-subrc <> 0.
*      2.4- no other active work agreement                     "MELN2081181
*           replace business E-Mail with private E-Mail
            CALL METHOD lo_cand_info->read_private_email
              IMPORTING
                ps_email = lv_email.

            CALL METHOD me->employee->change_e_mail
              EXPORTING
                e_mail          = lv_email
                external_commit = abap_true
              IMPORTING
                return          = et_errors.

*           Keep only errors of type E or A. Delete the rest.
            DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
            IF NOT et_errors IS INITIAL.
              RETURN.
            ELSE.
              lv_email_status_chng = abap_true.
            ENDIF.

*           remove the telephone number
            CALL METHOD employee->change_telephone_data    "MELN2148461
              EXPORTING
                telephone_no    = space
                external_commit = abap_true
              IMPORTING
                return          = et_errors.

*           Keep only errors of type E or A. Delete the rest.
            DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
            IF NOT et_errors IS INITIAL.
              RETURN.
            ENDIF.
          ENDIF.

*    3- Employee becomes Active
        ELSEIF lv_work_agreement_inactive              EQ false AND
               me->employee->candidate->is_employee( ) EQ false.

*    3.1- Employee ist inactive, and there is least one active work agreement
*         Activate the employees
          lv_status_changed = true.
        ENDIF.

        IF lv_status_changed = true.
          CALL METHOD lo_cand_info->set_is_inactive_flag
            EXPORTING
              is_inactive        = lv_work_agreement_inactive
              im_v_clr_email_upd = lv_email_status_chng
            IMPORTING
              return               = et_errors.

*         Keep only errors of type E or A. Delete the rest.
          DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
          IF NOT et_errors IS INITIAL.
            RETURN.
          ENDIF.
        ENDIF.

      ELSE.  "is_pa_infotype-begda > sy-datum
*       Work Agreements that start in the future will be handled by the
*       daily background job of HRALXSYNC which is mandatory in case BF
*       HCM_ERC_CI_2 is active -> see note 1779471
*       therefore, T77RCF_P_STAT-usage has been removed and already
*       existing entries are deleted for the current PERNR
*       MELN1777933
        cl_hrrcf_t77rcf_p_stat=>delte_all_records_for_ee( iv_hr_pernr ).
      ENDIF.

    CATCH cx_hrrcf INTO lo_ex.
      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_ex
        IMPORTING
          pt_errors = et_errors.
  ENDTRY.

ENDMETHOD.


METHOD process_user_email.
*
  DATA:
    lv_user_subty          TYPE subtyp,
    lv_user                TYPE bapibname-bapibname,
    lv_maintenance_mode    TYPE char10,
    ls_e1p0105             TYPE e1p0105.
*
  CLEAR et_errors.
*
* Get subtype of user (usually 0001)
  lv_user_subty = get_user_subtype( ).
*
* Get the user id, if available.
  READ TABLE it_e1p0105
    WITH KEY   subty = lv_user_subty
    INTO ls_e1p0105.
  IF NOT sy-subrc IS INITIAL.
    CLEAR ls_e1p0105.
  ENDIF.
*
  CALL METHOD me->check_user_change_required
    EXPORTING
      is_e1p0105          = ls_e1p0105
    IMPORTING
      et_errors           = et_errors
      et_user_name        = lv_user
      et_maintenance_mode = lv_maintenance_mode.
*
  CHECK et_errors IS INITIAL.
*
  IF NOT lv_maintenance_mode IS INITIAL.
    CALL METHOD me->maintain_user_data
      EXPORTING
        iv_maintaince_mode = lv_maintenance_mode
        iv_user_name       = lv_user
        iv_email           = iv_email
      IMPORTING
        et_errors          = et_errors.
*
  ENDIF.
*
  CHECK et_errors IS INITIAL.
*
  CALL METHOD me->maintain_email
    EXPORTING
      iv_email  = iv_email
    IMPORTING
      et_errors = et_errors.
*
  CHECK et_errors IS INITIAL.
*
ENDMETHOD.


METHOD synch_address_and_comm.
* In E-Recruiting the address maintained at BP is available only
* if IT5110 is synchronized
*
  DATA:
    lt_return      TYPE bapirettab,
    lo_bas         TYPE REF TO cl_hrrcf_address_service,
    lt_telefondata TYPE TABLE OF bapiadtel,
    ls_telefon     TYPE bapiadtel,
    lo_exception   TYPE REF TO cx_hrrcf.
*
  CLEAR et_return.
*
  CALL METHOD cl_hrrcf_address_service=>get_instance
    EXPORTING
      businesspartner = iv_bp_number
    IMPORTING
      instance        = lo_bas
      return          = lt_return.
*
* Keep only errors of type E or A. Delete the rest.
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT lt_return IS INITIAL.
    APPEND LINES OF lt_return TO et_return.
    RETURN.
  ENDIF.
*
  CALL METHOD lo_bas->update_address_from_bupa
    IMPORTING
      et_return = lt_return.

* Keep only errors of type E or A. Delete the rest.
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT lt_return IS INITIAL.
    APPEND LINES OF lt_return TO et_return.
    RETURN.
  ENDIF.

**************** handle telephone number ****************
  CALL FUNCTION 'BAPI_BUPA_ADDRESS_GETDETAIL'
    EXPORTING
      businesspartner = iv_bp_number
    TABLES
      bapiadtel       = lt_telefondata.

  READ TABLE lt_telefondata INTO ls_telefon
                            WITH KEY std_no = 'X'.

  TRY.
      CALL METHOD me->employee->change_telephone_data      "MELN2148461
        EXPORTING
          telephone_no    = ls_telefon-telephone
          external_commit = true
        IMPORTING
          return          = et_return.

      IF NOT et_return IS INITIAL.
        RETURN.
      ENDIF.

    CATCH cx_hrrcf_maintain_object INTO lo_exception .
      RAISE EXCEPTION TYPE cx_hrrcf_address_service
        EXPORTING
          textid   = cx_hrrcf_address_service=>cx_hrrcf_address_service
          previous = lo_exception.
  ENDTRY.

ENDMETHOD.


METHOD update_comm_data.

  DATA: lo_instance TYPE REF TO cl_hrrcf_address_service.

  DATA: lt_p0105     TYPE hrobjsdata_tab,
        ls_p0105     TYPE hrobjsdata.
  DATA: ls_e1p0105   TYPE e1p0105,
*        lt_e1p0105   TYPE TABLE OF e1p0105 INITIAL SIZE 0,
        ls_emaildata TYPE rcf_s_emaildata_bp,
        ls_email     TYPE rcf_s_emaildata_bp.

  DATA: lo_ex       TYPE REF TO cx_hrrcf,
        lo_addr_ex  TYPE REF TO cx_hrrcf_address_service.

  TRY.
      CALL METHOD cl_hrrcf_address_service=>get_instance
        EXPORTING
          businesspartner = iv_bp
        IMPORTING
          instance        = lo_instance
          return          = et_return.
    CATCH cx_hrrcf_address_service INTO lo_addr_ex.
      CALL METHOD me->convert_exception
        EXPORTING
          io_ex     = lo_addr_ex
        IMPORTING
          pt_errors = et_return.
      RETURN.
  ENDTRY.

  DELETE et_return WHERE type NE 'A' AND type NE 'E'.
  CHECK et_return IS INITIAL.

  IF lo_instance IS BOUND.
    TRY.
*       get communication data of person
        CALL METHOD me->get_it0105_records
          EXPORTING
            iv_pernr   = iv_pernr
          IMPORTING
            pt_e1p0105 = lt_p0105.

*       retrieve email address
        LOOP AT lt_p0105 INTO ls_p0105.
          ls_e1p0105 = ls_p0105-sdata.
*         only email will be considered for update
          CHECK ls_e1p0105-subty = '0010'.
          IF NOT ls_e1p0105-usrid_long IS INITIAL.
            ls_emaildata-e_mail = ls_e1p0105-usrid_long.
          ELSE.
            ls_emaildata-e_mail = ls_e1p0105-usrid.
          ENDIF.
          EXIT.
        ENDLOOP.

        TRY.
            IF lo_instance->e_maildata IS NOT INITIAL.
*             update
              READ TABLE lo_instance->e_maildata INDEX 1 INTO ls_email.
              ls_emaildata-consnumber = ls_email-consnumber.
              CALL METHOD lo_instance->update_contact_data
                IMPORTING
                  return    = et_return
                CHANGING
                  emaildata = ls_emaildata.
            ELSE.
*             insert
              CHECK ls_emaildata IS NOT INITIAL.
              CALL METHOD lo_instance->add_contact_data
                IMPORTING
                  return    = et_return
                CHANGING
                  emaildata = ls_emaildata.
            ENDIF.

            DELETE et_return WHERE type NE 'A' AND type NE 'E'.

          CATCH cx_hrrcf_address_service INTO lo_addr_ex.
            CALL METHOD me->convert_exception
              EXPORTING
                io_ex     = lo_addr_ex
              IMPORTING
                pt_errors = et_return.
            RETURN.
        ENDTRY.

      CATCH cx_hrrcf INTO lo_ex.
        CALL METHOD me->convert_exception
          EXPORTING
            io_ex     = lo_ex
          IMPORTING
            pt_errors = et_return.
        RETURN.
    ENDTRY.
  ENDIF.



ENDMETHOD.


METHOD update_from_pa_infotype.
  DATA ls_p_stat              TYPE t77rcf_p_stat .
  DATA lt_p_stat              TYPE t77rcf_p_stat_tab .
  DATA lo_cand_info           TYPE REF TO cl_hrrcf_candidate_info.
  DATA lv_emp_inactive        TYPE rcf_employee_inactive.
  DATA lo_ex                  TYPE REF TO cx_hrrcf.
  DATA lv_email               TYPE ad_smtpadr.              "WAR1868050

  CLEAR et_errors.
  CLEAR me->employee.


  IF is_pa_infotype-endda LT sy-datum.
* Record in the past, don't take care
  ELSEIF is_pa_infotype-begda LE sy-datum.

    TRY.
        CALL METHOD cl_hrrcf_employee=>get
          EXPORTING
            employeeid = iv_hr_pernr
          IMPORTING
            employee   = employee.
      CATCH cx_hrrcf.                                   "#EC NO_HANDLER
*   no reaction, existence check only
    ENDTRY.

    TRY.
        IF employee IS NOT INITIAL.
          CALL METHOD cl_hrrcf_candidate_info=>get_instance
            EXPORTING
              hrobject = employee->candidate->hrobject
            IMPORTING
              instance = lo_cand_info.

*         Check existence of IT5102 and possibly create it
          CALL METHOD me->check_create_cand_info           "MELN1617853
            IMPORTING
              et_errors  = et_errors.

*         Keep only errors of type E or A. Delete the rest.
          DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
          IF NOT et_errors IS INITIAL.
            RETURN.
          ENDIF.

          IF is_pa_infotype-stat2 = '3'.
            lv_emp_inactive = ' '.
          ELSE.
            lv_emp_inactive = 'X'.

*           get private email
            CALL METHOD lo_cand_info->read_private_email    "WAR1868050
              IMPORTING
                ps_email         =  lv_email.

*           Remove the Email Address                                                  "INS NOTE 0001323296
            CALL METHOD employee->change_e_mail                                       "INS NOTE 0001323296
              EXPORTING                                                               "INS NOTE 0001323296
                e_mail          = lv_email                  "WAR1868050
                external_commit = abap_true                                           "INS NOTE 0001323296
              IMPORTING                                                               "INS NOTE 0001323296
                return          = et_errors.                                          "INS NOTE 0001323296

*     Keep only errors of type E or A. Delete the rest.
            DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
            IF NOT et_errors IS INITIAL.
              RETURN.
            ENDIF.

*           remove the telephone number
            CALL METHOD employee->change_telephone_data    "MELN2148461
              EXPORTING
                telephone_no    = space
                external_commit = abap_true
              IMPORTING
                return          = et_errors.

*     Keep only errors of type E or A. Delete the rest.
            DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
            IF NOT et_errors IS INITIAL.
              RETURN.
            ENDIF.
          ENDIF.

          CALL METHOD lo_cand_info->set_is_inactive_flag
            EXPORTING
              is_inactive = lv_emp_inactive
            IMPORTING
              return      = et_errors.

*     Keep only errors of type E or A. Delete the rest.
          DELETE et_errors WHERE type NE 'E' AND type NE 'A'.
          IF NOT et_errors IS INITIAL.
            RETURN.
          ENDIF.
        ENDIF.

      CATCH cx_hrrcf INTO lo_ex.
        CALL METHOD me->convert_exception
          EXPORTING
            io_ex     = lo_ex
          IMPORTING
            pt_errors = et_errors.

    ENDTRY.

  ELSE.
*   future record
    CLEAR ls_p_stat.
    ls_p_stat-employee_id     = iv_hr_pernr.
    ls_p_stat-processing_date = is_pa_infotype-begda.
    IF is_pa_infotype-stat2 = '3'. "Employee will be active==> int cand
      ls_p_stat-is_inactive     = false.
    ELSE.                      "Employee won't be active==> ext cand
      ls_p_stat-is_inactive     = true.
    ENDIF.
    APPEND ls_p_stat TO lt_p_stat .
  ENDIF.


* Adjust the table T77RCF_P_STAT as per internal table lt_p_stat
* In the integrated system we have all records of IT0000 available.
* Therfore we should delete the records in T77RCF_P_STAT to make
* sure that only those records are stored, which are relevant for the future

* Delete all records in T77RCF_P_STAT
*  cl_hrrcf_t77rcf_p_stat=>delte_all_records_for_ee( iv_hr_pernr ).

* Write all future records to T77RCF_P_STAT
  IF NOT lt_p_stat IS INITIAL.
    cl_hrrcf_t77rcf_p_stat=>insert_records( lt_p_stat ).
  ENDIF.


ENDMETHOD.


METHOD update_na_after_cp_exchange.
* In case the former external candidate is hired not in the future in
* PA48 or HRADMIN a new internal candidate was created. After hiring
* FM HR_RCF_ASSIGN_EE_TO_CANDIDATE is called with the information of
* the candidate id and the employee ID. We exchange the CPs, i.e.
* assign the candidate to the new CP. However the attributes of the
* external candidate are not synchronized at this point.
*
  DATA:
    lv_email          TYPE          ad_smtpadr,
*
    ls_p0105          TYPE          hrobjsdata,
    ls_e1p0105        TYPE          e1p0105,
    ls_return         TYPE          bapiret2,
*
    lt_p0105          TYPE          hrobjsdata_tab,
    lt_e1p0105        TYPE TABLE OF e1p0105,
    lt_return         TYPE          bapiret2_t.
  DATA lv_is_employee TYPE boole_d.                       "WAR1868050
  DATA lo_cand_info   TYPE REF TO cl_hrrcf_candidate_info."WAR1868050
*
  CLEAR me->employee.
*
  CALL METHOD cl_hrrcf_employee=>get
    EXPORTING
      candidateid = im_candidate_id
    IMPORTING
      employee    = me->employee.
*
*
**********************************************************************
*   IT0000
*   Set 'inactive'-flag according to IT0000-STAT2
  CALL METHOD me->maintain_is_inactive_flag
    EXPORTING
      iv_hr_pernr = me->employee->employeeid
    IMPORTING
      et_errors   = lt_return.
*
*       Keep only errors of type E or A. Delete the rest.
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT lt_return IS INITIAL.
    READ TABLE lt_return INTO ls_return INDEX 1.
    RAISE EXCEPTION TYPE cx_hrrcf
       EXPORTING
         message_type   = ls_return-type
         message_class  = ls_return-id
         message_number = ls_return-number
         message_par1   = ls_return-message_v1
         message_par2   = ls_return-message_v2
         message_par3   = ls_return-message_v3
         message_par4   = ls_return-message_v4.
  ENDIF.
*
**********************************************************************
*   IT0006
*   The update of the address at the BP is done. To make it available
*   in E-Recruiting infotype 5110 must be synchronised
*
  CALL METHOD me->synch_address_and_comm
    EXPORTING
      iv_bp_number = me->employee->partner
    IMPORTING
      et_return    = lt_return.
*
*       Keep only errors of type E or A. Delete the rest.
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT lt_return IS INITIAL.
    READ TABLE lt_return INTO ls_return INDEX 1.
    RAISE EXCEPTION TYPE cx_hrrcf
       EXPORTING
         message_type   = ls_return-type
         message_class  = ls_return-id
         message_number = ls_return-number
         message_par1   = ls_return-message_v1
         message_par2   = ls_return-message_v2
         message_par3   = ls_return-message_v3
         message_par4   = ls_return-message_v4.
  ENDIF.
*
**********************************************************************
*   IT0105 // user ID and email
*
  CALL METHOD me->get_it0105_records
    EXPORTING
      iv_pernr   = me->employee->employeeid
    IMPORTING
      pt_e1p0105 = lt_p0105.
*
  LOOP AT lt_p0105 INTO  ls_p0105.
    ls_e1p0105 = ls_p0105-sdata.
    IF ls_e1p0105-subty EQ c_subty_email.        "E-mail-assignmet
      IF NOT ls_e1p0105-usrid_long IS INITIAL.
        lv_email = ls_e1p0105-usrid_long.
      ELSE.
        lv_email = ls_e1p0105-usrid.
      ENDIF.
    ENDIF.
    APPEND ls_e1p0105 TO lt_e1p0105.
  ENDLOOP.
*
  lv_is_employee = me->employee->candidate->is_employee( )."{WAR1868050

  IF lv_is_employee EQ false.
    CALL METHOD cl_hrrcf_candidate_info=>get_instance
      EXPORTING
        hrobject = me->employee->candidate->hrobject
      IMPORTING
        instance = lo_cand_info.
*   get private email
    CALL METHOD lo_cand_info->read_private_email
      IMPORTING
        ps_email         =  lv_email.
  ENDIF.                                         "}WAR1868050

  CALL METHOD me->process_user_email
    EXPORTING
      it_e1p0105 = lt_e1p0105
      iv_email   = lv_email
    IMPORTING
      et_errors  = lt_return.
*
*       Keep only errors of type E or A. Delete the rest.
  DELETE lt_return WHERE type NE 'E' AND type NE 'A'.
  IF NOT lt_return IS INITIAL.
    READ TABLE lt_return INTO ls_return INDEX 1.
    RAISE EXCEPTION TYPE cx_hrrcf
       EXPORTING
         message_type   = ls_return-type
         message_class  = ls_return-id
         message_number = ls_return-number
         message_par1   = ls_return-message_v1
         message_par2   = ls_return-message_v2
         message_par3   = ls_return-message_v3
         message_par4   = ls_return-message_v4.
  ENDIF.
*
ENDMETHOD.
ENDCLASS.