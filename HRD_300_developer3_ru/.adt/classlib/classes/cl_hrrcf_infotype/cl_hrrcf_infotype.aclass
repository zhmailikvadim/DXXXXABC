class CL_HRRCF_INFOTYPE definition
  public
  abstract
  create public .

public section.

  interfaces IF_HRRCF_CONSTANTS .

  aliases DELETE_OPERATION
    for IF_HRRCF_CONSTANTS~DELETE_OPERATION .
  aliases FALSE
    for IF_HRRCF_CONSTANTS~FALSE .
  aliases HIGH_DATE
    for IF_HRRCF_CONSTANTS~HIGH_DATE .
  aliases INSERT_OPERATION
    for IF_HRRCF_CONSTANTS~INSERT_OPERATION .
  aliases LOW_DATE
    for IF_HRRCF_CONSTANTS~LOW_DATE .
  aliases MODIFY_OPERATION
    for IF_HRRCF_CONSTANTS~MODIFY_OPERATION .
  aliases MSGCL_ADMIN
    for IF_HRRCF_CONSTANTS~MSGCL_ADMIN .
  aliases MSGCL_USER
    for IF_HRRCF_CONSTANTS~MSGCL_USER .
  aliases TRUE
    for IF_HRRCF_CONSTANTS~TRUE .

  data HROBJECT type HROBJECT .
  data MY_INFTY type INFTY read-only .
  data MY_777D type T777D read-only .

  events RCF_INFOTYPE_RECORD_CHANGED
    exporting
      value(HRRCF_INFOTYPE_OBJECT) type ref to CL_HRRCF_INFOTYPE
      value(BEFORE_IMAGE) type WPLOG_TAB
      value(EXTERNAL_COMMIT) type BOOLE_D default SPACE .

  class-methods CLEAR_LAST_BUFFER_REFRESH .
  class-methods CLASS_CONSTRUCTOR .
  methods CONSTRUCTOR .
  methods DELETE_RECORD
    importing
      !CHECK_ONLY type BOOLE_D default SPACE
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORD type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods DELETE_TAB_RECORD
    importing
      !CHECK_ONLY type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORD type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods DELETE_TEXT
    importing
      !IS_WPLOG_RECORD type WPLOG
    exporting
      !ET_MESSAGES type BAPIRETTAB .
  methods GET_BUSINESS_OBJECT
    exporting
      !HROBJECT type HROBJECT
      !BUSINESSOBJECT type ref to OBJECT .
  methods GET_CUSTOMER_FIELDS
    importing
      !P_LANGU type SYLANGU default SY-LANGU
    exporting
      !P_FIELD_TABLE type DFIES_TABLE
      !P_HELPLIST type RCF_T_FIELD_HELPLIST .
  methods GET_FIELD_SET_HISTORY_TC12
    importing
      !FIELD_SET type RCF_T_FIELDNAME
    exporting
      !FIELD_LOG type RCF_T_FIELDLOG .
  methods GET_RECORDS
    exporting
      !INFOTYPE_RECORDS type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_FIELD_SET_HISTORY_TC3
    importing
      !FIELD_SET type RCF_T_FIELDNAME
    exporting
      !FIELD_LOG type RCF_T_FIELDLOG .
  methods GET_RECORDS_BY_DATE
    importing
      !DATE type DATS default SY-DATUM
    exporting
      !INFOTYPE_RECORDS type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_RECORDS_BY_SUBTYPE
    importing
      !DATE type DATS optional
      !SUBTYPE type SUBTY
    exporting
      !INFOTYPE_RECORDS type ANY
    raising
      CX_HRRCF .
  methods GET_TAB_RECORDS
    exporting
      !INFOTYPE_RECORDS type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_TAB_RECORDS_BY_DATE
    importing
      !DATE type DATS default SY-DATUM
    exporting
      !INFOTYPE_RECORDS type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_TAB_RECORDS_BY_SUBTYPE
    importing
      !DATE type DATS optional
      !SUBTYPE type SUBTY
    exporting
      !INFOTYPE_RECORDS type ANY
    raising
      CX_HRRCF .
  methods HAS_DATA
    importing
      !DATE type DATS optional
    exporting
      !RETURN type BOOLE_D
    raising
      CX_HRRCF .
  methods HAS_TAB_DATA
    importing
      !DATE type DATS optional
    exporting
      !RETURN type BOOLE_D
    raising
      CX_HRRCF .
  methods INSERT_RECORD
    importing
      !CHECK_ONLY type BOOLE_D default SPACE
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORD type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods INSERT_TAB_RECORD
    importing
      !CHECK_ONLY type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORDS type TABLE
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  class-methods PNNNN_TO_WPLOG
    importing
      !PNNNN type ANY
    exporting
      !WPLOG type WPLOG .
  class-methods PNNNN_TO_WPLOG_TAB
    importing
      !PNNNN_TAB type TABLE
    exporting
      !WPLOG_TAB type WPLOG_TAB .
  methods READ_ALL_TEXT
    importing
      !FIELDNAME type FIELDNAME
      !LANGU type SPRAS default SY-LANGU
    exporting
      !INFTY_TEXT_TAB type RCF_T_HRKWF_INFTY_TEXT
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods READ_TEXT
    importing
      !FIELDNAME type FIELDNAME
      !INFOTYPE_RECORD type ANY
      !LANGU type SPRAS default SY-LANGU
      !USE_FALLBACK type BOOLE_D default SPACE
    exporting
      !TEXT type RCF_ITF_DESCRIPTION
      !LANGU_TAB type RCF_T_LANGU
      !DOC_LANGU type SPRAS
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  class-methods REFRESH_INSTANCE_DIRECTORY .
  methods RESET_RECORDS_BUFFER .
  methods UPDATE_RECORD
    importing
      !CHECK_ONLY type BOOLE_D default SPACE
      !EXTERNAL_COMMIT type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORD type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods UPDATE_TAB_RECORD
    importing
      !CHECK_ONLY type BOOLE_D default SPACE
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORDS type TABLE
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods UPDATE_TEXT
    importing
      !TEXT type RCF_ITF_DESCRIPTION
      !FIELDNAME type FIELDNAME
      !LANGU type SPRAS default SY-LANGU
    changing
      !INFOTYPE_RECORD type ANY
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  class-methods WPLOG_TO_PNNNN
    importing
      !WPLOG type WPLOG
    exporting
      !PNNNN type ANY .
  class-methods WPLOG_TO_PNNNN_TAB
    importing
      !WPLOG_TAB type WPLOG_TAB
    exporting
      !PNNNN_TAB type TABLE .
protected section.

  data RECORDS type WPLOG_TAB .
  data RECORDS_ALREADY_READ type BOOLE_D value FALSE. "#EC NOTEXT
  data CUSTOMER_FIELD_TABLE type DFIES_TABLE .
  data CUSTOMER_FIELD_HELPLIST type RCF_T_FIELD_HELPLIST .
  data CUSTOMER_FIELD_ALREADY_READ type BOOLE_D value FALSE. "#EC NOTEXT

  methods AUTHORITY_CHECK_STATUS_CHANGE
    importing
      !STATUS type RCF_STATUS
    returning
      value(RETURN) type BOOLE_D .
  methods CHECK
    importing
      !OPERATION type RCF_OPERA
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORD type WPLOG
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods CHECK_BUSINESS_RULES
  abstract
    importing
      !OPERATION type RCF_OPERA
    exporting
      !RETURN type BAPIRETTAB
    changing
      !INFOTYPE_RECORD type WPLOG
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods CHECK_DATES
    importing
      !BEGIN_DATE type BEGDA default LOW_DATE
      !END_DATE type ENDDA default HIGH_DATE
    changing
      !RETURN type BAPIRETTAB .
  methods CHECK_DDIC
    importing
      !INFOTYPE_RECORD type WPLOG
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods CHECK_GENERAL_PLAUSIBILITY
    importing
      !INFOTYPE_RECORD type WPLOG
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  class-methods GET_INSTANCE_FROM_DIRECTORY
    importing
      !HROBJECT type HROBJECT
      !CLASSNAME type CLASSNAME
    exporting
      value(INSTANCE) type ref to CL_HRRCF_INFOTYPE .
  methods ON_CHANGE
    importing
      !BEFORE_IMAGE type WPLOG_TAB
      !EXTERNAL_COMMIT type BOOLE_D default SPACE .
  methods READ_RECORDS
    exporting
      !INFOTYPE_RECORDS type WPLOG_TAB
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods READ_TAB_RECORDS
    exporting
      !INFOTYPE_RECORDS type WPLOG_TAB
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  class-methods REGISTER_INSTANCE
    importing
      !HROBJECT type HROBJECT
      !CLASSNAME type CLASSNAME
      !INSTANCE type ref to CL_HRRCF_INFOTYPE .
private section.

  class-data INSTANCE_DIRECTORY type INSTANCE_DIRECTORY .
  class-data LAST_BUFFER_REFRESH type SYUZEIT .

  methods CONVERT_TO_ADF
    importing
      !TABNAME type DDOBJNAME
      !RECORD type WPLOG
    exporting
      !ADF_TAB type DCFIELDDATS
      !DFIES_TAB type DDFIELDS
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods EXTRACT_FIELD_SET_FOR_LOG_TC12
    importing
      !FIELD_SET type RCF_T_FIELDNAME
      !DATE type SYDATUM
      !IMAGE type WPLOG_TAB
    exporting
      !FIELD_DATA type RCF_T_FIELDLOG_DATA .
  methods EXTRACT_FIELD_SET_FOR_LOG_TC3
    importing
      !FIELD_SET type RCF_T_FIELDNAME
      !DATE type SYDATUM
      !IMAGE type WPLOG_TAB
    exporting
      !FIELD_DATA type RCF_T_FIELDLOG_DATA .
  methods MERGE_RECORDS_W_PLOG
    importing
      !PLOG_TAB_BEFORE type HRDBTAB_TAB
      !PLOG_TAB type HRDBTAB_TAB .
  class-methods ON_BUFFER_REFRESH
    for event RCF_BUFFER_REFRESH of CL_HRRCF_SIMPLE_MAIN_OBJECT .
ENDCLASS.



CLASS CL_HRRCF_INFOTYPE IMPLEMENTATION.


method AUTHORITY_CHECK_STATUS_CHANGE .

  AUTHORITY-CHECK OBJECT 'P_RCF_STAT'
           ID 'OTYPE' FIELD me->hrobject-otype
           ID 'RCF_STATUS' FIELD status.
  if sy-subrc = 0.
    return = true.
  else.
    return = false.
  endif.

endmethod.


METHOD check .

  DATA lt_infty_tab TYPE TABLE OF wplog .

  DATA lo_exception TYPE REF TO cx_root.

  IF operation EQ insert_operation .

*Set the basic fields
    MOVE sy-mandt TO infotype_record-mandt .
    MOVE me->hrobject-plvar TO infotype_record-plvar .
    MOVE me->hrobject-otype TO infotype_record-otype .
    MOVE me->hrobject-objid TO infotype_record-objid .
    MOVE me->my_infty TO infotype_record-infty .
    MOVE '1' TO infotype_record-istat .
  ENDIF .

  IF operation NE insert_operation .

    TRY.
        CALL METHOD me->get_records
          IMPORTING
            infotype_records = lt_infty_tab.

      CATCH cx_hrrcf_infotype_operation INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.

    ENDTRY.

    READ TABLE lt_infty_tab WITH KEY
                          plvar = infotype_record-plvar
                          otype = infotype_record-otype
                          objid = infotype_record-objid
                          subty = infotype_record-subty
                          istat = infotype_record-istat
                          begda = infotype_record-begda
                          endda = infotype_record-endda
                          varyf = infotype_record-varyf
                          seqnr = infotype_record-seqnr
                          infty = infotype_record-infty
                          TRANSPORTING NO FIELDS.

*Read the record from the database using this key for the
*before image

    IF sy-subrc <> 0 .
*Record key has been changed. Do not allow update
      IF 1 EQ 0.
        MESSAGE e005(hrrcf0001).
*   Schlüsseländerung ist nicht erlaubt
      ENDIF.

      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>wrong_date
          hrobject = me->hrobject
          infotype = infotype_record
          message_type = 'E'
          message_class = 'HRRCF0001'
          message_number = '005'.

    ENDIF .

  ENDIF .

  IF operation NE delete_operation.
* basic checks
*   - begda gt low_date
*   - begda lt endda
*   - numc fields only with digits
*   - dates consistent
*   - times consistent

    TRY.
        CALL METHOD me->check_general_plausibility
          EXPORTING
            infotype_record = infotype_record.

      CATCH cx_hrrcf_infotype_operation INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
           EXPORTING
             previous       = lo_exception.

    ENDTRY.

* foreign key check as defined within the DDIC
    TRY.
        CALL METHOD me->check_ddic
          EXPORTING
            infotype_record = infotype_record.

      CATCH cx_hrrcf INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.

    ENDTRY.

  ENDIF .

  TRY.
      CALL METHOD me->check_business_rules
        EXPORTING
          operation       = operation
        IMPORTING
          return          = return
        CHANGING
          infotype_record = infotype_record.

    CATCH cx_hrrcf_infotype_operation INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

ENDMETHOD.                    "CHECK


METHOD check_dates .

** This method checks the right format of the dates and whether the
**  start_date is <= end_date. If at least one of the dates is
**  inconsistent, then a return message is exported
** Author: Peter Enrico Vittoria


  DATA: v_date_error TYPE boole_d,
        ls_return TYPE bapiret2.


  v_date_error = false.

* -- Check begin date
  CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
    EXPORTING
      date                      = begin_date
    EXCEPTIONS
      plausibility_check_failed = 1
      OTHERS                    = 2.

  IF sy-subrc <> 0.
    v_date_error = true.
  ENDIF.

  IF end_date IS NOT INITIAL.
* -- Check end date
    CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
      EXPORTING
        date                      = end_date
      EXCEPTIONS
        plausibility_check_failed = 1
        OTHERS                    = 2.

    IF sy-subrc <> 0.
      v_date_error = true.
    ENDIF.
  ENDIF.

* output return message
  IF     v_date_error = true.

*-- only needed for where-used list and navigation
    IF 1 EQ 0.
      MESSAGE e007(hrrcf0002).
    ENDIF.

    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'E'
        cl     = 'HRRCF0002'
        number = '007'
      IMPORTING
        return = ls_return.
    APPEND ls_return TO return.

    RETURN.
  ENDIF.


* -- Check begin_date le end_date
  IF ( end_date IS NOT INITIAL ) AND ( NOT begin_date LE end_date ).

* output return message

*-- only needed for where-used list and navigation
    IF 1 EQ 0.
      MESSAGE e008(hrrcf0002).
    ENDIF.

    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'E'
        cl     = 'HRRCF0002'
        number = '008'
      IMPORTING
        return = ls_return.
    APPEND ls_return TO return.

    RETURN.
  ENDIF.

ENDMETHOD.


METHOD check_ddic .

  DATA adf_tab  TYPE dcfielddats.
  DATA adf_save TYPE dcfielddats.

  DATA dfies_tab  TYPE TABLE OF dfies.
  DATA dfies_wa   TYPE          dfies.

  DATA field_name TYPE fnam_____4.
  DATA l_field_name TYPE fnam_____4.

  FIELD-SYMBOLS <field> TYPE ANY.
  FIELD-SYMBOLS <struc> TYPE ANY.

  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA: msgid TYPE sy-msgid,
        msgty TYPE sy-msgty,
        msgno TYPE sy-msgno,
        msgv1 TYPE sy-msgv1,
        msgv2 TYPE sy-msgv2,
        msgv3 TYPE sy-msgv3,
        msgv4 TYPE sy-msgv4.

  TRY.
      CALL METHOD me->convert_to_adf
        EXPORTING
          tabname   = me->my_777d-ppnnn
          record    = infotype_record
        IMPORTING
          adf_tab   = adf_tab
          dfies_tab = dfies_tab.

    CATCH cx_hrrcf_infotype_operation INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

  adf_save = adf_tab.

  ASSIGN infotype_record TO <struc> CASTING TYPE (my_777d-ppnnn).

* DDIC-Check pro Feld
  LOOP AT dfies_tab INTO dfies_wa.

    IF dfies_wa-tabname = me->my_777d-ppnnn.
      CONCATENATE '<struc>-' dfies_wa-fieldname INTO field_name.
    ELSE.
      CONTINUE.                                             "next loop
    ENDIF.

    ASSIGN (field_name) TO <field>.
    CHECK NOT <field> IS INITIAL.
    l_field_name = dfies_wa-fieldname.

*    field_name = l_field_name.
*    READ TABLE excluded_fields FROM field_name TRANSPORTING NO FIELDS.
*    CHECK sy-subrc NE 0.

    adf_tab = adf_save.

    CALL FUNCTION 'DDUT_INPUT_CHECK'
      EXPORTING
        tabname           = dfies_wa-tabname
        fieldname         = l_field_name
        value             = <field>
      IMPORTING
        msgid             = msgid
        msgty             = msgty
        msgno             = msgno
        msgv1             = msgv1
        msgv2             = msgv2
        msgv3             = msgv3
        msgv4             = msgv4
      CHANGING
        additional_fields = adf_tab.
*     EXCEPTIONS                 "all parameters are determined
*       no_ddic_field     = 1    "by DDIC-interfaces
*       illegal_move      = 2    "  Therefore
*       OTHERS            = 3.   "    force short dump

    IF NOT msgid IS INITIAL.

      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>foreign_key_missmatch
          hrobject = me->hrobject
          infotype = infotype_record
          message_type = msgty
          message_class = msgid
          message_number = msgno
          message_par1 = msgv1
          message_par2 = msgv2
          message_par3 = msgv3
          message_par4 = msgv4.

    ENDIF.

  ENDLOOP.

ENDMETHOD.                    "CHECK_DDIC


METHOD check_general_plausibility .

  DATA lv_par1 TYPE sy-msgv1.

*Check Begin Date Consistency
  CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
    EXPORTING
      date                      = infotype_record-begda
    EXCEPTIONS
      plausibility_check_failed = 1
      OTHERS                    = 2.

  IF sy-subrc <> 0.

    IF 1 EQ 0.
      MESSAGE e002(hrrcf0001).
*   Bitte überprüfen Sie das Datum.
    ENDIF.

    WRITE infotype_record-begda TO lv_par1 DD/MM/YYYY .

*XDP Exeption (wg. begda)
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>wrong_date
        hrobject = me->hrobject
        infotype = infotype_record
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '002'
        message_par1 = lv_par1.

  ENDIF .

*Check End Date Consistency
  CALL FUNCTION 'DATE_CHECK_PLAUSIBILITY'
    EXPORTING
      date                      = infotype_record-endda
    EXCEPTIONS
      plausibility_check_failed = 1
      OTHERS                    = 2.

  IF sy-subrc <> 0.

    IF 1 EQ 0.
      MESSAGE e002(hrrcf0001).
*   Bitte überprüfen Sie das Datum.
    ENDIF.

    WRITE infotype_record-endda TO lv_par1 DD/MM/YYYY .

*XDP Exeption (wg. begda)
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>wrong_date
        hrobject = me->hrobject
        infotype = infotype_record
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '002'
        message_par1 = lv_par1.

  ENDIF .

  IF infotype_record-begda LT low_date.

    IF 1 EQ 0.
      MESSAGE e001(hrrcf0001) WITH '&'.
*   Das Datum &1 liegt vor 1900.
    ENDIF.

*XDP Exeption (wg. begda)
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>wrong_date
        hrobject = me->hrobject
        infotype = infotype_record
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '001'
        message_par1 = lv_par1.

  ENDIF.

  IF infotype_record-begda GT infotype_record-endda.
*XDP Exeption (wg. begda)
    IF 1 EQ 0.
      MESSAGE e003(hrrcf0001).
*   Das Beginndatum ist größer als das Endedatum
    ENDIF.

*XDP Exeption (wg. begda)
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>wrong_date
        hrobject = me->hrobject
        infotype = infotype_record
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '003'.

  ENDIF.

* Infotype Parameter
  IF me->my_777d IS INITIAL.
    CALL METHOD cl_hr_t777d=>read
      EXPORTING
        infty = me->my_infty
      RECEIVING
        t777d = me->my_777d.
  ENDIF.

  IF me->my_777d IS INITIAL
     OR NOT me->my_777d-papd IS INITIAL.

    IF 1 EQ 0.
      MESSAGE e004(hrrcf0001) WITH '&'.
*   Die technischen Eigenschaften des Infotyps &1 sind fehlerhaft.
    ENDIF.

    lv_par1 = me->my_infty.
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid =
          cx_hrrcf_infotype_operation=>invalid_infotype_properties
        hrobject = me->hrobject
        infotype = infotype_record
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '004'
        message_par1 = lv_par1.

  ENDIF.

ENDMETHOD.                    "


METHOD class_constructor .

  SET HANDLER on_buffer_refresh.

ENDMETHOD.


method CLEAR_LAST_BUFFER_REFRESH.
  clear last_buffer_refresh.
endmethod.


METHOD constructor.

*  SET HANDLER on_buffer_refresh.

ENDMETHOD.


METHOD convert_to_adf .

  DATA dfies_wa  TYPE dfies.
  DATA field_name TYPE fnam_____4.
  DATA adf_wa   TYPE dcfielddat.
  FIELD-SYMBOLS <struc> TYPE ANY.
  FIELD-SYMBOLS <field> TYPE ANY.

  DATA lv_message_par1 TYPE sy-msgv1.

* DDIC-Informationen zur logischen Struktur des Infotypen
  CALL FUNCTION 'DDIF_NAMETAB_GET'
    EXPORTING
      tabname   = tabname
    TABLES
      dfies_tab = dfies_tab
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.
  IF dfies_tab IS INITIAL or sy-subrc ne 0.
    IF 1 = 0.
      MESSAGE e007(e2) WITH '&'.
    ENDIF.
    lv_message_par1 = tabname.
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid =
          cx_hrrcf_infotype_operation=>wrong_infotype_database_table
        message_type = 'E'
        message_class = 'E2'
        message_number = '007'
        message_par1 = lv_message_par1.
  ENDIF.

  ASSIGN record TO <struc> CASTING TYPE (tabname).

* Infotyp in Felder zerlegen > adf_tab
  LOOP AT dfies_tab INTO dfies_wa.

    CLEAR adf_wa.

    adf_wa-tabname   = dfies_wa-tabname.
    adf_wa-fieldname = dfies_wa-fieldname.
    adf_wa-found = 'X'.

    CONCATENATE '<struc>-' dfies_wa-fieldname INTO field_name.
    ASSIGN (field_name) TO <field>.
    GET REFERENCE OF <field> INTO adf_wa-value.

    INSERT adf_wa INTO TABLE adf_tab.

  ENDLOOP.

ENDMETHOD.                    "CONVERT_TO_ADF


method delete_record .
*
* Additions: AS, XLV, PEV
*
  DATA wplog_record       TYPE          wplog.
  DATA wplog_record_tab   TYPE TABLE OF wplog.
  DATA before_image       TYPE TABLE OF wplog.
  DATA lt_plog_tab        TYPE TABLE OF hrdbtab.
  DATA lt_plog_tab_before TYPE TABLE OF hrdbtab.
  DATA ls_return          TYPE bapiret2.
  DATA lv_commit          TYPE boole_d.          "WAR1540502

  clear return . refresh return .

  call method cl_hrrcf_infotype=>pnnnn_to_wplog
    exporting
      pnnnn = infotype_record
    importing
      wplog = wplog_record.

  check not wplog_record is initial .

*  TRY.
  call method me->check
    exporting
      operation       = delete_operation
    importing
      return          = return
    changing
      infotype_record = wplog_record.

*      CATCH cx_hrrcf INTO lo_exception.
*
*        RAISE EXCEPTION TYPE cx_hrrcf
*          EXPORTING
*             previous = lo_exception.
*
*    ENDTRY.

  check return is initial.

  if check_only is initial .

    if ( cl_hrrcf_simple_main_object=>luw_mode eq true ).
      lv_commit = false.                         "WAR1540502
*     read actual before image
      call method me->get_records
        importing
          infotype_records = before_image.

      CALL FUNCTION 'RH_GET_PLOG_TAB'
        TABLES
          plog_tab_tab = lt_plog_tab_before.
    ELSE.
      IF external_commit = false.                "{WAR1540502
        lv_commit = true.
      ELSE.
        lv_commit = false.
      ENDIF.                                     "}WAR1540502
*     read record from DB
      call method me->read_records
        importing
          infotype_records = before_image.
    ENDIF.
*
    APPEND wplog_record TO wplog_record_tab.

    call function 'RH_DELETE_INFTY'
      exporting
        vtask               = 'B'
        commit_flg          = lv_commit          "WAR1540502
        authy               = 'X'
      tables
        innnn               = wplog_record_tab
      exceptions
        no_authorization    = 1
        error_during_delete = 2
        delete_first_record = 2
        corr_exit           = 2
        others              = 2.

    case sy-subrc .

      when '0' .                "Success
*
        if cl_hrrcf_simple_main_object=>luw_mode eq false.
*
          call function 'RH_UPDATE_DATABASE'
            exporting
              vtask               = 'D'          "WAR1540502
              commit_flg          = lv_commit    "WAR1540502
*            EXCEPTIONS                          "force short dump
*              CORR_EXIT           = 1
*              OTHERS              = 2
              .                                  "WAR1540502

          clear me->records .     "clear buffer
*
          try.
              call method me->read_records
                importing
                  infotype_records = me->records.
            catch cx_hrrcf_infotype_operation .         "#EC NO_HANDLER
* no reaction (xdp)
          endtry.
*
        elseif cl_hrrcf_simple_main_object=>luw_mode eq true.
*         get buffer after modify
*          call function 'RH_GET_BUFFER'
*            tables
*              buffer_tab = lt_buffer_tab.
*         restore instance buffer
*
          call function 'RH_GET_PLOG_TAB'
            tables
              plog_tab_tab = lt_plog_tab.
*
          call method me->merge_records_w_plog
            exporting
              plog_tab_before = lt_plog_tab_before
              plog_tab        = lt_plog_tab.
*
*          clear me->records.
*          loop at lt_buffer_tab into ls_buffer_tab.
*            move-corresponding ls_buffer_tab to ls_records.
*            append ls_records to me->records.
*          endloop.
*
        endif.

*       delete the related KW texts
        me->delete_text(
          exporting
            is_wplog_record = wplog_record
          importing
            et_messages     = return ).
*
      when '1' .
*
        if 1 eq 0.
          message e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        endif.

        call function 'BALW_BAPIRETURN_GET2'
          exporting
            type   = 'E'
            cl     = '5A'
            number = 278
          importing
            return = ls_return.
        append ls_return to return.

      when '2' .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        raise exception type cx_hrrcf_infotype_operation
          exporting
            textid         = cx_hrrcf_infotype_operation=>error_during_update
            hrobject       = me->hrobject
            infotype       = wplog_record
            message_type   = sy-msgty
            message_class  = sy-msgid
            message_number = sy-msgno
            message_par1   = sy-msgv1
            message_par2   = sy-msgv2
            message_par3   = sy-msgv3
            message_par4   = sy-msgv4.

    endcase .

    IF return[] IS INITIAL.                      "WAR1540502
      CALL METHOD me->on_change
        EXPORTING
          before_image    = before_image
          external_commit = external_commit.     "WAR1540502
    ENDIF.                                       "WAR1540502

  endif .

endmethod.                    "DELETE_RECORD


METHOD DELETE_TAB_RECORD .

* Additions: AS, XLV, PEV

  DATA wplog_record       TYPE          wplog.
  DATA wplog_record_tab   TYPE TABLE OF wplog.

  DATA before_image       TYPE TABLE OF wplog.

*  DATA lt_buffer_tab      TYPE TABLE OF  hrbuffer .
*  DATA ls_buffer_tab      TYPE           hrbuffer .
  DATA lt_plog_tab        TYPE TABLE OF  hrdbtab .
  DATA lt_plog_tab_before TYPE TABLE OF  hrdbtab .
*  DATA ls_records         TYPE           wplog .

  DATA ls_return TYPE bapiret2.

  CLEAR return . REFRESH return .

  CALL METHOD cl_hrrcf_infotype=>pnnnn_to_wplog
    EXPORTING
      pnnnn = infotype_record
    IMPORTING
      wplog = wplog_record.

  CHECK NOT wplog_record IS INITIAL .

*  TRY.
  CALL METHOD me->check
    EXPORTING
      operation       = delete_operation
    IMPORTING
      return          = return
    CHANGING
      infotype_record = wplog_record.

*      CATCH cx_hrrcf INTO lo_exception.
*
*        RAISE EXCEPTION TYPE cx_hrrcf
*          EXPORTING
*             previous = lo_exception.
*
*    ENDTRY.

  CHECK return IS INITIAL.

  IF check_only IS INITIAL .

    IF ( cl_hrrcf_simple_main_object=>luw_mode EQ true ).
*     read actual before image
      CALL METHOD me->get_tab_records
        IMPORTING
          infotype_records = before_image.
    ELSE.
*     read record from DB
      CALL METHOD me->read_tab_records
        IMPORTING
          infotype_records = before_image.
    ENDIF.
*
    IF  cl_hrrcf_simple_main_object=>luw_mode EQ true.
      CALL FUNCTION 'RH_GET_PLOG_TAB'
        TABLES
          plog_tab_tab = lt_plog_tab_before.
    ENDIF.
*
    APPEND wplog_record TO wplog_record_tab.

    CALL FUNCTION 'RH_DELETE_INFTY'
      EXPORTING
        vtask               = 'B'
        authy               = 'X'
      TABLES
        innnn               = wplog_record_tab
      EXCEPTIONS
        no_authorization    = 1
        error_during_delete = 2
        delete_first_record = 2
        corr_exit           = 2
        OTHERS              = 2.

    CASE sy-subrc .

      WHEN '0' .                "Success
*
        IF cl_hrrcf_simple_main_object=>luw_mode EQ false.
*
          CALL FUNCTION 'RH_UPDATE_DATABASE'
            EXPORTING
              vtask = 'D'.
*         EXCEPTIONS                  "force short dump
*           CORR_EXIT          = 1
*           OTHERS             = 2
*
          CLEAR me->records .     "clear buffer
*
          TRY.
              CALL METHOD me->read_tab_records
                IMPORTING
                  infotype_records = me->records.
            CATCH cx_hrrcf_infotype_operation .         "#EC NO_HANDLER
* no reaction (xdp)
          ENDTRY.
*
        ELSEIF cl_hrrcf_simple_main_object=>luw_mode EQ true.
*         get buffer after modify
*          call function 'RH_GET_BUFFER'
*            tables
*              buffer_tab = lt_buffer_tab.
*         restore instance buffer
*
          CALL FUNCTION 'RH_GET_PLOG_TAB'
            TABLES
              plog_tab_tab = lt_plog_tab.
*
          CALL METHOD me->merge_records_w_plog
            EXPORTING
              plog_tab_before = lt_plog_tab_before
              plog_tab        = lt_plog_tab.
*
*          clear me->records.
*          loop at lt_buffer_tab into ls_buffer_tab.
*            move-corresponding ls_buffer_tab to ls_records.
*            append ls_records to me->records.
*          endloop.
*
        ENDIF.
*
      WHEN '1' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN '2' .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            infotype = wplog_record
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .

    CALL METHOD me->on_change
      EXPORTING
        before_image = before_image.

  ENDIF .

ENDMETHOD.                    "DELETE_RECORD


method delete_text.

  data: lo_exception                  type ref to cx_hrrcf_hrkwf_storage,
        lo_dref                       type ref to data,
        lt_doc_ids                    type t77rcf_docid_tab,
        ls_doc_id                     type t77rcf_docid,
        ls_hrobject                   type hrobject,
        ls_message                    type bapiret2,
        lv_version                    type hrkwf_version,
        lv_par1                       type symsgv,
        lv_par2                       type symsgv,
        lv_par3                       type symsgv,
        lv_dummy                      type string.

  field-symbols: <lv_field>           type any,
                 <ls_structure>       type any.

  try.

      clear: et_messages.

      cl_hrrcf_t77rcf_docid=>read_all_records_for_it(
        exporting
          infty            = my_777d-infty
        receiving
          t77rcf_docid_tab = lt_doc_ids ).

      if lt_doc_ids is not initial.

        ls_hrobject-plvar = is_wplog_record-plvar.
        ls_hrobject-otype = is_wplog_record-otype.
        ls_hrobject-objid = is_wplog_record-objid.

        create data lo_dref type (me->my_777d-ppnnn).
        assign lo_dref->* to <ls_structure>.

        if sy-subrc ne 0.
          raise exception type cx_hrrcf_infotype_operation.
        endif.

        cl_hrrcf_infotype=>wplog_to_pnnnn(
          exporting
            wplog  = is_wplog_record
          importing
            pnnnn  = <ls_structure> ).

        loop at lt_doc_ids into ls_doc_id
          where docid is not initial.

          clear: lv_version.

          assign component ls_doc_id-fieldname
            of structure <ls_structure>
            to <lv_field>.

          if sy-subrc ne 0.
            raise exception type cx_hrrcf_infotype_operation.
          endif.

          lv_version = <lv_field>.

          if lv_version is not initial.

            try.

                cl_hrrcf_hrkwf_storage=>delete_doc_by_version(
                  exporting
                    doc_id   = ls_doc_id-docid
                    hrobject = ls_hrobject
                    version  = lv_version ).

              catch cx_hrrcf_hrkwf_storage into lo_exception.
                if lo_exception->message_number ne '023'      or " message 023(HRRCF0001) means that the document could not be found -> the document does
                   lo_exception->message_class  ne 'HRRCF0001'.  " not exist anymore -> it is no problem that the deletion of the document failed
                  raise exception type cx_hrrcf_hrkwf_storage.
                endif.
            endtry.

          endif.

        endloop.

      endif.

    catch cx_hrrcf.

      lv_par1 = ls_hrobject.
      lv_par2 = ls_doc_id-docid.
      lv_par3 = lv_version.

      message e302(hrrcf0001) with lv_par1 lv_par2 lv_par3 into lv_dummy.
*     Dokument &2 &3 von Objekt-ID &1 konnte nicht gelöscht werden

      call function 'BALW_BAPIRETURN_GET2'
        exporting
          type   = 'E'
          cl     = 'HRRCF0001'
          number = '302'
          par1   = lv_par1
          par2   = lv_par2
          par3   = lv_par3
        importing
          return = ls_message.

      append ls_message to et_messages.

  endtry.

endmethod.


METHOD EXTRACT_FIELD_SET_FOR_LOG_TC12 .

  DATA ls_wplog TYPE wplog.

  FIELD-SYMBOLS <field> TYPE c.
  FIELD-SYMBOLS <struc> TYPE ANY.
  DATA lp_record         TYPE REF TO data.

* get record for specific date
  LOOP AT image INTO ls_wplog WHERE begda LE date AND endda GE date.
    EXIT.
  ENDLOOP.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.

* create ddic structre
  CREATE DATA lp_record TYPE (me->my_777d-ppnnn).
  ASSIGN lp_record->* TO <struc> CASTING TYPE (me->my_777d-ppnnn).

* convert char-like to ddic
  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
    EXPORTING
      wplog = ls_wplog
    IMPORTING
      pnnnn = <struc>.

  DATA ls_field TYPE fieldname.
  DATA ls_field_data TYPE rcf_s_fieldlog_data.
  DATA ls_field_name TYPE fnam_____4.
  DATA text_identifier TYPE REF TO cl_text_identifier.
  CREATE OBJECT text_identifier.

* for each field in field set
  LOOP AT field_set INTO ls_field.
*   assign field-symbol
    CONCATENATE '<struc>-' ls_field INTO ls_field_name.
    ASSIGN (ls_field_name) TO <field> CASTING.

*   write field_value to field_data
    MOVE ls_field TO ls_field_data-fieldname.
    MOVE <field> TO ls_field_data-fieldvalue.

    CALL METHOD text_identifier->if_text_identifier~read_text
      EXPORTING
        tabname                    = me->my_777d-ppnnn
        fieldname                  = ls_field
        fieldvalue                 = <field>
      IMPORTING
        text                       = ls_field_data-fielddescription
      EXCEPTIONS
        internal_error             = 0
        illegal_call               = 0
        illegal_table              = 0
        illegal_field              = 0
        no_text                    = 0
        record_required            = 0
        illegal_record             = 0
        table_record_required      = 0
        illegal_table_record       = 0
        special_parameter_mismatch = 0
        OTHERS                     = 0.

*   append field_data
    APPEND ls_field_data TO field_data.

  ENDLOOP.

ENDMETHOD.


METHOD extract_field_set_for_log_tc3.
* Author: JDH - Adapted from EXTRACT_FIELD_SET_FOR_LOG_TC12

  DATA: ls_wplog  TYPE wplog,
        lp_record TYPE REF TO data,
        ls_field TYPE fieldname,
        ls_field_data TYPE rcf_s_fieldlog_data,
        ls_field_name TYPE fnam_____4,
        text_identifier TYPE REF TO cl_text_identifier.

  FIELD-SYMBOLS <field> TYPE c.
  FIELD-SYMBOLS <struc> TYPE any.

  CREATE OBJECT text_identifier.

  LOOP AT image INTO ls_wplog WHERE begda LE date AND endda GE date.
    CLEAR: lp_record.

* create ddic structure
    CREATE DATA lp_record TYPE (me->my_777d-ppnnn).
    ASSIGN lp_record->* TO <struc> CASTING TYPE (me->my_777d-ppnnn).

* convert char-like to ddic
    CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
      EXPORTING
        wplog = ls_wplog
      IMPORTING
        pnnnn = <struc>.

* for each field in field set
    LOOP AT field_set INTO ls_field.
      CONCATENATE '<struc>-' ls_field INTO ls_field_name.
      ASSIGN (ls_field_name) TO <field> CASTING.

      MOVE ls_field TO ls_field_data-fieldname.
      MOVE <field> TO ls_field_data-fieldvalue.

      CALL METHOD text_identifier->if_text_identifier~read_text
        EXPORTING
          tabname                    = me->my_777d-ppnnn
          fieldname                  = ls_field
          fieldvalue                 = <field>
        IMPORTING
          text                       = ls_field_data-fielddescription
        EXCEPTIONS
          internal_error             = 0
          illegal_call               = 0
          illegal_table              = 0
          illegal_field              = 0
          no_text                    = 0
          record_required            = 0
          illegal_record             = 0
          table_record_required      = 0
          illegal_table_record       = 0
          special_parameter_mismatch = 0
          OTHERS                     = 0.

      APPEND ls_field_data TO field_data.

    ENDLOOP.
  ENDLOOP.

ENDMETHOD.


method GET_BUSINESS_OBJECT .
endmethod.


method get_customer_fields.
*
* author Detlef
*
  data lv_tabname type ddobjname.

  data ls_customer_field_info type dfies.
  data ls_customer_field_helplist type rcf_s_field_helplist.

  data lt_fixed_values type ddfixvalues.
  data ls_fixed_values type ddfixvalue.

  data lt_return type table of ddshretval.
  data ls_return type ddshretval.

  if customer_field_already_read eq false.

    customer_field_already_read = true.

*   Naming convention CI_PNNNNN
    concatenate 'CI_P' me->my_infty into lv_tabname.

*   get information on customer fields
    call function 'DDIF_FIELDINFO_GET'
      exporting
        tabname        = lv_tabname
        langu          = p_langu
      tables
        dfies_tab      = customer_field_table
      exceptions
        not_found      = 1
        internal_error = 2
        others         = 3.

    if sy-subrc <> 0.
* no problem
    endif.

    if not customer_field_table is initial.

* searchhelp
      loop at customer_field_table into  ls_customer_field_info
                                   where f4availabl = true.

        if ls_customer_field_info-valexi = true. "fixed values

          clear lt_fixed_values.

* read fixed values
          call function 'DDIF_FIELDINFO_GET'
            exporting
              tabname        = lv_tabname
              langu          = p_langu
              lfieldname     = ls_customer_field_info-lfieldname
            tables
              fixed_values   = lt_fixed_values
            exceptions
              not_found      = 1
              internal_error = 2
              others         = 3.

          if sy-subrc <> 0.
* no problem
          endif.

* convert fixed values
          if not lt_fixed_values is initial.
            ls_customer_field_helplist-fieldname = ls_customer_field_info-fieldname.
            loop at lt_fixed_values into ls_fixed_values.
              ls_customer_field_helplist-field_value = ls_fixed_values-low.
              ls_customer_field_helplist-description = ls_fixed_values-ddtext.
              append ls_customer_field_helplist to customer_field_helplist.
            endloop.
          endif.

        else. "no fixed values

          clear lt_return.

* get f4 values (searchhelp)
          call function 'F4IF_FIELD_VALUE_REQUEST'
            exporting
              tabname             = ls_customer_field_info-tabname
              fieldname           = ls_customer_field_info-fieldname
              suppress_recordlist = true
            tables
              return_tab          = lt_return
            exceptions
              field_not_found     = 1
              no_help_for_field   = 2
              inconsistent_help   = 3
              no_values_found     = 4
              others              = 5.
          if sy-subrc <> 0.
* no problem
          endif.

* convert value list
          if not lt_return is initial.
            ls_customer_field_helplist-fieldname = ls_customer_field_info-fieldname.
* return contains several records for each value. Records with the same recordpos belong together
            while not lt_return is initial.
              clear ls_customer_field_helplist.
              ls_customer_field_helplist-fieldname = ls_customer_field_info-fieldname.
              read table lt_return into ls_return index 1.
              loop at lt_return into ls_return where recordpos = ls_return-recordpos. "collect infos
                if not ls_return-retfield is initial. "field value
                  ls_customer_field_helplist-field_value = ls_return-fieldval.
                else. "description
                  if ls_customer_field_helplist-description is initial.
                    ls_customer_field_helplist-description = ls_return-fieldval.
                  else.
                    concatenate ls_customer_field_helplist-description
                                ls_return-fieldval into ls_customer_field_helplist-description
                                separated by space.
                  endif.
                endif.
                delete lt_return.
              endloop.
              append ls_customer_field_helplist to customer_field_helplist.
            endwhile.
          endif.

        endif. " ls_customer_field_info-VALEXI = true

      endloop. "customer fields

    endif. "Customer Fields available

  endif. "already read

  p_field_table = customer_field_table.
  p_helplist = customer_field_helplist.

endmethod.


METHOD get_field_set_history_tc12 .

  DATA lo_infotype_log TYPE REF TO cl_hrrcf_infotype_log.

  DATA lt_infotype_log TYPE rcf_t_infotype_log.
  DATA ls_infotype_log TYPE rcf_s_infotype_log.
  DATA lt_record TYPE wplog_tab.

  DATA lt_field_data TYPE rcf_t_fieldlog_data.
  DATA ls_field_data TYPE rcf_s_fieldlog_data.
  DATA ls_former_field_data TYPE rcf_s_fieldlog_data.

  DATA ls_field_log TYPE rcf_s_fieldlog.

  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.

  DATA is_changed TYPE boole_d.

  TRY.

* check existence of fields
* xdp

* get log manager first
      CALL METHOD cl_hrrcf_infotype_log=>get_instance
        EXPORTING
          infty    = me->my_infty
          hrobject = me->hrobject
        IMPORTING
          instance = lo_infotype_log.

* get log (if available)

      CALL METHOD lo_infotype_log->get_log
        IMPORTING
          infotype_log_tab = lt_infotype_log.

      IF lt_infotype_log IS INITIAL.
        EXIT. "No log available
      ENDIF.

* read first log for before image (before switch on the log)
      READ TABLE lt_infotype_log INTO ls_infotype_log INDEX 1.
      IF sy-subrc = 0.
* get before image (if available)
        IF NOT ls_infotype_log-before_image IS INITIAL.
*   extract fields (private method)
          lt_record = ls_infotype_log-before_image.
          CLEAR lt_field_data.
          CALL METHOD me->extract_field_set_for_log_tc12
            EXPORTING
              field_set  = field_set
              date       = ls_infotype_log-date
              image      = lt_record
            IMPORTING
              field_data = lt_field_data.

          IF NOT lt_field_data IS INITIAL.
*   add fields to field_log without admin data
            CLEAR ls_field_log.
            APPEND LINES OF lt_field_data TO ls_field_log-log_data.

* append field_log for output
            APPEND ls_field_log TO field_log.
          ENDIF.

        ENDIF.

      ENDIF.

* extract logs in the given sequence
      LOOP AT lt_infotype_log INTO ls_infotype_log.
        lt_record = ls_infotype_log-after_image.
        CLEAR lt_field_data.
        CALL METHOD me->extract_field_set_for_log_tc12
          EXPORTING
            field_set  = field_set
            date       = ls_infotype_log-date
            image      = lt_record
          IMPORTING
            field_data = lt_field_data.
* condense field_log
        is_changed = false.
        LOOP AT lt_field_data INTO ls_field_data.
* read former field
          READ TABLE ls_field_log-log_data
            INTO ls_former_field_data
            WITH KEY fieldname = ls_field_data-fieldname.
* compare fieldvalue
          IF NOT ls_field_data-fieldvalue = ls_former_field_data-fieldvalue
            OR sy-subrc NE 0. " no former field.
            is_changed = true.
            EXIT.
          ENDIF.
        ENDLOOP.

* add fields to field_log without admin data
        IF is_changed EQ true. "   condense field_log
          CLEAR ls_field_log.
          ls_field_log-date = ls_infotype_log-date.
          ls_field_log-time = ls_infotype_log-time.
          ls_field_log-user = ls_infotype_log-user.
          IF NOT ls_infotype_log-user IS INITIAL.
            TRY.
                CLEAR lo_candidate.
                CALL METHOD cl_hrrcf_candidate=>get
                  EXPORTING
                    user      = ls_infotype_log-user
                  IMPORTING
                    candidate = lo_candidate.
              CATCH cx_hrrcf .
                                                        "#EC NO_HANDLER
* xdp: no reaction neccessary
            ENDTRY.
            IF lo_candidate IS BOUND.
              ls_field_log-user = lo_candidate->centraldataperson-fullname.
            ENDIF.
          ENDIF.
          APPEND LINES OF lt_field_data TO ls_field_log-log_data.
* append field_log for output
          APPEND ls_field_log TO field_log.
        ENDIF. "   condense field_log
      ENDLOOP.

    CATCH cx_hrrcf.                                     "#EC NO_HANDLER
  ENDTRY.

ENDMETHOD.


METHOD get_field_set_history_tc3.
* Author: JDH - Adapted from GET_FIELD_SET_HISTORY_TC12

  DATA lo_infotype_log TYPE REF TO cl_hrrcf_infotype_log.

  DATA lt_infotype_log TYPE rcf_t_infotype_log.
  DATA ls_infotype_log TYPE rcf_s_infotype_log.
  DATA lt_record TYPE wplog_tab.

  DATA lt_field_data TYPE rcf_t_fieldlog_data.
  DATA ls_field_data TYPE rcf_s_fieldlog_data.
  DATA ls_former_field_data TYPE rcf_s_fieldlog_data.

  DATA ls_field_log TYPE rcf_s_fieldlog.

  DATA lo_candidate TYPE REF TO cl_hrrcf_candidate.

  DATA is_changed TYPE boole_d.

  TRY.

* check existence of fields
* xdp

* get log manager first
      CALL METHOD cl_hrrcf_infotype_log=>get_instance
        EXPORTING
          infty    = me->my_infty
          hrobject = me->hrobject
        IMPORTING
          instance = lo_infotype_log.

* get log (if available)

      CALL METHOD lo_infotype_log->get_log
        IMPORTING
          infotype_log_tab = lt_infotype_log.

      IF lt_infotype_log IS INITIAL.
        EXIT. "No log available
      ENDIF.

* read first log for before image (before log was switched on)
      READ TABLE lt_infotype_log INTO ls_infotype_log INDEX 1.
      IF sy-subrc = 0.
* get before image (if available)
        IF NOT ls_infotype_log-before_image IS INITIAL.
          lt_record = ls_infotype_log-before_image.
          CLEAR lt_field_data.
          CALL METHOD me->extract_field_set_for_log_tc3
            EXPORTING
              field_set  = field_set
              date       = ls_infotype_log-date
              image      = lt_record
            IMPORTING
              field_data = lt_field_data.

          IF NOT lt_field_data IS INITIAL.
*   add fields to field_log without admin data
            CLEAR ls_field_log.
            APPEND LINES OF lt_field_data TO ls_field_log-log_data.

            APPEND ls_field_log TO field_log.
          ENDIF.
        ENDIF.
      ENDIF.

* extract logs in the given sequence
      LOOP AT lt_infotype_log INTO ls_infotype_log.
        lt_record = ls_infotype_log-after_image.
        CLEAR lt_field_data.
        CALL METHOD me->extract_field_set_for_log_tc3
          EXPORTING
            field_set  = field_set
            date       = ls_infotype_log-date
            image      = lt_record
          IMPORTING
            field_data = lt_field_data.
* condense field_log
        is_changed = false.
        LOOP AT lt_field_data INTO ls_field_data.
* read former field
          READ TABLE ls_field_log-log_data
            INTO ls_former_field_data
            WITH KEY fieldname = ls_field_data-fieldname.
* compare fieldvalue
          IF NOT ls_field_data-fieldvalue = ls_former_field_data-fieldvalue
            OR sy-subrc NE 0. " no former field.
            is_changed = true.
            EXIT.
          ENDIF.
        ENDLOOP.

* add fields to field_log without admin data
        IF is_changed EQ true. "   condense field_log
          CLEAR ls_field_log.
          ls_field_log-date = ls_infotype_log-date.
          ls_field_log-time = ls_infotype_log-time.
          ls_field_log-user = ls_infotype_log-user.
          IF NOT ls_infotype_log-user IS INITIAL.
            TRY.
                CLEAR lo_candidate.
                CALL METHOD cl_hrrcf_candidate=>get
                  EXPORTING
                    user      = ls_infotype_log-user
                  IMPORTING
                    candidate = lo_candidate.
              CATCH cx_hrrcf .
                                                        "#EC NO_HANDLER
* xdp: no reaction neccessary
            ENDTRY.
            IF lo_candidate IS BOUND.
              ls_field_log-user = lo_candidate->centraldataperson-fullname.
            ENDIF.
          ENDIF.
          APPEND LINES OF lt_field_data TO ls_field_log-log_data.
          APPEND ls_field_log TO field_log.
        ENDIF. "   condense field_log
      ENDLOOP.

    CATCH cx_hrrcf.                                     "#EC NO_HANDLER
  ENDTRY.

ENDMETHOD.


method get_instance_from_directory .
*
* Additions: AS
*
  data instance_directory_line type instance_directory_line.
  data interval  type syuzeit.
  data threshold type syuzeit value '001000'.
*
  if cl_hrrcf_simple_main_object=>luw_mode eq false.
    if last_buffer_refresh is initial.
      last_buffer_refresh = sy-uzeit.
    endif.
    interval = sy-uzeit - last_buffer_refresh.
    if interval ge threshold.
      last_buffer_refresh = sy-uzeit.
      call method cl_hrrcf_simple_main_object=>refresh_rcf_buffer.
    endif.
  endif.
*
  read table instance_directory into instance_directory_line
    with table key hrobject = hrobject classname = classname.

  if sy-subrc is initial.
    instance = instance_directory_line-instance.
  else.
    clear instance.
  endif.

endmethod.                    "GET_INSTANCE_FROM_DIRECTORY


METHOD get_records .
*  DATA lo_exception TYPE REF TO cx_hrrcf.

  IF records IS INITIAL AND me->records_already_read EQ false.
*    TRY.
        CALL METHOD me->read_records
          IMPORTING
            infotype_records = records.

*      CATCH cx_hrrcf_infotype_operation.
*    ENDTRY.
  ENDIF.

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = records
    IMPORTING
      pnnnn_tab = infotype_records.

ENDMETHOD.                    "GET_RECORDS


METHOD get_records_by_date .
  DATA lt_records TYPE wplog_tab.

*  TRY.
      CALL METHOD me->get_records
        IMPORTING
          infotype_records = lt_records.
*    CATCH cx_hrrcf_infotype_operation.
*  ENDTRY.

  DELETE lt_records WHERE begda GT date
                       OR endda LT date.

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = lt_records
    IMPORTING
      pnnnn_tab = infotype_records.

ENDMETHOD.                    "GET_RECORDS


method GET_RECORDS_BY_SUBTYPE .

  DATA lt_records TYPE wplog_tab.

*  TRY.
      CALL METHOD me->get_records
        IMPORTING
          infotype_records = lt_records.
*    CATCH cx_hrrcf_infotype_operation INTO lo_exception.
*
*      RAISE EXCEPTION TYPE cx_hrrcf
*        EXPORTING
*           previous = lo_exception.
*
*  ENDTRY.

  delete lt_records where subty ne subtype .

  if date is supplied .

    DELETE lt_records WHERE begda GT date
                         OR endda LT date.
  endif .

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = lt_records
    IMPORTING
      pnnnn_tab = infotype_records.

endmethod.                    "GET_RECORDS_BY_SUBTYPE


METHOD GET_TAB_RECORDS .
*  DATA lo_exception TYPE REF TO cx_hrrcf.

  IF records IS INITIAL AND me->records_already_read EQ false.
*    TRY.
        CALL METHOD me->read_tab_records
          IMPORTING
            infotype_records = records.

*      CATCH cx_hrrcf_infotype_operation.
*    ENDTRY.
  ENDIF.

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = records
    IMPORTING
      pnnnn_tab = infotype_records.

ENDMETHOD.                    "GET_RECORDS


METHOD GET_TAB_RECORDS_BY_DATE .
  DATA lt_records TYPE wplog_tab.

*  TRY.
      CALL METHOD me->get_tab_records
        IMPORTING
          infotype_records = lt_records.
*    CATCH cx_hrrcf_infotype_operation.
*  ENDTRY.

  DELETE lt_records WHERE begda GT date
                       OR endda LT date.

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = lt_records
    IMPORTING
      pnnnn_tab = infotype_records.

ENDMETHOD.                    "GET_RECORDS


method GET_TAB_RECORDS_BY_SUBTYPE .

  DATA lt_records TYPE wplog_tab.

*  TRY.
      CALL METHOD me->get_tab_records
        IMPORTING
          infotype_records = lt_records.
*    CATCH cx_hrrcf_infotype_operation INTO lo_exception.
*
*      RAISE EXCEPTION TYPE cx_hrrcf
*        EXPORTING
*           previous = lo_exception.
*
*  ENDTRY.

  delete lt_records where subty ne subtype .

  if date is supplied .

    DELETE lt_records WHERE begda GT date
                         OR endda LT date.
  endif .

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = lt_records
    IMPORTING
      pnnnn_tab = infotype_records.

endmethod.                    "GET_RECORDS_BY_SUBTYPE


METHOD has_data .
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lt_records TYPE wplog_tab.
  IF date IS INITIAL.
    TRY.
        CALL METHOD me->get_records
          IMPORTING
            infotype_records = lt_records.

      CATCH cx_hrrcf_infotype_operation INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.

    ENDTRY.
  ELSE.
    TRY.
        CALL METHOD me->get_records_by_date
          EXPORTING
            date             = date
          IMPORTING
            infotype_records = lt_records.
      CATCH cx_hrrcf_infotype_operation INTO lo_exception .
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.
    ENDTRY.

  ENDIF.

  IF lt_records IS INITIAL.
    return = false.
  ELSE.
    return = true.
  ENDIF.

ENDMETHOD.                    "HAS_DATA


METHOD HAS_TAB_DATA .
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lt_records TYPE wplog_tab.
  IF date IS INITIAL.
    TRY.
        CALL METHOD me->get_tab_records
          IMPORTING
            infotype_records = lt_records.

      CATCH cx_hrrcf_infotype_operation INTO lo_exception.

        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.

    ENDTRY.
  ELSE.
    TRY.
        CALL METHOD me->get_tab_records_by_date
          EXPORTING
            date             = date
          IMPORTING
            infotype_records = lt_records.
      CATCH cx_hrrcf_infotype_operation INTO lo_exception .
        RAISE EXCEPTION TYPE cx_hrrcf
          EXPORTING
             previous = lo_exception.
    ENDTRY.

  ENDIF.

  IF lt_records IS INITIAL.
    return = false.
  ELSE.
    return = true.
  ENDIF.

ENDMETHOD.                    "HAS_DATA


METHOD insert_record .
*
* Additions: XDP, AS, XLV, PEV
*
  DATA wplog_record       TYPE          wplog.
  DATA wplog_record_tab   TYPE TABLE OF wplog.
  DATA before_image       TYPE TABLE OF wplog.
  DATA ls_return          TYPE bapiret2.
  DATA lt_buffer_tab      TYPE TABLE OF hrbuffer.
  DATA ls_buffer_tab      TYPE          hrbuffer.
  DATA lt_plog_tab        TYPE TABLE OF hrdbtab.
  DATA lt_plog_tab_before TYPE TABLE OF hrdbtab.
  DATA ls_records         TYPE          wplog.
  DATA lv_commit          TYPE boole_d.          "WAR1540502
*
  CLEAR return. REFRESH return .

  CALL METHOD cl_hrrcf_infotype=>pnnnn_to_wplog
    EXPORTING
      pnnnn = infotype_record
    IMPORTING
      wplog = wplog_record.

  CHECK NOT wplog_record IS INITIAL .

*  TRY.
  CALL METHOD me->check
    EXPORTING
      operation       = insert_operation
    IMPORTING
      return          = return
    CHANGING
      infotype_record = wplog_record.

*    CATCH cx_hrrcf INTO lo_exception.
*
*      RAISE EXCEPTION TYPE cx_hrrcf
*        EXPORTING
*           previous = lo_exception.
*
*  ENDTRY.

  CHECK return IS INITIAL.

  IF check_only IS INITIAL .

    IF cl_hrrcf_simple_main_object=>luw_mode EQ true.
      lv_commit = false.                         "WAR1540502
*     read actual before image
      CALL METHOD me->get_records
        IMPORTING
          infotype_records = before_image.

      CALL FUNCTION 'RH_GET_PLOG_TAB'
        TABLES
          plog_tab_tab = lt_plog_tab_before.
    ELSE.
      IF external_commit EQ false.               "{WAR1540502
        lv_commit = true.
      ELSE.
        lv_commit = false.
      ENDIF.                                     "}WAR1540502
*     read record from DB
      CALL METHOD me->read_records
        IMPORTING
          infotype_records = before_image.
    ENDIF.
*
    APPEND wplog_record TO wplog_record_tab.
*
    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'B'
        commit_flg          = lv_commit          "WAR1540502
        authy               = 'X'
      TABLES
        innnn               = wplog_record_tab
      EXCEPTIONS
        no_authorization    = 1
        error_during_insert = 2
        repid_form_initial  = 2
        corr_exit           = 2
        begda_greater_endda = 2
        OTHERS              = 2.
*
    CASE sy-subrc .
      WHEN '0' .                "Success
*
        CALL FUNCTION 'RH_GET_PLOG_TAB'
          TABLES
            plog_tab_tab = lt_plog_tab.
*
        IF cl_hrrcf_simple_main_object=>luw_mode = false.

          READ TABLE lt_plog_tab INTO wplog_record WITH KEY opera = 'I'. "PD-Insert

          CALL FUNCTION 'RH_UPDATE_DATABASE'
            EXPORTING
              vtask               = 'D'          "WAR1540502
              commit_flg          = lv_commit    "WAR1540502
*            EXCEPTIONS                          "force short dump
*              CORR_EXIT          = 1
*              OTHERS             = 2
              .                                  "WAR1540502

          CLEAR me->records .     "clear buffer

          TRY.
              CALL METHOD me->read_records
                IMPORTING
                  infotype_records = me->records.
            CATCH cx_hrrcf_infotype_operation .         "#EC NO_HANDLER
* no reaction (xdp)
          ENDTRY.

        ELSEIF cl_hrrcf_simple_main_object=>luw_mode = true.

* get buffer after modify
          CALL FUNCTION 'RH_GET_BUFFER'
            TABLES
              buffer_tab = lt_buffer_tab.

* get changed record from buffer
          MOVE-CORRESPONDING wplog_record TO ls_records.
          READ TABLE lt_buffer_tab INTO ls_buffer_tab
             WITH KEY plvar = ls_records-plvar
                      otype = ls_records-otype
                      objid = ls_records-objid
                      subty = ls_records-subty
                      istat = ls_records-istat
                      begda = ls_records-begda
                      endda = ls_records-endda
                      varyf = ls_records-varyf
                      vdata = ls_records-vdata.

          MOVE-CORRESPONDING ls_buffer_tab TO wplog_record.

* restore instance buffer
          CALL METHOD me->merge_records_w_plog
            EXPORTING
              plog_tab_before = lt_plog_tab_before
              plog_tab        = lt_plog_tab.
        ENDIF.

      WHEN '1' .
*
        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN '2' .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            hrobject = me->hrobject
            infotype = wplog_record
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.
    ENDCASE .

    IF return[] IS INITIAL.                      "WAR1540502
      CALL METHOD me->on_change
        EXPORTING
          before_image    = before_image
          external_commit = external_commit.     "WAR1540502
    ENDIF.                                       "WAR1540502

  ENDIF .

* changes back to parameter
  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
    EXPORTING
      wplog = wplog_record
    IMPORTING
      pnnnn = infotype_record.

ENDMETHOD.                    "


METHOD insert_tab_record .

  DATA wplog_record           TYPE          wplog.
  DATA wplog_record_tab       TYPE TABLE OF wplog.
  DATA lt_wplog_record_tab    TYPE TABLE OF wplog.

  DATA before_image       TYPE TABLE OF wplog.

  DATA ls_return          TYPE bapiret2.

  DATA lt_buffer_tab      TYPE TABLE OF  hrbuffer .
  DATA ls_buffer_tab      TYPE           hrbuffer .
  DATA lt_plog_tab        TYPE TABLE OF  hrdbtab .
  DATA lt_plog_tab_before TYPE TABLE OF  hrdbtab .
  DATA ls_records         TYPE           wplog .
*
  CLEAR return. REFRESH return .

  CALL METHOD cl_hrrcf_infotype=>pnnnn_to_wplog_tab
    EXPORTING
      pnnnn_tab = infotype_records
    IMPORTING
      wplog_tab = lt_wplog_record_tab.

  CHECK NOT lt_wplog_record_tab IS INITIAL .

  LOOP AT lt_wplog_record_tab INTO wplog_record.
*  TRY.
    CALL METHOD me->check
      EXPORTING
        operation       = insert_operation
      IMPORTING
        return          = return
      CHANGING
        infotype_record = wplog_record.

*    CATCH cx_hrrcf INTO lo_exception.
*
*      RAISE EXCEPTION TYPE cx_hrrcf
*        EXPORTING
*           previous = lo_exception.
*
*  ENDTRY.

    CHECK return IS INITIAL.

    APPEND wplog_record TO wplog_record_tab.

  ENDLOOP.

  IF check_only IS INITIAL .

    IF ( cl_hrrcf_simple_main_object=>luw_mode EQ true ).
*     read actual before image
      CALL METHOD me->get_tab_records
        IMPORTING
          infotype_records = before_image.
    ELSE.
*     read record from DB
      CALL METHOD me->read_tab_records
        IMPORTING
          infotype_records = before_image.
    ENDIF.

    IF  cl_hrrcf_simple_main_object=>luw_mode EQ true.
      CALL FUNCTION 'RH_GET_PLOG_TAB'
        TABLES
          plog_tab_tab = lt_plog_tab_before.
    ENDIF.
*
    CALL FUNCTION 'RH_INSERT_INFTY_EXP'
      EXPORTING
        vtask                  = 'B'
        authy                  = 'X'
      TABLES
        innnn_exp              = wplog_record_tab
      EXCEPTIONS
        no_authorization       = 1
        error_during_insert    = 2
        corr_exit              = 2
        begda_greater_endda    = 2
        no_innnn_tnnnn         = 2
        additional_innnn_tnnnn = 2
        OTHERS                 = 2.

*
    CASE sy-subrc .
      WHEN '0' .                "Success
*
        CALL FUNCTION 'RH_GET_PLOG_TAB'
          TABLES
            plog_tab_tab = lt_plog_tab.
*
        IF cl_hrrcf_simple_main_object=>luw_mode = false.

          READ TABLE lt_plog_tab INTO wplog_record WITH KEY opera = 'I'. "PD-Insert

          CALL FUNCTION 'RH_UPDATE_DATABASE'
            EXPORTING
              vtask = 'D'.
*         EXCEPTIONS                  "force short dump
*           CORR_EXIT          = 1
*           OTHERS             = 2

          CLEAR me->records .     "clear buffer

          TRY.
              CALL METHOD me->read_tab_records
                IMPORTING
                  infotype_records = me->records.
            CATCH cx_hrrcf_infotype_operation .         "#EC NO_HANDLER
* no reaction (xdp)
          ENDTRY.

        ELSEIF cl_hrrcf_simple_main_object=>luw_mode = true.

* get buffer after modify
          CALL FUNCTION 'RH_GET_BUFFER'
            TABLES
              buffer_tab = lt_buffer_tab.

* get changed record from buffer
          MOVE-CORRESPONDING wplog_record TO ls_records.
          READ TABLE lt_buffer_tab INTO ls_buffer_tab
             WITH KEY plvar = ls_records-plvar
                      otype = ls_records-otype
                      objid = ls_records-objid
                      subty = ls_records-subty
                      istat = ls_records-istat
                      begda = ls_records-begda
                      endda = ls_records-endda
                      varyf = ls_records-varyf
                      vdata = ls_records-vdata.

          MOVE-CORRESPONDING ls_buffer_tab TO wplog_record.

* restore instance buffer
          CALL METHOD me->merge_records_w_plog
            EXPORTING
              plog_tab_before = lt_plog_tab_before
              plog_tab        = lt_plog_tab.
*          clear me->records.
*
*          loop at lt_buffer_tab into ls_buffer_tab.
*            move-corresponding ls_buffer_tab to ls_records.
*            append ls_records to me->records.
*          endloop.

        ENDIF.

      WHEN '1' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN '2' .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            hrobject = me->hrobject
            infotype = wplog_record
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.
    ENDCASE .

    CALL METHOD me->on_change
      EXPORTING
        before_image = before_image.

  ENDIF .

* changes back to parameter
  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = wplog_record_tab
    IMPORTING
      pnnnn_tab = infotype_records.

ENDMETHOD.                    "


METHOD merge_records_w_plog.
* XLV
* After writing data to PD-buffer (insert/update/delete) we must
* update the instance buffer of E-Recruiting. The first approach
* using FM RH_GET_BUFFER was not sufficient, since
* a) the PD-buffer contains only the changed records, but not
*    the unchanged. Example: If an employee has address data and
*    email me->records contains two entries, one for subtype 0000
*    and one for subtype 0003. When we change the address, the FM
*    returns only the new record of subtype 0000, but not the old
*    of subtype 0003
* b) the PD-buffer may also contain records from previous IT-changes
*    which must not be stored in the instance directory
* So we use the current PLOG_TAB, i.e. after we wrote to PD-buffer,
* and process those records, which came new into that table, i.e.
* do not exist in PLOG_TAB before writing to PD-buffer
*
  DATA:
    ls_wplog           TYPE wplog,
    lt_plog_tab_before TYPE hrdbtab_tab.
*
  FIELD-SYMBOLS:
    <plog>             TYPE hrdbtab.
*
* Merge is only necessary if LUW-mode is set, i.e. PD-buffer is used
  IF cl_hrrcf_simple_main_object=>luw_mode EQ true.
*
* work on a local copy of plog_tab_before
    lt_plog_tab_before = plog_tab_before.
*
    LOOP AT plog_tab ASSIGNING <plog> WHERE infty EQ me->my_infty.
      READ TABLE lt_plog_tab_before
        WITH KEY
          mandt      = <plog>-mandt
          plvar      = <plog>-plvar
          otype      = <plog>-otype
          objid      = <plog>-objid
          infty      = <plog>-infty
          subty      = <plog>-subty
          istat      = <plog>-istat
          priox      = <plog>-priox
          begda      = <plog>-begda
          endda      = <plog>-endda
          varyf      = <plog>-varyf
          seqnr      = <plog>-seqnr
          aedtm      = <plog>-aedtm
          uname      = <plog>-uname
          reasn      = <plog>-reasn
          histo      = <plog>-histo
          itxnr      = <plog>-itxnr
          opera      = <plog>-opera
          vsign      = <plog>-vsign
          primary_wf = <plog>-primary_wf
          lfcod      = <plog>-lfcod
        TRANSPORTING NO FIELDS.
*
      IF sy-subrc IS INITIAL.
*     To make sure that an entry in the before-image is only used
*     to neutralize one entry we delete it after 'usage'
        DELETE lt_plog_tab_before INDEX sy-tabix.
      ELSE.
        CLEAR ls_wplog.
        MOVE-CORRESPONDING <plog> TO ls_wplog.
        CASE <plog>-opera.
          WHEN 'I'.
            APPEND ls_wplog TO me->records.
          WHEN 'D'.
            READ TABLE me->records
                                WITH KEY
                                  mandt      = <plog>-mandt
                                  plvar      = <plog>-plvar
                                  otype      = <plog>-otype
                                  objid      = <plog>-objid
                                  infty      = <plog>-infty
                                  subty      = <plog>-subty
                                  istat      = <plog>-istat
                                  priox      = <plog>-priox
                                  begda      = <plog>-begda
                                  endda      = <plog>-endda
                                  varyf      = <plog>-varyf
                                  seqnr      = <plog>-seqnr
                                  aedtm      = <plog>-aedtm
                                  uname      = <plog>-uname
                                  reasn      = <plog>-reasn
                                  histo      = <plog>-histo
                                  itxnr      = <plog>-itxnr
                                TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              DELETE me->records INDEX sy-tabix.
            ENDIF.
          WHEN 'U'.
*           Statement "MODIFY TABLE me->records FROM ls_wplog" does not work here because of vdata (it is considered as a key!!!).
            READ TABLE me->records
                    WITH KEY
                      mandt      = <plog>-mandt
                      plvar      = <plog>-plvar
                      otype      = <plog>-otype
                      objid      = <plog>-objid
                      infty      = <plog>-infty
                      subty      = <plog>-subty
                      istat      = <plog>-istat
                      priox      = <plog>-priox
                      begda      = <plog>-begda
                      endda      = <plog>-endda
                      varyf      = <plog>-varyf
                      seqnr      = <plog>-seqnr
                      aedtm      = <plog>-aedtm
                      uname      = <plog>-uname
                      reasn      = <plog>-reasn
                      histo      = <plog>-histo
                      itxnr      = <plog>-itxnr
                    TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              MODIFY me->records INDEX sy-tabix FROM ls_wplog.
            ENDIF.
        ENDCASE.
      ENDIF.
*
    ENDLOOP.
*
  ENDIF.
*
ENDMETHOD.


METHOD on_buffer_refresh .

  CLEAR instance_directory.
* Deactivate handler: Old instances will be deleted by the garbage collector
  SET HANDLER on_buffer_refresh ACTIVATION ' '.

* Activate handler: New instances will react to the event
  SET HANDLER on_buffer_refresh.

ENDMETHOD.


METHOD on_change .

  DATA oref               TYPE REF TO cx_hrrcf.
  DATA lo_infty_log       TYPE REF TO cl_hrrcf_infotype_log.
  DATA lv_external_commit TYPE        boole_d.
  DATA lo_trxlist_admin   TYPE REF TO if_hrrcf_trxlist_deltaindex.

  IF cl_hrrcf_simple_main_object=>luw_mode = false.

    CALL METHOD cl_hrrcf_simple_main_object=>refresh_rcf_buffer.
    lv_external_commit = external_commit.        "WAR1540502
  ELSE.
    lv_external_commit = true.
  ENDIF.

  TRY.

      CALL METHOD cl_hrrcf_spt_change_pointer=>insert_change_pointer
        EXPORTING
          hrobject        = me->hrobject
          external_commit = lv_external_commit.

    CATCH cx_hrrcf INTO oref.
* we write the log and continue the program logic
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = oref.
  ENDTRY.

* Write change pointers for CDCY LIST
******************************************************
  CALL METHOD cl_hrrcf_trxlist_admin=>get_instance
    IMPORTING
      eo_trxlist_admin = lo_trxlist_admin.

  CALL METHOD lo_trxlist_admin->insert_change_pointer
    EXPORTING
      is_hrobject = me->hrobject.

  TRY.
      CALL METHOD cl_hrrcf_infotype_log=>get_instance
        EXPORTING
          infty    = me->my_infty
          hrobject = me->hrobject
        IMPORTING
          instance = lo_infty_log.

      CALL METHOD lo_infty_log->add_log
        EXPORTING
          before_image = before_image
          after_image  = me->records.

    CATCH cx_hrrcf INTO oref.
* we write the log and continue the program logic
      CALL METHOD cl_hrrcf_exception_handler=>write_exception_log
        EXPORTING
          ex = oref.
  ENDTRY.

  RAISE EVENT rcf_infotype_record_changed
    EXPORTING
      hrrcf_infotype_object = me
      before_image          = before_image
      external_commit       = external_commit.   "WAR1540502

ENDMETHOD.


METHOD pnnnn_to_wplog .

  FIELD-SYMBOLS <wplog> TYPE c.

  ASSIGN pnnnn TO <wplog> CASTING.
  wplog = <wplog>.

ENDMETHOD.                    "


method PNNNN_TO_WPLOG_TAB .

  FIELD-SYMBOLS <wplog> TYPE c.
  FIELD-SYMBOLS <pnnnn> TYPE ANY.

  CLEAR wplog_tab[].
  LOOP AT pnnnn_tab ASSIGNING <pnnnn>.
    ASSIGN <pnnnn> to <wplog> CASTING.
    APPEND <wplog> TO wplog_tab.
  ENDLOOP.

endmethod.                    "


METHOD read_all_text .

  DATA lt_infty_text_tab TYPE rcf_t_hrkwf_infty_text.
  DATA ls_infty_text_tab TYPE rcf_s_hrkwf_infty_text.

  DATA lt_infotype_record TYPE wplog_tab.
  DATA ls_infotype_record TYPE wplog.

  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lv_par1 TYPE sy-msgv1.

  FIELD-SYMBOLS <field> TYPE ANY.
  FIELD-SYMBOLS <struc> TYPE ANY.

  DATA l_field_name TYPE fieldname.

  DATA l77rcf_docid TYPE t77rcf_docid.

  CLEAR infty_text_tab.

  CALL METHOD cl_hrrcf_t77rcf_docid=>read_record
    EXPORTING
      infty        = my_777d-infty
      fieldname    = fieldname
    IMPORTING
      t77rcf_docid = l77rcf_docid.

  IF l77rcf_docid-docid IS INITIAL.

    IF 1 EQ 2.
      MESSAGE e006(hrrcf0001) WITH '&' '&'.
*   Dokumentart &1 für Infotyp &2 nicht eingerichtet
    ENDIF.

    lv_par1 = l77rcf_docid.
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>invalid_docid
        hrobject = me->hrobject
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '006'
        message_par1 = lv_par1.

  ENDIF.

  CALL METHOD cl_hrrcf_hrkwf_storage=>read_all_infty_text
    EXPORTING
      doc_id         = l77rcf_docid-docid
      hrobject       = me->hrobject
      langu          = langu
    IMPORTING
      infty_text_tab = lt_infty_text_tab.

  CHECK NOT lt_infty_text_tab IS INITIAL.

  CALL METHOD me->get_records_by_date
    EXPORTING
      date             = sy-datum
    IMPORTING
      infotype_records = lt_infotype_record.

  CONCATENATE '<struc>-' fieldname INTO l_field_name.
  ASSIGN ls_infotype_record TO <struc> CASTING TYPE (my_777d-ppnnn).
  ASSIGN (l_field_name) TO <field>.

  LOOP AT lt_infotype_record INTO ls_infotype_record.

    READ TABLE lt_infty_text_tab INTO ls_infty_text_tab
               WITH KEY version = <field>.
    IF sy-subrc = 0.
      APPEND ls_infty_text_tab TO infty_text_tab.
    ENDIF.
  ENDLOOP.

ENDMETHOD.                    "UPDATE_TEXT


METHOD read_records .
  DATA:
    lv_subrc TYPE sysubrc.
*
  CLEAR infotype_records[].

  IF cl_hrrcf_object_buffer=>is_object_buffer_active( ) = abap_true.
    CALL METHOD cl_hrrcf_object_buffer=>get_object_buffer_nnnn
      EXPORTING
        pv_iplvar = me->hrobject-plvar
        pv_iotype = me->hrobject-otype
        pv_iobjid = me->hrobject-objid
        pv_iinfty = me->my_infty
        pv_iistat = '1'
      IMPORTING
        pt_ennnn  = infotype_records
        pv_esubrc = lv_subrc.
  ELSE.
    CALL FUNCTION 'RH_READ_INFTY'
      EXPORTING
        authority                  = 'DISP'
        with_stru_auth             = ' '                    "N2098095
        plvar                      = me->hrobject-plvar
        otype                      = me->hrobject-otype
        objid                      = me->hrobject-objid
        infty                      = me->my_infty
        istat                      = '1'
*       SUBTY                      = ' '
        begda                      = low_date
        endda                      = high_date
      TABLES
        innnn                      = infotype_records
      EXCEPTIONS
        all_infty_with_subty       = 1
        nothing_found              = 0
        no_objects                 = 3
        wrong_condition            = 4
        wrong_parameters           = 5
        OTHERS                     = 6 .
    lv_subrc = sy-subrc.
  ENDIF.

  IF lv_subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
        hrobject = me->hrobject
*       INFOTYPE =
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ELSE.
    records_already_read = true.
  ENDIF.

ENDMETHOD.                    "


METHOD READ_TAB_RECORDS .
  DATA:
    lv_subrc TYPE sysubrc.
*
  CLEAR infotype_records[].

  IF cl_hrrcf_object_buffer=>is_object_buffer_active( ) = abap_true.
    CALL METHOD cl_hrrcf_object_buffer=>get_object_buffer_nnnn
      EXPORTING
        pv_iplvar = me->hrobject-plvar
        pv_iotype = me->hrobject-otype
        pv_iobjid = me->hrobject-objid
        pv_iinfty = me->my_infty
        pv_iistat = '1'
      IMPORTING
        pt_ennnn  = infotype_records
        pv_esubrc = lv_subrc.
  ELSE.
    CALL FUNCTION 'RH_READ_INFTY_NNNN_EXP'
      EXPORTING
        AUTHORITY                   = 'DISP'
        WITH_STRU_AUTH              = 'X'
        PLVAR                       = me->hrobject-plvar
        OTYPE                       = me->hrobject-otype
        OBJID                       = me->hrobject-objid
        infty                       = me->my_infty
        ISTAT                       = ' '
        EXTEND                      = 'X'
        SUBTY                       = ' '
        BEGDA                       = low_date
        ENDDA                       = high_date
*       CONDITION                   = '00000'
*       SORT                        = 'X'
      tables
        innnn                       = infotype_records
*       OBJECTS                     =
     EXCEPTIONS
       NOTHING_FOUND               = 0
       WRONG_CONDITION             = 4
       INFOTYP_NOT_SUPPORTED       = 7
       WRONG_PARAMETERS            = 5
       OTHERS                      = 6.
    lv_subrc = sy-subrc.
  ENDIF.

  IF lv_subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
        hrobject = me->hrobject
*       INFOTYPE =
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ELSE.
    records_already_read = true.
  ENDIF.

ENDMETHOD.                    "


METHOD read_text .
  DATA lo_exception TYPE REF TO cx_hrrcf.
  DATA lv_par1 TYPE sy-msgv1.

  FIELD-SYMBOLS <field> TYPE ANY.
  FIELD-SYMBOLS <struc> TYPE ANY.

  DATA l_field_name TYPE fieldname.

  DATA lv_version     TYPE hrkwf_version.
  DATA l77rcf_docid TYPE t77rcf_docid.

  CLEAR text.
  CLEAR langu_tab.
  CLEAR doc_langu.

  CALL METHOD cl_hrrcf_t77rcf_docid=>read_record
    EXPORTING
      infty        = my_777d-infty
      fieldname    = fieldname
    IMPORTING
      t77rcf_docid = l77rcf_docid.

  IF l77rcf_docid-docid IS INITIAL.

    IF 1 EQ 2.
      MESSAGE e006(hrrcf0001) WITH '&' '&'.
*   Dokumentart &1 für Infotyp &2 nicht eingerichtet
    ENDIF.

    lv_par1 = l77rcf_docid.
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>invalid_docid
        hrobject = me->hrobject
*        infotype = infotype_record
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '006'
        message_par1 = lv_par1.

  ENDIF.

  ASSIGN infotype_record TO <struc> CASTING TYPE (my_777d-ppnnn).

  CONCATENATE '<struc>-' fieldname INTO l_field_name.
  ASSIGN (l_field_name) TO <field>.

  lv_version = <field>.

  CHECK lv_version CN ' 0'.

  TRY.
      CALL METHOD cl_hrrcf_hrkwf_storage=>read_infty_text
        EXPORTING
          hrobject     = me->hrobject
          version      = lv_version
          doc_id       = l77rcf_docid-docid
          langu        = langu
          use_fallback = use_fallback
        IMPORTING
          text         = text
          doc_langu    = doc_langu
          langu_tab    = langu_tab.

    CATCH cx_hrrcf INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

ENDMETHOD.                    "UPDATE_TEXT


METHOD refresh_instance_directory .

  FIELD-SYMBOLS: <lo>                    TYPE REF TO cl_hrrcf_infotype,
                 <ls_instance_directory> TYPE instance_directory_line.


*  LOOP AT instance_directory ASSIGNING <ls_instance_directory>.
*    ASSIGN <ls_instance_directory>-instance TO <lo>.
*    FREE <lo>.
*  ENDLOOP.

  CLEAR instance_directory.

ENDMETHOD.                    "REFRESH_INSTANCE_DIRECTORY


method REGISTER_INSTANCE .

  DATA instance_directory_line TYPE instance_directory_line.

    instance_directory_line-hrobject  = hrobject.
    instance_directory_line-classname = classname.
    instance_directory_line-instance  = instance.

    INSERT instance_directory_line INTO TABLE instance_directory.

endmethod.


METHOD reset_records_buffer.

* Author: PEV

  CLEAR me->records.

  CLEAR me->records_already_read.

ENDMETHOD.


METHOD update_record .
*
* Additions: AS, XLV, PEV
*
  DATA wplog_record       TYPE          wplog.
  DATA wplog_record_tab   TYPE TABLE OF wplog.
  DATA before_image       TYPE TABLE OF wplog.
  DATA lt_buffer_tab      TYPE TABLE OF hrbuffer.
  DATA ls_buffer_tab      TYPE          hrbuffer.
  DATA lt_plog_tab        TYPE TABLE OF hrdbtab.
  DATA lt_plog_tab_before TYPE TABLE OF hrdbtab.
  DATA ls_records         TYPE          wplog.
  DATA ls_return          TYPE bapiret2.
  DATA lv_commit          TYPE boole_d.          "WAR1540502

  CLEAR return . REFRESH return .

  CALL METHOD cl_hrrcf_infotype=>pnnnn_to_wplog
    EXPORTING
      pnnnn = infotype_record
    IMPORTING
      wplog = wplog_record.

  CHECK NOT wplog_record IS INITIAL .

*  TRY.
  CALL METHOD me->check
    EXPORTING
      operation       = modify_operation
    IMPORTING
      return          = return
    CHANGING
      infotype_record = wplog_record.

*    CATCH cx_hrrcf INTO lo_exception.
*
*      RAISE EXCEPTION TYPE cx_hrrcf
*        EXPORTING
*           previous = lo_exception.
*
*  ENDTRY.

  CHECK return IS INITIAL.

  IF check_only IS INITIAL .

    IF cl_hrrcf_simple_main_object=>luw_mode EQ true.
      lv_commit = false.                         "WAR1540502
*     read actual before image
      CALL METHOD me->get_records
        IMPORTING
          infotype_records = before_image.

      CALL FUNCTION 'RH_GET_PLOG_TAB'
        TABLES
          plog_tab_tab = lt_plog_tab_before.
    ELSE.
      IF external_commit EQ false.               "{WAR1540502
        lv_commit = true.
      ELSE.
        lv_commit = false.
      ENDIF.                                     "}WAR1540502
*     read record from DB
      CALL METHOD me->read_records
        IMPORTING
          infotype_records = before_image.
    ENDIF.
*
    APPEND wplog_record TO wplog_record_tab.

    CALL FUNCTION 'RH_UPDATE_INFTY'
      EXPORTING
        vtask               = 'B'
        commit_flg          = lv_commit          "WAR1540502
        authy               = 'X'
      TABLES
        innnn               = wplog_record_tab
      EXCEPTIONS
        no_authorization    = 1
        error_during_update = 2
        repid_form_initial  = 2
        corr_exit           = 2
        OTHERS              = 2.

    CASE sy-subrc .

      WHEN '0' .                "Success
*
        CALL FUNCTION 'RH_GET_PLOG_TAB'
          TABLES
            plog_tab_tab = lt_plog_tab.
*
        IF cl_hrrcf_simple_main_object=>luw_mode EQ false.
*
          READ TABLE lt_plog_tab INTO wplog_record WITH KEY opera = 'U'. "PD-Update
*
          CALL FUNCTION 'RH_UPDATE_DATABASE'
            EXPORTING
              vtask               = 'D'          "WAR1540502
              commit_flg          = lv_commit    "WAR1540502
*            EXCEPTIONS                          "force short dump
*              CORR_EXIT           = 1
*              OTHERS              = 2
              .                                  "WAR1540502

          CLEAR me->records .     "clear buffer
*
          TRY.
              CALL METHOD me->read_records
                IMPORTING
                  infotype_records = me->records.
            CATCH cx_hrrcf_infotype_operation .         "#EC NO_HANDLER
*           no reaction (xdp)
          ENDTRY.
*
        ELSEIF cl_hrrcf_simple_main_object=>luw_mode EQ true.
*         get buffer after modify
          CALL FUNCTION 'RH_GET_BUFFER'
            TABLES
              buffer_tab = lt_buffer_tab.
*         get changed record from buffer
          MOVE-CORRESPONDING wplog_record TO ls_records.
          READ TABLE lt_buffer_tab INTO ls_buffer_tab
             WITH KEY plvar = ls_records-plvar
                      otype = ls_records-otype
                      objid = ls_records-objid
                      subty = ls_records-subty
                      istat = ls_records-istat
                      begda = ls_records-begda
                      endda = ls_records-endda
                      varyf = ls_records-varyf
                      vdata = ls_records-vdata.
          MOVE-CORRESPONDING ls_buffer_tab TO wplog_record.
*         restore instance buffer me->records
          CALL METHOD me->merge_records_w_plog
            EXPORTING
              plog_tab_before = lt_plog_tab_before
              plog_tab        = lt_plog_tab.
        ENDIF.

      WHEN '1' .
*
        IF 1 EQ 0.
          MESSAGE e278(5a).
*         Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN '2' .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            infotype = wplog_record
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .

    IF return[] IS INITIAL.                      "WAR1540502
      CALL METHOD me->on_change
        EXPORTING
          before_image    = before_image
          external_commit = external_commit.     "WAR1540502
    ENDIF.                                       "WAR1540502

  ENDIF .

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn
    EXPORTING
      wplog = wplog_record
    IMPORTING
      pnnnn = infotype_record.

ENDMETHOD.                    "UPDATE_RECORD


METHOD update_tab_record .

  DATA wplog_record           TYPE          wplog.
  DATA wplog_record_tab       TYPE TABLE OF wplog.
  DATA lt_wplog_record_tab    TYPE TABLE OF wplog.

  DATA before_image       TYPE TABLE OF wplog.

  DATA lt_buffer_tab      TYPE TABLE OF  hrbuffer .
  DATA ls_buffer_tab      TYPE           hrbuffer .
  DATA lt_plog_tab        TYPE TABLE OF  hrdbtab .
  DATA lt_plog_tab_before TYPE TABLE OF  hrdbtab .
  DATA ls_records         TYPE           wplog .

  DATA ls_return TYPE bapiret2.

  CLEAR return . REFRESH return .

  CALL METHOD cl_hrrcf_infotype=>pnnnn_to_wplog_tab
    EXPORTING
      pnnnn_tab = infotype_records
    IMPORTING
      wplog_tab = lt_wplog_record_tab.

  CHECK NOT lt_wplog_record_tab IS INITIAL .

  LOOP AT lt_wplog_record_tab INTO wplog_record.
*  TRY.
    CALL METHOD me->check
      EXPORTING
        operation       = insert_operation
      IMPORTING
        return          = return
      CHANGING
        infotype_record = wplog_record.

*    CATCH cx_hrrcf INTO lo_exception.
*
*      RAISE EXCEPTION TYPE cx_hrrcf
*        EXPORTING
*           previous = lo_exception.
*
*  ENDTRY.

    CHECK return IS INITIAL.

    APPEND wplog_record TO wplog_record_tab.

  ENDLOOP.

  IF check_only IS INITIAL .

    IF ( cl_hrrcf_simple_main_object=>luw_mode EQ true ).
*     read actual before image
      CALL METHOD me->get_tab_records
        IMPORTING
          infotype_records = before_image.
    ELSE.
*     read record from DB
      CALL METHOD me->read_tab_records
        IMPORTING
          infotype_records = before_image.
    ENDIF.

    IF  cl_hrrcf_simple_main_object=>luw_mode EQ true.
      CALL FUNCTION 'RH_GET_PLOG_TAB'
        TABLES
          plog_tab_tab = lt_plog_tab_before.
    ENDIF.
*
    CALL FUNCTION 'RH_UPDATE_INFTY_EXP'
      EXPORTING
        vtask                  = 'B'
        authy                  = 'X'
      TABLES
        innnn_exp              = wplog_record_tab
      EXCEPTIONS
        error_during_update    = 2
        no_authorization       = 1
        corr_exit              = 2
        no_innnn_tnnnn         = 2
        additional_innnn_tnnnn = 2
        OTHERS                 = 2.

    CASE sy-subrc .

      WHEN '0' .                "Success
*
        CALL FUNCTION 'RH_GET_PLOG_TAB'
          TABLES
            plog_tab_tab = lt_plog_tab.
*
        IF cl_hrrcf_simple_main_object=>luw_mode EQ false.
*
          READ TABLE lt_plog_tab INTO wplog_record WITH KEY opera = 'U'. "PD-Update
*
          CALL FUNCTION 'RH_UPDATE_DATABASE'
            EXPORTING
              vtask = 'D'.
*         EXCEPTIONS                  "force short dump
*           CORR_EXIT          = 1
*           OTHERS             = 2
*
          CLEAR me->records .     "clear buffer
*
          TRY.
              CALL METHOD me->read_tab_records
                IMPORTING
                  infotype_records = me->records.
            CATCH cx_hrrcf_infotype_operation .         "#EC NO_HANDLER
* no reaction (xdp)
          ENDTRY.
*
        ELSEIF cl_hrrcf_simple_main_object=>luw_mode EQ true.
*         get buffer after modify
          CALL FUNCTION 'RH_GET_BUFFER'
            TABLES
              buffer_tab = lt_buffer_tab.
*         get changed record from buffer
          MOVE-CORRESPONDING wplog_record TO ls_records.
          READ TABLE lt_buffer_tab INTO ls_buffer_tab
             WITH KEY plvar = ls_records-plvar
                      otype = ls_records-otype
                      objid = ls_records-objid
                      subty = ls_records-subty
                      istat = ls_records-istat
                      begda = ls_records-begda
                      endda = ls_records-endda
                      varyf = ls_records-varyf
                      vdata = ls_records-vdata.
          MOVE-CORRESPONDING ls_buffer_tab TO wplog_record.
*         restore instance buffer me->records
          CALL METHOD me->merge_records_w_plog
            EXPORTING
              plog_tab_before = lt_plog_tab_before
              plog_tab        = lt_plog_tab.
*          CLEAR me->records.
*          LOOP AT lt_buffer_tab INTO ls_buffer_tab.
*            MOVE-CORRESPONDING ls_buffer_tab TO ls_records.
*            APPEND ls_records TO me->records.
*          ENDLOOP.
*
        ENDIF.
      WHEN '1' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN '2' .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            infotype = wplog_record
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .

    CALL METHOD me->on_change
      EXPORTING
        before_image = before_image.

  ENDIF .

  CALL METHOD cl_hrrcf_infotype=>wplog_to_pnnnn_tab
    EXPORTING
      wplog_tab = wplog_record_tab
    IMPORTING
      pnnnn_tab = infotype_records.

ENDMETHOD.                    "UPDATE_TAB_RECORD


METHOD update_text .
  DATA lv_par1 TYPE sy-msgv1.

  FIELD-SYMBOLS <field> TYPE ANY.
  FIELD-SYMBOLS <struc> TYPE ANY.

  DATA l_field_name TYPE fieldname.

  DATA lv_version     TYPE hrkwf_version.
  DATA lv_new_version TYPE hrkwf_version.

  DATA l77rcf_docid TYPE t77rcf_docid.

  CALL METHOD cl_hrrcf_t77rcf_docid=>read_record
    EXPORTING
      infty        = my_777d-infty
      fieldname    = fieldname
    IMPORTING
      t77rcf_docid = l77rcf_docid.

  IF l77rcf_docid-docid IS INITIAL.

    IF 1 EQ 2.
      MESSAGE e006(hrrcf0001) WITH '&' '&'.
*   Dokumentart &1 für Infotyp &2 nicht eingerichtet
    ENDIF.

    lv_par1 = l77rcf_docid.
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>invalid_docid
        hrobject = me->hrobject
        message_type = 'E'
        message_class = 'HRRCF0001'
        message_number = '006'
        message_par1 = lv_par1.

  ENDIF.

  ASSIGN infotype_record TO <struc> CASTING TYPE (my_777d-ppnnn).

  CONCATENATE '<struc>-' fieldname INTO l_field_name.
  ASSIGN (l_field_name) TO <field>.

  lv_version = <field>.

  CHECK NOT ( lv_version IS INITIAL AND text IS INITIAL ). "XJG20011126

*  TRY.
  CALL METHOD cl_hrrcf_hrkwf_storage=>update_infty_text
    EXPORTING
      hrobject    = me->hrobject
      version     = lv_version
      doc_id      = l77rcf_docid-docid
      text        = text
      langu       = langu
    IMPORTING
      new_version = lv_new_version.
*      CATCH cx_hrrcf INTO lo_exception.
*
*        RAISE EXCEPTION TYPE cx_hrrcf
*          EXPORTING
*             previous = lo_exception.
*
*    ENDTRY.

  <field> = lv_new_version.

ENDMETHOD.                    "UPDATE_TEXT


method WPLOG_TO_PNNNN .

  FIELD-SYMBOLS <pnnnn> TYPE c.

  ASSIGN pnnnn TO <pnnnn> CASTING.
  <pnnnn> = wplog.

endmethod.


method WPLOG_TO_PNNNN_TAB .

  FIELD-SYMBOLS <pnnnn> TYPE ANY.
  FIELD-SYMBOLS <wplog> TYPE c.

  DATA pnnnn_ref TYPE REF TO data.


  CREATE DATA pnnnn_ref LIKE LINE OF pnnnn_tab.
  ASSIGN pnnnn_ref->* TO <pnnnn>.
  ASSIGN pnnnn_ref->* TO <wplog> CASTING.

  CLEAR pnnnn_tab[].
  LOOP AT wplog_tab INTO <wplog>.
    APPEND <pnnnn> TO pnnnn_tab.
  ENDLOOP.

endmethod.
ENDCLASS.