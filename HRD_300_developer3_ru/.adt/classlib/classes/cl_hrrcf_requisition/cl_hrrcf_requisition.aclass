class CL_HRRCF_REQUISITION definition
  public
  inheriting from CL_HRRCF_SIMPLE_MAIN_OBJECT
  final
  create private

  global friends CL_HRRCF_DELETE_MANAGER
                 CL_HRRCF_SIMPLE_MAIN_OBJECT .

public section.
*"* public components of class CL_HRRCF_REQUISITION
*"* do not include other source files here!!!

  constants MY_OTYPE type OTYPE value 'NB'. "#EC NOTEXT
  constants MY_CLASSNAME type SEOCLSNAME value 'CL_HRRCF_REQUISITION'. "#EC NOTEXT

  class-methods CREATE
    importing
      !NAME type STEXT optional
    exporting
      !REQUISITION type ref to CL_HRRCF_REQUISITION
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .
  class-methods GET
    importing
      !ID type HROBJID optional
    exporting
      !REQUISITION type ref to CL_HRRCF_REQUISITION
    raising
      CX_HRRCF .
  methods ASSIGN_CANDIDACY
    importing
      !CANDIDACY type ref to CL_HRRCF_CANDIDACY
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_CANDIDACIES
    exporting
      !CANDIDACY_LIST type RCF_T_CANDIDACY
      !ET_CANDIDACY_LIST_HROBJECT type RCF_T_HROBJECT
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods GET_REQUISITION_STATUS
    importing
      !P_DATE type DATS default SY-DATUM
      !P_LANGU type SPRAS default SY-LANGU
    exporting
      !P_STATUS type RCF_REQUISITION_STATUS
      !P_STATUS_TXT type DDTEXT
      !P_REASON_CODE type RCF_REASON_CODE
      !P_REASON_CODE_TXT type RCF_REASON_CODE_TXT
    raising
      CX_HRRCF .
  methods GET_POSTINGS
    exporting
      !POSTING_LIST type RCF_T_POSTING
    raising
      CX_HRRCF_INFOTYPE_OPERATION
      CX_HRRCF .
  methods DELIMIT_POSTING
    importing
      !POSTING type ref to CL_HRRCF_POSTING
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods ASSIGN_POSTING
    importing
      !POSTING type ref to CL_HRRCF_POSTING
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods DELIMIT_CANDIDACY
    importing
      !CANDIDACY type ref to CL_HRRCF_CANDIDACY
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods ASSIGN_VACANCY
    importing
      !POSITION type HROBJECT-OBJID
      value(PRIOX) type PRIOX default SPACE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_VACANCY_OF_REQUISITION
    exporting
      !VACANCY_LIST type RCF_T_REQUISITION_VACANCY
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods DELIMIT_VACANCY
    importing
      !POSITION type HROBJECT-OBJID
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF_INFOTYPE_OPERATION .
  methods GET_STATUS_REASON_HISTORY
    exporting
      !FIELD_LOG type RCF_T_FIELDLOG .
  methods GET_RELEASED_DATE
    exporting
      !RELEASED_DATE type SYDATUM .
  methods GET_CLOSED_DATE
    exporting
      !CLOSED_DATE type SYDATUM .
  class-methods GET_NUMBER_CDCY_ASSIGNED
    importing
      !PT_REQUISITIONS type RCF_T_HROBJECT
    exporting
      !PT_REQUISITIONS_NO_CDCY type RCF_T_REQUISITION_NO_CDCY .
  methods LEGAL_CHECK_BEFORE_DELETE
    exporting
      !RETURN type BAPIRETTAB
    raising
      CX_HRRCF .

  methods DELETE
    redefinition .
protected section.
*"* protected components of class CL_HRRCF_REQUISITION
*"* do not include other source files here!!!

  methods CHECK_BEFORE_DELETE
    redefinition .
private section.
*"* private components of class CL_HRRCF_REQUISITION
*"* do not include other source files here!!!
ENDCLASS.



CLASS CL_HRRCF_REQUISITION IMPLEMENTATION.


METHOD assign_candidacy .
* XDP Copy Object: Interface

* XDP Copy Object
  CONSTANTS c_rsign TYPE p1001-rsign VALUE 'B'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '654'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA l_plvar TYPE plvar.

  DATA ls_return TYPE bapiret2.

  DATA lv_commit TYPE boole_d.

* XDP Copy Object
  IF NOT candidacy IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = l_plvar.
    ls_relation-otype = me->my_otype.
    ls_relation-objid = me->id.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = c_rsign.
    ls_relation-relat = c_relat.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
* XDP Copy Object
    ls_relation-sclas = candidacy->my_otype.
* XDP Copy Object
    ls_relation-sobid = candidacy->id.
    APPEND ls_relation TO lt_relation.

    IF cl_hrrcf_simple_main_object=>luw_mode = true.
      lv_commit = false.
    ELSE.
      lv_commit = true.
    ENDIF.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
        commit_flg          = lv_commit
      TABLES
        innnn               = lt_relation
      EXCEPTIONS
        no_authorization    = 1
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '1' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .

  ENDIF.
  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.


ENDMETHOD.                    "


METHOD assign_posting .
* XDP Copy Object: Interface

* XDP Copy Object
  CONSTANTS c_rsign TYPE p1001-rsign VALUE 'B'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '652'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA l_plvar TYPE plvar.

  DATA ls_return TYPE bapiret2.

  DATA lv_commit TYPE boole_d.

* XDP Copy Object
  IF NOT posting IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = l_plvar.
    ls_relation-otype = me->my_otype.
    ls_relation-objid = me->id.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = c_rsign.
    ls_relation-relat = c_relat.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
* XDP Copy Object
    ls_relation-sclas = posting->my_otype.
* XDP Copy Object
    ls_relation-sobid = posting->id.
    APPEND ls_relation TO lt_relation.

    IF cl_hrrcf_simple_main_object=>luw_mode = true.
      lv_commit = false.
    ELSE.
      lv_commit = true.
    ENDIF.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
        commit_flg          = lv_commit
      TABLES
        innnn               = lt_relation
      EXCEPTIONS
        no_authorization    = 1
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '1' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .

  ENDIF.
  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD ASSIGN_VACANCY .
* XDP Copy Object: Interface

* XDP Copy Object
  CONSTANTS c_rsign TYPE p1001-rsign VALUE 'B'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '657'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.

  DATA l_plvar TYPE plvar.

  DATA ls_return TYPE bapiret2.

* XDP Copy Object
  IF NOT position IS INITIAL.

    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
      EXPORTING
        set_default_plvar = 'X'
      IMPORTING
        act_plvar         = l_plvar
      EXCEPTIONS
        no_active_plvar   = 0
        OTHERS            = 0.

    ls_relation-mandt = sy-mandt.
    ls_relation-plvar = l_plvar.
    ls_relation-otype = me->my_otype.
    ls_relation-objid = me->id.
    ls_relation-infty = '1001'.
    ls_relation-istat = '1'.
    ls_relation-rsign = c_rsign.
    ls_relation-relat = c_relat.
    ls_relation-begda = sy-datum.
    ls_relation-endda = '99991231'.
    ls_relation-priox = priox.
* XDP Copy Object
    ls_relation-sclas = 'S'.
* XDP Copy Object
    ls_relation-sobid = position.
    APPEND ls_relation TO lt_relation.

    CALL FUNCTION 'RH_INSERT_INFTY'
      EXPORTING
        vtask               = 'D'
      TABLES
        innnn               = lt_relation
      EXCEPTIONS
        no_authorization    = 1
        error_during_insert = 2
        repid_form_initial  = 3
        corr_exit           = 4
        begda_greater_endda = 5
        OTHERS              = 6.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '1' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_insert
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .

  ENDIF.
  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD check_before_delete .
*Author:SGS
*This method checks if the object in question allows to be deleted

  DATA : lv_req_status TYPE rcf_requisition_status ,
         ls_return TYPE bapiret2 .

  CLEAR return .REFRESH return .

  CALL METHOD me->get_requisition_status
    IMPORTING
      p_status = lv_req_status.

  IF lv_req_status NE '3' .            "to be deleted
    IF 1 EQ 0.
      MESSAGE e064(hrrcf0002).
*       Requisition cannot be deleted as it is still in process
    ENDIF.

    CALL FUNCTION 'BALW_BAPIRETURN_GET2'
      EXPORTING
        type   = 'E'
        cl     = 'HRRCF0002'
        number = 064
      IMPORTING
        return = ls_return.
    APPEND ls_return TO return.
  ENDIF .

ENDMETHOD.


METHOD create .
* XDP Copy Object: Interface Requisition
  DATA lo_instance TYPE REF TO cl_hrrcf_simple_main_object.
  DATA lo_exception TYPE REF TO cx_hrrcf.

  TRY.
      CALL METHOD cl_hrrcf_simple_main_object=>create_internal
        EXPORTING
          name      = name
          otype     = my_otype
          classname = my_classname
        IMPORTING
          instance  = lo_instance
          return    = return.

    CATCH cx_hrrcf INTO lo_exception.

* XDP Copy Object
      CLEAR requisition.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

* XDP Copy Object
  requisition ?= lo_instance.

ENDMETHOD.                    "


METHOD delete .

  DATA : lt_return          TYPE bapirettab ,
         lo_exception       TYPE REF TO cx_hrrcf,
         lo_trxlist_admin   TYPE REF TO if_hrrcf_trxlist_deltaindex.

  TRY.
      CALL METHOD super->delete
        IMPORTING
          return = lt_return.
      APPEND LINES OF lt_return TO return .

      CALL METHOD cl_hrrcf_t77rcf_va2nb=>delete_by_requi
        EXPORTING
          iv_requi = me->hrobject-objid.

* Push changes for LIST
******************************************************
      CALL METHOD cl_hrrcf_trxlist_admin=>get_instance
        IMPORTING
          eo_trxlist_admin = lo_trxlist_admin.

      CALL METHOD lo_trxlist_admin->push_changes
        EXPORTING
          is_hrobject = me->hrobject
          iv_upd_flag = if_hrrcf_trxlist_deltaindex=>gc_upd_flag_delete.

    CATCH cx_hrrcf_maintain_object INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf_maintain_object
        EXPORTING
          previous = lo_exception.

    CATCH cx_hrrcf_infotype_operation INTO lo_exception.

      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          previous = lo_exception.

  ENDTRY.

ENDMETHOD.


METHOD DELIMIT_CANDIDACY .
* XDP Copy Object: Interface

* XDP Copy Object
  CONSTANTS c_subty TYPE plog-subty VALUE 'B654'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA lt_object TYPE TABLE OF hrobject.
  DATA l_objid TYPE plog-objid.

  DATA delimitdate TYPE  sydatum.
  DATA lt_delimt_record TYPE TABLE OF p1001.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA ls_return TYPE bapiret2.

  delimitdate = sy-datum - 1.
  APPEND me->hrobject TO lt_object.

  CALL FUNCTION 'RH_READ_INFTY'
    EXPORTING
      infty                = '1001'
      istat                = '1'
      subty                = c_subty
      begda                = delimitdate
    TABLES
      innnn                = lt_relation
      OBJECTS              = lt_object
    EXCEPTIONS
      all_infty_with_subty = 1
      nothing_found        = 0
      no_objects           = 3
      wrong_condition      = 4
      OTHERS               = 5.
  IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
        hrobject = me->hrobject
*       INFOTYPE =
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ENDIF.

* XDP Copy Object
  LOOP AT    lt_relation
       INTO  ls_relation
             WHERE begda LT delimitdate
               AND sobid = candidacy->hrobject-objid.
    APPEND ls_relation TO lt_delimt_record.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'RH_CUT_INFTY'
      EXPORTING
        vtask               = 'D'
        gdate              = delimitdate
        histo              = space
      TABLES
        innnn              = lt_delimt_record
      EXCEPTIONS
        error_during_cut   = 1
        no_authorization   = 2
        gdate_before_begda = 3
        cut_of_timco_one   = 4
        corr_exit          = 5
        OTHERS             = 6.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '2' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .
  ENDIF.


  REFRESH lt_delimt_record.
* XDP Copy Object
  LOOP AT    lt_relation
       INTO  ls_relation
             WHERE begda gE delimitdate
               AND sobid = candidacy->hrobject-objid.
    APPEND ls_relation TO lt_delimt_record.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'RH_DELETE_INFTY'
      EXPORTING
        vtask               = 'D'
      TABLES
        innnn               = lt_delimt_record
      EXCEPTIONS
        error_during_delete = 1
        no_authorization    = 2
        delete_first_record = 3
        corr_exit           = 4
        OTHERS              = 5.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '2' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .
  ENDIF.
  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD delimit_posting .
* XDP Copy Object: Interface

* XDP Copy Object
  CONSTANTS c_subty TYPE plog-subty VALUE 'B652'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA lt_object TYPE TABLE OF hrobject.
  DATA l_objid TYPE plog-objid.

  DATA delimitdate TYPE  sydatum.
  DATA lt_delimt_record TYPE TABLE OF p1001.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA ls_return TYPE bapiret2.

  delimitdate = sy-datum - 1.
  APPEND me->hrobject TO lt_object.

  CALL FUNCTION 'RH_READ_INFTY'
    EXPORTING
      infty                = '1001'
      istat                = '1'
      subty                = c_subty
      begda                = delimitdate
    TABLES
      innnn                = lt_relation
      OBJECTS              = lt_object
    EXCEPTIONS
      all_infty_with_subty = 1
      nothing_found        = 0
      no_objects           = 3
      wrong_condition      = 4
      OTHERS               = 5.
  IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
        hrobject = me->hrobject
*       INFOTYPE =
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ENDIF.

* XDP Copy Object
  LOOP AT    lt_relation
       INTO  ls_relation
             WHERE begda LT delimitdate
               AND sobid = posting->hrobject-objid.
    APPEND ls_relation TO lt_delimt_record.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'RH_CUT_INFTY'
      EXPORTING
        vtask               = 'D'
        gdate              = delimitdate
        histo              = space
      TABLES
        innnn              = lt_delimt_record
      EXCEPTIONS
        error_during_cut   = 1
        no_authorization   = 2
        gdate_before_begda = 3
        cut_of_timco_one   = 4
        corr_exit          = 5
        OTHERS             = 6.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '2' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .
  ENDIF.


  REFRESH lt_delimt_record.
* XDP Copy Object
  LOOP AT    lt_relation
       INTO  ls_relation
             WHERE begda gE delimitdate
               AND sobid = posting->hrobject-objid.
    APPEND ls_relation TO lt_delimt_record.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'RH_DELETE_INFTY'
      EXPORTING
        vtask               = 'D'
      TABLES
        innnn               = lt_delimt_record
      EXCEPTIONS
        error_during_delete = 1
        no_authorization    = 2
        delete_first_record = 3
        corr_exit           = 4
        OTHERS              = 5.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '2' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .
  ENDIF.
  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD delimit_vacancy .
* XDP Copy Object: Interface

* XDP Copy Object
  CONSTANTS c_subty TYPE plog-subty VALUE 'B657'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA lt_object TYPE TABLE OF hrobject.
  DATA l_objid TYPE plog-objid.

  DATA delimitdate TYPE  sydatum.
  DATA lt_delimt_record TYPE TABLE OF p1001.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA ls_return TYPE bapiret2.

  delimitdate = sy-datum - 1.
  APPEND me->hrobject TO lt_object.

  CALL FUNCTION 'RH_READ_INFTY'
    EXPORTING
      infty                = '1001'
      istat                = '1'
      subty                = c_subty
      begda                = delimitdate
    TABLES
      innnn                = lt_relation
      OBJECTS              = lt_object
    EXCEPTIONS
      all_infty_with_subty = 1
      nothing_found        = 0
      no_objects           = 3
      wrong_condition      = 4
      OTHERS               = 5.
  IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
    RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
      EXPORTING
        textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
        hrobject = me->hrobject
*       INFOTYPE =
        message_type = sy-msgty
        message_class = sy-msgid
        message_number = sy-msgno
        message_par1 = sy-msgv1
        message_par2 = sy-msgv2
        message_par3 = sy-msgv3
        message_par4 = sy-msgv4.
  ENDIF.

* XDP Copy Object
  LOOP AT    lt_relation
       INTO  ls_relation
             WHERE begda LT delimitdate
               AND sobid = position.
    APPEND ls_relation TO lt_delimt_record.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'RH_CUT_INFTY'
      EXPORTING
        vtask              = 'D'
        gdate              = delimitdate
        histo              = space
      TABLES
        innnn              = lt_delimt_record
      EXCEPTIONS
        error_during_cut   = 1
        no_authorization   = 2
        gdate_before_begda = 3
        cut_of_timco_one   = 4
        corr_exit          = 5
        OTHERS             = 6.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '2' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .
  ENDIF.


  REFRESH lt_delimt_record.
* XDP Copy Object
  LOOP AT    lt_relation
       INTO  ls_relation
             WHERE begda GE delimitdate
               AND sobid = position.
    APPEND ls_relation TO lt_delimt_record.
  ENDLOOP.
  IF sy-subrc = 0.
    CALL FUNCTION 'RH_DELETE_INFTY'
      EXPORTING
        vtask               = 'D'
      TABLES
        innnn               = lt_delimt_record
      EXCEPTIONS
        error_during_delete = 1
        no_authorization    = 2
        delete_first_record = 3
        corr_exit           = 4
        OTHERS              = 5.
    CASE sy-subrc .

      WHEN '0' .                "Success

      WHEN '2' .

        IF 1 EQ 0.
          MESSAGE e278(5a).
*   Sie haben keine Berechtigung zum Ausführen dieser Funktion
        ENDIF.

        CALL FUNCTION 'BALW_BAPIRETURN_GET2'
          EXPORTING
            type   = 'E'
            cl     = '5A'
            number = 278
          IMPORTING
            return = ls_return.
        APPEND ls_return TO return.

      WHEN OTHERS .
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
        RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
          EXPORTING
            textid = cx_hrrcf_infotype_operation=>error_during_update
            hrobject = me->hrobject
            message_type = sy-msgty
            message_class = sy-msgid
            message_number = sy-msgno
            message_par1 = sy-msgv1
            message_par2 = sy-msgv2
            message_par3 = sy-msgv3
            message_par4 = sy-msgv4.

    ENDCASE .
  ENDIF.
  RAISE EVENT rcf_relationship_changed
    EXPORTING
      hrobject = me->hrobject.

ENDMETHOD.                    "


METHOD get .
* XDP Copy Object: Interface requisition

  DATA lo_instance TYPE REF TO cl_hrrcf_simple_main_object.
  DATA lo_exception TYPE REF TO cx_hrrcf.

  TRY.
      CALL METHOD cl_hrrcf_simple_main_object=>get_internal
        EXPORTING
          otype     = my_otype
          id        = id
          classname = my_classname
        IMPORTING
          instance  = lo_instance.

    CATCH cx_hrrcf INTO lo_exception.

* XDP Copy Object
      CLEAR requisition.

      RAISE EXCEPTION TYPE cx_hrrcf
        EXPORTING
           previous = lo_exception.

  ENDTRY.

* XDP Copy Object
  requisition ?= lo_instance.

ENDMETHOD.                    "


METHOD get_candidacies .
* XDP Copy Object: Interface candidacy_List

* XDP Copy Object
  CONSTANTS c_subty TYPE plog-subty VALUE 'B654'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '654'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA l_objid TYPE plog-objid.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA lo_object TYPE REF TO object.
* XDP Copy Object
  DATA lo_candidacy TYPE REF TO cl_hrrcf_candidacy.
  DATA:
    lv_subrc TYPE sysubrc.
  DATA: ls_hrobject TYPE hrobject.

* XDP Copy Object
  CLEAR candidacy_list.

*Check whether records for the  relationshiptype exists in buffer


  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = candidacy_list.


* if no recprds exist, read from database

  IF candidacy_list IS INITIAL.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = c_subty
        ps_ihrobject = me->hrobject
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid         = cx_hrrcf_infotype_operation=>error_during_read
*         PREVIOUS       =
          hrobject       = me->hrobject
*         INFOTYPE       =
          message_type   = sy-msgty
          message_class  = sy-msgid
          message_number = sy-msgno
          message_par1   = sy-msgv1
          message_par2   = sy-msgv2
          message_par3   = sy-msgv3
          message_par4   = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.

      IF et_candidacy_list_hrobject IS SUPPLIED.

        ls_hrobject-plvar = ls_relation-plvar.
        ls_hrobject-otype = ls_relation-sclas.
        ls_hrobject-objid = ls_relation-sobid.
        APPEND ls_hrobject TO et_candidacy_list_hrobject.
      ENDIF.

      IF candidacy_list IS SUPPLIED.

        TRY.

            l_objid = ls_relation-sobid.

* XDP Copy Object
            CALL METHOD cl_hrrcf_candidacy=>get
              EXPORTING
                id        = l_objid
              IMPORTING
                candidacy = lo_candidacy.

* XDP Copy Object
            APPEND lo_candidacy TO candidacy_list.

          CATCH cx_hrrcf INTO lo_exception.

            RAISE EXCEPTION TYPE cx_hrrcf
              EXPORTING
                previous = lo_exception.

        ENDTRY.
      ENDIF.
    ENDLOOP.

*  register records in the buffer

    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = candidacy_list.


  ENDIF.


ENDMETHOD.                    "


METHOD get_closed_date .
*
* Author: XLV
*
* This method should determine the highest date
* the requisition was closed. If this date could not be determined
* the export parameter will be cleared.
*
  CONSTANTS:
    c_closed            TYPE rcf_requisition_status VALUE '2'.
*
  DATA:
    lo_requisition_info TYPE REF TO   cl_hrrcf_requisition_info,
    lv_det_by_log       TYPE          boole_d,
    ls_p5125            TYPE          p5125,
    lt_requisition_info TYPE TABLE OF p5125,
    ls_log_data         TYPE          rcf_s_fieldlog_data,
    ls_field_log        TYPE          rcf_s_fieldlog,
    lt_field_log        TYPE          rcf_t_fieldlog,
    lt_field_set        TYPE          rcf_t_fieldname.
*
  closed_date = low_date.
*
  CALL METHOD cl_hrrcf_requisition_info=>get_instance
    EXPORTING
      hrobject = me->hrobject
    IMPORTING
      instance = lo_requisition_info.
*
  IF lo_requisition_info IS BOUND.
*
    APPEND 'STATUS' TO lt_field_set.
*
    CALL METHOD lo_requisition_info->get_field_set_history_tc12
      EXPORTING
        field_set = lt_field_set
      IMPORTING
        field_log = lt_field_log.
*
  ENDIF.
*
  IF lt_field_log IS INITIAL.
*  No entry in the log means we can not use it to determine
*  the correct date
    lv_det_by_log = false.
  ELSE.
    CLEAR ls_field_log.
    READ TABLE lt_field_log WITH KEY
      date = ls_field_log-date
      time = ls_field_log-time
      user = ls_field_log-user
      TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.
*    If one entry like this exists the log has been switched on
*    after the requisition has been created, so we can not trust
*    the log
      lv_det_by_log = false.
    ELSE.
      lv_det_by_log = true.
    ENDIF.
  ENDIF.
*
  IF lv_det_by_log = true.
*    sort lt_field_log by begda.
    LOOP AT lt_field_log INTO ls_field_log.
      READ TABLE ls_field_log-log_data
        INTO ls_log_data
        WITH KEY
          fieldname = 'STATUS'
          fieldvalue = c_closed.
      IF sy-subrc IS INITIAL AND closed_date < ls_field_log-date.
        closed_date = ls_field_log-date.
      ENDIF.
    ENDLOOP.
  ELSE.
    TRY.
        CALL METHOD lo_requisition_info->get_records
          IMPORTING
            infotype_records = lt_requisition_info.
      CATCH cx_hrrcf_infotype_operation .
* released_date could not be determined ==> clear return value
* Do we need an entry in the log?
        CLEAR closed_date.
        RETURN.
    ENDTRY.
*    sort lt_requisition_info by begda.
    LOOP AT lt_requisition_info INTO ls_p5125
      WHERE status = c_closed.
      IF closed_date < ls_p5125-begda.
        closed_date = ls_p5125-begda.
      ENDIF.
    ENDLOOP.
  ENDIF.
*
* released_date could not be determined ==> clear return value
  IF closed_date = low_date.
    CLEAR closed_date.
  ENDIF.
*
ENDMETHOD.


METHOD get_number_cdcy_assigned.

* Additions: PEV

  TYPES: BEGIN OF ty_req_cdcy_struc,
           plvar            TYPE plvar,
           otype            TYPE otype,
           objid            TYPE hrobjid,
           sobid            TYPE sobid,
           candidacy_status TYPE rcf_candidacy_status,
         END OF ty_req_cdcy_struc.

  TYPES: BEGIN OF ty_s_hrotjid,
           plvar            TYPE plvar,
           otjid            TYPE otjid,
         END OF ty_s_hrotjid.

  CONSTANTS:
    lc_status_draft         TYPE n      VALUE '4',
    lc_status_in_process    TYPE n      VALUE '0',
    lc_status_rejected      TYPE n      VALUE '2',
    lc_subty                TYPE subtyp VALUE 'B654',
    lc_status               TYPE c      VALUE '1',
    lc_otype_cdcy           TYPE otype  VALUE 'NE'.

  DATA:
    lv_tabix                TYPE sy-tabix,
    lv_count                TYPE i,
    lv_num_total            TYPE int4,
    lv_num_in_process       TYPE int4,
    lv_num_rejected         TYPE int4,
    lv_num_unread           TYPE int4,
    lt_requisitions_no_cdcy TYPE rcf_t_requisition_no_cdcy,
    lt_req_cdcy             TYPE TABLE OF ty_req_cdcy_struc,
    ls_requisitions_no_cdcy TYPE rcf_s_requisition_no_cdcy,
    ls_cdcy_to_be_checked   TYPE hrobject,
    lt_cdcy_unread          TYPE rcf_t_hrobject,
    lt_cdcy_to_be_checked   TYPE rcf_t_hrobject,
    ls_hrotjid              TYPE ty_s_hrotjid,
    lt_hrotjid              TYPE TABLE OF ty_s_hrotjid.

  FIELD-SYMBOLS:
    <ls_requisitions>       TYPE hrobject,
    <ls_req_cdcy>           TYPE ty_req_cdcy_struc,
    <ls_req_cdcy_next>      TYPE ty_req_cdcy_struc.
*
  IF pt_requisitions IS INITIAL.
    CLEAR pt_requisitions_no_cdcy.
    RETURN.
  ENDIF.

  LOOP AT        pt_requisitions
       ASSIGNING <ls_requisitions>.

    ls_hrotjid-plvar = <ls_requisitions>-plvar.
    CONCATENATE <ls_requisitions>-otype
                <ls_requisitions>-objid
           INTO ls_hrotjid-otjid.
    APPEND ls_hrotjid
        TO lt_hrotjid.

  ENDLOOP.

* inner join HRP1001 and HRP5133
  SELECT
    hrp1001~plvar
    hrp1001~otype
    hrp1001~objid
    hrp1001~sobid
    hrp5133~candidacy_status

    INTO CORRESPONDING FIELDS OF TABLE lt_req_cdcy

    FROM hrp1001 INNER JOIN hrp5133 ON
         hrp1001~plvar = hrp5133~plvar  AND
         hrp1001~varyf = hrp5133~otjid

    FOR ALL entries IN lt_hrotjid WHERE
         hrp1001~plvar  = lt_hrotjid-plvar AND
         hrp1001~otjid  = lt_hrotjid-otjid AND
         hrp1001~subty  = lc_subty         AND
         hrp1001~sclas  = lc_otype_cdcy    AND
         hrp1001~istat  = lc_status        AND

         hrp5133~candidacy_status NE lc_status_draft AND
         hrp1001~begda <= sy-datum       AND
         hrp1001~endda >= sy-datum       AND
         hrp5133~begda <= sy-datum       AND
         hrp5133~endda >= sy-datum.

* sort table
  SORT lt_req_cdcy
    BY objid candidacy_status.

* determine which candidacies in table lt_req_cdcy are in table
* t77rcf_wl_object (i.e. are unread)
  LOOP AT        lt_req_cdcy
       ASSIGNING <ls_req_cdcy>.
    ls_cdcy_to_be_checked-plvar = <ls_req_cdcy>-plvar.
    ls_cdcy_to_be_checked-otype = lc_otype_cdcy.
    ls_cdcy_to_be_checked-objid = <ls_req_cdcy>-sobid.
    APPEND ls_cdcy_to_be_checked
        TO lt_cdcy_to_be_checked.
  ENDLOOP.

  lt_cdcy_unread =
            cl_hrrcf_t77rcf_wl_object=>check_cdcies_existence(
            lt_cdcy_to_be_checked ).

  SORT lt_cdcy_unread.

* build up numbers for candidacies (total, in process, unread)
  LOOP AT        lt_req_cdcy
       ASSIGNING <ls_req_cdcy>.
    lv_tabix = sy-tabix + 1.
* determine total number of candidacies per requisition
    lv_num_total = lv_num_total + 1.
* determine number of candidacies 'in process' per requisition
    IF  <ls_req_cdcy>-candidacy_status EQ lc_status_in_process.
      lv_num_in_process = lv_num_in_process + 1.
    ENDIF.
* determine number of candidacies 'rejected' per requisition
    IF  <ls_req_cdcy>-candidacy_status EQ lc_status_rejected.
      lv_num_rejected = lv_num_rejected + 1.
    ENDIF.

* determine number of candidacies 'unread' per requisition
    READ TABLE    lt_cdcy_unread
         WITH KEY plvar = <ls_req_cdcy>-plvar
                  otype = lc_otype_cdcy
                  objid = <ls_req_cdcy>-sobid
         BINARY SEARCH
         TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      lv_num_unread = lv_num_unread + 1.
    ENDIF.
* check whether in sorted table next entry still belongs to the same
* requisition
* if yes, continue process
* if no, append line in requisition table with numbers
    READ TABLE     lt_req_cdcy
         INDEX     lv_tabix
         ASSIGNING <ls_req_cdcy_next>.

    IF ( sy-subrc = 0 AND
         <ls_req_cdcy>-objid NE <ls_req_cdcy_next>-objid ) OR
         sy-subrc <> 0.
      ls_requisitions_no_cdcy-plvar          = <ls_req_cdcy>-plvar.
      ls_requisitions_no_cdcy-otype          = <ls_req_cdcy>-otype.
      ls_requisitions_no_cdcy-objid          = <ls_req_cdcy>-objid.
      ls_requisitions_no_cdcy-no_total       = lv_num_total.
      ls_requisitions_no_cdcy-no_in_process  = lv_num_in_process.
      ls_requisitions_no_cdcy-no_unread      = lv_num_unread.
      APPEND ls_requisitions_no_cdcy
          TO lt_requisitions_no_cdcy.
      CLEAR lv_num_total.
      CLEAR lv_num_in_process.
      CLEAR lv_num_unread.
    ENDIF.
  ENDLOOP.

  pt_requisitions_no_cdcy = lt_requisitions_no_cdcy.

ENDMETHOD.


METHOD get_postings .
* XDP Copy Object: Interface Posting_List

* XDP Copy Object
  CONSTANTS c_subty TYPE plog-subty VALUE 'B652'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '652'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA l_objid TYPE plog-objid.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA lo_object TYPE REF TO object.
* XDP Copy Object
  DATA lo_posting TYPE REF TO cl_hrrcf_posting.
  DATA:
    lv_subrc TYPE sysubrc.


* XDP Copy Object
  CLEAR posting_list.

*Check whether records for the  relationshiptype exists in buffer


  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = posting_list.


* if no recprds exist, read from database

  IF posting_list IS INITIAL.

    CALL METHOD cl_hrrcf_object_buffer=>read_relationship
      EXPORTING
        pv_isubty    = c_subty
        ps_ihrobject = me->hrobject
      IMPORTING
        pt_erelation = lt_relation
        pv_esubrc    = lv_subrc.

    IF lv_subrc <> 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
          hrobject = me->hrobject
*       INFOTYPE =
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.
      TRY.

          l_objid = ls_relation-sobid.

* XDP Copy Object
          CALL METHOD cl_hrrcf_posting=>get
            EXPORTING
              id      = l_objid
            IMPORTING
              posting = lo_posting.

* XDP Copy Object
          APPEND lo_posting TO posting_list.

        CATCH cx_hrrcf INTO lo_exception.

          RAISE EXCEPTION TYPE cx_hrrcf
            EXPORTING
               previous = lo_exception.

      ENDTRY.
    ENDLOOP.

* register records in the buffer

    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = posting_list.


  ENDIF.


ENDMETHOD.                    "


METHOD get_released_date .
*
* Author: XLV
*
* This method should determine the highest date
* the requisition was released. If this date could not be determined
* the export parameter will be cleared.
*
  CONSTANTS:
    c_released          TYPE rcf_requisition_status VALUE '1'.
*
  DATA:
    lo_requisition_info TYPE REF TO   cl_hrrcf_requisition_info,
    lv_det_by_log       TYPE          boole_d,
    ls_p5125            TYPE          p5125,
    lt_requisition_info TYPE TABLE OF p5125,
    ls_log_data         TYPE          rcf_s_fieldlog_data,
    ls_field_log        TYPE          rcf_s_fieldlog,
    lt_field_log        TYPE          rcf_t_fieldlog,
    lt_field_set        TYPE          rcf_t_fieldname.
*
  released_date = low_date.
*
  CALL METHOD cl_hrrcf_requisition_info=>get_instance
    EXPORTING
      hrobject = me->hrobject
    IMPORTING
      instance = lo_requisition_info.
*
  IF lo_requisition_info IS BOUND.
*
    APPEND 'STATUS' TO lt_field_set.
*
    CALL METHOD lo_requisition_info->get_field_set_history_tc12
      EXPORTING
        field_set = lt_field_set
      IMPORTING
        field_log = lt_field_log.
*
  ENDIF.
*
  IF lt_field_log IS INITIAL.
*  No entry in the log means we can not use it to determine
*  the correct date
    lv_det_by_log = false.
  ELSE.
    CLEAR ls_field_log.
    READ TABLE lt_field_log WITH KEY
      date = ls_field_log-date
      time = ls_field_log-time
      user = ls_field_log-user
      TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.
*    If one entry like this exists the log has been switched on
*    after the requisition has been created, so we can not trust
*    the log
      lv_det_by_log = false.
    ELSE.
      lv_det_by_log = true.
    ENDIF.
  ENDIF.
*
  IF lv_det_by_log = true.
*    sort lt_field_log by begda.
    LOOP AT lt_field_log INTO ls_field_log.
      READ TABLE ls_field_log-log_data
        INTO ls_log_data
        WITH KEY
          fieldname = 'STATUS'
          fieldvalue = c_released.
      IF sy-subrc IS INITIAL AND released_date < ls_field_log-date.
        released_date = ls_field_log-date.
      ENDIF.
    ENDLOOP.
  ELSE.
    TRY.
        CALL METHOD lo_requisition_info->get_records
          IMPORTING
            infotype_records = lt_requisition_info.
      CATCH cx_hrrcf_infotype_operation .
* released_date could not be determined ==> clear return value
* Do we need an entry in the log?
        CLEAR released_date.
        RETURN.
    ENDTRY.
*    sort lt_requisition_info by begda.
    LOOP AT lt_requisition_info INTO ls_p5125
      WHERE status = c_released.
      IF released_date < ls_p5125-begda.
        released_date = ls_p5125-begda.
      ENDIF.
    ENDLOOP.
  ENDIF.
*
* released_date could not be determined ==> clear return value
  IF released_date = low_date.
    CLEAR released_date.
  ENDIF.
*
ENDMETHOD.


method get_requisition_status .
*
* Author: Joachim Gross
* Additions: AS
*
  data: lo_ri type ref to cl_hrrcf_requisition_info.
  data: lt_ri type table of p5125, ls_ri type p5125.
  data: lo_exception type ref to cx_hrrcf.

  data lt_req_txt type rcf_t_requisition_info_text .
  data ls_req_txt type rcf_s_requisition_info_text .

  try.
      call method cl_hrrcf_requisition_info=>get_instance
        exporting
          hrobject = me->hrobject
        importing
          instance = lo_ri.

      if p_status_txt is supplied or p_reason_code_txt is supplied.

        call method lo_ri->get_records_by_date_with_text
          exporting
            date                  = p_date
            language              = p_langu
          importing
            pt_requisition_info_t = lt_req_txt.

        read table lt_req_txt index 1 into ls_req_txt.

        if sy-subrc is not initial.
          if 1 = 2.                      "Only for where used list
            message e073(hrrcf0001) with 'REQUISITION'.
          endif.

          raise exception type cx_hrrcf
            exporting
              message_type = 'E'
              message_class = 'HRRCF0001'
              message_number = 073
              message_par1   = 'REQUISITION' .

        endif.

        p_status = ls_req_txt-status.
        p_status_txt = ls_req_txt-status_txt .
        p_reason_code = ls_req_txt-reason_code.
        p_reason_code_txt = ls_req_txt-reason_code_txt.

      else .

        call method lo_ri->get_records_by_date
          exporting
            date             = p_date
          importing
            infotype_records = lt_ri.

        read table lt_ri index 1 into ls_ri.
        if sy-subrc is not initial.
          if 1 = 2.                      "Only for where used list
            message e073(hrrcf0001) with 'REQUISITION'.
          endif.

          raise exception type cx_hrrcf
            exporting
              message_type = 'E'
              message_class = 'HRRCF0001'
              message_number = 073
              message_par1   = 'REQUISITION' .

        endif.

        p_status = ls_ri-status.
        p_reason_code = ls_ri-reason_code.

      endif .

    catch cx_hrrcf into lo_exception.
      raise exception type cx_hrrcf
        exporting
          previous = lo_exception
          hrobject = me->hrobject
          .
  endtry.
endmethod.                    "GET_REQUISITION_STATUS


METHOD get_status_reason_history .

  DATA lo_requisition_info TYPE REF TO  cl_hrrcf_requisition_info.
  DATA lt_field_set TYPE rcf_t_fieldname.

  CALL METHOD cl_hrrcf_requisition_info=>get_instance
    EXPORTING
      hrobject = me->hrobject
    IMPORTING
      instance = lo_requisition_info.
  IF lo_requisition_info IS BOUND.

    APPEND 'STATUS' TO lt_field_set.
    APPEND 'REASON_CODE' TO lt_field_set.

    CALL METHOD lo_requisition_info->get_field_set_history_tc12
      EXPORTING
        field_set = lt_field_set
      IMPORTING
        field_log = field_log.

  ENDIF.

ENDMETHOD.


METHOD get_vacancy_of_requisition .
**** Author: Claudia Staps
*            Detlef
**** Datadeclaration
***  CONSTANTS c_subty TYPE plog-subty VALUE 'B657'.
***
***  DATA: lt_relation TYPE TABLE OF p1001,
***        ls_relation TYPE          p1001,
***        lt_object   TYPE TABLE OF hrobject,
***        l_plvar     Type          plvar,
***        ls_vacancy  type          RCF_S_REQUISITION_VACANCY
***        .
***
***
***  if not requisition is initial.
***
***    CALL FUNCTION 'RH_GET_ACTIVE_WF_PLVAR'
***      EXPORTING
***        set_default_plvar = 'X'
***      IMPORTING
***        act_plvar         = l_plvar
***      EXCEPTIONS
***        no_active_plvar   = 0
***        OTHERS            = 0.
***
***
***    CALL FUNCTION 'RH_READ_INFTY'
***     EXPORTING
***       PLVAR                      = l_plvar
***       OTYPE                      = 'NB'
***       OBJID                      = requisition-objid
***       INFTY                      = '1001'
***       ISTAT                      = '1'
****     EXTEND                    = 'X'
***       SUBTY                      = 'B657'
***       BEGDA                      = low_date
***       ENDDA                      = high_date
****     CONDITION                  = '00000'
****     INFTB                      = '1'
****     SORT                       = 'X'
****     VIA_T777D                  = ' '
***      TABLES
***        INNNN                      = lt_relation
***        OBJECTS                    = lt_object
***     EXCEPTIONS
***       ALL_INFTY_WITH_SUBTY       = 1
***       NOTHING_FOUND              = 0
***       NO_OBJECTS                 = 3
***       WRONG_CONDITION            = 4
***       WRONG_PARAMETERS           = 5
***       OTHERS                     = 6
***              .
***
***    IF sy-subrc NE 0.
****XDP preliminary
**** -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
****    Development Request is addressed
***      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
***        EXPORTING
***          textid = cx_hrrcf_infotype_operation=>error_during_read
****       PREVIOUS =
***          hrobject = me->hrobject
****       INFOTYPE =
***          message_type = sy-msgty
***          message_class = sy-msgid
***          message_number = sy-msgno
***          message_par1 = sy-msgv1
***          message_par2 = sy-msgv2
***          message_par3 = sy-msgv3
***          message_par4 = sy-msgv4.
***
***    else.
***
***
***
***      LOOP AT lt_relation INTO  ls_relation
***           WHERE begda LE sy-datum
***             AND endda GE sy-datum.
***
***        move ls_relation-sobid to ls_vacancy-sobid.
***        move ls_relation-sclas to ls_vacancy-sclas.
***
***        append ls_vacancy to vacancy_list.
***      endloop.
***
***    ENDIF.
***
***  endif.
***
  CONSTANTS c_subty TYPE plog-subty VALUE 'B657'.
  CONSTANTS c_relat TYPE p1001-relat VALUE '657'.

  DATA lt_relation TYPE TABLE OF p1001.
  DATA ls_relation TYPE          p1001.
  DATA lt_object TYPE TABLE OF hrobject.
  DATA l_objid TYPE plog-objid.

  DATA lo_exception TYPE REF TO cx_hrrcf.

  DATA lo_object TYPE REF TO object.

* XDP Copy Object
  DATA lo_vacancy TYPE rcf_s_requisition_vacancy.

  APPEND me->hrobject TO lt_object.

* XDP Copy Object
  CLEAR vacancy_list.

*Check whether records for the  relationshiptype exists in buffer


  CALL METHOD me->get_relationship
    EXPORTING
      relat              = c_relat
    IMPORTING
      relationship_table = vacancy_list.


* if no recprds exist, read from database

  IF vacancy_list IS INITIAL.


    CALL FUNCTION 'RH_READ_INFTY'
      EXPORTING
        infty                = '1001'
        istat                = '1'
        subty                = c_subty
      TABLES
        innnn                = lt_relation
        OBJECTS              = lt_object
      EXCEPTIONS
        all_infty_with_subty = 1
        nothing_found        = 0
        no_objects           = 3
        wrong_condition      = 4
        OTHERS               = 5.
    IF sy-subrc NE 0.
*XDP preliminary
* -> Currently the RH_XXXX_INFTY do not set the sy-msgno etc.
*    Development Request is addressed
      RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
        EXPORTING
          textid = cx_hrrcf_infotype_operation=>error_during_read
*       PREVIOUS =
          hrobject = me->hrobject
*       INFOTYPE =
          message_type = sy-msgty
          message_class = sy-msgid
          message_number = sy-msgno
          message_par1 = sy-msgv1
          message_par2 = sy-msgv2
          message_par3 = sy-msgv3
          message_par4 = sy-msgv4.
    ENDIF.

    LOOP AT    lt_relation
         INTO  ls_relation
               WHERE begda LE sy-datum
                 AND endda GE sy-datum.
      TRY.

          lo_vacancy-sobid = ls_relation-sobid.
          lo_vacancy-sclas = ls_relation-sclas.
          lo_vacancy-priox = ls_relation-priox.

          l_objid = ls_relation-sobid.

          CALL FUNCTION 'RH_READ_OBJECT'
            EXPORTING
              plvar = me->hrobject-plvar
              otype = 'S'
              objid = l_objid
            IMPORTING
              stext     = lo_vacancy-description
            EXCEPTIONS
              NOT_FOUND = 1.

          if sy-subrc = 0.
*           append object only if the user has authorization to see it
            APPEND lo_vacancy TO vacancy_list.
          endif.

        CATCH cx_hrrcf INTO lo_exception.

          RAISE EXCEPTION TYPE cx_hrrcf_infotype_operation
            EXPORTING
               previous = lo_exception.

      ENDTRY.
    ENDLOOP.

* register records in the buffer

    CALL METHOD me->register_relationship
      EXPORTING
        relat              = c_relat
        relationship_table = vacancy_list.

  ENDIF.

ENDMETHOD.


METHOD legal_check_before_delete.

  DATA: lt_cdcy_list      TYPE rcf_t_candidacy.
  DATA: lo_candidacy      TYPE REF TO cl_hrrcf_candidacy.
  DATA: lo_cdcy_bl        TYPE REF TO cl_hrrcf_candidacy_bl.
  DATA: lt_appl_list      TYPE rcf_t_application.
  DATA: lo_application    TYPE REF TO cl_hrrcf_candidate_application.
  DATA: lt_appl_cdcy_list TYPE rcf_t_candidacy.
  DATA: lo_appl_candidacy TYPE REF TO cl_hrrcf_candidacy.
  DATA: lt_cand_list      TYPE rcf_t_candidate.
  DATA: lo_candidate      TYPE REF TO cl_hrrcf_candidate.
  DATA: lt_cand_cdcy_list TYPE rcf_t_candidacy.
  DATA: lo_cand_candidacy TYPE REF TO cl_hrrcf_candidacy.
  DATA: ls_return         TYPE bapiret2.
  DATA: lv_ret_date       TYPE dats.

  CALL METHOD me->get_candidacies
    IMPORTING
      candidacy_list = lt_cdcy_list.

  CALL METHOD cl_hrrcf_candidacy_bl=>get_instance
    RECEIVING
      return = lo_cdcy_bl.

* at first check the retention date of the "to be deleted" requisiton, which is chosed by the administrator.
  LOOP AT lt_cdcy_list INTO lo_candidacy.
    CALL METHOD lo_cdcy_bl->get_requi_retention_date
      EXPORTING
        ps_cdcy_hrobject = lo_candidacy->hrobject
      IMPORTING
        p_ret_date       = lv_ret_date.

    IF lv_ret_date GE sy-datum.
      CLEAR ls_return.
      IF 1 EQ 0.
        MESSAGE e111(hrrcf0002).
*     End of retention period not yet reached
      ENDIF.
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type   = 'E'
          cl     = 'HRRCF0002'
          number = '111'
        IMPORTING
          return = ls_return.
      APPEND ls_return TO return.
    ENDIF.
  ENDLOOP.

* now check if there is any open candidacy to this selected requisiton, and loop over all existing applications and
* candidates linked to candidacies, check if there a valid retention date on a requisition.
  LOOP AT lt_cdcy_list INTO lo_candidacy.

* check from application's candidacy
    CALL METHOD lo_candidacy->get_applications
      IMPORTING
        application_list = lt_appl_list.

    LOOP AT lt_appl_list INTO lo_application.
      CALL METHOD lo_application->get_candidacies
        IMPORTING
          candidacy_list = lt_appl_cdcy_list.

      LOOP AT lt_appl_cdcy_list INTO lo_appl_candidacy.
        CALL METHOD lo_cdcy_bl->get_requi_retention_date
          EXPORTING
            ps_cdcy_hrobject = lo_appl_candidacy->hrobject
          IMPORTING
            p_ret_date       = lv_ret_date.

        IF lv_ret_date GE sy-datum.
          CLEAR ls_return.
          IF 1 EQ 0.
            MESSAGE e111(hrrcf0002).
*     End of retention period not yet reached
          ENDIF.
          CALL FUNCTION 'BALW_BAPIRETURN_GET2'
            EXPORTING
              type   = 'E'
              cl     = 'HRRCF0002'
              number = '111'
            IMPORTING
              return = ls_return.
          APPEND ls_return TO return.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDLOOP.
ENDMETHOD.
ENDCLASS.