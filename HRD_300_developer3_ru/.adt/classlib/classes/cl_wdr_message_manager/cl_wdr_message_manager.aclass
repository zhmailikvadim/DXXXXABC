class CL_WDR_MESSAGE_MANAGER definition
  public
  create public .

public section.
  type-pools ABAP .
  type-pools WDYN .

  interfaces IF_WD_MESSAGE_MANAGER .
  interfaces IF_WD_MESSAGE_MANAGER2 .
  interfaces IF_WD_VALIDATION .
  interfaces IF_WD_MESSAGE_LOG .

  aliases CO_TYPE_ERROR
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_ERROR .
  aliases CO_TYPE_FATAL
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_FATAL .
  aliases CO_TYPE_INFO
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_INFO .
  aliases CO_TYPE_INVISIBLE_ALERT_MSG
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_INVISIBLE_ALERT_MSG .
  aliases CO_TYPE_REFERENCE
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_REFERENCE .
  aliases CO_TYPE_STANDARD
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_STANDARD .
  aliases CO_TYPE_WARNING
    for IF_WD_MESSAGE_MANAGER~CO_TYPE_WARNING .
  aliases CLEAR_INVISIBLE_ALERT_MESSAGES
    for IF_WD_MESSAGE_MANAGER~CLEAR_INVISIBLE_ALERT_MESSAGES .
  aliases CLEAR_MESSAGES
    for IF_WD_MESSAGE_MANAGER~CLEAR_MESSAGES .
  aliases GET_INVISIBLE_ALERT_MESSAGES
    for IF_WD_MESSAGE_MANAGER~GET_INVISIBLE_ALERT_MESSAGES .
  aliases IS_EMPTY
    for IF_WD_MESSAGE_MANAGER~IS_EMPTY .
  aliases REMOVE_INVISIBLE_ALERT_MESSAGE
    for IF_WD_MESSAGE_MANAGER~REMOVE_INVISIBLE_ALERT_MESSAGE .
  aliases REPORT_INVISIBLE_ALERT_MESSAGE
    for IF_WD_MESSAGE_MANAGER~REPORT_INVISIBLE_ALERT_MESSAGE .

  types:
    BEGIN OF TRANSPORT_ROOT_ATTRIBUTES,
          is_report_single type ABAP_BOOL,
          has_exceptions   type ABAP_BOOL,
          is_modified      type ABAP_BOOL,
    END   OF TRANSPORT_ROOT_ATTRIBUTES .

  data HAS_EXCEPTION type ABAP_BOOL read-only .
  class-data IS_MODIFIED type ABAP_BOOL read-only .
  data R_TRANSPORT_MESSAGES type ref to WDR_MESSAGE_TAB .
  data R_TRANSPORT_ATTRIBUTES type ref to TRANSPORT_ROOT_ATTRIBUTES .
  data R_DATA_CONTAINER type ref to CL_WDR_DATA_CONTAINER .
  data R_RENDER_MESSAGES type ref to WDR_MESSAGE_TAB .
  data R_INVISIBLE_ALERT_MESSAGES type ref to WDR_MESSAGE_TAB .

  methods RESET_TOPWINDOW_MESSAGES
    importing
      !WINDOW type ref to CL_WDR_WINDOW .
  methods ON_EXIT_CONTEXT
    importing
      !CONTEXT type ref to IF_WDR_CONTEXT .
  methods ON_EXIT_COMPONENT .
  class-methods GET_VIEW_CONTEXT_PATH
    importing
      !ITEM type WDR_MESSAGE_ITEM
    returning
      value(PATH) type STRING .
  methods RAISE_PENDING_EXCEPTION .
  methods CONSTRUCTOR
    importing
      !COMPONENT type ref to CL_WDR_COMPONENT
      !ROOT_MESSAGE_MANAGER type ref to CL_WDR_MESSAGE_MANAGER optional .
  methods REPORT_MESSAGE
    importing
      !ATTRIBUTE type WDR_ATTRIBUTE_POINTER optional
      !MSG type CSEQUENCE optional
      !TYPE type I
      !PARAMS type WDR_NAME_VALUE_LIST optional
      !MSG_OBJECT type ref to IF_MESSAGE optional
      !MSG_USER_DATA type ref to DATA optional
      !IS_PERMANENT type ABAP_BOOL optional
      !SCOPE_PERMANENT_MSG type WDR_MESSAGE_SCOPE optional
      !VIEW type STRING optional
      !SHOW_AS_POPUP type ABAP_BOOL optional
      !CONTROLLER_PERMANENT_MSG type ref to IF_WD_CONTROLLER optional
      !ATTRIBUTES type STRING_TABLE optional
      !MSG_INDEX type I optional
      !CANCEL_NAVIGATION type ABAP_BOOL optional
      !IS_VALIDATION_INDEPENDENT type ABAP_BOOL default ABAP_FALSE
      !ENABLE_MESSAGE_NAVIGATION type ABAP_BOOL optional
      !COMPONENT type ref to IF_WD_COMPONENT optional
      !MSG_KEY type STRING optional
      !METHOD_NAME type STRING default 'REPORT_MESSAGE'
    returning
      value(MESSAGE_ID) type STRING .
  methods RAISE_MESSAGE
    importing
      !ATTRIBUTE type WDR_ATTRIBUTE_POINTER optional
      !MSG type STRING optional
      !TYPE type I
      !PARAMS type WDR_NAME_VALUE_LIST optional
      !MSG_OBJECT type ref to IF_MESSAGE optional
      !MSG_USER_DATA type ref to DATA optional .
  methods CLEAR
    importing
      !INCLUDING_PERMANENT_MSG type ABAP_BOOL default ABAP_FALSE .
  methods HAS_EXCEPTIONS
    importing
      !INCLUDING_PERMANENT_MSG type ABAP_BOOL default ABAP_FALSE
    returning
      value(HAS_EXCEPTIONS) type ABAP_BOOL .
  methods HAS_ERRORS_FOR_ATTRIBUTE
    importing
      !ATTRIBUTE type WDR_ATTRIBUTE_POINTER
      !INCLUDING_PERMANENT_MSG type ABAP_BOOL default ABAP_FALSE
    returning
      value(HAS_ERRORS) type ABAP_BOOL .
  methods GET_NUMBER_OF_MESSAGES
    importing
      !IGNORE_REFERENCE_MESSAGES type WDY_BOOLEAN default ABAP_TRUE
    returning
      value(NUMBER) type I .
  methods GET_MESSAGE_FOR_ATTRIBUTE
    importing
      !ATTRIBUTE type WDR_ATTRIBUTE_POINTER
    returning
      value(MESSAGE) type WDR_MESSAGE_ITEM .
  methods GET_MESSAGE_STRING_BY_INDEX
    importing
      !INDEX type I
    returning
      value(MESSAGE) type STRING .
  methods GET_MESSAGE_STRING_BY_ATTR
    importing
      !ATTRIBUTE_POINTER type WDR_ATTRIBUTE_POINTER
    returning
      value(MESSAGE) type STRING .
  class-methods ITEM_TO_STRING
    importing
      !ITEM type WDR_MESSAGE_ITEM
      !FOLLOW_REFERENCE type WDY_BOOLEAN default ABAP_TRUE
    returning
      value(MESSAGE) type STRING .
  methods CLEAR_MODIFIED .
  class-methods GET_TYPE_STRING
    importing
      !ITEM type WDR_MESSAGE_ITEM
    returning
      value(VALUE) type STRING .
  methods CHECK_AND_PROC_VALIDATION
    returning
      value(RC) type ABAP_BOOL .
  methods REMOVE_VALIDATION_ERRORS .
  methods REPORT_VALIDATION_ERROR
    importing
      !ATTRIBUTE type WDR_ATTRIBUTE_POINTER
      !MSG_OBJECT type ref to CX_WDR_CONVERSION_EXCEPTION
      !MESSAGE_TYPE type I default CO_TYPE_ERROR .
  methods GET_RENDER_MESSAGES
    importing
      !FOLLOW_REFERENCE type WDY_BOOLEAN default ABAP_TRUE
      !FILL_AUTO_MESSAGES type WDY_BOOLEAN default ABAP_FALSE
    returning
      value(MESSAGES) type WDR_MESSAGE_TAB .
  methods HAS_VALIDATION_ERRORS
    importing
      !INCLUDING_PERMANENT_MSG type ABAP_BOOL default ABAP_FALSE
    returning
      value(HAS_VALIDATION_ERRORS) type ABAP_BOOL .
  methods HAS_ERRORS_FOR_WINDOW
    importing
      !WINDOW type ref to CL_WDR_WINDOW
    returning
      value(HAS_ERRORS) type ABAP_BOOL .
  methods GET_MESSAGES_FOR_WINDOW
    importing
      !FOLLOW_REFERENCE type WDY_BOOLEAN default ABAP_TRUE
      !WINDOW type ref to CL_WDR_WINDOW
    returning
      value(MESSAGES) type WDR_MESSAGE_TAB .
  methods HAS_VAL_ERRORS_FOR_WINDOW
    importing
      !WINDOW type ref to CL_WDR_WINDOW
    returning
      value(HAS_VALIDATION_ERRORS) type ABAP_BOOL .
  methods HAS_MESSAGES
    returning
      value(HAS_MESSAGES) type ABAP_BOOL .
  methods CLEAR_MESSAGES_FOR_WINDOW
    importing
      !WINDOW type ref to IF_WD_WINDOW
      !INCLUDING_PERMANENT_MSG type ABAP_BOOL default ABAP_FALSE .
protected section.
*"* protected components of class CL_WDR_MESSAGE_MANAGER
*"* do not include other source files here!!!
private section.

  data M_COMPONENT type ref to CL_WDR_COMPONENT .
  interface IF_WD_MESSAGE_MANAGER load .
  data R_MESSAGE_LOG type ref to IF_WD_MESSAGE_MANAGER=>TY_T_MESSAGES .
  class-data M_MSG_ID_CNT type I .

  methods GET_TOP_WINDOW
    exporting
      !WINDOW_NAME type STRING
      !WINDOW_COMPONENT type ref to CL_WDR_COMPONENT .
  methods REMOVE_OUTDATED_MESSAGES .
ENDCLASS.



CLASS CL_WDR_MESSAGE_MANAGER IMPLEMENTATION.


method check_and_proc_validation.

  field-symbols: <l_message> type wdr_message_item.


  rc = abap_true.

  loop at r_transport_messages->* assigning <l_message>.
    read table r_render_messages->* transporting no fields with key
                    element = <l_message>-element
                    attribute_name = <l_message>-attribute_name.
    if sy-subrc <> 0.
      insert <l_message> into table r_render_messages->*.
    endif.
    rc = abap_false.
  endloop.

  if rc = abap_false.
    cl_wdr_message_trace=>method_call( method_name = 'CHECK_AND_PROC_VALIDATION' ).
  endif.
endmethod.


method clear.
  data l_removed type abap_bool.

  if including_permanent_msg = abap_false.
    delete r_render_messages->* where is_permanent_msg = abap_false.
    if sy-subrc = 0. l_removed = abap_true. endif.
    me->has_exception = me->has_exceptions( ).
  else.
    clear r_render_messages->*.
    if sy-subrc = 0. l_removed = abap_true. endif.
    me->has_exception = abap_false.
  endif.

  clear r_invisible_alert_messages->*.

  is_modified = abap_true.

  if l_removed = abap_true.
    cl_wdr_message_trace=>clear_messages( method_name = 'CLEAR' ).
  endif.
endmethod.


method clear_messages_for_window.

  data:  l_window   type ref to cl_wdr_window,
         wa         type wdr_message_item,
         l_messages type wdr_message_tab.
  data l_removed type abap_bool.

  l_window ?= window.
  case l_window->message_display_mode.
    when if_wd_window=>co_msg_display_mode_none.
* do not delete any messages because the popup does not show messages
    when if_wd_window=>co_msg_display_mode_all.
* delete all the messages
      me->clear( ).
    when if_wd_window=>co_msg_display_mode_selected.
* delete only messages that belong to the popup
      l_messages = me->get_messages_for_window(
           window = l_window
           follow_reference = abap_false ).
      if including_permanent_msg = abap_true.
        loop at l_messages into wa.
          delete r_render_messages->* where msg_id = wa-msg_id.
          if sy-subrc = 0. l_removed = abap_true. endif.
        endloop.
      else.
        loop at l_messages into wa where is_permanent_msg = abap_false.
          delete r_render_messages->* where msg_id = wa-msg_id.
          if sy-subrc = 0. l_removed = abap_true. endif.
        endloop.
      endif.
      if l_removed = abap_true.
        cl_wdr_message_trace=>method_call( method_name = 'CLEAR_MESSAGES_FOR_WINDOW' ).
      endif.
  endcase.
  me->has_exception = me->has_exceptions( including_permanent_msg ).
  is_modified = abap_true.

* reset pager for message area
  if l_window->message_window is bound.
    l_window->message_window->message_helper_class->reset_first_vis_row( ).
  endif.

endmethod.


method CLEAR_MODIFIED.

is_modified = ABAP_FALSE.
endmethod.


method CONSTRUCTOR.
m_component = component.

has_exception = ABAP_FALSE.
is_modified = ABAP_TRUE.

if root_message_manager is bound.
* take the messages list of the transport root
  r_transport_attributes = root_message_manager->r_transport_attributes.
  r_transport_messages   = root_message_manager->r_transport_messages.
  r_render_messages      = root_message_manager->r_render_messages.
    r_message_log          = root_message_manager->r_message_log.
  r_invisible_alert_messages = root_message_manager->r_invisible_alert_messages.
else.
*  this must be the transport root
  create data r_transport_attributes.
  create data r_transport_messages.
  create data r_render_messages.
    create data r_message_log.
  create data r_invisible_alert_messages.
  endif.

endmethod.


method get_messages_for_window.

  data: l_views           type wdr_viewmap,
        l_view            type ref to cl_wdr_view,
        l_mappers         type wdr_context_mapper_set,
        l_mapper          type ref to cl_wdr_context_node_map,
        l_messages        type wdr_message_tab,
        wa_view           like line of l_views,
        l_found           type abap_bool,
        l_node            type ref to cl_wdr_context_node.

  field-symbols: <message> type wdr_message_item.

  me->remove_outdated_messages( ).
  case window->message_display_mode.

    when if_wd_window=>co_msg_display_mode_all.
      messages = me->get_render_messages( follow_reference = follow_reference ).
      return.

    when if_wd_window=>co_msg_display_mode_none.
      clear messages.
      return.

    when if_wd_window=>co_msg_display_mode_selected.
      clear messages.
      l_messages = me->get_render_messages( follow_reference = follow_reference fill_auto_messages = abap_true ).

      loop at l_messages assigning <message>.
        clear l_found.
        if <message>-element is initial and <message>-view is initial.
*         this message should be displayed in all windows (created with view = CO_ANY_WINDOW
          l_found = abap_true.
        else.
          if l_views is initial.
            l_views = window->get_views_for_window( ).
          endif.
          if  <message>-view is not initial.
            if <message>-the_component = window->root_component and
              <message>-view = window->view_manager->window_info->definition-view_name.
              l_found = abap_true.
            else.
              loop at l_views into wa_view where name = <message>-view.
                if wa_view-view->component = <message>-the_component.
                  l_found = abap_true.
                endif.
              endloop.
            endif.
          endif.

          if l_found = abap_false and <message>-element is bound.
            try.
                l_view ?= <message>-element->node->controller.
                read table l_views into wa_view with key name = <message>-element->node->controller->name
                                                         view = l_view.
                if sy-subrc = 0.
                  l_found = abap_true.
                endif.
              catch cx_sy_move_cast_error.
                l_found = abap_false.
            endtry.
            if l_found = abap_false.
              l_node = <message>-element->node.
              while l_found = abap_false and l_node is bound.
                l_mappers = l_node->get_mapped_nodes( ).
                loop at l_mappers into l_mapper.
                  check l_mapper->controller is bound.
                  try.
                      l_view ?= l_mapper->controller.
                    catch cx_sy_move_cast_error.
                      continue.
                  endtry.
                  read table l_views into wa_view with key name = l_mapper->controller->name
                                                           view = l_view.
                  if sy-subrc = 0.
                    l_found = abap_true.
                    exit.
                  endif.
                endloop.
                if l_node->parent_element is bound.
                  l_node = l_node->parent_element->node.
                else.
                  clear l_node.
                endif.
              endwhile.
            endif.
          endif.
        endif.
        if l_found = abap_true.
          append <message> to messages.
        endif.
      endloop.

  endcase.
endmethod.


method get_message_for_attribute .

  field-symbols: <item> type wdr_message_item.

  loop at r_render_messages->* assigning <item> where element = attribute-element.
    if <item>-attribute_name = attribute-attribute_name.
      if <item>-element is bound and <item>-element->node is not initial.
        message = <item>.
        return.
      endif.
    elseif <item>-attributes is not initial.
      read table <item>-attributes transporting no fields
       with key table_line = attribute-attribute_name.
      if sy-subrc = 0.
        if <item>-element is bound and <item>-element->node is not initial.
          message = <item>.
          return.
        endif.
      endif.
    endif.
  endloop.

endmethod.


method get_message_string_by_attr.

  field-symbols: <item> type wdr_message_item.

  loop at r_render_messages->* assigning <item> where element = attribute_pointer-element.
    if <item>-attribute_name = attribute_pointer-attribute_name.
      if sy-subrc = 0 and
         <item>-element is bound and
         <item>-element->node is not initial.
        message = item_to_string( <item> ).
        return.
      endif.
    elseif <item>-attributes is not initial.
      read table <item>-attributes transporting no fields
        with key table_line = attribute_pointer-attribute_name.
      if sy-subrc = 0 and
        <item>-element is bound and
        <item>-element->node is not initial.
        message = item_to_string( <item> ).
        return.
      endif.
    endif.
  endloop.

  clear message.

endmethod.


method GET_MESSAGE_STRING_BY_INDEX.

data: istring type string.
field-symbols: <item> type wdr_message_item.

read table r_render_messages->* index index assigning <item>.

if sy-subrc = 0 and
 <item>-element is bound and
 <item>-element->node is not initial.
  message = item_to_string( <item> ).
else.
  message = text-002.
  istring = sy-tabix.
  replace `&1` in message with istring.
endif.

endmethod.


method GET_NUMBER_OF_MESSAGES.

  if ignore_reference_messages = abap_true.
    loop at r_render_messages->* transporting no fields where msg_type >= 0.
      add 1 to number.
    endloop.
  else.
    number = lines( r_render_messages->* ).
  endif.
endmethod.


method get_render_messages.
* Parameter FILL_AUTO_MESSAGES:
*  when messages are fetched for rendering, check whether there are messages, which automatically should be placed on
*  the toplevel window. Enter the right window there. This message should be placed on this window in the future, too
* (only relevant for permanent messages)Only when the window is
* closed and the message is still there, set the state to the initial state
* (reset_topwindow_messages called on any window close)

  field-symbols: <m> type wdr_message_item.

  me->remove_outdated_messages( ).
  if follow_reference = abap_false.
    clear messages.
    loop at r_render_messages->* assigning <m> where msg_type >= 0 .
      if <m>-auto_window_detection = abap_true and
         <m>-view                  = if_wd_message_manager=>co_top_window and
         fill_auto_messages        = abap_true.
        me->get_top_window(
          importing
            window_name      = <m>-view
            window_component = <m>-the_component
       ).
      endif.
      append <m> to messages.
    endloop.
  else.
    if fill_auto_messages        = abap_true.
      loop at r_render_messages->* assigning <m> where
           auto_window_detection = abap_true and
           view                  = if_wd_message_manager=>co_top_window.
        me->get_top_window(
          importing
            window_name      = <m>-view
            window_component = <m>-the_component
       ).
      endloop.
    endif.
    messages = r_render_messages->*.
  endif.
endmethod.


method GET_TOP_WINDOW.
  data l_window type ref to cl_wdr_window.
  l_window ?= wdr_task=>application->application_window->get_active_modal_window( ).

  window_name = l_window->view_manager->window_info->definition-view_name.
  window_component ?= l_window->root_component.

endmethod.


method GET_TYPE_STRING.

case item-msg_type.
  when CO_TYPE_ERROR.
    value = `error`.
  when CO_TYPE_WARNING.
    value = `warning`.
  when CO_TYPE_STANDARD.
    value = `standard`.
  when CO_TYPE_FATAL.
    value = `fatal`.
  when co_type_info.
    value = `info`.
  endcase.
endmethod.


METHOD get_view_context_path.

  DATA: node_paths TYPE wdr_context_path_with_cntl_tab,
        view_name TYPE string,
        path_in_view TYPE string,
        num_paths TYPE i.
  FIELD-SYMBOLS:
        <path_to_node> LIKE LINE OF node_paths.

* get list of paths pointing to element
  IF item-element IS NOT BOUND OR
     item-element->node IS INITIAL.
    RETURN.
  ENDIF.

  node_paths = item-element->node->get_mapped_meta_paths( ).

*   choose the path that starts with a view.
  num_paths = LINES( node_paths ).
  IF num_paths = 0.
*    raise exception type
  ELSEIF num_paths = 1.
*    there is only one. fine!
    READ TABLE node_paths INDEX 1 ASSIGNING <path_to_node>.
  ELSE.
    LOOP AT node_paths ASSIGNING <path_to_node>.
*      check which of the paths starting with a view
      SPLIT <path_to_node>-path AT '.' INTO view_name path_in_view.
      CHECK view_name IS NOT INITIAL AND  path_in_view IS NOT INITIAL.

      READ TABLE item-the_component->if_wdr_context_manager~controllers
      WITH TABLE KEY name = view_name
           TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.
    ENDLOOP.
  ENDIF.

  CONCATENATE item-the_component->id <path_to_node>-path item-attribute_name INTO path SEPARATED BY '.'.
ENDMETHOD.


method has_errors_for_attribute.

  field-symbols: <l_message> type wdr_message_item.

* simple case: no errors at all
  if r_render_messages->* is initial.
    has_errors = abap_false.
    return.
  endif.

  if including_permanent_msg = abap_true.

    loop at r_render_messages->* assigning <l_message> where element = attribute-element.
      if <l_message>-attribute_name = attribute-attribute_name.
        if <l_message>-msg_type >= co_type_error.
          has_errors = abap_true.
        else.
          has_errors = abap_false.
        endif.
      elseif <l_message>-attributes is not initial.
        read table <l_message>-attributes transporting no fields with key table_line = attribute-attribute_name.
        if sy-subrc = 0 and <l_message>-msg_type >= co_type_error.
          has_errors = abap_true.
        else.
          has_errors = abap_false.
        endif.
      else.
        has_errors = abap_false.
      endif.
    endloop.

  else.

    loop at r_render_messages->* assigning <l_message>
       where element = attribute-element and
             is_permanent_msg = abap_false.
      if <l_message>-attribute_name = attribute-attribute_name.
        if <l_message>-msg_type >= co_type_error.
          has_errors = abap_true.
        else.
          has_errors = abap_false.
        endif.
      elseif <l_message>-attributes is not initial.
        read table <l_message>-attributes transporting no fields with key table_line = attribute-attribute_name.
        if sy-subrc = 0 and <l_message>-msg_type >= co_type_error.
          has_errors = abap_true.
        else.
          has_errors = abap_false.
        endif.
      else.
        has_errors = abap_false.
      endif.
    endloop.

  endif.
endmethod.


method has_errors_for_window.

  data: l_views           type wdr_viewmap,
        l_view            type ref to cl_wdr_view,
        l_mappers         type wdr_context_mapper_set,
        l_mapper          type ref to cl_wdr_context_node_map,
        wa_view           like line of l_views,
        l_node            type ref to cl_wdr_context_node.

  field-symbols: <message> type wdr_message_item.

* simple case: no errors at all
  if r_render_messages->* is initial.
    has_errors = abap_false.
    return.
  endif.

  case window->message_display_mode.

    when if_wd_window=>co_msg_display_mode_all.
      has_errors = me->has_exceptions( including_permanent_msg = abap_true ).
      return.

    when if_wd_window=>co_msg_display_mode_none.
      has_errors = abap_false.
      return.

    when if_wd_window=>co_msg_display_mode_selected.
      loop at r_render_messages->* assigning <message> where msg_type >= co_type_error .

        if <message>-element is initial and <message>-view is initial.
          has_errors = abap_true.
          return.
        else.

          if l_views is initial.
            l_views = window->get_views_for_window( ).
          endif.

          if <message>-view is not initial.
            if <message>-the_component = window->root_component and
               <message>-view = window->view_manager->window_info->definition-view_name.
              has_errors = abap_true.
              return.
            else.
              read table l_views into wa_view with key name = <message>-view.
              if sy-subrc = 0 and wa_view-view->component = <message>-the_component.
                has_errors = abap_true.
                return.
              endif.
            endif.
          endif.

          if <message>-element is bound.
            try.
                l_view ?= <message>-element->node->controller.
                read table l_views into wa_view with key name = <message>-element->node->controller->name
                                                         view = l_view.
                if sy-subrc = 0.
                  has_errors = abap_true.
                  return.
                endif.
              catch cx_sy_move_cast_error.
                has_errors = abap_false.
            endtry.
            if has_errors = abap_false.
              l_node = <message>-element->node.
              while has_errors = abap_false and l_node is bound.
                l_mappers = l_node->get_mapped_nodes( ).
                loop at l_mappers into l_mapper.
                  check l_mapper->controller is bound.
                  try.
                      l_view ?= l_mapper->controller.
                    catch cx_sy_move_cast_error.
                      continue.
                  endtry.
                  read table l_views into wa_view with key name = l_mapper->controller->name
                                                           view = l_view.
                  if sy-subrc = 0.
                    has_errors = abap_true.
                    exit.
                  endif.
                endloop.
                if l_node->parent_element is bound.
                  l_node = l_node->parent_element->node.
                else.
                  clear l_node.
                endif.
              endwhile.
              if has_errors = abap_true.
                return.
              endif.
            endif.
          endif.

        endif.
      endloop.

  endcase.
  has_errors = abap_false.

endmethod.


method has_exceptions.

  field-symbols: <item> type wdr_message_item.

  if including_permanent_msg = abap_true.
    loop at r_render_messages->* assigning <item>
      where msg_type >= co_type_error .
      if <item>-element is initial.
        has_exceptions = abap_true.
        return.
      elseif <item>-element is bound and
        <item>-element->node is not initial.
        has_exceptions = abap_true.
        return.
      endif.
    endloop.

  else.

    loop at r_render_messages->* assigning <item>
    where msg_type >= co_type_error
    and   is_permanent_msg = abap_false.
      if <item>-element is initial.
        has_exceptions = abap_true.
        return.
      elseif <item>-element is bound and
        <item>-element->node is not initial.
        has_exceptions = abap_true.
        return.
      endif.
    endloop.

  endif.

  has_exceptions = abap_false.
  me->has_exception = has_exceptions.

endmethod.


method has_messages.
  if r_render_messages->* is not initial.
    has_messages = abap_true.
  else.
    has_messages = abap_false.
  endif.
endmethod.


method has_validation_errors.

  field-symbols: <item> type wdr_message_item.

* has messages from data container validation?
  if r_transport_messages->* is not initial.
    loop at r_transport_messages->* assigning <item>.
      if <item>-element is bound and
        <item>-element->node is not initial.
        has_validation_errors = abap_true.
        return.
      endif.
    endloop.
  endif.

* has application messages for context attributes?
  if including_permanent_msg = abap_true.
    loop at r_render_messages->* assigning <item>
      where msg_type >= co_type_error
      and   is_validation_independent = abap_false.
      if <item>-element is bound and
        <item>-element->node is not initial.
        has_validation_errors = abap_true.
        return.
      endif.
    endloop.

  else.

    loop at r_render_messages->* assigning <item>
    where msg_type >= co_type_error
    and   is_permanent_msg = abap_false
    and   is_validation_independent = abap_false.
      if <item>-element is bound and
             <item>-element->node is not initial.
        has_validation_errors = abap_true.
        return.
      endif.
    endloop.

  endif.

  has_validation_errors = abap_false.

endmethod.


method has_val_errors_for_window.

  data: l_views           type wdr_viewmap,
        l_view            type ref to cl_wdr_view,
        l_mappers         type wdr_context_mapper_set,
        l_mapper          type ref to cl_wdr_context_node_map,
        wa_view           like line of l_views,
        l_node            type ref to cl_wdr_context_node.

  field-symbols: <message> type wdr_message_item.

* simple case: no errors at all
  if r_render_messages->* is initial and r_transport_messages->* is initial.
    has_validation_errors = abap_false.
    return.
  endif.

  case window->message_display_mode.

    when if_wd_window=>co_msg_display_mode_all.
      has_validation_errors = me->has_validation_errors( including_permanent_msg = abap_true ).
      return.

    when if_wd_window=>co_msg_display_mode_none.
      has_validation_errors = abap_false.
      return.

    when if_wd_window=>co_msg_display_mode_selected.
      loop at r_render_messages->* assigning <message> where msg_type >= co_type_error .

        check <message>-element is bound
          and <message>-element->node is bound
          and <message>-is_validation_independent = abap_false.

        if l_views is initial.
          l_views = window->get_views_for_window( ).
        endif.

        if <message>-view is not initial.
          if <message>-the_component = window->root_component and
             <message>-view = window->view_manager->window_info->definition-view_name.
            has_validation_errors = abap_true.
            return.
          else.
            read table l_views into wa_view with key name = <message>-view.
            if sy-subrc = 0 and wa_view-view->component = <message>-the_component.
              has_validation_errors = abap_true.
              return.
            endif.
          endif.
        endif.

        try.
            l_view ?= <message>-element->node->controller.
            read table l_views into wa_view with key name = <message>-element->node->controller->name
                                                     view = l_view.
            if sy-subrc = 0.
              has_validation_errors = abap_true.
              return.
            endif.
          catch cx_sy_move_cast_error.
            has_validation_errors = abap_false.
        endtry.
        if has_validation_errors = abap_false.
          l_node = <message>-element->node.
          while has_validation_errors = abap_false and l_node is bound.
            l_mappers = l_node->get_mapped_nodes( ).
            loop at l_mappers into l_mapper.
              check l_mapper->controller is bound.
              try.
                  l_view ?= l_mapper->controller.
                catch cx_sy_move_cast_error.
                  continue.
              endtry.
              read table l_views into wa_view with key name = l_mapper->controller->name
                                                       view = l_view.
              if sy-subrc = 0.
                has_validation_errors = abap_true.
                exit.
              endif.
            endloop.
            if l_node->parent_element is bound.
              l_node = l_node->parent_element->node.
            else.
              clear l_node.
            endif.
          endwhile.
          if has_validation_errors = abap_true.
            return.
          endif.
        endif.
      endloop.


  endcase.
  has_validation_errors = abap_false.

endmethod.


method if_wd_message_log~add_message.

  insert message into table R_message_log->*.

endmethod.


method if_wd_message_log~clear.

  clear r_message_log.

endmethod.


method if_wd_message_log~get_messages.

  messages = r_message_log->*.

endmethod.


method IF_WD_MESSAGE_LOG~REMOVE_MESSAGE.

  delete r_message_log->* where msg_id = message_id.

endmethod.


method if_wd_message_manager2~add_message_item_for_attribute.
  data: help type string,
        l_element type ref to cl_wdr_context_element,
        l_old_msg_item type wdr_message_item.

  data: l_message_tab type ref to wdr_message_tab.

  l_message_tab = r_render_messages.

  if element is bound.
    l_element          ?= element.
    item-element        = l_element.
    item-attribute_name = attribute.
    item-context = l_element->node->controller.
  endif.
  is_modified = abap_true.

  if item-msg_type = co_type_error or item-msg_type = co_type_fatal.
    has_exception = abap_true.
  endif.

  cl_wdr_message_trace=>add_message_item(
    exporting
      message_item = item
      method_name  = 'ADD_MESSAGE_ITEM_FOR_ATTRIBUTE'
  ).
  insert item into table l_message_tab->*.

* raise message if single_mode and this is an error
  if item-msg_type = co_type_fatal.
    raise exception type cx_wd_abort_message_manager.
  endif.


endmethod.


method if_wd_message_manager2~add_message_item_for_element.

  data: help type string,
        l_element type ref to cl_wdr_context_element,
        l_old_msg_item type wdr_message_item.

  data: l_message_tab type ref to wdr_message_tab.

  l_message_tab = r_render_messages.

  if element is bound.
    l_element          ?= element.
    item-element        = l_element.
    item-attributes     = attributes.
    item-context = l_element->node->controller.
  endif.
  is_modified = abap_true.

  if item-msg_type = co_type_error or item-msg_type = co_type_fatal.
    has_exception = abap_true.
  endif.

  cl_wdr_message_trace=>add_message_item(
    exporting
      message_item = item
      method_name  = 'ADD_MESSAGE_ITEM_FOR_ATTRIBUTE'
  ).
  insert item into table l_message_tab->*.

* raise message if single_mode and this is an error
  if item-msg_type = co_type_fatal.
    raise exception type cx_wd_abort_message_manager.
  endif.

endmethod.


method if_wd_message_manager2~add_referencing_message.

  data: l_message_ref type ref to wdr_message_item,
        l_new_message type wdr_message_item.

  field-symbols: <old_message> type wdr_message_item.

  success = abap_true.
  read table r_transport_messages->* from original_message reference into l_message_ref.
  if sy-subrc = 0.
    l_new_message = l_message_ref->*.
    l_new_message-element ?= element.
    l_new_message-attribute_name = attribute.
    read table r_transport_messages->*
      with key element = l_new_message-element assigning <old_message>.
    if sy-subrc = 0. " old message found
      if <old_message>-attribute_name = l_new_message-attribute_name.
        success = abap_false.
        return.
      elseif <old_message>-attributes is not initial.
        read table <old_message>-attributes transporting no fields
           with key table_line = l_new_message-attribute_name.
        if sy-subrc = 0.
          success = abap_false.
          return.
        endif.
      endif.
      l_new_message-msg_type = co_type_reference.
      l_new_message-orig_msg = l_message_ref.
      insert l_new_message into table r_transport_messages->*.
    else.
      success = abap_false.
    endif.
  else.
    success = abap_false.
  endif.
  if success = abap_true.
    cl_wdr_message_trace=>add_message_item(
        message_item = l_new_message
        method_name  = 'ADD_REFERENCING_MESSAGE(successful)'
    ).
  else.
    cl_wdr_message_trace=>add_message_item(
        message_item = l_new_message
        method_name  = 'ADD_REFERENCING_MESSAGE(not successful)'
    ).
  endif.
endmethod.


method if_wd_message_manager2~add_referencing_msg_for_elem.

  data: l_message_ref type ref to wdr_message_item,
        l_new_message type wdr_message_item,
        l_attribute   type string.

  field-symbols: <old_message> type wdr_message_item.

  success = abap_true.
  read table r_transport_messages->* from original_message reference into l_message_ref.
  if sy-subrc = 0.
    l_new_message = l_message_ref->*.
    l_new_message-element ?= element.
    l_new_message-attributes = attributes.
    read table r_transport_messages->*
      with key element = l_new_message-element assigning <old_message>.
    if sy-subrc = 0. " old message found
      if l_new_message-attributes is initial and <old_message>-attributes is initial.
        success = abap_false.
        return.
      else.
        loop at l_new_message-attributes into l_attribute.
          if <old_message>-attribute_name = l_attribute.
            success = abap_false.
            return.
          elseif <old_message>-attributes is not initial.
            read table <old_message>-attributes transporting no fields
               with key table_line = l_attribute.
            if sy-subrc = 0.
              success = abap_false.
              return.
            endif.
          endif.
        endloop.
      endif.
      l_new_message-msg_type = co_type_reference.
      l_new_message-orig_msg = l_message_ref.
      insert l_new_message into table r_transport_messages->*.
    else.
      success = abap_false.
    endif.
  else.
    success = abap_false.
  endif.
  if success = abap_true.
    cl_wdr_message_trace=>add_message_item(
        message_item = l_new_message
        method_name  = 'ADD_REFERENCING_MSG_FOR_ELEM(successful)'
    ).
  else.
    cl_wdr_message_trace=>add_message_item(
        message_item = l_new_message
        method_name  = 'ADD_REFERENCING_MSG_FOR_ELEM(not successful)'
    ).
  endif.

endmethod.


method if_wd_message_manager2~get_message_items.

  items = r_render_messages->*.

endmethod.


method if_wd_message_manager2~get_message_items_for_attr.
  data: l_element type ref to cl_wdr_context_element.
  field-symbols: <message> type wdr_message_item.

  l_element ?= element.

  loop at r_render_messages->* assigning <message> where element = l_element.
    if <message>-attribute_name is not initial and <message>-attribute_name = attribute.
      append <message> to items.
    elseif <message>-attributes is not initial.
      read table <message>-attributes transporting no fields with key table_line = attribute.
      if sy-subrc = 0.
        append <message> to items.
      endif.
    endif.
  endloop.

endmethod.


method IF_WD_MESSAGE_MANAGER2~GET_MESSAGE_ITEMS_FOR_ELEMENT.
  DATA: l_element TYPE REF TO cl_wdr_context_element.
  FIELD-SYMBOLS: <message> TYPE wdr_message_item.

  l_element ?= element.

  LOOP AT r_render_messages->* ASSIGNING <message>
    WHERE
      element = l_element.
    APPEND <message> TO items.
  ENDLOOP.
endmethod.


method IF_WD_MESSAGE_MANAGER2~GET_MESSAGE_ITEMS_FOR_NODE.
  data: l_node type ref to cl_wdr_context_node,
        l_context type ref to if_wdr_context.

  field-symbols: <message> type WDR_MESSAGE_ITEM.

* simple case: no errors at all
  if r_render_messages->* is initial.
    return.
  endif.

  l_node ?= node.
* if mapped, get the original
  l_node = l_node->get_original_node( ).
  l_context ?= l_node->if_wd_context_node~get_context( ).

  loop at r_render_messages->* assigning <message>
      where
*        context = l_context  and
        element is bound.
    if <message>-element->node = l_node.
      append <message> to items.
    endif.
  endloop.

endmethod.


method if_wd_message_manager2~remove_message_items_for_attr.
  data: l_element type ref to cl_wdr_context_element.
  field-symbols <message> type wdr_message_item.

  l_element ?= element.

  if cl_wdr_message_trace=>m_is_active = abap_true.
    loop at r_render_messages->* assigning <message>
      where element = l_element and attribute_name = attribute.
      cl_wdr_message_trace=>remove_message_item(
        exporting
          message_item = <message>
          method_name  = 'REMOVE_MESSAGE_ITEMS_FOR_ATTR'
      ).
    endloop.
  endif.
  delete r_render_messages->*
    where
      element = l_element and
      attribute_name = attribute.

  is_modified = abap_true.

endmethod.


method if_wd_message_manager2~remove_message_items_for_elem.

  data: l_element type ref to cl_wdr_context_element.
  field-symbols <message> type wdr_message_item.

  l_element ?= element.

  if cl_wdr_message_trace=>m_is_active = abap_true.
    loop at r_render_messages->* assigning <message> where element = l_element.
      cl_wdr_message_trace=>remove_message_item(
        exporting
          message_item = <message>
          method_name  = 'REMOVE_MESSAGE_ITEMS_FOR_ELEM'
      ).
    endloop.
  endif.
  delete r_render_messages->*
    where
      element = l_element.

  is_modified = abap_true.

endmethod.


method IF_WD_MESSAGE_MANAGER2~REMOVE_MESSAGE_ITEMS_FOR_NODE.
  data: l_node type ref to cl_wdr_context_node,
        l_context type ref to if_wdr_context.
  data l_index type I.
  field-symbols: <message> type WDR_MESSAGE_ITEM.

* simple case: no errors at all
  if r_render_messages->* is initial.
    return.
  endif.

  l_node ?= node.
* if mapped, get the original
  l_node = l_node->get_original_node( ).
  l_context ?= l_node->if_wd_context_node~get_context( ).

  loop at r_render_messages->* assigning <message>
       where
*      context = l_context and
        element is bound.
    l_index = sy-tabix.
    if <message>-element->node = l_node.
      cl_wdr_message_trace=>remove_message_item(
        exporting
          message_item = <message>
          method_name  = 'REMOVE_MESSAGE_ITEMS_FOR_NODE'
      ).
      delete r_render_messages->* index l_index.
    endif.
  endloop.

  is_modified = abap_true.
endmethod.


  method IF_WD_MESSAGE_MANAGER~CLEAR_INVISIBLE_ALERT_MESSAGES.

    clear r_invisible_alert_messages->*.
    is_modified = abap_true.
    cl_wdr_message_trace=>clear_messages( method_name = 'CLEAR_INVISIBLE_ALERT_MESSAGES' ).

  endmethod.


method if_wd_message_manager~clear_messages.

  if only_permanent_msg = abap_true.
    delete r_render_messages->* where is_permanent_msg = abap_true.
    cl_wdr_message_trace=>clear_messages( method_name = 'CLEAR_MESSAGES(ONLY_PERMANENT)' ).
    return.
  endif.
  if including_permanent_msg = abap_false.
    delete r_render_messages->* where is_permanent_msg = abap_false.
  else.
    clear r_render_messages->*.
  endif.
  is_modified = abap_true.
  cl_wdr_message_trace=>clear_messages( method_name = 'CLEAR_MESSAGES' ).
endmethod.


  method if_wd_message_manager~get_invisible_alert_messages.

    loop at r_invisible_alert_messages->* assigning field-symbol(<item>).
      append corresponding #( <item> ) to result assigning field-symbol(<result_entry>).
      <result_entry>-message = <item>-err_message.
    endloop.

  endmethod.


method if_wd_message_manager~get_messages.

  data: wa type if_wd_message_manager~ty_s_message.

  field-symbols: <item> type wdr_message_item.

  loop at r_render_messages->* assigning <item>.
    move-corresponding <item> to wa.
    append wa to result.
  endloop.

endmethod.


method if_wd_message_manager~get_message_for_id.

  field-symbols: <item> type wdr_message_item.

  read table r_render_messages->* assigning <item>
       with key msg_id = message_id.
  if sy-subrc = 0.
    move-corresponding <item> to result.
  endif.
endmethod.


method if_wd_message_manager~has_validation_errors.

  has_validation_errors = me->has_validation_errors( including_permanent_msg = including_permanent_msg ).

endmethod.


method if_wd_message_manager~has_val_errors_for_window.

  data: l_window type ref to cl_wdr_window.

  if window is initial.
    l_window = wdr_task=>application->application_window.
  else.
    l_window ?= window.
  endif.

  has_validation_errors = me->has_val_errors_for_window( window = l_window ).

endmethod.


method IF_WD_MESSAGE_MANAGER~IS_EMPTY.
  if r_render_messages->* is initial.
    empty = ABAP_TRUE.
  else.
    empty = ABAP_FALSE.
  endif.
endmethod.


method if_wd_message_manager~raise_attribute_exception.

  data: attribute_pointer type wdr_attribute_pointer.

  attribute_pointer-element ?= element.
  attribute_pointer-attribute_name = attribute_name.
  attribute_pointer-context = attribute_pointer-element->node->controller.

  raise_message(
    attribute     = attribute_pointer
    type          = co_type_error
    msg_object    = message_object
    msg_user_data = msg_user_data ).

endmethod.


method if_wd_message_manager~raise_error_message.

  raise_message(
    type          = co_type_error
    msg           = message_text
    params        = params
    msg_user_data = msg_user_data ).

endmethod.


method if_wd_message_manager~raise_exception.

  raise_message(
    type          = co_type_error
    msg_object    = message_object
    msg_user_data = msg_user_data ).

endmethod.


method if_wd_message_manager~raise_fatal_error_message.

  raise_message(
    type          = co_type_fatal
    msg           = message_text
    params        = params
    msg_user_data = msg_user_data ).

endmethod.


method if_wd_message_manager~raise_fatal_exception.

  raise_message(
    type          = co_type_fatal
    msg_object    = message_object
    msg_user_data = msg_user_data ).

endmethod.


method if_wd_message_manager~raise_t100_error.

  data: msg      type string,
        msg_type type i,
        l_parameter  type wdr_name_value,
        l_para_list  type wdr_name_value_list.

  if msgty co 'XAEIWS'.
    " Only message types A, E, I, W, S, and X are allowed. otherwise dump  MESSAGE_TYPE_UNKNOWN
    message id msgid type msgty number msgno
            with p1 p2 p3 p4
            into msg.
  else.
    raise exception type cx_wdr_general EXPORTING textid = cx_wdr_general=>error_in_application.
  endif.


  if p1 is not initial.
    l_parameter-name = 'P1'.
    l_parameter-value = p1.
    append l_parameter to l_para_list.
    if p2 is not initial.
      l_parameter-name = 'P2'.
      l_parameter-value = p2.
      append l_parameter to l_para_list.
      if p3 is not initial.
        l_parameter-name = 'P3'.
        l_parameter-value = p3.
        append l_parameter to l_para_list.
        if p4 is not initial.
          l_parameter-name = 'P4'.
          l_parameter-value = p4.
          append l_parameter to l_para_list.
        endif.
      endif.
    endif.
  endif.

  case msgty.
    when 'A'.
      msg_type = co_type_fatal.
    when 'E'.
      msg_type = co_type_error.
    when 'I'.
      msg_type = co_type_standard.
    when 'W'.
      msg_type = co_type_warning.
    when 'S'.
      msg_type = co_type_standard.
  endcase.

  raise_message(
    msg           = msg
    type          = msg_type
    params        = l_para_list
    msg_user_data = msg_user_data ).

endmethod.


  method if_wd_message_manager~remove_invisible_alert_message.

    if cl_wdr_message_trace=>m_is_active = abap_true.
      loop at r_invisible_alert_messages->* assigning field-symbol(<message>) where msg_id = msg_id.
        cl_wdr_message_trace=>remove_message_item(
          exporting
            message_item = <message>
            method_name  = 'REMOVE_INVISIBLE_ALERT_MESSAGE'
        ).
      endloop.
    endif.
    delete r_invisible_alert_messages->* where msg_id = msg_id.

  endmethod.


method if_wd_message_manager~remove_message.

  FIELD-SYMBOLS <message> type wdr_message_item.

  if cl_wdr_message_trace=>m_is_active = abap_true.
    loop at r_render_messages->* ASSIGNING <message> where msg_id = msg_id.
      cl_wdr_message_trace=>remove_message_item(
        exporting
          message_item = <message>
          method_name  = 'REMOVE_MESSAGE'
      ).
    ENDLOOP.
  endif.
  delete r_render_messages->* where msg_id = msg_id.

endmethod.


method if_wd_message_manager~report_attribute_error_message.

  data: attribute_pointer type wdr_attribute_pointer,
        l_skip_message    type abap_bool.

  if element->is_alive( ) = abap_true.
    attribute_pointer-element ?= element.
    attribute_pointer-attribute_name = attribute_name.
    attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ATTRIBUTE_ERROR_MESSAGE'
          element_ref     = element
          attribute       = attribute_name
          message_string  = message_text ).
      endif.
    endif.
  endif.

  check l_skip_message = abap_false.
  message_id = report_message(
    attribute           = attribute_pointer
    type                = co_type_error
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    is_validation_independent = is_validation_independent
    component           = component
    enable_message_navigation = enable_message_navigation ).

endmethod.


method if_wd_message_manager~report_attribute_exception.

  data: attribute_pointer type wdr_attribute_pointer,
        l_skip_message    type abap_bool.

  if element->is_alive( ) = abap_true.
  attribute_pointer-element ?= element.
  attribute_pointer-attribute_name = attribute_name.
  attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ATTRIBUTE_EXCEPTION'
          element_ref     = element
          attribute       = attribute_name
          message_string  = message_object->get_text( ) ).
      endif.
    endif.
  endif.

  check l_skip_message = abap_false.
  message_id = report_message(
    attribute           = attribute_pointer
    type                = message_type
    msg_object          = message_object
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    component           = component
    is_validation_independent = is_validation_independent
    enable_message_navigation = enable_message_navigation ).

endmethod.


method IF_WD_MESSAGE_MANAGER~REPORT_ATTRIBUTE_MESSAGE.

  data: attribute_pointer type wdr_attribute_pointer,
        l_skip_message    type abap_bool.

  if element->is_alive( ) = abap_true.
    attribute_pointer-element ?= element.
    attribute_pointer-attribute_name = attribute_name.
    attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ATTRIBUTE_MESSAGE'
          element_ref     = element
          attribute       = attribute_name
          message_string  = message_text ).
      endif.
    endif.
  endif.

  check l_skip_message = abap_false.
  message_id = report_message(
    attribute           = attribute_pointer
    type                = message_type
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    component           = component
    is_validation_independent = is_validation_independent
    enable_message_navigation = enable_message_navigation ).

endmethod.


method if_wd_message_manager~report_attribute_t100_message.

  data: attribute_pointer type wdr_attribute_pointer.
  data: msgtext type string.
  data: l_t100_helper type ref to lcl_t100_helper,
        l_msg_object type ref to cl_t100_message.
  data: msg_type type i,
        l_parameter type wdr_name_value,
        l_para_list type wdr_name_value_list,
        l_skip_message type abap_bool,
        l_msg_key type string.

  if msg-msgv1 is not initial.
    l_parameter-name = 'P1'.
    l_parameter-value = msg-msgv1.
    append l_parameter to l_para_list.
    if msg-msgv2 is not initial.
      l_parameter-name = 'P2'.
      l_parameter-value = msg-msgv2.
      append l_parameter to l_para_list.
      if msg-msgv3 is not initial.
        l_parameter-name = 'P3'.
        l_parameter-value = msg-msgv3.
        append l_parameter to l_para_list.
        if msg-msgv4 is not initial.
          l_parameter-name = 'P4'.
          l_parameter-value = msg-msgv4.
          append l_parameter to l_para_list.
        endif.
      endif.
    endif.
  endif.

  create object l_t100_helper
    exporting
      p1 = msg-msgv1
      p2 = msg-msgv2
      p3 = msg-msgv3
      p4 = msg-msgv4.
  create object l_msg_object
    exporting
      the_msg_class  = msg-msgid
      the_msg_number = msg-msgno
      the_subject    = l_t100_helper.

  if element->is_alive( ) = abap_true.
    attribute_pointer-element ?= element.
    attribute_pointer-attribute_name = attribute_name.
    attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ATTRIBUTE_T100_MESSAGE'
          element_ref     = element
          attribute       = attribute_name
          message_string  = l_msg_object->get_text( ) ).
      endif.
    endif.
  endif.

  if msg-msgty co 'XAEIWS'.
    " Only message types A, E, I, W, S, and X are allowed. otherwise dump  MESSAGE_TYPE_UNKNOWN
    message id msg-msgid type msg-msgty number msg-msgno
          with msg-msgv1 msg-msgv2 msg-msgv3 msg-msgv4
          into msgtext.
  else.
    raise exception type cx_wdr_general exporting textid = cx_wdr_general=>error_in_application.
  endif.

  if message_type is not supplied.
    if msg-msgty is not initial.
      case msg-msgty.
        when 'X'.
          msg_type = co_type_fatal.
        when 'A'.
          msg_type = co_type_fatal.
        when 'E'.
          msg_type = co_type_error.
        when 'I'.
          msg_type = co_type_standard.
        when 'W'.
          msg_type = co_type_warning.
        when 'S'.
          msg_type = co_type_standard.
      endcase.
    else.
      msg_type = co_type_error.
    endif.
  else.
    msg_type = message_type.
  endif.

  check l_skip_message = abap_false.
  concatenate msg-msgid msg-msgno msg-msgty into l_msg_key separated by '_'.
  condense l_msg_key.
  message_id = report_message(
    attribute           = attribute_pointer
    msg                 = msgtext
    type                = msg_type
    msg_object          = l_msg_object
    params              = l_para_list
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    component           = component
    msg_key             = l_msg_key
    is_validation_independent = is_validation_independent
    enable_message_navigation = enable_message_navigation
).


endmethod.


method IF_WD_MESSAGE_MANAGER~REPORT_ELEMENT_ERROR_MESSAGE.

  data: attribute_pointer type wdr_attribute_pointer,
        l_skip_message    type abap_bool.

  if element->is_alive( ) = abap_true.
    attribute_pointer-element ?= element.
    attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ELEMENT_ERROR_MESSAGE'
          element_ref     = element
          attribute       = ''
          message_string  = message_text ).
      endif.

    endif.
  endif.

  check l_skip_message = abap_false.
  message_id = report_message(
    attribute           = attribute_pointer
    type                = co_type_error
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    attributes          = attributes
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    component           = component
    is_validation_independent = is_validation_independent
    enable_message_navigation = enable_message_navigation ).

endmethod.


method IF_WD_MESSAGE_MANAGER~REPORT_ELEMENT_EXCEPTION.

  data: attribute_pointer type wdr_attribute_pointer,
        l_skip_message    type abap_bool.

  if element->is_alive( ) = abap_true.
    attribute_pointer-element ?= element.
    attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ELEMENT_EXCEPTION'
          element_ref     = element
          attribute       = ''
          message_string  = message_object->get_text( ) ).
      endif.
    endif.
  endif.

  check l_skip_message = abap_false.
  message_id = report_message(
    attribute           = attribute_pointer
    type                = message_type
    msg_object          = message_object
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    attributes          = attributes
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    component           = component
    is_validation_independent = is_validation_independent
    enable_message_navigation = enable_message_navigation ).

endmethod.


method IF_WD_MESSAGE_MANAGER~REPORT_ELEMENT_T100_MESSAGE.

  data: attribute_pointer type wdr_attribute_pointer.
  data: msgtext type string.
  data: l_t100_helper type ref to lcl_t100_helper,
        l_msg_object type ref to cl_t100_message.
  data: msg_type type i,
        l_parameter type wdr_name_value,
        l_para_list type wdr_name_value_list,
        l_skip_message type abap_bool,
        l_msg_key type string.

  if msg-msgv1 is not initial.
    l_parameter-name = 'P1'.
    l_parameter-value = msg-msgv1.
    append l_parameter to l_para_list.
    if msg-msgv2 is not initial.
      l_parameter-name = 'P2'.
      l_parameter-value = msg-msgv2.
      append l_parameter to l_para_list.
      if msg-msgv3 is not initial.
        l_parameter-name = 'P3'.
        l_parameter-value = msg-msgv3.
        append l_parameter to l_para_list.
        if msg-msgv4 is not initial.
          l_parameter-name = 'P4'.
          l_parameter-value = msg-msgv4.
          append l_parameter to l_para_list.
        endif.
      endif.
    endif.
  endif.

  create object l_t100_helper
    exporting
      p1 = msg-msgv1
      p2 = msg-msgv2
      p3 = msg-msgv3
      p4 = msg-msgv4.
  create object l_msg_object
    exporting
      the_msg_class  = msg-msgid
               the_msg_number = msg-msgno
               the_subject    = l_t100_helper.

  if element->is_alive( ) = abap_true.
    attribute_pointer-element ?= element.
    attribute_pointer-context = attribute_pointer-element->node->controller.
  else.
    assert id wdr_runtime_msg_manager condition 1 = 0.
    clear attribute_pointer.
    if is_permanent = abap_true and scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
      l_skip_message = abap_true.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>skip_message(
          method_name     = 'REPORT_ELEMENT_T100_MESSAGE'
          element_ref     = element
          attribute       = ''
          message_string  = l_msg_object->get_text( ) ).
      endif.

    endif.
  endif.


  if msg-msgty co 'XAEIWS'.
    " Only message types A, E, I, W, S, and X are allowed. otherwise dump  MESSAGE_TYPE_UNKNOWN
    message id msg-msgid type msg-msgty number msg-msgno
          with msg-msgv1 msg-msgv2 msg-msgv3 msg-msgv4
          into msgtext.
  else.
    raise exception type cx_wdr_general exporting textid = cx_wdr_general=>error_in_application.
  endif.


  case msg-msgty.
    when 'X'.
      msg_type = co_type_fatal.
    when 'A'.
      msg_type = co_type_fatal.
    when 'E'.
      msg_type = co_type_error.
    when 'I'.
      msg_type = co_type_standard.
    when 'W'.
      msg_type = co_type_warning.
    when 'S'.
      msg_type = co_type_standard.
  endcase.

  check l_skip_message = abap_false.
  concatenate msg-msgid msg-msgno msg-msgty into l_msg_key separated by '_'.
  condense l_msg_key.
  message_id = report_message(
    attribute           = attribute_pointer
    msg                 = msgtext
    type                = msg_type
    msg_object          = l_msg_object
    params              = l_para_list
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    attributes          = attributes
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    view                = view
    component           = component
    msg_key             = l_msg_key
    is_validation_independent = is_validation_independent
    enable_message_navigation = enable_message_navigation ).

endmethod.


method if_wd_message_manager~report_error_message.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = co_type_error
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation ).

endmethod.


method if_wd_message_manager~report_exception.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = message_type
    msg_object          = message_object
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation
     ).

endmethod.


method if_wd_message_manager~report_fatal_error_message.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = co_type_fatal
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation ).


endmethod.


method if_wd_message_manager~report_fatal_exception.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = co_type_fatal
    msg_object          = message_object
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation ).


endmethod.


  method IF_WD_MESSAGE_MANAGER~REPORT_INVISIBLE_ALERT_MESSAGE.

    message_id = report_message(
      type                = co_type_invisible_alert_msg
      msg                 = message_text
      params              = params
      msg_index           = msg_index
      component           = component ).

  endmethod.


method IF_WD_MESSAGE_MANAGER~REPORT_MESSAGE.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = message_type
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation ).


endmethod.


method if_wd_message_manager~report_success.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = co_type_standard
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation ).

endmethod.


method if_wd_message_manager~report_t100_message.

  data: msg                 type string,
        msg_type            type i,
        l_msg_object        type ref to cl_t100_message,
        l_parameter         type wdr_name_value,
        l_para_list         type wdr_name_value_list,
        l_t100_helper       type ref to lcl_t100_helper,
        l_msg_key           type string.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  if msgty co 'XAEIWS'.
    " Only message types A, E, I, W, S, and X are allowed. otherwise dump  MESSAGE_TYPE_UNKNOWN
    message id msgid type msgty number msgno
            with p1 p2 p3 p4
            into msg.
  else.
    raise exception type cx_wdr_general EXPORTING textid = cx_wdr_general=>error_in_application.
  endif.


  if p1 is not initial.
    l_parameter-name = 'P1'.
    l_parameter-value = p1.
    append l_parameter to l_para_list.
    if p2 is not initial.
      l_parameter-name = 'P2'.
      l_parameter-value = p2.
      append l_parameter to l_para_list.
      if p3 is not initial.
        l_parameter-name = 'P3'.
        l_parameter-value = p3.
        append l_parameter to l_para_list.
        if p4 is not initial.
          l_parameter-name = 'P4'.
          l_parameter-value = p4.
          append l_parameter to l_para_list.
        endif.
      endif.
    endif.
  endif.
  create object l_t100_helper
    exporting
      p1 = p1
      p2 = p2
      p3 = p3
      p4 = p4.
  create object l_msg_object
    exporting
      the_msg_class  = msgid
      the_msg_number = msgno
      the_subject    = l_t100_helper.
  case msgty.
    when 'X'.
      msg_type = co_type_fatal.
    when 'A'.
      msg_type = co_type_fatal.
    when 'E'.
      msg_type = co_type_error.
    when 'I'.
      msg_type = co_type_standard.
    when 'W'.
      msg_type = co_type_warning.
    when 'S'.
      msg_type = co_type_standard.
  endcase.

  concatenate msgid msgno msgty into l_msg_key separated by '_'.
  condense l_msg_key.
  message_id = report_message(
    msg                 = msg
    type                = msg_type
    msg_object          = l_msg_object
    params              = l_para_list
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
   msg_key             = l_msg_key
   enable_message_navigation = enable_message_navigation ).


endmethod.


method if_wd_message_manager~report_warning.

  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_ctxt_element.
    raise exception type cx_wdr_rt_exception
       exporting
          textid = cx_wdr_rt_exception=>invalid_msg_scope.
  endif.

  message_id = report_message(
    type                = co_type_warning
    msg                 = message_text
    params              = params
    msg_user_data       = msg_user_data
    is_permanent        = is_permanent
    scope_permanent_msg = scope_permanent_msg
    view                = view
    show_as_popup       = show_as_popup
    controller_permanent_msg = controller_permanent_msg
    msg_index           = msg_index
    cancel_navigation   = cancel_navigation
    component           = component
    enable_message_navigation = enable_message_navigation ).

endmethod.


  method if_wd_validation~get_current_messages.
    data: wa type if_wd_message_manager~ty_s_message.

    field-symbols: <item> type wdr_message_item.
*   return all current messages where the element is either initial or valid
    loop at r_transport_messages->* assigning <item>.
      if <item>-element is initial or
         ( <item>-element is bound and
           <item>-element->if_wd_context_element~is_alive( ) = abap_true ).
        move-corresponding <item> to wa.
        append wa to rt_messages.
      endif.
    endloop.
  endmethod.


method if_wd_validation~get_messages_for_attribute.

  data: l_element type ref to cl_wdr_context_element,
        l_message type string.
  field-symbols: <message> type wdr_message_item.

  l_element ?= element.

  loop at r_transport_messages->* assigning <message> where element = l_element.
    if <message>-attribute_name = attribute_name.
      l_message = item_to_string( <message> ).
      append l_message to messages.
    elseif <message>-attributes is not initial.
      read table <message>-attributes transporting no fields with key table_line = attribute_name.
      if sy-subrc = 0.
        l_message = item_to_string( <message> ).
        append l_message to messages.
      endif.
    endif.
  endloop.

endmethod.


method if_wd_validation~get_messages_for_context.

  data: l_node type ref to cl_wdr_context_node,
        l_controller type ref to cl_wdr_controller,
        l_message type string.

  field-symbols: <message> type wdr_message_item,
                 <map_node> type ref to cl_wdr_context_node_map.

* simple case: no errors at all
  if r_transport_messages->* is initial.
    return.
  endif.

* loop through all messages and check whether they belong to current context
  l_controller ?= context.
  loop at r_transport_messages->* assigning <message>
        where element is bound.
    if <message>-element->node is bound.
      l_node = <message>-element->node.
*     original node belongs to current context?
      if l_node->controller = l_controller.
        l_message = item_to_string( <message> ).
        append l_message to messages.
      else.
        data mappers type wdr_context_mapper_set.
        mappers = l_node->get_mapped_nodes( ).
        if mappers is not initial.
*       any mapper of the node that belongs to current context?
          loop at mappers assigning <map_node>.
            if <map_node>->controller = l_controller.
              l_message = item_to_string( <message> ).
              append l_message to messages.
            endif.
          endloop.
        endif.
      endif.
    endif.
  endloop.

endmethod.


METHOD if_wd_validation~get_messages_for_element.

  DATA: l_element TYPE REF TO cl_wdr_context_element,
        l_message TYPE string.
  FIELD-SYMBOLS: <message> TYPE wdr_message_item.

  l_element ?= element.

  LOOP AT r_transport_messages->* ASSIGNING <message>
    WHERE
    element = l_element.
    l_message = item_to_string( <message> ).
    APPEND l_message TO messages.
  ENDLOOP.

ENDMETHOD.


method IF_WD_VALIDATION~GET_MESSAGES_FOR_NODE.

  data: l_node type ref to cl_wdr_context_node,
        l_context type ref to if_wdr_context,
        l_message type string.

  field-symbols: <message> type WDR_MESSAGE_ITEM.

* simple case: no errors at all
  if r_transport_messages->* is initial.
    return.
  endif.

  l_node ?= node.
* if mapped, get the original
  l_node = l_node->get_original_node( ).
  l_context ?= l_node->if_wd_context_node~get_context( ).

  loop at r_transport_messages->* assigning <message>
      where context = l_context
        and element is bound.
    if <message>-element->node = l_node.
      l_message = item_to_string( <message> ).
      append l_message to messages.
    endif.
  endloop.

endmethod.


method if_wd_validation~get_message_for_message_id.

  data: l_message type string.
  field-symbols: <message> type wdr_message_item.

  read table r_transport_messages->* assigning <message> with key msg_id = msg_id.
  if sy-subrc = 0.
    l_message = item_to_string( <message> ).
    append l_message to message.
  endif.

endmethod.


method if_wd_validation~get_message_ids_for_attribute.

  data: l_element type ref to cl_wdr_context_element.

  field-symbols: <item>  type wdr_message_item.

  l_element ?= element.

  loop at r_transport_messages->* assigning <item> where element = element.
    if <item>-attribute_name = attribute_name.
      append <item>-msg_id to message_ids.
    elseif <item>-attributes is not initial.
      read table <item>-attributes transporting no fields with key table_line = attribute_name.
      if sy-subrc = 0.
        append <item>-msg_id to message_ids.
      endif.
    elseif <item>-attributes is initial and <item>-attribute_name is initial.
      append <item>-msg_id to message_ids.
    endif.
  endloop.

  loop at r_render_messages->* assigning <item> where element = element.
    if <item>-attribute_name = attribute_name.
      append <item>-msg_id to message_ids.
    elseif <item>-attributes is not initial.
      read table <item>-attributes transporting no fields with key table_line = attribute_name.
      if sy-subrc = 0.
        append <item>-msg_id to message_ids.
      endif.
    elseif <item>-attributes is initial and <item>-attribute_name is initial.
      append <item>-msg_id to message_ids.
    endif.
  endloop.

endmethod.


method if_wd_validation~get_message_id_for_attribute.

  data: l_element type ref to cl_wdr_context_element.

  field-symbols: <item>  type wdr_message_item.

  l_element ?= element.

  loop at r_transport_messages->* assigning <item> where element = element.
    if <item>-attribute_name = attribute_name.
      msg_id = <item>-msg_id.
      return.
    elseif <item>-attributes is not initial.
      read table <item>-attributes transporting no fields with key table_line = attribute_name.
      if sy-subrc = 0.
        msg_id = <item>-msg_id.
        return.
      endif.
    elseif <item>-attributes is initial and <item>-attribute_name is initial.
      msg_id = <item>-msg_id.
      return.
    endif.
  endloop.

  loop at r_render_messages->* assigning <item> where element = element.
    if <item>-attribute_name = attribute_name.
      msg_id = <item>-msg_id.
      return.
    elseif <item>-attributes is not initial.
      read table <item>-attributes transporting no fields with key table_line = attribute_name.
      if sy-subrc = 0.
        msg_id = <item>-msg_id.
        return.
      endif.
    elseif <item>-attributes is initial and <item>-attribute_name is initial.
      msg_id = <item>-msg_id.
      return.
    endif.
  endloop.

  clear msg_id.
endmethod.


method if_wd_validation~is_attribute_valid.

  data: l_msg_id type string.

  l_msg_id = me->if_wd_validation~get_message_id_for_attribute(
                               element = element
                               attribute_name = attribute_name ).
  if l_msg_id is initial.
    is_valid = abap_true.
  else.
    is_valid = abap_false.
  endif.

endmethod.


method if_wd_validation~is_context_valid.

  data: l_node type ref to cl_wdr_context_node,
        l_controller type ref to cl_wdr_controller.

  field-symbols: <message> type wdr_message_item,
                 <map_node> type ref to cl_wdr_context_node_map.

* simple case: no errors at all
  if r_transport_messages->* is initial.
    is_valid = abap_true.
    return.
  endif.

* loop through all messages and check whether they belong to current context
  l_controller ?= context.
  loop at r_transport_messages->* assigning <message>
      where element is bound.
    if <message>-element->node is bound.
      l_node = <message>-element->node.
*     original node belongs to current context?
      if l_node->controller = l_controller.
        is_valid = abap_false.
        return.
      else.
        data mappers type wdr_context_mapper_set.
        mappers = l_node->get_mapped_nodes( ).
        if mappers is not initial.
*       any mapper of the node that belongs to current context?
          loop at mappers assigning <map_node>.
            if <map_node>->controller = l_controller.
              is_valid = abap_false.
              return.
            endif.
          endloop.
        endif.
      endif.
    endif.
  endloop.

  loop at r_render_messages->* assigning <message>
      where element is bound.
    if <message>-element->node is bound.
      l_node = <message>-element->node.
*     original node belongs to current context?
      if l_node->controller = l_controller.
        is_valid = abap_false.
        return.
      else.
        mappers = l_node->get_mapped_nodes( ).
        if mappers is not initial.
*       any mapper of the node that belongs to current context?
          loop at mappers assigning <map_node>.
            if <map_node>->controller = l_controller.
              is_valid = abap_false.
              return.
            endif.
          endloop.
        endif.
      endif.
    endif.
  endloop.

  is_valid = abap_true.

endmethod.


method IF_WD_VALIDATION~IS_ELEMENT_VALID.

  data: l_element type ref to cl_wdr_context_element.

  l_element ?= element.

  read table r_transport_messages->* with key
    element = l_element
    transporting no fields.
  if sy-subrc = 0.
    is_valid = ABAP_FALSE.
    return.
  else.
    is_valid = ABAP_TRUE.
  endif.

  read table r_render_messages->* with key
    element = l_element
    transporting no fields.
  if sy-subrc = 0.
    is_valid = ABAP_FALSE.
    return.
  else.
    is_valid = ABAP_TRUE.
  endif.

endmethod.


method IF_WD_VALIDATION~IS_NODE_VALID.

  data: l_node type ref to cl_wdr_context_node,
        l_context type ref to if_wdr_context.

  field-symbols: <message> type WDR_MESSAGE_ITEM.

* simple case: no errors at all
  if r_transport_messages->* is initial and
     r_render_messages->* is initial.
    is_valid = ABAP_TRUE.
    return.
  endif.

  l_node ?= node.
* if mapped, get the original
  l_node = l_node->get_original_node( ).

  l_context ?= l_node->if_wd_context_node~get_context( ).

  loop at r_transport_messages->* assigning <message>
      where context = l_context
        and element is bound.
    if <message>-element->node = l_node.
      is_valid = ABAP_FALSE.
      return.
    endif.
  endloop.

  loop at r_render_messages->* assigning <message>
      where context = l_context
        and element is bound.
    if <message>-element->node = l_node.
      is_valid = ABAP_FALSE.
      return.
    endif.
  endloop.

  is_valid = ABAP_TRUE.

endmethod.


method if_wd_validation~set_attribute_valid.

* an attribute is valid whenever there is no entry in the messages table for this attribute
  data: l_element type ref to cl_wdr_context_element.
  data l_msg_keys type string_table.
  data l_index type I.

  field-symbols <item> type wdr_message_item.

  l_element ?= element.

  loop at r_transport_messages->*
      assigning <item>
      where element = l_element and attribute_name = attribute_name.
    l_index = sy-tabix.
    if cl_wdr_message_trace=>m_is_active = abap_true.
      cl_wdr_message_trace=>remove_message_item(
        exporting
          message_item = <item>
          method_name  = 'SET_ATTRIBUTE_VALID'
      ).
      append <item>-msg_key to l_msg_keys.
    endif.
    delete r_transport_messages->* index l_index.
  endloop.

  loop at r_render_messages->*
      assigning <item>
      where element = l_element and attribute_name = attribute_name.
    l_index = sy-tabix.
    if cl_wdr_message_trace=>m_is_active = abap_true.
      read table l_msg_keys from <item>-msg_key transporting no fields.
      if sy-subrc <> 0.
        cl_wdr_message_trace=>remove_message_item(
          exporting
            message_item = <item>
            method_name  = 'SET_ATTRIBUTE_VALID'
        ).
      endif.
    endif.
    delete r_render_messages->* index l_index.
  endloop.

endmethod.


method if_wd_validation~set_context_valid.

  data: l_node type ref to cl_wdr_context_node,
        l_controller type ref to cl_wdr_controller.
  data l_msg_keys type string_table.
  data l_index type I.

  field-symbols <item> type wdr_message_item.
  field-symbols: <message> type wdr_message_item,
                 <map_node> type ref to cl_wdr_context_node_map.

* simple case: no errors at all
  if r_transport_messages->* is initial and
     r_render_messages->* is initial.
    return.
  endif.

* loop through all messages and check whether they belong to current context
  l_controller ?= context.
  loop at r_transport_messages->* assigning <message>
      where element is bound.
    l_index = sy-tabix.
    if <message>-element->node is bound.
      l_node = <message>-element->node.
*     original node belongs to current context?
      if l_node->controller = l_controller.
        if cl_wdr_message_trace=>m_is_active = abap_true.
          cl_wdr_message_trace=>remove_message_item(
            exporting
              message_item = <message>
              method_name  = 'SET_CONTEXT_VALID'
          ).
          append <message>-msg_key to l_msg_keys.
        endif.
        delete r_transport_messages->* index l_index.
      else.
        data mappers type wdr_context_mapper_set.
        mappers = l_node->get_mapped_nodes( ).
        if mappers is not initial.
*       any mapper of the node that belongs to current context?
          loop at mappers assigning <map_node>.
            if <map_node>->controller = l_controller.
              if cl_wdr_message_trace=>m_is_active = abap_true.
                cl_wdr_message_trace=>remove_message_item(
                  exporting
                    message_item = <message>
                    method_name  = 'SET_CONTEXT_VALID'
                ).
                append <message>-msg_key to l_msg_keys.
              endif.
              delete r_transport_messages->* index l_index.
            endif.
          endloop.
        endif.
      endif.
    endif.
  endloop.

  loop at r_render_messages->* assigning <message>
      where element is bound.
    l_index = sy-tabix.
    if <message>-element->node is bound.
      l_node = <message>-element->node.
*     original node belongs to current context?
      if l_node->controller = l_controller.
        if cl_wdr_message_trace=>m_is_active = abap_true.
          read table l_msg_keys from <message>-msg_key transporting no fields.
          if sy-subrc <> 0.
            cl_wdr_message_trace=>remove_message_item(
              exporting
                message_item = <message>
                method_name  = 'SET_CONTEXT_VALID'
            ).
          endif.
        endif.
        delete r_transport_messages->* index l_index.
      else.
        mappers = l_node->get_mapped_nodes( ).
        if mappers is not initial.
*       any mapper of the node that belongs to current context?
          loop at mappers assigning <map_node>.
            if <map_node>->controller = l_controller.
              if cl_wdr_message_trace=>m_is_active = abap_true.
                read table l_msg_keys from <message>-msg_key transporting no fields.
                if sy-subrc <> 0.
                  cl_wdr_message_trace=>remove_message_item(
                    exporting
                      message_item = <message>
                      method_name  = 'SET_CONTEXT_VALID'
                  ).
                endif.
              endif.
              delete r_render_messages->* index l_index.
            endif.
          endloop.
        endif.
      endif.
    endif.
  endloop.

endmethod.


method if_wd_validation~set_element_valid.

* an element is valid whenever there is no entry in the messages table for this attribute
  data: l_element type ref to cl_wdr_context_element.
  data l_msg_keys type string_table.
  data l_index type i.
  field-symbols <item> type wdr_message_item.

  l_element ?= element.

  loop at r_transport_messages->*
      assigning <item>
      where element = l_element.
    l_index = sy-tabix.
    if cl_wdr_message_trace=>m_is_active = abap_true.
      cl_wdr_message_trace=>remove_message_item(
        exporting
          message_item = <item>
          method_name  = 'SET_ELEMENT_VALID'
      ).
      append <item>-msg_key to l_msg_keys.
    endif.
    delete r_transport_messages->* index l_index.
  endloop.

  loop at r_render_messages->*
      assigning <item>
      where element = l_element.
    l_index = sy-tabix.
    if cl_wdr_message_trace=>m_is_active = abap_true.
      read table l_msg_keys from <item>-msg_key transporting no fields.
      if sy-subrc <> 0.
        cl_wdr_message_trace=>remove_message_item(
          exporting
            message_item = <item>
            method_name  = 'SET_ELEMENT_VALID'
        ).
      endif.
    endif.
    delete r_render_messages->* index l_index.
  endloop.

endmethod.


method IF_WD_VALIDATION~SET_NODE_VALID.

* an attribute is valid whenever there is no entry in the messages table for this attribute
  data: l_element_list type WDR_CONTEXT_NODE_COLLECTION,
        l_node type ref to cl_wdr_context_node.
  data l_msg_keys type string_table.
  data l_index type I.
  field-symbols: <el> type ref to cl_wdr_context_element.
  field-symbols <item> type wdr_message_item.

  if r_transport_messages->* is initial and
     r_render_messages->* is initial.
    return.
  endif.

  l_node ?= node.
  l_element_list = l_node->get_elements( ).
  loop at l_element_list assigning <el>.
    loop at r_transport_messages->*
        assigning <item>
        where element = <el>.
      l_index = sy-tabix.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        cl_wdr_message_trace=>remove_message_item(
          exporting
            message_item = <item>
            method_name  = 'SET_NODE_VALID'
        ).
        append <item>-msg_key to l_msg_keys.
      endif.
      delete r_transport_messages->* index l_index.
    endloop.

    loop at r_render_messages->*
        assigning <item>
        where element = <el>.
      l_index = sy-tabix.
      if cl_wdr_message_trace=>m_is_active = abap_true.
        read table l_msg_keys from <item>-msg_key transporting no fields.
        if sy-subrc <> 0.
          cl_wdr_message_trace=>remove_message_item(
            exporting
              message_item = <item>
              method_name  = 'SET_NODE_VALID'
          ).
        endif.
      endif.
      delete r_render_messages->* index l_index.
    endloop.

  endloop.

endmethod.


method ITEM_TO_STRING.

  data: l_item type ref to wdr_message_item.

  if item-msg_type = co_type_reference.
    if follow_reference = abap_true.
      l_item ?= item-orig_msg.
      message = cl_wdr_message_manager=>item_to_string(
        item = l_item->*
        follow_reference = abap_false
      ).
    endif.
  else.
*   switch to different types of messaging
    if item-err_message is not initial.
*   given by text
      message = item-err_message.

    elseif item-msg_object is bound.
*   given by message object
      message = item-msg_object->get_text( ).
    endif.
  endif.
endmethod.


method on_exit_component.
  data l_client_component type ref to cl_wdr_client_component.
  data l_what type string.

* delete permanent messages with scope controller
  delete r_render_messages->* where is_permanent_msg    = abap_true
                              and   scope_permanent_msg = if_wd_message_manager=>co_msg_scope_component
                              and   controller_permanent_msg = m_component.
  if sy-subrc = 0 and
     cl_wdr_message_trace=>m_is_active = abap_true and
     m_component is bound and
     m_component->is_alive = abap_true.
    l_client_component ?= m_component->data_container_superior.
    l_what = `COMPONENT ` && l_client_component->component_usage_path.
    cl_wdr_message_trace=>clear_messages(
      method_name = 'ON_EXIT_COMPONENT'
      what = l_what ).
  endif.


  clear m_component.

endmethod.


method on_exit_context.
  data l_removed type abap_bool.
  data l_client_component type ref to cl_wdr_client_component.
  data l_what type string.

  loop at r_transport_messages->*
      transporting no fields
      where context = context.
    delete r_transport_messages->* index sy-tabix.
    if sy-subrc = 0.
      l_removed = abap_true.
    endif.
  endloop.

* delete permanent messages with scope controller
  delete r_render_messages->* where is_permanent_msg    = abap_true
                              and   scope_permanent_msg = if_wd_message_manager=>co_msg_scope_controller
                              and   controller_permanent_msg = context.
  if sy-subrc = 0.
    l_removed = abap_true.
  endif.

  if l_removed = abap_true and cl_wdr_message_trace=>m_is_active = abap_true and
     m_component is bound and
     m_component->is_alive = abap_true and context is bound.
    l_client_component ?= m_component->data_container_superior.
    l_what = `CONTROLLER ` && l_client_component->component_usage_path && '.' && context->name.
    cl_wdr_message_trace=>clear_messages(
      method_name = 'ON_EXIT_CONTEXT'
      what = l_what ).
  endif.

endmethod.


method raise_message.

  me->report_message(
    attribute     = attribute
    msg           = msg
    type          = type
    params        = params
    msg_object    = msg_object
    msg_user_data = msg_user_data ).

  raise exception type cx_wd_abort_message_manager.

endmethod.


method RAISE_PENDING_EXCEPTION .

  if me->has_exception = ABAP_TRUE or me->HAS_EXCEPTIONS( including_permanent_msg = abap_true ) = ABAP_TRUE.
    raise exception type CX_WD_ABORT_MESSAGE_MANAGER.
  endif.
endmethod.


method remove_outdated_messages.
  field-symbols: <m> type wdr_message_item.

  loop at r_render_messages->* assigning <m>.
    if ( <m>-element is bound and <m>-element->node is not bound ) or
       ( <m>-the_component is bound and <m>-the_component->is_alive = abap_false ).
      delete r_render_messages->*.
      assert id wdr_runtime_msg_manager condition 1 = 0.
    endif.
  endloop.
  is_modified = abap_true.

endmethod.


method REMOVE_VALIDATION_ERRORS.
* validation errors are identified through the type of the exception: CX_WDR_CONVERSION_EXCEPTION
  data l_conversion_error type ref to cx_wdr_conversion_exception.
  FIELD-SYMBOLS <item> type WDR_MESSAGE_ITEM.
  data l_client_component type ref to cl_wdr_client_component.
  data l_what type string.
  data l_removed type abap_bool.

  loop at r_transport_messages->* ASSIGNING <item> WHERE the_component = m_component .
    check <item>-MSG_OBJECT is bound.
    try.
        l_conversion_error ?= <item>-msg_object.
      catch cx_root.
        continue.
    endtry.
    DELETE table r_transport_messages->* from <item>.
    if sy-subrc = 0. l_removed = abap_true. endif.
  endloop.

  loop at r_render_messages->* ASSIGNING <item> WHERE the_component = m_component .
    check <item>-MSG_OBJECT is bound.
    try.
        l_conversion_error ?= <item>-msg_object.
      catch cx_root.
        continue.
    endtry.
    DELETE table r_render_messages->* from <item>.
    if sy-subrc = 0. l_removed = abap_true. endif.
  endloop.

  if l_removed = abap_true and
     cl_wdr_message_trace=>m_is_active = abap_true and
     m_component is bound and
     m_component->is_alive = abap_true.
    l_client_component ?= m_component->data_container_superior.
    l_what = `COMPONENT ` && l_client_component->component_usage_path.
    cl_wdr_message_trace=>clear_messages(
      method_name = 'REMOVE_VALIDATION_ERRORS'
      what = l_what ).
  endif.

endmethod.


method report_message.

  data: item            type wdr_message_item,
        help            type string,
        l_old_msg_found type abap_bool,
       " l_unique_id     type rssguid25,
        l_old_msg_item  type wdr_message_item,
        l_window        type ref to cl_wdr_window,
        l_msg_text      type string,
        l_msg_long_text type string,
        l_exception     type ref to cx_root.
  data  l_component     type ref to cl_wdr_component.

  field-symbols: <par> type wdr_name_value.

  data: l_message_tab        type ref to wdr_message_tab.


  if cancel_navigation = abap_true.
    m_component->if_wd_component~cancel_navigation( ).
  endif.

  if is_permanent = abap_true and
     scope_permanent_msg = if_wd_message_manager=>co_msg_scope_controller and
     controller_permanent_msg is initial.
    raise exception type cx_wdr_rt_exception
        exporting
          textid = cx_wdr_rt_exception=>cntlr_not_specified_perm_msg.
  endif.

if type = co_type_invisible_alert_msg.
  l_message_tab = r_invisible_alert_messages.
else.
  l_message_tab = r_render_messages.
endif.

  if attribute is not initial.
    item-context        = attribute-context.
    item-element        = attribute-element.
    item-attribute_name = attribute-attribute_name.
  endif.
  item-attributes = attributes.
  item-err_message       = msg.
  item-msg_type          = type.
  item-msg_user_data     = msg_user_data.
  item-msg_index         = msg_index.
  if params is not initial.
    item-msg_parameter = params.
    loop at params assigning <par>.
      if <par>-name is not initial.
        concatenate `&` <par>-name into help.
      else.
        help = sy-tabix.
        concatenate `&` help into help.
      endif.
      condense help no-gaps.
      replace help in item-err_message with <par>-value.
    endloop.
  endif.

  if component is bound.
    l_component ?= component.
  else.
    l_component = m_component.
  endif.
  item-the_component = l_component.

  item-msg_object                = msg_object.
  item-is_permanent_msg          = is_permanent.
  item-scope_permanent_msg       = scope_permanent_msg.
  item-view                      = view.
  if item-view is initial and item-element is initial.
    item-view = if_wd_message_manager=>co_top_window.
    item-auto_window_detection = abap_true.
  endif.
  if item-view = if_wd_message_manager=>co_any_window.
    clear item-view.
  endif.
  item-show_as_popup             = show_as_popup.
  item-is_validation_independent = is_validation_independent.
  item-enable_message_navigation = enable_message_navigation.
  item-msg_key                   = msg_key.
  if controller_permanent_msg is bound.
*    item-controller_permanent_msg ?= cl_wdr_proxy_cast_tool=>get_instance( controller_permanent_msg ).
  item-controller_permanent_msg ?= controller_permanent_msg.
  endif.
  if scope_permanent_msg = if_wd_message_manager=>co_msg_scope_component.
    item-controller_permanent_msg = l_component.
  endif.

* performance issues if many messages are rendered
* 2000 x 	 Call Function RSS_SYSTEM_GET_UNIQUE_ID	 	0,833 sec
* GUID is no longer used for message id
* instead we use a static variable as count
*  call function 'RSS_SYSTEM_GET_UNIQUE_ID'
*    importing
*      e_uni_idc25 = l_unique_id.
*  item-msg_id = l_unique_id.
*  message_id = l_unique_id.
  add 1 to m_msg_id_cnt.
  item-msg_id = m_msg_id_cnt.
  message_id = m_msg_id_cnt.

  is_modified = abap_true.

  if type = co_type_error or type = co_type_fatal.
    has_exception = abap_true.
   endif.

  insert item into table l_message_tab->*.
  cl_wdr_message_trace=>add_message_item( method_name = method_name message_item = item ).

* raise message if single_mode and this is an error
  if item-msg_type = co_type_fatal.
    if item-element is bound.
      m_component->if_wd_component~cancel_navigation( ).
    endif.
    if msg_object is bound.
      l_msg_text = item-msg_object->get_text( ).
      l_msg_long_text = item-msg_object->get_longtext( ).
      try.
          l_exception ?= item-msg_object.
        catch cx_sy_move_cast_error.
                                                            "#EC NEEDED
      endtry.
    else.
      l_msg_text = item-err_message.
    endif.
    raise exception type cx_wd_abort_message_manager
      exporting
        textid        = cx_wd_abort_message_manager=>aborted_by_application
        msg_text      = l_msg_text
        msg_long_text = l_msg_long_text
        previous      = l_exception.
  endif.


endmethod.


method report_validation_error.

  data: item        type wdr_message_item,
        r           type ref to wdr_message_item,
        r2          type ref to wdr_message_item,
        wa          type wdr_message_item,
        l_index     type i.
  "l_unique_id type rssguid25.

  item-context        = attribute-context.
  item-element        = attribute-element.
  item-attribute_name = attribute-attribute_name.

  item-msg_type          = message_type.

  item-the_component     = me->m_component.
  item-msg_object        = msg_object.

* performance issues if many messages are rendered
* 2000 x 	 Call Function RSS_SYSTEM_GET_UNIQUE_ID	 	0,833 sec
* GUID is no longer used for message id
* instead we use a static variable as count
*  call function 'RSS_SYSTEM_GET_UNIQUE_ID'
*    importing
*      e_uni_idc25 = l_unique_id.
*  item-msg_id = l_unique_id.
  add 1 to m_msg_id_cnt.
  item-msg_id = m_msg_id_cnt.

  r_transport_attributes->is_modified = abap_true.
  if item-msg_type >= co_type_error.
    r_transport_attributes->has_exceptions = abap_true.
  endif.
* if there is already an entry for this attribute, delete the old one
  read table r_transport_messages->*
      with key
        element = attribute-element
        attribute_name = attribute-attribute_name
      reference into r.
  if sy-subrc = 0.
    l_index = sy-tabix.
    if r->msg_type < 0.
      r2 ?= r->orig_msg.
      if r2 is bound.
        wa = r2->*.
        delete table r_transport_messages->* from r2->*.
        delete table r_transport_messages->* from wa.
      else.
        read table r_transport_messages->*
          with key msg_type = -1
                   orig_msg = r
          reference into r2.
        wa = r2->*.
        delete table r_transport_messages->* from r2->*.
        delete table r_render_messages->* from wa.
      endif.
    endif.
    wa = r->*.
    delete r_transport_messages->* index l_index.
    delete table r_render_messages->* from wa.
  endif.

  insert item into table r_transport_messages->*.
  cl_wdr_message_trace=>add_message_item(
      message_item = item
      method_name  = 'REPORT_VALIDATION_ERROR'
  ).
  is_modified = abap_true.

endmethod.


method reset_topwindow_messages.
  field-symbols: <m> type wdr_message_item.
  data l_window_name type string.
* when a popup is closed, messages automatically placed on this window, should be unbound from this window,
* in order to place them automatically the next time

  me->remove_outdated_messages( ).
  l_window_name = window->view_manager->window_info->definition-view_name.

  loop at r_render_messages->* assigning <m>
         where auto_window_detection = abap_true and
               view                  = l_window_name and
               the_component         = window->root_component.
    <m>-view = if_wd_message_manager=>co_top_window.
  endloop.

  cl_wdr_message_trace=>clear_messages( ).

endmethod.
ENDCLASS.