CLASS /bobf/cl_frw DEFINITION
  PUBLIC
  CREATE PROTECTED

  GLOBAL FRIENDS /bobf/cl_frw_aunit_friend
                 /bobf/cl_frw_factory
                 /bobf/cl_frw_int_access
                 /bobf/cl_frw_lock_manager
                 /bobf/cl_tool_assert
                 /bobf/cl_tool_trace .

  PUBLIC SECTION.

    INTERFACES /bobf/if_frw_service_layer .
    INTERFACES /bobf/if_tra_clone .
    INTERFACES /bobf/if_frw_auth_handler_inst .
    INTERFACES /bobf/if_frw_handle .

    TYPES:
      tt_access_stack TYPE STANDARD TABLE OF REF TO /bobf/cl_frw_int_access WITH DEFAULT KEY .

    DATA mo_authority_handler TYPE REF TO /bobf/cl_frw_authority_handler READ-ONLY .

    CLASS-METHODS class_constructor .
    METHODS constructor
      IMPORTING
        !io_conf TYPE REF TO /bobf/if_frw_configuration
      RAISING
        /bobf/cx_frw .
    METHODS get_enqueue_scope
      RETURNING
        VALUE(rv_enqueue_scope) TYPE /bobf/conf_enqueue_scope .
    METHODS get_cleanup_mode
      RETURNING
        VALUE(rv_cleanup_mode) TYPE /bobf/conf_cleanup_mode .


  PROTECTED SECTION.

    METHODS check_and_determine
      IMPORTING
        !iv_node_key    TYPE /bobf/obm_node_key OPTIONAL
        !it_key         TYPE /bobf/t_frw_key OPTIONAL
        !iv_check_scope TYPE /bobf/frw_scope
        !io_change      TYPE REF TO /bobf/if_frw_change OPTIONAL
      EXPORTING
        !eo_change      TYPE REF TO /bobf/if_frw_change
        !eo_message     TYPE REF TO /bobf/if_frw_message .
    METHODS get_delegation
      IMPORTING
        !iv_node_key         TYPE /bobf/obm_node_key
      RETURNING
        VALUE(eo_delegation) TYPE REF TO /bobf/if_frw_delegation .
    METHODS raise_notify_changes
      IMPORTING
        !io_change              TYPE REF TO /bobf/if_frw_change OPTIONAL
        !iv_notify_entire_stack TYPE boole_d DEFAULT abap_false
          PREFERRED PARAMETER io_change .
    METHODS retrieve
      IMPORTING
        !iv_node_key             TYPE /bobf/obm_node_key
        !it_key                  TYPE /bobf/t_frw_key
        !iv_state                TYPE /bobf/conf_state
        !iv_invalidate_cache     TYPE boole_d DEFAULT abap_false
        !iv_fill_data            TYPE boole_d DEFAULT abap_true
        !iv_edit_mode            TYPE /bobf/conf_edit_mode DEFAULT /bobf/if_conf_c=>sc_edit_read_only
        !iv_buffer_only          TYPE boole_d DEFAULT abap_false
        !iv_within_loading       TYPE boole_d DEFAULT abap_false
        !iv_within_retrieve      TYPE boole_d DEFAULT abap_false
        !it_requested_attributes TYPE /bobf/t_frw_name OPTIONAL
      EXPORTING
        !eo_change               TYPE REF TO /bobf/if_frw_change
        !eo_message              TYPE REF TO /bobf/if_frw_message
        !et_data                 TYPE INDEX TABLE
        !et_failed_key           TYPE /bobf/t_frw_key
        !et_node_cat             TYPE /bobf/t_frw_node_cat .
    METHODS after_loading
      IMPORTING
        !io_change         TYPE REF TO /bobf/if_frw_change
        !iv_within_loading TYPE boole_d DEFAULT abap_false
        !iv_load_state     TYPE /bobf/conf_state
      EXPORTING
        !et_failed_node    TYPE /bobf/t_frw_node
        !eo_message        TYPE REF TO /bobf/if_frw_message
        !et_loaded_node    TYPE /bobf/t_frw_node .
    METHODS retrieve_by_association
      IMPORTING
        !iv_node_key                 TYPE /bobf/obm_node_key
        !it_key                      TYPE /bobf/t_frw_key
        !iv_association              TYPE /bobf/obm_assoc_key
        !is_parameters               TYPE REF TO data OPTIONAL
        !it_filtered_attributes      TYPE /bobf/t_frw_name OPTIONAL
        !iv_state                    TYPE /bobf/conf_state
        !iv_before_image             TYPE boole_d OPTIONAL
        !iv_invalidate_cache         TYPE boole_d DEFAULT abap_false
        !iv_edit_mode                TYPE /bobf/conf_edit_mode DEFAULT /bobf/if_conf_c=>sc_edit_read_only
        !iv_ask_buffer               TYPE boole_d DEFAULT abap_false
        !iv_buffer_only              TYPE boole_d DEFAULT abap_false
        !iv_fill_data                TYPE boole_d DEFAULT abap_false
        !iv_fill_failed_key          TYPE boole_d DEFAULT abap_false
        !iv_with_det_before_retrieve TYPE boole_d DEFAULT abap_true
        !iv_within_loading           TYPE boole_d DEFAULT abap_false
        !it_requested_attributes     TYPE /bobf/t_frw_name OPTIONAL
      EXPORTING
        !eo_change                   TYPE REF TO /bobf/if_frw_change
        !eo_message                  TYPE REF TO /bobf/if_frw_message
        !et_data                     TYPE INDEX TABLE
        !et_key_link                 TYPE /bobf/t_frw_key_link
        !et_target_key               TYPE /bobf/t_frw_key
        !et_failed_key               TYPE /bobf/t_frw_key .
    METHODS set_application_error
      IMPORTING
        io_exception TYPE REF TO cx_root OPTIONAL .
    "! finds all node instances for which a given validation has to be executed, based
    "! on the validation triggers and the given changes.
    METHODS determine_triggered_val_keys
      IMPORTING
        is_validation        TYPE /bobf/s_confro_val_list
        io_change            TYPE REF TO /bobf/cl_frw_change
        iv_processing_mode   TYPE /bobf/frw_processing_mode
        iv_use_check_trigger TYPE abap_bool
        iv_last_state        TYPE /bobf/conf_state
      EXPORTING
        et_key               TYPE /bobf/t_frw_key
      CHANGING
        co_message           TYPE REF TO /bobf/if_frw_message.
    CLASS-METHODS needs_notify_keyload
      IMPORTING
        !iv_has_transient_elements     TYPE boole_d
        !iv_has_auth_determ            TYPE boole_d
        !it_requested_attributes       TYPE /bobf/t_frw_name
        !ir_load_attribute_tab         TYPE REF TO /bobf/t_frw_name
      EXPORTING
        !ev_transient_fields_requested TYPE boole_d
      RETURNING
        VALUE(rv_notify_keyload)       TYPE boole_d .
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_sync_point,
        handle          TYPE        /bobf/conf_key,
        state           TYPE        /bobf/conf_state,
        state_d         TYPE        /bobf/conf_state,
        state_v         TYPE        /bobf/conf_state,
        state_f         TYPE        /bobf/conf_state,
        change_fail_det TYPE REF TO /bobf/cl_frw_change,
        change_fail_val TYPE REF TO /bobf/cl_frw_change,
        states_count    TYPE        i,
      END OF ty_sync_point .
    TYPES:
      tt_sync_point TYPE STANDARD TABLE OF ty_sync_point .
    TYPES:
      ty_transient_node_ctrl TYPE c LENGTH 1 .
    TYPES:
      BEGIN OF ty_dra_consistency_failed_node,
        node_key TYPE /bobf/obm_node_key,
        keys     TYPE /bobf/t_frw_key,
      END OF ty_dra_consistency_failed_node .
    TYPES:
      tt_dra_consistency_failed_node TYPE STANDARD TABLE OF ty_dra_consistency_failed_node .

    DATA mv_loadable TYPE boole_d .
    DATA mo_non_cache_reg TYPE REF TO /bobf/cl_buf_non_cache_regstry.
    CLASS-DATA gv_system_client_role TYPE cccategory .
    DATA mo_buffer TYPE REF TO /bobf/if_frw_buffer .
    DATA mo_change_fail_det TYPE REF TO /bobf/cl_frw_change .
    DATA mo_change_fail_val TYPE REF TO /bobf/cl_frw_change .
    DATA mo_change_save TYPE REF TO /bobf/if_frw_change .
    DATA mo_conf TYPE REF TO /bobf/if_frw_configuration .
    DATA mo_delegation_read TYPE REF TO /bobf/if_frw_read .
    DATA mo_sam TYPE REF TO /bobf/if_frw_status .
    DATA mo_lock_manager TYPE REF TO /bobf/cl_frw_lock_manager .
    DATA mt_access_stack TYPE tt_access_stack .
    DATA mt_action TYPE tt_action .
    DATA mt_association TYPE tt_association .
    DATA mt_change_save TYPE /bobf/t_frw_change_save .
    DATA mt_delegation TYPE /bobf/t_frw_delegation .
    DATA mt_delegation2 TYPE /bobf/t_frw_delegation2 .
    DATA mt_determination TYPE tt_determination .
    DATA mt_node TYPE tt_node .
    DATA mt_nodecat TYPE /bobf/t_frw_node_cat .
    DATA mt_nodecat_key TYPE /bobf/t_frw_key .
    DATA mt_query TYPE tt_query .
    DATA mt_validation TYPE tt_validation .
    DATA mt_value_set_code TYPE tt_value_set_code .
    DATA mt_value_set_id TYPE tt_value_set_id .
    DATA mv_application_error TYPE boole_d .
    DATA mv_before_modification_exists TYPE boole_d .
    DATA mv_configuration_error TYPE boole_d .
    DATA mv_defaults_exists TYPE boole_d .
    DATA mv_modifying_transaction TYPE boole_d .
    DATA mv_nodecat_node_key TYPE /bobf/obm_node_key .
    DATA mt_node_properties_requested TYPE /bobf/t_frw_key2 .
    DATA mv_no_determinations TYPE boole_d .
    DATA mt_sync_point TYPE tt_sync_point .
    CONSTANTS gc_sync_state TYPE string VALUE ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' ##NO_TEXT.
    DATA mv_sync_state_index TYPE i .
    DATA mv_cleanup_mode TYPE /bobf/conf_cleanup_mode .
    DATA mv_enqueue_scope TYPE /bobf/conf_enqueue_scope .
    DATA mo_amount_decimal_converter TYPE REF TO /bobf/cl_frw_amount_dec_conv.
    DATA mv_no_content_changes TYPE abap_bool .
    CONSTANTS:
      BEGIN OF gc_transient_node_ctrl.
    CONSTANTS   none                           TYPE ty_transient_node_ctrl VALUE IS INITIAL.
    CONSTANTS   return_transient_nodes         TYPE ty_transient_node_ctrl VALUE 'X'.
    CONSTANTS   return_transient_only_buffered TYPE ty_transient_node_ctrl VALUE 'B'.
    CONSTANTS END OF gc_transient_node_ctrl .
    CONSTANTS gc_val_time_no_value TYPE /bobf/obm_name VALUE 'NO_VALUE' ##NO_TEXT.
    DATA mv_auth_supr_comp_chi_del_chck TYPE boole_d .
    DATA: mo_lib_draft_active TYPE REF TO /bobf/cl_lib_draft_active_util,
          mo_dra_act_diff TYPE REF TO /bobf/if_frw_draft_active_diff.

    METHODS get_state_for_read
      IMPORTING
        !iv_before_image TYPE boole_d
      RETURNING
        VALUE(rv_state)  TYPE /bobf/conf_state .
    METHODS cleanup_mods_from_unchanged
      IMPORTING
        !it_unchanged          TYPE /bobf/t_frw_node_data
        !it_changed            TYPE /bobf/t_frw_node_data
      CHANGING
        !ct_mod                TYPE /bobf/t_frw_modification
        !ct_update             TYPE /bobf/t_frw_node
        !ct_node_state_create  TYPE /bobf/t_frw_node
        !ct_update_data        TYPE /bobf/t_frw_node_data
        !ct_update_data_status TYPE /bobf/t_frw_node_data .
    METHODS notify_nodes_read_cache_enable
      IMPORTING
        !it_node_key TYPE /bobf/t_frw_key .
    METHODS lock
      IMPORTING
        !it_lock              TYPE /bobf/t_frw_node
        !iv_generic           TYPE boole_d
        !iv_within_loading    TYPE boole_d
        !iv_edit_mode         TYPE /bobf/conf_edit_mode
        !io_change            TYPE REF TO /bobf/if_frw_change
        !it_locked_for_delete TYPE /bobf/t_frw_node OPTIONAL
      CHANGING
        !co_message           TYPE REF TO /bobf/if_frw_message
        !ct_mod               TYPE /bobf/t_frw_modification
        !ct_failed_lock       TYPE /bobf/t_frw_node .
    METHODS do_det_fill_change_fail
      IMPORTING
        !iv_exectime        TYPE /bobf/conf_exectime
        !iv_current_state   TYPE /bobf/conf_state
        !it_failed_root_key TYPE /bobf/t_frw_key
        !io_change          TYPE REF TO /bobf/if_frw_change
      CHANGING
        !co_message         TYPE REF TO /bobf/if_frw_message .
    METHODS type_check
      IMPORTING
        !iv_expected_line_type TYPE string
        !iv_service_name       TYPE string
        !iv_parameter_name     TYPE string
        !it_data               TYPE INDEX TABLE .
    METHODS add_messages
      IMPORTING
        !io_change  TYPE REF TO /bobf/if_frw_change
      CHANGING
        !co_message TYPE REF TO /bobf/if_frw_message .
    METHODS add_trigger_condition
      IMPORTING
        !it_group  TYPE /bobf/t_frw_group
        !io_change TYPE REF TO /bobf/if_frw_change .
    METHODS check_action
      IMPORTING
        !iv_act_key               TYPE /bobf/act_key OPTIONAL
        !iv_node_key              TYPE /bobf/obm_node_key OPTIONAL
        !iv_act_cat               TYPE /bobf/act_cat OPTIONAL
        !is_context               TYPE /bobf/s_frw_ctx_act OPTIONAL
        !is_parameters            TYPE REF TO data OPTIONAL
        !iv_check_property        TYPE boole_d
        !iv_check_validation      TYPE boole_d
        !io_change                TYPE REF TO /bobf/if_frw_change OPTIONAL
        !it_delete_auth_check_key TYPE /bobf/t_frw_key OPTIONAL
      EXPORTING
        !et_failed_key            TYPE /bobf/t_frw_key
        !eo_message               TYPE REF TO /bobf/if_frw_message
      CHANGING
        !ct_key                   TYPE /bobf/t_frw_key .
    METHODS check_fatal_error .
    METHODS check_modification_properties
      IMPORTING
        !iv_state        TYPE /bobf/conf_state
      EXPORTING
        !eo_message      TYPE REF TO /bobf/if_frw_message
        !et_failed       TYPE /bobf/t_frw_node
      CHANGING
        !ct_modification TYPE /bobf/t_frw_modification .
    METHODS cleanup_modifications
      IMPORTING
        !it_failed_node       TYPE /bobf/t_frw_node OPTIONAL
        !io_change            TYPE REF TO /bobf/if_frw_change
        !it_failed_root_key   TYPE /bobf/t_frw_key OPTIONAL
      CHANGING
        !ct_mod               TYPE /bobf/t_frw_modification
        !ct_mod_do            TYPE /bobf/t_frw_modification_do
        !ct_load              TYPE /bobf/t_frw_node OPTIONAL
        !ct_lock_created      TYPE /bobf/t_frw_node OPTIONAL
        !ct_create            TYPE /bobf/t_frw_node OPTIONAL
        !ct_update            TYPE /bobf/t_frw_node OPTIONAL
        !ct_delete            TYPE /bobf/t_frw_node OPTIONAL
        !ct_update_data       TYPE /bobf/t_frw_node_data OPTIONAL
        !ct_update_data_sta   TYPE /bobf/t_frw_node_data OPTIONAL
        !ct_node_state_create TYPE /bobf/t_frw_node OPTIONAL
        !ct_update_data_all   TYPE /bobf/t_frw_node_data OPTIONAL
        !ct_load_only_keyload TYPE /bobf/t_frw_node OPTIONAL
        !ct_node_category     TYPE /bobf/t_frw_node OPTIONAL .
    METHODS convert_altern_key
      IMPORTING
        !iv_node_key               TYPE /bobf/obm_node_key
        !iv_altkey_key             TYPE /bobf/obm_altkey_key
        !iv_target_altkey_key      TYPE /bobf/obm_altkey_key
        !it_key                    TYPE INDEX TABLE
        !iv_state                  TYPE /bobf/conf_state
        !iv_invalidate_cache       TYPE boole_d
        !iv_check_existence        TYPE boole_d
        !iv_fill_target_key        TYPE boole_d
        !iv_buffer_sufficient_hint TYPE boole_d DEFAULT abap_false
      EXPORTING
        !eo_change                 TYPE REF TO /bobf/if_frw_change
        !eo_message                TYPE REF TO /bobf/if_frw_message
        !et_result                 TYPE /bobf/t_frw_keyindex
        !et_key                    TYPE INDEX TABLE .
    METHODS create
      IMPORTING
        !it_mod             TYPE /bobf/t_frw_modification
        !iv_assoc_key       TYPE /bobf/obm_assoc_key
        !iv_edit_mode       TYPE /bobf/conf_edit_mode
        !iv_state           TYPE /bobf/conf_state DEFAULT /bobf/if_conf_c=>sc_state_current
        !iv_within_loading  TYPE boole_d
        !iv_within_retrieve TYPE boole_d
        !io_change          TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !eo_message         TYPE REF TO /bobf/if_frw_message .
    METHODS create_states .
    METHODS derive_consistency_status
      IMPORTING
        !it_failed_val TYPE /bobf/t_frw_validations
      EXPORTING
        !eo_message    TYPE REF TO /bobf/if_frw_message
      CHANGING
        !ct_group      TYPE /bobf/t_frw_group .
    METHODS do_action
      IMPORTING
        !is_action               TYPE /bobf/s_frw_action
        !iv_with_detval          TYPE boole_d DEFAULT abap_true
        !iv_internal_call        TYPE boole_d
        !iv_within_loading       TYPE boole_d DEFAULT abap_false
      EXPORTING
        !eo_message              TYPE REF TO /bobf/if_frw_message
        !eo_change               TYPE REF TO /bobf/if_frw_change
        !et_failed_key           TYPE /bobf/t_frw_key
        !ev_static_action_failed TYPE abap_bool
        !et_data                 TYPE INDEX TABLE
        !et_data_link            TYPE /bobf/t_frw_act_exp_data_link .
    METHODS do_determinations
      IMPORTING
        !iv_exectime     TYPE /bobf/conf_exectime
        !iv_load_state   TYPE /bobf/conf_state OPTIONAL
        !io_change       TYPE REF TO /bobf/if_frw_change
        !iv_cleanup_mode TYPE /bobf/conf_cleanup_mode OPTIONAL
        !iv_keep_cache   TYPE boole_d OPTIONAL
      EXPORTING
        !eo_message      TYPE REF TO /bobf/if_frw_message
        !et_failed       TYPE /bobf/t_frw_node .
    METHODS do_determinations_retrieve
      IMPORTING
        !iv_node_key            TYPE /bobf/obm_node_key OPTIONAL
        !iv_assoc_key           TYPE /bobf/obm_assoc_key OPTIONAL
        !it_key                 TYPE /bobf/t_frw_key
        !iv_key_is_default      TYPE boole_d DEFAULT abap_false
        !is_parameters          TYPE REF TO data OPTIONAL
        !it_filtered_attributes TYPE /bobf/t_frw_name OPTIONAL
        !iv_state               TYPE /bobf/conf_state
        !iv_within_loading      TYPE boole_d
      EXPORTING
        !eo_message             TYPE REF TO /bobf/if_frw_message
        !et_failed_key          TYPE /bobf/t_frw_key .
    METHODS do_detval
      IMPORTING
        !io_change                  TYPE REF TO /bobf/if_frw_change
        !iv_validation_time_context TYPE /bobf/obm_name DEFAULT gc_val_time_no_value
      EXPORTING
        !eo_message                 TYPE REF TO /bobf/if_frw_message .
    METHODS do_loading
      IMPORTING
        !iv_node_key_unique TYPE /bobf/obm_node_key OPTIONAL
        !it_node            TYPE /bobf/t_frw_node OPTIONAL
        !iv_node_key        TYPE /bobf/obm_node_key OPTIONAL
        !it_key             TYPE /bobf/t_frw_key OPTIONAL
        !iv_check_buf       TYPE boole_d DEFAULT abap_true
        !iv_reload          TYPE boole_d DEFAULT abap_false
        !iv_within_loading  TYPE boole_d DEFAULT abap_false
        !io_change          TYPE REF TO /bobf/if_frw_change OPTIONAL
        !iv_load_data       TYPE boole_d
        !iv_load_subtree    TYPE /bobf/frw_load_subtree
        !iv_edit_mode       TYPE /bobf/conf_edit_mode DEFAULT /bobf/if_conf_c=>sc_edit_read_only
        !iv_notify_keyload  TYPE boole_d DEFAULT abap_false
        !it_node_no_reload  TYPE /bobf/t_frw_node OPTIONAL
      EXPORTING
        !et_failed          TYPE /bobf/t_frw_node
        !eo_message         TYPE REF TO /bobf/if_frw_message
        !et_loaded_node     TYPE /bobf/t_frw_node .
    METHODS do_lock_action
      IMPORTING
        !is_lock_param TYPE REF TO /bobf/s_frw_lock_parameters
        !is_context    TYPE /bobf/s_frw_ctx_act
        !iv_act_class  TYPE string
        !io_change     TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !eo_message    TYPE REF TO /bobf/if_frw_message
        !et_failed_key TYPE /bobf/t_frw_key
      CHANGING
        !ct_key        TYPE /bobf/t_frw_key
        !ct_mod        TYPE /bobf/t_frw_modification OPTIONAL ##relax. " relax: private method not called in /bobf/cl_frw
    METHODS do_modify
      IMPORTING
        !it_modification    TYPE /bobf/t_frw_modification
        !iv_internal_modify TYPE boole_d DEFAULT abap_false
        !iv_edit_mode       TYPE /bobf/conf_edit_mode DEFAULT /bobf/if_conf_c=>sc_edit_exclusive
        !iv_assoc_key       TYPE /bobf/obm_assoc_key OPTIONAL
        !iv_act_key         TYPE /bobf/act_key OPTIONAL
        !iv_det_key         TYPE /bobf/det_key OPTIONAL
        !iv_within_loading  TYPE boole_d DEFAULT abap_false
        !iv_within_retrieve TYPE boole_d DEFAULT abap_false
        !iv_state           TYPE /bobf/conf_state DEFAULT /bobf/if_conf_c=>sc_state_current
      EXPORTING
        !eo_message         TYPE REF TO /bobf/if_frw_message
        !eo_change          TYPE REF TO /bobf/if_frw_change .
    METHODS do_validate
      IMPORTING
        !iv_last_state_db           TYPE boole_d DEFAULT abap_false
        !iv_check_group_key         TYPE /bobf/obm_group_key OPTIONAL
        !iv_only_given_validations  TYPE boole_d
        !iv_perform_check_delta     TYPE boole_d DEFAULT abap_false
        !it_validation              TYPE /bobf/t_frw_key OPTIONAL
        !io_change                  TYPE REF TO /bobf/if_frw_change
        !iv_consistency             TYPE boole_d DEFAULT abap_true
        !iv_validation_time_context TYPE /bobf/obm_name DEFAULT gc_val_time_no_value
      EXPORTING
        !eo_message                 TYPE REF TO /bobf/if_frw_message
        !et_failed_val              TYPE /bobf/t_frw_validations .
    METHODS filter_consistency_groups
      CHANGING
        !ct_group TYPE /bobf/t_frw_group .
    METHODS get_content_description
      IMPORTING
        !iv_act                       TYPE boole_d DEFAULT abap_false
        !iv_assoc                     TYPE boole_d DEFAULT abap_false
        !iv_det                       TYPE boole_d DEFAULT abap_false
        !iv_val                       TYPE boole_d DEFAULT abap_false
        !iv_query                     TYPE boole_d DEFAULT abap_false
        !iv_node                      TYPE boole_d DEFAULT abap_false
        !iv_vset                      TYPE boole_d DEFAULT abap_false
        !iv_key                       TYPE /bobf/conf_key
      RETURNING
        VALUE(ev_content_description) TYPE /bobf/obm_name .
    METHODS get_loadable_node
      IMPORTING
        !it_node         TYPE /bobf/t_frw_node
        !iv_load_subtree TYPE /bobf/frw_load_subtree
        !io_change       TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !et_node         TYPE /bobf/t_frw_node
        !et_node_link    TYPE /bobf/t_frw_node_key_link
        !et_failed_node  TYPE /bobf/t_frw_node
        !eo_message      TYPE REF TO /bobf/if_frw_message
      CHANGING
        !ct_load_do      TYPE tt_load_do .
    METHODS get_loadable_subnode
      IMPORTING
        !iv_node_key       TYPE /bobf/obm_node_key
        !it_key            TYPE /bobf/t_frw_key
        !iv_all_lockgroups TYPE boole_d
        !iv_recursive_call TYPE boole_d DEFAULT abap_false
      EXPORTING
        !et_node           TYPE /bobf/t_frw_node
        !eo_message        TYPE REF TO /bobf/if_frw_message
      CHANGING
        !ct_load_do        TYPE tt_load_do .
    METHODS get_lockable_node
      IMPORTING
        !it_node        TYPE /bobf/t_frw_node
        !io_change      TYPE REF TO /bobf/if_frw_change OPTIONAL
      EXPORTING
        !et_node        TYPE /bobf/t_frw_node
        !et_node_link   TYPE /bobf/t_frw_node_key_link
        !et_failed_node TYPE /bobf/t_frw_node
        !eo_message     TYPE REF TO /bobf/if_frw_message
        !et_loaded_node TYPE /bobf/t_frw_node .
    METHODS get_node_cat
      IMPORTING
        !iv_node_key      TYPE /bobf/obm_node_key
        !it_key           TYPE /bobf/t_frw_key
        !iv_current_state TYPE /bobf/conf_state
        !iv_last_state    TYPE /bobf/conf_state
      EXPORTING
        !et_nodecat       TYPE /bobf/t_frw_node_cat
        !et_failed_key    TYPE /bobf/t_frw_key
        !eo_message       TYPE REF TO /bobf/if_frw_message .
    METHODS get_relevant_groups
      IMPORTING
        !iv_processing_mode TYPE /bobf/frw_processing_mode
        !io_change          TYPE REF TO /bobf/if_frw_change
        !iv_state_current   TYPE /bobf/conf_state DEFAULT /bobf/if_conf_c=>sc_state_current
        !iv_state_before    TYPE /bobf/conf_state
      EXPORTING
        !et_group_2_way     TYPE /bobf/t_frw_group
        !et_group_3_way     TYPE /bobf/t_frw_group
        !et_group_no_status TYPE /bobf/t_frw_group
        !et_validations     TYPE /bobf/t_frw_key
        !eo_message         TYPE REF TO /bobf/if_frw_message .
    METHODS get_root_key
      IMPORTING
        !iv_node_key     TYPE /bobf/obm_node_key
        !it_key          TYPE /bobf/t_frw_key
        !iv_before_image TYPE boole_d DEFAULT abap_false
      EXPORTING
        !et_key_link     TYPE /bobf/t_frw_key_link
        !et_failed_key   TYPE /bobf/t_frw_key
        !et_target_key   TYPE /bobf/t_frw_key
        !et_loaded_node  TYPE /bobf/t_frw_node .
    METHODS get_root_key_modify
      IMPORTING
        !it_node     TYPE /bobf/t_frw_node
        !iv_state    TYPE /bobf/conf_state
        !io_change   TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !et_key      TYPE /bobf/t_frw_key
        !eo_message  TYPE REF TO /bobf/if_frw_message
        !et_key_link TYPE /bobf/t_frw_key_link
      CHANGING
        !ct_mod      TYPE /bobf/t_frw_modification OPTIONAL .
    METHODS get_subnodes
      IMPORTING
        !iv_node_key                   TYPE /bobf/obm_node_key
        !it_key                        TYPE /bobf/t_frw_key
        !it_node_key                   TYPE /bobf/t_frw_key2 OPTIONAL
        !iv_stop_at_loadable           TYPE boole_d DEFAULT abap_false
        !iv_stop_at_lockable           TYPE boole_d DEFAULT abap_false
        !iv_stop_at_delegation_root    TYPE boole_d DEFAULT abap_false
        !iv_stop_at_delegation_subtree TYPE boole_d DEFAULT abap_false
        !iv_return_only_loadable       TYPE boole_d DEFAULT abap_false
        !iv_return_only_lockable       TYPE boole_d DEFAULT abap_false
        !iv_return_transient_nodes     TYPE ty_transient_node_ctrl DEFAULT gc_transient_node_ctrl-none
        !iv_return_only_check_trigger  TYPE boole_d DEFAULT abap_false
        !iv_buffer_only                TYPE boole_d DEFAULT abap_false
        iv_fill_child_node_information TYPE abap_bool DEFAULT abap_false
      EXPORTING
        !eo_message                    TYPE REF TO /bobf/if_frw_message
        et_node_with_children          TYPE /bobf/t_frw_node
        et_node_without_children       TYPE /bobf/t_frw_node
      CHANGING
        !ct_host_node                  TYPE /bobf/t_frw_node
        !ct_delegation_root_node       TYPE /bobf/t_frw_node OPTIONAL
        !ct_delegation_subtree         TYPE /bobf/t_frw_node OPTIONAL
        !ct_node_keys_on_path          TYPE /bobf/t_frw_key2 OPTIONAL .
    METHODS map_to_node
      IMPORTING
        !iv_node_key TYPE /bobf/conf_key
        !it_key      TYPE /bobf/t_frw_key
      EXPORTING
        !et_node     TYPE /bobf/t_frw_node .
    "! Creates association change notifications for CREATE, UPDATE, DELETE in case of a dependent object
    METHODS notify_association_changes_do
      IMPORTING
        !io_change  TYPE REF TO /bobf/if_frw_change
        !iv_state   TYPE /bobf/conf_state DEFAULT /bobf/if_conf_c=>sc_state_database
      EXPORTING
        !eo_message TYPE REF TO /bobf/if_frw_message .
    "! Creates association change notifications for CREATE and UPDATE
    METHODS notify_association_changes_cu
      IMPORTING
        !io_change  TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !eo_message TYPE REF TO /bobf/if_frw_message .
    "! Creates association change notifications for DELETE
    METHODS notify_association_changes_d
      IMPORTING
        !io_change     TYPE REF TO /bobf/if_frw_change
        !iv_last_state TYPE /bobf/conf_state DEFAULT /bobf/if_conf_c=>sc_state_database
      EXPORTING
        !eo_message    TYPE REF TO /bobf/if_frw_message .
    METHODS add_notifs_for_resolve_assoc
      IMPORTING
        !it_source_key        TYPE /bobf/t_frw_key
        !ir_assoc             TYPE REF TO /bobf/s_confro_assoc
        !iv_resolve_assoc_key TYPE /bobf/obm_assoc_key
        !iv_state             TYPE /bobf/conf_state
      CHANGING
        !co_message           TYPE REF TO /bobf/if_frw_message
        !ct_content_change    TYPE /bobf/t_frw_change_content .
    METHODS notify_property_changes
      IMPORTING
        !io_change     TYPE REF TO /bobf/if_frw_change
        !iv_last_state TYPE /bobf/conf_state OPTIONAL
        !iv_delete     TYPE boole_d DEFAULT abap_false
      EXPORTING
        !eo_message    TYPE REF TO /bobf/if_frw_message .
    METHODS restrict_property
      IMPORTING
        !iv_node_property             TYPE boole_d DEFAULT abap_false
        !iv_node_attribute_property   TYPE boole_d DEFAULT abap_false
        !it_node_attribute            TYPE /bobf/t_frw_name OPTIONAL
        !iv_assoc_property            TYPE boole_d DEFAULT abap_false
        !it_assoc                     TYPE /bobf/t_frw_key2 OPTIONAL
        !iv_assoc_attribute_property  TYPE boole_d DEFAULT abap_false
        !iv_action_property           TYPE boole_d DEFAULT abap_false
        !it_action                    TYPE /bobf/t_frw_key2 OPTIONAL
        !iv_action_attribute_property TYPE boole_d DEFAULT abap_false
        !iv_query_property            TYPE boole_d DEFAULT abap_false
        !it_query                     TYPE /bobf/t_frw_key2 OPTIONAL
        !iv_query_attribute_property  TYPE boole_d DEFAULT abap_false
      CHANGING
        !ct_property_data             TYPE /bobf/t_confro_property_d OPTIONAL .
    METHODS retrieve_subtree_property
      IMPORTING
        !iv_node_key           TYPE /bobf/obm_node_key
        !it_key                TYPE /bobf/t_frw_key
        !it_key_link           TYPE /bobf/t_frw_key_link OPTIONAL
        !iv_state              TYPE /bobf/conf_state
        !iv_determine_property TYPE boole_d DEFAULT abap_true
        !iv_resolve_property   TYPE boole_d OPTIONAL
        !iv_node_property      TYPE boole_d OPTIONAL
        !iv_assoc_property     TYPE boole_d OPTIONAL
        !it_assoc              TYPE /bobf/t_frw_key2 OPTIONAL
      EXPORTING
        !et_property           TYPE /bobf/t_frw_property_k
        !eo_message            TYPE REF TO /bobf/if_frw_message .
    METHODS set_configuration_error
      IMPORTING
        !io_exception TYPE REF TO cx_root OPTIONAL .
    METHODS set_consistency_status
      IMPORTING
        !it_group   TYPE /bobf/t_frw_group
        !io_change  TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !eo_message TYPE REF TO /bobf/if_frw_message .
    METHODS set_node_category
      IMPORTING
        !it_node            TYPE /bobf/t_frw_node
        !iv_internal_modify TYPE boole_d
      EXPORTING
        !et_failed          TYPE /bobf/t_frw_node
        !eo_message         TYPE REF TO /bobf/if_frw_message .
    METHODS check_properties_before_modify
      IMPORTING
        !io_change             TYPE REF TO /bobf/if_frw_change
        !iv_state              TYPE /bobf/conf_state
      CHANGING
        !co_message            TYPE REF TO /bobf/if_frw_message
        !ct_mod                TYPE /bobf/t_frw_modification
        !ct_mod_do             TYPE /bobf/t_frw_modification_do
        !ct_create             TYPE /bobf/t_frw_node
        !ct_update             TYPE /bobf/t_frw_node
        !ct_delete             TYPE /bobf/t_frw_node
        !ct_lock_created       TYPE /bobf/t_frw_node
        !ct_node_category      TYPE /bobf/t_frw_node
        !ct_update_data        TYPE /bobf/t_frw_node_data
        !ct_update_data_status TYPE /bobf/t_frw_node_data
        !ct_update_data_all    TYPE /bobf/t_frw_node_data
        !ct_node_state_create  TYPE /bobf/t_frw_node .
    METHODS unlock_lockable_nodes
      IMPORTING
        !it_nodes TYPE /bobf/t_frw_node .
    METHODS check_action_node_category
      IMPORTING
        !is_conf_action TYPE /bobf/s_confro_act_list
        !is_conf_node   TYPE /bobf/s_confro_node
        !iv_last_state  TYPE /bobf/conf_state
      CHANGING
        !ct_key         TYPE /bobf/t_frw_key
        !ct_failed_key  TYPE /bobf/t_frw_key
        !co_message     TYPE REF TO /bobf/if_frw_message .
    METHODS collect_messages
      IMPORTING
        !io_message TYPE REF TO /bobf/if_frw_message
      CHANGING
        !co_message TYPE REF TO /bobf/if_frw_message .
    METHODS create_durable_msg_container
      CHANGING
        !co_message TYPE REF TO /bobf/if_frw_message .
    METHODS remove_durable_messages
      IMPORTING
        it_node_deleted_w_children  TYPE /bobf/t_frw_node
        it_node_deleted_wo_children TYPE /bobf/t_frw_node
      CHANGING
        !co_message                 TYPE REF TO /bobf/if_frw_message .
    METHODS do_delete_action
      IMPORTING
        !it_delete      TYPE /bobf/t_frw_node
        !io_change      TYPE REF TO /bobf/if_frw_change
      EXPORTING
        !eo_message     TYPE REF TO /bobf/if_frw_message
        !et_failed_node TYPE /bobf/t_frw_node .
    METHODS execute_action
      IMPORTING
        !is_context              TYPE /bobf/s_frw_ctx_act
        !is_conf                 TYPE /bobf/s_confro_act_list
        !is_parameter            TYPE REF TO data OPTIONAL
        !io_change               TYPE REF TO /bobf/if_frw_change
        !iv_within_loading       TYPE abap_bool DEFAULT abap_false
        !iv_is_base_action       TYPE abap_bool DEFAULT abap_true
      EXPORTING
        !et_failed_key           TYPE /bobf/t_frw_key
        !eo_message              TYPE REF TO /bobf/if_frw_message
        !ev_static_action_failed TYPE abap_bool
        !et_data                 TYPE INDEX TABLE
        !et_data_link            TYPE /bobf/t_frw_act_exp_data_link
      CHANGING
        !ct_key                  TYPE /bobf/t_frw_key .
    METHODS check_inconsistent_composition
      IMPORTING
        !it_create_node TYPE /bobf/t_frw_node
      EXPORTING
        !eo_message     TYPE REF TO /bobf/if_frw_message
        !et_failed_node TYPE /bobf/t_frw_node .
    METHODS lib_enqueue_context_push_keys
      IMPORTING
        !iv_node_key TYPE /bobf/obm_node_key
        !it_key      TYPE /bobf/t_frw_key .
    METHODS lib_enqueue_context_pop .
    METHODS evaluate_failed_validate_keys
      IMPORTING
        !iv_node_key         TYPE /bobf/obm_node_key
        !it_key              TYPE /bobf/t_frw_key
        !it_failed_val       TYPE /bobf/t_frw_validations
      EXPORTING
        !et_inconsistent_key TYPE /bobf/t_frw_key
      RAISING
        /bobf/cx_frw .
    "! @parameter iv_state_current | can be omitted if an internal access object is on mt_access_stack
    "! @parameter iv_state_before  | can be omitted if an internal access object is on mt_access_stack
    METHODS get_validation_trigger
      IMPORTING
        !iv_processing_mode TYPE /bobf/frw_processing_mode
        !is_change_mode     TYPE /bobf/s_confro_chg_mode
        !iv_node_key        TYPE /bobf/obm_node_key
        !io_change          TYPE REF TO /bobf/cl_frw_change
        !iv_state_current   TYPE /bobf/conf_state OPTIONAL
        !iv_state_before    TYPE /bobf/conf_state OPTIONAL
      EXPORTING
        !et_key             TYPE /bobf/t_frw_key .
    METHODS val_time_to_processing_mode
      IMPORTING
        !iv_val_time              TYPE /bobf/obm_name
      RETURNING
        VALUE(rv_processing_mode) TYPE /bobf/frw_processing_mode .
    METHODS prepare_notifications_f_export
      IMPORTING
        !io_change TYPE REF TO /bobf/cl_frw_change .
    METHODS convert_asc_src_to_cont_change
      IMPORTING
        !it_association_source   TYPE /bobf/if_frw_change=>tt_association_source
      RETURNING
        VALUE(rt_content_change) TYPE /bobf/t_frw_change_content .
    "! creates the change container for the current SAVE sequence.
    "! @parameter et_root_key_all | contains all changed root keys (including those from delegations), even if it_root_key is initial.
    METHODS create_change_save
      IMPORTING
        !it_root_key     TYPE /bobf/t_frw_key
      EXPORTING
        !et_root_key_all TYPE /bobf/t_frw_key
      RETURNING
        VALUE(ro_change) TYPE REF TO /bobf/if_frw_change .
    "! returns the change container for the current SAVE sequence (may return UNBOUND reference).
    METHODS get_change_save
      IMPORTING
        !it_root_key     TYPE /bobf/t_frw_key
      RETURNING
        VALUE(ro_change) TYPE REF TO /bobf/if_frw_change .
    "! clears the change container for the current SAVE sequence
    METHODS clear_change_save
      IMPORTING
        !it_root_key TYPE /bobf/t_frw_key .
    "! draft applications only: create enqueue context for new draft root instance *created internally* (IO_MODIFY)
    METHODS enqueue_context_for_int_create
      IMPORTING
        !iv_state   TYPE /bobf/conf_state
      CHANGING
        !ct_create  TYPE /bobf/t_frw_node
        !ct_restore TYPE /bobf/t_frw_node
        !co_message TYPE REF TO /bobf/if_frw_message .
    "! Those keys from certain library determinations are completely ignored, since no messages are created for sure
    "! Those keys for newly-created instances without any messages are deleted from it_all_keys
    METHODS filter_out_unnecessary_detkeys IMPORTING io_det_class  TYPE REF TO /bobf/if_frw_determination
                                                     it_all_keys   TYPE /bobf/t_frw_key
                                           RETURNING VALUE(rt_key) TYPE /bobf/t_frw_key.
    METHODS filter_out_unnecessary_actkeys IMPORTING is_context    TYPE /bobf/s_frw_ctx_act
                                                     it_all_keys   TYPE /bobf/t_frw_key
                                           RETURNING VALUE(rt_key) TYPE /bobf/t_frw_key.
    METHODS filter_unauthorised_prop_keys IMPORTING iv_node_key TYPE /bobf/obm_node_key
                                          CHANGING  ct_key      TYPE /bobf/t_frw_key.
    METHODS delegate_retrieve_property IMPORTING iv_node_key                  TYPE /bobf/obm_node_key
                                                 it_key                       TYPE /bobf/t_frw_key
                                                 iv_key_is_default            TYPE boole_d
                                                 iv_node_property             TYPE boole_d
                                                 iv_node_attribute_property   TYPE boole_d
                                                 it_node_attribute            TYPE /bobf/t_frw_name
                                                 iv_assoc_property            TYPE boole_d
                                                 it_assoc                     TYPE /bobf/t_frw_key2
                                                 iv_assoc_attribute_property  TYPE boole_d
                                                 iv_action_property           TYPE boole_d
                                                 it_action                    TYPE /bobf/t_frw_key2
                                                 iv_action_attribute_property TYPE boole_d
                                                 iv_check_services            TYPE /bobf/conf_check_services
                                                 io_property                  TYPE REF TO /bobf/if_frw_property
                                       EXPORTING et_failed_key                TYPE /bobf/t_frw_key.
    METHODS add_opcode_trigger_to_change
      IMPORTING
        it_check_key        TYPE /bobf/t_frw_key
        io_change           TYPE REF TO /bobf/cl_frw_change.
    METHODS is_draft
      IMPORTING
                iv_node_key   TYPE /bobf/obm_node_key
                it_key        TYPE /bobf/t_frw_key
      RETURNING VALUE(result) TYPE abap_bool.
    METHODS can_accelerate_check
      IMPORTING
        iv_node_key    TYPE /bobf/obm_node_key
        it_key         TYPE /bobf/t_frw_key
      RETURNING
        VALUE(result)  TYPE abap_bool.
ENDCLASS.



CLASS /BOBF/CL_FRW IMPLEMENTATION.


  METHOD /bobf/if_frw_service_layer~adjust_numbers.

    DATA: lt_root_key         TYPE /bobf/t_frw_key,
          lt_tmp_key          TYPE /bobf/t_frw_key,
          lt_failed_node      TYPE /bobf/t_frw_node,
          lt_adjusted_numbers TYPE /bobf/t_frw_adjusted_numbers,
          lo_delegation       TYPE REF TO /bobf/if_frw_delegation,
          lo_change_save      TYPE REF TO /bobf/if_frw_change,
          lx_root             TYPE REF TO cx_root.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    CLEAR: eo_change, eo_message, et_adjusted_numbers.

    lo_change_save = get_change_save( it_root_key ).

* ____________________________________________________________________ *
* check if there is really something to do
    CHECK lo_change_save IS BOUND.

* ____________________________________________________________________ *
* check for fatal errors
    check_fatal_error( ).

* ____________________________________________________________________ *
* get_list of changed objects to save
    IF it_root_key IS INITIAL.
      TRY.
          mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys(
              EXPORTING io_read     = mo_delegation_read
              IMPORTING et_root_key = lt_tmp_key ).
            APPEND LINES OF lt_tmp_key TO lt_root_key.
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      lt_root_key = it_root_key.
    ENDIF.

    CHECK lt_root_key IS NOT INITIAL.
    SORT lt_root_key BY key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* perform determinations (before save to draw numbers)
    do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_before_save_numbers
          io_change   = lo_change_save
        IMPORTING
          eo_message  = eo_message
          et_failed   = lt_failed_node ).

    IF lt_failed_node IS NOT INITIAL.
      ASSERT ID /bobf/frw_error CONDITION 0 = 1.           "#EC BOOL_OK
      set_application_error( ).
    ENDIF.

* ____________________________________________________________________ *
* adjust numbers of delegated objects
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->adjust_numbers(
            EXPORTING
              it_root_key         = lt_root_key
            IMPORTING
              et_adjusted_numbers = lt_adjusted_numbers ).
          APPEND LINES OF lt_adjusted_numbers TO et_adjusted_numbers.
        ENDLOOP.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

* ____________________________________________________________________ *
* create change object for external world
    eo_change = /bobf/cl_frw_factory=>get_change( ).
    eo_change->merge( lo_change_save ).
    prepare_notifications_f_export( CAST /bobf/cl_frw_change( eo_change ) ).
    notify_association_changes_cu( eo_change ).
    notify_property_changes( eo_change ).
    CAST /bobf/cl_frw_change( eo_change )->delete_duplicate_notifications( ).

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~after_failed_save.

    DATA: lt_root_key    TYPE /bobf/t_frw_key,
          lt_tmp_key     TYPE /bobf/t_frw_key,
          lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
          lo_message     TYPE REF TO /bobf/if_frw_message,
          lo_change_save TYPE REF TO /bobf/if_frw_change,
          lx_root        TYPE REF TO cx_root.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    CLEAR: eo_message,
           eo_change.

    mv_no_determinations = abap_false.

    lo_change_save = get_change_save( it_root_key ).

*  ____________________________________________________________________ *
*  check if there is really something to do
*  if lo_change_save is not bound the object wasn't called yet
    IF  lo_change_save IS BOUND
    AND lo_change_save->has_changes( ).

*  ____________________________________________________________________ *
*  get_list of changed objects
      IF it_root_key IS INITIAL.
        TRY.
            mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
            LOOP AT mt_delegation2 INTO lo_delegation.
              lo_delegation->get_root_keys(
                EXPORTING io_read     = mo_delegation_read
                IMPORTING et_root_key = lt_tmp_key ).
              APPEND LINES OF lt_tmp_key TO lt_root_key.
            ENDLOOP.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ELSE.
        lt_root_key = it_root_key.
      ENDIF.

      SORT lt_root_key BY key.
      DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.
*  ____________________________________________________________________ *
*  after save for delegated objects
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->after_failed_save(
              EXPORTING
                it_root_key = lt_root_key
                io_change   = lo_change_save
              IMPORTING
                eo_message  = lo_message ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDLOOP.

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

*  ____________________________________________________________________ *
*  perform determinations (before save)
      do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_after_fail_save
          io_change   = lo_change_save
        IMPORTING
          eo_message  = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      eo_change = /bobf/cl_frw_factory=>get_change( ).
      eo_change->merge( lo_change_save ).
      prepare_notifications_f_export( CAST /bobf/cl_frw_change( eo_change ) ).
      notify_association_changes_cu( eo_change ).
      notify_property_changes( eo_change ).
      CAST /bobf/cl_frw_change( eo_change )->delete_duplicate_notifications( ).

    ENDIF.

    clear_change_save( it_root_key ).

    IF mo_sam IS BOUND.
      mo_sam->cleanup( ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~after_successful_save.

    DATA:
      lt_root_key                    TYPE /bobf/t_frw_key,
      lt_chngd_and_unchngd_root_keys TYPE /bobf/t_frw_key,
      lt_tmp_key                     TYPE /bobf/t_frw_key,
      lt_root_node                   TYPE /bobf/t_frw_node,
      lv_cleanup_mode                TYPE /bobf/conf_cleanup_mode,
      lv_application_information     TYPE string,
      lx_frw                         TYPE REF TO /bobf/cx_frw_core,
      ls_determination               TYPE REF TO /bobf/s_confro_exectime,
      lo_delegation                  TYPE REF TO /bobf/if_frw_delegation,
      lo_message                     TYPE REF TO /bobf/if_frw_message,
      lx_root                        TYPE REF TO cx_root,
      lo_change_lock                 TYPE REF TO /bobf/if_frw_change,
      lo_change_save                 TYPE REF TO /bobf/if_frw_change.


    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    CLEAR: eo_message,
           eo_change.

    mv_no_determinations = abap_false.

*  ____________________________________________________________________ *
*  transaction manager may overrule the cleanup mode
*  in case of asynchronous save & continue transaction pattern

    lv_cleanup_mode = mv_cleanup_mode.
    IF /bobf/cl_tra_transaction_mgr=>gv_tp_asynchronous_save = abap_true.
      "  As the BOPF update task writing the changes to database run asynchronously in that case,
      "  it is not ensured, that its execution was finished until a BO reload old data from the database.
      "  Thus all BOs must reuse their buffer as the new database state
      IF lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_refresh.
        lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_keep.
      ENDIF.

      " also ensure, that there is no AfterCommit Determination for the same reason
      ls_determination = mo_conf->get_determination( /bobf/if_conf_c=>sc_time_after_succ_save ).
      IF ls_determination IS NOT INITIAL AND ls_determination->det_list IS BOUND.
        IF ls_determination->det_list->* IS NOT INITIAL.
          " AfterCommit determinations are not allowed in scenarios using Asynchronous Save & Continue Patterns
          lv_application_information = 'AfterCommit Determinations are not allowed in Asynchronous Save & Continue scenarios' ##no_text.  " shall be English as part of dump
          CREATE OBJECT lx_frw
            EXPORTING
              previous                   = lx_root
              textid                     = /bobf/cx_frw_core=>sc_transaction_mode_error
              mv_application_information = lv_application_information.
          set_application_error( lx_frw ).
        ENDIF.
      ENDIF.
    ENDIF.

*  ____________________________________________________________________ *
*  get_list of changed objects
    IF it_root_key IS INITIAL.
      TRY.
          mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys( EXPORTING io_read     = mo_delegation_read
                                          IMPORTING et_root_key = lt_tmp_key ).
            APPEND LINES OF lt_tmp_key TO lt_root_key.
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      lt_root_key = it_root_key.
    ENDIF.
    SORT lt_root_key BY key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

    lo_change_save = get_change_save( it_root_key ).

    IF lo_change_save IS BOUND.
*  ____________________________________________________________________ *
*    after save for delegated objects
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->after_successful_save( EXPORTING it_root_key = lt_root_key
                                                            io_change   = lo_change_save
                                                  IMPORTING eo_message  = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

*  ____________________________________________________________________ *
*    perform determinations (after successful save)
      IF lo_change_save->has_changes( ) = abap_true.
        do_determinations( EXPORTING iv_exectime = /bobf/if_conf_c=>sc_time_after_succ_save
                                     io_change   = lo_change_save
                           IMPORTING eo_message  = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
        prepare_notifications_f_export( CAST /bobf/cl_frw_change( lo_change_save ) ).
        notify_association_changes_cu( lo_change_save ).
        CAST /bobf/cl_frw_change( lo_change_save )->delete_duplicate_notifications( ).
      ENDIF.

      eo_change = lo_change_save.
      notify_property_changes( eo_change ).
    ENDIF.

*  ____________________________________________________________________ *
*  cleanup locks
    mo_lock_manager->after_successful_save( EXPORTING iv_cleanup_mode = lv_cleanup_mode
                                            IMPORTING eo_message      = lo_message
                                                      eo_change       = lo_change_lock ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    IF lo_change_lock IS BOUND.
      IF eo_change IS BOUND.
        eo_change->merge( lo_change_lock ).
      ELSE.
        eo_change = lo_change_lock.
      ENDIF.
    ENDIF.

*  ____________________________________________________________________ *
*  clear buffer states - copy current to database

    TRY.
        mo_buffer->get_root_keys( EXPORTING iv_changed_only = abap_false
                                  IMPORTING et_root_key     = lt_chngd_and_unchngd_root_keys ).
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    IF lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_keep
    OR lv_cleanup_mode = /bobf/if_conf_c=>sc_cleanup_keep_lock.
*    endless transaction
      map_to_node( EXPORTING iv_node_key = mo_conf->ms_obj-root_node_key
                             it_key      = lt_chngd_and_unchngd_root_keys
                   IMPORTING et_node     = lt_root_node ).
      IF mv_modifying_transaction = abap_true.
        TRY.
            do_determinations( EXPORTING iv_exectime   = /bobf/if_conf_c=>sc_time_cleanup
                                         io_change     = lo_change_save
                                         iv_keep_cache = abap_true
                               IMPORTING eo_message    = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            " Reset state to non-modifying transaction...
            mv_modifying_transaction = abap_false.
            " Clear change buffers
            mo_buffer->do_cleanup( it_root_key   = lt_chngd_and_unchngd_root_keys
                                   iv_keep_cache = abap_true ).
            " And remove unnecessary states from buffer (will be created later on)!
            mo_buffer->delete_state( it_node         = lt_root_node
                                     iv_incl_subtree = abap_true
                                     iv_state        = /bobf/if_conf_c=>sc_state_database ).
            IF mo_conf->ms_obj-last_val_state_not_relevant = abap_false.
              mo_buffer->delete_state( it_node         = lt_root_node
                                       iv_incl_subtree = abap_true
                                       iv_state        = /bobf/if_conf_c=>sc_state_last_validated ).
            ENDIF.
            IF mo_conf->ms_obj-last_det_state_not_relevant = abap_false.
              mo_buffer->delete_state( it_node         = lt_root_node
                                       iv_incl_subtree = abap_true
                                       iv_state        = /bobf/if_conf_c=>sc_state_last_determined ).
            ENDIF.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.
      IF mv_defaults_exists = abap_true.
        TRY.
            mo_buffer->delete_state( it_node         = lt_root_node
                                     iv_incl_subtree = abap_true
                                     iv_state        = /bobf/if_conf_c=>sc_state_default ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.

    ELSE. "cleanup mode is REFRESH
      mv_modifying_transaction = abap_false.

      do_determinations( EXPORTING iv_exectime   = /bobf/if_conf_c=>sc_time_cleanup
                                   io_change     = lo_change_save
                                   iv_keep_cache = abap_false
                         IMPORTING eo_message  = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
      " do complete cleanup
      TRY.
          mo_buffer->do_cleanup( it_root_key = lt_chngd_and_unchngd_root_keys ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

    mv_defaults_exists = abap_false.

    clear_change_save( it_root_key ).

    IF mo_sam IS BOUND.
      mo_sam->cleanup( ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_action.

    DATA: lt_key                TYPE /bobf/t_frw_key,
          ls_actconf            TYPE /bobf/s_confro_act_list,
          ls_key                TYPE /bobf/s_frw_key,
          lt_failed_key         TYPE /bobf/t_frw_key,
          lo_change             TYPE REF TO /bobf/if_frw_change,
          lo_message            TYPE REF TO /bobf/if_frw_message,
          lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
          lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
          lt_auth_failed_key    TYPE /bobf/t_frw_key.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           et_failed_key.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
    ENDIF.

* check for the action
    lt_key = is_action-key.
    lo_change = /bobf/cl_frw_factory=>get_change( ).

* ____________________________________________________________________ *
* check existence of all node instances the action is called with
    IF lt_key IS NOT INITIAL.
      IF mo_conf->ms_last_action-act_key NE is_action-act_key.
        mo_conf->get_act(
          EXPORTING
            iv_act_key = is_action-act_key
          IMPORTING
            es_action  = ls_actconf ).
      ELSE.
        ls_actconf = mo_conf->ms_last_action.
      ENDIF.

      ASSERT ID /bobf/frw CONDITION
         /bobf/cl_tool_assert=>is_key_subset_stack_set(
             it_key_set = lt_key ) = abap_true.

      retrieve(
        EXPORTING
          iv_node_key         = ls_actconf-node_key
          it_key              = lt_key
          iv_state            = /bobf/if_conf_c=>sc_state_current
          iv_invalidate_cache = abap_false
          iv_fill_data        = abap_false
          iv_edit_mode        = /bobf/if_conf_c=>sc_edit_read_only
          iv_buffer_only      = abap_false
          iv_within_loading   = abap_false
        IMPORTING
          eo_message          = lo_message
          et_failed_key       = lt_failed_key ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      LOOP AT lt_failed_key INTO ls_key.
        DELETE lt_key WHERE key = ls_key-key.
      ENDLOOP.

      ASSERT ID /bobf/frw CONDITION
         /bobf/cl_tool_assert=>is_key_subset_stack_check(
             it_key_subset = lt_failed_key ) = abap_true.

      IF lt_key IS INITIAL.
        et_failed_key = lt_failed_key.
        RETURN.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* check authorization
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-check_action
                                    bo_service          = space
                                    node_key            = ls_actconf-node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = lt_auth_failed_key
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).

    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_set(
           it_key_set = lt_key ) = abap_true.

    check_action(
      EXPORTING
        iv_act_key          = is_action-act_key
        is_parameters       = is_action-parameters
        iv_check_property   = abap_true
        iv_check_validation = abap_true
        io_change           = lo_change
      IMPORTING
        eo_message          = lo_message
        et_failed_key       = et_failed_key
      CHANGING
        ct_key              = lt_key ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    LOOP AT lt_failed_key INTO ls_key.
      INSERT ls_key INTO TABLE et_failed_key.
    ENDLOOP.

    LOOP AT lt_auth_failed_key INTO ls_key.
      INSERT ls_key INTO TABLE et_failed_key.
    ENDLOOP.

    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_check(
           it_key_subset = et_failed_key ) = abap_true.
    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_and_determine.

* consistency check + calculation of consistency groups with status

    DATA: lo_message            TYPE REF TO /bobf/if_frw_message,
          lo_message2           TYPE REF TO /bobf/if_frw_message,
          lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
          lo_change             TYPE REF TO /bobf/if_frw_change,
          lo_change_cl          TYPE REF TO /bobf/cl_frw_change,
          lt_failed_val         TYPE /bobf/t_frw_validations,
          lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
          lo_auth_change        TYPE REF TO /bobf/if_frw_change,
          lt_key                TYPE /bobf/t_frw_key.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           eo_change,
           ev_rejected. " can be deleted

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
      IF lo_int_access->mv_valid_if_check = abap_false.
        ASSERT ID /bobf/frw_error CONDITION 0 = 1.         "#EC BOOL_OK
*     todo
      ENDIF.
    ENDIF.

    lt_key = it_key.

* ____________________________________________________________________ *
* check authorization (ignore IV_CHECK_SCOPE!)
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-change
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-check_and_determine
                                    bo_service          = space
                                    node_key            = iv_node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).

* ____________________________________________________________________ *
* check for pending determinations
    IF mo_change_fail_det IS BOUND.
      lo_change = /bobf/cl_frw_factory=>get_change( ).
      lo_change->merge( mo_change_fail_det ).
      CLEAR mo_change_fail_det.
      do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_after_modify
          io_change   = lo_change
        IMPORTING
          eo_message  = lo_message ).
    ENDIF.

    IF mo_change_fail_val IS BOUND.
      IF lo_change IS NOT BOUND.
        lo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.
      lo_change->merge( mo_change_fail_val ).
      CLEAR mo_change_fail_val.
      do_validate(
        EXPORTING
          iv_only_given_validations  = abap_false
          io_change                  = lo_change
          iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check_and_determ
        IMPORTING
          et_failed_val              = lt_failed_val
          eo_message                 = lo_message2 ).
      collect_messages( EXPORTING io_message = lo_message2
                        CHANGING  co_message = lo_message ).

      do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_after_validation
          io_change   = lo_change
        IMPORTING
          eo_message  = lo_message2 ).
      collect_messages( EXPORTING io_message = lo_message2
                        CHANGING  co_message = lo_message ).
    ENDIF.

* ____________________________________________________________________ *
* call internal method
    check_and_determine(
      EXPORTING
        iv_node_key    = iv_node_key
        it_key         = lt_key
        iv_check_scope = iv_check_scope
      IMPORTING
        eo_change      = eo_change
        eo_message     = eo_message ).

* ____________________________________________________________________ *
* merge output from pending determinations into output from regular check_and_determine
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF lt_failed_val IS NOT INITIAL.
      ev_rejected = abap_true.
    ENDIF.

    IF lo_change IS BOUND.
      IF eo_change IS BOUND.
        eo_change->merge( lo_change ).
      ELSE.
        eo_change = lo_change.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* handle changes
    IF eo_change IS BOUND.
      eo_change->merge( lo_auth_change ).
    ELSE.
      eo_change = lo_auth_change.
    ENDIF.
    lo_change_cl ?= eo_change.
    prepare_notifications_f_export( lo_change_cl ).
    notify_association_changes_cu( eo_change ).
    notify_property_changes( eo_change ).
    lo_change_cl->delete_duplicate_notifications( ).

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_authority.

    DATA lt_key TYPE /bobf/t_frw_key.
    lt_key = it_key.

    CLEAR et_failed_key.
    CLEAR eo_message.

    CALL METHOD mo_authority_handler->check_authority
      EXPORTING
        io_bopf          = me
        io_buffer        = mo_buffer
        io_change        = /bobf/cl_frw_factory=>get_change( )
        is_ctx           = is_ctx
        iv_cleanse_keys  = abap_false
        iv_last_state    = /bobf/if_conf_c=>sc_state_before_modification
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = et_failed_key
      CHANGING
        co_message       = eo_message
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_authority_statically.

    mo_authority_handler->check_authority_statically(
      EXPORTING
        is_ctx     = is_ctx
      IMPORTING
        eo_message = eo_message
        ev_failed  = ev_failed
    ).

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_before_save.
    DATA: lt_node        TYPE /bobf/t_frw_node,
          ls_node        TYPE /bobf/s_frw_node,
          lt_failed_key  TYPE /bobf/t_frw_key,
          lt_root_key    TYPE /bobf/t_frw_key,
          lt_tmp_key     TYPE /bobf/t_frw_key,
          lt_key         TYPE /bobf/t_frw_key,
          ls_key         TYPE /bobf/s_frw_key,
          ls_change_mode TYPE /bobf/s_confro_chg_mode,
          lv_rejected    TYPE boole_d,
          lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
          lo_message     TYPE REF TO /bobf/if_frw_message,
          lo_change_save TYPE REF TO /bobf/if_frw_change,
          lt_group       TYPE /bobf/t_frw_group,
          lt_validation  TYPE /bobf/t_frw_key,
          lt_failed_val  TYPE /bobf/t_frw_validations,
          lx_root        TYPE REF TO cx_root.


    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    CLEAR: eo_message,
           ev_rejected,
           et_failed_node.

    mv_no_determinations = abap_true.

    lo_change_save = get_change_save( it_root_key ).

* ____________________________________________________________________ *
* check if there is really something to do
    CHECK lo_change_save IS BOUND.
    CHECK lo_change_save->has_changes( ) = abap_true.

* ____________________________________________________________________ *
* get_list of changed objects
    IF it_root_key IS INITIAL.
      TRY.
          mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys(
              EXPORTING io_read     = mo_delegation_read
              IMPORTING et_root_key = lt_tmp_key ).
            APPEND LINES OF lt_tmp_key TO lt_root_key.
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      lt_root_key = it_root_key.
*   WORKAOUND for CSN 0120061532 0001550573 2008: Call GET_ROOT_KEYS of delegation to make sure internal caches are filled.
      TRY.
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys(
              EXPORTING io_read     = mo_delegation_read
              IMPORTING et_root_key = lt_tmp_key ).
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.
    SORT lt_root_key BY key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* check delegated objects
    TRY.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->check_before_save(
            EXPORTING
              it_root_key     = lt_root_key
            IMPORTING
              eo_message      = lo_message
              ev_rejected     = lv_rejected ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF lv_rejected = abap_true.
            ASSERT ID /bobf/frw_warning CONDITION 0 = 1.   "#EC BOOL_OK
            ev_rejected = abap_true.
          ENDIF.
        ENDLOOP.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

* ____________________________________________________________________ *
* check host object
    ls_change_mode-create = abap_true.
    ls_change_mode-update = abap_true.
    lo_change_save->get_changes(
      EXPORTING is_change_mode  = ls_change_mode
      IMPORTING et_changed_node = lt_node ).

    LOOP AT lt_node INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.

      AT END OF node.
        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.
        IF mo_conf->ms_last_node-node_type <> /bobf/if_conf_c=>sc_node_type_normal OR
           mo_conf->ms_last_node-transient = abap_true OR
           mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
          CLEAR lt_key.
          CONTINUE.
        ENDIF.

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_set(
               it_key_set = lt_key ) = abap_true.

        check_action(
          EXPORTING
            iv_node_key         = ls_node-node
            iv_act_cat          = /bobf/if_conf_c=>sc_action_save
            iv_check_property   = abap_false
            iv_check_validation = abap_true
          IMPORTING
            eo_message          = lo_message
            et_failed_key       = lt_failed_key
          CHANGING
            ct_key              = lt_key  ).

        ASSERT ID /bobf/frw CONDITION
           /bobf/cl_tool_assert=>is_key_subset_stack_check(
               it_key_subset = lt_failed_key ) = abap_true.

        CLEAR lt_key.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF lt_failed_key IS NOT INITIAL.
          ASSERT ID /bobf/frw_warning CONDITION 0 = 1.     "#EC BOOL_OK
          ev_rejected = abap_true.
        ENDIF.
      ENDAT.
    ENDLOOP.

* ____________________________________________________________________ *
* check consistency groups without status assignment
    get_relevant_groups(
      EXPORTING
        iv_processing_mode = /bobf/if_frw_c=>sc_mode_check_before_save
        iv_state_before    = /bobf/if_conf_c=>sc_state_database
        io_change          = lo_change_save
      IMPORTING
        et_group_no_status = lt_group
        et_validations     = lt_validation
        eo_message         = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF lt_group IS NOT INITIAL.
      IF mo_conf->ms_obj-smart_validations = abap_false.
        " add check trigger, otherwise validations only triggered on check are not called
        add_trigger_condition( it_group   = lt_group
                               io_change  = lo_change_save ).
      ENDIF.

      do_validate(
        EXPORTING
          iv_last_state_db           = abap_true
          it_validation              = lt_validation
          iv_only_given_validations  = abap_true
          iv_consistency             = abap_false " set lifetime to state messages
          io_change                  = lo_change_save
          iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check_before_save
        IMPORTING
          eo_message                 = lo_message
          et_failed_val              = lt_failed_val ).

      add_messages(
        EXPORTING
          io_change  = lo_change_save
        CHANGING
          co_message = eo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      CAST /bobf/cl_frw_change( lo_change_save )->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_check ).

      IF lt_failed_val IS NOT INITIAL.

        IF et_failed_node IS SUPPLIED.
          mo_conf->get_validation( IMPORTING et_val_list = DATA(lt_val_list) ).

          LOOP AT lt_failed_val ASSIGNING FIELD-SYMBOL(<ls_failed_val>) GROUP BY ( val_key = <ls_failed_val>-val_key ) INTO DATA(ls_group_val_key).

            DATA(lv_node_key) = lt_val_list[ val_key = ls_group_val_key-val_key ]-node_key.

            DATA(lt_failed_node) = VALUE /bobf/t_frw_node( FOR frw_key IN GROUP ls_group_val_key ( node = lv_node_key
                                                                                                   key  = frw_key-key ) ).
            INSERT LINES OF lt_failed_node INTO TABLE et_failed_node.

          ENDLOOP.

          DELETE ADJACENT DUPLICATES FROM et_failed_node.
        ENDIF.

        ASSERT ID /bobf/frw_warning CONDITION 0 = 1.       "#EC BOOL_OK
        ev_rejected = abap_true.
      ENDIF.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~check_consistency.

* consistency check

    DATA: lo_message                TYPE REF TO /bobf/if_frw_message,
          lo_delegation             TYPE REF TO /bobf/if_frw_delegation,
          ls_nodeconf               TYPE /bobf/s_confro_node,
          ls_group                  TYPE /bobf/s_confro_group,
          lt_delegated_nodes        TYPE /bobf/t_frw_node,
          lt_host_nodes             TYPE /bobf/t_frw_node,
          ls_node                   TYPE /bobf/s_frw_node,
          lt_key                    TYPE /bobf/t_frw_key,
          lt_validations            TYPE /bobf/t_frw_key,
          ls_key                    TYPE /bobf/s_frw_key,
          lo_change                 TYPE REF TO /bobf/cl_frw_change,
          lv_only_given_validations TYPE boole_d,
          lx_root                   TYPE REF TO cx_root,
          lt_auth_key               TYPE /bobf/t_frw_key,
          lo_auth_message_dummy     TYPE REF TO /bobf/if_frw_message,
          lo_auth_change            TYPE REF TO /bobf/if_frw_change.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message, et_inconsistent_key.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

* ____________________________________________________________________ *
* check authorization (ignore IV_CHECK_SCOPE!)
    lt_auth_key = it_key.
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-check
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-check_consistency
                                    bo_service          = space
                                    node_key            = iv_node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_auth_key
        co_message       = lo_auth_message_dummy
    ).

* ____________________________________________________________________ *
* check for complete delegation
    IF mo_conf->ms_last_node-node_key = iv_node_key.
      ls_nodeconf = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
         EXPORTING iv_node_key = iv_node_key
         IMPORTING es_node     = ls_nodeconf ).
    ENDIF.

    IF ls_nodeconf-delegation_class IS NOT INITIAL.
      TRY.
          lo_delegation = get_delegation( iv_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->check_consistency(
            EXPORTING
              iv_node_key    = iv_node_key
              it_key         = lt_auth_key
              iv_check_scope = iv_check_scope
            IMPORTING
              eo_message     = eo_message ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      ASSERT ID /bobf/frw_error CONDITION
         /bobf/cl_tool_assert=>access_stack_stack_check(
             it_access_stack = mt_access_stack ) = abap_true.

      RETURN.
    ENDIF.

* ____________________________________________________________________ *
* determine objects to check

    lo_change = NEW #( ).

    CASE iv_check_scope.
      WHEN: /bobf/if_frw_c=>sc_scope_substructure.

        if can_accelerate_check( iv_node_key = iv_node_key  it_key = lt_auth_key ).
          add_opcode_trigger_to_change( it_check_key = lt_auth_key
                                        io_change    = lo_change ).
        ENDIF.
        " Accelerate GET_SUBNODES for Draft BOs by utilizing IV_RETURN_ONLY_CHECK_TRIGGER=X. Due to CT_DELEGATION_ROOT_NODE Classic BOs are too risky (at least for me)...
        get_subnodes(
          EXPORTING
            iv_node_key                   = iv_node_key
            it_key                        = lt_auth_key
            iv_stop_at_delegation_subtree = abap_true
            iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_nodes
            iv_return_only_check_trigger  = xsdbool( mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft )
          IMPORTING
            eo_message                    = lo_message
          CHANGING
            ct_host_node                  = lt_host_nodes
            ct_delegation_root_node       = lt_delegated_nodes ).
        LOOP AT lt_host_nodes INTO ls_node.
          lo_change->add_change(
             iv_change_mode = /bobf/if_frw_c=>sc_modify_check
             iv_node_key    = ls_node-node
             iv_key         = ls_node-key ).
        ENDLOOP.

      WHEN: /bobf/if_frw_c=>sc_scope_local.
        lo_change->add_change(
           iv_change_mode = /bobf/if_frw_c=>sc_modify_check
           iv_node_key    = iv_node_key
           it_key         = lt_auth_key ).

      WHEN OTHERS.
*     unknown scope
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK

        ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>access_stack_stack_check(
               it_access_stack = mt_access_stack ) = abap_true.

        RETURN.
    ENDCASE.

* ____________________________________________________________________ *
* call consistency check for delegated nodes within subtree
    TRY.
        LOOP AT lt_delegated_nodes INTO ls_node.
          ls_key-key = ls_node-key.
          APPEND ls_key TO lt_key.
          AT END OF node.
            mo_conf->get_node(
              EXPORTING iv_node_key = ls_node-node
              IMPORTING es_node     = ls_nodeconf ).

            lo_delegation = get_delegation( ls_node-node ).
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            lo_delegation->check_consistency(
                EXPORTING
                  iv_node_key    = ls_node-node
                  it_key         = lt_key
                  iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure
                IMPORTING
                  eo_message     = lo_message ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            CLEAR lt_key.
          ENDAT.
        ENDLOOP.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

* ____________________________________________________________________ *
* call consistency check for own nodes
    IF iv_check_group IS NOT INITIAL.
      mo_conf->get_group(
        EXPORTING
          iv_group_key = iv_check_group
        IMPORTING
          es_group     = ls_group ).
      IF ls_group-val_keys IS BOUND.
        lt_validations = ls_group-val_keys->*.
      ENDIF.
      lv_only_given_validations = abap_true.
    ENDIF.

    do_validate(
      EXPORTING
        iv_check_group_key         = iv_check_group
        it_validation              = lt_validations
        iv_perform_check_delta     = abap_false
        iv_only_given_validations  = lv_only_given_validations
        io_change                  = lo_change
        iv_last_state_db           = abap_true
        iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check
      IMPORTING
        eo_message                 = lo_message
        et_failed_val              = DATA(lt_failed_val) ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF iv_fill_inconsistent_key = abap_true.
      TRY.
          evaluate_failed_validate_keys( EXPORTING
                                          iv_node_key         = iv_node_key
                                          it_key              = it_key
                                          it_failed_val       = lt_failed_val
                                         IMPORTING
                                          et_inconsistent_key = et_inconsistent_key ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

* ____________________________________________________________________ *
* collect messages from validation message node
    add_messages(
      EXPORTING
        io_change  = lo_change
      CHANGING
        co_message = eo_message ).

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~compare.

    DATA lo_int_access TYPE REF TO /bobf/cl_frw_int_access.

    BREAK-POINT ID /bobf/frw.

    CLEAR eo_change.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf            =  me
        io_conf            =  mo_conf
        io_buffer          =  mo_buffer
        io_change          =  eo_change
      RECEIVING
        eo_internal_access = lo_int_access
    ).

    lo_int_access->set_context( iv_read_allowed = abap_true ).
    lo_int_access->set_last_state( iv_last_state = iv_last_state ).
    lo_int_access->set_current_state( iv_current_state = iv_current_state ).

*  DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

    lo_int_access->/bobf/if_frw_read~compare(
      EXPORTING
        iv_node_key        = iv_node_key
        it_key             = it_key
        iv_fill_attributes = iv_fill_attributes
        iv_scope           = iv_scope
      IMPORTING
         eo_change         = eo_change ).

*   /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

    lo_int_access->invalidate( ).

    ASSERT ID /bobf/frw_error CONDITION
     /bobf/cl_tool_assert=>access_stack_stack_check(
         it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~convert_altern_key.

    DATA: lv_state              TYPE /bobf/conf_state,
          lv_fill_target_key    TYPE boole_d,
          lo_message            TYPE REF TO /bobf/if_frw_message, "#EC NEEDED
          lt_auth_key           TYPE /bobf/t_frw_key,
          lt_auth_failed_key    TYPE /bobf/t_frw_key,
          lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
          lt_auth_failed_altkey TYPE REF TO data,
          lo_auth_change        TYPE REF TO /bobf/if_frw_change,
          lo_auth_change_ak1    TYPE REF TO /bobf/if_frw_change,
          lo_auth_change_ak2    TYPE REF TO /bobf/if_frw_change.

    FIELD-SYMBOLS: <ls_auth_failed_key>    TYPE /bobf/s_frw_key,
                   <lt_auth_failed_altkey> TYPE INDEX TABLE,
                   <ls_failed_key>         TYPE any,
                   <lt_key>                TYPE /bobf/t_frw_key.

    BREAK-POINT ID /bobf/frw.
    CLEAR: et_result, et_key.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    lv_fill_target_key = boolc( et_key IS REQUESTED ).
    lv_state = get_state_for_read( iv_before_image ).

    convert_altern_key(
      EXPORTING
        iv_node_key                = iv_node_key
        iv_altkey_key              = iv_altkey_key
        iv_target_altkey_key       = iv_target_altkey_key
        it_key                     = it_key
        iv_check_existence         = iv_check_existence
        iv_state                   = lv_state
        iv_invalidate_cache        = iv_invalidate_cache
        iv_fill_target_key         = lv_fill_target_key
        iv_buffer_sufficient_hint  = iv_buffer_sufficient_hint
      IMPORTING
        eo_message                 = lo_message
        eo_change                  = eo_change
        et_result                  = et_result
        et_key                     = et_key ).

    collect_messages(
      EXPORTING
        io_message = lo_message
      CHANGING
        co_message = eo_message
    ).

* ____________________________________________________________________
* check authorization as _after burner_
    IF mo_authority_handler->is_authority_check_expected( iv_node_key ) = abap_true.
      IF mo_conf->ms_last_node-node_key <> iv_node_key.
        mo_conf->get_node( EXPORTING iv_node_key = iv_node_key ).
      ENDIF.
      " authority checking for key->key/altkey (non-delegated) and key/altkey->key/altkey (delegated)
      " requests is missing. authority checking for altkey->altkey/key (non-delegated) requests was
      " already processed in a performant way in previous CONVERT_ALTERN_KEY call...
      IF iv_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key
        OR mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
        IF iv_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key.
          lt_auth_key = it_key.
        ELSEIF iv_target_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key.
          lt_auth_key = et_key.
        ELSE.
          " altkey -> altkey is requested: for auth check need to determine keys first
          convert_altern_key(
            EXPORTING
              iv_node_key               = iv_node_key
              iv_altkey_key             = iv_altkey_key
              iv_target_altkey_key      = /bobf/if_frw_c=>sc_alternative_key_key
              it_key                    = it_key
              iv_check_existence        = iv_check_existence
              iv_state                  = lv_state
              iv_invalidate_cache       = iv_invalidate_cache
              iv_buffer_sufficient_hint = iv_buffer_sufficient_hint
              iv_fill_target_key        = abap_true
            IMPORTING
              eo_message                = lo_message
              eo_change                 = lo_auth_change_ak1
              et_key               = lt_auth_key ).
          collect_messages(
            EXPORTING
              io_message = lo_message
            CHANGING
              co_message = eo_message
          ).

        ENDIF.
        lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
        mo_authority_handler->check_authority(
          EXPORTING
            io_change        = lo_auth_change
            is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                        activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-convert_altern_key
                                        bo_service          = space
                                        node_key            = iv_node_key )
            iv_cleanse_keys  = abap_false
            io_bopf          = me
            io_buffer        = mo_buffer
            iv_last_state    = /bobf/if_conf_c=>sc_state_database
            iv_current_state = /bobf/if_conf_c=>sc_state_current
          IMPORTING
            et_failed_key    = lt_auth_failed_key
          CHANGING
            ct_access_stack  = mt_access_stack
            ct_key           = lt_auth_key
            co_message       = lo_auth_message_dummy
        ).
        " update exporting tables for result and key
        IF lt_auth_failed_key IS NOT INITIAL.
          IF et_result IS REQUESTED.
            LOOP AT lt_auth_failed_key ASSIGNING <ls_auth_failed_key>.
              DELETE et_result WHERE key = <ls_auth_failed_key>-key. "#EC CI_SORTSEQ
            ENDLOOP.
          ENDIF.
          IF lv_fill_target_key = abap_true.
            IF iv_target_altkey_key = /bobf/if_frw_c=>sc_alternative_key_key.
              IF lt_auth_failed_key IS NOT INITIAL.
                ASSIGN et_key TO <lt_key>.
                LOOP AT <lt_key> ASSIGNING FIELD-SYMBOL(<ls_key>).
                  IF line_exists( lt_auth_failed_key[ KEY key_sort  key = <ls_key>-key ] ).
                    CLEAR <ls_key>.
                  ENDIF.
                ENDLOOP.
              ENDIF.
            ELSE.
              " for cleanup of ET_KEY re-conversion of failed keys -> altkeys is needed
              IF mo_conf->ms_last_altkey-altkey_key <> iv_target_altkey_key.
                mo_conf->get_altkey( iv_altkey_key = iv_target_altkey_key ).
              ENDIF.
              CREATE DATA lt_auth_failed_altkey TYPE TABLE OF (mo_conf->ms_last_altkey-data_type).
              ASSIGN lt_auth_failed_altkey->* TO <lt_auth_failed_altkey>.
              convert_altern_key(
                EXPORTING
                  iv_node_key          = iv_node_key
                  iv_altkey_key        = /bobf/if_frw_c=>sc_alternative_key_key
                  iv_target_altkey_key = iv_target_altkey_key
                  it_key               = lt_auth_failed_key
                  iv_check_existence   = iv_check_existence
                  iv_state             = lv_state
                  iv_invalidate_cache  = iv_invalidate_cache
                  iv_fill_target_key   = abap_true
                IMPORTING
                  eo_message           = lo_message
                  eo_change            = lo_auth_change_ak2
                  et_key               = <lt_auth_failed_altkey> ).
              collect_messages(
                EXPORTING
                  io_message = lo_message
                CHANGING
                  co_message = eo_message
              ).

              SORT <lt_auth_failed_altkey> BY table_line.

              LOOP AT et_key ASSIGNING <ls_failed_key>.
                READ TABLE <lt_auth_failed_altkey> BINARY SEARCH WITH KEY table_line = <ls_failed_key> TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
                  CLEAR <ls_failed_key>.
                ENDIF.
              ENDLOOP.
            ENDIF.
          ENDIF.
        ENDIF.
        IF eo_change IS BOUND.
          eo_change->merge( lo_auth_change ).
        ELSE.
          eo_change = lo_auth_change.
        ENDIF.
        IF lo_auth_change_ak1 IS BOUND.
          eo_change->merge( lo_auth_change_ak1 ).
        ENDIF.
        IF lo_auth_change_ak2 IS BOUND.
          eo_change->merge( lo_auth_change_ak2 ).
        ENDIF.
      ENDIF.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~create_sync_point.

    DATA:
      ls_sync_point TYPE ty_sync_point,
      lt_key        TYPE /bobf/t_frw_key,
      lt_node       TYPE /bobf/t_frw_node,
      lo_int_access TYPE REF TO /bobf/cl_frw_int_access,
*    lt_conf_node  TYPE /bobf/t_confro_node,
*    ls_conf_node  TYPE /bobf/s_confro_node,
      lx_root       TYPE REF TO cx_root.


* check if there is already a syncpoint with the same handle
    READ TABLE mt_sync_point TRANSPORTING NO FIELDS
      WITH KEY handle = iv_handle.                       "#EC CI_STDSEQ
    IF sy-subrc = 0.
      set_application_error( ).
    ENDIF.

    IF mv_modifying_transaction = abap_true.
      mv_sync_state_index += 1.
      ls_sync_point-states_count += 1.
      ls_sync_point-state = gc_sync_state+mv_sync_state_index(1).
      ls_sync_point-handle  = iv_handle.
      ls_sync_point-state_d = ls_sync_point-state.
      ls_sync_point-state_v = ls_sync_point-state.
*    ls_sync_point-state_f = ls_sync_point-state.
      IF mt_access_stack IS NOT INITIAL.
        READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
        IF lo_int_access->mv_process_immediately_allowed = abap_true.
          lo_int_access->end_modify( iv_process_immediately = abap_true ).
          mv_sync_state_index += 1.
          ls_sync_point-states_count += 1.
          ls_sync_point-state_d = gc_sync_state+mv_sync_state_index(1).
          ls_sync_point-state_v = ls_sync_point-state_d.
        ENDIF.
      ENDIF.
*   pending determinations or validations
      IF mo_change_fail_det IS NOT INITIAL.
        ls_sync_point-change_fail_det ?= /bobf/cl_frw_factory=>get_change( ).
        ls_sync_point-change_fail_det->merge( mo_change_fail_det ).
        IF ls_sync_point-state_d = ls_sync_point-state.
          mv_sync_state_index += 1.
          ls_sync_point-states_count += 1.
          IF mo_conf->ms_obj-last_det_state_not_relevant = abap_true.
            ls_sync_point-state_v = gc_sync_state+mv_sync_state_index(1).
          ELSE.
            ls_sync_point-state_d = gc_sync_state+mv_sync_state_index(1).
          ENDIF.
        ENDIF.
      ENDIF.
      IF mo_change_fail_val IS NOT INITIAL.
        ls_sync_point-change_fail_val ?= /bobf/cl_frw_factory=>get_change( ).
        ls_sync_point-change_fail_val->merge( mo_change_fail_val ).
        mv_sync_state_index += 1.
        ls_sync_point-states_count += 1.
        ls_sync_point-state_v = gc_sync_state+mv_sync_state_index(1).
      ENDIF.

      IF mo_conf->ms_obj-last_det_state_not_relevant = abap_true.
        ls_sync_point-state_d = ls_sync_point-state_v.
      ENDIF.
      IF mo_conf->ms_obj-last_val_state_not_relevant = abap_true.
        ls_sync_point-state_d = ls_sync_point-state.
        ls_sync_point-state_v = ls_sync_point-state.
      ENDIF.
      INSERT ls_sync_point INTO mt_sync_point INDEX 1.

      TRY.
          mo_buffer->get_root_keys( EXPORTING iv_changed_only = abap_false
                                    IMPORTING et_root_key     = lt_key ).

          map_to_node( EXPORTING iv_node_key = mo_conf->ms_obj-root_node_key
                                 it_key      = lt_key
                       IMPORTING et_node     = lt_node ).

          mo_buffer->transfer_state( it_node         = lt_node
                                     iv_incl_subtree = abap_true
                                     iv_state_source = /bobf/if_conf_c=>sc_state_current
                                     iv_state_dest   = ls_sync_point-state ).

          IF ls_sync_point-state_v <> ls_sync_point-state.
            mo_buffer->transfer_state( it_node         = lt_node
                                       iv_incl_subtree = abap_true
                                       iv_state_source = /bobf/if_conf_c=>sc_state_last_validated
                                       iv_state_dest   = ls_sync_point-state_v ).
          ENDIF.

          IF ls_sync_point-state_d <> ls_sync_point-state_v.
            mo_buffer->transfer_state( it_node         = lt_node
                                       iv_incl_subtree = abap_true
                                       iv_state_source = /bobf/if_conf_c=>sc_state_last_determined
                                       iv_state_dest   = ls_sync_point-state_d ).
          ENDIF.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      ls_sync_point-handle  = iv_handle.
      ls_sync_point-state   = /bobf/if_conf_c=>sc_state_database.
      ls_sync_point-state_d = /bobf/if_conf_c=>sc_state_database.
      ls_sync_point-state_v = /bobf/if_conf_c=>sc_state_database.
      INSERT ls_sync_point INTO mt_sync_point INDEX 1.
    ENDIF.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~do_action.

    DATA: lo_change     TYPE REF TO /bobf/cl_frw_change,
          lo_change_if  TYPE REF TO /bobf/if_frw_change,
          lo_message    TYPE REF TO /bobf/if_frw_message,
          lo_int_access TYPE REF TO /bobf/cl_frw_int_access,
          lt_change     TYPE /bobf/t_frw_change.

    BREAK-POINT ID /bobf/frw.

    CLEAR: eo_change,
           eo_message,
           et_data,
           et_failed_key,
           ev_static_action_failed,
           et_data_link.

    ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>access_stack_stack_set( mt_access_stack ).

* ____________________________________________________________________ *
* external change during save sequence
    ASSERT ID /bobf/frw CONDITION mo_change_save IS NOT BOUND.

* ____________________________________________________________________ *
* execute determinations and validations that failed before
    IF mo_change_fail_det IS BOUND
    OR mo_change_fail_val IS BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
      do_detval( EXPORTING io_change                  = eo_change
                           iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_action
                 IMPORTING eo_message                 = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF mo_change_fail_det IS BOUND
      OR mo_change_fail_val IS BOUND.
        et_failed_key = is_action-key.
        lo_change ?= eo_change.
        prepare_notifications_f_export( lo_change ).
        ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>access_stack_stack_check( mt_access_stack ).
        RETURN.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* execute action
    IF mt_access_stack IS INITIAL.

      TRY.
          do_action( EXPORTING is_action               = is_action
                               iv_internal_call        = abap_false
                     IMPORTING eo_message              = lo_message
                               eo_change               = lo_change_if
                               et_failed_key           = et_failed_key
                               ev_static_action_failed = ev_static_action_failed
                               et_data                 = et_data
                               et_data_link            = et_data_link ).

        CATCH /bobf/cx_frw_int_cntrct_violtn INTO DATA(lx_int_cntrct_violtn).
          RAISE EXCEPTION /bobf/cx_frw_contrct_violation=>create_with( lx_int_cntrct_violtn ). " converts no_check to dynamic_check exception
      ENDTRY.

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = is_action-key
                                                                         it_key_subset = et_failed_key ).

      IF eo_change IS BOUND.
        eo_change->merge( lo_change_if ).
      ELSE.
        eo_change = lo_change_if.
      ENDIF.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

    ELSE.
      ASSERT ID /bobf/frw CONDITION NOT /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ).

      lo_int_access = mt_access_stack[ 1 ].
      lo_int_access->/bobf/if_frw_modify~do_action( EXPORTING iv_act_key              = is_action-act_key
                                                              it_key                  = is_action-key
                                                              is_parameters           = is_action-parameters
                                                    IMPORTING eo_message              = lo_message
                                                              et_failed_key           = et_failed_key
                                                              eo_change               = lo_change_if
                                                              ev_static_action_failed = ev_static_action_failed
                                                              et_data                 = et_data
                                                              et_data_link            = et_data_link ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = is_action-key
                                                                         it_key_subset = et_failed_key ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      "when no change object is returned, get an empty change object
      IF lo_change_if IS NOT BOUND.
        lo_change_if = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

      lo_change_if->get( IMPORTING et_change = lt_change ).
      lo_change ?= lo_int_access->mo_change.
      IF lt_change IS NOT INITIAL.
        lo_change->clear_external( lt_change ).
      ENDIF.

      IF eo_change IS BOUND.
        eo_change->merge( lo_change_if ).
      ELSE.
        eo_change = lo_change_if.
      ENDIF.

    ENDIF.

* ____________________________________________________________________ *
* add message from the consistency checks
    add_messages( EXPORTING io_change  = eo_change
                  CHANGING  co_message = eo_message ).

* ____________________________________________________________________ *
* handle changes
    IF eo_change IS BOUND.
      lo_change ?= eo_change.
      prepare_notifications_f_export( lo_change ).
      notify_association_changes_cu( lo_change ).
      notify_property_changes( eo_change ).
      lo_change->delete_duplicate_notifications( ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>access_stack_stack_check( mt_access_stack ).

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~do_cleanup.

    DATA:
      lt_root_key   TYPE        /bobf/t_frw_key,
      lt_tmp_key    TYPE        /bobf/t_frw_key,
      lo_change     TYPE REF TO /bobf/if_frw_change,
      lo_message    TYPE REF TO /bobf/if_frw_message,
      lx_root       TYPE REF TO cx_root,
      lo_delegation TYPE REF TO /bobf/if_frw_delegation.

    " breakpoints & assertions
    BREAK-POINT ID /bobf/frw.
    IF mv_application_error IS INITIAL.
      ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    ENDIF.
    ASSERT ID /bobf/frw_error CONDITION mv_application_error IS INITIAL. " see below
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

    " todo: clean also possible inconsistencies; then remove the corresponding assertion above
    CLEAR mt_access_stack.
    " CLEAR mv_application_error.  <-- as soon as ensured that clean works correctly on inconsistent state

    " clear exporting parameter
    CLEAR eo_message.

    " delegate cleanup to dependent objects and get the ROOT keys of all instances contained in the buffer so far
    IF it_root_key IS INITIAL.
      TRY.
          mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys(
              EXPORTING io_read     = mo_delegation_read
              IMPORTING et_root_key = lt_tmp_key ).
            lo_delegation->do_cleanup( it_root_key = lt_tmp_key ).
            APPEND LINES OF lt_tmp_key TO lt_root_key.
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      lt_root_key = it_root_key.
    ENDIF.
    SORT lt_root_key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key.

    " get changes done during the current transaction
    lo_change = /bobf/cl_frw_factory=>get_change( ).
    CAST /bobf/cl_frw_change( lo_change )->trace_external_changes( abap_false ).
    TRY.
        IF mv_modifying_transaction = abap_true.
          mo_buffer->compare_states( iv_node_key      = mo_conf->ms_obj-root_node_key
                                     it_key           = lt_root_key
                                     iv_state_current = /bobf/if_conf_c=>sc_state_current
                                     iv_state_before  = /bobf/if_conf_c=>sc_state_database
                                     iv_incl_subtree  = abap_true
                                     io_change        = lo_change ).
        ENDIF.
        LOOP AT mt_delegation2 INTO lo_delegation.
          lo_delegation->get_changes( it_root_key = lt_root_key
                                      io_change   = lo_change ).
        ENDLOOP.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    CAST /bobf/cl_frw_change( lo_change )->trace_external_changes( abap_true ).

    " perform determinations 'cleanup'
    do_determinations( EXPORTING iv_exectime     = /bobf/if_conf_c=>sc_time_cleanup
                                 io_change       = lo_change
                                 iv_cleanup_mode = iv_cleanup_mode
                       IMPORTING eo_message  = lo_message ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    " allow the execution of determinations in the upcoming transaction
    mv_no_determinations = abap_false.

    " unlock all instances locked in the current transaction so far
    " (evaluate the BOPF lock buffer)
    IF it_root_key IS INITIAL.
      mo_lock_manager->on_cleanup( IMPORTING eo_message    = lo_message ).
    ELSE.
      mo_lock_manager->on_cleanup( EXPORTING it_root_key   = lt_root_key
                                   IMPORTING eo_message    = lo_message ).
    ENDIF.
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    " cleanup buffer so all changes done so far in the transaction are lost
    TRY.
        IF it_root_key IS INITIAL.
          mo_buffer->do_cleanup( ).
        ELSE.
          mo_buffer->do_cleanup( it_root_key = lt_root_key ).
        ENDIF.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    " clear framework caches and S&AM
    CLEAR:
      mo_change_save,
      mo_change_fail_det,
      mo_change_fail_val,
      mt_change_save.
    IF mo_sam IS BOUND.
      mo_sam->cleanup( ).
    ENDIF.
    " start the new transaction in readmode (non-modifying)
    IF mo_conf->ms_obj-objcat <> /bobf/if_conf_c=>sc_objcat_tsto.
      mv_modifying_transaction = abap_false.
    ENDIF.
    " consumers are expected to clear their property buffers, therefore this table can be cleared too
    CLEAR mt_node_properties_requested.
    mv_defaults_exists = abap_false.
    mo_authority_handler->cleanup( ).

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    ASSERT ID /bobf/frw_error CONDITION mv_application_error IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~do_save.

    DATA: lt_root_key    TYPE /bobf/t_frw_key,
          lt_tmp_key     TYPE /bobf/t_frw_key,
          lt_failed_node TYPE /bobf/t_frw_node,
          lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
          lx_root        TYPE REF TO cx_root,
          lo_message     TYPE REF TO /bobf/if_frw_message,
          lo_change_save TYPE REF TO /bobf/if_frw_change.

    CLEAR eo_message.
    ev_rejected = abap_false.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    check_fatal_error( ).

* ____________________________________________________________________ *
* check for transient root node -> don't save
    IF mo_conf->get_root_node( )-transient = abap_true.
      RETURN.
    ENDIF.

* ____________________________________________________________________ *
* get_list of changed objects to save

    lo_change_save = get_change_save( it_root_key ).
    IF lo_change_save IS BOUND.

      IF it_root_key IS INITIAL.
        TRY.
            mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
        TRY.
            LOOP AT mt_delegation2 INTO lo_delegation.
              lo_delegation->get_root_keys( EXPORTING io_read     = mo_delegation_read
                                            IMPORTING et_root_key = lt_tmp_key ).
              APPEND LINES OF lt_tmp_key TO lt_root_key.
            ENDLOOP.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ELSE.
        lt_root_key = it_root_key.
      ENDIF.

      IF lt_root_key IS NOT INITIAL.
        SORT lt_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

* ____________________________________________________________________ *
* perform determinations (at save)
        do_determinations( EXPORTING iv_exectime = /bobf/if_conf_c=>sc_time_at_save
                                     io_change   = lo_change_save
                           IMPORTING eo_message  = eo_message
                                     et_failed   = lt_failed_node ).
        check_fatal_error( ).
        IF lt_failed_node IS NOT INITIAL.
          ASSERT ID /bobf/frw_warning CONDITION 0 = 1.     "#EC BOOL_OK
          ev_rejected = abap_true.
          RETURN.
        ENDIF.

* ____________________________________________________________________ *
* save delegated objects
        TRY.
            LOOP AT mt_delegation2 INTO lo_delegation.
              lo_delegation->do_save( EXPORTING it_root_key = lt_root_key
                                      IMPORTING eo_message  = lo_message
                                                ev_rejected = ev_rejected ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
              IF ev_rejected = abap_true.
                ASSERT ID /bobf/frw_warning CONDITION 0 = 1. "#EC BOOL_OK
                RETURN.
              ENDIF.
            ENDLOOP.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

* ____________________________________________________________________ *
* save buffer
        TRY.
            mo_buffer->do_save( it_root_key           = lt_root_key
                                iv_state_current      = /bobf/if_conf_c=>sc_state_current
                                iv_state_before_image = /bobf/if_conf_c=>sc_state_database ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
        check_fatal_error( ).
        ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
      ENDIF.

    ENDIF.

    " Internal incident https://support.wdf.sap.corp/sap/support/message/1770067339
    " Even if lt_root_key is initial, there can be draft instances which have neither a before image nor a current image.
    " (e.g. Create and Delete within the same session)
    " In this case, the durable lock manager needs to check whether there are such instances and if there are, those
    " enqueue contexts will be removed.
    IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft.
      TRY.
          " In addition to the house keeping of enqueue contexts, this also saves the draft admin entries:
          /bobf/cl_lib_durable_lock_mngr=>during_save( io_configuration = mo_conf
                                                       io_buffer        = mo_buffer ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~finalize.

    DATA: lt_root_key_all TYPE /bobf/t_frw_key,
          lt_failed_node  TYPE /bobf/t_frw_node,
          lt_group_2_way  TYPE /bobf/t_frw_group,
          lt_group_3_way  TYPE /bobf/t_frw_group,
          lt_validation   TYPE /bobf/t_frw_key,
          lt_failed_val   TYPE /bobf/t_frw_validations,
          lv_rejected     TYPE boole_d,
          lo_delegation   TYPE REF TO /bobf/if_frw_delegation,
          lo_message      TYPE REF TO /bobf/if_frw_message,
          lx_root         TYPE REF TO cx_root.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           eo_change,
           ev_rejected.


* ____________________________________________________________________ *
* execute determinations and validations that failed before
    IF mo_change_fail_det IS BOUND
    OR mo_change_fail_val IS BOUND.
      DATA(lo_change_failed_det_val) = /bobf/cl_frw_factory=>get_change( ).
      do_detval( EXPORTING io_change                  = lo_change_failed_det_val
                           iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_finalize
                 IMPORTING eo_message                 = eo_message ).

      IF mo_change_fail_det IS BOUND
      OR mo_change_fail_val IS BOUND.
        ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.         "#EC BOOL_OK
        ev_rejected = abap_true.
        prepare_notifications_f_export( CAST /bobf/cl_frw_change( lo_change_failed_det_val ) ).
        eo_change = lo_change_failed_det_val.
        RETURN.
      ELSE.
*     prepare local change object for further use
        CAST /bobf/cl_frw_change( lo_change_failed_det_val )->clear_external( ).
      ENDIF.
    ENDIF.

    DATA(lo_change_save) = create_change_save( EXPORTING it_root_key     = it_root_key "contains all BO changes of current transaction
                                               IMPORTING et_root_key_all = lt_root_key_all ).

    IF lo_change_save->has_changes( ) = abap_true.

      IF NOT ( mo_conf->ms_obj-smart_validations = abap_true AND /bobf/cl_tra_transaction_mgr=>is_session_stateless( ) ).

*   determinations at finalize - before consistency check
        IF mo_conf->ms_obj-has_consistency_groups <> /bobf/if_frw_c=>sc_group_none.
          do_determinations(
            EXPORTING
              iv_exectime = /bobf/if_conf_c=>sc_time_before_save_check
              io_change   = lo_change_save
            IMPORTING
              eo_message  = lo_message
              et_failed   = lt_failed_node ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF lt_failed_node IS NOT INITIAL.
            ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.     "#EC BOOL_OK
            ev_rejected = abap_true.
          ENDIF.
        ENDIF.

*   Check for consistency groups
        get_relevant_groups(
         EXPORTING
           iv_processing_mode = /bobf/if_frw_c=>sc_mode_finalize
           iv_state_before    = /bobf/if_conf_c=>sc_state_database
           io_change          = lo_change_save
         IMPORTING
           et_group_2_way     = lt_group_2_way
           et_group_3_way     = lt_group_3_way
           et_validations     = lt_validation
           eo_message         = lo_message ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        filter_consistency_groups(
          CHANGING
            ct_group = lt_group_3_way ).

        IF lt_group_2_way IS NOT INITIAL OR
           lt_group_3_way IS NOT INITIAL.

          INSERT LINES OF lt_group_2_way INTO TABLE lt_group_3_way.
          add_trigger_condition( it_group   = lt_group_3_way
                                 io_change  = lo_change_save ).

          do_validate(
            EXPORTING
              iv_last_state_db           = abap_true
              io_change                  = lo_change_save
              it_validation              = lt_validation
              iv_only_given_validations  = abap_true
              iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_finalize
            IMPORTING
              eo_message                 = lo_message
              et_failed_val              = lt_failed_val ).

*     merge consistency message from message nodes
          add_messages( EXPORTING io_change  = lo_change_save
                        CHANGING  co_message = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          derive_consistency_status(
            EXPORTING
              it_failed_val = lt_failed_val
            IMPORTING
              eo_message    = lo_message
            CHANGING
              ct_group      = lt_group_3_way ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          set_consistency_status(
            EXPORTING
              it_group   = lt_group_3_way
              io_change  = lo_change_save
            IMPORTING
              eo_message = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          CAST /bobf/cl_frw_change( lo_change_save )->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_check ).
        ENDIF.
      ENDIF.
      IF ev_rejected = abap_false.
* ____________________________________________________________________ *
*   finalize delegated objects - after consistency check
        TRY.
            LOOP AT mt_delegation2 INTO lo_delegation.
              lo_delegation->finalize(
                EXPORTING
                  it_root_key = lt_root_key_all
                  io_change   = lo_change_save
                IMPORTING
                  eo_message  = lo_message
                  ev_rejected = lv_rejected ).

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              IF lv_rejected = abap_true.
                ASSERT ID /bobf/frw_warning CONDITION 0 = 1. "#EC BOOL_OK
                ev_rejected = lv_rejected.
              ENDIF.
            ENDLOOP.

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

*____________________________________________________________________ *
*   finalize host object -> perform determinations (finalize)
        do_determinations(
          EXPORTING
            iv_exectime = /bobf/if_conf_c=>sc_time_before_save
            io_change   = lo_change_save
          IMPORTING
            eo_message  = lo_message
            et_failed   = lt_failed_node ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF lt_failed_node IS NOT INITIAL.
          ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.       "#EC BOOL_OK
          ev_rejected = abap_true.
        ENDIF.

* ____________________________________________________________________ *
*   finalize delegated objects (again)
        TRY.
            LOOP AT mt_delegation2 INTO lo_delegation.
              lo_delegation->get_root_keys(
                EXPORTING io_read     = mo_delegation_read
                IMPORTING et_root_key = DATA(lt_root_key_delegation) ).
              lo_delegation->finalize(
                EXPORTING
                  it_root_key = lt_root_key_delegation
                  io_change   = lo_change_save
                IMPORTING
                  eo_message  = lo_message
                  ev_rejected = lv_rejected ).

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              IF lv_rejected = abap_true.
                ASSERT ID /bobf/frw_warning CONDITION 0 = 1. "#EC BOOL_OK
                ev_rejected = lv_rejected.
              ENDIF.
            ENDLOOP.

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* create change object for external world
    eo_change = /bobf/cl_frw_factory=>get_change( ).
    eo_change->merge( lo_change_save ).
    notify_association_changes_cu( eo_change ).
    prepare_notifications_f_export( CAST /bobf/cl_frw_change( eo_change ) ).
    notify_property_changes( eo_change ).
    CAST /bobf/cl_frw_change( eo_change )->delete_duplicate_notifications( ).

* Prepare local change object for further use in SAVE sequence.
* Note that lo_change_save points to the same instance as a member variable
* which is returned by get_change_save(). So, the visibility of LO_CHANGE_SAVE
* is NOT limited to this method.
    CAST /bobf/cl_frw_change( lo_change_save )->clear_external( ).
    CAST /bobf/cl_frw_change( lo_change_save )->condense( ).

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~get_auth_profile_reader.
    ro_auth_profile_reader = mo_authority_handler->get_auth_profile_reader( iv_bo_key   = iv_bo_key
                                                                            iv_node_key = iv_node_key ).
  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~get_root_key.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    IF it_key IS INITIAL.
      CLEAR: et_key_link,
             et_failed_key,
             et_target_key.
      RETURN.
    ENDIF.

    get_root_key(
      EXPORTING
        iv_node_key         = iv_node_key
        it_key              = it_key
        iv_before_image     = iv_before_image
      IMPORTING
        et_key_link         = et_key_link
        et_failed_key       = et_failed_key
        et_target_key       = et_target_key ).

    ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = it_key
            it_key_subset = et_failed_key ) = abap_true.
    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>is_key_link_matching(
           it_key_link = et_key_link
           it_key      = it_key ) = abap_true.
    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~modify.

    DATA: lo_change              TYPE REF TO /bobf/cl_frw_change,
          lo_int_access          TYPE REF TO /bobf/cl_frw_int_access,
          lt_change              TYPE /bobf/t_frw_change,
          lv_process_immediately TYPE boole_d.


    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_change, eo_message.

    CHECK it_modification IS NOT INITIAL.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

* ____________________________________________________________________ *
* external change during save sequence
    ASSERT ID /bobf/frw CONDITION mo_change_save IS NOT BOUND.

* ____________________________________________________________________ *
* perform modifications
    IF mt_access_stack IS INITIAL.
      TRY.
          do_modify(
            EXPORTING
              it_modification   = it_modification
            IMPORTING
              eo_message        = eo_message
              eo_change         = eo_change ).
        CATCH /bobf/cx_frw_int_cntrct_violtn INTO DATA(lx_int_cntrct_violtn).
          RAISE EXCEPTION /bobf/cx_frw_contrct_violation=>create_with( lx_int_cntrct_violtn ). " converts no_check to dynamic_check exception
      ENDTRY.
    ELSE.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
      lo_int_access->end_modify( ).
      lo_int_access->/bobf/if_frw_modify~do_modify( it_modification = it_modification ).
      lv_process_immediately = abap_false.
      IF lo_int_access->mv_process_immediately_allowed = abap_true.
        IF mo_conf->ms_last_action-act_key <> lo_int_access->ms_action-act_key.
          mo_conf->get_act( iv_act_key = lo_int_access->ms_action-act_key ).
        ENDIF.
        IF mo_conf->ms_last_action-act_cardinality = /bobf/if_conf_c=>sc_act_card_static.
          lv_process_immediately = abap_true.
        ENDIF.
      ENDIF.

      lo_int_access->end_modify(
          EXPORTING
            iv_process_immediately = lv_process_immediately
          IMPORTING
            eo_change              = eo_change ).
      IF eo_change IS BOUND.
        eo_change->get( IMPORTING et_change = lt_change ).
        IF lt_change IS NOT INITIAL.
          lo_change ?= lo_int_access->mo_change.
          lo_change->clear_external( lt_change ).
        ENDIF.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* add message from the consistency checks
    add_messages(
      EXPORTING
        io_change  = eo_change
      CHANGING
        co_message = eo_message ).

* ____________________________________________________________________ *
* add property changes and association changes
    IF eo_change IS BOUND.
      lo_change ?= eo_change.
      prepare_notifications_f_export( lo_change ).
      notify_association_changes_cu( lo_change ).
      notify_property_changes( eo_change ).
      lo_change->delete_duplicate_notifications( ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~on_business_object_changed.

    DATA:
      ls_actconf    TYPE /bobf/s_confro_act_list,
      ls_action     TYPE /bobf/s_frw_action,
      lt_failed_key TYPE /bobf/t_frw_key,
      lo_change     TYPE REF TO /bobf/cl_frw_change.


    CLEAR:
      eo_message,
      eo_change.

* ____________________________________________________________________ *
* find action for event handling
    mo_conf->get_act(
      EXPORTING
        iv_node_key = iv_node_key
        iv_act_cat  = /bobf/if_conf_c=>sc_action_handle_bo_events
      IMPORTING
        es_action = ls_actconf ).
    IF ls_actconf IS INITIAL.
      ASSERT ID /bobf/frw_error CONDITION 0 = 1.           "#EC BOOL_OK
      RETURN.
    ENDIF.

    ls_action-act_key    = ls_actconf-act_key.
    ls_action-parameters = is_bo_changes.

    /bobf/if_frw_service_layer~do_action(
      EXPORTING
        is_action     = ls_action
      IMPORTING
        eo_change     = eo_change
        eo_message    = eo_message
        et_failed_key = lt_failed_key ).

    IF lt_failed_key IS NOT INITIAL.
      ASSERT ID /bobf/frw_error CONDITION 0 = 1.           "#EC BOOL_OK
      set_application_error( ).
    ENDIF.

*  ____________________________________________________________________ *
*  handle changes
    IF eo_change IS BOUND.
      lo_change ?= eo_change.
      prepare_notifications_f_export( lo_change ).
      notify_association_changes_cu( eo_change ).
      notify_property_changes( eo_change ).
      lo_change->delete_duplicate_notifications( ).
    ENDIF.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~on_numbers_adjusted.

    DATA: ls_actconf    TYPE /bobf/s_confro_act_list,
          ls_action     TYPE /bobf/s_frw_action,
          lt_root_key   TYPE /bobf/t_frw_key,
          lt_tmp_key    TYPE /bobf/t_frw_key,
          lt_failed_key TYPE /bobf/t_frw_key,
          lo_delegation TYPE REF TO /bobf/if_frw_delegation,
          lo_change     TYPE REF TO /bobf/cl_frw_change,
          lx_root       TYPE REF TO cx_root.

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

    CLEAR: eo_change, eo_message, eo_change.

* ____________________________________________________________________ *
* get_list of changed objects to adopt foreign numbers
    IF it_root_key IS INITIAL.
      TRY.
          mo_buffer->get_root_keys( IMPORTING et_root_key = lt_root_key ).
          LOOP AT mt_delegation2 INTO lo_delegation.
            lo_delegation->get_root_keys(
              EXPORTING io_read     = mo_delegation_read
              IMPORTING et_root_key = lt_tmp_key ).
            APPEND LINES OF lt_tmp_key TO lt_root_key.
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      lt_root_key = it_root_key.
    ENDIF.

    CHECK lt_root_key IS NOT INITIAL.
    SORT lt_root_key BY key.
    DELETE ADJACENT DUPLICATES FROM lt_root_key COMPARING key.

    DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ). "SAVE-sequence should run without auth checks
    TRY.
* ____________________________________________________________________ *
* adopt foreign numbers
        mo_conf->get_act(
          EXPORTING
            iv_node_key = mo_conf->ms_obj-root_node_key
            iv_act_cat  = /bobf/if_conf_c=>sc_action_adopt_numbers
          IMPORTING
            es_action = ls_actconf ).
        IF ls_actconf IS NOT INITIAL.
          ls_action-act_key = ls_actconf-act_key.
          ls_action-key     = lt_root_key.

          IF is_param IS SUPPLIED.
            " use the IS_PARAM parameter (filled by the Service Manager)
            ls_action-parameters = is_param.
          ELSE.
            " use the IT_ADJUSTED_NUMBERS parameter
            GET REFERENCE OF it_adjusted_numbers INTO ls_action-parameters.
          ENDIF.

          do_action(
            EXPORTING
              is_action        = ls_action
              iv_with_detval   = abap_false
              iv_internal_call = abap_true
            IMPORTING
              eo_message       = eo_message
              eo_change        = eo_change
              et_failed_key    = lt_failed_key ).

          IF lt_failed_key IS NOT INITIAL.
            ASSERT ID /bobf/frw_error CONDITION 0 = 1.     "#EC BOOL_OK
            set_application_error( ).
          ENDIF.
        ENDIF.

* ____________________________________________________________________ *
* adopt foreign numbers for delegated objects
        TRY.
            LOOP AT mt_delegation2 INTO lo_delegation.
              lo_delegation->on_numbers_adjusted(
                EXPORTING
                  it_root_key         = lt_root_key
                  it_adjusted_numbers = it_adjusted_numbers ).
            ENDLOOP.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

      CLEANUP.
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
    ENDTRY.
    /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

* ____________________________________________________________________ *
* handle changes
    IF eo_change IS BOUND.
      lo_change ?= eo_change.
      prepare_notifications_f_export( lo_change ).
      notify_association_changes_cu( eo_change ).
      notify_property_changes( eo_change ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION mt_access_stack IS INITIAL.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~query.

    DATA: ls_query            TYPE        /bobf/s_confro_query,
          ls_query_class      TYPE        ty_query,
          lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
          ls_context          TYPE        /bobf/s_frw_ctx_query,
          lv_content_cat      TYPE        string,
          lv_content_name     TYPE        /bobf/obm_name,
          lx_frw              TYPE REF TO /bobf/cx_frw_core,
          lx_root             TYPE REF TO cx_root,
          lv_application_info TYPE        string,
          lo_change           TYPE REF TO /bobf/if_frw_change.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           es_query_info,
           et_key,
           et_data.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    IF mt_access_stack IS INITIAL.
      mo_conf->get_query(
        EXPORTING iv_query_key = iv_query_key
        IMPORTING es_query     = ls_query ).

      TRY.
          IF ls_query-query_class IS INITIAL.
*         ask buffer
            TRY.
                mo_buffer->query(
                  EXPORTING
                    iv_node_key              = ls_query-node_key
                    iv_query_key             = iv_query_key
                    it_filter_key            = it_filter_key
                    it_selection_parameters  = it_selection_parameters
                    io_query_authorities     = io_query_authorities
                    is_query_options         = is_query_options
                  IMPORTING
                    et_key                  = et_key
                    es_query_info           = es_query_info ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

          ELSE.
*         call query implementation
            ls_context-bo_key                = mo_conf->ms_obj-bo_key.
            ls_context-root_node_key         = mo_conf->ms_obj-root_node_key.
            ls_context-node_key              = ls_query-node_key.
            ls_context-query_key             = iv_query_key.

*         get query class
            READ TABLE mt_query
               WITH TABLE KEY query_key = ls_query-query_key
               INTO ls_query_class.
            IF sy-subrc <> 0.
              ls_query_class-query_key = ls_query-query_key.
              CREATE OBJECT ls_query_class-class TYPE (ls_query-query_class).
              INSERT ls_query_class INTO TABLE mt_query.
            ENDIF.

*         get internal access class
            lo_change = /bobf/cl_frw_factory=>get_change( ).

            /bobf/cl_frw_int_access=>new_instance(
              EXPORTING
                io_bopf            = me
                io_conf            = mo_conf
                io_buffer          = mo_buffer
                io_change          = lo_change
                iv_class_name      = /bobf/cl_frw_int_access_trans=>gc_class_name
              RECEIVING
                eo_internal_access = lo_int_access
            ).

            lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).
            lo_int_access->set_context(
              is_query          = ls_context
              iv_read_allowed   = abap_true
              iv_modify_allowed = abap_true ).

            lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_read_only ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_query_class-class->query( EXPORTING is_ctx                  = ls_context
                                                   it_filter_key           = it_filter_key
                                                   it_selection_parameters = it_selection_parameters
                                                   io_query_authorities    = io_query_authorities
                                                   is_query_options        = is_query_options
                                                   io_query                = lo_int_access
                                                   io_read                 = lo_int_access
                                                   io_modify               = lo_int_access
                                                   iv_fill_data            = iv_fill_data
                                                   it_requested_attributes = it_requested_attributes
                                         IMPORTING et_key                  = et_key
                                                   eo_message              = eo_message
                                                   es_query_info           = es_query_info
                                                   et_data                 = et_data ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

*         check for undone modifications and flush
            IF lo_int_access->mt_modification IS NOT INITIAL.
              lo_int_access->end_modify( ).
            ENDIF.
            collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                              CHANGING  co_message = eo_message ).
            lo_int_access->invalidate( ).

            DELETE mt_access_stack INDEX 1.
          ENDIF.

        CATCH cx_sy_dyn_call_error INTO lx_root.
          lv_content_name = lcl_error_provider=>get_content_name( io_configuration = mo_conf
                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_qry
                                                                  iv_content_key   = iv_query_key ).
          lv_content_cat = TEXT-005.
          CREATE OBJECT lx_frw
            EXPORTING
              textid                     = /bobf/cx_frw_core=>sc_no_instance
              previous                   = lx_root
              mv_method_name             = 'QUERY'
              mv_content_name            = lv_content_name
              mv_content_cat             = lv_content_cat
              mv_application_information = lv_application_info.
          set_configuration_error( lx_frw ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                              iv_content_cat   = /bobf/if_conf_c=>sc_content_qry
                                                                              iv_content_key   = ls_context-query_key
                                                                              iv_content_class = ls_query-query_class
                                                                              iv_node_key      = ls_context-node_key
                                                                              io_configuration = mo_conf
                                                                              iv_method_name   = 'QUERY' ) ).
      ENDTRY.


    ELSE.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
      ls_context-bo_key                = mo_conf->ms_obj-bo_key.
      ls_context-root_node_key         = mo_conf->ms_obj-root_node_key.
      ls_context-node_key              = ls_query-node_key.
      ls_context-query_key             = iv_query_key.

      TRY.
          lo_int_access->/bobf/if_frw_query~query(
            EXPORTING
              is_ctx                   = ls_context
              it_filter_key            = it_filter_key
              it_selection_parameters  = it_selection_parameters
              io_query_authorities     = io_query_authorities
              is_query_options         = is_query_options
              io_query                 = lo_int_access
              io_read                  = lo_int_access
              io_modify                = lo_int_access
              iv_fill_data             = iv_fill_data
              it_requested_attributes  = it_requested_attributes
            IMPORTING
              eo_message               = eo_message
              et_key                   = et_key
              es_query_info            = es_query_info
              et_data                  = et_data ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_query = abap_true
            iv_key   = iv_query_key ).
          lv_content_cat = TEXT-005.
          CREATE OBJECT lx_frw
            EXPORTING
              textid          = /bobf/cx_frw_core=>sc_content_exception
              previous        = lx_root
              mv_method_name  = 'QUERY'
              mv_content_name = lv_content_name
              mv_content_cat  = lv_content_cat.
          set_application_error( lx_frw ).
      ENDTRY.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

    ASSERT ID /bobf/frw_error CONDITION
       is_query_options-maximum_rows <= 0 OR
       lines( et_key ) <= is_query_options-maximum_rows.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~release_sync_point.

    DATA:
      ls_sync_point TYPE ty_sync_point,
      lt_key        TYPE /bobf/t_frw_key,
      lt_node       TYPE /bobf/t_frw_node,
*    lt_conf_node  TYPE /bobf/t_confro_node,
*    ls_conf_node  TYPE /bobf/s_confro_node,
      lx_root       TYPE REF TO cx_root.


    READ TABLE mt_sync_point INTO ls_sync_point INDEX 1.
    IF sy-subrc = 0.
*   check if the syncpoints are released in the right order
      IF ls_sync_point-handle <> iv_handle.
        set_application_error( ).
      ENDIF.

*   remove created state if not database state
      IF ls_sync_point-state <> /bobf/if_conf_c=>sc_state_database.
        TRY.
            mo_buffer->get_root_keys(
              EXPORTING
                iv_changed_only = abap_false
              IMPORTING
                et_root_key     = lt_key ).

            map_to_node(
              EXPORTING
                iv_node_key = mo_conf->ms_obj-root_node_key
                it_key      = lt_key
              IMPORTING
                et_node     = lt_node ).

            mo_buffer->delete_state(
                it_node         = lt_node
                iv_incl_subtree = abap_true
                iv_state        = ls_sync_point-state ).

            IF ls_sync_point-state_d IS NOT INITIAL AND ls_sync_point-state_d <> ls_sync_point-state.
              mo_buffer->delete_state(
                  it_node         = lt_node
                  iv_incl_subtree = abap_true
                  iv_state        = ls_sync_point-state_d ).
            ENDIF.

            IF ls_sync_point-state_v IS NOT INITIAL AND ls_sync_point-state_v <> ls_sync_point-state_d.
              mo_buffer->delete_state(
                  it_node         = lt_node
                  iv_incl_subtree = abap_true
                  iv_state        = ls_sync_point-state_v ).
            ENDIF.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.

      DELETE mt_sync_point INDEX 1.

*   reset sync state index
      mv_sync_state_index = mv_sync_state_index - ls_sync_point-states_count.
    ELSE.
*   nothing to do (assumption is that BO has been touched only after sync point creation)
      ASSERT ID /bobf/frw_warning CONDITION 0 = 1.         "#EC BOOL_OK
    ENDIF.

** release sync points for framework nodes
*  mo_conf->get_node_tab( IMPORTING et_node = lt_conf_node ).
*  LOOP AT lt_conf_node INTO ls_conf_node WHERE node_type = /bobf/if_conf_c=>sc_node_type_lock. "#EC CI_SORTSEQ
*    mo_buffer->get_keys(
*      EXPORTING
*        iv_node_key = ls_conf_node-node_key
*        iv_state    = ls_sync_point-state_f
*      IMPORTING
*        et_key      = lt_key ).
*
*    CHECK lt_key IS NOT INITIAL.
*
*    map_to_node(
*      EXPORTING
*        iv_node_key = ls_conf_node-node_key
*        it_key      = lt_key
*      IMPORTING
*        et_node     = lt_node ).
*
*    mo_buffer->delete_state(
*        it_node         = lt_node
*        iv_state        = ls_sync_point-state_f ).
*  ENDLOOP.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve.

    DATA: lv_state              TYPE /bobf/conf_state,
          lo_change             TYPE REF TO /bobf/cl_frw_change,
          lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
          lo_auth_change        TYPE REF TO /bobf/if_frw_change,
          lt_failed_key         TYPE /bobf/t_frw_key,
          lt_key                TYPE /bobf/t_frw_key.

    BREAK-POINT ID /bobf/frw.

    CLEAR: eo_message,
           et_failed_key,
           et_data.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    lt_key = it_key.
    lv_state = get_state_for_read( iv_before_image ).

    IF iv_fill_data = abap_true.
      IF mo_conf->ms_last_node-node_key <> iv_node_key.
        mo_conf->get_node( iv_node_key ).
      ENDIF.
      type_check( iv_expected_line_type = mo_conf->ms_last_node-data_type
                  iv_service_name       = 'Retrieve'
                  iv_parameter_name     = 'ET_DATA'
                  it_data               = et_data ) ##no_text.
    ENDIF.

* ____________________________________________________________________ *
* check authorization
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve
                                    bo_service          = space
                                    node_key            = iv_node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = et_failed_key
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).

* ____________________________________________________________________ *
* retrieve data
    retrieve(
      EXPORTING
        iv_node_key             = iv_node_key
        it_key                  = lt_key
        iv_state                = lv_state
        iv_invalidate_cache     = iv_invalidate_cache
        iv_fill_data            = iv_fill_data
        iv_edit_mode            = iv_edit_mode
        it_requested_attributes = it_requested_attributes
      IMPORTING
        eo_message              = eo_message
        eo_change               = eo_change
        et_data                 = et_data
        et_failed_key           = lt_failed_key ).

    INSERT LINES OF lt_failed_key INTO TABLE et_failed_key.

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = lt_key
            it_key_subset = et_failed_key ) = abap_true.

    IF eo_change IS BOUND.
      eo_change->merge( lo_auth_change ).
    ELSE.
      eo_change = lo_auth_change.
    ENDIF.
    lo_change ?= eo_change.
    prepare_notifications_f_export( lo_change ).
    notify_property_changes( eo_change ).

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve_by_association.

    DATA: lv_state               TYPE /bobf/conf_state,
          ls_assoc               TYPE /bobf/s_confro_assoc,
          lo_property            TYPE REF TO /bobf/if_frw_property,
          lt_property            TYPE /bobf/t_frw_property_k_sorted,
          lt_key                 TYPE /bobf/t_frw_key,
          lt_failed_key          TYPE /bobf/t_frw_key,
          lt_key_check_exist     TYPE /bobf/t_frw_key,
          ls_key                 TYPE /bobf/s_frw_key,
          lv_check_services      TYPE /bobf/conf_check_services,
          lo_message             TYPE REF TO /bobf/if_frw_message,
          lo_change              TYPE REF TO /bobf/cl_frw_change,
          lv_fill_failed_key     TYPE boole_d,
          lt_auth_failed_src_key TYPE /bobf/t_frw_key,
          lt_auth_failed_trg_key TYPE /bobf/t_frw_key,
          lo_auth_message_dummy  TYPE REF TO /bobf/if_frw_message,
          lo_auth_change         TYPE REF TO /bobf/if_frw_change,
          ls_key_link            TYPE /bobf/s_frw_key_link,
          ls_failed_key          TYPE /bobf/s_frw_key.

    FIELD-SYMBOLS: <ls_data> TYPE any,
                   <lv_key>  TYPE /bobf/conf_key.

    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           et_key_link,
           et_failed_key,
           et_data.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    lt_key = it_key.
    lv_state = get_state_for_read( iv_before_image ).

* check association
    IF mo_conf->ms_last_assoc-assoc_key = iv_association.
      ls_assoc = mo_conf->ms_last_assoc.
    ELSE.
      mo_conf->get_assoc( EXPORTING iv_assoc_key = iv_association
        IMPORTING es_assoc     = ls_assoc ).
    ENDIF.

    IF ls_assoc IS INITIAL.
*   unknown association
      set_application_error( ).
    ENDIF.

    IF iv_fill_data = abap_true.
      DATA lv_target_node_data_type TYPE string.
      IF ls_assoc-assoc_cat = /bobf/if_conf_c=>sc_assoccat_xbo.
        " xBO association...
        TRY.
            DATA lo_ref_bo_conf TYPE REF TO /bobf/if_frw_configuration.
            lo_ref_bo_conf = /bobf/cl_frw_factory=>get_configuration( iv_bo_key = ls_assoc-target_node->ref_bo_key ).
            DATA ls_ref_node_conf TYPE /bobf/s_confro_node.
            lo_ref_bo_conf->get_node( EXPORTING iv_node_key = ls_assoc-target_node->ref_node_key
                                      IMPORTING es_node     = ls_ref_node_conf ).
          CATCH BEFORE UNWIND /bobf/cx_frw INTO DATA(lx_frw).
            RAISE SHORTDUMP lx_frw.
        ENDTRY.
        lv_target_node_data_type = ls_ref_node_conf-data_type.
      ELSE.
        " inner BO association...
        lv_target_node_data_type = ls_assoc-target_node->data_type.
      ENDIF.
      type_check( iv_expected_line_type = lv_target_node_data_type
                  iv_service_name       = 'RetrieveByAssociation'
                  iv_parameter_name     = 'ET_DATA'
                  it_data               = et_data ) ##no_text.
    ENDIF.
    lv_fill_failed_key = iv_fill_failed_key.
    IF et_failed_key IS NOT REQUESTED.
      lv_fill_failed_key = abap_false.
    ENDIF.

* ____________________________________________________________________ *
* check association properties
    IF ( mo_conf->ms_obj-chk_serv_assoc = /bobf/if_conf_c=>sc_check_services_stat OR
         mo_conf->ms_obj-chk_serv_assoc = /bobf/if_conf_c=>sc_check_services_stat_dyn ) AND
       ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent AND
       ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_root.

      lv_check_services = mo_conf->ms_obj-chk_serv_assoc.
*   Use only static properties when working on before image as properties relate to current image by definition
      IF iv_before_image = abap_true.
        lv_check_services = /bobf/if_conf_c=>sc_check_services_stat.
      ENDIF.

      /bobf/if_frw_service_layer~retrieve_property(
        EXPORTING
          iv_node_key                = iv_node_key
          it_key                     = lt_key
          iv_check_services          = lv_check_services
          iv_assoc_property          = abap_true
        IMPORTING
          eo_property                = lo_property
          eo_message                 = eo_message ).

      IF lo_property IS BOUND.
        lo_property->get_property( IMPORTING et_property_sorted = lt_property ).

        LOOP AT lt_key INTO ls_key.
          READ TABLE lt_property WITH KEY
              parent_key    = ls_key-key
              content_cat   = /bobf/if_conf_c=>sc_content_ass
              content_key   = iv_association
              property_name = /bobf/if_conf_c=>sc_property_name_enabled
              value         = abap_false
              TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            DELETE lt_key.
            IF lv_fill_failed_key = abap_true.
              INSERT ls_key INTO TABLE lt_key_check_exist.
            ENDIF.
          ENDIF.
        ENDLOOP.
        IF lt_key_check_exist IS NOT INITIAL.
          retrieve(
            EXPORTING
              iv_node_key             = iv_node_key
              it_key                  = lt_key_check_exist
              iv_state                = lv_state
              iv_fill_data            = abap_false
            IMPORTING
              et_failed_key           = et_failed_key ).
        ENDIF.
      ENDIF.

    ENDIF.

* ____________________________________________________________________ *
* check authorization on source node
* (remark: this is ignored in standard library implementation)
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-rba_source_node
                                    bo_service          = space
                                    node_key            = ls_assoc-source_node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = lt_auth_failed_src_key
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).
    IF lv_fill_failed_key = abap_true.
      INSERT LINES OF lt_auth_failed_src_key INTO TABLE et_failed_key.
    ENDIF.

* ____________________________________________________________________ *
* retrieve data
    retrieve_by_association(
     EXPORTING
       iv_node_key             = iv_node_key
       it_key                  = lt_key
       iv_association          = iv_association
       is_parameters           = is_parameters
       it_filtered_attributes  = it_filtered_attributes
       iv_state                = lv_state
       iv_before_image         = iv_before_image
       iv_invalidate_cache     = iv_invalidate_cache
       iv_edit_mode            = iv_edit_mode
       it_requested_attributes = it_requested_attributes
       iv_fill_data            = iv_fill_data
       iv_fill_failed_key      = lv_fill_failed_key
     IMPORTING
       eo_message              = lo_message
       eo_change               = eo_change
       et_data                 = et_data
       et_key_link             = et_key_link
       et_target_key           = et_target_key
       et_failed_key           = lt_failed_key ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = lt_key
            it_key_subset = lt_failed_key ) = abap_true.
    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_link_matching(
           it_key_link = et_key_link
           it_key      = lt_key ) = abap_true.

    INSERT LINES OF lt_failed_key INTO TABLE et_failed_key.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

* ____________________________________________________________________ *
* check authorization on target node
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-rba_target_node
                                    bo_service          = space
                                    node_key            = ls_assoc-target_node_key )
        iv_cleanse_keys  = abap_false
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = lt_auth_failed_trg_key
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = et_target_key
        co_message       = lo_auth_message_dummy
    ).
    " update exporting tables for data, key link and target keys
    LOOP AT lt_auth_failed_trg_key INTO ls_key.
      LOOP AT et_key_link INTO ls_key_link USING KEY target_key WHERE target_key = ls_key-key.
        DELETE et_key_link USING KEY loop_key.
        ENDLOOP.
        DELETE et_target_key USING KEY key_sort WHERE key = ls_key-key.
        IF iv_fill_data = abap_true.
          LOOP AT et_data ASSIGNING <ls_data>.
            ASSIGN COMPONENT /bobf/if_conf_c=>sc_attribute_name_key OF STRUCTURE <ls_data> TO <lv_key>.
            IF sy-subrc = 0 AND <lv_key> = ls_key-key.
              DELETE et_data.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDLOOP.

    IF eo_change IS BOUND.
      eo_change->merge( lo_auth_change ).
    ELSE.
      eo_change = lo_auth_change.
    ENDIF.
    lo_change ?= eo_change.
    prepare_notifications_f_export( lo_change ).
    notify_property_changes( eo_change ).

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.                    "retrieve_by_association


  METHOD /bobf/if_frw_service_layer~retrieve_code_value_set.

    DATA: ls_vset               TYPE /bobf/s_confro_value_set,
          ls_node               TYPE /bobf/s_confro_node,
          ls_act                TYPE /bobf/s_confro_act_list,
          ls_assoc              TYPE /bobf/s_confro_assoc,
          ls_query              TYPE /bobf/s_confro_query,
          ls_vset_class         TYPE ty_value_set_code,
          lv_content_cat        TYPE string,
          lv_content_name       TYPE /bobf/obm_name,
          lt_fieldmapping       TYPE /bobf/t_confro_mapping,
          ls_fieldmapping       TYPE /bobf/s_confro_mapping,
          lo_int_access         TYPE REF TO /bobf/cl_frw_int_access,
          ls_context            TYPE /bobf/s_frw_ctx_value_set,
          lo_delegation         TYPE REF TO /bobf/if_frw_delegation,
          lx_frw                TYPE REF TO /bobf/cx_frw_core,
          lx_root               TYPE REF TO cx_root,
          lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
          lo_auth_change        TYPE REF TO /bobf/if_frw_change,
          lt_key                TYPE /bobf/t_frw_key.

    BREAK-POINT ID /bobf/frw.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    CLEAR et_code_values.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
    ENDIF.

    IF mo_conf->ms_last_vset-vset_key = iv_vset_key.
      ls_vset = mo_conf->ms_last_vset.
    ELSE.
      mo_conf->get_value_set(
        EXPORTING iv_vset_key = iv_vset_key
        IMPORTING es_vset     = ls_vset ).
    ENDIF.

    CASE ls_vset-content_cat.
      WHEN /bobf/if_conf_c=>sc_content_nod.
        IF mo_conf->ms_last_node-node_key = ls_vset-content_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_vset-content_key
            IMPORTING es_node     = ls_node ).
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_content_act.
        IF mo_conf->ms_last_action-act_key = ls_vset-content_key.
          ls_act = mo_conf->ms_last_action.
        ELSE.
          mo_conf->get_act(
            EXPORTING iv_act_key = ls_vset-content_key
            IMPORTING es_action  = ls_act ).
        ENDIF.
        IF mo_conf->ms_last_node-node_key = ls_act-node_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_act-node_key
            IMPORTING es_node     = ls_node ).
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_content_ass.
        IF mo_conf->ms_last_assoc-assoc_key = ls_vset-content_key.
          ls_assoc = mo_conf->ms_last_assoc.
        ELSE.
          mo_conf->get_assoc(
            EXPORTING iv_assoc_key = ls_vset-content_key
            IMPORTING es_assoc  = ls_assoc ).
        ENDIF.
        ls_node = ls_assoc-source_node->*.

      WHEN /bobf/if_conf_c=>sc_content_qry.
        IF mo_conf->ms_last_query-query_key = ls_vset-content_key.
          ls_query = mo_conf->ms_last_query.
        ELSE.
          mo_conf->get_query(
            EXPORTING iv_query_key = ls_vset-content_key
            IMPORTING es_query     = ls_query ).
        ENDIF.
        IF mo_conf->ms_last_node-node_key = ls_query-node_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_query-node_key
            IMPORTING es_node     = ls_node ).
        ENDIF.
    ENDCASE.

    lt_key = it_key.

* ____________________________________________________________________ *
* check authorization
    IF iv_key_is_default = abap_false.
      lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
      mo_authority_handler->check_authority(
        EXPORTING
          io_change        = lo_auth_change
          is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                      activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_code_value_set
                                      bo_service          = space
                                      node_key            = ls_node-node_key )
          iv_cleanse_keys  = abap_true
          io_bopf          = me
          io_buffer        = mo_buffer
          iv_last_state    = /bobf/if_conf_c=>sc_state_database
          iv_current_state = /bobf/if_conf_c=>sc_state_current
        CHANGING
          ct_access_stack  = mt_access_stack
          ct_key           = lt_key
          co_message       = lo_auth_message_dummy
      ).
    ENDIF.

* ____________________________________________________________________ *
* delegate call if necessary
    IF ls_node-delegation_class IS NOT INITIAL.
      TRY.
          lo_delegation = get_delegation( ls_node-node_key ).

          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
            RECEIVING
              eo_internal_access = lo_int_access
          ).

          lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
          lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
          lo_int_access->set_context( iv_read_allowed  = abap_true ).

          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          lo_delegation->retrieve_code_value_set(
            EXPORTING
              iv_vset_key       = iv_vset_key
              it_key            = lt_key
              iv_key_is_default = iv_key_is_default
              is_parameters     = is_parameters
              it_attributes     = it_attributes
              io_read           = lo_int_access
            IMPORTING
              et_code_values    = et_code_values ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          lo_int_access->invalidate( ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

    ELSE.
* ____________________________________________________________________ *
* call implementation if existing
      IF ls_vset-value_set_class IS NOT INITIAL.

        TRY.
*         get node class
            READ TABLE mt_value_set_code
               WITH TABLE KEY vset_key = iv_vset_key
               INTO ls_vset_class.
            IF sy-subrc <> 0.
              ls_vset_class-vset_key = iv_vset_key.
              CREATE OBJECT ls_vset_class-class TYPE (ls_vset-value_set_class).
              INSERT ls_vset_class INTO TABLE mt_value_set_code.
            ENDIF.

            IF iv_key_is_default = abap_true.
              /bobf/cl_frw_int_access=>new_instance(
                EXPORTING
                  io_bopf            = me
                  io_conf            = mo_conf
                  io_buffer          = mo_buffer
                  iv_class_name      = /bobf/cl_frw_int_defaults=>gc_class_name
                RECEIVING
                  eo_internal_access = lo_int_access
              ).
            ELSE.
              /bobf/cl_frw_int_access=>new_instance(
                EXPORTING
                  io_bopf            = me
                  io_conf            = mo_conf
                  io_buffer          = mo_buffer
                RECEIVING
                  eo_internal_access = lo_int_access
              ).
            ENDIF.

            lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
            lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
            lo_int_access->set_context( iv_read_allowed  = abap_true ).

            mo_conf->get_fieldmapping( IMPORTING et_fieldmapping = lt_fieldmapping ).
            READ TABLE lt_fieldmapping INTO ls_fieldmapping WITH KEY fieldname_ext
              COMPONENTS content_cat        = ls_vset-content_cat
                         content_key        = ls_vset-content_key
                         fieldname_ext_long = ls_vset-vset_esr_name.
            ls_context-attribute     = ls_fieldmapping-fieldname_int.
            ls_context-bo_key        = mo_conf->ms_obj-bo_key.
            ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
            ls_context-value_set_key = iv_vset_key.
            ls_context-node_key      = ls_node-node_key.
            ls_context-act_key       = ls_act-act_key.
            ls_context-assoc_key     = ls_assoc-assoc_key.
            ls_context-query_key     = ls_query-query_key.

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_vset_class-class->retrieve_code_values(
              EXPORTING
                is_ctx         = ls_context
                it_key         = lt_key
                io_read        = lo_int_access
                is_parameters  = is_parameters
                it_attributes  = it_attributes
              CHANGING
                ct_code_values = et_code_values ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            lo_int_access->invalidate( ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
            DELETE mt_access_stack INDEX 1.

          CATCH cx_sy_dyn_call_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_vset = abap_true
              iv_key  = iv_vset_key ).
            lv_content_cat = TEXT-007.
            CREATE OBJECT lx_frw
              EXPORTING
                textid          = /bobf/cx_frw_core=>sc_no_instance
                previous        = lx_root
                mv_method_name  = 'RETRIEVE_CODE_VALUES'
                mv_content_name = lv_content_name
                mv_content_cat  = lv_content_cat.
            set_configuration_error( lx_frw ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_vset
                                                                                iv_content_key   = ls_vset-content_key
                                                                                iv_content_class = ls_vset-value_set_class
                                                                                iv_node_key      = ls_vset-vset_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'RETRIEVE_CODE_VALUES' ) ).
        ENDTRY.
      ENDIF.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve_default_action_param.

    DATA: ls_action                TYPE /bobf/s_confro_act_list,
          ls_obj                   TYPE /bobf/s_confro_obj,
          lo_delegation            TYPE REF TO /bobf/if_frw_delegation,
          ls_act_class             TYPE ty_action,
          lv_content_name          TYPE /bobf/obm_name,
          lv_content_cat           TYPE string,
          ls_context               TYPE /bobf/s_frw_ctx_act,
          lo_int_access            TYPE REF TO /bobf/cl_frw_int_access,
          lx_root                  TYPE REF TO cx_root,
          lx_frw                   TYPE REF TO /bobf/cx_frw_core,
          lt_action_execution_list TYPE /bobf/t_frw_key2,
          lv_action_execution_list TYPE /bobf/conf_key,
          lo_auth_message_dummy    TYPE REF TO /bobf/if_frw_message,
          lo_auth_change           TYPE REF TO /bobf/if_frw_change,
          lt_key                   TYPE /bobf/t_frw_key.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
      CLEAR lo_int_access.
    ENDIF.

*  ____________________________________________________________________ *
*  create sorted action execution list
*  (pre-enhancement actions, basic action and post-enhancement actions)
    IF mo_conf->ms_last_action-act_key = iv_act_key.
      ls_action = mo_conf->ms_last_action.
    ELSE.
      mo_conf->get_act(
        EXPORTING
          iv_act_key  = iv_act_key
        IMPORTING
          es_action   = ls_action ).
    ENDIF.

    IF ls_action-pre_enhancement_keys IS BOUND.
      lt_action_execution_list = ls_action-pre_enhancement_keys->*.
    ENDIF.

    INSERT ls_action-act_key INTO TABLE lt_action_execution_list.

    IF ls_action-post_enhancement_keys IS BOUND.
      APPEND LINES OF ls_action-post_enhancement_keys->* TO lt_action_execution_list.
    ENDIF.

    lt_key = it_key.

* ____________________________________________________________________ *
* check authorization
    lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = lo_auth_change
        is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                    activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_default_action_param
                                    bo_service          = space
                                    node_key            = ls_action-node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      CHANGING
        ct_access_stack  = mt_access_stack
        ct_key           = lt_key
        co_message       = lo_auth_message_dummy
    ).

*  ____________________________________________________________________ *
*  execute the action list
    LOOP AT lt_action_execution_list INTO lv_action_execution_list.

      IF mo_conf->ms_last_action-act_key = lv_action_execution_list.
        ls_action = mo_conf->ms_last_action.
      ELSE.
        mo_conf->get_act(
          EXPORTING
            iv_act_key  = lv_action_execution_list
          IMPORTING
            es_action   = ls_action ).
      ENDIF.

      IF ls_action-act_class IS INITIAL.
*   check for delegation class
        IF mo_conf->ms_last_node-node_key <> ls_action-node_key.
          mo_conf->get_node( iv_node_key = ls_action-node_key ).
        ENDIF.

        IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
          TRY.
              lo_delegation = get_delegation( ls_action-node_key ).
              DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

              lo_delegation->retrieve_default_action_param(
                EXPORTING
                  iv_act_key    = lv_action_execution_list
                  it_key        = lt_key
                CHANGING
                  cs_parameters = cs_parameters ).

              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

      ELSE.
        lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
        TRY.
*       get action class
            READ TABLE mt_action
              WITH TABLE KEY act_key = lv_action_execution_list
              INTO ls_act_class.
            IF sy-subrc <> 0.
              ls_act_class-act_key = lv_action_execution_list.
              CREATE OBJECT ls_act_class-class TYPE (ls_action-act_class).
            ENDIF.

            /bobf/cl_frw_int_access=>new_instance(
              EXPORTING
                io_bopf            = me
                io_conf            = mo_conf
                io_buffer          = mo_buffer
              RECEIVING
                eo_internal_access = lo_int_access
            ).
            lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            ls_obj = mo_conf->ms_obj.
            ls_context-bo_key          = ls_obj-bo_key.
            ls_context-root_node_key   = ls_obj-root_node_key.
            ls_context-node_key        = ls_action-node_key.
            ls_context-act_key         = lv_action_execution_list.
            ls_context-act_cat         = ls_action-act_cat.
            lo_int_access->set_context(
              is_action        = ls_context
              iv_read_allowed  = abap_true ).

*       call action class
            ls_act_class-class->retrieve_default_param(
               EXPORTING
                 is_ctx        = ls_context
                 it_key        = lt_key
                 io_read       = lo_int_access
               CHANGING
                 cs_parameters = cs_parameters ).

            lo_int_access->invalidate( ).

          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_act = abap_true
              iv_key = ls_action-act_key ).
            lv_content_cat = TEXT-000.
            CREATE OBJECT lx_frw
              EXPORTING
                previous        = lx_root
                textid          = /bobf/cx_frw_core=>sc_no_instance
                mv_classname    = ls_action-act_class
                mv_content_name = lv_content_name
                mv_content_cat  = lv_content_cat.
            set_configuration_error( lx_frw ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_act
                                                                                iv_content_key   = ls_action-act_key
                                                                                iv_content_class = ls_action-act_class
                                                                                iv_node_key      = ls_action-node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'RETRIEVE_DEFAULT_PARAM' ) ).
        ENDTRY.
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.

      ENDIF.

    ENDLOOP.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve_default_node_values.

    DATA: ls_nodeconf     TYPE        /bobf/s_confro_node,
          ls_node_class   TYPE        ty_node,
          lt_key          TYPE        /bobf/t_frw_key,
          ls_key          TYPE        /bobf/s_frw_key,
          lt_node         TYPE        /bobf/t_frw_node,
          ls_node         TYPE        /bobf/s_frw_node,
          lo_int_access   TYPE REF TO /bobf/cl_frw_int_access,
          lo_int_defaults TYPE REF TO /bobf/cl_frw_int_access,
          ls_mod          TYPE        /bobf/s_frw_modification,
          ls_context      TYPE        /bobf/s_frw_ctx_assoc,
          lo_delegation   TYPE REF TO /bobf/if_frw_delegation,
          lo_change       TYPE REF TO /bobf/if_frw_change,
          lv_content_cat  TYPE        string,
          lv_content_name TYPE        /bobf/obm_name,
          lt_src_key      TYPE        /bobf/t_frw_key,
          ls_key_link     TYPE        /bobf/s_frw_key_link,
          lt_key_link     TYPE        /bobf/t_frw_key_link,
          lt_key_link2    TYPE        /bobf/t_frw_key_link,
          lt_failed_key   TYPE        /bobf/t_frw_key,
          lt_failed_key2  TYPE        /bobf/t_frw_key,
          lt_modification TYPE        /bobf/t_frw_modification,
          lo_message      TYPE REF TO /bobf/if_frw_message,
          lx_frw          TYPE REF TO /bobf/cx_frw_core,
          lx_root         TYPE REF TO cx_root.

    FIELD-SYMBOLS: <ls_mod> TYPE /bobf/s_frw_modification.

    BREAK-POINT ID /bobf/frw.

    CLEAR: et_data,
           eo_message,
           eo_property.

    CHECK it_modification IS NOT INITIAL.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
    ENDIF.

    IF mo_conf->ms_last_node-node_key = iv_node_key.
      ls_nodeconf = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
        EXPORTING iv_node_key = iv_node_key
        IMPORTING es_node     = ls_nodeconf ).
    ENDIF.

* ____________________________________________________________________ *
    IF ls_nodeconf-delegation_class IS NOT INITIAL.
*   delegate call if necessary
      TRY.
          CREATE OBJECT eo_property TYPE /bobf/cl_frw_property.
          lo_delegation = get_delegation( iv_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          lo_delegation->retrieve_default_node_values(
            EXPORTING
               iv_node_key                  = iv_node_key
               it_modification              = it_modification
               is_assoc_parameters          = is_assoc_parameters
               it_assoc_filtered_attributes = it_assoc_filtered_attributes
               io_property                  = eo_property
             IMPORTING
               eo_message                   = eo_message
               et_data                      = et_data ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

    ELSE.
* ____________________________________________________________________ *
*   no delegation involved
      LOOP AT it_modification ASSIGNING <ls_mod>.
        ls_key-key = <ls_mod>-key.
        APPEND ls_key TO lt_key.
        ls_key-key = <ls_mod>-source_key.
        APPEND ls_key TO lt_src_key.
      ENDLOOP.

      IF <ls_mod>-source_node IS NOT INITIAL.
        TRY.
            mo_buffer->get_root_key(
              EXPORTING
                iv_node_key   = <ls_mod>-source_node
                it_key        = lt_src_key
                iv_state      = /bobf/if_conf_c=>sc_state_default
              IMPORTING
                et_key_link   = lt_key_link
                et_failed_key = lt_failed_key ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        IF lt_failed_key IS NOT INITIAL.
*       Parent was not defaulted -> check in current state
          TRY.
              mo_buffer->get_root_key(
               EXPORTING
                 iv_node_key   = <ls_mod>-source_node
                 it_key        = lt_failed_key
                 iv_state      = /bobf/if_conf_c=>sc_state_current
               IMPORTING
                 et_key_link   = lt_key_link2
                 et_failed_key = lt_failed_key2 ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
          ASSERT ID /bobf/frw_error CONDITION lt_failed_key2 IS INITIAL.
          INSERT LINES OF lt_key_link2 INTO TABLE lt_key_link.
        ENDIF.

        LOOP AT it_modification INTO ls_mod.
          READ TABLE lt_key_link INTO ls_key_link
            WITH KEY source_key = ls_mod-source_key.
          ASSERT ID /bobf/frw_error CONDITION sy-subrc = 0.
          IF sy-subrc = 0.
            ls_mod-root_key = ls_key_link-target_key.
            APPEND ls_mod TO lt_modification.
          ELSE.
            DELETE lt_key WHERE key = ls_mod-key.
          ENDIF.
        ENDLOOP.
      ELSE.
*     working on ROOT node
        lt_modification = it_modification.
      ENDIF.

      CHECK lt_modification IS NOT INITIAL.

* ____________________________________________________________________ *
*   set node category (default only)
      LOOP AT lt_modification ASSIGNING <ls_mod>.
        IF <ls_mod>-node_cat IS INITIAL.
          <ls_mod>-node_cat = ls_nodeconf-node_cat_key.
        ENDIF.
      ENDLOOP.

* ____________________________________________________________________ *
*   apply defaults to buffer
      TRY.
          mv_defaults_exists = abap_true.
          lo_change = /bobf/cl_frw_factory=>get_change( ).
          mo_buffer->modify(
             EXPORTING
               it_modification   = lt_modification
               iv_state          = /bobf/if_conf_c=>sc_state_default
               iv_only_transient = abap_true
               io_change         = lo_change
             IMPORTING
               eo_message        = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

* ____________________________________________________________________ *
*   set initial status values
      IF mo_conf->ms_obj-status_class  IS NOT INITIAL AND
         ls_nodeconf-status_attributes IS NOT INITIAL.
*     get status adapter
        IF mo_sam IS NOT BOUND.
          TRY.
              CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
                EXPORTING
                  iv_bo_key = mo_conf->ms_obj-bo_key.
            CATCH BEFORE UNWIND cx_sy_create_object_error INTO lx_root.
              lv_content_cat = TEXT-004.
              CREATE OBJECT lx_frw
                EXPORTING
                  previous       = lx_root
                  textid         = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname   = mo_conf->ms_obj-status_class
                  mv_content_cat = lv_content_cat.
              set_application_error( lx_frw ).
          ENDTRY.
          ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
        ENDIF.

*     get int access
        lo_int_defaults = /bobf/cl_frw_int_access=>new_instance(
            io_bopf            = me
            io_conf            = mo_conf
            io_buffer          = mo_buffer
            io_change          = lo_change
            iv_class_name      = /bobf/cl_frw_int_defaults=>gc_class_name
        ).
        lo_int_defaults->set_current_state( /bobf/if_conf_c=>sc_state_current ).
        ls_context-bo_key        = mo_conf->ms_obj-bo_key.
        ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
        ls_context-node_key      = iv_node_key.
        ls_context-assoc_key     = ls_mod-association.
        lo_int_defaults->set_context( iv_read_allowed   = abap_true
                                      iv_modify_allowed = abap_true
                                      is_association    = ls_context ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
        INSERT lo_int_defaults INTO mt_access_stack INDEX 1.

        LOOP AT it_modification INTO ls_mod.
          ls_node-node = ls_mod-node.
          ls_node-key  = ls_mod-key.
          INSERT ls_node INTO TABLE lt_node.
        ENDLOOP.

        lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        TRY.
            mo_sam->create(
              EXPORTING
                it_node    = lt_node
                io_read    = lo_int_defaults
                io_modify  = lo_int_defaults
             IMPORTING
                eo_message = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

*     check for undone modifications and flush
        IF lo_int_defaults->mt_modification IS NOT INITIAL.
          lo_int_defaults->/bobf/if_frw_modify~end_modify( IMPORTING eo_message = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.
        lo_int_defaults->invalidate( ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.
      ENDIF.

* ____________________________________________________________________ *
*   call implementation if existing
      IF ls_nodeconf-node_class IS NOT INITIAL.
        lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        TRY.
*         get node class
            READ TABLE mt_node
               WITH TABLE KEY node_key = ls_nodeconf-node_key
               INTO ls_node_class.
            IF sy-subrc <> 0.
              ls_node_class-node_key = ls_nodeconf-node_key.
              CREATE OBJECT ls_node_class-class TYPE (ls_nodeconf-node_class).
              INSERT ls_node_class INTO TABLE mt_node.
            ENDIF.

            IF lo_int_defaults IS NOT BOUND.
              lo_int_defaults = /bobf/cl_frw_int_access=>new_instance(
                  io_bopf   = me
                  io_conf   = mo_conf
                  io_buffer = mo_buffer
                  io_change = lo_change
                  iv_class_name  = /bobf/cl_frw_int_defaults=>gc_class_name
              ).
              lo_int_defaults->set_current_state( /bobf/if_conf_c=>sc_state_current ).
              ls_context-bo_key        = mo_conf->ms_obj-bo_key.
              ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
              ls_context-node_key      = iv_node_key.
              ls_context-assoc_key     = ls_mod-association.
            ENDIF.
            lo_int_defaults->set_context( iv_read_allowed   = abap_true
                                          iv_modify_allowed = abap_true ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            lo_int_access = lo_int_defaults.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            ls_node_class-class->retrieve_default_values(
              EXPORTING
                is_ctx                       = ls_context
                it_key                       = lt_key
                is_assoc_parameters          = is_assoc_parameters
                it_assoc_filtered_attributes = it_assoc_filtered_attributes
                iv_source_node_key           = ls_mod-source_node
                iv_source_key                = ls_mod-source_key
                io_read                      = lo_int_defaults
                io_modify                    = lo_int_defaults
              IMPORTING
                eo_message                   = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

          CATCH cx_sy_dyn_call_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_node = abap_true
              iv_key  = iv_node_key ).
            lv_content_cat = TEXT-006.
            CREATE OBJECT lx_frw
              EXPORTING
                textid          = /bobf/cx_frw_core=>sc_no_instance
                previous        = lx_root
                mv_method_name  = 'RETRIEVE_DEFAULT_VALUES'
                mv_content_name = lv_content_name
                mv_content_cat  = lv_content_cat.
            set_configuration_error( lx_frw ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_nod
                                                                                iv_content_key   = ls_nodeconf-node_key
                                                                                iv_content_class = ls_nodeconf-node_class
                                                                                iv_node_key      = iv_node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'RETRIEVE_DEFAULT_VALUES' ) ).
        ENDTRY.

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

*     check for undone modifications and flush
        IF lo_int_defaults->mt_modification IS NOT INITIAL.
          lo_int_defaults->/bobf/if_frw_modify~end_modify( IMPORTING eo_message = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.
        lo_int_defaults->invalidate( ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.
      ENDIF.

*   read data from buffer
      TRY.
          mo_buffer->retrieve(
            EXPORTING
              iv_node_key       = iv_node_key
              it_key            = lt_key
              iv_state          = /bobf/if_conf_c=>sc_state_default
              iv_fill_data      = abap_true
              iv_buffer_only    = abap_true
              io_change         = lo_change
            IMPORTING
              et_data           = et_data ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

*   determine properties
      /bobf/if_frw_service_layer~retrieve_property(
        EXPORTING
          iv_node_key                  = iv_node_key
          it_key                       = lt_key
          iv_key_is_default            = abap_true
          iv_node_property             = abap_true
          iv_node_attribute_property   = abap_true
          iv_assoc_property            = abap_true
          iv_assoc_attribute_property  = abap_true
          iv_action_property           = abap_true
          iv_action_attribute_property = abap_true
          iv_query_property            = abap_true
          iv_query_attribute_property  = abap_true
          iv_check_services            = /bobf/if_conf_c=>sc_retrieve_property
        IMPORTING
          eo_message                   = lo_message
          eo_property                  = eo_property ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve_default_query_param.

    DATA: ls_obj          TYPE /bobf/s_confro_obj,
          ls_query        TYPE /bobf/s_confro_query,
          ls_query_class  TYPE ty_query,
          lv_content_cat  TYPE string,
          lv_content_name TYPE /bobf/obm_name,
          ls_context      TYPE /bobf/s_frw_ctx_query,
          lo_int_access   TYPE REF TO /bobf/cl_frw_int_access,
          lx_frw          TYPE REF TO /bobf/cx_frw_core,
          lx_root         TYPE REF TO cx_root.

    BREAK-POINT ID /bobf/frw.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
    ENDIF.

    mo_conf->get_query(
      EXPORTING iv_query_key = iv_query_key
      IMPORTING es_query     = ls_query ).

    TRY.
        IF ls_query-query_class IS INITIAL.
*       no implementation available -> no default
          ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>access_stack_stack_check(
                 it_access_stack = mt_access_stack ) = abap_true.
          RETURN.

        ELSE.
*       fill context structure
          ls_obj = mo_conf->ms_obj.
          ls_context-bo_key        = ls_obj-bo_key.
          ls_context-root_node_key = ls_obj-root_node_key.
          ls_context-node_key      = ls_query-node_key.
          ls_context-query_key     = iv_query_key.

*       get query class
          READ TABLE mt_query
             WITH TABLE KEY query_key = ls_query-query_key
             INTO ls_query_class.
          IF sy-subrc <> 0.
            ls_query_class-query_key = ls_query-query_key.
            CREATE OBJECT ls_query_class-class TYPE (ls_query-query_class).
            INSERT ls_query_class INTO TABLE mt_query.
          ENDIF.

          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          ls_query_class-class->retrieve_default_param(
            EXPORTING
              is_ctx                  = ls_context
            CHANGING
              ct_selection_parameters = ct_selection_parameters ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        ENDIF.

      CATCH cx_sy_dyn_call_error INTO lx_root.
        lv_content_name = get_content_description(
          iv_query = abap_true
          iv_key   = iv_query_key ).
        lv_content_cat = TEXT-001.
        CREATE OBJECT lx_frw
          EXPORTING
            textid          = /bobf/cx_frw_core=>sc_no_instance
            previous        = lx_root
            mv_method_name  = 'RETRIEVE_DEFAULT_PARAM'
            mv_content_name = lv_content_name
            mv_content_cat  = lv_content_cat.
        set_configuration_error( lx_frw ).

      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                            iv_content_cat   = /bobf/if_conf_c=>sc_content_qry
                                                                            iv_content_key   = ls_query-query_key
                                                                            iv_content_class = ls_query-query_class
                                                                            iv_node_key      = ls_query-node_key
                                                                            io_configuration = mo_conf
                                                                            iv_method_name   = 'RETRIEVE_DEFAULT_PARAM' ) ).
    ENDTRY.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve_id_value_set.

    DATA: ls_vset         TYPE /bobf/s_confro_value_set,
          ls_node         TYPE /bobf/s_confro_node,
          ls_act          TYPE /bobf/s_confro_act_list,
          ls_assoc        TYPE /bobf/s_confro_assoc,
          ls_query        TYPE /bobf/s_confro_query,
          ls_vset_class   TYPE ty_value_set_id,
          lv_content_cat  TYPE string,
          lv_content_name TYPE /bobf/obm_name,
          lt_fieldmapping TYPE /bobf/t_confro_mapping,
          ls_fieldmapping TYPE /bobf/s_confro_mapping,
          lo_int_access   TYPE REF TO /bobf/cl_frw_int_access,
          ls_context      TYPE /bobf/s_frw_ctx_value_set,
          lo_delegation   TYPE REF TO /bobf/if_frw_delegation,
          lx_frw          TYPE REF TO /bobf/cx_frw_core,
          lx_root         TYPE REF TO cx_root.

    BREAK-POINT ID /bobf/frw.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

    CLEAR et_key.

    READ TABLE mt_access_stack INTO lo_int_access INDEX 1.
    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      lo_int_access->end_modify( ).
    ENDIF.

    IF mo_conf->ms_last_vset-vset_key = iv_vset_key.
      ls_vset = mo_conf->ms_last_vset.
    ELSE.
      mo_conf->get_value_set(
        EXPORTING iv_vset_key = iv_vset_key
        IMPORTING es_vset     = ls_vset ).
    ENDIF.

    CASE ls_vset-content_cat.
      WHEN /bobf/if_conf_c=>sc_content_nod.
        IF mo_conf->ms_last_node-node_key = ls_vset-content_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_vset-content_key
            IMPORTING es_node     = ls_node ).
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_content_act.
        IF mo_conf->ms_last_action-act_key = ls_vset-content_key.
          ls_act = mo_conf->ms_last_action.
        ELSE.
          mo_conf->get_act(
            EXPORTING iv_act_key = ls_vset-content_key
            IMPORTING es_action  = ls_act ).
        ENDIF.
        IF mo_conf->ms_last_node-node_key = ls_act-node_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_act-node_key
            IMPORTING es_node     = ls_node ).
        ENDIF.

      WHEN /bobf/if_conf_c=>sc_content_ass.
        IF mo_conf->ms_last_assoc-assoc_key = ls_vset-content_key.
          ls_assoc = mo_conf->ms_last_assoc.
        ELSE.
          mo_conf->get_assoc(
            EXPORTING iv_assoc_key = ls_vset-content_key
            IMPORTING es_assoc  = ls_assoc ).
        ENDIF.
        ls_node = ls_assoc-source_node->*.

      WHEN /bobf/if_conf_c=>sc_content_qry.
        IF mo_conf->ms_last_query-query_key = ls_vset-content_key.
          ls_query = mo_conf->ms_last_query.
        ELSE.
          mo_conf->get_query(
            EXPORTING iv_query_key = ls_vset-content_key
            IMPORTING es_query     = ls_query ).
        ENDIF.
        IF mo_conf->ms_last_node-node_key = ls_query-node_key.
          ls_node = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_query-node_key
            IMPORTING es_node     = ls_node ).
        ENDIF.
    ENDCASE.

* ____________________________________________________________________ *
* delegate call if necessary
    IF ls_node-delegation_class IS NOT INITIAL.
      TRY.
          lo_delegation = get_delegation( ls_node-node_key ).

          CREATE OBJECT lo_int_access
            EXPORTING
              io_bopf   = me
              io_conf   = mo_conf
              io_buffer = mo_buffer.
          lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
          lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
          lo_int_access->set_context( iv_read_allowed  = abap_true ).

          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          lo_delegation->retrieve_id_value_set(
            EXPORTING
              iv_vset_key              = iv_vset_key
              it_key                   = it_key
              iv_key_is_default        = iv_key_is_default
              it_selection_parameters  = it_selection_parameters
              is_query_options         = is_query_options
              io_read                  = lo_int_access
            IMPORTING
              et_key                   = et_key ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          lo_int_access->invalidate( ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

    ELSE.
* ____________________________________________________________________ *
* call implementation if existing
      IF ls_vset-value_set_class IS NOT INITIAL.

        TRY.
*         get node class
            READ TABLE mt_value_set_id
               WITH TABLE KEY vset_key = iv_vset_key
               INTO ls_vset_class.
            IF sy-subrc <> 0.
              ls_vset_class-vset_key = iv_vset_key.
              CREATE OBJECT ls_vset_class-class TYPE (ls_vset-value_set_class).
              INSERT ls_vset_class INTO TABLE mt_value_set_id.
            ENDIF.

            IF iv_key_is_default = abap_true.
              CREATE OBJECT lo_int_access TYPE /bobf/cl_frw_int_defaults
                EXPORTING
                  io_bopf   = me
                  io_conf   = mo_conf
                  io_buffer = mo_buffer.
            ELSE.
              CREATE OBJECT lo_int_access
                EXPORTING
                  io_bopf   = me
                  io_conf   = mo_conf
                  io_buffer = mo_buffer.
            ENDIF.
            lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
            lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
            lo_int_access->set_context( iv_read_allowed  = abap_true ).

            mo_conf->get_fieldmapping( IMPORTING et_fieldmapping = lt_fieldmapping ).
            READ TABLE lt_fieldmapping INTO ls_fieldmapping WITH KEY fieldname_ext
              COMPONENTS content_cat        = ls_vset-content_cat
                         content_key        = ls_vset-content_key
                         fieldname_ext_long = ls_vset-vset_esr_name.
            ls_context-attribute             = ls_fieldmapping-fieldname_int.
            ls_context-bo_key                = mo_conf->ms_obj-bo_key.
            ls_context-root_node_key         = mo_conf->ms_obj-root_node_key.
            ls_context-value_set_key         = iv_vset_key.
            ls_context-node_key              = ls_node-node_key.
            ls_context-act_key               = ls_act-act_key.
            ls_context-assoc_key             = ls_assoc-assoc_key.
            ls_context-query_key             = ls_query-query_key.

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_vset_class-class->retrieve_value_set(
              EXPORTING
                is_ctx                  = ls_context
                it_key                  = it_key
                io_read                 = lo_int_access
                io_query                = lo_int_access
                it_selection_parameters = it_selection_parameters
                is_query_options        = is_query_options
              CHANGING
                ct_key                  = et_key ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            lo_int_access->invalidate( ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
            DELETE mt_access_stack INDEX 1.

          CATCH cx_sy_dyn_call_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_vset = abap_true
              iv_key  = iv_vset_key ).
            lv_content_cat = TEXT-007.
            CREATE OBJECT lx_frw
              EXPORTING
                textid          = /bobf/cx_frw_core=>sc_no_instance
                previous        = lx_root
                mv_method_name  = 'RETRIEVE_VALUE_SET'
                mv_content_name = lv_content_name
                mv_content_cat  = lv_content_cat.
            set_configuration_error( lx_frw ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_vset
                                                                                iv_content_key   = ls_vset-content_key
                                                                                iv_content_class = ls_vset-value_set_class
                                                                                iv_node_key      = ls_vset-vset_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'RETRIEVE_VALUE_SET' ) ).
        ENDTRY.
      ENDIF.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~retrieve_property.

    DATA: ls_assoc               TYPE        /bobf/s_confro_assoc,
          lt_assoc               TYPE        /bobf/t_confro_assoc,
          ls_nodeconf            TYPE        /bobf/s_confro_node,
          lt_key                 TYPE        /bobf/t_frw_key,
          lt_key_lock            TYPE        /bobf/t_frw_key,
          ls_key                 TYPE        /bobf/s_frw_key,
          lt_failed_key          TYPE        /bobf/t_frw_key,
          lt_property_ncat       TYPE        /bobf/t_confro_property_d,
          lt_property_dyn        TYPE        /bobf/t_frw_property_k,
          lt_property_stat       TYPE        /bobf/t_frw_property_k,
          lt_property_sam        TYPE        /bobf/t_frw_property_k,
          ls_property            TYPE        /bobf/s_frw_property_k,
          lt_filtered_attributes TYPE        /bobf/t_frw_name,
          lt_lock_node           TYPE        /bobf/t_frw_lock_node,
          lo_message             TYPE REF TO /bobf/if_frw_message,
          lt_node_link           TYPE        /bobf/t_frw_node_key_link,
          ls_node_link           TYPE        /bobf/s_frw_node_key_link,
          lv_state               TYPE        /bobf/conf_state,
          lx_root                TYPE REF TO cx_root,
          lo_int_access          TYPE REF TO /bobf/cl_frw_int_access.

    FIELD-SYMBOLS:
      <ls_property> TYPE /bobf/s_frw_property_k.

    CLEAR: eo_message,
           eo_property.

    CHECK iv_check_services <> /bobf/if_conf_c=>sc_check_services_skip.
    CHECK it_key IS NOT INITIAL.

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_set(
           it_access_stack = mt_access_stack ) = abap_true.

* remember node for later notifications of association and property changes
    IF iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
      READ TABLE mt_node_properties_requested TRANSPORTING NO FIELDS
        WITH KEY key_sort COMPONENTS table_line = iv_node_key.
      IF sy-subrc <> 0.
        APPEND iv_node_key TO mt_node_properties_requested.
      ENDIF.
    ENDIF.

* check for delegation
    IF mo_conf->ms_last_node-node_key = iv_node_key.
      ls_nodeconf = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
         EXPORTING iv_node_key = iv_node_key
         IMPORTING es_node     = ls_nodeconf ).
    ENDIF.

    IF iv_key_is_default = abap_true.
      lv_state = /bobf/if_conf_c=>sc_state_default.
    ELSE.
      lv_state = /bobf/if_conf_c=>sc_state_current.
    ENDIF.

    lt_key = it_key.
    SORT lt_key.
    DELETE ADJACENT DUPLICATES FROM lt_key COMPARING key.
* using secondary key KEY_SORT is slower even if index already built up

* ____________________________________________________________________ *
* check authorization
    IF iv_key_is_default = abap_false
      AND iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
      " handle keys with no authorization like non-existing keys => just filter them out, don't set properties for them
      filter_unauthorised_prop_keys( EXPORTING iv_node_key = iv_node_key
                                     CHANGING  ct_key      = lt_key ).
      CHECK lt_key IS NOT INITIAL.
    ENDIF.

* ____________________________________________________________________ *
* delegate property call
    IF ls_nodeconf-delegation_class IS NOT INITIAL AND
       iv_check_services <> /bobf/if_conf_c=>sc_check_services_stat AND
       iv_check_services <> /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.

      eo_property = NEW /bobf/cl_frw_property( ).

      delegate_retrieve_property( EXPORTING iv_node_key                  = iv_node_key
                                            it_key                       = lt_key
                                            iv_key_is_default            = iv_key_is_default
                                            iv_node_property             = iv_node_property
                                            iv_node_attribute_property   = iv_node_attribute_property
                                            it_node_attribute            = it_node_attribute
                                            iv_assoc_property            = iv_assoc_property
                                            it_assoc                     = it_assoc
                                            iv_assoc_attribute_property  = iv_assoc_attribute_property
                                            iv_action_property           = iv_action_property
                                            it_action                    = it_action
                                            iv_action_attribute_property = iv_action_attribute_property
                                            iv_check_services            = iv_check_services
                                            io_property                  = eo_property
                                  IMPORTING et_failed_key                = lt_failed_key ).

      IF lt_failed_key IS NOT INITIAL.
        lt_key = FILTER #( lt_key EXCEPT IN lt_failed_key USING KEY key_sort WHERE key = key ).
      ENDIF.
      IF lt_key IS INITIAL.
        ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>access_stack_stack_check(
               it_access_stack = mt_access_stack ) = abap_true.
        RETURN.
      ENDIF.

    ENDIF.

* ____________________________________________________________________ *
* get dynamic properties
    IF ls_nodeconf-delegation_class IS INITIAL.
      IF iv_check_services = /bobf/if_conf_c=>sc_retrieve_property OR
         iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn.

        mo_conf->get_assoc(
         EXPORTING
           iv_node_key   = iv_node_key
           iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_property
           iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
         IMPORTING
           es_assoc      = ls_assoc ).
        IF ls_assoc IS INITIAL.
*       no property node defined
          ASSERT ID /bobf/frw CONDITION 0 = 1.             "#EC BOOL_OK
          ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>access_stack_stack_check(
                 it_access_stack = mt_access_stack ) = abap_true.
          RETURN.
        ENDIF.

        DATA(ls_property_parameter_r) = NEW /bobf/s_frw_c_property( all_node_property              = iv_node_property
                                                                    all_node_attribute_property    = iv_node_attribute_property
                                                                    node_attribute                 = it_node_attribute
                                                                    all_association_property       = iv_assoc_property
                                                                    association                    = it_assoc
                                                                    all_association_attribute_prop = iv_assoc_attribute_property
                                                                    all_action_property            = iv_action_property
                                                                    action                         = it_action
                                                                    all_action_attribute_property  = iv_action_attribute_property
                                                                    all_query_property             = iv_query_property
                                                                    query                          = it_query
                                                                    all_query_attribute_property   = iv_query_attribute_property
                                                                    all_subtree_property           = ls_nodeconf-subtree_property ).


        IF iv_node_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_node       TO lt_filtered_attributes.
        ENDIF.
        IF iv_node_attribute_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_node_attr  TO lt_filtered_attributes.
        ENDIF.
        IF it_node_attribute IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_node_attr      TO lt_filtered_attributes.
        ENDIF.
        IF iv_assoc_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_assoc      TO lt_filtered_attributes.
        ENDIF.
        IF iv_assoc_attribute_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_assoc_attr TO lt_filtered_attributes.
        ENDIF.
        IF it_assoc IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_association    TO lt_filtered_attributes.
        ENDIF.
        IF iv_action_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_act        TO lt_filtered_attributes.
        ENDIF.
        IF iv_action_attribute_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_act_attr   TO lt_filtered_attributes.
        ENDIF.
        IF it_action IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_action         TO lt_filtered_attributes.
        ENDIF.
        IF iv_query_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_query      TO lt_filtered_attributes.
        ENDIF.
        IF iv_query_attribute_property IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_qry_attr   TO lt_filtered_attributes.
        ENDIF.
        IF it_query IS NOT INITIAL.
          APPEND /bobf/if_conf_c=>sc_prop_param_query          TO lt_filtered_attributes.
        ENDIF.
        IF ls_nodeconf-subtree_property = abap_true.
          APPEND /bobf/if_conf_c=>sc_prop_param_all_subtree    TO lt_filtered_attributes.
        ENDIF.

        IF iv_key_is_default = abap_false.
          retrieve_by_association(
            EXPORTING
              iv_node_key            = iv_node_key
              it_key                 = lt_key
              iv_association         = ls_assoc-assoc_key
              is_parameters          = ls_property_parameter_r
              it_filtered_attributes = lt_filtered_attributes
              iv_state               = lv_state
              iv_buffer_only         = abap_false
              iv_fill_data           = abap_true
              iv_fill_failed_key     = abap_true
            IMPORTING
              et_data                = lt_property_dyn
              et_failed_key          = lt_failed_key
              eo_message             = eo_message ).
        ELSE.
*       calculate dynamic properties
          do_determinations_retrieve(
            EXPORTING
              iv_assoc_key           = ls_assoc-assoc_key
              it_key                 = lt_key
              iv_key_is_default      = abap_true
              is_parameters          = ls_property_parameter_r
              it_filtered_attributes = lt_filtered_attributes
              iv_state               = /bobf/if_conf_c=>sc_state_current
              iv_within_loading      = abap_false
            IMPORTING
              eo_message             = eo_message ).

*       read dynamic properties
          TRY.
              mo_buffer->retrieve_by_association(
                EXPORTING
                  iv_node_key            = iv_node_key
                  it_key                 = lt_key
                  iv_association         = ls_assoc-assoc_key
                  is_parameters          = ls_property_parameter_r
                  it_filtered_attributes = lt_filtered_attributes
                  iv_state               = lv_state
                  iv_buffer_only         = abap_true
                  iv_fill_data           = abap_true
                  iv_fill_failed_key     = abap_true
                IMPORTING
                  et_data                = lt_property_dyn
                  et_failed_key          = lt_failed_key ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.

        LOOP AT lt_property_dyn ASSIGNING FIELD-SYMBOL(<ls_property_dyn>).
          <ls_property_dyn>-source = /bobf/if_conf_c=>sc_property_source_dynamic.
        ENDLOOP.
* ____________________________________________________________________ *
*     delete keys which have failed
        IF iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
          IF lt_failed_key IS NOT INITIAL.
            lt_key = FILTER #( lt_key EXCEPT IN lt_failed_key USING KEY key_sort WHERE key = key ).
          ENDIF.
          IF lt_key IS INITIAL.
            ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>access_stack_stack_check(
                   it_access_stack = mt_access_stack ) = abap_true.
            RETURN.
          ENDIF.
        ENDIF.

* ____________________________________________________________________ *
*     delete read subtree properties (will be evaluated below)
        IF ls_nodeconf-subtree_property = abap_true.
          DELETE lt_property_dyn WHERE content_cat = /bobf/if_conf_c=>sc_content_subtree.
        ENDIF.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* evaluate subtree properties (only supported for root node)
    IF iv_key_is_default = abap_false AND
       ( ls_nodeconf-subtree_property_node_key IS NOT INITIAL OR
         ls_nodeconf-subtree_property = abap_true ) AND
      ( iv_check_services = /bobf/if_conf_c=>sc_retrieve_property OR
        iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn ).

      READ TABLE mt_node_properties_requested TRANSPORTING NO FIELDS
        WITH KEY key_sort COMPONENTS table_line = iv_node_key.
      IF sy-subrc <> 0.
        APPEND iv_node_key TO mt_node_properties_requested.
      ENDIF.

      retrieve_subtree_property( EXPORTING iv_node_key           = iv_node_key
                                           it_key                = lt_key
                                           iv_state              = lv_state
                                           iv_resolve_property   = abap_true
                                           iv_determine_property = abap_false
                                           iv_node_property      = iv_node_property
                                           iv_assoc_property     = iv_assoc_property
                                           it_assoc              = it_assoc
                                IMPORTING  et_property           = DATA(lt_property_subtree)
                                           eo_message            = lo_message ).

      LOOP AT lt_property_subtree ASSIGNING FIELD-SYMBOL(<ls_property_subtree>).
        <ls_property_subtree>-source = /bobf/if_conf_c=>sc_property_source_subtree.
      ENDLOOP.

      IF lt_property_dyn IS INITIAL.
        lt_property_dyn = lt_property_subtree.
      ELSE.
        INSERT LINES OF lt_property_subtree INTO lt_property_dyn INDEX 1.
      ENDIF.
    ENDIF.
* ____________________________________________________________________ *
* set status dependent properties
    IF iv_key_is_default            = abap_false AND
       ls_nodeconf-delegation_class  IS INITIAL  AND
       ( iv_check_services          = /bobf/if_conf_c=>sc_retrieve_property         OR
       iv_check_services            = /bobf/if_conf_c=>sc_check_services_stat_dyn ) AND
       mo_conf->ms_obj-status_class IS NOT INITIAL                                  AND
       ( iv_action_property         = abap_true                                     OR
       it_action                    IS NOT INITIAL ).

      CLEAR ls_assoc.
      IF ls_nodeconf-status_attributes    IS NOT BOUND OR
         ls_nodeconf-status_attributes->* IS INITIAL.
        mo_conf->get_assoc(
          EXPORTING
            iv_node_key   = ls_nodeconf-node_key
            iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
            iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
          IMPORTING
            es_assoc      = ls_assoc ).
      ENDIF.

      IF ( ls_nodeconf-status_attributes    IS BOUND         AND
           ls_nodeconf-status_attributes->* IS NOT INITIAL ) OR
           ls_assoc                         IS NOT INITIAL.

*     get status adapter
        IF mo_sam IS NOT BOUND.
          TRY.
              CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
                EXPORTING
                  iv_bo_key = mo_conf->ms_obj-bo_key.

            CATCH BEFORE UNWIND cx_sy_create_object_error INTO lx_root.
              set_application_error( NEW /bobf/cx_frw_core( previous       = lx_root
                                                            textid         = /bobf/cx_frw_core=>sc_no_instance
                                                            mv_classname   = mo_conf->ms_obj-status_class
                                                            mv_content_cat = CONV #( TEXT-004 ) ) ).
          ENDTRY.
          ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
        ENDIF.

        /bobf/cl_frw_int_access=>new_instance(
          EXPORTING
            io_bopf            = me
            io_conf            = mo_conf
            io_buffer          = mo_buffer
          RECEIVING
            eo_internal_access = lo_int_access
        ).

        lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
        lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
        lo_int_access->set_context( iv_read_allowed = abap_true ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
        INSERT lo_int_access INTO mt_access_stack INDEX 1.

        TRY.
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            mo_sam->get_properties( EXPORTING iv_node_key = iv_node_key
                                              it_key      = lt_key
                                              it_action   = it_action
                                              io_read     = lo_int_access
                                    IMPORTING et_property = lt_property_sam ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        lo_int_access->invalidate( ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.

        mo_conf->get_act(
          EXPORTING
            iv_node_key = iv_node_key
            iv_act_cat  = /bobf/if_conf_c=>sc_action_delete
          IMPORTING
            es_action   = DATA(ls_act_conf) ).

        CLEAR ls_property.
        LOOP AT lt_property_sam ASSIGNING <ls_property> WHERE
             property_name = /bobf/if_conf_c=>sc_property_name_enabled AND
             value         = abap_false AND
             content_cat   = /bobf/if_conf_c=>sc_content_act.

          IF <ls_property>-content_key EQ ls_act_conf-act_key.
            ls_property-parent_key    = <ls_property>-parent_key.
            ls_property-content_cat   = /bobf/if_conf_c=>sc_content_nod.
            ls_property-content_key   = iv_node_key.
            ls_property-value         = <ls_property>-value.
            ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable.
            ls_property-source          = /bobf/if_conf_c=>sc_property_source_sam.
            INSERT ls_property INTO lt_property_dyn INDEX 1.
          ELSE.
            <ls_property>-source = /bobf/if_conf_c=>sc_property_source_sam.
            INSERT <ls_property> INTO lt_property_dyn INDEX 1.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* set lock dependent properties of nodes and/or associations
    IF iv_key_is_default          = abap_false                            AND
       iv_check_services          = /bobf/if_conf_c=>sc_retrieve_property AND
       ( iv_node_property         = abap_true                             OR
       iv_node_attribute_property = abap_true                             OR
       it_node_attribute          IS NOT INITIAL                          OR
       iv_assoc_property          = abap_true                             OR
       it_assoc                   IS NOT INITIAL )                        AND
       mo_conf->ms_obj-no_lock    = abap_false                            AND
       ls_nodeconf-transient      = abap_false                            AND
       ls_nodeconf-object_model_cds_view_name IS INITIAL. " ...not for CDS generated BOs (Draft, Existing)...

      map_to_node(
        EXPORTING
          iv_node_key = iv_node_key
          it_key      = lt_key
        IMPORTING
          et_node     = DATA(lt_node) ).

      get_lockable_node(
        EXPORTING
          it_node      = lt_node
        IMPORTING
          et_node_link = lt_node_link
          eo_message   = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      LOOP AT lt_node_link INTO ls_node_link.
        ls_key-key = ls_node_link-target_key.
        APPEND ls_key TO lt_key_lock.
      ENDLOOP.

      IF lt_key_lock IS NOT INITIAL.
        SORT lt_key_lock BY key.
        DELETE ADJACENT DUPLICATES FROM lt_key_lock.

        mo_conf->get_assoc(
         EXPORTING
           iv_node_key   = ls_node_link-target_node
           iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_lock
           iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
         IMPORTING
           es_assoc      = ls_assoc ).

        retrieve_by_association(
          EXPORTING
            iv_node_key    = ls_node_link-target_node
            it_key         = lt_key_lock
            iv_association = ls_assoc-assoc_key
            iv_state       = lv_state
            iv_fill_data   = abap_true
          IMPORTING
            et_data        = lt_lock_node
            eo_message     = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        lt_key_lock = lt_key.

        LOOP AT lt_lock_node INTO DATA(ls_lock_node)
          WHERE edit_mode = /bobf/if_conf_c=>sc_edit_exclusive OR edit_mode = /bobf/if_conf_c=>sc_edit_optimistic.
          LOOP AT lt_node_link INTO ls_node_link
            WHERE target_node = ls_node_link-target_node
              AND target_key  = ls_lock_node-key.
*         Binary search can be used here as the table (LT_KEY) was sorted at the begiining of the method to eliminate duplicates
            READ TABLE lt_key_lock WITH KEY key = ls_node_link-source_key TRANSPORTING NO FIELDS BINARY SEARCH.
            IF sy-subrc = 0.
              DELETE lt_key_lock INDEX sy-tabix.
            ENDIF.
          ENDLOOP.
        ENDLOOP.

* _______________________________________________________________________________ *
*     not locked nodes: set property value to false, leading entry -> at first
        CLEAR ls_property.
        LOOP AT lt_key_lock INTO ls_key.
          IF iv_node_property           = abap_true OR
             iv_node_attribute_property = abap_true OR
             it_node_attribute IS NOT INITIAL.

            ls_property-parent_key    = ls_key-key.
            ls_property-content_cat   = /bobf/if_conf_c=>sc_content_nod.
            ls_property-content_key   = iv_node_key.
            ls_property-value         = abap_false.
            ls_property-source        = /bobf/if_conf_c=>sc_property_source_lock.
            ls_property-property_name = /bobf/if_conf_c=>sc_property_name_update_enable.
            INSERT ls_property INTO lt_property_dyn INDEX 1.
            ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable.
            INSERT ls_property INTO lt_property_dyn INDEX 1.
          ENDIF.

          IF iv_assoc_property = abap_true OR
             it_assoc IS NOT INITIAL.
            IF lt_assoc IS INITIAL.
              mo_conf->get_assoc_tab(
                IMPORTING
                  et_assoc           = lt_assoc ).
            ENDIF.
*         association properties
            ls_property-parent_key    = ls_key-key.
            ls_property-property_name = /bobf/if_conf_c=>sc_property_name_create_enable.
            ls_property-content_cat   = /bobf/if_conf_c=>sc_content_ass.
            ls_property-value         = abap_false.
            LOOP AT lt_assoc INTO ls_assoc
              WHERE source_node_key        = iv_node_key
                AND ( assoc_cat  = /bobf/if_conf_c=>sc_assoccat_specialization OR
                      assoc_cat  = /bobf/if_conf_c=>sc_assoccat_foreign_key OR
                      assoc_cat  = /bobf/if_conf_c=>sc_assoccat_foreign_key_r OR
                      assoc_cat  = /bobf/if_conf_c=>sc_assoccat_normal OR
                      assoc_type = /bobf/if_conf_c=>sc_assoctype_comp )
                AND target_node->lockable  = abap_false
                AND target_node->transient = abap_false. "#EC CI_SORTSEQ
              ls_property-content_key = ls_assoc-assoc_key.
              ls_property-source        = /bobf/if_conf_c=>sc_property_source_lock.
              INSERT ls_property INTO lt_property_dyn INDEX 1.
            ENDLOOP.
          ENDIF.
        ENDLOOP.
        CLEAR lt_key_lock.
      ENDIF.
    ENDIF.

    IF ls_nodeconf-delegation_class IS INITIAL.
* ____________________________________________________________________ *
*   get static properties
      IF lines( ls_nodeconf-node_cat->* ) = 1.
*     just one node category defined
        READ TABLE ls_nodeconf-node_cat->* INDEX 1 INTO DATA(ls_node_cat_c).
        mo_conf->get_property( EXPORTING iv_node_cat_key = ls_node_cat_c-node_cat_key
                               IMPORTING et_property     = lt_property_ncat ).
        IF lt_property_ncat IS NOT INITIAL.
          restrict_property(
            EXPORTING
              iv_node_property             = iv_node_property
              iv_node_attribute_property   = iv_node_attribute_property
              it_node_attribute            = it_node_attribute
              iv_assoc_property            = iv_assoc_property
              it_assoc                     = it_assoc
              iv_assoc_attribute_property  = iv_assoc_attribute_property
              iv_action_property           = iv_action_property
              it_action                    = it_action
              iv_action_attribute_property = iv_action_attribute_property
              iv_query_property            = iv_query_property
              it_query                     = it_query
              iv_query_attribute_property  = iv_query_attribute_property
            CHANGING
              ct_property_data             = lt_property_ncat ).

*       create entries for each instance
          IF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn
          OR iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre
          OR iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
*            lt_property_stat = value #( for ls_key in lt_key ( for ls_property_ncat in lt_property_ncat ( ) ) ).
            LOOP AT lt_key INTO ls_key.
              lt_property_stat = VALUE #( BASE lt_property_stat
                                          FOR <ls_property_ncat> IN lt_property_ncat
                                              ( node_data  = <ls_property_ncat>
                                                key        = /bobf/cl_frw_factory=>get_new_transient_key( )
                                                parent_key = ls_key-key
                                                source     = /bobf/if_conf_c=>sc_property_source_static ) ).
            ENDLOOP.
          ELSEIF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat.
            LOOP AT lt_key INTO ls_key.
              lt_property_stat = VALUE #( BASE lt_property_stat
                                          FOR <ls_property_ncat> IN lt_property_ncat WHERE ( final = abap_true ) "#EC CI_SORTSEQ
                                              ( node_data  = <ls_property_ncat>
                                                key        = /bobf/cl_frw_factory=>get_new_transient_key( )
                                                parent_key = ls_key-key
                                                source     = /bobf/if_conf_c=>sc_property_source_static ) ).
            ENDLOOP.
          ENDIF.

        ENDIF.
      ELSE.

*     evaluate node categories
        TRY.
            mo_buffer->retrieve( EXPORTING iv_node_key    = iv_node_key
                                           it_key         = lt_key
                                           iv_state       = lv_state
                                           iv_fill_data   = abap_false
                                           iv_buffer_only = abap_true
                                IMPORTING  et_node_cat    = DATA(lt_node_cat) ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        LOOP AT lt_node_cat INTO DATA(ls_node_cat).
          CHECK ls_node_cat-node_cat_key IS NOT INITIAL.

          AT NEW node_cat_key.
            mo_conf->get_property(
              EXPORTING
                iv_node_cat_key = ls_node_cat-node_cat_key
              IMPORTING
                et_property     = lt_property_ncat ).
            IF lt_property_ncat IS NOT INITIAL.
              restrict_property(
               EXPORTING
                 iv_node_property             = iv_node_property
                 iv_node_attribute_property   = iv_node_attribute_property
                 it_node_attribute            = it_node_attribute
                 iv_assoc_property            = iv_assoc_property
                 it_assoc                     = it_assoc
                 iv_assoc_attribute_property  = iv_assoc_attribute_property
                 iv_action_property           = iv_action_property
                 it_action                    = it_action
                 iv_action_attribute_property = iv_action_attribute_property
                 iv_query_property            = iv_query_property
                 it_query                     = it_query
                 iv_query_attribute_property  = iv_query_attribute_property
               CHANGING
                 ct_property_data             = lt_property_ncat ).
            ENDIF.
          ENDAT.

          IF lt_property_ncat IS NOT INITIAL.

            IF iv_check_services  = /bobf/if_conf_c=>sc_check_services_stat_dyn OR
                iv_check_services = /bobf/if_conf_c=>sc_retrieve_property.
              LOOP AT lt_property_ncat INTO ls_property-node_data.
                ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
                ls_property-parent_key = ls_node_cat-key.
                ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
                APPEND ls_property TO lt_property_stat.
              ENDLOOP.
            ELSEIF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat OR
                   iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
              LOOP AT lt_property_ncat INTO ls_property-node_data WHERE
                  final = abap_true.                    "#EC CI_SORTSEQ
                ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
                ls_property-parent_key = ls_node_cat-key.
                ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
                APPEND ls_property TO lt_property_stat.
              ENDLOOP.
            ENDIF.

          ENDIF.
        ENDLOOP.
      ENDIF.

* ____________________________________________________________________ *
*   get static proxy properties
      IF iv_check_services <> /bobf/if_conf_c=>sc_retrieve_property.
        mo_conf->get_property_prx(
          EXPORTING
            iv_node_key  = iv_node_key
          IMPORTING
            et_property  = lt_property_ncat ).
*     create entries for each instance
        IF lt_property_ncat IS NOT INITIAL.
          restrict_property(
            EXPORTING
              iv_node_property             = iv_node_property
              iv_node_attribute_property   = iv_node_attribute_property
              it_node_attribute            = it_node_attribute
              iv_assoc_property            = iv_assoc_property
              it_assoc                     = it_assoc
              iv_assoc_attribute_property  = iv_assoc_attribute_property
              iv_action_property           = iv_action_property
              it_action                    = it_action
              iv_action_attribute_property = iv_action_attribute_property
              iv_query_property            = iv_query_property
              it_query                     = it_query
              iv_query_attribute_property  = iv_query_attribute_property
            CHANGING
              ct_property_data             = lt_property_ncat ).

          LOOP AT lt_key INTO ls_key.
            IF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn  OR
               iv_check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
              LOOP AT lt_property_ncat INTO ls_property-node_data.
                ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
                ls_property-parent_key = ls_key-key.
                ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
                APPEND ls_property TO lt_property_stat.
              ENDLOOP.
            ELSEIF iv_check_services = /bobf/if_conf_c=>sc_check_services_stat.
              LOOP AT lt_property_ncat INTO ls_property-node_data WHERE
                  final = abap_true.                    "#EC CI_SORTSEQ
                ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
                ls_property-parent_key = ls_key-key.
                ls_property-source     = /bobf/if_conf_c=>sc_property_source_static.
                APPEND ls_property TO lt_property_stat.
              ENDLOOP.
            ENDIF.
          ENDLOOP.

        ENDIF.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* set authority dependent properties
    IF iv_key_is_default = abap_false AND
       iv_check_services          = /bobf/if_conf_c=>sc_retrieve_property AND
       ( iv_action_property         = abap_true OR
         it_action                    IS NOT INITIAL ).

      mo_authority_handler->get_action_properties( EXPORTING iv_node_key     = iv_node_key
                                                             it_key          = lt_key
                                                             it_action       = it_action
                                                             io_bopf         = me
                                                             io_buffer       = mo_buffer
                                                   IMPORTING et_property     = DATA(lt_property_auth_action)
                                                   CHANGING  ct_access_stack = mt_access_stack ).

      LOOP AT lt_property_auth_action ASSIGNING <ls_property> WHERE
           property_name = /bobf/if_conf_c=>sc_property_name_enabled AND
           value         = abap_false AND
           content_cat   = /bobf/if_conf_c=>sc_content_act.
        <ls_property>-source = /bobf/if_conf_c=>sc_property_source_authority.
        INSERT <ls_property> INTO lt_property_dyn INDEX 1.
      ENDLOOP.

    ENDIF.

    IF iv_key_is_default = abap_false AND
         iv_check_services = /bobf/if_conf_c=>sc_retrieve_property AND
         iv_node_property = abap_true.

      mo_authority_handler->get_node_properties( EXPORTING iv_node_key     = iv_node_key
                                                           it_key          = lt_key
                                                           io_bopf         = me
                                                           io_buffer       = mo_buffer
                                                 IMPORTING et_property     = DATA(lt_property_auth_node)
                                                 CHANGING  ct_access_stack = mt_access_stack ).

      LOOP AT lt_property_auth_node ASSIGNING <ls_property>.
        <ls_property>-source = /bobf/if_conf_c=>sc_property_source_authority.
        INSERT <ls_property> INTO lt_property_dyn INDEX 1.
      ENDLOOP.

    ENDIF.

    IF iv_key_is_default = abap_false AND
       iv_check_services = /bobf/if_conf_c=>sc_retrieve_property AND
       ( iv_assoc_property = abap_true OR
         it_assoc IS NOT INITIAL ).

      mo_authority_handler->get_association_properties( EXPORTING iv_node_key    = iv_node_key
                                                                  it_key         = lt_key
                                                                  it_association = it_assoc
                                                        IMPORTING et_property    = DATA(lt_property_auth_assoc) ).

      LOOP AT lt_property_auth_assoc ASSIGNING <ls_property>.
        <ls_property>-source = /bobf/if_conf_c=>sc_property_source_authority.
        INSERT <ls_property> INTO lt_property_dyn INDEX 1.
      ENDLOOP.

    ENDIF.

* ____________________________________________________________________ *
* combine properties


**   For rap Bos fix bug that dynamic overwrites static final
**   put static final in front of dynamic
    IF mo_conf->ms_obj-is_rap_bo = abap_true.
      DATA lt_property_stat_final TYPE /bobf/t_frw_property_k.
      LOOP AT lt_property_stat ASSIGNING FIELD-SYMBOL(<stat_prop>) WHERE final EQ abap_true.
        INSERT <stat_prop> INTO TABLE lt_property_stat_final.
      ENDLOOP.
      INSERT LINES OF lt_property_stat_final INTO lt_property_dyn INDEX 1.
    ENDIF.


* dynamic overwrite static properties  -> append static at the end
*   sort and delete
*   keeping sequence stable 1. UNLOCKED/SAM, 2. Dynamic, 3. static, 4. DO
    IF lt_property_dyn IS INITIAL.
      lt_property_dyn = lt_property_stat.
    ELSE.
      APPEND LINES OF lt_property_stat TO lt_property_dyn.
    ENDIF.

    IF eo_property IS BOUND.
      eo_property->get_property( IMPORTING et_property = DATA(lt_property_do) ).
      APPEND LINES OF lt_property_do TO lt_property_dyn.
      CLEAR eo_property.
    ENDIF.

    IF lt_property_dyn IS INITIAL.
      ASSERT ID /bobf/frw_error CONDITION
         /bobf/cl_tool_assert=>access_stack_stack_check(
             it_access_stack = mt_access_stack ) = abap_true.
      RETURN.
    ENDIF.

    SORT lt_property_dyn
      STABLE BY content_cat parent_key property_name content_key attribute_name.
    DELETE ADJACENT DUPLICATES FROM lt_property_dyn
      COMPARING content_cat parent_key property_name content_key attribute_name.

    " Finally overwrite the DELETE property for draft ROOT node instances
    IF iv_node_property = abap_true.
      IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft AND iv_node_key = mo_conf->ms_obj-root_node_key.
        mo_conf->get_act( iv_node_key = iv_node_key  iv_act_annotation = /bobf/if_conf_c=>sc_act_anno_draft_discard ).
        IF mo_conf->ms_last_action IS NOT INITIAL AND /bobf/cl_tool_switch=>is_switch_on( /bobf/cl_tool_switch=>gc_switch_id-rap_draft_modify_del_disabled ).
          " Disable DELETE, action DISCARD will do the job
          DATA(lv_prop_delete_value_src) = abap_true.
          DATA(lv_prop_delete_value_trg) = abap_false.
        ELSE.
          " To make draft instances always 'delete enabled', independent of the CDS annotation / property determination
          lv_prop_delete_value_src       = abap_false.
          lv_prop_delete_value_trg       = abap_true.
        ENDIF.
        DATA(lt_property_delete) = VALUE /bobf/t_frw_property_k(
                                     FOR <property> IN lt_property_dyn
                                         WHERE ( content_cat   = /bobf/if_conf_c=>sc_content_nod AND
                                                 property_name = /bobf/if_conf_c=>sc_property_name_delete_enable AND
                                                 content_key   = iv_node_key AND
                                                 value         = lv_prop_delete_value_src )
                                     ( <property> ) ).
        IF lt_property_delete IS NOT INITIAL.
          " Check whether there are any draft instances. If there are, overwrite the property

          mo_lib_draft_active->separate_keys( EXPORTING iv_node_key  = iv_node_key
                                                        it_key       = CORRESPONDING #( lt_property_delete MAPPING key = parent_key )
                                              IMPORTING et_draft_key = DATA(lt_draft_key_delete) ).
          LOOP AT lt_draft_key_delete INTO DATA(ls_draft_key_delete).
            READ TABLE lt_property_dyn BINARY SEARCH ASSIGNING <ls_property> WITH KEY content_cat   = /bobf/if_conf_c=>sc_content_nod
                                                                                      parent_key    = ls_draft_key_delete-key
                                                                                      property_name = /bobf/if_conf_c=>sc_property_name_delete_enable
                                                                                      content_key   = iv_node_key.
            <ls_property>-value = lv_prop_delete_value_trg.
          ENDLOOP.
        ENDIF.
      ENDIF.
    ENDIF.

    eo_property = NEW /bobf/cl_frw_property( lt_property_dyn ).

    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>access_stack_stack_check(
           it_access_stack = mt_access_stack ) = abap_true.

  ENDMETHOD.


  METHOD /bobf/if_frw_service_layer~rollback_to_sync_point.

    DATA:
      lt_key    TYPE        /bobf/t_frw_key,
      lo_change TYPE REF TO /bobf/cl_frw_change.

    CLEAR eo_change.
    TRY.
        " get changes done so far
        mo_buffer->get_root_keys( IMPORTING et_root_key = lt_key ).

        lo_change ?= /bobf/cl_frw_factory=>get_change( ).

        mo_buffer->compare_states(
            iv_node_key      = mo_conf->ms_obj-root_node_key
            it_key           = lt_key
            iv_state_current = /bobf/if_conf_c=>sc_state_database
            iv_state_before  = /bobf/if_conf_c=>sc_state_current
            iv_incl_subtree  = abap_true
            io_change        = lo_change ).

        " perform determinations 'cleanup'
        " on all changes done between the last and the current sync point
        do_determinations(
            iv_exectime   = /bobf/if_conf_c=>sc_time_cleanup
            io_change     = lo_change
            iv_keep_cache = abap_true ).

      CATCH BEFORE UNWIND /bobf/cx_frw INTO DATA(lx_frw).
        RAISE SHORTDUMP lx_frw.
    ENDTRY.

  ENDMETHOD.


  METHOD /bobf/if_tra_clone~clone.
    DATA lo_buf        TYPE REF TO /bobf/if_tra_clone.
    DATA lo_bopf_clone TYPE REF TO /bobf/cl_frw.
    SYSTEM-CALL OBJMGR CLONE me TO eo_clone.
    TRY.
        lo_bopf_clone ?= eo_clone.
        lo_buf  ?= lo_bopf_clone->mo_buffer.
        lo_bopf_clone->mo_buffer ?= lo_buf->clone( ).
        lo_bopf_clone->mo_lock_manager = /bobf/cl_frw_lock_manager=>create( lo_bopf_clone ).
      CATCH BEFORE UNWIND /bobf/cx_frw INTO DATA(lx).
        RAISE SHORTDUMP lx.
    ENDTRY.
  ENDMETHOD.


  METHOD /bobf/if_tra_clone~destroy_clone.
    CAST /bobf/if_tra_clone( mo_buffer )->destroy_clone( ).
  ENDMETHOD.


  METHOD /bobf/if_tra_clone~restore_from_clone.
    DATA lo_buffer TYPE REF TO /bobf/if_frw_buffer .
    lo_buffer = CAST /bobf/cl_frw( io_clone )->mo_buffer.
    CAST /bobf/if_tra_clone( lo_buffer )->restore_from_clone( ).
    ro_bopf = io_clone.
    /bobf/cl_frw_factory=>replace_bopf( iv_bo_key   = mo_conf->ms_obj-bo_key
                                        io_new_bopf = ro_bopf ).
  ENDMETHOD.


  METHOD add_messages.

    DATA: lt_change   TYPE /bobf/t_frw_node,
          ls_change   TYPE /bobf/s_frw_node,
          lt_key      TYPE /bobf/t_frw_key,
          ls_key      TYPE /bobf/s_frw_key,
          lt_message  TYPE /bobf/t_frw_message_k,
          ls_message  TYPE /bobf/s_frw_message_k,
          lo_message  TYPE REF TO /bobf/cl_frw_message,
          lo_message2 TYPE REF TO /bobf/if_frw_message,
          ls_nodeconf TYPE /bobf/s_confro_node,
          ls_context  TYPE /bobf/s_frw_runtime_context.

    CHECK io_change IS BOUND.
    io_change->get_changes(
      EXPORTING
        iv_change_mode  = /bobf/if_frw_c=>sc_modify_create
      IMPORTING
        et_changed_node = lt_change ).

    LOOP AT lt_change INTO ls_change.
      ls_key-key = ls_change-key.
      INSERT ls_key INTO TABLE lt_key.

      AT END OF node.
        mo_conf->get_node(
          EXPORTING iv_node_key = ls_change-node
          IMPORTING es_node     = ls_nodeconf ).

        IF ls_nodeconf-node_type = /bobf/if_conf_c=>sc_node_type_message.
*        it's a message node change
          retrieve(
            EXPORTING
              iv_node_key    = ls_change-node
              it_key         = lt_key
              iv_state       = /bobf/if_conf_c=>sc_state_current
              iv_fill_data   = abap_true
            IMPORTING
              eo_message     = lo_message2
              et_data        = lt_message ).

          IF lo_message IS NOT BOUND.
            lo_message ?= /bobf/cl_frw_factory=>get_message( ).
          ENDIF.
          lo_message->/bobf/if_frw_message~add( lo_message2 ).
          LOOP AT lt_message INTO ls_message.
            lo_message->/bobf/if_frw_message~add_cm( ls_message-message ).
          ENDLOOP.
        ENDIF.
        CLEAR lt_key.
      ENDAT.
    ENDLOOP.

    IF lo_message IS BOUND.
      ls_context-consistency = abap_true.
      lo_message->set_context( ls_context ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = co_message ).
    ENDIF.

  ENDMETHOD.


  METHOD add_notifs_for_resolve_assoc.

    DATA:
      lt_target_key TYPE /bobf/t_frw_key,
      lo_message    TYPE REF TO /bobf/if_frw_message.

    ASSIGN ir_assoc->* TO FIELD-SYMBOL(<ls_assoc>).
    retrieve_by_association( EXPORTING iv_node_key    = <ls_assoc>-target_node_key
                                       it_key         = it_source_key
                                       iv_association = iv_resolve_assoc_key
                                       iv_state       = iv_state
                             IMPORTING eo_message     = lo_message
                                       et_target_key  = lt_target_key ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = co_message ).

    ct_content_change = VALUE #( BASE ct_content_change
                                 FOR wa_key IN lt_target_key
                                     ( key         = wa_key-key
                                       content_key = <ls_assoc>-assoc_key
                                       node_key    = <ls_assoc>-source_node_key
                                       change_mode = /bobf/if_frw_c=>sc_modify_association ) ).

  ENDMETHOD.


  METHOD add_opcode_trigger_to_change.
    DATA: lt_creates TYPE /bobf/if_frw_draft_active_diff=>tt_key_changes.
    DATA: lt_updates TYPE /bobf/if_frw_draft_active_diff=>tt_key_changes.
    DATA: lt_deletes TYPE /bobf/if_frw_draft_active_diff=>tt_key_changes.

    DATA(lo_int_access) = /bobf/cl_frw_int_access=>new_instance( io_bopf   = me
                                                                 io_conf   = mo_conf
                                                                 io_buffer = mo_buffer ).
    lo_int_access->mv_valid_if_read = abap_true.
    lo_int_access->mv_current_state = /bobf/if_conf_c=>sc_state_current.

    mo_dra_act_diff->get_draft_changes(  EXPORTING it_draft_root_keys = it_check_key
                                                   io_buffer_reader   = lo_int_access
                                         IMPORTING et_draft_changes   = DATA(lt_changed_keys) ).

    lt_creates = FILTER #( lt_changed_keys USING KEY opcode WHERE draftentityoperationcode = if_draft_constants=>co_operation_code-created ).
    lt_updates = FILTER #( lt_changed_keys USING KEY opcode WHERE draftentityoperationcode = if_draft_constants=>co_operation_code-updated ).
    lt_deletes = FILTER #( lt_changed_keys USING KEY opcode WHERE draftentityoperationcode = if_draft_constants=>co_operation_code-deleted ).

    io_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_create
                           it_node        = CORRESPONDING #( lt_creates MAPPING key = key node = node_key ) ).
    io_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_update
                           it_node        = CORRESPONDING #( lt_updates MAPPING key = key node = node_key ) ).
    io_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete
                           it_node        = CORRESPONDING #( lt_deletes MAPPING key = key node = node_key ) ).
  ENDMETHOD.


  METHOD add_trigger_condition.

    TYPES: BEGIN OF ty_stack,
             stack    TYPE i,
             node_key TYPE /bobf/obm_node_key,
             key      TYPE /bobf/t_frw_key,
           END OF ty_stack,
           tt_stack TYPE STANDARD TABLE OF ty_stack.

    DATA: ls_group         TYPE /bobf/s_frw_group,
          ls_groupconf     TYPE /bobf/s_confro_group,
          lt_comp          TYPE /bobf/t_confro_assoc2,
          ls_comp          TYPE /bobf/s_confro_assoc2,
          lt_stack         TYPE tt_stack,
          ls_stack         TYPE ty_stack,
          ls_stack_new     TYPE ty_stack,
          lv_current_stack TYPE i,
          ls_key           TYPE /bobf/s_frw_key.


    mo_conf->get_assoc_tab( IMPORTING et_comp = lt_comp ).

    " performance optimization: iterate/navigate only on group instances having validation trigger [internal incident 1870011620, 2018]...
    mo_conf->get_group_tab( IMPORTING et_group = DATA(lt_group_w_val_trig) ).
    DELETE lt_group_w_val_trig WHERE val_trigger->* IS INITIAL.
    DATA(lt_group_w_val_trig_instance) = FILTER #( it_group IN lt_group_w_val_trig USING KEY group_key WHERE group_key = group_key ).

    LOOP AT lt_group_w_val_trig_instance INTO ls_group.

      ls_key-key = ls_group-key.
      APPEND ls_key TO ls_stack-key.

      AT END OF group_key.
        ls_groupconf = lt_group_w_val_trig[ KEY group_key group_key = ls_group-group_key ].

        IF ls_groupconf-node_key IS INITIAL.
          ls_groupconf-node_key = mo_conf->ms_obj-root_node_key.
        ENDIF.

*     check whether the group node has to be added as check trigger as well
        READ TABLE ls_groupconf-val_trigger->* TRANSPORTING NO FIELDS
          WITH KEY table_line = ls_groupconf-node_key.
        IF sy-subrc = 0.
          io_change->add_change(
            EXPORTING
              iv_change_mode = /bobf/if_frw_c=>sc_modify_check
              iv_node_key    = ls_groupconf-node_key
              it_key         = ls_stack-key ).
        ENDIF.

*     build stack
        lv_current_stack  = 1.
        ls_stack-stack    = 1.
        ls_stack-node_key = ls_groupconf-node_key.
        APPEND ls_stack TO lt_stack.

        DO.
          LOOP AT lt_stack INTO ls_stack
            WHERE stack = lv_current_stack.

            LOOP AT lt_comp INTO ls_comp
              WHERE source_node_key = ls_stack-node_key.

              CHECK ls_comp-target_node->check_trigger          = abap_true
                 OR ls_comp-target_node->check_trigger_subnodes = abap_true.

*           navigate composition
              retrieve_by_association(
                EXPORTING
                  iv_node_key                 = ls_stack-node_key
                  it_key                      = ls_stack-key
                  iv_association              = ls_comp-assoc_key
                  iv_state                    = /bobf/if_conf_c=>sc_state_current
                IMPORTING
                  et_target_key               = ls_stack_new-key ).

              IF ls_stack_new-key IS NOT INITIAL.
                ls_stack_new-node_key = ls_comp-target_node_key.
                ls_stack_new-stack    = ls_stack-stack + 1.
                APPEND ls_stack_new TO lt_stack.

*             add trigger for this node to the change object
                READ TABLE ls_groupconf-val_trigger->* TRANSPORTING NO FIELDS
                  WITH KEY table_line = ls_comp-target_node_key.
                IF sy-subrc = 0.
                  io_change->add_change(
                    EXPORTING
                      iv_change_mode = /bobf/if_frw_c=>sc_modify_check
                      iv_node_key    = ls_comp-target_node_key
                      it_key         = ls_stack_new-key ).
                ENDIF.
              ENDIF.
            ENDLOOP.
          ENDLOOP.

          IF sy-subrc = 4. " no nodes exist in this level
            EXIT.
          ENDIF.
          lv_current_stack = lv_current_stack + 1.
        ENDDO.

        CLEAR: lt_stack, ls_stack.
      ENDAT.

    ENDLOOP.

  ENDMETHOD.


  METHOD after_loading.

    DATA: lt_loaded_node_keyload TYPE /bobf/t_frw_node,
          ls_node                TYPE /bobf/s_frw_node,
          lt_loaded_key          TYPE /bobf/t_frw_key,
          ls_key                 TYPE /bobf/s_frw_key,
          lo_change              TYPE REF TO /bobf/cl_frw_change,
          lo_change_del          TYPE REF TO /bobf/cl_frw_change,
          lt_node_transfer       TYPE /bobf/t_frw_node,
          lt_node_deleted        TYPE /bobf/t_frw_node,
          lt_node_tmp            TYPE /bobf/t_frw_node,
          ls_conf_node           TYPE /bobf/s_confro_node,
          ls_sync_point          TYPE ty_sync_point,
          lx_root                TYPE REF TO cx_root,
          ls_obj                 TYPE /bobf/s_confro_obj.

    CLEAR: eo_message,
           et_failed_node,
           et_loaded_node.

    IF iv_within_loading = abap_false AND
       ( io_change->has_changes( /bobf/if_frw_c=>sc_modify_load )              = abap_true OR
         io_change->has_changes( /bobf/if_frw_c=>sc_modify_reload_int )        = abap_true OR
         io_change->has_changes( /bobf/if_frw_c=>sc_modify_reload_int_delete ) = abap_true OR
         ( mo_conf->ms_obj-has_authority_dets                           = abap_true AND
           io_change->has_changes( /bobf/if_frw_c=>sc_modify_load_key ) = abap_true ) ).

      do_determinations(
        EXPORTING
          iv_exectime   = /bobf/if_conf_c=>sc_time_after_loading
          iv_load_state = iv_load_state
          io_change     = io_change
        IMPORTING
          eo_message    = eo_message
          et_failed     = et_failed_node ).

      io_change->get_changes(
        EXPORTING
          iv_change_mode  = /bobf/if_frw_c=>sc_modify_load
        IMPORTING
          et_changed_node = et_loaded_node ).

      IF et_failed_node IS NOT INITIAL.

        unlock_lockable_nodes( et_failed_node ). "  CSN: 0120061532 291236 2014, 1486627 2014

*      unload failed objects
        TRY.
            mo_buffer->delete_state(
              EXPORTING
                it_node         = et_failed_node
                iv_incl_subtree = abap_false
                iv_state        = iv_load_state ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        IF mv_modifying_transaction = abap_true.
          LOOP AT et_loaded_node INTO ls_node.
            READ TABLE et_failed_node
              WITH KEY node = ls_node-node
                       key  = ls_node-key
              TRANSPORTING NO FIELDS.
            CHECK sy-subrc = 0.
            DELETE et_loaded_node.
          ENDLOOP.
        ENDIF.
      ENDIF.

*    transfer current state to other states for loaded nodes
      IF et_loaded_node IS NOT INITIAL AND
          mv_modifying_transaction = abap_true.

        IF iv_load_state <> /bobf/if_conf_c=>sc_state_current.
*        Make sure only to transfer instances that are not deleted in the target state
          lt_node_transfer = et_loaded_node.

          mo_conf->get_bo(
          IMPORTING
            es_obj = ls_obj ).

          IF ls_obj-delete_loads_data = abap_false.
            lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
            LOOP AT et_loaded_node INTO ls_node.
              AT NEW node.
                mo_conf->get_node(
                  EXPORTING
                    iv_node_key = ls_node-node
                  IMPORTING
                    es_node     = ls_conf_node ).
              ENDAT.
              IF ls_conf_node-transient = abap_false.
                ls_key-key = ls_node-key.
                INSERT ls_key INTO TABLE lt_loaded_key.
              ENDIF.
              AT END OF node.
                IF ls_conf_node-transient = abap_false.
                  TRY.
                      mo_buffer->compare_states(
                        EXPORTING
                          iv_node_key      = ls_node-node
                          it_key           = lt_loaded_key
                          iv_state_current = /bobf/if_conf_c=>sc_state_current
                          iv_state_before  = iv_load_state
                          io_change        = lo_change_del ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.
                ENDIF.
                CLEAR lt_loaded_key.
              ENDAT.
            ENDLOOP.
            lo_change_del->get_changes(
                 EXPORTING
                   iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                 IMPORTING
                   et_changed_node = lt_node_deleted ).
            LOOP AT lt_node_deleted INTO ls_node.
              DELETE lt_node_transfer WHERE table_line = ls_node.
            ENDLOOP.
          ENDIF.

          TRY.
              mo_buffer->transfer_state(
                EXPORTING
                  it_node         = lt_node_transfer
                  iv_incl_subtree = abap_false
                  iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_current ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

        IF iv_load_state <> /bobf/if_conf_c=>sc_state_database.
*        No check for deleted instances necessary as they cannot be deleted in DB state
          TRY.
              mo_buffer->transfer_state(
                EXPORTING
                  it_node         = et_loaded_node
                  iv_incl_subtree = abap_false
                  iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_database ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

        IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_determined AND
           mo_conf->ms_obj-last_det_state_not_relevant = abap_false.
          lt_node_transfer = et_loaded_node.
          IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
            lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
            CLEAR lt_node_tmp.
            LOOP AT lt_node_deleted INTO ls_node.
              ls_key-key = ls_node-key.
              INSERT ls_key INTO TABLE lt_loaded_key.
              AT END OF node.
                TRY.
                    mo_buffer->compare_states(
                      EXPORTING
                        iv_node_key      = ls_node-node
                        it_key           = lt_loaded_key
                        iv_state_current = /bobf/if_conf_c=>sc_state_last_determined
                        iv_state_before  = iv_load_state
                        io_change        = lo_change_del ).
                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.
                CLEAR lt_loaded_key.
              ENDAT.
            ENDLOOP.
            lo_change_del->get_changes(
                 EXPORTING
                   iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                 IMPORTING
                   et_changed_node = lt_node_tmp ).
            LOOP AT lt_node_tmp INTO ls_node.
              DELETE lt_node_transfer WHERE table_line = ls_node.
            ENDLOOP.
          ENDIF.

          TRY.
              mo_buffer->transfer_state(
                EXPORTING
                  it_node         = lt_node_transfer
                  iv_incl_subtree = abap_false
                  iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_last_determined ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

        IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_validated AND
           mo_conf->ms_obj-last_val_state_not_relevant = abap_false.
          lt_node_transfer = et_loaded_node.
          IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
            lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
            CLEAR lt_node_tmp.
            LOOP AT lt_node_deleted INTO ls_node.
              ls_key-key = ls_node-key.
              INSERT ls_key INTO TABLE lt_loaded_key.
              AT END OF node.
                TRY.
                    mo_buffer->compare_states(
                      EXPORTING
                        iv_node_key      = ls_node-node
                        it_key           = lt_loaded_key
                        iv_state_current = /bobf/if_conf_c=>sc_state_last_validated
                        iv_state_before  = iv_load_state
                        io_change        = lo_change_del ).
                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.
                CLEAR lt_loaded_key.
              ENDAT.
            ENDLOOP.
            lo_change_del->get_changes(
                 EXPORTING
                   iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                 IMPORTING
                   et_changed_node = lt_node_tmp ).
            LOOP AT lt_node_tmp INTO ls_node.
              DELETE lt_node_transfer WHERE table_line = ls_node.
            ENDLOOP.
          ENDIF.
          TRY.
              mo_buffer->transfer_state(
              EXPORTING
                it_node         = lt_node_transfer
                iv_incl_subtree = abap_false
                iv_state_source = iv_load_state
                iv_state_dest   = /bobf/if_conf_c=>sc_state_last_validated ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

        IF iv_load_state <> /bobf/if_conf_c=>sc_state_before_modification AND
            mv_before_modification_exists = abap_true.
          lt_node_transfer = et_loaded_node.
          IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
            lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
            CLEAR lt_node_tmp.
            LOOP AT lt_node_deleted INTO ls_node.
              ls_key-key = ls_node-key.
              INSERT ls_key INTO TABLE lt_loaded_key.
              AT END OF node.
                TRY.
                    mo_buffer->compare_states(
                      EXPORTING
                        iv_node_key      = ls_node-node
                        it_key           = lt_loaded_key
                        iv_state_current = /bobf/if_conf_c=>sc_state_before_modification
                        iv_state_before  = iv_load_state
                        io_change        = lo_change_del ).
                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.
                CLEAR lt_loaded_key.
              ENDAT.
            ENDLOOP.
            lo_change_del->get_changes(
                 EXPORTING
                   iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                 IMPORTING
                   et_changed_node = lt_node_tmp ).
            LOOP AT lt_node_tmp INTO ls_node.
              DELETE lt_node_transfer WHERE table_line = ls_node.
            ENDLOOP.
          ENDIF.

          TRY.
              mo_buffer->transfer_state(
                EXPORTING
                  it_node         = lt_node_transfer
                  iv_incl_subtree = abap_false
                  iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_before_modification ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

      ENDIF.
      lo_change ?= io_change.
      lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_load ).
    ENDIF.

*  transfer current state to database state for loaded keys
    IF mv_modifying_transaction = abap_true.
      io_change->get_changes(
        EXPORTING
          iv_change_mode  = /bobf/if_frw_c=>sc_modify_load_key
        IMPORTING
          et_changed_node = lt_loaded_node_keyload ).
*    filter loaded key
      IF et_loaded_node IS NOT INITIAL.
        LOOP AT lt_loaded_node_keyload INTO ls_node.
          READ TABLE et_loaded_node
            WITH KEY node = ls_node-node
                     key  = ls_node-key
            TRANSPORTING NO FIELDS.
          CHECK sy-subrc = 0.
          DELETE lt_loaded_node_keyload.
        ENDLOOP.
      ENDIF.

      INSERT LINES OF lt_loaded_node_keyload INTO TABLE et_loaded_node.

      IF lt_loaded_node_keyload IS NOT INITIAL.

        "It is possible that loading a before image of a deleted node causes
        "a keyload change. (Test /BOBF/CL_TST_CONV_KEY_BEF_IMG->CONV_KEY_AFTER_DELETE)
        "In this specific case, we do not want to distribute
        "the loaded key to the other states:
        IF iv_load_state = /bobf/if_conf_c=>sc_state_database.
          " Make sure only to transfer instances that are not deleted
          lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
          CLEAR lt_loaded_key.
          LOOP AT lt_loaded_node_keyload INTO ls_node.
            ls_key-key = ls_node-key.
            INSERT ls_key INTO TABLE lt_loaded_key.
            AT END OF node.
              TRY.
                  mo_buffer->compare_states(
                    EXPORTING
                      iv_node_key      = ls_node-node
                      it_key           = lt_loaded_key
                      iv_state_current = /bobf/if_conf_c=>sc_state_current
                      iv_state_before  = iv_load_state
                      io_change        = lo_change_del ).
                CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.
              CLEAR lt_loaded_key.
            ENDAT.
          ENDLOOP.
          lo_change_del->get_changes(
               EXPORTING
                 iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
               IMPORTING
                 et_changed_node = lt_node_tmp ).
          LOOP AT lt_node_tmp INTO ls_node.
            DELETE lt_loaded_node_keyload WHERE table_line = ls_node.
          ENDLOOP.
        ENDIF.

        IF lt_loaded_node_keyload IS NOT INITIAL.

          IF iv_load_state <> /bobf/if_conf_c=>sc_state_current.
            TRY.
                mo_buffer->transfer_state(
                  EXPORTING
                    it_node         = lt_loaded_node_keyload
                    iv_incl_subtree = abap_false
                    iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_current ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

          IF iv_load_state <> /bobf/if_conf_c=>sc_state_database.
            TRY.
                mo_buffer->transfer_state(
                  EXPORTING
                    it_node         = lt_loaded_node_keyload
                    iv_incl_subtree = abap_false
                    iv_state_source = iv_load_state
                    iv_state_dest   = /bobf/if_conf_c=>sc_state_database ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

          IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_determined AND
             mo_conf->ms_obj-last_det_state_not_relevant = abap_false..
            TRY.
                mo_buffer->transfer_state(
                   EXPORTING
                     it_node         = lt_loaded_node_keyload
                     iv_incl_subtree = abap_false
                     iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_last_determined ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

          IF iv_load_state <> /bobf/if_conf_c=>sc_state_last_validated AND
             mo_conf->ms_obj-last_val_state_not_relevant = abap_false..
            TRY.
                mo_buffer->transfer_state(
                  EXPORTING
                    it_node         = lt_loaded_node_keyload
                    iv_incl_subtree = abap_false
                    iv_state_source = iv_load_state
                iv_state_dest   = /bobf/if_conf_c=>sc_state_last_validated ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

          IF iv_load_state <> /bobf/if_conf_c=>sc_state_before_modification AND
              mv_before_modification_exists = abap_true.
            TRY.
                mo_buffer->transfer_state(
                  EXPORTING
                    it_node         = lt_loaded_node_keyload
                    iv_incl_subtree = abap_false
                    iv_state_source = iv_load_state
                  iv_state_dest   = /bobf/if_conf_c=>sc_state_before_modification ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

        ENDIF.

        lo_change ?= io_change.
        lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key ).
      ENDIF.

    ELSE.
      io_change->get_changes(
        EXPORTING
          iv_change_mode  = /bobf/if_frw_c=>sc_modify_load_key
        IMPORTING
          et_changed_node = lt_loaded_node_keyload ).
      IF et_loaded_node IS INITIAL.
        et_loaded_node = lt_loaded_node_keyload.
      ELSE.
        INSERT LINES OF lt_loaded_node_keyload INTO TABLE et_loaded_node.
        DELETE ADJACENT DUPLICATES FROM et_loaded_node.
      ENDIF.

      lo_change ?= io_change.
      lo_change->cleanup( iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key ).
    ENDIF.

*  also transfer loaded nodes to existing sync states
    TRY.
        LOOP AT mt_sync_point INTO ls_sync_point.
          IF ls_sync_point-state IS NOT INITIAL AND ls_sync_point-state <> /bobf/if_conf_c=>sc_state_database.
            lt_node_transfer = et_loaded_node.
            IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
              lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
              CLEAR lt_node_tmp.
              LOOP AT lt_node_deleted INTO ls_node.
                ls_key-key = ls_node-key.
                INSERT ls_key INTO TABLE lt_loaded_key.
                AT END OF node.
                  TRY.
                      mo_buffer->compare_states(
                        EXPORTING
                          iv_node_key      = ls_node-node
                          it_key           = lt_loaded_key
                          iv_state_current = ls_sync_point-state
                          iv_state_before  = iv_load_state
                          io_change        = lo_change_del ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.
                  CLEAR lt_loaded_key.
                ENDAT.
              ENDLOOP.
              lo_change_del->get_changes(
                   EXPORTING
                     iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                   IMPORTING
                     et_changed_node = lt_node_tmp ).
              LOOP AT lt_node_tmp INTO ls_node.
                DELETE lt_node_transfer WHERE table_line = ls_node.
              ENDLOOP.
            ENDIF.
            mo_buffer->transfer_state(
              EXPORTING
                it_node         = lt_node_transfer
                iv_incl_subtree = abap_false
                iv_state_source = iv_load_state
                iv_state_dest   = ls_sync_point-state ).
          ENDIF.

          IF ls_sync_point-state_d IS NOT INITIAL AND ls_sync_point-state_d <> ls_sync_point-state.
            lt_node_transfer = et_loaded_node.
            IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
              lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
              CLEAR lt_node_tmp.
              LOOP AT lt_node_deleted INTO ls_node.
                ls_key-key = ls_node-key.
                INSERT ls_key INTO TABLE lt_loaded_key.
                AT END OF node.
                  TRY.
                      mo_buffer->compare_states(
                        EXPORTING
                          iv_node_key      = ls_node-node
                          it_key           = lt_loaded_key
                          iv_state_current = ls_sync_point-state_d
                          iv_state_before  = iv_load_state
                          io_change        = lo_change_del ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.
                  CLEAR lt_loaded_key.
                ENDAT.
              ENDLOOP.
              lo_change_del->get_changes(
                   EXPORTING
                     iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                   IMPORTING
                     et_changed_node = lt_node_tmp ).
              LOOP AT lt_node_tmp INTO ls_node.
                DELETE lt_node_transfer WHERE table_line = ls_node.
              ENDLOOP.
            ENDIF.
            mo_buffer->transfer_state(
              EXPORTING
                it_node         = lt_node_transfer
                iv_incl_subtree = abap_false
                iv_state_source = iv_load_state
                iv_state_dest   = ls_sync_point-state_d ).
          ENDIF.

          IF ls_sync_point-state_v IS NOT INITIAL AND ls_sync_point-state_v <> ls_sync_point-state.
            lt_node_transfer = et_loaded_node.
            IF lt_node_deleted IS NOT INITIAL.
*        Make sure only to transfer instances that are not deleted in the target state
              lo_change_del ?= /bobf/cl_frw_factory=>get_change( ).
              CLEAR lt_node_tmp.
              LOOP AT lt_node_deleted INTO ls_node.
                ls_key-key = ls_node-key.
                INSERT ls_key INTO TABLE lt_loaded_key.
                AT END OF node.
                  TRY.
                      mo_buffer->compare_states(
                        EXPORTING
                          iv_node_key      = ls_node-node
                          it_key           = lt_loaded_key
                          iv_state_current = ls_sync_point-state_v
                          iv_state_before  = iv_load_state
                          io_change        = lo_change_del ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.
                  CLEAR lt_loaded_key.
                ENDAT.
              ENDLOOP.
              lo_change_del->get_changes(
                   EXPORTING
                     iv_change_mode  = /bobf/if_frw_c=>sc_modify_delete
                   IMPORTING
                     et_changed_node = lt_node_tmp ).
              LOOP AT lt_node_tmp INTO ls_node.
                DELETE lt_node_transfer WHERE table_line = ls_node.
              ENDLOOP.
            ENDIF.
            mo_buffer->transfer_state(
              EXPORTING
                it_node         = lt_node_transfer
                iv_incl_subtree = abap_false
                iv_state_source = iv_load_state
                iv_state_dest   = ls_sync_point-state_v ).
          ENDIF.
        ENDLOOP.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

  ENDMETHOD.


  METHOD can_accelerate_check.
    result  = xsdbool(
                     mo_conf->ms_obj-root_node_key = iv_node_key
*   and mo_conf->ms_obj-is_rap_bo = abap_false
                    AND   mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft
                    AND  mo_conf->ms_obj-smart_validations = abap_true
                    AND /bobf/cl_tool_switch=>is_switch_off( /bobf/cl_tool_switch=>gc_switch_id-no_accelerated_prepare )
                    AND  NEW cl_sadl_gw_configuration( )->get( iv_param = 'OP_CODE_MIG' )
                    AND is_draft( iv_node_key = iv_node_key  it_key = it_key  )
                     ).
  ENDMETHOD.


  METHOD check_action.

    DATA: ls_actconf         TYPE /bobf/s_confro_act_list,
          ls_val             TYPE REF TO /bobf/s_confro_val_list,
          ls_val_class       TYPE ty_validation,
          ls_act_class       TYPE ty_action,
          ls_valread         TYPE /bobf/s_confro_read,
          ls_context_val     TYPE /bobf/s_frw_ctx_val,
          ls_context_act     TYPE /bobf/s_frw_ctx_act,
          ls_key             TYPE /bobf/s_frw_key,
          lt_key             TYPE /bobf/t_frw_key,
          lt_initial_key     TYPE /bobf/t_frw_key,
          lt_key_read        TYPE /bobf/t_frw_key,
          lt_failed_key      TYPE /bobf/t_frw_key,
          lt_failed_key_auth TYPE /bobf/t_frw_key,
          lt_failed_key_all  TYPE /bobf/t_frw_key,
          lo_message         TYPE REF TO /bobf/if_frw_message,
          lo_message_int     TYPE REF TO /bobf/cl_frw_message,
          lv_last_state      TYPE /bobf/conf_state,
          lv_state           TYPE /bobf/conf_state,
          lo_int_access      TYPE REF TO /bobf/cl_frw_int_access,
          lt_nodecat         TYPE /bobf/t_frw_node_cat,
          ls_nodecat         TYPE /bobf/s_frw_node_cat,
          lt_sta_var         TYPE /bobf/t_confro_sta_var,
          lx_root            TYPE REF TO cx_root,
          lx_frw_core        TYPE REF TO /bobf/cx_frw_core,
          lx_frw             TYPE REF TO /bobf/cx_frw,
          lv_content_cat     TYPE string,
          lv_content_name    TYPE /bobf/obm_name,
          lv_empty_string    TYPE string,
          lo_property        TYPE REF TO /bobf/if_frw_property,
          lt_property        TYPE /bobf/t_frw_property_k_sorted,
          ls_runtime_context TYPE /bobf/s_frw_runtime_context,
          ls_location        TYPE /bobf/s_frw_location,
          lm_common_esi      TYPE REF TO /bobf/cm_frw_common_esi,
          lo_delegation      TYPE REF TO /bobf/if_frw_delegation,
          ls_action          TYPE /bobf/s_frw_action.


    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

    CLEAR: et_failed_key,
           eo_message.

    lt_initial_key = ct_key.

    IF is_context IS INITIAL.
      IF mo_conf->ms_last_action-act_key NE iv_act_key OR
          iv_act_key IS INITIAL.
        mo_conf->get_act(
          EXPORTING
            iv_act_key  = iv_act_key
            iv_node_key = iv_node_key
            iv_act_cat  = iv_act_cat
          IMPORTING
            es_action   = ls_actconf ).
      ELSE.
        ls_actconf = mo_conf->ms_last_action.
      ENDIF.
      ls_context_act-bo_key        = mo_conf->ms_obj-bo_key.
      ls_context_act-root_node_key = mo_conf->ms_obj-root_node_key.
      ls_context_act-node_key      = ls_actconf-node_key.
      ls_context_act-act_key       = ls_actconf-act_key.
      ls_context_act-act_cat       = ls_actconf-act_cat.

    ELSE.
      IF mo_conf->ms_last_action-act_key NE is_context-act_key.
        mo_conf->get_act(
          EXPORTING
            iv_act_key = is_context-act_key
          IMPORTING
            es_action  = ls_actconf ).
      ELSE.
        ls_actconf = mo_conf->ms_last_action.
      ENDIF.
      ls_context_act = is_context.
    ENDIF.

    IF ls_actconf IS INITIAL.
*      unknown action
      set_application_error( ).
    ENDIF.

*  ____________________________________________________________________ *
*  check for delegated action
    IF mo_conf->ms_last_node-node_key <> ls_actconf-node_key.
      mo_conf->get_node( iv_node_key = ls_actconf-node_key ).
    ENDIF.
    IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
*    delegate action
      TRY.
          lo_delegation = get_delegation( ls_actconf-node_key ).
          ls_action-act_key    = iv_act_key.
          ls_action-key        = ct_key.
          ls_action-parameters = is_parameters.
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->check_action(
            EXPORTING
              is_action     = ls_action
            IMPORTING
              eo_message    = eo_message
              et_failed_key = et_failed_key ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      RETURN.
    ENDIF.

    IF it_delete_auth_check_key IS SUPPLIED.
      lv_last_state = /bobf/if_conf_c=>sc_state_before_modification.
      DATA(lt_key_auth) = it_delete_auth_check_key.
      mo_authority_handler->check_authority_for_modify(
        EXPORTING io_bopf         = me
                  io_buffer       = mo_buffer
                  io_change       = io_change
                  is_act_conf     = ls_actconf
        IMPORTING et_failed_key   = lt_failed_key_auth
        CHANGING  ct_key          = lt_key_auth
                  co_message      = eo_message
                  ct_access_stack = mt_access_stack ).
      IF lt_failed_key_auth IS NOT INITIAL.
        APPEND LINES OF lt_failed_key_auth TO lt_failed_key_all.
        ct_key = FILTER #( ct_key EXCEPT IN lt_failed_key_auth USING KEY key_sort WHERE key = key ).
      ENDIF.
    ELSEIF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_delete OR
           ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_update OR
           ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_create.
      lv_last_state = /bobf/if_conf_c=>sc_state_before_modification.
      CALL METHOD mo_authority_handler->check_authority_for_modify
        EXPORTING
          io_bopf         = me
          io_buffer       = mo_buffer
          io_change       = io_change
          is_act_conf     = ls_actconf
        IMPORTING
          et_failed_key   = lt_failed_key_auth
        CHANGING
          ct_key          = ct_key
          co_message      = eo_message
          ct_access_stack = mt_access_stack.
      APPEND LINES OF lt_failed_key_auth TO lt_failed_key_all.
    ELSE.
      lv_last_state = /bobf/if_conf_c=>sc_state_database.
    ENDIF.

*  ____________________________________________________________________ *
*  prepare action
    IF ls_actconf-act_class IS NOT INITIAL AND
        ls_actconf-prepare_impl = abap_true.

*    create internal access object for action
      CREATE OBJECT lo_int_access
        EXPORTING
          io_bopf   = me
          io_conf   = mo_conf
          io_buffer = mo_buffer
          io_change = io_change.
      lo_int_access->set_last_state( iv_last_state = lv_last_state ).
      lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).

      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
      INSERT lo_int_access INTO mt_access_stack INDEX 1.

*    get action class
      READ TABLE mt_action
        WITH TABLE KEY act_key = ls_actconf-act_key
        INTO ls_act_class.
      IF sy-subrc <> 0.
        ls_act_class-act_key = ls_actconf-act_key.
        TRY.
            CREATE OBJECT ls_act_class-class TYPE (ls_actconf-act_class).
          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_act = abap_true
              iv_key = ls_actconf-act_key ).
            lv_content_cat = TEXT-000.
            CREATE OBJECT lx_frw_core
              EXPORTING
                previous        = lx_root
                textid          = /bobf/cx_frw_core=>sc_no_instance
                mv_classname    = ls_actconf-act_class
                mv_content_name = lv_content_name
                mv_content_cat  = lv_content_cat.
            set_configuration_error( lx_frw ).
        ENDTRY.

        INSERT ls_act_class INTO TABLE mt_action.
      ENDIF.

      lo_int_access->set_context(
         is_action        = ls_context_act
         iv_read_allowed  = abap_true
         iv_check_allowed = abap_true ).

      /bobf/cl_tool_assert=>is_message_cleared_stack_set( io_message = lo_message ).

      TRY.
          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          ls_act_class-class->prepare(
            EXPORTING
              is_ctx        = ls_context_act
              io_read       = lo_int_access
              io_check      = lo_int_access
              is_parameters = is_parameters
            IMPORTING
              eo_message    = lo_message
            CHANGING
              ct_key        = ct_key ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          lv_content_name = get_content_description(
            iv_act = abap_true
            iv_key = ls_actconf-act_key ).
          lv_content_cat = TEXT-000.
          CREATE OBJECT lx_frw_core
            EXPORTING
              previous        = lx_root
              textid          = /bobf/cx_frw_core=>sc_content_exception
              mv_node         = ls_actconf-node_key
              mv_method_name  = 'PREPARE'
              mv_content_name = lv_content_name
              mv_content_cat  = lv_content_cat.
          set_application_error( lx_frw_core ).
      ENDTRY.

      /bobf/cl_tool_assert=>is_message_cleared_stack_check( io_message = lo_message ).

      lo_int_access->invalidate( ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

*  ____________________________________________________________________ *
*  check action properties
    IF iv_check_property                 = abap_true                               AND
        ct_key                           IS NOT INITIAL                            AND
        ( mo_conf->ms_obj-chk_serv_action = /bobf/if_conf_c=>sc_check_services_stat OR
        mo_conf->ms_obj-chk_serv_action   = /bobf/if_conf_c=>sc_check_services_stat_dyn ).

      " [customer incident 0020079747 0000036035 2016, transportation management, performance]
      " give the implementation of RETRIEVE_PROPERTY the chance, to calculate properties
      " more specific and performant by handing over the concrete action. especially
      " when SAM is in the game, this should gain some performance...
      IF ls_context_act-act_key IS NOT INITIAL.
        DATA(lv_action_property) = abap_false. " TRUE would request ALL action properties...
        DATA(lt_action)          = VALUE /bobf/t_frw_key2( ( ls_context_act-act_key ) ).
      ELSE.
        lv_action_property       = abap_true.
      ENDIF.

      /bobf/if_frw_service_layer~retrieve_property(
        EXPORTING
          iv_node_key        = ls_actconf-node_key
          it_key             = ct_key
          iv_check_services  = mo_conf->ms_obj-chk_serv_action
          iv_action_property = lv_action_property
          it_action          = lt_action
        IMPORTING
          eo_property        = lo_property
          eo_message         = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lo_property IS BOUND.
        lo_property->get_property( IMPORTING et_property_sorted = lt_property ).
        LOOP AT ct_key INTO ls_key.
          READ TABLE lt_property WITH KEY
              content_cat    = /bobf/if_conf_c=>sc_content_act
              parent_key     = ls_key-key
              property_name  = /bobf/if_conf_c=>sc_property_name_enabled
              content_key    = ls_context_act-act_key
              attribute_name = lv_empty_string
              value          = abap_false
              TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            ls_location-node_key = ls_actconf-node_key.
            ls_location-key      = ls_key-key.
            IF ls_actconf-act_esr_name IS INITIAL.
              lv_content_name    = ls_actconf-act_name.
            ELSE.
              lv_content_name    = ls_actconf-act_esr_name.
            ENDIF.
            CREATE OBJECT lm_common_esi
              EXPORTING
                textid                = /bobf/cm_frw_common_esi=>cm_action_disabled
                severity              = /bobf/cm_frw=>co_severity_error
                symptom               = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                lifetime              = /bobf/cm_frw=>co_lifetime_transition
                ms_origin_location    = ls_location
                cmn_action_proxy_name = lv_content_name.
            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.
            eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
            DELETE ct_key.
            APPEND ls_key TO lt_failed_key_all.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

    IF ct_key IS INITIAL.
      IF lo_int_access IS BOUND.
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.
      ENDIF.
      IF ls_actconf-exec_only_all EQ abap_false.
        et_failed_key = lt_failed_key_all.
      ELSE.
        et_failed_key = lt_initial_key.
      ENDIF.
      RETURN.
    ENDIF.

*  ____________________________________________________________________ *
*  check node category of instances vs. node category of action
    check_action_node_category(
      EXPORTING
        is_conf_action = ls_actconf
        is_conf_node   = mo_conf->ms_last_node
        iv_last_state  = lv_last_state
      CHANGING
        ct_key         = ct_key
        ct_failed_key  = lt_failed_key_all
        co_message     = eo_message ).

*  ____________________________________________________________________ *
*  check action in status & action management
    IF mo_conf->ms_obj-status_class IS NOT INITIAL AND
     ( ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_standard OR
       ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_delete ).

*    Check if there are any status variabled on this node -> Node is SAM relevant
      mo_conf->get_status_variables(
        IMPORTING
          et_sta_var = lt_sta_var ).
      READ TABLE lt_sta_var WITH KEY node_key COMPONENTS node_key = ls_context_act-node_key TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.

        IF mo_sam IS NOT BOUND.
          TRY.
              CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
                EXPORTING
                  iv_bo_key = mo_conf->ms_obj-bo_key.

            CATCH cx_sy_create_object_error INTO lx_root.
              lv_content_cat = TEXT-004.
              CREATE OBJECT lx_frw_core
                EXPORTING
                  previous       = lx_root
                  textid         = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname   = mo_conf->ms_obj-status_class
                  mv_content_cat = lv_content_cat.
              set_configuration_error( lx_frw_core ).
          ENDTRY.
        ENDIF.

*    create internal access object for action
        IF lo_int_access IS NOT BOUND.
          CREATE OBJECT lo_int_access
            EXPORTING
              io_bopf   = me
              io_conf   = mo_conf
              io_buffer = mo_buffer.
          lo_int_access->set_last_state( iv_last_state = lv_last_state ).
          lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.
        ENDIF.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

        lo_int_access->set_context(
           is_action       = ls_context_act
           iv_read_allowed = abap_true ).

        TRY.
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            mo_sam->check_action(
              EXPORTING
                iv_act_key    = ls_actconf-act_key
                it_key        = ct_key
                io_read       = lo_int_access
              IMPORTING
                et_failed_key = lt_failed_key
                eo_message    = lo_message ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH BEFORE UNWIND /bobf/cx_frw INTO lx_frw.
            set_application_error( lx_frw ).
        ENDTRY.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = ct_key
                it_key_subset = lt_failed_key ) = abap_true.
        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ) = abap_true.

        lo_int_access->invalidate( ).

        APPEND LINES OF lt_failed_key TO lt_failed_key_all.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

      ENDIF.
    ENDIF.

*  ____________________________________________________________________ *
*  validate all

    IF iv_check_validation = abap_true.
      IF ls_actconf-act_cat        = /bobf/if_conf_c=>sc_action_delete AND
          mv_modifying_transaction = abap_true.
        lv_state = /bobf/if_conf_c=>sc_state_before_modification.
      ELSE.
        lv_state = /bobf/if_conf_c=>sc_state_current.
      ENDIF.

      ls_context_val-bo_key         = mo_conf->ms_obj-bo_key.
      ls_context_val-root_node_key  = mo_conf->ms_obj-root_node_key.
      ls_context_val-act_key        = ls_actconf-act_key.
      ls_context_val-act_parameters = is_parameters.

      LOOP AT ls_actconf-val_list->* REFERENCE INTO ls_val.
        lt_key = ct_key.

*  ____________________________________________________________________ *
*    filter keys regarding their node category
        IF ls_val->node_cat->* IS NOT INITIAL.
          IF lt_nodecat IS INITIAL.
            retrieve(
              EXPORTING
                iv_node_key    = ls_actconf-node_key
                it_key         = ct_key
                iv_state       = lv_state
                iv_fill_data   = abap_false
              IMPORTING
                et_node_cat    = lt_nodecat
                eo_message     = lo_message ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.

          LOOP AT lt_nodecat INTO ls_nodecat.
*        check if node category is valid
            READ TABLE ls_val->node_cat->*
              WITH KEY node_cat_key = ls_nodecat-node_cat_key
              TRANSPORTING NO FIELDS.
            IF sy-subrc <> 0.
              DELETE TABLE lt_key WITH TABLE KEY key = ls_nodecat-key.
            ENDIF.
          ENDLOOP.
          IF lt_key IS INITIAL.
            CONTINUE.
          ENDIF.
        ENDIF.

*  ____________________________________________________________________ *
*    if action check execution only if not failed
*    => kick out already failed keys
        IF ls_val->no_exec_if_fail = abap_true.
          LOOP AT lt_failed_key_all INTO ls_key.
            DELETE TABLE lt_key WITH TABLE KEY key = ls_key-key.
          ENDLOOP.
          IF lt_key IS INITIAL.
            CONTINUE.
          ENDIF.
        ENDIF.

*  ____________________________________________________________________ *
*    build up context for validation implementation
        ls_context_val-node_key       = ls_val->node_key.
        ls_context_val-val_key        = ls_val->val_key.

*    create internal access object for action
        IF lo_int_access IS NOT BOUND.
          CREATE OBJECT lo_int_access
            EXPORTING
              io_bopf   = me
              io_conf   = mo_conf
              io_buffer = mo_buffer.
          lo_int_access->set_last_state( iv_last_state = lv_last_state ).
          lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access INTO mt_access_stack INDEX 1.
        ENDIF.

*    get validation class
        READ TABLE mt_validation
           WITH TABLE KEY val_key = ls_val->val_key
           INTO ls_val_class.
        IF sy-subrc <> 0.
          ls_val_class-val_key = ls_val->val_key.
          TRY.
              CREATE OBJECT ls_val_class-class TYPE (ls_val->val_class).

            CATCH cx_sy_create_object_error INTO lx_root.
              lv_content_name = get_content_description(
                iv_val = abap_true
                iv_key = ls_val->val_key ).
              lv_content_cat = TEXT-003.
              CREATE OBJECT lx_frw_core
                EXPORTING
                  previous        = lx_root
                  textid          = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname    = ls_actconf-act_class
                  mv_content_cat  = lv_content_cat
                  mv_content_name = lv_content_name.
              set_configuration_error( lx_frw_core ).
          ENDTRY.
          INSERT ls_val_class INTO TABLE mt_validation.
        ENDIF.

*  ____________________________________________________________________ *
*    call method CHECK_DELTA (only for Create/Update/Delete)
        IF  ls_val->check_delta_impl = abap_true
        AND ( ls_actconf-act_cat    = /bobf/if_conf_c=>sc_action_create OR
              ls_actconf-act_cat    = /bobf/if_conf_c=>sc_action_update OR
              ls_actconf-act_cat    = /bobf/if_conf_c=>sc_action_delete OR
              ls_actconf-act_cat    = /bobf/if_conf_c=>sc_action_save ).
          lo_int_access->set_context( iv_read_allowed = abap_true ).
          TRY.
              lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
              ls_val_class-class->check_delta( EXPORTING io_read = lo_int_access
                                                         is_ctx  = ls_context_val
                                               CHANGING  ct_key  = lt_key ).
              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_val
                                                                                  iv_content_key   = ls_val->val_key
                                                                                  iv_content_class = ls_val->val_class
                                                                                  iv_node_key      = ls_val->node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'CHECK_DELTA' ) ).
          ENDTRY.
          lo_int_access->invalidate( ).
          IF lt_key IS INITIAL.
            CONTINUE.
          ENDIF.
        ENDIF.

*  ____________________________________________________________________ *
*    check if all required nodes are loaded

        LOOP AT ls_val->val_read->* INTO ls_valread.
          IF ls_valread-assoc IS BOUND.
*        association defined from node to be determined to read-node
*        -> retrieve keys of read-nodes
            retrieve_by_association(
              EXPORTING
                iv_node_key    = ls_val->node_key
                it_key         = lt_key
                iv_association = ls_valread-assoc->assoc_key
                iv_state       = lv_state
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_key_read ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ELSE.
*        own node
            lt_key_read = lt_key.
          ENDIF.

          retrieve(
            EXPORTING
              iv_node_key    = ls_valread-node_key
              it_key         = lt_key_read
              iv_state       = lv_state
              iv_fill_data   = abap_false
            IMPORTING
              eo_message     = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDLOOP.

        IF ls_val->check_impl = abap_true.

*  ____________________________________________________________________ *
*    call method CHECK
          lo_int_access->set_context( iv_read_allowed = abap_true ).
          TRY.
              lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
              ls_val_class-class->check( EXPORTING io_read = lo_int_access
                                                   is_ctx  = ls_context_val
                                         CHANGING  ct_key  = lt_key ).
              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_val
                                                                                  iv_content_key   = ls_val->val_key
                                                                                  iv_content_class = ls_val->val_class
                                                                                  iv_node_key      = iv_node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'CHECK' ) ).
          ENDTRY.
          lo_int_access->invalidate( ).

          IF lt_key IS INITIAL.
            CONTINUE.
          ENDIF.
        ENDIF.

*  ____________________________________________________________________ *
*    call method EXECUTE
        lo_int_access->set_context(
            iv_read_allowed = abap_true ).

        " this method always execute the action_validation
        IF ls_context_val-act_key IS NOT INITIAL.
          ls_context_val-val_time = /bobf/if_conf_c=>sc_val_time_action.
        ENDIF.

        TRY.
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            ls_val_class-class->execute( EXPORTING is_ctx        = ls_context_val
                                                   it_key        = lt_key
                                                   io_read       = lo_int_access
                                         IMPORTING et_failed_key = lt_failed_key
                                                   eo_message    = lo_message ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = lt_key
                                                                                     it_key_subset = lt_failed_key ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>failed_key_message( io_message    = lo_message
                                                                                          it_failed_key = lt_failed_key ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_val
                                                                                iv_content_key   = ls_val->val_key
                                                                                iv_content_class = ls_val->val_class
                                                                                iv_node_key      = ls_val->node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'EXECUTE' ) ).
        ENDTRY.

        APPEND LINES OF lt_failed_key TO lt_failed_key_all.

        lo_int_access->invalidate( ).

*    fill message
        create_durable_msg_container( CHANGING co_message = lo_message ).
        IF lo_message IS BOUND.
          lo_message_int ?= lo_message.
          ls_runtime_context-bo_key   =  mo_conf->ms_obj-bo_key.
          ls_runtime_context-node_key = ls_context_val-node_key.
          ls_runtime_context-val_key  = ls_context_val-val_key.
          lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

      ENDLOOP.
    ENDIF.

    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.
    ENDIF.

    IF lt_failed_key_all IS NOT INITIAL.
      IF ls_actconf-exec_only_all = abap_true.
        et_failed_key = lt_initial_key.
        CLEAR ct_key.
      ELSE.
        SORT lt_failed_key_all.
        DELETE ADJACENT DUPLICATES FROM lt_failed_key_all.
        LOOP AT lt_failed_key_all INTO ls_key.
          READ TABLE lt_initial_key WITH KEY key_sort
            COMPONENTS key = ls_key-key TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            APPEND ls_key TO et_failed_key.
          ENDIF.
          DELETE ct_key WHERE key = ls_key-key.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD check_action_node_category.

    " first of all check, if it's no framework action (save runtime)...
    IF is_conf_action-act_cat <> /bobf/if_conf_c=>sc_action_standard.
      RETURN. " !!!
    ENDIF.

    " secondly check, if there's more than one node category defined (save runtime)...
    IF is_conf_node-node_cat IS BOUND.
      IF lines( is_conf_node-node_cat->* ) <= 1.
        RETURN. " !!!
      ENDIF.
    ENDIF.

    " check, if it's no CONF MODEL action (partly results in errors)...
    IF mo_conf->ms_obj-bo_key = /bobf/if_conf_obj_c=>sc_bo_key.
      RETURN. " !!!
    ENDIF.

    " be gracious, new component NODE_CAT may no exist in SHM...
    IF is_conf_action-node_cat IS NOT BOUND.
      RETURN. " !!!
    ENDIF.


    " >>>>> check node category of instances vs. node category of action...

    " get node category of instances...
    get_node_cat(
      EXPORTING
        iv_node_key      = is_conf_action-node_key
        it_key           = ct_key
        iv_current_state = /bobf/if_conf_c=>sc_state_current
        iv_last_state    = iv_last_state
      IMPORTING
        et_nodecat       = DATA(lt_node_cat)
        eo_message       = DATA(lo_message) ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = co_message ).

    " check node categories...
    LOOP AT lt_node_cat ASSIGNING FIELD-SYMBOL(<ls_node_cat>).

      READ TABLE is_conf_action-node_cat->* WITH KEY node_cat_key = <ls_node_cat>-node_cat_key TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.

        " node category of instance differs from action node category(ies)...
        DELETE ct_key WHERE key = <ls_node_cat>-key.
        APPEND VALUE #( key = <ls_node_cat>-key ) TO ct_failed_key.
        DATA(lm_frw) = NEW /bobf/cm_frw_common_esi(
                         textid                = /bobf/cm_frw_common_esi=>cm_action_wrong_nodecat
                         severity              = /bobf/cm_frw=>co_severity_error
                         lifetime              = /bobf/cm_frw=>co_lifetime_transition
                         symptom               = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                         ms_origin_location    = VALUE #( node_key = is_conf_action-node_key
                                                          key      = <ls_node_cat>-key )
                         mv_act_key            = is_conf_action-act_key
                         cmn_action_proxy_name = is_conf_action-act_name ).
        IF co_message IS NOT BOUND.
          co_message = /bobf/cl_frw_factory=>get_message( ).
        ENDIF.
        co_message->add_cm( lm_frw ).

      ENDIF.

    ENDLOOP.

  ENDMETHOD.


  METHOD check_and_determine.
    DATA: lo_message               TYPE REF TO /bobf/if_frw_message,
          lv_need_lock             TYPE boole_d,
          lt_node_lock             TYPE /bobf/t_frw_node,
          lt_node_newly_locked     TYPE /bobf/t_frw_node,
          lv_lock_generic          TYPE boole_d,
          lt_delegated_node        TYPE /bobf/t_frw_node,
          lo_delegation            TYPE REF TO /bobf/if_frw_delegation,
          ls_detconf               TYPE REF TO /bobf/s_confro_exectime,
          lt_groupconf             TYPE /bobf/t_confro_group,
          ls_groupconf             TYPE /bobf/s_confro_group,
          lt_host_node             TYPE /bobf/t_frw_node,
          ls_node                  TYPE /bobf/s_frw_node,
          lt_key                   TYPE /bobf/t_frw_key,
          ls_key                   TYPE /bobf/s_frw_key,
          lt_check_key             TYPE /bobf/t_frw_key,
          lt_failed_key            TYPE /bobf/t_frw_key,
          lt_failed_val            TYPE /bobf/t_frw_validations,
          lt_group                 TYPE /bobf/t_frw_group,
          ls_group                 TYPE /bobf/s_frw_group,
          ls_change_mode           TYPE /bobf/s_confro_chg_mode,
          lo_change                TYPE REF TO /bobf/cl_frw_change,
          lx_root                  TYPE REF TO cx_root,
          lt_created_keys_per_node TYPE /bobf/t_frw_key,
          lt_updated_keys_per_node TYPE /bobf/t_frw_key,
          lt_deleted_keys_per_node TYPE /bobf/t_frw_key,
          lv_accelerate_check      TYPE abap_bool.

    CLEAR:
        eo_change,
        eo_message.

* ____________________________________________________________________ *
* check for complete delegation
    eo_change = /bobf/cl_frw_factory=>get_change( ).
    lo_change ?= eo_change.

    IF io_change IS BOUND.
      lo_change->merge( io_change ).
    ENDIF.

    IF iv_node_key IS NOT INITIAL.
      IF mo_conf->ms_last_node-node_key <> iv_node_key.
        mo_conf->get_node( EXPORTING iv_node_key = iv_node_key ).
      ENDIF.

      IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
        TRY.
            lo_delegation = get_delegation( iv_node_key ).
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_delegation->check_and_determine(
              EXPORTING
                iv_node_key    = iv_node_key
                it_key         = it_key
                iv_check_scope = iv_check_scope
                io_change      = eo_change
              IMPORTING
                eo_message     = eo_message ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        IF mv_modifying_transaction = abap_false AND
           eo_change IS BOUND AND
           ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
             eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
             eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).
          create_states( ).
          mv_modifying_transaction = abap_true.
        ENDIF.

        RETURN.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* determine objects to check
    lo_change->trace_external_changes( abap_false ).

    lt_check_key = it_key.

*  ____________________________________________________________________ *
* check existence of all node instances the check&determine action is called with
    IF lt_check_key IS NOT INITIAL.
      retrieve(
        EXPORTING
          iv_node_key         = iv_node_key
          it_key              = lt_check_key
          iv_state            = /bobf/if_conf_c=>sc_state_current
          iv_invalidate_cache = abap_false
          iv_fill_data        = abap_false
          iv_edit_mode        = /bobf/if_conf_c=>sc_edit_read_only
          iv_buffer_only      = abap_false
          iv_within_loading   = abap_false
        IMPORTING
          eo_message          = lo_message
          et_failed_key       = lt_failed_key ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      LOOP AT lt_failed_key INTO ls_key.
        DELETE lt_check_key WHERE key = ls_key-key.
      ENDLOOP.
    ENDIF.

    mo_conf->get_group_tab( IMPORTING et_group = lt_groupconf ).
    ls_detconf = mo_conf->get_determination( /bobf/if_conf_c=>sc_time_check_and_determine ).

* Pre-Lock all instances that might be affected by setting of consistency status or determinations
    IF ls_detconf IS BOUND AND
      ls_detconf->det_list    IS BOUND AND
      ls_detconf->det_list->* IS NOT INITIAL.
      lv_need_lock = abap_true.
    ELSE.
      LOOP AT lt_groupconf INTO ls_groupconf
        WHERE group_cat = /bobf/if_conf_c=>sc_group_cat_consistency
          AND sta_var_key IS NOT INITIAL.
        IF iv_check_scope = /bobf/if_frw_c=>sc_scope_local.
          IF ls_groupconf-local_group = abap_true AND
             ls_groupconf-node_key    = iv_node_key.
            lv_need_lock = abap_true.
            EXIT.
          ENDIF.
        ELSEIF iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure.
          IF ls_groupconf-checkdet_node_key = iv_node_key.
            lv_need_lock = abap_true.
            EXIT.
          ELSEIF ls_groupconf-checkdet_super_node_keys IS BOUND.
            READ TABLE ls_groupconf-checkdet_super_node_keys->* TRANSPORTING NO FIELDS
              WITH KEY table_line = iv_node_key.
            IF sy-subrc = 0.
              lv_need_lock = abap_true.
              EXIT.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF lv_need_lock = abap_true.

      IF iv_check_scope = /bobf/if_frw_c=>sc_scope_local
      OR mo_conf->ms_obj-lock_only_root = abap_true.
        lv_lock_generic = abap_false.
      ELSE.
        lv_lock_generic = abap_true.
      ENDIF.
      map_to_node(
        EXPORTING
          iv_node_key = iv_node_key
          it_key      = it_key
        IMPORTING
          et_node     = lt_node_lock ).

      mo_lock_manager->lock(
        EXPORTING
          iv_edit_mode       = /bobf/if_conf_c=>sc_edit_exclusive
          it_node            = lt_node_lock
          io_change          = eo_change
          iv_generic         = lv_lock_generic
        IMPORTING
          et_lockable_node_newly_locked = lt_node_newly_locked
          eo_message         = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_node_newly_locked IS NOT INITIAL.
*     reload lock groups of newly locked lockable nodes
        do_loading(
          EXPORTING
            it_node           = lt_node_newly_locked
            iv_check_buf      = abap_false
            iv_reload         = abap_true
            iv_load_data      = abap_true
            iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
            io_change         = eo_change
          IMPORTING
            eo_message        = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
    ENDIF.



    CASE iv_check_scope.
      WHEN: /bobf/if_frw_c=>sc_scope_substructure.
        lv_accelerate_check = can_accelerate_check( iv_node_key    = iv_node_key
                                                    it_key         = lt_check_key ).
        if lv_accelerate_check EQ abap_true.
          add_opcode_trigger_to_change( it_check_key = lt_check_key
                                        io_change = lo_change ).
        ENDIF.
        " Accelerate GET_SUBNODES for Draft BOs by utilizing IV_RETURN_ONLY_CHECK_TRIGGER=X. Due to CT_DELEGATION_ROOT_NODE Classic BOs are too risky (at least for me)...
        get_subnodes( EXPORTING iv_node_key                   = iv_node_key
                                it_key                        = lt_check_key
                                iv_stop_at_delegation_subtree = abap_true
                                iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_nodes
                                iv_return_only_check_trigger  = abap_false " xsdbool( mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft ) // will cancel determinations w/ DETERMINE=X
                      IMPORTING eo_message                    = lo_message
                      CHANGING  ct_host_node                  = lt_host_node
                                ct_delegation_root_node       = lt_delegated_node ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        INSERT LINES OF lt_delegated_node INTO TABLE lt_host_node.
        lo_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_check
                               it_node        = lt_host_node ).

      WHEN: /bobf/if_frw_c=>sc_scope_local.
        lo_change->add_change(
          iv_change_mode = /bobf/if_frw_c=>sc_modify_check
          iv_node_key    = iv_node_key
          it_key         = lt_check_key ).

      WHEN OTHERS.
*     unknown scope
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK
        RETURN.
    ENDCASE.

    lo_change->trace_external_changes( abap_true ).

* ___________________________________________________________________________ *
* Perform Determinations for Check&Determine
    IF ls_detconf              IS BOUND AND
       ls_detconf->det_list    IS BOUND AND
       ls_detconf->det_list->* IS NOT INITIAL.

      do_determinations(
        EXPORTING
          iv_exectime   = /bobf/if_conf_c=>sc_time_check_and_determine
          io_change     = lo_change
        IMPORTING
          eo_message    = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lo_change IS BOUND AND
         ( lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
           lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
           lo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).

        do_determinations(
          EXPORTING
            iv_exectime = /bobf/if_conf_c=>sc_time_after_modify
            io_change   = lo_change
          IMPORTING
            eo_message  = lo_message ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      IF lo_change->has_changes(
          iv_selection   = /bobf/if_frw_c=>sc_change_succ_only
          iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
         lo_change->has_changes(
          iv_selection   = /bobf/if_frw_c=>sc_change_succ_only
          iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true.

        lo_change->cleanup( /bobf/if_frw_c=>sc_modify_check ).

*     Re-Determine instances to check if determinations created or deleted instances
        CASE iv_check_scope.
          WHEN: /bobf/if_frw_c=>sc_scope_substructure.
            CLEAR lt_delegated_node.
            " Accelerate GET_SUBNODES for Draft BOs by utilizing IV_RETURN_ONLY_CHECK_TRIGGER=X. Due to CT_DELEGATION_ROOT_NODE Classic BOs are too risky (at least for me)...
            get_subnodes( EXPORTING iv_node_key                   = iv_node_key
                                    it_key                        = lt_check_key
                                    iv_stop_at_delegation_subtree = abap_true
                                    iv_return_transient_nodes     = gc_transient_node_ctrl-return_transient_nodes
                                    iv_return_only_check_trigger  = abap_false " xsdbool( mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft ) // will cancel determinations w/ DETERMINE=X
                          IMPORTING eo_message                    = lo_message
                          CHANGING  ct_host_node                  = lt_host_node
                                    ct_delegation_root_node       = lt_delegated_node ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            INSERT LINES OF lt_delegated_node INTO TABLE lt_host_node.
            lo_change->add_change( iv_change_mode = /bobf/if_frw_c=>sc_modify_check
                                   it_node        = lt_host_node ).

          WHEN: /bobf/if_frw_c=>sc_scope_local.
            lo_change->add_change(
               iv_change_mode = /bobf/if_frw_c=>sc_modify_check
               iv_node_key    = iv_node_key
               it_key         = lt_check_key ).
        ENDCASE.

      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* call consistency check for delegated nodes within subtree
    lo_change->trace_external_changes( abap_false ).

    TRY.
        LOOP AT lt_delegated_node INTO ls_node.

          ls_key-key = ls_node-key.
          APPEND ls_key TO lt_key.

          AT END OF node.
            mo_conf->get_node( ls_node-node ).
            lo_delegation = get_delegation( ls_node-node ).

            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_delegation->check_and_determine(
              EXPORTING
                iv_node_key    = ls_node-node
                it_key         = lt_key
                iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure
                io_change      = eo_change
              IMPORTING
                eo_message     = lo_message ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            CLEAR lt_key.
          ENDAT.
        ENDLOOP.

        IF mv_modifying_transaction = abap_false AND
           eo_change IS BOUND AND
           ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
             eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
             eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).
          create_states( ).
          mv_modifying_transaction = abap_true.
        ENDIF.

      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

* ____________________________________________________________________ *
* determine groups that are complete
    ls_change_mode-check = abap_true.

    LOOP AT lt_groupconf INTO ls_groupconf
      WHERE group_cat = /bobf/if_conf_c=>sc_group_cat_consistency.
      CHECK ls_groupconf-sta_var_key IS NOT INITIAL.

      IF iv_check_scope           = /bobf/if_frw_c=>sc_scope_local AND
         ls_groupconf-local_group = abap_false.
        CONTINUE.
      ENDIF.

      IF ls_groupconf-checkdet_node_key <> ls_groupconf-node_key.
        IF ls_groupconf-checkdet_super_node_keys IS BOUND.
          READ TABLE ls_groupconf-checkdet_super_node_keys->* TRANSPORTING NO FIELDS
            WITH KEY table_line = iv_node_key.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDIF.

      lo_change->get_trigger(
        EXPORTING
          iv_node_key    = ls_groupconf-node_key
          is_change_mode = ls_change_mode
          iv_exectime    = /bobf/if_conf_c=>sc_time_after_modify
        IMPORTING
          et_changed_key = lt_key ).

      ls_group-group_key    = ls_groupconf-group_key.
      ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.
      LOOP AT lt_key INTO ls_key.
        ls_group-key = ls_key-key.
        INSERT ls_group INTO TABLE lt_group.
      ENDLOOP.

    ENDLOOP.

* ____________________________________________________________________ *
* call consistency check for own nodes
    IF lo_change IS BOUND.
      do_validate(
        EXPORTING
          iv_only_given_validations  = abap_false
          io_change                  = lo_change
          iv_last_state_db           = abap_true
          iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_check_and_determ
        IMPORTING
          et_failed_val              = lt_failed_val
          eo_message                 = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

* ____________________________________________________________________ *
*   set consistency status
      IF lv_accelerate_check = abap_true.
        " In case of validations that are not triggered on 'check':
        " get untouched instances to set their draft consistency status
        " (so it is not 'pending' anymore)

        ls_group-group_key    = lt_groupconf[ group_cat  = /bobf/if_conf_c=>sc_group_cat_consistency
                                              group_name = /bobf/if_conf_c=>sc_group_name_draft_consist
                                              node_key   = iv_node_key ]-group_key.
        ls_group-status_value = /bobf/if_frw_c=>sc_status_consistent.

        LOOP AT lt_check_key ASSIGNING FIELD-SYMBOL(<ls_check_key>).
          ASSIGN lt_group[ key = <ls_check_key>-key ] TO FIELD-SYMBOL(<ls_group>).
          IF sy-subrc <> 0.
            ls_group-key = <ls_check_key>-key.
            INSERT ls_group INTO TABLE lt_group.
          ENDIF.
        ENDLOOP.

      ENDIF.

      lo_change->trace_external_changes( abap_true ).
      derive_consistency_status(
        EXPORTING
          it_failed_val = lt_failed_val
        IMPORTING
          eo_message    = lo_message
        CHANGING
          ct_group      = lt_group ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      set_consistency_status(
        EXPORTING
          it_group   = lt_group
          io_change  = lo_change
        IMPORTING
          eo_message = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      lo_change->set_processed( iv_det_processed = abap_true ).

* ____________________________________________________________________ *
*   call determination after validation
      do_determinations(
        EXPORTING
          iv_exectime = /bobf/if_conf_c=>sc_time_after_validation
          io_change   = lo_change
        IMPORTING
          eo_message  = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

* ____________________________________________________________________ *
* collect messages from validation message node
    add_messages(
      EXPORTING
        io_change  = lo_change
      CHANGING
        co_message = eo_message ).
  ENDMETHOD.


  METHOD check_fatal_error.

    IF mv_application_error = abap_true.
      RAISE EXCEPTION TYPE /bobf/cx_frw_fatal
        EXPORTING
          textid           = /bobf/cx_frw_fatal=>sc_application_error
          mv_bo_name       = mo_conf->ms_obj-bo_name
          mv_proxy_bo_name = mo_conf->ms_obj-bo_esr_name.
    ENDIF.

    IF mv_configuration_error = abap_true.
      RAISE EXCEPTION TYPE /bobf/cx_frw_fatal
        EXPORTING
          textid           = /bobf/cx_frw_fatal=>sc_configuration_error
          mv_bo_name       = mo_conf->ms_obj-bo_name
          mv_proxy_bo_name = mo_conf->ms_obj-bo_esr_name.
    ENDIF.

  ENDMETHOD.


  METHOD check_inconsistent_composition.

    TYPES:
      BEGIN OF ty_root_data_extract,
        key            TYPE /bobf/conf_key, "name is important! needed for MOVE-CORRESPONDING from node compound structure
        isactiveentity TYPE abap_bool,      "name is important! needed for MOVE-CORRESPONDING from node compound structure
      END OF ty_root_data_extract,
      BEGIN OF ty_node_data_extract,
        key            TYPE /bobf/conf_key, "name is important! needed for MOVE-CORRESPONDING from node compound structure
        root_key       TYPE /bobf/conf_key, "name is important! needed for MOVE-CORRESPONDING from node compound structure
        isactiveentity TYPE abap_bool,      "name is important! needed for MOVE-CORRESPONDING from node compound structure
      END OF ty_node_data_extract,
      BEGIN OF ty_node_data,
        node_key       TYPE /bobf/obm_node_key,
        t_data_extract TYPE STANDARD TABLE OF ty_node_data_extract WITH KEY key,
      END OF ty_node_data,
      BEGIN OF ty_failed_location,
        node_key TYPE /bobf/obm_node_key,
        key      TYPE /bobf/conf_key,
        root_key TYPE /bobf/conf_key,
      END OF ty_failed_location.
    DATA:
      lt_all_data_by_node  TYPE STANDARD TABLE OF ty_node_data,
      lt_all_root_keys     TYPE /bobf/t_frw_key,
      ls_this_node_data    TYPE ty_node_data,
      lrt_node_data        TYPE REF TO data,
      ls_failed_location   TYPE ty_failed_location,
      ls_root_node         TYPE /bobf/s_confro_node,
      lt_root_data_extract TYPE SORTED TABLE OF ty_root_data_extract WITH NON-UNIQUE KEY key,
      lt_failed_location   TYPE STANDARD TABLE OF ty_failed_location.
    FIELD-SYMBOLS:
      <lt_this_node_data> TYPE STANDARD TABLE,
      <lt_root_node_data> TYPE STANDARD TABLE.

    CLEAR: eo_message, et_failed_node.

    " Step 1: Read data for all created node instances.
    "         Collect data extracts and root keys.
    LOOP AT it_create_node INTO DATA(ls_create_node) WHERE node <> mo_conf->ms_obj-root_node_key " ROOT has no parent => nothing to check #EC CI_SORTSEQ
    GROUP BY ls_create_node-node INTO ls_this_node_data-node_key. " ls_this_node_data-node_key needs to contain the node_key. Directly grouping into this field saves one MOVE statement
      mo_conf->get_node( ls_this_node_data-node_key ).
      CHECK mo_conf->ms_last_node-node_type = /bobf/if_conf_c=>sc_node_type_normal.

      " retrieve my own node data:
      CREATE DATA lrt_node_data TYPE (mo_conf->ms_last_node-data_table_type).
      ASSIGN lrt_node_data->* TO <lt_this_node_data>.
      retrieve( EXPORTING iv_node_key = ls_this_node_data-node_key
                          it_key      = VALUE #( FOR ls_node_key IN GROUP ls_this_node_data-node_key ( key = ls_node_key-key ) )
                          iv_state    = /bobf/if_conf_c=>sc_state_current
                IMPORTING et_data     = <lt_this_node_data> ).
      " collect data extract:
      INSERT ls_this_node_data INTO TABLE lt_all_data_by_node ASSIGNING FIELD-SYMBOL(<ls_this_data_by_node>).
      <ls_this_data_by_node>-t_data_extract = CORRESPONDING #( <lt_this_node_data> ). " creating a statically typed data extract saves lots of ASSIGN COMPONENTs
      " collect root keys:
      lt_all_root_keys = CORRESPONDING #( BASE ( lt_all_root_keys ) <ls_this_data_by_node>-t_data_extract MAPPING key = root_key ).
    ENDLOOP.

    CHECK lt_all_data_by_node IS NOT INITIAL. "can happen, e.g., for a single root node CREATE

    " feed the garbage collector:
    UNASSIGN <lt_this_node_data>.
    CLEAR lrt_node_data.

    " Step 2: prepare an extract of the root data:
    SORT lt_all_root_keys.
    DELETE ADJACENT DUPLICATES FROM lt_all_root_keys.
    mo_conf->get_node( EXPORTING iv_node_key = mo_conf->ms_obj-root_node_key
                       IMPORTING es_node     = ls_root_node ).
    CREATE DATA lrt_node_data TYPE (ls_root_node-data_table_type).
    ASSIGN lrt_node_data->* TO <lt_root_node_data>.
    retrieve( EXPORTING iv_node_key = mo_conf->ms_obj-root_node_key
                        it_key      = lt_all_root_keys
                        iv_state    = /bobf/if_conf_c=>sc_state_current
              IMPORTING et_data     = <lt_root_node_data> ).
    lt_root_data_extract = CORRESPONDING #( <lt_root_node_data> ). " creating a statically typed data extract saves lots of ASSIGN COMPONENTs
    " feed the garbage collector:
    UNASSIGN <lt_root_node_data>.
    CLEAR lrt_node_data.

    " Step 3: check consistency of IS_ACTIVE_ENTITY flag for all nodes:
    IF lines( lt_root_data_extract ) = 1.
      "here, we can use a (slightly) faster algorithm than for the other case
      DATA(lv_expected_is_active) = lt_root_data_extract[ 1 ]-isactiveentity.
      LOOP AT lt_all_data_by_node ASSIGNING <ls_this_data_by_node>.
        LOOP AT <ls_this_data_by_node>-t_data_extract INTO DATA(ls_this_node_data_extract) WHERE isactiveentity <> lv_expected_is_active.
          INSERT VALUE #( node_key = <ls_this_data_by_node>-node_key
                          key      = ls_this_node_data_extract-key
                          root_key = ls_this_node_data_extract-root_key ) INTO TABLE lt_failed_location.
        ENDLOOP.
      ENDLOOP.
    ELSE.
      LOOP AT lt_all_data_by_node ASSIGNING <ls_this_data_by_node>.
        LOOP AT <ls_this_data_by_node>-t_data_extract INTO ls_this_node_data_extract.
          IF ls_this_node_data_extract-isactiveentity
          <> lt_root_data_extract[ key = ls_this_node_data_extract-root_key ]-isactiveentity.
            INSERT VALUE #( node_key = <ls_this_data_by_node>-node_key
                            key      = ls_this_node_data_extract-key
                            root_key = ls_this_node_data_extract-root_key ) INTO TABLE lt_failed_location.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
    ENDIF.

    " Step 4: create error messages and failed nodes:
    IF lt_failed_location IS NOT INITIAL.
      IF eo_message IS NOT BOUND.
        eo_message = /bobf/cl_frw_factory=>get_message( ).
      ENDIF.
      LOOP AT lt_failed_location INTO ls_failed_location.
        eo_message->add_cm( NEW /bobf/cm_frw_common_esi( textid             = /bobf/cm_frw_common_esi=>cm_invalid_composition
                                                         severity           = /bobf/cm_frw=>co_severity_error
                                                         symptom            = /bobf/if_frw_message_symptoms=>co_service_contract_violation
                                                         lifetime           = /bobf/cm_frw=>co_lifetime_transition
                                                         ms_origin_location = VALUE #( bo_key   = mo_conf->ms_obj-bo_key
                                                                                       node_key = ls_failed_location-node_key
                                                                                       key      = ls_failed_location-key
                                                                                       attributes = VALUE #( ( CONV #( if_draft_constants=>co_db_fieldname-is_active_entity ) ) ) ) ) ).
        INSERT VALUE #( node = ls_failed_location-node_key
                        key  = ls_failed_location-key ) INTO TABLE et_failed_node.
        "test whether the root node key is also newly created
        IF line_exists( it_create_node[ node = mo_conf->ms_obj-root_node_key
                                        key  = ls_failed_location-root_key ] ).
          "add it to the failed keys too (duplicates are removed below)
          INSERT VALUE #( node = mo_conf->ms_obj-root_node_key
                          key  = ls_failed_location-root_key ) INTO TABLE et_failed_node.
        ENDIF.
      ENDLOOP.
      DELETE ADJACENT DUPLICATES FROM et_failed_node. "created ROOT keys may be added more than once
    ENDIF.

  ENDMETHOD.


  METHOD check_modification_properties.

    TYPES:
      BEGIN OF ty_mod_with_location,
        location TYPE /bobf/s_frw_location,
        mod      TYPE REF TO /bobf/s_frw_modification,
      END OF ty_mod_with_location,
      tt_mod_with_location TYPE STANDARD TABLE OF ty_mod_with_location,
      BEGIN OF ty_tabix_range,
        from TYPE sytabix,
        to   TYPE sytabix,
      END OF ty_tabix_range,
      BEGIN OF ty_group,
        node_key                   TYPE /bobf/obm_node_key,
        node_key_source            TYPE /bobf/obm_node_key,
        check_services             TYPE abap_bool,
        check_services_source      TYPE abap_bool,
        t_modification_tabix_range TYPE STANDARD TABLE OF ty_tabix_range WITH EMPTY KEY,
        t_key                      TYPE /bobf/t_frw_key,
        t_key_source               TYPE /bobf/t_frw_key,
        t_property                 TYPE /bobf/t_frw_property_k_sorted,
        t_property_source          TYPE /bobf/t_frw_property_k_sorted,
      END OF ty_group.

    DATA:
      ls_node                TYPE /bobf/s_frw_node,
      lo_property            TYPE REF TO /bobf/if_frw_property,
      lo_property_source     TYPE REF TO /bobf/if_frw_property,
      lt_key                 TYPE /bobf/t_frw_key,
      lt_key_source          TYPE /bobf/t_frw_key,
      lv_changed_field       TYPE string,
      lv_group_change        TYPE boole_d,
      lo_message             TYPE REF TO /bobf/if_frw_message,
      ls_location            TYPE /bobf/s_frw_location,
      lt_read_only_update    TYPE tt_mod_with_location,
      lt_read_only_location  TYPE /bobf/t_frw_location,
      lm_common_esi          TYPE REF TO /bobf/cm_frw_common_esi,
      lrt_node_data          TYPE REF TO data,
      ls_current_group_range TYPE ty_tabix_range,
      ls_group               TYPE ty_group,
      lt_group               TYPE SORTED TABLE OF ty_group WITH UNIQUE KEY node_key node_key_source check_services check_services_source.

    FIELD-SYMBOLS:
      <lt_node_data> TYPE STANDARD TABLE,
      <ls_mod>       TYPE /bobf/s_frw_modification,
      <ls_mod1>      TYPE /bobf/s_frw_modification,
      <ls_mod_next>  TYPE /bobf/s_frw_modification,
      <ls_group>     TYPE ty_group.

    CLEAR:
      eo_message,
      et_failed.

    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Pass 1: sort the modifications into groups for which the property checks are identical:
    LOOP AT ct_modification ASSIGNING <ls_mod1>.
      ls_current_group_range-to = sy-tabix.

      IF lt_key IS INITIAL.
        " at the beginning of a new group
        ls_current_group_range-from = sy-tabix.

        ls_group-check_services = mo_conf->ms_obj-check_services.
        IF <ls_mod1>-association IS NOT INITIAL.
          ls_group-check_services_source = mo_conf->ms_obj-check_services.
          ls_group-node_key_source = <ls_mod1>-source_node.
        ENDIF.

        IF  <ls_mod1>-change_mode          = /bobf/if_frw_c=>sc_modify_create
        AND mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn.

          ls_group-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.

          IF <ls_mod1>-association IS NOT INITIAL.
            READ TABLE ct_modification TRANSPORTING NO FIELDS WITH KEY change
              COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                         node        = <ls_mod1>-source_node
                         key         = <ls_mod1>-source_key.
            IF sy-subrc = 0.
              ls_group-check_services_source = /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      APPEND VALUE #( key = <ls_mod1>-key ) TO lt_key.

      IF  <ls_mod1>-change_mode = /bobf/if_frw_c=>sc_modify_create
      AND <ls_mod1>-association IS NOT INITIAL.
        APPEND VALUE #( key = <ls_mod1>-source_key ) TO lt_key_source.
      ENDIF.

      " check for group change:
      READ TABLE ct_modification ASSIGNING <ls_mod_next> INDEX ls_current_group_range-to + 1.
      IF sy-subrc = 0.
        " reasons for a group change:
        " - node change
        " - different associations
        " - different values for LV_CHECK_SERVICES (--> dynamic checks enabled AND create <> {update, delete} )
        " - different values for LV_CHECK_SERVICES_SOURCE
        IF <ls_mod1>-node        <> <ls_mod_next>-node
        OR <ls_mod1>-association <> <ls_mod_next>-association
        OR ( mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn AND
             <ls_mod1>-change_mode <> <ls_mod_next>-change_mode AND
             ( <ls_mod1>-change_mode     = /bobf/if_frw_c=>sc_modify_create OR
               <ls_mod_next>-change_mode = /bobf/if_frw_c=>sc_modify_create ) ).
          lv_group_change = abap_true.
        ELSEIF <ls_mod_next>-association IS NOT INITIAL
           AND mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn.
          " will there be a change in LV_CHECK_SERVICES_SOURCE?
          READ TABLE ct_modification TRANSPORTING NO FIELDS WITH KEY change
           COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                      node        = <ls_mod_next>-source_node
                      key         = <ls_mod_next>-source_key.
          IF sy-subrc = 0 AND ls_group-check_services_source <> /bobf/if_conf_c=>sc_check_services_stat_dyn_cre.
            lv_group_change = abap_true.
          ELSEIF sy-subrc <> 0 AND ls_group-check_services_source <> /bobf/if_conf_c=>sc_check_services_stat_dyn.
            lv_group_change = abap_true.
          ENDIF.
        ENDIF.
      ELSE.
        lv_group_change = abap_true. " last entry
      ENDIF.

      " at end of one node: read all properties and maintain modifications of node
      IF lv_group_change = abap_true.

        ls_group-node_key = <ls_mod1>-node.
        " find a matching group entry or create one:
        READ TABLE lt_group ASSIGNING <ls_group> FROM ls_group.
        IF sy-subrc <> 0.
          INSERT ls_group INTO TABLE lt_group ASSIGNING <ls_group>.
        ENDIF.
        INSERT ls_current_group_range INTO TABLE <ls_group>-t_modification_tabix_range.
        INSERT LINES OF lt_key INTO TABLE <ls_group>-t_key.
        INSERT LINES OF lt_key_source INTO TABLE <ls_group>-t_key_source.

        CLEAR:
          lv_group_change,
          lt_key,
          lt_key_source,
          ls_group.
      ENDIF.
    ENDLOOP.

    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Pass 2: For each collected group, retrieve the properties
    "         with (almost) a minimum of calls to RETRIEVE_PROPERTY
    LOOP AT lt_group ASSIGNING <ls_group>.

      /bobf/if_frw_service_layer~retrieve_property(
        EXPORTING
          iv_node_key                = <ls_group>-node_key
          it_key                     = <ls_group>-t_key
          iv_check_services          = <ls_group>-check_services
          iv_node_property           = abap_true
          iv_node_attribute_property = abap_true
          iv_assoc_property          = abap_false
        IMPORTING
          eo_property                = lo_property
          eo_message                 = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF <ls_group>-t_key_source IS NOT INITIAL.
        SORT <ls_group>-t_key_source.                  "#EC CI_SORTLOOP
        DELETE ADJACENT DUPLICATES FROM <ls_group>-t_key_source.
        /bobf/if_frw_service_layer~retrieve_property(
          EXPORTING
            iv_node_key                = <ls_group>-node_key_source
            it_key                     = <ls_group>-t_key_source
            iv_check_services          = <ls_group>-check_services_source
            iv_node_property           = abap_false
            iv_node_attribute_property = abap_false
            iv_assoc_property          = abap_true
          IMPORTING
            eo_property                = lo_property_source
            eo_message                 = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ELSE.
        CLEAR lo_property_source.
      ENDIF.

      IF  lo_property_source IS NOT BOUND
      AND lo_property        IS NOT BOUND.
        DELETE lt_group.
        CONTINUE.
      ENDIF.

      IF lo_property IS BOUND.
        lo_property->get_property( IMPORTING et_property_sorted = <ls_group>-t_property ).
        " Remove irrelevant (all non-restricting) properties:
        DELETE <ls_group>-t_property
         WHERE ( ( property_name = /bobf/if_conf_c=>sc_property_name_create_enable OR
                   property_name = /bobf/if_conf_c=>sc_property_name_update_enable OR
                   property_name = /bobf/if_conf_c=>sc_property_name_delete_enable OR
                   property_name = /bobf/if_conf_c=>sc_property_name_enabled          ) AND value = abap_true )
              OR ( property_name = /bobf/if_conf_c=>sc_property_name_readonly           AND value = abap_false ). "#EC CI_SORTSEQ
      ENDIF.

      IF lo_property_source IS BOUND.
        lo_property_source->get_property( IMPORTING et_property_sorted = <ls_group>-t_property_source ).
        " Remove irrelevant (all non-restricting) properties:
        DELETE <ls_group>-t_property_source
         WHERE ( property_name = /bobf/if_conf_c=>sc_property_name_create_enable OR
                 property_name = /bobf/if_conf_c=>sc_property_name_enabled          ) AND value = abap_true. "#EC CI_SORTSEQ
      ENDIF.

    ENDLOOP.

    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Pass 3: Loop at the individual modifications and check the relevant
    "         properties. By looping at the groups, the modifications are
    "         are not checked in their original order, but this should not
    "         be a problem.
    LOOP AT lt_group ASSIGNING <ls_group>.
      ls_node-node         = <ls_group>-node_key.
      ls_location-node_key = <ls_group>-node_key.
      LOOP AT <ls_group>-t_modification_tabix_range INTO ls_current_group_range.
        LOOP AT ct_modification FROM ls_current_group_range-from TO ls_current_group_range-to ASSIGNING <ls_mod>.
          ls_node-key     = <ls_mod>-key.
          ls_location-key = <ls_mod>-key.
          CLEAR ls_location-attributes.

          CASE <ls_mod>-change_mode.

* ___________________________________________________________________________ *
*           create
            WHEN /bobf/if_frw_c=>sc_modify_create.

              " check association create enabled
              IF <ls_mod>-association IS NOT INITIAL AND <ls_group>-t_property_source IS NOT INITIAL.
                READ TABLE <ls_group>-t_property_source
                  WITH KEY  parent_key    = <ls_mod>-source_key
                            content_cat   = /bobf/if_conf_c=>sc_content_ass
                            content_key   = <ls_mod>-association
                            property_name = /bobf/if_conf_c=>sc_property_name_create_enable
                            value         = abap_false
                  TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
                  CREATE OBJECT lm_common_esi
                    EXPORTING
                      textid             = /bobf/cm_frw_common_esi=>cm_node_create_disabled
                      severity           = /bobf/cm_frw=>co_severity_error
                      symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                      lifetime           = /bobf/cm_frw=>co_lifetime_transition
                      ms_origin_location = ls_location.
                  IF eo_message IS NOT BOUND.
                    eo_message = /bobf/cl_frw_factory=>get_message( ).
                  ENDIF.
                  eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                  INSERT ls_node INTO TABLE et_failed.
                  CONTINUE.
                ENDIF.

                READ TABLE <ls_group>-t_property_source
                  WITH KEY parent_key    = <ls_mod>-source_key
                           content_cat   = /bobf/if_conf_c=>sc_content_ass
                           content_key   = <ls_mod>-association
                           property_name = /bobf/if_conf_c=>sc_property_name_enabled
                           value         = abap_false
                  TRANSPORTING NO FIELDS.
                IF sy-subrc = 0.
                  CREATE OBJECT lm_common_esi
                    EXPORTING
                      textid             = /bobf/cm_frw_common_esi=>cm_node_create_disabled
                      severity           = /bobf/cm_frw=>co_severity_error
                      symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                      lifetime           = /bobf/cm_frw=>co_lifetime_transition
                      ms_origin_location = ls_location.
                  IF eo_message IS NOT BOUND.
                    eo_message = /bobf/cl_frw_factory=>get_message( ).
                  ENDIF.
                  eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                  INSERT ls_node INTO TABLE et_failed.
                  CONTINUE.
                ENDIF.
              ENDIF.

              " check node create enabled
              READ TABLE <ls_group>-t_property
                WITH KEY parent_key    = <ls_mod>-key
                         content_cat   = /bobf/if_conf_c=>sc_content_nod
                         content_key   = <ls_mod>-node
                         property_name = /bobf/if_conf_c=>sc_property_name_create_enable
                         value         = abap_false
                TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CREATE OBJECT lm_common_esi
                  EXPORTING
                    textid             = /bobf/cm_frw_common_esi=>cm_node_create_disabled
                    severity           = /bobf/cm_frw=>co_severity_error
                    symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                    lifetime           = /bobf/cm_frw=>co_lifetime_transition
                    ms_origin_location = ls_location.
                IF eo_message IS NOT BOUND.
                  eo_message = /bobf/cl_frw_factory=>get_message( ).
                ENDIF.
                eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                INSERT ls_node INTO TABLE et_failed.
                CONTINUE.
              ENDIF.

              IF <ls_mod>-changed_fields IS NOT INITIAL.
                " check attributes changeable
                LOOP AT <ls_mod>-changed_fields INTO lv_changed_field
                  WHERE table_line <> /bobf/if_conf_c=>sc_attribute_name_key
                    AND table_line <> /bobf/if_conf_c=>sc_attribute_name_parent_key
                    AND table_line <> /bobf/if_conf_c=>sc_attribute_name_root_key.
                  CLEAR ls_location-attributes.
                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                             value          = abap_true
                    TRANSPORTING NO FIELDS.

                  IF sy-subrc = 0.
                    " field not changeable -> remove field and add error message
                    DELETE <ls_mod>-changed_fields.
                    APPEND lv_changed_field TO ls_location-attributes.
                    CREATE OBJECT lm_common_esi
                      EXPORTING
                        textid              = /bobf/cm_frw_common_esi=>cm_attr_read_only
                        severity            = /bobf/cm_frw=>co_severity_error
                        symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                        lifetime            = /bobf/cm_frw=>co_lifetime_transition
                        ms_origin_location  = ls_location
                        cmn_attr_proxy_name = lv_changed_field.
                    IF eo_message IS NOT BOUND.
                      eo_message = /bobf/cl_frw_factory=>get_message( ).
                    ENDIF.
                    eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                    CONTINUE.
                  ENDIF.

                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                             value          = abap_false
                    TRANSPORTING NO FIELDS.

                  IF sy-subrc = 0.
                    " field not enabled -> remove field and add error message
                    DELETE <ls_mod>-changed_fields.
                    APPEND lv_changed_field TO ls_location-attributes.
                    CREATE OBJECT lm_common_esi
                      EXPORTING
                        textid              = /bobf/cm_frw_common_esi=>cm_attr_disabled
                        severity            = /bobf/cm_frw=>co_severity_error
                        symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                        lifetime            = /bobf/cm_frw=>co_lifetime_transition
                        ms_origin_location  = ls_location
                        cmn_attr_proxy_name = lv_changed_field.
                    IF eo_message IS NOT BOUND.
                      eo_message = /bobf/cl_frw_factory=>get_message( ).
                    ENDIF.
                    eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                  ENDIF.
                ENDLOOP.

                IF <ls_mod>-changed_fields IS INITIAL.
                  " check if node is delegated node
                  IF mo_conf->ms_last_node-node_key <> <ls_mod>-node.
                    mo_conf->get_node( <ls_mod>-node ).
                  ENDIF.
                  " no changeable fields left -> clear modification data
                  IF mo_conf->ms_last_node-delegation_class IS INITIAL.
                    CLEAR <ls_mod>-data.
                  ENDIF.
                ENDIF.

              ELSE.
                " No changed fields specified -> Derive changed fields out of properties
                IF mo_conf->ms_last_node-node_key <> <ls_mod>-node.
                  mo_conf->get_node( <ls_mod>-node ).
                ENDIF.
**********************************************************************
*                TODO (performance): Instead of looping over all field names,
*                        we could check if there is any disabled field at all with a single READ TABLE.
*                  OR: we could fetch all disabled fields and calculate the inverse list
*                NOTE that <ls_mod>-changed_fields is cleared anyway below if it equals the list of all available fields!!
**********************************************************************
                LOOP AT mo_conf->ms_last_node-field_names->* INTO lv_changed_field
                  WHERE table_line <> /bobf/if_conf_c=>sc_attribute_name_key
                    AND table_line <> /bobf/if_conf_c=>sc_attribute_name_parent_key
                    AND table_line <> /bobf/if_conf_c=>sc_attribute_name_root_key.
                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                             value          = abap_true
                    TRANSPORTING NO FIELDS.
                  IF sy-subrc = 0.
                    " Field is read-only -> skip it
                    CONTINUE.
                  ENDIF.
                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                             value          = abap_false
                  TRANSPORTING NO FIELDS.
                  IF sy-subrc = 0.
                    " Field is disabled -> skip it
                    CONTINUE.
                  ENDIF.
                  INSERT lv_changed_field INTO TABLE <ls_mod>-changed_fields.
                ENDLOOP.

                IF <ls_mod>-changed_fields IS INITIAL.
                  " check if node is delegated node
                  IF mo_conf->ms_last_node-delegation_class IS INITIAL.
                    " no changeable fields left -> clear modification data
                    CLEAR <ls_mod>-data.
                  ENDIF.
                ELSEIF <ls_mod>-changed_fields = mo_conf->ms_last_node-field_names->*.
                  " If all fields may be moved -> drop changed fields for better performance in buffer
                  CLEAR <ls_mod>-changed_fields.
                ENDIF.
              ENDIF.


* ___________________________________________________________________________ *
*         update
            WHEN /bobf/if_frw_c=>sc_modify_update.
              " check node update enabled
              READ TABLE <ls_group>-t_property
                WITH KEY parent_key    = <ls_mod>-key
                         content_cat   = /bobf/if_conf_c=>sc_content_nod
                         content_key   = <ls_mod>-node
                         property_name = /bobf/if_conf_c=>sc_property_name_update_enable
                         value         = abap_false
                TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CREATE OBJECT lm_common_esi
                  EXPORTING
                    textid             = /bobf/cm_frw_common_esi=>cm_node_update_disabled
                    severity           = /bobf/cm_frw=>co_severity_error
                    symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                    lifetime           = /bobf/cm_frw=>co_lifetime_transition
                    ms_origin_location = ls_location.
                IF eo_message IS NOT BOUND.
                  eo_message = /bobf/cl_frw_factory=>get_message( ).
                ENDIF.
                eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                INSERT ls_node INTO TABLE et_failed.
                CONTINUE.
              ENDIF.

              " check attributes changeable
              IF <ls_mod>-changed_fields IS NOT INITIAL.
                LOOP AT <ls_mod>-changed_fields INTO lv_changed_field.
                  CLEAR ls_location-attributes.
                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                             value          = abap_true
                     TRANSPORTING NO FIELDS.

                  IF sy-subrc = 0.
                    " field not changeable -> remove field and add error message
                    DELETE <ls_mod>-changed_fields.
                    APPEND lv_changed_field TO ls_location-attributes.
                    INSERT VALUE #( location = ls_location
                                    mod      = REF #( <ls_mod> ) ) INTO TABLE lt_read_only_update.
                    CONTINUE.
                  ENDIF.

                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                             value          = abap_false
                    TRANSPORTING NO FIELDS.

                  IF sy-subrc = 0.
                    " field not enabled -> remove field and add error message
                    DELETE <ls_mod>-changed_fields.
                    APPEND lv_changed_field TO ls_location-attributes.
                    CREATE OBJECT lm_common_esi
                      EXPORTING
                        textid              = /bobf/cm_frw_common_esi=>cm_attr_disabled
                        severity            = /bobf/cm_frw=>co_severity_error
                        symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                        lifetime            = /bobf/cm_frw=>co_lifetime_transition
                        ms_origin_location  = ls_location
                        cmn_attr_proxy_name = lv_changed_field.
                    IF eo_message IS NOT BOUND.
                      eo_message = /bobf/cl_frw_factory=>get_message( ).
                    ENDIF.
                    eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                  ENDIF.
                ENDLOOP.

                IF <ls_mod>-changed_fields IS INITIAL.
                  " no changeable fields left -> remove modification and add failed change
                  INSERT ls_node INTO TABLE et_failed.
                  CONTINUE.
                ENDIF.
              ELSE.
                " No changed fields specified -> Derive changed fields out of properties
                IF mo_conf->ms_last_node-node_key <> <ls_mod>-node.
                  mo_conf->get_node( <ls_mod>-node ).
                ENDIF.
                LOOP AT mo_conf->ms_last_node-field_names->* INTO lv_changed_field
                  WHERE table_line <> /bobf/if_conf_c=>sc_attribute_name_key
                    AND table_line <> /bobf/if_conf_c=>sc_attribute_name_parent_key
                    AND table_line <> /bobf/if_conf_c=>sc_attribute_name_root_key.
                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_readonly
                             value          = abap_true
                    TRANSPORTING NO FIELDS.
                  IF sy-subrc = 0.
                    " Field is read-only -> skip it
                    CONTINUE.
                  ENDIF.
                  READ TABLE <ls_group>-t_property
                    WITH KEY parent_key     = <ls_mod>-key
                             content_cat    = /bobf/if_conf_c=>sc_content_nod
                             content_key    = <ls_mod>-node
                             attribute_name = lv_changed_field
                             property_name  = /bobf/if_conf_c=>sc_property_name_enabled
                             value          = abap_false
                  TRANSPORTING NO FIELDS.
                  IF sy-subrc = 0.
                    " Field is disabled -> skip it
                    CONTINUE.
                  ENDIF.
                  INSERT lv_changed_field INTO TABLE <ls_mod>-changed_fields.
                ENDLOOP.

                IF <ls_mod>-changed_fields IS INITIAL.
                  " no changeable fields left -> remove modification and add failed change
                  INSERT ls_node INTO TABLE et_failed.
                  CONTINUE.
                ENDIF.

              ENDIF.

* ___________________________________________________________________________ *
*           delete
            WHEN /bobf/if_frw_c=>sc_modify_delete.
              " check node delete enabled
              READ TABLE <ls_group>-t_property
                 WITH KEY parent_key    = <ls_mod>-key
                          content_cat   = /bobf/if_conf_c=>sc_content_nod
                          content_key   = <ls_mod>-node
                          property_name = /bobf/if_conf_c=>sc_property_name_delete_enable
                          value         = abap_false
                 TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CREATE OBJECT lm_common_esi
                  EXPORTING
                    textid             = /bobf/cm_frw_common_esi=>cm_node_delete_disabled
                    severity           = /bobf/cm_frw=>co_severity_error
                    symptom            = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                    lifetime           = /bobf/cm_frw=>co_lifetime_transition
                    ms_origin_location = ls_location.
                IF eo_message IS NOT BOUND.
                  eo_message = /bobf/cl_frw_factory=>get_message( ).
                ENDIF.
                eo_message->add_cm( EXPORTING io_message = lm_common_esi ).
                INSERT ls_node INTO TABLE et_failed.
                CONTINUE.
              ENDIF.

          ENDCASE.

        ENDLOOP. "modification
      ENDLOOP. "group tabix range
    ENDLOOP. "group

    IF lt_read_only_update IS NOT INITIAL.
      " LT_READ_ONLY_UPDATE is the list of all modifications which affect read-only fields.
      " We want to send errors messages only for such changes which attempt to set a value differing from the current buffer value.

      " Find "dummy" changes, i.e. modifications which set the same value as currently in the buffer:
      LOOP AT lt_read_only_update ASSIGNING FIELD-SYMBOL(<ls_group_by_node>)
                                  GROUP BY ( node_key = <ls_group_by_node>-location-node_key ).
        "create an ET_DATA container for the RETRIEVE call below:
        mo_conf->get_node( <ls_group_by_node>-location-node_key ).
        CREATE DATA lrt_node_data TYPE STANDARD TABLE OF (mo_conf->ms_last_node-data_type).
        ASSIGN lrt_node_data->* TO <lt_node_data>.

        "compare modifications with buffer, one-by-one:
        "(assuming that the number of changes to read-only fields will be small,
        " there should not be a very big performance impact caused by doing single RETRIEVES.
        " After all, pure buffer retrieves are not too slow.):
        LOOP AT GROUP <ls_group_by_node> ASSIGNING FIELD-SYMBOL(<ls_read_only_update>) WHERE mod->data IS BOUND.
          DATA(lv_same_values) = abap_false.
          TRY.
              mo_buffer->retrieve(
                EXPORTING iv_node_key    = <ls_read_only_update>-location-node_key
                          it_key         = VALUE #( ( key = <ls_read_only_update>-location-key ) )
                          iv_state       = iv_state
                          iv_fill_data   = abap_true
                          iv_buffer_only = abap_true "if it's not in the buffer, we don't bother to fetch it
                IMPORTING et_data        = <lt_node_data> ).
              IF <lt_node_data> IS NOT INITIAL.
                ASSIGN COMPONENT <ls_read_only_update>-location-attributes[ 1 ] OF STRUCTURE <lt_node_data>[ 1 ]
                       TO FIELD-SYMBOL(<lv_attr_in_buffer>).
                ASSIGN <ls_read_only_update>-mod->data->* TO FIELD-SYMBOL(<ls_mod_data>).
                ASSIGN COMPONENT <ls_read_only_update>-location-attributes[ 1 ] OF STRUCTURE <ls_mod_data>
                       TO FIELD-SYMBOL(<lv_attr_in_mod>).
                IF <lv_attr_in_buffer> = <lv_attr_in_mod>.
                  lv_same_values = abap_true.
                ENDIF.
              ENDIF.
            CATCH /bobf/cx_frw ##no_handler.
          ENDTRY.
          IF lv_same_values = abap_false.
            INSERT <ls_read_only_update>-location INTO TABLE lt_read_only_location.
          ENDIF.
        ENDLOOP.
        UNASSIGN: <lv_attr_in_buffer>, <lv_attr_in_mod>. "paranoia
      ENDLOOP.

      " send error messages for the remaining (real) changes
      IF lt_read_only_location IS NOT INITIAL.
        IF eo_message IS NOT BOUND.
          eo_message = /bobf/cl_frw_factory=>get_message( ).
        ENDIF.
        LOOP AT lt_read_only_location ASSIGNING FIELD-SYMBOL(<ls_read_only_location>).
          eo_message->add_cm( NEW /bobf/cm_frw_common_esi(
                                      textid              = /bobf/cm_frw_common_esi=>cm_attr_read_only
                                      severity            = /bobf/cm_frw=>co_severity_error
                                      symptom             = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
                                      lifetime            = /bobf/cm_frw=>co_lifetime_transition
                                      ms_origin_location  = <ls_read_only_location>
                                      cmn_attr_proxy_name = <ls_read_only_location>-attributes[ 1 ] ) ).
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD check_properties_before_modify.
    DATA: lt_failed    TYPE /bobf/t_frw_node,
          lo_message   TYPE REF TO /bobf/if_frw_message,
          lt_failed_do TYPE /bobf/t_frw_node.

    FIELD-SYMBOLS: <ls_mod_do> TYPE /bobf/s_frw_modification_do.

    check_modification_properties( EXPORTING iv_state        = iv_state
                                   IMPORTING eo_message      = lo_message
                                             et_failed       = lt_failed
                                   CHANGING  ct_modification = ct_mod ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = co_message ).

    LOOP AT ct_mod_do ASSIGNING <ls_mod_do>.
      check_modification_properties( EXPORTING iv_state        = iv_state
                                     IMPORTING eo_message      = lo_message
                                               et_failed       = lt_failed_do
                                     CHANGING  ct_modification = <ls_mod_do>-modification ).
      INSERT LINES OF lt_failed_do INTO TABLE lt_failed.
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = co_message ).
    ENDLOOP.

    IF lt_failed IS NOT INITIAL.
*     not all modifications are allowed
      ASSERT ID /bobf/frw_warning CONDITION 0 = 1.         "#EC BOOL_OK

      cleanup_modifications( EXPORTING it_failed_node       = lt_failed
                                       io_change            = io_change
                             CHANGING  ct_mod               = ct_mod
                                       ct_mod_do            = ct_mod_do
                                       ct_lock_created      = ct_lock_created
                                       ct_create            = ct_create
                                       ct_update            = ct_update
                                       ct_delete            = ct_delete
                                       ct_update_data       = ct_update_data
                                       ct_update_data_all   = ct_update_data_all
                                       ct_update_data_sta   = ct_update_data_status
                                       ct_node_state_create = ct_node_state_create
                                       ct_node_category     = ct_node_category ).
    ENDIF.
  ENDMETHOD.


  METHOD class_constructor.
    CALL FUNCTION 'TR_SYS_PARAMS' IMPORTING system_client_role = gv_system_client_role.
  ENDMETHOD.


  METHOD cleanup_modifications.

    DATA: lt_node               TYPE /bobf/t_frw_node,
          ls_node               TYPE /bobf/s_frw_node,
          lt_failed_root_key    TYPE /bobf/t_frw_key,
          lt_root_key           TYPE /bobf/t_frw_key,
          ls_key                TYPE /bobf/s_frw_key,
          lt_key                TYPE /bobf/t_frw_key,
          ls_mod                TYPE /bobf/s_frw_modification,
          ls_mod2               TYPE /bobf/s_frw_modification,
          lt_mod                TYPE /bobf/t_frw_modification,
          lt_key_link           TYPE /bobf/t_frw_key_link,
          ls_key_link           TYPE /bobf/s_frw_key_link,
          lo_delegation         TYPE REF TO /bobf/if_frw_delegation,
          lo_change             TYPE REF TO /bobf/cl_frw_change,
          lv_create             TYPE boole_d,
          lv_process            TYPE boole_d,
          lv_check_before_image TYPE boole_d,
          lt_node_mod           TYPE /bobf/t_frw_node_mod,
          ls_node_mod           TYPE /bobf/s_frw_node_mod,
          lv_index              TYPE i,
          lx_root               TYPE REF TO cx_root.

    FIELD-SYMBOLS:
          <ls_mod_do>           TYPE /bobf/s_frw_modification_do.

    lo_change ?= io_change.

    CHECK it_failed_node     IS NOT INITIAL OR
          it_failed_root_key IS NOT INITIAL.

* ___________________________________________________________________________ *
* get root keys
    IF it_failed_node IS NOT INITIAL.
      get_root_key_modify(
        EXPORTING
          it_node   = it_failed_node
          iv_state  = /bobf/if_conf_c=>sc_state_current
          io_change = io_change
        IMPORTING
          et_key    = lt_failed_root_key
        CHANGING
          ct_mod    = ct_mod ).

    ELSE.
      lt_failed_root_key = it_failed_root_key.
    ENDIF.

* ___________________________________________________________________________ *
* cleanup DO modifications
    LOOP AT ct_mod_do ASSIGNING <ls_mod_do>.
      LOOP AT <ls_mod_do>-modification INTO ls_mod.
        lv_index = sy-tabix.
        AT NEW change_mode.
          IF ls_mod-change_mode = /bobf/if_frw_c=>sc_modify_create.
            lv_create = abap_true.
          ELSE.
            lv_create = abap_false.
          ENDIF.
        ENDAT.

        AT END OF node.
          lv_process = abap_true.
        ENDAT.

        IF lv_process = abap_false.
          AT END OF change_mode.
            IF lv_create = abap_true.
              lv_process = abap_true.
            ELSE.
              READ TABLE <ls_mod_do>-modification INTO ls_mod2 INDEX lv_index + 1.
              IF ls_mod2-change_mode = /bobf/if_frw_c=>sc_modify_create.
                lv_process = abap_true.
              ENDIF.
            ENDIF.
          ENDAT.
        ENDIF.

        IF lv_create = abap_true.
          ls_key-key = ls_mod-source_key.
        ELSE.
          ls_key-key = ls_mod-key.
        ENDIF.
        APPEND ls_key TO lt_key.

        IF lv_process = abap_true.
          IF ls_mod-node = <ls_mod_do>-delegation_root_node_key AND
              lv_create  = abap_true.
            get_root_key(
              EXPORTING
                iv_node_key         = ls_mod-source_node
                it_key              = lt_key
              IMPORTING
                et_key_link         = lt_key_link ).

          ELSE.
            TRY.
                IF lo_delegation IS NOT BOUND.
                  lo_delegation = get_delegation( <ls_mod_do>-delegation_root_node_key ).
                ENDIF.

                DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                IF lv_create = abap_false.
                  lo_delegation->get_root_key(
                    EXPORTING
                      iv_node_key         = ls_mod-node
                      it_key              = lt_key
                      iv_state            = /bobf/if_conf_c=>sc_state_current
                      io_read             = mo_delegation_read
                    IMPORTING
                      et_key_link         = lt_key_link ).

                ELSE.
                  lo_delegation->get_root_key(
                    EXPORTING
                      iv_node_key         = ls_mod-source_node
                      it_key              = lt_key
                      iv_state            = /bobf/if_conf_c=>sc_state_current
                      io_read             = mo_delegation_read
                    IMPORTING
                      et_key_link         = lt_key_link ).
                ENDIF.
                /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

          LOOP AT lt_key_link INTO ls_key_link.
            READ TABLE lt_failed_root_key WITH KEY key_sort
              COMPONENTS key = ls_key_link-target_key
              TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              IF lv_create = abap_true.
                DELETE <ls_mod_do>-modification WHERE
                    source_node = ls_mod-source_node AND
                    source_key  = ls_key_link-source_key.
                lo_change->add_change(
                  iv_change_mode = /bobf/if_frw_c=>sc_modify_create
                  iv_node_key    = ls_mod-node
                  iv_key         = ls_mod-key
                  iv_failed      = abap_true ).

              ELSE.
                DELETE <ls_mod_do>-modification WHERE
                    node = ls_mod-node AND
                    key  = ls_key_link-source_key.
              ENDIF.
            ENDIF.
          ENDLOOP.

          lv_process = abap_false.
          CLEAR lt_key.
        ENDIF.
        IF <ls_mod_do>-modification IS INITIAL.
          DELETE ct_mod_do.
          EXIT.
        ENDIF.
      ENDLOOP.

      CLEAR lo_delegation.
    ENDLOOP.

* Prepare modifications table with filled root_keys for performance
    CLEAR lt_node.
    LOOP AT ct_mod INTO ls_mod WHERE root_key IS INITIAL.
      CHECK ls_mod-node <> mo_conf->ms_obj-root_node_key.
      IF ls_mod-change_mode = /bobf/if_frw_c=>sc_modify_create.
        ls_node-node = ls_mod-source_node.
        ls_node-key  = ls_mod-source_key.
      ELSE.
        ls_node-node = ls_mod-node.
        ls_node-key  = ls_mod-key.
      ENDIF.
      INSERT ls_node INTO TABLE lt_node.
      IF ls_mod-change_mode = /bobf/if_frw_c=>sc_modify_delete AND
         mv_before_modification_exists = abap_true.
        lv_check_before_image = abap_true.
      ENDIF.
    ENDLOOP.
    IF lt_node IS NOT INITIAL.
      get_root_key_modify(
        EXPORTING
          it_node   = lt_node
          iv_state  = /bobf/if_conf_c=>sc_state_current
          io_change = io_change
        IMPORTING
          et_key    = lt_root_key
        CHANGING
          ct_mod    = ct_mod ).
    ENDIF.
    IF lv_check_before_image = abap_true.
      CLEAR lt_node.
      LOOP AT ct_mod INTO ls_mod WHERE root_key IS INITIAL.
        ls_node-node = ls_mod-node.
        ls_node-key  = ls_mod-key.
        INSERT ls_node INTO TABLE lt_node.
      ENDLOOP.
      IF lt_node IS NOT INITIAL.
        get_root_key_modify(
          EXPORTING
            it_node   = lt_node
            iv_state  = /bobf/if_conf_c=>sc_state_before_modification
            io_change = io_change
          IMPORTING
            et_key    = lt_root_key
          CHANGING
            ct_mod    = ct_mod ).
      ENDIF.
    ENDIF.

* ___________________________________________________________________________ *
* analyse modification tables
    LOOP AT ct_mod INTO ls_mod.    "assigning ? JS

      IF ls_mod-node = mo_conf->ms_obj-root_node_key.
        IF ls_mod-source_node = mo_conf->ms_obj-root_node_key.
          ls_key-key = ls_mod-source_key.
        ELSE.
          ls_key-key = ls_mod-key.
        ENDIF.
        sy-subrc = 0.
      ELSEIF ls_mod-root_key IS NOT INITIAL.
        ls_key-key = ls_mod-root_key.
        sy-subrc = 0.
      ELSE.
        CLEAR lt_node.
        IF ls_mod-change_mode = /bobf/if_frw_c=>sc_modify_create.
          ls_node-node = ls_mod-source_node.
          ls_node-key  = ls_mod-source_key.
        ELSE.
          ls_node-node = ls_mod-node.
          ls_node-key  = ls_mod-key.
        ENDIF.
        INSERT ls_node INTO TABLE lt_node.

        get_root_key_modify(
          EXPORTING
            it_node   = lt_node
            iv_state  = /bobf/if_conf_c=>sc_state_current
            io_change = io_change
          IMPORTING
            et_key    = lt_root_key
          CHANGING
            ct_mod    = ct_mod ).

        IF lt_root_key IS INITIAL AND
           ls_mod-change_mode = /bobf/if_frw_c=>sc_modify_delete AND
           mv_before_modification_exists = abap_true.

          get_root_key_modify(
            EXPORTING
              it_node   = lt_node
              iv_state  = /bobf/if_conf_c=>sc_state_before_modification
              io_change = io_change
            IMPORTING
              et_key    = lt_root_key
            CHANGING
              ct_mod    = ct_mod ).
        ENDIF.

        ASSERT ID /bobf/frw CONDITION lt_root_key IS NOT INITIAL.
        READ TABLE lt_root_key INTO ls_key INDEX 1.
      ENDIF.

      IF sy-subrc = 0.
*     check whether root key is one of the failed
        READ TABLE lt_failed_root_key WITH KEY key_sort
          COMPONENTS key = ls_key-key
          TRANSPORTING NO FIELDS.

        IF sy-subrc <> 0.
*       keep good ones
*       don't delete failed ones to get root key also for following created subnodes
          APPEND ls_mod TO lt_mod.
          CONTINUE.
        ENDIF.
      ENDIF.

*   clear tables as failed root
      CASE ls_mod-change_mode.
        WHEN /bobf/if_frw_c=>sc_modify_create.
          DELETE ct_create
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_lock_created
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_node_state_create
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_node_category
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.

          lo_change->add_change(
            iv_change_mode = ls_mod-change_mode
            iv_node_key    = ls_mod-node
            iv_key         = ls_mod-key
            iv_failed      = abap_true ).

        WHEN /bobf/if_frw_c=>sc_modify_update.
          DELETE ct_update
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_update_data
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_update_data_all
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_update_data_sta
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_node_state_create
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          lo_change->add_change(
            iv_change_mode = ls_mod-change_mode
            iv_node_key    = ls_mod-node
            iv_key         = ls_mod-key
            iv_failed      = abap_true ).

        WHEN /bobf/if_frw_c=>sc_modify_delete.
          DELETE ct_delete
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          DELETE ct_node_state_create
            WHERE node = ls_mod-node
              AND key  = ls_mod-key.
          lo_change->add_change(
            iv_change_mode = ls_mod-change_mode
            iv_node_key    = ls_mod-node
            iv_key         = ls_mod-key
            iv_failed      = abap_true ).
      ENDCASE.
      DELETE ct_load
        WHERE node = ls_mod-node
          AND key  = ls_mod-key.
      DELETE ct_load_only_keyload
        WHERE node = ls_mod-node
          AND key  = ls_mod-key.

*   Remember node instances to clear change notifications
      ls_node_mod-node        = ls_mod-node.
      ls_node_mod-key         = ls_mod-key.
      ls_node_mod-change_mode = ls_mod-change_mode.
      INSERT ls_node_mod INTO TABLE lt_node_mod.
    ENDLOOP.

* Cleanup change notifications for failed instances
    lo_change->failed_modifications( it_node_mod = lt_node_mod ).


    ct_mod = lt_mod.

  ENDMETHOD.


  METHOD cleanup_mods_from_unchanged.

*   Purpose of this method:
*   Update requests containing the same data as the already existing data
*   should be removed from all modification tables
    FIELD-SYMBOLS <ls_unchanged> TYPE /bobf/s_frw_node_data.


    CHECK it_unchanged IS NOT INITIAL.

    LOOP AT it_unchanged ASSIGNING <ls_unchanged>.

      "don't delete the record, if there's another update on the same node instance
      CHECK NOT line_exists( it_changed[ node = <ls_unchanged>-node key = <ls_unchanged>-key ] ).

      DELETE ct_update
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.
      DELETE ct_node_state_create
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.
      DELETE ct_update_data
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.
      DELETE ct_update_data_status
        WHERE node = <ls_unchanged>-node
          AND key  = <ls_unchanged>-key.

      "don't: delete CT_MOD single-wise via secondary index `change`; This is very slow
      "do:    Mark the record for deletion. mass-delete ct_mod after this loop
      READ TABLE ct_mod ASSIGNING FIELD-SYMBOL(<ls_mod>)
        WITH TABLE KEY change
        COMPONENTS
          change_mode = /bobf/if_frw_c=>sc_modify_update
          node        = <ls_unchanged>-node
          key         = <ls_unchanged>-key.
      CHECK sy-subrc = 0."if record is part of status updates, it may not be part of ct_mod
      <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_no_change.

    ENDLOOP.

    DELETE ct_mod USING KEY change WHERE change_mode = /bobf/if_frw_c=>sc_modify_no_change.

  ENDMETHOD.


  METHOD clear_change_save.

    IF it_root_key IS INITIAL.

      CLEAR mo_change_save.

    ELSE.

      " create unique and sorted copy of IT_ROOT_KEY:
      DATA(lt_root_key_unique) = it_root_key.
      SORT lt_root_key_unique BY key.
      DELETE ADJACENT DUPLICATES FROM lt_root_key_unique COMPARING key.

      DELETE mt_change_save WHERE root_keys = lt_root_key_unique.

    ENDIF.

  ENDMETHOD.


  METHOD collect_messages.
    IF io_message IS BOUND.
      IF co_message IS BOUND.
        co_message->add( io_message ).
      ELSE.
        co_message = io_message.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD constructor.

    DATA lx_root TYPE REF TO cx_root.
    DATA lv_trans_enqueue_scope_is_set TYPE boole_d.
    DATA lv_trans_enqueue_scope        TYPE /bobf/conf_enqueue_scope.
    DATA lv_trans_cleanup_mode_is_set  TYPE boole_d.
    DATA lv_trans_cleanup_mode         TYPE /bobf/conf_cleanup_mode.
    DATA lo_if_transaction_manager     TYPE REF TO /bobf/if_tra_transaction_mgr.
    DATA lo_transaction_manager        TYPE REF TO /bobf/cl_tra_transaction_mgr.

* set configuration object
    mo_conf = io_conf.

    mo_lib_draft_active = NEW /bobf/cl_lib_draft_active_util( mo_conf->ms_obj-bo_key ).
    mo_dra_act_diff = NEW /bobf/cl_frw_draft_active_diff( mo_conf ).

    TEST-SEAM on_construct.
      "allow unit tests to exit the constructor at this point
    END-TEST-SEAM.
* ___________________________________________________________________________ *
* create new buffer instance
    ASSERT ID /bobf/frw CONDITION mo_conf->ms_obj IS NOT INITIAL.

    IF mo_conf->ms_obj-buffer_class IS INITIAL.
*    todo exception
      set_configuration_error( ).
    ENDIF.

    TRY.
        CALL METHOD (mo_conf->ms_obj-buffer_class)=>/bobf/if_frw_buffer~get_instance
          EXPORTING
            iv_bo_key       = mo_conf->ms_obj-bo_key
            iv_buffer_class = mo_conf->ms_obj-buffer_class
            io_bopf_handle  = CAST /bobf/if_frw_handle(
                                COND #(
                                   WHEN mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_do
                                     THEN me "supplying framework handle in case of dependent object in order to ensure one buffer instance per framework instance
                                   ELSE VALUE #( ) ) )
          IMPORTING
            eo_buffer       = mo_buffer.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

* The buffer could not be created
    IF mo_buffer IS NOT BOUND.
*    todo exception
      set_application_error( ).
    ENDIF.

* ___________________________________________________________________________ *
* switch optimized state handling off
    IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_tsto.
      mv_modifying_transaction = abap_true.
    ENDIF.

    mv_auth_supr_comp_chi_del_chck = abap_false.
    IF mo_conf->ms_obj-has_authority_checks = abap_false OR
       mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_do.
      "not authority relevant -> create empty authority handler
      CREATE OBJECT mo_authority_handler TYPE /bobf/cl_frw_empty_auth_handlr
        EXPORTING
          io_conf = mo_conf.
    ELSE.
      CREATE OBJECT mo_authority_handler
        EXPORTING
          io_conf = mo_conf.
      DATA(lo_root_authority_checker) = mo_authority_handler->get_authority_checker( mo_conf->ms_obj-root_node_key ).
      IF lo_root_authority_checker IS BOUND.
        TRY.
            DATA(lo_root_authority_customizer) = CAST /bobf/if_lib_auth_custom_gen( lo_root_authority_checker ).
            IF lo_root_authority_customizer IS BOUND.
              mv_auth_supr_comp_chi_del_chck = lo_root_authority_customizer->suppress_comp_child_del_checks( ).
            ENDIF.
          CATCH cx_sy_move_cast_error ##no_handler.
        ENDTRY.
      ENDIF.
    ENDIF.
    /bobf/if_frw_auth_handler_inst~mo_authority_handler = mo_authority_handler.

    " set enqueue scope and cleanup mode from shared object by default
    mv_enqueue_scope = mo_conf->ms_obj-enqueue_scope.
    mv_cleanup_mode  = mo_conf->ms_obj-cleanup_mode.

    " overrule enqueue scope and cleanup mode from Transaction Manager
    " (only if the stand-alone transaction manager is used)
    lo_if_transaction_manager = /bobf/cl_tra_trans_mgr_factory=>get_transaction_manager( ).
    TRY.
        mo_non_cache_reg = CAST /bobf/cl_buf_non_cache_regstry(
           CAST /bobf/if_tra_trans_mgr_compl( lo_if_transaction_manager
           )->mo_non_cache_reg ).
        lo_transaction_manager ?= lo_if_transaction_manager.

        lo_transaction_manager->get_transaction_enqueue_scope(
          IMPORTING
            ev_enqueue_scope_is_set = lv_trans_enqueue_scope_is_set
            ev_enqueue_scope        = lv_trans_enqueue_scope ).
        IF lv_trans_enqueue_scope_is_set = abap_true.
          mv_enqueue_scope = lv_trans_enqueue_scope.
        ENDIF.
        lo_transaction_manager->get_transaction_cleanup_mode(
          IMPORTING
            ev_cleanup_mode_is_set = lv_trans_cleanup_mode_is_set
            ev_cleanup_mode        = lv_trans_cleanup_mode ).
        IF lv_trans_cleanup_mode_is_set = abap_true.
          mv_cleanup_mode = lv_trans_cleanup_mode.
        ENDIF.
      CATCH cx_sy_move_cast_error ##no_handler.
    ENDTRY.

    mv_no_content_changes = CAST /bobf/if_tra_trans_mgr_compl( lo_if_transaction_manager )->mv_no_content_changes.
    mv_loadable = boolc( mo_conf->get_root_node( )-transient = abap_false ).
    TRY.
        mo_lock_manager = /bobf/cl_frw_lock_manager=>create( io_bopf = me ).
      CATCH /bobf/cm_frw INTO lx_root.
        set_configuration_error( lx_root ).
    ENDTRY.


    mo_amount_decimal_converter = NEW /bobf/cl_frw_amount_dec_conv( io_conf   = mo_conf
                                                                    io_buffer = mo_buffer
                                                                    io_service = me ).

  ENDMETHOD.


  METHOD convert_altern_key.

    DATA: ls_node               TYPE /bobf/s_confro_node,
          lt_failed_key         TYPE /bobf/t_frw_key,
          lt_key                TYPE /bobf/t_frw_key,
          ls_key                TYPE /bobf/s_frw_key,
          ls_empty              TYPE REF TO data,
          ls_result             TYPE /bobf/s_frw_keyindex,
          lo_message            TYPE REF TO /bobf/if_frw_message, "#EC NEEDED
          lo_delegation         TYPE REF TO /bobf/if_frw_delegation,
          lx_root               TYPE REF TO cx_root,
          lo_auth_change        TYPE REF TO /bobf/if_frw_change,
          lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message,
          lt_auth_failed_key    TYPE /bobf/t_frw_key.

    FIELD-SYMBOLS: <ls_line>  TYPE any,
                   <ls_empty> TYPE any.

    CLEAR: et_result,
           et_key,
           eo_message,
           eo_change.

* ___________________________________________________________________________ *
* shortcut for KEY -> KEY without existence check
    IF iv_altkey_key      = iv_target_altkey_key                   AND
       iv_altkey_key      = /bobf/if_frw_c=>sc_alternative_key_key AND
       iv_check_existence = abap_false.
      IF iv_fill_target_key = abap_true.
        et_key = it_key.
      ENDIF.
      IF et_result IS REQUESTED.
        LOOP AT it_key INTO ls_key.
          ls_result-index = sy-tabix.
          ls_result-key   = ls_key-key.
          INSERT ls_result INTO TABLE et_result.
        ENDLOOP.
      ENDIF.
      RETURN.
    ENDIF.

* ___________________________________________________________________________ *
* get conf
    IF mo_conf->ms_last_node-node_key = iv_node_key.
      ls_node = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
        EXPORTING iv_node_key = iv_node_key
        IMPORTING es_node     = ls_node ).
    ENDIF.

* ___________________________________________________________________________ *
* check for delegation
    IF ls_node-delegation_class IS NOT INITIAL.
      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.
      TRY.
          lo_delegation = get_delegation( iv_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->convert_altern_key(
            EXPORTING
              iv_node_key                = iv_node_key
              iv_altkey_key              = iv_altkey_key
              iv_target_altkey_key       = iv_target_altkey_key
              it_key                     = it_key
              iv_state                   = iv_state
              iv_check_existence         = iv_check_existence
              iv_invalidate_cache        = iv_invalidate_cache
              iv_buffer_sufficient_hint  = iv_buffer_sufficient_hint
              io_change                  = eo_change
            IMPORTING
              et_result                  = et_result
              et_key                     = et_key ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      RETURN.
    ENDIF.

* ___________________________________________________________________________ *
* check for KEY -> KEY with existence check (on KEY)
    IF iv_altkey_key          = iv_target_altkey_key                   AND
       iv_altkey_key          = /bobf/if_frw_c=>sc_alternative_key_key AND
       ls_node-use_proxy_type = abap_false.

      retrieve(
        EXPORTING
          iv_node_key         = iv_node_key
          it_key              = it_key
          iv_state            = iv_state
          iv_fill_data        = abap_false
          iv_invalidate_cache = iv_invalidate_cache
          iv_buffer_only      = iv_buffer_sufficient_hint
        IMPORTING
          eo_change           = eo_change
          et_failed_key       = lt_failed_key ).

      LOOP AT it_key INTO ls_key.
        ls_result-index = sy-tabix.
        READ TABLE lt_failed_key WITH KEY key_sort
          COMPONENTS key = ls_key-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          CLEAR ls_key.
        ELSEIF et_result IS REQUESTED.
          ls_result-key   = ls_key-key.
          INSERT ls_result INTO TABLE et_result.
        ENDIF.
        IF iv_fill_target_key = abap_true.
          APPEND ls_key TO et_key.
        ENDIF.
      ENDLOOP.
      RETURN.
    ENDIF.

* ___________________________________________________________________________ *
* ask own buffer -> convert alternative key to KEY
    IF ls_node-optimized_buffer_access = abap_true.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

    IF iv_altkey_key          = /bobf/if_frw_c=>sc_alternative_key_key AND
       ls_node-use_proxy_type = abap_false.
*   source key = key
      lt_key = it_key.
      IF et_result IS REQUESTED.
        LOOP AT lt_key INTO ls_key.
          ls_result-index = sy-tabix.
          ls_result-key   = ls_key-key.
          INSERT ls_result INTO TABLE et_result.
        ENDLOOP.
      ENDIF.
    ELSE.
*   source key = altern key
      TRY.
          mo_buffer->convert_altern_key(
            EXPORTING
              iv_node_key                = iv_node_key
              iv_altkey_key              = iv_altkey_key
              it_key                     = it_key
              iv_state                   = iv_state
              iv_invalidate_cache        = iv_invalidate_cache
              iv_buffer_sufficient_hint  = iv_buffer_sufficient_hint
              io_change                  = eo_change
            IMPORTING
              et_result                  = et_result ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      IF ls_node-optimized_buffer_access = abap_true.
        after_loading(
          EXPORTING
            io_change         = eo_change
            iv_load_state     = iv_state
          IMPORTING
            eo_message        = eo_message
             ).
      ENDIF.

*   source == target, but not KEY
      IF iv_altkey_key      = iv_target_altkey_key AND
         iv_fill_target_key = abap_true.
        CREATE DATA ls_empty LIKE LINE OF it_key.
        ASSIGN ls_empty->* TO <ls_empty>.
        LOOP AT it_key ASSIGNING <ls_line>.
          READ TABLE et_result TRANSPORTING NO FIELDS
            WITH KEY index = sy-tabix.
          IF sy-subrc = 0.
            APPEND <ls_line> TO et_key.
          ELSE.
            APPEND <ls_empty> TO et_key.
          ENDIF.
        ENDLOOP.
        lt_key = et_key.
      ELSE.
*     build LT_KEY
        DO lines( it_key ) TIMES.
          APPEND ls_key TO lt_key.
        ENDDO.
        LOOP AT et_result INTO ls_result.
          ls_key-key = ls_result-key.
          MODIFY lt_key INDEX ls_result-index FROM ls_key.
        ENDLOOP.
      ENDIF.

*   check authorization: filter out non-authorized keys
      lo_auth_change = /bobf/cl_frw_factory=>get_change( ).
      DATA lt_auth_key TYPE /bobf/t_frw_key.
      IF et_result IS NOT INITIAL.
        LOOP AT et_result INTO ls_result.
          ls_key-key = ls_result-key.
          APPEND ls_key TO lt_auth_key.
        ENDLOOP.
      ELSE.
        lt_auth_key = lt_key.
      ENDIF.

      DATA(lv_lines_auth_key) = lines( lt_auth_key ).

      mo_authority_handler->check_authority(
        EXPORTING
          io_change        = lo_auth_change
          is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                      activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-convert_altern_key
                                      bo_service          = space
                                      node_key            = iv_node_key )
          iv_cleanse_keys  = abap_true
          io_bopf          = me
          io_buffer        = mo_buffer
          iv_last_state    = /bobf/if_conf_c=>sc_state_database
          iv_current_state = /bobf/if_conf_c=>sc_state_current
        IMPORTING
          et_failed_key    = lt_auth_failed_key
        CHANGING
          ct_access_stack  = mt_access_stack
          ct_key           = lt_auth_key
          co_message       = lo_auth_message_dummy
      ).
      IF eo_change IS BOUND.
        eo_change->merge( lo_auth_change ).
      ELSE.
        eo_change = lo_auth_change.
      ENDIF.
      " update exporting table for result / update LT_KEY
      IF lt_auth_failed_key IS NOT INITIAL.
        IF lines( lt_auth_failed_key ) = lv_lines_auth_key.
          CLEAR et_result.
          CLEAR lt_key.
        ELSE.
          	et_result = FILTER #( et_result EXCEPT IN lt_auth_failed_key USING KEY key_sort WHERE key = key ).
          	lt_key = FILTER #( lt_key EXCEPT IN lt_auth_failed_key USING KEY key_sort WHERE key = key ).
        ENDIF.
      ENDIF.

*   source == target, but not KEY
      IF iv_altkey_key      = iv_target_altkey_key AND
         iv_fill_target_key = abap_true.
        " update exporting table for key
        et_key = lt_key.
        RETURN.
      ENDIF.
    ENDIF.

* ___________________________________________________________________________ *
* ask own buffer -> convert KEY to altern key
    IF iv_fill_target_key = abap_true. " et_key is requested
      IF iv_target_altkey_key   = /bobf/if_frw_c=>sc_alternative_key_key AND
         ls_node-use_proxy_type = abap_false.
*     target key = key
        et_key = lt_key.
      ELSE.
*     target_key = altern key
        TRY.
            mo_buffer->retrieve_altern_key(
              EXPORTING
                iv_node_key         = iv_node_key
                iv_altkey_key       = iv_target_altkey_key
                it_key              = lt_key
                iv_state            = iv_state
                iv_invalidate_cache = iv_invalidate_cache
                io_change           = eo_change
              IMPORTING
                et_key              = et_key
                et_failed_key       = lt_failed_key ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
        IF ls_node-optimized_buffer_access = abap_true.
          after_loading(
            EXPORTING
              io_change         = eo_change
              iv_load_state     = iv_state ).
        ENDIF.

        IF lt_failed_key IS NOT INITIAL.
          IF lines( lt_failed_key ) = lines( lt_key ).
            CLEAR et_result.
          ELSE.
            et_result = FILTER #( et_result EXCEPT IN lt_failed_key USING KEY key_sort WHERE key = key ).
          ENDIF.
        ENDIF.

      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD convert_asc_src_to_cont_change.
    DATA ls_content_chg TYPE /bobf/s_frw_change_content.

    CHECK mv_no_content_changes = abap_false.
    CHECK it_association_source IS NOT INITIAL.

    mo_conf->get_assoc_tab( IMPORTING et_comp  = DATA(lt_composition)
                                      et_assoc = DATA(lt_association) ).

    ls_content_chg-change_mode = /bobf/if_frw_c=>sc_modify_association.

    LOOP AT it_association_source ASSIGNING FIELD-SYMBOL(<ls_comp_spec_id>).

      ASSERT <ls_comp_spec_id>-parent_key IS NOT INITIAL AND
             <ls_comp_spec_id>-parent_node_key IS NOT INITIAL AND
             <ls_comp_spec_id>-node_key IS NOT INITIAL.

      ls_content_chg-key      = <ls_comp_spec_id>-parent_key.
      ls_content_chg-node_key = <ls_comp_spec_id>-parent_node_key.

      CASE <ls_comp_spec_id>-association_kind.

        WHEN /bobf/if_conf_c=>sc_assoc_kind_composition. " Composition
          READ TABLE lt_composition ASSIGNING FIELD-SYMBOL(<ls_composition>) WITH KEY target_key
                                                                           COMPONENTS target_node_key = <ls_comp_spec_id>-node_key
                                                                                      source_node_key = <ls_comp_spec_id>-parent_node_key.
          ASSERT sy-subrc = 0.
          ls_content_chg-content_key = <ls_composition>-assoc_key.
          APPEND ls_content_chg TO rt_content_change.

        WHEN /bobf/if_conf_c=>sc_assoc_kind_specialization. " Specialization
          LOOP AT lt_association ASSIGNING FIELD-SYMBOL(<ls_assoc>) USING KEY key3
            WHERE source_node_key = <ls_comp_spec_id>-parent_node_key
            AND assoc_cat         = /bobf/if_conf_c=>sc_assoccat_specialization
            AND assoc_type        = /bobf/if_conf_c=>sc_assoctype_std
            AND target_node_key   = <ls_comp_spec_id>-node_key.

            ls_content_chg-content_key = <ls_assoc>-assoc_key.
            APPEND ls_content_chg TO rt_content_change.
          ENDLOOP.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.


  METHOD create.

    DATA: lo_int_access      TYPE REF TO /bobf/cl_frw_int_access,
          ls_assoc           TYPE /bobf/s_confro_assoc,
          ls_assoc_context   TYPE /bobf/s_frw_ctx_assoc,
          ls_assoc_class     TYPE ty_association,
          lt_failed_key      TYPE /bobf/t_frw_key,
          lt_key             TYPE /bobf/t_frw_key,
          ls_key             TYPE /bobf/s_frw_key,
          lt_key_link        TYPE /bobf/t_frw_key_link,
          lt_mod             TYPE /bobf/t_frw_modification,
          ls_mod             TYPE /bobf/s_frw_modification,
          ls_mod_tmp         TYPE /bobf/s_frw_modification,
          lo_message         TYPE REF TO /bobf/if_frw_message,
          lm_message_esi     TYPE REF TO /bobf/cm_frw_common_esi,
          ls_origin_location TYPE /bobf/s_frw_location,
          lx_root            TYPE REF TO cx_root,
          lv_node_proxy_name TYPE string.


    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR eo_message.

    READ TABLE it_mod INDEX 1 INTO ls_mod.
    IF mo_conf->ms_last_assoc-assoc_key = ls_mod-association.
      ls_assoc = mo_conf->ms_last_assoc.
    ELSE.
      mo_conf->get_assoc(
        EXPORTING iv_assoc_key  = ls_mod-association
        IMPORTING es_assoc      = ls_assoc ).
    ENDIF.

* ___________________________________________________________________________ *
*  existency check for source key
    lt_mod = it_mod.

    IF ls_assoc-source_node_key = ls_assoc-target_node_key. " only for hierarchical creates on one node type
      LOOP AT lt_mod INTO ls_mod.
        READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY change
          COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                     node        = ls_mod-source_node
                     key         = ls_mod-source_key.
        IF sy-subrc <> 0.
          ls_key-key = ls_mod-source_key.
          APPEND ls_key TO lt_key.
        ENDIF.
      ENDLOOP.
    ELSE.
      LOOP AT lt_mod INTO ls_mod.
        ls_key-key = ls_mod-source_key.
        APPEND ls_key TO lt_key.
      ENDLOOP.
    ENDIF.
    SORT lt_key.
    DELETE ADJACENT DUPLICATES FROM lt_key.

    retrieve(
      EXPORTING
        iv_node_key         = ls_assoc-source_node_key
        it_key              = lt_key
        iv_state            = iv_state
        iv_fill_data        = abap_false
      IMPORTING
        eo_message          = lo_message
        et_failed_key       = lt_failed_key ).

    LOOP AT lt_failed_key INTO ls_key.
      LOOP AT lt_mod INTO ls_mod USING KEY source
        WHERE source_node = ls_assoc-source_node_key
          AND source_key  = ls_key-key.
        io_change->add_change(
            iv_change_mode = /bobf/if_frw_c=>sc_modify_create
            iv_node_key    = ls_assoc-target_node_key
            iv_key         = ls_mod-key
            iv_failed      = abap_true ).
        DELETE lt_mod USING KEY loop_key.
      ENDLOOP.
    ENDLOOP.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

* ___________________________________________________________________________ *
*  Check for 1:0..1 and 1:1 delegated objects if cardinality would be violated by create
    IF ls_assoc-target_node->delegation_class IS NOT INITIAL AND
       ( ls_assoc-cardinality = /bobf/if_conf_c=>sc_card_zero_to_one OR
         ls_assoc-cardinality = /bobf/if_conf_c=>sc_card_one ).
      retrieve_by_association(
        EXPORTING
          iv_node_key         = ls_assoc-source_node_key
          it_key              = lt_key
          iv_association      = iv_assoc_key
          iv_state            = iv_state
        IMPORTING
          eo_message          = lo_message
          et_key_link         = lt_key_link ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_key_link IS NOT INITIAL.
        LOOP AT lt_mod INTO ls_mod USING KEY source
          WHERE source_node = ls_assoc-source_node_key.

          READ TABLE lt_key_link WITH KEY source_key = ls_mod-source_key TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.

            io_change->add_change(
               iv_change_mode = /bobf/if_frw_c=>sc_modify_create
               iv_node_key    = ls_assoc-target_node_key
               iv_key         = ls_mod-key
               iv_failed      = abap_true ).
            DELETE lt_mod USING KEY loop_key.

            IF eo_message IS NOT BOUND.
              eo_message = /bobf/cl_frw_factory=>get_message( ).
            ENDIF.

            ls_origin_location-node_key = ls_mod-source_node.
            ls_origin_location-key      = ls_mod-source_key.

            lv_node_proxy_name = ls_assoc-target_node->node_name.
            CREATE OBJECT lm_message_esi
              EXPORTING
                textid              = /bobf/cm_frw_common_esi=>cm_node_not_more_than_one
                severity            = /bobf/cm_frw=>co_severity_error
                symptom             = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                lifetime            = /bobf/cm_frw=>co_lifetime_transition
                ms_origin_location  = ls_origin_location
                mv_assoc_key        = iv_assoc_key
                cmn_node_proxy_name = lv_node_proxy_name.

            eo_message->add_cm( lm_message_esi ).

          ENDIF.
        ENDLOOP.
      ENDIF.

*    Check for duplicate instances to be created under same source instance
      LOOP AT lt_mod INTO ls_mod USING KEY source
        WHERE source_node = ls_assoc-source_node_key.
        READ TABLE lt_mod INTO ls_mod_tmp INDEX sy-tabix + 1 USING KEY source.
        IF sy-subrc = 0 AND
           ls_mod-source_node = ls_mod_tmp-source_node AND
           ls_mod-source_key  = ls_mod_tmp-source_key.

          io_change->add_change(
             iv_change_mode = /bobf/if_frw_c=>sc_modify_create
             iv_node_key    = ls_assoc-target_node_key
             iv_key         = ls_mod-key
             iv_failed      = abap_true ).
          DELETE lt_mod USING KEY loop_key.

          IF eo_message IS NOT BOUND.
            eo_message = /bobf/cl_frw_factory=>get_message( ).
          ENDIF.

          ls_origin_location-node_key = ls_mod-source_node.
          ls_origin_location-key      = ls_mod-source_key.

          lv_node_proxy_name = ls_assoc-target_node->node_name.
          CREATE OBJECT lm_message_esi
            EXPORTING
              textid              = /bobf/cm_frw_common_esi=>cm_node_not_more_than_one
              severity            = /bobf/cm_frw=>co_severity_error
              symptom             = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
              lifetime            = /bobf/cm_frw=>co_lifetime_transition
              ms_origin_location  = ls_origin_location
              mv_assoc_key        = iv_assoc_key
              cmn_node_proxy_name = lv_node_proxy_name.

          eo_message->add_cm( lm_message_esi ).

        ENDIF.
      ENDLOOP.

    ENDIF.

* ___________________________________________________________________________ *
*  call association class to perform create
    CHECK lt_mod IS NOT INITIAL.
    /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf            = me
        io_conf            = mo_conf
        io_buffer          = mo_buffer
        io_change          = io_change
      RECEIVING
        eo_internal_access = lo_int_access
    ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

    lo_int_access->set_current_state( iv_current_state = iv_state ).
    lo_int_access->set_edit_mode( iv_edit_mode ).
    ls_assoc_context-bo_key        = mo_conf->ms_obj-bo_key.
    ls_assoc_context-root_node_key = mo_conf->ms_obj-root_node_key.
    ls_assoc_context-node_key      = ls_assoc-source_node_key.
    ls_assoc_context-assoc_key     = ls_assoc-assoc_key.
    lo_int_access->set_context(
      is_association     = ls_assoc_context
      iv_read_allowed    = abap_true
      iv_modify_allowed  = abap_true
      iv_within_loading  = iv_within_loading
      iv_within_retrieve = iv_within_retrieve ).

*  get assoc class
    READ TABLE mt_association
       WITH TABLE KEY assoc_key = iv_assoc_key
       INTO ls_assoc_class.
    IF sy-subrc <> 0.
      ls_assoc_class-assoc_key = iv_assoc_key.
      CREATE OBJECT ls_assoc_class-class TYPE (ls_assoc-assoc_class).
      INSERT ls_assoc_class INTO TABLE mt_association.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>no_children_existing(
            it_mod_create = lt_mod
            is_assoc      = ls_assoc
            io_assoc      = ls_assoc_class-class
            is_ctx_assoc  = ls_assoc_context
            io_read       = lo_int_access ) = abap_true.

    TRY.
        ls_assoc_class-class->create(
          EXPORTING
            is_ctx          = ls_assoc_context
            it_modification = lt_mod
            io_read         = lo_int_access
            io_modify       = lo_int_access
          IMPORTING
            eo_message      = lo_message ).
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

*  check for undone modifications and flush
    IF lo_int_access->mt_modification IS NOT INITIAL.
      lo_int_access->end_modify( ).
    ENDIF.
    collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                      CHANGING  co_message = eo_message ).

    lo_int_access->invalidate( ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

  ENDMETHOD.


  METHOD create_change_save.

    DATA:
      ls_change_save LIKE LINE OF mt_change_save.

    " get_list of changed objects
    IF it_root_key IS INITIAL.
      TRY.
          mo_buffer->get_root_keys( IMPORTING et_root_key = et_root_key_all ).
        CATCH BEFORE UNWIND cx_root INTO DATA(lx_root).  "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      TRY.
          LOOP AT mt_delegation2 ASSIGNING FIELD-SYMBOL(<lo_delegation>).
            <lo_delegation>->get_root_keys( EXPORTING io_read     = mo_delegation_read
                                            IMPORTING et_root_key = DATA(lt_tmp_key) ).
            APPEND LINES OF lt_tmp_key TO et_root_key_all.
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ELSE.
      et_root_key_all = it_root_key.
      " WORKAOUND for CSN 0120061532 0001550573 2008: Call GET_ROOT_KEYS of delegation to make sure internal caches are filled.
      TRY.
          LOOP AT mt_delegation2 ASSIGNING <lo_delegation>.
            <lo_delegation>->get_root_keys( EXPORTING io_read     = mo_delegation_read
                                            IMPORTING et_root_key = lt_tmp_key ).
          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

    SORT et_root_key_all.
    DELETE ADJACENT DUPLICATES FROM et_root_key_all.

    " create the change object and collect changes:
    DATA(lo_change_save) = CAST /bobf/cl_frw_change( /bobf/cl_frw_factory=>get_change( ) ).
    lo_change_save->trace_external_changes( abap_false ).
    TRY.
        IF mv_modifying_transaction = abap_true.
          mo_buffer->compare_states(
            EXPORTING
              iv_node_key      = mo_conf->ms_obj-root_node_key
              it_key           = et_root_key_all
              iv_state_current = /bobf/if_conf_c=>sc_state_current
              iv_state_before  = /bobf/if_conf_c=>sc_state_database
              iv_incl_subtree  = abap_true
              io_change        = lo_change_save ).
        ENDIF.
        LOOP AT mt_delegation2 ASSIGNING <lo_delegation>.
          <lo_delegation>->get_changes( it_root_key = et_root_key_all
                                        io_change   = lo_change_save ).
        ENDLOOP.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
    lo_change_save->trace_external_changes( abap_true ).

    " store change object for further use during SAVE sequence:
    IF it_root_key IS INITIAL.
      mo_change_save = lo_change_save.
    ELSE.
      ls_change_save-change    = lo_change_save.
      ls_change_save-root_keys = et_root_key_all. "lt_root_key is sorted and unique
      APPEND ls_change_save TO mt_change_save.
    ENDIF.

    ro_change = lo_change_save.

  ENDMETHOD.


  METHOD create_durable_msg_container.
    IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft AND /bobf/cl_frw_intrnl_msg_mode=>is_message_mode_durable( ).
      " Int. Incident 1570795951: A BO can be an old style transactional BO but have an action that calls a service using
      " Gateway. This is the point where SADL initialize our /BOBF/CL_SADL_TRANSACTION_MNGR with entity_type = CDS and enables
      " durable messages. After finishing the action the runtime is again in a transactional environment but durable message are still enabled.
      IF co_message IS NOT BOUND.
        " If durable messages shall be used, we need a message container even if no container was returned from the application
        " This empty message container will invalidate all messages that were raises previously in this context
        co_message = /bobf/cl_frw_message_factory=>create_container( ).
      ELSE.   "IF lines( co_message->get( importing et_message = DATA(lt_message) ) > 0.
        " The application has returned a message container.
        " Check, that the returned message container has an unfinalized (initial) invalidation context.
        " This context is needed to invalidate messages that were raised previously in this context.
        " Adding a new default context can be necessary, if the application just forwards a message container
        " that was received by a nested BO call (e.g. an action calls an action)
        CAST /bobf/cl_frw_durable_message( co_message )->check_and_add_default_invalctx( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD create_states.

    DATA:
      lt_root_key                   TYPE /bobf/t_frw_key,
      lt_root_node                  TYPE /bobf/t_frw_node,
      lt_additional_state_dest      TYPE /bobf/if_frw_buffer=>tt_state,
      lv_add_state_dest_transferred TYPE boole_d,
      lv_state_dest                 TYPE /bobf/conf_state,
      lx_root                       TYPE REF TO cx_root.

    TRY.
        mo_buffer->get_root_keys(
           EXPORTING
             iv_changed_only = abap_false
           IMPORTING
             et_root_key     = lt_root_key ).
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    CHECK lt_root_key IS NOT INITIAL.

    map_to_node(
      EXPORTING
        iv_node_key = mo_conf->ms_obj-root_node_key
        it_key      = lt_root_key
      IMPORTING
        et_node     = lt_root_node ).

    TRY.
        IF mo_conf->ms_obj-last_val_state_not_relevant = abap_false.
          APPEND /bobf/if_conf_c=>sc_state_last_validated TO lt_additional_state_dest.
        ENDIF.

        IF mo_conf->ms_obj-last_det_state_not_relevant = abap_false.
          APPEND /bobf/if_conf_c=>sc_state_last_determined TO lt_additional_state_dest.
        ENDIF.

        mo_buffer->transfer_state(
          EXPORTING
            it_node         = lt_root_node
            iv_incl_subtree = abap_true
            iv_state_source = /bobf/if_conf_c=>sc_state_current
            iv_state_dest   = /bobf/if_conf_c=>sc_state_database
            it_additional_state_dest = lt_additional_state_dest
          IMPORTING
            ev_add_state_dest_transferred = lv_add_state_dest_transferred
          ).
        IF lv_add_state_dest_transferred = abap_false.
          LOOP AT lt_additional_state_dest INTO lv_state_dest.
            mo_buffer->transfer_state(
              EXPORTING
              it_node         = lt_root_node
              iv_incl_subtree = abap_true
              iv_state_source = /bobf/if_conf_c=>sc_state_current
                iv_state_dest   = lv_state_dest
              ).
          ENDLOOP.
        ENDIF.
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

  ENDMETHOD.


  METHOD delegate_retrieve_property.
    DATA(lo_delegation) = get_delegation( iv_node_key ).

    TRY.
        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        lo_delegation->retrieve_property(
          EXPORTING
            iv_node_key                  = iv_node_key
            it_key                       = it_key
            iv_key_is_default            = iv_key_is_default
            iv_node_property             = iv_node_property
            iv_node_attribute_property   = iv_node_attribute_property
            it_node_attribute            = it_node_attribute
            iv_assoc_property            = iv_assoc_property
            it_assoc                     = it_assoc
            iv_assoc_attribute_property  = iv_assoc_attribute_property
            iv_action_property           = iv_action_property
            it_action                    = it_action
            iv_action_attribute_property = iv_action_attribute_property
            iv_check_services            = iv_check_services
            io_property                  = io_property
            io_read                      = mo_delegation_read ).

        " do existency check on DO nodes as no failed keys are returned
        lo_delegation->retrieve(
          EXPORTING
            iv_node_key       = iv_node_key
            it_key            = it_key
            iv_fill_data      = abap_false
            iv_state          = /bobf/if_conf_c=>sc_state_current
            io_read           = mo_delegation_read
            io_change         = VALUE #( )
          IMPORTING
            et_failed_key     = et_failed_key ).

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      CATCH BEFORE UNWIND cx_root INTO DATA(lx_root).    "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.
  ENDMETHOD.


  METHOD derive_consistency_status.

    DATA: lt_val_list       TYPE /bobf/t_confro_val_list,
          ls_val_list       TYPE /bobf/s_confro_val_list,
          ls_assoc          TYPE /bobf/s_confro_assoc,
          ls_failed_val     TYPE /bobf/s_frw_validations,
          ls_group          TYPE /bobf/s_confro_group,
          lt_key            TYPE /bobf/t_frw_key,
          lt_relevant_key   TYPE /bobf/t_frw_key,
          lt_key_parent     TYPE /bobf/t_frw_key,
          ls_key            TYPE /bobf/s_frw_key,
          lv_start_node_key TYPE /bobf/obm_node_key,
          lv_group_node_key TYPE /bobf/obm_node_key,
          lo_message        TYPE REF TO /bobf/if_frw_message.

    FIELD-SYMBOLS:
            <ls_group>             TYPE /bobf/s_frw_group.


    CLEAR eo_message.

* if no validation failed the CT_GROUP can remain unchanged, because
* the corresponding default status value is already set by GET_RELEVANT_GROUPS
    CHECK it_failed_val IS NOT INITIAL
      AND ct_group      IS NOT INITIAL.

    mo_conf->get_validation( IMPORTING et_val_list = lt_val_list ).
    SORT lt_val_list.

    LOOP AT it_failed_val INTO ls_failed_val.
*   collect all key to the same validation
      ls_key-key = ls_failed_val-key.
      APPEND ls_key TO lt_relevant_key.

      AT END OF val_key.
        READ TABLE lt_val_list INTO ls_val_list BINARY SEARCH
          WITH KEY val_key = ls_failed_val-val_key.
        ASSERT ID /bobf/frw_error CONDITION sy-subrc = 0. " validation not assigned to a group

*     and loop over its groups
        LOOP AT ls_val_list-val_group->* INTO ls_group.
*       check whether this validation belongs to a group that is looked at
          READ TABLE ct_group TRANSPORTING NO FIELDS
            WITH KEY group_key = ls_group-group_key.
          CHECK sy-subrc = 0.

          lt_key            = lt_relevant_key.
          lv_start_node_key = ls_val_list-node_key.  " source node
          lv_group_node_key = ls_group-node_key.     " target node

*       navigate up to the node the group belongs to (same code as in GET_RELEVANT_GROUPS)
          DO.
            IF lv_start_node_key = lv_group_node_key.
              EXIT.
            ENDIF.

*         navigate TO_PARENT
            mo_conf->get_assoc(
              EXPORTING
                iv_node_key  = lv_start_node_key
                iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
              IMPORTING
                es_assoc     = ls_assoc ).
            IF ls_assoc IS INITIAL.
*           no association to parent found
              set_application_error( ).
            ENDIF.

            retrieve_by_association(
              EXPORTING
                iv_node_key    = lv_start_node_key
                it_key         = lt_key
                iv_association = ls_assoc-assoc_key
                iv_state       = /bobf/if_conf_c=>sc_state_current
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_key_parent ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            lt_key            = lt_key_parent.
            lv_start_node_key = ls_assoc-target_node_key.
          ENDDO.

*       set the consistency status to inconsistent if the instances match
          LOOP AT lt_key INTO ls_key.
            READ TABLE ct_group ASSIGNING <ls_group>
              WITH KEY group_key = ls_group-group_key
                       key       = ls_key-key.
            IF sy-subrc = 0.
              <ls_group>-status_value = /bobf/if_frw_c=>sc_status_inconsistent.
            ENDIF.
          ENDLOOP.
        ENDLOOP.

        CLEAR lt_relevant_key.
      ENDAT.

    ENDLOOP.

  ENDMETHOD.


  METHOD determine_triggered_val_keys.

    DATA lt_key3 TYPE /bobf/t_frw_key.
    DATA lt_key_missing TYPE /bobf/t_frw_key.
    DATA lt_val_key_missing TYPE /bobf/t_frw_key.

    CLEAR et_key.

    LOOP AT is_validation-val_trigger->* ASSIGNING FIELD-SYMBOL(<ls_val_trigger>).

      IF <ls_val_trigger>-assoc IS BOUND.
        DATA(lv_node_key) = <ls_val_trigger>-assoc->source_node_key.
      ELSE.
        lv_node_key = is_validation-node_key.
      ENDIF.

      DATA(ls_change_mode) = <ls_val_trigger>-change_mode.
      IF iv_use_check_trigger = abap_false. " do not trigger in check
        ls_change_mode-check = abap_false.
      ENDIF.

      get_validation_trigger( EXPORTING iv_processing_mode = iv_processing_mode
                                        is_change_mode     = ls_change_mode
                                        iv_node_key        = lv_node_key
                                        io_change          = io_change
                              IMPORTING et_key             = DATA(lt_key) ).

      CHECK lt_key IS NOT INITIAL.

      IF <ls_val_trigger>-assoc IS BOUND.
*        association defined from trigger-node to node to be validated
*        -> retrieve node to be validated
        retrieve_by_association(
          EXPORTING
            iv_node_key   		 = <ls_val_trigger>-node_key
            it_key        		 = lt_key
            iv_association		 = <ls_val_trigger>-assoc->assoc_key
            iv_state      		 = /bobf/if_conf_c=>sc_state_current
          IMPORTING
            eo_message     		 = DATA(lo_message)
            et_key_link    		 = DATA(lt_key_link)
            et_target_key  		 = DATA(lt_key2) ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>is_key_link_matching(
                                                              it_key        = lt_key
                                                              it_key_link   = lt_key_link
                                                              it_target_key = lt_key2 ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = co_message ).
        APPEND LINES OF lt_key2 TO lt_key3.
        CLEAR lt_key2.

        IF <ls_val_trigger>-delete = abap_true.
*          check if changed key-table is incomplete due to deleted
*          trigger keys. if yes -> add nodes

          CLEAR lt_val_key_missing.
          IF lt_key_link IS INITIAL.
            lt_key_missing = lt_key.
          ELSE.
            lt_key_missing = FILTER #( lt_key EXCEPT IN lt_key_link WHERE key = source_key ).
          ENDIF.

          IF lt_key_missing IS NOT INITIAL.
            retrieve_by_association(
              EXPORTING
                iv_node_key    		 = <ls_val_trigger>-assoc->source_node_key
                it_key         		 = lt_key_missing
                iv_association 		 = <ls_val_trigger>-assoc->assoc_key
                iv_state       		 = iv_last_state
              IMPORTING
                eo_message     		 = lo_message
                et_target_key  		 = lt_val_key_missing ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = co_message ).

            TRY.
                " check existence of association's target node key
                " Incident 0020751294 0000075583 2018 => changed mo_buffer->retrieve to service manager retrieve (for buffer update)
                retrieve(
                 EXPORTING
                   iv_node_key             = <ls_val_trigger>-assoc->target_node_key
                   it_key                  = lt_val_key_missing
                   iv_state                = /bobf/if_conf_c=>sc_state_current
                   iv_fill_data            = abap_false
                 IMPORTING
                   et_failed_key           = DATA(lt_failed_key) ).

                APPEND LINES OF
                   FILTER #( lt_val_key_missing EXCEPT IN lt_failed_key USING KEY key_sort WHERE key = key )
                   TO lt_key3. "adding existing keys
              CATCH BEFORE UNWIND cx_root INTO DATA(lx_root). "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

          ENDIF.
        ENDIF.

      ELSE.
*        check existence of instances
        retrieve(
          EXPORTING
            iv_node_key             = <ls_val_trigger>-node_key
            it_key                  = lt_key
            iv_state                = /bobf/if_conf_c=>sc_state_current
            iv_fill_data            = abap_false
          IMPORTING
            et_failed_key           = lt_key2 ).

*        lt_key3 = lt_key.   " Internal incident #1770153074
        APPEND LINES OF lt_key TO lt_key3.
        DELETE ADJACENT DUPLICATES FROM lt_key3 USING KEY key_sort.
        LOOP AT lt_key2 INTO DATA(ls_key2).
          DELETE TABLE lt_key3 WITH TABLE KEY key_sort COMPONENTS key = ls_key2-key.
        ENDLOOP.
        CLEAR lt_key2.
      ENDIF.

    ENDLOOP.

    et_key = lt_key3.

    CHECK et_key IS NOT INITIAL.
    SORT et_key.
    DELETE ADJACENT DUPLICATES FROM et_key.

  ENDMETHOD.


  METHOD do_action.

    DATA: ls_actconf               TYPE /bobf/s_confro_act_list,
          ls_actwrite              TYPE /bobf/s_confro_act_write,
          lo_delegation            TYPE REF TO /bobf/if_frw_delegation,
          lt_node                  TYPE /bobf/t_frw_node,
          lt_failed_node           TYPE /bobf/t_frw_node,
          lt_node_reload           TYPE /bobf/t_frw_node,
          lt_node_all_reload       TYPE /bobf/t_frw_node,
          ls_node                  TYPE /bobf/s_frw_node,
          lt_action_key            TYPE /bobf/t_frw_key,
          lt_failed_key            TYPE /bobf/t_frw_key,
          lt_key                   TYPE /bobf/t_frw_key,
          ls_key                   TYPE /bobf/s_frw_key,
          ls_context               TYPE /bobf/s_frw_ctx_act,
          ls_runtime_context       TYPE /bobf/s_frw_runtime_context,
          ls_param_lock            TYPE /bobf/s_frw_lock_parameters,
          ls_param_lock_r          TYPE REF TO /bobf/s_frw_lock_parameters,
          lo_message               TYPE REF TO /bobf/if_frw_message,
          lo_message_int           TYPE REF TO /bobf/cl_frw_message,
          lx_root                  TYPE REF TO cx_root,
          lv_prev_privileged_mode  TYPE c LENGTH 1,
          lt_key_link              TYPE /bobf/t_frw_key_link,
          ls_key_link              TYPE /bobf/s_frw_key_link,
          lv_check_property        TYPE boole_d,
          lv_load_subtree          TYPE /bobf/frw_load_subtree,
          lt_action_execution_list TYPE /bobf/t_frw_key2,
          lv_action_execution_list TYPE /bobf/conf_key.

    FIELD-SYMBOLS: <ls_lockparam> TYPE /bobf/s_frw_lock_parameters.

    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           eo_change,
           ev_static_action_failed,
           et_data,
           et_failed_key,
           et_data_link.

    lt_action_key = is_action-key.

*  ____________________________________________________________________ *
*  get configuration
    IF mo_conf->ms_last_action-act_key = is_action-act_key.
      ls_actconf = mo_conf->ms_last_action.
    ELSE.
      mo_conf->get_act(
        EXPORTING iv_act_key = is_action-act_key
        IMPORTING es_action  = ls_actconf ).
      IF ls_actconf IS INITIAL.
*      unknown action
        set_configuration_error( ).
      ENDIF.
    ENDIF.

*____________________________________________________________________ *
*  check for delegated action
    IF mo_conf->ms_last_node-node_key <> ls_actconf-node_key.
      mo_conf->get_node( iv_node_key = ls_actconf-node_key ).
    ENDIF.
    IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
*    delegate action
      TRY.
          eo_change = /bobf/cl_frw_factory=>get_change( ).
          lt_key = is_action-key.
          mo_authority_handler->check_authority(
            EXPORTING
              is_ctx           = VALUE #(
                                  activity = /bobf/cl_frw_authority_check=>sc_activity-execute
                                  bo_service = ls_actconf-act_name
                                  node_key = ls_actconf-node_key )
              io_change        = eo_change
              io_bopf          = me
              io_buffer        = mo_buffer
              iv_cleanse_keys  = abap_true
              iv_last_state    = /bobf/if_conf_c=>sc_state_database
              iv_current_state = /bobf/if_conf_c=>sc_state_current
            IMPORTING
              et_failed_key    = et_failed_key
            CHANGING
              ct_access_stack  = mt_access_stack
              ct_key           = lt_key
              co_message       = eo_message
          ).

          IF lt_key IS NOT INITIAL
            OR is_action-key IS INITIAL. " _static_ action // IM 1648217 (2013)
*          delegate action
            lo_delegation = get_delegation( ls_actconf-node_key ).
            lv_prev_privileged_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_delegation->do_action(
              EXPORTING
                is_action               = VALUE #(
                                            act_key = is_action-act_key
                                            key = lt_key
                                            parameters = is_action-parameters )
                io_change               = eo_change
              IMPORTING
                eo_message              = lo_message
                et_failed_key           = lt_failed_key
                ev_static_action_failed = ev_static_action_failed ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            APPEND LINES OF lt_failed_key TO et_failed_key.
          ENDIF.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      IF mv_modifying_transaction = abap_false AND
         eo_change IS BOUND AND
         ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
           eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
           eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).
        create_states( ).
        mv_modifying_transaction = abap_true.
      ENDIF.

*    perform determination and validation
      IF iv_with_detval       = abap_true AND
         mv_no_determinations = abap_false.
        do_detval(
          EXPORTING io_change                  = eo_change
                    iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_action
          IMPORTING eo_message                 = lo_message ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
      RETURN.
    ENDIF.

*  ____________________________________________________________________ *
*  if lock action is called -> call locking
    IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_lock     OR
       ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_unlock.
*    object does not have any lock nodes
      ASSERT ID /bobf/frw CONDITION mo_conf->ms_obj-no_lock = abap_false.

      IF is_action-parameters IS BOUND.
        ASSIGN is_action-parameters->* TO <ls_lockparam>.
      ELSE.
        ls_param_lock-all_none = abap_false.
        ls_param_lock-scope    = mv_enqueue_scope.
        IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_lock.
          ls_param_lock-edit_mode = /bobf/if_conf_c=>sc_edit_exclusive.
        ENDIF.
        ASSIGN ls_param_lock TO <ls_lockparam>.
      ENDIF.

*    check action
      GET REFERENCE OF <ls_lockparam> INTO ls_param_lock_r.
      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

      ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_set(
           it_key_set = lt_action_key ) = abap_true.

      IF iv_internal_call = abap_false.
        lv_check_property = abap_true.
      ENDIF.

      check_action(
        EXPORTING
          iv_act_key          = is_action-act_key
          is_parameters       = ls_param_lock_r
          iv_check_property   = lv_check_property
          iv_check_validation = abap_true
          io_change           = eo_change
        IMPORTING
          et_failed_key       = lt_failed_key
          eo_message          = eo_message
        CHANGING
          ct_key              = lt_action_key ).

      ASSERT ID /bobf/frw CONDITION
         /bobf/cl_tool_assert=>is_key_subset_stack_check(
             it_key_subset = lt_failed_key ) = abap_true.

      APPEND LINES OF lt_failed_key TO et_failed_key.

      IF lt_action_key IS NOT INITIAL.
        ls_node-node = ls_actconf-node_key.
        LOOP AT lt_action_key INTO ls_key.
          ls_node-key = ls_key-key.
          INSERT ls_node INTO TABLE lt_node.
        ENDLOOP.

        IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_lock.
          mo_lock_manager->lock(
            EXPORTING
              it_node                       = lt_node
              iv_edit_mode                  = <ls_lockparam>-edit_mode
              iv_generic                    = <ls_lockparam>-generic
              iv_scope                      = <ls_lockparam>-scope
              iv_all_none                   = <ls_lockparam>-all_none
              io_change                     = eo_change
            IMPORTING
              eo_message                    = lo_message
              et_lockable_node_newly_locked = lt_node_reload
              et_node_not_locked            = lt_failed_node ).
        ELSE.
          mo_lock_manager->unlock(
            EXPORTING
              it_node                       = lt_node
              iv_generic                    = <ls_lockparam>-generic
              iv_scope                      = <ls_lockparam>-scope
              iv_all_none                   = <ls_lockparam>-all_none
              io_change                     = eo_change
            IMPORTING
              eo_message                    = lo_message
              et_lockable_node_newly_locked = lt_node_reload
              et_node_not_locked            = lt_failed_node ).
        ENDIF.

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_node_subset(
                it_node_set    = lt_node
                it_node_subset = lt_failed_node ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        LOOP AT lt_failed_node INTO ls_node
          WHERE node = ls_actconf-node_key.
          ls_key-key = ls_node-key.
          INSERT ls_key INTO TABLE et_failed_key.
        ENDLOOP.

        IF <ls_lockparam>-force_invalidation = abap_true AND
           ls_actconf-act_cat                = /bobf/if_conf_c=>sc_action_lock.
          lt_node_reload = lt_node.
        ENDIF.

*      reload newly locked nodes
        IF lt_node_reload IS NOT INITIAL.
          IF <ls_lockparam>-generic = abap_false.
            lv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup.
          ELSE.
            lv_load_subtree = /bobf/if_frw_c=>sc_load_whole_subtree.
          ENDIF.
          do_loading(
            EXPORTING
              it_node         = lt_node_reload
              iv_reload       = abap_true
              iv_load_data    = abap_true
              iv_check_buf    = abap_false
              iv_load_subtree = lv_load_subtree
              iv_edit_mode    = <ls_lockparam>-edit_mode
              io_change       = eo_change
            IMPORTING
              eo_message      = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

      ENDIF.
      RETURN.
    ENDIF.

*  ____________________________________________________________________ *
*  check if write nodes of the action have sufficient locking
    IF ls_actconf-edit_mode <> /bobf/if_conf_c=>sc_edit_read_only AND
       lt_action_key IS NOT INITIAL.
      LOOP AT ls_actconf-act_write->* INTO ls_actwrite.
        IF ls_actwrite-assoc IS BOUND.
          retrieve_by_association(
            EXPORTING
              iv_node_key    = ls_actconf-node_key
              it_key         = lt_action_key
              iv_association = ls_actwrite-assoc->assoc_key
              iv_state       = /bobf/if_conf_c=>sc_state_current
            IMPORTING
              eo_message     = lo_message
              et_key_link    = lt_key_link
              et_failed_key  = lt_failed_key
              et_target_key  = lt_key ).

          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_action_key
                  it_key_subset = lt_failed_key ) = abap_true.
          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_key_link_matching(
                 it_key        = lt_action_key
                 it_key_link   = lt_key_link
                 it_target_key = lt_key ) = abap_true.

          APPEND LINES OF lt_failed_key TO et_failed_key.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          map_to_node(
            EXPORTING
              iv_node_key = ls_actwrite-assoc->target_node_key
              it_key      = lt_key
            IMPORTING
              et_node     = lt_node ).
        ELSE.
          map_to_node(
            EXPORTING
              iv_node_key = ls_actconf-node_key
              it_key      = lt_action_key
            IMPORTING
              et_node     = lt_node ).
        ENDIF.

        IF lt_node IS NOT INITIAL.

*      check locks of write nodes and lock if necessary
          IF eo_change IS NOT BOUND.
            eo_change = /bobf/cl_frw_factory=>get_change( ).
          ENDIF.

          DATA(lt_node_locked_for_delete) = VALUE /bobf/t_frw_node(  ).
          IF ls_actconf-act_annotation = /bobf/if_conf_c=>sc_act_anno_draft_discard.
            lt_node_locked_for_delete = lt_node.
          ENDIF.

          mo_lock_manager->lock(
            EXPORTING
              iv_edit_mode = ls_actconf-edit_mode
              iv_all_none  = ls_actconf-exec_only_all
              it_node      = lt_node
              io_change    = eo_change
              iv_generic   = abap_false
              it_node_locked_for_delete = lt_node_locked_for_delete
            IMPORTING
              eo_message                    = lo_message
              et_lockable_node_newly_locked = lt_node_reload
              et_node_not_locked            = lt_failed_node ).
          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_node_subset(
                  it_node_set    = lt_node
                  it_node_subset = lt_failed_node ) = abap_true.

          " Incident https://support.wdf.sap.corp/sap/support/message/1970310414
          " Use case: On the object page, user clicks on EDIT button, and stays till the draft expires.
          " Then the user clicks on SAVE, the PREPARATION tries to lock the active document, so does the ACTIVATION.
          " Both fail with error message SDRAFT_COMMON 006 and maybe also application-defined messages.
          " We suppress all the messages from PREPARATION since otherwise it will be created in ACTIVATION again.
          IF lo_message IS BOUND AND ls_actconf-act_annotation = /bobf/if_conf_c=>sc_act_anno_draft_prep.
            CLEAR lo_message.
          ENDIF.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          INSERT LINES OF lt_node_reload INTO TABLE lt_node_all_reload.

          LOOP AT lt_failed_node INTO ls_node.
            IF ls_actwrite-assoc IS BOUND.
              LOOP AT lt_key_link INTO ls_key_link USING KEY target_key WHERE
                  target_key = ls_node-key.
                ls_key-key = ls_key_link-source_key.
                APPEND ls_key TO et_failed_key.
              ENDLOOP.
            ELSE.
              ls_key-key = ls_node-key.
              APPEND ls_key TO et_failed_key.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
    ENDIF.

*  reload newly locked nodes
    IF lt_node_all_reload IS NOT INITIAL.
      do_loading(
        EXPORTING
          it_node         = lt_node_all_reload
          iv_reload       = abap_true
          iv_load_data    = abap_true
          iv_check_buf    = abap_false
          iv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup
          iv_edit_mode    = ls_actconf-edit_mode
          io_change       = eo_change
        IMPORTING
          eo_message      = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    LOOP AT et_failed_key INTO ls_key.
      DELETE lt_action_key USING KEY key_sort WHERE key = ls_key-key.
    ENDLOOP.

*  ____________________________________________________________________ *
*  check existence of all node instances the action is called with
    IF lt_action_key IS NOT INITIAL.
      retrieve(
        EXPORTING
          iv_node_key         = ls_actconf-node_key
          it_key              = lt_action_key
          iv_state            = /bobf/if_conf_c=>sc_state_current
          iv_invalidate_cache = abap_false
          iv_fill_data        = abap_false
          iv_edit_mode        = /bobf/if_conf_c=>sc_edit_read_only
          iv_buffer_only      = abap_false
          iv_within_loading   = abap_false
        IMPORTING
          eo_message          = lo_message
          et_failed_key       = lt_failed_key ).

      "send messages for CDS BOs only
      LOOP AT lt_failed_key ASSIGNING FIELD-SYMBOL(<ls_failed_key>).
        NEW /bobf/cm_frw_common_esi(
          ms_origin_location = VALUE #( bo_key = mo_conf->ms_obj-bo_key  node_key = ls_actconf-node_key key = <ls_failed_key>-key )
          lifetime = /bobf/cm_frw=>co_lifetime_transition
          severity = /bobf/cm_frw=>co_severity_error
          symptom = /bobf/if_frw_message_symptoms=>co_bo_inconsistency
          textid = /bobf/cm_frw_common_esi=>cm_action_ref_not_exists
          cmn_action_proxy_name = ls_actconf-act_name
          )->send_for_cds_bo(
            EXPORTING io_conf    = mo_conf
            CHANGING  co_message = lo_message ).
      ENDLOOP.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF ls_actconf-act_cat = /bobf/if_conf_c=>sc_action_adopt_numbers.
        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_action_key USING KEY key_sort WHERE key = ls_key-key.
        ENDLOOP.
      ELSE.
        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_action_key USING KEY key_sort WHERE key = ls_key-key.
          APPEND ls_key TO et_failed_key.
        ENDLOOP.
      ENDIF.
    ENDIF.

    IF et_failed_key IS NOT INITIAL AND
       ls_actconf-exec_only_all = abap_true.
*    action rejected
      et_failed_key = is_action-key.
      RETURN.
    ENDIF.

*  ____________________________________________________________________ *
*  check authority
    mo_authority_handler->check_authority(
      EXPORTING
        io_change        = eo_change
        is_ctx           = VALUE #(
                            activity = /bobf/cl_frw_authority_check=>sc_activity-execute
                            bo_service = ls_actconf-act_name
                            node_key = ls_actconf-node_key )
        iv_cleanse_keys  = abap_true
        io_bopf          = me
        io_buffer        = mo_buffer
        iv_last_state    = /bobf/if_conf_c=>sc_state_database
        iv_current_state = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_failed_key    = lt_failed_key
      CHANGING
        ct_key           = lt_action_key
        co_message       = eo_message
        ct_access_stack  = mt_access_stack
    ).

    APPEND LINES OF lt_failed_key TO et_failed_key.

*  ____________________________________________________________________ *
*  create context
    ls_context-bo_key          = mo_conf->ms_obj-bo_key.
    ls_context-root_node_key   = mo_conf->ms_obj-root_node_key.
    ls_context-node_key        = ls_actconf-node_key.
    ls_context-act_key         = is_action-act_key.
    ls_context-act_cat         = ls_actconf-act_cat.
    IF eo_change IS NOT BOUND.
      eo_change = /bobf/cl_frw_factory=>get_change( ).
    ENDIF.

*  ____________________________________________________________________ *
*  prepare and check action - action depending validation
    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_set(
           it_key_set = lt_action_key ) = abap_true.

    IF iv_internal_call = abap_false.
      lv_check_property = abap_true.
    ENDIF.

    check_action(
      EXPORTING
        is_context          = ls_context
        is_parameters       = is_action-parameters
        iv_check_property   = lv_check_property
        iv_check_validation = abap_true
        io_change           = eo_change
      IMPORTING
        et_failed_key       = lt_failed_key
        eo_message          = lo_message
      CHANGING
        ct_key              = lt_action_key ).

    ASSERT ID /bobf/frw CONDITION
       /bobf/cl_tool_assert=>is_key_subset_stack_check(
           it_key_subset = lt_failed_key ) = abap_true.

    APPEND LINES OF lt_failed_key TO et_failed_key.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    IF ls_actconf-act_cardinality <> /bobf/if_conf_c=>sc_act_card_static AND
       lt_action_key IS INITIAL.
*    all keys kicked out by action check
      RETURN.
    ENDIF.

    IF et_failed_key IS NOT INITIAL AND
       ls_actconf-exec_only_all = abap_true.
*    action rejected
      et_failed_key = is_action-key.
      RETURN.
    ENDIF.


*  ____________________________________________________________________ *
*  create sorted action execution list
*  (pre-enhancement actions, basic action and post-enhancement actions)
    IF ls_actconf-pre_enhancement_keys IS BOUND.
      lt_action_execution_list = ls_actconf-pre_enhancement_keys->*.
    ENDIF.

    INSERT is_action-act_key INTO TABLE lt_action_execution_list.

    IF ls_actconf-post_enhancement_keys IS BOUND.
      APPEND LINES OF ls_actconf-post_enhancement_keys->* TO lt_action_execution_list.
    ENDIF.

*  ____________________________________________________________________ *
*  execute the action list
    LOOP AT lt_action_execution_list INTO lv_action_execution_list.

      IF mo_conf->ms_last_action-act_key = lv_action_execution_list.
        ls_actconf = mo_conf->ms_last_action.
      ELSE.
        mo_conf->get_act(
          EXPORTING
            iv_act_key  = lv_action_execution_list
          IMPORTING
            es_action   = ls_actconf ).
      ENDIF.

*  ____________________________________________________________________ *
*  create context
      ls_context-act_key         = lv_action_execution_list.
      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

*  ____________________________________________________________________ *
*  execute action
      ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

      DATA(lt_key_for_message_context) = lt_action_key.
      execute_action(
        EXPORTING
          is_context              = ls_context
          is_conf                 = ls_actconf
          is_parameter            = is_action-parameters
          io_change               = eo_change
          iv_within_loading       = iv_within_loading
          iv_is_base_action       = xsdbool( lv_action_execution_list = is_action-act_key )
        IMPORTING
          et_failed_key           = lt_failed_key
          eo_message              = lo_message
          ev_static_action_failed = ev_static_action_failed
          et_data                 = et_data
          et_data_link            = et_data_link
        CHANGING
          ct_key                  = lt_action_key
      ).
      APPEND LINES OF lt_failed_key TO et_failed_key.


*  set context
      create_durable_msg_container( CHANGING co_message = lo_message ).
      IF lo_message IS BOUND.

        lo_message_int ?= lo_message.
        ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
        ls_runtime_context-node_key = ls_actconf-node_key.
        ls_runtime_context-act_key  = ls_actconf-act_key.
        lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key_for_message_context ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

*  if no keys have been left by the basic action, do no execute any post enhancement actions
*  in case of non static actions only
      IF lv_action_execution_list = is_action-act_key
        AND lt_action_key IS INITIAL
        AND ls_actconf-act_cardinality NE /bobf/if_conf_c=>sc_act_card_static.
        EXIT.
      ENDIF.

    ENDLOOP.

    IF  iv_with_detval       = abap_true
    AND mv_no_determinations = abap_false
    " Checking for action PREPARATION here is a work-around: action PREPARATION should not have
    " write-nodes in the first place, but it's too late to change all the BOs out there, now.
    " Why do we have to skip do_detval? - Because the LOCK action may have set the draftconsistencystatus
    " to "pending" during RESUME. This counts as a change which, in turn, will cause the status
    " variables to be reset by do_detval. We do not want this to happen for the PREPARATION action.
    AND ls_actconf-act_annotation <> /bobf/if_conf_c=>sc_act_anno_draft_prep
    " RAP: Disable side-effects for draft action EDIT...
    AND NOT ( mo_conf->ms_obj-is_rap_bo = abap_true AND ls_actconf-act_annotation = /bobf/if_conf_c=>sc_act_anno_draft_edit ).
      do_detval( EXPORTING io_change                  = eo_change
                           iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_action
                 IMPORTING eo_message                 = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

  ENDMETHOD.


  METHOD do_delete_action.
    DATA lt_delete_for_action TYPE /bobf/t_frw_key.

    CLEAR: eo_message, et_failed_node.

    LOOP AT it_delete ASSIGNING FIELD-SYMBOL(<ls_delete>) GROUP BY ( node = <ls_delete>-node ) ASSIGNING FIELD-SYMBOL(<ls_node_group>).
      CLEAR lt_delete_for_action.
      "Check whether a implementation for the delete action exists
      mo_conf->get_act( EXPORTING iv_node_key = <ls_node_group>-node
                                  iv_act_cat  = /bobf/if_conf_c=>sc_action_delete
                        IMPORTING es_action   = DATA(ls_act_conf) ).
      IF ls_act_conf-act_class IS NOT INITIAL.
        LOOP AT GROUP <ls_node_group> ASSIGNING FIELD-SYMBOL(<ls_delete_for_same_node>).
          APPEND VALUE #( key = <ls_delete_for_same_node>-key ) TO lt_delete_for_action.
        ENDLOOP.

        IF lt_delete_for_action IS NOT INITIAL.
          DATA(ls_action_context) = VALUE /bobf/s_frw_ctx_act( bo_key        = mo_conf->ms_obj-bo_key
                                                               root_node_key = mo_conf->ms_obj-root_node_key
                                                               node_key      = ls_act_conf-node_key
                                                               act_key       = ls_act_conf-act_key ).
          DATA(lt_key_for_message_contex) = lt_delete_for_action.
          execute_action( EXPORTING is_context    = ls_action_context
                                    is_conf       = ls_act_conf
                                    io_change     = io_change
                          IMPORTING et_failed_key = DATA(lt_failed_key)
                                    eo_message    = DATA(lo_message)
                          CHANGING  ct_key        = lt_delete_for_action ).
          " set message context
          create_durable_msg_container( CHANGING co_message = lo_message ).
          IF lo_message IS BOUND.
            DATA(lo_message_int)  = CAST /bobf/cl_frw_message( lo_message ).
            DATA(ls_runtime_context) = VALUE /bobf/s_frw_runtime_context( bo_key   = mo_conf->ms_obj-bo_key
                                                                          node_key = ls_act_conf-node_key
                                                                          act_key  = ls_act_conf-act_key ).
            lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key_for_message_contex ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.

          LOOP AT lt_failed_key ASSIGNING FIELD-SYMBOL(<ls_failed_key>).
            INSERT VALUE #( node = <ls_node_group>-node key = <ls_failed_key>-key ) INTO TABLE et_failed_node.
          ENDLOOP.

        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD do_determinations.

    DATA: ls_detconf          TYPE REF TO /bobf/s_confro_exectime,
          ls_det              TYPE REF TO /bobf/s_confro_det_list,
          ls_det_inst         TYPE ty_determination,
          ls_statecr          TYPE /bobf/s_confro_chg_mode,
          ls_dettrig          TYPE /bobf/s_confro_det_trigger,
          ls_detwrite         TYPE /bobf/s_confro_det_write,
          ls_detread          TYPE /bobf/s_confro_read,
          ls_context          TYPE /bobf/s_frw_ctx_det,
          lt_nodecat          TYPE /bobf/t_frw_node_cat,
          ls_nodecat          TYPE /bobf/s_frw_node_cat,
          lt_key              TYPE /bobf/t_frw_key,
          lt_key2             TYPE /bobf/t_frw_key,
          lt_key3             TYPE /bobf/t_frw_key,
          lt_key4             TYPE /bobf/t_frw_key,
          lt_key_for_db       TYPE /bobf/t_frw_key,
          ls_key              TYPE /bobf/s_frw_key,
          ls_key_new          TYPE /bobf/s_frw_key,
          lt_write_key        TYPE /bobf/t_frw_key,
          lt_det_key          TYPE /bobf/t_frw_key,
          lt_det_key_missing  TYPE /bobf/t_frw_key,
          lt_det_key_missing2 TYPE /bobf/t_frw_key,
          lt_changed_key      TYPE /bobf/t_frw_key,
          lt_changed_key2     TYPE /bobf/t_frw_key,
          lt_key_link         TYPE /bobf/t_frw_key_link,
          ls_key_link         TYPE /bobf/s_frw_key_link,
          lt_key_link2        TYPE /bobf/t_frw_key_link,
          lt_key_missing      TYPE /bobf/t_frw_key,
          lt_failed_key       TYPE /bobf/t_frw_key,
          lt_failed_root_key  TYPE /bobf/t_frw_key,
          lt_failed_write_key TYPE /bobf/t_frw_key,
          lt_root_key         TYPE /bobf/t_frw_key,
          lt_tmp_key          TYPE /bobf/t_frw_key,
          lt_write_node       TYPE /bobf/t_frw_node,
          lt_write_node_bef   TYPE /bobf/t_frw_node,
          lt_lock_node        TYPE /bobf/t_frw_node,
          lt_tmp_node         TYPE /bobf/t_frw_node,
          lt_failed_node      TYPE /bobf/t_frw_node,
          lt_node_reload      TYPE /bobf/t_frw_node,
          ls_node             TYPE /bobf/s_frw_node,
          lv_node             TYPE /bobf/obm_node_key,
          lt_change           TYPE /bobf/t_frw_change,
          ls_change           TYPE /bobf/s_frw_change,
          lo_change           TYPE REF TO /bobf/cl_frw_change,
          lo_delegation       TYPE REF TO /bobf/if_frw_delegation,
          lo_message          TYPE REF TO /bobf/if_frw_message,
          lo_message_int      TYPE REF TO /bobf/cl_frw_message,
          ls_runtime_context  TYPE /bobf/s_frw_runtime_context,
          lv_content_cat      TYPE string,
          lv_content_name     TYPE /bobf/obm_name,
          lv_within_loading   TYPE boole_d,
          lx_root             TYPE REF TO cx_root,
          lx_frw              TYPE REF TO /bobf/cx_frw_core,
          lx_cx_frw           TYPE REF TO /bobf/cx_frw,
          lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
          lv_current_state    TYPE /bobf/conf_state.

    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           et_failed.

    IF iv_exectime <> /bobf/if_conf_c=>sc_time_cleanup AND
       io_change->has_changes( ) = abap_false.
      RETURN.
    ENDIF.

    ls_detconf = mo_conf->get_determination( iv_exectime ).
    IF ls_detconf IS NOT BOUND.
*   unknown exectime
      set_configuration_error( ).
      RETURN.
    ENDIF.
    IF ls_detconf->exectime = /bobf/if_conf_c=>sc_time_after_loading.
      lv_current_state = iv_load_state.
      lv_within_loading = abap_true.
    ELSE.
      lv_current_state = /bobf/if_conf_c=>sc_state_current.
      lv_within_loading = abap_false.
    ENDIF.

    IF ls_detconf->det_list IS BOUND AND
        ls_detconf->det_list->* IS NOT INITIAL.
      lo_change ?= io_change.

*   clear GET_NODE_CAT local buffer
      CLEAR: mt_nodecat_key,
             mv_nodecat_node_key,
             mt_nodecat.
      lo_int_access = /bobf/cl_frw_int_access=>new_instance(
        EXPORTING
          io_bopf   = me
          io_conf   = mo_conf
          io_buffer = mo_buffer
          io_change = io_change ).

      lo_int_access->set_last_state( iv_last_state = ls_detconf->last_state ).
      lo_int_access->set_current_state( iv_current_state = lv_current_state ).

*   loop at determinations (already correctly sorted)
      LOOP AT ls_detconf->det_list->* REFERENCE INTO ls_det.
        CLEAR lt_key.

* ____________________________________________________________________ *
*     analyse changed trigger nodes
        LOOP AT ls_det->det_trigger->* INTO ls_dettrig.
*       get changed source nodes
          IF ls_dettrig-assoc IS BOUND.
            lv_node = ls_dettrig-assoc->source_node_key.
          ELSE.
*         association is missing within the configuration -> check your configuration!
            ASSERT ID /bobf/frw CONDITION ls_det->node_key = ls_dettrig-node_key.
            lv_node = ls_det->node_key.
          ENDIF.
          IF iv_exectime = /bobf/if_conf_c=>sc_time_after_loading.
            CHECK ls_dettrig-load = abap_true.
            lo_change->get_trigger(
              EXPORTING
                iv_exectime    = iv_exectime
                iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                iv_node_key    = lv_node
              IMPORTING
                et_changed_key = lt_changed_key ).

            " remove instances from the trigger list that are already failed by after loading determinations executed before
            IF et_failed IS NOT INITIAL.
              LOOP AT lt_changed_key INTO ls_key.
                READ TABLE et_failed TRANSPORTING NO FIELDS
                  WITH KEY node = lv_node
                           key  = ls_key-key.
                IF sy-subrc = 0.
                  DELETE lt_changed_key.
                ENDIF.
              ENDLOOP.
            ENDIF.

            ls_dettrig-check  = abap_false.
            ls_dettrig-create = abap_false.
            ls_dettrig-update = abap_false.
            ls_dettrig-delete = abap_false.
          ELSEIF iv_exectime = /bobf/if_conf_c=>sc_time_cleanup.
            " get all node instances which are loaded into the buffer of the request node
            " (don't care about trigger condition as this allows to clear also read buffers)
            TRY.
                mo_buffer->get_keys(
                  EXPORTING
                    iv_node_key = lv_node
                    iv_state    = /bobf/if_conf_c=>sc_state_current
                  IMPORTING
                    et_key      = lt_changed_key ).
              CATCH BEFORE UNWIND /bobf/cx_frw INTO lx_cx_frw.
                set_application_error( lx_cx_frw ).
            ENDTRY.
          ELSE.
            CHECK iv_exectime <> /bobf/if_conf_c=>sc_time_after_modify OR
                ls_dettrig-create = abap_true OR
                ls_dettrig-update = abap_true OR
                ls_dettrig-delete = abap_true.

            IF iv_exectime <> /bobf/if_conf_c=>sc_time_check_and_determine.
              ls_dettrig-check = abap_false.
            ENDIF.
            ls_dettrig-load = abap_false.

            lo_change->get_trigger(
              EXPORTING
                iv_exectime    = iv_exectime
                iv_node_key    = lv_node
                is_change_mode = ls_dettrig-change_mode
              IMPORTING
                et_changed_key = lt_changed_key ).
          ENDIF.

          " if this is an authority determination check keyload trigger additionally
          IF ls_det->det_cat = /bobf/if_conf_c=>sc_detcat_authority.
            lo_change->get_trigger(
              EXPORTING
                iv_exectime    = iv_exectime
                iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
                iv_node_key    = lv_node
              IMPORTING
                et_changed_key = lt_changed_key2 ).
            APPEND LINES OF lt_changed_key2 TO lt_changed_key.
          ENDIF.

          CHECK lt_changed_key IS NOT INITIAL.

*       get corresponding target keys
          IF ls_dettrig-assoc IS BOUND.
            retrieve_by_association(
              EXPORTING
                iv_node_key        = ls_dettrig-assoc->source_node_key
                it_key             = lt_changed_key
                iv_association     = ls_dettrig-assoc->assoc_key
                iv_fill_failed_key = abap_true
                iv_state           = lv_current_state
              IMPORTING
                eo_message         = lo_message
                et_key_link        = lt_key_link
                et_target_key      = lt_det_key
                et_failed_key      = lt_key_missing ).

            ASSERT ID /bobf/frw CONDITION
               /bobf/cl_tool_assert=>is_key_link_matching(
                   it_key_link   = lt_key_link
                   it_key        = lt_changed_key
                   it_target_key = lt_det_key ) = abap_true.

            ASSERT ID /bobf/frw CONDITION
               /bobf/cl_tool_assert=>is_key_subset(
                 it_key_set    = lt_changed_key
                 it_key_subset = lt_key_missing ) = abap_true.

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF ls_dettrig-delete = abap_true AND lt_key_missing IS NOT INITIAL.
*           check if changed key-table is incomplete due to
*           deleted trigger keys, if yes -> add nodes
              retrieve_by_association(
                EXPORTING
                  iv_node_key        = ls_dettrig-assoc->source_node_key
                  it_key             = lt_key_missing
                  iv_association     = ls_dettrig-assoc->assoc_key
                  iv_state           = ls_detconf->last_state
                  iv_buffer_only     = abap_true
                IMPORTING
                  eo_message         = lo_message
                  et_target_key      = lt_det_key_missing ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              IF ls_detconf->last_state <> /bobf/if_conf_c=>sc_state_database.
                retrieve_by_association(
                  EXPORTING
                    iv_node_key        = ls_dettrig-assoc->source_node_key
                    it_key             = lt_key_missing
                    iv_association     = ls_dettrig-assoc->assoc_key
                    iv_state           = /bobf/if_conf_c=>sc_state_database
                    iv_buffer_only     = abap_true
                  IMPORTING
                    eo_message         = lo_message
                    et_target_key      = lt_det_key_missing2 ).
                APPEND LINES OF lt_det_key_missing2 TO lt_det_key_missing.
                CLEAR lt_det_key_missing2.
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).
                SORT lt_det_key_missing.               "#EC CI_SORTLOOP
                DELETE ADJACENT DUPLICATES FROM lt_det_key_missing.
              ENDIF.

              retrieve(
                EXPORTING
                  iv_node_key         = ls_dettrig-assoc->target_node_key
                  it_key              = lt_det_key_missing
                  iv_state            = lv_current_state
                  iv_invalidate_cache = abap_false
                  iv_fill_data        = abap_false
                IMPORTING
                  et_failed_key       = lt_failed_key
                  eo_message          = lo_message ).

              ASSERT ID /bobf/frw CONDITION
                  /bobf/cl_tool_assert=>is_key_subset(
                      it_key_set    = lt_det_key_missing
                      it_key_subset = lt_failed_key ) = abap_true.

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              IF lt_failed_key IS NOT INITIAL.
                LOOP AT lt_det_key_missing INTO ls_key.
                  READ TABLE lt_failed_key WITH KEY key_sort
                    COMPONENTS key = ls_key-key
                    TRANSPORTING NO FIELDS.
                  CHECK sy-subrc = 0.
                  DELETE lt_det_key_missing.
                ENDLOOP.
              ENDIF.
              APPEND LINES OF lt_det_key_missing TO lt_det_key.
            ENDIF.
            APPEND LINES OF lt_det_key TO lt_key.
          ELSE.
*         perform existence check if delete triggers are used to avoid that the
*         determination is called with non-existing keys in current and before image
*         => CHECK DISABLED on REQUEST by AP CCM for FP2.0
*          IF ls_dettrig-delete = abap_true.
*            <...>
*          ENDIF.
            APPEND LINES OF lt_changed_key TO lt_key.
          ENDIF.
        ENDLOOP.

        CHECK lt_key IS NOT INITIAL.
        SORT lt_key.                                   "#EC CI_SORTLOOP
        DELETE ADJACENT DUPLICATES FROM lt_key.

* ____________________________________________________________________ *
*    filter keys regarding their node category
        IF ls_det->node_cat->* IS NOT INITIAL.
          get_node_cat(
            EXPORTING
              iv_node_key      = ls_det->node_key
              it_key           = lt_key
              iv_current_state = lv_current_state
              iv_last_state    = ls_detconf->last_state
            IMPORTING
              et_nodecat       = lt_nodecat
              et_failed_key    = lt_failed_key
              eo_message       = lo_message ).

          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_key
                  it_key_subset = lt_failed_key ) = abap_true.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          CLEAR: lt_key, lt_tmp_key.
          LOOP AT lt_nodecat INTO ls_nodecat.
            ls_key_new-key = ls_nodecat-key.
            APPEND ls_key_new TO lt_tmp_key.
            AT END OF node_cat_key.
*            check if node category is valid
              READ TABLE ls_det->node_cat->*
                WITH KEY node_cat_key = ls_nodecat-node_cat_key
                TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                APPEND LINES OF lt_tmp_key TO lt_key.
              ENDIF.
              CLEAR lt_tmp_key.
            ENDAT.
          ENDLOOP.
          CHECK lt_key IS NOT INITIAL.
        ENDIF.

* ____________________________________________________________________ *
*     call determination check delta
        ls_context-bo_key        = mo_conf->ms_obj-bo_key.
        ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
        ls_context-node_key      = ls_det->node_key.
        ls_context-det_key       = ls_det->det_key.
        ls_context-exectime      = iv_exectime.
        ls_context-cleanup_mode  = iv_cleanup_mode.
        ls_context-keep_cache    = iv_keep_cache.

        READ TABLE mt_determination
          WITH TABLE KEY det_key = ls_det->det_key
          INTO ls_det_inst.
        IF sy-subrc <> 0.
          ls_det_inst-det_key = ls_det->det_key.
          TRY.
              CREATE OBJECT ls_det_inst-class TYPE (ls_det->det_class).
            CATCH cx_sy_create_object_error INTO lx_root.
              lv_content_name = get_content_description(
                iv_det = abap_true
                iv_key = ls_det->det_key ).
              lv_content_cat = TEXT-002.
              CREATE OBJECT lx_frw
                EXPORTING
                  previous        = lx_root
                  textid          = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname    = ls_det->det_class
                  mv_content_cat  = lv_content_cat
                  mv_content_name = lv_content_name.
              set_configuration_error( lx_frw ).
          ENDTRY.

          INSERT ls_det_inst INTO TABLE mt_determination.
        ENDIF.

*     check for field changes between last and current state
        IF  ls_detconf->last_state IS NOT INITIAL
        AND ls_det->check_delta_impl = abap_true.
          lo_int_access->set_context( is_determination  = ls_context
                                      iv_within_loading = lv_within_loading
                                      iv_read_allowed   = abap_true ).
          INSERT lo_int_access INTO mt_access_stack INDEX 1.
          TRY.
              DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

              ls_det_inst-class->check_delta( EXPORTING is_ctx  = ls_context
                                                        io_read = lo_int_access
                                              CHANGING  ct_key  = lt_key ).

              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                  iv_content_key   = ls_det->det_key
                                                                                  iv_content_class = ls_det->det_class
                                                                                  iv_node_key      = ls_det->node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'CHECK_DELTA' ) ).
          ENDTRY.
          lo_int_access->invalidate( ).
          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ).
          DELETE mt_access_stack INDEX 1.
        ENDIF.

        CHECK lt_key IS NOT INITIAL.

* ____________________________________________________________________ *
*     if determination is transient: check if all required write-nodes are loaded
*     determination then only must happen for already loaded write-nodes
        IF ls_det->det_cat = /bobf/if_conf_c=>sc_detcat_transient.
          CLEAR lt_key_link2.
          LOOP AT ls_det->det_write->* INTO ls_detwrite
            WHERE assoc IS BOUND
              AND assoc->target_node->transient = abap_false.

            retrieve_by_association(
              EXPORTING
                iv_node_key    = ls_det->node_key
                it_key         = lt_key
                iv_association = ls_detwrite-assoc->assoc_key
                iv_state       = lv_current_state
                iv_buffer_only = abap_true
              IMPORTING
                eo_message     = lo_message
                et_key_link    = lt_key_link
                et_target_key  = lt_write_key ).

            ASSERT ID /bobf/frw CONDITION
               /bobf/cl_tool_assert=>is_key_link_matching(
                   it_key_link   = lt_key_link
                   it_key        = lt_key
                   it_target_key = lt_write_key ) = abap_true.

            retrieve(
              EXPORTING
                iv_node_key         = ls_detwrite-assoc->target_node_key
                it_key              = lt_write_key
                iv_state            = lv_current_state
                iv_invalidate_cache = abap_false
                iv_fill_data        = abap_false
                iv_buffer_only      = abap_true
              IMPORTING
                et_failed_key       = lt_failed_key
                eo_message          = lo_message ).

            ASSERT ID /bobf/frw CONDITION
                /bobf/cl_tool_assert=>is_key_subset(
                    it_key_set    = lt_tmp_key
                    it_key_subset = lt_failed_key ) = abap_true.

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            LOOP AT lt_failed_key INTO ls_key.
              DELETE lt_key_link USING KEY target_key WHERE target_key = ls_key-key.
            ENDLOOP.
            INSERT LINES OF lt_key_link INTO TABLE lt_key_link2.

          ENDLOOP.

          IF sy-subrc = 0.
            LOOP AT lt_key INTO ls_key.
              READ TABLE lt_key_link2 WITH KEY
                  source_key = ls_key-key
                  TRANSPORTING NO FIELDS.
              IF sy-subrc <> 0.
*             no write node yet in buffer -> do not execute determination
                DELETE lt_key.
              ENDIF.
            ENDLOOP.
          ENDIF.
          CHECK lt_key IS NOT INITIAL.
        ENDIF.

* ____________________________________________________________________ *
*     check if all required nodes are locked
        IF ls_det->edit_mode <> /bobf/if_conf_c=>sc_edit_read_only     AND
           iv_exectime       <> /bobf/if_conf_c=>sc_time_after_loading AND
           mo_conf->ms_obj-no_lock = abap_false                        AND
           ls_det->det_write IS NOT INITIAL.
          CLEAR lt_lock_node.
          LOOP AT ls_det->det_write->* INTO ls_detwrite.
            IF ls_detwrite-assoc IS BOUND.
              retrieve_by_association(
                EXPORTING
                  iv_node_key    = ls_det->node_key
                  it_key         = lt_key
                  iv_association = ls_detwrite-assoc->assoc_key
                  iv_state       = lv_current_state
                IMPORTING
                  eo_message     = lo_message
                  et_failed_key  = lt_failed_write_key
                  et_target_key  = lt_write_key ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
              map_to_node(
                EXPORTING
                  iv_node_key = ls_detwrite-assoc->target_node_key
                  it_key      = lt_write_key
                IMPORTING
                  et_node     = lt_write_node ).
              IF lt_failed_write_key IS NOT INITIAL.
                retrieve_by_association(
                 EXPORTING
                   iv_node_key    = ls_det->node_key
                   it_key         = lt_failed_write_key
                   iv_association = ls_detwrite-assoc->assoc_key
                   iv_state       = ls_detconf->last_state
                 IMPORTING
                   eo_message     = lo_message
                   et_target_key  = lt_write_key ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).
                map_to_node(
                  EXPORTING
                    iv_node_key = ls_detwrite-assoc->target_node_key
                    it_key      = lt_write_key
                  IMPORTING
                    et_node     = lt_write_node_bef ).
                INSERT LINES OF lt_write_node_bef INTO TABLE lt_write_node.
              ENDIF.
            ELSE.
*           no association maintained -> take own node
              map_to_node(
                EXPORTING
                  iv_node_key = ls_det->node_key
                  it_key      = lt_key
                IMPORTING
                  et_node     = lt_write_node ).
            ENDIF.
            INSERT LINES OF lt_write_node INTO TABLE lt_lock_node.
            CLEAR lt_write_node.
          ENDLOOP.

          IF lt_lock_node IS NOT INITIAL.

            DELETE ADJACENT DUPLICATES FROM lt_lock_node.
*       lock required nodes
            mo_lock_manager->lock(
              EXPORTING
                iv_edit_mode                  = ls_det->edit_mode
                iv_all_none                   = abap_true
                it_node                       = lt_lock_node
                io_change                     = io_change
                iv_generic                    = abap_false
              IMPORTING
                eo_message                    = lo_message
                et_lockable_node_newly_locked = lt_node_reload
                et_node_not_locked            = lt_failed_node ).

            ASSERT ID /bobf/frw CONDITION
                /bobf/cl_tool_assert=>is_node_subset(
                    it_node_set    = lt_lock_node
                    it_node_subset = lt_failed_node ) = abap_true.

            INSERT LINES OF lt_failed_node INTO TABLE et_failed.
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF lt_failed_node IS NOT INITIAL.
*         skip determination if required nodes are not locked
              CONTINUE.
            ENDIF.

*       reload newly locked nodes
            IF lt_node_reload IS NOT INITIAL.
              do_loading(
                EXPORTING
                  it_node         = lt_node_reload
                  iv_reload       = abap_true
                  iv_load_data    = abap_true
                  iv_check_buf    = abap_false
                  iv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup
                  iv_edit_mode    = ls_det->edit_mode
                  io_change       = io_change
                IMPORTING
                  eo_message      = lo_message ).

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
            ENDIF.
          ENDIF.
        ENDIF.

* ____________________________________________________________________ *
*     check read-nodes
        LOOP AT ls_det->det_read->* INTO ls_detread.
          IF ls_detread-assoc IS BOUND.
            retrieve_by_association(
              EXPORTING
                iv_node_key    = ls_det->node_key
                it_key         = lt_key
                iv_association = ls_detread-assoc->assoc_key
                iv_state       = lv_current_state
              IMPORTING
                eo_message     = lo_message ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ELSE.
*         no association maintained -> take own node
            retrieve(
              EXPORTING
                iv_node_key         = ls_det->node_key
                it_key              = lt_key
                iv_state            = lv_current_state
                iv_invalidate_cache = abap_false
                iv_fill_data        = abap_false
              IMPORTING
                eo_message          = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.
        ENDLOOP.

* ____________________________________________________________________ *
*     call determination check
*     check for field values of current state
        IF ls_det->check_impl = abap_true.
          lo_int_access->set_context( is_determination  = ls_context
                                      iv_within_loading = lv_within_loading
                                      iv_read_allowed   = abap_true ).
          INSERT lo_int_access INTO mt_access_stack INDEX 1.
          TRY.
              lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

              ls_det_inst-class->check( EXPORTING is_ctx  = ls_context
                                                  io_read = lo_int_access
                                        CHANGING  ct_key  = lt_key ).

              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                  iv_content_key   = ls_det->det_key
                                                                                  iv_content_class = ls_det->det_class
                                                                                  iv_node_key      = ls_det->node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'CHECK' ) ).
          ENDTRY.
          lo_int_access->invalidate( ).
          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ).
          DELETE mt_access_stack INDEX 1.
          CHECK lt_key IS NOT INITIAL.
        ENDIF.

* ____________________________________________________________________ *
*     call determination execution
        CLEAR: lt_failed_key,
               lo_message.
        IF ls_det->edit_mode = /bobf/if_conf_c=>sc_edit_read_only OR
           ls_det->edit_mode = /bobf/if_conf_c=>sc_edit_shared.
          lo_int_access->set_edit_mode( ls_det->edit_mode ).
        ELSE.
          lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_exclusive ).
        ENDIF.
        IF iv_exectime = /bobf/if_conf_c=>sc_time_cleanup.
          " modifications done during this determination time are immediately lost
          " as cleanup is performed afterwards - thus don't all modification at all
          lo_int_access->set_context(
            is_determination  = ls_context
            iv_read_allowed   = abap_true
            iv_within_loading = lv_within_loading
            iv_modify_allowed = abap_false ).
        ELSE.
          lo_int_access->set_context(
            is_determination  = ls_context
            iv_read_allowed   = abap_true
            iv_within_loading = lv_within_loading
            iv_modify_allowed = abap_true ).
        ENDIF.
        INSERT lo_int_access INTO mt_access_stack INDEX 1.

        TRY.
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ).

            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lib_enqueue_context_push_keys( iv_node_key = ls_context-node_key
                                           it_key      = lt_key ).

            ls_det_inst-class->execute( EXPORTING is_ctx        = ls_context
                                                  it_key        = lt_key
                                                  io_read       = lo_int_access
                                                  io_modify     = lo_int_access
                                        IMPORTING eo_message    = lo_message
                                                  et_failed_key = lt_failed_key ).

            lib_enqueue_context_pop( ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = lt_key
                                                                                     it_key_subset = lt_failed_key ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>failed_key_message( io_message    = lo_message
                                                                                          it_failed_key = lt_failed_key ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                iv_content_key   = ls_det->det_key
                                                                                iv_content_class = ls_det->det_class
                                                                                iv_node_key      = ls_det->node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'EXECUTE' ) ).
          CLEANUP.
            lib_enqueue_context_pop( ).
        ENDTRY.

        ASSERT ID /bobf/frw CONDITION lt_failed_key IS INITIAL.

*     check for undone modifications and flush
        IF lo_int_access->mt_modification IS NOT INITIAL.
          TRY.
              lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
              lo_int_access->end_modify( ).
              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                  iv_content_key   = ls_det->det_key
                                                                                  iv_content_class = ls_det->det_class
                                                                                  iv_node_key      = ls_det->node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'FRW_END_MODIFY' ) ).
          ENDTRY.
        ENDIF.
        collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                          CHANGING  co_message = lo_message ).
        lo_int_access->invalidate( ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ).
        DELETE mt_access_stack INDEX 1.

*     fill message
        create_durable_msg_container( CHANGING co_message = lo_message ).
        IF lo_message IS BOUND.
          lo_message_int ?= lo_message.
          ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
          ls_runtime_context-node_key = ls_context-node_key.
          ls_runtime_context-det_key  = ls_context-det_key.
          lo_message_int->set_context( is_context = ls_runtime_context
                                       it_key     = filter_out_unnecessary_detkeys( io_det_class = ls_det_inst-class
                                                                                    it_all_keys  = lt_key ) ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

*     fill failed keys
        IF lt_failed_key IS NOT INITIAL.
          IF mo_conf->ms_obj-is_rap_bo EQ abap_true.
            " for RAI BOs we are strict: Determinations must not return failed keys.
            " This has been illegally used in AI BOs to prevent saving of Drafts. We do not
            " want this to slip through, again.
            set_application_error( lcl_error_provider=>create_impl_class_error( textid           = /bobf/cx_frw_core=>sc_no_failed_keys_from_dets
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                iv_content_key   = ls_det->det_key
                                                                                iv_content_class = ls_det->det_class
                                                                                iv_node_key      = ls_det->node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'EXECUTE' ) ).
          ENDIF.

          map_to_node(
            EXPORTING
              iv_node_key = ls_context-node_key
              it_key      = lt_failed_key
            IMPORTING
              et_node     = lt_failed_node ).
          INSERT LINES OF lt_failed_node INTO TABLE et_failed.

          " add trigger nodes if failed for authority determinations
          IF ls_det->det_cat = /bobf/if_conf_c=>sc_detcat_authority.
            LOOP AT ls_det->det_trigger->* INTO ls_dettrig.
              IF ls_dettrig-assoc IS BOUND. " only if the node is not the same otherwise just take lt_failed_key
                lo_change->get_trigger(
                   EXPORTING
                     iv_exectime    = iv_exectime
                     iv_change_mode = /bobf/if_frw_c=>sc_modify_load
                     iv_node_key    = ls_dettrig-assoc->source_node_key
                   IMPORTING
                     et_changed_key = lt_changed_key ).

                lo_change->get_trigger(
                   EXPORTING
                     iv_exectime    = iv_exectime
                     iv_change_mode = /bobf/if_frw_c=>sc_modify_load_key
                     iv_node_key    = ls_dettrig-assoc->source_node_key
                   IMPORTING
                     et_changed_key = lt_changed_key2 ).
                APPEND LINES OF lt_changed_key2 TO lt_changed_key.

                IF lt_changed_key IS NOT INITIAL.
                  retrieve_by_association(
                    EXPORTING
                      iv_node_key        = ls_dettrig-assoc->source_node_key
                      it_key             = lt_changed_key
                      iv_association     = ls_dettrig-assoc->assoc_key
                      iv_fill_failed_key = abap_false
                      iv_state           = lv_current_state
                    IMPORTING
                      eo_message         = lo_message
                      et_key_link        = lt_key_link
                      et_target_key      = lt_det_key ).

                  collect_messages( EXPORTING io_message = lo_message
                                    CHANGING  co_message = eo_message ).

                  LOOP AT lt_key_link INTO ls_key_link.
                    READ TABLE lt_failed_key TRANSPORTING NO FIELDS
                      WITH KEY key_sort COMPONENTS key = ls_key_link-target_key.
                    IF sy-subrc = 0.
                      ls_node-node = ls_dettrig-node_key.
                      ls_node-key  = ls_key_link-source_key.
                      INSERT ls_node INTO TABLE et_failed.
                    ENDIF.
                  ENDLOOP.
                ENDIF.
              ENDIF.
            ENDLOOP.
          ENDIF.

        ENDIF.
      ENDLOOP.

* ____________________________________________________________________ *
*   if exectime = after_val: prevent state creation of keys that failed
*   during the validation execution
      IF mo_change_fail_val IS BOUND AND
         iv_exectime = /bobf/if_conf_c=>sc_time_after_validation.

        mo_change_fail_val->get( IMPORTING et_change = lt_change ).
        LOOP AT lt_change INTO ls_change.
          CLEAR lt_key.
          ls_key-key = ls_change-key.
          APPEND ls_key TO lt_key.

          IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
            mo_conf->get_node( iv_node_key = ls_change-node_key ).
          ENDIF.

          IF mo_conf->ms_last_node-delegation_class IS INITIAL.
            TRY.
                mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_change-node_key
                    it_key        = lt_key
                    iv_state      = lv_current_state
                    io_change     = io_change
                  IMPORTING
                    et_target_key = lt_root_key ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            after_loading(
              EXPORTING
                io_change         = io_change
                iv_load_state     = lv_current_state
              IMPORTING
                eo_message        = lo_message ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF lt_root_key IS INITIAL.
              TRY.
                  mo_buffer->get_root_key(
                    EXPORTING
                      iv_node_key   = ls_change-node_key
                      it_key        = lt_key
                      iv_state      = /bobf/if_conf_c=>sc_state_database
                      io_change     = io_change
                    IMPORTING
                      et_target_key = lt_root_key ).
                CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.

              after_loading(
                EXPORTING
                  io_change         = io_change
                  iv_load_state     = /bobf/if_conf_c=>sc_state_database
                IMPORTING
                  eo_message        = lo_message ).

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).
            ENDIF.
            INSERT LINES OF lt_root_key INTO TABLE lt_failed_root_key.

          ELSE.
            TRY.
                lo_delegation = get_delegation( ls_change-node_key ).
                lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key = ls_change-node_key
                    it_key      = lt_key
                    iv_state    = lv_current_state
                    io_read     = mo_delegation_read
                  IMPORTING
                    et_key_link = lt_key_link ).

                IF lt_key_link IS INITIAL.
                  lo_delegation->get_root_key(
                    EXPORTING
                      iv_node_key = ls_change-node_key
                      it_key      = lt_key
                      iv_state    = /bobf/if_conf_c=>sc_state_database
                      io_read     = mo_delegation_read
                    IMPORTING
                      et_key_link = lt_key_link ).
                ENDIF.
                /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_key_link_matching(
                   it_key_link = lt_key_link
                   it_key      = lt_key ) = abap_true.

            READ TABLE lt_key_link INTO ls_key_link INDEX 1.
            ls_key-key = ls_key_link-target_key.
            INSERT ls_key INTO TABLE lt_failed_root_key.
          ENDIF.
        ENDLOOP.
        SORT lt_failed_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_failed_root_key.
        CLEAR: mo_change_fail_val, lt_key.
      ENDIF.

* ____________________________________________________________________ *
*   insert all changes belonging to failed keys into
*   mo_change_fail_det/mo_change_fail_val
      IF iv_exectime = /bobf/if_conf_c=>sc_time_after_modify.
        CLEAR mo_change_fail_det.
      ENDIF.

      IF et_failed IS NOT INITIAL AND
       ( iv_exectime = /bobf/if_conf_c=>sc_time_after_validation OR
         iv_exectime = /bobf/if_conf_c=>sc_time_after_modify ).

        CLEAR: lt_key2, lt_key3, lt_key4, lt_key_for_db.
        LOOP AT et_failed INTO ls_node.
          ls_key-key = ls_node-key.
          INSERT ls_key INTO TABLE lt_key2.

          AT END OF node.
            IF mo_conf->ms_last_node-node_key <> ls_node-node.
              mo_conf->get_node( iv_node_key = ls_node-node ).
            ENDIF.

            IF mo_conf->ms_last_node-delegation_class IS INITIAL.
              TRY.
                  mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node-node
                    it_key        = lt_key2
                    iv_state      = lv_current_state
                    io_change     = io_change
                  IMPORTING
                    et_target_key = lt_key3
                    et_failed_key = lt_key4 ).
                CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.
              ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_key2
                  it_key_subset = lt_key4 ) = abap_true.

              after_loading(
                EXPORTING
                  io_change     = io_change
                  iv_load_state = lv_current_state
                IMPORTING
                  eo_message    = lo_message ).
              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              INSERT LINES OF lt_key3 INTO TABLE lt_failed_root_key.
              IF lt_key4 IS NOT INITIAL.
                IF ls_detconf->last_state IS NOT INITIAL.
                  TRY.
                      mo_buffer->get_root_key(
                        EXPORTING
                          it_key        = lt_key4
                          iv_node_key   = ls_node-node
     iv_state      = ls_detconf->last_state
                            io_change     = io_change
                          IMPORTING
                            et_target_key = lt_key3
                            et_failed_key = lt_key_for_db ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.

                  after_loading(
                    EXPORTING
                      io_change     = io_change
                      iv_load_state = ls_detconf->last_state
                    IMPORTING
                      eo_message    = lo_message ).
                  collect_messages( EXPORTING io_message = lo_message
                                    CHANGING  co_message = eo_message ).

                  INSERT LINES OF lt_key3 INTO TABLE lt_failed_root_key.
                ELSE.
                  lt_key_for_db = lt_key4.
                ENDIF.

                IF lt_key_for_db IS NOT INITIAL.
                  TRY.
                      mo_buffer->get_root_key(
                        EXPORTING
                          it_key        = lt_key_for_db
                          iv_node_key   = ls_node-node
                        iv_state      = /bobf/if_conf_c=>sc_state_database
                        io_change     = io_change
                      IMPORTING
                        et_target_key = lt_key3 ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.

                  after_loading(
                    EXPORTING
                      io_change     = io_change
                      iv_load_state = /bobf/if_conf_c=>sc_state_database
                    IMPORTING
                      eo_message    = lo_message ).
                  collect_messages( EXPORTING io_message = lo_message
                                    CHANGING  co_message = eo_message ).

                  INSERT LINES OF lt_key3 INTO TABLE lt_failed_root_key.
                ENDIF.

              ENDIF.
              CLEAR: lt_key2, lt_key3, lt_key4, lt_key_for_db.

            ELSE.
              lo_delegation = get_delegation( ls_node-node ).
              TRY.
                  lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                  lo_delegation->get_root_key(
                    EXPORTING
                      iv_node_key = ls_node-node
                      it_key      = lt_key2
                      iv_state    = lv_current_state
                      io_read     = mo_delegation_read
                    IMPORTING
                      et_key_link = lt_key_link ).
                  /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
                CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.
              ASSERT ID /bobf/frw_error CONDITION
                 /bobf/cl_tool_assert=>is_key_link_matching(
                     it_key_link = lt_key_link
                     it_key      = lt_key2 ) = abap_true.

              LOOP AT lt_key2 INTO ls_key.
                READ TABLE lt_key_link
                   WITH KEY source_key = ls_key-key
                   INTO ls_key_link.
                IF sy-subrc = 0.
                  ls_key-key = ls_key_link-target_key.
                  APPEND ls_key TO lt_failed_root_key.
                ELSE.
                  APPEND ls_key TO lt_key3.
                ENDIF.
              ENDLOOP.
              IF lt_key3 IS NOT INITIAL.
                TRY.
                    lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                    lo_delegation->get_root_key(
                      EXPORTING
                        iv_node_key = ls_node-node
                        it_key      = lt_key3
                        iv_state    = /bobf/if_conf_c=>sc_state_database
                        io_read     = mo_delegation_read
                      IMPORTING
                        et_key_link = lt_key_link ).
                    /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.
                ASSERT ID /bobf/frw_error CONDITION
                   /bobf/cl_tool_assert=>is_key_link_matching(
                       it_key_link = lt_key_link
                       it_key      = lt_key3 ) = abap_true.

                LOOP AT lt_key_link INTO ls_key_link.
                  ls_key-key = ls_key_link-target_key.
                  APPEND ls_key TO lt_failed_root_key.
                ENDLOOP.
              ENDIF.
              CLEAR: lt_key2,
                     lt_key3.
            ENDIF.
          ENDAT.
        ENDLOOP.
        SORT lt_failed_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_failed_root_key.

        do_det_fill_change_fail(
          EXPORTING
            iv_exectime = iv_exectime
            io_change   = io_change
            it_failed_root_key = lt_failed_root_key
            iv_current_state = lv_current_state
          CHANGING
            co_message  = eo_message
        ).

      ENDIF.

    ENDIF.

* ____________________________________________________________________ *
* create new state for all changed objects
    IF ls_detconf->new_state IS NOT INITIAL AND
       ls_detconf->exectime <> /bobf/if_conf_c=>sc_time_after_loading.

      IF ls_detconf->exectime <> /bobf/if_conf_c=>sc_time_after_validation OR
         NOT ( mo_conf->ms_obj-last_det_state_not_relevant = abap_true AND
               mo_change_fail_det IS BOUND ).

        ls_statecr-create = abap_true.
        ls_statecr-update = abap_true.
        ls_statecr-delete = abap_true.

        io_change->get_changes(
          EXPORTING
            is_change_mode = ls_statecr
          IMPORTING
            et_change      = lt_change ).

        IF lt_failed_root_key IS INITIAL.
*     no failed keys -> perform state handling on node level
          CLEAR lt_tmp_node.
          IF lt_change IS NOT INITIAL.
            LOOP AT lt_change INTO ls_change.
              IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
                mo_conf->get_node( iv_node_key = ls_change-node_key ).
              ENDIF.
              IF mo_conf->ms_last_node-delegation_class IS INITIAL.
                ls_node-node = ls_change-node_key.
                ls_node-key  = ls_change-key.
                INSERT ls_node INTO TABLE lt_tmp_node.
              ENDIF.
            ENDLOOP.
            DELETE ADJACENT DUPLICATES FROM lt_tmp_node.

            TRY.
                mo_buffer->transfer_state(
                  EXPORTING
                    it_node         = lt_tmp_node
                    iv_incl_subtree = abap_false
                    iv_state_source = lv_current_state
                    iv_state_dest   = ls_detconf->new_state ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.

        ELSE.
*     failed keys are filled -> perform state handling on BO level
          CLEAR lt_key.
          LOOP AT lt_change INTO ls_change.
            ls_key_new-key = ls_change-key.
            APPEND ls_key_new TO lt_key.
            AT END OF node_key.
*         get root key
              IF ls_change-node_key = mo_conf->ms_obj-root_node_key.
                APPEND LINES OF lt_key TO lt_root_key.
              ELSE.
                IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
                  mo_conf->get_node( iv_node_key = ls_change-node_key ).
                ENDIF.
                IF mo_conf->ms_last_node-delegation_class IS INITIAL.
                  TRY.
                      mo_buffer->get_root_key(
                      EXPORTING
                        iv_node_key   = ls_change-node_key
                        it_key        = lt_key
                        iv_state      = lv_current_state
                        io_change     = io_change
                      IMPORTING
                        et_target_key = lt_tmp_key
                        et_failed_key = lt_failed_key ).
                    CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                      set_application_error( lx_root ).
                  ENDTRY.
                  ASSERT ID /bobf/frw_error CONDITION
                      /bobf/cl_tool_assert=>is_key_subset(
                          it_key_set    = lt_key
                          it_key_subset = lt_failed_key ) = abap_true.

                  after_loading(
                    EXPORTING
                      io_change     = io_change
                      iv_load_state = lv_current_state
                    IMPORTING
                      eo_message    = lo_message ).
                  collect_messages( EXPORTING io_message = lo_message
                                    CHANGING  co_message = eo_message ).

                  APPEND LINES OF lt_tmp_key TO lt_root_key.

                ELSE.
                  CLEAR lt_failed_key.
                ENDIF.
              ENDIF.

              IF lt_failed_key IS NOT INITIAL AND
                 ls_detconf->last_state IS NOT INITIAL.
*           get root of deleted objects
                TRY.
                    mo_buffer->get_root_key(
                      EXPORTING
                        iv_node_key   = ls_change-node_key
                        it_key        = lt_failed_key
                        iv_state      = ls_detconf->last_state
                        io_change     = io_change
                      IMPORTING
                        et_target_key = lt_tmp_key ).
                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.

                after_loading(
                  EXPORTING
                    io_change     = io_change
                    iv_load_state = ls_detconf->last_state
                  IMPORTING
                    eo_message    = lo_message ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).

                APPEND LINES OF lt_tmp_key TO lt_root_key.
              ENDIF.
              CLEAR: lt_tmp_key,
                     lt_key.
            ENDAT.
          ENDLOOP.

          SORT lt_root_key.
          DELETE ADJACENT DUPLICATES FROM lt_root_key.

*     filter root keys regarding failed keys
          IF lt_failed_root_key IS NOT INITIAL.
            LOOP AT lt_root_key INTO ls_key_new.
              READ TABLE lt_failed_root_key WITH KEY key_sort
                COMPONENTS key = ls_key_new-key
                TRANSPORTING NO FIELDS.
              CHECK sy-subrc = 0.
              DELETE lt_root_key.
            ENDLOOP.
          ENDIF.

*     transfer state
          IF lt_root_key IS NOT INITIAL.
            map_to_node(
              EXPORTING
                iv_node_key = mo_conf->ms_obj-root_node_key
                it_key      = lt_root_key
              IMPORTING
                et_node     = lt_tmp_node ).
            TRY.
                mo_buffer->transfer_state(
                EXPORTING
                  it_node         = lt_tmp_node
                  iv_incl_subtree = abap_true
                  iv_state_source = lv_current_state
                  iv_state_dest   = ls_detconf->new_state ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD do_determinations_retrieve.

    DATA: lt_key              TYPE        /bobf/t_frw_key,
          lt_tmp_key          TYPE        /bobf/t_frw_key,
          lv_node_key         TYPE        /bobf/obm_node_key,
          lv_trigger_node_key TYPE        /bobf/obm_node_key,
          ls_detconf          TYPE REF TO /bobf/s_confro_exectime,
          ls_ctx_det          TYPE        /bobf/s_frw_ctx_det,
          ls_ctx_assoc        TYPE        /bobf/s_frw_ctx_assoc,
          ls_det              TYPE        ty_determination,
          ls_key_new          TYPE        /bobf/s_frw_key,
          lo_change           TYPE REF TO /bobf/cl_frw_change,
          lo_message          TYPE REF TO /bobf/if_frw_message,
          lo_message_int      TYPE REF TO /bobf/cl_frw_message,
          ls_runtime_context  TYPE        /bobf/s_frw_runtime_context,
          lo_int_access       TYPE REF TO /bobf/cl_frw_int_access,
          lv_content_cat      TYPE        string,
          lt_nodecat          TYPE        /bobf/t_frw_node_cat,
          ls_nodecat          TYPE        /bobf/s_frw_node_cat,
          lv_content_name     TYPE        /bobf/obm_name,
          lt_failed_key       TYPE        /bobf/t_frw_key,
          lx_root             TYPE REF TO cx_root,
          lx_frw              TYPE REF TO /bobf/cx_frw_core,
          ls_statecr          TYPE        /bobf/s_confro_chg_mode,
          lt_change           TYPE        /bobf/t_frw_change,
          lt_tmp_node         TYPE        /bobf/t_frw_node,
          ls_change           TYPE        /bobf/s_frw_change,
          ls_node             TYPE        /bobf/s_frw_node.

    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           et_failed_key.

*  get configuration
    ls_detconf = mo_conf->get_determination( /bobf/if_conf_c=>sc_time_before_retrieve ).

    IF iv_assoc_key IS NOT INITIAL.
      IF mo_conf->ms_last_assoc-assoc_key <> iv_assoc_key.
        mo_conf->get_assoc( iv_assoc_key  = iv_assoc_key ).
      ENDIF.
    ENDIF.

    IF iv_node_key IS INITIAL.
      lv_node_key         = mo_conf->ms_last_assoc-source_node_key.
      lv_trigger_node_key = mo_conf->ms_last_assoc-target_node_key.
    ELSE.
      lv_node_key         = iv_node_key.
      lv_trigger_node_key = iv_node_key.
    ENDIF.

*  loop at all determinations
    LOOP AT ls_detconf->det_list->* ASSIGNING FIELD-SYMBOL(<ls_detlist>)
      WHERE node_key = lv_node_key.

      " take over keys
      lt_key = it_key.

*    check trigger nodes
      CHECK line_exists( <ls_detlist>-det_trigger->*[ node_key = lv_trigger_node_key ] ).

* ____________________________________________________________________ *
*    filter keys regarding their node category
      IF <ls_detlist>-node_cat->* IS NOT INITIAL.
        get_node_cat(
          EXPORTING
            iv_node_key      = <ls_detlist>-node_key
            it_key           = lt_key
            iv_current_state = /bobf/if_conf_c=>sc_state_current
            iv_last_state    = ls_detconf->last_state
          IMPORTING
            et_nodecat       = lt_nodecat
            et_failed_key    = lt_failed_key
            eo_message       = lo_message ).

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        CLEAR: lt_key, lt_tmp_key.
        LOOP AT lt_nodecat INTO ls_nodecat.
          ls_key_new-key = ls_nodecat-key.
          APPEND ls_key_new TO lt_tmp_key.
          AT END OF node_cat_key.
*            check if node category is valid
            IF line_exists( <ls_detlist>-node_cat->*[ node_cat_key = ls_nodecat-node_cat_key ] ).
              APPEND LINES OF lt_tmp_key TO lt_key.
            ENDIF.
            CLEAR lt_tmp_key.
          ENDAT.
        ENDLOOP.
        CHECK lt_key IS NOT INITIAL.
      ENDIF.

*    create internal access object and context for determinations
      IF lo_int_access IS NOT BOUND.
        CREATE OBJECT lo_change.
        IF iv_key_is_default = abap_true.
          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
              io_change          = lo_change
              iv_class_name      = /bobf/cl_frw_int_defaults=>gc_class_name
            RECEIVING
              eo_internal_access = lo_int_access
          ).
        ELSE.
          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
              io_change          = lo_change
              iv_class_name      = /bobf/cl_frw_int_access_trans=>gc_class_name
            RECEIVING
              eo_internal_access = lo_int_access
          ).
        ENDIF.
        lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
        lo_int_access->set_current_state( iv_current_state  = iv_state ).
        lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_read_only ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
        INSERT lo_int_access INTO mt_access_stack INDEX 1.

        ls_ctx_det-bo_key              = mo_conf->ms_obj-bo_key.
        ls_ctx_det-root_node_key       = mo_conf->ms_obj-root_node_key.
        ls_ctx_det-node_key            = lv_node_key.
        ls_ctx_det-exectime            = /bobf/if_conf_c=>sc_time_before_retrieve.
        ls_ctx_det-assoc_key           = iv_assoc_key.
        ls_ctx_det-assoc_parameters    = is_parameters.
        ls_ctx_det-filtered_attributes = it_filtered_attributes.
        IF iv_assoc_key IS NOT INITIAL.
          ls_ctx_assoc-bo_key          = mo_conf->ms_obj-bo_key.
          ls_ctx_assoc-root_node_key   = mo_conf->ms_obj-root_node_key.
          ls_ctx_assoc-node_key        = iv_node_key.
          ls_ctx_assoc-assoc_key       = iv_assoc_key.
        ENDIF.
      ENDIF.

*    call determination
      ls_ctx_det-det_key = <ls_detlist>-det_key.

      READ TABLE mt_determination
        WITH TABLE KEY det_key = <ls_detlist>-det_key
        INTO ls_det.
      IF sy-subrc <> 0.
        ls_det-det_key = <ls_detlist>-det_key.
        TRY.
            CREATE OBJECT ls_det-class TYPE (<ls_detlist>-det_class).
          CATCH cx_sy_create_object_error INTO lx_root.
            lv_content_name = get_content_description(
              iv_det = abap_true
              iv_key = <ls_detlist>-det_key ).
            lv_content_cat = TEXT-002.
            CREATE OBJECT lx_frw
              EXPORTING
                previous        = lx_root
                textid          = /bobf/cx_frw_core=>sc_no_instance
                mv_classname    = <ls_detlist>-det_class
                mv_content_cat  = lv_content_cat
                mv_content_name = lv_content_name.
            set_configuration_error( lx_frw ).
        ENDTRY.
        INSERT ls_det INTO TABLE mt_determination.
      ENDIF.

*    call determination check
      IF lt_key IS NOT INITIAL.
        lo_int_access->set_context(
          is_determination   = ls_ctx_det
          is_association     = ls_ctx_assoc
          iv_within_loading  = iv_within_loading
          iv_within_retrieve = abap_true
          iv_read_allowed    = abap_true ).
        TRY.
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_det-class->check( EXPORTING is_ctx  = ls_ctx_det
                                           io_read = lo_int_access
                                 CHANGING  ct_key  = lt_key ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                iv_content_key   = <ls_detlist>-det_key
                                                                                iv_content_class = <ls_detlist>-det_class
                                                                                iv_node_key      = <ls_detlist>-node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'CHECK' ) ).
        ENDTRY.
        lo_int_access->invalidate( ).
      ENDIF.

      CHECK lt_key IS NOT INITIAL.

      lo_int_access->set_context(
        is_determination   = ls_ctx_det
        is_association     = ls_ctx_assoc
        iv_read_allowed    = abap_true
        iv_modify_allowed  = abap_true
        iv_within_loading  = iv_within_loading
        iv_within_retrieve = abap_true ).
      TRY.
          lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lib_enqueue_context_push_keys( iv_node_key = ls_ctx_det-node_key
                                         it_key      = lt_key ).

          ls_det-class->execute( EXPORTING is_ctx        = ls_ctx_det
                                           it_key        = lt_key
                                           io_read       = lo_int_access
                                           io_modify     = lo_int_access
                                 IMPORTING eo_message    = lo_message
                                           et_failed_key = lt_failed_key ).

          " hard assertion because if state messages are switched on (AI, RAP), only generated
          " determinations can be assigned to retrieve
          ASSERT /bobf/cl_tool_assert=>contains_state_message( lo_message ) = abap_false.

          lib_enqueue_context_pop( ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          ASSERT ID /bobf/frw_error CONDITION lt_failed_key IS INITIAL
                                           OR iv_node_key   IS INITIAL.
          ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = it_key
                                                                                   it_key_subset = lt_failed_key ).
          ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>failed_key_message( io_message    = lo_message
                                                                                        it_failed_key = lt_failed_key ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                              iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                              iv_content_key   = <ls_detlist>-det_key
                                                                              iv_content_class = <ls_detlist>-det_class
                                                                              iv_node_key      = <ls_detlist>-node_key
                                                                              io_configuration = mo_conf
                                                                              iv_method_name   = 'EXECUTE' ) ).
        CLEANUP.
          lib_enqueue_context_pop( ).
      ENDTRY.

      APPEND LINES OF lt_failed_key TO et_failed_key.
      CLEAR lt_failed_key.

      create_durable_msg_container( CHANGING co_message = lo_message ).
      IF lo_message IS BOUND.
        lo_message_int ?= lo_message.
        ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
        ls_runtime_context-node_key = ls_ctx_det-node_key.
        ls_runtime_context-det_key  = ls_ctx_det-det_key.
        lo_message_int->set_context( is_context = ls_runtime_context
                                     " no invalidations in retrieve because no state messages should be produced (see assertion above)
                                     " therefore no key table is provided
                                   ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

*    check for undone modifications and flush
      IF lo_int_access->mt_modification IS NOT INITIAL.
        TRY.
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_int_access->end_modify( ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_det
                                                                                iv_content_key   = <ls_detlist>-det_key
                                                                                iv_content_class = <ls_detlist>-det_class
                                                                                iv_node_key      = <ls_detlist>-node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'FRW_END_MODIFY' ) ).
        ENDTRY.
      ENDIF.
      collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                        CHANGING  co_message = eo_message ).
      lo_int_access->invalidate( ).
    ENDLOOP.

    " collect changes
    IF lo_int_access IS BOUND.
      ls_statecr-create = abap_true.
      ls_statecr-update = abap_true.
      ls_statecr-delete = abap_true.
      lo_int_access->mo_change->get_changes(
        EXPORTING
          is_change_mode = ls_statecr
        IMPORTING
          et_change      = lt_change ).
    ENDIF.

    " transfer state (on node level)
    CLEAR lt_tmp_node.
    IF lt_change IS NOT INITIAL.
      LOOP AT lt_change INTO ls_change.
        IF mo_conf->ms_last_node-node_key <> ls_change-node_key.
          mo_conf->get_node( iv_node_key = ls_change-node_key ).
        ENDIF.
        IF mo_conf->ms_last_node-delegation_class IS INITIAL.
          ls_node-node = ls_change-node_key.
          ls_node-key  = ls_change-key.
          INSERT ls_node INTO TABLE lt_tmp_node.
        ENDIF.
      ENDLOOP.
      DELETE ADJACENT DUPLICATES FROM lt_tmp_node.
      " copy to image 2
      TRY.
          mo_buffer->transfer_state(
            EXPORTING
              it_node         = lt_tmp_node
              iv_incl_subtree = abap_false
              iv_state_source = /bobf/if_conf_c=>sc_state_current
              iv_state_dest   = /bobf/if_conf_c=>sc_state_last_determined ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      " copy to image 3
      TRY.
          mo_buffer->transfer_state(
            EXPORTING
              it_node         = lt_tmp_node
              iv_incl_subtree = abap_false
              iv_state_source = /bobf/if_conf_c=>sc_state_current
              iv_state_dest   = /bobf/if_conf_c=>sc_state_last_validated ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

    IF lo_int_access IS BOUND.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.
    ENDIF.

    IF et_failed_key IS NOT INITIAL.
      SORT et_failed_key.
      DELETE ADJACENT DUPLICATES FROM et_failed_key.
    ENDIF.

  ENDMETHOD.


  METHOD do_detval.

    DATA: lo_change      TYPE REF TO /bobf/cl_frw_change,
          lt_group_2_way TYPE /bobf/t_frw_group,
          lt_group_3_way TYPE /bobf/t_frw_group,
          lt_failed_val  TYPE /bobf/t_frw_validations,
          lt_validations TYPE /bobf/t_frw_key,
          lo_message     TYPE REF TO /bobf/if_frw_message.


    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    ASSERT ID /bobf/frw CONDITION io_change  IS BOUND.
    CLEAR eo_message.

    lo_change ?= io_change.

    DO.
      ASSERT ID /bobf/frw_error CONDITION sy-index < 4.
*  ____________________________________________________________________ *
*    perform determinations  (after data change)
*    compare: current state - last determined state
      io_change->merge( mo_change_fail_det ).
      CLEAR mo_change_fail_det.
      do_determinations(
        EXPORTING
          iv_exectime      = /bobf/if_conf_c=>sc_time_after_modify
          io_change        = io_change
        IMPORTING
          eo_message       = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*  ____________________________________________________________________ *
*    new consistency calculation
      get_relevant_groups(
        EXPORTING
          iv_processing_mode = /bobf/if_frw_c=>sc_mode_modify
          iv_state_before    = /bobf/if_conf_c=>sc_state_last_validated
          io_change          = io_change
        IMPORTING
          et_group_2_way     = lt_group_2_way
          et_group_3_way     = lt_group_3_way
          et_validations     = lt_validations
          eo_message         = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lt_group_2_way IS NOT INITIAL.
        add_trigger_condition( it_group   = lt_group_2_way
                               io_change  = io_change ).
      ENDIF.

*  ____________________________________________________________________ *
*    perform consistency validations
      io_change->merge( mo_change_fail_val ).
      CLEAR mo_change_fail_val.
      do_validate(
        EXPORTING
          io_change                  = io_change
          it_validation              = lt_validations
          iv_only_given_validations  = abap_false
          iv_perform_check_delta     = abap_true
          iv_validation_time_context = iv_validation_time_context
        IMPORTING
          eo_message                 = lo_message
          et_failed_val              = lt_failed_val ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*  ____________________________________________________________________ *
*    new consistency calculation
      derive_consistency_status(
        EXPORTING
          it_failed_val = lt_failed_val
        IMPORTING
          eo_message    = lo_message
        CHANGING
          ct_group      = lt_group_2_way ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      INSERT LINES OF lt_group_3_way INTO TABLE lt_group_2_way.
      filter_consistency_groups(
        CHANGING
          ct_group = lt_group_2_way ).

      set_consistency_status(
        EXPORTING
          it_group   = lt_group_2_way
          io_change  = io_change
       IMPORTING
         eo_message = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*  ____________________________________________________________________ *
*      perform determinations (after validation).
*      compare: current state - last validated state
*      create : last validated state
      lo_change->set_processed( iv_det_processed = abap_true ).

      do_determinations(
        EXPORTING
          iv_exectime      = /bobf/if_conf_c=>sc_time_after_validation
          io_change        = io_change
        IMPORTING
          eo_message       = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      lo_change->set_processed( iv_val_processed = abap_true ).

*    loop again?
      IF lo_change->has_unprocessed_changes( iv_det_processed = abap_false ) = abap_false.
        EXIT.
      ENDIF.

    ENDDO.

  ENDMETHOD.


  METHOD do_det_fill_change_fail.

    "this methods fills mo_change_fail_val/mo_change_fail_det from io_change,
    "by taking the IT_FAILED_ROOT_KEYS into consideration

    DATA lt_change              TYPE /bobf/t_frw_change.
    DATA lo_message             TYPE REF TO /bobf/if_frw_message.
    DATA lt_key_change          TYPE /bobf/t_frw_key.
    DATA lx_root                TYPE REF TO cx_root.
    DATA lt_key_link            TYPE /bobf/t_frw_key_link.
    DATA lt_key_link_db         TYPE /bobf/t_frw_key_link.
    DATA lt_failed_in_current   TYPE /bobf/t_frw_key.
    DATA lo_delegation          TYPE REF TO /bobf/if_frw_delegation.
    DATA lo_change_fail         TYPE REF TO /bobf/if_frw_change.
    DATA lt_change_fail         TYPE /bobf/t_frw_change.
    DATA lv_from_index          TYPE i.
    DATA ls_key_change          TYPE /bobf/s_frw_key.
    DATA ls_node_meta           TYPE /bobf/s_confro_node.


    FIELD-SYMBOLS <ls_change>            TYPE /bobf/s_frw_change.
    FIELD-SYMBOLS <ls_change_node_key>   TYPE /bobf/s_frw_change.
    FIELD-SYMBOLS <ls_key_link>          TYPE /bobf/s_frw_key_link.


    IF NOT io_change IS BOUND OR
      ( iv_exectime <> /bobf/if_conf_c=>sc_time_after_validation AND
        iv_exectime <> /bobf/if_conf_c=>sc_time_after_modify ).
      RETURN.
    ENDIF.

    lo_change_fail = /bobf/cl_frw_factory=>get_change( ).
    CAST /bobf/cl_frw_change( lo_change_fail )->trace_external_changes( abap_false ).

    "get the destination change object for the change notifications
    IF iv_exectime = /bobf/if_conf_c=>sc_time_after_validation.
      mo_change_fail_val ?= lo_change_fail.
    ELSEIF iv_exectime = /bobf/if_conf_c=>sc_time_after_modify.
      mo_change_fail_det ?= lo_change_fail.
    ENDIF.

    IF it_failed_root_key IS INITIAL.
      RETURN.
    ENDIF.

    io_change->get(
      EXPORTING
        iv_sorted = /bobf/if_frw_c=>sc_change_sort_node_key
      IMPORTING
        et_change = lt_change
     ).

    LOOP AT lt_change ASSIGNING <ls_change>.

      AT NEW node_key.
        lv_from_index = sy-tabix.

        mo_conf->get_node(
          EXPORTING
            iv_node_key = <ls_change>-node_key
          IMPORTING
            es_node = ls_node_meta ).

        CLEAR lt_key_change.
        CLEAR lt_failed_in_current.
        CLEAR lt_key_link.
        CLEAR lt_key_link_db.
      ENDAT.

      "collect all keys of one node
      ls_key_change-key = <ls_change>-key.
      INSERT ls_key_change INTO TABLE lt_key_change.

      AT END OF node_key.

        "get root keys either from buffer or from delegation
        IF ls_node_meta-delegation_class IS INITIAL.
          "common node: get root keys from buffer
          TRY.
              "- try current state
              mo_buffer->get_root_key(
                EXPORTING
                  iv_node_key   = ls_node_meta-node_key
                  it_key        = lt_key_change
                  iv_state      = iv_current_state
                  io_change     = io_change
                IMPORTING
                  et_failed_key = lt_failed_in_current
                  et_key_link   = lt_key_link
              ).

              "- deleted instances: try database state
              IF NOT lt_failed_in_current IS INITIAL.

                mo_buffer->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node_meta-node_key
                    it_key        = lt_failed_in_current
                    iv_state      = /bobf/if_conf_c=>sc_state_database
                    io_change     = io_change
                  IMPORTING
                    et_key_link   = lt_key_link_db
                ).
                INSERT LINES OF lt_key_link_db INTO TABLE lt_key_link.
              ENDIF.

            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          "execute after loadings for newly loaded data
          after_loading(
            EXPORTING
              io_change     = io_change
              iv_load_state = iv_current_state
            IMPORTING
              eo_message    = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = co_message ).
        ELSE.

          "delegation scenario
          lo_delegation = get_delegation( iv_node_key = ls_node_meta-node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
          TRY.
              "- try current state
              lo_delegation->get_root_key(
                EXPORTING
                  iv_node_key   = ls_node_meta-node_key
                  it_key        = lt_key_change
                  iv_state      = iv_current_state
                  io_read       = mo_delegation_read
                IMPORTING
                  et_failed_key = lt_failed_in_current
                  et_key_link   = lt_key_link
               ).

              "- deleted instances: try database state
              IF NOT lt_failed_in_current IS INITIAL.
                lo_delegation->get_root_key(
                  EXPORTING
                    iv_node_key   = ls_node_meta-node_key
                    it_key        = lt_failed_in_current
                    iv_state      = /bobf/if_conf_c=>sc_state_database
                    io_read       = mo_delegation_read
                  IMPORTING
                    et_key_link   = lt_key_link_db
                 ).
                INSERT LINES OF lt_key_link_db INTO TABLE lt_key_link.
              ENDIF.

            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        ENDIF.

        "collect all changes belonging to a failed root key
        LOOP AT lt_change ASSIGNING <ls_change_node_key> FROM lv_from_index.

          "exit condition: next node reached
          IF <ls_change_node_key>-node_key <> ls_node_meta-node_key.
            EXIT.
          ENDIF.

          READ TABLE lt_key_link WITH KEY source_key = <ls_change_node_key>-key ASSIGNING <ls_key_link>.
          IF sy-subrc = 0.
            READ TABLE it_failed_root_key WITH TABLE KEY key_sort COMPONENTS key = <ls_key_link>-target_key
                TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              INSERT <ls_change_node_key> INTO TABLE lt_change_fail.
            ENDIF.
          ENDIF.

        ENDLOOP.

      ENDAT."node key
    ENDLOOP.

    "notify failed changes
    IF NOT lt_change_fail IS INITIAL.
      lo_change_fail->add(
        EXPORTING
          it_change          = lt_change_fail
      ).
    ENDIF.

  ENDMETHOD.


  METHOD do_loading .

*  IV_RELOAD = abap_true  -> load even if objects are in the buffer
*  IV_RELOAD = abap_false -> load only if objects that are not in buffer

    DATA: ls_node        TYPE /bobf/s_frw_node,
          lt_load        TYPE /bobf/t_frw_node,
          ls_load_do     TYPE ts_load_do,
          lt_load_do     TYPE tt_load_do,
          lt_loadable    TYPE /bobf/t_frw_node,
          lt_load_key    TYPE /bobf/t_frw_key,
          ls_node_link   TYPE /bobf/s_frw_node_key_link,
          lt_node_link   TYPE /bobf/t_frw_node_key_link,
          lt_failed_key  TYPE /bobf/t_frw_key,
          ls_failed_node TYPE /bobf/s_frw_node,
          lt_failed_node TYPE /bobf/t_frw_node,
          lt_key         TYPE /bobf/t_frw_key,
          ls_key         TYPE /bobf/s_frw_key,
          lt_tmp_node    TYPE /bobf/t_frw_node,
          lo_delegation  TYPE REF TO /bobf/if_frw_delegation,
          lo_change      TYPE REF TO /bobf/cl_frw_change,
          lo_message     TYPE REF TO /bobf/if_frw_message,
          lx_root        TYPE REF TO cx_root.

    FIELD-SYMBOLS: <ls_load_do>  TYPE ts_load_do.

    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           et_failed,
           et_loaded_node.

* Check if BO is loadable at all (not completely transient).
    CHECK mv_loadable = abap_true.


*  ____________________________________________________________________ *
*  check buffer first
    IF iv_check_buf = abap_true AND
        iv_reload   = abap_false.

      IF iv_node_key IS INITIAL.
        LOOP AT it_node INTO ls_node.
          ls_key-key = ls_node-key.
          APPEND ls_key TO lt_key.

          AT END OF node.
            IF mo_conf->ms_last_node-node_key <> ls_node-node.
              mo_conf->get_node( ls_node-node ).
            ENDIF.
            CHECK mo_conf->ms_last_node-transient = abap_false.

            TRY.
                mo_buffer->check_state_exists(
                EXPORTING
                  iv_node_key       = ls_node-node
                  it_key            = lt_key
                  iv_state          = /bobf/if_conf_c=>sc_state_current
                  iv_with_data      = iv_load_data
                IMPORTING
                  et_key_exists_not = lt_failed_key ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            ASSERT ID /bobf/frw CONDITION
                /bobf/cl_tool_assert=>is_key_subset(
                    it_key_set    = lt_key
                    it_key_subset = lt_failed_key ) = abap_true.

            IF lt_failed_key IS NOT INITIAL.
              TRY.
                  mo_buffer->check_state_exists(
                  EXPORTING
                    iv_node_key       = ls_node-node
                    it_key            = lt_failed_key
                    iv_state          = /bobf/if_conf_c=>sc_state_database
                    iv_with_data      = iv_load_data
                  IMPORTING
                    et_key_exists_not = lt_load_key ).
                CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.

              ASSERT ID /bobf/frw CONDITION
                  /bobf/cl_tool_assert=>is_key_subset(
                      it_key_set    = lt_failed_key
                      it_key_subset = lt_load_key ) = abap_true.

              IF lt_load_key IS NOT INITIAL.
                map_to_node(
                  EXPORTING
                    iv_node_key = ls_node-node
                    it_key      = lt_load_key
                  IMPORTING
                    et_node     = lt_tmp_node ).
                INSERT LINES OF lt_tmp_node INTO TABLE lt_load.
                CLEAR lt_load_key.
              ENDIF.
            ENDIF.
            CLEAR lt_key.
          ENDAT.
        ENDLOOP.

      ELSE.
*      call is only for one node (must not be a DO-node)
        IF mo_conf->ms_last_node-node_key <> iv_node_key.
          mo_conf->get_node( iv_node_key ).
        ENDIF.
        CHECK mo_conf->ms_last_node-transient = abap_false.

        TRY.
            mo_buffer->check_state_exists(
            EXPORTING
              iv_node_key       = iv_node_key
              it_key            = it_key
              iv_state          = /bobf/if_conf_c=>sc_state_current
              iv_with_data      = iv_load_data
            IMPORTING
              et_key_exists_not = lt_failed_key ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = it_key
                it_key_subset = lt_failed_key ) = abap_true.

        IF lt_failed_key IS NOT INITIAL.
          TRY.
              mo_buffer->check_state_exists(
              EXPORTING
                iv_node_key       = iv_node_key
                it_key            = lt_failed_key
                iv_state          = /bobf/if_conf_c=>sc_state_database
                iv_with_data      = iv_load_data
              IMPORTING
                et_key_exists_not = lt_load_key ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          ASSERT ID /bobf/frw CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_failed_key
                  it_key_subset = lt_load_key ) = abap_true.

          IF lt_load_key IS NOT INITIAL.
            map_to_node(
              EXPORTING
                iv_node_key = iv_node_key
                it_key      = lt_load_key
              IMPORTING
                et_node     = lt_tmp_node ).
            INSERT LINES OF lt_tmp_node INTO TABLE lt_load.
            CLEAR lt_load_key.
          ENDIF.
        ENDIF.
      ENDIF.

    ELSE.
      IF iv_node_key IS INITIAL.
        lt_load = it_node.
      ELSE.
        map_to_node(
          EXPORTING
            iv_node_key = iv_node_key
            it_key      = it_key
          IMPORTING
            et_node     = lt_load ).
      ENDIF.
    ENDIF.

    CHECK lt_load IS NOT INITIAL.

    IF io_change IS NOT BOUND.
      CREATE OBJECT lo_change TYPE /bobf/cl_frw_change.
    ELSE.
      lo_change ?= io_change.
    ENDIF.

*  ____________________________________________________________________ *
*  get loadable nodes (for data load)
    IF iv_load_data    = abap_false AND
       iv_reload       = abap_false AND
       iv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree.

*    check for delegated nodes
      IF iv_node_key IS NOT INITIAL.
        IF mo_conf->ms_last_node-node_key <> iv_node_key.
          mo_conf->get_node( iv_node_key ).
        ENDIF.
        IF mo_conf->ms_last_node-delegation_class IS INITIAL.
          lt_loadable = lt_load.
        ELSE.
          ls_load_do-delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
          ls_load_do-node                     = lt_load.
          INSERT ls_load_do INTO TABLE lt_load_do.
        ENDIF.
      ELSEIF iv_node_key_unique IS NOT INITIAL.
        IF mo_conf->ms_last_node-node_key <> iv_node_key_unique.
          mo_conf->get_node( iv_node_key_unique ).
        ENDIF.
        IF mo_conf->ms_last_node-delegation_class IS INITIAL.
          lt_loadable = lt_load.
        ELSE.
          ls_load_do-delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
          ls_load_do-node                     = lt_load.
          INSERT ls_load_do INTO TABLE lt_load_do.
        ENDIF.
      ELSE.
*      fallback (should not happen due to existing calls)
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK
        lt_loadable = lt_load.
      ENDIF.

    ELSE.
      get_loadable_node(
        EXPORTING
          it_node         = lt_load
          iv_load_subtree = iv_load_subtree
          io_change       = lo_change
        IMPORTING
          et_node         = lt_loadable
          et_node_link    = lt_node_link
          et_failed_node  = et_failed
          eo_message      = lo_message
        CHANGING
          ct_load_do      = lt_load_do ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_node_subset(
              it_node_set    = lt_load
              it_node_subset = et_failed ) = abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    IF iv_reload = abap_true.
      LOOP AT it_node_no_reload INTO ls_node.
        DELETE lt_loadable WHERE
           node = ls_node-node AND
           key  = ls_node-key.
      ENDLOOP.
    ENDIF.

*  ____________________________________________________________________ *
*  reload DO nodes
    IF lt_load_do IS NOT INITIAL AND
       iv_reload = abap_true.
      TRY.
          LOOP AT lt_load_do ASSIGNING <ls_load_do>.
            lo_delegation = get_delegation( <ls_load_do>-delegation_root_node_key ).
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_delegation->reload(
              it_node      = <ls_load_do>-node
              iv_edit_mode = iv_edit_mode
              io_change    = lo_change ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          ENDLOOP.
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

*  ____________________________________________________________________ *
*  load data into currect state (host nodes only)
    IF lt_loadable IS NOT INITIAL.
      TRY.
          mo_buffer->load(
            EXPORTING
              it_node           = lt_loadable
              iv_state          = /bobf/if_conf_c=>sc_state_current
              iv_reload         = iv_reload
              io_change         = lo_change
              iv_fill_data      = iv_load_data
              iv_notify_keyload = iv_notify_keyload
            IMPORTING
              et_failed_node    = lt_failed_node ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

    IF iv_load_data     = abap_true OR
        iv_load_subtree <> /bobf/if_frw_c=>sc_load_no_subtree.
      LOOP AT lt_failed_node INTO ls_node.
        LOOP AT lt_node_link INTO ls_node_link
          WHERE target_node = ls_node-node
            AND target_key  = ls_node-key.
          ls_failed_node-node = ls_node_link-source_node.
          ls_failed_node-key  = ls_node_link-source_key.
          INSERT ls_failed_node INTO TABLE et_failed.
        ENDLOOP.
      ENDLOOP.
    ELSE.
      INSERT LINES OF lt_failed_node INTO TABLE et_failed.
    ENDIF.

*  ____________________________________________________________________ *
*  do determination after loading on current state
    after_loading(
      EXPORTING
        io_change         = lo_change
        iv_within_loading = iv_within_loading
        iv_load_state     = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_loaded_node    = et_loaded_node
        eo_message        = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

  ENDMETHOD.


  METHOD do_lock_action.
    DATA: lo_int_access      TYPE REF TO /bobf/cl_frw_int_access,
          ls_act_class       TYPE        ty_action,
          lt_failed_key      TYPE        /bobf/t_frw_key,
          lo_message         TYPE REF TO /bobf/if_frw_message,
          lx_root            TYPE REF TO cx_root,
          lo_message_int     TYPE REF TO /bobf/cl_frw_message,
          ls_runtime_context TYPE /bobf/s_frw_runtime_context.

    BREAK-POINT ID /bobf/frw_lock.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

    CLEAR: eo_message,
           et_failed_key.

    lo_int_access = /bobf/cl_frw_int_access=>new_instance( io_bopf       = me
                                                           io_conf       = mo_conf
                                                           io_buffer     = mo_buffer
                                                           io_change     = io_change
                                                           iv_class_name = /bobf/cl_frw_int_access_lock=>gc_class_name ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

    lo_int_access->set_last_state(    /bobf/if_conf_c=>sc_state_current ).
    lo_int_access->set_current_state( /bobf/if_conf_c=>sc_state_current ).

*  get action class
    READ TABLE mt_action
       WITH TABLE KEY act_key = is_context-act_key
       INTO ls_act_class.
    IF sy-subrc <> 0.
      ls_act_class-act_key = is_context-act_key.
      TRY.
          CREATE OBJECT ls_act_class-class TYPE (iv_act_class).
        CATCH cx_sy_create_object_error INTO lx_root.
          set_configuration_error( NEW /bobf/cx_frw_core( previous        = lx_root
                                                          textid          = /bobf/cx_frw_core=>sc_no_instance
                                                          mv_classname    = iv_act_class
                                                          mv_content_cat  = CONV #( TEXT-000 )
                                                          mv_content_name = get_content_description( iv_act = abap_true
                                                                                                     iv_key = is_context-act_key ) ) ).
      ENDTRY.
      INSERT ls_act_class INTO TABLE mt_action.
    ENDIF.

    IF mo_conf->ms_last_action-act_key <> is_context-act_key.
      mo_conf->get_act( iv_act_key = is_context-act_key ).
    ENDIF.

    IF mo_conf->ms_last_action-chk_act_also_int = abap_true AND
       mo_conf->ms_last_action-act_cat          = /bobf/if_conf_c=>sc_action_lock.

      check_action( EXPORTING is_context          = is_context
                              is_parameters       = is_lock_param
                              iv_check_property   = abap_false
                              iv_check_validation = abap_true
                              io_change           = io_change
                    IMPORTING et_failed_key       = et_failed_key
                              eo_message          = eo_message
                    CHANGING  ct_key              = ct_key ).

    ELSEIF mo_conf->ms_last_action-prepare_impl = abap_true.
      TRY.
          lo_int_access->set_context( is_action        = is_context
                                      iv_read_allowed  = abap_true
                                      iv_check_allowed = abap_true
                                      it_mod           = ct_mod ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

          ls_act_class-class->prepare( EXPORTING is_ctx        = is_context
                                                 io_read       = lo_int_access
                                                 io_check      = lo_int_access
                                                 is_parameters = is_lock_param
                                       CHANGING  ct_key        = ct_key ).

          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          lo_int_access->invalidate( IMPORTING et_mod = ct_mod ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                              iv_content_cat   = /bobf/if_conf_c=>sc_content_act
                                                                              iv_content_key   = is_context-act_key
                                                                              iv_content_class = iv_act_class
                                                                              iv_node_key      = is_context-node_key
                                                                              io_configuration = mo_conf
                                                                              iv_method_name   = 'PREPARE' ) ).
      ENDTRY.
    ENDIF.

    IF ct_key IS INITIAL.
      ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
      DELETE mt_access_stack INDEX 1.
      RETURN.
    ENDIF.

    TRY.
        lo_int_access->set_context( is_action         = is_context
                                    iv_read_allowed   = abap_true
                                    iv_modify_allowed = abap_true
                                    it_mod            = ct_mod ).
        lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

        ls_act_class-class->execute( EXPORTING is_ctx        = is_context
                                               it_key        = ct_key
                                               io_read       = lo_int_access
                                               io_modify     = lo_int_access
                                               is_parameters = is_lock_param
                                     IMPORTING eo_message    = lo_message
                                               et_failed_key = lt_failed_key ).

        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = ct_key
                                                                                 it_key_subset = lt_failed_key ).

      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                            iv_content_cat   = /bobf/if_conf_c=>sc_content_act
                                                                            iv_content_key   = is_context-act_key
                                                                            iv_content_class = iv_act_class
                                                                            iv_node_key      = is_context-node_key
                                                                            io_configuration = mo_conf
                                                                            iv_method_name   = 'EXECUTE' ) ).
    ENDTRY.

    create_durable_msg_container( CHANGING co_message = lo_message ).
    IF lo_message IS BOUND.
      lo_message_int ?= lo_message.
      ls_runtime_context-bo_key   = mo_conf->ms_obj-bo_key.
      ls_runtime_context-node_key = is_context-node_key.
      ls_runtime_context-act_key  = is_context-act_key.
      lo_message_int->set_context( is_context = ls_runtime_context
                                   it_key     = filter_out_unnecessary_actkeys( is_context   = is_context
                                                                                it_all_keys  = ct_key ) ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    IF et_failed_key IS INITIAL.
      et_failed_key = lt_failed_key.
    ELSE.
      APPEND LINES OF lt_failed_key TO et_failed_key.
    ENDIF.

*  check for undone modifications and flush
    IF lo_int_access->mt_modification IS NOT INITIAL.
      lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
      lo_int_access->end_modify( ).
      /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
    ENDIF.
    collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                      CHANGING  co_message = eo_message ).

    lo_int_access->invalidate( IMPORTING et_mod = ct_mod ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

    IF  mo_conf->supports_feature( /bobf/if_conf_c=>sc_feature-draft_new_consistency )
    AND is_lock_param->et_key_locked_on_resume IS NOT INITIAL.

      mo_conf->get_group_tab( IMPORTING et_group = DATA(lt_group) ).
      DATA(lv_group_key) = lt_group[ group_cat  = /bobf/if_conf_c=>sc_group_cat_consistency
                                     group_name = /bobf/if_conf_c=>sc_group_name_draft_consist
                                     node_key   = is_context-node_key ]-group_key.
      set_consistency_status( EXPORTING it_group   = VALUE #( FOR key IN is_lock_param->et_key_locked_on_resume
                                                              ( group_key = lv_group_key
                                                                key       = key-key
                                                                status_value = /bobf/if_frw_c=>sc_status_pending ) )
                                        io_change  = io_change
                              IMPORTING eo_message = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
      CLEAR is_lock_param->et_key_locked_on_resume.
    ENDIF.

  ENDMETHOD.


  METHOD do_modify.

    DEFINE raise_int_contract_violation.
      ASSERT ID /bobf/frw CONDITION 1 = 0.
      mv_application_error = abap_true.
      MESSAGE e&1(/bobf/frw_contract) INTO sy-msgv1.
      lx_contract = /bobf/cl_frw_error_state=>create_caller_error_from_symsg( ).
      RAISE EXCEPTION lx_contract. " implicitly sets error state
    END-OF-DEFINITION.

    CONSTANTS: co_err_sam_create TYPE string VALUE 'creation', "#EC NOTEXT
               co_err_sam_update TYPE string VALUE 'update', "#EC NOTEXT
               co_err_sam_delete TYPE string VALUE 'deletion'. "#EC NOTEXT

    DATA: ls_node_c                   TYPE        /bobf/s_confro_node,
          lt_mod                      TYPE        /bobf/t_frw_modification,
          lt_mod_del                  TYPE        /bobf/t_frw_modification,
          lt_mod_tmp                  TYPE        /bobf/t_frw_modification,
          lt_mod_tmp_class            TYPE        /bobf/t_frw_modification,
          lt_mod_remove               TYPE        /bobf/t_frw_modification,
          ls_mod_int                  TYPE        /bobf/s_frw_modification,
          lt_mod_do                   TYPE        /bobf/t_frw_modification_do,
          ls_mod_do                   TYPE        /bobf/s_frw_modification_do,
          lt_node                     TYPE        /bobf/t_frw_node,
          ls_node                     TYPE        /bobf/s_frw_node,
          lt_create                   TYPE        /bobf/t_frw_node,
          lt_update                   TYPE        /bobf/t_frw_node,
          lt_node_restore             TYPE        /bobf/t_frw_node,
          lt_node_restore_del         TYPE        /bobf/t_frw_node,
          lt_root_node_restore        TYPE        /bobf/t_frw_node,
          lt_delete                   TYPE        /bobf/t_frw_node,
          lt_delete_dep               TYPE        /bobf/t_frw_node,
          lt_delete_dep_deleg         TYPE        /bobf/t_frw_node,
          lt_load                     TYPE        /bobf/t_frw_node,
          lt_load_only_keyload        TYPE        /bobf/t_frw_node,
          lt_lock                     TYPE        /bobf/t_frw_node,
          lt_lock_generic             TYPE        /bobf/t_frw_node,
          lt_lock_generic_for_delete  TYPE        /bobf/t_frw_node,
          lt_lock_created             TYPE        /bobf/t_frw_node,
          lt_node_category            TYPE        /bobf/t_frw_node,
          ls_lock_data                TYPE REF TO /bobf/s_frw_lock_node,
          lt_new_node                 TYPE        /bobf/t_frw_node,
          lt_delegated_node           TYPE        /bobf/t_frw_node,
          lv_delegation_root_node_key TYPE        /bobf/obm_node_key,
          lo_delegation               TYPE REF TO /bobf/if_frw_delegation,
          lt_update_data              TYPE        /bobf/t_frw_node_data,
          lt_update_data_status       TYPE        /bobf/t_frw_node_data,
          lt_update_data_all          TYPE        /bobf/t_frw_node_data,
          ls_update_data              TYPE        /bobf/s_frw_node_data,
          ls_update_data_status       TYPE        /bobf/s_frw_node_data,
          lt_changed                  TYPE        /bobf/t_frw_node_data,
          lt_unchanged                TYPE        /bobf/t_frw_node_data,
          lt_failed                   TYPE        /bobf/t_frw_node,
          lt_failed_key               TYPE        /bobf/t_frw_key,
          lt_root_key                 TYPE        /bobf/t_frw_key,
          lt_root_key2                TYPE        /bobf/t_frw_key,
          lt_key                      TYPE        /bobf/t_frw_key,
          ls_key                      TYPE        /bobf/s_frw_key,
          lo_message                  TYPE REF TO /bobf/if_frw_message,
          lm_message_esi              TYPE REF TO /bobf/cm_frw_common_esi,
          ls_assoc_status             TYPE        /bobf/s_confro_assoc,
          ls_assoc                    TYPE        /bobf/s_confro_assoc,
          ls_node_conf                TYPE        /bobf/s_confro_node,
          lo_int_access               TYPE REF TO /bobf/cl_frw_int_access,
          lo_int_access_read          TYPE REF TO /bobf/cl_frw_int_access,
          lt_node_state_create        TYPE        /bobf/t_frw_node,
          lt_node_status_create       TYPE        /bobf/t_frw_node,
          lt_node_status_delete       TYPE        /bobf/t_frw_node,
          lv_only_transient           TYPE        boole_d,
          lx_root                     TYPE REF TO cx_root,
          lx_frw                      TYPE REF TO /bobf/cx_frw_core,
          ls_origin_location          TYPE        /bobf/s_frw_location,
          lv_content_cat              TYPE        string,
          lv_changed_field            TYPE        string,
          lv_implemented_create       TYPE        boole_d,
          lv_delete_status            TYPE        boole_d,
          lv_status_variable          TYPE        boole_d,
          lv_check_validation         TYPE        boole_d,
          ls_obj                      TYPE        /bobf/s_confro_obj,
          lt_failed_change            TYPE        /bobf/t_frw_change,
          ls_change                   TYPE        /bobf/s_frw_change,
          lo_change                   TYPE REF TO /bobf/if_frw_change,
          lv_index                    TYPE        sy-index,
          lv_before_modif_set         TYPE        boole_d,
          lv_state_prop_notif         TYPE        /bobf/conf_state,
          lt_messages                 TYPE        /bobf/t_frw_message_k,
          ls_message                  TYPE        /bobf/s_frw_message_k,
          lt_node_needs_read_cache    TYPE        HASHED TABLE OF /bobf/s_frw_key WITH UNIQUE KEY table_line,
          lv_app_info                 TYPE        string,
          lt_node_w_children_for_msg  TYPE        /bobf/t_frw_node,
          lt_node_wo_children_for_msg TYPE        /bobf/t_frw_node,
          lx_contract                 TYPE REF TO /bobf/cx_frw_int_cntrct_violtn,
          lv_message                  TYPE        string.

    FIELD-SYMBOLS: <ls_mod_do>   TYPE /bobf/s_frw_modification_do,
                   <ls_mod>      TYPE /bobf/s_frw_modification,
                   <ls_mod_next> TYPE /bobf/s_frw_modification.


    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR eo_message.

    eo_change = /bobf/cl_frw_factory=>get_change( ).

    lt_mod = it_modification.

    IF iv_within_loading   = abap_true OR
        iv_within_retrieve = abap_true.
      lv_only_transient = abap_true.
    ELSEIF iv_act_key IS NOT INITIAL.
      IF mo_conf->ms_last_action-act_key <> iv_act_key.
        mo_conf->get_act( iv_act_key = iv_act_key ).
      ENDIF.
      IF mo_conf->ms_last_action-act_cat = /bobf/if_conf_c=>sc_action_lock OR
         mo_conf->ms_last_action-act_cat = /bobf/if_conf_c=>sc_action_unlock.
        lv_only_transient = abap_true.
      ENDIF.
    ENDIF.

    "nodes being modified require read caching
    lt_node_needs_read_cache = CORRESPONDING #( lt_mod DISCARDING DUPLICATES MAPPING key = node ).

* ____________________________________________________________________ *
* analyse modification request
    LOOP AT lt_mod ASSIGNING <ls_mod>.
      IF <ls_mod>-data IS BOUND.
        ASSIGN <ls_mod>-data->* TO FIELD-SYMBOL(<ls_data>).
        DESCRIBE FIELD <ls_data> TYPE DATA(lv_type).
        IF lv_type <> cl_abap_typedescr=>typekind_struct1 AND  " flat structure
           lv_type <> cl_abap_typedescr=>typekind_struct2.     " deep structure
          raise_int_contract_violation 027.
        ENDIF.
      ENDIF.

      IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_create.
        IF <ls_mod>-association IS NOT INITIAL AND <ls_mod>-association <> ls_assoc-assoc_key.
          mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_mod>-association
                              IMPORTING es_assoc     = ls_assoc ).
          IF ls_assoc-assoc_class IS NOT INITIAL.
            lv_implemented_create = abap_true.
          ENDIF.
        ENDIF.

        "check consistency:
        IF <ls_mod>-node = mo_conf->ms_obj-root_node_key.
          "ROOT instances usually cannot be created by an association - except for implemented associations
          IF <ls_mod>-association IS INITIAL OR ls_assoc-assoc_class IS INITIAL. "not an implemented association
            IF <ls_mod>-source_key  IS NOT INITIAL
            OR <ls_mod>-source_node IS NOT INITIAL
            OR <ls_mod>-association IS NOT INITIAL.
              " Source information provided for the creation of the ROOT-node
              raise_int_contract_violation 020.
            ENDIF.
          ENDIF.
        ELSE.
          IF <ls_mod>-association IS INITIAL
          OR <ls_mod>-source_node IS INITIAL
          OR <ls_mod>-source_key  IS INITIAL.
            " Source information missing for the creation of a ROOT-subnode
            raise_int_contract_violation 021.
          ENDIF.
        ENDIF.
      ENDIF.

*   get node configuration
      ASSERT ID /bobf/frw CONDITION <ls_mod>-node IS NOT INITIAL.
      IF mo_conf->ms_last_node-node_key = <ls_mod>-node.
        ls_node_c = mo_conf->ms_last_node.
      ELSE.
        mo_conf->get_node(
           EXPORTING iv_node_key = <ls_mod>-node
           IMPORTING es_node     = ls_node_c ).
        IF ls_node_c IS INITIAL.
*       unknown node
          ASSERT ID /bobf/frw CONDITION 0 = 1.             "#EC BOOL_OK
          set_application_error( ).
        ENDIF.
      ENDIF.

*   check for framework nodes
      IF  iv_internal_modify  =  abap_false
      AND ls_node_c-node_type <> /bobf/if_conf_c=>sc_node_type_normal.
        " no external change on framework nodes allowed!
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK
        set_application_error( ).
      ENDIF.

*   check for delegated modifications
      IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_create AND
         <ls_mod>-association IS NOT INITIAL AND
         <ls_mod>-association <> iv_assoc_key.
        IF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source AND
           ls_assoc-source_node->delegation_class IS NOT INITIAL OR
           ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target AND
           ls_assoc-target_node->delegation_class IS NOT INITIAL.
*       delegated modification (create)
          IF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.
            lv_delegation_root_node_key = ls_assoc-source_node->delegation_root_node_key.
          ELSE.
            lv_delegation_root_node_key = ls_assoc-target_node->delegation_root_node_key.
          ENDIF.
          READ TABLE lt_mod_do
            WITH KEY delegation_root_node_key = lv_delegation_root_node_key
            ASSIGNING <ls_mod_do>.
          IF sy-subrc <> 0.
            ls_mod_do-delegation_root_node_key = lv_delegation_root_node_key.
            INSERT ls_mod_do INTO TABLE lt_mod_do ASSIGNING <ls_mod_do>.
          ENDIF.
          APPEND <ls_mod> TO <ls_mod_do>-modification.

*       locking
          READ TABLE lt_new_node WITH KEY
              node = <ls_mod>-source_node
              key  = <ls_mod>-source_key
              TRANSPORTING NO FIELDS.
          IF sy-subrc <> 0.
            ls_node-node = <ls_mod>-source_node.
            ls_node-key  = <ls_mod>-source_key.
            INSERT ls_node INTO TABLE lt_lock.
          ENDIF.
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_new_node.

          DELETE lt_mod.
          CONTINUE.
        ENDIF.

      ELSE.
        IF ls_node_c-delegation_class IS NOT INITIAL.
*       delegated modification (update/delete)
          READ TABLE lt_mod_do
            WITH KEY delegation_root_node_key = ls_node_c-delegation_root_node_key
            ASSIGNING <ls_mod_do>.
          IF sy-subrc <> 0.
            ls_mod_do-delegation_root_node_key = ls_node_c-delegation_root_node_key.
            INSERT ls_mod_do INTO TABLE lt_mod_do ASSIGNING <ls_mod_do>.
          ENDIF.
          APPEND <ls_mod> TO <ls_mod_do>-modification.

*       locking
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_lock.

          DELETE lt_mod.
          CONTINUE.
        ENDIF.
      ENDIF.

      IF <ls_mod>-node_cat IS INITIAL.
        <ls_mod>-node_cat = ls_node_c-node_cat_key.
      ENDIF.

      CASE <ls_mod>-change_mode.
*     create
        WHEN: /bobf/if_frw_c=>sc_modify_create.
*       set framework guid
          IF <ls_mod>-key IS INITIAL.
            <ls_mod>-key = /bobf/cl_frw_factory=>get_new_key( ).
          ENDIF.
          IF ls_node_c-delegation_class IS INITIAL.
            ls_node-node = <ls_mod>-node.
            ls_node-key  = <ls_mod>-key.
            INSERT ls_node INTO TABLE lt_create.
            IF  <ls_mod>-node_cat IS INITIAL
            AND ls_node_c-node_type = /bobf/if_conf_c=>sc_node_type_normal
            AND ( <ls_mod>-association IS INITIAL  OR  ls_assoc-assoc_class IS INITIAL ).
              INSERT ls_node INTO TABLE lt_node_category.
            ENDIF.
          ENDIF.
*       check if node has to be loaded in advance
          IF  <ls_mod>-source_node IS NOT INITIAL
          AND ls_assoc-source_node->transient = abap_false
          AND NOT line_exists( lt_new_node[ node = <ls_mod>-source_node key  = <ls_mod>-source_key ] ).
*           source is not created with same modify call

            IF ls_assoc-assoc_class IS INITIAL  OR  ls_assoc-assoc_key = iv_assoc_key."delayed locking for implemented associations during do_modify call of implemented create method (else node instance hierarchy cannot be determined)
              ls_node-node = <ls_mod>-source_node.
              ls_node-key  = <ls_mod>-source_key.
              INSERT ls_node INTO TABLE lt_load_only_keyload.
              IF ls_node_c-transient = abap_false
              AND mo_conf->ms_obj-no_lock = abap_false.
                IF ls_node_c-lockable = abap_false.
                  ls_node-node = <ls_mod>-source_node.
                  ls_node-key  = <ls_mod>-source_key.
                  INSERT ls_node INTO TABLE lt_lock.
                ELSE.
                  ls_node-node = <ls_mod>-node.
                  ls_node-key  = <ls_mod>-key.
                  INSERT ls_node INTO TABLE lt_lock_generic.
                ENDIF.
              ENDIF.
            ENDIF.
          ELSEIF mo_conf->ms_obj-no_lock = abap_false  AND  ls_node_c-lockable = abap_true.
            ls_node-node = <ls_mod>-node.
            ls_node-key  = <ls_mod>-key.
            INSERT ls_node INTO TABLE lt_lock_created. "newly created instances may not need a real lock (see below)
          ENDIF.
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_new_node.

*     update
        WHEN: /bobf/if_frw_c=>sc_modify_update.
          IF <ls_mod>-data IS NOT BOUND.
            raise_int_contract_violation 025.
          ENDIF.
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
*       check if node has to be loaded in advance
          IF ls_node_c-transient = abap_false.
            IF iv_internal_modify  = abap_true.
              READ TABLE lt_create TRANSPORTING NO FIELDS
                WITH KEY node = <ls_mod>-node
                         key  = <ls_mod>-key.
              IF sy-subrc <> 0.
                INSERT ls_node INTO TABLE lt_load.
                IF mo_conf->ms_obj-no_lock = abap_false.
                  INSERT ls_node INTO TABLE lt_lock.
                ENDIF.
              ENDIF.
            ELSE.
              INSERT ls_node INTO TABLE lt_load.
              IF mo_conf->ms_obj-no_lock = abap_false.
                INSERT ls_node INTO TABLE lt_lock.
              ENDIF.
            ENDIF.
          ENDIF.

          ls_update_data-node           = <ls_mod>-node.
          ls_update_data-key            = <ls_mod>-key.
          ls_update_data-changed_fields = <ls_mod>-changed_fields.
          ls_update_data-data           = <ls_mod>-data.
          INSERT ls_update_data INTO TABLE lt_update_data_all.

          INSERT ls_node INTO TABLE lt_update.

          IF ( ls_node_c-status_attributes    IS NOT BOUND OR
               ls_node_c-status_attributes->* IS INITIAL ) OR
             ( iv_act_key                     IS INITIAL   AND
               iv_det_key                     IS INITIAL ) OR
               iv_within_loading = abap_true.
*         no status update
            INSERT ls_update_data INTO TABLE lt_update_data.

          ELSEIF ls_node_c-field_names IS NOT BOUND  OR
                 ls_node_c-field_names->* IS INITIAL.
*         update on status node
            INSERT <ls_mod>       INTO TABLE lt_mod_remove.
            INSERT ls_update_data INTO TABLE lt_update_data_status.

          ELSE.
*        possibly mixed status/non-status update
            IF <ls_mod>-changed_fields IS NOT INITIAL.
              LOOP AT <ls_mod>-changed_fields INTO lv_changed_field.
                READ TABLE ls_node_c-status_attributes->* TRANSPORTING NO FIELDS
                  WITH KEY table_line = lv_changed_field.
                IF sy-subrc = 0.
                  IF ls_update_data_status IS INITIAL.
                    ls_update_data_status-node = <ls_mod>-node.
                    ls_update_data_status-key  = <ls_mod>-key.
                    ls_update_data_status-data = <ls_mod>-data.
                  ENDIF.
                  APPEND lv_changed_field TO ls_update_data_status-changed_fields.
                  DELETE <ls_mod>-changed_fields.
                ENDIF.
              ENDLOOP.
              IF ls_update_data_status IS NOT INITIAL.
                INSERT ls_update_data_status INTO TABLE lt_update_data_status.
                CLEAR ls_update_data_status.
              ENDIF.
              IF <ls_mod>-changed_fields IS INITIAL.
                INSERT <ls_mod> INTO TABLE lt_mod_remove.
              ELSE.
                ls_update_data-changed_fields = <ls_mod>-changed_fields.
                INSERT ls_update_data INTO TABLE lt_update_data.
              ENDIF.
            ELSE.
              <ls_mod>-changed_fields       = ls_node_c-field_names->*.
              ls_update_data-changed_fields = ls_node_c-field_names->*.
              INSERT ls_update_data INTO TABLE lt_update_data.
*           When called without changed fields no status field is allowed
*           to be changed by S&AM contract
*           ls_update_data-changed_fields = ls_node_c-sta_field_names->*.
*            CLEAR ls_update_data-changed_fields.
*            INSERT ls_update_data INTO TABLE lt_update_data_status.
            ENDIF.
          ENDIF.

*     delete
        WHEN: /bobf/if_frw_c=>sc_modify_delete.
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_delete.
          IF ls_node_c-node_type <> /bobf/if_conf_c=>sc_node_type_status AND
             ls_node_c-node_type <> /bobf/if_conf_c=>sc_node_type_qrtn   AND
             ls_node_c-transient = abap_false.
            INSERT ls_node INTO TABLE lt_load.
            IF mo_conf->ms_obj-no_lock = abap_false.
              INSERT ls_node INTO TABLE lt_lock_generic.
              INSERT ls_node INTO TABLE lt_lock_generic_for_delete.
            ENDIF.
          ENDIF.
      ENDCASE.
    ENDLOOP.

    "nodes being modified require read caching
    notify_nodes_read_cache_enable( it_node_key = CORRESPONDING #( lt_node_needs_read_cache ) ).

    lt_node_state_create = lt_create.
    INSERT LINES OF lt_update INTO TABLE lt_node_state_create.
    INSERT LINES OF lt_delete INTO TABLE lt_node_state_create.

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>mod_tables_consistent(
        io_conf   = mo_conf
        it_mod    = lt_mod
        it_create = lt_create
        it_update = lt_update
        it_delete = lt_delete ) = abap_true.

* ____________________________________________________________________ *
* do lockings

    " Ideally, we only _pretend_ to lock new ROOT instances by modifying the lock
    " buffer (see usage of LT_LOCK_CREATED below).
    " However, when locks shall be kept after SAVE, we need to acquire locks
    " even for newly created instances.
    " In case of exclusive dialog locks we should acquire the locks immediately in
    " order to prevent anyone from stealing them shortly before we can acquire them
    " after save.
    " In case of OPTDIAUPD the re-acquire logic during AFTER_SUCCESSFUL_SAVE
    " expects to loose locks anyway, so it is safe to defer the actual locking
    " to this time.
    IF  mv_cleanup_mode  =  /bobf/if_conf_c=>sc_cleanup_keep_lock
    AND mv_enqueue_scope <> /bobf/if_conf_c=>sc_enqueue_scope_optdiaupd.
      INSERT LINES OF lt_lock_created INTO TABLE lt_lock_generic.
      CLEAR lt_lock_created.
    ENDIF.
    DELETE ADJACENT DUPLICATES FROM: lt_lock, lt_lock_generic.

    lock( "generically
      EXPORTING
        it_lock              = lt_lock_generic    " Node Table
        iv_generic           = abap_true
        iv_within_loading    = iv_within_loading
        iv_edit_mode         = iv_edit_mode" Change Mode
        io_change            = eo_change   " Interface of Change Object
        it_locked_for_delete = lt_lock_generic_for_delete
      CHANGING
        co_message        = eo_message  " Interface of Message Object
        ct_mod            = lt_mod      " Changes
        ct_failed_lock    = lt_failed   " Key Table
    ).

    lock( "non-generically
      EXPORTING
        it_lock           = lt_lock     " Node Table
        iv_generic        = abap_false
        iv_within_loading = iv_within_loading
        iv_edit_mode      = iv_edit_mode" Change Mode
        io_change         = eo_change   " Interface of Change Object
      CHANGING
        co_message        = eo_message  " Interface of Message Object
        ct_mod            = lt_mod
        ct_failed_lock    = lt_failed   " Key Table
    ).

    IF lt_failed IS NOT INITIAL.
*   error: not all nodes locked
      ASSERT ID /bobf/frw CONDITION lt_failed IS NOT INITIAL.
      cleanup_modifications(
        EXPORTING
          it_failed_node       = lt_failed
          io_change            = eo_change
        CHANGING
          ct_mod               = lt_mod
          ct_mod_do            = lt_mod_do
          ct_load              = lt_load
          ct_load_only_keyload = lt_load_only_keyload
          ct_lock_created      = lt_lock_created
          ct_create            = lt_create
          ct_update            = lt_update
          ct_delete            = lt_delete
          ct_update_data       = lt_update_data
          ct_update_data_all   = lt_update_data_all
          ct_update_data_sta   = lt_update_data_status
          ct_node_state_create = lt_node_state_create
          ct_node_category     = lt_node_category ).
    ENDIF.

* ____________________________________________________________________ *
* load required node instance into the buffer
    IF lt_load IS NOT INITIAL.
      DELETE ADJACENT DUPLICATES FROM lt_load.
      do_loading(
        EXPORTING
          it_node           = lt_load
          iv_check_buf      = abap_true
          iv_reload         = abap_false
          iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
          iv_within_loading = iv_within_loading
          iv_load_data      = abap_true
          io_change         = eo_change
        IMPORTING
          et_failed         = lt_failed
          eo_message        = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_node_subset(
              it_node_set    = lt_load
              it_node_subset = lt_failed ) = abap_true.

      IF lt_failed IS NOT INITIAL.
*     error: not all nodes were loaded
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK

        IF iv_internal_modify = abap_false.
*       create esi common messages
          LOOP AT lt_failed INTO ls_node.

*         check for creates
            READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY source
              COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                         source_node = ls_node-node
                         source_key  = ls_node-key.
            IF sy-subrc = 0.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              ls_origin_location-node_key = ls_node-node.
              ls_origin_location-key      = ls_node-key.
              CREATE OBJECT lm_message_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_create_src
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                  severity           = /bobf/cm_frw=>co_severity_error
                  ms_origin_location = ls_origin_location.
              eo_message->add_cm( lm_message_esi ).
            ENDIF.

*        check for updates
            READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY change
              COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_update
                         node        = ls_node-node
                         key         = ls_node-key.
            IF sy-subrc = 0.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              ls_origin_location-node_key = ls_node-node.
              ls_origin_location-key      = ls_node-key.
              CREATE OBJECT lm_message_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_update
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                  severity           = /bobf/cm_frw=>co_severity_error
                  ms_origin_location = ls_origin_location.
              eo_message->add_cm( lm_message_esi ).
            ENDIF.

*         check for deletes
            READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY change
              COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_delete
                         node        = ls_node-node
                         key         = ls_node-key.
            IF sy-subrc = 0.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              ls_origin_location-node_key = ls_node-node.
              ls_origin_location-key      = ls_node-key.
              CREATE OBJECT lm_message_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_delete
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                  severity           = /bobf/cm_frw=>co_severity_error
                  ms_origin_location = ls_origin_location.
              eo_message->add_cm( lm_message_esi ).
            ENDIF.
          ENDLOOP.
        ENDIF.

*     clear modification table
        cleanup_modifications(
          EXPORTING
            it_failed_node       = lt_failed
            io_change            = eo_change
          CHANGING
            ct_mod               = lt_mod
            ct_mod_do            = lt_mod_do
            ct_load_only_keyload = lt_load_only_keyload
            ct_lock_created      = lt_lock_created
            ct_create            = lt_create
            ct_update            = lt_update
            ct_delete            = lt_delete
            ct_update_data       = lt_update_data
            ct_update_data_all   = lt_update_data_all
            ct_update_data_sta   = lt_update_data_status
            ct_node_state_create = lt_node_state_create
            ct_node_category     = lt_node_category ).
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* load required node instance into the buffer
    IF lt_load_only_keyload IS NOT INITIAL.
      DELETE ADJACENT DUPLICATES FROM lt_load_only_keyload.
      do_loading(
        EXPORTING
          it_node           = lt_load_only_keyload
          iv_check_buf      = abap_true
          iv_reload         = abap_false
          iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
          iv_within_loading = iv_within_loading
          iv_load_data      = abap_false
          io_change         = eo_change
        IMPORTING
          et_failed         = lt_failed
          eo_message        = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_node_subset(
              it_node_set    = lt_load_only_keyload
              it_node_subset = lt_failed ) = abap_true.

      IF lt_failed IS NOT INITIAL.
*     error: not all nodes were loaded
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK

        IF iv_internal_modify = abap_false.
*       create esi common messages
          LOOP AT lt_failed INTO ls_node.

*         check for creates
            READ TABLE lt_mod TRANSPORTING NO FIELDS WITH KEY source
              COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                         source_node = ls_node-node
                         source_key  = ls_node-key.
            IF sy-subrc = 0.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.
              ls_origin_location-node_key = ls_node-node.
              ls_origin_location-key      = ls_node-key.
              CREATE OBJECT lm_message_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_fn_modify_create_src
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                  severity           = /bobf/cm_frw=>co_severity_error
                  ms_origin_location = ls_origin_location.
              eo_message->add_cm( lm_message_esi ).
            ENDIF.
          ENDLOOP.
        ENDIF.

*     clear modification table
        cleanup_modifications(
          EXPORTING
            it_failed_node       = lt_failed
            io_change            = eo_change
          CHANGING
            ct_mod               = lt_mod
            ct_mod_do            = lt_mod_do
            ct_lock_created      = lt_lock_created
            ct_create            = lt_create
            ct_update            = lt_update
            ct_delete            = lt_delete
            ct_update_data       = lt_update_data
            ct_update_data_all   = lt_update_data_all
            ct_update_data_sta   = lt_update_data_status
            ct_node_state_create = lt_node_state_create
            ct_node_category     = lt_node_category ).
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* remove obsolete entries from lt_mod (not removed before to make cleanup_modifications work correctly)
    LOOP AT lt_mod_remove ASSIGNING <ls_mod>.
      READ TABLE lt_mod WITH KEY change
        COMPONENTS node           = <ls_mod>-node
                   change_mode    = <ls_mod>-change_mode
                   node_cat       = <ls_mod>-node_cat
                   key            = <ls_mod>-key
                   changed_fields = <ls_mod>-changed_fields
                   association    = <ls_mod>-association
                   source_node    = <ls_mod>-source_node
                   source_key     = <ls_mod>-source_key TRANSPORTING NO FIELDS.
      CHECK sy-subrc = 0.
      DELETE lt_mod INDEX sy-tabix USING KEY change.
    ENDLOOP.
    CLEAR lt_mod_remove.

* ____________________________________________________________________ *
* check for property violations in modifications
    IF iv_internal_modify = abap_false AND
        ( mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat OR
          mo_conf->ms_obj-check_services = /bobf/if_conf_c=>sc_check_services_stat_dyn ).
      check_properties_before_modify(
        EXPORTING
          io_change = eo_change
          iv_state  = iv_state
        CHANGING
          co_message            = eo_message
          ct_mod                = lt_mod
          ct_mod_do             = lt_mod_do
          ct_create             = lt_create
          ct_update             = lt_update
          ct_delete             = lt_delete
          ct_lock_created       = lt_lock_created
          ct_node_category      = lt_node_category
          ct_update_data        = lt_update_data
          ct_update_data_status = lt_update_data_status
          ct_update_data_all    = lt_update_data_all
          ct_node_state_create  = lt_node_state_create ).
    ENDIF.

* ____________________________________________________________________ *
* check for recursive delete actions
    IF lt_delete IS NOT INITIAL.
      IF mv_auth_supr_comp_chi_del_chck = abap_true.
        DATA(lt_delete_auth_check) = lt_delete.
      ENDIF.
      LOOP AT lt_delete INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.
        AT END OF node.
          CLEAR: lt_node,
                 lt_delegated_node.
          get_subnodes(
             EXPORTING
                iv_node_key                    = ls_node-node
                it_key                         = lt_key
                iv_stop_at_delegation_subtree  = abap_true
                iv_return_transient_nodes      = gc_transient_node_ctrl-return_transient_only_buffered
                iv_fill_child_node_information = abap_true
              IMPORTING
                eo_message                     = lo_message
                et_node_with_children          = DATA(lt_node_with_children)
                et_node_without_children       = DATA(lt_node_without_children)
              CHANGING
                ct_host_node                   = lt_node
                ct_delegation_root_node        = lt_delegated_node ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          DELETE lt_node WHERE node = ls_node-node.

          INSERT LINES OF lt_node                  INTO TABLE lt_delete_dep.
          INSERT LINES OF lt_delegated_node        INTO TABLE lt_delete_dep_deleg.
          INSERT LINES OF lt_node_with_children    INTO TABLE lt_node_w_children_for_msg.
          INSERT LINES OF lt_node_without_children INTO TABLE lt_node_wo_children_for_msg.

          CLEAR: lt_key, lt_node, lt_delegated_node.
        ENDAT.
      ENDLOOP.

      DELETE ADJACENT DUPLICATES FROM lt_delete_dep.
      DELETE ADJACENT DUPLICATES FROM lt_delete_dep_deleg.
      DELETE ADJACENT DUPLICATES FROM lt_node_w_children_for_msg.
      DELETE ADJACENT DUPLICATES FROM lt_node_wo_children_for_msg.

      mo_conf->get_bo(
        IMPORTING
          es_obj = ls_obj ).

      IF ls_obj-delete_loads_data = abap_true.
        do_loading(
          EXPORTING
            it_node           = lt_delete_dep
            iv_check_buf      = abap_true
            iv_reload         = abap_false
            iv_load_data      = abap_true
            iv_notify_keyload = abap_true
            iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
            iv_within_loading = iv_within_loading
            io_change         = eo_change
          IMPORTING
            et_failed         = lt_failed
            eo_message        = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_node_subset(
                it_node_set    = lt_delete_dep
                it_node_subset = lt_failed ) = abap_true.
      ENDIF.

*   deletes to be delegated
      LOOP AT lt_delete_dep_deleg INTO ls_node.
        AT NEW node.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_node-node
            IMPORTING es_node     = ls_node_c ).

          READ TABLE lt_mod_do ASSIGNING <ls_mod_do>
            WITH KEY delegation_root_node_key = ls_node_c-delegation_root_node_key.
          IF sy-subrc <> 0.
            CLEAR ls_mod_do.
            ls_mod_do-delegation_root_node_key = ls_node_c-delegation_root_node_key.
            INSERT ls_mod_do INTO TABLE lt_mod_do ASSIGNING <ls_mod_do>.
          ENDIF.
        ENDAT.
        DELETE <ls_mod_do>-modification
          WHERE node = ls_node-node
            AND key  = ls_node-key.
        ls_mod_int-node        = ls_node-node.
        ls_mod_int-change_mode = /bobf/if_frw_c=>sc_modify_delete.
        ls_mod_int-key         = ls_node-key.
        APPEND ls_mod_int TO <ls_mod_do>-modification.
      ENDLOOP.

*   standard deletes

      LOOP AT lt_delete_dep INTO ls_node.
        ls_mod_int-node        = ls_node-node.
        ls_mod_int-change_mode = /bobf/if_frw_c=>sc_modify_delete.
        ls_mod_int-key         = ls_node-key.
        APPEND ls_mod_int TO lt_mod_del.
        INSERT ls_node INTO TABLE lt_load.
        READ TABLE lt_delete TRANSPORTING NO FIELDS
          WITH KEY node = ls_node-node
                   key  = ls_node-key.
        IF sy-subrc NE 0.
          INSERT ls_node INTO lt_delete INDEX sy-tabix. "#EC CI_INSERT_OK
          DELETE lt_delete_dep.  "also not in lt_mod !!
        ENDIF.
      ENDLOOP.
      IF lt_delete_dep IS NOT INITIAL.
        LOOP AT lt_mod ASSIGNING <ls_mod>.
          READ TABLE lt_delete_dep TRANSPORTING NO FIELDS
            WITH KEY node = <ls_mod>-node
                     key  = <ls_mod>-key.
          IF sy-subrc = 0.
            DELETE lt_mod.
          ENDIF.
        ENDLOOP.
      ENDIF.
      APPEND LINES OF lt_mod_del TO lt_mod.
    ENDIF.

    IF mo_conf->ms_obj-status_class IS NOT INITIAL.
*   deleted nodes: get status nodes to delete if necessary
      LOOP AT lt_delete INTO ls_node.
        AT NEW node.
          mo_conf->get_node(
            EXPORTING
              iv_node_key     = ls_node-node
            IMPORTING
              es_node         = ls_node_conf ).
          IF ls_node_conf-status_attributes IS BOUND AND
             ls_node_conf-status_attributes->* IS NOT INITIAL.
            lv_delete_status = abap_true.
            EXIT.
          ELSE.
            mo_conf->get_assoc(
              EXPORTING
                iv_node_key   = ls_node-node
                iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
                iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
              IMPORTING
                es_assoc      = ls_assoc_status ).
            IF ls_assoc_status IS NOT INITIAL.
              lv_delete_status = abap_true.
              EXIT.
            ENDIF.
          ENDIF.
        ENDAT.
      ENDLOOP.
    ENDIF.

* ____________________________________________________________________ *
* filter out non-changing update requests
    IF lt_update_data_all IS NOT INITIAL.
      TRY.
          mo_buffer->compare(
          EXPORTING
            it_data      = lt_update_data_all
            iv_state     = iv_state
          IMPORTING
            et_equal     = lt_unchanged
            et_different = lt_changed ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      IF lt_unchanged IS NOT INITIAL.
        cleanup_mods_from_unchanged(
          EXPORTING
            it_unchanged          = lt_unchanged
            it_changed            = lt_changed
          CHANGING
            ct_mod                = lt_mod
            ct_update             = lt_update
            ct_node_state_create  = lt_node_state_create
            ct_update_data        = lt_update_data
            ct_update_data_status = lt_update_data_status
        ).
      ENDIF.
    ENDIF.

*  ____________________________________________________________________ *
* create before modification state
    IF iv_internal_modify = abap_false OR
       lv_delete_status   = abap_true.

      IF lt_node_state_create IS NOT INITIAL.

        get_root_key_modify(
         EXPORTING
           it_node   = lt_node_state_create
           iv_state  = iv_state
           io_change = eo_change
         IMPORTING
           et_key    = lt_root_key
         CHANGING
            ct_mod   = lt_mod ).
        CLEAR lt_node_state_create.
        ls_node-node = mo_conf->ms_obj-root_node_key.
        LOOP AT lt_root_key INTO ls_key.
          ls_node-key = ls_key-key.
          INSERT ls_node INTO TABLE lt_node_state_create.
        ENDLOOP.
      ENDIF.

*   create state
      IF lt_node_state_create IS NOT INITIAL.
        DELETE ADJACENT DUPLICATES FROM lt_node_state_create.
        TRY.
            mo_buffer->transfer_state(
              EXPORTING
                it_node         = lt_node_state_create
                iv_incl_subtree = abap_true
                iv_state_source = iv_state
                iv_state_dest   = /bobf/if_conf_c=>sc_state_before_modification ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        mv_before_modification_exists = abap_true.
        lv_before_modif_set           = abap_true.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* execute modifications
    IF lt_mod    IS NOT INITIAL OR
       lt_mod_do IS NOT INITIAL.
      IF mv_modifying_transaction = abap_false AND
          lv_only_transient       = abap_false.
        mv_modifying_transaction = abap_true.
        create_states( ).
      ENDIF.

*   own modifications
      lo_change = /bobf/cl_frw_factory=>get_change( ).


      IF mt_access_stack IS INITIAL
        AND mo_amount_decimal_converter->has_bo_node_with_curr_mapping( ). "only for CDS generated bo see: /BOBF/CL_CONF_READ_ONLY

        TRY.
            lo_int_access = /bobf/cl_frw_int_access=>new_instance( io_bopf            = me
                                                                   io_conf            = mo_conf
                                                                   io_buffer          = mo_buffer
                                                                   io_change          = lo_change ).
            lo_int_access->set_current_state( iv_state ).
            lo_int_access->set_context( iv_modify_allowed  = abap_true ).

            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
            INSERT lo_int_access INTO mt_access_stack INDEX 1.

            mo_amount_decimal_converter->convert( EXPORTING io_int_access = lo_int_access
                                                            it_modification = lt_mod
                                                            io_change = lo_change
                                                  IMPORTING eo_message = lo_message  ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            IF lo_int_access->mt_modification IS NOT INITIAL.
              lo_int_access->end_modify( ).
              collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                                CHANGING  co_message = lo_message ).
            ENDIF.

            lo_int_access->invalidate( ).
            CLEAR lo_int_access.
            ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
            DELETE mt_access_stack INDEX 1.

          CATCH BEFORE UNWIND /bobf/cx_frw INTO lx_root.
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.


      IF lv_implemented_create = abap_true.
        CLEAR: lt_mod_tmp.

        LOOP AT lt_mod ASSIGNING <ls_mod>.
          lv_index = sy-tabix.
          IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_update OR
             <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_delete OR
             <ls_mod>-association = iv_assoc_key                     OR
             <ls_mod>-association IS INITIAL.

            APPEND <ls_mod> TO lt_mod_tmp.

          ELSE.
            IF <ls_mod>-association <> ls_assoc-assoc_key.
              mo_conf->get_assoc(
                EXPORTING iv_assoc_key = <ls_mod>-association
                IMPORTING es_assoc     = ls_assoc ).
            ENDIF.

            IF ls_assoc-assoc_class IS INITIAL.
              APPEND <ls_mod> TO lt_mod_tmp.

            ELSE.
*       flush buffer modifications
              IF lt_mod_tmp IS NOT INITIAL.
                TRY.
                    mo_buffer->modify(
                       EXPORTING
                         it_modification   = lt_mod_tmp
                         iv_state          = iv_state
                         io_change         = lo_change
                         iv_only_transient = lv_only_transient
                       IMPORTING
                         eo_message        = lo_message ).
                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.

                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).
                CLEAR lt_mod_tmp.
              ENDIF.

              APPEND <ls_mod> TO lt_mod_tmp_class.

              READ TABLE lt_mod ASSIGNING <ls_mod_next> INDEX lv_index + 1.

              IF sy-subrc              <> 0 OR
                  <ls_mod>-association <> <ls_mod_next>-association.
                create(
                  EXPORTING
                    it_mod             = lt_mod_tmp_class
                    iv_edit_mode       = iv_edit_mode
                    iv_assoc_key       = <ls_mod>-association
                    iv_state           = iv_state
                    io_change          = lo_change
                    iv_within_loading  = iv_within_loading
                    iv_within_retrieve = iv_within_retrieve
                  IMPORTING
                    eo_message = lo_message ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).
                CLEAR lt_mod_tmp_class.
              ENDIF.

            ENDIF.
          ENDIF.
        ENDLOOP.

*     flush left buffer modifications
        IF lt_mod_tmp IS NOT INITIAL.
          TRY.
              mo_buffer->modify(
               EXPORTING
                 it_modification   = lt_mod_tmp
                 iv_state          = iv_state
                 io_change         = lo_change
                 iv_only_transient = lv_only_transient
               IMPORTING
                 eo_message        = lo_message ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
          CLEAR lt_mod_tmp.
        ENDIF.

      ELSE.
*     no implemented create associations used -> use lt_mod directly
        TRY.
            mo_buffer->modify(
              EXPORTING
                it_modification   = lt_mod
                iv_state          = iv_state
                io_change         = lo_change
                iv_only_transient = lv_only_transient
              IMPORTING
                eo_message        = lo_message ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      after_loading(
        EXPORTING
          io_change         = lo_change
          iv_within_loading = iv_within_loading
          iv_load_state     = iv_state
        IMPORTING
          eo_message        = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

* ____________________________________________________________________ *
* remove failed modifications
    IF lo_change IS BOUND.
      lo_change->get_changes(
        EXPORTING
          iv_failed = abap_true
        IMPORTING
          et_change = lt_failed_change ).
      ASSERT ID /bobf/frw CONDITION lt_failed_change IS INITIAL.
      LOOP AT lt_failed_change INTO ls_change.
        AT NEW node_key.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_change-node_key
            IMPORTING es_node     = ls_node_c ).
        ENDAT.
        CHECK ls_node_c-delegation_class IS INITIAL.
        ls_node-node = ls_change-node_key.
        ls_node-key  = ls_change-key.
        INSERT ls_node INTO TABLE lt_node_restore.
        IF iv_internal_modify = abap_true.
*       cleanups for internal changes. For external ones cleanup for entire BO instance is necessary and done below
          CASE ls_change-change_mode.
            WHEN /bobf/if_frw_c=>sc_modify_create.
              DELETE lt_create
                WHERE node = ls_change-node_key
                  AND key  = ls_change-key.
            WHEN /bobf/if_frw_c=>sc_modify_update.
              DELETE lt_update
                WHERE node = ls_change-node_key
                  AND key  = ls_change-key.
            WHEN /bobf/if_frw_c=>sc_modify_delete.
              DELETE lt_delete
                WHERE node = ls_change-node_key
                  AND key  = ls_change-key.
          ENDCASE.
        ELSEIF ls_change-change_mode = /bobf/if_frw_c=>sc_modify_create.
*       create message for rejected create in case of 1:1/1:c-association with same key
          READ TABLE lt_mod ASSIGNING <ls_mod> WITH KEY change
            COMPONENTS change_mode = ls_change-change_mode
                       node        = ls_change-node_key
                       key         = ls_change-key.
          IF sy-subrc = 0 AND <ls_mod>-association IS NOT INITIAL.
            IF mo_conf->ms_last_assoc-assoc_key <> <ls_mod>-association.
              mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_mod>-association ).
            ENDIF.
            IF mo_conf->ms_last_assoc-target_node->key_inherited = abap_true.
              IF eo_message IS NOT BOUND.
                eo_message = /bobf/cl_frw_factory=>get_message( ).
              ENDIF.

              ls_origin_location-node_key = ls_change-node_key.
              ls_origin_location-key      = ls_change-key.

              CREATE OBJECT lm_message_esi
                EXPORTING
                  textid             = /bobf/cm_frw_common_esi=>cm_node_not_more_than_one
                  severity           = /bobf/cm_frw=>co_severity_error
                  symptom            = /bobf/if_frw_message_symptoms=>co_failed_service_invocation
                  lifetime           = /bobf/cm_frw=>co_lifetime_transition
                  ms_origin_location = ls_origin_location
                  mv_assoc_key       = mo_conf->ms_last_assoc-assoc_key.

              eo_message->add_cm( lm_message_esi ).
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.

      IF lt_failed_change IS NOT INITIAL AND
         iv_internal_modify = abap_false.
        cleanup_modifications(
        EXPORTING
          it_failed_node  = lt_node_restore
          io_change       = lo_change
        CHANGING
          ct_mod           = lt_mod
          ct_mod_do        = lt_mod_do
          ct_lock_created  = lt_lock_created
          ct_create        = lt_create
          ct_update        = lt_update
          ct_delete        = lt_delete
          ct_node_category = lt_node_category ).
      ENDIF.
    ENDIF.

    eo_change->merge( lo_change ).


* ____________________________________________________________________ *
* set node category
    IF lt_node_category IS NOT INITIAL.
      set_node_category(
        EXPORTING
          iv_internal_modify = iv_internal_modify
          it_node            = lt_node_category
        IMPORTING
          et_failed  = lt_failed
          eo_message = lo_message ).

      LOOP AT lt_failed INTO ls_node.
        INSERT ls_node INTO TABLE lt_node_restore.
        DELETE TABLE lt_create FROM ls_node.
      ENDLOOP.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

    ENDIF.

* ____________________________________________________________________ *
    IF  lt_create IS NOT INITIAL
    AND mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft.
*    AND mo<<_conf->identify_scenario( ) = /bobf/if_conf_c=>sc_scenario-new_app_w_draft.
      " Check whether a draft instance is trying to create an active child instance and vice versa
      check_inconsistent_composition( EXPORTING it_create_node  = lt_create
                                      IMPORTING eo_message      = lo_message
                                                et_failed_node  = DATA(lt_failed_node) ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      LOOP AT lt_failed_node INTO ls_node.
        INSERT ls_node INTO TABLE lt_node_restore.
        DELETE TABLE lt_create FROM ls_node.
      ENDLOOP.

      CLEAR lt_failed_node.
    ENDIF.

* ____________________________________________________________________ *
* draft applications only: create enqueue context for new draft root instance *created internally* (IO_MODIFY)
* (*externally created* new draft root instance is covered by action validation DURABLE_LOCK_CREATE_FOR_NEW)...
    IF iv_internal_modify = abap_true.
      enqueue_context_for_int_create( EXPORTING iv_state   = iv_state
                                      CHANGING  ct_create  = lt_create
                                                ct_restore = lt_node_restore
                                                co_message = eo_message ).
    ENDIF.

* ____________________________________________________________________ *
* check action: create/update/delete
    IF iv_internal_modify = abap_false.

      CLEAR: lt_key, lt_failed_key.
      LOOP AT lt_create INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.
        AT END OF node.

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset_stack_set(
                 it_key_set = lt_key ) = abap_true.

          check_action(
            EXPORTING
              iv_node_key         = ls_node-node
              iv_act_cat          = /bobf/if_conf_c=>sc_action_create
              iv_check_property   = abap_false
              iv_check_validation = abap_true
              io_change           = eo_change
            IMPORTING
              et_failed_key       = lt_failed_key
              eo_message          = lo_message
            CHANGING
              ct_key              = lt_key ).

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset_stack_check(
                 it_key_subset = lt_failed_key ) = abap_true.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_failed_key INTO ls_key.
            ls_node-key = ls_key-key.
            INSERT ls_node INTO TABLE lt_node_restore.
            DELETE TABLE lt_create FROM ls_node.
          ENDLOOP.

          CLEAR: lt_key, lt_failed_key.
        ENDAT.
      ENDLOOP.

* ____________________________________________________________________ *
*   check action: update
      CLEAR: lt_key, lt_failed_key.
      LOOP AT lt_update INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.
        AT END OF node.

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset_stack_set(
                 it_key_set = lt_key ) = abap_true.

          check_action(
            EXPORTING
              iv_node_key         = ls_node-node
              iv_act_cat          = /bobf/if_conf_c=>sc_action_update
              iv_check_property   = abap_false
              iv_check_validation = abap_true
              io_change           = eo_change
            IMPORTING
              et_failed_key       = lt_failed_key
              eo_message          = lo_message
            CHANGING
              ct_key              = lt_key ).

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset_stack_check(
                 it_key_subset = lt_failed_key ) = abap_true.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_failed_key INTO ls_key.
            ls_node-key = ls_key-key.
            INSERT ls_node INTO TABLE lt_node_restore.
            DELETE TABLE lt_update FROM ls_node.
          ENDLOOP.

          CLEAR: lt_key, lt_failed_key.
        ENDAT.
      ENDLOOP.

    ENDIF.

* ____________________________________________________________________ *
* check action: delete
    IF iv_internal_modify = abap_false OR
        mo_conf->ms_obj-status_class IS NOT INITIAL.

      IF iv_internal_modify = abap_false.
        lv_check_validation = abap_true.
      ELSE.
        lv_check_validation = abap_false.
      ENDIF.

      CLEAR: lt_key, lt_failed_key.
      LOOP AT lt_delete INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.
        AT END OF node.
          IF mo_conf->ms_last_node-node_key <> ls_node-node.
            mo_conf->get_node( iv_node_key = ls_node-node ).
          ENDIF.
          IF mo_conf->ms_last_node-node_type <> /bobf/if_conf_c=>sc_node_type_normal.
            CLEAR lt_key.
            CONTINUE.
          ENDIF.

          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset_stack_set(
                 it_key_set = lt_key ) = abap_true.

          DATA lt_delete_auth_check_key TYPE /bobf/t_frw_key.
          CLEAR lt_delete_auth_check_key.
          IF mv_auth_supr_comp_chi_del_chck = abap_true.
            LOOP AT lt_delete_auth_check ASSIGNING FIELD-SYMBOL(<ls_delete_auth_check>) WHERE node = ls_node-node.
              IF line_exists( lt_key[ KEY key_sort key = <ls_delete_auth_check>-key ] ).
                APPEND VALUE #( key = <ls_delete_auth_check>-key ) TO lt_delete_auth_check_key.
              ENDIF.
            ENDLOOP.
          ELSE.
            lt_delete_auth_check_key = lt_key.
          ENDIF.

          check_action(
            EXPORTING
              iv_node_key              = ls_node-node
              iv_act_cat               = /bobf/if_conf_c=>sc_action_delete
              iv_check_property        = abap_false
              iv_check_validation      = lv_check_validation
              io_change                = eo_change
              it_delete_auth_check_key = lt_delete_auth_check_key
            IMPORTING
              et_failed_key            = lt_failed_key
              eo_message               = lo_message
            CHANGING
              ct_key                   = lt_key ).
          ASSERT ID /bobf/frw CONDITION
             /bobf/cl_tool_assert=>is_key_subset_stack_check(
                 it_key_subset = lt_failed_key ) = abap_true.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          LOOP AT lt_failed_key INTO ls_key.
            ls_node-key = ls_key-key.
            INSERT ls_node INTO TABLE lt_node_restore_del.
            DELETE TABLE lt_delete FROM ls_node.
          ENDLOOP.
          CLEAR: lt_key, lt_failed_key.
        ENDAT.
      ENDLOOP.
    ENDIF.

* ____________________________________________________________________ *
* call delete action
    do_delete_action( EXPORTING it_delete      = lt_delete
                                io_change      = eo_change
                      IMPORTING eo_message     = lo_message
                                et_failed_node = DATA(lt_failed_delete) ).
    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    LOOP AT lt_failed_delete INTO DATA(ls_failed_delete).
      INSERT ls_failed_delete INTO TABLE lt_node_restore_del.
      DELETE TABLE lt_delete FROM ls_failed_delete.
    ENDLOOP.

* ____________________________________________________________________ *
* undo failed modifications
    IF ( lt_node_restore    IS NOT INITIAL OR
        lt_node_restore_del IS NOT INITIAL ) AND
        mv_before_modification_exists = abap_true.

      CLEAR lt_root_key.
      IF lt_node_restore IS NOT INITIAL.
        get_root_key_modify(
          EXPORTING
            it_node   = lt_node_restore
            iv_state  = iv_state
            io_change = eo_change
          IMPORTING
            et_key    = lt_root_key
          CHANGING
            ct_mod    = lt_mod ).
      ENDIF.
      IF lt_node_restore_del IS NOT INITIAL.
        get_root_key_modify(
          EXPORTING
            it_node   = lt_node_restore_del
            iv_state  = /bobf/if_conf_c=>sc_state_before_modification
            io_change = eo_change
          IMPORTING
            et_key    = lt_root_key2
          CHANGING
            ct_mod    = lt_mod ).
        IF lt_root_key IS NOT INITIAL.
          APPEND LINES OF lt_root_key2 TO lt_root_key.
          SORT lt_root_key.
          DELETE ADJACENT DUPLICATES FROM lt_root_key.
        ELSE.
          lt_root_key = lt_root_key2.
        ENDIF.
      ENDIF.

      ls_node-node = mo_conf->ms_obj-root_node_key.
      LOOP AT lt_root_key INTO ls_key.
        ls_node-key = ls_key-key.
        INSERT ls_node INTO TABLE lt_root_node_restore.
      ENDLOOP.

      TRY.
          mo_buffer->transfer_state(
            EXPORTING
              it_node         = lt_root_node_restore
              iv_incl_subtree = abap_true
              iv_state_source = /bobf/if_conf_c=>sc_state_before_modification
              iv_state_dest   = iv_state ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      cleanup_modifications(
        EXPORTING
          it_failed_root_key   = lt_root_key
          io_change            = eo_change
        CHANGING
          ct_mod               = lt_mod
          ct_mod_do            = lt_mod_do
          ct_lock_created      = lt_lock_created
          ct_create            = lt_create
          ct_update            = lt_update
          ct_delete            = lt_delete
          ct_node_category     = lt_node_category ).

    ENDIF.

* ____________________________________________________________________ *
* delegated modifications
    IF lt_mod_do IS NOT INITIAL.
      TRY.
          LOOP AT lt_mod_do ASSIGNING <ls_mod_do>.
            lo_delegation = get_delegation( <ls_mod_do>-delegation_root_node_key ).
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            lo_delegation->modify(
              EXPORTING
                it_modification             = <ls_mod_do>-modification
                io_change                   = eo_change
                iv_priv_mode_for_auth_check = lv_previous_priv_mode
              IMPORTING
                eo_message                  = lo_message ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDLOOP.

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

* ____________________________________________________________________ *
* lock newly created node instances (just write the lock buffer)
* (This happens only if locks are to be discarded after SAVE. See
*  reference to LT_LOCK_CREATED above).
    IF iv_edit_mode <> /bobf/if_conf_c=>sc_edit_read_only AND
       lv_only_transient = abap_false                     AND
       lt_lock_created IS NOT INITIAL.

      CLEAR lt_mod_tmp.

      LOOP AT lt_lock_created INTO ls_node.
        IF mo_conf->ms_last_node-node_key <> ls_node-node.
          mo_conf->get_node( iv_node_key = ls_node-node ).
        ENDIF.

        CREATE DATA ls_lock_data.
        ls_lock_data->edit_mode        = iv_edit_mode.
        IF mv_enqueue_scope = /bobf/if_conf_c=>sc_enqueue_scope_optdiaupd.
          ls_lock_data->edit_mode_dialog = /bobf/if_conf_c=>sc_edit_optimistic.
          ls_lock_data->edit_mode_update = iv_edit_mode.
        ELSE.
          " this part is not expected to be executed for EXCDIAUPD:
          ASSERT mv_enqueue_scope <> /bobf/if_conf_c=>sc_enqueue_scope_excdiaupd.
        ENDIF.
        ls_lock_data->generic          = abap_true.
        ls_lock_data->parent_edit_mode = /bobf/if_conf_c=>sc_edit_read_only.

        ls_mod_int-node                = mo_conf->ms_last_node-lock_node_key.
        ls_mod_int-change_mode         = /bobf/if_frw_c=>sc_modify_create.
        ls_mod_int-key                 = ls_node-key.

        ls_lock_data->key              = ls_mod_int-key.
        ls_lock_data->parent_key       = ls_mod_int-key.

        ls_mod_int-data                = ls_lock_data.
*     LS_MOD_INT-ASSOCIATION = " not necessary
        ls_mod_int-source_node         = ls_node-node.
        ls_mod_int-source_key          = ls_node-key.
        APPEND ls_mod_int TO lt_mod_tmp.
      ENDLOOP.

      TRY.
          mo_buffer->modify(
            EXPORTING
              it_modification   = lt_mod_tmp
              iv_state          = /bobf/if_conf_c=>sc_state_current
              io_change         = eo_change
              iv_only_transient = abap_true
            IMPORTING
              eo_message        = lo_message ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

* update S&AM
    IF mo_conf->ms_obj-status_class IS NOT INITIAL.

*  ____________________________________________________________________ *
*   new and deleted nodes: create and delete status nodes if necessary
      LOOP AT lt_create INTO ls_node.
        AT NEW node.
          mo_conf->get_assoc(
            EXPORTING
              iv_node_key   = ls_node-node
              iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
              iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
            IMPORTING
              es_assoc      = ls_assoc_status ).
          IF mo_conf->ms_last_node-node_key <> ls_node-node.
            mo_conf->get_node( iv_node_key = ls_node-node ).
          ENDIF.
          IF mo_conf->ms_last_node-node_type           <> /bobf/if_conf_c=>sc_node_type_status AND
             mo_conf->ms_last_node-status_attributes    IS BOUND                               AND
             mo_conf->ms_last_node-status_attributes->* IS NOT INITIAL.
            lv_status_variable = abap_true.
          ELSE.
            lv_status_variable = abap_false.
          ENDIF.
        ENDAT.
        IF lv_status_variable = abap_true.
          INSERT ls_node INTO TABLE lt_node_status_create.
        ENDIF.
        IF ls_assoc_status IS NOT INITIAL.
          ls_node-node = ls_assoc_status-target_node->node_key.
          INSERT ls_node INTO TABLE lt_node_status_create.
        ENDIF.
      ENDLOOP.

      LOOP AT lt_delete INTO ls_node.
        AT NEW node.
          mo_conf->get_assoc(
            EXPORTING
              iv_node_key   = ls_node-node
              iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_status
              iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
            IMPORTING
              es_assoc      = ls_assoc_status ).
          IF mo_conf->ms_last_node-node_key <> ls_node-node.
            mo_conf->get_node( iv_node_key = ls_node-node ).
          ENDIF.
          IF mo_conf->ms_last_node-node_type           <> /bobf/if_conf_c=>sc_node_type_status AND
             mo_conf->ms_last_node-status_attributes    IS BOUND                               AND
             mo_conf->ms_last_node-status_attributes->* IS NOT INITIAL.
            lv_status_variable = abap_true.
          ELSE.
            lv_status_variable = abap_false.
          ENDIF.
        ENDAT.
        IF lv_status_variable = abap_true.
          INSERT ls_node INTO TABLE lt_node_status_delete.
        ENDIF.
        IF ls_assoc_status IS NOT INITIAL.
          ls_node-node = ls_assoc_status-target_node->node_key.
          INSERT ls_node INTO TABLE lt_node_status_delete.
        ENDIF.
      ENDLOOP.

*   check for status changes
      IF lt_node_status_create IS NOT INITIAL OR
         lt_update_data_status IS NOT INITIAL OR
         lt_node_status_delete IS NOT INITIAL.

        lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

*     get status adapter
        IF mo_sam IS NOT BOUND.
          TRY.
              CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
                EXPORTING
                  iv_bo_key = mo_conf->ms_obj-bo_key.

            CATCH BEFORE UNWIND cx_sy_create_object_error INTO lx_root.
              lv_content_cat = TEXT-004.
              CREATE OBJECT lx_frw
                EXPORTING
                  previous       = lx_root
                  textid         = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname   = mo_conf->ms_obj-status_class
                  mv_content_cat = lv_content_cat.
              set_application_error( lx_frw ).
          ENDTRY.
          ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
        ENDIF.

*  ____________________________________________________________________ *
*     create, update and delete status nodes
        IF lo_int_access IS NOT BOUND.
          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
              io_change          = eo_change
            RECEIVING
              eo_internal_access = lo_int_access
          ).
        ENDIF.
        lo_int_access->set_current_state( iv_state ).
        lo_int_access->set_last_state( /bobf/if_conf_c=>sc_state_before_modification ).
        lo_int_access->set_context(
          EXPORTING
            iv_read_allowed    = abap_true
            iv_modify_allowed  = abap_true ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
        INSERT lo_int_access INTO mt_access_stack INDEX 1.

        IF lt_node_status_create IS NOT INITIAL.
          TRY.
              mo_sam->create(
                EXPORTING
                  it_node    = lt_node_status_create
                  io_read    = lo_int_access
                  io_modify  = lo_int_access
                IMPORTING
                  eo_message = lo_message ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              IF lo_message IS BOUND.
                lo_message->get_messages(
                  IMPORTING
                    et_message  =  lt_messages ).
              ENDIF.

              CLEAR lv_message.

              IF lt_messages IS NOT INITIAL.
                READ TABLE lt_messages INTO ls_message INDEX 1.
                lv_message = ls_message-message->get_text( ).
              ENDIF.

              lcl_error_provider=>get_text_sam_error(
                EXPORTING
                  iv_error_type       = co_err_sam_create
                  iv_bo_key           = mo_conf->ms_obj-bo_key
                  iv_message          = lv_message
                  io_configuration    = mo_conf
                RECEIVING
                  rv_application_info = lv_app_info
              ).

              CREATE OBJECT lx_frw
                EXPORTING
                  previous                   = lx_root
                  mv_application_information = lv_app_info.
              set_application_error( io_exception = lx_frw ).
          ENDTRY.
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

        IF lt_update_data_status IS NOT INITIAL.
          TRY.
              mo_sam->update(
                EXPORTING
                  it_status  = lt_update_data_status
                  iv_act_key = iv_act_key
                  io_read    = lo_int_access
                  io_modify  = lo_int_access
                IMPORTING
                  eo_message = lo_message ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              IF lo_message IS BOUND.
                lo_message->get_messages(
                  IMPORTING
                    et_message  =  lt_messages ).
              ENDIF.

              CLEAR lv_message.

              IF lt_messages IS NOT INITIAL.
                READ TABLE lt_messages INTO ls_message INDEX 1.
                lv_message = ls_message-message->get_text( ).
              ENDIF.

              lcl_error_provider=>get_text_sam_error(
                EXPORTING
                  iv_error_type       = co_err_sam_update
                  iv_bo_key           = mo_conf->ms_obj-bo_key
                  iv_message          = lv_message
                  io_configuration    = mo_conf
                RECEIVING
                  rv_application_info = lv_app_info
              ).

              CREATE OBJECT lx_frw
                EXPORTING
                  previous                   = lx_root
                  mv_application_information = lv_app_info.
              set_application_error( io_exception = lx_frw ).
          ENDTRY.
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

        IF lt_node_status_delete IS NOT INITIAL.
*       create read interface with different current state
          /bobf/cl_frw_int_access=>new_instance(
            EXPORTING
              io_bopf            = me
              io_conf            = mo_conf
              io_buffer          = mo_buffer
            RECEIVING
              eo_internal_access = lo_int_access_read
          ).

          lo_int_access_read->set_current_state( /bobf/if_conf_c=>sc_state_before_modification ).
          lo_int_access_read->set_last_state( /bobf/if_conf_c=>sc_state_before_modification ).
          lo_int_access_read->set_context(
            EXPORTING
              iv_read_allowed = abap_true ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
          INSERT lo_int_access_read INTO mt_access_stack INDEX 1.

          TRY.
              mo_sam->delete(
                EXPORTING
                  it_node    = lt_node_status_delete
                  io_read    = lo_int_access_read
                  io_modify  = lo_int_access
                IMPORTING
                  eo_message = lo_message ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              IF lo_message IS BOUND.
                lo_message->get_messages(
                  IMPORTING
                    et_message  =  lt_messages ).
              ENDIF.

              CLEAR lv_message.

              IF lt_messages IS NOT INITIAL.
                READ TABLE lt_messages INTO ls_message INDEX 1.
                lv_message = ls_message-message->get_text( ).
              ENDIF.

              lcl_error_provider=>get_text_sam_error(
                EXPORTING
                  iv_error_type       = co_err_sam_delete
                  iv_bo_key           = mo_conf->ms_obj-bo_key
                  iv_message          = lv_message
                  io_configuration    = mo_conf
                RECEIVING
                  rv_application_info = lv_app_info
              ).

              CREATE OBJECT lx_frw
                EXPORTING
                  previous                   = lx_root
                  mv_application_information = lv_app_info.
              set_application_error( io_exception = lx_frw ).
          ENDTRY.

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          lo_int_access_read->invalidate( ).
          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
          DELETE mt_access_stack INDEX 1.

        ENDIF.

*     check for undone modifications and flush
        IF lo_int_access->mt_modification IS NOT INITIAL.
          lo_int_access->end_modify( ).
        ENDIF.
        collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                          CHANGING  co_message = lo_message ).
        lo_int_access->invalidate( ).
        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
        DELETE mt_access_stack INDEX 1.
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* remove before modification state
    IF lv_before_modif_set = abap_true.
      TRY.
          mo_buffer->delete_state(
              it_node         = lt_node_state_create
              iv_incl_subtree = abap_true
              iv_state        = /bobf/if_conf_c=>sc_state_before_modification ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
      mv_before_modification_exists = abap_false.
    ENDIF.

* ____________________________________________________________________ *
* invalidate properties and add association changes (on delete trigger or DO)
    IF mo_conf->ms_obj-last_det_state_not_relevant = abap_true.
      lv_state_prop_notif = /bobf/if_conf_c=>sc_state_last_validated.
    ELSE.
      lv_state_prop_notif = /bobf/if_conf_c=>sc_state_last_determined.
    ENDIF.

    IF lt_delete IS NOT INITIAL.
      notify_property_changes(
        EXPORTING
          io_change     = eo_change
          iv_last_state = lv_state_prop_notif
          iv_delete     = abap_true
       IMPORTING
         eo_message    = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
      notify_association_changes_d( EXPORTING io_change     = eo_change
                                              iv_last_state = lv_state_prop_notif
                                    IMPORTING eo_message    = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

    IF lt_mod_do IS NOT INITIAL.
      notify_association_changes_do( EXPORTING io_change  = eo_change
                                               iv_state   = lv_state_prop_notif
                                     IMPORTING eo_message = lo_message ).
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

* ____________________________________________________________________ *
* delete defaults
    IF lt_create IS NOT INITIAL AND
       mv_defaults_exists = abap_true.
      CLEAR: lt_mod,
             ls_mod_int.

      ls_mod_int-change_mode = /bobf/if_frw_c=>sc_modify_delete.
      LOOP AT lt_create INTO ls_node.
        AT NEW node.
          IF mo_conf->ms_last_node-node_key <> ls_node-node.
            mo_conf->get_node( iv_node_key = ls_node-node ).
          ENDIF.
        ENDAT.
        IF mo_conf->ms_last_node-node_type = /bobf/if_conf_c=>sc_node_type_normal.
          ls_mod_int-node = ls_node-node.
          ls_mod_int-key  = ls_node-key.
          APPEND ls_mod_int TO lt_mod.
        ENDIF.
      ENDLOOP.

      IF lt_mod IS NOT INITIAL.
        lo_change = /bobf/cl_frw_factory=>get_change( ).
        TRY.
            mo_buffer->modify(
              EXPORTING
                it_modification   = lt_mod
                iv_state          = /bobf/if_conf_c=>sc_state_default
                io_change         = lo_change
                iv_only_transient = abap_true ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* perform determination and validation loop
    IF iv_internal_modify   = abap_false AND
       mv_no_determinations = abap_false AND
       ( eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_create ) = abap_true OR
         eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_update ) = abap_true OR
         eo_change->has_changes( iv_change_mode = /bobf/if_frw_c=>sc_modify_delete ) = abap_true ).

      FREE lt_mod.
      FREE lt_mod_do.

      do_detval( EXPORTING io_change                  = eo_change
                           iv_validation_time_context = /bobf/if_conf_c=>sc_val_time_after_modify
                 IMPORTING eo_message                 = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

* ____________________________________________________________________ *
* remove durable messages if necessary
    remove_durable_messages( EXPORTING it_node_deleted_wo_children = lt_node_wo_children_for_msg
                                       it_node_deleted_w_children  = lt_node_w_children_for_msg
                             CHANGING  co_message                  = eo_message ).

  ENDMETHOD.                    "do_modify


  METHOD do_validate.

*  constistency-check

    DATA: lv_last_state        TYPE /bobf/conf_state,
          lo_int_access        TYPE REF TO /bobf/cl_frw_int_access,
          lo_message           TYPE REF TO /bobf/if_frw_message,
          lo_message_int       TYPE REF TO /bobf/cl_frw_message,
          lt_message           TYPE /bobf/t_frw_message_k,
          ls_message           TYPE /bobf/s_frw_message_k,
          ls_message_r         TYPE REF TO /bobf/s_frw_message_k,
          lt_message_key       TYPE /bobf/t_frw_key,
          ls_val_read          TYPE /bobf/s_confro_read,
          lt_node_unsorted     TYPE /bobf/t_frw_node_unsorted,
          lt_node_load         TYPE /bobf/t_frw_node,
          ls_node_load         TYPE /bobf/s_frw_node,
          lt_nodecat           TYPE /bobf/t_frw_node_cat,
          ls_nodecat           TYPE /bobf/s_frw_node_cat,
          ls_assoc_conf        TYPE /bobf/s_confro_assoc,
          lt_val_list          TYPE /bobf/t_confro_val_list,
          ls_val               TYPE ty_validation,
          lt_key               TYPE /bobf/t_frw_key,
          lt_key_tmp           TYPE /bobf/t_frw_key,
          ls_key               TYPE /bobf/s_frw_key,
          lt_key_link          TYPE /bobf/t_frw_key_link,
          ls_key_link          TYPE /bobf/s_frw_key_link,
          lt_failed_key        TYPE /bobf/t_frw_key,
          ls_context           TYPE /bobf/s_frw_ctx_val,
          ls_runtime_context   TYPE /bobf/s_frw_runtime_context,
          lv_use_check_trigger TYPE boole_d,
          lt_modification      TYPE /bobf/t_frw_modification,
          ls_modification      TYPE /bobf/s_frw_modification,
          lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
          ls_action            TYPE /bobf/s_confro_act_list,
          lx_root              TYPE REF TO cx_root,
          lv_content_cat       TYPE string,
          lv_content_name      TYPE /bobf/obm_name,
          lo_change            TYPE REF TO /bobf/cl_frw_change,
          ls_failed_val        TYPE /bobf/s_frw_validations,
          ls_val_group         TYPE /bobf/s_confro_group,   "#EC NEEDED
          lx_frw               TYPE REF TO /bobf/cx_frw_core,
          lv_external          TYPE boole_d,
          lo_change_int        TYPE REF TO /bobf/cl_frw_change.

    FIELD-SYMBOLS: <ls_val_list> TYPE /bobf/s_confro_val_list,
                   <ls_key>      TYPE /bobf/s_frw_key.



    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.
    CLEAR: eo_message,
           et_failed_val.

    IF io_change->has_changes( ) = abap_false.
      RETURN.
    ENDIF.
*  ____________________________________________________________________ *
*  get all changed nodes
    mo_conf->get_validation( IMPORTING et_val_list  = lt_val_list ).
    CHECK lt_val_list IS NOT INITIAL.
    lo_change ?= io_change.

*  create internal access object for validation
    /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf            = me
        io_conf            = mo_conf
        io_buffer          = mo_buffer
        io_change          = io_change
      RECEIVING
        eo_internal_access = lo_int_access
    ).

    IF iv_last_state_db = abap_true.
      lv_last_state = /bobf/if_conf_c=>sc_state_database.
    ELSEIF mo_conf->ms_obj-last_val_state_not_relevant = abap_true.
      lv_last_state = /bobf/if_conf_c=>sc_state_database.
    ELSE.
      lv_last_state = /bobf/if_conf_c=>sc_state_last_validated.
    ENDIF.
    lo_int_access->set_last_state(
       iv_last_state = lv_last_state ).
    lo_int_access->set_current_state(
       iv_current_state = /bobf/if_conf_c=>sc_state_current ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

    ls_context-bo_key          = mo_conf->ms_obj-bo_key.
    ls_context-root_node_key   = mo_conf->ms_obj-root_node_key.
    ls_context-check_group_key = iv_check_group_key.

    IF iv_perform_check_delta = abap_true.
      lv_use_check_trigger = abap_false.
    ELSE.
      lv_use_check_trigger = abap_true.
    ENDIF.

*  ____________________________________________________________________ *
*  perform validations
    LOOP AT lt_val_list ASSIGNING <ls_val_list>.

*    check whether to execute this one and with which trigger
      IF it_validation IS NOT INITIAL.
        READ TABLE it_validation TRANSPORTING NO FIELDS
          WITH KEY key_sort COMPONENTS key = <ls_val_list>-val_key.
        IF sy-subrc <> 0.                    " validation not provided
          IF iv_only_given_validations = abap_true.
            CONTINUE.
          ENDIF.
          lv_use_check_trigger = abap_false. " do not trigger on check
        ELSE.
          lv_use_check_trigger = abap_true.  " trigger this validation also on check
        ENDIF.
      ENDIF.

****    look at trigger nodes
      determine_triggered_val_keys( EXPORTING is_validation        = <ls_val_list>
                                              io_change            = lo_change
                                              iv_processing_mode   = val_time_to_processing_mode( iv_validation_time_context )
                                              iv_use_check_trigger = lv_use_check_trigger
                                              iv_last_state        = lv_last_state
                                    IMPORTING et_key               = lt_key
                                    CHANGING  co_message           = eo_message ).
      CHECK lt_key IS NOT INITIAL.

*  ____________________________________________________________________ *
*    filter keys regarding their node category
      IF <ls_val_list>-node_cat IS BOUND AND
         <ls_val_list>-node_cat->* IS NOT INITIAL.
        get_node_cat(
          EXPORTING
            iv_node_key      = <ls_val_list>-node_key
            it_key           = lt_key
            iv_current_state = /bobf/if_conf_c=>sc_state_current
            iv_last_state    = lv_last_state
          IMPORTING
            et_nodecat       = lt_nodecat
            et_failed_key    = lt_failed_key
            eo_message       = lo_message ).

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        CLEAR: lt_key, lt_key_tmp.
        LOOP AT lt_nodecat INTO ls_nodecat.
          ls_key-key = ls_nodecat-key.
          APPEND ls_key TO lt_key_tmp.
          AT END OF node_cat_key.
*          check if node category is valid
            READ TABLE <ls_val_list>-node_cat->*
              WITH KEY node_cat_key = ls_nodecat-node_cat_key
              TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              APPEND LINES OF lt_key_tmp TO lt_key.
            ENDIF.
            CLEAR lt_key_tmp.
          ENDAT.
        ENDLOOP.
        CHECK lt_key IS NOT INITIAL.
      ENDIF.

*  ____________________________________________________________________ *
*  implementation existing
      IF <ls_val_list>-val_class IS NOT INITIAL.
*      create context
        mo_conf->get_act(
          EXPORTING
            iv_node_key = <ls_val_list>-node_key
            iv_act_cat  = /bobf/if_conf_c=>sc_action_validate
          IMPORTING
            es_action   = ls_action ).

        ls_context-node_key = <ls_val_list>-node_key.
        ls_context-val_key  = <ls_val_list>-val_key.
        ls_context-act_key  = ls_action-act_key.

*      get validation class
        READ TABLE mt_validation
           WITH TABLE KEY val_key = <ls_val_list>-val_key
           INTO ls_val.
        IF sy-subrc <> 0.
          ls_val-val_key = <ls_val_list>-val_key.

          TRY.
              CREATE OBJECT ls_val-class TYPE (<ls_val_list>-val_class).
              INSERT ls_val INTO TABLE mt_validation.

            CATCH cx_sy_create_object_error INTO lx_root.
              lv_content_name = get_content_description(
                iv_val = abap_true
                iv_key = <ls_val_list>-val_key ).
              lv_content_cat = TEXT-003.
              CREATE OBJECT lx_frw
                EXPORTING
                  previous        = lx_root
                  textid          = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname    = <ls_val_list>-val_class
                  mv_content_cat  = lv_content_cat
                  mv_content_name = lv_content_name.
              set_configuration_error( lx_frw ).
              CONTINUE.
          ENDTRY.
        ENDIF.

*  ____________________________________________________________________ *
*      perform validation check delta
        IF lv_use_check_trigger           = abap_false AND
           <ls_val_list>-check_delta_impl = abap_true.
          ls_context-val_time = COND #( WHEN mo_conf->ms_obj-smart_validations = abap_true
                                        THEN SWITCH #( iv_validation_time_context WHEN /bobf/if_conf_c=>sc_val_time_check OR
                                                                                       /bobf/if_conf_c=>sc_val_time_check_and_determ OR
                                                                                       /bobf/if_conf_c=>sc_val_time_check_before_save
                                                                                  THEN /bobf/if_conf_c=>sc_val_time-smart_validations-final
                                                                                  ELSE /bobf/if_conf_c=>sc_val_time-smart_validations-preliminary )
                                        ELSE iv_validation_time_context ).
          lo_int_access->set_context( iv_read_allowed = abap_true ).
          TRY.
              DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

              ls_val-class->check_delta( EXPORTING io_read = lo_int_access
                                                   is_ctx  = ls_context
                                         CHANGING  ct_key  = lt_key ).

              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_val
                                                                                  iv_content_key   = <ls_val_list>-val_key
                                                                                  iv_content_class = <ls_val_list>-val_class
                                                                                  iv_node_key      = <ls_val_list>-node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'CHECK_DELTA' ) ).
          ENDTRY.
          lo_int_access->invalidate( ).
          CHECK lt_key IS NOT INITIAL.
        ENDIF.

*  ____________________________________________________________________ *
*      assure that read-nodes are in buffer
        LOOP AT <ls_val_list>-val_read->* INTO ls_val_read.
          IF ls_val_read-assoc            IS NOT INITIAL AND
             ls_val_read-assoc->assoc_key IS NOT INITIAL.
*        association defined from node to be validated to read-node
*        -> retrieve keys of read-nodes
            retrieve_by_association(
              EXPORTING
                iv_node_key    = <ls_val_list>-node_key
                it_key         = lt_key
                iv_association = ls_val_read-assoc->assoc_key
                iv_state       = /bobf/if_conf_c=>sc_state_current
              IMPORTING
                eo_message     = lo_message
                et_key_link    = lt_key_link ).
            ASSERT ID /bobf/frw CONDITION
               /bobf/cl_tool_assert=>is_key_link_matching(
                   it_key        = lt_key
                   it_key_link   = lt_key_link )
               = abap_true.

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            CLEAR ls_node_load.
            LOOP AT lt_key_link INTO ls_key_link.
              IF ls_node_load-node NE ls_val_read-assoc->target_node_key
              OR ls_node_load-key  NE ls_key_link-target_key.
                ls_node_load-node = ls_val_read-assoc->target_node_key.
                ls_node_load-key  = ls_key_link-target_key.
                INSERT ls_node_load INTO TABLE lt_node_unsorted.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDLOOP.

*      load nodes
        IF lt_node_unsorted IS NOT INITIAL.
          lt_node_load = lt_node_unsorted.
          DELETE ADJACENT DUPLICATES FROM lt_node_load.
          do_loading(
            EXPORTING
              it_node         = lt_node_load
              iv_check_buf    = abap_true
              iv_reload       = abap_false
              iv_load_data    = abap_true
              iv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree
              io_change       = io_change
            IMPORTING
              eo_message      = lo_message ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
          CLEAR: lt_node_load,
                 lt_node_unsorted.
        ENDIF.

*  ____________________________________________________________________ *
*  perform validation check

        IF <ls_val_list>-check_impl = abap_true.
          ls_context-val_time = COND #( WHEN mo_conf->ms_obj-smart_validations = abap_true
                                        THEN SWITCH #( iv_validation_time_context WHEN /bobf/if_conf_c=>sc_val_time_check OR
                                                                                       /bobf/if_conf_c=>sc_val_time_check_and_determ OR
                                                                                       /bobf/if_conf_c=>sc_val_time_check_before_save
                                                                                  THEN /bobf/if_conf_c=>sc_val_time-smart_validations-final
                                                                                  ELSE /bobf/if_conf_c=>sc_val_time-smart_validations-preliminary )
                                        ELSE iv_validation_time_context ).
          lo_int_access->set_context( iv_read_allowed = abap_true ).
          TRY.
              lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

              ls_val-class->check( EXPORTING io_read = lo_int_access
                                             is_ctx  = ls_context
                                   CHANGING  ct_key  = lt_key ).

              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_val
                                                                                  iv_content_key   = <ls_val_list>-val_key
                                                                                  iv_content_class = <ls_val_list>-val_class
                                                                                  iv_node_key      = <ls_val_list>-node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'CHECK' ) ).
          ENDTRY.
          lo_int_access->invalidate( ).
          CHECK lt_key IS NOT INITIAL.
        ENDIF.

*  ____________________________________________________________________ *
*  perform validation execution
        CLEAR: lt_failed_key,
               lo_message,
               lo_message_int.
        ls_context-val_time = COND #( WHEN mo_conf->ms_obj-smart_validations = abap_true
                                      THEN SWITCH #( iv_validation_time_context WHEN /bobf/if_conf_c=>sc_val_time_check OR
                                                                                     /bobf/if_conf_c=>sc_val_time_check_and_determ OR
                                                                                     /bobf/if_conf_c=>sc_val_time_check_before_save
                                                                                THEN /bobf/if_conf_c=>sc_val_time-smart_validations-final
                                                                                ELSE /bobf/if_conf_c=>sc_val_time-smart_validations-preliminary )
                                      ELSE iv_validation_time_context ).
        lo_int_access->set_context( iv_read_allowed = abap_true ).

        TRY.
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ).

            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lib_enqueue_context_push_keys( iv_node_key = ls_context-node_key
                                           it_key      = lt_key ).

            ls_val-class->execute( EXPORTING is_ctx        = ls_context
                                             it_key        = lt_key
                                             io_read       = lo_int_access
                                   IMPORTING et_failed_key = lt_failed_key
                                             eo_message    = lo_message ).

            lib_enqueue_context_pop( ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = lt_key
                                                                                     it_key_subset = lt_failed_key ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>failed_key_message( io_message    = lo_message
                                                                                          it_failed_key = lt_failed_key ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_val
                                                                                iv_content_key   = <ls_val_list>-val_key
                                                                                iv_content_class = <ls_val_list>-val_class
                                                                                iv_node_key      = <ls_val_list>-node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'EXECUTE' ) ).
          CLEANUP.
            lib_enqueue_context_pop( ).
        ENDTRY.
        lo_int_access->invalidate( ).
      ENDIF. " validation class existing

*    check for pseudo validation for delegation objects
      IF mo_conf->ms_last_node-node_key <> <ls_val_list>-node_key.
        mo_conf->get_node( <ls_val_list>-node_key ).
      ENDIF.
      IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
        TRY.
            lo_delegation = get_delegation( <ls_val_list>-node_key ).
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_delegation->check_consistency(
              EXPORTING
                iv_node_key    = <ls_val_list>-node_key
                it_key         = lt_key
                iv_check_scope = /bobf/if_frw_c=>sc_scope_substructure
              IMPORTING
                eo_message     = lo_message ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        IF lo_message IS BOUND.
          lo_message->get_messages(
            EXPORTING iv_severity = /bobf/cm_frw=>co_severity_error
            IMPORTING et_message  = lt_message ).
          IF lt_message IS NOT INITIAL.
            lt_failed_key = lt_key.
          ENDIF.
        ENDIF.
      ENDIF.

*    fill list of failed validations for later consistency group calculation
      ls_failed_val-val_key = <ls_val_list>-val_key.
      LOOP AT lt_failed_key ASSIGNING <ls_key>.
        ls_failed_val-key = <ls_key>-key.
        INSERT ls_failed_val INTO TABLE et_failed_val.
      ENDLOOP.

*    set context
      create_durable_msg_container( CHANGING co_message = lo_message ).
      IF lo_message IS BOUND.
        lo_message_int ?= lo_message.
        ls_runtime_context-bo_key      = mo_conf->ms_obj-bo_key.
        ls_runtime_context-node_key    = <ls_val_list>-node_key.
        ls_runtime_context-act_key     = ls_context-act_key.
        ls_runtime_context-val_key     = ls_context-val_key.
        ls_runtime_context-consistency = iv_consistency.
        lo_message_int->set_context( is_context = ls_runtime_context  it_key = lt_key ).
      ENDIF.

      IF /bobf/cl_frw_intrnl_msg_mode=>is_message_mode_durable( ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

*  ____________________________________________________________________ *
*    update validation node
      IF NOT /bobf/cl_frw_intrnl_msg_mode=>is_message_mode_durable( ).
        CLEAR lt_modification.

        mo_conf->get_assoc(
          EXPORTING
            iv_node_key   = <ls_val_list>-node_key
            iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_message
            iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
          IMPORTING
            es_assoc      = ls_assoc_conf ).
        IF ls_assoc_conf IS NOT INITIAL.
          TRY.
              mo_buffer->retrieve_by_association(
                EXPORTING
                  iv_node_key        = <ls_val_list>-node_key
                  it_key             = lt_key
                  iv_association     = ls_assoc_conf-assoc_key
                  iv_state           = /bobf/if_conf_c=>sc_state_current
                  io_change          = io_change
                  iv_fill_failed_key = abap_false
                IMPORTING
                  et_target_key      = lt_message_key ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          IF lt_message_key IS NOT INITIAL.
            CLEAR lt_failed_key.
            TRY.
                mo_buffer->retrieve(
                  EXPORTING
                    iv_node_key       = ls_assoc_conf-target_node_key
                    it_key            = lt_message_key
                    iv_state          = /bobf/if_conf_c=>sc_state_current
                    iv_fill_data      = abap_true
                    io_change         = io_change
                  IMPORTING
                    et_data           = lt_message ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            ls_modification-change_mode = /bobf/if_frw_c=>sc_modify_delete.
            ls_modification-node        = ls_assoc_conf-target_node_key.
            LOOP AT lt_message INTO ls_message
              WHERE val_key = <ls_val_list>-val_key.
              ls_modification-key         = ls_message-key.
              INSERT ls_modification INTO TABLE lt_modification.
            ENDLOOP.
          ENDIF.

*        insert all newly create messages from lo_message
          IF lo_message_int IS BOUND.
            lo_message_int->/bobf/if_frw_message~get_messages( IMPORTING et_message = lt_message ).
            ls_modification-node        = ls_assoc_conf-target_node_key.
            ls_modification-change_mode = /bobf/if_frw_c=>sc_modify_create.
            ls_modification-association = ls_assoc_conf-assoc_key.
            LOOP AT lt_message INTO ls_message.

*            If the debugger stops here: MS_ORIGIN_LOCATION is not provided in the validation coding!
*            This will result in the message not being displayed
              ASSERT ID /bobf/frw_error CONDITION ls_message-node_key = <ls_val_list>-node_key AND
                  ls_message-parent_key IS NOT INITIAL.

              IF ls_message-node_key = <ls_val_list>-node_key AND
                 ls_message-parent_key IS NOT INITIAL.
                CREATE DATA ls_message_r.
                MOVE-CORRESPONDING ls_message TO ls_message_r->*.
                ls_modification-key         = ls_message-key.
                ls_modification-data        = ls_message_r.
                ls_modification-source_node = ls_message-node_key.
                ls_modification-source_key  = ls_message-parent_key.
                INSERT ls_modification INTO TABLE lt_modification.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ELSE.
*        no message node existing
          ASSERT ID /bobf/frw CONDITION 0 = 1.             "#EC BOOL_OK
        ENDIF.

*      write modifications into message node
        IF lt_modification IS NOT INITIAL.
          CLEAR lo_message.
          lo_change_int ?= io_change.
          lv_external = lo_change_int->mv_external.
          lo_change_int->trace_external_changes( abap_false ).
          TRY.
              mo_buffer->modify(
              EXPORTING
                it_modification   = lt_modification
                iv_state          = /bobf/if_conf_c=>sc_state_current
                io_change         = io_change
                iv_only_transient = abap_false
              IMPORTING
                eo_message        = lo_message ).
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
          lo_change_int->trace_external_changes( lv_external ).

          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.
      ENDIF.

    ENDLOOP.

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

  ENDMETHOD.


  METHOD enqueue_context_for_int_create.
    " >>>>> draft applications only: create enqueue context for new draft root instance *created internally* (IO_MODIFY)
    " >>>>> (*externally created* new draft root instance is covered by action validation DURABLE_LOCK_CREATE_FOR_NEW)...

    CHECK mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft.

    DATA(lt_root_create) = FILTER #( ct_create WHERE node = mo_conf->ms_obj-root_node_key ).
    CHECK lt_root_create IS NOT INITIAL.

    DATA(lo_int_access_read) = /bobf/cl_frw_int_access=>new_instance( io_bopf = me io_conf = mo_conf io_buffer = mo_buffer ).
    lo_int_access_read->set_current_state( iv_state ).
    lo_int_access_read->set_last_state( /bobf/if_conf_c=>sc_state_before_modification ).
    lo_int_access_read->set_context( iv_read_allowed = abap_true ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access_read INTO mt_access_stack INDEX 1.

    TRY.
        NEW /bobf/cl_lib_v_new_dura_lock( )->/bobf/if_frw_validation~execute( EXPORTING is_ctx        = VALUE #( bo_key        = mo_conf->ms_obj-bo_key
                                                                                                                 root_node_key = mo_conf->ms_obj-root_node_key
                                                                                                                 node_key      = mo_conf->ms_obj-root_node_key )
                                                                                        it_key        = CORRESPONDING #( lt_root_create )
                                                                                        io_read       = lo_int_access_read
                                                                              IMPORTING eo_message    = DATA(lo_message)
                                                                                        et_failed_key = DATA(lt_failed_key) ).
      CATCH BEFORE UNWIND cx_root INTO DATA(lx_root) ##catch_all.
        set_application_error( lx_root ).
    ENDTRY.

    lo_int_access_read->invalidate( ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

    collect_messages( EXPORTING io_message = lo_message CHANGING co_message = co_message ).
    LOOP AT lt_failed_key ASSIGNING FIELD-SYMBOL(<ls_failed_key>).
      DATA(ls_failed_node) = VALUE /bobf/s_frw_node( node = mo_conf->ms_obj-root_node_key key = <ls_failed_key>-key ).
      INSERT ls_failed_node INTO TABLE ct_restore.
      DELETE TABLE ct_create FROM ls_failed_node.
    ENDLOOP.
  ENDMETHOD.


  METHOD evaluate_failed_validate_keys.

    DATA lv_failed_node_key TYPE /bobf/obm_node_key.
    DATA lt_target_key      TYPE /bobf/t_frw_key.
    DATA lv_failed_key      TYPE /bobf/conf_key.

    CLEAR et_inconsistent_key.

    CHECK it_failed_val IS NOT INITIAL.

    " Get the Associations and Validations list from the config
    mo_conf->get_assoc_tab( IMPORTING et_assoc = DATA(lt_assoc) ).
    mo_conf->get_validation( IMPORTING et_val_list = DATA(lt_val_list) ).

    LOOP AT it_failed_val INTO DATA(ls_failed_val) GROUP BY ls_failed_val-val_key INTO DATA(val_key).

      LOOP AT GROUP val_key ASSIGNING FIELD-SYMBOL(<ls_failed_validations>).
        " Get the node key using the failed validation key
        lv_failed_node_key = lt_val_list[ val_key = <ls_failed_validations>-val_key ]-node_key.
        lv_failed_key = <ls_failed_validations>-key.

        " do this until you reach the node from where the consistency check was called
        DO.
          IF lv_failed_node_key = iv_node_key.
            IF line_exists( it_key[ KEY key_sort COMPONENTS key = lv_failed_key ] ).
              INSERT VALUE #( key = lv_failed_key ) INTO TABLE et_inconsistent_key.
            ENDIF.
            EXIT.
          ELSE.
            " Get the association key for the current node -> parent node
            " (using incomplete secondary key => cannot use table expression)
            READ TABLE lt_assoc ASSIGNING FIELD-SYMBOL(<ls_assoc_to_parent>)
                                WITH KEY key3 COMPONENTS source_node_key = lv_failed_node_key
                                                         assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent.
            IF sy-subrc <> 0.
              EXIT.
            ENDIF.

            " Retrieve the Instance keys for the parent node
            mo_buffer->retrieve_by_association( EXPORTING
                                                 iv_node_key    = lv_failed_node_key
                                                 it_key         = VALUE #( ( key = lv_failed_key ) )
                                                 iv_association = <ls_assoc_to_parent>-assoc_key
                                                 iv_state       = /bobf/if_conf_c=>sc_state_current
                                                IMPORTING
                                                 et_target_key  = lt_target_key ).

            IF lt_target_key IS INITIAL.
              EXIT.
            ENDIF.

            " Assign the parent node's instance key so that the check is done recursively
            lv_failed_key = lt_target_key[ 1 ]-key.

            " Get the node key of the Parent using the association key
            lv_failed_node_key = <ls_assoc_to_parent>-target_node_key.
          ENDIF.
        ENDDO.
      ENDLOOP.
    ENDLOOP.

    " There can be duplicates when the consistency check calling node has multiple instances
    " that has to be checked for consistency, the check is done recursively instance by instance,
    " In other words, just delete the duplicates
    SORT et_inconsistent_key.
    DELETE ADJACENT DUPLICATES FROM et_inconsistent_key.

  ENDMETHOD.


  METHOD execute_action.
    CONSTANTS:
      lc_undefined TYPE abap_bool VALUE 'U'.
    DATA:
      lv_content_name           TYPE /bobf/obm_name,
      lx_frw                    TYPE REF TO /bobf/cx_frw_core,
      lt_failed_key             TYPE /bobf/t_frw_key,
      lx_root                   TYPE REF TO cx_root,
      lx_int_contract_violation TYPE REF TO /bobf/cx_frw_int_cntrct_violtn,
      lv_application_info       TYPE string.

    CLEAR: et_failed_key, et_data, eo_message, ev_static_action_failed, et_data_link.

    TEST-SEAM get_int_access.
      DATA(lo_int_access) = /bobf/cl_frw_int_access=>new_instance( io_bopf   = me
                                                                   io_conf   = mo_conf
                                                                   io_buffer = mo_buffer
                                                                   io_change = io_change ).
    END-TEST-SEAM.

    IF is_conf-edit_mode = /bobf/if_conf_c=>sc_edit_read_only OR
       is_conf-edit_mode = /bobf/if_conf_c=>sc_edit_shared.
      lo_int_access->set_edit_mode( is_conf-edit_mode ).
    ELSE.
      lo_int_access->set_edit_mode( /bobf/if_conf_c=>sc_edit_exclusive ).
    ENDIF.
    lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
    lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
    IF mt_access_stack IS NOT INITIAL.
      READ TABLE mt_access_stack INTO DATA(lo_int_access2) INDEX 1.
      DATA(lv_allowed) = lo_int_access2->mv_process_immediately_allowed.
    ELSE.
      lv_allowed = abap_true.
    ENDIF.
    lo_int_access->set_context(
       is_action                      = is_context
       iv_read_allowed                = abap_true
       iv_modify_allowed              = abap_true
       iv_process_immediately_allowed = lv_allowed
       iv_within_loading              = iv_within_loading ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

*  get action class
    READ TABLE mt_action WITH TABLE KEY act_key = is_conf-act_key INTO DATA(ls_act_class).
    IF sy-subrc <> 0.
      ls_act_class-act_key = is_conf-act_key.

      TRY.
          CREATE OBJECT ls_act_class-class TYPE (is_conf-act_class).

        CATCH cx_sy_create_object_error INTO lx_root.
          lv_content_name = get_content_description(
            iv_act = abap_true
            iv_key = is_conf-act_key ).
          CREATE OBJECT lx_frw
            EXPORTING
              previous        = lx_root
              textid          = /bobf/cx_frw_core=>sc_no_instance
              mv_classname    = is_conf-act_class
              mv_content_name = lv_content_name
              mv_content_cat  = CONV #( TEXT-000 ).
          set_configuration_error( lx_frw ).
      ENDTRY.

      INSERT ls_act_class INTO TABLE mt_action.
    ENDIF.


    IF is_conf-act_cardinality = /bobf/if_conf_c=>sc_act_card_static.
      ev_static_action_failed = lc_undefined. "pre-set a dummy value for the parameter, so we can later check if the implementation knows about it
    ENDIF.

    TRY.

        DATA(lv_prev_privileged_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
        lib_enqueue_context_push_keys( iv_node_key = is_context-node_key
                                       it_key      = ct_key ).
        TRY.
            TEST-SEAM call_action_impl.

              IF is_conf-export_param = /bobf/if_conf_c=>sc_action_export_param_type.
                " action has export parameter type, create result type to avoid a dump
                " in case of et_data has not the expected type
                DATA lr_result_data TYPE REF TO data.
                IF mo_conf->ms_obj-is_rap_bo = abap_true AND is_conf-export_param_cds_abstr_entity IS NOT INITIAL.
                  CREATE DATA lr_result_data TYPE STANDARD TABLE OF (is_conf-export_param_cds_abstr_entity).
                ELSEIF is_conf-export_param_tt IS NOT INITIAL.
                  CREATE DATA lr_result_data TYPE (is_conf-export_param_tt).
                ELSE.
                  CREATE DATA lr_result_data TYPE STANDARD TABLE OF (is_conf-export_param_s).
                ENDIF.
                FIELD-SYMBOLS <lt_result_data> TYPE ANY TABLE.
                ASSIGN lr_result_data->* TO <lt_result_data>.

                ls_act_class-class->execute( EXPORTING is_ctx                  = is_context
                                                       it_key                  = ct_key
                                                       io_read                 = lo_int_access
                                                       io_modify               = lo_int_access
                                                       is_parameters           = is_parameter
                                             IMPORTING eo_message              = eo_message
                                                       et_failed_key           = lt_failed_key
                                                       ev_static_action_failed = ev_static_action_failed
                                                       et_data                 = <lt_result_data>
                                                       et_data_link            = et_data_link ).

                "check if et_data has the expected type:
                DATA lr_descr_ref TYPE REF TO cl_abap_datadescr.
                lr_descr_ref ?= cl_abap_typedescr=>describe_by_data_ref( lr_result_data ).
                IF lr_descr_ref->applies_to_data( p_data = et_data ) = abap_true.
                  APPEND LINES OF <lt_result_data> TO et_data.
                ENDIF.

              ELSEIF is_conf-export_param = /bobf/if_conf_c=>sc_action_export_param_node
                 AND is_conf-export_param_bo = mo_conf->ms_obj-bo_key
                 AND is_conf-export_param_nd IS NOT INITIAL.

                " >>>>> create and supply appropriate node result type to avoid dumps. e.g. caller doesn't need and doesn't supply ET_DATA.
                " >>>>> this is done for the 99% use cases, where the result node is part of the same BO...

                IF mo_conf->ms_last_node-node_key <> is_conf-export_param_nd.
                  mo_conf->get_node( is_conf-export_param_nd ).
                ENDIF.
                DATA lr_node_data TYPE REF TO data.
                CREATE DATA lr_node_data TYPE (mo_conf->ms_last_node-data_type).
                DATA lr_exporting_data TYPE REF TO data.
                CREATE DATA lr_exporting_data LIKE LINE OF et_data.
                ASSIGN lr_exporting_data->* TO FIELD-SYMBOL(<ls_exporting_data>).
                IF CAST cl_abap_datadescr( cl_abap_typedescr=>describe_by_data_ref( lr_node_data ) )->applies_to_data( <ls_exporting_data> ) = abap_true.
                  " ET_DATA is appropriate...
                  ls_act_class-class->execute( EXPORTING is_ctx                  = is_context
                                                         it_key                  = ct_key
                                                         io_read                 = lo_int_access
                                                         io_modify               = lo_int_access
                                                         is_parameters           = is_parameter
                                               IMPORTING eo_message              = eo_message
                                                         et_failed_key           = lt_failed_key
                                                         ev_static_action_failed = ev_static_action_failed
                                                         et_data                 = et_data
                                                         et_data_link            = et_data_link ).
                ELSE.
                  " ET_DATA is not appropriate => create and supply appropriate table type...
                  DATA ltr_node_data TYPE REF TO data.
                  CREATE DATA ltr_node_data TYPE (mo_conf->ms_last_node-data_table_type).
                  FIELD-SYMBOLS <lt_node_data> TYPE ANY TABLE.
                  ASSIGN ltr_node_data->* TO <lt_node_data>.
                  ls_act_class-class->execute( EXPORTING is_ctx                  = is_context
                                                         it_key                  = ct_key
                                                         io_read                 = lo_int_access
                                                         io_modify               = lo_int_access
                                                         is_parameters           = is_parameter
                                               IMPORTING eo_message              = eo_message
                                                         et_failed_key           = lt_failed_key
                                                         ev_static_action_failed = ev_static_action_failed
                                                         et_data                 = <lt_node_data>
                                                         et_data_link            = et_data_link ).
                ENDIF.

              ELSE.

                ls_act_class-class->execute( EXPORTING is_ctx                  = is_context
                                                       it_key                  = ct_key
                                                       io_read                 = lo_int_access
                                                       io_modify               = lo_int_access
                                                       is_parameters           = is_parameter
                                             IMPORTING eo_message              = eo_message
                                                       et_failed_key           = lt_failed_key
                                                       ev_static_action_failed = ev_static_action_failed
                                                       et_data                 = et_data
                                                       et_data_link            = et_data_link ).

              ENDIF.

            END-TEST-SEAM.

            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = ct_key
                                                                                     it_key_subset = lt_failed_key ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_check( eo_message ).

          CLEANUP.
            lib_enqueue_context_pop( ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).
        ENDTRY.
        lib_enqueue_context_pop( ).
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).

      CATCH /bobf/cx_frw_int_cntrct_violtn INTO lx_int_contract_violation.
        " if this is reached, the /bobf/cl_frw_error_state is inconsistent.
        " Forward the internal no_check exception, such that it can be turned into /bobf/cx_frw_contract_violation at the API boundary.
        " Do not just re-raise lx_int_contract_violation. This would change the raise location.
        RAISE EXCEPTION TYPE /bobf/cx_frw_int_cntrct_violtn EXPORTING previous = lx_int_contract_violation.

      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                            iv_content_cat   = /bobf/if_conf_c=>sc_content_act
                                                                            iv_content_key   = is_conf-act_key
                                                                            iv_content_class = is_conf-act_class
                                                                            iv_node_key      = is_conf-node_key
                                                                            io_configuration = mo_conf
                                                                            iv_method_name   = 'EXECUTE' ) ).
    ENDTRY.


*  append only failed keys of the basic action
    IF iv_is_base_action = abap_true.
      APPEND LINES OF lt_failed_key TO et_failed_key.
*  failed keys of the basic action must not be in the IT_KEY of the post enhancement actions
      LOOP AT lt_failed_key INTO DATA(ls_failed_key).
        DELETE ct_key USING KEY key_sort WHERE key = ls_failed_key-key.
      ENDLOOP.

    ENDIF.

*  check for undone modifications and flush
    IF lo_int_access->mt_modification IS NOT INITIAL.

      TRY.
          lv_prev_privileged_mode = /bobf/cl_frw_authority_context=>set_privileged_mode( ).
          lo_int_access->end_modify( ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_prev_privileged_mode ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                              iv_content_cat   = /bobf/if_conf_c=>sc_content_act
                                                                              iv_content_key   = is_conf-act_key
                                                                              iv_content_class = is_conf-act_class
                                                                              iv_node_key      = is_conf-node_key
                                                                              io_configuration = mo_conf
                                                                              iv_method_name   = 'FRW_END_MODIFY' ) ).
      ENDTRY.
    ENDIF.

    "EV_STATIC_ACTION_FAILED has been introduced after many implementations of the interface method
    "already existed.  We have to check if the action implementation is aware of the parameter.
    IF ev_static_action_failed = lc_undefined.
      IF mo_conf->ms_obj-smart_validations = abap_true.
        lv_content_name = get_content_description( iv_act = abap_true  iv_key = is_conf-act_key ).
        lv_application_info = lcl_error_provider=>get_text_static_action_fail(
              iv_content_key      = is_conf-act_key
              iv_node_key         = is_conf-node_key
              iv_content_name     = lv_content_name
              iv_content_class    = CONV #( is_conf-act_class )
              io_configuration    = mo_conf ).
        CREATE OBJECT lx_frw
          EXPORTING
            previous                   = lx_root
            textid                     = /bobf/cx_frw_core=>sc_static_action_fail_not_set
            mv_application_information = lv_application_info.
        set_application_error( lx_frw ).
      ELSE.
        IF eo_message IS BOUND.
          eo_message->get_messages( EXPORTING iv_severity = /bobf/cm_frw=>co_severity_error
                                    IMPORTING et_message  = DATA(lt_local_message) ).
        ENDIF.
        IF lt_local_message IS NOT INITIAL.
          ev_static_action_failed = abap_true.
        ELSE.
          io_change->get_changes( EXPORTING iv_failed       = abap_true
                                  IMPORTING et_change       = DATA(lt_failed_local_change) ).
          ev_static_action_failed = boolc( lt_failed_local_change IS NOT INITIAL ).
        ENDIF.
      ENDIF.
    ENDIF.

    collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                      CHANGING  co_message = eo_message ).
    lo_int_access->invalidate( ).
    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.

    DELETE mt_access_stack INDEX 1.

  ENDMETHOD.


  METHOD filter_consistency_groups.

    DATA: lt_group         TYPE /bobf/t_frw_group,
          ls_group         TYPE /bobf/s_frw_group,
          ls_group2        TYPE /bobf/s_frw_group,
          ls_groupconf     TYPE /bobf/s_confro_group,
          lo_int_access    TYPE REF TO /bobf/cl_frw_int_access,
          lt_key           TYPE /bobf/t_frw_key,
          ls_key           TYPE /bobf/s_frw_key,
          lt_status_values TYPE /bobf/t_frw_status_value,
          ls_status_value  TYPE /bobf/s_frw_status_value,
          lv_content_cat   TYPE string,
          lx_frw           TYPE REF TO /bobf/cx_frw_core,
          lx_root          TYPE REF TO cx_root.

    CHECK ct_group IS NOT INITIAL
      AND mo_conf->ms_obj-status_class IS NOT INITIAL.

* ___________________________________________________________________________ *
* create status adapter access

    /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf            = me
        io_conf            = mo_conf
        io_buffer          = mo_buffer
      RECEIVING
        eo_internal_access = lo_int_access
    ).

    lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).
    lo_int_access->set_last_state(    iv_last_state = /bobf/if_conf_c=>sc_state_current ).
    lo_int_access->set_context(
      EXPORTING
        iv_read_allowed   = abap_true ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

* get status adapter
    IF mo_sam IS NOT BOUND.
      TRY.
          CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
            EXPORTING
              iv_bo_key = mo_conf->ms_obj-bo_key.

        CATCH BEFORE UNWIND cx_sy_create_object_error INTO lx_root.
          lv_content_cat = TEXT-004.
          CREATE OBJECT lx_frw
            EXPORTING
              previous       = lx_root
              textid         = /bobf/cx_frw_core=>sc_no_instance
              mv_classname   = mo_conf->ms_obj-status_class
              mv_content_cat = lv_content_cat.
          set_application_error( lx_frw ).
      ENDTRY.
      ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
    ENDIF.

* ___________________________________________________________________________ *
* read status
    lt_group = ct_group.
    LOOP AT lt_group INTO ls_group.

      ls_key-key = ls_group-key.
      APPEND ls_key TO lt_key.

      AT END OF group_key.
        mo_conf->get_group(
          EXPORTING
            iv_group_key = ls_group-group_key
          IMPORTING
            es_group     = ls_groupconf ).

        TRY.
            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            mo_sam->get_consistency_status(
              EXPORTING
                iv_node_key      = ls_groupconf-node_key
                iv_sta_var_key   = ls_groupconf-sta_var_key
                it_key           = lt_key
                io_read          = lo_int_access
              IMPORTING
                et_status_values = lt_status_values ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

*     filter ct_group with results from lt_status_value
        LOOP AT ct_group INTO ls_group2
          WHERE group_key = ls_group-group_key.

          READ TABLE lt_status_values INTO ls_status_value
            WITH KEY key = ls_group2-key.
          IF sy-subrc <> 0 OR ls_status_value-status_value = ls_group2-status_value.
            DELETE ct_group.
          ENDIF.
        ENDLOOP.

        CLEAR lt_key.
      ENDAT.

    ENDLOOP.

    lo_int_access->invalidate( ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

  ENDMETHOD.


  METHOD filter_out_unnecessary_actkeys.

** no performance benefit...
*    CHECK it_all_keys IS NOT INITIAL.
*    CHECK /bobf/cl_frw_intrnl_msg_mode=>is_message_mode_durable( ).

    " some actions will not return STATE messages => no need to invalidate their message context
    IF is_context-act_cat = /bobf/if_conf_c=>sc_action_unlock OR
       is_context-act_cat = /bobf/if_conf_c=>sc_action_lock.
      rt_key = VALUE #( ).
    ELSE.
      rt_key = it_all_keys.
    ENDIF.

  ENDMETHOD.


  METHOD filter_out_unnecessary_detkeys.

    CHECK /bobf/cl_frw_intrnl_msg_mode=>is_message_mode_durable( ).
    CHECK it_all_keys IS NOT INITIAL.

    " Remark: It has also no sense to perform invalidations for determinations before retrieve
    " because in this read-time it has no sense to produce state messages.
    " This is solved directly in the method do_determinations_retrieve so that no key is passed
    " to the method set_context of the message class.

    " For certain dets/vals/actions we know that they will not return messages.
    " So, we do not need to invalidate the messages for the given keys
    IF io_det_class IS BOUND.
      DATA(lv_determination_class_name) = cl_abap_classdescr=>get_class_name( io_det_class ).

      CASE lv_determination_class_name+7. " +7 for skipping the letters '\CLASS='
        WHEN /bobf/if_conf_def_classes_c=>gc_cl_lib_dura_lock_clean OR
             /bobf/if_conf_def_classes_c=>gc_cl_libclass_draft_act_prop OR
             /bobf/if_conf_def_classes_c=>gc_cl_lib_draft_admi.
          RETURN. " Return empty rt_key
      ENDCASE.
    ENDIF.

    rt_key = it_all_keys.

  ENDMETHOD.


  METHOD filter_unauthorised_prop_keys.
    DATA lo_auth_message_dummy TYPE REF TO /bobf/if_frw_message.

    mo_authority_handler->check_authority( EXPORTING io_change        = /bobf/cl_frw_factory=>get_change( )
                                                     is_ctx           = VALUE #( activity            = /bobf/cl_frw_authority_check=>sc_activity-display
                                                                                 activity_supplement = /bobf/cl_frw_authority_check=>sc_activity_supplement-retrieve_property
                                                                                 bo_service          = space
                                                                                 node_key            = iv_node_key )
                                                     iv_cleanse_keys  = abap_true
                                                     io_bopf          = me
                                                     io_buffer        = mo_buffer
                                                     iv_last_state    = /bobf/if_conf_c=>sc_state_database
                                                     iv_current_state = /bobf/if_conf_c=>sc_state_current
                                           CHANGING  ct_access_stack  = mt_access_stack
                                                     ct_key           = ct_key
                                                     co_message       = lo_auth_message_dummy ).
  ENDMETHOD.


  METHOD get_change_save.

    IF it_root_key IS INITIAL.

      ro_change = mo_change_save.

    ELSE.

      " create unique and sorted copy of IT_ROOT_KEY:
      DATA(lt_root_key_unique) = it_root_key.
      SORT lt_root_key_unique BY key.
      DELETE ADJACENT DUPLICATES FROM lt_root_key_unique COMPARING key.

      TRY.
          ro_change = VALUE #( mt_change_save[ root_keys = lt_root_key_unique ]-change ).

        CATCH cx_sy_itab_line_not_found.

**** Don't know why we should support a "strange" access pattern --> to be removed
* <<<
          " Dealing with a strange access pattern, try best effort to support this
          ro_change = create_change_save( it_root_key ).
* >>>
*          CLEAR ro_change.
****

      ENDTRY.

    ENDIF.

  ENDMETHOD.


  METHOD get_cleanup_mode.
    rv_cleanup_mode = mv_cleanup_mode.
  ENDMETHOD.


  METHOD get_content_description.

    DATA: lo_conf_bopf TYPE REF TO /bobf/if_frw_service_layer,
          lo_message   TYPE REF TO /bobf/if_frw_message,    "#EC NEEDED
          ls_key       TYPE /bobf/s_frw_key,
          lt_key       TYPE /bobf/t_frw_key,
          lt_act       TYPE /bobf/t_conf_act_list,
          ls_act       TYPE /bobf/s_conf_act_list,
          lt_assoc     TYPE /bobf/t_conf_assoc,
          ls_assoc     TYPE /bobf/s_conf_assoc,
          lt_det       TYPE /bobf/t_conf_det_list,
          ls_det       TYPE /bobf/s_conf_det_list,
          lt_val       TYPE /bobf/t_conf_val_list,
          ls_val       TYPE /bobf/s_conf_val_list,
          lt_query     TYPE /bobf/t_conf_query,
          ls_query     TYPE /bobf/s_conf_query,
          lt_node      TYPE /bobf/t_conf_node,
          ls_node      TYPE /bobf/s_conf_node,
          lt_vset      TYPE /bobf/t_conf_value_set,
          ls_vset      TYPE /bobf/s_conf_value_set,
          lt_bo        TYPE /bobf/t_conf_bo,                "#EC NEEDED
          lt_obj       TYPE /bobf/t_conf_obj,               "#EC NEEDED
          lx_root      TYPE REF TO cx_root.


    TRY.
        lo_conf_bopf = /bobf/cl_frw_factory=>get_bopf( iv_bo_key = /bobf/if_conf_obj_c=>sc_bo_key ).
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

*  first retrieve root node to trigger loading of configuration BO
    ls_key-key = mo_conf->ms_obj-bo_key.
    APPEND ls_key TO lt_key.

    lo_conf_bopf->retrieve(
      EXPORTING
        iv_node_key = /bobf/if_conf_obj_c=>sc_node-root
        it_key      = lt_key
      IMPORTING
        et_data     = lt_bo
        eo_message  = lo_message ).

    lo_conf_bopf->retrieve_by_association(
      EXPORTING
        iv_node_key    = /bobf/if_conf_obj_c=>sc_node-root
        it_key         = lt_key
        iv_association = /bobf/if_conf_obj_c=>sc_association-root-to_active_version
        iv_fill_data   = abap_true
      IMPORTING
        et_data        = lt_obj
        eo_message     = lo_message ).

    CLEAR lt_key.

    ls_key-key = iv_key.
    APPEND ls_key TO lt_key.

    IF iv_act = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-action
          it_key      = lt_key
        IMPORTING
          et_data     = lt_act
          eo_message  = lo_message ).

      READ TABLE lt_act INTO ls_act INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_act-act_name.
      ENDIF.

    ELSEIF iv_assoc = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-association
          it_key      = lt_key
        IMPORTING
          et_data     = lt_assoc
          eo_message  = lo_message ).

      READ TABLE lt_assoc INTO ls_assoc INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_assoc-assoc_name.
      ENDIF.

    ELSEIF iv_det = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-determination
          it_key      = lt_key
        IMPORTING
          et_data     = lt_det
          eo_message  = lo_message ).

      READ TABLE lt_det INTO ls_det INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_det-det_name.
      ENDIF.

    ELSEIF iv_val = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-validation
          it_key      = lt_key
        IMPORTING
          et_data     = lt_val
          eo_message  = lo_message ).

      READ TABLE lt_val INTO ls_val INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_val-val_name.
      ENDIF.

    ELSEIF iv_query = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-query
          it_key      = lt_key
        IMPORTING
          et_data     = lt_query
          eo_message  = lo_message ).

      READ TABLE lt_query INTO ls_query INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_query-query_name.
      ENDIF.

    ELSEIF iv_node = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-node
          it_key      = lt_key
        IMPORTING
          et_data     = lt_node
          eo_message  = lo_message ).

      READ TABLE lt_node INTO ls_node INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_node-node_name.
      ENDIF.

    ELSEIF iv_vset = abap_true.
      lo_conf_bopf->retrieve(
        EXPORTING
          iv_node_key = /bobf/if_conf_obj_c=>sc_node-value_set
          it_key      = lt_key
        IMPORTING
          et_data     = lt_vset
          eo_message  = lo_message ).

      READ TABLE lt_vset INTO ls_vset INDEX 1.
      IF sy-subrc = 0.
        ev_content_description = ls_vset-vset_name.
      ENDIF.


    ENDIF.

  ENDMETHOD.


  METHOD get_delegation.

    DATA: ls_delegation TYPE /bobf/s_frw_delegation,
          lo_int_access TYPE REF TO /bobf/cl_frw_int_access,
          lt_node       TYPE /bobf/t_confro_node.

    FIELD-SYMBOLS: <ls_node> TYPE /bobf/s_confro_node.

    READ TABLE mt_delegation
      WITH KEY node_key = iv_node_key
      INTO ls_delegation.

    IF sy-subrc = 0.
*   delegation class found
      eo_delegation = ls_delegation-delegation.
    ELSE.
*   get instance of delegation class
      IF mo_conf->ms_last_node-node_key <> iv_node_key.
        mo_conf->get_node( iv_node_key = iv_node_key ).
      ENDIF.

      "building the delegation context
      DATA(lo_previous_delegation_ctx) = /bobf/cl_frw_factory=>get_delegation_contxt_for_bopf( io_bopf_handle = me ).
      DATA(lo_delegation_context) = NEW /bobf/cl_frw_delegation_ctx(
        io_previous        = lo_previous_delegation_ctx
        is_local_embedding = VALUE #(
            hosting_bo_name = mo_conf->ms_obj-bo_name
            hosting_bo_key = mo_conf->ms_obj-bo_key
            delegation_node_esr_prefix = mo_conf->ms_last_node-node_esr_prefix
            delegation_node_name = mo_conf->ms_last_node-node_name
            delegation_node_key = mo_conf->ms_last_node-delegation_root_node_key ) ).


      CALL METHOD (mo_conf->ms_last_node-delegation_class)=>/bobf/if_frw_delegation~get_instance
        EXPORTING
          iv_host_bo_key        = mo_conf->ms_obj-bo_key
          iv_node_key           = mo_conf->ms_last_node-delegation_root_node_key
          io_conf               = mo_conf
          io_delegation_context = lo_delegation_context
        IMPORTING
          eo_delegation         = eo_delegation.

      mo_conf->get_node_tab( IMPORTING et_node = lt_node ).
      ls_delegation-delegation = eo_delegation.
      LOOP AT lt_node ASSIGNING <ls_node>
        WHERE delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key. "#EC CI_SORTSEQ
        ls_delegation-node_key   = <ls_node>-node_key.
        INSERT ls_delegation INTO TABLE mt_delegation.
      ENDLOOP.
      APPEND eo_delegation TO mt_delegation2.

    ENDIF.

    IF eo_delegation IS NOT BOUND.
*   no delegation class found
      set_application_error( ).
    ENDIF.

* check delegation read access class
    IF mo_delegation_read IS NOT BOUND.
      /bobf/cl_frw_int_access=>new_instance(
        EXPORTING
          io_bopf            = me
          io_conf            = mo_conf
          io_buffer          = mo_buffer    " Interface to the Data Layer
        RECEIVING
          eo_internal_access = lo_int_access
      ).

      lo_int_access->set_current_state( iv_current_state = /bobf/if_conf_c=>sc_state_current ).
      lo_int_access->set_last_state( iv_last_state = /bobf/if_conf_c=>sc_state_database ).
      lo_int_access->set_context( iv_read_allowed = abap_true ).

      mo_delegation_read = lo_int_access.
    ENDIF.

  ENDMETHOD.


  METHOD get_enqueue_scope.
    rv_enqueue_scope = mv_enqueue_scope.
  ENDMETHOD.


  METHOD get_loadable_node.

    DATA: lt_start_node        TYPE /bobf/t_frw_node,
          lt_node              TYPE /bobf/t_frw_node,
          ls_node              TYPE /bobf/s_frw_node,
          ls_node2             TYPE /bobf/s_frw_node,
          lv_node              TYPE /bobf/obm_node_key,
          lt_target            TYPE /bobf/t_frw_key,
          lt_key               TYPE /bobf/t_frw_key,
          ls_key               TYPE /bobf/s_frw_key,
          ls_assoc_parent_node TYPE /bobf/s_confro_assoc,
          ls_nodeconf          TYPE /bobf/s_confro_node,
          ls_load_do           TYPE ts_load_do,
          lo_message           TYPE REF TO /bobf/if_frw_message,
          ls_node_link         TYPE /bobf/s_frw_node_key_link,
          lv_all_lockgroups    TYPE boole_d,
          lt_key_link          TYPE /bobf/t_frw_key_link,
          ls_key_link          TYPE /bobf/s_frw_key_link,
          lt_failed_node       TYPE /bobf/t_frw_node,
          lx_root              TYPE REF TO cx_root,
          lt_node_only         TYPE /bobf/t_frw_node_only.

    FIELD-SYMBOLS: <ls_load_do>  TYPE ts_load_do.

    CLEAR: et_node,
           et_node_link,
           et_failed_node,
           eo_message.

*  ____________________________________________________________________ *
*  find next loadable node
    et_node_link = CORRESPONDING #( it_node MAPPING source_node = node
                                                    source_key  = key
                                                    target_node = node
                                                    target_key  = key ).
    lt_node_only = CORRESPONDING #( it_node DISCARDING DUPLICATES ).
    LOOP AT lt_node_only INTO DATA(ls_node_only).

      mo_conf->get_node( ls_node_only-node ).
      IF mo_conf->ms_last_node-loadable = abap_true.
        " performance short-cut: avoids MAP_TO_NODE below
        et_node = CORRESPONDING #( BASE ( et_node )  FILTER #( it_node WHERE node = ls_node_only-node ) ).
        CONTINUE. " !!!
      ENDIF.

      " initialize search for loadable node:
      lt_key = CORRESPONDING #( FILTER #( it_node WHERE node = ls_node_only-node ) ).
      lv_node = ls_node_only-node.
      DO.
*        jump up the tree until a loadable node is found
        mo_conf->get_node( EXPORTING iv_node_key = lv_node
                           IMPORTING es_node     = ls_nodeconf ).

        IF ls_nodeconf-loadable = abap_true.
*          found the node -> leave the (DO) loop
          map_to_node(
            EXPORTING
              iv_node_key = lv_node
              it_key      = lt_key
            IMPORTING
              et_node     = lt_node ).
          INSERT LINES OF lt_node INTO TABLE et_node.
          EXIT.

        ELSEIF ls_nodeconf-key_inherited = abap_true.
*          node has same NodeID as parent node
          IF et_node_link IS REQUESTED.
            LOOP AT et_node_link INTO ls_node_link
              WHERE target_node = lv_node.
              DELETE et_node_link.
              ls_node_link-target_node = ls_nodeconf-parent_node_key.
              INSERT ls_node_link INTO TABLE et_node_link.
            ENDLOOP.
          ENDIF.
          lv_node = ls_nodeconf-parent_node_key.

        ELSEIF ls_nodeconf-delegation_class IS NOT INITIAL.
*          node is delegated
          READ TABLE ct_load_do ASSIGNING <ls_load_do>
            WITH KEY delegation_root_node_key = ls_nodeconf-delegation_root_node_key.
          IF sy-subrc <> 0.
            ls_load_do-delegation_root_node_key = ls_nodeconf-delegation_root_node_key.
            CLEAR ls_load_do-node.
            INSERT ls_load_do INTO TABLE ct_load_do ASSIGNING <ls_load_do>.
          ENDIF.
          INSERT LINES OF lt_node INTO TABLE <ls_load_do>-node.
          EXIT.

        ELSE.
*          get parent NodeIDs
          mo_conf->get_assoc(
            EXPORTING
              iv_node_key  = lv_node
              iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
            IMPORTING
              es_assoc     = ls_assoc_parent_node ).

          IF ls_assoc_parent_node IS NOT INITIAL.
*            jump to the parent node (check buffer first)
            IF ls_assoc_parent_node-source_node->transient                = abap_false AND
                ls_assoc_parent_node-source_node->optimized_buffer_access = abap_false.
              do_loading(
                 EXPORTING
                   iv_node_key       = lv_node
                   it_key            = lt_key
                   iv_check_buf      = abap_true
                   iv_reload         = abap_false
                   iv_load_data      = abap_false
                   iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
                   io_change         = io_change
                 IMPORTING
                   eo_message        = lo_message
                   et_failed         = lt_failed_node ).

              collect_messages( EXPORTING io_message = lo_message
                                CHANGING  co_message = eo_message ).

              LOOP AT lt_failed_node INTO ls_node.
                DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
                INSERT ls_node INTO TABLE et_failed_node.
              ENDLOOP.

            ENDIF.

            IF lt_key IS NOT INITIAL.
              TRY.
                  mo_buffer->retrieve_by_association(
                    EXPORTING
                      iv_association     = ls_assoc_parent_node-assoc_key
                      iv_node_key        = lv_node
                      it_key             = lt_key
                      iv_state           = /bobf/if_conf_c=>sc_state_current
                      io_change          = io_change
                      iv_fill_failed_key = abap_false
                    IMPORTING
                      et_target_key      = lt_target
                      et_key_link        = lt_key_link ).
                CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                  set_application_error( lx_root ).
              ENDTRY.

              ASSERT ID /bobf/frw_error CONDITION
                 /bobf/cl_tool_assert=>is_key_link_matching(
                     it_key_link   = lt_key_link
                     it_key        = lt_key
                     it_target_key = lt_target ) = abap_true.
            ENDIF.

            IF lt_target IS INITIAL.
*              no parent node found -> no keys can be loaded
              LOOP AT lt_node INTO ls_node2.
                READ TABLE et_node_link INTO ls_node_link WITH KEY
                   target_node = ls_node2-node
                   target_key  = ls_node2-key.
                ls_node2-node = ls_node_link-source_node.
                ls_node2-key  = ls_node_link-source_key.
                INSERT ls_node2 INTO TABLE et_failed_node.
              ENDLOOP.
              EXIT.
            ENDIF.

            LOOP AT lt_key_link INTO ls_key_link.
              LOOP AT et_node_link INTO ls_node_link WHERE
                  target_node = lv_node AND
                  target_key  = ls_key_link-source_key.
                DELETE et_node_link.
                ls_node_link-target_node = ls_assoc_parent_node-target_node_key.
                ls_node_link-target_key = ls_key_link-target_key.
                INSERT ls_node_link INTO TABLE et_node_link.
              ENDLOOP.
            ENDLOOP.

            lv_node = ls_assoc_parent_node-target_node_key.
            lt_key  = lt_target.
          ELSE.
*            no assoc to parent found
            set_application_error( ).
          ENDIF.
        ENDIF.
      ENDDO.

    ENDLOOP.
    DELETE ADJACENT DUPLICATES FROM et_node.

*  ____________________________________________________________________ *
*  find next all loadable subnodes of et_node
    IF iv_load_subtree  <> /bobf/if_frw_c=>sc_load_no_subtree.
      lv_all_lockgroups = abap_true.
      lt_start_node = et_node.
      CLEAR lt_key.
      LOOP AT lt_start_node INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.

        AT END OF node.
          get_loadable_subnode(
            EXPORTING
              iv_node_key       = ls_node-node
              it_key            = lt_key
              iv_all_lockgroups = lv_all_lockgroups
            IMPORTING
              et_node           = lt_node
              eo_message        = lo_message
            CHANGING
              ct_load_do        = ct_load_do ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
          INSERT LINES OF lt_node INTO TABLE et_node.
          CLEAR lt_key.
        ENDAT.

      ENDLOOP.
      DELETE ADJACENT DUPLICATES FROM et_node.
    ENDIF.

  ENDMETHOD.


  METHOD get_loadable_subnode.

*  recursive method to find all loadable subnodes

    DATA: lt_new_key TYPE /bobf/t_frw_key,
          lt_node    TYPE /bobf/t_frw_node,
          ls_node    TYPE /bobf/s_frw_node,
          ls_key     TYPE /bobf/s_frw_key,
          lt_assoc2  TYPE /bobf/t_confro_assoc2,
          ls_assoc2  TYPE /bobf/s_confro_assoc2,
          ls_load_do TYPE ts_load_do,
          lo_message TYPE REF TO /bobf/if_frw_message.

    FIELD-SYMBOLS: <ls_load_do>  TYPE ts_load_do.

    CLEAR:
      eo_message,
      et_node.

*  am I loadable? -> mark nodes as "to load"
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( iv_node_key = iv_node_key ).
    ENDIF.

    IF iv_all_lockgroups = abap_false.
*    stop if loadable group equals lockable group
      CHECK mo_conf->ms_last_node-loadgroup_eq_lockgroup = abap_false.

*    stop at lockable node
      IF mo_conf->ms_last_node-lockable = abap_true AND
         iv_recursive_call              = abap_true.
        RETURN.
      ENDIF.
    ENDIF.

*  stop at delegated node
    IF mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
      READ TABLE ct_load_do ASSIGNING <ls_load_do>
        WITH KEY delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
      IF sy-subrc <> 0.
        ls_load_do-delegation_root_node_key = mo_conf->ms_last_node-delegation_root_node_key.
        CLEAR ls_load_do-node.
        INSERT ls_load_do INTO TABLE ct_load_do ASSIGNING <ls_load_do>.
      ENDIF.

      ls_node-node = iv_node_key.
      LOOP AT it_key INTO ls_key.
        ls_node-key = ls_key-key.
        INSERT ls_node INTO TABLE <ls_load_do>-node.
      ENDLOOP.
      RETURN.
    ENDIF.

    IF mo_conf->ms_last_node-loadable = abap_true.
      map_to_node(
        EXPORTING
          iv_node_key = iv_node_key
          it_key      = it_key
        IMPORTING
          et_node     = et_node ).
    ENDIF.

*  stop if no loadable subnodes exist
    IF mo_conf->ms_last_node-loadable_subnodes = abap_false.
      RETURN.
    ENDIF.

*  find all compositions
    mo_conf->get_assoc_tab( IMPORTING et_comp = lt_assoc2 ).
    LOOP AT lt_assoc2 INTO ls_assoc2 WHERE
        source_node_key = iv_node_key
*      these framework nodes are not loadable by definition
        AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_lock
        AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_property
        AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_message
*      AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_object
        AND assoc_cat <> /bobf/if_conf_c=>sc_assoccat_status
        AND target_node->node_type <> /bobf/if_conf_c=>sc_node_type_qrtn
        AND target_node->transient = abap_false.

*    check for delegated nodes if it was touched already
*    (currently the only use case for loading delegation nodes is a cache invalidation)
      IF ls_assoc2-assoc_cat = /bobf/if_conf_c=>sc_assoccat_object.
        READ TABLE mt_delegation WITH KEY node_key = ls_assoc2-target_node_key TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
      ENDIF.

*    find keys of target nodes
      retrieve_by_association(
        EXPORTING
          iv_node_key    = iv_node_key
          it_key         = it_key
          iv_association = ls_assoc2-assoc_key
          iv_state       = /bobf/if_conf_c=>sc_state_current
          iv_buffer_only = abap_true
        IMPORTING
          et_target_key  = lt_new_key
          eo_message     = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*    call me recursively
      IF lt_new_key IS NOT INITIAL.
        get_loadable_subnode(
          EXPORTING
            iv_node_key       = ls_assoc2-target_node_key
            it_key            = lt_new_key
            iv_recursive_call = abap_true
            iv_all_lockgroups = iv_all_lockgroups
          IMPORTING
            et_node           = lt_node
            eo_message        = lo_message
          CHANGING
            ct_load_do        = ct_load_do ).

        INSERT LINES OF lt_node INTO TABLE et_node.
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD get_lockable_node.

    DATA: lt_node              TYPE          /bobf/t_frw_node,
          lt_failed_node       TYPE          /bobf/t_frw_node,
          ls_node              TYPE          /bobf/s_frw_node,
          ls_node_result       TYPE          /bobf/s_frw_node,
          lv_node              TYPE          /bobf/obm_node_key,
          lt_target            TYPE          /bobf/t_frw_key,
          lt_key               TYPE          /bobf/t_frw_key,
          lt_key_root          TYPE          /bobf/t_frw_key,
          lt_failed_key        TYPE          /bobf/t_frw_key,
          ls_key               TYPE          /bobf/s_frw_key,
          ls_assoc_parent_node TYPE          /bobf/s_confro_assoc,
          ls_nodeconf          TYPE          /bobf/s_confro_node,
          lo_change            TYPE REF TO   /bobf/if_frw_change,
          lo_delegation        TYPE REF TO   /bobf/if_frw_delegation,
          lo_message           TYPE REF TO   /bobf/if_frw_message,
          lt_node_link         TYPE TABLE OF /bobf/s_frw_node_key_link,
          ls_node_link         TYPE          /bobf/s_frw_node_key_link,
          lt_key_link          TYPE          /bobf/t_frw_key_link,
          ls_key_link          TYPE          /bobf/s_frw_key_link,
          lt_loaded_node       TYPE          /bobf/t_frw_node,
          lx_root              TYPE REF TO   cx_root.

    CLEAR:
        et_node,
        et_node_link,
        et_failed_node,
        et_loaded_node,
        eo_message.

*  ___________________________________________________________________________ *
*  if there is only one locking group defined in the whole BO (defined on ROOT node)
    IF mo_conf->ms_obj-lock_only_root = abap_true.
      LOOP AT it_node INTO ls_node.
        ls_key-key = ls_node-key.
        APPEND ls_key TO lt_key.

        AT END OF node.
          IF ls_node-node = mo_conf->ms_obj-root_node_key.
*          I'm already the root node
            ls_node_result-node      = ls_node-node.
            ls_node_link-source_node = ls_node-node.
            ls_node_link-target_node = mo_conf->ms_obj-root_node_key.
            LOOP AT lt_key INTO ls_key.
              ls_node_result-key       =
              ls_node_link-source_key  =
              ls_node_link-target_key  = ls_key-key.
              INSERT ls_node_result INTO TABLE et_node.
              INSERT ls_node_link   INTO TABLE et_node_link.
            ENDLOOP.
          ELSE.
*          I'm a subnode
            get_root_key( EXPORTING iv_node_key    = ls_node-node
                                    it_key         = lt_key
                          IMPORTING et_loaded_node = et_loaded_node
                                    et_failed_key  = lt_failed_key
                                    et_target_key  = lt_key_root
                                    et_key_link    = lt_key_link ).

            IF lt_failed_key IS NOT INITIAL.
              " try again with before image
              get_root_key( EXPORTING iv_node_key     = ls_node-node
                                      it_key          = lt_failed_key
                                      iv_before_image = abap_true
                            IMPORTING et_loaded_node  = DATA(lt_loaded_node_before)
                                      et_failed_key   = DATA(lt_failed_key_before)
                                      et_target_key   = DATA(lt_key_root_before)
                                      et_key_link     = DATA(lt_key_root_link_before) ).
              INSERT LINES OF lt_loaded_node_before   INTO TABLE et_loaded_node.
              INSERT LINES OF lt_key_root_before      INTO TABLE lt_key_root.
              INSERT LINES OF lt_key_root_link_before INTO TABLE lt_key_link.
              LOOP AT lt_failed_key_before INTO ls_key.
                ls_node-key = ls_key-key.
                INSERT ls_node INTO TABLE et_failed_node.
              ENDLOOP.
            ENDIF.

            ASSERT ID /bobf/frw_error CONDITION
               /bobf/cl_tool_assert=>is_key_link_matching(
                   it_key        = lt_key
                   it_key_link   = lt_key_link
                   it_target_key = lt_key_root ) = abap_true.

            ls_node_link-source_node = ls_node-node.
            ls_node_link-target_node = mo_conf->ms_obj-root_node_key.
            LOOP AT lt_key_link INTO ls_key_link.
              ls_node_link-source_key = ls_key_link-source_key.
              ls_node_link-target_key = ls_key_link-target_key.
              INSERT ls_node_link INTO TABLE et_node_link.
            ENDLOOP.
            ls_node_result-node = mo_conf->ms_obj-root_node_key.
            LOOP AT lt_key_root INTO ls_key.
              ls_node_result-key = ls_key-key.
              INSERT ls_node_result INTO TABLE et_node.
            ENDLOOP.
          ENDIF.
          CLEAR lt_key.
        ENDAT.
      ENDLOOP.

      DELETE ADJACENT DUPLICATES FROM et_node.
      " quit !
      RETURN.
    ENDIF.

*  ___________________________________________________________________________ *
*  if there are more than one locking group in the BO defined
    IF io_change IS BOUND.
      lo_change = io_change.
    ELSE.
      CREATE OBJECT lo_change TYPE /bobf/cl_frw_change.
    ENDIF.

    " loop at each node instance, for which the corresponding instance of its locking node shall be retrieved
    LOOP AT it_node INTO ls_node.

      " built LT_KEY which will be IT_KEY in the upcoming RBA TO_PARENT
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.

      " ET_NODE_LINK is filled from start and will be updated in each iteration with the result of the TO_PARENT RBA
      ls_node_link-source_node = ls_node-node.
      ls_node_link-source_key  = ls_node-key.
      ls_node_link-target_node = ls_node-node.
      ls_node_link-target_key  = ls_node-key.
      INSERT ls_node_link INTO TABLE et_node_link.

      AT END OF node.

        " all instances of a ceratain node are now packaged
        lv_node = ls_node-node.

        " loop TO_PARENT until we reach the common locking node for those instances
        DO.
          " get configuration of current node
          IF mo_conf->ms_last_node-node_key = lv_node.
            ls_nodeconf = mo_conf->ms_last_node.
          ELSE.
            mo_conf->get_node(
               EXPORTING iv_node_key = lv_node
               IMPORTING es_node     = ls_nodeconf ).
            IF ls_nodeconf IS INITIAL.
              ASSERT ID /bobf/frw CONDITION 0 = 1.         "#EC BOOL_OK
              RETURN.
            ENDIF.
          ENDIF.

          " if we reached the locking node, quit
          IF ls_nodeconf-lockable = abap_true.

            " update the et_node
            map_to_node(
              EXPORTING
                iv_node_key = lv_node
                it_key      = lt_key
              IMPORTING
                et_node     = lt_node ).
            INSERT LINES OF lt_node INTO TABLE et_node.
            EXIT.

          ELSEIF ls_nodeconf-key_inherited = abap_true.
            " if the current node uses the same keys than its subnode,
            " we do not need to execute the RBA TO_PARENT - we can take directly take over that keys

            " update the et_node_link result table
            IF et_node_link IS REQUESTED.
              LOOP AT et_node_link INTO ls_node_link
                WHERE target_node = lv_node.
                DELETE et_node_link.
                ls_node_link-target_node = ls_nodeconf-parent_node_key.
                APPEND ls_node_link TO lt_node_link.
              ENDLOOP.
              INSERT LINES OF lt_node_link INTO TABLE et_node_link.
              CLEAR lt_node_link.
            ENDIF.
            lv_node = ls_nodeconf-parent_node_key.

          ELSEIF ls_nodeconf-delegation_class IS NOT INITIAL.
            " we reached a delegation node - consult the delegation class
            TRY.
                lo_delegation = get_delegation( lv_node ).
                DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                lo_delegation->get_host_node_key(
                  EXPORTING
                    iv_node_key         = lv_node
                    it_key              = lt_key
                    iv_state            = /bobf/if_conf_c=>sc_state_current
                    io_read             = mo_delegation_read
                  IMPORTING
                    et_failed_key       = lt_failed_key
                    et_key_link         = lt_key_link
                    et_target_key       = lt_target
                    ev_host_node_key    = ls_assoc_parent_node-target_node_key ).
                /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            ASSERT ID /bobf/frw_error CONDITION
             /bobf/cl_tool_assert=>is_key_link_matching(
                 it_key_link   = lt_key_link
                 it_key        = lt_key
                 it_target_key = lt_target ) = abap_true.

            " update et_node_link
            IF lt_target IS INITIAL.
              " no parent node found -> no keys ca be loaded -> virtually not possible
              DELETE et_node_link USING KEY source_node WHERE source_node = ls_node-node.
              EXIT.
            ENDIF.
            IF et_node_link IS REQUESTED.
              LOOP AT lt_key_link INTO ls_key_link.
                LOOP AT et_node_link INTO ls_node_link
                  WHERE target_node = lv_node
                    AND target_key  = ls_key_link-source_key.
                  DELETE et_node_link.
                  ls_node_link-target_node = ls_assoc_parent_node-target_node_key.
                  ls_node_link-target_key  = ls_key_link-target_key.
                  APPEND ls_node_link TO lt_node_link.
                ENDLOOP.
              ENDLOOP.
              INSERT LINES OF lt_node_link INTO TABLE et_node_link.
              CLEAR lt_node_link.
            ENDIF.

            " prepare lv_node and lt_key for the next iteration
            lv_node = ls_assoc_parent_node-target_node_key.
            lt_key  = lt_target.

          ELSEIF ls_nodeconf-parent_node_key IS INITIAL.
            " exit as ROOT node is reached (only node without parent node)
            " this will always finally be reached
            CLEAR lt_key.
            EXIT.

          ELSE.

            " common case: current node is not lockable, thus execute TO_PARENT association

            " get TO_PARENT association configuration
            mo_conf->get_assoc(
              EXPORTING
                iv_node_key  = lv_node
                iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
              IMPORTING
                es_assoc     = ls_assoc_parent_node ).

            IF ls_assoc_parent_node IS NOT INITIAL.

              IF ls_assoc_parent_node-source_node->optimized_buffer_access = abap_false.
                " non-optimized buffer access

                " load the source keys and fill them into et_loaded_node (this is also an existence check)
                do_loading(
                   EXPORTING
                     iv_node_key     = lv_node
                     it_key          = lt_key
                     iv_check_buf    = abap_true
                     iv_reload       = abap_false
                     iv_load_data    = abap_false
                     iv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree
                     io_change       = lo_change
                   IMPORTING
                     et_loaded_node  = lt_loaded_node
                     et_failed       = lt_failed_node
                     eo_message      = lo_message ).
                collect_messages( EXPORTING io_message = lo_message
                                  CHANGING  co_message = eo_message ).

                " append loaded nodes to et_loaded_node
                IF lt_loaded_node  IS NOT INITIAL AND
                    et_loaded_node IS REQUESTED.
                  IF et_loaded_node IS NOT INITIAL.
                    INSERT LINES OF lt_loaded_node INTO TABLE et_loaded_node.
                  ELSE.
                    et_loaded_node = lt_loaded_node.
                  ENDIF.
                ENDIF.

                " remove the failed instance keys from lt_key (so they are excluded in the next iteration)
                LOOP AT lt_failed_node INTO ls_node.
                  DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
                ENDLOOP.

                TRY.
                    " navigate TO_PARENT: try also database and before image,
                    " if the parent node was deleted in the current transaction

                    " put result into LT_TARGET, LT_FAILED_KEY, LT_KEY_LINK
                    DATA lt_key_tmp TYPE /bobf/t_frw_key.
                    DATA lt_target_tmp TYPE /bobf/t_frw_key.
                    DATA lt_key_link_tmp TYPE /bobf/t_frw_key_link.
                    DATA lv_state TYPE /bobf/conf_state.

                    lt_key_tmp = lt_key.
                    CLEAR: lt_target, lt_key_link.

                    DO 3 TIMES.
                      CLEAR: lt_target_tmp, lt_key_link_tmp.
                      CASE sy-index.
                        WHEN 1.
                          lv_state = /bobf/if_conf_c=>sc_state_current.
                        WHEN 2.
                          lv_state = /bobf/if_conf_c=>sc_state_database.
                        WHEN 3.
                          lv_state = /bobf/if_conf_c=>sc_state_before_modification.
                      ENDCASE.
                      mo_buffer->retrieve_by_association(
                         EXPORTING
                           iv_association     = ls_assoc_parent_node-assoc_key
                           iv_node_key        = lv_node
                           it_key             = lt_key_tmp
                           iv_state           = lv_state
                           iv_fill_failed_key = abap_true
                           iv_buffer_only     = abap_true
                         IMPORTING
                           et_failed_key      = lt_failed_key
                           et_target_key      = lt_target_tmp
                           et_key_link        = lt_key_link_tmp ).
                      INSERT LINES OF lt_target_tmp   INTO TABLE lt_target.
                      INSERT LINES OF lt_key_link_tmp INTO TABLE lt_key_link.
                      IF lt_failed_key IS INITIAL.
                        EXIT. " all instances found
                      ELSE.
                        lt_key_tmp = lt_failed_key.
                      ENDIF.
                    ENDDO.


                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.

              ELSE.
                " optimized buffer access
                TRY.

                    " navigate TO_PARENT: try also database and before image,
                    " if the parent node was deleted in the current transaction

                    " put result into LT_TARGET, LT_FAILED_KEY, LT_KEY_LINK
                    lt_key_tmp = lt_key.
                    CLEAR: lt_target, lt_key_link.

                    DO 3 TIMES.
                      CLEAR: lt_target_tmp, lt_key_link_tmp.

                      CASE sy-index.
                        WHEN 1.
                          lv_state = /bobf/if_conf_c=>sc_state_current.
                        WHEN 2.
                          lv_state = /bobf/if_conf_c=>sc_state_database.
                        WHEN 3.
                          lv_state = /bobf/if_conf_c=>sc_state_before_modification.
                      ENDCASE.

                      mo_buffer->retrieve_by_association(
                        EXPORTING
                          iv_association     = ls_assoc_parent_node-assoc_key
                          iv_node_key        = lv_node
                          it_key             = lt_key_tmp
                          iv_state           = lv_state
                          io_change          = lo_change
                          iv_fill_failed_key = abap_true
                          iv_buffer_only     = abap_false
                        IMPORTING
                          et_failed_key      = lt_failed_key
                          et_target_key      = lt_target_tmp
                          et_key_link        = lt_key_link_tmp ).

                      INSERT LINES OF lt_target_tmp   INTO TABLE lt_target.
                      INSERT LINES OF lt_key_link_tmp INTO TABLE lt_key_link.
                      IF lt_failed_key IS INITIAL.
                        EXIT. " all instances found
                      ELSE.
                        lt_key_tmp = lt_failed_key.
                      ENDIF.
                    ENDDO.


                  CATCH BEFORE UNWIND cx_root INTO lx_root. "#EC CATCH_ALL
                    set_application_error( lx_root ).
                ENDTRY.
              ENDIF.

              ASSERT ID /bobf/frw_error CONDITION
                 /bobf/cl_tool_assert=>is_key_link_matching(
                     it_key_link   = lt_key_link
                     it_key        = lt_key
                     it_target_key = lt_target ) = abap_true.

              " add failed nodes to ET_FAILED_NODE, remove failed instance from ET_NODE_LINK
              LOOP AT lt_failed_node INTO ls_node.
                LOOP AT et_node_link INTO ls_node_link
                  WHERE target_node = lv_node
                    AND target_key  = ls_node-key.
                  DELETE et_node_link.
                  ls_node-node = ls_node_link-source_node.
                  ls_node-key  = ls_node_link-source_key.
                  INSERT ls_node INTO TABLE et_failed_node.
                ENDLOOP.
              ENDLOOP.
              LOOP AT lt_failed_key INTO ls_key.
                LOOP AT et_node_link INTO ls_node_link
                  WHERE target_node = lv_node
                    AND target_key  = ls_key-key.
                  DELETE et_node_link.
                  ls_node-node = ls_node_link-source_node.
                  ls_node-key  = ls_node_link-source_key.
                  INSERT ls_node INTO TABLE et_failed_node.
                ENDLOOP.
              ENDLOOP.

              " update the link information in ET_KEY_LINK by the help of the current RBA result
              LOOP AT lt_key_link INTO ls_key_link.
                LOOP AT et_node_link INTO ls_node_link
                  WHERE target_node = lv_node
                    AND target_key  = ls_key_link-source_key.
                  DELETE et_node_link.
                  ls_node_link-target_node = ls_assoc_parent_node-target_node_key.
                  ls_node_link-target_key  = ls_key_link-target_key.
                  APPEND ls_node_link TO lt_node_link.
                ENDLOOP.
              ENDLOOP.
              INSERT LINES OF lt_node_link INTO TABLE et_node_link.
              CLEAR lt_node_link.
              IF lt_target IS INITIAL.
                " no parent node found -> no keys ca be loaded -> virtually not possible
                DELETE et_node_link USING KEY source_node WHERE source_node = ls_node-node.
                EXIT.
              ENDIF.

              " set the node and keys for the RBA for the next iteration
              lv_node = ls_assoc_parent_node-target_node_key.
              lt_key  = lt_target.
            ELSE.
              " no association to parent node found
              set_application_error( ).
            ENDIF.
          ENDIF.
        ENDDO.
        CLEAR lt_key.
      ENDAT.

    ENDLOOP.

    after_loading(
      EXPORTING
        io_change      = lo_change
        iv_load_state  = /bobf/if_conf_c=>sc_state_current
      IMPORTING
        et_loaded_node = et_loaded_node
        eo_message     = lo_message ).

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    DELETE ADJACENT DUPLICATES FROM et_node.

  ENDMETHOD.


  METHOD get_node_cat.

    DATA: lt_nodecat    TYPE /bobf/t_frw_node_cat,
          lt_failed_key TYPE /bobf/t_frw_key,
          lt_key        TYPE /bobf/t_frw_key,
          lo_message    TYPE REF TO /bobf/if_frw_message.

    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

    CLEAR:
      et_nodecat,
      et_failed_key,
      eo_message.

    IF iv_node_key = mv_nodecat_node_key AND
       it_key      = mt_nodecat_key.
      et_nodecat = mt_nodecat.
      RETURN.
    ENDIF.
    mv_nodecat_node_key = iv_node_key.
    mt_nodecat_key      = it_key.

*  check current state at first
    retrieve(
      EXPORTING
        iv_node_key    = iv_node_key
        it_key         = it_key
        iv_state       = iv_current_state
        iv_fill_data   = abap_false
      IMPORTING
        et_node_cat    = et_nodecat
        et_failed_key  = lt_failed_key
        eo_message     = lo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = it_key
            it_key_subset = lt_failed_key ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

    mt_nodecat = et_nodecat.
    CHECK lt_failed_key IS NOT INITIAL.
    lt_key = lt_failed_key.

*  check last state
    CHECK iv_last_state <> iv_current_state.
    retrieve(
      EXPORTING
        iv_node_key    = iv_node_key
        it_key         = lt_key
        iv_state       = iv_last_state
        iv_fill_data   = abap_false
      IMPORTING
        et_node_cat   = lt_nodecat
        et_failed_key = lt_failed_key
        eo_message     = lo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = lt_key
            it_key_subset = lt_failed_key ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    INSERT LINES OF lt_nodecat INTO TABLE et_nodecat.
    mt_nodecat = et_nodecat.
    CHECK lt_failed_key IS NOT INITIAL.
    lt_key = lt_failed_key.

*  check database state
    CHECK iv_last_state <> /bobf/if_conf_c=>sc_state_database.
    retrieve(
      EXPORTING
        iv_node_key    = iv_node_key
        it_key         = lt_key
        iv_state       = /bobf/if_conf_c=>sc_state_database
        iv_fill_data   = abap_false
      IMPORTING
        et_node_cat    = lt_nodecat
        et_failed_key  = et_failed_key
        eo_message     = lo_message ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = lt_key
            it_key_subset = et_failed_key ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).
    INSERT LINES OF lt_nodecat INTO TABLE et_nodecat.
    mt_nodecat = et_nodecat.

  ENDMETHOD.


  METHOD get_relevant_groups.

    TYPES:
      BEGIN OF lty_assoc_to_group_node,
        "! Association pointing from a trigger node to the node of a triggered validation.
        "! An initial line indicates that the trigger node is also a validation node.
        assoc_key     TYPE /bobf/obm_assoc_key,
        "! target node of the association. Only filled if assoc_key is not initial
        target_node   TYPE /bobf/obm_node_key,
        "! list of nodes of groups to which the triggered validations belong.
        t_group_nodes TYPE SORTED TABLE OF /bobf/obm_node_key  WITH UNIQUE KEY table_line,
      END OF lty_assoc_to_group_node.

    TYPES:
      "! holds information about trigger nodes accross groups
      BEGIN OF lty_trigger_info,
        "! tiggering node
        node_key     TYPE /bobf/obm_node_key,
        "! relevant change modes (trigger flags)
        change_mode  TYPE /bobf/s_confro_chg_mode,
        "! lists associations from the trigger node to any triggered validations.
        "! Includes a list of nodes of groups for which the association is relevant.
        t_assoc_info TYPE SORTED TABLE OF lty_assoc_to_group_node WITH UNIQUE KEY assoc_key,
      END OF lty_trigger_info.

    TYPES:
      BEGIN OF lty_group_info,
        conf           TYPE REF TO /bobf/s_confro_group,
        node_key       TYPE /bobf/obm_node_key,
        default_status TYPE /bobf/frw_sta_consistency,
        t_key          TYPE /bobf/t_frw_key,
      END OF lty_group_info.

    DATA:
      lt_failed_key TYPE /bobf/t_frw_key,
      lo_message    TYPE REF TO /bobf/if_frw_message,
      ls_group_info TYPE lty_group_info,
      lt_group_info TYPE SORTED TABLE OF lty_group_info WITH NON-UNIQUE KEY node_key,
      lt_trigger    TYPE SORTED TABLE OF lty_trigger_info WITH UNIQUE KEY node_key.


    " This method processes groups in multiple phases (LOOPS).  The goal is to reduce the
    " number of calls to GET_TRIGGER and RETRIEVE_BY_ASSOCIATION as much as possible.
    "
    " 1) Candidate groups are filtered based on the group meta data.
    " 2) Trigger conditions are collected from all validations belonging to selected groups.
    "    The triggers are aggregated by node key, such that GET_TRIGGER is called at most once
    "    per node_key.  Trigger associations are also collected, and the group nodes to which
    "    the triggers belong are stored at the associations.
    " 3) GET_TRIGGER and potentially RBA up to validation nodes and group nodes are executed
    "    for each trigger node. Any instance keys retrieved for group nodes are associated to
    "    interested groups.
    " 4) Collected instance keys are distributed to the respective et_group... exporting
    "    parameters.

    CLEAR:
      et_group_2_way,
      et_group_3_way,
      et_group_no_status,
      et_validations,
      eo_message.

    CHECK io_change IS BOUND.

    mo_conf->get_group_tab( IMPORTING et_group = DATA(lt_groupconf) ).

    " 1) filter groups and set default status values:
    LOOP AT lt_groupconf ASSIGNING FIELD-SYMBOL(<ls_group_conf>) WHERE group_cat = /bobf/if_conf_c=>sc_group_cat_consistency.

      " skip groups on status nodes
      IF  <ls_group_conf>-node_key IS NOT INITIAL AND ( iv_processing_mode EQ /bobf/if_frw_c=>sc_mode_finalize         OR
                                                        iv_processing_mode EQ /bobf/if_frw_c=>sc_mode_modify           OR
                                                        iv_processing_mode EQ /bobf/if_frw_c=>sc_mode_check_before_save ).
        mo_conf->get_node( <ls_group_conf>-node_key ).
        CHECK mo_conf->ms_last_node-node_type NE /bobf/if_conf_c=>sc_node_type_status.
      ENDIF.

      CASE iv_processing_mode.
        WHEN /bobf/if_frw_c=>sc_mode_check_and_determine.
          " all groups
          ls_group_info-default_status = /bobf/if_frw_c=>sc_status_consistent.

        WHEN /bobf/if_frw_c=>sc_mode_finalize.
          " only 2-way + 3-way only pending
          CHECK <ls_group_conf>-sta_var IS BOUND AND ( <ls_group_conf>-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary OR
                                                       <ls_group_conf>-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_ternary ).
          ls_group_info-default_status = /bobf/if_frw_c=>sc_status_consistent.

        WHEN /bobf/if_frw_c=>sc_mode_modify.
          " only 2-way immediately + 3-way to pending
          CHECK <ls_group_conf>-sta_var IS BOUND
          AND ( <ls_group_conf>-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary AND <ls_group_conf>-check_immediate = abap_true OR
                <ls_group_conf>-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_ternary ).
          IF <ls_group_conf>-sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary.
            ls_group_info-default_status = /bobf/if_frw_c=>sc_status_consistent.
          ELSE.
            ls_group_info-default_status = /bobf/if_frw_c=>sc_status_pending.
          ENDIF.

        WHEN /bobf/if_frw_c=>sc_mode_check_before_save.
          " only groups without any status
          CHECK <ls_group_conf>-sta_var_key IS INITIAL.
          ls_group_info-default_status = /bobf/if_frw_c=>sc_status_consistent.

      ENDCASE.

      ls_group_info-node_key = COND #( WHEN <ls_group_conf>-node_key IS NOT INITIAL THEN <ls_group_conf>-node_key
                                                                                    ELSE mo_conf->ms_obj-root_node_key ).
      ls_group_info-conf     = REF #( <ls_group_conf> ).
      INSERT ls_group_info INTO TABLE lt_group_info.

    ENDLOOP.

    mo_conf->get_validation( IMPORTING et_val_list = DATA(lt_val_list) ).
    SORT lt_val_list BY val_key.

    " 2) collect (in LT_TRIGGER) and condense all triggers for the groups:
    LOOP AT lt_group_info ASSIGNING FIELD-SYMBOL(<ls_group_info>).

      " assign (and optionally create) trigger info for group node:
      ASSIGN lt_trigger[ node_key = <ls_group_info>-node_key ] TO FIELD-SYMBOL(<ls_trigger_info>).
      IF sy-subrc <> 0.
        INSERT VALUE #( node_key = <ls_group_info>-node_key ) INTO TABLE lt_trigger ASSIGNING <ls_trigger_info>.
      ENDIF.
      " assign (and optionally create) assoc info for initial association key:
      ASSIGN <ls_trigger_info>-t_assoc_info[ assoc_key = VALUE #( ) ] TO FIELD-SYMBOL(<ls_assoc_info>).
      IF sy-subrc <> 0.
        INSERT INITIAL LINE INTO TABLE <ls_trigger_info>-t_assoc_info ASSIGNING <ls_assoc_info>.
      ENDIF.
      " register group node as interested in triggers of this node:
      INSERT <ls_group_info>-node_key INTO TABLE <ls_assoc_info>-t_group_nodes.
      " add CHECKs and CREATEs for group node (create scenario):
      <ls_trigger_info>-change_mode-check  = abap_true.
      <ls_trigger_info>-change_mode-create = abap_true.

      " collect info about triggers of all validations of the group:
      LOOP AT <ls_group_info>-conf->val_keys->* INTO DATA(ls_val_key).
        READ TABLE lt_val_list ASSIGNING FIELD-SYMBOL(<ls_validation>) BINARY SEARCH WITH KEY val_key = ls_val_key-key.
        CHECK sy-subrc = 0. " check may fail in some rare situations. E.g. validations in "deactivation groups"
        LOOP AT <ls_validation>-val_trigger->* ASSIGNING FIELD-SYMBOL(<ls_val_trigger>).

          " assign (and optionally create) trigger info for trigger node:
          ASSIGN lt_trigger[ node_key = <ls_val_trigger>-node_key ] TO <ls_trigger_info>.
          IF sy-subrc <> 0.
            INSERT VALUE #( node_key = <ls_val_trigger>-node_key ) INTO TABLE lt_trigger ASSIGNING <ls_trigger_info>.
          ENDIF.
          " assign (and optionally create) assoc info for association key:
          " collect associations:
          IF <ls_val_trigger>-assoc IS BOUND AND <ls_val_trigger>-assoc->assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent.
            DATA(lv_trigger_assoc_key)    = <ls_val_trigger>-assoc->assoc_key.
            DATA(lv_trigger_assoc_target) = <ls_val_trigger>-assoc->target_node_key.
          ELSE.
            CLEAR lv_trigger_assoc_key.
            CLEAR lv_trigger_assoc_target.
          ENDIF.
          ASSIGN <ls_trigger_info>-t_assoc_info[ assoc_key = lv_trigger_assoc_key ] TO <ls_assoc_info>.
          IF sy-subrc <> 0.
            INSERT VALUE #( assoc_key   = lv_trigger_assoc_key
                            target_node = lv_trigger_assoc_target ) INTO TABLE <ls_trigger_info>-t_assoc_info ASSIGNING <ls_assoc_info>.
          ENDIF.
          " register group node as interested in triggers of this node node:
          INSERT <ls_group_info>-node_key INTO TABLE <ls_assoc_info>-t_group_nodes.

          " aggregate the trigger flags:
          IF mo_conf->ms_obj-smart_validations = abap_true.
            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
            " For smart-enabled BOs, the logic below has been changed to improve
            " performance (compare to the ELSE-branch below).
            " With the old logic, validations in groups have been triggered too
            " often, or the search for relevant groups was too costly.
            " The change of logic may occasionally lead to small changes in
            " behavior.  However, if this is the case, the trigger configuration
            " of affected BOs probably should be adjusted.
            "
            " We would like to use the same logic for non-smart BOs as well,
            " but the risk of incompatible behavior would be too high.
            " For smart BOs, the design time does not allow _not_ to set any of
            " the CUD-triggers. Therefore, we think we can assume that BO owners
            " have chosen the triggers consciously.
            """" >>> """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
            IF iv_processing_mode = /bobf/if_frw_c=>sc_mode_check_and_determine.
              IF <ls_val_trigger>-check  = abap_true.
                <ls_trigger_info>-change_mode-check  = abap_true.
              ENDIF.
            ELSE.
              IF <ls_val_trigger>-create = abap_true.
                <ls_trigger_info>-change_mode-create = abap_true.
              ENDIF.
              IF <ls_val_trigger>-update = abap_true.
                <ls_trigger_info>-change_mode-update = abap_true.
              ENDIF.
              IF <ls_val_trigger>-node_key <> <ls_validation>-node_key. " do not trigger on delete if the trigger is the validation node itself
                IF <ls_val_trigger>-delete = abap_true.
                  <ls_trigger_info>-change_mode-delete = abap_true.
                ENDIF.
              ENDIF.
            ENDIF.
            """" <<< """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
          ELSE.
            IF iv_processing_mode = /bobf/if_frw_c=>sc_mode_check_and_determine.
              <ls_trigger_info>-change_mode-check  = abap_true.
            ELSE.
              <ls_trigger_info>-change_mode-create = abap_true.
              <ls_trigger_info>-change_mode-update = abap_true.
              IF <ls_val_trigger>-node_key <> <ls_validation>-node_key. " do not trigger on delete if the trigger is the validation node itself
                <ls_trigger_info>-change_mode-delete = abap_true.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
    ENDLOOP.
    DELETE lt_trigger WHERE change_mode IS INITIAL.     "#EC CI_SORTSEQ

    " 3) For all trigger nodes, traverse to the validation nodes, and then up to the relevant group nodes.
    "    Add the resulting set of group node keys to all groups of the node:
    LOOP AT lt_trigger ASSIGNING <ls_trigger_info>.

      " collect triggering keys (result in lt_trigger_key):
      get_validation_trigger( EXPORTING iv_processing_mode = iv_processing_mode
                                        is_change_mode     = <ls_trigger_info>-change_mode
                                        iv_node_key        = <ls_trigger_info>-node_key
                                        io_change          = CAST #( io_change )
                                        iv_state_current   = iv_state_current
                                        iv_state_before    = iv_state_before
                              IMPORTING et_key             = DATA(lt_trigger_key) ).
      CHECK lt_trigger_key IS NOT INITIAL.

      LOOP AT <ls_trigger_info>-t_assoc_info ASSIGNING <ls_assoc_info>.

        DATA(lv_state_before_used) = abap_false. " loop initialization

        " navigate to triggered validation (result in lt_validation_key):
        IF <ls_assoc_info>-assoc_key IS INITIAL.
          DATA(lt_validation_key) = lt_trigger_key.
          DATA(lv_this_node_key) = <ls_trigger_info>-node_key.
        ELSE.
          retrieve_by_association( EXPORTING iv_node_key        = <ls_trigger_info>-node_key
                                             it_key             = lt_trigger_key
                                             iv_association     = <ls_assoc_info>-assoc_key
                                             iv_state           = iv_state_current
                                             iv_fill_failed_key = abap_true
                                   IMPORTING eo_message         = lo_message
                                             et_target_key      = lt_validation_key
                                             et_failed_key      = lt_failed_key ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          IF lt_failed_key IS NOT INITIAL AND <ls_trigger_info>-change_mode-delete = abap_true.
            retrieve_by_association( EXPORTING iv_node_key    = <ls_trigger_info>-node_key
                                               it_key         = lt_failed_key
                                               iv_association = <ls_assoc_info>-assoc_key
                                               iv_state       = iv_state_before
                                     IMPORTING eo_message     = lo_message
                                               et_target_key  = DATA(lt_validation_key_before) ).
            lv_state_before_used = abap_true.
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
            IF lt_validation_key IS INITIAL.
              lt_validation_key = lt_validation_key_before.
            ELSE.
              APPEND LINES OF lt_validation_key_before TO lt_validation_key.
              SORT lt_validation_key.                  "#EC CI_SORTLOOP
              DELETE ADJACENT DUPLICATES FROM lt_validation_key.
            ENDIF.
          ENDIF.
          lv_this_node_key = <ls_assoc_info>-target_node.
        ENDIF.

        " Navigate up the node hierarchy until all relevant group nodes have been visited:
        DATA(lt_group_node_keys_remaining) = <ls_assoc_info>-t_group_nodes.
        DATA(lt_key_this_node) = lt_validation_key.
        DO.

          IF line_exists( lt_group_node_keys_remaining[ table_line = lv_this_node_key ] ).
            " there are groups at this node --> add the keys to these groups
            IF lv_state_before_used = abap_true.
              " we used the before image to collect the group node keys -> have to check for existence of the instances
              retrieve( EXPORTING iv_node_key   = lv_this_node_key
                                  it_key        = lt_key_this_node
                                  iv_state      = iv_state_current
                                  iv_fill_data  = abap_false
                        IMPORTING et_failed_key = lt_failed_key ).
              DATA(lt_key_for_group) = FILTER #( lt_key_this_node EXCEPT IN lt_failed_key USING KEY key_sort WHERE key = key ).
            ELSE.
              lt_key_for_group = lt_key_this_node.
            ENDIF.
            " distribute the keys to all relevant groups:
            LOOP AT lt_group_info ASSIGNING <ls_group_info> WHERE node_key = lv_this_node_key.
              INSERT LINES OF lt_key_for_group INTO TABLE <ls_group_info>-t_key.
            ENDLOOP.

            " check if all relevant groups nodes have been traversed:
            DELETE TABLE lt_group_node_keys_remaining WITH TABLE KEY table_line = lv_this_node_key.
            IF lt_group_node_keys_remaining IS INITIAL.
              EXIT.
            ENDIF.
          ENDIF.

          " navigate up the node hierarchy to find the remaining group nodes:
          IF lv_this_node_key = mo_conf->ms_obj-root_node_key.
            " the groups in LT_GROUP_NODE_KEYS_REMAINING contain validations which are not assigned to the group node or a subnode thereof.
            set_configuration_error( ).
          ENDIF.
          mo_conf->get_assoc( iv_node_key  = lv_this_node_key
                              iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent ).
          DATA(lv_to_parent_assoc_key) = mo_conf->ms_last_assoc-assoc_key.
          DATA(lv_parent_node_key)     = mo_conf->ms_last_assoc-target_node_key.

          retrieve_by_association( EXPORTING iv_node_key        = lv_this_node_key
                                             it_key             = lt_key_this_node
                                             iv_association     = lv_to_parent_assoc_key
                                             iv_state           = iv_state_current
                                             iv_fill_failed_key = abap_true
                                   IMPORTING eo_message         = lo_message
                                             et_target_key      = DATA(lt_key_parent_curr_img)
                                             et_failed_key      = lt_failed_key ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
          lt_key_this_node = lt_key_parent_curr_img.

          IF lt_failed_key IS NOT INITIAL.
            lv_state_before_used = abap_true.
            retrieve_by_association( EXPORTING iv_node_key    = lv_this_node_key
                                               it_key         = lt_failed_key
                                               iv_association = lv_to_parent_assoc_key
                                               iv_state       = iv_state_before
                                     IMPORTING eo_message     = lo_message
                                               et_target_key  = DATA(lt_key_parent_before_img) ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
            APPEND LINES OF lt_key_parent_before_img TO lt_key_this_node.
            IF lt_key_parent_curr_img IS NOT INITIAL. " even disjunct node keys may have identical parents -> have to make unique
              SORT lt_key_this_node.
              DELETE ADJACENT DUPLICATES FROM lt_key_this_node.
            ENDIF.
          ENDIF.

          lv_this_node_key = lv_parent_node_key.
        ENDDO.

      ENDLOOP.
    ENDLOOP.

    " 4) Distribute collected keys to the exporting parameters:
    LOOP AT lt_group_info ASSIGNING <ls_group_info> WHERE t_key IS NOT INITIAL. "#EC CI_SORTSEQ

      " add result to the appropriate exporting table
      IF <ls_group_info>-conf->sta_var IS BOUND.
        IF <ls_group_info>-conf->sta_var->sta_var_cat = /bobf/if_conf_c=>sc_sta_cat_consist_binary.
          ASSIGN et_group_2_way TO FIELD-SYMBOL(<et_group>).
        ELSE.
          ASSIGN et_group_3_way TO <et_group>.
        ENDIF.
      ELSE.
        ASSIGN et_group_no_status TO <et_group>.
      ENDIF.
      SORT <ls_group_info>-t_key.                      "#EC CI_SORTLOOP
      DELETE ADJACENT DUPLICATES FROM <ls_group_info>-t_key.
      <et_group> = VALUE #( BASE <et_group> FOR key IN <ls_group_info>-t_key
                                                ( group_key    = <ls_group_info>-conf->group_key
                                                  key          = key-key
                                                  status_value = <ls_group_info>-default_status ) ).

      " Collect validations, but do not add validations of 3-way groups that are set to pending
      IF iv_processing_mode <> /bobf/if_frw_c=>sc_mode_modify
      OR <ls_group_info>-conf->sta_var->sta_var_cat <> /bobf/if_conf_c=>sc_sta_cat_consist_ternary.
        APPEND LINES OF <ls_group_info>-conf->val_keys->* TO et_validations.
      ENDIF.

    ENDLOOP.

    SORT et_validations.
    DELETE ADJACENT DUPLICATES FROM et_validations.

  ENDMETHOD.


  METHOD get_root_key.

    DATA: lv_state      TYPE /bobf/conf_state,
          lv_node       TYPE /bobf/obm_node_key,
          ls_key        TYPE /bobf/s_frw_key,
          ls_key_link   TYPE /bobf/s_frw_key_link,
          lo_delegation TYPE REF TO /bobf/if_frw_delegation,
          lo_change     TYPE REF TO /bobf/if_frw_change,
          lx_root       TYPE REF TO cx_root.


    CLEAR: et_key_link,
           et_failed_key,
           et_target_key,
           et_loaded_node.

    IF iv_before_image           = abap_true AND
        mv_modifying_transaction = abap_true.
      lv_state = /bobf/if_conf_c=>sc_state_database.
    ELSE.
      lv_state = /bobf/if_conf_c=>sc_state_current.
    ENDIF.

    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( iv_node_key = iv_node_key ).
    ENDIF.

    IF mo_conf->ms_last_node-delegation_class IS INITIAL.

*  ____________________________________________________________________ *
*    retrieve data from buffer
      IF mo_conf->ms_last_node-transient = abap_false.
        lo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

*    get root key of the parent node if key inherited and not loadable
      IF mo_conf->ms_last_node-key_inherited = abap_true  AND
         mo_conf->ms_last_node-loadable      = abap_false AND
         mo_conf->ms_last_node-transient     = abap_false.
        lv_node = mo_conf->ms_last_node-parent_node_key.
      ELSE.
        lv_node = iv_node_key.
      ENDIF.

      TRY.
          mo_buffer->get_root_key(
           EXPORTING
             iv_node_key   = lv_node
             it_key        = it_key
             iv_state      = lv_state
             io_change     = lo_change
           IMPORTING
             et_key_link   = et_key_link
             et_failed_key = et_failed_key
             et_target_key = et_target_key ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      IF lo_change                  IS BOUND AND
         lo_change->has_changes( ) = abap_true.
        after_loading(
          EXPORTING
            io_change      = lo_change
            iv_load_state  = lv_state
          IMPORTING
            et_loaded_node = et_loaded_node ).
      ENDIF.

    ELSE.
*  ____________________________________________________________________ *
*    delegate call
      TRY.
          lo_delegation = get_delegation( iv_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->get_root_key(
            EXPORTING
             iv_node_key         = iv_node_key
             it_key              = it_key
             iv_state            = lv_state
             io_read             = mo_delegation_read
           IMPORTING
             et_key_link         = et_key_link
             et_failed_key       = et_failed_key ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      IF et_target_key IS REQUESTED.
        CLEAR et_target_key.
        LOOP AT et_key_link INTO ls_key_link.
          ls_key-key = ls_key_link-target_key.
          APPEND ls_key TO et_target_key.
        ENDLOOP.
        SORT et_target_key.
        DELETE ADJACENT DUPLICATES FROM et_target_key.
      ENDIF.
    ENDIF.

    ASSERT ID /bobf/frw_error CONDITION
        /bobf/cl_tool_assert=>is_key_subset(
            it_key_set    = it_key
            it_key_subset = et_failed_key ) = abap_true.
    ASSERT ID /bobf/frw_error CONDITION
       /bobf/cl_tool_assert=>is_key_link_matching(
           it_key_link = et_key_link
           it_key      = it_key ) = abap_true.

  ENDMETHOD.


  METHOD get_root_key_modify.

    DATA: lt_node       TYPE /bobf/t_frw_node,
          ls_node       TYPE /bobf/s_frw_node,
          lt_node2      TYPE /bobf/t_frw_node,
          lt_key        TYPE /bobf/t_frw_key,
          lt_tmp_key    TYPE /bobf/t_frw_key,
          ls_key        TYPE /bobf/s_frw_key,
          lt_key_link   TYPE /bobf/t_frw_key_link,
          ls_key_link   TYPE /bobf/s_frw_key_link,
          lt_node_link  TYPE /bobf/t_frw_node_key_link,
          ls_node_link  TYPE /bobf/s_frw_node_key_link,
          ls_mod        TYPE /bobf/s_frw_modification,
          lo_message    TYPE REF TO /bobf/if_frw_message,
          lo_delegation TYPE REF TO /bobf/if_frw_delegation,
          lx_root       TYPE REF TO cx_root.

    FIELD-SYMBOLS: <ls_mod> TYPE /bobf/s_frw_modification.

    CLEAR:
        et_key,
        et_key_link,
        eo_message.

    lt_node = it_node.

* search also in modify table first
    LOOP AT ct_mod ASSIGNING <ls_mod>.
      IF <ls_mod>-root_key IS NOT INITIAL.              " root key already known
        DELETE lt_node
          WHERE node = <ls_mod>-node
            AND key  = <ls_mod>-key.
        IF sy-subrc = 0.
          ls_key-key = <ls_mod>-root_key.
          APPEND ls_key TO et_key.
          ls_key_link-source_key = <ls_mod>-key.
          ls_key_link-target_key = <ls_mod>-root_key.
          IF et_key_link IS REQUESTED.
            INSERT ls_key_link INTO TABLE et_key_link.
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.
      IF <ls_mod>-node = mo_conf->ms_obj-root_node_key. " root key in modify table
        <ls_mod>-root_key = <ls_mod>-key.
        DELETE lt_node
          WHERE node = <ls_mod>-node
            AND key  = <ls_mod>-key.
        IF sy-subrc = 0.
          ls_key-key = <ls_mod>-root_key.
          APPEND ls_key TO et_key.
          ls_key_link-source_key = <ls_mod>-key.
          ls_key_link-target_key = <ls_mod>-root_key.
          IF et_key_link IS REQUESTED.
            INSERT ls_key_link INTO TABLE et_key_link.
          ENDIF.
        ENDIF.
        CONTINUE.
      ENDIF.

      IF <ls_mod>-change_mode = /bobf/if_frw_c=>sc_modify_create.
*     search for created parent
        READ TABLE ct_mod INTO ls_mod
          TRANSPORTING root_key
          WITH KEY change
          COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                     node        = <ls_mod>-source_node
                     key         = <ls_mod>-source_key.
        IF sy-subrc <> 0. " parent already in the buffer
          ls_node-node = <ls_mod>-source_node.
          ls_node-key  = <ls_mod>-source_key.
          INSERT ls_node INTO TABLE lt_node2.
*        IF et_key_link IS REQUESTED.
*          ls_key_link-source_key = <ls_mod>-key.
*          ls_key_link-target_key = <ls_mod>-source_key.
*          INSERT ls_key_link INTO TABLE lt_key_link2.
*        ENDIF.
        ELSEIF ls_mod-root_key IS NOT INITIAL.
          <ls_mod>-root_key = ls_mod-root_key.
          DELETE lt_node
            WHERE node = <ls_mod>-node
              AND key  = <ls_mod>-key.
          IF sy-subrc = 0.
            ls_key-key = <ls_mod>-root_key.
            APPEND ls_key TO et_key.
            IF et_key_link IS REQUESTED.
              ls_key_link-source_key = <ls_mod>-key.
              ls_key_link-target_key = <ls_mod>-root_key.
              INSERT ls_key_link INTO TABLE et_key_link.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
*     update or delete
        READ TABLE lt_node TRANSPORTING NO FIELDS
          WITH KEY node = <ls_mod>-node
                   key  = <ls_mod>-key.
        IF sy-subrc = 0. " add to table if requested
          ls_node-node = <ls_mod>-node.
          ls_node-key  = <ls_mod>-key.
          INSERT ls_node INTO TABLE lt_node2.
        ENDIF.
      ENDIF.
    ENDLOOP.

* get root keys
    LOOP AT lt_node2 INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.
      AT END OF node.
        TRY.
            mo_buffer->get_root_key(
              EXPORTING
                iv_node_key   = ls_node-node
                it_key        = lt_key
                iv_state      = iv_state
                io_change     = io_change
              IMPORTING
                et_key_link   = lt_key_link ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        after_loading(
          EXPORTING
            io_change         = io_change
            iv_load_state     = iv_state
          IMPORTING
            eo_message        = eo_message ).

        LOOP AT lt_key_link INTO ls_key_link.
          ls_mod-root_key = ls_key_link-target_key.
*       check updates
          MODIFY ct_mod FROM ls_mod USING KEY change TRANSPORTING root_key
            WHERE change_mode = /bobf/if_frw_c=>sc_modify_update
              AND node        = ls_node-node
              AND key         = ls_key_link-source_key.
          IF sy-subrc = 0.
            DELETE lt_node
              WHERE node = ls_node-node
                AND key  = ls_key_link-source_key.
            IF sy-subrc = 0.
              ls_key-key = ls_key_link-target_key.
              APPEND ls_key TO et_key.
              IF et_key_link IS REQUESTED.
                INSERT ls_key_link INTO TABLE et_key_link.
              ENDIF.
            ENDIF.
*          CONTINUE.
          ENDIF.
*       check deletes
          MODIFY ct_mod FROM ls_mod USING KEY change TRANSPORTING root_key
            WHERE change_mode = /bobf/if_frw_c=>sc_modify_delete
              AND node        = ls_node-node
              AND key         = ls_key_link-source_key.
          IF sy-subrc = 0.
            DELETE lt_node
              WHERE node = ls_node-node
                AND key  = ls_key_link-source_key.
            IF sy-subrc = 0.
              ls_key-key = ls_key_link-target_key.
              APPEND ls_key TO et_key.
              INSERT ls_key_link INTO TABLE et_key_link.
            ENDIF.
*          CONTINUE.
          ENDIF.
*       mark creates
          ls_node_link-source_node = mo_conf->ms_obj-root_node_key.
          ls_node_link-source_key  = ls_key_link-target_key. " root_key
          ls_node_link-target_node = ls_node-node.
          ls_node_link-target_key  = ls_key_link-source_key.
          INSERT ls_node_link INTO TABLE lt_node_link.
        ENDLOOP.
        CLEAR lt_key.
      ENDAT.
    ENDLOOP.

* write root key into modification table
    IF lt_node2 IS NOT INITIAL.
      LOOP AT ct_mod ASSIGNING <ls_mod> USING KEY change
        WHERE change_mode = /bobf/if_frw_c=>sc_modify_create.

        READ TABLE ct_mod INTO ls_mod
          TRANSPORTING root_key
          WITH KEY change
          COMPONENTS change_mode = /bobf/if_frw_c=>sc_modify_create
                     node        = <ls_mod>-source_node
                     key         = <ls_mod>-source_key.
        IF sy-subrc = 0.  " source also newly created
          <ls_mod>-root_key = ls_mod-root_key. " take root of source
        ELSE.             " source already created
          READ TABLE lt_node_link INTO ls_node_link
            WITH KEY target_node = <ls_mod>-source_node
                     target_key  = <ls_mod>-source_key.
          IF sy-subrc = 0.
            <ls_mod>-root_key = ls_node_link-source_key.
          ENDIF.
        ENDIF.
        DELETE lt_node
          WHERE node = <ls_mod>-node
            AND key  = <ls_mod>-key.
        IF sy-subrc = 0.
          ls_key-key = <ls_mod>-root_key.
          APPEND ls_key TO et_key.
          IF et_key_link IS REQUESTED.
            ls_key_link-source_key = <ls_mod>-key.
            ls_key_link-target_key = <ls_mod>-root_key.
            INSERT ls_key_link INTO TABLE et_key_link.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.

* get rest of root keys (not existing in modification table)
    LOOP AT lt_node INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.
      AT END OF node.
        IF ls_node-node = mo_conf->ms_obj-root_node_key.
          lt_tmp_key = lt_key.
        ELSE.

          IF mo_conf->ms_last_node-node_key <> ls_node-node.
            mo_conf->get_node( iv_node_key = ls_node-node ).
          ENDIF.

          IF mo_conf->ms_last_node-delegation_class IS INITIAL.
            TRY.
                IF et_key_link IS REQUESTED.
                  mo_buffer->get_root_key(
                    EXPORTING
                      iv_node_key   = ls_node-node
                      it_key        = lt_key
                      iv_state      = iv_state
                      io_change     = io_change
                    IMPORTING
                      et_key_link   = lt_key_link
                      et_target_key = lt_tmp_key ).
                  INSERT LINES OF lt_key_link INTO TABLE et_key_link.
                ELSE.
                  mo_buffer->get_root_key(
                    EXPORTING
                      iv_node_key   = ls_node-node
                      it_key        = lt_key
                      iv_state      = iv_state
                      io_change     = io_change
                    IMPORTING
                      et_target_key = lt_tmp_key ).
                ENDIF.
              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            after_loading(
              EXPORTING
                io_change         = io_change
                iv_load_state     = iv_state
              IMPORTING
                eo_message        = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

          ELSE.
            TRY.
                lo_delegation = get_delegation( ls_node-node ).
                DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
                lo_delegation->get_root_key(
                  EXPORTING
                   iv_node_key   = ls_node-node
                   it_key        = lt_key
                   iv_state      = iv_state
                   io_read       = mo_delegation_read
                 IMPORTING
                   et_key_link   = lt_key_link ).
                /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

              CATCH BEFORE UNWIND cx_root INTO lx_root.  "#EC CATCH_ALL
                set_application_error( lx_root ).
            ENDTRY.

            IF et_key_link IS REQUESTED.
              INSERT LINES OF lt_key_link INTO TABLE et_key_link.
            ENDIF.

            IF et_key IS REQUESTED.
              LOOP AT lt_key_link INTO ls_key_link.
                ls_key-key = ls_key_link-target_key.
                APPEND ls_key TO lt_tmp_key.
              ENDLOOP.
              SORT lt_tmp_key.                         "#EC CI_SORTLOOP
              DELETE ADJACENT DUPLICATES FROM lt_tmp_key.
            ENDIF.
          ENDIF.
        ENDIF.

        APPEND LINES OF lt_tmp_key TO et_key.
        CLEAR lt_key.
      ENDAT.
    ENDLOOP.

    SORT et_key.
    DELETE ADJACENT DUPLICATES FROM et_key.
    DELETE ADJACENT DUPLICATES FROM et_key_link.

  ENDMETHOD.


  METHOD get_state_for_read.

    DATA(ls_rba_cross_bo_states) = /bobf/cl_frw_authority_context=>get_rba_cross_bo_states( ).

    rv_state = COND #(
      WHEN iv_before_image = abap_true AND mv_modifying_transaction = abap_true THEN
        COND #(
          WHEN ls_rba_cross_bo_states-bo_key = mo_conf->ms_obj-bo_key  THEN ls_rba_cross_bo_states-before_state
          ELSE /bobf/if_conf_c=>sc_state_database )
      ELSE
        COND #(
          WHEN ls_rba_cross_bo_states-bo_key = mo_conf->ms_obj-bo_key THEN ls_rba_cross_bo_states-current_state
          ELSE /bobf/if_conf_c=>sc_state_current )
    ).

  ENDMETHOD.


  METHOD get_subnodes.

*  recursive method to navigate to almost all all subnodes
*  all combinations of STOP indicators are valid

    DATA: lt_new_key     TYPE        /bobf/t_frw_key,
          lt_node        TYPE        /bobf/t_frw_node,
          lt_path        TYPE        /bobf/t_frw_key2,
          lv_node_key    TYPE        /bobf/obm_node_key,
          ls_node        TYPE        /bobf/s_confro_node,
          lt_assoc2      TYPE        /bobf/t_confro_assoc2,
          ls_assoc2      TYPE        /bobf/s_confro_assoc2,
          lv_buffer_only TYPE        boole_d,
          lo_message     TYPE REF TO /bobf/if_frw_message.

    CLEAR: eo_message, et_node_with_children, et_node_without_children.

* ___________________________________________________________________________ *
*  determine path from IV_NODE_KEY to all IT_NODE_KEY if not yet done
    IF it_node_key IS NOT INITIAL AND
       ct_node_keys_on_path IS INITIAL.

      LOOP AT it_node_key INTO lv_node_key.
        IF lv_node_key = iv_node_key.
          APPEND lv_node_key TO ct_node_keys_on_path.
          CONTINUE.
        ENDIF.

        DO.
          APPEND lv_node_key TO lt_path.
          mo_conf->get_node( iv_node_key = lv_node_key ).
          lv_node_key = mo_conf->ms_last_node-parent_node_key.

          IF lv_node_key IS INITIAL. " node is not in subtree of iv_node_key -> skip path
            EXIT.
          ENDIF.

          IF lv_node_key = iv_node_key. " path completed -> add nodes to overall list
            APPEND lv_node_key TO lt_path.
            APPEND LINES OF lt_path TO ct_node_keys_on_path.
            EXIT.
          ENDIF.
        ENDDO.
        CLEAR lt_path.
      ENDLOOP.

      SORT ct_node_keys_on_path.
      DELETE ADJACENT DUPLICATES FROM ct_node_keys_on_path.
    ENDIF.

* ___________________________________________________________________________ *
*  read this node
    IF mo_conf->ms_last_node-node_key <> iv_node_key.
      mo_conf->get_node( iv_node_key = iv_node_key ).
    ENDIF.
    ls_node = mo_conf->ms_last_node.

* ___________________________________________________________________________ *
*  add this node to result tables
    IF iv_return_only_loadable      = abap_false AND iv_return_only_lockable = abap_false OR
       iv_return_only_loadable      = abap_true  AND ls_node-loadable        = abap_true  OR
       iv_return_only_lockable      = abap_true  AND ls_node-lockable        = abap_true  OR
       iv_return_only_check_trigger = abap_true  AND ls_node-check_trigger   = abap_true.

      IF it_node_key IS INITIAL.
        map_to_node(
          EXPORTING
            iv_node_key = iv_node_key
            it_key      = it_key
          IMPORTING
            et_node     = lt_node ).
      ELSE.
        READ TABLE it_node_key TRANSPORTING NO FIELDS
          WITH KEY key_sort COMPONENTS table_line = iv_node_key.
        IF sy-subrc = 0.
          map_to_node(
            EXPORTING
              iv_node_key = iv_node_key
              it_key      = it_key
            IMPORTING
              et_node     = lt_node ).
        ENDIF.
      ENDIF.

      IF lt_node IS NOT INITIAL.
        IF ls_node-delegation_class IS INITIAL.
          INSERT LINES OF lt_node INTO TABLE ct_host_node.
        ELSEIF iv_node_key = ls_node-delegation_root_node_key.
          INSERT LINES OF lt_node INTO TABLE ct_delegation_root_node.
        ELSE.
          INSERT LINES OF lt_node INTO TABLE ct_delegation_subtree.
        ENDIF.
      ENDIF.
    ENDIF.

* ___________________________________________________________________________ *
*  loop all compositions
    mo_conf->get_assoc_tab( IMPORTING et_comp = lt_assoc2 ).
    LOOP AT lt_assoc2 INTO ls_assoc2
      WHERE source_node_key = iv_node_key.
*    these framework nodes are not evaluated by definition
      CHECK ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_lock
        AND ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_property
        AND ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_message
        AND ls_assoc2-assoc_cat              <> /bobf/if_conf_c=>sc_assoccat_status
        AND ls_assoc2-target_node->node_type <> /bobf/if_conf_c=>sc_node_type_qrtn.

*    check static stop condition
      IF iv_stop_at_loadable           = abap_true  AND ls_assoc2-target_node->loadable  = abap_true           OR
         iv_stop_at_lockable           = abap_true  AND ls_assoc2-target_node->lockable  = abap_true           OR
         iv_stop_at_delegation_root    = abap_true  AND ls_assoc2-target_node->delegation_class IS NOT INITIAL OR
         iv_stop_at_delegation_subtree = abap_true  AND ls_node-delegation_class IS NOT INITIAL                OR
         iv_return_transient_nodes     = gc_transient_node_ctrl-none AND ls_assoc2-target_node->transient = abap_true OR
         iv_return_only_check_trigger  = abap_true  AND ls_node-check_trigger_subnodes   = abap_false OR
         iv_return_only_check_trigger  = abap_true  AND ( ls_assoc2-target_node->check_trigger_subnodes = abap_false AND ls_assoc2-target_node->check_trigger = abap_false ).
        CONTINUE.
      ENDIF.

*    check dynamic stop condition -> whether the target node is part of the path to be followed
      IF ct_node_keys_on_path IS NOT INITIAL.
        READ TABLE ct_node_keys_on_path TRANSPORTING NO FIELDS
          WITH KEY key_sort COMPONENTS table_line = ls_assoc2-target_node_key.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
      ENDIF.

*    navigate to child node
      lv_buffer_only = iv_buffer_only.
      IF ls_assoc2-target_node->transient = abap_true AND
        iv_return_transient_nodes = gc_transient_node_ctrl-return_transient_only_buffered.
        " do not create any new transient node instances through determinations
        lv_buffer_only = abap_true.
      ENDIF.
      IF iv_fill_child_node_information = abap_true.

        retrieve_by_association(
          EXPORTING
            iv_node_key    = iv_node_key
            it_key         = it_key
            iv_association = ls_assoc2-assoc_key
            iv_state       = /bobf/if_conf_c=>sc_state_current
            iv_buffer_only = lv_buffer_only
          IMPORTING
            et_target_key  = lt_new_key
            eo_message     = lo_message
            et_key_link    = DATA(lt_key_link) ).

        DATA(lt_key_with_children) = CORRESPONDING /bobf/t_frw_key( lt_key_link MAPPING key = source_key ).

        DELETE ADJACENT DUPLICATES FROM lt_key_with_children.

        map_to_node( EXPORTING iv_node_key = iv_node_key
                               it_key      = lt_key_with_children
                     IMPORTING et_node     = DATA(lt_node_with_children) ).

        INSERT LINES OF lt_node_with_children INTO TABLE et_node_with_children.

      ELSE.
        retrieve_by_association(
          EXPORTING
            iv_node_key    = iv_node_key
            it_key         = it_key
            iv_association = ls_assoc2-assoc_key
            iv_state       = /bobf/if_conf_c=>sc_state_current
            iv_buffer_only = lv_buffer_only
          IMPORTING
            et_target_key  = lt_new_key
            eo_message     = lo_message ).

      ENDIF.
      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

*    call me recursively
      IF lt_new_key IS NOT INITIAL.
        get_subnodes(
          EXPORTING
            iv_node_key                   = ls_assoc2-target_node_key
            it_key                        = lt_new_key
            it_node_key                   = it_node_key
            iv_stop_at_loadable           = iv_stop_at_loadable
            iv_stop_at_lockable           = iv_stop_at_lockable
            iv_stop_at_delegation_root    = iv_stop_at_delegation_root
            iv_stop_at_delegation_subtree = iv_stop_at_delegation_subtree
            iv_return_only_loadable       = iv_return_only_loadable
            iv_return_only_lockable       = iv_return_only_lockable
            iv_return_transient_nodes     = iv_return_transient_nodes
            iv_return_only_check_trigger  = iv_return_only_check_trigger
            iv_buffer_only                = iv_buffer_only
          IMPORTING
            eo_message                    = lo_message
          CHANGING
            ct_host_node                  = ct_host_node
            ct_delegation_root_node       = ct_delegation_root_node
            ct_delegation_subtree         = ct_delegation_subtree
            ct_node_keys_on_path          = ct_node_keys_on_path ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
        CLEAR lt_new_key.
      ENDIF.
    ENDLOOP.

    IF iv_fill_child_node_information = abap_true.

      DATA(lt_key_without_children) = FILTER /bobf/t_frw_key( it_key USING KEY key_sort EXCEPT IN et_node_with_children WHERE key = key ).
      map_to_node( EXPORTING iv_node_key = iv_node_key
                             it_key      = lt_key_without_children
                   IMPORTING et_node     = et_node_without_children ).
    ENDIF.

  ENDMETHOD.


  METHOD get_validation_trigger.

    DATA:
      lv_no_draft  TYPE abap_bool VALUE abap_false,
      lv_no_active TYPE abap_bool VALUE abap_false.

    CLEAR et_key.

    " Check if we need to filter the triggers by draft/active:

    IF mo_conf->ms_obj-smart_validations = abap_true.

      CASE iv_processing_mode.

        WHEN /bobf/if_frw_c=>sc_mode_check_and_determine.
          " No restriction. All validations should be triggered

        WHEN /bobf/if_frw_c=>sc_mode_finalize.
          " During finalize, only status groups are executed.
          " With smart validations, we currently only support one specific status: the draft consistency status.
          " This status shall not be evaluated during finalize.
          " It will be checked before draft activation, at the latest.
          RETURN.

        WHEN /bobf/if_frw_c=>sc_mode_modify.
          " (Note that during modify, only status groups with binary status values are
          "  executed. This currently is not a use case for CDS-based BOs.)
          IF /bobf/cl_tra_transaction_mgr=>is_session_stateless( ).
            " After modify, only draft-validations shall be executed.
            " Others will be executed on Check Before Save.
            lv_no_active = abap_true.
          ENDIF.

        WHEN /bobf/if_frw_c=>sc_mode_check_before_save.

          " Draft instances must never prevent save --> they should not trigger consistency groups
          lv_no_draft = abap_true.

      ENDCASE.

    ENDIF.


    " get the triggers from the change object:
    io_change->get_trigger( EXPORTING iv_node_key    = iv_node_key
                                      is_change_mode = is_change_mode
                                      iv_exectime    = /bobf/if_conf_c=>sc_time_after_modify
                            IMPORTING et_changed_key = et_key ).


    " filter triggers by draft/active, if required:
    IF lv_no_draft = abap_true OR lv_no_active = abap_true.
      " separate_keys might need an internal access object...
      IF mt_access_stack IS INITIAL.
        ASSERT iv_state_before IS NOT INITIAL AND iv_state_current IS NOT INITIAL. "consumer fault: have to provide states if no int_access is on stack
      ENDIF.

      DATA(lo_int_access) = /bobf/cl_frw_int_access=>new_instance( io_bopf   = me
                                                                   io_conf   = mo_conf
                                                                   io_buffer = mo_buffer
                                                                   io_change = io_change ).
      lo_int_access->set_last_state( iv_state_before ).
      lo_int_access->set_current_state( iv_state_current ).
      lo_int_access->set_context( iv_read_allowed = abap_true ).
      INSERT lo_int_access INTO mt_access_stack INDEX 1.
    ENDIF.

    IF lv_no_draft = abap_true.
      mo_lib_draft_active->separate_keys( EXPORTING iv_node_key   = iv_node_key
                                                    it_key        = et_key
                                          IMPORTING et_active_key = DATA(lt_active_key) ).
      et_key = lt_active_key.

    ELSEIF lv_no_active = abap_true.
      mo_lib_draft_active->separate_keys( EXPORTING iv_node_key   = iv_node_key
                                                    it_key        = et_key
                                          IMPORTING et_draft_key = DATA(lt_draft_key) ).
      et_key = lt_draft_key.

    ENDIF.

    IF lo_int_access IS BOUND.
      DELETE mt_access_stack INDEX 1.
    ENDIF.

  ENDMETHOD.


  METHOD is_draft.
    mo_lib_draft_active->separate_keys( EXPORTING iv_node_key    = iv_node_key
                                                    it_key         = it_key
                                          IMPORTING et_draft_key   = DATA(lt_draft)
                                                    et_active_key = DATA(lt_active)
                                                    et_failed_key = DATA(lt_failed) ).

    IF lt_active IS INITIAL AND lt_failed IS INITIAL. "only draft keys
      result = abap_true.
    ELSEIF lt_active IS NOT INITIAL AND lt_draft IS NOT INITIAL. "mixed keys
      set_application_error( NEW /bobf/cx_frw_core( textid = /bobf/cx_frw_core=>sc_mixed_active_and_draft_keys ) ).
    ELSE.
      result = abap_false.
    ENDIF.
  ENDMETHOD.


  METHOD lib_enqueue_context_pop.

    CHECK mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft.

    /bobf/cl_lib_enqueue_context=>pop( ).

  ENDMETHOD.


  METHOD lib_enqueue_context_push_keys.

    DATA:
      lt_root_key TYPE /bobf/t_frw_key.

    CHECK mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_draft.

    IF iv_node_key = mo_conf->ms_obj-root_node_key.
      lt_root_key = it_key.
    ELSE.
      get_root_key( EXPORTING iv_node_key   = iv_node_key
                              it_key        = it_key
                    IMPORTING et_target_key = lt_root_key
                              et_failed_key = DATA(lt_key_no_root) ).
      IF lt_key_no_root IS NOT INITIAL.
        " try again with before_image:
        get_root_key( EXPORTING iv_node_key     = iv_node_key
                                it_key          = lt_key_no_root
                                iv_before_image = abap_true
                      IMPORTING et_target_key   = DATA(lt_root_key_before_img) ).
        INSERT LINES OF lt_root_key_before_img INTO TABLE lt_root_key.
        SORT lt_root_key.
        DELETE ADJACENT DUPLICATES FROM lt_root_key.
      ENDIF.
    ENDIF.
    mo_lib_draft_active->separate_keys( EXPORTING iv_node_key  = mo_conf->ms_obj-root_node_key
                                                        it_key       = lt_root_key
                                              IMPORTING et_draft_key = DATA(lt_draft_key) ).

    /bobf/cl_lib_enqueue_context=>push( iv_entity_name = mo_conf->ms_obj-bo_name
                                        it_draft_key   = lt_draft_key ).

  ENDMETHOD.


  METHOD lock.

    DATA lv_generic TYPE boole_d.

    CHECK
      iv_edit_mode            <> /bobf/if_conf_c=>sc_edit_read_only AND
      iv_within_loading       = abap_false AND
      mo_conf->ms_obj-no_lock = abap_false AND
      it_lock                 IS NOT INITIAL.

*   If only ROOT is lockable no generic lock is needed for these nodes.
    lv_generic = boolc( iv_generic = abap_true AND mo_conf->ms_obj-lock_only_root = abap_false ).

    mo_lock_manager->lock(
      EXPORTING
        iv_edit_mode                  = iv_edit_mode
        it_node                       = it_lock
        io_change                     = io_change
        iv_generic                    = lv_generic
        it_node_locked_for_delete     = it_locked_for_delete
      IMPORTING
        eo_message                    = DATA(lo_message)
        et_lockable_node_newly_locked = DATA(lt_node_reload)
        et_node_not_locked            = DATA(lt_failed)
      CHANGING
        ct_mod                        = ct_mod ).

    ASSERT ID /bobf/frw CONDITION
        /bobf/cl_tool_assert=>is_node_subset(
            it_node_set    = it_lock
            it_node_subset = lt_failed ) = abap_true.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = co_message ).

    INSERT LINES OF lt_failed INTO TABLE ct_failed_lock.

    IF lt_node_reload IS NOT INITIAL.
      do_loading(
        EXPORTING
          it_node           = lt_node_reload
          iv_reload         = abap_true
          iv_check_buf      = abap_false
          iv_within_loading = iv_within_loading
          iv_edit_mode      = iv_edit_mode
          io_change         = io_change
          iv_load_data      = COND #(
                                WHEN lv_generic = abap_true  THEN abap_false "for generic locking do existence check only
                                WHEN lv_generic = abap_false THEN abap_true )
          iv_load_subtree   = COND #(
                                WHEN lv_generic = abap_true  THEN /bobf/if_frw_c=>sc_load_whole_subtree "for generic locking the whole substructure is relevant
                                WHEN lv_generic = abap_false THEN /bobf/if_frw_c=>sc_load_own_lockgroup )
        IMPORTING
          eo_message        = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = co_message ).
    ENDIF.

  ENDMETHOD.


  METHOD map_to_node.

    DATA:
      ls_node TYPE /bobf/s_frw_node.


    CLEAR et_node.
    IF lines( it_key ) < 130. " threshold measured with ZIVCL_PERF_MAP_TO_NODE
      ls_node-node = iv_node_key.
      LOOP AT it_key INTO DATA(ls_key).
        ls_node-key = ls_key-key.
        INSERT ls_node INTO TABLE et_node.
      ENDLOOP.
    ELSE.
      DATA(lo_corresponding) = cl_abap_corresponding=>create_with_value(
                                 source      = it_key
                                 destination = et_node
                                 mapping     = VALUE #( ( kind = cl_abap_corresponding=>mapping_component  dstname = 'KEY'  srcname = 'KEY' )
                                                        ( kind = cl_abap_corresponding=>mapping_value      dstname = 'NODE' value   = REF #( iv_node_key ) ) ) ).
      lo_corresponding->execute( EXPORTING source      = it_key
                                 CHANGING  destination = et_node ).
    ENDIF.

  ENDMETHOD.


  METHOD needs_notify_keyload.
    "This method checks whether keyload needs to be notified and thus influences
    "execution of after loading determinations

    rv_notify_keyload = abap_false.
    ev_transient_fields_requested = iv_has_transient_elements.

    IF it_requested_attributes IS NOT INITIAL AND
       ir_load_attribute_tab IS BOUND AND
       ir_load_attribute_tab->* IS NOT INITIAL.

      rv_notify_keyload = abap_true.
      ev_transient_fields_requested = abap_false.

      DATA(lt_req_attr_sorted) = it_requested_attributes.
      SORT lt_req_attr_sorted BY table_line.
      LOOP AT ir_load_attribute_tab->* ASSIGNING FIELD-SYMBOL(<lv_load_attribute>).
        READ TABLE lt_req_attr_sorted TRANSPORTING NO FIELDS
                                      WITH KEY table_line = <lv_load_attribute> BINARY SEARCH.
        IF sy-subrc = 0.
          rv_notify_keyload = abap_false.
          ev_transient_fields_requested = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

    ENDIF.

    IF iv_has_auth_determ = abap_true."authority determinations need to be executed anyway
      ev_transient_fields_requested = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD notify_association_changes_cu.

    DATA:
      lt_change         TYPE /bobf/t_frw_change,
      lt_key_for_rba    TYPE /bobf/t_frw_key,
      lt_content_change TYPE /bobf/t_frw_change_content,
      lt_key_create     TYPE /bobf/t_frw_key,
      lt_key_update     TYPE /bobf/t_frw_key,
      ls_assoc          TYPE /bobf/s_confro_assoc,
      lt_assoc_chg_trig TYPE /bobf/t_confro_assoc_chg_trig.

    CLEAR eo_message.

    CHECK mv_no_content_changes = abap_false.
    CHECK mo_conf->ms_obj-notify_association_changes  = abap_true.
    CHECK mo_conf->ms_obj-assoc_change_notifs_by_bopf = abap_true.
    CHECK io_change IS BOUND.

    " Get changes: table is sorted by node_key, key, change_mode, external, failed, det_processed, val_processed
    io_change->get( IMPORTING et_change = lt_change ).

    LOOP AT lt_change ASSIGNING FIELD-SYMBOL(<ls_change>).

      AT NEW node_key.
        mo_conf->get_node( <ls_change>-node_key ).
        CLEAR:
          lt_key_create,
          lt_key_update.
      ENDAT.

      CHECK <ls_change>-external = abap_true AND
            <ls_change>-failed   = abap_false AND
            mo_conf->ms_last_node-assoc_change_notifs_by_bopf = abap_true.

      " Sort keys in changes into CREATE, UPDATE
      CASE <ls_change>-change_mode.
        WHEN /bobf/if_frw_c=>sc_modify_create.
          APPEND VALUE #( key = <ls_change>-key ) TO lt_key_create.
        WHEN /bobf/if_frw_c=>sc_modify_update.
          APPEND VALUE #( key = <ls_change>-key ) TO lt_key_update.
      ENDCASE.

      " Process all changes for one node
      AT END OF node_key.

        " Store combination of initial/non-initial CREATE/UPDATE key tables
        DATA(lo_key_table_selector) = lcla_key_table_selector=>create_instance_cu( it_key_create = lt_key_create
                                                                                         it_key_update = lt_key_update ).
        CHECK lo_key_table_selector IS BOUND.

        " Get triggers of associations for the current node
        mo_conf->get_assoc_change( EXPORTING iv_node_key                   = <ls_change>-node_key
                                   IMPORTING et_association_change_trigger = lt_assoc_chg_trig ).

        " Process each association (trigger) individually
        LOOP AT lt_assoc_chg_trig ASSIGNING FIELD-SYMBOL(<ls_assoc_chg_trig>) WHERE create = abap_true
                                                                              OR    update = abap_true. "#EC CI_SORTSEQ

          " Get configuration of the association which belongs to the current association trigger
          mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_assoc_chg_trig>-assoc_key
                              IMPORTING es_assoc     = ls_assoc ).
          CHECK ls_assoc-change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.

          IF <ls_assoc_chg_trig>-resolve_assoc_key IS NOT INITIAL.
            " Incoming association (CREATE, UPDATE): content change notifications are raised for
            " instances that are targets of the association with key <ls_assoc_chg_trig>-resolve_assoc_key

            " Determine source keys for RETRIEVE_BY_ASSOCIATION call from CREATE/UPDATE key tables
            " and triggers of the current association
            lo_key_table_selector->get_key_combination( EXPORTING iv_create = <ls_assoc_chg_trig>-create
                                                                  iv_update = <ls_assoc_chg_trig>-update
                                                                  iv_delete = <ls_assoc_chg_trig>-delete
                                                        IMPORTING et_key    = lt_key_for_rba ).
            CHECK lt_key_for_rba IS NOT INITIAL.

            " Perform RBA and add content change notifications for its targets
            add_notifs_for_resolve_assoc( EXPORTING it_source_key        = lt_key_for_rba
                                                    ir_assoc             = REF #( ls_assoc )
                                                    iv_resolve_assoc_key = <ls_assoc_chg_trig>-resolve_assoc_key
                                                    iv_state             = /bobf/if_conf_c=>sc_state_current
                                          CHANGING  co_message           = eo_message
                                                    ct_content_change    = lt_content_change
            ).
          ELSE.
            " Outgoing association: only UPDATE

            IF <ls_assoc_chg_trig>-update = abap_true AND
               lt_key_update IS NOT INITIAL.

              lt_content_change = VALUE #( BASE lt_content_change
                                           FOR wa_key IN lt_key_update
                                               ( key         = wa_key-key
                                                 content_key = <ls_assoc_chg_trig>-assoc_key
                                                 node_key    = <ls_change>-node_key
                                                 change_mode = /bobf/if_frw_c=>sc_modify_association ) ).
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDAT.

    ENDLOOP.

    io_change->add( it_content_change = lt_content_change ).

  ENDMETHOD.


  METHOD notify_association_changes_d.

    DATA:
      lt_change         TYPE /bobf/t_frw_change,
      lt_content_change TYPE /bobf/t_frw_change_content,
      lt_key_delete     TYPE /bobf/t_frw_key,
      ls_assoc          TYPE /bobf/s_confro_assoc,
      lt_assoc_chg_trig TYPE /bobf/t_confro_assoc_chg_trig.

    CLEAR eo_message.

    CHECK mv_no_content_changes = abap_false.
    CHECK mo_conf->ms_obj-notify_association_changes  = abap_true.
    CHECK mo_conf->ms_obj-assoc_change_notifs_by_bopf = abap_true.
    CHECK io_change IS BOUND.

    " Get changes: table is sorted by node_key, key, change_mode, external, failed, det_processed, val_processed
    io_change->get( IMPORTING et_change = lt_change ).

    LOOP AT lt_change ASSIGNING FIELD-SYMBOL(<ls_change>).

      AT NEW node_key.
        mo_conf->get_node( <ls_change>-node_key ).
        CLEAR lt_key_delete.
      ENDAT.

      CHECK <ls_change>-change_mode = /bobf/if_frw_c=>sc_modify_delete AND
            <ls_change>-external    = abap_true AND
            <ls_change>-failed      = abap_false AND
            mo_conf->ms_last_node-assoc_change_notifs_by_bopf = abap_true.

      APPEND VALUE #( key = <ls_change>-key ) TO lt_key_delete.

      " Process all changes for one node
      AT END OF node_key.
        CHECK lt_key_delete IS NOT INITIAL.

        " Get triggers of associations for the current node
        mo_conf->get_assoc_change( EXPORTING iv_node_key                   = <ls_change>-node_key
                                   IMPORTING et_association_change_trigger = lt_assoc_chg_trig ).

        " Process each association (trigger) individually
        LOOP AT lt_assoc_chg_trig ASSIGNING FIELD-SYMBOL(<ls_assoc_chg_trig>) WHERE delete = abap_true
                                                                              AND   resolve_assoc_key IS NOT INITIAL. "#EC CI_SORTSEQ
          " Only incoming associations: content change notifications are raised for instances
          " that are targets of the association with key <ls_assoc_chg_trig>-resolve_assoc_key

          " Get configuration of the association which belongs to the current association trigger
          mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_assoc_chg_trig>-assoc_key
                              IMPORTING es_assoc     = ls_assoc ).
          CHECK ls_assoc-change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.

          " Perform RBA and add content change notifications for its targets
          add_notifs_for_resolve_assoc( EXPORTING it_source_key        = lt_key_delete
                                                  ir_assoc             = REF #( ls_assoc )
                                                  iv_resolve_assoc_key = <ls_assoc_chg_trig>-resolve_assoc_key
                                                  iv_state             = iv_last_state
                                        CHANGING  co_message           = eo_message
                                                  ct_content_change    = lt_content_change ).
        ENDLOOP.
      ENDAT.
    ENDLOOP.

    io_change->add( it_content_change = lt_content_change ).

  ENDMETHOD.


  METHOD notify_association_changes_do.

    DATA:
      lt_change         TYPE /bobf/t_frw_change,
      lv_process_node   TYPE abap_bool,
      lt_key_for_rba    TYPE /bobf/t_frw_key,
      lt_content_change TYPE /bobf/t_frw_change_content,
      lt_key_create     TYPE /bobf/t_frw_key,
      lt_key_update     TYPE /bobf/t_frw_key,
      lt_key_delete     TYPE /bobf/t_frw_key,
      ls_assoc          TYPE /bobf/s_confro_assoc,
      lt_assoc_chg_trig TYPE /bobf/t_confro_assoc_chg_trig.

    CLEAR eo_message.

    CHECK mv_no_content_changes = abap_false.
    CHECK mo_conf->ms_obj-notify_association_changes  = abap_true.
    CHECK mo_conf->ms_obj-assoc_change_notifs_by_bopf = abap_true.
    CHECK io_change IS BOUND.

    " Get changes: table is sorted by node_key, key, change_mode, external, failed, det_processed, val_processed
    io_change->get( IMPORTING et_change = lt_change ).

    LOOP AT lt_change ASSIGNING FIELD-SYMBOL(<ls_change>).

      AT NEW node_key.
        " Get node configuration and determine if changes for that node need to be processed
        mo_conf->get_node( <ls_change>-node_key ).
        IF mo_conf->ms_last_node-assoc_change_notifs_by_bopf = abap_true AND
           mo_conf->ms_last_node-delegation_class IS NOT INITIAL.
          lv_process_node = abap_true.
        ELSE.
          lv_process_node = abap_false.
        ENDIF.
        CLEAR:
          lt_key_create,
          lt_key_update,
          lt_key_delete.
      ENDAT.

      CHECK <ls_change>-external = abap_true AND
            <ls_change>-failed   = abap_false AND
            lv_process_node      = abap_true.

      " Sort keys in changes into CREATE, UPDATE, DELETE
      CASE <ls_change>-change_mode.
        WHEN /bobf/if_frw_c=>sc_modify_create.
          APPEND VALUE #( key = <ls_change>-key ) TO lt_key_create.
        WHEN /bobf/if_frw_c=>sc_modify_update.
          APPEND VALUE #( key = <ls_change>-key ) TO lt_key_update.
        WHEN /bobf/if_frw_c=>sc_modify_delete.
          APPEND VALUE #( key = <ls_change>-key ) TO lt_key_delete.
      ENDCASE.

      " Process all changes for one node
      AT END OF node_key.

        " Store combination of initial/non-initial CREATE/UPDATE/DELETE key tables
        DATA(lo_key_table_selector) = lcla_key_table_selector=>create_instance( it_key_create = lt_key_create
                                                                                      it_key_update = lt_key_update
                                                                                      it_key_delete = lt_key_delete ).
        CHECK lo_key_table_selector IS BOUND.

        " Get triggers of associations for the current node
        mo_conf->get_assoc_change( EXPORTING iv_node_key                   = <ls_change>-node_key
                                   IMPORTING et_association_change_trigger = lt_assoc_chg_trig ).

        " Process each association (trigger) individually
        LOOP AT lt_assoc_chg_trig ASSIGNING FIELD-SYMBOL(<ls_assoc_chg_trig>).

          " Get configuration of the association which belongs to the current association trigger
          mo_conf->get_assoc( EXPORTING iv_assoc_key = <ls_assoc_chg_trig>-assoc_key
                              IMPORTING es_assoc     = ls_assoc ).
          CHECK ls_assoc-change_resolve = /bobf/if_conf_c=>sc_assoc_change_bopf.

          IF <ls_assoc_chg_trig>-resolve_assoc_key IS NOT INITIAL.
            " Incoming association (CREATE, UPDATE, DELETE): content change notifications are raised for
            " instances that are targets of the association with key <ls_assoc_chg_trig>-resolve_assoc_key

            " Determine source keys for RETRIEVE_BY_ASSOCIATION call from CREATE/UPDATE/DELETE key tables
            " and triggers of the current association
            lo_key_table_selector->get_key_combination( EXPORTING iv_create = <ls_assoc_chg_trig>-create
                                                                  iv_update = <ls_assoc_chg_trig>-update
                                                                  iv_delete = <ls_assoc_chg_trig>-delete
                                                        IMPORTING et_key    = lt_key_for_rba ).
            CHECK lt_key_for_rba IS NOT INITIAL.

            " Perform RBA and add content change notifications for its targets
            add_notifs_for_resolve_assoc( EXPORTING it_source_key        = lt_key_for_rba
                                                    ir_assoc             = REF #( ls_assoc )
                                                    iv_resolve_assoc_key = <ls_assoc_chg_trig>-resolve_assoc_key
                                                    iv_state             = iv_state
                                          CHANGING  co_message           = eo_message
                                                    ct_content_change    = lt_content_change
            ).
          ELSE.
            " Outgoing association: only UPDATE

            IF <ls_assoc_chg_trig>-update = abap_true AND
               lt_key_update IS NOT INITIAL.

              lt_content_change = VALUE #( BASE lt_content_change
                                           FOR wa_key IN lt_key_update
                                               ( key         = wa_key-key
                                                 content_key = <ls_assoc_chg_trig>-assoc_key
                                                 node_key    = <ls_change>-node_key
                                                 change_mode = /bobf/if_frw_c=>sc_modify_association ) ).
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDAT.

    ENDLOOP.

    io_change->add( it_content_change = lt_content_change ).

  ENDMETHOD.


  METHOD notify_nodes_read_cache_enable.

*   This method enables nodes registered as "non caching" to be cached from now on.
    CHECK it_node_key IS NOT INITIAL.
    CHECK mo_non_cache_reg->/bobf/if_buf_non_cache_regstry~has_non_cached_nodes( ).

    mo_conf->get_node_tab(
      IMPORTING
        et_node = DATA(lt_node)
    ).

    DATA(lt_node_loadgroup) = /bobf/cl_confrt_assist=>get_nodes_of_same_loadgroup(
      EXPORTING
        it_node_key = it_node_key
        it_node_all = lt_node
    ).

    mo_non_cache_reg->enable_read_cache_for_nodes( it_node_key = lt_node_loadgroup  io_bopf_handle = me ).

  ENDMETHOD.


  METHOD notify_property_changes.

    DATA: lt_change          TYPE /bobf/t_frw_change,
          ls_change          TYPE /bobf/s_frw_change,
          lt_property_change TYPE /bobf/t_frw_change_content,
          ls_property_change TYPE /bobf/s_frw_change_content,
          lt_target_key      TYPE /bobf/t_frw_key,
          lt_failed_key      TYPE /bobf/t_frw_key,
          lt_create          TYPE /bobf/t_frw_key,
          lt_update          TYPE /bobf/t_frw_key,
          lt_delete          TYPE /bobf/t_frw_key,
          lt_lock            TYPE /bobf/t_frw_key,
          ls_key             TYPE /bobf/s_frw_key,
          lt_node            TYPE /bobf/t_frw_node,
          lt_node_do_root    TYPE /bobf/t_frw_node,
          lt_node_do_subtree TYPE /bobf/t_frw_node,
          ls_node            TYPE /bobf/s_frw_node,
          lt_pct             TYPE /bobf/t_confro_prop_chg_trig,
          ls_pct             TYPE /bobf/s_confro_prop_chg_trig,
          lo_message         TYPE REF TO /bobf/if_frw_message.

    CLEAR eo_message.

    CHECK mo_conf->ms_obj-notify_property_changes = abap_true.
    CHECK mv_no_content_changes = abap_false.

* only done if any retrieve properties has been performed before
    CHECK mt_node_properties_requested IS NOT INITIAL.

    CHECK io_change IS BOUND.
    io_change->get( IMPORTING et_change = lt_change ).
    CHECK lt_change IS NOT INITIAL.

    LOOP AT lt_change INTO ls_change.

      AT NEW node_key.
        READ TABLE mt_node_properties_requested TRANSPORTING NO FIELDS
          WITH KEY key_sort COMPONENTS table_line = ls_change-node_key.
        IF sy-subrc = 0.
          mo_conf->get_property_change(
            EXPORTING iv_node_key                = ls_change-node_key
            IMPORTING et_property_change_trigger = lt_pct ).
        ELSE.
          CLEAR lt_pct.
        ENDIF.
      ENDAT.

      IF ls_change-failed   = abap_false AND
         ls_change-external = abap_true.

        IF iv_delete = abap_false OR
           ls_change-change_mode = /bobf/if_frw_c=>sc_modify_delete.

          " in case of IV_DELETE, only delete property change notifications must be returned
          ls_key-key = ls_change-key.
          CASE ls_change-change_mode.
            WHEN /bobf/if_frw_c=>sc_modify_create.
              APPEND ls_key TO lt_create.
            WHEN /bobf/if_frw_c=>sc_modify_update.
              APPEND ls_key TO lt_update.
            WHEN /bobf/if_frw_c=>sc_modify_delete.
              APPEND ls_key TO lt_delete.
            WHEN /bobf/if_frw_c=>sc_modify_lock.
              APPEND ls_key TO lt_lock.
          ENDCASE.

        ENDIF.
      ENDIF.

      AT END OF node_key.
* ___________________________________________________________________________ *
*     create property changes for created instances
        IF lt_create IS NOT INITIAL.
          LOOP AT lt_pct INTO ls_pct.
            CHECK ls_pct-create = abap_true
              AND ls_pct-assoc_key IS NOT INITIAL.
            IF mo_conf->ms_last_assoc-assoc_key <> ls_pct-assoc_key.
              mo_conf->get_assoc( iv_assoc_key = ls_pct-assoc_key ).
            ENDIF.
            ls_property_change-node_key    = mo_conf->ms_last_assoc-target_node_key.
            ls_property_change-change_mode = ls_pct-change_mode.

            retrieve_by_association(
              EXPORTING
                iv_node_key    = mo_conf->ms_last_assoc-source_node_key
                it_key         = lt_create
                iv_association = ls_pct-assoc_key
                iv_state       = /bobf/if_conf_c=>sc_state_current
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_target_key ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            LOOP AT lt_target_key INTO ls_key.
              ls_property_change-key = ls_key-key.
              APPEND ls_property_change TO lt_property_change.
            ENDLOOP.
          ENDLOOP.
          CLEAR lt_create.
        ENDIF.
* ___________________________________________________________________________ *
*     create property changes for updated instances
        IF lt_update IS NOT INITIAL.
          LOOP AT lt_pct INTO ls_pct.
            CHECK ls_pct-update = abap_true.

            IF ls_pct-assoc_key IS INITIAL.
              LOOP AT lt_update INTO ls_key.
                ls_property_change-node_key    = ls_change-node_key.
                ls_property_change-key         = ls_key-key.
                ls_property_change-change_mode = ls_pct-change_mode.
                APPEND ls_property_change TO lt_property_change.
              ENDLOOP.
              CONTINUE.
            ENDIF.

            IF mo_conf->ms_last_assoc-assoc_key <> ls_pct-assoc_key.
              mo_conf->get_assoc( iv_assoc_key = ls_pct-assoc_key ).
            ENDIF.
            ls_property_change-node_key    = mo_conf->ms_last_assoc-target_node_key.
            ls_property_change-change_mode = ls_pct-change_mode.

            retrieve_by_association(
              EXPORTING
                iv_node_key    = mo_conf->ms_last_assoc-source_node_key
                it_key         = lt_update
                iv_association = ls_pct-assoc_key
                iv_state       = /bobf/if_conf_c=>sc_state_current
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_target_key ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            LOOP AT lt_target_key INTO ls_key.
              ls_property_change-key = ls_key-key.
              APPEND ls_property_change TO lt_property_change.
            ENDLOOP.
          ENDLOOP.
          CLEAR lt_update.
        ENDIF.
* ___________________________________________________________________________ *
*     create property changes for deleted instances
        IF lt_delete IS NOT INITIAL AND iv_last_state IS NOT INITIAL.
          LOOP AT lt_pct INTO ls_pct.
            CHECK ls_pct-delete = abap_true
              AND ls_pct-assoc_key IS NOT INITIAL.
            IF mo_conf->ms_last_assoc-assoc_key <> ls_pct-assoc_key.
              mo_conf->get_assoc( iv_assoc_key = ls_pct-assoc_key ).
            ENDIF.
            ls_property_change-node_key    = mo_conf->ms_last_assoc-target_node_key.
            ls_property_change-change_mode = ls_pct-change_mode.

            retrieve_by_association(
              EXPORTING
                iv_node_key    = mo_conf->ms_last_assoc-source_node_key
                it_key         = lt_delete
                iv_association = ls_pct-assoc_key
                iv_state       = iv_last_state
              IMPORTING
                eo_message     = lo_message
                et_target_key  = lt_target_key ).

            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

            LOOP AT lt_target_key INTO ls_key.
              ls_property_change-key = ls_key-key.
              APPEND ls_property_change TO lt_property_change.
            ENDLOOP.
          ENDLOOP.
          CLEAR lt_delete.
        ENDIF.
* ___________________________________________________________________________ *
*     create property changes for lock changes
        IF lt_lock IS NOT INITIAL.
*       perform existence check for locked node
          retrieve(
            EXPORTING
              iv_node_key             = ls_change-node_key
              it_key                  = lt_lock
              iv_state                = /bobf/if_conf_c=>sc_state_current
              iv_fill_data            = abap_false
              iv_buffer_only          = abap_true
            IMPORTING
              et_failed_key           = lt_failed_key ).

          LOOP AT lt_failed_key INTO ls_key.
            DELETE lt_lock WHERE key = ls_key-key.
          ENDLOOP.

*       set property change for all subnodes
          CLEAR: lt_node,
                 lt_node_do_root,
                 lt_node_do_subtree.

          get_subnodes(
            EXPORTING
              iv_node_key                = ls_change-node_key
              it_key                     = lt_lock
              it_node_key                = mt_node_properties_requested
              iv_stop_at_lockable        = abap_true
              iv_buffer_only             = abap_false
            IMPORTING
              eo_message                 = lo_message
            CHANGING
              ct_host_node               = lt_node
              ct_delegation_root_node    = lt_node_do_root
              ct_delegation_subtree      = lt_node_do_subtree ).

*       set property change for all nodes
          LOOP AT lt_node INTO ls_node.
            ls_property_change-node_key    = ls_node-node.
            ls_property_change-key         = ls_node-key.
            ls_property_change-change_mode = /bobf/if_frw_c=>sc_modify_property_node.
            APPEND ls_property_change TO lt_property_change.
          ENDLOOP.

          LOOP AT lt_node_do_root INTO ls_node.
            ls_property_change-node_key    = ls_node-node.
            ls_property_change-key         = ls_node-key.
            ls_property_change-change_mode = /bobf/if_frw_c=>sc_modify_property_node.
            APPEND ls_property_change TO lt_property_change.
          ENDLOOP.

          LOOP AT lt_node_do_subtree INTO ls_node.
            ls_property_change-node_key    = ls_node-node.
            ls_property_change-key         = ls_node-key.
            ls_property_change-change_mode = /bobf/if_frw_c=>sc_modify_property_node.
            APPEND ls_property_change TO lt_property_change.
          ENDLOOP.

          CLEAR lt_lock.
        ENDIF.
      ENDAT.
    ENDLOOP.


* ___________________________________________________________________________ *
* write property changes
    IF lt_property_change IS NOT INITIAL.
      io_change->add( it_content_change = lt_property_change ).
    ENDIF.

  ENDMETHOD.


  METHOD prepare_notifications_f_export.
    " Get association sources
    DATA(lt_association_source) = io_change->get_n_drop_association_sources( ).
    " Create association change notifications and add content changes
    io_change->/bobf/if_frw_change~add( it_content_change = convert_asc_src_to_cont_change( lt_association_source ) ).
    " Prepare for export
    io_change->prepare_for_export( ).
  ENDMETHOD.


  METHOD raise_notify_changes.

    DATA: lo_change_cl   TYPE REF TO /bobf/cl_frw_change,
          lo_change      TYPE REF TO /bobf/if_frw_change,
          lo_change_temp TYPE REF TO /bobf/if_frw_change,
          lo_int_access  TYPE REF TO /bobf/cl_frw_int_access.

* Get changes for early notification
    IF io_change IS SUPPLIED.
*   Notify only supplied change object
      lo_change_cl ?= io_change.
      lo_change = lo_change_cl->export_changes_for_notify( ).
    ENDIF.

    IF iv_notify_entire_stack = abap_true.
*   Notify entire access stack
      LOOP AT mt_access_stack INTO lo_int_access.
        IF lo_int_access->mo_change IS BOUND.
          lo_change_cl ?= lo_int_access->mo_change.
          lo_change_temp = lo_change_cl->export_changes_for_notify( ).
          IF lo_change IS NOT BOUND.
            lo_change = lo_change_temp.
          ELSE.
            lo_change->merge( lo_change_temp ).
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.
    CHECK lo_change IS BOUND.

* And prepare them for exporting.
    lo_change_cl ?= lo_change.
    prepare_notifications_f_export( lo_change_cl ).
* Enrich properties also with association and property change
* notifications as they won't be created later on anymore
    notify_association_changes_cu( lo_change_cl ).
    notify_property_changes( lo_change_cl ).
    lo_change_cl->delete_duplicate_notifications( ).

    RAISE EVENT /bobf/if_frw_service_layer~notify_changes
      EXPORTING io_change = lo_change.

  ENDMETHOD.


  METHOD remove_durable_messages.

    CHECK /bobf/cl_frw_intrnl_msg_mode=>is_message_mode_durable( ).

    LOOP AT it_node_deleted_w_children ASSIGNING FIELD-SYMBOL(<ls_node_deleted_w_children>)
      GROUP BY ( node = <ls_node_deleted_w_children>-node ) INTO DATA(ls_group_node).

      DATA(lo_delete_msg_container) = /bobf/cl_frw_message_factory=>create_container( ).

      CAST /bobf/cl_frw_durable_message( lo_delete_msg_container
        )->set_deleted_keys_with_children( is_context = VALUE #( bo_key   = mo_conf->ms_obj-bo_key
                                                                 node_key = ls_group_node-node )
                                           it_key     = VALUE #( FOR node IN GROUP ls_group_node ( key = node-key ) ) ).

      collect_messages( EXPORTING io_message = lo_delete_msg_container
                        CHANGING  co_message = co_message ).
    ENDLOOP.

    LOOP AT it_node_deleted_wo_children ASSIGNING FIELD-SYMBOL(<ls_node_deleted_wo_children>)
      GROUP BY ( node = <ls_node_deleted_wo_children>-node ) INTO ls_group_node.

      lo_delete_msg_container = /bobf/cl_frw_message_factory=>create_container( ).

      CAST /bobf/cl_frw_durable_message( lo_delete_msg_container
        )->set_deleted_keys( is_context = VALUE #( bo_key   = mo_conf->ms_obj-bo_key
                                                   node_key = ls_group_node-node )
                             it_key     = VALUE #( FOR node IN GROUP ls_group_node ( key = node-key ) ) ).

      collect_messages( EXPORTING io_message = lo_delete_msg_container
                        CHANGING  co_message = co_message ).
    ENDLOOP.

  ENDMETHOD.


  METHOD restrict_property.
* delete not required property data

    DATA:
      lv_where       TYPE string,
      lt_where       TYPE STANDARD TABLE OF string,
      lv_cat(3)      TYPE c,
      lv_apo         TYPE char1  VALUE '''',                "#EC NOTEXT
      lv_open        TYPE char1  VALUE '(',                 "#EC NOTEXT
      lv_close       TYPE char1  VALUE ')',                 "#EC NOTEXT
      lv_content(13) TYPE c      VALUE 'CONTENT_CAT =',     "#EC NOTEXT
      lv_and(3)      TYPE c      VALUE 'AND',               "#EC NOTEXT
      lv_or(2)       TYPE c      VALUE 'OR',                "#EC NOTEXT
      lv_initial     TYPE char30 VALUE 'ATTRIBUTE_NAME = SPACE', "#EC NOTEXT
      lv_notinitial  TYPE char30 VALUE 'ATTRIBUTE_NAME > SPACE'. "#EC NOTEXT
    FIELD-SYMBOLS:
      <cs_property_data> TYPE /bobf/s_frw_property_d.

    IF ct_property_data IS NOT INITIAL.

*   build WHERE condition
      IF it_action IS INITIAL.
        CLEAR lv_where.
        CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_act lv_apo INTO lv_cat.
        IF iv_action_property           = abap_false AND
           iv_action_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_action_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_action_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
          INTO lv_where SEPARATED BY space.
        ENDIF.
        IF lv_where IS NOT INITIAL.
          APPEND lv_where TO lt_where.
        ENDIF.
      ELSE.
        " restrict static action properties to the desired actions (IT_ACTION)
        LOOP AT ct_property_data ASSIGNING <cs_property_data> WHERE content_cat = /bobf/if_conf_c=>sc_content_act.
          READ TABLE it_action WITH TABLE KEY key_sort COMPONENTS table_line = <cs_property_data>-content_key TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            DELETE ct_property_data.
          ENDIF.
        ENDLOOP.
      ENDIF.

      IF it_assoc IS INITIAL.
        CLEAR lv_where.
        CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_ass lv_apo INTO lv_cat.
        IF iv_assoc_property           = abap_false AND
           iv_assoc_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_assoc_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_assoc_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
          INTO lv_where SEPARATED BY space.
        ENDIF.
        IF lv_where IS NOT INITIAL.
          IF lt_where IS NOT INITIAL.
            APPEND lv_or TO lt_where.
          ENDIF.
          APPEND lv_where TO lt_where.
        ENDIF.
      ELSE.
        " restrict static association properties to the desired association (IT_ASSOC)
        LOOP AT ct_property_data ASSIGNING <cs_property_data> WHERE content_cat = /bobf/if_conf_c=>sc_content_ass.
          READ TABLE it_assoc WITH TABLE KEY key_sort COMPONENTS table_line = <cs_property_data>-content_key TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            DELETE ct_property_data.
          ENDIF.
        ENDLOOP.
      ENDIF.

      IF it_node_attribute IS INITIAL.
        CLEAR lv_where.
        CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_nod lv_apo INTO lv_cat.
        IF iv_node_property           = abap_false AND
           iv_node_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_node_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
           INTO lv_where SEPARATED BY space.
        ELSEIF iv_node_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
          INTO lv_where SEPARATED BY space.
        ENDIF.
        IF lv_where IS NOT INITIAL.
          IF lt_where IS NOT INITIAL.
            APPEND lv_or TO lt_where.
          ENDIF.
          APPEND lv_where TO lt_where.
        ENDIF.
      ELSE.
        " restrict static node attribute properties to the desired node attributes (IT_NODE_ATTRIBUTE)
        LOOP AT ct_property_data ASSIGNING <cs_property_data> WHERE content_cat = /bobf/if_conf_c=>sc_content_nod
                                                                AND attribute_name IS NOT INITIAL.
          " only if it s node attribute property (not a node property)...
          READ TABLE it_node_attribute WITH KEY table_line = <cs_property_data>-attribute_name TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            DELETE ct_property_data.
          ENDIF.
        ENDLOOP.
      ENDIF.

      IF it_query IS INITIAL.
        CLEAR lv_where.
        CONCATENATE lv_apo /bobf/if_conf_c=>sc_content_qry lv_apo INTO lv_cat.
        IF iv_query_property           = abap_false AND
           iv_query_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_query_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_initial lv_close
          INTO lv_where SEPARATED BY space.
        ELSEIF iv_query_attribute_property = abap_false.
          CONCATENATE lv_open lv_content lv_cat lv_and lv_notinitial lv_close
          INTO lv_where SEPARATED BY space.
        ENDIF.
        IF lv_where IS NOT INITIAL.
          IF lt_where IS NOT INITIAL.
            APPEND lv_or TO lt_where.
          ENDIF.
          APPEND lv_where TO lt_where.
        ENDIF.
      ELSE.
        " restrict static node query properties to the desired queries (IT_QUERY)
        LOOP AT ct_property_data ASSIGNING <cs_property_data> WHERE content_cat = /bobf/if_conf_c=>sc_content_qry.
          READ TABLE it_query WITH TABLE KEY key_sort COMPONENTS table_line = <cs_property_data>-content_key TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            DELETE ct_property_data.
          ENDIF.
        ENDLOOP.
      ENDIF.

*   execute one dynamic DELETE WHERE
      IF lt_where IS NOT INITIAL.
        DELETE ct_property_data WHERE (lt_where).
      ENDIF.

    ENDIF.

  ENDMETHOD.


  METHOD retrieve.

    DATA: ls_nodeconf          TYPE /bobf/s_confro_node,
          lt_node              TYPE /bobf/t_frw_node,
          ls_node              TYPE /bobf/s_frw_node,
          lt_node_not_locked   TYPE /bobf/t_frw_node,
          lt_node_newly_locked TYPE /bobf/t_frw_node,
          lt_failed_node       TYPE /bobf/t_frw_node,
          lt_failed_det        TYPE /bobf/t_frw_node,
          lt_failed_key        TYPE /bobf/t_frw_key,
          lt_key               TYPE /bobf/t_frw_key,
          ls_key               TYPE /bobf/s_frw_key,
          lt_key_retrieve      TYPE /bobf/t_frw_key,
          lv_notify_keyload    TYPE boole_d,
          lv_load_subtree      TYPE /bobf/frw_load_subtree,
          lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
          lo_message           TYPE REF TO /bobf/if_frw_message,
          lx_root              TYPE REF TO cx_root.


    BREAK-POINT ID /bobf/frw.
    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

    CLEAR: eo_change,
           eo_message,
           et_failed_key,
           et_data,
           et_node_cat.

    IF mo_conf->ms_last_node-node_key = iv_node_key.
      ls_nodeconf = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
        EXPORTING iv_node_key = iv_node_key
        IMPORTING es_node     = ls_nodeconf ).
    ENDIF.

    lt_key_retrieve = it_key.

* ____________________________________________________________________ *
*   check for request attributes
    needs_notify_keyload(
        EXPORTING
          it_requested_attributes       = it_requested_attributes
          ir_load_attribute_tab         = ls_nodeconf-det_load_attributes
          iv_has_transient_elements     = ls_nodeconf-has_trans_fields
          iv_has_auth_determ            = ls_nodeconf-has_auth_determ
        IMPORTING
          ev_transient_fields_requested = DATA(lv_transient_fields_requested)
        RECEIVING
          rv_notify_keyload             = lv_notify_keyload
    ).

    "with retrieval of transient fields, caching is required
    IF lv_transient_fields_requested = abap_true.
      notify_nodes_read_cache_enable( it_node_key =  VALUE #( ( key = iv_node_key ) ) ).
    ENDIF.
* ____________________________________________________________________ *
* check for reload
    IF iv_invalidate_cache = abap_true                           OR
       ( iv_edit_mode          <> /bobf/if_conf_c=>sc_edit_read_only AND
       mo_conf->ms_obj-no_lock = abap_false ).
*    potential reload required
      map_to_node(
        EXPORTING
          iv_node_key = iv_node_key
          it_key      = lt_key_retrieve
        IMPORTING
          et_node     = lt_node ).

      eo_change = /bobf/cl_frw_factory=>get_change( ).

* ____________________________________________________________________ *
*   check locks & lock if necessary
      IF iv_edit_mode             <> /bobf/if_conf_c=>sc_edit_read_only AND
          mo_conf->ms_obj-no_lock = abap_false.
*     lock requested nodes
        mo_lock_manager->lock(
          EXPORTING
            iv_edit_mode                  = iv_edit_mode
            it_node                       = lt_node
            io_change                     = eo_change
            iv_generic                    = abap_false
          IMPORTING
            et_failed_node                = lt_failed_node
            et_lockable_node_newly_locked = lt_node_newly_locked
            et_node_not_locked            = lt_node_not_locked
            eo_message                    = lo_message ).

      ELSEIF iv_invalidate_cache  = abap_true AND
          mo_conf->ms_obj-no_lock = abap_false.
*     check locking on requested nodes
        mo_lock_manager->lock(
          EXPORTING
            iv_edit_mode       = /bobf/if_conf_c=>sc_edit_optimistic
            iv_check_only      = abap_true
            it_node            = lt_node
            io_change          = eo_change
            iv_generic         = abap_false
          IMPORTING
            et_failed_node     = lt_failed_node
            et_node_not_locked = lt_node_not_locked
            eo_message         = lo_message ).

      ELSEIF iv_invalidate_cache = abap_true.
        lt_node_not_locked = lt_node.
      ENDIF.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      LOOP AT lt_failed_node INTO ls_node.
        DELETE lt_key_retrieve USING KEY key_sort WHERE key = ls_node-key.
      ENDLOOP.

      IF lt_node_newly_locked IS NOT INITIAL.
*     reload lock groups of newly locked lockable nodes
        do_loading(
          EXPORTING
            it_node           = lt_node_newly_locked
            iv_check_buf      = abap_false
            iv_reload         = abap_true
            iv_within_loading = iv_within_loading
            iv_load_data      = iv_fill_data
            iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
            iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
            io_change         = eo_change
            iv_notify_keyload = lv_notify_keyload
          IMPORTING
            eo_message        = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      IF iv_invalidate_cache = abap_true AND
          lt_node_not_locked IS NOT INITIAL.
        IF mo_conf->ms_obj-objcat = /bobf/if_conf_c=>sc_objcat_do AND
           iv_node_key = mo_conf->ms_obj-root_node_key.
          lv_load_subtree = /bobf/if_frw_c=>sc_load_own_lockgroup.
        ELSE.
          lv_load_subtree = /bobf/if_frw_c=>sc_load_no_subtree.
        ENDIF.
*     reload not locked nodes
        do_loading(
          EXPORTING
            it_node           = lt_node_not_locked
            iv_check_buf      = abap_false
            iv_reload         = abap_true
            iv_within_loading = iv_within_loading
            iv_load_data      = iv_fill_data
            iv_load_subtree   = lv_load_subtree
            iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
            io_change         = eo_change
          IMPORTING
            eo_message        = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* delegate call
    IF ls_nodeconf-delegation_class IS NOT INITIAL.

      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.
      TRY.
          lo_delegation = get_delegation( iv_node_key ).
          DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
          lo_delegation->retrieve(
            EXPORTING
              iv_node_key             = iv_node_key
              it_key                  = lt_key_retrieve
              iv_state                = iv_state
              iv_fill_data            = iv_fill_data
              it_requested_attributes = it_requested_attributes
              iv_invalidate_cache     = iv_invalidate_cache
              iv_edit_mode            = iv_edit_mode
              io_read                 = mo_delegation_read
              io_change               = eo_change
            IMPORTING
              eo_message              = lo_message
              et_data                 = et_data
              et_failed_key           = et_failed_key ).
          /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.

      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key_retrieve
              it_key_subset = lt_failed_key ) = abap_true.
      ASSERT ID /bobf/frw_error CONDITION
          /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ) = abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

    ELSE.

* ____________________________________________________________________ *
*   retrieve data from buffer
      IF ls_nodeconf-optimized_buffer_access = abap_true  AND
         ls_nodeconf-transient               = abap_false AND
         iv_buffer_only                      = abap_false.

        IF eo_change IS NOT BOUND.
          eo_change = /bobf/cl_frw_factory=>get_change( ).
        ENDIF.

        TRY.
            IF et_node_cat IS REQUESTED.
              mo_buffer->retrieve(
                EXPORTING
                  iv_node_key       = iv_node_key
                  it_key            = lt_key_retrieve
                  iv_state          = iv_state
                  iv_fill_data      = iv_fill_data
                  iv_buffer_only    = abap_false
                  io_change         = eo_change
                  iv_notify_keyload = lv_notify_keyload
                IMPORTING
                  et_data           = et_data
                  et_failed_key     = et_failed_key
                  et_node_cat       = et_node_cat ).
            ELSE.
              mo_buffer->retrieve(
                EXPORTING
                  iv_node_key       = iv_node_key
                  it_key            = lt_key_retrieve
                  iv_state          = iv_state
                  iv_fill_data      = iv_fill_data
                  iv_buffer_only    = abap_false
                  io_change         = eo_change
                  iv_notify_keyload = lv_notify_keyload
                IMPORTING
                  et_data           = et_data
                  et_failed_key     = et_failed_key ).
            ENDIF.

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key_retrieve
                it_key_subset = et_failed_key ) = abap_true.

        after_loading(
          EXPORTING
            io_change         = eo_change
            iv_within_loading = iv_within_loading
            iv_load_state     = iv_state
          IMPORTING
            eo_message        = lo_message
            et_failed_node    = lt_failed_det ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

*     check for changes on requested node
        eo_change->get_changes(
          EXPORTING
            iv_node_key    = iv_node_key
            iv_change_mode = /bobf/if_frw_c=>sc_modify
          IMPORTING
            et_changed_key = lt_key ).

*     check for failed determinations after loading on that node and other nodes due to authority determinations
        IF lt_failed_det IS NOT INITIAL OR
           lt_key        IS NOT INITIAL.
*        retrieve data from buffer again (if changed after loading)
          TRY.
              IF et_node_cat IS REQUESTED.
                mo_buffer->retrieve(
                 EXPORTING
                   iv_node_key       = iv_node_key
                   it_key            = lt_key_retrieve
                   iv_state          = iv_state
                   iv_fill_data      = iv_fill_data
                   iv_buffer_only    = abap_true
                 IMPORTING
                   et_data           = et_data
                   et_failed_key     = et_failed_key
                   et_node_cat       = et_node_cat ).
              ELSE.
                mo_buffer->retrieve(
                  EXPORTING
                    iv_node_key       = iv_node_key
                    it_key            = lt_key_retrieve
                    iv_state          = iv_state
                    iv_fill_data      = iv_fill_data
                    iv_buffer_only    = abap_true
                  IMPORTING
                    et_data           = et_data
                    et_failed_key     = et_failed_key ).
              ENDIF.
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.
        ENDIF.

      ELSE.
*     default buffer access
        TRY.
            IF et_node_cat IS REQUESTED.
              mo_buffer->retrieve(
                EXPORTING
                  iv_node_key       = iv_node_key
                  it_key            = lt_key_retrieve
                  iv_state          = iv_state
                  iv_fill_data      = iv_fill_data
                  iv_buffer_only    = abap_true
                IMPORTING
                  et_data           = et_data
                  et_failed_key     = lt_failed_key
                  et_node_cat       = et_node_cat ).
            ELSE.
              mo_buffer->retrieve(
                 EXPORTING
                   iv_node_key       = iv_node_key
                   it_key            = lt_key_retrieve
                   iv_state          = iv_state
                   iv_fill_data      = iv_fill_data
                   iv_buffer_only    = abap_true
                 IMPORTING
                   et_data           = et_data
                   et_failed_key     = lt_failed_key ).
            ENDIF.
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key_retrieve
                it_key_subset = lt_failed_key ) = abap_true.

        IF lt_failed_key IS NOT INITIAL AND
           ( ls_nodeconf-transient = abap_true  AND iv_within_retrieve = abap_false OR
             ls_nodeconf-transient = abap_false AND iv_buffer_only     = abap_false ).
*         in case not all key were found

          IF ls_nodeconf-transient = abap_false AND
             iv_buffer_only        = abap_false.
*         persistent node
            do_loading(
              EXPORTING
                iv_node_key       = iv_node_key
                it_key            = lt_failed_key
                iv_check_buf      = abap_false
                iv_load_data      = iv_fill_data
                iv_notify_keyload = lv_notify_keyload
                iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
                io_change         = eo_change
              IMPORTING
                eo_message        = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).

          ELSE.
*         transient node
            do_determinations_retrieve(
              EXPORTING
                iv_node_key       = iv_node_key
                it_key            = lt_failed_key
                iv_state          = iv_state
                iv_within_loading = iv_within_loading
              IMPORTING
                eo_message        = lo_message ).
            collect_messages( EXPORTING io_message = lo_message
                              CHANGING  co_message = eo_message ).
          ENDIF.

*       try again
          TRY.
              IF et_node_cat IS REQUESTED.
                mo_buffer->retrieve(
                  EXPORTING
                    iv_node_key    = iv_node_key
                    it_key         = lt_key_retrieve
                    iv_state       = iv_state
                    iv_fill_data   = iv_fill_data
                    iv_buffer_only = abap_true
                  IMPORTING
                    et_data        = et_data
                    et_failed_key  = et_failed_key
                    et_node_cat    = et_node_cat ).
              ELSE.
                mo_buffer->retrieve(
                  EXPORTING
                    iv_node_key    = iv_node_key
                    it_key         = lt_key_retrieve
                    iv_state       = iv_state
                    iv_fill_data   = iv_fill_data
                    iv_buffer_only = abap_true
                  IMPORTING
                    et_data        = et_data
                    et_failed_key  = et_failed_key ).
              ENDIF.
            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lx_root ).
          ENDTRY.

          ASSERT ID /bobf/frw_error CONDITION
              /bobf/cl_tool_assert=>is_key_subset(
                  it_key_set    = lt_key_retrieve
                  it_key_subset = et_failed_key ) = abap_true.

        ELSE.
          et_failed_key = lt_failed_key.
        ENDIF.
      ENDIF.
    ENDIF.

    LOOP AT lt_failed_node INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO et_failed_key.
    ENDLOOP.

  ENDMETHOD.


  METHOD retrieve_by_association.

    DATA: ls_assoc             TYPE        /bobf/s_confro_assoc,
          lo_delegation        TYPE REF TO /bobf/if_frw_delegation,
          ls_assoc_class       TYPE        ty_association,
          ls_key_link          TYPE        /bobf/s_frw_key_link,
          lt_failed_key        TYPE        /bobf/t_frw_key,
          lt_target_key        TYPE        /bobf/t_frw_key,
          lt_key               TYPE        /bobf/t_frw_key,
          ls_key               TYPE        /bobf/s_frw_key,
          ls_node              TYPE        /bobf/s_frw_node,
          ls_node_2            TYPE        /bobf/s_frw_node,
          lt_node              TYPE        /bobf/t_frw_node,
          lt_node_reload       TYPE        /bobf/t_frw_node,
          lt_node_not_locked   TYPE        /bobf/t_frw_node,
          lt_node_not_locked_2 TYPE        /bobf/t_frw_node,
          lt_node_loaded       TYPE        /bobf/t_frw_node,
          lt_node_loaded_2     TYPE        /bobf/t_frw_node,
          lt_failed_node       TYPE        /bobf/t_frw_node,
          lt_failed_node_2     TYPE        /bobf/t_frw_node,
          ls_context           TYPE        /bobf/s_frw_ctx_assoc,
          ls_context_det       TYPE        /bobf/s_frw_ctx_det,
          lx_root              TYPE REF TO cx_root,
          lo_int_access        TYPE REF TO /bobf/cl_frw_int_access,
          lx_frw               TYPE REF TO /bobf/cx_frw_core,
          lv_content_cat       TYPE        string,
          lt_nodecat           TYPE        /bobf/t_frw_node_cat,
          ls_nodecat           TYPE        /bobf/s_frw_node_cat,
          lv_valid             TYPE        i,
          lv_lock_required     TYPE        boole_d,
          lv_fill_failed_key   TYPE        boole_d,
          lv_fill_data         TYPE        boole_d,
          lv_notify_keyload    TYPE        boole_d,
          lv_load_data         TYPE        boole_d,
          lo_message           TYPE REF TO /bobf/if_frw_message,
          lo_message_int       TYPE REF TO /bobf/cl_frw_message,
          ls_runtime_context   TYPE        /bobf/s_frw_runtime_context,
          lv_content_name      TYPE        /bobf/obm_name,
          lo_change            TYPE REF TO /bobf/if_frw_change.


    ASSERT ID /bobf/frw CONDITION eo_message IS REQUESTED.

    CLEAR: eo_change,
           eo_message,
           et_data,
           et_key_link,
           et_target_key,
           et_failed_key.

    CHECK it_key IS NOT INITIAL.

* read configuration
    IF mo_conf->ms_last_assoc-assoc_key = iv_association.
      ls_assoc = mo_conf->ms_last_assoc.
    ELSE.
      mo_conf->get_assoc(
        EXPORTING iv_assoc_key = iv_association
        IMPORTING es_assoc     = ls_assoc ).
    ENDIF.

    ASSERT ID /bobf/frw CONDITION iv_node_key = ls_assoc-source_node_key.

* the target node is not part of this objects (X-BO?)
    IF ls_assoc-target_node_key IS INITIAL.
      set_application_error( ).
    ENDIF.

    lt_key             = it_key.
    lv_fill_failed_key = iv_fill_failed_key.

* check for requested attributes
    needs_notify_keyload(
      EXPORTING
        it_requested_attributes       = it_requested_attributes
        ir_load_attribute_tab         = ls_assoc-target_node->det_load_attributes
        iv_has_transient_elements     = ls_assoc-target_node->has_trans_fields
        iv_has_auth_determ            = ls_assoc-target_node->has_auth_determ
      IMPORTING
        ev_transient_fields_requested = DATA(lv_transient_fields_requested)
      RECEIVING
        rv_notify_keyload             = lv_notify_keyload
    ).

    "transient fields requires caching of the data
    IF lv_transient_fields_requested = abap_true.
      notify_nodes_read_cache_enable( it_node_key = VALUE #( ( key = ls_assoc-target_node_key ) ) ).
    ENDIF.
* ____________________________________________________________________ *
* lock and reload source node
    IF iv_invalidate_cache              =  abap_true                          OR
        ( iv_edit_mode                  <> /bobf/if_conf_c=>sc_edit_read_only AND
*      ls_assoc-target_node->transient =  abap_false                         AND
        mo_conf->ms_obj-no_lock         =  abap_false ).
*    potential reload required
      map_to_node(
        EXPORTING
          iv_node_key = iv_node_key
          it_key      = it_key
        IMPORTING
          et_node     = lt_node ).

      IF iv_edit_mode        <> /bobf/if_conf_c=>sc_edit_read_only AND
          ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_xbo.
        lv_lock_required = abap_true.
      ENDIF.

      IF lv_lock_required                    = abap_true AND
          ls_assoc-target_locked_with_source = abap_true.
*     lock source nodes
        eo_change = /bobf/cl_frw_factory=>get_change( ).
        mo_lock_manager->lock(
          EXPORTING
            iv_edit_mode                  = iv_edit_mode
            it_node                       = lt_node
            io_change                     = eo_change
            iv_generic                    = abap_false
          IMPORTING
            et_failed_node                = lt_failed_node
            et_node_not_locked            = lt_node_not_locked
            et_lockable_node_newly_locked = lt_node_reload
            et_loaded_node                = lt_node_loaded
            eo_message                    = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

*     reload successfully locked locking groups
        IF lt_node_reload IS NOT INITIAL.
          IF ls_assoc-source_data_required = abap_true.
            lv_load_data = abap_true.
          ELSE.
            lv_load_data = iv_fill_data.
          ENDIF.

          do_loading(
            EXPORTING
              it_node           = lt_node_reload
              iv_check_buf      = abap_false
              iv_reload         = abap_true
              iv_within_loading = iv_within_loading
              iv_load_data      = lv_load_data
              iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
              iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
              io_change         = eo_change
            IMPORTING
              et_failed         = lt_failed_node_2
              eo_message        = lo_message ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).
        ENDIF.

        IF lt_failed_node_2 IS NOT INITIAL.
          IF lt_failed_node IS NOT INITIAL.
            INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
          ELSE.
            lt_failed_node = lt_failed_node_2.
          ENDIF.
        ENDIF.

      ELSEIF ( lv_lock_required              = abap_true    AND
          ls_assoc-target_locked_with_source = abap_false ) OR
          iv_invalidate_cache                = abap_true.
*     check locking of source nodes
        eo_change = /bobf/cl_frw_factory=>get_change( ).
        mo_lock_manager->lock(
          EXPORTING
            iv_edit_mode       = /bobf/if_conf_c=>sc_edit_optimistic
            iv_check_only      = abap_true
            it_node            = lt_node
            io_change          = eo_change
            iv_generic         = abap_false
          IMPORTING
            et_failed_node     = lt_failed_node
            et_node_not_locked = lt_node_not_locked
            et_loaded_node     = lt_node_loaded
            eo_message         = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.

      IF lt_node_not_locked                  IS NOT INITIAL AND
          ( iv_invalidate_cache              = abap_true    OR
          ls_assoc-target_locked_with_source = abap_false ) AND
          ( ls_assoc-source_node->delegation_class IS INITIAL OR
            ls_assoc-target_node->delegation_class IS INITIAL ).
*     reload not locked nodes (if required)
        IF ls_assoc-source_data_required = abap_true.
          lv_load_data = abap_true.
        ELSEIF ls_assoc-target_loaded_with_source = abap_true.
          lv_load_data = iv_fill_data.
        ELSE.
          lv_load_data = abap_false.
        ENDIF.

        do_loading(
          EXPORTING
            iv_node_key_unique = iv_node_key
            it_node            = lt_node_not_locked
            it_node_no_reload  = lt_node_loaded
            iv_check_buf       = abap_false
            iv_reload          = abap_true
            iv_within_loading  = iv_within_loading
            iv_load_data       = lv_load_data
            iv_load_subtree    = /bobf/if_frw_c=>sc_load_no_subtree
            iv_edit_mode       = /bobf/if_conf_c=>sc_edit_read_only
            io_change          = eo_change
          IMPORTING
            et_failed          = lt_failed_node_2
            eo_message         = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF lt_failed_node_2 IS NOT INITIAL.
          IF lt_failed_node IS NOT INITIAL.
            INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
          ELSE.
            lt_failed_node = lt_failed_node_2.
          ENDIF.
        ENDIF.
      ENDIF.

      LOOP AT lt_failed_node INTO ls_node.
        DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
        IF iv_fill_failed_key = abap_true.
          ls_key-key = ls_node-key.
          APPEND ls_key TO et_failed_key.
        ENDIF.
      ENDLOOP.

      CLEAR:
          lt_node_reload,
          lt_node_loaded,
          lt_failed_node,
          lt_failed_node_2.
    ENDIF.

* ____________________________________________________________________ *
* check if source nodes are in buffer / load object part / reload buffer
    IF iv_buffer_only                                   = abap_false  AND
        ls_assoc-source_node->delegation_class          IS INITIAL    AND
        ( ls_assoc-assoc_class                          IS INITIAL    OR
        iv_ask_buffer                                   = abap_true ) AND
        ( ls_assoc-source_node->optimized_buffer_access = abap_false  OR
        ls_assoc-target_node->optimized_buffer_access   = abap_false ).

      IF ls_assoc-source_data_required = abap_true.
        lv_load_data = abap_true.
      ELSEIF ls_assoc-target_loaded_with_source = abap_true AND
          iv_fill_data                          = abap_true.
        lv_load_data = abap_true.
      ELSE.
        lv_load_data = abap_false.
      ENDIF.

      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

      do_loading(
        EXPORTING
          iv_node_key       = iv_node_key
          it_key            = lt_key
          iv_check_buf      = abap_true
          iv_reload         = abap_false
          iv_load_data      = lv_load_data
          iv_notify_keyload = abap_true
          iv_within_loading = iv_within_loading
          iv_load_subtree   = /bobf/if_frw_c=>sc_load_no_subtree
          io_change         = eo_change
        IMPORTING
          et_failed         = lt_failed_node
          eo_message        = lo_message ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_node_subset(
              iv_node_set    = iv_node_key
              it_key_set     = lt_key
              it_node_subset = lt_failed_node ) =  abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

* not removing faileds from lt_key leads to a superfluous DB access
      LOOP AT lt_failed_node INTO ls_node.
        DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
        IF iv_fill_failed_key = abap_true.
          ls_key-key = ls_node-key.
          APPEND ls_key TO et_failed_key.
        ENDIF.
      ENDLOOP.
    ENDIF.

*  ____________________________________________________________________ *
*  filter keys regarding their node category
    IF ls_assoc-node_cat->* IS NOT INITIAL.
      CLEAR lt_nodecat.
      retrieve(
        EXPORTING
          iv_node_key    = iv_node_key
          it_key         = lt_key
          iv_state       = iv_state
          iv_fill_data   = abap_false
          iv_buffer_only = iv_buffer_only
        IMPORTING
          et_node_cat    = lt_nodecat
          et_failed_key  = lt_failed_key
          eo_message     = lo_message ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = lt_key
              it_key_subset = lt_failed_key ) = abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      ASSERT ID /bobf/frw CONDITION lines( lt_nodecat ) + lines( lt_failed_key ) = lines( lt_key ).

      IF iv_fill_failed_key = abap_true.
        APPEND LINES OF lt_failed_key TO et_failed_key.
      ENDIF.

      lv_fill_failed_key = abap_false.

      LOOP AT lt_failed_key INTO ls_key.
        DELETE lt_key USING KEY key_sort WHERE key = ls_key-key.
      ENDLOOP.

      LOOP AT lt_nodecat INTO ls_nodecat.
*     check if node category is valid
        AT NEW node_cat_key.
          READ TABLE ls_assoc-node_cat->*
            WITH KEY node_cat_key = ls_nodecat-node_cat_key
            TRANSPORTING NO FIELDS.
          lv_valid = sy-subrc.
        ENDAT.
        ls_key-key = ls_nodecat-key.
        IF lv_valid <> 0.
*        association is disabled for node category
*          => do not search for associated nodes
*        important note: do not fill failed keys as the source key is ok
          DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
        ENDIF.
      ENDLOOP.
    ENDIF.


*  ____________________________________________________________________ *
*  perform determination before retrieve of target node
    IF ls_assoc-target_node->transient = abap_true                         AND
       iv_with_det_before_retrieve     = abap_true                         AND
       lt_key IS NOT INITIAL.

      "filter out invalid source keys; for internal nodes the retrieve is not executed
      "in case failed keys are not requested due to performance optimization
      IF lv_fill_failed_key = abap_true OR
        ( ls_assoc-source_node->node_type <> /bobf/if_conf_c=>sc_node_type_lock AND
          ls_assoc-source_node->node_type <> /bobf/if_conf_c=>sc_node_type_message AND
          ls_assoc-source_node->node_type <> /bobf/if_conf_c=>sc_node_type_property ).

        retrieve(
          EXPORTING
            iv_node_key    = iv_node_key
            it_key         = lt_key
            iv_state       = iv_state
            iv_fill_data   = abap_false
          IMPORTING
            et_failed_key  = lt_failed_key
            eo_message     = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        lv_fill_failed_key = abap_false.
        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_key USING KEY key_sort WHERE key = ls_key-key.
        ENDLOOP.
        APPEND LINES OF lt_failed_key TO et_failed_key.
      ENDIF.

      IF lt_key IS NOT INITIAL AND
         NOT iv_buffer_only = abap_true.

        do_determinations_retrieve(
          EXPORTING
            iv_assoc_key           = iv_association
            it_key                 = lt_key
            is_parameters          = is_parameters
            it_filtered_attributes = it_filtered_attributes
            iv_state               = iv_state
            iv_within_loading      = iv_within_loading
          IMPORTING
            eo_message             = lo_message
            et_failed_key          = lt_failed_key ).

        ASSERT ID /bobf/frw CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF iv_fill_failed_key = abap_true.
          APPEND LINES OF lt_failed_key TO et_failed_key.
        ENDIF.

        LOOP AT lt_failed_key INTO ls_key.
          DELETE lt_key USING KEY key_sort WHERE key = ls_node-key.
        ENDLOOP.

      ENDIF.
    ENDIF.

* ____________________________________________________________________ *
* resolve assoication
    IF lt_key IS NOT INITIAL.
      IF eo_change IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

* ____________________________________________________________________ *
*   call external association implementation
      IF ls_assoc-assoc_class IS NOT INITIAL AND
        iv_ask_buffer = abap_false.
        ls_context-bo_key        = mo_conf->ms_obj-bo_key.
        ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
        ls_context-node_key      = ls_assoc-source_node_key.
        ls_context-assoc_key     = ls_assoc-assoc_key.

        IF iv_before_image IS SUPPLIED.
          ls_context-before_image = iv_before_image.
        ELSEIF iv_state = /bobf/if_conf_c=>sc_state_database.
          ls_context-before_image = abap_true.
        ELSE.
          ls_context-before_image = abap_false.
        ENDIF.

*     create internal access object for associations
        /bobf/cl_frw_int_access=>new_instance(
          EXPORTING
            io_bopf            = me
            io_conf            = mo_conf
            io_buffer          = mo_buffer
            io_change          = eo_change
          RECEIVING
            eo_internal_access = lo_int_access
        ).
        lo_int_access->set_last_state(    iv_last_state    = iv_state ).
        lo_int_access->set_current_state( iv_current_state = iv_state ).

*     Intentional missing of assert: retrieve_by_association could be called within det or val loop with not valid
*     access object in access stack
        INSERT lo_int_access INTO mt_access_stack INDEX 1.

*     get assoc class
        READ TABLE mt_association
           WITH TABLE KEY assoc_key = ls_assoc-assoc_key
           INTO ls_assoc_class.
        IF sy-subrc <> 0.
          ls_assoc_class-assoc_key = ls_assoc-assoc_key.
          TRY.
              CREATE OBJECT ls_assoc_class-class TYPE (ls_assoc-assoc_class).
            CATCH cx_sy_create_object_error INTO lx_root.
              lv_content_name = get_content_description(
                iv_assoc = abap_true
                iv_key = ls_assoc-assoc_key ).
              lv_content_cat = TEXT-001.
              CREATE OBJECT lx_frw
                EXPORTING
                  previous        = lx_root
                  textid          = /bobf/cx_frw_core=>sc_no_instance
                  mv_classname    = ls_assoc-assoc_class
                  mv_content_cat  = lv_content_cat
                  mv_content_name = lv_content_name.
              set_configuration_error( lx_frw ).
          ENDTRY.

          INSERT ls_assoc_class INTO TABLE mt_association.
        ENDIF.

        IF iv_within_loading = abap_true.
          ls_context_det-exectime = /bobf/if_conf_c=>sc_time_after_loading.
        ENDIF.

        lo_int_access->set_context(
           is_association      = ls_context
           is_determination    = ls_context_det
           iv_read_allowed     = abap_true
           iv_read_buffer_only = iv_buffer_only
           iv_invalidate_cache = iv_invalidate_cache
           iv_within_loading   = iv_within_loading ).

        TRY.
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ).

            DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

            ls_assoc_class-class->resolve( EXPORTING is_ctx                 = ls_context
                                                     it_key                 = lt_key
                                                     io_read                = lo_int_access
                                                     is_parameters          = is_parameters
                                                     it_filtered_attributes = it_filtered_attributes
                                                     iv_invalidate_cache    = iv_invalidate_cache
                                           IMPORTING et_key_link            = et_key_link
                                                     et_failed_key          = lt_failed_key
                                                     eo_message             = lo_message ).

            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_subset( it_key_set    = lt_key
                                                                                     it_key_subset = lt_failed_key ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_key_link_matching( it_key        = lt_key
                                                                                            it_key_link   = et_key_link ).
            ASSERT ID /bobf/frw_error CONDITION /bobf/cl_tool_assert=>is_message_cleared_stack_check( lo_message ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                iv_content_cat   = /bobf/if_conf_c=>sc_content_ass
                                                                                iv_content_key   = ls_assoc-assoc_key
                                                                                iv_content_class = ls_assoc-assoc_class
                                                                                iv_node_key      = iv_node_key
                                                                                io_configuration = mo_conf
                                                                                iv_method_name   = 'RESOLVE' ) ).
        ENDTRY.
        lo_int_access->invalidate( ).

        ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ).
        DELETE mt_access_stack INDEX 1.

        APPEND LINES OF lt_failed_key TO et_failed_key.

*     set context
        create_durable_msg_container(  CHANGING co_message = lo_message ).
        IF lo_message IS BOUND.
          lo_message_int ?= lo_message.
          ls_runtime_context-bo_key      = mo_conf->ms_obj-bo_key.
          ls_runtime_context-node_key    = iv_node_key.
          ls_runtime_context-assoc_key   = iv_association.
          ls_runtime_context-consistency = abap_false.
          lo_message_int->set_context( is_context = ls_runtime_context it_key = lt_key ).
        ENDIF.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF et_target_key IS REQUESTED OR
           iv_fill_data = abap_true.
          LOOP AT et_key_link INTO ls_key_link.
            ls_key-key = ls_key_link-target_key.
            APPEND ls_key TO et_target_key.
          ENDLOOP.
          SORT et_target_key.
          DELETE ADJACENT DUPLICATES FROM et_target_key.
        ENDIF.

* ____________________________________________________________________ *
*   ask own buffer
      ELSEIF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source AND
             ls_assoc-source_node->delegation_class IS INITIAL OR
             ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_target AND
             ls_assoc-target_node->delegation_class IS INITIAL.

        IF ls_assoc-target_node->transient               = abap_false AND
           ls_assoc-target_node->optimized_buffer_access = abap_false.
          lv_fill_data = abap_false.
        ELSE.
          lv_fill_data = iv_fill_data.
        ENDIF.

        TRY.
            mo_buffer->retrieve_by_association(
               EXPORTING
                 iv_node_key            = iv_node_key
                 it_key                 = lt_key
                 iv_association         = iv_association
                 is_parameters          = is_parameters
                 it_filtered_attributes = it_filtered_attributes
                 iv_state               = iv_state
                 iv_buffer_only         = iv_buffer_only
                 iv_fill_data           = lv_fill_data
                 io_change              = eo_change
                 iv_fill_failed_key     = lv_fill_failed_key
                 iv_notify_keyload      = lv_notify_keyload
                 iv_invalidate_cache    = iv_invalidate_cache
               IMPORTING
                 et_key_link            = et_key_link
                 et_data                = et_data
                 et_failed_key          = lt_failed_key
                 et_target_key          = et_target_key ).
          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.
        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_link_matching(
               it_key        = lt_key
               it_key_link   = et_key_link
               it_target_key = et_target_key ) = abap_true.

*     do det after loading and state handling
        after_loading(
          EXPORTING
            io_change         = eo_change
            iv_within_loading = iv_within_loading
            iv_load_state     = iv_state
          IMPORTING
            eo_message        = lo_message
            et_loaded_node    = lt_node_loaded
            et_failed_node    = lt_failed_node ).

        LOOP AT lt_failed_node ASSIGNING FIELD-SYMBOL(<ls_failed_node>) WHERE node = ls_assoc-target_node_key.
          DELETE TABLE et_target_key WITH TABLE KEY key = <ls_failed_node>-key.
          IF iv_fill_data = abap_true.
            READ TABLE et_data WITH KEY (/bobf/if_conf_c=>sc_attribute_name_key) = <ls_failed_node>-key TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              DELETE et_data INDEX sy-tabix.
            ENDIF.
          ENDIF.
          DELETE TABLE et_key_link WITH TABLE KEY target_key COMPONENTS target_key = <ls_failed_node>-key.
        ENDLOOP.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

*     check for changes on requested target node
        eo_change->get_changes(
          EXPORTING
            iv_node_key     = ls_assoc-target_node_key
            iv_change_mode  = /bobf/if_frw_c=>sc_modify
          IMPORTING
            et_changed_key  = lt_target_key ).

*     check for updates during determination after loading on target node
        IF lt_target_key IS NOT INITIAL.
*       read target data again -> done at the end of the method
          CLEAR et_data.
        ENDIF.

        IF iv_fill_failed_key = abap_true.
          APPEND LINES OF lt_failed_key TO et_failed_key.
        ENDIF.

* ____________________________________________________________________ *
*   ask delegation class
      ELSE.
        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

        TRY.
            IF ls_assoc-assoc_resolve = /bobf/if_conf_c=>sc_assoc_resolve_source.
              lo_delegation = get_delegation( iv_node_key ).
            ELSE.
              lo_delegation = get_delegation( ls_assoc-target_node_key ).
            ENDIF.
            lv_previous_priv_mode = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
            lo_delegation->retrieve_by_association(
              EXPORTING
                iv_node_key                   = iv_node_key
                it_key                        = lt_key
                iv_association                = iv_association
                is_parameters                 = is_parameters
                it_filtered_attributes        = it_filtered_attributes
                iv_fill_data                  = iv_fill_data
                it_requested_attributes       = it_requested_attributes
                iv_state                      = iv_state
                iv_invalidate_cache           = iv_invalidate_cache
                iv_buffer_sufficient_hint     = iv_buffer_only
                iv_edit_mode                  = iv_edit_mode
                io_change                     = eo_change
              IMPORTING
                eo_message                    = lo_message
                et_data                       = et_data
                et_failed_key                 = lt_failed_key
                et_key_link                   = et_key_link ).
            /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

          CATCH BEFORE UNWIND cx_root INTO lx_root.      "#EC CATCH_ALL
            set_application_error( lx_root ).
        ENDTRY.

        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_subset(
                it_key_set    = lt_key
                it_key_subset = lt_failed_key ) = abap_true.
        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_key_link_matching(
               it_key        = lt_key
               it_key_link   = et_key_link ) = abap_true.
        ASSERT ID /bobf/frw_error CONDITION
            /bobf/cl_tool_assert=>is_message_cleared_stack_set( lo_message ) = abap_true.

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF iv_fill_failed_key = abap_true AND
            lt_failed_key     IS NOT INITIAL.
          IF et_failed_key IS NOT INITIAL.
            APPEND LINES OF lt_failed_key TO et_failed_key.
          ELSE.
            et_failed_key = lt_failed_key.
          ENDIF.
        ENDIF.

*     fill target key if not done yet
        IF et_target_key   IS REQUESTED AND
           et_key_link     IS NOT INITIAL.
          LOOP AT et_key_link INTO ls_key_link.
            ls_key-key = ls_key_link-target_key.
            APPEND ls_key TO et_target_key.
          ENDLOOP.
          SORT et_target_key.
          DELETE ADJACENT DUPLICATES FROM et_target_key.
        ENDIF.
      ENDIF.

    ENDIF.

    CLEAR lt_failed_node.

* ____________________________________________________________________ *
* lock and reload target node
    IF ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_xbo AND
       ls_assoc-target_node->transient = abap_false.
      IF ( lv_lock_required    = abap_true OR
         iv_invalidate_cache = abap_true ) AND
         eo_change           IS NOT BOUND.
        eo_change = /bobf/cl_frw_factory=>get_change( ).
      ENDIF.

*   lock target nodes
      IF lv_lock_required                   = abap_true AND
         ls_assoc-target_locked_with_source = abap_false.
        map_to_node(
          EXPORTING
            iv_node_key = ls_assoc-target_node_key
            it_key      = et_target_key
          IMPORTING
            et_node     = lt_node ).

        mo_lock_manager->lock(
          EXPORTING
            iv_edit_mode                  = iv_edit_mode
            it_node                       = lt_node
            io_change                     = eo_change
            iv_generic                    = abap_false
          IMPORTING
            et_failed_node                = lt_failed_node
            et_lockable_node_newly_locked = lt_node_reload
            et_node_not_locked            = lt_node_not_locked
            et_loaded_node                = lt_node_loaded_2
            eo_message                    = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        IF lt_node_loaded_2 IS NOT INITIAL AND
            iv_invalidate_cache = abap_true.
          IF lt_node_loaded IS INITIAL.
            lt_node_loaded = lt_node_loaded_2.
          ELSE.
            INSERT LINES OF lt_node_loaded_2 INTO TABLE lt_node_loaded.
            DELETE ADJACENT DUPLICATES FROM lt_node_loaded.
          ENDIF.
        ENDIF.

*     reload successfully locked locking groups
        IF lt_node_reload IS NOT INITIAL.
          do_loading(
            EXPORTING
              it_node           = lt_node_reload
              iv_check_buf      = abap_false
              iv_reload         = abap_true
              iv_load_data      = abap_false
              iv_load_subtree   = /bobf/if_frw_c=>sc_load_own_lockgroup
              iv_edit_mode      = /bobf/if_conf_c=>sc_edit_read_only
              io_change         = eo_change
            IMPORTING
              eo_message        = lo_message
              et_failed         = lt_failed_node_2 ).
          collect_messages( EXPORTING io_message = lo_message
                            CHANGING  co_message = eo_message ).

          CLEAR et_data.

          IF lt_failed_node_2 IS NOT INITIAL.
            IF lt_failed_node IS INITIAL.
              lt_failed_node = lt_failed_node_2.
            ELSE.
              INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
            ENDIF.
          ENDIF.
        ENDIF.

*   determine nodes belonging to not locked source nodes
      ELSEIF ls_assoc-target_locked_with_source = abap_true  AND
          ls_assoc-target_loaded_with_source    = abap_false AND
          iv_invalidate_cache                   = abap_true.
        ls_node_2-node = ls_assoc-target_node_key.
        LOOP AT lt_node_not_locked INTO ls_node.
          LOOP AT et_key_link INTO ls_key_link WHERE
              source_key = ls_node-key.
            ls_node_2-key = ls_key_link-target_key.
            INSERT ls_node_2 INTO TABLE lt_node_not_locked_2.
          ENDLOOP.
        ENDLOOP.
        lt_node_not_locked = lt_node_not_locked_2.

*   check locks of target nodes
      ELSEIF lv_lock_required                = abap_false AND
          iv_invalidate_cache                = abap_true  AND
          ls_assoc-target_locked_with_source = abap_false.
        map_to_node(
          EXPORTING
            iv_node_key = ls_assoc-target_node_key
            it_key      = et_target_key
          IMPORTING
            et_node     = lt_node ).

        mo_lock_manager->lock(
          EXPORTING
            iv_edit_mode       = /bobf/if_conf_c=>sc_edit_optimistic
            iv_check_only      = abap_true
            it_node            = lt_node
            io_change          = eo_change
            iv_generic         = abap_false
          IMPORTING
            et_failed_node     = lt_failed_node
            et_node_not_locked = lt_node_not_locked
            eo_message         = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

      ELSE.
        CLEAR lt_node_not_locked.
      ENDIF.


*   reload
      IF lt_node_not_locked   IS NOT INITIAL AND
         iv_invalidate_cache = abap_true.
        do_loading(
          EXPORTING
            iv_node_key_unique = ls_assoc-target_node_key
            it_node            = lt_node_not_locked
            it_node_no_reload  = lt_node_loaded
            iv_check_buf       = abap_false
            iv_reload          = abap_true
            iv_load_data       = iv_fill_data
            iv_load_subtree    = /bobf/if_frw_c=>sc_load_no_subtree
            iv_edit_mode       = /bobf/if_conf_c=>sc_edit_read_only
            io_change          = eo_change
            iv_notify_keyload  = lv_notify_keyload
          IMPORTING
            et_failed          = lt_failed_node_2
            eo_message         = lo_message ).
        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        CLEAR et_data.

        IF lt_failed_node_2 IS NOT INITIAL.
          IF lt_failed_node IS INITIAL.
            lt_failed_node = lt_failed_node_2.
          ELSE.
            INSERT LINES OF lt_failed_node_2 INTO TABLE lt_failed_node.
          ENDIF.
        ENDIF.
      ENDIF.

*   update exporting parameters
      LOOP AT lt_failed_node INTO ls_node.
        DELETE et_target_key USING KEY key_sort WHERE key = ls_node-key.
        READ TABLE et_key_link INTO ls_key_link WITH KEY target_key
          COMPONENTS target_key = ls_node-key.
        CHECK sy-subrc = 0.
        DELETE et_key_link INDEX sy-tabix USING KEY target_key.
      ENDLOOP.
    ENDIF.

* ____________________________________________________________________ *
* retrieve target node
    IF iv_fill_data = abap_true     AND
       et_target_key IS NOT INITIAL AND
       et_data       IS INITIAL.

      retrieve(
        EXPORTING
          iv_node_key             = ls_assoc-target_node_key
          it_key                  = et_target_key
          iv_state                = iv_state
          iv_fill_data            = iv_fill_data
          iv_within_loading       = iv_within_loading
          it_requested_attributes = it_requested_attributes
        IMPORTING
          et_failed_key           = lt_failed_key
          et_data                 = et_data
          eo_message              = lo_message
          eo_change               = lo_change ).

      ASSERT ID /bobf/frw CONDITION
          /bobf/cl_tool_assert=>is_key_subset(
              it_key_set    = et_target_key
              it_key_subset = lt_failed_key ) = abap_true.

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).

      IF lo_change IS BOUND.
        IF eo_change IS NOT BOUND.
          eo_change = lo_change.
        ELSE.
          eo_change->merge( lo_change ).
        ENDIF.
      ENDIF.

*   update failed keys
      LOOP AT lt_failed_key INTO ls_key.
        LOOP AT et_key_link INTO ls_key_link USING KEY target_key WHERE target_key = ls_key-key.
          DELETE et_key_link USING KEY loop_key.
        ENDLOOP.
        DELETE et_target_key USING KEY key_sort WHERE key = ls_key-key.
      ENDLOOP.

      " do det after loading and state handling
      IF eo_change IS BOUND.

        after_loading(
          EXPORTING
            io_change         = eo_change
            iv_within_loading = iv_within_loading
            iv_load_state     = iv_state
          IMPORTING
            eo_message        = lo_message
            et_loaded_node    = lt_node_loaded
            et_failed_node    = lt_failed_node ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        " update exporting parameters
        LOOP AT lt_failed_node INTO ls_node.
          DELETE et_target_key USING KEY key_sort WHERE key = ls_node-key.
          READ TABLE et_key_link INTO ls_key_link WITH KEY target_key
            COMPONENTS target_key = ls_node-key.
          CHECK sy-subrc = 0.
          DELETE et_key_link INDEX sy-tabix USING KEY target_key.
        ENDLOOP.

      ENDIF.

    ENDIF.

  ENDMETHOD.


  METHOD retrieve_subtree_property.

    DATA: ls_nodeconf             TYPE /bobf/s_confro_node,
          lv_node_key             TYPE /bobf/obm_node_key,
          lt_assoc                TYPE /bobf/t_confro_assoc,
          ls_assoc                TYPE /bobf/s_confro_assoc,
          lt_key                  TYPE /bobf/t_frw_key,
          lt_key_link             TYPE /bobf/t_frw_key_link,
          lt_key_link2            TYPE /bobf/t_frw_key_link,
          lt_key_link3            TYPE /bobf/t_frw_key_link,
          ls_key_link             TYPE /bobf/s_frw_key_link,
          ls_key_link2            TYPE /bobf/s_frw_key_link,
          lt_target_key           TYPE /bobf/t_frw_key,
          lv_recursion            TYPE boole_d,
          ls_property_parameter   TYPE /bobf/s_frw_c_property,
          ls_property_parameter_r TYPE REF TO /bobf/s_frw_c_property,
          lt_property             TYPE /bobf/t_frw_property_k,
          lt_property_own         TYPE /bobf/t_frw_property_k,
          ls_property             TYPE /bobf/s_frw_property_k,
          lv_parent_key           TYPE /bobf/conf_key,
          lo_message              TYPE REF TO /bobf/if_frw_message.

    CLEAR: et_property, eo_message.

    IF mo_conf->ms_last_node-node_key = iv_node_key.
      ls_nodeconf = mo_conf->ms_last_node.
    ELSE.
      mo_conf->get_node(
         EXPORTING iv_node_key = iv_node_key
         IMPORTING es_node     = ls_nodeconf ).
    ENDIF.

    ASSERT ID /bobf/frw CONDITION ls_nodeconf-subtree_property = abap_true
                               OR ls_nodeconf-subtree_property_node_key IS NOT INITIAL.

* determine next relevant node for subtree properties
    IF ls_nodeconf-subtree_property_node_key = mo_conf->ms_obj-root_node_key.
*   root node -> navigate to root node
      lv_recursion = abap_true.
      lv_node_key = mo_conf->ms_obj-root_node_key.

      get_root_key(
        EXPORTING
          iv_node_key         = iv_node_key
          it_key              = it_key
        IMPORTING
          et_key_link         = lt_key_link
          et_target_key       = lt_key ).

*   build key link
      IF it_key_link IS NOT INITIAL.
        lt_key_link2 = lt_key_link.
        CLEAR lt_key_link.
        LOOP AT it_key_link INTO ls_key_link.
          READ TABLE lt_key_link2 INTO ls_key_link2
            WITH KEY source_key = ls_key_link-target_key.
          ASSERT ID /bobf/frw CONDITION sy-subrc = 0.
          IF sy-subrc = 0.
            ls_key_link-target_key = ls_key_link2-target_key.
            INSERT ls_key_link INTO TABLE lt_key_link.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ELSEIF ls_nodeconf-subtree_property_node_key IS NOT INITIAL.
*   some parent node and not root -> navigate to relevant parent node
      lv_recursion = abap_true.
      lv_node_key = iv_node_key.
      lt_key      = it_key.
      lt_key_link = it_key_link.

      DO.
        mo_conf->get_assoc(
          EXPORTING
            iv_node_key  = lv_node_key
            iv_assoc_cat = /bobf/if_conf_c=>sc_assoccat_parent
          IMPORTING
            es_assoc     = ls_assoc ).
        IF ls_assoc IS INITIAL.
*       problem in model
          ASSERT ID /bobf/frw_error CONDITION 0 = 1.       "#EC BOOL_OK
          lv_recursion = abap_false.
          EXIT.
        ENDIF.

        retrieve_by_association(
          EXPORTING
            iv_node_key          = lv_node_key
            it_key               = lt_key
            iv_association       = ls_assoc-assoc_key
            iv_state             = iv_state
          IMPORTING
            et_key_link          = lt_key_link2
            et_target_key        = lt_target_key
            eo_message           = lo_message ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).

        ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>is_key_link_matching(
               it_key_link   = lt_key_link2
               it_key        = lt_key
               it_target_key = lt_target_key ) = abap_true.

        lv_node_key = ls_assoc-target_node_key.
        lt_key      = lt_target_key.

*     build key link
        IF lt_key_link IS INITIAL.
          lt_key_link = lt_key_link2.
        ELSE.
          lt_key_link3 = lt_key_link.
          CLEAR lt_key_link.
          LOOP AT lt_key_link3 INTO ls_key_link.
            READ TABLE lt_key_link2 INTO ls_key_link2
              WITH KEY source_key = ls_key_link-target_key.
            ASSERT ID /bobf/frw CONDITION sy-subrc = 0.
            IF sy-subrc = 0.
              ls_key_link-target_key = ls_key_link2-target_key.
              INSERT ls_key_link INTO TABLE lt_key_link.
            ENDIF.
          ENDLOOP.
        ENDIF.

*     relevant node reached
        IF ls_assoc-target_node_key = ls_nodeconf-subtree_property_node_key.
          EXIT.
        ENDIF.
      ENDDO.
    ENDIF.

* start recursion to determine subtree properties
    IF lv_recursion = abap_true.
      retrieve_subtree_property(
        EXPORTING
          iv_node_key = lv_node_key
          it_key      = lt_key
          it_key_link = lt_key_link
          iv_state    = iv_state
        IMPORTING
          et_property = lt_property
          eo_message  = lo_message ).

      collect_messages( EXPORTING io_message = lo_message
                        CHANGING  co_message = eo_message ).
    ENDIF.

* retrieve subtree properties
    IF ls_nodeconf-subtree_property = abap_true.
*   get association to property node
      mo_conf->get_assoc(
       EXPORTING
         iv_node_key   = iv_node_key
         iv_assoc_cat  = /bobf/if_conf_c=>sc_assoccat_property
         iv_assoc_type = /bobf/if_conf_c=>sc_assoctype_comp
       IMPORTING
         es_assoc      = ls_assoc ).
      IF ls_assoc IS INITIAL.
*     no property node defined
        ASSERT ID /bobf/frw CONDITION 0 = 1.               "#EC BOOL_OK
        ASSERT ID /bobf/frw_error CONDITION
           /bobf/cl_tool_assert=>access_stack_stack_check(
               it_access_stack = mt_access_stack ) = abap_true.
      ELSE.
*     determine subtree properties
        CLEAR ls_property_parameter.
        ls_property_parameter-all_subtree_property = abap_true.
        GET REFERENCE OF ls_property_parameter INTO ls_property_parameter_r.

        retrieve_by_association(
          EXPORTING
            iv_node_key                 = iv_node_key
            it_key                      = it_key
            iv_association              = ls_assoc-assoc_key
            is_parameters               = ls_property_parameter_r
            iv_state                    = iv_state
            iv_buffer_only              = abap_false
            iv_fill_data                = abap_true
            iv_fill_failed_key          = abap_true
            iv_with_det_before_retrieve = iv_determine_property
          IMPORTING
            et_data                     = lt_property_own
            eo_message                  = lo_message ).

        collect_messages( EXPORTING io_message = lo_message
                          CHANGING  co_message = eo_message ).
      ENDIF.
    ENDIF.

* calculate specific properties and link properties to origin node
    IF iv_resolve_property = abap_true.
      IF iv_assoc_property = abap_true OR it_assoc IS NOT INITIAL.
        mo_conf->get_assoc_tab( IMPORTING et_assoc = lt_assoc ).
      ENDIF.
      APPEND LINES OF lt_property_own TO lt_property.

      LOOP AT lt_property INTO ls_property.
*     check for subtree property
        IF ls_property-content_cat <> /bobf/if_conf_c=>sc_content_subtree.
*       only subtree properties should be calculated and returned!
          ASSERT ID /bobf/frw_error CONDITION 0 = 1.       "#EC BOOL_OK
          CONTINUE.
        ENDIF.
*     set node properties
        IF ls_property-property_name = /bobf/if_conf_c=>sc_property_name_update_enable OR
           ls_property-property_name = /bobf/if_conf_c=>sc_property_name_delete_enable.

          IF iv_node_property = abap_true.
            ls_property-content_cat   = /bobf/if_conf_c=>sc_content_nod.
            ls_property-content_key   = iv_node_key.
            IF it_key_link IS INITIAL.
              ls_property-key = /bobf/cl_frw_factory=>get_new_transient_key( ).
              INSERT ls_property INTO TABLE et_property.
            ELSE.
              lv_parent_key             = ls_property-parent_key.
              LOOP AT lt_key_link INTO ls_key_link USING KEY target_key
                WHERE target_key = lv_parent_key.
                ls_property-parent_key  = ls_key_link-source_key.
                ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                INSERT ls_property INTO TABLE et_property.
              ENDLOOP.
            ENDIF.
          ENDIF.

*     set association property
        ELSEIF ls_property-property_name = /bobf/if_conf_c=>sc_property_name_create_enable.

          IF ( iv_assoc_property = abap_true OR it_assoc IS NOT INITIAL ).
            ls_property-content_cat = /bobf/if_conf_c=>sc_content_ass.

            IF it_assoc IS INITIAL.
*           all association properties
              lv_parent_key = ls_property-parent_key.
              LOOP AT lt_assoc INTO ls_assoc USING KEY key2 WHERE source_node_key = iv_node_key.
                CHECK ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_root
                  AND ls_assoc-assoc_cat <> /bobf/if_conf_c=>sc_assoccat_parent.
                IF it_key_link IS INITIAL.
                  ls_property-content_key = ls_assoc-assoc_key.
                  ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                  INSERT ls_property INTO TABLE et_property.
                ELSE.
                  LOOP AT lt_key_link INTO ls_key_link USING KEY target_key
                    WHERE target_key = lv_parent_key.
                    ls_property-parent_key  = ls_key_link-source_key.
                    ls_property-content_key = ls_assoc-assoc_key.
                    ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                    INSERT ls_property INTO TABLE et_property.
                  ENDLOOP.
                ENDIF.
              ENDLOOP.
            ELSE.
*           only selected associations
              LOOP AT lt_assoc INTO ls_assoc USING KEY key2
                WHERE source_node_key = iv_node_key.
                READ TABLE it_assoc TRANSPORTING NO FIELDS
                  WITH KEY key_sort COMPONENTS table_line = ls_assoc-assoc_key.
                CHECK sy-subrc = 0.
                IF it_key_link IS INITIAL.
                  ls_property-content_key = ls_assoc-assoc_key.
                  ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                  INSERT ls_property INTO TABLE et_property.
                ELSE.
                  lv_parent_key = ls_property-parent_key.
                  LOOP AT lt_key_link INTO ls_key_link USING KEY target_key
                    WHERE target_key = lv_parent_key.
                    ls_property-parent_key  = ls_key_link-source_key.
                    ls_property-content_key = ls_assoc-assoc_key.
                    ls_property-key         = /bobf/cl_frw_factory=>get_new_transient_key( ).
                    INSERT ls_property INTO TABLE et_property.
                  ENDLOOP.
                ENDIF.
              ENDLOOP.
            ENDIF.
          ENDIF.
        ELSE.
*       unknown property name used with subtree
          ASSERT ID /bobf/frw_error CONDITION 0 = 1.       "#EC BOOL_OK
        ENDIF.
      ENDLOOP.
    ELSE.
      et_property = lt_property.
      IF it_key_link IS INITIAL.
        APPEND LINES OF lt_property_own TO et_property.
      ELSE.
        LOOP AT lt_property_own INTO ls_property.
          lv_parent_key = ls_property-parent_key.
          LOOP AT it_key_link INTO ls_key_link USING KEY target_key
            WHERE target_key = lv_parent_key.
            ls_property-parent_key = ls_key_link-source_key.
            ls_property-key        = /bobf/cl_frw_factory=>get_new_transient_key( ).
            INSERT ls_property INTO TABLE et_property.
          ENDLOOP.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD set_application_error.

    DATA:
      lx_root                    TYPE REF TO cx_root,
      lx_bobf_frw                TYPE REF TO /bobf/cx_frw,
      lv_application_information TYPE        string.


    ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.             "#EC BOOL_OK
    mv_application_error = abap_true.

    " Get application information (if there is one defined).
    " Earliest application information wins.
    lx_root = io_exception.
    WHILE lx_root IS BOUND.
      IF lx_root IS INSTANCE OF /bobf/cx_frw.
        lx_bobf_frw ?= lx_root.
        IF lx_bobf_frw->mv_application_information IS NOT INITIAL.
          lv_application_information = lx_bobf_frw->mv_application_information.
        ENDIF.
      ENDIF.
      lx_root = lx_root->previous.
    ENDWHILE.

    " Be sure to place the RAISE SHORTDUMP statement directly in the current
    " method (and not have it buried deep in a call hierarchy).  This makes
    " dump analysis much easier in combination with CATCH BEFORE UNWIND.
    DATA(lx_fatal) = NEW /bobf/cx_frw_fatal( textid                  = /bobf/cx_frw_fatal=>sc_application_error
                                             previous                = io_exception
                                             mv_bo_name              = mo_conf->ms_obj-bo_name
                                             mv_proxy_bo_name        = mo_conf->ms_obj-bo_esr_name
                                             application_information = lv_application_information
                                           )->prepare_for_shortdump( ).
    DATA(dummy) = lx_fatal->get_longtext( ).
    RAISE SHORTDUMP lx_fatal.

  ENDMETHOD.


  METHOD set_configuration_error.

    ASSERT ID /bobf/frw_fatal CONDITION 0 = 1.             "#EC BOOL_OK
    mv_configuration_error = abap_true.

    NEW /bobf/cx_frw_fatal( textid           = /bobf/cx_frw_fatal=>sc_configuration_error
                            previous         = io_exception
                            mv_bo_name       = mo_conf->ms_obj-bo_name
                            mv_proxy_bo_name = mo_conf->ms_obj-bo_esr_name
                          )->shortdump( ).

  ENDMETHOD.


  METHOD set_consistency_status.

    DATA: ls_group        TYPE /bobf/s_frw_group,
          lt_consistency  TYPE /bobf/t_frw_consistency,
          ls_consistency  TYPE /bobf/s_frw_consistency,
          lo_int_access   TYPE REF TO /bobf/cl_frw_int_access,
          lv_content_cat  TYPE string,
          lo_message      TYPE REF TO /bobf/if_frw_message,
          lo_msg_dummy    TYPE REF TO /bobf/if_frw_message, "#EC NEEDED
          lo_change_dummy TYPE REF TO /bobf/if_frw_change,  "#EC NEEDED
          lx_frw          TYPE REF TO /bobf/cx_frw_core,
          lx_root         TYPE REF TO cx_root.

    CLEAR eo_message.

* ___________________________________________________________________________ *
* convert tables
    CHECK it_group IS NOT INITIAL.
    LOOP AT it_group INTO ls_group.
      IF ls_group-group_key <> mo_conf->ms_last_group-group_key.
        mo_conf->get_group( iv_group_key = ls_group-group_key ).
      ENDIF.

      ls_consistency-node_key        = mo_conf->ms_last_group-node_key.
      ls_consistency-key             = ls_group-key.
      ls_consistency-act_key         = mo_conf->ms_last_group-act_key.
      ls_consistency-sta_var_key     = mo_conf->ms_last_group-sta_var_key.
      ls_consistency-consistent      = ls_group-status_value.
      ls_consistency-status_variable = mo_conf->ms_last_group-sta_var->sta_var_esr_name.
      APPEND ls_consistency TO lt_consistency.
    ENDLOOP.

* ___________________________________________________________________________ *
* write status to status adapter
    /bobf/cl_frw_int_access=>new_instance(
      EXPORTING
        io_bopf            =  me   " Framework Main Class
        io_conf            =  mo_conf
        io_buffer          =  mo_buffer
        io_change          =  io_change
     RECEIVING
        eo_internal_access =  lo_int_access
    ).
    lo_int_access->set_current_state( iv_current_state  = /bobf/if_conf_c=>sc_state_current ).
    lo_int_access->set_last_state(    iv_last_state = /bobf/if_conf_c=>sc_state_current ).
    lo_int_access->set_context(
      EXPORTING
        iv_read_allowed   = abap_true
        iv_modify_allowed = abap_true ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
    INSERT lo_int_access INTO mt_access_stack INDEX 1.

* get status adapter
    IF mo_sam IS NOT BOUND.
      TRY.
          CREATE OBJECT mo_sam TYPE (mo_conf->ms_obj-status_class)
            EXPORTING
              iv_bo_key = mo_conf->ms_obj-bo_key.

        CATCH BEFORE UNWIND cx_sy_create_object_error INTO lx_root.
          lv_content_cat = TEXT-004.
          CREATE OBJECT lx_frw
            EXPORTING
              previous       = lx_root
              textid         = /bobf/cx_frw_core=>sc_no_instance
              mv_classname   = mo_conf->ms_obj-status_class
              mv_content_cat = lv_content_cat.
          set_application_error( lx_frw ).
      ENDTRY.
      ASSERT ID /bobf/frw_error CONDITION mo_sam IS BOUND.
    ENDIF.

    TRY.
        DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).
        mo_sam->set_consistency_status(
          EXPORTING
            it_consistency = lt_consistency
            io_read        = lo_int_access
            io_modify      = lo_int_access
          IMPORTING
            eo_message     = lo_message ).
        /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).
      CATCH BEFORE UNWIND cx_root INTO lx_root.          "#EC CATCH_ALL
        set_application_error( lx_root ).
    ENDTRY.

    collect_messages( EXPORTING io_message = lo_message
                      CHANGING  co_message = eo_message ).

* check for undone modifications and flush
    IF lo_int_access->mt_modification IS NOT INITIAL.
      lo_int_access->end_modify(
        EXPORTING
          iv_check_for_failed = abap_false ).
    ENDIF.
    collect_messages( EXPORTING io_message = lo_int_access->mo_local_message
                      CHANGING  co_message = eo_message ).
    lo_int_access->invalidate( ).

    ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
    DELETE mt_access_stack INDEX 1.

  ENDMETHOD.


  METHOD set_node_category.

    DATA: ls_nodeconf      TYPE /bobf/s_confro_node,
          ls_node_class    TYPE ty_node,
          lt_key           TYPE /bobf/t_frw_key,
          ls_key           TYPE /bobf/s_frw_key,
          ls_node          TYPE /bobf/s_frw_node,
          ls_node_failed   TYPE /bobf/s_frw_node,
          ls_context       TYPE /bobf/s_frw_ctx_node,
          lt_node_category TYPE /bobf/t_frw_node_cat,
          ls_node_category TYPE /bobf/s_frw_node_cat,
          lt_modification  TYPE /bobf/t_frw_modification,
          ls_modification  TYPE /bobf/s_frw_modification,
          lv_content_cat   TYPE string,
          lv_content_name  TYPE /bobf/obm_name,
          lo_change        TYPE REF TO /bobf/if_frw_change,
          lo_int_access    TYPE REF TO /bobf/cl_frw_int_access,
          lx_frw           TYPE REF TO /bobf/cx_frw_core,
          lx_root          TYPE REF TO cx_root.


    CLEAR: et_failed, eo_message.

    LOOP AT it_node INTO ls_node.
      ls_key-key = ls_node-key.
      APPEND ls_key TO lt_key.

      AT END OF node.
*     read node and call node class if available
        IF mo_conf->ms_last_node-node_key = ls_node-node.
          ls_nodeconf = mo_conf->ms_last_node.
        ELSE.
          mo_conf->get_node(
            EXPORTING iv_node_key = ls_node-node
            IMPORTING es_node     = ls_nodeconf ).
        ENDIF.

        IF ls_nodeconf-node_class IS NOT INITIAL.
          TRY.
*           get node class
              READ TABLE mt_node
                 WITH TABLE KEY node_key = ls_nodeconf-node_key
                 INTO ls_node_class.
              IF sy-subrc <> 0.
                ls_node_class-node_key = ls_nodeconf-node_key.
                CREATE OBJECT ls_node_class-class TYPE (ls_nodeconf-node_class).
                INSERT ls_node_class INTO TABLE mt_node.
              ENDIF.

              IF lo_int_access IS NOT BOUND.
                /bobf/cl_frw_int_access=>new_instance(
                  EXPORTING
                    io_bopf            = me
                    io_conf            = mo_conf
                    io_buffer          = mo_buffer    " Interface to the Data Layer
                  RECEIVING
                    eo_internal_access = lo_int_access
                ).
                lo_int_access->set_current_state( /bobf/if_conf_c=>sc_state_current ).
              ENDIF.
              ls_context-bo_key        = mo_conf->ms_obj-bo_key.
              ls_context-root_node_key = mo_conf->ms_obj-root_node_key.
              ls_context-node_key      = ls_nodeconf-node_key.
              lo_int_access->set_context( iv_read_allowed   = abap_true
                                          iv_modify_allowed = abap_false ).

              ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>access_stack_invalid( mt_access_stack ) = abap_false.
              INSERT lo_int_access INTO mt_access_stack INDEX 1.

              DATA(lv_previous_priv_mode) = /bobf/cl_frw_authority_context=>set_privileged_mode(  ).

              ls_node_class-class->set_node_category( EXPORTING is_ctx           = ls_context
                                                                it_key           = lt_key
                                                                io_read          = lo_int_access
                                                      IMPORTING et_node_category = lt_node_category ).

              /bobf/cl_frw_authority_context=>restore_privileged_mode( lv_previous_priv_mode ).

            CATCH cx_sy_dyn_call_error INTO lx_root.
              lv_content_name = get_content_description(
                iv_node = abap_true
                iv_key  = ls_nodeconf-node_key ).
              lv_content_cat = TEXT-006.
              CREATE OBJECT lx_frw
                EXPORTING
                  textid          = /bobf/cx_frw_core=>sc_no_instance
                  previous        = lx_root
                  mv_method_name  = 'SET_NODE_CATEGORY'
                  mv_content_name = lv_content_name
                  mv_content_cat  = lv_content_cat.
              set_configuration_error( lx_frw ).

            CATCH BEFORE UNWIND cx_root INTO lx_root.    "#EC CATCH_ALL
              set_application_error( lcl_error_provider=>create_impl_class_error( ix_previous      = lx_root
                                                                                  iv_content_cat   = /bobf/if_conf_c=>sc_content_nod
                                                                                  iv_content_key   = ls_nodeconf-node_key
                                                                                  iv_content_class = ls_nodeconf-node_class
                                                                                  iv_node_key      = ls_nodeconf-node_key
                                                                                  io_configuration = mo_conf
                                                                                  iv_method_name   = 'SET_NODE_CATEGORY' ) ).
          ENDTRY.

          lo_int_access->invalidate( ).

          ASSERT ID /bobf/frw CONDITION /bobf/cl_tool_assert=>upmost_int_acc_bound_and_inval( mt_access_stack ) = abap_true.
          DELETE mt_access_stack INDEX 1.

*       write node categories into the buffer
          SORT lt_key.                                 "#EC CI_SORTLOOP
          LOOP AT lt_node_category INTO ls_node_category.
            READ TABLE lt_key BINARY SEARCH TRANSPORTING NO FIELDS
              WITH KEY key = ls_node_category-key.
            IF sy-subrc <> 0.
*           node category determination returned a key that was not given in
              set_application_error( ).
            ENDIF.
            IF ls_node_category-node_cat_key IS NOT INITIAL.
              DELETE lt_key INDEX sy-tabix.
              ls_modification-node        = ls_nodeconf-node_key.
              ls_modification-key         = ls_node_category-key.
              ls_modification-change_mode = /bobf/if_frw_c=>sc_modify_set_node_category.
              ls_modification-node_cat    = ls_node_category-node_cat_key.
              APPEND ls_modification TO lt_modification.
            ENDIF.
          ENDLOOP.
*       add failed entries for keys that where not returned
          ls_node_failed-node = ls_node-node.
          LOOP AT lt_key INTO ls_key.
            ls_node_failed-key = ls_key-key.
            INSERT ls_node_failed INTO TABLE et_failed.
          ENDLOOP.

        ELSE.
*       no implementation available -> mark all instances as failed
          ls_node_failed-node = ls_node-node.
          LOOP AT lt_key INTO ls_key.
            ls_node_failed-key = ls_key-key.
            INSERT ls_node_failed INTO TABLE et_failed.
          ENDLOOP.
        ENDIF.

        CLEAR lt_key.

        "in case of internal access, it is expected that no errors occur here,
        "otherwise it is a programming error
        IF NOT et_failed IS INITIAL AND iv_internal_modify = abap_true.
          CREATE OBJECT lx_frw
            EXPORTING
              mv_application_information = lcl_error_provider=>get_text_node_cat_not_found(
                                             iv_node_key      = ls_node-node
                                             io_configuration = mo_conf ).

          set_application_error( lx_frw ).

        ENDIF.

      ENDAT.

    ENDLOOP.

* perform modifications in the buffer
    IF lt_modification IS NOT INITIAL.
      lo_change = /bobf/cl_frw_factory=>get_change( ).
      TRY.
          mo_buffer->modify(
            EXPORTING
              it_modification   = lt_modification
              io_change         = lo_change
              iv_state          = /bobf/if_conf_c=>sc_state_current
              iv_only_transient = abap_false
            IMPORTING
              eo_message        = eo_message ).

        CATCH BEFORE UNWIND cx_root INTO lx_root.        "#EC CATCH_ALL
          set_application_error( lx_root ).
      ENDTRY.
    ENDIF.

  ENDMETHOD.


  METHOD type_check.

    DATA lr_exp TYPE REF TO data.
    DATA lr_act TYPE REF TO data.
    DATA lv_exp_type TYPE c LENGTH 1.
    DATA lv_act_type TYPE c LENGTH 1.
    DATA lv_exp_components TYPE i.
    DATA lv_act_components TYPE i.
    DATA lx_frw_core TYPE REF TO /bobf/cx_frw_core.

    FIELD-SYMBOLS <ls_exp> TYPE any.
    FIELD-SYMBOLS <ls_act> TYPE any.

    CHECK gv_system_client_role <> 'P' ##NO_TEXT. "Don't perform check in productive client

    CREATE DATA lr_exp TYPE (iv_expected_line_type).
    CREATE DATA lr_act LIKE LINE OF it_data.
    ASSIGN lr_exp->* TO <ls_exp>.
    ASSIGN lr_act->* TO <ls_act>.
    DESCRIBE FIELD <ls_exp> TYPE lv_exp_type COMPONENTS lv_exp_components.
    DESCRIBE FIELD <ls_act> TYPE lv_act_type COMPONENTS lv_act_components.

    IF lv_exp_type <> lv_act_type OR lv_exp_components <> lv_act_components.
      CREATE OBJECT lx_frw_core
        EXPORTING
          textid         = /bobf/cx_frw_core=>sc_wrong_type_passed
          mv_bo_name     = mo_conf->ms_obj-bo_name
          mv_method_name = CONV #( iv_service_name )
          mv_parameter   = iv_parameter_name
          mv_type        = cl_abap_typedescr=>describe_by_data( it_data )->get_relative_name( ).
      set_application_error( lx_frw_core ).
    ENDIF.

  ENDMETHOD.


  METHOD unlock_lockable_nodes.
    DATA: lt_nodes_to_unlock TYPE /bobf/t_frw_node,
          ls_conf_node       TYPE /bobf/s_confro_node,
          ls_frw_node        TYPE /bobf/s_frw_node,
          lo_change          TYPE REF TO /bobf/if_frw_change.

    LOOP AT it_nodes INTO ls_frw_node.
      AT NEW node.
        mo_conf->get_node( EXPORTING iv_node_key = ls_frw_node-node
                           IMPORTING es_node     = ls_conf_node ).
      ENDAT.
      IF ls_conf_node-lockable = abap_true.
        INSERT ls_frw_node INTO TABLE lt_nodes_to_unlock.
      ENDIF.
    ENDLOOP.

    lo_change = /bobf/cl_frw_factory=>get_change( ).
    mo_lock_manager->unlock( it_node    = lt_nodes_to_unlock
                             iv_generic = abap_true
                             io_change  = lo_change ).
  ENDMETHOD.


  METHOD val_time_to_processing_mode.

    rv_processing_mode = SWITCH #( iv_val_time
                                   WHEN /bobf/if_conf_c=>sc_val_time_check OR
                                        /bobf/if_conf_c=>sc_val_time_check_and_determ  THEN /bobf/if_frw_c=>sc_mode_check_and_determine
                                   WHEN /bobf/if_conf_c=>sc_val_time_check_before_save THEN /bobf/if_frw_c=>sc_mode_check_before_save
                                   WHEN /bobf/if_conf_c=>sc_val_time_finalize          THEN /bobf/if_frw_c=>sc_mode_finalize
                                   ELSE                                                     /bobf/if_frw_c=>sc_mode_modify ).

  ENDMETHOD.
ENDCLASS.