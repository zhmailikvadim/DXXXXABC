CLASS cl_faa_dc_segments_720 DEFINITION
  PUBLIC
  CREATE PUBLIC

  GLOBAL FRIENDS cl_faa_dc_engine_call_720 .

  PUBLIC SECTION.

    INTERFACES if_faa_dc_segments_720 .
    INTERFACES if_faa_dc_segments_720_c .

    ALIASES gc_amount_type
      FOR if_faa_dc_segments_720_c~gc_amount_type .
    ALIASES gc_area_value_sign
      FOR if_faa_dc_segments_720_c~gc_area_value_sign .
    ALIASES gc_basevalue
      FOR if_faa_dc_segments_720_c~gc_basevalue .
    ALIASES gc_changeover_meth_at_end
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_at_end .
    ALIASES gc_changeover_meth_country
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_country .
    ALIASES gc_changeover_meth_customer
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_customer .
    ALIASES gc_changeover_meth_depr
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_depr .
    ALIASES gc_changeover_meth_in_ul
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_in_ul .
    ALIASES gc_changeover_meth_nbv
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_nbv .
    ALIASES gc_changeover_meth_none
      FOR if_faa_dc_segments_720_c~gc_changeover_meth_none .
    ALIASES gc_classification
      FOR if_faa_dc_segments_720_c~gc_classification .
    ALIASES gc_date
      FOR if_faa_dc_segments_720_c~gc_date .
    ALIASES gc_message_id
      FOR if_faa_dc_segments_720_c~gc_message_id .
    ALIASES gc_percent
      FOR if_faa_dc_segments_720_c~gc_percent .
    ALIASES gc_period_group
      FOR if_faa_dc_segments_720_c~gc_period_group .
    ALIASES gc_process
      FOR if_faa_dc_segments_720_c~gc_process .
    ALIASES gc_rounding_method
      FOR if_faa_dc_segments_720_c~gc_rounding_method .
    ALIASES gc_scrapvalue
      FOR if_faa_dc_segments_720_c~gc_scrapvalue .
    ALIASES gc_setting_halfmonth
      FOR if_faa_dc_segments_720_c~gc_setting_halfmonth .
    ALIASES gc_step
      FOR if_faa_dc_segments_720_c~gc_step .
    ALIASES gc_uselife_reduction_ind
      FOR if_faa_dc_segments_720_c~gc_uselife_reduction_ind .
    ALIASES mo_previous
      FOR if_faa_dc_segments_720~mo_previous .
    ALIASES mo_start
      FOR if_faa_dc_segments_720~mo_start .
    ALIASES ms_asset_data
      FOR if_faa_dc_segments_720~ms_asset_data .
    ALIASES ms_proc_data
      FOR if_faa_dc_segments_720~ms_proc_data .
    ALIASES ms_transaction_cntrl
      FOR if_faa_dc_segments_720~ms_transaction_cntrl .
    ALIASES mts_area
      FOR if_faa_dc_segments_720~mts_area .
    ALIASES mts_calcamount
      FOR if_faa_dc_segments_720~mts_calcamount .
    ALIASES mts_calcdata
      FOR if_faa_dc_segments_720~mts_calcdata .
    ALIASES mts_calcorder
      FOR if_faa_dc_segments_720~mts_calcorder .
    ALIASES mts_hlpseg
      FOR if_faa_dc_segments_720~mts_hlpseg .
    ALIASES mts_planvalue
      FOR if_faa_dc_segments_720~mts_planvalue .
    ALIASES mt_areasign
      FOR if_faa_dc_segments_720~mt_areasign .
    ALIASES mt_parameter
      FOR if_faa_dc_segments_720~mt_parameter .
    ALIASES mt_period
      FOR if_faa_dc_segments_720~mt_period .
    ALIASES mt_rounding
      FOR if_faa_dc_segments_720~mt_rounding .
    ALIASES mt_sumseg
      FOR if_faa_dc_segments_720~mt_sumseg .
    ALIASES mt_symsg
      FOR if_faa_dc_segments_720~mt_symsg .
    ALIASES mt_timeseg
      FOR if_faa_dc_segments_720~mt_timeseg .
    ALIASES mt_transaction
      FOR if_faa_dc_segments_720~mt_transaction .
    ALIASES mt_transaction_post
      FOR if_faa_dc_segments_720~mt_transaction_post .
    ALIASES mt_virtarea
      FOR if_faa_dc_segments_720~mt_virtarea .
    ALIASES mt_virtarea_s4
      FOR if_faa_dc_segments_720~mt_virtarea_s4 .
    ALIASES mt_yearseg
      FOR if_faa_dc_segments_720~mt_yearseg .
    ALIASES check_badi_is_active
      FOR if_faa_dc_segments_720~check_badi_is_active .
    ALIASES perform_calc_with_implicit_cf
      FOR if_faa_dc_segments_720~perform_calc_with_implicit_cf .
    ALIASES perform_step_processing
      FOR if_faa_dc_segments_720~perform_step_processing .
    ALIASES ty_o_dc_calc_handle
      FOR if_faa_dc_segments_720~ty_o_dc_calc_handle .
    ALIASES ty_o_dc_message_handle
      FOR if_faa_dc_segments_720~ty_o_dc_message_handle .
    ALIASES ty_o_indexseries_handle
      FOR if_faa_dc_segments_720~ty_o_indexseries_handle .
    ALIASES ty_sx_ee_edata
      FOR if_faa_dc_segments_720~ty_sx_ee_edata .
    ALIASES ty_sx_ee_idata
      FOR if_faa_dc_segments_720~ty_sx_ee_idata .
    ALIASES ty_s_area
      FOR if_faa_dc_segments_720~ty_s_area .
    ALIASES ty_s_arearef
      FOR if_faa_dc_segments_720~ty_s_arearef .
    ALIASES ty_s_areasign
      FOR if_faa_dc_segments_720~ty_s_areasign .
    ALIASES ty_s_asset_data
      FOR if_faa_dc_segments_720~ty_s_asset_data .
    ALIASES ty_s_calcamount
      FOR if_faa_dc_segments_720~ty_s_calcamount .
    ALIASES ty_s_calcdata
      FOR if_faa_dc_segments_720~ty_s_calcdata .
    ALIASES ty_s_calcorder
      FOR if_faa_dc_segments_720~ty_s_calcorder .
    ALIASES ty_s_deprarea
      FOR if_faa_dc_segments_720~ty_s_deprarea .
    ALIASES ty_s_deprkey
      FOR if_faa_dc_segments_720~ty_s_deprkey .
    ALIASES ty_s_duevalue
      FOR if_faa_dc_segments_720~ty_s_duevalue .
    ALIASES ty_s_ee_currency
      FOR if_faa_dc_segments_720~ty_s_ee_currency .
    ALIASES ty_s_ee_error
      FOR if_faa_dc_segments_720~ty_s_ee_error .
    ALIASES ty_s_hlpseg
      FOR if_faa_dc_segments_720~ty_s_hlpseg .
    ALIASES ty_s_indexseries
      FOR if_faa_dc_segments_720~ty_s_indexseries .
    ALIASES ty_s_parameter
      FOR if_faa_dc_segments_720~ty_s_parameter .
    ALIASES ty_s_period
      FOR if_faa_dc_segments_720~ty_s_period .
    ALIASES ty_s_planvalue
      FOR if_faa_dc_segments_720~ty_s_planvalue .
    ALIASES ty_s_processing_info
      FOR if_faa_dc_segments_720~ty_s_processing_info .
    ALIASES ty_s_proc_data
      FOR if_faa_dc_segments_720~ty_s_proc_data .
    ALIASES ty_s_rounding
      FOR if_faa_dc_segments_720~ty_s_rounding .
    ALIASES ty_s_sumseg
      FOR if_faa_dc_segments_720~ty_s_sumseg .
    ALIASES ty_s_symsg
      FOR if_faa_dc_segments_720~ty_s_symsg .
    ALIASES ty_s_timeseg
      FOR if_faa_dc_segments_720~ty_s_timeseg .
    ALIASES ty_s_transaction
      FOR if_faa_dc_segments_720~ty_s_transaction .
    ALIASES ty_s_value
      FOR if_faa_dc_segments_720~ty_s_value .
    ALIASES ty_s_virtarea
      FOR if_faa_dc_segments_720~ty_s_virtarea .
    ALIASES ty_s_virtarea_s4
      FOR if_faa_dc_segments_720~ty_s_virtarea_s4 .
    ALIASES ty_s_yearseg
      FOR if_faa_dc_segments_720~ty_s_yearseg .
    ALIASES ty_ts_calcamount
      FOR if_faa_dc_segments_720~ty_ts_calcamount .
    ALIASES ty_ts_calcdata
      FOR if_faa_dc_segments_720~ty_ts_calcdata .
    ALIASES ty_ts_calcorder
      FOR if_faa_dc_segments_720~ty_ts_calcorder .
    ALIASES ty_ts_deprkey_period_determin
      FOR if_faa_dc_segments_720~ty_ts_deprkey_period_determin .
    ALIASES ty_ts_deprkey_phase
      FOR if_faa_dc_segments_720~ty_ts_deprkey_phase .
    ALIASES ty_ts_hlpseg
      FOR if_faa_dc_segments_720~ty_ts_hlpseg .
    ALIASES ty_t_area
      FOR if_faa_dc_segments_720~ty_t_area .
    ALIASES ty_t_areasign
      FOR if_faa_dc_segments_720~ty_t_areasign .
    ALIASES ty_t_parameter
      FOR if_faa_dc_segments_720~ty_t_parameter .
    ALIASES ty_t_period
      FOR if_faa_dc_segments_720~ty_t_period .
*  aliases TY_T_POSTVALUE
*    for IF_FAA_DC_SEGMENTS_720~TY_T_POSTVALUE .
    ALIASES ty_t_rounding
      FOR if_faa_dc_segments_720~ty_t_rounding .
    ALIASES ty_t_sumseg
      FOR if_faa_dc_segments_720~ty_t_sumseg .
    ALIASES ty_t_symsg
      FOR if_faa_dc_segments_720~ty_t_symsg .
    ALIASES ty_t_timeseg
      FOR if_faa_dc_segments_720~ty_t_timeseg .
    ALIASES ty_t_transaction
      FOR if_faa_dc_segments_720~ty_t_transaction .
    ALIASES ty_t_yearseg
      FOR if_faa_dc_segments_720~ty_t_yearseg .

    CLASS-DATA go_badi_country TYPE REF TO if_ex_faa_dc_country READ-ONLY .
    CLASS-DATA go_badi_customer TYPE REF TO if_ex_faa_dc_customer READ-ONLY .

    CLASS-METHODS class_constructor .
    METHODS create_message_from_syst
      CHANGING
        !co_message_handle TYPE ty_o_dc_message_handle OPTIONAL
      RAISING
        cm_faa_t100_dc_720 .
protected section.

  methods ADJUST_PROP_VALUES_ON_MINVAL
    importing
      !IS_CALCAMOUNT type TY_S_CALCAMOUNT
      !IS_YEARSEG type TY_S_YEARSEG
      !IS_SUMSEG type TY_S_SUMSEG
      !IS_AREASIGN type TY_S_AREASIGN
    changing
      !CS_TRANSACTION type TY_S_TRANSACTION
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods ADJUST_USEFUL_LIFE
    importing
      !IS_HLPSEG type TY_S_HLPSEG
    changing
      !CS_PERIOD type TY_S_PERIOD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_AREA_SIGNS
    importing
      !IO_AREAREF type TY_S_HLPSEG-AREAREF
      !ID_NEG_VALUES type TY_S_HLPSEG-NEG_VALUES
    exporting
      !ES_AREASIGN type TY_S_AREASIGN .
  methods GET_BASE_DATE_AND_YR_AND_PRD
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !ID_DETERMINATION_RULE type NUM1
      !ID_BASE_RULE type CHAR1
    exporting
      !ED_BASE_DATE type DATS
      !ED_BASE_PRD type NUMC3
      !ED_BASE_YR type NUMC4
      !ED_BASE_FYR type NUMC4
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_CALC_INFO_FOR_AMOUNT_TYPE
    importing
      !IS_DEPR_PARAM type TY_S_DEPRAREA-DEPR_PARAM
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_CALC_YR_AND_PER_4_TRNSCTN
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IV_PER_CTRL_GROUP type TABWG-PERGRP
      !IV_VALUE_DATE type BZDAT
    exporting
      !EV_FISCAL_YEAR type FAA_DC_START_YR
      !EV_CALCULATION_PERIOD type FAA_DC_START_PRD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_CALC_YR_AND_PER_FROM_DATE
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IV_PER_CTRL_GROUP type TABWG-PERGRP
      !IV_VALUE_DATE type BZDAT
    exporting
      !EV_FISCAL_YEAR type FAA_DC_START_YR
      !EV_CALCULATION_PERIOD type FAA_DC_START_PRD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_DATA_FROM_BADI
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_DATA_FROM_PRIOR_YEAR
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_DEPR_PARAM
    importing
      !IS_DEPR_PARAM type TY_S_DEPRAREA-DEPR_PARAM
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_EXPIRED_LIFE_FOR_INTERVAL
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_NETBOOK_VALUE
    importing
      !IS_CALCAMOUNT type TY_S_CALCAMOUNT optional
      !IS_YEARSEG type TY_S_YEARSEG optional
      !IS_SUMSEG type TY_S_SUMSEG optional
    returning
      value(RV_NETBOOK_VALUE) type TY_S_YEARSEG-CUM-APC
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_PHASE_AND_DEPRKEY_CONFIG
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_PRCNTG_ON_UNITS_OF_PROD
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IS_PARAMETER type TY_S_PARAMETER
    exporting
      !ED_PERCENTAGE type TY_S_PARAMETER-PERCENT_STATED
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_REPL_PARAM
    changing
      !CS_HLPSEG type TY_S_HLPSEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods GET_SHIFTED_PERIOD_FROM_AND_TO
    importing
      !ID_DETERMINATION_RULE type NUM1
      !ID_BASE_DATE type DATS
      !IS_HLPSEG type TY_S_HLPSEG
      !ID_BASE_PRD type NUMC3
      !ID_BASE_FYR type NUMC4
    changing
      !CD_PERIOD_TO type INT2
      !CD_PERIOD_FROM type INT2
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods PREPARE_BADI_CALL
    changing
      value(CO_DC_SEGMENT_HANDLE) type FAA_DC_SEGMENT_HANDLE .
  methods SET_ASSET_DATA
    importing
      !IS_ASSET_DATA type IF_FAA_DEPR_CALC_TYPES=>TY_S_ASSET_DATA
      !IS_TRANSACTION_POST type TY_S_TRANSACTION optional
      !IT_TRANSACTION_POST type TY_T_TRANSACTION optional .
  methods SET_PROCESS_CONTROL_DATA
    importing
      !IS_PROCESS_CONTROL_DATA type TY_S_PROC_DATA
      !ITS_AREA type IF_FAA_DEPR_CALC_TYPES=>TY_T_AREA
      !IO_PREVIOUS type ref to OBJECT .
  methods _AREASIGN_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _CALCAMOUNT_CREATE
    exceptions
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _CALCORDER_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _CALCORDER_CREATE
    exceptions
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_CO_YR_AND_PRD
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_DEACT_DATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_EXP_LIFE_SEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_GET_LAST_RET_DATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_AT_UL_END
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_IN_MAX_PRDS
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_ALIGNMENT
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_COV_KEY
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_DIGITAL
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_MLM
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_MLM_DAT
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _HLPSEG_SPLIT_ON_TIMESEG
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PARAMETER_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PARAMETER_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PERIOD_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _PLANVALUE_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720
      CM_FAA_T100 .
  methods _PROPVALUE_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _ROUNDING_CALL_BADI
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _ROUNDING_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _SUMSEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TIMESEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TIMESEG_CREATE_MISSING
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADD_ON_POSTCAP
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADD_ON_POSTING
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADD_ON_RETIREMENT
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_ADJST_ON_REVERSAL
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _TRANSACTION_CREATE_FROM_DB
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _VALUES_CALCULATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _VALUES_CHECK_ON_POSTING
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _VIRTAREA_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
  methods _YEARSEG_CREATE
    raising
      CX_FAA_CONFIG
      CM_FAA_T100_DC_720 .
private section.

  methods _GET_AREAREF_4_CURRTYPE
    importing
      !IV_CURR_TYPE type FAA_EE_CURR_TYPE
      !IO_AREAREF type ref to IF_FAA_CFG_DEPRAREA
    returning
      value(RO_AREAREF) type ref to IF_FAA_CFG_DEPRAREA .
  methods _GET_UNITS_FROM_DEPR_KEY
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IB_NBV_DEPR type ABAP_BOOL
    returning
      value(RV_PERCENTAGE) type FAA_EE_S_PARAMETER-PERCENT_STATED .
  methods _GET_UNITS_FROM_USAGE_OBJECT
    importing
      !IS_HLPSEG type TY_S_HLPSEG
      !IB_NBV_DEPR type ABAP_BOOL
    returning
      value(RV_PERCENTAGE) type FAA_EE_S_PARAMETER-PERCENT_STATED .
ENDCLASS.



CLASS CL_FAA_DC_SEGMENTS_720 IMPLEMENTATION.


  METHOD adjust_prop_values_on_minval.
*=======================================================================
* On partial retirement system has to insure that minval rules ar not hurt
* therfore the calculated proportional values may need to be adjusted
* to st√≠ck to the rules
* The adjustment is performed by the following rules:
* - first adjust values of structure CUR
* - then  adjust values of structure PREV_CUR
* - at last adjust values of structure PREV_PREV
* - within each structure adjustment sequence is:
*   ordinary depr., special depr., unplanned depr., reserves
*=======================================================================
* Reworked/ Cleanup up with 19/08
*=======================================================================

* DEFINITIONS
    FIELD-SYMBOLS <ls_value1>    TYPE ty_s_value.
    FIELD-SYMBOLS <ls_value2>    TYPE ty_s_value.

    FIELD-SYMBOLS <lv_value1>    TYPE ty_s_value-apc.
    FIELD-SYMBOLS <lv_value2>    TYPE ty_s_value-apc.

    CONSTANTS lc_sign_minus      TYPE c VALUE '-'.

    DATA ls_parameter            TYPE ty_s_parameter.
    DATA ls_transaction          TYPE ty_s_transaction.

    DATA lv_nbv_before_ret       TYPE ty_s_yearseg-cum-apc.
    DATA lv_nbv_after_ret        TYPE ty_s_yearseg-cum-apc.
    DATA lv_nbv_of_ret           TYPE ty_s_yearseg-cum-apc.
    DATA lv_adjustment           TYPE ty_s_yearseg-cum-apc.
    DATA lv_minval               TYPE ty_s_yearseg-cum-apc.
    DATA lv_index                TYPE int1.

    DATA lv_repl_value           TYPE ty_s_calcdata-amount.
    DATA lv_minval_float         TYPE ty_s_calcdata-amount.
    DATA lv_minval_memo          TYPE ty_s_parameter-minval_memo.

* BODY

* calculate netbook value based on the base values for prop. value calc.
    lv_nbv_before_ret = get_netbook_value(
                          EXPORTING
                            is_calcamount  = is_calcamount
                            is_yearseg     = is_yearseg
                            is_sumseg      = is_sumseg ).

* calculate netbook value of the actual retirement
    lv_nbv_of_ret     = cs_transaction-cur-apc
                      + cs_transaction-cur-downp
                      + cs_transaction-cur-invs
                      + cs_transaction-cur-revl
                      + cs_transaction-cur-revl_d
                      + cs_transaction-cur-depr_o
                      + cs_transaction-cur-depr_s
                      + cs_transaction-cur-depr_u
                      + cs_transaction-cur-resv

                      + cs_transaction-prev_cur-apc
                      + cs_transaction-prev_cur-downp
                      + cs_transaction-prev_cur-invs
                      + cs_transaction-prev_cur-revl
                      + cs_transaction-prev_cur-revl_d
                      + cs_transaction-prev_cur-depr_o
                      + cs_transaction-prev_cur-depr_s
                      + cs_transaction-prev_cur-depr_u
                      + cs_transaction-prev_cur-resv

                      + cs_transaction-prev_prev-apc
                      + cs_transaction-prev_prev-downp
                      + cs_transaction-prev_prev-invs
                      + cs_transaction-prev_prev-revl
                      + cs_transaction-prev_prev-revl_d
                      + cs_transaction-prev_prev-depr_o
                      + cs_transaction-prev_prev-depr_s
                      + cs_transaction-prev_prev-depr_u
                      + cs_transaction-prev_prev-resv.

* get netbook value including retirement
    lv_nbv_after_ret = lv_nbv_before_ret + lv_nbv_of_ret.

* get cut off value to be considered
* Make sure that scrap value and cut off value information is
* read from a segment which calculates depreciation
    LOOP AT mt_parameter INTO ls_parameter
                           WHERE area      = cs_transaction-area
                             AND curr_type = cs_transaction-curr_type
                             AND NOT baseval_key IS INITIAL.
      EXIT.
    ENDLOOP.
    IF sy-subrc NE 0.
      READ TABLE mt_parameter INTO ls_parameter
          WITH KEY area      = cs_transaction-area
                   curr_type = cs_transaction-curr_type.
      ASSERT sy-subrc = 0.
    ENDIF.

    CLEAR lv_minval.

* calculate replacement value as base for scrap value
    lv_repl_value   =
*         "cumulated, posted, proportional values at fiscal year start
                        is_yearseg-cum-apc
                      + is_yearseg-cum-downp
                      + is_yearseg-cum-invs
                      + is_yearseg-cum-revl
                      + is_yearseg-cum-resv

*         "current year calculated and posted values
                      + is_sumseg-cur-apc
                      + is_sumseg-cur-downp
                      + is_sumseg-cur-invs
                      + is_sumseg-cur-revl
                      + is_sumseg-cur-resv

                      + is_sumseg-prev_cur-apc
                      + is_sumseg-prev_cur-downp
                      + is_sumseg-prev_cur-invs
                      + is_sumseg-prev_cur-revl
                      + is_sumseg-prev_cur-resv

                      + is_sumseg-prev_prev-apc
                      + is_sumseg-prev_prev-downp
                      + is_sumseg-prev_prev-invs
                      + is_sumseg-prev_prev-revl
                      + is_sumseg-prev_prev-resv

                      + is_calcamount-total-revl

*         "posted values from current transaction
                      + cs_transaction-prev_prev-apc
                      + cs_transaction-cur-apc
                      + cs_transaction-prev_prev-revl
                      + cs_transaction-prev_cur-revl
                      + cs_transaction-cur-revl.

    CALL METHOD cl_faa_ee=>_calc_min_value
      EXPORTING
        id_replvalue = lv_repl_value
        id_repl_prev = lv_repl_value
        it_parameter = ls_parameter
      IMPORTING
        ed_minvalue  = lv_minval_float.

    CALL METHOD cl_faa_ee=>_round_value
      EXPORTING
        id_place    = ls_parameter-minval_rndplace
        id_decimals = ls_parameter-minval_rnddecim
        id_method   = ls_parameter-minval_rndmethod
      CHANGING
        cd_value    = lv_minval_float.

    IF is_areasign-apc  = '0' AND
       is_areasign-invs = '-'.
      lv_minval_memo = - ls_parameter-minval_memo.
    ELSE.
      lv_minval_memo = ls_parameter-minval_memo.
    ENDIF.

    IF abs( lv_minval_memo ) > abs( lv_minval_float ).
      lv_minval_float = lv_minval_memo.
    ENDIF.

    lv_minval = lv_minval_float.

* minval not hurt => process next valuation view
* note_2577975 (same issue as already solved in FAA_DC_PROP_VALUES_ADJUST with note_1027869

* minval already passed pefore retirement => process next valuation view
    IF abs( lv_nbv_before_ret ) < abs( lv_minval ).
      RETURN.
    ENDIF.

* netbook value of retirement zero => process next valuation view
    IF lv_nbv_of_ret = 0.
      RETURN.
    ENDIF.

* determine adjustment amount if zero => process next valuation view
    lv_adjustment = lv_nbv_after_ret - lv_minval.

    IF abs( lv_adjustment ) = 0.
      RETURN.
    ENDIF.

    IF lv_nbv_before_ret > lv_minval.
      IF lv_minval >= 0 AND lv_adjustment < 0.
      ELSE.
        RETURN.
      ENDIF.
    ENDIF.

    IF lv_nbv_before_ret < lv_minval.
      IF lv_minval <= 0 AND lv_adjustment > 0.
      ELSE.
        RETURN.
      ENDIF.
    ENDIF.

* get maximum amounts for possible adjustments
    ls_transaction-cur-depr_o       = cs_transaction-cur-depr_o
                                    + is_sumseg-cur-depr_o
                                    + is_calcamount-total-depr_o
                                    - is_calcamount-prev-depr_o.
    ls_transaction-cur-depr_s       = cs_transaction-cur-depr_s
                                    + is_sumseg-cur-depr_s
                                    + is_calcamount-total-depr_s
                                    - is_calcamount-prev-depr_s.
    ls_transaction-cur-depr_u       = cs_transaction-cur-depr_u
                                    + is_sumseg-cur-depr_u.
    ls_transaction-cur-resv         = cs_transaction-cur-resv
                                    + is_sumseg-cur-resv.
    ls_transaction-prev_cur-depr_o  = cs_transaction-prev_cur-depr_o
                                    + is_sumseg-prev_cur-depr_o
                                    + is_calcamount-prev-depr_o
                                    + is_yearseg-cum-depr_o.
    ls_transaction-prev_cur-depr_s  = cs_transaction-prev_cur-depr_s
                                    + is_sumseg-prev_cur-depr_s
                                    + is_calcamount-prev-depr_s
                                    + is_yearseg-cum-depr_s.
    ls_transaction-prev_cur-depr_u  = cs_transaction-prev_cur-depr_u
                                    + is_sumseg-prev_cur-depr_u.
    ls_transaction-prev_cur-resv    = cs_transaction-prev_cur-resv
                                    + is_sumseg-prev_cur-resv.
    ls_transaction-prev_prev-depr_o = cs_transaction-prev_prev-depr_o
                                    + is_sumseg-prev_prev-depr_o
                                    + is_yearseg-cum-depr_o.
    ls_transaction-prev_prev-depr_s = cs_transaction-prev_prev-depr_s
                                    + is_sumseg-prev_prev-depr_s
                                    + is_yearseg-cum-depr_s.
    ls_transaction-prev_prev-depr_u = cs_transaction-prev_prev-depr_u
                                    + is_sumseg-prev_prev-depr_u.
    ls_transaction-prev_prev-resv   = cs_transaction-prev_prev-resv
                                    + is_sumseg-prev_prev-resv.

    DO 3 TIMES.
      IF lv_adjustment EQ 0.
        EXIT.
      ENDIF.
      CASE sy-index.
        WHEN 1.
          ASSIGN ls_transaction-cur         TO <ls_value1>.
          ASSIGN cs_transaction-cur       TO <ls_value2>.
        WHEN 2.
          ASSIGN ls_transaction-prev_cur    TO <ls_value1>.
          ASSIGN cs_transaction-prev_cur  TO <ls_value2>.
        WHEN 3.
          ASSIGN ls_transaction-prev_prev   TO <ls_value1>.
          ASSIGN cs_transaction-prev_prev TO <ls_value2>.
      ENDCASE.

      DO 4 TIMES.
        lv_index = sy-index + 3.

        ASSIGN COMPONENT lv_index OF STRUCTURE <ls_value1> TO <lv_value1>.
        CHECK <lv_value1> <> 0.
        ASSIGN COMPONENT lv_index OF STRUCTURE <ls_value2> TO <lv_value2>.

        IF is_areasign-sign = lc_sign_minus.
          <lv_value2>       =  0 - <lv_value2>.
          <lv_value1>       =  0 - <lv_value1>.
          lv_adjustment     =  0 - lv_adjustment.
        ENDIF.

*     we can only adjust, if the total of depreciation is still below zero
        IF <lv_value1> < 0.
*       Adjustment only possible with the amount that is available on the asset
          IF ( abs( <lv_value1> ) >= abs( lv_adjustment ) ).
*         we may not change the sign of the proportional value
*         proportional values need to be positive  (value2)
            IF ( <lv_value2> - lv_adjustment ) >=  0.
              <lv_value2>   = <lv_value2> - lv_adjustment.
              lv_adjustment = 0.
*           to avoid change of the sign of proportional values,
*           adjust only available amount
            ELSE.
              lv_adjustment = lv_adjustment - <lv_value2>.
              <lv_value2> = 0.
            ENDIF.
*       Only available amount is adjusted
          ELSE.
            lv_adjustment = lv_adjustment - <lv_value2>.
            <lv_value2> = 0.
          ENDIF.
        ENDIF.

* For negative areas change sign
        IF is_areasign-sign = lc_sign_minus.
          <lv_value2>       =  0 - <lv_value2>.
          <lv_value1>       =  0 - <lv_value1>.
          lv_adjustment     =  0 - lv_adjustment.
        ENDIF.

* leave if nothing left to adjust
        CHECK lv_adjustment EQ 0.
        EXIT.
      ENDDO.
    ENDDO.

* POSTCONDITION

  ENDMETHOD.


  METHOD adjust_useful_life.
* PRECONDITION

* DEFINITION
  DATA lv_last_day_of_calc   TYPE dats.
    DATA lv_last_day_of_yr TYPE dats  VALUE '00001231'. "#VALUE_OK
    DATA lv_periods            TYPE numc3.
    DATA lv_periods_in_fyr     TYPE numc3.
    DATA lv_periods_reduced    TYPE int4.
    DATA lv_periods_covered    TYPE int4.
    DATA lv_fyear              TYPE numc4.
    DATA lv_useful_life_yrs    TYPE int4.
    DATA lv_useful_life_prds   TYPE int4.

* BODY
* set flag if expired life is to be calculated from change over year
  CASE is_hlpseg-key_phase_ref->ms_settings-uselife_reduce.
      WHEN abap_true.

        CASE is_hlpseg-use_days.

*// daily calculation
          WHEN abap_true.

* determine end date of depreciation calculation with correct year assignment
            lv_last_day_of_calc = is_hlpseg-start_date.
            lv_useful_life_yrs  = is_hlpseg-useful_life_yrs.
            lv_useful_life_prds = is_hlpseg-useful_life_prds.

            CALL FUNCTION 'FIMA_DATE_CREATE'
              EXPORTING
                i_date   = is_hlpseg-start_date
                i_years  = lv_useful_life_yrs
                i_months = lv_useful_life_prds
              IMPORTING
                e_date   = lv_last_day_of_calc.

            lv_last_day_of_calc = lv_last_day_of_calc - 1.

* Start of note 2428524
            CALL METHOD is_hlpseg-arearef->get_period_and_year
              EXPORTING
                iv_date      = lv_last_day_of_calc
              IMPORTING
*               ev_period    = cs_hlpseg-start_prd
                ev_fisc_year = DATA(lv_fiscal_year_of_last_day).

* 1. Check if last day of calculation is already on the end of a fiscal year OR the ending year is the same as starting year
*    Useful life is already calculated and there is no need of adjustment
*            IF lv_last_day_of_calc+4(4) = lv_last_day_of_yr+4(4) OR
            IF lv_last_day_of_calc+4(4) = is_hlpseg-last_day_in_yr+4(4) OR "< 2428524
               lv_fiscal_year_of_last_day = is_hlpseg-start_yr.

              cs_period-useful_life = is_hlpseg-useful_life.
              RETURN.
            ENDIF.

* 2. Check if useful life has to end in depreciation start year due to reduction
*    If yes just calculate from start date until end of that year
            DATA(lv_fiscal_year_before_last_yr) = lv_fiscal_year_of_last_day - 1.
            DATA(lv_last_day_of_start_yr) = is_hlpseg-arearef->get_last_day_in_year( iv_fisc_year = is_hlpseg-start_yr ).

            IF lv_fiscal_year_before_last_yr <= is_hlpseg-start_yr.
              cs_period-useful_life  = lv_last_day_of_start_yr - is_hlpseg-start_date + 1.
              RETURN.
            ENDIF.

* adjustment of useful life is required if enddate is in a future year and not last day of the year
* determine days covered within last year of useful life by ignoring leap years
* thus we adjust the years to (any) none leap years
            cs_period-useful_life    = ( lv_fiscal_year_before_last_yr - is_hlpseg-start_yr ) * 365.

            cs_period-useful_life    = cs_period-useful_life
                                     + ( lv_last_day_of_start_yr - is_hlpseg-start_date + 1 ).
* End of note 2428524

* if depr. starts before first of March in leap year just adjust regard 365 periods for calc.
            IF is_hlpseg-periods          = 366 AND
               is_hlpseg-start_date+4(2) <= '02'.

              cs_period-useful_life = cs_period-useful_life - 1.
            ENDIF.


*// period based calculation
          WHEN OTHERS.

* determine periods coverd within start year
            lv_periods_in_fyr  = is_hlpseg-periods     - is_hlpseg-start_prd  + 1.

* determine count of periods left excluding start year
            lv_periods_reduced = is_hlpseg-useful_life - lv_periods_in_fyr.

            IF lv_periods_reduced <= 0.
              cs_period-useful_life = is_hlpseg-useful_life.
              RETURN.
            ENDIF.

* useful life ends within year that succeeds start year => take periods in start year as UL
            IF lv_periods_reduced < is_hlpseg-periods.
              cs_period-useful_life = lv_periods_in_fyr.
              RETURN.
            ENDIF.

* determine count of overhanging periods in last year of useful life
            lv_periods_reduced    = lv_periods_reduced MOD is_hlpseg-periods.

            cs_period-useful_life = is_hlpseg-useful_life - lv_periods_reduced.

            RETURN.
        ENDCASE.

* special logic required if there were shortened fiscal years in the past
      WHEN gc_uselife_reduction_ind-shortyear_reduction.

* determine remaining useful life
        cs_period-useful_life = is_hlpseg-useful_life - is_hlpseg-exp_life.

* no adjustment required if useful life ends within second year of usage
        IF cs_period-useful_life <= is_hlpseg-periods AND
           cs_period-exp_life    <= is_hlpseg-periods.

          cs_period-useful_life = is_hlpseg-useful_life.

          EXIT.
* adjust useful life in that way that remaining useful life covers just whole years
        ELSE.
          cs_period-useful_life = is_hlpseg-useful_life - ( cs_period-useful_life MOD is_hlpseg-periods ).
        ENDIF.

        CHECK is_hlpseg-arearef->mo_leadobj->get_setup( )-has_short_fyear <> space.

        lv_fyear = is_hlpseg-start_yr + 1.
        CHECK is_hlpseg-fyear > lv_fyear.

        WHILE lv_fyear < is_hlpseg-fyear.
          CALL METHOD is_hlpseg-arearef->get_number_of_periods
            EXPORTING
              iv_fisc_year        = lv_fyear
            IMPORTING
              ev_periods          = lv_periods
              ev_periods_short_fy = lv_periods_in_fyr.

          lv_fyear = lv_fyear + 1.

          CHECK lv_periods_in_fyr < lv_periods .
          CHECK lv_periods_in_fyr > 0 .

          lv_periods_reduced  = lv_periods_reduced + lv_periods  - lv_periods_in_fyr.
          lv_periods_covered  = lv_periods_covered + lv_periods_in_fyr.
        ENDWHILE.

        cs_period-useful_life = is_hlpseg-useful_life - ( is_hlpseg-exp_life + lv_periods_reduced ).

        CHECK is_hlpseg-changeover_yr IS INITIAL.
        cs_period-useful_life = cs_period-useful_life + lv_periods_covered.
    ENDCASE.

* POSTCONDITION

ENDMETHOD.


  METHOD class_constructor.
* PRECONDITION
    CHECK cl_faa_tdc_activation=>get_tdc_active( ) = abap_false.

* DEFINITION
    CLASS: cl_exithandler DEFINITION LOAD.

* BODY
* check if there is any active BADI implementation for country specific issues
    CALL METHOD cl_exithandler=>get_instance
      EXPORTING
        exit_name              = 'FAA_DC_COUNTRY'
        null_instance_accepted = abap_true
      CHANGING
        instance               = go_badi_country. "#EC CI_BADI_OLD.

    IF cl_cos_utilities=>is_s4h_on_premise( ) = abap_true.
* check if there is any active BADI implementation for customer specific issues
      CALL METHOD cl_exithandler=>get_instance
        EXPORTING
          exit_name              = 'FAA_DC_CUSTOMER'
          null_instance_accepted = abap_true
        CHANGING
          instance               = go_badi_customer. "#EC CI_BADI_OLD.
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD create_message_from_syst.
* PRECONDITION

* DEFINITION
  DATA lo_message_handle      TYPE ty_o_dc_message_handle.

    DATA ls_rounding            TYPE ty_s_rounding.
    DATA ls_textid              LIKE if_t100_message=>t100key.
    DATA ls_symsg               TYPE symsg.

    DATA lv_depr_area           TYPE ty_s_area-depr_area.
    DATA lv_minvalue_float      TYPE f.

* BODY
  MOVE-CORRESPONDING syst TO ls_symsg.

    CASE ls_symsg-msgno(1).
      WHEN 0.
        IF sy-msgno <> 087.                                 "2223258
          ls_symsg-msgno = 698.
        ENDIF.

* exchange first digit of message number by 6, digits 2 and 3 correspond to Messageid AA
      WHEN 1.
        ls_symsg-msgno(1) = 6.
    ENDCASE.

    CASE ls_symsg-msgno.

* check if write up posting related with ord. depr. causes error message
      WHEN 624
        OR 625.

        IF ms_transaction_cntrl-classification EQ if_faa_posting_constants=>gc_movcat-writeup.
          ls_symsg-msgno = 634.
        ENDIF.

* check if write up posting related with spec. depr. causes error message
      WHEN 626
        OR 627.
        IF ms_transaction_cntrl-classification EQ if_faa_posting_constants=>gc_movcat-writeup.
          ls_symsg-msgno = 635.
        ENDIF.

*   invalid transaction typ used on manual revaluation => adjust content of MSGV1 to provide the asset number
      WHEN 629.                                             "2345009
        CLEAR       ls_symsg-msgv1.
        CONCATENATE ms_asset_data-s_asset_key-asset_no '-' ms_asset_data-s_asset_key-asset_subno INTO ls_symsg-msgv1.

*   Error message 632 for scrap value needs minimum value
      WHEN 632.
        lv_depr_area = sy-msgv1.
        READ TABLE mt_rounding INTO ls_rounding
          WITH KEY area = lv_depr_area.

        IF sy-subrc NE 0.
          CLEAR ls_rounding.
        ENDIF.

        lv_minvalue_float = syst-msgv1.
        WRITE lv_minvalue_float TO syst-msgv1 LEFT-JUSTIFIED EXPONENT 0 DECIMALS ls_rounding-place.

      WHEN 660.
        IF ms_transaction_cntrl-classification EQ if_faa_posting_constants=>gc_movcat-depreciation.
          ls_symsg-msgno = 590.
        ENDIF.
    ENDCASE.

    ls_textid-msgid = gc_message_id.
    ls_textid-msgno = ls_symsg-msgno.
    ls_textid-attr1 = 'MV_SY_MSGV1'.
    ls_textid-attr2 = 'MV_SY_MSGV2'.
    ls_textid-attr3 = 'MV_SY_MSGV3'.
    ls_textid-attr4 = 'MV_SY_MSGV4'.

    CREATE OBJECT lo_message_handle
      EXPORTING
        textid          = ls_textid
        severity        = cm_faa_t100=>co_severity_error
        mv_comp_code    = ms_proc_data-comp_code
        mv_ledger_group = ms_proc_data-ledger_group
        mv_fisc_year    = ms_proc_data-fyear
        mv_asset_no     = ms_asset_data-s_asset_key-asset_no
        mv_asset_subno  = ms_asset_data-s_asset_key-asset_subno
        mv_sy_msgv1     = ls_symsg-msgv1
        mv_sy_msgv2     = ls_symsg-msgv2
        mv_sy_msgv3     = ls_symsg-msgv3
        mv_sy_msgv4     = ls_symsg-msgv4.

    IF co_message_handle IS BOUND.
      CALL METHOD co_message_handle->add_detail_message_reference
        EXPORTING
          io_message = lo_message_handle.
    ELSE.
      co_message_handle = lo_message_handle.
      IF co_message_handle IS NOT REQUESTED.
        RAISE EXCEPTION lo_message_handle.
      ENDIF.
    ENDIF.

* POSTCONDITION

ENDMETHOD.


  METHOD get_area_signs.
* PRECONDITION

* DEFINITION

* BODY
    es_areasign-area   = io_arearef->mv_depr_area.
    es_areasign-apc    = io_arearef->ms_setup-sign_apc.
    es_areasign-nbv    = io_arearef->ms_setup-sign_nbv.
    es_areasign-invs   = io_arearef->ms_setup-sign_invest.
    es_areasign-resv   = io_arearef->ms_setup-sign_reserve.
    es_areasign-depr_o = io_arearef->ms_setup-sign_depr_o.
    es_areasign-depr_s = io_arearef->ms_setup-sign_depr_s.
    es_areasign-depr_u = io_arearef->ms_setup-sign_depr_u.
    es_areasign-revl   = io_arearef->ms_setup-sign_revl_apc.
    es_areasign-intr   = io_arearef->ms_setup-sign_interest.
    es_areasign-revl_d = io_arearef->ms_setup-sign_revl_depr.

* define overall sign for area
    es_areasign-sign  = id_neg_values.

    CASE es_areasign-sign.
      WHEN abap_true.
        es_areasign-sign = gc_area_value_sign-any.
      WHEN ' '.
        es_areasign-sign = gc_area_value_sign-positive.
    ENDCASE.

    IF ( es_areasign-apc  = gc_area_value_sign-negative                                                       ) OR
       ( es_areasign-apc  = gc_area_value_sign-none       AND  es_areasign-invs = gc_area_value_sign-negative ) OR
       ( es_areasign-apc  = gc_area_value_sign-none       AND  es_areasign-resv = gc_area_value_sign-negative ).

      IF es_areasign-sign = gc_area_value_sign-positive.
        es_areasign-sign = gc_area_value_sign-negative.
      ENDIF.
    ENDIF.

    IF io_arearef->ms_setup-calc_sequence+1(1) = gc_amount_type-ordn.
      es_areasign-depr_o_first = abap_true.
    ELSE.                             "
      CLEAR es_areasign-depr_o_first.
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD get_base_date_and_yr_and_prd.
* PRECONDITION

* DEFINITION
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

* BODY
    CLEAR ed_base_date.
    CLEAR ed_base_prd.
    CLEAR ed_base_fyr.

* determine validity year to be used for table access
    CASE id_base_rule.

* base date is activation date
      WHEN 1.
        ed_base_date = is_hlpseg-cap_date.

        IF ed_base_date IS INITIAL.
          ed_base_date = is_hlpseg-initial_acq.
        ENDIF.

        CALL METHOD is_hlpseg-arearef->get_period_and_year
          EXPORTING
            iv_date      = ed_base_date
          IMPORTING
            ev_period    = ed_base_prd
            ev_fisc_year = ed_base_fyr.

* base date is depreciation start date
      WHEN 2.
        ed_base_date  = is_hlpseg-start_date.
        ed_base_prd   = is_hlpseg-start_prd.
        ed_base_fyr    = is_hlpseg-start_yr.

        IF is_hlpseg-amount_type = gc_amount_type-spec.
          READ TABLE mts_hlpseg ASSIGNING <ls_hlpseg>
                WITH KEY fyear       = is_hlpseg-fyear
                         area        = is_hlpseg-area
                         curr_type   = is_hlpseg-curr_type
                         amount_type = gc_amount_type-ordn.

          IF sy-subrc = 0.
            ed_base_date  = <ls_hlpseg>-start_date.
            ed_base_prd   = <ls_hlpseg>-start_prd.
            ed_base_fyr    = <ls_hlpseg>-start_yr.
          ENDIF.
        ENDIF.

* base date is start date of sepcial depreciation
      WHEN 3.
        ed_base_date  = is_hlpseg-start_date.
        ed_base_prd   = is_hlpseg-start_prd.
        ed_base_fyr    = is_hlpseg-start_yr.

* base date is start date ordinary depreciation
        IF is_hlpseg-amount_type = gc_amount_type-ordn.
          READ TABLE mts_hlpseg ASSIGNING <ls_hlpseg>
                WITH KEY fyear       = is_hlpseg-fyear
                         area        = is_hlpseg-area
                         curr_type   = is_hlpseg-curr_type
                         amount_type = gc_amount_type-spec.

          IF sy-subrc = 0.
            ed_base_date  = <ls_hlpseg>-start_date.
            ed_base_prd   = <ls_hlpseg>-start_prd.
            ed_base_fyr    = <ls_hlpseg>-start_yr.
          ENDIF.
        ENDIF.

* base date activation date of AuC
      WHEN 4.
        ed_base_date = is_hlpseg-orig_acq_date
  .
        IF ed_base_date IS INITIAL.
          ed_base_date = is_hlpseg-cap_date.
        ENDIF.

        CALL METHOD is_hlpseg-arearef->get_period_and_year
          EXPORTING
            iv_date      = ed_base_date
          IMPORTING
            ev_period    = ed_base_prd
            ev_fisc_year = ed_base_fyr.

* use change over year
      WHEN 5.
        CHECK NOT is_hlpseg-changeover_yr IS INITIAL.

        ed_base_prd = is_hlpseg-changeover_prd.
        ed_base_fyr  = is_hlpseg-changeover_yr.

        IF ed_base_prd IS INITIAL.
          ed_base_prd = 1.
        ENDIF.
        CALL METHOD is_hlpseg-arearef->get_first_day_in_period
          EXPORTING
            iv_fisc_year = ed_base_fyr
            iv_period    = ed_base_prd
          IMPORTING
            ev_first_day = ed_base_date.
    ENDCASE.

* determine year for table access
    CASE id_determination_rule.
      WHEN 1.
*<<<<< start of insertion note 1473873 >>>>>*
        CALL METHOD is_hlpseg-arearef->get_first_day_in_period
          EXPORTING
            iv_fisc_year = ed_base_fyr
            iv_period    = ed_base_prd
          IMPORTING
            ev_first_day = ed_base_date.
*<<<<< end of insertion note 1473873 >>>>>*

        ed_base_yr = ed_base_date(4).
      WHEN 2.
        ed_base_yr = ed_base_date(4).
      WHEN 3.
        ed_base_yr = ed_base_fyr.
    ENDCASE.

* POSTCONDITION

ENDMETHOD.


  METHOD get_calc_info_for_amount_type.
* PRECONDITION

* DEFINITION
  DATA lt_area                  TYPE if_faa_depr_calc_types=>ty_t_area.

    DATA ls_transaction           TYPE ty_s_transaction.
    DATA ls_hlpseg                TYPE ty_s_hlpseg.

    DATA lv_periodcontrol         TYPE pergrp_d.
    DATA lv_first_day             TYPE dats.
    DATA lv_periods               TYPE ty_s_hlpseg-periods.

    DATA lv_fyear                 TYPE numc4.
    DATA lv_last_day_start_yr     TYPE ty_s_hlpseg-start_date.
    DATA lv_exp_life_start_yr     TYPE ty_s_hlpseg-exp_life.

    DATA lo_processing_handle     LIKE me.
    DATA lo_previous              LIKE me.

* BODY
* leave if both depreciation start date and capitalization date are initial
  IF cs_hlpseg-start_date IS INITIAL AND
       cs_hlpseg-cap_date   IS INITIAL.
      RETURN.
    ENDIF.

* determine depreciation start date from capitalization date
    IF cs_hlpseg-start_date IS INITIAL.
      IF cs_hlpseg-use_days EQ abap_true.
        cs_hlpseg-start_date = cs_hlpseg-cap_date.

      ELSE.
        IF ms_transaction_cntrl IS INITIAL.
          lv_periodcontrol = gc_period_group-acquisition.
        ELSE.
          READ TABLE mt_transaction_post INTO ls_transaction "2227480
           WITH KEY area      = cs_hlpseg-area
                    curr_type = cs_hlpseg-curr_type.
          IF sy-subrc = 0.
            lv_periodcontrol = ls_transaction-periodcontrol.
          ELSE.
            lv_periodcontrol = ms_transaction_cntrl-periodcontrol.
          ENDIF.
        ENDIF.

        CALL METHOD get_calc_yr_and_per_from_date
          EXPORTING
            is_hlpseg             = cs_hlpseg
            iv_per_ctrl_group     = lv_periodcontrol
            iv_value_date         = cs_hlpseg-cap_date
          IMPORTING
            ev_fiscal_year        = cs_hlpseg-start_yr
            ev_calculation_period = cs_hlpseg-start_prd.

* Adjust start year and period if period determined is behind fiscal year end
        IF cs_hlpseg-start_yr  = cs_hlpseg-fyear AND
           cs_hlpseg-start_prd > cs_hlpseg-periods_short_fy.
          cs_hlpseg-start_prd = 1.
          cs_hlpseg-start_yr  = cs_hlpseg-start_yr + 1.
        ENDIF.

* get start period if start year is prior fiscal year
        IF cs_hlpseg-start_yr  < cs_hlpseg-fyear.
          CALL METHOD cs_hlpseg-arearef->get_number_of_periods
            EXPORTING
              iv_fisc_year        = cs_hlpseg-start_yr
            IMPORTING
              ev_periods_short_fy = lv_periods.

          IF cs_hlpseg-start_prd > lv_periods.
            cs_hlpseg-start_prd = 1.
            cs_hlpseg-start_yr  = cs_hlpseg-start_yr + 1.
          ENDIF.
        ENDIF.

* get start date
        CALL METHOD cs_hlpseg-arearef->get_first_day_in_period
          EXPORTING
            iv_fisc_year = cs_hlpseg-start_yr
            iv_period    = cs_hlpseg-start_prd
          IMPORTING
            ev_first_day = cs_hlpseg-start_date.
      ENDIF.
    ENDIF.

* determine depreciation start year and period
    IF cs_hlpseg-start_prd IS INITIAL.
      CALL METHOD cs_hlpseg-arearef->get_period_and_year
        EXPORTING
          iv_date      = cs_hlpseg-start_date
        IMPORTING
          ev_period    = cs_hlpseg-start_prd
          ev_fisc_year = cs_hlpseg-start_yr.

* on daily calc. determine start period using first day of start year
      IF cs_hlpseg-use_days EQ abap_true.
        CALL METHOD cs_hlpseg-arearef->get_first_day_in_year
          EXPORTING
            iv_fisc_year = cs_hlpseg-start_yr
          RECEIVING
            rv_first_day = lv_first_day.

        cs_hlpseg-start_prd = cs_hlpseg-start_date - lv_first_day + 1.
      ENDIF.
    ENDIF.

********************************************************************
* takeover expired useful life from asset master
********************************************************************
    CHECK ms_proc_data-step <> gc_step-dc_int_calc_exp_life_cz.
    IF cs_hlpseg-use_days IS INITIAL.
      lv_periods  = cs_hlpseg-periods.
    ELSE.
      lv_periods  = 365.
    ENDIF.

    CASE cs_hlpseg-amount_type.
      WHEN gc_amount_type-ordn.
        cs_hlpseg-exp_life   = is_depr_param-exp_ulife_yrs
                             * lv_periods
                             + is_depr_param-exp_ulife_prds.

      WHEN gc_amount_type-spec.
        cs_hlpseg-exp_life   = is_depr_param-exp_ulife_sdep_yrs
                             * lv_periods
                             + is_depr_param-exp_ulife_sdep_prds.

      WHEN gc_amount_type-intr.
        cs_hlpseg-exp_life    = is_depr_param-exp_ulife_yrs
                              * lv_periods
                              + is_depr_param-exp_ulife_prds.
    ENDCASE.

********************************************************************
* calculate expired useful life from cap. date but only
* when no shutdown needs to be considered.
********************************************************************
    IF cs_hlpseg-start_date LT cs_hlpseg-first_day_in_yr AND
       cs_hlpseg-start_date NE gc_date-no_date        AND
       cs_hlpseg-exp_life   EQ 0.

* check if shut down periods are to be regarded
      IF cs_hlpseg-key_phase_ref->ms_settings-regard_shutdown = abap_true.

        LOOP AT mo_start->ms_asset_data-ts_depr_param TRANSPORTING NO FIELDS
          WHERE depr_area   = CONV bf_afabe_d( cs_hlpseg-area ) "#EC *
            AND curr_type   = cs_hlpseg-curr_type
            AND from_date   < is_depr_param-from_date
            AND is_shutdown = abap_true.
          EXIT.
        ENDLOOP.

* asset has been shut down before actual time interval = > no calculation
        IF sy-subrc = 0.
          RETURN.
        ENDIF.

* asset is shut down for actual time interval = > no calculation
        IF is_depr_param-is_shutdown  = abap_true.
          RETURN.
        ENDIF.
      ENDIF.

* perform simplified calculation of expired useful life
      IF cs_hlpseg-use_days IS INITIAL.
        cs_hlpseg-exp_life = cs_hlpseg-fyear    - cs_hlpseg-start_yr  - 1.
        cs_hlpseg-exp_life = cs_hlpseg-exp_life * cs_hlpseg-periods.
        cs_hlpseg-exp_life = cs_hlpseg-exp_life + cs_hlpseg-periods
                                                - cs_hlpseg-start_prd + 1.
      ELSE.

* get last day of start year and calculate expired days in the start year
        CALL METHOD cs_hlpseg-arearef->get_last_day_in_year
          EXPORTING
            iv_fisc_year = cs_hlpseg-start_yr
          RECEIVING
            rv_last_day  = lv_last_day_start_yr.

        lv_exp_life_start_yr = lv_last_day_start_yr - cs_hlpseg-start_date + 1.

* correct for a leap year because a whole leap year
* added 365 days to the planned useful life
        IF lv_exp_life_start_yr = 366.
          lv_exp_life_start_yr = 365.
        ENDIF.

        cs_hlpseg-exp_life = lv_exp_life_start_yr
                           + ( cs_hlpseg-fyear - cs_hlpseg-start_yr - 1 ) * lv_periods.

      ENDIF.

* H3066337: reset the expired useful life in case the depreciation start date is changed and no longer in the past;
*           the expired useful life in the depreciation start year is always set to 0
    ELSEIF cs_hlpseg-start_date GE cs_hlpseg-first_day_in_yr AND
           cs_hlpseg-start_date NE gc_date-no_date           AND
           cs_hlpseg-exp_life   NE 0.

      CLEAR cs_hlpseg-exp_life.
    ENDIF.

********************************************************************
* calculate expired useful life from changeover year
********************************************************************
    IF cs_hlpseg-use_exp_life_new EQ abap_true.
      IF cs_hlpseg-changeover_yr LT cs_hlpseg-fyear AND
         cs_hlpseg-changeover_yr IS NOT INITIAL.

        lv_fyear    = cs_hlpseg-changeover_yr.
        lt_area     = mts_area.

        DELETE lt_area
         WHERE depr_area <> cs_hlpseg-area.

        READ TABLE lt_area ASSIGNING FIELD-SYMBOL(<ls_area>)
          WITH KEY depr_area = cs_hlpseg-area.
        ASSERT sy-subrc = 0.

        DELETE <ls_area>-t_curtp_amount
         WHERE curr_type <> cs_hlpseg-curr_type.


        WHILE lv_fyear <= cs_hlpseg-fyear.
          CREATE OBJECT lo_processing_handle.
          lo_processing_handle->mo_previous        = lo_previous.
*         lo_processing_handle->mo_start           = lo_previous->mo_start.
* mo_start is always the same                                      "2301034
          lo_processing_handle->mo_start           = me->mo_start. "2301034
          lo_processing_handle->mts_area           = lt_area.
          lo_processing_handle->ms_proc_data       = ms_proc_data.
          lo_processing_handle->ms_proc_data-step  = gc_step-dc_int_calc_exp_life_cz.
          lo_processing_handle->ms_proc_data-fyear = lv_fyear. "2273009
          lo_processing_handle->ms_proc_data-first_day_in_fyr = cs_hlpseg-arearef->get_first_day_in_year( iv_fisc_year = lv_fyear ). "3041253
          lo_processing_handle->ms_proc_data-last_day_in_fyr = cs_hlpseg-arearef->get_last_day_in_year( iv_fisc_year = lv_fyear ). "3041253

          CALL METHOD lo_processing_handle->_hlpseg_create.
          CALL METHOD lo_processing_handle->_hlpseg_split_at_ul_end.
          CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
          lo_previous = lo_processing_handle.
          lv_fyear = lv_fyear + 1.
        ENDWHILE.

* take over calculated expired life new starting at changeover year
        READ TABLE lo_processing_handle->mts_hlpseg  INTO ls_hlpseg
          WITH KEY amount_type  = cs_hlpseg-amount_type.    "2273009

        ASSERT sy-subrc = 0.

*       cs_hlpseg-exp_life_new = ls_hlpseg-exp_life_new.    "2301034
        cs_hlpseg-exp_life_new = ls_hlpseg-exp_life.        "2301034
      ENDIF.
    ENDIF.

* POSTCONDITION

ENDMETHOD.


  METHOD get_calc_yr_and_per_4_trnsctn.
*=======================================================================
* get calculation period and year for value date of transaction  "new with note 2189388
*=======================================================================
* PRECONDITION

* DEFINITIONS
  FIELD-SYMBOLS <lv_check_date>    TYPE dats.

    DATA ls_period_cntrl             TYPE ty_s_deprkey-period_control.
    DATA lv_per_ctrl_group           TYPE tabwg-pergrp.

* BODY
    CLEAR ev_calculation_period.
    CLEAR ev_fiscal_year.
* incoming period control may change if acquisition and no depreciation to the day
  lv_per_ctrl_group     = iv_per_ctrl_group.                      "< 2953331

* get calculation period and year for value date of transaction according to settings
    IF is_hlpseg-use_days = abap_true.
      ev_calculation_period = iv_value_date - is_hlpseg-first_day_in_yr + 1.
      ev_fiscal_year        = is_hlpseg-fyear.
    ELSE.

* adjust period control group of acquisition posting if applicable
      IF lv_per_ctrl_group = gc_period_group-acquisition.

        DO 2 TIMES.
          IF sy-index = 1.
            ASSIGN is_hlpseg-start_date  TO <lv_check_date>.
          ELSE.
            ASSIGN is_hlpseg-initial_acq TO <lv_check_date>.
          ENDIF.

          CHECK <lv_check_date> < is_hlpseg-first_day_in_yr.
          lv_per_ctrl_group = gc_period_group-postcap.
          EXIT.
        ENDDO.
      ENDIF.

* get calculation period and year accoding to settings
      CALL METHOD get_calc_yr_and_per_from_date
        EXPORTING
          is_hlpseg             = is_hlpseg
          iv_per_ctrl_group     = lv_per_ctrl_group
          iv_value_date         = iv_value_date
        IMPORTING
          ev_fiscal_year        = ev_fiscal_year
          ev_calculation_period = ev_calculation_period.
    ENDIF.

***************************************************************************
* perform adjustment of calc. year and period if neccessary
***************************************************************************

*--------------------------------------------------------------------------*
* perform adjustment if transactions is before the calc. start year
*--------------------------------------------------------------------------*
* calculation starts earliest at calculation start year and period
    IF ev_fiscal_year < is_hlpseg-start_yr.
      ev_calculation_period = is_hlpseg-start_prd.
      ev_fiscal_year        = is_hlpseg-start_yr.
    ENDIF.

*--------------------------------------------------------------------------*
* perform adjustment if transactions is in the calc. start year
*--------------------------------------------------------------------------*
    IF ev_fiscal_year = is_hlpseg-start_yr.

* consideration of transaction starts earliest with start period
      IF ev_calculation_period < is_hlpseg-start_prd.
        ev_calculation_period = is_hlpseg-start_prd.

* perform adjustment of calculation period if it is after the start period
      ELSE.
      CASE lv_per_ctrl_group.                                     "< 2953331

* acquisitions in start year are to be assigned to start period if not denied by depr. key settings
          WHEN gc_period_group-acquisition.
            CLEAR ls_period_cntrl.

            LOOP AT is_hlpseg-key_phase_ref->mts_period_control INTO ls_period_cntrl "#EC CI_SORTSEQ
              WHERE valid_to_fyear  >= is_hlpseg-fyear
              AND prd_cntrl_group  = lv_per_ctrl_group.           "< 2953331
              EXIT.
            ENDLOOP.

            IF ls_period_cntrl-prd_cntrl_valdat = abap_false.
              ev_calculation_period = is_hlpseg-start_prd.
              ev_fiscal_year        = is_hlpseg-start_yr.
            ENDIF.

* on daily calculation retirement/transfer/Revalutaion is to be shifted to next year if
* value date equals to the last day of the fixcal year to insure the whole year is regarded
          WHEN gc_period_group-transfer
            OR gc_period_group-retirement
            OR gc_period_group-revaluation.

            IF is_hlpseg-last_day_in_yr = iv_value_date AND
               is_hlpseg-use_days        = abap_true.

              ev_fiscal_year = ev_fiscal_year + 1.
            ENDIF.
        ENDCASE.
      ENDIF.
    ENDIF.

*--------------------------------------------------------------------------*
* perform adjustment if transactions is after the calc. start year
*--------------------------------------------------------------------------*
    IF ev_fiscal_year > is_hlpseg-start_yr.
    CASE lv_per_ctrl_group.                                       "< 2953331
        WHEN gc_period_group-acquisition.

* on daily calculation retirement/transfer/Revalutaion is to be shifted to next year if
* value date equals to the last day of the fixcal year to insure the whole year is regarded
        WHEN gc_period_group-transfer
          OR gc_period_group-retirement
          OR gc_period_group-revaluation.

          IF is_hlpseg-last_day_in_yr = iv_value_date AND
            is_hlpseg-use_days        = abap_true.

            ev_fiscal_year = ev_fiscal_year + 1.
          ENDIF.
      ENDCASE.
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD get_calc_yr_and_per_from_date.
* method is completely reworked with note 2189388
*=======================================================================
* determination of calc. period and year for value date according
* to given period control group
*=======================================================================
* PRECONDITION
    CLEAR ev_calculation_period.
    CLEAR ev_fiscal_year.

* DEFINITIONS
    FIELD-SYMBOLS <lts_period_det>   TYPE ty_ts_deprkey_period_determin.
    FIELD-SYMBOLS <lv_check_date>    TYPE dats.

    DATA ls_period_cntrl             TYPE ty_s_deprkey-period_control.
    DATA ls_period_det               TYPE ty_s_deprkey-period_determin.

*    DATA lv_first_day_in_fyr         TYPE dats.
    DATA lv_midmonth                 TYPE abap_bool.
    DATA lv_message                  TYPE string.
    DATA lv_calculation_period TYPE faa_dc_start_prd.       "< 2535113

    DATA: BEGIN OF ls_date,
            year  TYPE numc4,
            month TYPE numc2,
            day   TYPE numc2,
          END   OF ls_date.

* BODY

* get period control for transaction assignment
    LOOP AT is_hlpseg-key_phase_ref->mts_period_control INTO ls_period_cntrl "#EC CI_SORTSEQ
      WHERE valid_to_fyear GE is_hlpseg-fyear
        AND prd_cntrl_group EQ iv_per_ctrl_group.

      EXIT.
    ENDLOOP.

    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_fatal_exception.
    ENDIF.

* <<< begin of insertion - note 2535113 >>>
*   determine fiscal year of value date and period which may be changed
*   later on
*   set default value using the capitalisation date provided by caller
*   period is determined applying the valid period controls
*   A possible shift to the next fiscal year due to the determination
*   of period 13 will be done in the calling method.
    CALL METHOD is_hlpseg-arearef->get_period_and_year
      EXPORTING
        iv_date      = iv_value_date
      IMPORTING
        ev_period    = lv_calculation_period
        ev_fisc_year = ev_fiscal_year.
* <<< end of insertion - note 2535113 >>>

* determine whether half month rule to be applied
    CALL METHOD is_hlpseg-arearef->is_active
      EXPORTING
        iv_setting = gc_setting_halfmonth
      RECEIVING
        rv_active  = lv_midmonth.

* determine assigned calculation period for transaction
    IF ls_period_cntrl-use_common_rules EQ abap_false.
      ls_date = iv_value_date.

      IF is_hlpseg-key_phase_ref->ms_settings-prd_detrm_per_yr IS INITIAL.
        CLEAR ls_date-year.
      ENDIF.

      ASSIGN is_hlpseg-arearef->mts_period_determine->* TO <lts_period_det>.

      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE cx_fatal_exception.
      ENDIF.

      READ TABLE <lts_period_det> INTO ls_period_det
            WITH KEY prd_control_key  = ls_period_cntrl-prd_control_key
                     date_year   = ls_date-year
                     date_month  = ls_date-month
                     date_day    = ls_date-day
                     BINARY SEARCH.

      CASE sy-subrc.
        WHEN 0.

        WHEN 4.
          READ TABLE <lts_period_det> INTO ls_period_det INDEX sy-tabix.
        WHEN 8.
          CLEAR ls_period_det.
      ENDCASE.

      IF ls_period_det-prd_control_key EQ ls_period_cntrl-prd_control_key AND
         ls_period_det-date_year       EQ ls_date-year.

*        ev_fiscal_year        = is_hlpseg-fyear.            "< 2535113
        ev_calculation_period = ls_period_det-period + 1.

* consider that calculation uses 24 periods
        IF NOT lv_midmonth IS INITIAL.
          ev_calculation_period = ls_period_det-period * 2 + 1.
        ENDIF.

* consider half month assignment request for transaction
        IF NOT ls_period_det-use_half_months IS INITIAL.
          ev_calculation_period = ev_calculation_period - 1.
        ENDIF.

* raise error message if calc. period determination not possible
      ELSE.
        syst-msgv3+0(1) = is_hlpseg-amount_type.
        syst-msgv3+1(1) = is_hlpseg-phase.
        MESSAGE e613(aa) WITH ls_period_cntrl-prd_control_key iv_value_date syst-msgv3 INTO lv_message.

        CALL METHOD create_message_from_syst.
      ENDIF.
    ELSE.
      ev_calculation_period = lv_calculation_period.        "<<< 2535113
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD get_data_from_badi.
* PRECONDITION

* DEFINITION
  DATA lo_segment_handle TYPE faa_dc_segment_handle.

    DATA ls_hlpseg LIKE cs_hlpseg.                          "2270486
    DATA lv_modulo         TYPE i.
    DATA lv_message        TYPE string.

* BODY
  ls_hlpseg = cs_hlpseg.                                    "2270486

    me->prepare_badi_call( CHANGING co_dc_segment_handle = lo_segment_handle ).

*--------------------------------------------------------------------------------
* call Country specific BADI methods
*--------------------------------------------------------------------------------
    IF go_badi_country IS BOUND.
      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_country->define_use_of_max_periods
          EXPORTING
            flt_val            = cs_hlpseg-arearef->mo_leadobj->get_setup( )-country
            io_handle          = lo_segment_handle
            is_hlpseg          = cs_hlpseg
          CHANGING
            cb_use_max_periods = cs_hlpseg-use_max_periods
          EXCEPTIONS
            error_occurred     = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-use_max_periods = abap_true.
          cs_hlpseg-range_length = 1.
        ENDIF.
      ENDIF.

      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_country->define_segment_length
          EXPORTING
            flt_val           = cs_hlpseg-arearef->mo_leadobj->get_setup( )-country
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_segment_length = cs_hlpseg-range_length
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-range_length > 0.
          lv_modulo  = cs_hlpseg-periods MOD cs_hlpseg-range_length.
        ENDIF.

        IF lv_modulo IS NOT INITIAL.
          CLEAR cs_hlpseg-range_length.

          MESSAGE e678(aa) WITH 'FAA_DC_CUNTRY' 'DEFINE_SEGMENT_LENGTH' INTO lv_message.
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.

* get country sepcific change over information
      IF cs_hlpseg-key_phase_ref->ms_settings-changeover_meth CA gc_changeover_meth_country AND
         cs_hlpseg-changeover_yr                              IS INITIAL.
        CALL METHOD go_badi_country->define_changeover_yr
          EXPORTING
            flt_val          = cs_hlpseg-arearef->mo_leadobj->get_setup( )-country
            io_handle        = lo_segment_handle
            is_hlpseg        = cs_hlpseg
          CHANGING
            cd_changeover_yr = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred   = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        CALL METHOD go_badi_country->define_changeover_yr_and_prd
          EXPORTING
            flt_val           = cs_hlpseg-arearef->mo_leadobj->get_setup( )-country
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_changeover_prd = cs_hlpseg-changeover_prd
            cd_changeover_yr  = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.
    ENDIF.

*--------------------------------------------------------------------------------
* call Customer specific BADI methods
*--------------------------------------------------------------------------------
    IF go_badi_customer IS BOUND.
      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_customer->define_use_of_max_periods
          EXPORTING
            io_handle          = lo_segment_handle
            is_hlpseg          = cs_hlpseg
          CHANGING
            cb_use_max_periods = cs_hlpseg-use_max_periods
          EXCEPTIONS
            error_occurred     = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-use_max_periods = abap_true.
          cs_hlpseg-range_length = 1.
        ENDIF.
      ENDIF.

      IF cs_hlpseg-use_max_periods IS INITIAL.
        CALL METHOD go_badi_customer->define_segment_length
          EXPORTING
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_segment_length = cs_hlpseg-range_length
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        IF cs_hlpseg-range_length > 0.
          lv_modulo  = cs_hlpseg-periods MOD cs_hlpseg-range_length.
        ENDIF.

        IF lv_modulo IS NOT INITIAL.
          CLEAR cs_hlpseg-range_length.

          MESSAGE e678(aa) WITH 'FAA_DC_CUSTOMER' 'DEFINE_SEGMENT_LENGTH' INTO lv_message.
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.

* get customer sepcific change over information
      IF cs_hlpseg-key_phase_ref->ms_settings-changeover_meth CA gc_changeover_meth_customer AND
         cs_hlpseg-changeover_yr                              IS INITIAL.
        CALL METHOD go_badi_customer->define_changeover_yr
          EXPORTING
            io_handle        = lo_segment_handle
            is_hlpseg        = cs_hlpseg
          CHANGING
            cd_changeover_yr = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred   = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        CALL METHOD go_badi_customer->define_changeover_yr_and_prd
          EXPORTING
            io_handle         = lo_segment_handle
            is_hlpseg         = cs_hlpseg
          CHANGING
            cd_changeover_prd = cs_hlpseg-changeover_prd
            cd_changeover_yr  = cs_hlpseg-changeover_yr
          EXCEPTIONS
            error_occurred    = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.
    ENDIF.

* get settings for depr. calc for phase 2
    CHECK go_badi_country  IS BOUND
       OR go_badi_customer IS BOUND.


    CHECK cs_hlpseg-changeover_yr <= cs_hlpseg-fyear
      AND cs_hlpseg-changeover_yr >  0.

    CHECK ls_hlpseg-changeover_yr =  0.                     "2270486

    CALL METHOD get_phase_and_deprkey_config
      CHANGING
        cs_hlpseg = cs_hlpseg.

* POSTCONDITION

ENDMETHOD.


METHOD get_data_from_prior_year.
* PRECONDITION

* DEFINITION
  FIELD-SYMBOLS <ls_hlpseg>        TYPE ty_s_hlpseg.
  DATA ls_reduction                TYPE ty_s_deprarea-short_fyear.
  DATA ls_hlpseg                   TYPE ty_s_hlpseg.
  DATA lv_exp_life                 TYPE ty_s_hlpseg-periods.

* BODY
********************************************************************
* get expired useful life from prior year period intervals
********************************************************************
  LOOP AT mo_previous->mts_hlpseg ASSIGNING <ls_hlpseg>
    WHERE area        = cs_hlpseg-area
      AND curr_type   = cs_hlpseg-curr_type
      AND amount_type = cs_hlpseg-amount_type.

    ls_hlpseg   = <ls_hlpseg>.
    lv_exp_life = lv_exp_life + <ls_hlpseg>-exp_life_seg.
  ENDLOOP.

  CHECK sy-subrc EQ 0.

* ignore leap years on determination of expired life because of compatibility to old AFAR
  IF cs_hlpseg-use_days EQ abap_true.
    IF lv_exp_life = 366.
      lv_exp_life = 365.
    ENDIF.
  ENDIF.

* get settings related with shortened fiscal year
  IF ls_hlpseg-is_shortfiscyear EQ abap_true.
*     Make sure to read with prior fiscal year                  "2545695
    READ TABLE cs_hlpseg-arearef->mts_short_fy_reduction INTO ls_reduction
      WITH KEY short_fisc_year = ls_hlpseg-fyear.           "2545695

    IF sy-subrc <> 0.
      CLEAR ls_reduction.
    ENDIF.

*     Shortened fiscal year information may only be passed locally to
*     prior fiscal year information
    CASE cs_hlpseg-amount_type.
      WHEN gc_amount_type-ordn OR gc_amount_type-intr. "note_2916065
* Expired useful life is stored in YDDA only for ordinary depreciation and special depreciation but NOT for interest. Therefore it has
* to be the same treatment in the implicit carry forward
        ls_hlpseg-regard_short_yr = ls_reduction-reduce_depr_o. "2545695
      WHEN gc_amount_type-spec.
        ls_hlpseg-regard_short_yr = ls_reduction-reduce_depr_s. "2545695
    ENDCASE.

* setting of depreciation key wins
    IF ls_hlpseg-key_phase_ref->ms_settings-no_reduction EQ abap_true.
      ls_hlpseg-regard_short_yr = abap_false.               "2545695
    ENDIF.

* in case depreciation was not reduced in a shortened year
* expired life has to be corrected to the whole year
    IF ls_hlpseg-regard_short_yr  = abap_false.             "2545695
      lv_exp_life = lv_exp_life * ls_hlpseg-periods / ls_hlpseg-periods_short_fy.
    ENDIF.
  ENDIF.

  cs_hlpseg-exp_life = ls_hlpseg-exp_life + lv_exp_life.

  IF NOT <ls_hlpseg>-use_exp_life_new IS INITIAL.
    cs_hlpseg-exp_life_new = ls_hlpseg-exp_life_new + lv_exp_life. "2322410
  ENDIF.

* get depreciation start and change over information
  cs_hlpseg-start_date      = ls_hlpseg-start_date.
  cs_hlpseg-start_yr        = ls_hlpseg-start_yr.
  cs_hlpseg-start_prd       = ls_hlpseg-start_prd.

  cs_hlpseg-changeover_yr   = ls_hlpseg-changeover_yr.
  cs_hlpseg-changeover_prd  = ls_hlpseg-changeover_prd.

* POSTCONDITION

ENDMETHOD.


  METHOD get_depr_param.
* PRECONDITION

* DEFINITION
    DATA lt_phase                 TYPE ty_ts_deprkey_phase.
    DATA ls_amount_types          TYPE ty_s_hlpseg-amount_types.

    DATA ls_phase                 TYPE ty_s_deprkey-phase.
    DATA lv_calc_seq TYPE char4. "##NEEDED
    DATA lv_alignment_ind         TYPE int2.
    DATA lv_message               TYPE string.
    DATA lo_depr_key              TYPE REF TO if_faa_cfg_depr_key.

* BODY
    cs_hlpseg-depr_key         = is_depr_param-depr_key.
    cs_hlpseg-changeover_yr    = is_depr_param-changeover_yr.
    cs_hlpseg-changeover_prd   = is_depr_param-changeover_prd.
    cs_hlpseg-scrapvalue       = is_depr_param-scrapvalue.
    cs_hlpseg-scrapvalue_prctg = is_depr_param-scrapvalue_prctg.
    cs_hlpseg-var_dep_portion  = is_depr_param-var_depr_portion.
    cs_hlpseg-neg_values       = is_depr_param-neg_values.
    cs_hlpseg-shift_fact       = is_depr_param-shift_fact.
    cs_hlpseg-is_shutdown      = is_depr_param-is_shutdown.
    cs_hlpseg-invsupport_key   = is_depr_param-invsupport_key.
    cs_hlpseg-to_date_of_tddp  = is_depr_param-to_date.
    cs_hlpseg-use_days         = is_depr_param-use_days.
  cs_hlpseg-usage_object     = is_depr_param-usage_object.

* get useful life in fiscal periods
    cs_hlpseg-useful_life      = is_depr_param-ulife_yrs * cs_hlpseg-periods
                               + is_depr_param-ulife_prds.

* periods of useful life are month on halmonth related calculation => add twice
    IF cs_hlpseg-arearef->is_active( gc_setting_halfmonth ) = abap_true.
      cs_hlpseg-useful_life    = cs_hlpseg-useful_life + is_depr_param-ulife_prds.
    ENDIF.

* get base settings of depr. key to determine if calc. on daily base to be performed
    lo_depr_key = cl_faa_cfg_factory_static=>get_instance_depr_key(
                                               iv_comp_code = cs_hlpseg-arearef->ms_leadobj_key-comp_code
                                               iv_depr_area = CONV #( cs_hlpseg-area )
                                               iv_depr_key  = cs_hlpseg-depr_key                         ).

    cs_hlpseg-use_days = lo_depr_key->ms_settings-calc_per_day.

* get useful life in days
    IF NOT cs_hlpseg-use_days IS INITIAL.
      cs_hlpseg-useful_life_prds = is_depr_param-ulife_prds.
      cs_hlpseg-useful_life_yrs  = is_depr_param-ulife_yrs.

      cs_hlpseg-useful_life      = is_depr_param-ulife_yrs  * 365
                                 + is_depr_param-ulife_prds * 365 / 12.

      cs_hlpseg-periods_short_fy = cs_hlpseg-last_day_in_yr - cs_hlpseg-first_day_in_yr + 1.
      cs_hlpseg-period_to        = cs_hlpseg-last_day_in_yr - cs_hlpseg-first_day_in_yr + 1.
      cs_hlpseg-periods          = cs_hlpseg-last_day_in_yr - cs_hlpseg-first_day_in_yr + 1.

      IF NOT cs_hlpseg-is_shortfiscyear IS INITIAL.
        cs_hlpseg-periods = 365.
      ENDIF.

*   for daily depreciation check, that leap year calculates with 366 days useful life
      IF cs_hlpseg-useful_life = 365  AND  cs_hlpseg-periods     = 366.
        cs_hlpseg-useful_life = 366.
      ENDIF.
    ENDIF.

* mark segment if group asset is assigned
    IF NOT is_depr_param-grp_asset IS INITIAL.
      cs_hlpseg-grp_asset_assgnd = abap_true.
    ENDIF.

* note if replacment value calculation is required
    cs_hlpseg-rplcmntval_index = is_depr_param-rplcmntval_index.
    cs_hlpseg-age_index        = is_depr_param-age_index.

* note if inflation calculation is required
    IF NOT cs_hlpseg-calc_inflation IS INITIAL.
      cs_hlpseg-revaltn_key = is_depr_param-revaltn_key.
    ENDIF.

    lt_phase = lo_depr_key->get_phases( ).
    ls_amount_types = cs_hlpseg-amount_types.

    LOOP AT lt_phase INTO ls_phase.
      AT NEW amount_type.
        CASE ls_phase-amount_type.
          WHEN gc_amount_type-ordn.
            cs_hlpseg-calc_seq_ordn = 50.
* determine calculation sequence for ordinary depreciation
            lv_calc_seq = cs_hlpseg-arearef->ms_setup-calc_sequence.
            SHIFT lv_calc_seq UP TO gc_amount_type-ordn.
            SHIFT lv_calc_seq UP TO gc_amount_type-spec.

            IF sy-subrc <> 0.
              cs_hlpseg-calc_seq_ordn = 60.
            ENDIF.

          WHEN gc_amount_type-spec.
            cs_hlpseg-calc_seq_spec = 60.
* determine calculation sequence for special dereciation
            lv_calc_seq = cs_hlpseg-arearef->ms_setup-calc_sequence.
            SHIFT lv_calc_seq UP TO gc_amount_type-ordn.
            SHIFT lv_calc_seq UP TO gc_amount_type-spec.

            IF sy-subrc <> 0.
              cs_hlpseg-calc_seq_spec = 50.
            ENDIF.

          WHEN gc_amount_type-intr.
            cs_hlpseg-calc_seq_intr = 80.

        ENDCASE.
      ENDAT.
    ENDLOOP.

    IF cs_hlpseg-arearef->ms_setup-sign_depr_o EQ gc_area_value_sign-none.
      cs_hlpseg-calc_seq_ordn = 0.
    ENDIF.

    IF cs_hlpseg-arearef->ms_setup-sign_depr_s EQ gc_area_value_sign-none.
      cs_hlpseg-calc_seq_spec = 0.
    ENDIF.

    IF cs_hlpseg-arearef->ms_setup-sign_interest EQ gc_area_value_sign-none.
      cs_hlpseg-calc_seq_intr = 0.
    ENDIF.

    IF cs_hlpseg-amount_types = 0.                          "2223525
      READ TABLE lt_phase INTO ls_phase INDEX 1.
      CASE ls_phase-amount_type.
        WHEN gc_amount_type-ordn.
          cs_hlpseg-calc_seq_ordn = 50.
        WHEN gc_amount_type-spec.
          cs_hlpseg-calc_seq_spec = 60.
        WHEN gc_amount_type-intr.
          cs_hlpseg-calc_seq_intr = 80.
      ENDCASE.
    ENDIF.

* deviation on amount types to be calculated are not allowed within one fiscal year
    IF ls_amount_types <> cs_hlpseg-amount_types AND ls_amount_types IS NOT INITIAL.
      MESSAGE e591(aa) INTO lv_message.
      CALL METHOD create_message_from_syst.
    ENDIF.

    lv_alignment_ind = cs_hlpseg-calc_seq_ordn
                     + cs_hlpseg-calc_seq_spec
                     + cs_hlpseg-calc_seq_intr.

    IF lv_alignment_ind > 80.
      cs_hlpseg-use_alignment = abap_true.
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD get_expired_life_for_interval.
* PRECONDITION

* DEFINITION
    DATA lv_var_dep_portion TYPE ty_s_hlpseg-amount_factor.

* BODY
    cs_hlpseg-exp_life_seg = 0.

    CHECK cs_hlpseg-phase > 0.

* calculate expireing useful life w/O regarding usage
    cs_hlpseg-exp_life_seg   = cs_hlpseg-period_to
                             - cs_hlpseg-period_from + 1.

* recognize variable portion of depreciation on ordinary depreciation
    CHECK cs_hlpseg-amount_type                            =  gc_amount_type-ordn.
    CHECK cs_hlpseg-key_phase_ref->ms_settings-percent_key <> gc_percent-key_n.
    CHECK cs_hlpseg-grp_asset_assgnd                       =  abap_false.

    CHECK cs_hlpseg-key_phase_ref->ms_settings-regard_shutdown  IS NOT INITIAL
       OR cs_hlpseg-key_phase_ref->ms_settings-shiftfactor_rule <> '2'.
    CHECK cs_hlpseg-var_dep_portion                      IS NOT INITIAL
       OR cs_hlpseg-is_shutdown                          IS NOT INITIAL.

* Begin_of_note_2641375
* shut down indicator is set => no calc. of exp. life & depreciation
    IF cs_hlpseg-is_shutdown IS NOT INITIAL AND
       cs_hlpseg-key_phase_ref->ms_settings-regard_shutdown = faadc_character-x.
      cs_hlpseg-usage_impact_ind   = 1.
    ELSE.
*   if shut down indicator isn't set => multi shift factor to be regarded
      CASE cs_hlpseg-key_phase_ref->ms_settings-shiftfactor_rule.

*   adjust depereciation & expired useful life
        WHEN ' '.
          cs_hlpseg-usage_impact_ind = 3.

*   adjust depereciation only
        WHEN '1'.
          cs_hlpseg-usage_impact_ind = 7.
      ENDCASE.
    ENDIF.
* End_of_note_2641375

    CASE cs_hlpseg-usage_impact_ind.

* usage not to be regarded at all, if any
      WHEN 0.

* there is no expired life to be calc. on shut down periods
      WHEN  1.
        cs_hlpseg-exp_life_seg = 0.

* adjust expired life variable portion of depreciation
* is already recognized in CS_HLPSEG-AMOUNT_FACTOR
      WHEN  3.
        lv_var_dep_portion      = cs_hlpseg-var_dep_portion / 100.
        cs_hlpseg-amount_factor =  1
                                - lv_var_dep_portion
                                + lv_var_dep_portion
                                * cs_hlpseg-shift_fact.

        cs_hlpseg-exp_life_seg = cs_hlpseg-exp_life_seg
                               * cs_hlpseg-amount_factor.

* prepare adjustment of deprecation
      WHEN  7.
        lv_var_dep_portion      = cs_hlpseg-var_dep_portion / 100.
        cs_hlpseg-amount_factor =  1
                                - lv_var_dep_portion
                                + lv_var_dep_portion
                                * cs_hlpseg-shift_fact.
    ENDCASE.

* POSTCONDITION

  ENDMETHOD.


  METHOD get_netbook_value.
*=======================================================================
* calculate netbook value
*=======================================================================
* PRECONDITION

* DEFINITION

* BODY
  rv_netbook_value  = rv_netbook_value
                      + is_sumseg-cur-apc
                      + is_sumseg-cur-downp
                      + is_sumseg-cur-invs
                      + is_sumseg-cur-revl
                      + is_sumseg-cur-revl_d
                      + is_sumseg-cur-depr_o
                      + is_sumseg-cur-depr_s
                      + is_sumseg-cur-depr_u
                      + is_sumseg-cur-resv

                      + is_sumseg-prev_cur-apc
                      + is_sumseg-prev_cur-downp
                      + is_sumseg-prev_cur-invs
                      + is_sumseg-prev_cur-revl
                      + is_sumseg-prev_cur-revl_d
                      + is_sumseg-prev_cur-depr_o
                      + is_sumseg-prev_cur-depr_s
                      + is_sumseg-prev_cur-depr_u
                      + is_sumseg-prev_cur-resv

                      + is_sumseg-prev_prev-apc
                      + is_sumseg-prev_prev-downp
                      + is_sumseg-prev_prev-invs
                      + is_sumseg-prev_prev-revl
                      + is_sumseg-prev_prev-revl_d
                      + is_sumseg-prev_prev-depr_o
                      + is_sumseg-prev_prev-depr_s
                      + is_sumseg-prev_prev-depr_u
                      + is_sumseg-prev_prev-resv

                      + is_yearseg-cum-apc
                      + is_yearseg-cum-downp
                      + is_yearseg-cum-invs
                      + is_yearseg-cum-revl
                      + is_yearseg-cum-revl_d
                      + is_yearseg-cum-depr_o
                      + is_yearseg-cum-depr_s
                      + is_yearseg-cum-depr_u
                      + is_yearseg-cum-resv

                      + is_calcamount-total-revl
                      + is_calcamount-total-revl_d
                      + is_calcamount-total-depr_o
                      + is_calcamount-total-depr_s.

* POSTCONDITION

  ENDMETHOD.


  METHOD get_phase_and_deprkey_config.
*-----------------------------------------------------------
* Reworked with 19/11
*-----------------------------------------------------------
* Comparing results will be handled in _HLPSEG_GET_CO_YR_AND_PRD
*-----------------------------------------------------------

* PRECONDITION

* DEFINITION
    DATA ls_deprkey_key TYPE ty_s_deprkey-key.

* BODY
    DATA(lt_phase) = cl_faa_cfg_factory_static=>get_instance_depr_key(
                       EXPORTING
                         iv_comp_code = cs_hlpseg-arearef->ms_leadobj_key-comp_code
                         iv_depr_area = CONV #( cs_hlpseg-area )
                         iv_depr_key  = cs_hlpseg-depr_key           )->get_phases( ).

    DELETE lt_phase WHERE amount_type <> cs_hlpseg-amount_type.

    ls_deprkey_key-depr_key    = cs_hlpseg-depr_key.
    ls_deprkey_key-amount_type = cs_hlpseg-amount_type.

* determine phase
    CASE lines( lt_phase ).
      WHEN 1. " phase 1
        ls_deprkey_key-phase = 1.

      WHEN 2. " phase 1 / phase 2
        IF cs_hlpseg-is_behind_ul EQ abap_true  AND  lt_phase[ phase = 1 ]-changeover_meth CA gc_changeover_meth_at_end.
          ls_deprkey_key-phase = 2.

        ELSEIF cs_hlpseg-changeover_yr IS NOT INITIAL
           AND ( ( cs_hlpseg-fyear > cs_hlpseg-changeover_yr ) OR
                 ( cs_hlpseg-fyear = cs_hlpseg-changeover_yr  AND  cs_hlpseg-period_from >= cs_hlpseg-changeover_prd ) )
           AND lt_phase[ phase = 1 ]-changeover_meth NA gc_changeover_meth_at_end.

          ls_deprkey_key-phase = 2.
        ELSE.

          ls_deprkey_key-phase = 1.
        ENDIF.

      WHEN 3. " phase 1 / phase 2 / phase 3
        IF cs_hlpseg-is_behind_ul EQ abap_true.
          IF lt_phase[ phase = 2 ]-changeover_meth CA gc_changeover_meth_at_end.
            ls_deprkey_key-phase = 3.
          ELSE.
            ASSERT 1 = 0. "this is not allowed
          ENDIF.
        ELSEIF cs_hlpseg-changeover_yr IS NOT INITIAL
           AND ( ( cs_hlpseg-fyear > cs_hlpseg-changeover_yr ) OR
                 ( cs_hlpseg-fyear = cs_hlpseg-changeover_yr  AND  cs_hlpseg-period_from >= cs_hlpseg-changeover_prd ) )
           AND lt_phase[ phase = 1 ]-changeover_meth NA gc_changeover_meth_at_end.
          ls_deprkey_key-phase = 2.
        ELSE.
          ls_deprkey_key-phase = 1.
        ENDIF.

      WHEN OTHERS.
        ASSERT 1 = 0.

    ENDCASE.

* instance still the right one
    IF cs_hlpseg-key_phase_ref IS BOUND AND cs_hlpseg-key_phase_ref->ms_settings-phase EQ ls_deprkey_key-phase.
      RETURN.
    ENDIF.

    cs_hlpseg-key_phase_ref = cl_faa_cfg_factory_static=>get_instance_depr_key_phase(
                                iv_comp_code   = cs_hlpseg-arearef->ms_leadobj_key-comp_code
                                iv_depr_area   = CONV #( cs_hlpseg-area )
                                iv_depr_key    = ls_deprkey_key-depr_key
                                iv_amount_type = ls_deprkey_key-amount_type
                                iv_phase       = ls_deprkey_key-phase ).

    cs_hlpseg-phase = ls_deprkey_key-phase.

* set flag if expired life is to be calculated from change over year
    IF cs_hlpseg-key_phase_ref->ms_settings-percent_key = gc_percent-key_c OR
       cs_hlpseg-key_phase_ref->ms_settings-percent_key = gc_percent-key_k OR
       cs_hlpseg-key_phase_ref->ms_settings-percent_key = gc_percent-key_u.

      cs_hlpseg-use_exp_life_new = abap_true.
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


METHOD get_prcntg_on_units_of_prod .
*&---------------------------------------------------------------------*
*& Method revised with note 2989652
*&---------------------------------------------------------------------*
* PRECONDITION
  CLEAR ed_percentage.

* DEFINITION
  "none

* BODY

  IF is_parameter-baseval_key EQ gc_basevalue-key_20 OR
     is_parameter-baseval_key EQ gc_basevalue-key_21 OR
     is_parameter-baseval_key EQ gc_basevalue-key_22 OR
     is_parameter-baseval_key EQ gc_basevalue-key_23 OR
     is_parameter-baseval_key EQ gc_basevalue-key_24 OR
     is_parameter-baseval_key EQ gc_basevalue-key_25 OR
     is_parameter-baseval_key EQ gc_basevalue-key_27.

    DATA(lb_nbv_depr) = abap_true.
  ENDIF.

  IF is_hlpseg-usage_object IS INITIAL.
    ed_percentage = _get_units_from_depr_key(
                      is_hlpseg      = is_hlpseg
                      ib_nbv_depr    = lb_nbv_depr ).
  ELSE.
    ed_percentage = _get_units_from_usage_object(
                      is_hlpseg      = is_hlpseg
                      ib_nbv_depr    = lb_nbv_depr ).
  ENDIF.

* POSTCONDITION
  "none

ENDMETHOD.


  METHOD get_repl_param.
* PRECONDITION

* DEFINITION
  DATA lo_instance          TYPE REF TO object.
    DATA lo_indexhandle       TYPE ty_o_indexseries_handle.

    DATA ls_key               TYPE ty_s_indexseries-key.
    DATA ls_percentage        TYPE ty_s_indexseries-percentage.

    DATA lv_index_year        TYPE numc4.
    DATA lv_base_percentage   TYPE ty_s_indexseries-percentage-index_percentage.
    DATA lv_index_percentage  TYPE ty_s_indexseries-percentage-index_percentage.
    DATA lb_simulation_mode   TYPE boolean.
    DATA ld_start_year        TYPE faa_dc_s_hlpseg-fyear.         "< 2897005
    DATA ld_start_per         TYPE faa_dc_s_hlpseg-start_prd.     "< 2897005

* BODY
  CASE cs_hlpseg-amount_type.
      WHEN gc_amount_type-rage.
        ls_key-calc_index = cs_hlpseg-age_index.
      WHEN gc_amount_type-repl.
        ls_key-calc_index = cs_hlpseg-rplcmntval_index.
    ENDCASE.

    lo_instance ?= cl_faa_cfg_factory_static=>get_instance_indexseries(
                       is_indexseries_key = ls_key
                       iv_comp_code       = cs_hlpseg-arearef->ms_leadobj_key-comp_code
                       iv_acc_principle   = cs_hlpseg-arearef->ms_leadobj_key-acc_principle
                       iv_index_type      = cs_hlpseg-amount_type ).

    lo_indexhandle ?= lo_instance.

* initialize help fields
    lv_base_percentage  = 100.
    lv_index_percentage = 0.
    lb_simulation_mode  = space.

* <<< begin of insertion - note 2897005 >>>
    IF ( cl_faa_fin_flags=>has_value( iv_name = cl_faa_fin_flags=>con_flags-index_cap_date_consider iv_value = '1' ) EQ abap_true ) OR
       ( cl_faa_fin_flags=>has_value( iv_name = cl_faa_fin_flags=>con_flags-index_cap_date_consider iv_value = '2' ) EQ abap_true ).
*       Calculate year of capitalization date
        CALL METHOD cs_hlpseg-arearef->get_period_and_year
          EXPORTING
            iv_date      = cs_hlpseg-cap_date
          IMPORTING
            ev_period    = ld_start_per
            ev_fisc_year = ld_start_year.
    ENDIF.
* <<< end of insertion - note 2897005 >>>

    CASE cs_hlpseg-amount_type.

* get base percentage on WBIND, determine year for access
      WHEN gc_amount_type-repl.
        lv_index_year = cs_hlpseg-fyear - 1.

        IF NOT lo_indexhandle->ms_setup-calc_historic IS INITIAL.
* <<<     begin of insertion - note 2897005 >>>
"         1 or 2
          IF ( cl_faa_fin_flags=>has_value( iv_name = 'FIAA_INDEX_CAP_DATE' iv_value = '1' ) EQ abap_true ) OR
             ( cl_faa_fin_flags=>has_value( iv_name = 'FIAA_INDEX_CAP_DATE' iv_value = '2' ) EQ abap_true ).
            lv_index_year = ld_start_year.
*         standard without settings in FIN_FLAGS
          ELSE.
            lv_index_year = cs_hlpseg-initial_acq_yr.
          ENDIF.
* <<<<   end of insertion - note 2897005 >>>
        ENDIF.

        READ TABLE lo_indexhandle->mt_percentage INTO ls_percentage
              WITH KEY index_year = lv_index_year.

        IF sy-subrc = 0.
          IF NOT ls_percentage IS INITIAL.
            lv_base_percentage = ls_percentage-index_percentage.
          ENDIF.
        ENDIF.

        lv_index_year = cs_hlpseg-fyear.

* determine year for access on ALIND
      WHEN gc_amount_type-rage.
*<<< begin of insertion - note 2897005 >>>
        IF ( cl_faa_fin_flags=>has_value( iv_name = 'FIAA_INDEX_CAP_DATE' iv_value = '2' ) EQ abap_true ).
          lv_index_year = cs_hlpseg-fyear - ld_start_year.
        ELSE.
          lv_index_year = cs_hlpseg-fyear - cs_hlpseg-initial_acq_yr.
        ENDIF.
*<<< end of insertion - note 2897005 >>>
    ENDCASE.

* get actual percentage
    READ TABLE lo_indexhandle->mt_percentage INTO ls_percentage
          WITH KEY index_year = lv_index_year.

* percentage found => take it over
    IF sy-subrc = 0 AND ls_percentage-index_percentage <> 0.
      lv_index_percentage = ls_percentage-index_percentage.

* no percentage found => get percentage for simulation if any
    ELSE.
      lb_simulation_mode = abap_true.

      IF lo_indexhandle->ms_setup-simulation_index IS INITIAL.

        CLEAR lv_index_year.

        READ TABLE lo_indexhandle->mt_percentage INTO ls_percentage
              WITH KEY index_year = lv_index_year.

        IF sy-subrc = 0.
          lv_index_percentage = ls_percentage-index_percentage.
        ENDIF.

* get simulation percentage
      ELSE.
        lv_index_percentage = lo_indexhandle->ms_setup-simulation_index.
        lv_base_percentage  = 100.
      ENDIF.
    ENDIF.

* calculate percentage for replacment value calculation
    cs_hlpseg-percent_stated = lv_index_percentage / lv_base_percentage.

* set baseval and percentage indicator
    IF lo_indexhandle->ms_setup-calc_historic IS INITIAL.
*    cs_hlpseg-baseval_key  = GC_basevalue-key_03.
      cs_hlpseg-baseval_key  = gc_basevalue-key_06.      "note_1786621
      cs_hlpseg-percent_key  = gc_percent-key_r1.
    ELSE.
*    cs_hlpseg-baseval_key  = GC_basevalue-key_01.
      cs_hlpseg-baseval_key  = gc_basevalue-key_14.      "note_1786621

      IF NOT lb_simulation_mode IS INITIAL.                 "<964625
        cs_hlpseg-percent_key = gc_percent-key_r1.
      ELSE.
        cs_hlpseg-percent_key = gc_percent-key_r2.
      ENDIF.
    ENDIF.

* POSTCONDITION

ENDMETHOD.


  METHOD get_shifted_period_from_and_to.
* PRECONDITION

* DEFINITION
  DATA lv_periods     TYPE int4.
    DATA lv_period_from TYPE numc3.
    DATA lv_fyear_from  TYPE numc4.
    DATA lv_period_to   TYPE numc3.
    DATA lv_fyear_to    TYPE numc4.
    DATA lv_date        TYPE dats.

* BODY
  CASE id_determination_rule.

* calendar year related determination
      WHEN 1
        OR 2.

* determine from which fiscal year and period entry is valid
        lv_periods   = id_base_date+0(4) * 12 + id_base_date+4(2) + cd_period_from - 1.

        lv_date      = id_base_date.

        lv_date+0(4) = ( lv_periods DIV 12 ).
        lv_date+4(2) = ( lv_periods MOD 12 ).

*     check on leap day 29.02.
        IF lv_date+4(4) = gc_date-feb_29+4(4).
          lv_date+4(4)  = gc_date-march_01+4(4).
          SUBTRACT 1 FROM lv_date.
        ENDIF.

        IF lv_date+4(2) = 0.
          lv_date+4(2) = 12.
          lv_date+0(4) = lv_date+0(4) - 1.
        ENDIF.

* entry is valid from the beginning of the fiscal year
        IF lv_date = is_hlpseg-first_day_in_yr.             "< 2449030
          cd_period_from = 000.
        ELSE.

* entry is not valid at all
          IF lv_date > is_hlpseg-last_day_in_yr.            "< 2449030
            cd_period_from = 999.
            EXIT.
          ENDIF.
        ENDIF.

* validity of entry starts within the fiscal year => get start period
        IF lv_date >= is_hlpseg-first_day_in_yr AND         "< 2449030
           lv_date <= is_hlpseg-last_day_in_yr.             "< 2449030

          IF id_determination_rule = 1.

* without daily depreciation
            CALL METHOD is_hlpseg-arearef->get_period_and_year
              EXPORTING
                iv_date      = lv_date
              IMPORTING
                ev_period    = lv_period_from
                ev_fisc_year = lv_fyear_from.

            cd_period_from = lv_period_from.

          ELSE.

* with daily depreciation
            cd_period_from = lv_date - is_hlpseg-first_day_in_yr + 1.

          ENDIF. "id_determination_rule = 1

        ENDIF.

* determine up to which fiscal year and period entry is valid
        lv_periods   = id_base_date+0(4) * 12 + id_base_date+4(2) + cd_period_to.

        lv_date      = id_base_date.

        lv_date+0(4) = ( lv_periods DIV 12 ).
        lv_date+4(2) = ( lv_periods MOD 12 ).

*     check on leap day 29.02.
        IF lv_date+4(4) = gc_date-feb_29+4(4).
          lv_date+4(4)  = gc_date-march_01+4(4).
          SUBTRACT 1 FROM lv_date.
        ENDIF.

        IF lv_date+4(2) = 0.
          lv_date+4(2)  = 12.
          lv_date+0(4)  = lv_date+0(4) - 1.
        ENDIF.

        lv_date         =   lv_date - 1.

* entry is not valid at all
        IF lv_date < is_hlpseg-first_day_in_yr.             "< 2449030
          cd_period_to = 000.

* entry is valid until the end of the fiscal year
        ELSE.
          IF lv_date > is_hlpseg-last_day_in_yr.            "< 2449030
            cd_period_to = 999.
          ENDIF.
        ENDIF.

* validity of entry ends within the fiscal year => get end period
        IF lv_date >= is_hlpseg-first_day_in_yr AND         "< 2449030
           lv_date <= is_hlpseg-last_day_in_yr.             "< 2449030

          IF id_determination_rule = 1.

* without daily depreciation
            CALL METHOD is_hlpseg-arearef->get_period_and_year
              EXPORTING
                iv_date      = lv_date
              IMPORTING
                ev_period    = lv_period_to
                ev_fisc_year = lv_fyear_to.

            cd_period_to = lv_period_to.

          ELSE.

* with daily depreciation
            cd_period_to = lv_date - is_hlpseg-first_day_in_yr + 1.

          ENDIF. "id_determination_rule = 1

        ENDIF.

* fiscal year related determination
      WHEN 3.

* determine from which fiscal year and period entry is valid
        lv_periods    =  id_base_prd + cd_period_from - 1.

        lv_fyear_from  = ( lv_periods DIV is_hlpseg-periods ) + id_base_fyr.
        cd_period_from = ( lv_periods MOD is_hlpseg-periods ).

* determine up to which fiscal year and period entry is valid
        lv_periods     = id_base_prd + cd_period_to - 1.

        lv_fyear_to    = ( lv_periods DIV is_hlpseg-periods ) + id_base_fyr.
        cd_period_to   = ( lv_periods MOD is_hlpseg-periods ).

* adjust period from if starting before or ending behind actual fiscal year
        IF lv_fyear_from < is_hlpseg-fyear.
          cd_period_from = 000.
        ENDIF.

        IF lv_fyear_from > is_hlpseg-fyear.
          cd_period_from = 999.
        ENDIF.

* adjust period to if starting before or ending behind actual fiscal year
        IF lv_fyear_to < is_hlpseg-fyear.
          cd_period_to = 000.
        ENDIF.

        IF lv_fyear_to > is_hlpseg-fyear.
          cd_period_to = 999.
        ENDIF.
    ENDCASE.

* POSTCONDITION

ENDMETHOD.


METHOD if_faa_dc_segments_720~check_badi_is_active.
* PRECONDITION

* DEFINITION

  "Process just once  - mainly because of the SELECT
  STATICS: BEGIN OF ls_s_results,
             is_processed            TYPE boolean,
             customer_badi_is_active TYPE boolean,
             country_badi_is_active  TYPE boolean,
             badi_is_active          TYPE boolean,
           END OF ls_s_results.

* BODY
  CLEAR: ev_customer_badi_is_active,
         ev_country_badi_is_active,
         rv_badi_is_active.

  IF ls_s_results-is_processed = abap_true.
    ev_customer_badi_is_active = ls_s_results-customer_badi_is_active.
    ev_country_badi_is_active  = ls_s_results-country_badi_is_active.
    rv_badi_is_active          = ls_s_results-badi_is_active.
    RETURN.
  ENDIF.

  IF go_badi_customer IS BOUND.
    "check only for active implem. not delivered by SAP - not API available
    SELECT SINGLE @abap_true INTO @ev_customer_badi_is_active
      FROM v_ext_act
     WHERE exit_name = 'FAA_DC_CUSTOMER'
       AND imp_name NOT LIKE 'FAA_DC_CUSTOMER_JP%'.
  ENDIF.

  IF go_badi_country IS BOUND.
    ev_country_badi_is_active = abap_true.
  ENDIF.


  IF go_badi_customer IS BOUND  OR  go_badi_country IS BOUND.
    rv_badi_is_active = abap_true.
  ENDIF.


  "Store results as this will normally not be changed
  ls_s_results-is_processed            = abap_true.
  ls_s_results-customer_badi_is_active = ev_customer_badi_is_active.
  ls_s_results-country_badi_is_active  = ev_country_badi_is_active.
  ls_s_results-badi_is_active          = rv_badi_is_active.

* POSTCONDITION

ENDMETHOD.


  METHOD if_faa_dc_segments_720~perform_calc_with_implicit_cf.
*-----------------------------------------------------------------------
* Reworked/cleaned up with 2002
*-----------------------------------------------------------------------
* PRECONDITION

* DEFINITION
    DATA lo_dc_calc_handle   TYPE ty_o_dc_calc_handle.
    DATA lo_dc_calc_previous TYPE ty_o_dc_calc_handle.

    DATA ls_proc_data        TYPE ty_s_proc_data.

* BODY
    ls_proc_data-process           = is_processing_info-process.
    ls_proc_data-step              = is_processing_info-step.
    ls_proc_data-fyear             = is_processing_info-fyear.
    ls_proc_data-period_offset     = is_processing_info-period_offset.

    ls_proc_data-leadobj_ref ?= is_processing_info-leadobj_ref.
    ls_proc_data-comp_code         = ls_proc_data-leadobj_ref->get_leadobj_key( )-comp_code.
    ls_proc_data-ledger_group      = ls_proc_data-leadobj_ref->get_leadobj_key( )-ledger_group.
    ls_proc_data-country           = ls_proc_data-leadobj_ref->get_setup( )-country.

    ls_proc_data-last_open_fyear   = ls_proc_data-leadobj_ref->get_max_open_fy( ).

* avoid endless loop
    ASSERT is_processing_info-fyear <= is_processing_info-fyear_to.

    DO.
      CREATE OBJECT lo_dc_calc_handle.

      IF lo_dc_calc_previous IS INITIAL.
        CALL METHOD lo_dc_calc_handle->set_asset_data
          EXPORTING
            is_asset_data = is_asset_data.

        IF io_dc_segments_previous IS NOT INITIAL.
          lo_dc_calc_previous ?= io_dc_segments_previous.
        ENDIF.
      ENDIF.

      ls_proc_data-first_day_in_fyr  = ls_proc_data-leadobj_ref->get_first_day_in_year( iv_fisc_year = ls_proc_data-fyear ).
      ls_proc_data-last_day_in_fyr   = ls_proc_data-leadobj_ref->get_last_day_in_year( iv_fisc_year = ls_proc_data-fyear ).

      " Adjust PERIOD_OFFSET for last year to be calculated on reporting request
      IF ls_proc_data-fyear = is_processing_info-fyear_to AND is_processing_info-period_offset_last_yr IS NOT INITIAL.
        ls_proc_data-period_offset = is_processing_info-period_offset_last_yr.
      ENDIF.

      lo_dc_calc_handle->set_process_control_data(
                          is_process_control_data = ls_proc_data
                          its_area                = is_processing_info-t_area
                          io_previous             = lo_dc_calc_previous ).

      IF ls_proc_data-step = gc_step-dc_int_perform_carry_forward.
        CALL METHOD lo_dc_calc_handle->_yearseg_create.
        CALL METHOD lo_dc_calc_handle->_transaction_create_from_db.
        CALL METHOD lo_dc_calc_handle->_hlpseg_create.
        CALL METHOD lo_dc_calc_handle->_hlpseg_get_exp_life_seg.
        CALL METHOD lo_dc_calc_handle->_sumseg_create.
        CALL METHOD lo_dc_calc_handle->_calcamount_create.
      ELSE.
        CALL METHOD perform_step_processing
          EXPORTING
            id_process = ls_proc_data-process
            id_step    = ls_proc_data-step
            io_handle  = lo_dc_calc_handle.
      ENDIF.

      IF ls_proc_data-step = gc_step-dc_720_ldt_check_request.
        EXIT.
      ENDIF.

      IF ls_proc_data-fyear = is_processing_info-fyear_to.
        EXIT.
      ENDIF.

      "This part is added just for calculating correctly,
      "but should not be in the hierarchy of object references
      IF  io_dc_segments_previous IS NOT INITIAL
      AND lo_dc_calc_handle->mo_previous = io_dc_segments_previous.
        CLEAR lo_dc_calc_handle->mo_previous.
      ENDIF.

      lo_dc_calc_previous = lo_dc_calc_handle.
      ls_proc_data-fyear  = ls_proc_data-fyear + 1.

      IF  ls_proc_data-step                      EQ gc_step-dc_int_perform_carry_forward "2871398
      AND is_processing_info-calc_only_exp_ulife EQ abap_false."                          2871398
        ls_proc_data-step = gc_step-dc_720_recalculation.
      ENDIF.
    ENDDO.

    ro_dc_calc_handle = lo_dc_calc_handle.

* POSTCONDITION

ENDMETHOD.


  METHOD if_faa_dc_segments_720~perform_step_processing.
* PRECONDITION

* DEFINITION
  DATA lo_process_handle           TYPE REF TO cl_faa_process_mngr.

  FIELD-SYMBOLS <ls_tfaa_pc_ps>    TYPE tfaa_pc_ps.
  FIELD-SYMBOLS <ls_tfaa_pc_sm>    TYPE tfaa_pc_sm.

* BODY
    lo_process_handle ?= cl_faa_da_api_factory=>get_process_mngr( )->find(
        id_comp     = id_comp
        id_process  = id_process
        id_step     = id_step
        id_procmode = id_procmode ).

    LOOP AT lo_process_handle->mt_subprocess ASSIGNING <ls_tfaa_pc_ps>.
      LOOP AT lo_process_handle->mt_method ASSIGNING <ls_tfaa_pc_sm>
        WHERE subprocess = <ls_tfaa_pc_ps>-subprocess.

        CALL METHOD io_handle->(<ls_tfaa_pc_sm>-method).
      ENDLOOP.
    ENDLOOP.

* POSTCONDITION

ENDMETHOD.


  METHOD prepare_badi_call.
*---------------------------------------------------------------------
* Cleaned up with 19/11
*---------------------------------------------------------------------
* PRECONDITION

* DEFINITION

* BODY
* get segment handle that is used as importing parameter for BaDI calls
    IF co_dc_segment_handle IS NOT BOUND.
      CREATE OBJECT co_dc_segment_handle.
    ENDIF.

    co_dc_segment_handle->mo_assetdata       ?= mo_start->ms_asset_data-object_instance.
    co_dc_segment_handle->mt_transaction      = mt_transaction.
    co_dc_segment_handle->mt_transaction_post = mt_transaction_post.
    co_dc_segment_handle->mt_virtarea         = mt_virtarea.

    co_dc_segment_handle->ms_asset_data       = mo_start->ms_asset_data.
    co_dc_segment_handle->mt_virtarea_s4      = mt_virtarea_s4.

    co_dc_segment_handle->mts_hlpseg          = mts_hlpseg.
    co_dc_segment_handle->mt_timeseg          = mt_timeseg.
    co_dc_segment_handle->mt_yearseg          = mt_yearseg.
    co_dc_segment_handle->mt_sumseg           = mt_sumseg.
    co_dc_segment_handle->mt_parameter        = mt_parameter.
    co_dc_segment_handle->mt_period           = mt_period.
    co_dc_segment_handle->mt_rounding         = mt_rounding.
    co_dc_segment_handle->mt_areasign         = mt_areasign.

    co_dc_segment_handle->mo_leadobj          = ms_proc_data-leadobj_ref.

    co_dc_segment_handle->md_process          = ms_proc_data-process.
    co_dc_segment_handle->md_step             = ms_proc_data-step.
    co_dc_segment_handle->md_fyear            = ms_proc_data-fyear.

* provide transactions of all calculated years to BAdI
    DATA lo_previous TYPE ty_o_dc_calc_handle.

    CHECK ms_proc_data-step = gc_step-dc_720_transaction_reversal
       OR ms_proc_data-step = gc_step-dc_720_transaction_posting
       OR ms_proc_data-step = gc_step-dc_720_recalculation.

    lo_previous = mo_previous.
    WHILE lo_previous IS BOUND.
      APPEND LINES OF mo_previous->mt_transaction_post TO co_dc_segment_handle->mt_transaction_post.
      APPEND LINES OF mo_previous->mt_transaction      TO co_dc_segment_handle->mt_transaction.
      lo_previous = lo_previous->mo_previous.
    ENDWHILE.

* POSTCONDITION

  ENDMETHOD.


  METHOD set_asset_data.
* PRECONDITION

* DEFINITION

* BODY
  ms_asset_data        = is_asset_data.
  ms_transaction_cntrl = is_asset_data-s_transaction_cntrl.
  mt_transaction_post  = is_asset_data-t_transaction_post.

* POSTCONDITION

  ENDMETHOD.


  METHOD set_process_control_data.
* PRECONDITION

* DEFINITION

* BODY
  ms_proc_data        = is_process_control_data.
    mts_area            = its_area.
    mo_previous        ?= io_previous.

* ensure that year independant data and asset data are just kept
* on first instance created to save memory
    IF mo_previous IS BOUND.
      mo_start = mo_previous->mo_start.
    ELSE.
      mo_start = me.
    ENDIF.

* POSTCONDITION

ENDMETHOD.


  METHOD _areasign_create.
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_virtarea_s4> TYPE if_faa_dc_segments_720=>ty_s_virtarea_s4.
    FIELD-SYMBOLS <ls_areasign>    TYPE ty_s_areasign.
    FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.
    FIELD-SYMBOLS <ls_area>        TYPE if_faa_depr_calc_types=>ty_s_area.

    DATA ls_areasign               TYPE ty_s_areasign.

* BODY
* get definitions for companycode and depr. areas
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      AT NEW area.
        CALL METHOD get_area_signs
          EXPORTING
            io_arearef    = <ls_hlpseg>-arearef
            id_neg_values = <ls_hlpseg>-neg_values
          IMPORTING
            es_areasign   = ls_areasign.
        APPEND ls_areasign TO mt_areasign.
      ENDAT.
    ENDLOOP.

* get settings for derived areas
    READ TABLE mts_area ASSIGNING <ls_area> INDEX 1.

    LOOP AT mt_virtarea_s4 ASSIGNING <ls_virtarea_s4>.
      AT NEW virt_depr_area.
        CLEAR ls_areasign.
        READ TABLE <ls_area>-arearef->mo_leadobj->get_list_depr_area( ) INTO DATA(ls_arearef)
          WITH KEY key_depr_area COMPONENTS depr_area = <ls_virtarea_s4>-virt_depr_area.

        CALL METHOD get_area_signs
          EXPORTING
            io_arearef    = ls_arearef-depr_area_ref
            id_neg_values = gc_area_value_sign-positive
          IMPORTING
            es_areasign   = ls_areasign.
      ENDAT.

      READ TABLE mt_areasign ASSIGNING <ls_areasign>
        WITH KEY area  = <ls_virtarea_s4>-real_depr_area.

      IF <ls_areasign>-sign <> gc_area_value_sign-positive.
        ls_areasign-sign = <ls_areasign>-sign.
      ENDIF.

      AT END OF virt_depr_area.
        APPEND ls_areasign TO mt_areasign.
      ENDAT.
    ENDLOOP.

* POSTCONDITION

  ENDMETHOD.


  METHOD _calcamount_create.
* PRECONDITION

* DEFINITION
  DATA ls_calcamount LIKE LINE OF mts_calcamount.

* BODY
    LOOP AT ms_asset_data-t_calc_values ASSIGNING FIELD-SYMBOL(<ls_calc_values>)
      WHERE fyear = ms_proc_data-fyear.
      ls_calcamount-fyear     = <ls_calc_values>-fyear.
      ls_calcamount-area      = <ls_calc_values>-area.
      ls_calcamount-curr_type = <ls_calc_values>-curr_type.
      ls_calcamount-total     = <ls_calc_values>-cum.
      INSERT ls_calcamount INTO TABLE mts_calcamount.       "2347861
    ENDLOOP.

* POSTCONDITION

ENDMETHOD.


  METHOD _calcorder_call_badi.
* PRECONDITION

* DEFINITION

* BODY

* POSTCONDITION

ENDMETHOD.


  METHOD _calcorder_create.
*******************************************************************
* Reworked/Cleaned up with 1908
*******************************************************************
* PRECONDITION
* check if processing required at all
    CHECK NOT mt_parameter[] IS INITIAL.

* DEFINITION
    FIELD-SYMBOLS <ls_virtarea_s4>   TYPE ty_s_virtarea_s4.
    FIELD-SYMBOLS <ls_area>       TYPE if_faa_depr_calc_types=>ty_s_area.
    FIELD-SYMBOLS <ls_hlpseg>     TYPE ty_s_hlpseg.

    DATA lt_calcorder             TYPE STANDARD TABLE OF ty_s_calcorder.

    DATA ls_calcorder             TYPE ty_s_calcorder.
    DATA ls_virtarea_s4           TYPE ty_s_virtarea_s4.
    DATA ls_seqno                 TYPE ty_s_calcorder-seqno.
    DATA lv_depr_area TYPE ty_s_hlpseg-area.

    DATA lv_entry_4_virt_area     TYPE boolean.

* BODY
    READ TABLE mts_area ASSIGNING <ls_area> INDEX 1.
* <<<<  create CALCORDER for all real areas following the rules: >>>>*
* 1. first calculate all real areas without virtual area assignment
*
* 2. second for real areas with virtual area assignment
*    the sequence is given by the first assigned virtual area
* 3. after all assigned real areas calculate virtual area
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
* determine wether area is assigned to virtual area
      AT NEW curr_type.
        READ TABLE mt_virtarea_s4 INTO ls_virtarea_s4
          WITH KEY real_depr_area = <ls_hlpseg>-area
                   real_curr_type = <ls_hlpseg>-curr_type.

        IF sy-subrc <> 0.
          lv_entry_4_virt_area = abap_false.

          CLEAR ls_virtarea_s4.

        ELSE.
          lv_entry_4_virt_area = abap_true.
        ENDIF.
      ENDAT.

      DO 1 TIMES.
* avoid call of calculation engine on retirement request dated to the beginning of the fiscal year
* and for areas which area assigned to group assets
        CHECK <ls_hlpseg>-grp_asset_assgnd IS INITIAL.
        CHECK <ls_hlpseg>-period_to        >  000.

* determine sequence number of CALCORDER entry to be created
        CLEAR ls_seqno.

        ls_seqno-virt_area       =  ls_virtarea_s4-virt_depr_area.
        ls_seqno-base_area       = <ls_hlpseg>-area.
        ls_seqno-period_from     = <ls_hlpseg>-period_from.
        ls_seqno-sort_ind        = <ls_hlpseg>-sort_indicator.

* create CALCORDER entry
        CLEAR ls_calcorder.

        ls_calcorder-seqno       = ls_seqno.
        ls_calcorder-fyear       = <ls_hlpseg>-fyear.
        ls_calcorder-area        = <ls_hlpseg>-area.
        ls_calcorder-amount_type = <ls_hlpseg>-amount_type.
        ls_calcorder-period_to   = <ls_hlpseg>-period_to.

        IF ls_virtarea_s4 IS NOT INITIAL.
          ls_calcorder-is_dependant = abap_true.
        ENDIF.

        "As there are several entries in HLPSEG for the same key we have to check
        READ TABLE lt_calcorder TRANSPORTING NO FIELDS
          WITH KEY fyear = ls_calcorder-fyear
                   seqno = ls_calcorder-seqno.

        CHECK sy-subrc <> 0.                              "^ ^ ^ ^ ^ ^


        APPEND ls_calcorder TO lt_calcorder.

* create entries for all virtual areas but for amount_types
* N,S,Z and I only and just for one of them
        CHECK lv_entry_4_virt_area    = abap_true.

        CHECK <ls_hlpseg>-amount_type = gc_amount_type-ordn
           OR <ls_hlpseg>-amount_type = gc_amount_type-spec
           OR <ls_hlpseg>-amount_type = gc_amount_type-intr
           OR <ls_hlpseg>-amount_type = gc_amount_type-infl.

        LOOP AT mt_virtarea_s4 ASSIGNING <ls_virtarea_s4>
          WHERE real_depr_area = <ls_hlpseg>-area
            AND real_curr_type = <ls_hlpseg>-curr_type.

          READ TABLE <ls_area>-arearef->mo_leadobj->get_list_depr_area( ) INTO DATA(ls_arearef)
            WITH KEY key_depr_area COMPONENTS depr_area = <ls_virtarea_s4>-virt_depr_area.

* check if there is already an appropriate entry for the virtual area
          IF ls_arearef-depr_area_ref->ms_setup-area_usage_ind = '2'.
            READ TABLE lt_calcorder TRANSPORTING NO FIELDS
                  WITH KEY area      = <ls_virtarea_s4>-virt_depr_area
                           period_to = 366.
          ELSE.
            READ TABLE lt_calcorder TRANSPORTING NO FIELDS
                  WITH KEY area      = <ls_virtarea_s4>-virt_depr_area
                           period_to = <ls_hlpseg>-period_to.
          ENDIF.                                                              "

          CHECK sy-subrc <> 0.

* determine sequence number of CALCORDER entry to be created
          ls_seqno-virt_area           = <ls_virtarea_s4>-virt_depr_area.
          ls_seqno-base_area           = <ls_virtarea_s4>-virt_depr_area.
          ls_seqno-period_from         = <ls_hlpseg>-period_from.
          ls_seqno-sort_ind            = 99.

* create CALCORDER entry
          CLEAR ls_calcorder.

          ls_calcorder-seqno           = ls_seqno.
          ls_calcorder-fyear           = <ls_hlpseg>-fyear.
          ls_calcorder-area            = <ls_virtarea_s4>-virt_depr_area.
          ls_calcorder-period_to       = <ls_hlpseg>-period_to.
          ls_calcorder-is_dependant    = abap_true.
          ls_calcorder-is_virtual_area = abap_true.

* create CALCORDER entries for each period interval if base areas
* use the same count of calculation periods this is true id area_usage_ind <> '2'.
* on different numbers of periods to be calc. for the base areas we create just
* one single entry for our vitual area to force value adjustment by the end of year
          IF ls_arearef-depr_area_ref->ms_setup-area_usage_ind = '2'.
            IF <ls_hlpseg>-period_to = <ls_hlpseg>-periods.
              ls_seqno-period_from   = 366.
              ls_calcorder-seqno     = ls_seqno.
              ls_calcorder-period_to = 366.

            ELSE.
              CONTINUE.
            ENDIF.
          ENDIF.

          APPEND ls_calcorder TO lt_calcorder.
        ENDLOOP.

      ENDDO.

* ensure CALCORDER is created just for one amount type of an area if several areas are to be calculated
      AT END OF amount_type.
        lv_entry_4_virt_area = abap_false.
      ENDAT.
    ENDLOOP.


    SORT lt_calcorder BY seqno.

    mts_calcorder[] = lt_calcorder[].

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_create.
*******************************************************************
* - Take over fixed asset master data
* - create intervals from time dependant parameter for each amount type
*   => determine calculation start date if applicable
*   => determine calculation phase and get settings of depr. key for phase
*   => determine expired useful life in periods
*   => perform split on calculation start period if applicable
*      - one entry with PERIOD_TO   = START_PERIOD - 1 and PHASE = 0
*      - one entry with PERIOD_from = START_PERIOD adn original PERIOD_TO
*   => perform split on changeover period if applicable
*
* - calculate expired useful life from changeover year if applicable
*   => create from first entry for area an entry for revaluation calcualtion
*      if we are not in the year of first acquisition per revaluation type
*
* - on implicit carry forward take over data from prior year
*   => depreciation start date, capitalization date
*   => change over year and period
*   => add on prior year calculated expired life for period intervals
*******************************************************************
* Reworked/Cleaned up with 1908
*******************************************************************
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_hlpseg>     TYPE ty_s_hlpseg.
    FIELD-SYMBOLS <ls_area>       TYPE if_faa_depr_calc_types=>ty_s_area.
    FIELD-SYMBOLS <lv_calc_seq>   TYPE ty_s_hlpseg-amount_types-calc_seq_ordn.

    DATA ls_depr_param TYPE if_faa_depr_calc_types=>ty_s_depr_area_amd. "ty_s_deprarea-depr_param.
    DATA ls_hlpseg_split          TYPE ty_s_hlpseg.
    DATA ls_hlpseg_repl           TYPE ty_s_hlpseg.
    DATA ls_hlpseg                TYPE ty_s_hlpseg.

    DATA lv_split_on_co_prd       TYPE abap_bool.

    DATA lt_depr_param            TYPE if_faa_depr_calc_types=>ty_ts_depr_area_amd.

* BODY
    lt_depr_param[] = mo_start->ms_asset_data-ts_depr_param[].
* Adjust depr param interval in cases where no data exists for requested dates
    LOOP AT lt_depr_param[] ASSIGNING FIELD-SYMBOL(<ls_depr_param>).
      CHECK <ls_depr_param>-from_date EQ gc_date-adatu_anlbza.
      IF ms_proc_data-first_day_in_fyr LT <ls_depr_param>-from_date.
        <ls_depr_param>-from_date = ms_proc_data-first_day_in_fyr.
      ENDIF.
    ENDLOOP.

* determine areas and amount types to be calculated
    LOOP AT lt_depr_param[] INTO ls_depr_param
      WHERE to_date   >= ms_proc_data-first_day_in_fyr
        AND from_date <= ms_proc_data-last_day_in_fyr.

* get instance of depreciation area configuration
      READ TABLE mts_area ASSIGNING <ls_area>
        WITH KEY depr_area = ls_depr_param-depr_area.
      CHECK sy-subrc = 0.

      CLEAR ls_hlpseg_split.
      CLEAR ls_hlpseg.

      ls_hlpseg-fyear            = ms_proc_data-fyear.
      ls_hlpseg-first_day_in_yr  = ms_proc_data-first_day_in_fyr.
      ls_hlpseg-last_day_in_yr   = ms_proc_data-last_day_in_fyr.
      ls_hlpseg-arearef          = <ls_area>-arearef.
      ls_hlpseg-area             = <ls_area>-depr_area.
      ls_hlpseg-curr_type        = ls_depr_param-curr_type.

* get count of periods, determine max. "to period" within actual fiscal year
      CALL METHOD ls_hlpseg-arearef->if_faa_cfg_period_determine~get_number_of_periods
        EXPORTING
          iv_fisc_year        = ls_hlpseg-fyear
        IMPORTING
          ev_periods          = ls_hlpseg-periods
          ev_periods_short_fy = ls_hlpseg-periods_short_fy.

* determine if fiscal year is a shortened one
      IF ls_hlpseg-periods_short_fy <> ls_hlpseg-periods.
        ls_hlpseg-is_shortfiscyear = abap_true.
      ENDIF.

* On calculation of sub-sequent fiscal year
* get amount type indepedent data from prior year processing
      IF mo_previous IS BOUND.
        READ TABLE mo_previous->mts_hlpseg ASSIGNING <ls_hlpseg>
                 WITH KEY fyear       = mo_previous->ms_proc_data-fyear
                          area        = ls_hlpseg-area
                          curr_type   = ls_hlpseg-curr_type.
        ASSERT sy-subrc EQ 0.

        ls_hlpseg-ignore_memval   = <ls_hlpseg>-ignore_memval.
        ls_hlpseg-assetclass      = <ls_hlpseg>-assetclass.
        ls_hlpseg-cap_date        = <ls_hlpseg>-cap_date.
        ls_hlpseg-initial_acq     = <ls_hlpseg>-initial_acq.
        ls_hlpseg-initial_acq_yr  = <ls_hlpseg>-initial_acq_yr.
        ls_hlpseg-initial_acq_prd = <ls_hlpseg>-initial_acq_prd.
        ls_hlpseg-last_ret_date   = <ls_hlpseg>-last_ret_date.
        ls_hlpseg-deact_date      = <ls_hlpseg>-deact_date.

* On calculation of first fiscal year take over data from asset master
      ELSE.
        ls_hlpseg-ignore_memval    = mo_start->ms_asset_data-ignore_memval.
        ls_hlpseg-assetclass       = mo_start->ms_asset_data-asset_class.
        ls_hlpseg-cap_date         = mo_start->ms_asset_data-cap_date.
        ls_hlpseg-initial_acq      = mo_start->ms_asset_data-initial_acq.
        ls_hlpseg-initial_acq_yr   = mo_start->ms_asset_data-initial_acq_yr.
        ls_hlpseg-initial_acq_prd  = mo_start->ms_asset_data-initial_acq_prd.
        ls_hlpseg-last_ret_date    = mo_start->ms_asset_data-last_ret_date.
      ENDIF.

* fill HLPSEG from depreciation parameter
      CALL METHOD get_depr_param
        EXPORTING
          is_depr_param = ls_depr_param
        CHANGING
          cs_hlpseg     = ls_hlpseg.

* determine start period of interval, from date is adjusted to first day of calc. period on ANLZ merge in CL_FAA_DC_ENGINE_CALL
      IF ls_depr_param-from_date <= ms_proc_data-first_day_in_fyr.
        ls_hlpseg-period_from = 1.
        CLEAR ls_hlpseg_repl.
      ELSE.
        IF ls_hlpseg-use_days EQ abap_false.
          CALL METHOD ls_hlpseg-arearef->get_period_and_year
            EXPORTING
              iv_date   = ls_depr_param-from_date
            IMPORTING
              ev_period = ls_hlpseg-period_from.
        ELSE.
          ls_hlpseg-period_from = ls_depr_param-from_date - ls_hlpseg-first_day_in_yr + 1.
        ENDIF.
      ENDIF.

* determine end period of interval, to date is adjusted to last day of calc. period on ANLZ merge in CL_FAA_DC_ENGINE_CALL
      IF ls_depr_param-to_date >= ms_proc_data-last_day_in_fyr.
        ls_hlpseg-period_to = ls_hlpseg-periods_short_fy.
      ELSE.
        IF ls_hlpseg-use_days EQ abap_false.
          CALL METHOD ls_hlpseg-arearef->get_period_and_year
            EXPORTING
              iv_date   = ls_depr_param-to_date
            IMPORTING
              ev_period = ls_hlpseg-period_to.
        ELSE.
          ls_hlpseg-period_to = ls_depr_param-to_date - ls_hlpseg-first_day_in_yr + 1.
        ENDIF.
      ENDIF.

*******************************************************************
* create entry per amount type to be calculated
*******************************************************************
      DO 3 TIMES.
        ASSIGN COMPONENT sy-index OF STRUCTURE ls_hlpseg-amount_types TO <lv_calc_seq>.
        CHECK <lv_calc_seq> > 0.
        CLEAR ls_hlpseg-start_prd.
        CLEAR ls_hlpseg-start_yr.
        CLEAR ls_hlpseg-key_phase_ref.

        CASE sy-index.
          WHEN 1.
            ls_hlpseg-start_date     = ls_depr_param-odepr_start_date.
            ls_hlpseg-amount_type    = gc_amount_type-ordn.
            ls_hlpseg-sort_indicator = ls_hlpseg-calc_seq_ordn.
          WHEN 2.
            ls_hlpseg-start_date     = ls_depr_param-sdepr_start_date.
            ls_hlpseg-amount_type    = gc_amount_type-spec.
            ls_hlpseg-sort_indicator = ls_hlpseg-calc_seq_spec.
          WHEN 3.
            ls_hlpseg-start_date     = ls_depr_param-intr_start_date.
            ls_hlpseg-amount_type    = gc_amount_type-intr.
            ls_hlpseg-sort_indicator = ls_hlpseg-calc_seq_intr.

            " special case: due to customizing of T093-VZZINS = '0' in prior years date was'nt set
            IF ls_hlpseg-start_date IS INITIAL AND ls_depr_param-odepr_start_date IS NOT INITIAL.
              ls_hlpseg-start_date = ls_depr_param-odepr_start_date.
            ENDIF.
        ENDCASE.

* On calculataion of sub-sequent fiscal year
* get amount type depedent data from prior year processing
        IF mo_previous IS BOUND.
          CALL METHOD get_data_from_prior_year
            CHANGING
              cs_hlpseg = ls_hlpseg.

* determine wether useful life has already expired to ensure correct phase determination
          IF ls_hlpseg-exp_life >= ls_hlpseg-useful_life.
            ls_hlpseg-is_behind_ul = abap_true.
          ENDIF.
        ENDIF.

* get phase and depr key settings for period interval4
        CALL METHOD get_phase_and_deprkey_config
          CHANGING
            cs_hlpseg = ls_hlpseg.

* determine calc start date/year/period and expired life for first year to calc
        IF mo_previous IS NOT BOUND.
          CALL METHOD get_calc_info_for_amount_type
            EXPORTING
              is_depr_param = ls_depr_param
            CHANGING
              cs_hlpseg     = ls_hlpseg.
        ENDIF.

* adjust PHASE to "no calculation" if calculations start date is initial.
        IF ls_hlpseg-start_date IS INITIAL.
          ls_hlpseg-phase = 0.
        ENDIF.

* get interval length and changeover year/period from BAdI implementation
* do not call BADI in case of implicit carry forward in the first year w/o calculation -> there should be no change of the given parameters
        IF ms_proc_data-step NE gc_step-dc_int_perform_carry_forward.
          IF go_badi_customer IS BOUND OR go_badi_country IS BOUND.
            CALL METHOD get_data_from_badi
              CHANGING
                cs_hlpseg = ls_hlpseg.

            IF ls_hlpseg-range_length > 0.
              ms_proc_data-split_on_badi = abap_true.
            ENDIF.
          ENDIF.
        ENDIF.

* note if check for change over within useful life to be performed
        CASE ls_hlpseg-key_phase_ref->ms_settings-changeover_meth.
          WHEN gc_changeover_meth_depr-rule_1
            OR gc_changeover_meth_depr-rule_6
            OR gc_changeover_meth_depr-rule_9.
            ms_proc_data-co_on_depr      = abap_true.
          WHEN gc_changeover_meth_nbv-rule_2
            OR gc_changeover_meth_nbv-rule_3
            OR gc_changeover_meth_nbv-rule_4
            OR gc_changeover_meth_nbv-rule_7.
            ms_proc_data-co_on_nbv        = abap_true.
          WHEN gc_changeover_meth_depr-rule_a.
            ms_proc_data-co_on_depr       = abap_true.
            ms_proc_data-co_no_co_yr_set  = abap_true.
          WHEN gc_changeover_meth_nbv-rule_b.
            ms_proc_data-co_on_nbv        = abap_true.
            ms_proc_data-co_no_co_yr_set  = abap_true.
          WHEN gc_changeover_meth_country.
            ms_proc_data-co_country_badi  = abap_true.
          WHEN gc_changeover_meth_customer.
            ms_proc_data-co_customer_badi = abap_true.
        ENDCASE.

* check if split on change over period to be performed
        IF ls_hlpseg-changeover_yr = ls_hlpseg-fyear.
          IF ls_hlpseg-changeover_prd > 1.
            lv_split_on_co_prd = abap_true.
          ENDIF.
        ENDIF.

* just add interval if we are not in the start year
        IF ls_hlpseg-start_yr <> ls_hlpseg-fyear.

          IF ls_hlpseg-start_yr > ls_hlpseg-fyear.
            ls_hlpseg-phase = 0.
          ENDIF.

          APPEND ls_hlpseg TO mts_hlpseg.

* perform interval split on calculation start period if required
        ELSE.
          IF ls_hlpseg-start_prd > ls_hlpseg-period_from AND
             ls_hlpseg-start_prd <= ls_hlpseg-period_to.

            ls_hlpseg_split             = ls_hlpseg.
            ls_hlpseg_split-phase       = 0.
            ls_hlpseg_split-period_from = ls_hlpseg-period_from.
            ls_hlpseg_split-period_to   = ls_hlpseg-start_prd - 1.

            APPEND ls_hlpseg_split TO mts_hlpseg.

            ls_hlpseg_split-phase       = ls_hlpseg-phase.
            ls_hlpseg_split-period_from = ls_hlpseg-start_prd.
            ls_hlpseg_split-period_to   = ls_hlpseg-period_to.

            APPEND ls_hlpseg_split TO mts_hlpseg.

* just add interval
          ELSE.
            IF ls_hlpseg-start_prd > ls_hlpseg-period_to.
              ls_hlpseg-phase = 0.
            ENDIF.
            APPEND ls_hlpseg TO mts_hlpseg.
          ENDIF.
        ENDIF.

* note data of first entry created for area to create entry for replacement value calculation
        CHECK ls_hlpseg-rplcmntval_index IS NOT INITIAL
           OR ls_hlpseg-age_index        IS NOT INITIAL.

        CHECK ls_hlpseg-initial_acq_yr   <  ms_proc_data-fyear.
        CHECK ls_hlpseg_repl             IS INITIAL.
        ls_hlpseg_repl = ls_hlpseg.
      ENDDO.

* finally add one whole year intervall for replacement value calculation
* if applicable
      CHECK ls_hlpseg_repl IS NOT INITIAL.
      CHECK ls_depr_param-to_date >= ms_proc_data-last_day_in_fyr.
      CLEAR ls_hlpseg.

      ls_hlpseg-fyear            = ls_hlpseg_repl-fyear.
      ls_hlpseg-area             = ls_hlpseg_repl-area.
      ls_hlpseg-curr_type        = ls_hlpseg_repl-curr_type.
      ls_hlpseg-arearef          = ls_hlpseg_repl-arearef.
      ls_hlpseg-key_phase_ref    = ls_hlpseg_repl-key_phase_ref.
      ls_hlpseg-periods          = ls_hlpseg_repl-periods.
      ls_hlpseg-period_to        = ls_hlpseg_repl-periods_short_fy.
      ls_hlpseg-period_from      =  1.
      ls_hlpseg-exp_life         = ls_hlpseg_repl-exp_life.
      ls_hlpseg-exp_life_seg     = ls_hlpseg_repl-periods.
      ls_hlpseg-phase            = 1.
      ls_hlpseg-initial_acq_yr   = ls_hlpseg_repl-initial_acq_yr.
      ls_hlpseg-start_yr         = ls_hlpseg_repl-initial_acq_yr + 1.
      ls_hlpseg-start_prd        = 1.
      ls_hlpseg-neg_values       = ls_hlpseg_repl-neg_values.
      ls_hlpseg-use_days         = ls_hlpseg_repl-use_days.
      ls_hlpseg-amount_types     = ls_hlpseg_repl-amount_types.
      ls_hlpseg-ignore_memval    = ls_hlpseg_repl-ignore_memval.
      ls_hlpseg-to_date_of_tddp  = if_faa_mdo_constants=>gc_max_date.
      ls_hlpseg-assetclass       = ls_hlpseg_repl-assetclass.
      ls_hlpseg-cap_date         = ls_hlpseg_repl-cap_date.
      ls_hlpseg-periods_short_fy = ls_hlpseg_repl-periods_short_fy.
      ls_hlpseg-first_day_in_yr  = ls_hlpseg_repl-first_day_in_yr.

* get parameter for calculation of replacement value
      IF ls_hlpseg_repl-rplcmntval_index IS NOT INITIAL.
        ls_hlpseg-sort_indicator   = 20.
        ls_hlpseg-amount_type      = gc_amount_type-repl.
        ls_hlpseg-rplcmntval_index = ls_hlpseg_repl-rplcmntval_index.

        CALL METHOD get_repl_param
          CHANGING
            cs_hlpseg = ls_hlpseg.

        APPEND ls_hlpseg TO mts_hlpseg.
      ENDIF.

* get parameter for calculation of replacement value using age index
      IF ls_hlpseg_repl-age_index IS NOT INITIAL.
        ls_hlpseg-sort_indicator = 10.
        ls_hlpseg-amount_type    = gc_amount_type-rage.
        ls_hlpseg-age_index      = ls_hlpseg_repl-age_index.

        CALL METHOD get_repl_param
          CHANGING
            cs_hlpseg = ls_hlpseg.

        APPEND ls_hlpseg TO mts_hlpseg.
      ENDIF.
    ENDLOOP.

* perform split on change over period if applicable/get appropriate phase
* for interval for which changeover is to be regarded
    IF lv_split_on_co_prd = abap_true.
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
        WHERE changeover_yr   = ms_proc_data-fyear
          AND changeover_prd  > 1
          AND phase           = 1.

        IF <ls_hlpseg>-changeover_prd <= <ls_hlpseg>-period_to AND
           <ls_hlpseg>-changeover_prd >  <ls_hlpseg>-period_from.

          ls_hlpseg_split             = <ls_hlpseg>.
          <ls_hlpseg>-period_to       = ls_hlpseg_split-changeover_prd - 1.
          ls_hlpseg_split-period_from = ls_hlpseg_split-changeover_prd.

* get phase and depr key settings for period interval
          CALL METHOD get_phase_and_deprkey_config
            CHANGING
              cs_hlpseg = ls_hlpseg_split.
          APPEND ls_hlpseg_split TO mts_hlpseg.
        ENDIF.

        IF <ls_hlpseg>-changeover_prd <= <ls_hlpseg>-period_from.
          CALL METHOD get_phase_and_deprkey_config
            CHANGING
              cs_hlpseg = <ls_hlpseg>.
        ENDIF.
      ENDLOOP.
    ENDIF.

    SORT mts_hlpseg.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_get_co_yr_and_prd.
*=======================================================================
* perform changeover according changeover rule to be applied
*=======================================================================
* Reworked with 19/11
*=======================================================================
* PRECONDITION
    CHECK ms_transaction_cntrl-set_changeover_y = abap_true
       OR ms_proc_data-co_on_depr               = abap_true
       OR ms_proc_data-co_on_nbv                = abap_true.

    IF ms_transaction_cntrl-is_reversal EQ abap_false.
      CHECK ms_transaction_cntrl-classification <> if_faa_posting_constants=>gc_movcat-transfer_ret
        AND ms_transaction_cntrl-classification <> if_faa_posting_constants=>gc_movcat-retirement.
    ENDIF.

* DEFINITION
    FIELD-SYMBOLS <ls_calcamount1>    TYPE ty_s_calcamount.
    FIELD-SYMBOLS <ls_calcamount2>    TYPE ty_s_calcamount.
    FIELD-SYMBOLS <ls_calcdata1>      TYPE ty_s_calcdata.
    FIELD-SYMBOLS <ls_calcdata2>      TYPE ty_s_calcdata.
    FIELD-SYMBOLS <ls_yearseg1>       TYPE ty_s_yearseg.
    FIELD-SYMBOLS <ls_hlpseg>         TYPE ty_s_hlpseg.

    DATA lo_processing_handle         LIKE me.
    DATA lo_processing_handle_phase_1 LIKE me.
    DATA lo_processing_handle_phase_2 LIKE me.

    DATA ls_hlpseg                    TYPE ty_s_hlpseg.

    DATA:
      lv_sum_depr1        TYPE afledf34_dec, "AFLE Enablement (old type: f)
      lv_sum_depr2        TYPE afledf34_dec, "AFLE Enablement (old type: f)
      lv_changeover_value TYPE afledf34_dec, "AFLE Enablement (old type: f)
      lv_sum_apc          TYPE afledf34_dec, "AFLE Enablement (old type: f)
      lv_nbv              TYPE afledf34_dec, "AFLE Enablement (old type: f)
      lv_lin_depr_proz    TYPE decfloat34.

* BODY
*=============================================================================
* set changover year from posting year for all areas for which no
* other changeover method is to be applied
*=============================================================================
    IF ms_transaction_cntrl-set_changeover_y EQ abap_true.
      ls_hlpseg-changeover_yr = ms_transaction_cntrl-fyear.

      MODIFY mts_hlpseg
        FROM ls_hlpseg TRANSPORTING changeover_yr
       WHERE changeover_yr                              < ms_transaction_cntrl-fyear
         AND key_phase_ref->ms_settings-changeover_meth = gc_changeover_meth_none-rule_0
         AND grp_asset_assgnd                           = abap_false.
    ENDIF.

*=============================================================================
* perform depreciation calculation for phase 1 and if applicaple for phase 2
*=============================================================================
    CREATE OBJECT lo_processing_handle_phase_1.

* take over phase independant data
    lo_processing_handle_phase_1->mo_previous       = me.
    lo_processing_handle_phase_1->mo_start          = mo_start.
    lo_processing_handle_phase_1->ms_proc_data      = ms_proc_data.
    lo_processing_handle_phase_1->mts_area          = mts_area.
    lo_processing_handle_phase_1->mt_areasign       = mt_areasign.
    lo_processing_handle_phase_1->mt_rounding       = mt_rounding.
    lo_processing_handle_phase_1->mt_yearseg        = mt_yearseg.
    lo_processing_handle_phase_1->mt_transaction    = mt_transaction.

    lo_processing_handle_phase_1->ms_proc_data-step = gc_step-dc_int_calc_co_rules.

* prepare calculation of the relevant areas and amount types for change over check
    lo_processing_handle_phase_1->mts_hlpseg        = mts_hlpseg.

    DELETE lo_processing_handle_phase_1->mts_hlpseg
     WHERE key_phase_ref->ms_settings-changeover_meth NA gc_changeover_meth_in_ul
        OR changeover_yr                              IS NOT INITIAL
        OR grp_asset_assgnd                           EQ abap_true
        OR amount_type                                EQ gc_amount_type-rage
        OR amount_type                                EQ gc_amount_type-repl
        OR start_yr                                   GT ms_proc_data-fyear.

    IF ms_proc_data-co_on_depr EQ abap_true.
      LOOP AT lo_processing_handle_phase_1->mts_hlpseg INTO ls_hlpseg
       WHERE key_phase_ref->ms_settings-changeover_meth CA gc_changeover_meth_depr.
        IF lo_processing_handle_phase_2 IS INITIAL.
          CREATE OBJECT lo_processing_handle_phase_2.

          lo_processing_handle_phase_2->ms_proc_data-step = lo_processing_handle_phase_1->ms_proc_data-step.
          lo_processing_handle_phase_2->mo_previous       = lo_processing_handle_phase_1->mo_previous.
          lo_processing_handle_phase_2->mo_start          = lo_processing_handle_phase_1->mo_start.
          lo_processing_handle_phase_2->ms_proc_data      = lo_processing_handle_phase_1->ms_proc_data.
          lo_processing_handle_phase_2->mts_area          = lo_processing_handle_phase_1->mts_area.
          lo_processing_handle_phase_2->mt_areasign       = lo_processing_handle_phase_1->mt_areasign.
          lo_processing_handle_phase_2->mt_rounding       = lo_processing_handle_phase_1->mt_rounding.
          lo_processing_handle_phase_2->mt_yearseg        = lo_processing_handle_phase_1->mt_yearseg.
          lo_processing_handle_phase_2->mt_transaction    = lo_processing_handle_phase_1->mt_transaction.
        ENDIF.

        IF ls_hlpseg-phase = 1.
          ls_hlpseg-phase = 2.
          ls_hlpseg-key_phase_ref = cl_faa_cfg_factory_static=>get_instance_depr_key_phase(
                                      iv_comp_code   = ls_hlpseg-arearef->ms_leadobj_key-comp_code
                                      iv_depr_area   = CONV #( ls_hlpseg-area )
                                      iv_depr_key    = ls_hlpseg-depr_key
                                      iv_amount_type = ls_hlpseg-amount_type
                                      iv_phase       = ls_hlpseg-phase ).
        ENDIF.
        APPEND ls_hlpseg TO lo_processing_handle_phase_2->mts_hlpseg.
      ENDLOOP.
    ENDIF.

    DO 2 TIMES.
      CASE sy-index.
        WHEN 1.
          lo_processing_handle = lo_processing_handle_phase_1.
        WHEN 2.
          CHECK lo_processing_handle_phase_2 IS BOUND.
          lo_processing_handle = lo_processing_handle_phase_2.
      ENDCASE.

      CALL METHOD lo_processing_handle->_hlpseg_split_at_ul_end.
      CALL METHOD lo_processing_handle->_hlpseg_split_on_mlm.
      CALL METHOD lo_processing_handle->_hlpseg_split_on_mlm_dat.
      CALL METHOD lo_processing_handle->_hlpseg_split_on_cov_key.
      CALL METHOD lo_processing_handle->_hlpseg_split_on_digital.
      CALL METHOD lo_processing_handle->_hlpseg_split_in_max_prds.
      CALL METHOD lo_processing_handle->_timeseg_create.
      CALL METHOD lo_processing_handle->_hlpseg_split_on_timeseg.
      CALL METHOD lo_processing_handle->_hlpseg_split_on_alignment.
      CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
      CALL METHOD lo_processing_handle->_timeseg_create_missing.
      CALL METHOD lo_processing_handle->_parameter_create.
      CALL METHOD lo_processing_handle->_parameter_call_badi.
      CALL METHOD lo_processing_handle->_period_create.
      CALL METHOD lo_processing_handle->_sumseg_create.
      CALL METHOD lo_processing_handle->_calcorder_create.

      TRY.
          CALL METHOD lo_processing_handle->_values_calculate.
        CATCH cm_faa_t100.
          CLEAR lo_processing_handle_phase_2.
      ENDTRY.
    ENDDO.

*=============================================================================
* Perform changeover checks
*=============================================================================
    LOOP AT lo_processing_handle_phase_1->mts_hlpseg ASSIGNING <ls_hlpseg>.
      AT NEW amount_type.
        CLEAR ls_hlpseg.
      ENDAT.

      CLEAR lv_changeover_value.

*=============================================================================
* Perform changeover on netbook value rule
*=============================================================================
      CASE <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth.
        WHEN gc_changeover_meth_nbv-rule_2      " change over if NBV percentage is LOWER THAN change over percentage
          OR gc_changeover_meth_nbv-rule_7.     " change over if NBV percentage is LOWER OR EQUAL than change over percentage
*         <<< begin of change note 2941276 >>>
          READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1>
                 WITH KEY fyear       = <ls_hlpseg>-fyear
                          area        = <ls_hlpseg>-area
                          curr_type   = <ls_hlpseg>-curr_type
                          amount_type = <ls_hlpseg>-amount_type
                          period_to   = <ls_hlpseg>-period_to.

          lv_sum_apc = <ls_calcdata1>-sum_apc.
          lv_nbv     = <ls_calcdata1>-netvalue - <ls_calcdata1>-amount.

*         <<< end of changes - note 2941276 >>>

          IF ls_hlpseg-changeover_yr IS INITIAL AND lv_sum_apc NE 0.

            " Determine net book value percentage in relation to apc
            lv_lin_depr_proz = lv_nbv / lv_sum_apc * 100.

            IF ( <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth EQ gc_changeover_meth_nbv-rule_2 AND
                 lv_lin_depr_proz LT <ls_hlpseg>-key_phase_ref->ms_settings-changeover_perc                 ) OR
               ( <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth EQ gc_changeover_meth_nbv-rule_7 AND
                 lv_lin_depr_proz LE <ls_hlpseg>-key_phase_ref->ms_settings-changeover_perc                 ).

              ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear.

              IF <ls_hlpseg>-use_max_periods EQ abap_true AND
                 <ls_hlpseg>-period_from     GT 1.
                ls_hlpseg-changeover_prd = <ls_hlpseg>-period_to.
              ENDIF.

            ENDIF.

          ENDIF.

        WHEN gc_changeover_meth_nbv-rule_3
          OR gc_changeover_meth_nbv-rule_4
          OR gc_changeover_meth_nbv-rule_b.

* <<<     begin of changes - note 2941276 >>>
          READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1>
                 WITH KEY fyear       = <ls_hlpseg>-fyear
                          area        = <ls_hlpseg>-area
                          curr_type   = <ls_hlpseg>-curr_type
                          amount_type = <ls_hlpseg>-amount_type
                          period_to   = <ls_hlpseg>-period_to.
          lv_sum_apc = <ls_calcdata1>-sum_apc.
          lv_nbv     = <ls_calcdata1>-netvalue - <ls_calcdata1>-amount.

* <<<    end of changes - note 2941276 >>>

          IF ls_hlpseg-changeover_yr IS INITIAL.
            CASE <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth.

* change over if NBV lower than change over amount defined for area
              WHEN gc_changeover_meth_nbv-rule_3.
                lv_changeover_value = <ls_hlpseg>-arearef->ms_setup-depr_changevalue.

* change over if NBV lower than calculated straight line depreciation, check per interval
              WHEN gc_changeover_meth_nbv-rule_4.
                READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1>
                  WITH KEY fyear       = <ls_hlpseg>-fyear
                           area        = <ls_hlpseg>-area
                           curr_type   = <ls_hlpseg>-curr_type
                           amount_type = <ls_hlpseg>-amount_type
                           period_to   = <ls_hlpseg>-period_to.
                lv_sum_apc = <ls_calcdata1>-sum_apc.
                lv_nbv     = <ls_calcdata1>-netvalue - <ls_calcdata1>-amount.
                IF <ls_hlpseg>-useful_life IS NOT INITIAL.
                  lv_changeover_value = lv_sum_apc * <ls_hlpseg>-periods / <ls_hlpseg>-useful_life. "< 2941276
                ENDIF.

                " Avoid changeover if condition is not met
                IF NOT ( ( lv_nbv LT lv_changeover_value AND lv_sum_apc GT 0  OR
                           lv_nbv GT lv_changeover_value AND lv_sum_apc LT 0 ) AND
                         lv_nbv  NE 0 ).
                  CLEAR: lv_sum_apc, lv_nbv, lv_changeover_value.
                ENDIF.
            ENDCASE.

* check netbook value at start of fiscal year only, if change over is not required on period interval level
            IF ( lv_sum_apc GT 0 AND lv_nbv LT lv_changeover_value ) OR
               ( lv_sum_apc LT 0 AND lv_nbv GT lv_changeover_value ).
              ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear.

              IF <ls_hlpseg>-use_max_periods EQ abap_true AND
                 <ls_hlpseg>-period_from     GT 1.
                ls_hlpseg-changeover_prd = <ls_hlpseg>-period_to.
              ENDIF.
            ENDIF.
          ENDIF.

*=============================================================================
* Perform changeover if straight line depreciation is higher
*=============================================================================
        WHEN gc_changeover_meth_depr-rule_1
          OR gc_changeover_meth_depr-rule_6
          OR gc_changeover_meth_depr-rule_9
          OR gc_changeover_meth_depr-rule_a.

* perform comparison of calculated amounts only if phase 2 was calculated w/o errors
          CHECK lo_processing_handle_phase_2 IS BOUND.

* perform check based on depreciation calculated for whole year and set changeover year
          IF <ls_hlpseg>-period_from = 1.
            READ TABLE lo_processing_handle_phase_1->mts_calcamount ASSIGNING <ls_calcamount1>
              WITH KEY area      = <ls_hlpseg>-area
                       curr_type = <ls_hlpseg>-curr_type.

            READ TABLE lo_processing_handle_phase_2->mts_calcamount ASSIGNING <ls_calcamount2>
              WITH KEY area      = <ls_hlpseg>-area
                       curr_type = <ls_hlpseg>-curr_type.

            CASE <ls_hlpseg>-amount_type.
              WHEN gc_amount_type-ordn.
                lv_sum_depr1 = abs( <ls_calcamount1>-total-depr_o ).
                lv_sum_depr2 = abs( <ls_calcamount2>-total-depr_o ).
              WHEN gc_amount_type-spec.
                lv_sum_depr1 = abs( <ls_calcamount1>-total-depr_s ).
                lv_sum_depr2 = abs( <ls_calcamount2>-total-depr_s ).
            ENDCASE.

            IF lv_sum_depr2 > lv_sum_depr1.
              CASE <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth.
                WHEN gc_changeover_meth_depr-rule_1
                  OR gc_changeover_meth_depr-rule_a.
                  ls_hlpseg-changeover_yr  = <ls_hlpseg>-fyear.

                WHEN gc_changeover_meth_depr-rule_6.
                  ls_hlpseg-changeover_yr  = <ls_hlpseg>-fyear + 1.

                WHEN gc_changeover_meth_depr-rule_9.
                  IF <ls_hlpseg>-start_yr < <ls_hlpseg>-fyear.
                    ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear.
                  ELSE.
                    ls_hlpseg-changeover_yr = <ls_hlpseg>-fyear + 1.
                  ENDIF.

              ENDCASE.
            ENDIF.
          ENDIF.

* get changeover period
          IF <ls_hlpseg>-use_max_periods EQ abap_true         AND
             ls_hlpseg-changeover_yr     EQ <ls_hlpseg>-fyear AND
             ls_hlpseg-changeover_prd    IS INITIAL.

            READ TABLE lo_processing_handle_phase_1->mts_calcdata ASSIGNING <ls_calcdata1>
              WITH KEY fyear       = <ls_hlpseg>-fyear
                       area        = <ls_hlpseg>-area
                       curr_type   = <ls_hlpseg>-curr_type
                       amount_type = <ls_hlpseg>-amount_type
                       period_to   = <ls_hlpseg>-period_to.

            READ TABLE lo_processing_handle_phase_2->mts_calcdata ASSIGNING <ls_calcdata2>
              WITH KEY fyear       = <ls_hlpseg>-fyear
                       area        = <ls_hlpseg>-area
                       curr_type   = <ls_hlpseg>-curr_type
                       amount_type = <ls_hlpseg>-amount_type
                       period_to   = <ls_hlpseg>-period_to.

            lv_sum_depr1 = lv_sum_depr1 - abs( <ls_calcdata1>-amount ).
            lv_sum_depr2 = lv_sum_depr2 - abs( <ls_calcdata2>-amount ).
            IF lv_sum_depr2 > lv_sum_depr1.
              ls_hlpseg-changeover_prd = <ls_calcdata2>-period_to.
            ENDIF.
          ENDIF.
      ENDCASE.

* provide dper. key settings for phase 2 in MTS_HLPSEG if changeover to be performed
      AT END OF amount_type.
        CHECK ls_hlpseg-changeover_yr IS NOT INITIAL.

* set changeover year and period for all intervalls, if to be stored
        IF <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth NE gc_changeover_meth_depr-rule_a AND
         <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth NE gc_changeover_meth_nbv-rule_b.
          MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING changeover_prd changeover_yr
           WHERE area        = <ls_hlpseg>-area
             AND curr_type   = <ls_hlpseg>-curr_type
             AND amount_type = <ls_hlpseg>-amount_type.
        ENDIF.

        ls_hlpseg-area          = <ls_hlpseg>-area.
        ls_hlpseg-amount_type   = <ls_hlpseg>-amount_type.
        ls_hlpseg-depr_key      = <ls_hlpseg>-depr_key.
        ls_hlpseg-phase         = <ls_hlpseg>-phase.
        ls_hlpseg-arearef       = <ls_hlpseg>-arearef.
        ls_hlpseg-key_phase_ref = <ls_hlpseg>-key_phase_ref.
        ls_hlpseg-fyear         = <ls_hlpseg>-fyear.
        ls_hlpseg-period_from   = <ls_hlpseg>-period_from.
        ls_hlpseg-is_behind_ul  = <ls_hlpseg>-is_behind_ul.

        CALL METHOD get_phase_and_deprkey_config
          CHANGING
            cs_hlpseg = ls_hlpseg.

        MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING phase key_phase_ref
         WHERE area         = <ls_hlpseg>-area
           AND curr_type    = <ls_hlpseg>-curr_type
           AND amount_type  = <ls_hlpseg>-amount_type
           AND period_from >= ls_hlpseg-changeover_prd
           AND phase        = 1.
      ENDAT.
    ENDLOOP.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_get_deact_date.
*******************************************************************
* 1. set/reset deactivation date on retirement posting or reversal
*    of a retirement posting
*******************************************************************
* Reworked/Cleaned up with 1908
*******************************************************************
* PRECONDITION
    CHECK ms_transaction_cntrl-classification  EQ if_faa_posting_constants=>gc_movcat-retirement
       OR ms_transaction_cntrl-classification  EQ if_faa_posting_constants=>gc_movcat-transfer_ret.

* DEFINITIONS
    FIELD-SYMBOLS <ls_yearseg>     TYPE ty_s_yearseg.
    FIELD-SYMBOLS <ls_sumseg>      TYPE ty_s_sumseg.

    DATA ls_calcamount TYPE ty_s_calcamount.

    DATA ls_hlpseg                  TYPE ty_s_hlpseg.

    DATA lv_apc                     TYPE ty_s_value-apc.
  DATA lv_revl                    TYPE ty_s_value-revl.     "note: 2924582
    DATA lv_nbv                     TYPE ty_s_value-apc.

* BODY
*// on reversal clear deactivation date
  IF  ms_transaction_cntrl-is_reversal = abap_true.
      CLEAR ls_hlpseg-deact_date.

* set deactivation date if all valuation view sum up to zero
    ELSE.

      " avoid deactivation of asset on retiremen type = 2 (8 is 2 but scrapping)
      LOOP AT mts_area TRANSPORTING NO FIELDS
        WHERE retirement_type = '2'
           OR retirement_type = '8'.
        IF sy-subrc = 0.
          RETURN.
        ENDIF.
      ENDLOOP.

      ls_hlpseg-deact_date = ms_transaction_cntrl-value_date.

      LOOP AT mt_yearseg ASSIGNING <ls_yearseg>.
        READ TABLE mts_calcamount INTO ls_calcamount
          WITH KEY fyear     = <ls_yearseg>-fyear
                   area      = <ls_yearseg>-area
                   curr_type = <ls_yearseg>-curr_type.
        IF sy-subrc <> 0.
          CLEAR ls_calcamount.
        ENDIF.

        READ TABLE mt_sumseg ASSIGNING <ls_sumseg>
          WITH KEY fyear     = <ls_yearseg>-fyear
                   area      = <ls_yearseg>-area
                   curr_type = <ls_yearseg>-curr_type.
        lv_apc = 0
               + ls_calcamount-total-revl

               + <ls_yearseg>-cum-apc
               + <ls_yearseg>-cum-revl

               + <ls_sumseg>-prev_prev-apc
               + <ls_sumseg>-prev_prev-revl

               + <ls_sumseg>-prev_cur-apc
               + <ls_sumseg>-prev_cur-revl

               + <ls_sumseg>-cur-apc
               + <ls_sumseg>-cur-revl.

      "begin of note: 2924582
      lv_revl = ls_calcamount-total-revl

             + <ls_yearseg>-cum-revl

             + <ls_sumseg>-prev_prev-revl

             + <ls_sumseg>-prev_cur-revl

             + <ls_sumseg>-cur-revl.
      "end of note: 2924582

        lv_nbv = lv_apc.

        lv_nbv = lv_nbv
               + ls_calcamount-total-revl_d
               + ls_calcamount-total-depr_o
               + ls_calcamount-total-depr_s

               + <ls_yearseg>-cum-invs
               + <ls_yearseg>-cum-revl_d
               + <ls_yearseg>-cum-depr_o
               + <ls_yearseg>-cum-depr_s
               + <ls_yearseg>-cum-depr_u
               + <ls_yearseg>-cum-resv
               + <ls_yearseg>-cum-downp


               + <ls_sumseg>-prev_prev-invs
               + <ls_sumseg>-prev_prev-revl_d
               + <ls_sumseg>-prev_prev-depr_o
               + <ls_sumseg>-prev_prev-depr_s
               + <ls_sumseg>-prev_prev-depr_u
               + <ls_sumseg>-prev_prev-resv
               + <ls_sumseg>-prev_prev-downp

               + <ls_sumseg>-prev_cur-invs
               + <ls_sumseg>-prev_cur-revl_d
               + <ls_sumseg>-prev_cur-depr_o
               + <ls_sumseg>-prev_cur-depr_s
               + <ls_sumseg>-prev_cur-depr_u
               + <ls_sumseg>-prev_cur-resv
               + <ls_sumseg>-prev_cur-downp

               + <ls_sumseg>-cur-invs
               + <ls_sumseg>-cur-revl_d
               + <ls_sumseg>-cur-depr_o
               + <ls_sumseg>-cur-depr_s
               + <ls_sumseg>-cur-depr_u
               + <ls_sumseg>-cur-resv
               + <ls_sumseg>-cur-downp.

* leave loop if values of valuation view do not sum up to zero
        CHECK lv_apc <> 0
         OR lv_revl <> 0                                    "note: 2924582
           OR lv_nbv <> 0.

        CLEAR ls_hlpseg-deact_date.
        EXIT.                                           "<<<<<< EXIT LOOP
      ENDLOOP.
    ENDIF.

* modify date of last retirement of alle entries in attribute table HLPSEG
    MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING deact_date
      WHERE fyear = ms_proc_data-fyear.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_get_exp_life_seg.
* PRECONDITION

* DEFINITION
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

* BODY
* calc. the expired useful life throughout each segment & get usage ind.
* this information is used for creation of PERIOD and PARAMETER
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      CALL METHOD get_expired_life_for_interval
        CHANGING
          cs_hlpseg = <ls_hlpseg>.
    ENDLOOP.

* POSTCONDITION

ENDMETHOD.


  METHOD _hlpseg_get_last_ret_date.
*=======================================================================
* 1. adjust date of last retirement on retirement posting or reversal
*    of a retirement posting
*=======================================================================
* PRECONDITION
  CHECK ms_transaction_cntrl-classification  EQ if_faa_posting_constants=>gc_movcat-retirement
       OR ms_transaction_cntrl-classification  EQ if_faa_posting_constants=>gc_movcat-transfer_ret.

* DEFINITIONS
    DATA lt_transaction             TYPE faa_dc_t_transaction.
    DATA ls_transaction             TYPE ty_s_transaction.
    DATA ls_hlpseg                  TYPE ty_s_hlpseg.

* BODY
* Retirement posting adjust last retirement date from actual value date
  IF  ms_transaction_cntrl-is_reversal = abap_false.
      ls_hlpseg-last_ret_date = ms_transaction_cntrl-value_date.

* set last retirement date from value date of prior retirement on reversal
* or clear it if there is none
    ELSE.

      lt_transaction = mt_transaction.

      DELETE lt_transaction
       WHERE classification <> if_faa_posting_constants=>gc_movcat-retirement
         AND classification <> if_faa_posting_constants=>gc_movcat-transfer_ret.

      DELETE lt_transaction                                 "2226481
       WHERE seqno_reversed IS NOT INITIAL.

      SORT lt_transaction DESCENDING BY value_date.

      READ TABLE lt_transaction INTO ls_transaction INDEX 1.
      IF sy-subrc EQ 0.
        ls_hlpseg-last_ret_date = ls_transaction-value_date.
      ELSE.
        CLEAR ls_hlpseg-last_ret_date.
      ENDIF.
    ENDIF.

* modify date of last retirement of alle entries in attribute table HLPSEG
    MODIFY mts_hlpseg FROM ls_hlpseg TRANSPORTING last_ret_date
     WHERE fyear = ms_proc_data-fyear.

* POSTCONDITION

ENDMETHOD.


  METHOD _hlpseg_split_at_ul_end.
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

    DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

    DATA ls_hlpseg                 TYPE ty_s_hlpseg.

    DATA lv_period_to_before_split TYPE faa_dc_period_to.
    DATA lv_decision_indicator     TYPE i.
    DATA lv_exp_life_sum_prev      TYPE float.
    DATA lv_exp_life_sum           TYPE float.
    DATA lv_period_to_int TYPE i.                           "> 2458203
    DATA lv_end_date               TYPE d.
    DATA lv_days                   TYPE p.

* BODY
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.

* initialize all split relevant local fields on new amount type
      AT NEW amount_type.
        lv_exp_life_sum_prev  = <ls_hlpseg>-exp_life.
        lv_exp_life_sum       = <ls_hlpseg>-exp_life.

        IF <ls_hlpseg>-use_exp_life_new = abap_true.
          lv_exp_life_sum_prev  = <ls_hlpseg>-exp_life_new.
          lv_exp_life_sum       = <ls_hlpseg>-exp_life_new.
        ENDIF.
      ENDAT.

* no processing if interval is already marked to be behind useful life
      CHECK <ls_hlpseg>-is_behind_ul                         = abap_false.
      CHECK <ls_hlpseg>-amount_type                         NA 'AC'.

* get next phase if we are already behind useful life at fiscal year start "2442066
      IF <ls_hlpseg>-use_exp_life_new = abap_true.          "2442066
        IF <ls_hlpseg>-exp_life_new >= <ls_hlpseg>-useful_life.
          <ls_hlpseg>-is_behind_ul = abap_true.
        ENDIF.
      ELSE.
        IF <ls_hlpseg>-exp_life >= <ls_hlpseg>-useful_life.
          <ls_hlpseg>-is_behind_ul = abap_true.
        ENDIF.
      ENDIF.

      IF  <ls_hlpseg>-is_behind_ul = abap_true.
        CALL METHOD get_phase_and_deprkey_config
          CHANGING
            cs_hlpseg = <ls_hlpseg>.
      ENDIF.                                                "2442066

      CHECK <ls_hlpseg>-key_phase_ref->ms_settings-changeover_meth <> gc_changeover_meth_at_end-rule_d. "2442066

* calculate the expired useful life of actual period interval
      CALL METHOD get_expired_life_for_interval
        CHANGING
          cs_hlpseg = <ls_hlpseg>.

* get complete expired useful life including the actual interval
      lv_exp_life_sum = lv_exp_life_sum + <ls_hlpseg>-exp_life_seg.

* set decision indicator how to process the actual perod interval
      CLEAR lv_decision_indicator.

* interval is completely within useful life
      IF lv_exp_life_sum <= <ls_hlpseg>-useful_life.
        lv_decision_indicator = 1.
      ENDIF.

* interval is to be split as useful life ends within/with the interval
      IF lv_exp_life_sum > <ls_hlpseg>-useful_life.
        lv_decision_indicator = 3.
      ENDIF.

* no split if just one period covered within period interval
      IF <ls_hlpseg>-period_from = <ls_hlpseg>-period_to.
        lv_decision_indicator = 7.
      ENDIF.

* interval is completely behind, split was performed on previous interval
      IF lv_exp_life_sum_prev >= <ls_hlpseg>-useful_life.
        lv_decision_indicator = 15.
      ENDIF.

* useful life is to be adjusted for calculation if passed, no split
      IF <ls_hlpseg>-key_phase_ref->ms_settings-calc_real_life = abap_true.
        lv_decision_indicator = 31.
      ENDIF.

      lv_exp_life_sum_prev = lv_exp_life_sum.

* perfrom processing according decision indicator
* 01 = interval is completely within useful life
* 03 = useful life ends within/with the interval => split
* 07 = interval covers just one period no split
* 15 = interval is completely behind useful life
* 31 = special treatment in _PERIOD_CREATE requested due to depr.key settings
      CASE lv_decision_indicator.

* nothing to be done with this period interval
        WHEN 01
          OR 07
          OR 31.

          CONTINUE.

* preform split
        WHEN 03.
          ls_hlpseg           = <ls_hlpseg>.

          IF <ls_hlpseg>-use_days IS INITIAL.

            ls_hlpseg-period_to = ls_hlpseg-period_from.

            lv_exp_life_sum     = lv_exp_life_sum - <ls_hlpseg>-exp_life_seg.

            WHILE ls_hlpseg-period_to < <ls_hlpseg>-period_to.

* get expiring life for one calculation period
              IF sy-index = 1.
                CALL METHOD get_expired_life_for_interval
                  CHANGING
                    cs_hlpseg = ls_hlpseg.
              ENDIF.

* get expired useful life including actual calculation period
              lv_exp_life_sum = lv_exp_life_sum + ls_hlpseg-exp_life_seg.

* complete expired useful life exceeds useful life => LEAVE and perform split
              IF lv_exp_life_sum   >= <ls_hlpseg>-useful_life.
                EXIT.

              ELSE.
                ls_hlpseg-period_to = ls_hlpseg-period_to  + 1.
              ENDIF.
            ENDWHILE.

* insure correct setting of decision indicator on next period interval
            lv_exp_life_sum  = lv_exp_life_sum_prev.

* no split required as end of usefule life is reached with the complete interval
            IF ls_hlpseg-period_to = <ls_hlpseg>-period_to.
              CONTINUE.
            ENDIF.

* on depreciation to the day the number of days in the last year
* has to be calculated precisely
          ELSE.

* logic to consider leap years correctly
            lv_end_date          = <ls_hlpseg>-start_date.
            lv_end_date+0(4)    = lv_end_date+0(4) + <ls_hlpseg>-useful_life_yrs.

            IF lv_end_date+4(4) = gc_date-feb_29+4(4).
              lv_end_date+4(4)  = gc_date-march_01+4(4).
              lv_end_date       = lv_end_date - 1.
            ENDIF.

            lv_days             = <ls_hlpseg>-useful_life_prds * 365 / 12.
            lv_end_date         = lv_end_date + lv_days - 1.

*         if last day of useful life is in prior year split is already done
*         further split is wrong.
            IF lv_end_date >= <ls_hlpseg>-first_day_in_yr.  "2270486
              lv_period_to_int = lv_end_date - <ls_hlpseg>-first_day_in_yr + 1. "< 2458203
              IF lv_period_to_int <= <ls_hlpseg>-periods.   "< 2458203
                ls_hlpseg-period_to = lv_end_date - <ls_hlpseg>-first_day_in_yr + 1.
              ENDIF.                                        "< 2458203
            ENDIF.

* no split required
            IF ls_hlpseg-period_to >= <ls_hlpseg>-period_to OR
               ls_hlpseg-period_to <  <ls_hlpseg>-period_from.

              CONTINUE.
            ENDIF.
          ENDIF.

* perform interval split by changing PERIOD_TO of the original interval and
* changing PERIOD_FROM of the new interval to appended
          lv_period_to_before_split = <ls_hlpseg>-period_to.

          <ls_hlpseg>-period_to     = ls_hlpseg-period_to.

          ls_hlpseg-period_from     = ls_hlpseg-period_to + 1.
          ls_hlpseg-period_to       = lv_period_to_before_split.

* interval is completely behind useful life, correct phase has to be defined
        WHEN 15.
          ls_hlpseg = <ls_hlpseg>.
      ENDCASE.

* mark intervals as behind useful life and get appropriate phase
      ls_hlpseg-is_behind_ul = abap_true.

      CALL METHOD get_phase_and_deprkey_config
        CHANGING
          cs_hlpseg = ls_hlpseg.

* append new interval/change actual one according decision indicator
      CASE lv_decision_indicator.

* new interval is to be created due to splitting
        WHEN 3.
          APPEND ls_hlpseg TO lt_hlpseg.

* interval is completely behind useful life, correct phase was to be defined
        WHEN 15.
          <ls_hlpseg> = ls_hlpseg.
      ENDCASE.
    ENDLOOP.

    CHECK NOT lt_hlpseg[] IS INITIAL.
    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

  ENDMETHOD.                    "change


  METHOD _hlpseg_split_in_max_prds .
* PRECONDITION
  CHECK ms_proc_data-split_on_badi = abap_true.

* DEFINITION
  DATA lt_hlpseg                  TYPE ty_ts_hlpseg.
  DATA ls_hlpseg                  TYPE ty_s_hlpseg.

  FIELD-SYMBOLS <ls_hlpseg>       TYPE ty_s_hlpseg.

* BODY
* split interval considering max. count of periods defined
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
      WHERE range_length IS NOT INITIAL.

      ls_hlpseg           = <ls_hlpseg>.

      DO.
        ls_hlpseg-period_to = sy-index * ls_hlpseg-range_length.

        IF ls_hlpseg-period_to >= <ls_hlpseg>-period_to.
          EXIT.
        ENDIF.

        CHECK  ls_hlpseg-period_to >= ls_hlpseg-period_from.

        APPEND ls_hlpseg TO lt_hlpseg.

        ls_hlpseg-period_from  = ls_hlpseg-period_to + 1.

* adjust from period of actual interval
        IF ls_hlpseg-period_from <= <ls_hlpseg>-period_to.
          <ls_hlpseg>-period_from  = ls_hlpseg-period_from.
        ELSE.
          <ls_hlpseg>-period_from  = ls_hlpseg-period_to.
        ENDIF.
      ENDDO.
    ENDLOOP.

* take over intervals created due to split
    CHECK NOT lt_hlpseg[] IS INITIAL.

    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

ENDMETHOD.


  METHOD _hlpseg_split_on_alignment .
************************************************************
*  completely reworked with note "2423741
************************************************************
* example:
*                                                    ( 46 42 )
*                                                    ( 46 43 )
*                                                    ( 46 44 )
*                ( 46 42 )                           ( 46 45 )
*                ( 46 43 )                           ( 47 42 )
*                ( 47 43 )                           ( 47 43 )
*  mt_virtarea = ( 47 44 )  -> lt_virtarea_aligned = ( 47 44 )
*                ( 48 44 )                           ( 47 45 )
*                ( 48 45 )                           ( 48 42 )
*                                                    ( 48 43 )
*                                                    ( 48 44 )
*                                                    ( 48 45 )
*
************************************************************
* PRECONDITION

* DEFINITION
    DATA lt_virtarea_s4                TYPE faa_ee_t_virtarea_s4.
    DATA lt_virtarea_s4_aligned        TYPE faa_ee_t_virtarea_s4.
    DATA lt_virtarea_s4_tmp            TYPE SORTED TABLE OF faa_ee_s_virtarea_s4 WITH UNIQUE KEY virt_depr_area virt_curr_type real_depr_area real_curr_type.
    DATA lt_period_to                  TYPE SORTED TABLE OF faa_ee_s_period      WITH UNIQUE KEY area period_to.
    DATA ls_period_to                  TYPE                 faa_ee_s_period.
    DATA lt_hlpseg                     TYPE ty_ts_hlpseg.
    DATA ls_hlpseg                     TYPE ty_s_hlpseg.
    DATA lv_count                      TYPE i.

  FIELD-SYMBOLS <ls_hlpseg>          TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_virtarea_s4>     TYPE faa_ee_s_virtarea_s4.

* BODY
* prepare alignment of period intervals of amount types S/Z/N within one area
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
      WHERE use_alignment IS NOT INITIAL
        AND amount_type   CA gc_amount_type+2(3).
      ls_period_to-area      = <ls_hlpseg>-area.
      ls_period_to-period_to = <ls_hlpseg>-period_to.
      INSERT ls_period_to INTO TABLE lt_period_to.
    ENDLOOP.

* clean up virtual areas - i.e. maybe reduce entries of mt_virtarea to lt_virtarea_relevant
    lt_virtarea_s4 = mt_virtarea_s4.
    LOOP AT lt_virtarea_s4 ASSIGNING <ls_virtarea_s4>.
*   No 'Sonderpostenanpassung Frankreich'
      READ TABLE ms_proc_data-leadobj_ref->get_list_depr_area( ) INTO DATA(ls_arearef)
         WITH KEY key_depr_area COMPONENTS depr_area = <ls_virtarea_s4>-virt_depr_area.
      IF ls_arearef-depr_area_ref->ms_setup-area_usage_ind = '2'.
        DELETE lt_virtarea_s4 WHERE virt_depr_area = <ls_virtarea_s4>-virt_depr_area.
        CONTINUE.
      ENDIF.
*   real area has to in HLP_SEG
      READ TABLE mts_hlpseg TRANSPORTING NO FIELDS
         WITH KEY area      = <ls_virtarea_s4>-real_depr_area
                  curr_type = <ls_virtarea_s4>-real_curr_type.
      IF sy-subrc IS NOT INITIAL.
        DELETE lt_virtarea_s4 WHERE virt_depr_area = <ls_virtarea_s4>-virt_depr_area.
        CONTINUE.
      ENDIF.
    ENDLOOP.

* I. prepare alignment:
* note: if a base area is assinged to multiple virt. areas
*       the alignment has to be done cross over all assigned base areas
* I.a. Starting criteria for while loop
    INSERT LINES OF lt_virtarea_s4 INTO TABLE lt_virtarea_s4_tmp.
    lt_virtarea_s4_aligned = lt_virtarea_s4_tmp.

    DATA(lb_insert_successful) = abap_true.
    WHILE lb_insert_successful = abap_true.
      lb_insert_successful = abap_false.
      LOOP AT lt_virtarea_s4_aligned INTO DATA(ls_virtarea_s4_aligned).
        LOOP AT lt_virtarea_s4 ASSIGNING <ls_virtarea_s4>
          WHERE real_depr_area EQ ls_virtarea_s4_aligned-real_depr_area
            AND real_curr_type EQ ls_virtarea_s4_aligned-real_curr_type.

          LOOP AT lt_virtarea_s4 INTO DATA(ls_virtarea_s4_tmp)
            WHERE virt_depr_area EQ <ls_virtarea_s4>-virt_depr_area
              AND virt_curr_type EQ <ls_virtarea_s4>-virt_curr_type.

            ls_virtarea_s4_tmp-virt_depr_area = ls_virtarea_s4_aligned-virt_depr_area.
            ls_virtarea_s4_tmp-virt_curr_type = ls_virtarea_s4_aligned-virt_curr_type.
            INSERT ls_virtarea_s4_tmp INTO TABLE lt_virtarea_s4_tmp.

            IF sy-subrc = 0. lb_insert_successful = abap_true. ENDIF.
          ENDLOOP.
        ENDLOOP.
      ENDLOOP.
* The alignment table will maybe enlarged
      lt_virtarea_s4_aligned = lt_virtarea_s4_tmp.
    ENDWHILE.

* II. get split information
    LOOP AT lt_virtarea_s4_aligned INTO ls_virtarea_s4_aligned.
      LOOP AT lt_virtarea_s4_aligned ASSIGNING FIELD-SYMBOL(<ls_virtarea_s4_aligned>)
        WHERE virt_depr_area = ls_virtarea_s4_aligned-virt_depr_area
          AND virt_curr_type = ls_virtarea_s4_aligned-virt_curr_type.
        LOOP AT me->mts_hlpseg ASSIGNING <ls_hlpseg>
          WHERE area      = <ls_virtarea_s4_aligned>-real_depr_area
            AND curr_type = <ls_virtarea_s4_aligned>-real_curr_type.
          ls_period_to-area      = ls_virtarea_s4_aligned-real_depr_area.
          ls_period_to-period_to = <ls_hlpseg>-period_to.
          INSERT ls_period_to INTO TABLE lt_period_to.
        ENDLOOP.
      ENDLOOP.
    ENDLOOP.

* III. perform interval split
    LOOP AT me->mts_hlpseg ASSIGNING <ls_hlpseg>.
      CHECK (     <ls_hlpseg>-amount_type EQ gc_amount_type-ordn " < 2612126
              OR  <ls_hlpseg>-amount_type EQ gc_amount_type-spec " < 2612126
              OR  <ls_hlpseg>-amount_type EQ gc_amount_type-intr ). " < 2612126

      CHECK <ls_hlpseg>-period_from <> <ls_hlpseg>-period_to.

      LOOP AT lt_period_to INTO ls_period_to
        WHERE area       = <ls_hlpseg>-area
          AND period_to >= <ls_hlpseg>-period_from
          AND period_to <  <ls_hlpseg>-period_to.

        ls_hlpseg           = <ls_hlpseg>.
        ls_hlpseg-period_to = ls_period_to-period_to.

        APPEND ls_hlpseg TO lt_hlpseg.

        <ls_hlpseg>-period_from = ls_period_to-period_to + 1.
      ENDLOOP.
    ENDLOOP.

    CHECK lt_hlpseg[] IS NOT INITIAL.
    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

ENDMETHOD.


  METHOD _hlpseg_split_on_cov_key.
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.
    FIELD-SYMBOLS <ls_minval>      TYPE ty_s_deprkey-minval.

    DATA lo_key_phase_ref          TYPE ty_s_hlpseg-key_phase_ref.

    DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

    DATA ls_minval                 TYPE ty_s_deprkey-minval.
    DATA ls_hlpseg                 TYPE ty_s_hlpseg.

    DATA lv_determination_rule     TYPE num1.
    DATA lv_valid_to_fyr           TYPE numc4.
    DATA lv_valid_to_yr            TYPE numc4.

    DATA lv_tabix_first            TYPE int4.
    DATA lv_tabix_valid            TYPE int4.

    DATA lv_base_date              TYPE dats.
    DATA lv_base_prd               TYPE numc3.
    DATA lv_base_fyr               TYPE numc4.
    DATA lv_base_yr                TYPE numc4.
    DATA lv_message                TYPE string.

* BODY
* determine index of valid cut of value table entry for each period interval
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
      WHERE NOT key_phase_ref->mts_minval[] IS INITIAL
        AND NOT phase                       =  0.

* check if more than one level assigned, if not => note index & leave loop
* if yes => determine valid entry for each period interval
      DESCRIBE TABLE  <ls_hlpseg>-key_phase_ref->mts_minval LINES sy-tfill.

      IF sy-tfill = 1.
        READ TABLE <ls_hlpseg>-key_phase_ref->mts_minval ASSIGNING <ls_minval> INDEX 1.

        IF <ls_minval>-validity_yrs = 999.
          <ls_hlpseg>-cutof_value_indx = 1.
          CONTINUE.
        ENDIF.
      ENDIF.

* get determination rule to be used for determination of expired periods at fiscal year start
* at new area/depr.key/phase determine -> valid to year for table access
*                                      -> expired periods up to year start
      IF lo_key_phase_ref <> <ls_hlpseg>-key_phase_ref.

        IF <ls_hlpseg>-use_days IS INITIAL.
          lv_determination_rule = 1.
        ELSE.
          lv_determination_rule = 2.
        ENDIF.

* determine base date for validity check of multi levels and already expired periods on fiscal year start
        CALL METHOD get_base_date_and_yr_and_prd
          EXPORTING
            is_hlpseg             = <ls_hlpseg>
            id_determination_rule = lv_determination_rule
            id_base_rule          = <ls_hlpseg>-key_phase_ref->ms_settings-minval_rule
          IMPORTING
            ed_base_date          = lv_base_date
            ed_base_prd           = lv_base_prd
            ed_base_yr            = lv_base_yr.


* prepare determination of expired periods up to actual year
        CHECK NOT lv_base_date IS INITIAL.

* determine first valid entry regarding the base year
        CLEAR lv_valid_to_fyr.
        CLEAR lv_valid_to_yr.

        LOOP AT <ls_hlpseg>-key_phase_ref->mts_minval ASSIGNING <ls_minval>
          WHERE valid_to_fyear GE <ls_hlpseg>-fyear
            AND valid_to_year  GE lv_base_yr.

          lv_valid_to_fyr = <ls_minval>-valid_to_fyear.
          lv_valid_to_yr  = <ls_minval>-valid_to_year.
          lv_tabix_first  = sy-tabix - 1.

          EXIT.
        ENDLOOP.

        IF sy-subrc <> 0.
          MESSAGE e608(aa) WITH <ls_hlpseg>-depr_key lv_base_fyr INTO lv_message.
          me->create_message_from_syst( ).
        ENDIF.
      ENDIF.

* note index of first valid entry regarding the validity year
      CHECK NOT lv_valid_to_yr IS INITIAL.

      ls_minval = <ls_minval>.

      CALL METHOD get_shifted_period_from_and_to
        EXPORTING
          id_determination_rule = lv_determination_rule
          id_base_date          = lv_base_date
          id_base_prd           = lv_base_prd
          id_base_fyr           = lv_base_yr
          is_hlpseg             = <ls_hlpseg>
        CHANGING
          cd_period_from        = ls_minval-period_from
          cd_period_to          = ls_minval-period_to.

* perform segment split if validity starts within segment
      IF ls_minval-period_from >  <ls_hlpseg>-period_from AND
         ls_minval-period_from <= <ls_hlpseg>-period_to.

        ls_hlpseg                  = <ls_hlpseg>.
        ls_hlpseg-period_to        = ls_minval-period_from - 1.

        APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of first valid entry
        <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.
      ENDIF.

* get start index of appropriate entries
      lv_tabix_valid = lv_tabix_first.

* get index of appropriate entry
      LOOP AT <ls_hlpseg>-key_phase_ref->mts_minval ASSIGNING <ls_minval>
        WHERE valid_to_fyear = lv_valid_to_fyr
          AND valid_to_year  = lv_valid_to_yr.

        <ls_hlpseg>-cutof_value_indx = sy-tabix.

        lv_tabix_valid = lv_tabix_valid + 1.

        ls_minval = <ls_minval>.

        CALL METHOD get_shifted_period_from_and_to
          EXPORTING
            id_determination_rule = lv_determination_rule
            id_base_date          = lv_base_date
            id_base_prd           = lv_base_prd
            id_base_fyr           = lv_base_fyr
            is_hlpseg             = <ls_hlpseg>
          CHANGING
            cd_period_from        = ls_minval-period_from
            cd_period_to          = ls_minval-period_to.

        IF ls_minval-period_from IS INITIAL AND
           ls_minval-period_to   IS INITIAL.
          CONTINUE.
        ENDIF.                                                      "

        IF <ls_hlpseg>-period_from > ls_minval-period_to.
          CONTINUE.
        ENDIF.

        IF <ls_hlpseg>-period_to <= ls_minval-period_to.

          <ls_hlpseg>-cutof_value_indx = lv_tabix_valid.

          EXIT.
        ENDIF.

* entry valid for whole segment => note index, leave loop
        IF <ls_hlpseg>-period_from >= ls_minval-period_from AND
           <ls_hlpseg>-period_to   <= ls_minval-period_to.

          <ls_hlpseg>-cutof_value_indx = lv_tabix_valid.

          EXIT.
        ENDIF.

* segment split to be performed as entry is just valid for part of segment
        ls_hlpseg                  = <ls_hlpseg>.

        ls_hlpseg-period_to        = ls_minval-period_to.
        ls_hlpseg-cutof_value_indx = lv_tabix_valid.

        APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of next valid entry
        <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.
      ENDLOOP.
    ENDLOOP.

* take over segments created due to split
    CHECK NOT lt_hlpseg[] IS INITIAL.

    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_split_on_digital.
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_hlpseg>    TYPE ty_s_hlpseg.

    DATA lt_hlpseg               TYPE ty_ts_hlpseg.
    DATA ls_hlpseg               TYPE ty_s_hlpseg.
    DATA lv_covered_prds         TYPE i.
    DATA lv_expired_prds         TYPE i.
    DATA lv_actual_year          TYPE i.
    DATA lv_expired_years        TYPE i.
    DATA lv_periods              TYPE i.
    DATA lb_perform_split        TYPE c.

* BODY
* check if segement split to be performed on sum of the digits method
    READ TABLE mts_hlpseg TRANSPORTING NO FIELDS
       WITH KEY key_phase_ref->ms_settings-percent_key = gc_percent-key_a.

    CHECK sy-subrc = 0.

* to insure that "AT NEW" works correctly just regard affected segments
    lt_hlpseg[] = mts_hlpseg[].

    DELETE lt_hlpseg
     WHERE key_phase_ref->ms_settings-percent_key  <> gc_percent-key_a.

    DELETE mts_hlpseg
      WHERE key_phase_ref->ms_settings-percent_key  = gc_percent-key_a.

* split segments if there is more than one period covered within
    LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>.
      AT NEW amount_type.
        lv_expired_years = <ls_hlpseg>-exp_life DIV <ls_hlpseg>-periods.
        lv_expired_prds  = <ls_hlpseg>-exp_life.
        lb_perform_split = abap_true.
      ENDAT.

* insure that spilt is just done on first segment in new UL year
      CHECK NOT lb_perform_split IS INITIAL.

      lv_expired_prds = lv_expired_prds + <ls_hlpseg>-exp_life_seg.

* get year of useful life covered by segment
      lv_actual_year  = lv_expired_prds DIV <ls_hlpseg>-periods.

* perfrom split on first segment of new year of useful life
      CHECK lv_actual_year <> lv_expired_years.
      CLEAR lb_perform_split.

* no split required if segment covers just one period
      CHECK  <ls_hlpseg>-period_to <> <ls_hlpseg>-period_from.

* get count of periods which belong already to new year of useful life
      lv_periods = lv_expired_prds MOD <ls_hlpseg>-periods.

* determine periods which belong to previous year of useful life
      lv_periods = <ls_hlpseg>-exp_life_seg - lv_periods.

* determine count of periods covered by segment
      lv_covered_prds = <ls_hlpseg>-period_to
                      - <ls_hlpseg>-period_from + 1.

      ls_hlpseg = <ls_hlpseg>.

* perfrom segment split
      DO lv_covered_prds TIMES.
        CALL METHOD get_expired_life_for_interval
          CHANGING
            cs_hlpseg = ls_hlpseg.

* get expired life regarding actual "to period"
        ls_hlpseg-period_to = ls_hlpseg-period_from + sy-index - 1.

        CALL METHOD get_expired_life_for_interval
          CHANGING
            cs_hlpseg = ls_hlpseg.

* segment split is to be performed if exp. periods exceed remaining
* periods of previous fiscal year
        CHECK ls_hlpseg-exp_life_seg > lv_periods.

* first create segment with new final "to period".
        ls_hlpseg-period_to = ls_hlpseg-period_from + sy-index - 2.

        CALL METHOD get_expired_life_for_interval
          CHANGING
            cs_hlpseg = ls_hlpseg.

        APPEND ls_hlpseg TO mts_hlpseg.

* second create segment with new "from period".
        ls_hlpseg-period_from  = ls_hlpseg-period_to + 1.
        ls_hlpseg-period_to    = <ls_hlpseg>-period_to.

        CALL METHOD get_expired_life_for_interval
          CHANGING
            cs_hlpseg = ls_hlpseg.

        APPEND ls_hlpseg TO mts_hlpseg.

* delete original segment
        DELETE lt_hlpseg.
        EXIT.
      ENDDO.
    ENDLOOP.

* take over segments not affected by split
    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_split_on_mlm.
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_multilevl>   TYPE ty_s_deprkey-multilevel.
    FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

    DATA lo_key_phase_ref          TYPE ty_s_hlpseg-key_phase_ref.

    DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

    DATA ls_multilevl              TYPE ty_s_deprkey-multilevel.
    DATA ls_hlpseg                 TYPE ty_s_hlpseg.

    DATA lv_determination_rule     TYPE num1.
    DATA lv_valid_to_yr            TYPE numc4.

    DATA lv_tabix_first            TYPE int4.
    DATA lv_tabix_valid            TYPE int4.
    DATA lv_message                TYPE string.

    DATA lv_base_date              TYPE dats.
    DATA lv_base_prd               TYPE numc3.
    DATA lv_base_fyr               TYPE numc4.
    DATA lv_base_yr                TYPE numc4.

* BODY
* get appropriate multi level entry for each period interval, if needed perform interval split
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
      WHERE key_phase_ref->ms_settings-multi_level_date EQ space
        AND phase                                       <> 0.

      CHECK (   <ls_hlpseg>-amount_type EQ gc_amount_type-ordn "    < 2655920
            OR  <ls_hlpseg>-amount_type EQ gc_amount_type-spec "    < 2655920
            OR  <ls_hlpseg>-amount_type EQ gc_amount_type-intr ). " < 2655920

* check if more than one level assigned, if not => note index & leave loop
* if yes => determine valid entry for each period interval
      DESCRIBE TABLE  <ls_hlpseg>-key_phase_ref->mts_multilevel LINES sy-tfill.

      IF sy-tfill = 1.
        READ TABLE <ls_hlpseg>-key_phase_ref->mts_multilevel ASSIGNING <ls_multilevl> INDEX 1.

        IF <ls_multilevl>-validity_yrs = 999.
          <ls_hlpseg>-multi_level_indx = 1.
          CONTINUE.
        ENDIF.
      ENDIF.

* at new area/depr.key/phase determine -> valid to year for table access
*                                      -> expired periods up to year start
      IF lo_key_phase_ref <> <ls_hlpseg>-key_phase_ref.

* get determination rule to be used for determination of expired periods at fiscal year start
        IF <ls_hlpseg>-key_phase_ref->ms_settings-use_fiscal_year IS INITIAL.
          IF <ls_hlpseg>-use_days IS INITIAL.
            lv_determination_rule = 1.
          ELSE.
            lv_determination_rule = 2.
          ENDIF.

* fiscal year based determination required
        ELSE.
          lv_determination_rule = 3.
        ENDIF.

* determine base date, period and fiscal year for validity check of multi levels
        CALL METHOD get_base_date_and_yr_and_prd
          EXPORTING
            is_hlpseg             = <ls_hlpseg>
            id_determination_rule = lv_determination_rule
            id_base_rule          = <ls_hlpseg>-key_phase_ref->ms_settings-multi_level_rule
          IMPORTING
            ed_base_date          = lv_base_date
            ed_base_prd           = lv_base_prd
            ed_base_fyr           = lv_base_fyr
            ed_base_yr            = lv_base_yr.

* prepare determination of expired periods up to actual year
        CHECK NOT lv_base_date IS INITIAL.

* determine first valid entry regarding the base year
        CLEAR lv_valid_to_yr.

        READ TABLE <ls_hlpseg>-key_phase_ref->mts_multilevel ASSIGNING <ls_multilevl>
              WITH KEY valid_to_date = gc_date-no_date
                       valid_to_yr   = lv_base_yr.

        CASE sy-subrc.
          WHEN 0.
            lv_valid_to_yr = <ls_multilevl>-valid_to_yr.

          WHEN 4.
            READ TABLE <ls_hlpseg>-key_phase_ref->mts_multilevel ASSIGNING <ls_multilevl> INDEX sy-tabix.
            lv_valid_to_yr = <ls_multilevl>-valid_to_yr.

          WHEN 8.
            MESSAGE e651(aa) WITH <ls_hlpseg>-depr_key <ls_hlpseg>-phase lv_base_yr INTO lv_message.
            me->create_message_from_syst( ).
        ENDCASE.

* note index of first valid entry regarding the validity year
        lv_tabix_first = sy-tabix - 1.
      ENDIF.

* determine numer of expired periods for from and to period of interval
      CHECK NOT lv_valid_to_yr IS INITIAL.

      ls_multilevl = <ls_multilevl>.

*      IF lv_determination_rule = 2.
      CALL METHOD get_shifted_period_from_and_to
        EXPORTING
          id_determination_rule = lv_determination_rule
          id_base_date          = lv_base_date
          id_base_prd           = lv_base_prd
          id_base_fyr           = lv_base_fyr
          is_hlpseg             = <ls_hlpseg>
        CHANGING
          cd_period_from        = ls_multilevl-period_from
          cd_period_to          = ls_multilevl-period_to.

* perform segment split if validity starts within segment
      IF ls_multilevl-period_from >  <ls_hlpseg>-period_from AND
         ls_multilevl-period_from <= <ls_hlpseg>-period_to.

        ls_hlpseg                  = <ls_hlpseg>.
        ls_hlpseg-period_to        = ls_multilevl-period_from - 1.

        APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of first valid entry
        <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.
      ENDIF.

* get start index of appropriate entries
      lv_tabix_valid = lv_tabix_first.

      "
* determine valid entry for each period interval
* if needed segment split is performed considering the valid to period of the valid entry
      DO.
        LOOP AT <ls_hlpseg>-key_phase_ref->mts_multilevel ASSIGNING <ls_multilevl>
           WHERE valid_to_yr = lv_valid_to_yr.

          lv_tabix_valid = lv_tabix_valid + 1.

          ls_multilevl = <ls_multilevl>.

          CALL METHOD get_shifted_period_from_and_to
            EXPORTING
              id_determination_rule = lv_determination_rule
              id_base_date          = lv_base_date
              id_base_prd           = lv_base_prd
              id_base_fyr           = lv_base_fyr
              is_hlpseg             = <ls_hlpseg>
            CHANGING
              cd_period_from        = ls_multilevl-period_from
              cd_period_to          = ls_multilevl-period_to.

          IF  ls_multilevl-period_from IS INITIAL AND
              ls_multilevl-period_to   IS INITIAL.
            CONTINUE.
          ENDIF.

          IF <ls_hlpseg>-period_from > ls_multilevl-period_to.
            CONTINUE.
          ENDIF.

          IF <ls_hlpseg>-period_to <= ls_multilevl-period_to.

            <ls_hlpseg>-multi_level_indx = lv_tabix_valid.

            EXIT.
          ENDIF.

* entry valid for whole segment => note index, leave loop
          IF <ls_hlpseg>-period_from >= ls_multilevl-period_from AND
             <ls_hlpseg>-period_to   <= ls_multilevl-period_to.

            <ls_hlpseg>-multi_level_indx = lv_tabix_valid.

            EXIT.
          ENDIF.

* segment split to be performed as entry is just valid for part of segment
          ls_hlpseg                  = <ls_hlpseg>.

          ls_hlpseg-period_to        = ls_multilevl-period_to.
          ls_hlpseg-multi_level_indx = lv_tabix_valid.

          APPEND ls_hlpseg TO lt_hlpseg.

* prepare determination of next valid entry
          <ls_hlpseg>-period_from    = ls_hlpseg-period_to + 1.

        ENDLOOP.

*<<<<< start of insertion note 1467704 >>>>>*
        IF  <ls_hlpseg>-multi_level_indx > 0.
          EXIT.
        ENDIF.

        IF lv_tabix_valid = lines( <ls_hlpseg>-key_phase_ref->mts_multilevel ).
          EXIT.
        ENDIF.

        sy-tabix = lv_tabix_valid + 1.

        READ TABLE <ls_hlpseg>-key_phase_ref->mts_multilevel ASSIGNING <ls_multilevl> INDEX sy-tabix.
        lv_valid_to_yr = <ls_multilevl>-valid_to_yr.

      ENDDO.
    ENDLOOP.

* take over new intervalls created due to split
    CHECK NOT lt_hlpseg[] IS INITIAL.

    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_split_on_mlm_dat .
* PRECONDITION

* DEFINITION
  DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

    DATA ls_hlpseg                 TYPE ty_s_hlpseg.

    DATA lv_date_from              TYPE dats.
    DATA lv_date_to                TYPE dats.
    DATA lv_tabix                  TYPE sytabix.

  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_multilevl>   TYPE ty_s_deprkey-multilevel.

* BODY
* get appropriate index of multi level if mor than one level within period interval split segment
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
     WHERE NOT key_phase_ref->ms_settings-multi_level_date EQ space
       AND NOT period_to                                   IS INITIAL
       AND NOT phase                                       EQ 0
       AND NOT phase                                       GT 3.

* determine covered date interval of period interval
      IF <ls_hlpseg>-use_days IS INITIAL.
        CALL METHOD <ls_hlpseg>-arearef->get_first_day_in_period
          EXPORTING
            iv_fisc_year = <ls_hlpseg>-fyear
            iv_period    = <ls_hlpseg>-period_from
          IMPORTING
            ev_first_day = lv_date_from.

        CALL METHOD <ls_hlpseg>-arearef->get_last_day_in_period
          EXPORTING
            iv_fisc_year = <ls_hlpseg>-fyear
            iv_period    = <ls_hlpseg>-period_to
          IMPORTING
            ev_last_day  = lv_date_to.
      ELSE.
        lv_date_from = <ls_hlpseg>-first_day_in_yr + <ls_hlpseg>-period_from - 1.
        lv_date_to   = <ls_hlpseg>-first_day_in_yr + <ls_hlpseg>-period_to   - 1.
      ENDIF.

* get appropriate level(s)
      LOOP AT <ls_hlpseg>-key_phase_ref->mts_multilevel ASSIGNING <ls_multilevl>.
        CHECK <ls_multilevl>-valid_to_date > lv_date_from.
        lv_tabix = sy-tabix.

* level is valid for complete segment as validity date is behind period
        IF lv_date_to <= <ls_multilevl>-valid_to_date.

          <ls_hlpseg>-multi_level_indx = lv_tabix.
          EXIT.
        ENDIF.

* level is valid only for part of actual segment => perform split
        IF lv_date_to > <ls_multilevl>-valid_to_date.
          ls_hlpseg = <ls_hlpseg>.

          IF <ls_hlpseg>-use_days IS INITIAL.
            CALL METHOD <ls_hlpseg>-arearef->get_period_and_year
              EXPORTING
                iv_date   = <ls_multilevl>-valid_to_date
              IMPORTING
                ev_period = ls_hlpseg-period_to.

          ELSE.
            ls_hlpseg-period_to = <ls_multilevl>-valid_to_date - ls_hlpseg-first_day_in_yr + 1.
          ENDIF.

* level is valid for complete segment accord. to period determination
          IF ls_hlpseg-period_to = <ls_hlpseg>-period_to.
            <ls_hlpseg>-multi_level_indx = lv_tabix.
            EXIT.
          ENDIF.

* perform segment split
          ls_hlpseg-multi_level_indx = lv_tabix.

          APPEND ls_hlpseg TO lt_hlpseg.

* adjust from period of actual segment due to split
          <ls_hlpseg>-period_from = ls_hlpseg-period_to + 1.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

* take over segments created due to split
    CHECK NOT lt_hlpseg[] IS INITIAL.

    APPEND LINES OF lt_hlpseg TO mts_hlpseg.

    SORT mts_hlpseg.

* POSTCONDITION

  ENDMETHOD.


  METHOD _hlpseg_split_on_timeseg.
* PRECONDITION
  CHECK NOT mt_timeseg[] IS INITIAL.

* DEFINITION
  DATA ls_hlpseg               TYPE ty_s_hlpseg.

  FIELD-SYMBOLS <ls_hlpseg>    TYPE ty_s_hlpseg.
  FIELD-SYMBOLS <ls_timeseg>   TYPE ty_s_timeseg.

* BODY
* perform split if there are TIMESEGs w. PERIOD_TO within ex. intervals
    LOOP AT mt_timeseg[] ASSIGNING <ls_timeseg>.

* check if PERIOD_TO lies within an interval covered in HLPSEG
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>
          WHERE area         = <ls_timeseg>-area
            AND curr_type    = <ls_timeseg>-curr_type
            AND amount_type  = <ls_timeseg>-amount_type
            AND period_to    > <ls_timeseg>-period_to
            AND period_from <= <ls_timeseg>-period_to.

* perform segment split
        ls_hlpseg           = <ls_hlpseg>.
        ls_hlpseg-period_to = <ls_timeseg>-period_to.

        APPEND ls_hlpseg TO mts_hlpseg.

* adjust from period of actual segment
        <ls_hlpseg>-period_from  = <ls_timeseg>-period_to + 1.

        EXIT.
      ENDLOOP.
    ENDLOOP.

    SORT mts_hlpseg.

* POSTCONDITION

ENDMETHOD.


  METHOD _parameter_call_badi.

* PRECONDITION
    CHECK go_badi_customer IS BOUND
       OR go_badi_country  IS BOUND.

* DEFINITION
    TYPES: BEGIN OF ty_s_parameter_copy,
             baseval_factor    TYPE faa_ee_s_parameter-baseval_factor,
             baseval_key       TYPE faa_ee_s_parameter-baseval_key,
             baseval_fact_add  TYPE faa_ee_s_parameter-baseval_fact_add,
             baseval_stated    TYPE faa_ee_s_parameter-baseval_stated,
             percent_stated    TYPE faa_ee_s_parameter-percent_stated,
             percent_factor    TYPE faa_ee_s_parameter-percent_factor,
             percent_key       TYPE faa_ee_s_parameter-percent_key,
             amount_factor     TYPE faa_ee_s_parameter-amount_factor,
             minval_percent    TYPE faa_ee_s_parameter-minval_percent,
             minval_stated     TYPE faa_ee_s_parameter-minval_stated,
             minval_memo       TYPE faa_ee_s_parameter-minval_memo,         "added for usage in Cloud BAdI
             minval_tolerance  TYPE faa_ee_s_parameter-minval_tolerance,
             minval_rndmethod  TYPE faa_ee_s_parameter-minval_rndmethod,
             minval_rndplace   TYPE faa_ee_s_parameter-minval_rndplace,
             minval_rnddecim   TYPE faa_ee_s_parameter-minval_rnddecim,
             minval_key        TYPE faa_ee_s_parameter-minval_key,
             minval_perc_add   TYPE faa_ee_s_parameter-minval_perc_add,
             minval_stated_add TYPE faa_ee_s_parameter-minval_stated_add,
             rounding_off      TYPE faa_ee_s_parameter-rounding_off,
             check_amount      TYPE faa_ee_s_parameter-check_amount,
           END OF ty_s_parameter_copy.

    FIELD-SYMBOLS <ls_parameter>   TYPE ty_s_parameter.
    FIELD-SYMBOLS <ls_area>        TYPE if_faa_depr_calc_types=>ty_s_area.

    DATA lo_segment_handle         TYPE faa_dc_segment_handle.
    DATA lt_parameter              TYPE ty_t_parameter.
    DATA ls_parameter              TYPE ty_s_parameter.
    DATA ls_parameter_copy         TYPE ty_s_parameter_copy.
    DATA ls_hlpseg       TYPE faa_dc_s_hlpseg.

* BODY
* CHECK if PROCESSING required AT all
    CHECK mt_parameter IS NOT INITIAL.

    READ TABLE mts_hlpseg INTO ls_hlpseg INDEX 1.

    me->prepare_badi_call( CHANGING co_dc_segment_handle = lo_segment_handle ).

    READ TABLE mts_area INDEX 1 ASSIGNING <ls_area>.

* call country specific BADI for change of PARAMETER data
    IF go_badi_country IS BOUND.
      CALL METHOD go_badi_country->set_parameter
        EXPORTING
          flt_val        = <ls_area>-arearef->mo_leadobj->get_setup( )-country
          io_handle      = lo_segment_handle
          it_parameter   = mt_parameter
          its_hlpseg     = mts_hlpseg
        CHANGING
          ct_parameter   = lt_parameter
        EXCEPTIONS
          error_occurred = 4.

      IF sy-subrc <> 0.                                     "2244188
        CALL METHOD create_message_from_syst.
      ENDIF.

* take over changes
      LOOP AT lt_parameter INTO ls_parameter.
        READ TABLE mt_parameter ASSIGNING <ls_parameter>
          WITH KEY fyear       = ls_parameter-fyear
                   area        = ls_parameter-area
                   curr_type   = ls_parameter-curr_type
                   amount_type = ls_parameter-amount_type
                   period_to   = ls_parameter-period_to.

        CHECK sy-subrc = 0.
        CLEAR ls_parameter_copy.
        MOVE-CORRESPONDING ls_parameter      TO ls_parameter_copy.
        MOVE-CORRESPONDING ls_parameter_copy TO <ls_parameter>.
      ENDLOOP.
    ENDIF.

* call customer specific BADI for change of PARAMETER data
    IF go_badi_customer  IS BOUND.
      CALL METHOD go_badi_customer->set_parameter
        EXPORTING
          io_handle      = lo_segment_handle
          it_parameter   = mt_parameter
          its_hlpseg     = mts_hlpseg
        CHANGING
          ct_parameter   = lt_parameter
        EXCEPTIONS
          error_occurred = 4.

      IF sy-subrc <> 0.                                     "2244188
        CALL METHOD create_message_from_syst.
      ENDIF.

* take over changes
      LOOP AT lt_parameter INTO ls_parameter.
        READ TABLE mt_parameter ASSIGNING <ls_parameter>
          WITH KEY fyear       = ls_parameter-fyear
                   area        = ls_parameter-area
                   curr_type   = ls_parameter-curr_type
                   amount_type = ls_parameter-amount_type
                   period_to   = ls_parameter-period_to.

        CHECK sy-subrc = 0.
        CLEAR ls_parameter_copy.
        MOVE-CORRESPONDING ls_parameter      TO ls_parameter_copy.
        MOVE-CORRESPONDING ls_parameter_copy TO <ls_parameter>.
      ENDLOOP.

* call BaDI implementation to get leasing parameters "2368005
      CLEAR lt_parameter.
      CALL METHOD go_badi_customer->provide_parameter_4_lease_calc
        EXPORTING
          io_handle      = me
          it_parameter   = mt_parameter
          its_hlpseg     = mts_hlpseg
        CHANGING
          ct_parameter   = lt_parameter
        EXCEPTIONS
          error_occurred = 4.

      IF sy-subrc <> 0.
        CALL METHOD create_message_from_syst.
      ENDIF.

* take over changes
      LOOP AT lt_parameter INTO ls_parameter.
        READ TABLE mt_parameter ASSIGNING <ls_parameter>
          WITH KEY fyear       = ls_parameter-fyear
                   area        = ls_parameter-area
                   curr_type   = ls_parameter-curr_type
                   amount_type = ls_parameter-amount_type
                   period_to   = ls_parameter-period_to.

        CHECK sy-subrc = 0.
        <ls_parameter>-leas_paymt_cycle = ls_parameter-leas_paymt_cycle.
        <ls_parameter>-leas_no_payments = ls_parameter-leas_no_payments.
        <ls_parameter>-leas_intrst_rate = ls_parameter-leas_intrst_rate.
        <ls_parameter>-leas_per_payment = ls_parameter-leas_per_payment.
        <ls_parameter>-leas_adv_payment = ls_parameter-leas_adv_payment.
      ENDLOOP.                                              "2368005
    ENDIF.

* POSTCONDITION

  ENDMETHOD.


  METHOD _parameter_create.
* PRECONDITION
    CHECK mt_parameter[] IS INITIAL.

* DEFINITION
    FIELD-SYMBOLS <ls_multilevl>     TYPE ty_s_deprkey-multilevel.
    FIELD-SYMBOLS <ls_maxamount>     TYPE ty_s_deprkey-maxamount.
    FIELD-SYMBOLS <ls_minval>        TYPE ty_s_deprkey-minval.
    FIELD-SYMBOLS <ls_hlpseg>        TYPE ty_s_hlpseg.
    FIELD-SYMBOLS <lo_key_phase_ref> TYPE ty_s_hlpseg-key_phase_ref.

    DATA ls_cfg_rounding           TYPE ty_s_deprarea-rounding.
    DATA ls_param                  TYPE ty_s_parameter.
* BODY
* create table PARAMETER from HLPSEG
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
* fill key fields of PARAMETER
      CLEAR ls_param.
      ls_param-fyear           = <ls_hlpseg>-fyear.
      ls_param-area            = <ls_hlpseg>-area.
      ls_param-amount_type     = <ls_hlpseg>-amount_type.
      ls_param-curr_type       = <ls_hlpseg>-curr_type.
      ls_param-period_to       = <ls_hlpseg>-period_to.

* set default value of calculation factors to 1.0
      ls_param-baseval_factor  = 1.
      ls_param-percent_factor  = 1.

      ls_param-use_days        = <ls_hlpseg>-use_days.
      ls_param-baseval_key     = <ls_hlpseg>-baseval_key.
      ls_param-base_add_key    = <ls_hlpseg>-base_add_key.
      ls_param-percent_key     = <ls_hlpseg>-percent_key.
      ls_param-percent_stated  = <ls_hlpseg>-percent_stated.
* set lease data
      ls_param-leas_paymt_cycle = <ls_hlpseg>-leas_paymt_cycle.
      ls_param-leas_no_payments = <ls_hlpseg>-leas_no_payments.
      ls_param-leas_intrst_rate = <ls_hlpseg>-leas_intrst_rate.
      ls_param-leas_per_payment = <ls_hlpseg>-leas_per_payment.
      ls_param-leas_adv_payment = <ls_hlpseg>-leas_adv_payment.

* on amount types A & C & I just take over the parameters for calc. from HLPSEG
      CASE <ls_hlpseg>-amount_type.
        WHEN gc_amount_type-infl
          OR gc_amount_type-rage
          OR gc_amount_type-repl.

          APPEND ls_param TO mt_parameter.
          CONTINUE.

* on amount types N & S & Z no calculation if there was a customizing error
        WHEN gc_amount_type-ordn
          OR gc_amount_type-spec
          OR gc_amount_type-intr.

          IF <ls_hlpseg>-key_phase_ref IS NOT BOUND.
            APPEND ls_param TO mt_parameter.
            CONTINUE.
          ENDIF.

        WHEN OTHERS.
          APPEND ls_param TO mt_parameter.
          CONTINUE.
      ENDCASE.

* create initial segment if group asset is assigned for area
      IF NOT <ls_hlpseg>-grp_asset_assgnd IS INITIAL.
        APPEND ls_param TO mt_parameter.
        CONTINUE.
      ENDIF.

* segment before start period
      IF <ls_hlpseg>-phase = 0.
        APPEND ls_param TO mt_parameter.
        CONTINUE.
      ENDIF.

* no multi level entry assigne => leave to avoid dump
      IF <ls_hlpseg>-multi_level_indx = 0.
        APPEND ls_param TO mt_parameter.
        CONTINUE.
      ENDIF.

* get calculation parameters from configuration
      CHECK  <ls_hlpseg>-key_phase_ref IS BOUND.
      ASSIGN <ls_hlpseg>-key_phase_ref TO <lo_key_phase_ref>.

* check if depreciation to be calculated after end of useful life
      IF <ls_hlpseg>-is_behind_ul = abap_true.
        IF <lo_key_phase_ref>->ms_settings-calc_after_end IS INITIAL.

          APPEND ls_param TO mt_parameter.
          CONTINUE.
        ENDIF.
      ENDIF.

* get appropriate multi level percentage
      READ TABLE <lo_key_phase_ref>->mts_multilevel
        ASSIGNING <ls_multilevl>
        INDEX <ls_hlpseg>-multi_level_indx.

      ls_param-baseval_key = <ls_multilevl>-basevalue_key.

* get paramter according to dedicated base value keys
      CASE ls_param-baseval_key.

* get max base value (luxury cars)
        WHEN gc_basevalue-key_05.
          CALL METHOD <lo_key_phase_ref>->get_max_basevalue
            EXPORTING
              iv_asset_class = <ls_hlpseg>-assetclass
              iv_valid_to    = <ls_hlpseg>-cap_date
            RECEIVING
              rv_baseval_max = ls_param-baseval_max.

* asset individual basevalue reduction percentage is delivered by BADI
        WHEN gc_basevalue-key_28.

* Real Estate Leasing
        WHEN faacc_basevalue_key-29. "note_2297363
          CALL METHOD cl_faa_dc_segments_services=>get_leasing_depreciation
            EXPORTING
              is_asset_key      = mo_start->ms_asset_data-s_asset_key
              is_hlpseg         = <ls_hlpseg>
            CHANGING
              cv_baseval_stated = ls_param-baseval_stated.

          ls_param-rounding_off = abap_true.

* special treatment of acq. from transfer is done in method _TIMESEG_CREATE
        WHEN gc_basevalue-key_40.
      ENDCASE.

      ls_param-baseval_factor = ls_param-baseval_factor - <ls_multilevl>-baseval_reductn / 100.

      IF ls_param-baseval_factor < 0.
        ls_param-baseval_factor = 0.
      ENDIF.

* get depreciation percentage if stated
      ls_param-percent_key = <lo_key_phase_ref>->ms_settings-percent_key.

      CASE ls_param-percent_key.
        WHEN gc_percent-key_p.
          ls_param-percent_stated = <ls_multilevl>-percentage_rate
                                  / 100.
        WHEN gc_percent-key_g.
          ls_param-percent_stated = <ls_multilevl>-percentage_rate
                                  / 100.
        WHEN gc_percent-key_d.
          IF NOT <ls_multilevl>-use_remain_life IS INITIAL.
            ls_param-percent_key = gc_percent-key_r.
          ENDIF.

* get percentage from units of production
        WHEN gc_percent-key_s
          OR gc_percent-key_t.
          CALL METHOD get_prcntg_on_units_of_prod
            EXPORTING
              is_parameter   = ls_param
              is_hlpseg      = <ls_hlpseg>
*            id_fisc_year   = <ls_hlpseg>-fyear
*            id_period_from = <ls_hlpseg>-period_from
*            id_period_to   = <ls_hlpseg>-period_to
            IMPORTING
              ed_percentage  = ls_param-percent_stated.

* Do not round in case of complete depreciation, otherwise net book value will remain on asset
        WHEN gc_percent-key_v.
          IF ls_param-baseval_factor EQ 1.
            ls_param-rounding_off = abap_true.
          ENDIF.
      ENDCASE.

* Provide stated percentage from multilevel method for BAdI implementations
      IF ( ls_param-percent_key BETWEEN gc_percent-key_x  AND  gc_percent-key_z ) OR
         ( ls_param-percent_key BETWEEN gc_percent-key_1  AND  gc_percent-key_9 ).
        ls_param-percent_stated = <ls_multilevl>-percentage_rate
                                / 100.
      ENDIF.

* get maximum and minimum percentage
      ls_param-percent_max = <lo_key_phase_ref>->ms_settings-percent_max / 100.
      ls_param-percent_min = <lo_key_phase_ref>->ms_settings-percent_min / 100.

* get multiplication factor if any
      IF <lo_key_phase_ref>->ms_settings-percent_factor > 0.
        ls_param-percent_factor = <lo_key_phase_ref>->ms_settings-percent_factor.
      ENDIF.

      IF ls_param-percent_factor < 0.
        ls_param-percent_factor = 0.
      ENDIF.

* get decimal places for rounding of percentage
      ls_param-percent_round = <lo_key_phase_ref>->ms_settings-percent_round.

      ls_param-amount_factor = 1.

* get factor to be applied on calculated depr. considering the usage
      CASE <ls_hlpseg>-usage_impact_ind.

* usage not to be regarded at all, if any
        WHEN 0.

* no calculation of depreciation as time interval is shut down
        WHEN 1.
          ls_param-amount_factor = 0.

* is already covered within AMOUNT_FACTOR
        WHEN 3
          OR 7 .
          ls_param-amount_factor = <ls_hlpseg>-amount_factor.
      ENDCASE.

* correct negative amount factor as this is not possible
      IF ls_param-amount_factor < 0.
        ls_param-amount_factor = 0.
      ENDIF.

* get maximum amount of depr. for year or in total
      READ TABLE <ls_hlpseg>-arearef->mo_leadobj->get_list_currency( ) WITH KEY currency_type = <ls_hlpseg>-curr_type INTO DATA(ls_currency).
      ASSERT sy-subrc = 0.
      LOOP AT <ls_hlpseg>-key_phase_ref->mts_maxamount ASSIGNING <ls_maxamount>
        WHERE valid_to_date >= <ls_hlpseg>-last_day_in_yr
          AND currency       = ls_currency-currency.
        ls_param-amount_max      = <ls_maxamount>-amount_max.
        ls_param-use_year_amount = <lo_key_phase_ref>->ms_settings-use_year_amount.
        EXIT.
      ENDLOOP.

* get indicator if ordinary depr./interest to be calculated at all
      CASE ls_param-amount_type.
        WHEN gc_amount_type-ordn.
          ls_param-skip_amount = <lo_key_phase_ref>->ms_settings-no_depr_o.

        WHEN gc_amount_type-intr.
          ls_param-skip_amount = <lo_key_phase_ref>->ms_settings-no_interest.
      ENDCASE.

* takeover scrap value / scrap value percentage
      ls_param-minval_percent  = <ls_hlpseg>-scrapvalue_prctg / 100.

      IF ls_param-minval_percent IS INITIAL.
        ls_param-minval_stated   = <ls_hlpseg>-scrapvalue.
      ENDIF.

* get maximum amout of scrap value and memo value
      IF <ls_hlpseg>-ignore_memval IS INITIAL.
      "begin of 3072922
*     ls_param-minval_memo  = <ls_hlpseg>-arearef->ms_setup-memo_value.
      ls_param-minval_memo  = _get_arearef_4_currtype( iv_curr_type = <ls_hlpseg>-curr_type io_arearef = <ls_hlpseg>-arearef )->ms_setup-memo_value.
      "end of 3072922
      ENDIF.

* get cut off value if any assigned
      IF ls_param-minval_percent = 0 AND
         ls_param-minval_stated  = 0.
        IF NOT <ls_hlpseg>-cutof_value_indx IS INITIAL.
          READ TABLE <lo_key_phase_ref>->mts_minval ASSIGNING <ls_minval>
            INDEX <ls_hlpseg>-cutof_value_indx.

          ls_param-minval_percent = <ls_minval>-min_value_percnt / 100.
        ENDIF.
      ENDIF.

* get add. parameters for minimum value consideration
      IF ls_param-minval_percent <> 0 OR
         ls_param-minval_stated  <> 0.

        IF <ls_hlpseg>-amount_type = gc_amount_type-ordn OR
           <ls_hlpseg>-amount_type = gc_amount_type-spec.

* set rounding parameters for calculated minimum value
          ls_cfg_rounding = <ls_hlpseg>-arearef->get_rounding(
                              iv_curr_type   = <ls_hlpseg>-curr_type
                              iv_amount_type = <ls_hlpseg>-amount_type ).

          CASE ls_cfg_rounding-base_value.

* always round down if net value is to be rounded
            WHEN 'V'.
              ls_param-minval_rndmethod = '2'.
              ls_param-minval_rnddecim  = ls_cfg_rounding-round_by.
              ls_param-minval_rndplace  =  2.

* perform rounding in the same way as on depreciation
            WHEN 'A'.

* normal case: no rounding of currency decimals
              ls_param-minval_rndmethod = '0'.
              ls_param-minval_rnddecim  =  0.
              ls_param-minval_rndplace  =  2.

* special case: currency without decimals (Japan) and
* depreciation is to be rounded down -> rounding min.value up
              IF   ls_cfg_rounding-rounding_method = '2'
              AND  ls_cfg_rounding-round_by        = '0'.
                ls_param-minval_rndmethod = '1'.
              ENDIF.
          ENDCASE.

* get indicator, if minimum value is to be subtracted from base value
          CASE <ls_hlpseg>-key_phase_ref->ms_settings-scrapvalue_rule.
            WHEN gc_scrapvalue-rule_0.
              ls_param-subtract_minval = <ls_hlpseg>-key_phase_ref->ms_settings-use_min_value.

            WHEN gc_scrapvalue-rule_1.
              ls_param-subtract_minval = abap_true.

            WHEN gc_scrapvalue-rule_2.
              ls_param-subtract_minval = space.

            WHEN gc_scrapvalue-rule_3.
              ls_param-minval_percent  = 0.
              ls_param-minval_stated   = 0.
              ls_param-subtract_minval = space.
          ENDCASE.
        ENDIF.
      ENDIF.

* set indicator if net value can be negative
      IF <ls_hlpseg>-arearef->ms_setup-sign_apc     <> gc_area_value_sign-none     OR
       ( <ls_hlpseg>-arearef->ms_setup-sign_invest  <> gc_area_value_sign-negative AND
         <ls_hlpseg>-arearef->ms_setup-sign_reserve <> gc_area_value_sign-negative  ). "

        IF <ls_hlpseg>-key_phase_ref->ms_settings-calc_below_zero <> space                       AND
           <ls_hlpseg>-arearef->ms_setup-sign_nbv                 <> gc_area_value_sign-positive AND
           <ls_hlpseg>-arearef->ms_setup-sign_nbv                 <> gc_area_value_sign-none.

          ls_param-no_minval = abap_true.
        ENDIF.

* ignore area sign rule for nbv on interest calculation
        IF <ls_hlpseg>-key_phase_ref->ms_settings-calc_below_zero <> space                AND
           <ls_hlpseg>-amount_type                                EQ gc_amount_type-intr.

          ls_param-no_minval = abap_true.
        ENDIF.
      ENDIF.

      APPEND ls_param TO mt_parameter.
    ENDLOOP.

* POSTCONDITION

  ENDMETHOD.


  METHOD _period_create.
*-----------------------------------------------------------
* Abolish T093B-X445R
*-----------------------------------------------------------
* PRECONDITION
* check if processing required at all
  CHECK NOT mt_parameter[] IS INITIAL.

* DEFINITION
    FIELD-SYMBOLS <ls_weighting>  TYPE ty_s_deprkey-period_weighting.
    FIELD-SYMBOLS <ls_reduction>  TYPE ty_s_deprarea-short_fyear.
    FIELD-SYMBOLS <ls_hlpseg>     TYPE ty_s_hlpseg.

    DATA lt_weighting             TYPE TABLE OF ty_s_deprkey-period_weighting.
    DATA lt_weighting_1           TYPE TABLE OF ty_s_deprkey-period_weighting.
    DATA ls_period                TYPE ty_s_period.

    DATA lv_periods               TYPE numc4.
    DATA lv_period                TYPE ty_s_period-useful_life.
    DATA lv_fyear                 TYPE numc4.
    DATA: lv_periods_in_start_yr          TYPE faa_ee_s_period-useful_life,  "< 2899226
          lv_periods_rest_nxt_yr          TYPE faa_ee_s_period-useful_life,  "< 2899226
          lv_periods_useful_life_strt_yr  TYPE faa_ee_s_period-useful_life.  "< 2899226
    DATA lv_peryear_weighted      TYPE faa_ee_s_period-peryear_weighted.
    DATA lv_perseg_weighted       TYPE faa_ee_s_period-perseg_weighted.

* BODY
* get definitions for companycode and depr. areas
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      CLEAR ls_period.

      AT NEW area.
        CLEAR lv_fyear.
        UNASSIGN <ls_reduction>.                            "< 2671146

* get settings related with shortened fiscal year
        IF NOT <ls_hlpseg>-is_shortfiscyear IS INITIAL.
          READ TABLE <ls_hlpseg>-arearef->mts_short_fy_reduction ASSIGNING <ls_reduction>
            WITH KEY short_fisc_year = <ls_hlpseg>-fyear.
        ENDIF.
      ENDAT.

* fill key fields of PERIOD
      ls_period-fyear          = <ls_hlpseg>-fyear.
      ls_period-area           = <ls_hlpseg>-area.
      ls_period-amount_type    = <ls_hlpseg>-amount_type.
      ls_period-period_to      = <ls_hlpseg>-period_to.

      "As there are several entries in HLPSEG for the same key we have to check
      READ TABLE mt_period TRANSPORTING NO FIELDS
        WITH KEY fyear       = ls_period-fyear
                 area        = ls_period-area
                 amount_type = ls_period-amount_type
                 period_to   = ls_period-period_to.

      CHECK sy-subrc <> 0.                                  " ^ ^ ^ ^ ^ ^


      ls_period-useful_life    = <ls_hlpseg>-useful_life.

      ls_period-changeover_yr  = <ls_hlpseg>-changeover_yr.
      ls_period-changeover_prd = <ls_hlpseg>-changeover_prd.

      ls_period-exp_life_seg   = <ls_hlpseg>-exp_life_seg.
      ls_period-exp_life_new   = <ls_hlpseg>-exp_life_new.
      ls_period-exp_life       = <ls_hlpseg>-exp_life.

* determine periods within segment and year to be used for value calculation
      ls_period-peryear          = <ls_hlpseg>-periods.
      ls_period-peryear_weighted = <ls_hlpseg>-periods.
      ls_period-perseg_weighted  = <ls_hlpseg>-period_to - <ls_hlpseg>-period_from + 1.

      CALL METHOD <ls_hlpseg>-arearef->is_active
        EXPORTING
          iv_setting = gc_setting_halfmonth
        RECEIVING
          rv_active  = ls_period-use_halfperiods.

* skip to next segment for other amount types than interest and depreciation
      IF <ls_hlpseg>-key_phase_ref IS NOT BOUND.
        APPEND ls_period TO mt_period.
        CONTINUE.
      ENDIF.

      IF <ls_hlpseg>-amount_type <> gc_amount_type-ordn AND
         <ls_hlpseg>-amount_type <> gc_amount_type-spec AND
         <ls_hlpseg>-amount_type <> gc_amount_type-intr.

        APPEND ls_period TO mt_period.
        CONTINUE.
      ENDIF.

*   If end of useful life within the current fiscal year, and curb function
*   (calculate from effective life) is checked, then the period useful life
*   will be calculated from the formula "expired useful life + 1 fiscal year".
*   Increase usefule life for appropriate calculation in last year of useful
*   life or after end of life
      lv_period = <ls_hlpseg>-exp_life + <ls_hlpseg>-periods.
      IF NOT <ls_hlpseg>-key_phase_ref->ms_settings-calc_real_life IS INITIAL AND
         NOT <ls_hlpseg>-key_phase_ref->ms_settings-calc_after_end IS INITIAL AND
         <ls_hlpseg>-useful_life <= lv_period.

        ls_period-useful_life =   lv_period.
      ENDIF.

      CLEAR lv_period.
* adjust useful life according French rule -> if calc. starts within the fiscal year
*                                          -> if shortened fiscal years in the past
      IF NOT <ls_hlpseg>-key_phase_ref->ms_settings-uselife_reduce IS INITIAL.
        CALL METHOD adjust_useful_life
          EXPORTING
            is_hlpseg = <ls_hlpseg>
          CHANGING
            cs_period = ls_period.
      ENDIF.

      IF ls_period-peryear_weighted > ls_period-useful_life.
        ls_period-peryear_weighted  = ls_period-useful_life.
      ENDIF.

* determine wether shortened fiscal year has influence on calculation
      IF NOT <ls_hlpseg>-is_shortfiscyear IS INITIAL.
        ls_period-short_yr_prds = <ls_hlpseg>-periods_short_fy.

        IF <ls_reduction> IS ASSIGNED.
          CASE <ls_hlpseg>-amount_type.
            WHEN gc_amount_type-ordn.
              IF <ls_reduction>-reduce_depr_o IS INITIAL.
                ls_period-ignore_short_yr = abap_true.
              ENDIF.

            WHEN gc_amount_type-spec.
              IF <ls_reduction>-reduce_depr_s IS INITIAL.
                ls_period-ignore_short_yr = abap_true.
              ENDIF.

            WHEN gc_amount_type-intr.
              IF <ls_reduction>-reduce_interest IS INITIAL.
                ls_period-ignore_short_yr = abap_true.
              ENDIF.

            WHEN gc_amount_type-rage
              OR gc_amount_type-repl.

              IF <ls_reduction>-reduce_revl IS INITIAL.
                ls_period-ignore_short_yr = abap_true.
              ENDIF.
          ENDCASE.

* in case reduction was not specified => no reduction
        ELSE.
          ls_period-ignore_short_yr = abap_true.
        ENDIF.

* setting of depreciation key wins
        IF NOT <ls_hlpseg>-key_phase_ref->ms_settings-no_reduction IS INITIAL.
          ls_period-ignore_short_yr = <ls_hlpseg>-key_phase_ref->ms_settings-no_reduction.
        ENDIF.
      ENDIF.

      IF ls_period-ignore_short_yr = abap_true.
        lv_periods = <ls_hlpseg>-periods_short_fy.
      ELSE.
        lv_periods = <ls_hlpseg>-periods.
      ENDIF.

* consider period weighting for each period coverd within the interval
      lt_weighting = <ls_hlpseg>-key_phase_ref->mo_depr_key->get_period_weighting( ).

      lv_peryear_weighted = ls_period-peryear_weighted.
      lv_perseg_weighted  = ls_period-perseg_weighted.

      DO 1 TIMES.
        CHECK lt_weighting         IS NOT INITIAL.
        CHECK <ls_hlpseg>-use_days IS     INITIAL.

        CLEAR ls_period-peryear_weighted.
        CLEAR ls_period-perseg_weighted.

* get valid due year if period weighting to be considered
        IF lv_fyear IS INITIAL.
          READ TABLE lt_weighting ASSIGNING <ls_weighting>
            WITH KEY valid_to_fyear = <ls_hlpseg>-fyear
            BINARY SEARCH.

          CASE sy-subrc.
            WHEN 0.
              lv_fyear = <ls_weighting>-valid_to_fyear.

            WHEN 4.
              READ TABLE lt_weighting ASSIGNING <ls_weighting> INDEX sy-tabix.
              lv_fyear = <ls_weighting>-valid_to_fyear.

            WHEN 8.
              lv_fyear = 9999.

          ENDCASE.
        ENDIF.

* get number of periods to be regarded within actual fiscal year
        LOOP AT  lt_weighting ASSIGNING <ls_weighting>
          WHERE valid_to_fyear = lv_fyear.

          IF <ls_weighting>-valid_to_period <= lv_periods.
            ls_period-peryear_weighted = ls_period-peryear_weighted
                                       + <ls_weighting>-factor.
          ENDIF.

          IF <ls_weighting>-valid_to_period >= <ls_hlpseg>-period_from AND
             <ls_weighting>-valid_to_period <= <ls_hlpseg>-period_to      .

            ls_period-perseg_weighted  = ls_period-perseg_weighted
                                       + <ls_weighting>-factor.
          ENDIF.
        ENDLOOP.

* provide sum of weeks covered within useful life starting with start period
* if usefule life is less than a year
        IF <ls_hlpseg>-useful_life < <ls_hlpseg>-periods AND
           <ls_hlpseg>-phase       > 0                      .

          lv_fyear = <ls_hlpseg>-start_yr + 1.

          IF <ls_hlpseg>-fyear = <ls_hlpseg>-start_yr OR
             <ls_hlpseg>-fyear =  lv_fyear              .

            DELETE lt_weighting
             WHERE valid_to_fyear < <ls_hlpseg>-start_yr.

* delete periods before start period if there are entries for start year
            DELETE lt_weighting
             WHERE valid_to_period < <ls_hlpseg>-start_prd
               AND valid_to_fyear  = <ls_hlpseg>-start_yr.
* delete periods also for entries with year 9999           "< boi 2899226
*        Determine possible periods in start year
         lv_periods_in_start_yr = <ls_hlpseg>-periods - <ls_hlpseg>-start_prd + 1 .
*        Determine remaining periods in subsequent year (negative, if end is in first year)
         lv_periods_rest_nxt_yr = <ls_hlpseg>-useful_life - lv_periods_in_start_yr.
*        Determine period until useful life end ( < 12 in case useful life ends in second year)
         lv_periods_useful_life_strt_yr = <ls_hlpseg>-useful_life + <ls_hlpseg>-start_prd - 1.

         IF <ls_hlpseg>-fyear = <ls_hlpseg>-start_yr.
*          Depreciation is not finished in start_year
*          consider all periods as of start period
           IF lv_periods_rest_nxt_yr > 0.
             DELETE lt_weighting
              WHERE valid_to_period < <ls_hlpseg>-start_prd
                AND valid_to_fyear  = '9999'.
*          End of useful life reached in start_year
           ELSE.
             DELETE lt_weighting
              WHERE valid_to_period < <ls_hlpseg>-start_prd
                AND valid_to_period > lv_periods_useful_life_strt_yr
                AND valid_to_fyear = '9999'.
           ENDIF.
*        year after start year. No further years can be reached
         ELSE.
           DELETE lt_weighting
            WHERE valid_to_period > lv_periods_rest_nxt_yr
              AND valid_to_fyear  = '9999'.
         ENDIF.      "< eoi 2899226

* delete periods that have not to be considered on summation if no entries
* exist explicitly for start year
            READ TABLE lt_weighting ASSIGNING <ls_weighting> INDEX 1.

            CHECK <ls_weighting> IS ASSIGNED.

            lv_fyear = <ls_weighting>-valid_to_fyear.

            lv_periods = <ls_hlpseg>-periods - <ls_hlpseg>-useful_life.

            IF <ls_hlpseg>-start_prd > lv_periods AND
               <ls_hlpseg>-start_yr  < lv_fyear.

              lv_period = <ls_hlpseg>-start_prd - 1.

              DO lv_periods TIMES.
                DELETE lt_weighting
                 WHERE valid_to_period = lv_period
                   AND valid_to_fyear  = lv_fyear.

                lv_period = lv_period - 1.
              ENDDO.
            ENDIF.

* get sum of weeks covered within useful life
            CLEAR ls_period-peryear_weighted.

            LOOP AT lt_weighting ASSIGNING <ls_weighting> FROM 1 TO <ls_hlpseg>-useful_life.
              ls_period-peryear_weighted = ls_period-peryear_weighted + <ls_weighting>-factor.
            ENDLOOP.
          ENDIF.
        ENDIF.

      ENDDO.

      "Reset to values calculated before DO - ENDO if necessary
      IF ls_period-peryear_weighted IS INITIAL OR
         ls_period-perseg_weighted  IS INITIAL   .

        ls_period-peryear_weighted = lv_peryear_weighted.
        ls_period-perseg_weighted  = lv_perseg_weighted.
      ENDIF.

      APPEND ls_period TO mt_period.
    ENDLOOP.

* POSTCONDITION

  ENDMETHOD.


  METHOD _planvalue_create.
*----------------------------------------------------------------------*
* Perform calculation of values to be posted by depreciation run
* This is done by calculating period by period backwards and
* determine the delta between the prior period and the actual period
*----------------------------------------------------------------------*
* Reworked/cleaned up with 1908
*----------------------------------------------------------------------*

* PRECONDITION
    CHECK mts_calcamount IS NOT INITIAL.

* DEFINITIONS
    FIELD-SYMBOLS <ls_hlpseg>       TYPE ty_s_hlpseg.

    DATA lo_processing_handle       LIKE me.

    DATA lt_calcamount_prev         TYPE ty_ts_calcamount.

    DATA ls_calcamount_prev         TYPE ty_s_calcamount.
    DATA ls_calcamount              TYPE ty_s_calcamount.
    DATA ls_planvalue               TYPE ty_s_planvalue.
    DATA ls_hlpseg                  TYPE ty_s_hlpseg.

    DATA lv_last_day_of_fiscper     TYPE dats.
    DATA lv_period_from             TYPE ty_s_hlpseg-period_to.
    DATA lv_period_to               TYPE ty_s_hlpseg-period_to.
    DATA lv_periods                 TYPE ty_s_hlpseg-period_to.
    DATA lv_fiscper                 TYPE poper.

* BODY
* get date of first acquisition for creation of due value adjustments
    CHECK  ms_asset_data-initial_acq <= ms_proc_data-last_day_in_fyr.

    DATA(lo_cfg_leadobj) = ms_proc_data-leadobj_ref.
    CREATE OBJECT lo_processing_handle.

* take over posting date independant data
    lo_processing_handle->mo_start       = mo_start.
    lo_processing_handle->ms_asset_data  = ms_asset_data.
    lo_processing_handle->ms_proc_data   = ms_proc_data.
    lo_processing_handle->mts_area       = mts_area.
    lo_processing_handle->mt_yearseg     = mt_yearseg.
    lo_processing_handle->mt_rounding    = mt_rounding.
    lo_processing_handle->mt_areasign    = mt_areasign.
    lo_processing_handle->mt_virtarea    = mt_virtarea.
    lo_processing_handle->mt_virtarea_s4 = mt_virtarea_s4.
    lo_processing_handle->mt_transaction = mt_transaction.

* create posting date dependant attribute tables for consistency check
    lo_processing_handle->ms_proc_data-step = gc_step-dc_int_calc_plan_values.

* get count of fiscal periods to be regarded
    CALL METHOD lo_cfg_leadobj->get_number_of_periods
      EXPORTING
        iv_fisc_year        = ms_proc_data-fyear
      IMPORTING
        ev_periods_short_fy = lv_periods.

* determine first period up to which values are to be calculated
    lv_fiscper = lv_periods - ms_proc_data-period_offset.

* determine periods to be calculated backwards in year of acquisition
    DATA(lv_date) = ms_asset_data-cap_date.
    IF lv_date IS INITIAL.
      lv_date = ms_asset_data-initial_acq.
    ENDIF.

    IF lv_date >= ms_proc_data-first_day_in_fyr AND
       lv_date <= ms_proc_data-last_day_in_fyr.
      CALL METHOD lo_cfg_leadobj->get_period_and_year
        EXPORTING
          iv_date   = lv_date
        IMPORTING
          ev_period = lv_period_from.

      lv_periods = lv_periods - lv_period_from + 1.
    ENDIF.

* take over whole year amounts for determination of the panned amounts of
* the highest period to be regarded
    lt_calcamount_prev = mts_calcamount.

    DATA lv_remaining_prds  TYPE ty_s_hlpseg-period_to.
    IF lv_periods <= ms_proc_data-period_offset.
      lv_periods = 1.
    ELSE.
      lv_remaining_prds = lv_periods MOD ms_proc_data-period_offset.
      lv_periods        = lv_periods DIV ms_proc_data-period_offset.
      IF lv_remaining_prds <> 0.
        lv_periods = lv_periods + 1.
      ENDIF.
    ENDIF.


    DO lv_periods TIMES.

* as we calc. the periods packwards (11, 10, ..) values for the first period
* are provided on the last leap ( SY-INDEX = 1 ) within lt_calcamount_prev
* thus nothing has to be reduced so we just clear the amounts in MTS_CALCAMOUNT
      IF sy-index = lv_periods.
        CLEAR ls_calcamount-total.
        MODIFY lo_processing_handle->mts_calcamount FROM ls_calcamount TRANSPORTING total
         WHERE fyear = ms_proc_data-fyear.

* trigger value calculation up to actual period
      ELSE.
        CALL METHOD lo_cfg_leadobj->get_last_day_in_period
          EXPORTING
            iv_fisc_year = ms_proc_data-fyear
            iv_period    = lv_fiscper
          IMPORTING
            ev_last_day  = lv_last_day_of_fiscper.

* delete transactions that are not assigned to actual period
        DELETE lo_processing_handle->mt_transaction
         WHERE posting_date > lv_last_day_of_fiscper
            OR value_date   > lv_last_day_of_fiscper.

        CLEAR lo_processing_handle->mts_hlpseg.
        CLEAR lo_processing_handle->mts_calcorder.
        CLEAR lo_processing_handle->mts_calcamount.
        CLEAR lo_processing_handle->mts_calcdata.

        CLEAR lo_processing_handle->mt_sumseg.
        CLEAR lo_processing_handle->mt_timeseg.
        CLEAR lo_processing_handle->mt_parameter.
        CLEAR lo_processing_handle->mt_period.

* provide HLPSEG with intervals up to the calc. period assigned
* to the last day of the posting period
        LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
          AT NEW area.
            IF <ls_hlpseg>-use_days = abap_false.
              CALL METHOD <ls_hlpseg>-arearef->get_period_and_year
                EXPORTING
                  iv_date   = lv_last_day_of_fiscper
                IMPORTING
                  ev_period = lv_period_to.
            ELSE.
              lv_period_to = lv_last_day_of_fiscper - <ls_hlpseg>-first_day_in_yr + 1.
            ENDIF.
          ENDAT.

* do not consider intervals behind LV_PERIOD_TO
          IF <ls_hlpseg>-period_from > lv_period_to.
            CONTINUE.
          ENDIF.

          ls_hlpseg = <ls_hlpseg>.

* adjust PERIOD_TO of the interval if it ends behind
          IF <ls_hlpseg>-amount_type <> gc_amount_type-rage AND
             <ls_hlpseg>-amount_type <> gc_amount_type-repl.
            IF ls_hlpseg-period_to > lv_period_to.
              ls_hlpseg-period_to = lv_period_to.
            ENDIF.
          ENDIF.

          APPEND ls_hlpseg TO lo_processing_handle->mts_hlpseg.
        ENDLOOP.

        CALL METHOD lo_processing_handle->_timeseg_create.
        CALL METHOD lo_processing_handle->_hlpseg_split_on_timeseg.
*     CALL METHOD lo_processing_handle->_hlpseg_split_on_alignment.
        CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
        CALL METHOD lo_processing_handle->_timeseg_create_missing.
        CALL METHOD lo_processing_handle->_parameter_create.
        CALL METHOD lo_processing_handle->_parameter_call_badi.
        CALL METHOD lo_processing_handle->_period_create.
        CALL METHOD lo_processing_handle->_sumseg_create.
        CALL METHOD lo_processing_handle->_calcorder_create.
        CALL METHOD lo_processing_handle->_values_calculate.
      ENDIF.

      LOOP AT lt_calcamount_prev INTO ls_calcamount_prev.
        READ TABLE lo_processing_handle->mts_calcamount INTO ls_calcamount
           WITH KEY area      = ls_calcamount_prev-area
                    curr_type = ls_calcamount_prev-curr_type.
        IF sy-subrc <> 0.
          CLEAR ls_calcamount.
        ENDIF.

        CLEAR ls_planvalue.

        ls_planvalue-fyear     = ls_calcamount_prev-fyear.
        ls_planvalue-area      = ls_calcamount_prev-area.
        ls_planvalue-curr_type = ls_calcamount_prev-curr_type.
        ls_planvalue-period    = lv_fiscper + ms_proc_data-period_offset.
        ls_planvalue-movcat    = if_faa_posting_constants=>gc_movcat-depreciation_run.

        ls_planvalue-slalittype = '07205'.
        ls_planvalue-amount     = ls_calcamount_prev-total-depr_o - ls_calcamount-total-depr_o.
        APPEND ls_planvalue TO mts_planvalue.

        ls_planvalue-slalittype = '07206'.
        ls_planvalue-amount     = ls_calcamount_prev-total-depr_s - ls_calcamount-total-depr_s.
        APPEND ls_planvalue TO mts_planvalue.

        IF ls_calcamount_prev-total-intr <> 0 OR
           ls_calcamount-total-intr      <> 0.

          ls_planvalue-slalittype = '07209'.
          ls_planvalue-amount     = ls_calcamount_prev-total-intr   - ls_calcamount-total-intr.
          APPEND ls_planvalue TO mts_planvalue.
        ENDIF.

* consider revaluation of APC and depreciation is just calculated on a yearly base
        IF sy-index = 1.
          ls_planvalue-period = lv_fiscper + ms_proc_data-period_offset.

          IF ls_calcamount_prev-total-revl <> 0.

            ls_planvalue-slalittype = '07203'.
            ls_planvalue-amount     = ls_calcamount_prev-total-revl.
            APPEND ls_planvalue TO mts_planvalue.
          ENDIF.

          IF ls_calcamount_prev-total-revl_d <> 0.
            ls_planvalue-slalittype = '07204'.
            ls_planvalue-amount     = ls_calcamount_prev-total-revl_d.
            APPEND ls_planvalue TO mts_planvalue.
          ENDIF.
        ENDIF.
      ENDLOOP.

* get next period up to which values are to be calculated
* and note the values calculate up to the actual period for delta
* calculation on the next leap
      lv_fiscper = lv_fiscper - ms_proc_data-period_offset.
      lt_calcamount_prev = lo_processing_handle->mts_calcamount.
    ENDDO.

    SORT mts_planvalue BY area period slalittype.

* POSTCONDITION

  ENDMETHOD.


  METHOD _propvalue_call_badi.
* PRECONDITION

* DEFINITION

* BODY

* POSTCONDITION

ENDMETHOD.


  METHOD _rounding_call_badi.
* PRECONDITION
  CHECK go_badi_customer IS BOUND
     OR go_badi_country  IS BOUND.

* DEFINITION
  DATA lo_segment_handle            TYPE faa_dc_segment_handle.
  DATA ls_rounding                  TYPE ty_s_rounding.

  FIELD-SYMBOLS <ls_rounding>       TYPE ty_s_rounding.
  FIELD-SYMBOLS <ls_area>           TYPE if_faa_depr_calc_types=>ty_s_area.

* BODY
    me->prepare_badi_call( CHANGING co_dc_segment_handle = lo_segment_handle ). "2569117

    READ TABLE mts_area INDEX 1 ASSIGNING <ls_area>.

    LOOP AT mt_rounding ASSIGNING <ls_rounding>.
      ls_rounding = <ls_rounding>.

* call country BADIs for change of rounding settings
      IF go_badi_country IS BOUND.
        CALL METHOD go_badi_country->change_rounding
          EXPORTING
            flt_val        = <ls_area>-arearef->mo_leadobj->get_setup( )-country
            io_handle      = lo_segment_handle
          CHANGING
            cs_rounding    = ls_rounding
          EXCEPTIONS
            error_occurred = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.
      ENDIF.

      <ls_rounding>-decimals = ls_rounding-decimals.
      <ls_rounding>-method   = ls_rounding-method.
      <ls_rounding>-value    = ls_rounding-value.
      <ls_rounding>-place    = ls_rounding-place.

* call customer BADIs for change of rounding settings
      IF go_badi_customer IS BOUND.
        CALL METHOD go_badi_customer->change_rounding
          EXPORTING
            io_handle      = lo_segment_handle
          CHANGING
            cs_rounding    = ls_rounding
          EXCEPTIONS
            error_occurred = 4.

        IF sy-subrc <> 0.                                   "2244188
          CALL METHOD create_message_from_syst.
        ENDIF.

        <ls_rounding>-decimals = ls_rounding-decimals.
        <ls_rounding>-method   = ls_rounding-method.
        <ls_rounding>-value    = ls_rounding-value.
        <ls_rounding>-place    = ls_rounding-place.
      ENDIF.
    ENDLOOP.

* POSTCONDITION

ENDMETHOD.


  METHOD _rounding_create.
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

    DATA ls_rounding               TYPE ty_s_rounding.
    DATA ls_cfg_rounding           TYPE ty_s_deprarea-rounding.

* VALUE    value to be rounded: V - net value, A - amount
* METHOD   rounding method: 0 - nearest whole, 1 - up, 2 - down
* PLACE    number of places for shifting the point before rounding
* DECIMALS number of places to be rounded

* BODY
* get definitions for companycode and depr. areas
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      AT NEW amount_type.

        CLEAR ls_rounding.

        ls_rounding-area        = <ls_hlpseg>-area.
        ls_rounding-curr_type   = <ls_hlpseg>-curr_type.
        ls_rounding-amount_type = <ls_hlpseg>-amount_type.
        ls_rounding-place       = 2.

        ls_cfg_rounding = <ls_hlpseg>-arearef->get_rounding(
                            iv_curr_type   = <ls_hlpseg>-curr_type
                            iv_amount_type = <ls_hlpseg>-amount_type ).

        ls_rounding-value       = ls_cfg_rounding-base_value.
        ls_rounding-method      = ls_cfg_rounding-rounding_method.
        ls_rounding-decimals    = ls_cfg_rounding-round_by.

        APPEND ls_rounding TO mt_rounding.
      ENDAT.
    ENDLOOP.
    _rounding_call_badi( ).                                 "2569117

* POSTCONDITION

  ENDMETHOD.


  METHOD _sumseg_create.
* PRECONDITION

* DEFINITION
  DATA ls_sumseg                        TYPE ty_s_sumseg.
  DATA lv_first_amount_type             TYPE ty_s_timeseg-amount_type.

  FIELD-SYMBOLS <ls_transaction>        TYPE ty_s_transaction.
    FIELD-SYMBOLS <ls_hlpseg>             TYPE ty_s_hlpseg.
    FIELD-SYMBOLS <ls_timeseg>            TYPE ty_s_timeseg.
    FIELD-SYMBOLS <ls_sumseg>             TYPE ty_s_sumseg.
    FIELD-SYMBOLS <lv_transaction_amount> TYPE ty_s_transaction-cur-apc.
    FIELD-SYMBOLS <lv_sumseg_amount>      TYPE ty_s_sumseg-cur-apc.

* BODY
    IF ms_proc_data-step = gc_step-dc_int_calc_plan_values. "2160063
* create SUMSEG from TIMESEG that is limited to current required PERIOD_TO
* to avoid errors due to calculation period assignment of transactions e.g. retirements
      LOOP AT me->mt_timeseg ASSIGNING <ls_timeseg>.
        AT NEW curr_type.
          CLEAR ls_sumseg.
          ls_sumseg-fyear      = <ls_timeseg>-fyear.
          ls_sumseg-area       = <ls_timeseg>-area.
          ls_sumseg-curr_type  = <ls_timeseg>-curr_type.
          lv_first_amount_type = <ls_timeseg>-amount_type.
        ENDAT.

        CHECK lv_first_amount_type = <ls_timeseg>-amount_type.

        ls_sumseg-prev_prev = <ls_timeseg>-prev_prev.
        ls_sumseg-prev_cur  = <ls_timeseg>-prev_cur.
        ls_sumseg-cur       = <ls_timeseg>-cur.

        COLLECT ls_sumseg INTO me->mt_sumseg.
      ENDLOOP.

    ELSE.
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
        AT END OF curr_type.
          INSERT INITIAL LINE INTO mt_sumseg ASSIGNING <ls_sumseg> INDEX 1.
          <ls_sumseg>-fyear     = <ls_hlpseg>-fyear.
          <ls_sumseg>-area      = <ls_hlpseg>-area.
          <ls_sumseg>-curr_type = <ls_hlpseg>-curr_type.
          <ls_sumseg>-period_to = <ls_hlpseg>-period_to.

          LOOP AT mt_transaction ASSIGNING <ls_transaction>
            WHERE area      = <ls_hlpseg>-area
              AND curr_type = <ls_hlpseg>-curr_type.
            DO 11 TIMES.                                    "H2193614
              IF <ls_transaction>-cur IS NOT INITIAL.
                ASSIGN COMPONENT sy-index OF STRUCTURE <ls_transaction>-cur       TO <lv_transaction_amount>.
                ASSIGN COMPONENT sy-index OF STRUCTURE <ls_sumseg>-cur            TO <lv_sumseg_amount>.
                <lv_sumseg_amount> = <lv_sumseg_amount> + <lv_transaction_amount>.
              ENDIF.

              IF <ls_transaction>-prev_cur IS NOT INITIAL.
                ASSIGN COMPONENT sy-index OF STRUCTURE <ls_transaction>-prev_cur  TO <lv_transaction_amount>.
                ASSIGN COMPONENT sy-index OF STRUCTURE <ls_sumseg>-prev_cur       TO <lv_sumseg_amount>.
                <lv_sumseg_amount> = <lv_sumseg_amount> + <lv_transaction_amount>.
              ENDIF.

              IF <ls_transaction>-prev_prev IS NOT INITIAL.
                ASSIGN COMPONENT sy-index OF STRUCTURE <ls_transaction>-prev_prev TO <lv_transaction_amount>.
                ASSIGN COMPONENT sy-index OF STRUCTURE <ls_sumseg>-prev_prev      TO <lv_sumseg_amount>.
                <lv_sumseg_amount> = <lv_sumseg_amount> + <lv_transaction_amount>.
              ENDIF.
            ENDDO.

          " Special check on complete retirement in CL_FAA_EE when transaction item
          IF ms_transaction_cntrl-is_reversal EQ abap_false AND                      " is no reversal AND                    "2941281
            ( <ls_transaction>-check_amount IS NOT INITIAL  OR                       " requires the check OR
              <ls_transaction>-classification = if_faa_posting_constants=>gc_movcat-retirement  OR  " is retirement OR       "2530208
              <ls_transaction>-classification = if_faa_posting_constants=>gc_movcat-transfer_ret ). " is retiring transfer   "2530208
              <ls_sumseg>-check_amount = abap_true.
            ENDIF.
          ENDLOOP.
        ENDAT.
      ENDLOOP.
      SORT mt_sumseg.

    ENDIF.

* POSTCONDITION

ENDMETHOD.


  METHOD _timeseg_create.
* PRECONDITION
  CHECK mt_transaction IS NOT INITIAL.

* DEFINITION
    DATA lt_transaction            TYPE ty_t_transaction.
    DATA lt_timeseg                TYPE ty_t_timeseg.
    DATA lt_hlpseg                 TYPE ty_ts_hlpseg.

    DATA ls_timeseg                TYPE ty_s_timeseg.
    DATA ls_hlpseg                 TYPE ty_s_hlpseg.
    DATA ls_amount_types           TYPE char3.

    DATA lv_fiscal_year            TYPE numc4.
    DATA lv_calculation_period     TYPE numc3.
    DATA lv_message                TYPE string.

  FIELD-SYMBOLS <ls_transaction> TYPE ty_s_transaction.
  FIELD-SYMBOLS <ls_timeseg>     TYPE ty_s_timeseg.
  FIELD-SYMBOLS <ls_hlpseg>      TYPE ty_s_hlpseg.

* BODY
* check if TIMSEG has to be created at all
    LOOP AT mts_hlpseg TRANSPORTING NO FIELDS
      WHERE key_phase_ref->ms_settings-percent_key <> gc_percent-key_n
        AND amount_type                     CA gc_amount_type+2(3) "2189388
        AND grp_asset_assgnd                =  abap_false.  "just needed for parallel Calc with checks
      EXIT.
    ENDLOOP.

    CHECK sy-subrc = 0.

    IF ms_proc_data-step = gc_step-dc_int_calc_co_rules.
      lt_hlpseg[] = mo_previous->mts_hlpseg[].
    ELSE.
      lt_hlpseg[] = mts_hlpseg[].
    ENDIF.

    lt_transaction = mt_transaction.                        "2226481

* avoid interval split on reversed items if both items the reversing and reversed one
* are provided in MT_TRANSACTION as otherwise calculation differences on NBV related calc. may occur
    LOOP AT lt_transaction ASSIGNING <ls_transaction>.
      IF <ls_transaction>-seqno_reversed IS NOT INITIAL AND
         <ls_transaction>-seqno_reversed <> '99999'.        "2343306
        READ TABLE mt_transaction TRANSPORTING NO FIELDS
          WITH KEY area           = <ls_transaction>-area
                   curr_type      = <ls_transaction>-curr_type
                   seqno          = <ls_transaction>-seqno_reversed
                   seqno_reversed = <ls_transaction>-seqno. "2329644
        IF sy-subrc = 0.
          DELETE lt_transaction.
          CONTINUE.

* insure that on whole year related calculation both items reversing and reversed exist
        ELSE.                                               "2329644
          IF ms_proc_data-step <> gc_step-dc_int_calc_plan_values.
            MESSAGE e524(aa) WITH <ls_transaction>-seqno INTO DATA(lv_msg). "2347067
            me->create_message_from_syst( ).
          ENDIF.
        ENDIF.
      ENDIF.

      ls_amount_types = gc_amount_type+2(3)."amount types to be considered => NSZ

      LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>
         WHERE area             = <ls_transaction>-area
           AND curr_type        = <ls_transaction>-curr_type
           AND to_date_of_tddp >= <ls_transaction>-value_date
           AND amount_type     CA gc_amount_type+2(3).

* ensure lowest interval is used and each amount type is just processed once
        CHECK   <ls_hlpseg>-amount_type CA ls_amount_types.
        REPLACE <ls_hlpseg>-amount_type IN ls_amount_types WITH space.

        CLEAR ls_timeseg.

        CALL METHOD get_calc_yr_and_per_4_trnsctn "2189388
          EXPORTING
            is_hlpseg             = <ls_hlpseg>
            iv_per_ctrl_group     = <ls_transaction>-periodcontrol
            iv_value_date         = <ls_transaction>-value_date
          IMPORTING
            ev_fiscal_year        = lv_fiscal_year
            ev_calculation_period = lv_calculation_period.

        CHECK lv_fiscal_year         = ms_proc_data-fyear.
        CHECK lv_calculation_period <= <ls_hlpseg>-periods_short_fy.

        ls_timeseg-fyear       = <ls_hlpseg>-fyear.
        ls_timeseg-area        = <ls_hlpseg>-area.
        ls_timeseg-curr_type   = <ls_hlpseg>-curr_type.
        ls_timeseg-amount_type = <ls_hlpseg>-amount_type.
        ls_timeseg-period_to   = lv_calculation_period.

        MOVE-CORRESPONDING <ls_transaction> TO ls_timeseg.

        COLLECT ls_timeseg INTO lt_timeseg.
      ENDLOOP.
    ENDLOOP.

* as lt_timeseg contains in PERIOD_TO the periods with assigned transactions
* there is the need for a period interval within local table LT_HLPSEG
* that starts with HLPSEG-PERIOD_FROM = TIMESEG-PERIOD_TO for later determination
* of final PERIOD_TO within attribute table MT_TIMESEG
* if temp. timeseg is behind highest period interval it is not to be regarded for calculation
    SORT lt_timeseg.

    lt_hlpseg[] = mts_hlpseg[].

* perform period interval split if needed regarding temporary TIMESEGs
    LOOP AT lt_timeseg ASSIGNING <ls_timeseg>.
      LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>
        WHERE fyear       EQ <ls_timeseg>-fyear
          AND area        EQ <ls_timeseg>-area
          AND curr_type   EQ <ls_timeseg>-curr_type
          AND amount_type EQ <ls_timeseg>-amount_type
          AND period_from LT <ls_timeseg>-period_to
          AND period_to   GE <ls_timeseg>-period_to.

* create new period interval ending with the period before the calc. period of the assigned movements
        ls_hlpseg               = <ls_hlpseg>.
        ls_hlpseg-period_to     = <ls_timeseg>-period_to - 1.

        CHECK ls_hlpseg-period_to > 0.

        APPEND ls_hlpseg TO lt_hlpseg.

* adjust start period of actual interval to the calc. period of the assigned movements
        <ls_hlpseg>-period_from = <ls_timeseg>-period_to.
      ENDLOOP.
    ENDLOOP.

* perpare determination of correct PERIOD_TO for TIMESEG
    SORT lt_timeseg.
    SORT lt_hlpseg.

    DELETE ADJACENT DUPLICATES FROM lt_hlpseg COMPARING area curr_type amount_type period_from.

* determine correct PERIOD_TO for all TIMESEGs
    LOOP AT lt_hlpseg ASSIGNING <ls_hlpseg>
      WHERE amount_type CA gc_amount_type+2(3).             "2189388

* perform PERIOD_TO adjustment for corresponding TIMESEG
      READ TABLE lt_timeseg INTO ls_timeseg
            WITH KEY fyear       = <ls_hlpseg>-fyear
                     area        = <ls_hlpseg>-area
                     curr_type   = <ls_hlpseg>-curr_type
                     amount_type = <ls_hlpseg>-amount_type
                     period_to   = <ls_hlpseg>-period_from.
      IF sy-subrc = 0.
        ls_timeseg-period_to = <ls_hlpseg>-period_to.

        APPEND ls_timeseg TO mt_timeseg.

* no movement assigned to period interval of HLPSEG => create appropriate initial entry
      ELSE.
        CLEAR ls_timeseg.

        ls_timeseg-amount_type = <ls_hlpseg>-amount_type.
        ls_timeseg-period_to   = <ls_hlpseg>-period_to.
        ls_timeseg-fyear       = <ls_hlpseg>-fyear.
        ls_timeseg-area        = <ls_hlpseg>-area.
        ls_timeseg-curr_type   = <ls_hlpseg>-curr_type.

        APPEND ls_timeseg TO mt_timeseg.
      ENDIF.
    ENDLOOP.

    SORT mt_timeseg.

* POSTCONDITION

  ENDMETHOD.


  METHOD _timeseg_create_missing.
* PRECONDITION

* DEFINITION
  DATA ls_timeseg              TYPE ty_s_timeseg.

  FIELD-SYMBOLS <ls_timeseg>   TYPE ty_s_timeseg.
  FIELD-SYMBOLS <ls_hlpseg>    TYPE ty_s_hlpseg.

* BODY
* create timeseg completely from HLPSEG, if empty
    IF mt_timeseg[] IS INITIAL.
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
        ls_timeseg-fyear        = <ls_hlpseg>-fyear.
        ls_timeseg-area         = <ls_hlpseg>-area.
        ls_timeseg-curr_type    = <ls_hlpseg>-curr_type.
        ls_timeseg-amount_type  = <ls_hlpseg>-amount_type.
        ls_timeseg-period_to    = <ls_hlpseg>-period_to.
        APPEND ls_timeseg TO mt_timeseg.
      ENDLOOP.

* create missing entries
    ELSE.
      LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
        READ TABLE mt_timeseg TRANSPORTING NO FIELDS
              WITH KEY fyear       = <ls_hlpseg>-fyear
                       area        = <ls_hlpseg>-area
                       curr_type   = <ls_hlpseg>-curr_type
                       amount_type = <ls_hlpseg>-amount_type
                       period_to   = <ls_hlpseg>-period_to BINARY SEARCH.


* create entries analog HLPSEG if to
        CASE sy-subrc.

* segments are in sync, nothing to do
          WHEN 0.
            CONTINUE.

          WHEN 4.
            READ TABLE mt_timeseg ASSIGNING <ls_timeseg> INDEX sy-tabix.

* same area and amount type => create new one with values and clear values in actual one
            IF <ls_timeseg>-fyear        = <ls_hlpseg>-fyear     AND
               <ls_timeseg>-area         = <ls_hlpseg>-area      AND
               <ls_timeseg>-curr_type    = <ls_hlpseg>-curr_type AND
               <ls_timeseg>-amount_type  = <ls_hlpseg>-amount_type.

* create TIMESEG with values for actual period interval
              ls_timeseg            = <ls_timeseg>.
              ls_timeseg-period_to  = <ls_hlpseg>-period_to.

              INSERT ls_timeseg INTO mt_timeseg INDEX sy-tabix.

* clear values as alread covered now by newly created TIMESEG
              CLEAR <ls_timeseg>-prev_prev.
              CLEAR <ls_timeseg>-prev_cur.
              CLEAR <ls_timeseg>-cur.

* different area or amount type => create initial one
            ELSE.
              CLEAR ls_timeseg.

              ls_timeseg-fyear        = <ls_hlpseg>-fyear.
              ls_timeseg-area         = <ls_hlpseg>-area.
              ls_timeseg-curr_type    = <ls_hlpseg>-curr_type.
              ls_timeseg-amount_type  = <ls_hlpseg>-amount_type.
              ls_timeseg-period_to    = <ls_hlpseg>-period_to.

              INSERT ls_timeseg INTO mt_timeseg INDEX sy-tabix.
            ENDIF.

* no more segments at all => create initial one
          WHEN 8.
            CLEAR ls_timeseg.

            ls_timeseg-fyear        = <ls_hlpseg>-fyear.
            ls_timeseg-area         = <ls_hlpseg>-area.
            ls_timeseg-curr_type    = <ls_hlpseg>-curr_type.
            ls_timeseg-amount_type  = <ls_hlpseg>-amount_type.
            ls_timeseg-period_to    = <ls_hlpseg>-period_to.

            APPEND ls_timeseg TO mt_timeseg.
        ENDCASE.
      ENDLOOP.
    ENDIF.

* POSTCONDITION

ENDMETHOD.


METHOD _transaction_add_on_postcap.
*=======================================================================
* calculate missed depreciaitons due to missed activation on asset
* => trigger depreciation caldulation starting with the fiscal year
*    assigned to the original value/posting date of the expense posting
*    up to the actual posting year
*=======================================================================
* PRECONDITION
  CHECK ms_transaction_cntrl-no_prop_val_calc EQ abap_false.
  CHECK ms_transaction_cntrl-classification   EQ if_faa_posting_constants=>gc_movcat-postcap.

* DEFINITION
  DATA lo_processing_handle                LIKE me.
  DATA lo_dc_calc_handle                   TYPE REF TO object.

  DATA ls_transaction                      TYPE ty_s_transaction.
  DATA ls_procinfo                         TYPE ty_s_processing_info.
  DATA ls_asset_data                       TYPE if_faa_depr_calc_types=>ty_s_asset_data.
  DATA ls_cum_values                       TYPE ty_s_yearseg.
  DATA ls_depr_param                       TYPE faa_s_depr_parameters.

  FIELD-SYMBOLS <ls_depr_param> TYPE faa_s_depr_parameters. "ty_s_deprarea-depr_param.
  FIELD-SYMBOLS <ls_yearseg>               TYPE ty_s_yearseg.
  FIELD-SYMBOLS <ls_area> TYPE if_faa_depr_calc_types=>ty_s_area. "ty_s_area.

* BODY
  READ TABLE mts_area ASSIGNING <ls_area> INDEX 1.

  CALL METHOD <ls_area>-arearef->get_period_and_year
    EXPORTING
      iv_date      = ms_transaction_cntrl-value_date_orig
    IMPORTING
      ev_fisc_year = ls_procinfo-fyear.

  ls_procinfo-process           = ms_proc_data-process.
  ls_procinfo-step              = gc_step-dc_720_recalculation.
  ls_procinfo-fyear_to          = ms_proc_data-fyear.
  ls_procinfo-period_offset     = ms_proc_data-period_offset.
  ls_procinfo-leadobj_ref  = ms_proc_data-leadobj_ref.
  ls_procinfo-t_area[]          = mts_area[].

  ls_asset_data                 = ms_asset_data.
  CLEAR ls_asset_data-t_cum_values.

* provide expired useful life for the first year to be calculated
  LOOP AT mts_area ASSIGNING <ls_area>.
    LOOP AT <ls_area>-t_curtp_amount ASSIGNING FIELD-SYMBOL(<ls_curtp_amount>).
      LOOP AT ls_asset_data-ts_depr_param ASSIGNING <ls_depr_param>
       WHERE depr_area = <ls_area>-depr_area AND curr_type = <ls_curtp_amount>-curr_type.
        <ls_depr_param>-exp_ulife_yrs       = <ls_area>-exp_ulife_yrs.
        <ls_depr_param>-exp_ulife_prds      = <ls_area>-exp_ulife_prds.
        <ls_depr_param>-exp_ulife_sdep_yrs  = <ls_area>-exp_ulife_sdep_yrs.
        <ls_depr_param>-exp_ulife_sdep_prds = <ls_area>-exp_ulife_sdep_prds.
        <ls_depr_param>-depr_units          = <ls_area>-depr_units .
      ENDLOOP.

* provide initial cumulated values for fiscal year of original value date
      CLEAR ls_cum_values.
      ls_cum_values-fyear     = ls_procinfo-fyear.
      ls_cum_values-area      = <ls_area>-depr_area.
      ls_cum_values-curr_type = <ls_curtp_amount>-curr_type.
      APPEND ls_cum_values TO ls_asset_data-t_cum_values.
    ENDLOOP.
  ENDLOOP.

* provide faked acquisition transaction for the first year to trigger backlog calc. up to now
  CLEAR ls_asset_data-t_transaction.

  LOOP AT mt_transaction_post INTO ls_transaction.
    ls_transaction-fyear          = ls_procinfo-fyear.
    ls_transaction-posting_date   = ms_transaction_cntrl-value_date_orig.
    ls_transaction-value_date     = ms_transaction_cntrl-value_date_orig.
    ls_transaction-periodcontrol  = gc_period_group-acquisition.
    ls_transaction-classification = if_faa_posting_constants=>gc_movcat-acquisition.
    CLEAR ls_transaction-cur.
    ls_transaction-cur-apc        = ls_transaction-prev_prev-apc.
    CLEAR ls_transaction-prev_cur.
    CLEAR ls_transaction-prev_prev.
    APPEND ls_transaction TO ls_asset_data-t_transaction.
  ENDLOOP.

  CALL METHOD perform_calc_with_implicit_cf
    EXPORTING
      is_processing_info = ls_procinfo
      is_asset_data      = ls_asset_data
    RECEIVING
      ro_dc_calc_handle  = lo_dc_calc_handle.

  lo_processing_handle ?= lo_dc_calc_handle.

  ls_transaction-cntrl = ms_transaction_cntrl.

  CLEAR mt_transaction_post.

  LOOP AT lo_processing_handle->mt_yearseg ASSIGNING <ls_yearseg>.
    CLEAR ls_transaction-prev_prev.
    CLEAR ls_transaction-prev_cur.
    CLEAR ls_transaction-cur.
    ls_transaction-fyear            = ms_transaction_cntrl-fyear.
    ls_transaction-area             = <ls_yearseg>-area.
    ls_transaction-prev_prev-apc    = <ls_yearseg>-cum-apc.
    ls_transaction-prev_prev-depr_o = <ls_yearseg>-cum-depr_o.
    ls_transaction-prev_prev-depr_s = <ls_yearseg>-cum-depr_s.
    ls_transaction-prev_prev-revl   = <ls_yearseg>-cum-revl.
    ls_transaction-prev_prev-revl_d = <ls_yearseg>-cum-revl_d.
    ls_transaction-curr_type        = <ls_yearseg>-curr_type.

    APPEND ls_transaction TO mt_transaction_post.
  ENDLOOP.

  APPEND LINES OF  mt_transaction_post TO  mt_transaction.

  "Adjust also Changeover year and period - changing also past should cause no issue
  LOOP AT lo_processing_handle->mts_hlpseg ASSIGNING FIELD-SYMBOL(<ls_hlpseg>).

    AT NEW curr_type.
      CHECK <ls_hlpseg>-changeover_yr IS NOT INITIAL.

      ls_depr_param-changeover_yr  = <ls_hlpseg>-changeover_yr.
      ls_depr_param-changeover_prd = <ls_hlpseg>-changeover_prd.

      MODIFY ms_asset_data-ts_depr_param FROM ls_depr_param TRANSPORTING changeover_yr changeover_prd
       WHERE depr_area = CONV bf_afabe_d( <ls_hlpseg>-area )
         AND curr_type = <ls_hlpseg>-curr_type.

    ENDAT.
  ENDLOOP.

* POSTCONDITION

ENDMETHOD.


  METHOD _transaction_add_on_posting.
* PRECONDITION
* exclude subsequent revenue/retirement costs as not relevant for depreciation calculation
    CHECK ms_transaction_cntrl-classification <> 'A8'.
    CHECK ms_transaction_cntrl-classification <> 'B8'.

* exclude transactions of type take over of legacy acumulated values as they are covered in YEARSEG
    CHECK ms_transaction_cntrl-classification <> 'E7'.
    CHECK ms_transaction_cntrl-classification <> 'C7'.
    CHECK ms_transaction_cntrl-classification <> '77'.      "2252940
    CHECK ms_transaction_cntrl-classification <> '87'.      "2252940
    CHECK ms_transaction_cntrl-classification <> '97'.      "2252940
    CHECK ms_transaction_cntrl-classification <> '06'.      "2226481


* DEFINITION

* BODY
* ensure that we take over overwritten values on retirement and post. cap.
  IF ms_transaction_cntrl-classification EQ if_faa_posting_constants=>gc_movcat-retirement   OR
       ms_transaction_cntrl-classification EQ if_faa_posting_constants=>gc_movcat-transfer_ret OR
       ms_transaction_cntrl-classification EQ if_faa_posting_constants=>gc_movcat-postcap.
      CHECK ms_transaction_cntrl-no_prop_val_calc EQ abap_true.
    ENDIF.

    APPEND LINES OF mt_transaction_post TO mt_transaction.

* POSTCONDITION

ENDMETHOD.


  METHOD _transaction_add_on_retirement.
*---------------------------------------------------------------------------------------------------------*
* Reworked/ Cleanup up with 19/08
* Special retirement 2: correction with note  3076174
*---------------------------------------------------------------------------------------------------------*
* PRECONDITION
    CHECK ms_transaction_cntrl-no_prop_val_calc EQ abap_false.
    CHECK ms_transaction_cntrl-classification   EQ gc_classification-retirement
       OR ms_transaction_cntrl-classification   EQ gc_classification-transfer_ret.

* DEFINITION
    FIELD-SYMBOLS <ls_hlpseg>                TYPE ty_s_hlpseg.
    FIELD-SYMBOLS <ls_area>                  TYPE if_faa_depr_calc_types=>ty_s_area.
    FIELD-SYMBOLS <ls_curtp_amount>          TYPE if_faa_depr_calc_types=>ty_s_curtp_amount.
    FIELD-SYMBOLS <ls_areasign>              TYPE ty_s_areasign.
    FIELD-SYMBOLS <ls_yearseg>               TYPE ty_s_yearseg.

    FIELD-SYMBOLS <lv_prop_amount>           TYPE any.
    FIELD-SYMBOLS <lv_percentage>            TYPE proz_abgwe.

    DATA lo_processing_handle                LIKE me.
    DATA lt_area                             TYPE if_faa_depr_calc_types=>ty_t_area.

    DATA ls_transaction                      TYPE ty_s_transaction.
    DATA ls_sumseg                           TYPE ty_s_sumseg.
    DATA ls_hlpseg                           TYPE ty_s_hlpseg.
    DATA ls_calcamount                       TYPE ty_s_calcamount.
    DATA ls_curtp_amount                     TYPE if_faa_depr_calc_types=>ty_s_curtp_amount.
    DATA ls_curtp_amount_hlp                 TYPE if_faa_depr_calc_types=>ty_s_curtp_amount.

    DATA lv_fiscal_year TYPE ty_s_hlpseg-fyear. "##NEEDED
    DATA lv_period_to                        TYPE ty_s_hlpseg-period_to.
    DATA lv_prop_amount                      TYPE nafav.
    DATA lv_base_amount                      TYPE ty_s_value-apc.
    DATA lv_ret_amount                       TYPE ty_s_value-apc.
    DATA lv_base_sign                        TYPE i.
    DATA lv_ret_sign                         TYPE i.
    DATA lv_message                          TYPE string.
    DATA lv_curr_type_base_area              TYPE curtp.

* BODY
*=======================================================================
* prepare and perform value calculation up to value date of retirement
*=======================================================================
    CREATE OBJECT lo_processing_handle.

* take over posting date independant data
    lo_processing_handle->ms_proc_data   = ms_proc_data.
    lo_processing_handle->mo_start       = mo_start.
    lo_processing_handle->mts_area       = mts_area.
    lo_processing_handle->mt_yearseg     = mt_yearseg.
    lo_processing_handle->mt_areasign    = mt_areasign.
    lo_processing_handle->mt_rounding    = mt_rounding.
    lo_processing_handle->mt_virtarea    = mt_virtarea.
    lo_processing_handle->mt_virtarea_s4 = mt_virtarea_s4.

* adjust/create value date dependant attribute tables for consistency check
    lo_processing_handle->ms_proc_data-step = gc_step-dc_int_retirement_request.

* Limit HLPSEG to calculation period assigned to value date
    LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
      AT NEW amount_type.
        LOOP AT mts_hlpseg ASSIGNING FIELD-SYMBOL(<ls_hlpseg_get_period>)
          WHERE area             = <ls_hlpseg>-area
            AND curr_type        = <ls_hlpseg>-curr_type
            AND to_date_of_tddp >= ms_transaction_cntrl-value_date
            AND amount_type      = <ls_hlpseg>-amount_type.

          CALL METHOD get_calc_yr_and_per_4_trnsctn
            EXPORTING
              is_hlpseg             = <ls_hlpseg_get_period>
              iv_per_ctrl_group     = ms_transaction_cntrl-periodcontrol
              iv_value_date         = ms_transaction_cntrl-value_date
            IMPORTING
              ev_fiscal_year        = lv_fiscal_year
              ev_calculation_period = lv_period_to.
          EXIT.
        ENDLOOP.

        READ TABLE mts_area ASSIGNING <ls_area>
          WITH KEY depr_area = <ls_hlpseg>-area.
        IF <ls_area>-retirement_type = 2.
          lv_period_to = <ls_hlpseg>-periods_short_fy + 1.
        ENDIF.
      ENDAT.

* do not consider intervals behind LV_PERIOD_TO
      CHECK <ls_hlpseg>-period_from <= lv_period_to.

      ls_hlpseg = <ls_hlpseg>.

* adjust PERIOD_TO of the interval if it ends behind
      IF ls_hlpseg-amount_type NA 'AC'.
        IF lv_fiscal_year = <ls_hlpseg>-fyear.
          IF ls_hlpseg-period_to >= lv_period_to.
            ls_hlpseg-period_to = lv_period_to - 1.

            IF ls_hlpseg-period_to = 0.
              ls_hlpseg-period_from = 0.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

* intervals with period from > adjusted PERIOD_TO are not to be considered
      IF ls_hlpseg-period_from > ls_hlpseg-period_to.
        CONTINUE.
      ENDIF.

      APPEND ls_hlpseg TO lo_processing_handle->mts_hlpseg.
    ENDLOOP.

* eliminate transactions with a posting date or value date behind the actual one
    lo_processing_handle->mt_transaction = mt_transaction.

    DELETE lo_processing_handle->mt_transaction
     WHERE posting_date > ms_transaction_cntrl-posting_date
        OR value_date   > ms_transaction_cntrl-value_date.

    CALL METHOD lo_processing_handle->_timeseg_create.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_timeseg.
    CALL METHOD lo_processing_handle->_hlpseg_split_on_alignment.
    CALL METHOD lo_processing_handle->_hlpseg_get_exp_life_seg.
    CALL METHOD lo_processing_handle->_timeseg_create_missing.
    CALL METHOD lo_processing_handle->_parameter_create.
    CALL METHOD lo_processing_handle->_parameter_call_badi.
    CALL METHOD lo_processing_handle->_period_create.
    CALL METHOD lo_processing_handle->_sumseg_create.
    CALL METHOD lo_processing_handle->_calcorder_create.
    CALL METHOD lo_processing_handle->_values_calculate.

*=======================================================================
* perform proportional value calculation
* consider that there might be no entry in table MTS_CALCAMOUNT if:
* - area is assigned to a group asset
* - no automatic calculation due to depreciation method
* - retirement posting is assigned to period 1 => HLPSEG-PERIO_TO = 0
*=======================================================================

* determine areas which area to be regarded on proportional value calculation to ensure
* correct processing on check if asset should be deactivated on ledger group level
    DATA(lt_transaction_hlp) = mt_transaction_post.
    SORT lt_transaction_hlp BY area curr_type.
    DELETE ADJACENT DUPLICATES FROM lt_transaction_hlp COMPARING area curr_type.

    LOOP AT lt_transaction_hlp ASSIGNING FIELD-SYMBOL(<ls_transaction_hlp>).
      "Create Base area entry first
      AT NEW area.
        READ TABLE mts_area INTO DATA(ls_area_base_orig)
          WITH KEY depr_area = <ls_transaction_hlp>-area.
        ASSERT sy-subrc = 0.

        INSERT ls_area_base_orig INTO TABLE lt_area.
        READ TABLE lt_area ASSIGNING FIELD-SYMBOL(<ls_area_base_new>)
          WITH KEY depr_area = <ls_transaction_hlp>-area.
        ASSERT sy-subrc = 0.

        CLEAR: <ls_area_base_new>-t_curtp_amount.
      ENDAT.

      "Add new CURR_TYPE
      READ TABLE ls_area_base_orig-t_curtp_amount ASSIGNING <ls_curtp_amount>
        WITH KEY curr_type = <ls_transaction_hlp>-curr_type.
      ASSERT sy-subrc = 0.

      APPEND <ls_curtp_amount> TO <ls_area_base_new>-t_curtp_amount.
    ENDLOOP.

    SORT lt_area BY sort_sequence ASCENDING is_base_area DESCENDING.
*-----------------------------------------------------------------------
    CLEAR mt_transaction_post.

    LOOP AT lt_area ASSIGNING <ls_area>.
      CLEAR lv_curr_type_base_area.

      LOOP AT <ls_area>-t_curtp_amount ASSIGNING <ls_curtp_amount>.
        IF lv_curr_type_base_area IS INITIAL.
          READ TABLE <ls_area>-t_curtp_amount INTO DATA(ls_curtp_amount_help) INDEX 1.
          lv_curr_type_base_area = ls_curtp_amount_help-curr_type.
        ENDIF.

        READ TABLE mt_areasign ASSIGNING <ls_areasign>
          WITH KEY area  = <ls_area>-depr_area.
        ASSERT sy-subrc EQ 0.

        READ TABLE mt_yearseg ASSIGNING <ls_yearseg>
          WITH KEY area      = <ls_area>-depr_area
                   curr_type = <ls_curtp_amount>-curr_type.
        ASSERT sy-subrc EQ 0.

        READ TABLE lo_processing_handle->mt_sumseg INTO ls_sumseg
          WITH KEY area      = <ls_area>-depr_area
                   curr_type = <ls_curtp_amount>-curr_type.
        IF sy-subrc <> 0.
          CLEAR ls_sumseg.
        ENDIF.

        READ TABLE lo_processing_handle->mts_calcamount INTO ls_calcamount
          WITH KEY area      = <ls_area>-depr_area
                   curr_type = <ls_curtp_amount>-curr_type.
        IF sy-subrc <> 0.
          CLEAR ls_calcamount.
        ENDIF.

* determine percentage to be applied for all areas on partial retirement
        IF <ls_area>-is_base_area = abap_true  AND  <ls_curtp_amount>-curr_type = lv_curr_type_base_area.
          READ TABLE <ls_area>-t_curtp_amount INTO ls_curtp_amount
            WITH KEY curr_type = <ls_curtp_amount>-curr_type.
          ASSERT sy-subrc = 0.

          lv_ret_sign = -1.

* begin_of_note 2995809 / Partial Retirement with different sign than group asset has - flag was set in _ADJUST_PROC_INFO_RET_POSTCAP
          IF <ls_area>-is_no_abs EQ abap_true.
            IF ls_curtp_amount-prev_prev_apc <> 0.
              IF sign( ls_curtp_amount-prev_prev_apc ) EQ sign( <ls_yearseg>-cum-apc  + ls_sumseg-prev_prev-apc ).
                lv_ret_sign = 1.
              ENDIF.
            ELSEIF ls_curtp_amount-cur_apc <> 0.
              IF sign( ls_curtp_amount-cur_apc ) EQ sign( ls_sumseg-cur-apc ).
                lv_ret_sign = 1.
              ENDIF.
            ENDIF.
            ls_curtp_amount-cur_apc       = abs( ls_curtp_amount-cur_apc ).
            ls_curtp_amount-prev_prev_apc = abs( ls_curtp_amount-prev_prev_apc ).
          ENDIF.
* end_of_note 2995809

* on prior year related partial retirement

          IF ls_curtp_amount-prev_prev_apc <> 0.
            ASSIGN ls_curtp_amount-prev_prev_percent TO <lv_percentage>.

            lv_ret_amount   = abs( <ls_curtp_amount>-prev_prev_apc ).

            IF <ls_areasign>-apc <> gc_area_value_sign-none.
              lv_base_amount = abs( <ls_yearseg>-cum-apc + ls_sumseg-prev_prev-apc ).

* on retirement simulation by settlement include prior year doen payments to avoid error 416
* if the amount of the down payments are greater than the APC amount
            IF <ls_area>-retirement_type = 9.
                lv_base_amount = abs( <ls_yearseg>-cum-apc  + ls_sumseg-prev_prev-apc
                                    + <ls_yearseg>-cum-downp ).

                IF sign( <ls_yearseg>-cum-apc + ls_sumseg-prev_prev-apc + <ls_yearseg>-cum-downp ) < 0.
                  lv_ret_sign = 1.
                ENDIF.
              ENDIF.

              IF  ( NOT cl_faa_fin_flags=>is_active( cl_faa_fin_flags=>con_flags-revl_consider_for_ret ) IS INITIAL ). "2869939
                lv_base_amount = abs( lv_base_amount  + <ls_yearseg>-cum-revl + ls_sumseg-prev_prev-revl "2869939
                                                                              + ls_sumseg-prev_cur-revl ). "2869939
              ENDIF.

            ELSE.
              IF <ls_areasign>-invs <> gc_area_value_sign-none.
                lv_base_amount = abs( <ls_yearseg>-cum-invs + ls_sumseg-prev_prev-invs ).
              ENDIF.

              IF <ls_areasign>-revl <> gc_area_value_sign-none.
                lv_base_amount = abs( <ls_yearseg>-cum-revl + ls_sumseg-prev_prev-revl ).
              ENDIF.
            ENDIF.

            IF lv_base_amount LT lv_ret_amount.
              IF <ls_area>-retirement_type <> 9  OR  <ls_areasign>-sign <> gc_area_value_sign-any.
                MESSAGE e316(aa) INTO lv_message.
              ENDIF.
            ENDIF.

            IF lv_ret_amount <> 0  AND  lv_base_amount EQ 0.
              IF <ls_area>-retirement_type <> 9  OR  <ls_areasign>-sign <> gc_area_value_sign-any.
                MESSAGE e416(aa) INTO lv_message.
              ENDIF.
            ENDIF.

            IF lv_ret_amount <> 0  AND  lv_base_amount <> 0  AND  lv_message IS INITIAL.
              DATA(lv_percentage) = lv_ret_amount * 100 / lv_base_amount.
              IF lv_percentage LE 100.
                <lv_percentage> = lv_percentage.
              ELSE.
                <lv_percentage> = 100.
              ENDIF.
            ENDIF.
          ENDIF.

* on current year related partial retirement
          IF ls_curtp_amount-cur_apc <> 0.
            ASSIGN ls_curtp_amount-cur_percent TO <lv_percentage>.

            lv_ret_amount   = abs( <ls_curtp_amount>-cur_apc ).

            IF <ls_areasign>-apc <> gc_area_value_sign-none.
              lv_base_amount = abs( ls_sumseg-cur-apc ).

* on retirement simulation by settlement include current year down payments to avoid error 417
* if the amount of the down payments are greater than the APC amount
              IF <ls_area>-retirement_type = 9.
                lv_base_amount = abs( ls_sumseg-cur-apc + ls_sumseg-cur-downp ).
              ENDIF.

              IF  ( NOT cl_faa_fin_flags=>is_active( cl_faa_fin_flags=>con_flags-revl_consider_for_ret ) IS INITIAL ). "2869939
                lv_base_amount = abs( lv_base_amount  + ls_sumseg-cur-revl ). "2869939
              ENDIF.                                        "2869939

            ELSE.
              IF <ls_areasign>-invs <> gc_area_value_sign-none.
                lv_base_amount = abs( ls_sumseg-cur-invs ).
              ENDIF.

              IF <ls_areasign>-revl <> gc_area_value_sign-none.
                lv_base_amount = abs( ls_sumseg-cur-revl ).
              ENDIF.
            ENDIF.

            IF lv_base_amount LT lv_ret_amount.
              IF <ls_area>-retirement_type <> 9  OR  <ls_areasign>-sign <> gc_area_value_sign-any.
                MESSAGE e317(aa) INTO lv_message.
              ENDIF.
            ENDIF.

            IF lv_ret_amount <> 0  AND  lv_base_amount EQ 0.
              IF <ls_area>-retirement_type <> 9  OR  <ls_areasign>-sign <> gc_area_value_sign-any.
                MESSAGE e417(aa) INTO lv_message.
              ENDIF.
            ENDIF.

            IF lv_ret_amount <> 0  AND  lv_base_amount <> 0  AND  lv_message IS INITIAL.
              lv_percentage = lv_ret_amount * 100 / lv_base_amount.
              IF lv_percentage LE 100.
                <lv_percentage> = lv_percentage.
              ELSE.
                <lv_percentage> = 100.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.

* EXIT Loop on error if amount entered is too high
        IF lv_message IS NOT INITIAL.
          WRITE <ls_yearseg>-area TO syst-msgv1.
          WRITE lv_base_amount    TO syst-msgv2 LEFT-JUSTIFIED DECIMALS <ls_area>-arearef->ms_setup-curr_decimals.
          me->create_message_from_syst( ).
        ENDIF.


* calculate proportional values
        CLEAR ls_transaction.

        ls_transaction-cntrl     = ms_transaction_cntrl.
        ls_transaction-area      = <ls_yearseg>-area.
        ls_transaction-curr_type = <ls_curtp_amount>-curr_type.


* calculate base amounts related to previous fisc. year for proportional value calc.
        IF ls_curtp_amount-prev_prev_percent <> 0  OR  <ls_area>-retirement_type = 2.
          ls_transaction-prev_cur-invs    = ls_sumseg-prev_cur-invs.
          ls_transaction-prev_cur-revl    = ls_sumseg-prev_cur-revl   + ls_calcamount-prev-revl.
          ls_transaction-prev_cur-revl_d  = ls_sumseg-prev_cur-revl_d + ls_calcamount-prev-revl_d.
          ls_transaction-prev_cur-depr_o  = ls_sumseg-prev_cur-depr_o + ls_calcamount-prev-depr_o.
          ls_transaction-prev_cur-depr_s  = ls_sumseg-prev_cur-depr_s + ls_calcamount-prev-depr_s.
          ls_transaction-prev_cur-depr_u  = ls_sumseg-prev_cur-depr_u.
          ls_transaction-prev_cur-resv    = ls_sumseg-prev_cur-resv.
          ls_transaction-prev_cur-downp   = ls_sumseg-prev_cur-downp.

          ls_transaction-prev_prev-apc    = <ls_yearseg>-cum-apc      + ls_sumseg-prev_prev-apc.
          ls_transaction-prev_prev-invs   = <ls_yearseg>-cum-invs     + ls_sumseg-prev_prev-invs.
          ls_transaction-prev_prev-revl   = <ls_yearseg>-cum-revl     + ls_sumseg-prev_prev-revl.
          ls_transaction-prev_prev-revl_d = <ls_yearseg>-cum-revl_d   + ls_sumseg-prev_prev-revl_d.
          ls_transaction-prev_prev-depr_o = <ls_yearseg>-cum-depr_o   + ls_sumseg-prev_prev-depr_o.
          ls_transaction-prev_prev-depr_s = <ls_yearseg>-cum-depr_s   + ls_sumseg-prev_prev-depr_s.
          ls_transaction-prev_prev-depr_u = <ls_yearseg>-cum-depr_u   + ls_sumseg-prev_prev-depr_u.
          ls_transaction-prev_prev-resv   = <ls_yearseg>-cum-resv     + ls_sumseg-prev_prev-resv.
          ls_transaction-prev_prev-downp  = <ls_yearseg>-cum-downp    + ls_sumseg-prev_prev-downp.
        ENDIF.

* calculate base amounts related to actual fisc. year for proportional value calc.
        IF ls_curtp_amount-cur_percent <> 0  OR  <ls_area>-retirement_type = 2.
          ls_transaction-cur-apc          = ls_sumseg-cur-apc.
          ls_transaction-cur-invs         = ls_sumseg-cur-invs        + ls_calcamount-total-invs.
          ls_transaction-cur-revl         = ls_sumseg-cur-revl        + ls_calcamount-total-revl   - ls_calcamount-prev-revl.
          ls_transaction-cur-revl_d       = ls_sumseg-cur-revl_d      + ls_calcamount-total-revl_d - ls_calcamount-prev-revl_d.
          ls_transaction-cur-depr_o       = ls_sumseg-cur-depr_o      + ls_calcamount-total-depr_o - ls_calcamount-prev-depr_o.
          ls_transaction-cur-depr_s       = ls_sumseg-cur-depr_s      + ls_calcamount-total-depr_s - ls_calcamount-prev-depr_s.
          ls_transaction-cur-depr_u       = ls_sumseg-cur-depr_u      + ls_calcamount-total-depr_u.
          ls_transaction-cur-resv         = ls_sumseg-cur-resv        + ls_calcamount-total-resv.
          ls_transaction-cur-downp        = ls_sumseg-cur-downp       + ls_calcamount-total-downp.
        ENDIF.

        CASE <ls_area>-retirement_type.

* simulate complete retirement on retirement type 2 to provide nbv at the end of the year
          WHEN 2.
            ls_transaction-periodcontrol = gc_period_group-endofyear.

            ls_curtp_amount_hlp               = ls_curtp_amount.
            ls_curtp_amount-prev_prev_percent = 100.
            ls_curtp_amount-cur_percent       = 100.

* nothing to be retired at all on scrapping with retirement type 2 which is changed to 8 to provide
* the information that this is no sale and shift the transaction to end of year to avoid interval splitting
          WHEN 8.
            ls_transaction-periodcontrol = gc_period_group-endofyear.

* if asset is an asset under construction (Retirement type = 9) which has down payments
* those have to be regarded on retirement simulation but not on final settlement
          WHEN 9.

            IF <ls_curtp_amount>-prev_prev_apc <> 0  OR  <ls_curtp_amount>-cur_apc <> 0.

              ls_transaction-prev_prev-downp = 0.
              ls_transaction-cur-downp       = 0.
            ENDIF.

* for all other retirements down payments have not to be regarded at all
          WHEN OTHERS.
            ls_transaction-prev_prev-downp = 0.
            ls_transaction-cur-downp       = 0.
        ENDCASE.

* perform proportional value calculation
        DO 10 TIMES.

          ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-prev_cur TO <lv_prop_amount>.

* if area is assigned to a group asset no depreciation is to be considered
          IF <ls_area>-grp_asset_assgnd = abap_true.
            IF sy-index < 3 OR sy-index > 8.
            ELSE.
              <lv_prop_amount> = 0.
            ENDIF.
          ENDIF.

* calculate proportional amount
          IF <lv_prop_amount> <> 0.
            <lv_prop_amount> = <lv_prop_amount> * ls_curtp_amount-prev_prev_percent * lv_ret_sign / 100.
            lv_prop_amount   = <lv_prop_amount>.
            <lv_prop_amount> =  lv_prop_amount.
          ENDIF.

          ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-prev_prev TO <lv_prop_amount>.
          IF <lv_prop_amount> <> 0.
            <lv_prop_amount> = <lv_prop_amount> * ls_curtp_amount-prev_prev_percent * lv_ret_sign / 100.
            lv_prop_amount   = <lv_prop_amount>.
            <lv_prop_amount> =  lv_prop_amount.
          ENDIF.

          ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-cur TO <lv_prop_amount>.
          IF <lv_prop_amount> <> 0.
            <lv_prop_amount> = <lv_prop_amount> * ls_curtp_amount-cur_percent * lv_ret_sign / 100.
            lv_prop_amount   = <lv_prop_amount>.
            <lv_prop_amount> =  lv_prop_amount.
          ENDIF.

          IF sy-index = 1 AND <ls_area>-retirement_type = 9.
            IF <ls_curtp_amount>-prev_prev_apc <> 0   OR   <ls_curtp_amount>-cur_apc       <> 0.
              ls_transaction-prev_prev-apc = <ls_curtp_amount>-prev_prev_apc.
              ls_transaction-cur-apc       = <ls_curtp_amount>-cur_apc.
            ENDIF.
          ENDIF.

        ENDDO.

* put back calculated percentage for proportional value calculation for next area
* and get statistical APC
        CASE <ls_area>-retirement_type.
        WHEN 1.
          IF ls_transaction-classification = if_faa_posting_constants=>gc_classification-transfer_ret.
            "Note 2952467
            "Same behaviour as in FAA_DC_PROP_VALUES_CALCULATE: for special handling of
            "transfer posting proportional values should not be calculated.
            DO 10 TIMES.
              IF ( sy-index >= 2 AND sy-index <= 7 )
                OR sy-index = 9.
                "REVL, INVS, DEPR_O, DEPR_S, DEPR_U, RESV, REVL_D
              ELSE.
                CONTINUE.
              ENDIF.

              ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-prev_cur TO <lv_prop_amount>.
              CLEAR <lv_prop_amount>.

              ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-prev_prev TO <lv_prop_amount>.
              CLEAR <lv_prop_amount>.

              ASSIGN COMPONENT sy-index OF STRUCTURE ls_transaction-cur TO <lv_prop_amount>.
              CLEAR <lv_prop_amount>.
            ENDDO.
          ENDIF.
        WHEN 2.
          "Set back to old information
            ls_curtp_amount = ls_curtp_amount_hlp.

            lv_prop_amount                      = ls_transaction-prev_prev-apc * ls_curtp_amount-prev_prev_percent / 100.
            ls_transaction-prev_prev-apc_ret_ia = lv_prop_amount.

            lv_prop_amount                      = ls_transaction-cur-apc       * ls_curtp_amount-cur_percent / 100.
            ls_transaction-cur-apc_ret_ia       = lv_prop_amount.

* scrapping with retirement type 2 => clear all values, as nothing is to be retired
          WHEN 8.
            lv_prop_amount                      = ls_transaction-prev_prev-apc.
            CLEAR ls_transaction-prev_prev.
            CLEAR ls_transaction-prev_cur.
            ls_transaction-prev_prev-apc_ret_ia = lv_prop_amount.

            lv_prop_amount                      = ls_transaction-cur-apc.
            CLEAR ls_transaction-cur.
            ls_transaction-cur-apc_ret_ia       = lv_prop_amount.

        ENDCASE.

* perform value adjustment on partial retirement if residual value is to be regarded
        IF ls_curtp_amount-prev_prev_percent IS INITIAL  OR  ls_curtp_amount-cur_percent IS INITIAL.

"note_3001621 / if only APCs should be posted there should be no adjustments of proportional values (already 0) - may cause NBV error later on
        IF <ls_area>-retirement_type = 1 AND
           ls_transaction-classification = if_faa_posting_constants=>gc_classification-transfer_ret.
        ELSE.
          CALL METHOD lo_processing_handle->adjust_prop_values_on_minval
            EXPORTING
              is_calcamount  = ls_calcamount
              is_yearseg     = <ls_yearseg>
              is_sumseg      = ls_sumseg
              is_areasign    = <ls_areasign>
            CHANGING
              cs_transaction = ls_transaction.
        ENDIF.
        ENDIF.

        APPEND ls_transaction TO mt_transaction_post.
        APPEND ls_transaction TO mt_transaction.
      ENDLOOP.
    ENDLOOP.

* POSTCONDITION

  ENDMETHOD.


  METHOD _transaction_adjst_on_reversal.
*=======================================================================
* remove reversed items to avoid interval splits that could lead to
* rounding issues on depreciation calculation
*=======================================================================
* PRECONDITION
* exclude subsequent revenue/retirement costs as not relevant for depreciation calculation
  CHECK ms_transaction_cntrl-classification <> 'A8'.
  CHECK ms_transaction_cntrl-classification <> 'B8'.

* exclude transactions of type take over of legacy acumulated values as they are covered in YEARSEG
    CHECK ms_transaction_cntrl-classification <> 'E7'.      "2252940
    CHECK ms_transaction_cntrl-classification <> 'C7'.
    CHECK ms_transaction_cntrl-classification <> '77'.
    CHECK ms_transaction_cntrl-classification <> '87'.
    CHECK ms_transaction_cntrl-classification <> '97'.

* DEFINITION

* BODY
* we need to regard all postings, to ensure correct planvalue creation
* special logic to avoid interval splitting is moved to _TIMESEG_CREATE
  APPEND LINES OF mt_transaction_post TO mt_transaction.

* POSTCONDITION

  ENDMETHOD.


  METHOD _transaction_create_from_db.
* PRECONDITION

* DEFINITION

* BODY
  mt_transaction = mo_start->ms_asset_data-t_transaction.

    DELETE mt_transaction
     WHERE fyear          <> ms_proc_data-fyear
        OR classification EQ 'A8'
        OR classification EQ 'B8'
        OR classification EQ 'E7'
        OR classification EQ 'C7'
        OR classification EQ '77'                           "2252940
        OR classification EQ '87'                           "2252940
        OR classification EQ '97'                           "2252940
        OR classification EQ '06'.
*     or SEQNO_REVERSED is not INITIAL."2226481

* POSTCONDITION

ENDMETHOD.


  METHOD _values_calculate.
*---------------------------------------------------------------------
* Reworked with 19/11
*---------------------------------------------------------------------
* PRECONDITION
* check if processing required at all
  CHECK NOT mts_calcorder[] IS INITIAL.

* DEFINITION
    DATA lsx_idata                  TYPE ty_sx_ee_idata.
    DATA lsx_edata                  TYPE ty_sx_ee_edata.

    DATA ls_currency                TYPE ty_s_ee_currency.
    DATA ls_sumseg                  TYPE ty_s_sumseg.
    DATA ls_error                   TYPE ty_s_ee_error.
    DATA lv_message                 TYPE string.
    DATA lo_message_handle          TYPE ty_o_dc_message_handle.

  FIELD-SYMBOLS <ls_sumseg>       TYPE ty_s_sumseg.
  FIELD-SYMBOLS <ls_virt_area_s4> TYPE ty_s_virtarea_s4.

* BODY
* provide created segments to Evaluation Engine
    lsx_idata-country         =  ms_proc_data-country.

* as AREASIGN and VIRTAREA do not change they are just created
    lsx_idata-t_rounding      =  mt_rounding.
    lsx_idata-t_areasign      =  mt_areasign.
    lsx_idata-t_virtarea      =  mt_virtarea.
    lsx_idata-t_virtarea_s4   =  mt_virtarea_s4.
    lsx_idata-ts_calcorder    =  mts_calcorder.
    lsx_idata-t_yearseg       =  mt_yearseg.
    lsx_idata-t_timeseg       =  mt_timeseg.
    lsx_idata-t_sumseg        =  mt_sumseg.
    lsx_idata-t_period        =  mt_period.
    lsx_idata-t_parameter     =  mt_parameter.

    "Currency Type Table
    "a) Normal areas
    LOOP AT mt_sumseg ASSIGNING <ls_sumseg>.
      ls_currency-area      = <ls_sumseg>-area.
      ls_currency-curr_type = <ls_sumseg>-curr_type.
      APPEND ls_currency TO lsx_idata-ts_currency.
    ENDLOOP.
    "b) Virtual areas
    LOOP AT mt_virtarea_s4 ASSIGNING <ls_virt_area_s4>.
      ls_currency-area      = <ls_virt_area_s4>-virt_depr_area.
      ls_currency-curr_type = <ls_virt_area_s4>-virt_curr_type.
      "on purpose: dublicate entries will not be inserted
      INSERT ls_currency INTO TABLE lsx_idata-ts_currency.
    ENDLOOP.

* call Evaluation Engine to calculate amounts
    cl_faa_da_api_factory=>get_ee( )->evaluate_amounts(
      EXPORTING
        isx_idata = lsx_idata
      IMPORTING
        esx_edata = lsx_edata ).

    mts_calcdata[]   = lsx_edata-ts_calcdata.
    mts_calcamount[] = lsx_edata-ts_calcamount.

* put error messages to message table
    LOOP AT lsx_edata-ts_error INTO ls_error.
      IF ls_error-var_01 IS INITIAL.
        ls_error-var_01 = ls_error-area.
      ENDIF.

      MESSAGE ID 'AA' TYPE 'E' NUMBER  ls_error-error_number
         WITH ls_error-var_01 ls_error-var_02 ls_error-var_03 ls_error-var_04
         INTO lv_message.

      CALL METHOD me->create_message_from_syst
        CHANGING
          co_message_handle = lo_message_handle.
    ENDLOOP.

    IF lo_message_handle IS BOUND.
      RAISE EXCEPTION lo_message_handle.
    ENDIF.

* POSTCONDITION

ENDMETHOD.


  METHOD _values_check_on_posting.
*---------------------------------------------------------------------------------------------------------*
* Reworked with 19/11
*---------------------------------------------------------------------------------------------------------*
* PRECONDITION
    CHECK ms_transaction_cntrl-classification <> gc_classification-writeup_gain_loss.

    IF  ms_transaction_cntrl-no_prop_val_calc = abap_false.
      CHECK ms_transaction_cntrl-classification <> if_faa_posting_constants=>gc_movcat-retirement.
      CHECK ms_transaction_cntrl-classification <> if_faa_posting_constants=>gc_movcat-transfer_ret.
      CHECK ms_transaction_cntrl-classification <> if_faa_posting_constants=>gc_movcat-transfer_acq.
    ENDIF.

    CHECK ms_transaction_cntrl-classification <> if_faa_posting_constants=>gc_movcat-downpayment.

* DEFINITION
    FIELD-SYMBOLS <ls_transaction>   TYPE ty_s_transaction.
    FIELD-SYMBOLS <ls_hlpseg>        TYPE ty_s_hlpseg.

    DATA lo_processing_handle        LIKE me.
    DATA lo_invsupport_handle        TYPE faa_dc_cfg_invsupport_handle.

    DATA lt_sumseg                   TYPE ty_t_sumseg.

    DATA ls_invsupport_key           TYPE faa_s_investment_support_key.
    DATA ls_yearseg                  TYPE ty_s_yearseg.
    DATA ls_timeseg                  TYPE ty_s_timeseg.
    DATA ls_sumseg                   TYPE ty_s_sumseg.

    TYPES:  BEGIN OF lty_invs_check,                         "< begin of 2853105
              base_area      TYPE faa_ee_area,
              base_curr_type TYPE faa_ee_curr_type,
              invs_area       TYPE faa_ee_area,
              invs_curr_type  TYPE faa_ee_curr_type,
              currency       TYPE waers,
              max_amount     TYPE ty_s_yearseg-cum-apc,
              sum_apc        TYPE ty_s_yearseg-cum-apc,
              sum_invs        TYPE ty_s_yearseg-cum-apc,
              max_amount_old TYPE ty_s_yearseg-cum-apc,
              sum_apc_old    TYPE ty_s_yearseg-cum-apc,
              sum_invs_old    TYPE ty_s_yearseg-cum-apc,
              max_amount_new TYPE ty_s_yearseg-cum-apc,
              sum_apc_new    TYPE ty_s_yearseg-cum-apc,
              sum_invs_new    TYPE ty_s_yearseg-cum-apc,
            END OF lty_invs_check.
   DATA: ls_invs_check       TYPE lty_invs_check,
         lt_invs_check       TYPE TABLE OF lty_invs_check,
         lv_sum_apc         TYPE ty_s_yearseg-cum-apc,
         lv_sum_apc_new     TYPE ty_s_yearseg-cum-apc,
         lv_sum_apc_old     TYPE ty_s_yearseg-cum-apc,
         lo_message_handle      TYPE ty_o_dc_message_handle, "< end of 2853105
         lv_max_amount      TYPE fins_vhcur12,              "< 3072530
         lv_max_amount_new  TYPE fins_vhcur12,              "< 3072530
         lv_max_amount_old  TYPE fins_vhcur12,              "< 3072530
         lv_sum_invs        TYPE fins_vhcur12,              "< 3076758
         ld_msgv2           LIKE sy-msgv2,                  "< 3076758
         ld_msgv3           LIKE sy-msgv3.                  "< 3076758
    DATA lv_message                  TYPE string.

* BODY
*----------------------------------------------------------------------------------*
* perform posting type independent check that relation to prior/current year is correct
*----------------------------------------------------------------------------------*
    CREATE OBJECT lo_processing_handle.

* take over posting date independent data
    "Create a local copy w/o mo_previous
    lo_processing_handle->mo_start            ?= mo_start->if_os_clone~clone( ).
*   lo_processing_handle->mo_start             = mo_start.
    lo_processing_handle->ms_proc_data         = ms_proc_data.
    lo_processing_handle->ms_asset_data        = ms_asset_data.
    lo_processing_handle->ms_transaction_cntrl = ms_transaction_cntrl.
    lo_processing_handle->mts_area             = mts_area.
    lo_processing_handle->mts_hlpseg           = mts_hlpseg.
    lo_processing_handle->mt_parameter         = mt_parameter.
    lo_processing_handle->mt_areasign          = mt_areasign.
    lo_processing_handle->mt_rounding          = mt_rounding.
    lo_processing_handle->mt_period            = mt_period.
    lo_processing_handle->mt_yearseg           = mt_yearseg.
    lo_processing_handle->mt_timeseg           = mt_timeseg.
    lo_processing_handle->mt_sumseg            = mt_sumseg.

    lo_processing_handle->ms_proc_data-step    = gc_step-dc_int_check_py_cy_assignmnt.

    CLEAR lo_processing_handle->mo_start->mt_virtarea.
    CLEAR lo_processing_handle->mo_start->mt_virtarea_s4.

    IF ms_transaction_cntrl-is_current_yr EQ abap_true.
      MODIFY lo_processing_handle->mt_yearseg FROM ls_yearseg TRANSPORTING cum
       WHERE fyear = ms_transaction_cntrl-fyear.

      MODIFY lo_processing_handle->mt_sumseg FROM ls_sumseg TRANSPORTING prev_prev prev_cur
       WHERE fyear = ms_transaction_cntrl-fyear.

      MODIFY lo_processing_handle->mt_timeseg FROM ls_timeseg TRANSPORTING prev_prev prev_cur
       WHERE fyear = ms_transaction_cntrl-fyear.

    ELSE.
      MODIFY lo_processing_handle->mt_sumseg FROM ls_sumseg TRANSPORTING cur
       WHERE fyear = ms_transaction_cntrl-fyear.

      MODIFY lo_processing_handle->mt_timeseg FROM ls_timeseg TRANSPORTING cur
       WHERE fyear = ms_transaction_cntrl-fyear.
    ENDIF.

    CALL METHOD lo_processing_handle->_calcorder_create.
    CALL METHOD lo_processing_handle->_values_calculate.

*----------------------------------------------------------------------------------*
* perform dedicated checks on manual depreciation posting, write-up and
* investment support
*----------------------------------------------------------------------------------*
    CASE ms_transaction_cntrl-classification.

* check if manual depreciation posting is allowed
      WHEN if_faa_posting_constants=>gc_movcat-depreciation.
        LOOP AT mt_transaction_post ASSIGNING <ls_transaction>.
          IF <ls_transaction>-prev_prev-depr_o <> 0 OR
             <ls_transaction>-prev_cur-depr_o  <> 0 OR
             <ls_transaction>-cur-depr_o       <> 0.

            READ TABLE mts_hlpseg  ASSIGNING <ls_hlpseg>
                  WITH KEY fyear       = <ls_transaction>-fyear
                           area        = <ls_transaction>-area
                           curr_type   = <ls_transaction>-curr_type
                           amount_type = gc_amount_type-ordn.
            IF sy-subrc                                          =  0                AND
              <ls_hlpseg>-key_phase_ref->ms_settings-percent_key <> gc_percent-key_n AND
              <ls_hlpseg>-grp_asset_assgnd                       =  abap_false.

              MESSAGE e633(aa) WITH  <ls_hlpseg>-depr_key INTO lv_message.
              me->create_message_from_syst( ).
            ENDIF.
          ENDIF.

          IF <ls_transaction>-prev_prev-depr_s <> 0 OR
             <ls_transaction>-prev_cur-depr_s  <> 0 OR
             <ls_transaction>-cur-depr_s       <> 0.

            READ TABLE mts_hlpseg  ASSIGNING <ls_hlpseg>
                  WITH KEY fyear       = <ls_transaction>-fyear
                           area        = <ls_transaction>-area
                           curr_type   = <ls_transaction>-curr_type
                           amount_type = gc_amount_type-spec.
            IF sy-subrc                                          =  0                AND
              <ls_hlpseg>-key_phase_ref->ms_settings-percent_key <> gc_percent-key_n AND
              <ls_hlpseg>-grp_asset_assgnd                       =  abap_false.

              MESSAGE e633(aa) WITH  <ls_hlpseg>-depr_key INTO lv_message.
              me->create_message_from_syst( ).
            ENDIF.
          ENDIF.
        ENDLOOP.

* check if write-up posting is allowed
      WHEN if_faa_posting_constants=>gc_movcat-writeup.
* <<< redesigned with 2853105  >>>
* check max amount of investment support is not hurt
* - get sum of all investment supports for base area and in SUMSEG
* - get sum of all investment supports for area to carry the investment support in SUMSEG
* - plus the sum of APC of the base area for checking purposes
      WHEN if_faa_posting_constants=>gc_movcat-inv_support.
        LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
          AT NEW curr_type.
*           CHECK  <ls_hlpseg>-curr_type = '10'.
            CHECK  <ls_hlpseg>-invsupport_key IS NOT INITIAL.
            ls_invsupport_key = <ls_hlpseg>-invsupport_key.
            lo_invsupport_handle = cl_faa_cfg_factory_static=>get_instance_investsupport(
                                       is_invsupport_key = VALUE #( measure_id = ls_invsupport_key  )
                                       iv_comp_code      = <ls_hlpseg>-arearef->mo_leadobj->get_leadobj_key( )-comp_code ).

*           investment support posted to liabilities -> get sum of APC of base area
            IF lo_invsupport_handle->mo_invsupport_area->mv_depr_area <> lo_invsupport_handle->mo_base_area->mv_depr_area.
              READ TABLE lt_invs_check INTO ls_invs_check
                     WITH KEY base_area = lo_invsupport_handle->mo_base_area->mv_depr_area
                              base_curr_type = <ls_hlpseg>-curr_type.

              IF sy-subrc NE 0.
                READ TABLE mt_sumseg INTO ls_sumseg
                  WITH KEY fyear     = <ls_hlpseg>-fyear
                           area      = lo_invsupport_handle->mo_base_area->mv_depr_area
                           curr_type = <ls_hlpseg>-curr_type.
                IF sy-subrc NE 0.
                  CONTINUE.
                ENDIF.

                CLEAR ls_invs_check.

                READ TABLE mt_yearseg INTO ls_yearseg
                       WITH KEY fyear      = ls_sumseg-fyear
                                area       = ls_sumseg-area
                                curr_type  = ls_sumseg-curr_type.

                ls_invs_check-base_area      = lo_invsupport_handle->mo_base_area->mv_depr_area.
                ls_invs_check-base_curr_type = <ls_hlpseg>-curr_type.
                ls_invs_check-sum_apc        =  ls_yearseg-cum-apc
                                             +  ls_sumseg-prev_prev-apc
                                             +  ls_sumseg-prev_cur-apc
                                             +  ls_sumseg-cur-apc.

                ls_invs_check-sum_apc        =  ABS( ls_invs_check-sum_apc ).

                ls_invs_check-sum_apc_old    = ls_yearseg-cum-apc
                                             + ls_sumseg-prev_prev-apc
                                             + ls_sumseg-prev_cur-apc.

                ls_invs_check-sum_apc_old = ABS( ls_invs_check-sum_apc_old ).
                ls_invs_check-sum_apc_new = ls_sumseg-cur-apc.
                ls_invs_check-sum_apc_new =  ABS( ls_invs_check-sum_apc_new ).
                APPEND ls_invs_check TO lt_invs_check.

              ENDIF.

*             get sum of investment supports posted to inv. area
              READ TABLE mt_sumseg INTO ls_sumseg
                     WITH KEY fyear     = <ls_hlpseg>-fyear
                              area      = <ls_hlpseg>-area
                              curr_type = <ls_hlpseg>-curr_type.


              READ TABLE mt_yearseg INTO ls_yearseg
                WITH KEY fyear     = ls_sumseg-fyear
                         area      = ls_sumseg-area
                         curr_type = ls_sumseg-curr_type.

*             note apc of base area to be used on inv. support area value check
*             to be able to perform COLLECT for base area with investment support amounts
              lv_sum_apc             = ls_invs_check-sum_apc.
              ls_invs_check-sum_apc  = 0.
              lv_sum_apc_old         = ls_invs_check-sum_apc_old.
              lv_sum_apc_new         = ls_invs_check-sum_apc_new.

              ls_invs_check-sum_apc_old = 0.
              ls_invs_check-sum_apc_new = 0.

*             Create entry for investment support area
              ls_invs_check-sum_invs = ls_yearseg-cum-invs
                                     + ls_sumseg-prev_prev-invs
                                     + ls_sumseg-prev_cur-invs
                                     + ls_sumseg-cur-invs.

              ls_invs_check-sum_invs_old = ls_yearseg-cum-invs
                                         + ls_sumseg-prev_prev-invs
                                         + ls_sumseg-prev_cur-invs.
              ls_invs_check-sum_invs_new = ls_sumseg-cur-invs.

              ls_invs_check-sum_invs     = ABS( ls_invs_check-sum_invs ).
              ls_invs_check-sum_invs_old = ABS( ls_invs_check-sum_invs_old ).
              ls_invs_check-sum_invs_new = ABS( ls_invs_check-sum_invs_new ).

*             if several investment supports are assigned to the same base area sum them up for value check
*             investment support area is not base area => create entry with base area
*             base area is already filled with correct APC
*             (base area technically filled in READ lt_inv_check)

              COLLECT ls_invs_check INTO lt_invs_check.

*             keep in mind the APC amount for investment support area to determine maximum investment amount if
*             maximum percentage is used for investment support
              ls_invs_check-sum_apc     = lv_sum_apc.
              ls_invs_check-sum_apc_old = lv_sum_apc_old.
              ls_invs_check-sum_apc_new = lv_sum_apc_new.
            ENDIF.

*           area covers apc and investment support: determine sum of apc for value check
            IF lo_invsupport_handle->mo_invsupport_area->mv_depr_area EQ lo_invsupport_handle->mo_base_area->mv_depr_area.
*             get sum of investment supports posted to inv. area
              READ TABLE mt_sumseg INTO ls_sumseg
                     WITH KEY fyear     = <ls_hlpseg>-fyear
                              area      = <ls_hlpseg>-area
                              curr_type = <ls_hlpseg>-curr_type.

              READ TABLE mt_yearseg INTO ls_yearseg
                WITH KEY fyear     = ls_sumseg-fyear
                         area      = ls_sumseg-area
                         curr_type = ls_sumseg-curr_type.

              ls_invs_check-sum_apc = ls_yearseg-cum-apc
                                    + ls_sumseg-prev_prev-apc
                                    + ls_sumseg-prev_cur-apc
                                    + ls_sumseg-cur-apc.
              ls_invs_check-sum_apc_old = ls_yearseg-cum-apc
                                        + ls_sumseg-prev_prev-apc
                                        + ls_sumseg-prev_cur-apc.
              ls_invs_check-sum_apc_new = ls_sumseg-cur-apc.
              ls_invs_check-sum_apc     =  ABS( ls_invs_check-sum_apc ).
              ls_invs_check-sum_apc_old =  ABS( ls_invs_check-sum_apc_old ).
              ls_invs_check-sum_apc_new =  ABS( ls_invs_check-sum_apc_new ).
            ENDIF.

            ls_invs_check-base_area = lo_invsupport_handle->mo_base_area->mv_depr_area.
            ls_invs_check-invs_area = <ls_hlpseg>-area.
            ls_invs_check-invs_curr_type = <ls_hlpseg>-curr_type.
            ls_invs_check-base_curr_type = <ls_hlpseg>-curr_type.

*           get max amount allowed by investment support measure
            IF NOT lo_invsupport_handle->ms_setup-max_percentage IS INITIAL.
              ls_invs_check-max_amount     = ls_invs_check-sum_apc * lo_invsupport_handle->ms_setup-max_percentage / 100.
              ls_invs_check-max_amount_new = ls_invs_check-sum_apc_new * lo_invsupport_handle->ms_setup-max_percentage / 100.
              ls_invs_check-max_amount_old = ls_invs_check-sum_apc_old * lo_invsupport_handle->ms_setup-max_percentage / 100.
*             Round maximum amount to whole currencies since postings contain currency amounts
              lv_max_amount =     ABS( ls_invs_check-max_amount ).       "< begin of 3072530
              lv_max_amount_new = ABS( ls_invs_check-max_amount_new ).
              lv_max_amount_old = ABS( ls_invs_check-max_amount_old ).
              ls_invs_check-max_amount     = lv_max_amount.
              ls_invs_check-max_amount_new = lv_max_amount_new.
              ls_invs_check-max_amount_old = lv_max_amount_old.          "< end of 3072530

*             take lower amount
              IF NOT lo_invsupport_handle->ms_setup-max_amount IS INITIAL.

                IF lo_invsupport_handle->ms_setup-max_amount < ls_invs_check-max_amount.
                  ls_invs_check-max_amount     = lo_invsupport_handle->ms_setup-max_amount.
                  ls_invs_check-max_amount_new = ls_invs_check-sum_apc_new.
                  ls_invs_check-max_amount_old = ls_invs_check-sum_apc_old.
                ENDIF.

              ENDIF.

*            stated maximum amount is entered
             ELSE.

               IF NOT lo_invsupport_handle->ms_setup-max_amount IS INITIAL.

                 ls_invs_check-max_amount     = lo_invsupport_handle->ms_setup-max_amount.
                 ls_invs_check-max_amount_new = ls_invs_check-sum_apc_new.
                 ls_invs_check-max_amount_old = ls_invs_check-sum_apc_old.

               ENDIF.
             ENDIF.

*           Create entry for inv. sup.area, base area field is empty
            APPEND ls_invs_check TO lt_invs_check.
          ENDAT.
        ENDLOOP.

        SORT lt_invs_check BY invs_area DESCENDING.

*       lt_invs_check entries for  two investment support areas 51, 52 with the same base area and
*       acquisition of current year

*       base_area | base_curr_type | invs_area | invs_curr_type | max_amount | sum_apc | sum_invs | ...| max_amount_new | sum_apc_new | sum_invs_new
*       --------------------------------------------------------------------------------------------------------------------------------------------
*          01     |     30         |           |                | 0          | 10000   | 203      | ...|                |   10000     |   203  (52+151)
*          01     |     30         |      51   |     30         | 10000      | 10000   | 151      | ...|    10000       |   10000     |   151
*          01     |     30         |      52   |     30         | 10000      |  5000   |  52      | ...|     5000       |   10000     |    52
*                 |                |           |                |            |   50%   |          | ...|     50%        |             |
*      ------------------------------------------------------------------------------------------------------------------------------------------------
        LOOP AT lt_invs_check INTO ls_invs_check.
*         check max amount
*         check single investment supports
          IF NOT ls_invs_check-invs_area IS INITIAL.
*           Too much investment support on new acquisition
            IF ls_invs_check-max_amount_new < ls_invs_check-sum_invs_new AND
              ls_invs_check-sum_invs_new NE 0.

              lv_max_amount = ls_invs_check-max_amount_new.                             "< 3076758
              lv_sum_invs   = ls_invs_check-sum_invs_new.                               "< 3076758
              WRITE lv_max_amount CURRENCY ls_invs_check-invs_curr_type TO ld_msgv2.    "< 3076758
              WRITE lv_sum_invs   CURRENCY ls_invs_check-invs_curr_type TO ld_msgv3.    "< 3076758

              MESSAGE ID 'AA' TYPE 'E' NUMBER  '789'   "AA789
                WITH ls_invs_check-invs_area ld_msgv2 ld_msgv3                          "< 3076758
                INTO lv_message.
              me->create_message_from_syst( ).
            ENDIF.

*           Too much investment support on acquisition of previous fiscal years
            IF ls_invs_check-max_amount_old < ls_invs_check-sum_invs_old AND
               ls_invs_check-sum_invs_old NE 0.

               lv_max_amount = ls_invs_check-max_amount_old.                            "< 3076758
               lv_sum_invs   = ls_invs_check-sum_invs_old.                              "< 3076758
               WRITE lv_max_amount CURRENCY ls_invs_check-invs_curr_type TO ld_msgv2.   "< 3076758
               WRITE lv_sum_invs   CURRENCY ls_invs_check-invs_curr_type TO ld_msgv3.   "< 3076758

               MESSAGE ID 'AA' TYPE 'E' NUMBER '788'   "AA788
                 WITH ls_invs_check-invs_area ld_msgv2 ld_msgv3 INTO lv_message.        "< 3076758
               me->create_message_from_syst( ).

            ENDIF.

*           check complete investment support against complete APC, in case that
*           not yet any APC amounts are available
            IF ls_invs_check-max_amount < ls_invs_check-sum_invs AND
               ls_invs_check-max_amount = 0.
*
              lv_max_amount = ls_invs_check-max_amount.                                 "< 3076758
              lv_sum_invs   = ls_invs_check-sum_invs.                                   "< 3076758
              WRITE lv_max_amount CURRENCY ls_invs_check-invs_curr_type TO ld_msgv2.    "< 3076758
              WRITE lv_sum_invs   CURRENCY ls_invs_check-invs_curr_type TO ld_msgv3.    "< 3076758

              MESSAGE ID 'AA' TYPE 'E' NUMBER '642'  "AA642
                WITH ls_invs_check-invs_area ld_msgv2 ld_msgv3 INTO lv_message.         "< 3076758
              me->create_message_from_syst( ).                                 "ER9

            ENDIF.

*           Make sure that check against maximum amount is done, when check
*           against APC amounts prev./curr. year acquisition is passed
*           (Assets without APC but with maximum amount and special configuration/modification with check only on
*            asset level (no distinction between prior year and new acquisition)
            IF lv_message IS INITIAL.
              IF ls_invs_check-max_amount < ls_invs_check-sum_invs.

                lv_max_amount = ls_invs_check-max_amount.                                 "< 3076758
                lv_sum_invs   = ls_invs_check-sum_invs.                                   "< 3076758
                WRITE lv_max_amount CURRENCY ls_invs_check-invs_curr_type TO ld_msgv2.    "< 3076758
                WRITE lv_sum_invs   CURRENCY ls_invs_check-invs_curr_type TO ld_msgv3.    "< 3076758

                 MESSAGE ID 'AA' TYPE 'E' NUMBER '642'  "AA642
                   WITH ls_invs_check-invs_area ld_msgv2 ld_msgv3.                        "< 3076758
                 me->create_message_from_syst( ).

              ENDIF.
            ENDIF.

*           Messages are prepared, now they are raised

            IF NOT lv_message IS INITIAL.
*              CALL METHOD me->create_message_from_syst                     "ER9
*               CHANGING
*                 co_message_handle = lo_message_handle.
*
*             IF lo_message_handle IS BOUND.
*               RAISE EXCEPTION lo_message_handle.
*             ENDIF.
           ENDIF.

*         Checks for base area
          ELSE.
            CHECK ls_invs_check-invs_area IS INITIAL.
            CHECK ( ls_invs_check-sum_invs     > ls_invs_check-sum_apc OR
                    ls_invs_check-sum_invs_new > ls_invs_check-sum_apc_new  OR
                    ls_invs_check-sum_invs_old > ls_invs_check-sum_apc_old ).

            MESSAGE ID 'AA' TYPE 'E' NUMBER '661'  "AA642
                 WITH ls_invs_check-base_area INTO lv_message.
            me->create_message_from_syst( ).

          ENDIF.

      ENDLOOP.

*<<< end of changes note 2853105 >>>
*
*** determine APC amounts of base area's for check and ensure that each base area is
*** just considered once and note APC amounts of base area for investment support area
*            LOOP AT mt_sumseg INTO ls_sumseg
*              WHERE curr_type = '10'.
*
*              CHECK ls_sumseg-area = lo_invsupport_handle->mo_base_area->mv_depr_area
*                 OR ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*
*              CASE ls_sumseg-area.
*                WHEN lo_invsupport_handle->mo_base_area->mv_depr_area.
*                  "avoid that investment support is considered twice
*                  "investment support is filled later, fill here only APC
*                  CLEAR ls_sumseg-prev_prev-invs.
*                  CLEAR ls_sumseg-prev_cur-invs.
*                  CLEAR ls_sumseg-cur-invs.
*
*                  "APC amounts of BASE AREA from SUMSEG
*                  "Do this only once per base area independent on base area usage in several investment support keys ???????
*                  READ TABLE lt_sumseg TRANSPORTING NO FIELDS
*                    WITH KEY area      = lo_invsupport_handle->mo_base_area->mv_depr_area
*                             curr_type = ls_sumseg-curr_type.
*                  IF sy-subrc <> 0.
*                    COLLECT ls_sumseg INTO lt_sumseg.
*                  ENDIF.
*
*                  IF lo_invsupport_handle->mo_invsupport_area->mv_depr_area <> lo_invsupport_handle->mo_base_area->mv_depr_area.
*                    ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*                    COLLECT ls_sumseg INTO lt_sumseg.
*                  ENDIF.
*
*                  "APC amounts of BASE AREA from YEARSEG (prior fiscal year values)
*                  READ TABLE mt_yearseg INTO ls_yearseg
*                    WITH KEY area      = lo_invsupport_handle->mo_base_area->mv_depr_area
*                             curr_type = ls_sumseg-curr_type.
*                  ASSERT sy-subrc = 0.
*
*                  CLEAR ls_sumseg-prev_cur.
*                  CLEAR ls_sumseg-cur.
*                  ls_sumseg-area      = lo_invsupport_handle->mo_base_area->mv_depr_area.
*                  ls_sumseg-prev_prev = ls_yearseg-cum.
*                  CLEAR ls_sumseg-prev_prev-invs.
*
*                  COLLECT ls_sumseg INTO lt_sumseg.
*
*                  IF lo_invsupport_handle->mo_invsupport_area->mv_depr_area <> lo_invsupport_handle->mo_base_area->mv_depr_area.
*                    ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*                    COLLECT ls_sumseg INTO lt_sumseg.
*                  ENDIF.
*
*                WHEN lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*                  IF lo_invsupport_handle->mo_invsupport_area->mv_depr_area <> lo_invsupport_handle->mo_base_area->mv_depr_area.
*                    COLLECT ls_sumseg INTO lt_sumseg.
*
*                    " check if base area exists on asset to avoid error on pure investment support assets
*                    READ TABLE mt_yearseg TRANSPORTING NO FIELDS
*                      WITH KEY area      = lo_invsupport_handle->mo_base_area->mv_depr_area
*                               curr_type =  ls_sumseg-curr_type.
*
*                    CHECK sy-subrc = 0.
*                    ls_sumseg-area = lo_invsupport_handle->mo_base_area->mv_depr_area.
*                    COLLECT ls_sumseg INTO lt_sumseg.
*
*                  ENDIF.
*
*              ENDCASE.
*            ENDLOOP.
*
*            LOOP AT mt_sumseg INTO ls_sumseg.
*            ENDLOOP.
*
***        Consider investment support of prior years for checks
**            IF lo_invsupport_handle->mo_invsupport_area->mv_depr_area <> lo_invsupport_handle->mo_base_area->mv_depr_area.
**
**              READ TABLE mt_yearseg INTO ls_yearseg
**                WITH KEY area      = lo_invsupport_handle->mo_invsupport_area->mv_depr_area
**                         curr_type = '10'.
**              IF sy-subrc EQ 0.
**                CLEAR ls_sumseg-prev_cur.
**                CLEAR ls_sumseg-cur.
**                ls_sumseg-prev_prev = ls_yearseg-cum.
**
**                ls_sumseg-area  = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
**                COLLECT ls_sumseg INTO lt_sumseg.
**
**                ls_sumseg-area  =  lo_invsupport_handle->mo_base_area->mv_depr_area.
**                COLLECT ls_sumseg INTO lt_sumseg.
**              ENDIF.
**
**            ENDIF.
*
*          ENDAT.
*        ENDLOOP.
*
** perform check
*        LOOP AT mts_hlpseg ASSIGNING <ls_hlpseg>.
*          AT NEW curr_type.
*            CHECK  <ls_hlpseg>-invsupport_key IS NOT INITIAL.
*            ls_invsupport_key = <ls_hlpseg>-invsupport_key.
*            lo_invsupport_handle  = cl_faa_cfg_factory_static=>get_instance_investsupport(
*                                      is_invsupport_key = VALUE #( measure_id = ls_invsupport_key )
*                                      iv_comp_code      = <ls_hlpseg>-arearef->mo_leadobj->get_leadobj_key( )-comp_code ).
*
*
** determine maximum available APC amount and sum of investment support
*            LOOP AT lt_sumseg INTO ls_sumseg
*              WHERE ( area = lo_invsupport_handle->mo_base_area->mv_depr_area
*                 OR   area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area )
*                AND  curr_type = <ls_hlpseg>-curr_type. "XXX
*
*              DO 2 TIMES.
*                CASE sy-index.
*                  WHEN 1.
*                    lv_max_amount = ls_sumseg-prev_prev-apc.
*                    lv_apc        = ls_sumseg-prev_prev-apc.
*                    lv_inv_amount = ls_sumseg-prev_prev-invs + ls_sumseg-prev_cur-invs.
*                  WHEN 2.
*                    lv_max_amount = ls_sumseg-cur-apc.
*                    lv_apc        = ls_sumseg-cur-apc.
*                    lv_inv_amount = ls_sumseg-cur-invs.
*                ENDCASE.
*
** consider settings of investment support measure
*                IF ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*                  IF lo_invsupport_handle->ms_setup-max_percentage IS NOT INITIAL.
*                    lv_max_amount = lv_max_amount * lo_invsupport_handle->ms_setup-max_percentage / 100.
*                  ENDIF.
*
** if max amount defined and percentage => max amount wins
*                  IF lo_invsupport_handle->ms_setup-max_amount IS NOT INITIAL.
*                    lv_max_amount = lo_invsupport_handle->ms_setup-max_amount.
**                 Maximum amount may never be higher than APC amount
*                    IF lv_max_amount > lv_apc.
*                      lv_max_amount = lv_apc.
*                    ENDIF.
*                  ENDIF.
*                ENDIF.
*
*                lv_max_amount = abs( lv_max_amount ).
*                lv_inv_amount = abs( lv_inv_amount ).
*
** raise error message if (sum of) investment support exceeds the allowed maximum amount
*                CHECK lv_inv_amount > lv_max_amount.
*
*                CASE sy-index.
*                  WHEN 1.
**                 Acquistion of prior year
*                    IF ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*                      MESSAGE e788(aa) WITH ls_sumseg-area INTO lv_message.
*                      me->create_message_from_syst( ).
*                    ELSE.
*                      MESSAGE e661(aa) WITH ls_sumseg-area INTO lv_message.
*                      me->create_message_from_syst( ).
*                    ENDIF.
*                  WHEN 2.
*                    IF ls_sumseg-area = lo_invsupport_handle->mo_invsupport_area->mv_depr_area.
*                      MESSAGE e789(aa) WITH ls_sumseg-area INTO lv_message.
*                      me->create_message_from_syst( ).
*                    ELSE.
*                      MESSAGE e661(aa) WITH ls_sumseg-area INTO lv_message.
*                      me->create_message_from_syst( ).
*                    ENDIF.
*                ENDCASE.
*              ENDDO.
*            ENDLOOP.
*          ENDAT.
*        ENDLOOP.


* check revaluation is posted with correct transaction type and goes only to valid areas
      WHEN if_faa_posting_constants=>gc_movcat-reval_manual_acq
        OR if_faa_posting_constants=>gc_movcat-reval_o_depr
        OR if_faa_posting_constants=>gc_movcat-revaluation.

        DATA(lt_depr_area) = ms_proc_data-leadobj_ref->get_list_depr_area( ).

        LOOP AT mt_transaction_post ASSIGNING <ls_transaction>
          WHERE prev_prev IS NOT INITIAL
             OR prev_cur  IS NOT INITIAL
             OR cur       IS NOT INITIAL.

          CLEAR: ls_yearseg,
                 ls_sumseg.

* get depreciation are to check against
          READ TABLE lt_depr_area ASSIGNING FIELD-SYMBOL(<ls_arearef>)
            WITH KEY key_depr_area COMPONENTS depr_area = <ls_transaction>-area.

* if area posted to just carries revaluations get leading area of ledger group to check against
          IF <ls_arearef>-depr_area_ref->ms_setup-sign_apc = '0'.
            READ TABLE lt_depr_area ASSIGNING <ls_arearef> INDEX 1.
          ENDIF.

          READ TABLE mt_yearseg INTO ls_yearseg
            WITH KEY area      = <ls_arearef>-depr_area
                     curr_type = <ls_transaction>-curr_type.

          READ TABLE mt_sumseg INTO ls_sumseg
            WITH KEY area      = <ls_arearef>-depr_area
                     curr_type = <ls_transaction>-curr_type.

          ls_sumseg-prev_prev-apc    = ls_sumseg-prev_prev-apc    + ls_yearseg-cum-apc.
          ls_sumseg-prev_prev-depr_o = ls_sumseg-prev_prev-depr_o + ls_sumseg-prev_cur-depr_o + ls_yearseg-cum-depr_o.

          DO 1 TIMES.

* check that values are provided in correct amount fields
*          IF <ls_transaction>-prev_prev IS NOT INITIAL.            "< 2816315
*            MESSAGE e679(aa) WITH ls_yearseg-area INTO lv_message.
*            EXIT.
*          ENDIF.                                                   "< 2816315

* if area is posted to it may not calc. replacement value
            LOOP AT mts_hlpseg TRANSPORTING NO FIELDS
              WHERE area         = <ls_transaction>-area
                AND curr_type    = <ls_transaction>-curr_type
                AND amount_type CA gc_amount_type(2).
            ENDLOOP.

* check correct transaction type used
            IF sy-subrc = 0.
              MESSAGE e628(aa) WITH <ls_transaction>-area INTO lv_message.
              EXIT.
            ENDIF.

            IF ls_sumseg-prev_cur-revl <> 0 AND ls_sumseg-prev_prev-apc = 0.
              MESSAGE e629(aa) WITH ls_yearseg-area INTO lv_message.
              EXIT.
            ENDIF.

            IF ls_sumseg-cur-revl <> 0 AND ls_sumseg-cur-apc = 0.
              MESSAGE e629(aa) WITH ls_yearseg-area INTO lv_message.
              EXIT.
            ENDIF.

            IF ls_sumseg-prev_cur-revl_d <> 0 AND ls_sumseg-prev_prev-apc = 0.
              MESSAGE e629(aa) WITH ls_sumseg-area INTO lv_message.
              EXIT.
            ENDIF.

            IF ls_sumseg-cur-revl_d <> 0 AND ls_sumseg-cur-apc = 0.
              MESSAGE e629(aa) WITH ls_sumseg-area INTO lv_message.
              EXIT.
            ENDIF.
          ENDDO.

          IF lv_message IS NOT INITIAL.
            me->create_message_from_syst( ).
            RETURN.
          ENDIF.
        ENDLOOP.

    ENDCASE.

* POSTCONDITION

  ENDMETHOD.


  METHOD _virtarea_create.
*******************************************************************
* Reworked/Cleaned up with 1908
*******************************************************************
* PRECONDITION

* DEFINITION
    DATA ls_virtarea                TYPE if_faa_dc_segments_720=>ty_s_virtarea_s4.
    DATA lv_periods                 TYPE faa_dc_periods_short_yr.

* BODY
    LOOP AT ms_proc_data-leadobj_ref->get_list_depr_area( ) ASSIGNING FIELD-SYMBOL(<ls_arearef>).

      "insure that only real virtual areas (which may influence depr.) are considered
      CHECK <ls_arearef>-depr_area_ref->is_real_area( )                                            EQ abap_false.
      CHECK <ls_arearef>-depr_area_ref->is_active( iv_setting = faabc_setting-reporting_deprarea ) EQ abap_false.
      CHECK <ls_arearef>-depr_area_ref->ms_setup-area_usage_ind                                    NE 1.

      CLEAR lv_periods.
      LOOP AT <ls_arearef>-depr_area_ref->mt_derive_tab ASSIGNING FIELD-SYMBOL(<ls_const_area>).
        READ TABLE mts_hlpseg ASSIGNING FIELD-SYMBOL(<ls_hlpseg>)
          WITH KEY area      = <ls_const_area>-depr_area_ref->mv_depr_area
                   curr_type = <ls_const_area>-depr_area_ref->ms_setup-currency_type.
        IF sy-subrc <> 0.
          DELETE me->mt_virtarea_s4
            WHERE virt_depr_area = <ls_arearef>-depr_area.
          EXIT.
        ENDIF.

        "periods may differ in RARUECK scenario
        IF <ls_arearef>-depr_area_ref->ms_setup-area_usage_ind NE 2.
          "ensure that all assigned base areas have the same count of calculation periods
          IF lv_periods IS INITIAL.
            lv_periods = <ls_hlpseg>-periods_short_fy.
          ENDIF.

          IF lv_periods NE <ls_hlpseg>-periods_short_fy.
            MESSAGE e087(aa) INTO DATA(lv_message) WITH <ls_hlpseg>-area.
            me->create_message_from_syst( ).
          ENDIF.

        ENDIF.

        ls_virtarea-real_depr_area = <ls_const_area>-depr_area_ref->mv_depr_area.
        ls_virtarea-real_curr_type = <ls_const_area>-depr_area_ref->ms_setup-currency_type.

        ls_virtarea-virt_depr_area = <ls_arearef>-depr_area.
        ls_virtarea-virt_curr_type = <ls_arearef>-depr_area_ref->ms_setup-currency_type.

        ls_virtarea-prop_part      = <ls_const_area>-proportion.
        IF <ls_const_area>-sign = if_faa_dc_segments_720_c=>gc_area_value_sign-negative.
          ls_virtarea-prop_part = - <ls_const_area>-proportion.
        ENDIF.

        "Insert adjustment areas as the first entry for each virtual area
        IF <ls_const_area>-depr_area_ref->mv_depr_area EQ <ls_arearef>-depr_area_ref->ms_setup-adjustment_area.
          READ TABLE me->mt_virtarea_s4 WITH KEY virt_depr_area = <ls_arearef>-depr_area_ref->mv_depr_area TRANSPORTING NO FIELDS.

          IF sy-subrc = 0.
            INSERT ls_virtarea INTO me->mt_virtarea_s4 INDEX sy-tabix.
          ELSE.
            APPEND ls_virtarea TO me->mt_virtarea_s4.
          ENDIF.

        ELSE.
          APPEND ls_virtarea TO me->mt_virtarea_s4.
        ENDIF.

      ENDLOOP.
    ENDLOOP.

* POSTCONDITION

  ENDMETHOD.


  METHOD _yearseg_create.
*******************************************************************
* Reworked/Cleaned up with 1908
*******************************************************************
* PRECONDITION

* DEFINITION
    FIELD-SYMBOLS <ls_calcamount>     TYPE ty_s_calcamount.
    FIELD-SYMBOLS <ls_yearseg>        TYPE ty_s_yearseg.
    FIELD-SYMBOLS <ls_sumseg>         TYPE ty_s_sumseg.

* BODY
* create YEARSEG for first fiscal year to be calculated
    IF mo_previous IS INITIAL.
      mt_yearseg = ms_asset_data-t_cum_values.

* create YEARSEG for subsequent fiscal year to be calculated
    ELSE.
      mt_yearseg[] = mo_previous->mt_yearseg[].

      LOOP AT mt_yearseg ASSIGNING <ls_yearseg>.
        <ls_yearseg>-fyear       = <ls_yearseg>-fyear + 1.
        READ TABLE mo_previous->mts_calcamount ASSIGNING <ls_calcamount>
          WITH KEY area      = <ls_yearseg>-area
                   curr_type = <ls_yearseg>-curr_type.

        IF sy-subrc = 0.
          <ls_yearseg>-cum-revl   = <ls_yearseg>-cum-revl   + <ls_calcamount>-total-revl.
          <ls_yearseg>-cum-depr_o = <ls_yearseg>-cum-depr_o + <ls_calcamount>-total-depr_o.
          <ls_yearseg>-cum-depr_s = <ls_yearseg>-cum-depr_s + <ls_calcamount>-total-depr_s.
          <ls_yearseg>-cum-depr_u = <ls_yearseg>-cum-depr_u + <ls_calcamount>-total-depr_u.
          <ls_yearseg>-cum-resv   = <ls_yearseg>-cum-resv   + <ls_calcamount>-total-resv.
          <ls_yearseg>-cum-intr   = <ls_yearseg>-cum-intr   + <ls_calcamount>-total-intr.
          <ls_yearseg>-cum-revl_d = <ls_yearseg>-cum-revl_d + <ls_calcamount>-total-revl_d.
        ENDIF.

        READ TABLE mo_previous->mt_sumseg ASSIGNING <ls_sumseg>
          WITH KEY area      = <ls_yearseg>-area
                   curr_type = <ls_yearseg>-curr_type.

        IF sy-subrc = 0.
          <ls_yearseg>-cum-apc        = <ls_yearseg>-cum-apc
                                      + <ls_sumseg>-cur-apc
                                      + <ls_sumseg>-prev_prev-apc.

          <ls_yearseg>-cum-downp      = <ls_yearseg>-cum-downp
                                      + <ls_sumseg>-cur-downp
                                      + <ls_sumseg>-prev_prev-downp.

          <ls_yearseg>-cum-invs       = <ls_yearseg>-cum-invs
                                      + <ls_sumseg>-cur-invs
                                + <ls_sumseg>-prev_cur-invs   "note_2886159
                                + <ls_sumseg>-prev_prev-invs.

          <ls_yearseg>-cum-revl       = <ls_yearseg>-cum-revl
                                      + <ls_sumseg>-cur-revl
                                      + <ls_sumseg>-prev_prev-revl
                                      + <ls_sumseg>-prev_cur-revl.

          <ls_yearseg>-cum-revl_d     = <ls_yearseg>-cum-revl_d
                                      + <ls_sumseg>-cur-revl_d
                                      + <ls_sumseg>-prev_prev-revl_d
                                      + <ls_sumseg>-prev_cur-revl_d.

          <ls_yearseg>-cum-depr_o     = <ls_yearseg>-cum-depr_o
                                      + <ls_sumseg>-cur-depr_o
                                      + <ls_sumseg>-prev_prev-depr_o
                                      + <ls_sumseg>-prev_cur-depr_o.

          <ls_yearseg>-cum-depr_s     = <ls_yearseg>-cum-depr_s
                                      + <ls_sumseg>-cur-depr_s
                                      + <ls_sumseg>-prev_prev-depr_s
                                      + <ls_sumseg>-prev_cur-depr_s.

          <ls_yearseg>-cum-depr_u     = <ls_yearseg>-cum-depr_u
                                      + <ls_sumseg>-cur-depr_u
                                      + <ls_sumseg>-prev_prev-depr_u
                                      + <ls_sumseg>-prev_cur-depr_u.

          <ls_yearseg>-cum-resv       = <ls_yearseg>-cum-resv
                                      + <ls_sumseg>-cur-resv
                                      + <ls_sumseg>-prev_prev-resv
                                      + <ls_sumseg>-prev_cur-resv.

          <ls_yearseg>-cum-apc_ret_ia = <ls_yearseg>-cum-apc_ret_ia
                                      + <ls_sumseg>-cur-apc_ret_ia
                                      + <ls_sumseg>-prev_prev-apc_ret_ia.
        ENDIF.
      ENDLOOP.

    ENDIF.

    SORT mt_yearseg BY fyear area curr_type.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~get_asset_data.
* PRECONDITION

* DEFINITION

* BODY
  rs_asset_data = ms_asset_data.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~get_previous_segment.
* PRECONDITION

* DEFINITION

* BODY
  ro_previous = mo_previous.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~get_proc_data.
* PRECONDITION

* DEFINITION

* BODY
  rs_proc_data = ms_proc_data.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~get_start_segment.
* PRECONDITION

* DEFINITION

* BODY
  ro_start = mo_start.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~reset_previous_segment.
* PRECONDITION

* DEFINITION

* BODY
  CLEAR mo_previous.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~reset_start_segment.
* PRECONDITION

* DEFINITION

* BODY
  CLEAR mo_start.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~set_asset_data.
* PRECONDITION

* DEFINITION

* BODY
  ms_asset_data = is_asset_data.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~set_previous_segment_ref.
* PRECONDITION

* DEFINITION

* BODY
  mo_previous ?= io_previous.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~set_proc_data.
* PRECONDITION

* DEFINITION

* BODY
  ms_proc_data = is_proc_data.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_faa_dc_segments_720~set_start_segment_ref.
* PRECONDITION

* DEFINITION

* BODY
  mo_start ?= io_start.

* POSTCONDITION

  ENDMETHOD.


  METHOD if_os_clone~clone.
*******************************************************************
* the complete hierarchy of a segments object is deeply cloned, i.e. covering mo_previous and mo_start
* the BAdI references (go_badi_country, go_badi_customer) are not considered
*******************************************************************
* PRECONDITION

* DEFINITION
    DATA lo_clone    TYPE REF TO if_faa_dc_segments_720.
    DATA lo_previous TYPE REF TO if_faa_dc_segments_720.
    DATA lo_start    TYPE REF TO if_faa_dc_segments_720.

* BODY
    SYSTEM-CALL OBJMGR CLONE me TO lo_clone.

    IF me->mo_previous IS BOUND.
      lo_previous ?= me->mo_previous->if_os_clone~clone( ).
      lo_clone->set_previous_segment_ref( lo_previous ).
    ENDIF.

    IF me->mo_start IS BOUND.
      IF me = me->mo_start.
        lo_clone->set_start_segment_ref( lo_clone ).
      ELSE.
        lo_start ?= me->mo_start->if_os_clone~clone( ).
        lo_clone->set_start_segment_ref( lo_start ).
      ENDIF.
    ENDIF.

    result = lo_clone.

* POSTCONDITION

  ENDMETHOD.


METHOD _get_arearef_4_currtype.
*&---------------------------------------------------------------------*
* New with note 3072922
*&---------------------------------------------------------------------*
* PRECONDITION

* DEFINITION

* BODY
  ro_arearef = io_arearef.

  "only for OnPrem
  CHECK NOT ro_arearef->ms_setup-currency_type IS INITIAL.

  "necessary only if it is not already the right area (base area)
  CHECK ro_arearef->ms_setup-currency_type <> iv_curr_type.

  "only exchange the reference, if everything goes well
  READ TABLE ro_arearef->get_parallel_area( ) INTO DATA(ls_parallel_area)
    WITH KEY currency_type = iv_curr_type.
  IF sy-subrc = 0.
    ro_arearef = ls_parallel_area-depr_area_ref.
  ENDIF.

* POSTCONDITION

ENDMETHOD.


METHOD _get_units_from_depr_key.
*&---------------------------------------------------------------------*
*& Method revised with note 2989652
*&---------------------------------------------------------------------*
*¬†PRECONDITION
  CHECK is_hlpseg-key_phase_ref->mts_prod_unit[] IS NOT INITIAL.

  rv_percentage = SWITCH #( ib_nbv_depr
                    WHEN abap_true THEN 1
                    ELSE 0 ).

*¬†DEFINITIONS
  DATA lv_percentage TYPE float.
  FIELD-SYMBOLS <ls_prod_unit> TYPE if_faa_dc_segments_720=>ty_s_deprkey-prod_units.

*¬†BODY

  LOOP AT is_hlpseg-key_phase_ref->mts_prod_unit ASSIGNING <ls_prod_unit>
    WHERE  validity_yr  EQ      is_hlpseg-fyear
      AND  validity_prd BETWEEN is_hlpseg-period_from AND is_hlpseg-period_to.

    CASE is_hlpseg-key_phase_ref->ms_settings-percent_key.
      WHEN gc_percent-key_s.
        lv_percentage = <ls_prod_unit>-planned_for_prd / <ls_prod_unit>-planned_total.

      WHEN gc_percent-key_t.

        IF <ls_prod_unit>-planned_total GT <ls_prod_unit>-sum_planned_prd.
          lv_percentage = <ls_prod_unit>-planned_for_prd
                        / ( <ls_prod_unit>-planned_total - <ls_prod_unit>-sum_planned_prd ).
        ELSE.
          lv_percentage = 0.
        ENDIF.
    ENDCASE.

    IF ib_nbv_depr EQ abap_true.
      rv_percentage = rv_percentage * ( 1 - lv_percentage ).
    ELSE.
      rv_percentage = rv_percentage +  lv_percentage.
    ENDIF.
  ENDLOOP.

  IF ib_nbv_depr EQ abap_true.
    rv_percentage = 1 - rv_percentage.
  ENDIF.

*¬†POSTCONDITION
  "none

ENDMETHOD.


METHOD _get_units_from_usage_object.
*&---------------------------------------------------------------------*
*& This method reads unit of production data from a usage object and
*& transforms the units into fiscal period segments.
*& Finally a percentage rate is calculated based on this UoP information
*&---------------------------------------------------------------------*
*& Method revised with note 2989652
*&---------------------------------------------------------------------*
*¬†PRECONDITION
  CHECK is_hlpseg-usage_object IS NOT INITIAL.

  rv_percentage = SWITCH #( ib_nbv_depr
                    WHEN abap_true THEN 1
                    ELSE 0 ).

*¬†DEFINITIONS
  DATA lv_percentage    TYPE float.
  DATA lv_fisc_per_from TYPE rsfiscper.
  DATA lv_fisc_per_to   TYPE rsfiscper.

*¬†BODY

  lv_fisc_per_from(4)   = is_hlpseg-fyear.
  lv_fisc_per_from+4(3) = is_hlpseg-period_from.

  lv_fisc_per_to(4)   = is_hlpseg-fyear.
  lv_fisc_per_to+4(3) = is_hlpseg-period_to.

  TRY.

      cl_faa_uo_mapping_srvs=>get_instance( )->get_units_for_fiscal_periods(
        EXPORTING
          iv_comp_code     = ms_proc_data-comp_code
          iv_usage_object  = is_hlpseg-usage_object
          iv_depr_area     = is_hlpseg-arearef->mv_depr_area
          iv_fisc_per_from = lv_fisc_per_from
          iv_fisc_per_to   = lv_fisc_per_to
        RECEIVING
          rt_period_units  = DATA(lt_period_units) ).

    CATCH cm_faa_uo.
      " Errors shall not be raised, the only consequence from errors is a percentage
      " rate zero
      rv_percentage = 0.
      RETURN.

  ENDTRY.

  " Process units from Usage Object
  LOOP AT lt_period_units ASSIGNING FIELD-SYMBOL(<ls_prod_unit>)
        WHERE  validity_yr  EQ      is_hlpseg-fyear                                 "the service should return data ...
          AND  validity_prd    BETWEEN is_hlpseg-period_from AND is_hlpseg-period_to   "... only for the given range
          AND  planned_for_prd NE 0.

    CASE is_hlpseg-key_phase_ref->ms_settings-percent_key.
      WHEN gc_percent-key_s.
        lv_percentage = <ls_prod_unit>-planned_for_prd / <ls_prod_unit>-planned_total.

      WHEN gc_percent-key_t.

        IF <ls_prod_unit>-planned_total GT <ls_prod_unit>-sum_planned_prd.
          lv_percentage = <ls_prod_unit>-planned_for_prd
                        / ( <ls_prod_unit>-planned_total - <ls_prod_unit>-sum_planned_prd ).
        ELSE.
          lv_percentage = 0.
        ENDIF.
    ENDCASE.

    IF ib_nbv_depr EQ abap_true.
      rv_percentage = rv_percentage * ( 1 - lv_percentage ).
    ELSE.
      rv_percentage = rv_percentage +  lv_percentage.
    ENDIF.

  ENDLOOP.

  IF ib_nbv_depr EQ abap_true.
    rv_percentage = 1 - rv_percentage.
  ENDIF.

*¬†POSTCONDITION
  "none

ENDMETHOD.
ENDCLASS.