class ZAA_CL_PRINT_INVENTORY definition
  public
  abstract
  create public .

public section.

  types:
    BEGIN OF gty_s_cell,
        name   TYPE text30,
        value  TYPE string,
        noconv TYPE abap_bool,
        row    TYPE i,
        col    TYPE i,
      END OF gty_s_cell .
  types:
    BEGIN OF gty_s_comis,
        sscr500      TYPE zaa_cl_print_inventory_amdp=>gty_s_comis,
        participants TYPE zaa_cl_print_inventory_amdp=>gty_t_pernr_data,
        responsible  TYPE zaa_cl_print_inventory_amdp=>gty_t_pernr_data,
        depgroups    TYPE wdy_key_value_list,
        locations    TYPE zaa_cl_print_inventory_amdp=>gty_t_locat,
      END OF gty_s_comis .
  types:
    BEGIN OF gty_s_out,
        title       TYPE string,
        bukrs       TYPE t001-bukrs,
        butxt       TYPE string,
        buname      TYPE text255,
        invdate     TYPE sy-datum,
        variant     TYPE disvariant,
        data        TYPE zaa_cl_print_inventory_amdp=>gty_t_data,
        comis       TYPE gty_s_comis,
        adds        TYPE zaa_cl_print_inventory_amdp=>gty_s_adds,
        repeat_sign TYPE abap_bool,
        mol_signs   TYPE abap_bool,
      END OF gty_s_out .
  types:
    gty_t_cells TYPE STANDARD TABLE OF gty_s_cell WITH DEFAULT KEY .
  types:
    BEGIN OF gty_s_template,
        title_gen TYPE string,
        template  TYPE bds_objid,
      END OF gty_s_template .
  types:
    BEGIN OF gty_s_new_record.
        INCLUDE TYPE zaa_cl_print_inventory_amdp=>gty_s_data.
    TYPES:
      valid TYPE abap_bool,
      END OF gty_s_new_record .
  types:
    BEGIN OF gty_s_sscr,
        "Опции и параметры для селекционного экрана
        bukrs         TYPE t001-bukrs,
        anln1         TYPE anla-anln1,
        anln2         TYPE anla-anln2,
        kostl         TYPE anlz-kostl,
        anlkl         TYPE anla-anlkl,
        depgr         TYPE j_3rfdeprgroup-amortgr,
        hkont         TYPE skat-saknr,
        lgort         TYPE anlz-lgort,
        stort         TYPE anlz-stort,
        raumn         TYPE anlz-raumn,
        glo_rus_okof  TYPE glofaaassetdata-glo_rus_okof,
        invdate       TYPE sy-datum,
        variant       TYPE disvariant,
        adatu         TYPE anlz-adatu,                                            "Дата дока завис от времени
        zzbelnr       TYPE anlz-zzbelnr,                                          "№ дока завис от времени
        "Заполненные опции СЭ и тип отчёта
        classtype     TYPE zaa_inv_head-type,
        classname     TYPE seoclsname,
        title         TYPE string,
        print_title   TYPE string,
        previous      TYPE abap_bool,
        laufi         TYPE zaa_inv-laufi,
        comis         TYPE zaa_inv_head-comis,
        repeat_sign   TYPE abap_bool,
        mol_signs     TYPE abap_bool,
        full_ozos     TYPE abap_bool,
        it_anln1      TYPE RANGE OF anla-anln1,
        it_anln2      TYPE RANGE OF anla-anln2,
        it_kostl      TYPE RANGE OF anlz-kostl,
        it_anlkl      TYPE RANGE OF anla-anlkl,
        it_depgr      TYPE RANGE OF j_3rfdeprgroup-amortgr,
        it_hkont      TYPE RANGE OF hkont,
        it_lgort      TYPE RANGE OF anlz-lgort,
        it_zzbelnr    TYPE RANGE OF anlz-zzbelnr,
        it_stort      TYPE RANGE OF anlz-stort,
        it_raumn      TYPE RANGE OF anlz-raumn,
        it_gloaf      TYPE RANGE OF  glofaaassetdata-glo_rus_okof,                          "Отбор № дока завис от времени
        initialized   TYPE abap_bool,
        add_dlg_versn TYPE i,
      END OF gty_s_sscr .

  class-data GS_SSCR type GTY_S_SSCR .
  class-data GR_HANDLER type ref to ZAA_CL_PRINT_INVENTORY .
  class-data GS_NEW_RECORD type GTY_S_NEW_RECORD .

  methods CHECK_RECORD
    importing
      !IS_RECORD type GTY_S_NEW_RECORD
    returning
      value(RV_OK) type ABAP_BOOL .
  methods AFTER_EXPORT
    importing
      value(IR_EXPORTER) type ref to ZCL_EXCEL_SIMPLE .
  methods READ_SET_PERNR
    changing
      value(CS_COMIS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS .
  methods FREE_COMISS .
  class-methods CLASS_CONSTRUCTOR .
  class-methods GET_VARIANT
    importing
      value(IS_VARI) type DISVARIANT
    returning
      value(RV_VARIANT) type DISVARIANT-VARIANT .
  class-methods CHECK_SSCR_VALUES
    importing
      value(IV_BUKRS) type T001-BUKRS
      value(IT_ANLKL) type RANGE_ANLKL_IN_T
      value(IV_CHECK_CLASS) type ABAP_BOOL optional
    exporting
      value(EV_BUTXT) type CHAR255
    returning
      value(RV_RESULT) type ABAP_BOOL .
  methods SAVE_COMIS
    importing
      !IS_COMIS type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS .
  class-methods INITIATE_REPORT
    importing
      value(IV_TYPE) type C optional
    returning
      value(RR_CLASS) type ref to ZAA_CL_PRINT_INVENTORY .
  methods SELECT_DATA
    returning
      value(RV_OK) type ABAP_BOOL .
  methods FREE .
  methods SHOW_ALV .
  class-methods GET_ZZBELNR
    importing
      value(IV_BUKRS) type ANLZ-BUKRS
    returning
      value(RV_ZZBELNR) type ANLZ-ZZBELNR .
  class-methods GET_DEPGROUP
    returning
      value(RV_GROUP) type J_3RFDEPRGROUP-AMORTGR .
  class-methods SELECT_STORED_RESULT
    returning
      value(RV_OK) type ABAP_BOOL .
  class-methods LOAD_HKONT_DEFAULTS
    returning
      value(RT_HKONT) type HRPP_SEL_HKONT .
  methods ANLN_SEARCH
    importing
      value(IV_SEARCH) type ABAP_BOOL optional
    changing
      value(CS_ANLN) type GTY_S_NEW_RECORD
    returning
      value(RV_OK) type ABAP_BOOL .
  methods STORE_RECORD
    importing
      value(CS_DATA) type GTY_S_NEW_RECORD .
  methods STORE_TO_DB
    importing
      value(IS_HEAD) type ZAA_INV_HEAD .
  methods GET_SAVE_PARAMS
    changing
      value(CV_LAUFD) type ZAA_INV-LAUFD
      value(CV_LAUFI) type ZAA_INV-LAUFI
      value(CV_TYPE) type ZAA_INV_HEAD-TYPE
      value(CV_TEXT) type DD07T-DDTEXT optional
      value(CV_COMIS) type ZAA_INV_HEAD-COMIS .
  methods EXPORT
    importing
      value(IV_TYPE) type STRING
      value(IS_TEMPLATE) type GTY_S_TEMPLATE optional
      value(IS_COMIS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS optional
    changing
      value(CT_CELLS) type GTY_T_CELLS optional .
  methods START_PRINT_DIALOG
    importing
      value(IV_NUMBER) type ZAA_INV_HEAD-COMIS optional
      value(IS_COMIS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS optional
    returning
      value(RS_COMIS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS .
  methods SHOW_COMIS
    importing
      value(IM_DYNNR) type SY-DYNNR
      value(IM_SCREEN) type SY-DYNNR optional
    returning
      value(RS_COMIS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS .
  class-methods LOAD_DEFAULT_SSCR .
  methods CHECK_OUTPUT
    importing
      !IM_TYPE type CLIKE
    returning
      value(RV_OK) type ABAP_BOOL .
  methods EXPORT_PDF
    importing
      value(IV_TYPE) type STRING
      value(IS_COMIS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_COMIS optional
      value(IS_TEMPLATE) type GTY_S_TEMPLATE optional
      value(IV_EDPDF) type CHAR01 optional .
protected section.

  data COLOR_POSITIVE type CHAR4 value 'C300' ##NO_TEXT.
  data COLOR_NEGATIVE type CHAR4 value 'C600' ##NO_TEXT.
  data COLOR_EQUIVALENT type CHAR4 value 'C500' ##NO_TEXT.
  class-data GS_OUT type GTY_S_OUT .
  class-data GR_GRID type ref to CL_GUI_ALV_GRID .
  class-data GT_REPORT_TYPES type WDY_KEY_VALUE_LIST .

  methods FILL_OZOS
    importing
      value(IT_KEYS) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_T_TEXTKEYS optional .
  methods INIT_SCREEN_500_ALV
    importing
      value(IR_TABLE) type ref to DATA optional
      value(IV_NUM) type I
    changing
      value(IR_GRID) type ref to CL_GUI_ALV_GRID .
  methods SET_PRICES
    importing
      value(IV_COPY_MENGE) type ABAP_BOOL optional
    changing
      value(CS_DATA) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_DATA .
  methods FILL_FIELDCAT
    returning
      value(RT_FCAT) type LVC_T_FCAT .
  methods GET_FILTER_STRING
    importing
      value(IT_SELTAB) type IF_SHDB_DEF=>TT_NAMED_DREF optional
    returning
      value(RV_FILTER) type STRING .
  class-methods ON_HEAD_DBLCLICK
    for event DOUBLE_CLICK of CL_SALV_EVENTS_TABLE
    importing
      !ROW
      !COLUMN .
  methods SET_PAGE_HEADER
    importing
      value(IR_CONTAINER) type ref to CL_GUI_CONTAINER .
  methods ON_DATA_CHANGED
    for event DATA_CHANGED_FINISHED of CL_GUI_ALV_GRID
    importing
      !E_MODIFIED
      !ET_GOOD_CELLS .
  methods ON_HOTSPOT_EVENT
    for event HOTSPOT_CLICK of CL_GUI_ALV_GRID
    importing
      !E_ROW_ID
      !E_COLUMN_ID
      !ES_ROW_NO .
  methods ON_TOOLBAR_EVENT
    for event TOOLBAR of CL_GUI_ALV_GRID
    importing
      !E_OBJECT
      !E_INTERACTIVE .
  methods ON_UCOMM_EVENT
    for event USER_COMMAND of CL_GUI_ALV_GRID
    importing
      !E_UCOMM .
  methods ON_CONTEXT_MENU
    for event CONTEXT_MENU_REQUEST of CL_GUI_ALV_GRID
    importing
      !E_OBJECT .
  methods MODIFY_FIELDCAT
  abstract
    changing
      value(CS_FCAT) type LVC_S_FCAT .
  methods GET_SSCR_TEXT
    returning
      value(RV_RESULT) type STRING .
private section.

  class-data LR_STORED type ref to CL_SALV_TABLE .
  data GR_PART type ref to CL_GUI_ALV_GRID .
  data GR_RESP type ref to CL_GUI_ALV_GRID .
  data GR_DEPGR type ref to CL_GUI_ALV_GRID .
  data GV_TITLE_GEN type STRING .

  methods GET_HKONT_LIST
    returning
      value(RV_LIST) type STRING .
  methods PERNR_F4
    exporting
      value(ES_PERNR) type ZAA_CL_PRINT_INVENTORY_AMDP=>GTY_S_PERNR_DATA
      value(EV_LONG) type STRING
    returning
      value(RV_OK) type ABAP_BOOL .
  methods MODIFY_0500_GRID
    importing
      value(IR_SENDER) type ref to OBJECT
      value(IR_EVENT) type ref to CL_ALV_EVENT_DATA
      value(IS_TABLINE) type ANY
      value(IV_ROW_ID) type I
      value(IV_LONG) type STRING optional .
  class-methods SET_UCOMM
    importing
      value(IV_UCOMM) type SY-UCOMM .
  class-methods GET_SELECTED_REPORTTYPE
    returning
      value(RV_TYPE) type STRING .
  methods ON_SCREEN500_F4
    for event ONF4 of CL_GUI_ALV_GRID
    importing
      !E_FIELDNAME
      !ES_ROW_NO
      !ER_EVENT_DATA
      !ET_BAD_CELLS
      !E_DISPLAY
      !SENDER .
ENDCLASS.



CLASS ZAA_CL_PRINT_INVENTORY IMPLEMENTATION.


  METHOD after_export.
    "Dummy - выполняется после всех шагов экспорта - callback для вызывающего класса
    "Пример в lcl_print_inventory_nma
  ENDMETHOD.


  METHOD anln_search.
    DATA:
      ls_shlp   TYPE shlp_descr_t,
      lt_return TYPE STANDARD TABLE OF ddshretval.

    cs_anln-valid = abap_false.

    IF iv_search = abap_true.

      CALL FUNCTION 'F4IF_GET_SHLP_DESCR'
        EXPORTING
          shlpname = CONV shlpname( 'AANL' )
        IMPORTING
          shlp     = ls_shlp.

      ls_shlp-fieldprop[ fieldname = 'BUKRS' ]-shlpoutput = 'X'.
      ls_shlp-interface[ shlpfield = 'BUKRS' ]-valfield = 'BUKRS'.
      ls_shlp-interface[ shlpfield = 'BUKRS' ]-f4field = 'BUKRS'.

      ls_shlp-fieldprop[ fieldname = 'ANLN1' ]-shlpoutput = 'X'.
      ls_shlp-interface[ shlpfield = 'ANLN1' ]-valfield = 'ANLN1'.
      ls_shlp-interface[ shlpfield = 'ANLN1' ]-f4field = 'ANLN1'.

      ls_shlp-fieldprop[ fieldname = 'ANLN2' ]-shlpoutput = 'X'.
      ls_shlp-interface[ shlpfield = 'ANLN2' ]-valfield = 'ANLN2'.
      ls_shlp-interface[ shlpfield = 'ANLN2' ]-f4field = 'ANLN2'.

      ls_shlp-selopt = VALUE #( BASE ls_shlp-selopt
          ( shlpfield = 'BUKRS'
          sign      = 'I'
          option    = 'EQ'
          low       = cs_anln-bukrs ) ).

      sy-linct = 0.

      CALL FUNCTION 'F4IF_START_VALUE_REQUEST'
        EXPORTING
          shlp          = ls_shlp
          disponly      = ''
        IMPORTING
          rc            = sy-linct
        TABLES
          return_values = lt_return[].

      CHECK sy-linct = 0 AND lt_return[] IS NOT INITIAL.

      cs_anln = VALUE #(
        bukrs = lt_return[ fieldname = 'BUKRS' ]-fieldval
        anln1 = lt_return[ fieldname = 'ANLN1' ]-fieldval
        anln2 = lt_return[ fieldname = 'ANLN2' ]-fieldval
      ).
    ENDIF.

    WHILE strlen( cs_anln-anln2 ) < 4.
      cs_anln-anln2 = '0' && cs_anln-anln2.
    ENDWHILE.

    DATA(lt_anln1) = VALUE ranges_anln1_tt( ( sign = 'I' option = 'EQ' low = cs_anln-anln1 ) ).
    DATA(lt_anln2) = VALUE ranges_anln2_tt( ( sign = 'I' option = 'EQ' low = cs_anln-anln2 ) ).

    TRY.
        zaa_cl_print_inventory_amdp=>read_data(
          EXPORTING
            iv_bukrs      = cs_anln-bukrs
            iv_ondate     = gs_sscr-invdate
            iv_filter     = cl_shdb_seltab=>combine_seltabs(
                              it_named_seltabs = VALUE #(
                                ( name = 'ANLN1'  dref = REF #( lt_anln1[] ) )
                                ( name = 'ANLN2'  dref = REF #( lt_anln2[] ) ) ) )
          IMPORTING
            et_data  = DATA(lt_data) ).
      CATCH cx_root.
        MESSAGE i999(zaa) WITH TEXT-e01 DISPLAY LIKE 'E'.
        RETURN.
    ENDTRY.

    IF lt_data IS INITIAL.
      DATA(lv_message) =
        replace( val =
          replace( val =
            replace( val = TEXT-e04 sub = '&' with = cs_anln-anln1 occ = 1 )
          sub = '&' with = cs_anln-anln2 occ = 1 )
        sub = '&' with = |{ gs_sscr-invdate+6(2) }.{ gs_sscr-invdate+4(2) }.{ gs_sscr-invdate(4) }| occ = 1 ).

      MESSAGE i999(zaa) WITH lv_message TEXT-e05 DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    DATA: lt_main TYPE STANDARD TABLE OF zaa_cl_print_inventory_amdp=>gty_s_key.

    lt_main[] = CORRESPONDING #( gs_out-data[] ).

    READ TABLE lt_main[] TRANSPORTING NO FIELDS WITH KEY bukrs = lt_data[ 1 ]-bukrs anln1 = lt_data[ 1 ]-anln1 anln2 = lt_data[ 1 ]-anln2 BINARY SEARCH.
    IF sy-subrc EQ 0.
      lv_message =
        replace( val =
          replace( val = TEXT-e06 sub = '&' with = cs_anln-anln1 occ = 1 )
        sub = '&' with = cs_anln-anln2 occ = 1 ).

      MESSAGE i999(zaa) WITH lv_message DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    cs_anln = corresponding #( lt_data[ 1 ] ).
    cs_anln-valid = abap_true.

    SUPPRESS DIALOG.

    rv_ok = abap_true.
  ENDMETHOD.


  METHOD check_output.
    CASE im_type.
      WHEN 'COLL'.
        LOOP AT gs_out-data[] TRANSPORTING NO FIELDS WHERE dif_n_amt > 0 or dif_p_amt > 0.
          EXIT.
        ENDLOOP.
        IF sy-subrc = 0.
          rv_ok = abap_true.
        ELSE.
         MESSAGE i999(zaa) WITH TEXT-e14 DISPLAY LIKE 'S'.
        ENDIF.
      WHEN OTHERS.
        rv_ok = abap_true.
    ENDCASE.
  ENDMETHOD.


  METHOD check_record.
    IF is_record-bukrs IS INITIAL OR is_record-anln1 IS INITIAL.
      RETURN.
    ENDIF.

    rv_ok = abap_true.

  ENDMETHOD.


  METHOD check_sscr_values.
    TYPES:
      BEGIN OF lty_s_bukrs,
        bukrs TYPE bukrs,
      END OF lty_s_bukrs.
    DATA: lt_bukrs TYPE STANDARD TABLE OF lty_s_bukrs WITH DEFAULT KEY.

    rv_result = abap_true.

    LOOP AT lt_bukrs[] ASSIGNING FIELD-SYMBOL(<lv_bukrs>).
      AUTHORITY-CHECK OBJECT 'F_BKPF_BUK'
         ID 'ACTVT' FIELD '03'
         ID 'BUKRS' FIELD iv_bukrs.
      IF sy-subrc <> 0.
        MESSAGE e460(f5) WITH iv_bukrs.                       "'Нет полномочий для БЕ'
        rv_result = abap_false.
        RETURN.
      ENDIF.
    ENDLOOP.

    " наименование БЕ
    zcl_names=>get_org_names(
     EXPORTING
       it_bukrs = VALUE #( ( sign = 'I' option = 'EQ' low = iv_bukrs ) )
     IMPORTING
       ev_butxt = DATA(lv_butxt) ).

    "Убираем двойные пробелы
    ev_butxt = replace( val = replace( val = lv_butxt sub = `  ` with = ` ` ) sub = `  ` with = ` ` ).

    IF iv_check_class <> abap_true OR it_anlkl IS INITIAL.
      RETURN.
    ENDIF.

    SELECT anlkl
      FROM anka
      INTO TABLE @DATA(lt_anlkl)
      WHERE anlkl IN @it_anlkl[].
    LOOP AT lt_anlkl ASSIGNING FIELD-SYMBOL(<ls_anlkl>).
      AUTHORITY-CHECK OBJECT 'A_M_ANLKL'
                      ID 'ANLKL' FIELD <ls_anlkl>
                      ID 'ACTVT' FIELD '03'.
      IF sy-subrc NE 0.
        MESSAGE e021(zaa) WITH <ls_anlkl>.
        rv_result = abap_false.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD class_constructor.
    SELECT domvalue_l AS key, ddtext AS value
      FROM dd07t
      INTO TABLE @gt_report_types[]
      WHERE domname = 'ZAA_DM_INV_TYPE'
        AND ddlanguage = @sy-langu
        AND as4local = 'A'.
  ENDMETHOD.


  METHOD export.
    DATA: lr_excel TYPE REF TO lcl_exporter.

    IF is_comis IS SUPPLIED.
      gs_out-comis-sscr500 = is_comis.
    ENDIF.

    DATA(lv_partner) = CONV numc10( gs_out-bukrs ).
    SELECT SINGLE taxnum
      FROM dfkkbptaxnum
      INTO gs_out-adds-taxnum
      WHERE partner = lv_partner
        AND taxtype = 'BY0'.

    gs_out-adds-location = REDUCE #( INIT lv_str TYPE string
      FOR <ls_line> IN gs_out-comis-locations[]
      NEXT lv_str = |{ lv_str }; { <ls_line>-address }| ).
    SHIFT gs_out-adds-location LEFT DELETING LEADING: ';', space.

    DATA(lv_classname) = |LCL_EXPORTER_{ iv_type }|.

    TRY.
        CREATE OBJECT lr_excel TYPE (lv_classname)
          EXPORTING
              ir_sender   = me
              iv_class    = 'ZIBA_DOCS'
              iv_keyid    = 'AA'
              iv_inplace  = abap_false
              iv_docname  = CONV text100( gs_out-title )
              iv_form     = SWITCH bds_objid( is_template-template
                                WHEN '' THEN
                                  SWITCH #( iv_type
                                    WHEN 'INV'  THEN 'ZAA_INVENTORY_F1-INV.xls'
                                    WHEN 'COLL' THEN 'ZAA_INVENTORY_F15-INV.xls'
                                    WHEN 'SVOD' THEN 'ZAA_INVENTORY_SVOD.xls'
                                    WHEN 'AKT'  THEN 'ZAA_INVENTORY_AKT.xls' )
                                ELSE is_template-template ).
      CATCH cx_root.
        MESSAGE i999(zaa) WITH TEXT-e13 lv_classname DISPLAY LIKE 'E'.
        RETURN.
    ENDTRY.

    lr_excel->switch_updates( abap_false ).
    lr_excel->export(
      EXPORTING
        iv_title_gen = is_template-title_gen
        iv_type = iv_type
      CHANGING
        is_out = gs_out ).

    lr_excel->post_export( is_out = gs_out ).
    lr_excel->switch_updates( abap_true ).
    lr_excel->maximize( ).
    lr_excel->free( ).

  ENDMETHOD.


  METHOD export_pdf.
    TYPES:
      BEGIN OF lty_s_out,
        ktansw     TYPE zaa_cl_print_inventory_amdp=>gty_s_data-ktansw,
        werks      TYPE zaa_cl_print_inventory_amdp=>gty_s_data-werks,
        lgort      TYPE zaa_cl_print_inventory_amdp=>gty_s_data-lgort,
        full_text  TYPE fclm_string,
        fmeng      TYPE zaa_cl_print_inventory_amdp=>gty_s_data-fmeng,
        fact       TYPE zaa_cl_print_inventory_amdp=>gty_s_data-fact,
        menge      TYPE zaa_cl_print_inventory_amdp=>gty_s_data-menge,
        stoim      TYPE zaa_cl_print_inventory_amdp=>gty_s_data-stoim,
        costre_ac  TYPE zcostre_ac,
        confirmed  TYPE zcostre_ac,
        uncofirmed TYPE zcostre_ac,
      END OF lty_s_out.

    DATA:
      lv_name             TYPE rs38l_fnam,
      lv_docparams        TYPE sfpdocparams,
      lv_errstr           TYPE string,
      ls_outputparams     TYPE sfpoutputparams,
      ls_nast             TYPE nast,
      ls_inv              TYPE zaa_inv_print,
      lv_form             TYPE fpname,
      lv_depgr            TYPE string,
      lv_depgr_pr         TYPE string,
      lv_locations        TYPE string,
      lv_locations_pr     TYPE string,
      lv_gr_name          TYPE string,
      lv_total_count      TYPE i,
      lv_cnt              TYPE i,
      lv_use              TYPE c LENGTH 1,
      lv_fmeng            TYPE p LENGTH 13 DECIMALS 2,
      lv_fact             TYPE p LENGTH 13 DECIMALS 2,
      lv_result_structure TYPE zbc_spell_curr_results,
      ls_svod             TYPE lty_s_out,
      lt_svod             TYPE SORTED TABLE OF lty_s_out
                          WITH UNIQUE KEY ktansw werks lgort full_text.

    "подбор типа отчета
    IF iv_type = 'INV'.                                                         "инв. опись
      CASE gs_out-title.
        WHEN TEXT-tt2.                                                          "ОС
          ls_inv-head-title_gen = TEXT-xl1.
          lv_form = 'ZAA_INV_PRINT_F1'.
        WHEN TEXT-tt3.                                                          "НМА
          ls_inv-head-title_gen = TEXT-xl2.
          lv_form = 'ZAA_INV_PRINT_F2'.
        WHEN TEXT-tt4.                                                          "активы на отв. хранении
          ls_inv-head-title_gen = TEXT-xl3.
          lv_form = 'ZAA_INV_PRINT_F10'.
        WHEN TEXT-tt6.                                                          "ДВ в МА
          ls_inv-head-title_gen = TEXT-xl5.
          lv_form = 'ZAA_INV_PRINT_F1'.
        WHEN TEXT-tt7.                                                          "долгосрочные активы
          ls_inv-head-title_gen = TEXT-xl6.
          lv_form = 'ZAA_INV_PRINT_F6'.
      ENDCASE.
    ELSEIF iv_type = 'COLL'.                                                    "слич. ведомость
      CASE gs_out-title.
        WHEN TEXT-tt2.                                                          "ОС
          ls_inv-head-title_gen = TEXT-xl1.
          lv_form = 'ZAA_INV_PRINT_F15_SL'.
        WHEN TEXT-tt6.                                                          "ДВ в МА
          ls_inv-head-title_gen = TEXT-xl5.
          lv_form = 'ZAA_INV_PRINT_F15_SL'.
        WHEN TEXT-tt7.                                                          "долгосрочные активы
          ls_inv-head-title_gen = TEXT-xl7.
          lv_form = 'ZAA_INV_PRINT_F15_SL_LTASS'.
      ENDCASE.
    ELSEIF iv_type = 'SVOD'.                                                    "свод наличия
      CASE gs_out-title.
        WHEN TEXT-tt2.                                                          "ОС
          ls_inv-head-title_gen = TEXT-xl1.
        WHEN TEXT-tt3.                                                          "НМА
          ls_inv-head-title_gen = TEXT-xl2.
        WHEN TEXT-tt6.                                                          "ДВ в МА
          ls_inv-head-title_gen = TEXT-xl5.
      ENDCASE.
      lv_form = 'ZAA_INV_PRINT_SVOD'.
    ELSEIF iv_type = 'AKT'.                                                     "акт инвентаризации, только забалансовые счета
      IF gs_out-title = TEXT-tt5.
        ls_inv-head-title_gen = TEXT-xl4.
      ENDIF.
      lv_form = 'ZAA_INV_PRINT_AKT'.

    ENDIF.
    "Разбить группы ОС, Местонахождения по 3 строки (длина подбирается)
    LOOP AT gs_out-comis-depgroups ASSIGNING FIELD-SYMBOL(<lv_depgr>).
      lv_depgr = SWITCH #( lv_depgr
                      WHEN '' THEN <lv_depgr>-value
                      ELSE  |{ lv_depgr }, { <lv_depgr>-value }| ).
    ENDLOOP.
    SPLIT lv_depgr AT space INTO TABLE DATA(lt_depgr) IN CHARACTER MODE.

    FREE: lv_depgr,lv_use.
    lv_cnt = 1.
    LOOP AT lt_depgr ASSIGNING FIELD-SYMBOL(<lv_depgr1>).
      lv_depgr_pr = lv_depgr.
      lv_depgr = SWITCH #( lv_depgr
                      WHEN '' THEN <lv_depgr1>
                      ELSE  |{ lv_depgr } { <lv_depgr1> }| ).
      IF ( lv_cnt = 1 AND strlen( lv_depgr_pr ) <= 90 AND strlen( lv_depgr ) > 90 )
        OR ( ( lv_cnt = 2 OR lv_cnt = 3 ) AND strlen( lv_depgr_pr ) <= 120 AND strlen( lv_depgr ) > 120 ).
        lv_use = abap_true.
        lv_depgr = <lv_depgr1>.
      ENDIF.

      AT LAST.
        lv_use = abap_true.
        lv_depgr_pr = lv_depgr.
      ENDAT.

      IF lv_use = abap_true.
        IF lv_cnt = 1.
          ls_inv-head-depgr1 = lv_depgr_pr.
        ELSEIF lv_cnt = 2.
          ls_inv-head-depgr2 = lv_depgr_pr.
        ELSEIF lv_cnt = 3.
          ls_inv-head-depgr3 = lv_depgr_pr.
        ENDIF.
        lv_cnt = lv_cnt + 1.
        FREE lv_use.
      ENDIF.

    ENDLOOP.

    LOOP AT gs_out-comis-locations ASSIGNING FIELD-SYMBOL(<lv_locations>).
      lv_locations = SWITCH #( lv_locations
                      WHEN '' THEN <lv_locations>-address
                      ELSE  |{ lv_locations }; { <lv_locations>-address }| ).
    ENDLOOP.
    SPLIT lv_locations AT space INTO TABLE DATA(lt_locations) IN CHARACTER MODE.

    FREE: lv_locations,lv_use.
    lv_cnt = 1.
    LOOP AT lt_locations ASSIGNING FIELD-SYMBOL(<lv_locations1>).
      lv_locations_pr = lv_locations.
      lv_locations = SWITCH #( lv_locations
                      WHEN '' THEN <lv_locations1>
                      ELSE  |{ lv_locations } { <lv_locations1> }| ).
      IF ( lv_cnt = 1 AND strlen( lv_locations_pr ) <= 90 AND strlen( lv_locations ) > 90 )
        OR ( ( lv_cnt = 2 OR lv_cnt = 3 ) AND strlen( lv_locations_pr ) <= 120 AND strlen( lv_locations ) > 120 ).
        lv_use = abap_true.
        lv_locations = <lv_locations1>.
      ENDIF.

      AT LAST.
        lv_use = abap_true.
        lv_locations_pr = lv_locations.
      ENDAT.

      IF lv_use = abap_true.
        IF lv_cnt = 1.
          ls_inv-head-location1 = lv_locations_pr.
        ELSEIF lv_cnt = 2.
          ls_inv-head-location2 = lv_locations_pr.
        ELSEIF lv_cnt = 3.
          ls_inv-head-location3 = lv_locations_pr.
        ENDIF.
        lv_cnt = lv_cnt + 1.
        FREE lv_use.
      ENDIF.

    ENDLOOP.

    "зачеркиваем документы основания
    TRANSLATE gs_out-comis-sscr500-basis_doc TO LOWER CASE.
    CASE gs_out-comis-sscr500-basis_doc.
      WHEN TEXT-ol1.                                                            "приказ
        ls_inv-head-pr_basis_doc = '1'.
      WHEN TEXT-ol2.                                                            "постановление
        ls_inv-head-pr_basis_doc = '2'.
      WHEN TEXT-ol3.                                                            "распоряжение
        ls_inv-head-pr_basis_doc = '3'.
      WHEN OTHERS.
        ls_inv-head-pr_basis_doc = '0'.
    ENDCASE.

    DATA(lv_partner) = CONV numc10( gs_out-bukrs ).
    SELECT SINGLE taxnum
      FROM dfkkbptaxnum
      INTO gs_out-adds-taxnum
      WHERE partner = lv_partner
        AND taxtype = 'BY0'.

    "заголовок
    "ls_inv-head-title_gen = TEXT-xl1.
    ls_inv-head-docnum = is_comis-docnum.
    ls_inv-head-name1 = gs_out-adds-name1.
    ls_inv-head-name2 = gs_out-adds-name2.
    ls_inv-head-buname = |{ gs_out-adds-name1 } { gs_out-adds-name2 }|.
    ls_inv-head-taxnum = gs_out-adds-taxnum.
    ls_inv-head-invdate = gs_out-invdate.
    ls_inv-head-order_date = SWITCH #( is_comis-order_date
                      WHEN '00000000' THEN ''
                      ELSE  is_comis-order_date ).
    ls_inv-head-order_num = is_comis-order_num.
    ls_inv-head-date_inv  = SWITCH #( is_comis-date_inv
                      WHEN '00000000' THEN ''
                      ELSE is_comis-date_inv ).
    ls_inv-head-date_inv_e = SWITCH #( is_comis-date_inv_e
                      WHEN '00000000' THEN ''
                      ELSE is_comis-date_inv_e ).
    ls_inv-head-ondate = SWITCH #( gs_out-invdate
                      WHEN '00000000' THEN ''
                      ELSE gs_out-invdate ).

    ls_inv-head-chairman_pos = is_comis-chairman_pos.
    ls_inv-head-chairman_fio = is_comis-chairman_fio.
    ls_inv-head-accnt_pos = is_comis-accnt_pos.
    ls_inv-head-accnt_fio = is_comis-accnt_fio.
    ls_inv-head-mol_pos = is_comis-mol_pos.
    ls_inv-head-mol_fio = is_comis-mol_fio.
    ls_inv-head-text = gs_out-comis-sscr500-text.
    ls_inv-head-text = gs_out-comis-sscr500-text.
    ls_inv-head-hcont = SWITCH string( zaa_cl_print_inventory=>gs_sscr-classtype
                                      WHEN 'NMA' THEN '_____________'
                                      ELSE zcl_names=>get_hkont_names_fi( zaa_cl_print_inventory=>gs_sscr-it_hkont[] ) ).

    "мат отв лица
    LOOP AT gs_out-comis-responsible ASSIGNING FIELD-SYMBOL(<ls_mol>).
      INSERT VALUE #( position = <ls_mol>-stext
                      fio = <ls_mol>-ename )
                      INTO TABLE ls_inv-mol.
    ENDLOOP.
    "комиссия
    LOOP AT gs_out-comis-participants ASSIGNING <ls_mol>.
      INSERT VALUE #( position = <ls_mol>-stext
                      fio = <ls_mol>-ename )
                     INTO TABLE ls_inv-comis.
    ENDLOOP.
    ls_inv-head-pr_full_ozos = zaa_cl_print_inventory=>gs_sscr-full_ozos.

    lv_total_count = 0.
    lv_fmeng = 0.
    lv_fact  = 0.

    "заполнение осн табл.
    ls_inv-pos = CORRESPONDING #( gs_out-data ).
    LOOP AT ls_inv-pos ASSIGNING FIELD-SYMBOL(<ls_pos>).
      lv_total_count = lv_total_count + 1.
      IF lv_total_count = 1.
        ls_inv-head-start_no = lv_total_count.                                  "<ls_data>-idx.
      ENDIF.
      ls_inv-head-end_no = lv_total_count.                                      "<ls_data>-idx.
      <ls_pos>-num = lv_total_count.
      IF <ls_pos>-menge - <ls_pos>-fmeng > 0.
        <ls_pos>-dif_n_amt = <ls_pos>-menge - <ls_pos>-fmeng.
        <ls_pos>-dif_n = <ls_pos>-stoim - <ls_pos>-fact.
        <ls_pos>-dif_p_amt = 0.
        <ls_pos>-dif_p = 0.
      ELSE.
        <ls_pos>-dif_p_amt =  <ls_pos>-fmeng - <ls_pos>-menge.
        <ls_pos>-dif_p =  <ls_pos>-fact - <ls_pos>-stoim.
        <ls_pos>-dif_n_amt = 0.
        <ls_pos>-dif_n = 0.

      ENDIF.

      lv_fmeng = lv_fmeng + <ls_pos>-fmeng.
      lv_fact  = lv_fact + <ls_pos>-fact.

      IF <ls_pos>-useflag IS INITIAL.
        <ls_pos>-noexpl = abap_true.
      ELSE.
        <ls_pos>-expl = abap_true.
      ENDIF.
      IF ls_inv-head-pr_full_ozos = abap_true.
        <ls_pos>-full_text = |{ <ls_pos>-full_text }{ cl_abap_char_utilities=>cr_lf }{ <ls_pos>-ozos_text }|.
      ENDIF.
    ENDLOOP.

    "по своду наличия группируем (счет, завод, склад)
    IF iv_type = 'SVOD'.
      LOOP AT ls_inv-pos ASSIGNING <ls_pos>.
        MOVE-CORRESPONDING <ls_pos> TO ls_svod.
        ASSIGN gs_out-comis-responsible[ werks = ls_svod-werks lgort = ls_svod-lgort ] TO FIELD-SYMBOL(<ls_resp>).
        ls_svod-full_text = SWITCH #( sy-subrc
          WHEN 0 THEN |{ <ls_resp>-ename }, { <ls_resp>-stext }|
          ELSE |{ TEXT-008 }| ).
        COLLECT ls_svod INTO lt_svod.
      ENDLOOP.
      ls_inv-pos = CORRESPONDING #( lt_svod ).
    ENDIF.

    "по акту инветеризации группируем(счет)
    IF iv_type = 'AKT'.
      LOOP AT ls_inv-pos ASSIGNING <ls_pos>.
        <ls_pos>-werks = ''.
        <ls_pos>-lgort = ''.
        <ls_pos>-full_text = |{ <ls_pos>-ktansw } { <ls_pos>-ktansw_text }|.
        MOVE-CORRESPONDING <ls_pos> TO ls_svod.
        COLLECT ls_svod INTO lt_svod.
      ENDLOOP.
      ls_inv-pos = CORRESPONDING #( lt_svod ).
    ENDIF.

    ls_inv-head-pr_repeat_sign = zaa_cl_print_inventory=>gs_sscr-repeat_sign.
    ls_inv-head-pr_mol_signs = zaa_cl_print_inventory=>gs_sscr-mol_signs.

    "сумма по отчету текстом
    zbc_spell_amount=>amount_to_words( EXPORTING iv_amount           = lv_total_count         " <-- Сумма
                                                   iv_currency         = ''              " <-- Валюта
                                                   iv_language         = ''              " <-- Язык
                                                   iv_short            = ''              " <-- Краткое наименование валюты
                                                   iv_dec_digits       = 'X'             " <-- копейки цифрами
                                         IMPORTING es_result_structure = lv_result_structure ).
    TRANSLATE lv_result_structure-main_part_amount(1) TO UPPER CASE.
    ls_inv-foot-total_count_txt  = lv_result_structure-main_part_amount.        " целая часть суммы строкой
    zbc_spell_amount=>amount_to_words( EXPORTING iv_amount           = lv_fmeng         " <-- Сумма
                                                   iv_currency         = ''              " <-- Валюта
                                                   iv_language         = ''              " <-- Язык
                                                   iv_short            = ''              " <-- Краткое наименование валюты
                                                   iv_dec_digits       = 'X'             " <-- копейки цифрами
                                         IMPORTING es_result_structure = lv_result_structure ).
    TRANSLATE lv_result_structure-main_part_amount(1) TO UPPER CASE.
    ls_inv-foot-total_fmeng_txt  = lv_result_structure-main_part_amount.         " целая часть суммы строкой

    zbc_spell_amount=>amount_to_words( EXPORTING iv_amount           = lv_fact         " <-- Сумма
                                                   iv_currency         = 'BYN'              " <-- Валюта
                                                   iv_language         = sy-langu              " <-- Язык
                                                   iv_short            = ''              " <-- Краткое наименование валюты
                                                   iv_dec_digits       = 'X'             " <-- копейки цифрами
                                       IMPORTING                                         "ev_words            = lv_words_total
                                                 es_result_structure = lv_result_structure ).
    TRANSLATE lv_result_structure-main_part_amount(1) TO UPPER CASE.
    ls_inv-foot-total_fact_txt  = |{ lv_result_structure-main_part_amount } { TEXT-am1 } { lv_result_structure-dec_part_amount } { TEXT-am2 }|.

*    data(str1) = 'asddddddddddddddddddddddddddddddsfffffffffffffffffffffffffffffffffffffffffffffffffffff'.
*    data(str2) = 'dsfdffddffffffffffffffffffffffdsfdsfdsffffffffffffffffffffffffffffffffffffffffffffffdsfdsfdsfdsf'.
*    data(str3) = 'bb'.
*    ls_inv-head-text = |{ str1 }  { str2 } { str1 }  { str2 } { str1 }  { str2 } { str1 }  { str2 } { str1 }  { str2 } { str1 }  { str2 } { str3 }|.

    "--- Set output parameters
    ls_outputparams-preview   = 'X'.                                            "gv_screen_display. " launch print preview
    ls_outputparams-dest      = ls_nast-ldest.
    ls_outputparams-copies    = ls_nast-anzal.
    ls_outputparams-dataset   = ls_nast-dsnam.
    ls_outputparams-suffix1   = ls_nast-dsuf1.
    ls_outputparams-suffix2   = ls_nast-dsuf2.
    ls_outputparams-cover     = ls_nast-tdocover.
    ls_outputparams-covtitle  = ls_nast-tdcovtitle.
    ls_outputparams-authority = ls_nast-tdautority.
    ls_outputparams-receiver  = ls_nast-tdreceiver.
    ls_outputparams-division  = ls_nast-tddivision.
    ls_outputparams-arcmode   = ls_nast-tdarmod.
    ls_outputparams-reqimm    = ls_nast-dimme.
    ls_outputparams-reqdel    = ls_nast-delet.
    ls_outputparams-senddate  = ls_nast-vsdat.
    ls_outputparams-sendtime  = ls_nast-vsura.

    "--- Open the spool job
    CALL FUNCTION 'FP_JOB_OPEN'
      CHANGING
        ie_outputparams = ls_outputparams
      EXCEPTIONS
        cancel          = 1
        usage_error     = 2
        system_error    = 3
        internal_error  = 4
        OTHERS          = 5.

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 DISPLAY LIKE 'E'.
      RETURN.
    ELSEIF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'
      EXPORTING
        i_name     = lv_form
      IMPORTING
        e_funcname = lv_name.
    IF sy-langu = 'R'.
      lv_docparams-langu = 'R'.
      lv_docparams-country = 'RU'.
    ENDIF.
    lv_docparams-fillable = iv_edpdf.                                           "редактируемый режим

    CALL FUNCTION lv_name
      EXPORTING
        /1bcdwb/docparams = lv_docparams
        inv               = ls_inv
      EXCEPTIONS
        usage_error       = 1
        system_error      = 2
        internal_error    = 3.

    IF sy-subrc <> 0.
      CALL FUNCTION 'FP_GET_LAST_ADS_ERRSTR'
        IMPORTING
          e_adserrstr = lv_errstr.
    ENDIF.

    "--- Close the spool job
    CALL FUNCTION 'FP_JOB_CLOSE'
      EXCEPTIONS
        usage_error    = 1
        system_error   = 2
        internal_error = 3
        OTHERS         = 4.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.



  ENDMETHOD.


  METHOD fill_fieldcat.
    rt_fcat[] = CORRESPONDING #(
      cl_salv_data_descr=>read_structdescr(
        CAST cl_abap_structdescr(
          CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( gs_out-data[] ) )->get_table_line_type( ) ) ) ).

    LOOP AT rt_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>).
      <ls_fcat> = VALUE #( BASE <ls_fcat>
        col_pos = sy-tabix
        no_out = SWITCH #( <ls_fcat>-fieldname
          WHEN 'KTANSW' OR 'ANLN' OR 'ANLA_TEXT' OR 'PRICE' OR 'MENGE' OR 'STOIM' OR 'FMENG'
            OR 'FACT' OR 'DIF_P' OR 'DIF_N' THEN abap_false
          ELSE abap_true )
        hotspot = SWITCH #( <ls_fcat>-fieldname
          WHEN 'ANLN' THEN abap_true
          ELSE  <ls_fcat>-hotspot )
        edit = SWITCH #( <ls_fcat>-fieldname
          WHEN 'FMENG' OR 'TTN_NAME' OR 'TTN_DATE' OR 'TTN_NUM' OR 'CONFIRMED' THEN abap_true
          ELSE <ls_fcat>-edit )
        col_opt = SWITCH #( <ls_fcat>-fieldname
          WHEN 'BUKRS' OR 'ANLN' OR 'INVNR' OR 'KOSTL' OR 'CSKT_TEXT' OR 'CAUFN'
            OR 'MENGE' OR 'STOIM' OR 'PRICE' OR 'FMENG' OR 'FACT' OR 'DIF_P' OR 'DIF_N'
            OR 'PASPORT' OR 'LR_NAME' OR 'LR_NUMBER' OR 'LIFTEXT' THEN abap_true
          ELSE <ls_fcat>-col_opt )
        key = SWITCH #( <ls_fcat>-fieldname
          WHEN 'BUKRS' OR 'ANLN' THEN abap_true
          ELSE <ls_fcat>-key )
        outputlen = SWITCH #( <ls_fcat>-fieldname
          WHEN 'MENGE' OR 'FMENG' OR 'PRICE' OR 'STOIM' OR 'FACT' OR 'DIF_N' OR 'DIF_P' THEN 0
          WHEN 'USEFLAG' THEN 5
          WHEN 'CSKT_TEXT' OR 'AUFK_TEXT' OR 'PLANTNR' THEN 10
          WHEN 'ANLA_TEXT' OR 'FULL_TEXT' OR 'GROUP_TXT' OR 'ADDRESS' THEN 20
          WHEN 'PLANTNR' OR 'LIFTEXT' THEN 40
          ELSE <ls_fcat>-outputlen )
        ref_table = SWITCH #( <ls_fcat>-fieldname
          WHEN 'ANLN' THEN 'ANLA'
          ELSE <ls_fcat>-ref_table )
        ref_field = SWITCH #( <ls_fcat>-fieldname
          WHEN 'ANLN' THEN 'ANLN1'
          ELSE <ls_fcat>-ref_field )
        qfieldname = SWITCH #( <ls_fcat>-fieldname
          WHEN 'MENGE' OR 'FMENG' THEN 'MEINS' )
        checkbox = SWITCH #( <ls_fcat>-fieldname
          WHEN 'USEFLAG' THEN abap_true )
      ).

      CASE <ls_fcat>-fieldname.
        WHEN 'PRICE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-00l.
          <ls_fcat>-scrtext_m = TEXT-00m.
          <ls_fcat>-scrtext_s = TEXT-00s.
        WHEN 'STOIM'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-01l.
          <ls_fcat>-scrtext_m = TEXT-01m.
          <ls_fcat>-scrtext_s = TEXT-01s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'MENGE'.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'FMENG'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-02l.
          <ls_fcat>-scrtext_m = TEXT-02m.
          <ls_fcat>-scrtext_s = TEXT-02s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'DIF_N'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-03l.
          <ls_fcat>-scrtext_m = TEXT-03m.
          <ls_fcat>-scrtext_s = TEXT-03s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'DIF_P'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-04l.
          <ls_fcat>-scrtext_m = TEXT-04m.
          <ls_fcat>-scrtext_s = TEXT-04s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'FACT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-05l.
          <ls_fcat>-scrtext_m = TEXT-05m.
          <ls_fcat>-scrtext_s = TEXT-05s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'ZANLZ_ADATU'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-06l.
          <ls_fcat>-scrtext_m = TEXT-06m.
          <ls_fcat>-scrtext_s = TEXT-06s.
        WHEN 'ADDRESS'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-07l.
          <ls_fcat>-scrtext_m = TEXT-07m.
          <ls_fcat>-scrtext_s = TEXT-07s.
        WHEN 'TTN_NAME'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-08l.
          <ls_fcat>-scrtext_m = TEXT-08m.
          <ls_fcat>-scrtext_s = TEXT-08s.
          <ls_fcat>-outputlen = 20.
        WHEN 'TTN_DATE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-09l.
          <ls_fcat>-scrtext_m = TEXT-09m.
          <ls_fcat>-scrtext_s = TEXT-09s.
          <ls_fcat>-ref_table = 'ANLA'.
          <ls_fcat>-ref_field = 'ERDAT'.
        WHEN 'TTN_NUM'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-10l.
          <ls_fcat>-scrtext_m = TEXT-10m.
          <ls_fcat>-scrtext_s = TEXT-10s.
        WHEN 'DIF_N_AMT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-11l.
          <ls_fcat>-scrtext_m = TEXT-11m.
          <ls_fcat>-scrtext_s = TEXT-11s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'DIF_P_AMT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-12l.
          <ls_fcat>-scrtext_m = TEXT-12m.
          <ls_fcat>-scrtext_s = TEXT-12s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'COSTRE_AC'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-15l.
          <ls_fcat>-scrtext_m = TEXT-15m.
          <ls_fcat>-scrtext_s = TEXT-15s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'CONFIRMED'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-16l.
          <ls_fcat>-scrtext_m = TEXT-16m.
          <ls_fcat>-scrtext_s = TEXT-16s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'UNCONFIRMED'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-17l.
          <ls_fcat>-scrtext_m = TEXT-17m.
          <ls_fcat>-scrtext_s = TEXT-17s.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'GJAHR_B'.
          <ls_fcat>-ref_table = 'ZANLU'.
          <ls_fcat>-ref_field = <ls_fcat>-fieldname.
        WHEN 'IDX'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-20l.
          <ls_fcat>-scrtext_m = TEXT-20m.
          <ls_fcat>-scrtext_s = TEXT-20s.
        WHEN 'OZOS_TEXT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-21l.
          <ls_fcat>-scrtext_m = TEXT-21m.
          <ls_fcat>-scrtext_s = TEXT-21s.
        WHEN 'GROUP_TXT' OR 'GROUP_DESCR'.
          <ls_fcat>-ref_table = 'J_3RFDEPRGROUPT'.
          <ls_fcat>-ref_field = 'AMORTGR'.
        WHEN 'LGORT_TXT' OR 'LGOBE'.
          <ls_fcat>-ref_table = 'T001L'.
          <ls_fcat>-ref_field = 'LGORT'.
        WHEN 'USEFLAG'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-22l.
          <ls_fcat>-scrtext_m = TEXT-22m.
          <ls_fcat>-scrtext_s = TEXT-22s.
        WHEN 'LIFTEXT' OR 'LIFNAME'.
          <ls_fcat>-ref_table = 'ANLA'.
          <ls_fcat>-ref_field = 'LIFNR'.
      ENDCASE.

      me->modify_fieldcat( CHANGING cs_fcat = <ls_fcat> ).

    ENDLOOP.
  ENDMETHOD.


  METHOD fill_ozos.
    TYPES:
      BEGIN OF lty_s_cluster,
        clustr TYPE stxl-clustr,
        clustd TYPE stxl-clustd,
      END   OF lty_s_cluster.
    DATA: lt_cluster TYPE STANDARD TABLE OF lty_s_cluster,
          lt_tlines  TYPE STANDARD TABLE OF tline.


    LOOP AT it_keys[] ASSIGNING FIELD-SYMBOL(<ls_key>).
      APPEND CORRESPONDING #( <ls_key> ) TO lt_cluster[].
      IMPORT tline = lt_tlines[] FROM INTERNAL TABLE lt_cluster[].

      ASSIGN gs_out-data[ bukrs = <ls_key>-bukrs anln1 = <ls_key>-anln1 anln2 = <ls_key>-anln2 ]-ozos_text TO FIELD-SYMBOL(<fs_dest>).
      IF sy-subrc = 0.
        <fs_dest> = <fs_dest> && REDUCE #( INIT lv_str TYPE string
          FOR <ls_line> IN lt_tlines[]
          NEXT lv_str = |{ lv_str } { <ls_line>-tdline }| ).
        SHIFT <fs_dest> LEFT DELETING LEADING: ';', space.
        REPLACE '<(>' WITH '' INTO <fs_dest>.
        REPLACE '<)>' WITH '' INTO <fs_dest>.
      ENDIF.

      CLEAR: lt_cluster[], lt_tlines[].
    ENDLOOP.

  ENDMETHOD.


  METHOD free.
    CLEAR gs_out.

    IF gr_grid IS BOUND.
      DATA(lr_splitter) = CAST cl_gui_splitter_container( gr_grid->parent->parent ).
      gr_grid->free( ).
      FREE gr_grid.

      IF lr_splitter IS BOUND.
        lr_splitter->remove_control( row = 1 column = 1 ).
        DATA(lr_parent) = lr_splitter->parent.
        lr_splitter->free( ).
        FREE lr_splitter.

        IF lr_parent IS BOUND.
          lr_parent->free( ).
          FREE lr_parent.
        ENDIF.

      ENDIF.
    ENDIF.

    cl_gui_cfw=>flush( ).
  ENDMETHOD.


  METHOD free_comiss.
    IF gr_part IS BOUND.
      DATA(lr_parent) = gr_part->parent.
      gr_part->free( ).
      FREE gr_part.
      IF lr_parent IS BOUND.
        FREE lr_parent.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD get_depgroup.
    TYPES:
      BEGIN OF lty_s_group,
        amortgr  TYPE j_3rfdeprgroupt-amortgr,
        descript TYPE j_3rfdeprgroupt-descript,
      END OF lty_s_group.
    DATA: lt_group  TYPE STANDARD TABLE OF lty_s_group,
          lt_return TYPE STANDARD TABLE OF ddshretval.

    SELECT amortgr, descript
      FROM j_3rfdeprgroupt
      INTO TABLE @lt_group[]
      WHERE sprsl = @sy-langu.

    CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
      EXPORTING
        retfield        = 'AMORTGR'
        dynpprog        = sy-repid
        dynpnr          = sy-dynnr
        value_org       = 'S'
      TABLES
        value_tab       = lt_group[]
        return_tab      = lt_return[]
      EXCEPTIONS
        parameter_error = 1
        no_values_found = 2
        OTHERS          = 3.

    IF sy-subrc = 0.
      TRY.
          rv_group = lt_return[ 1 ]-fieldval.
        CATCH cx_sy_itab_line_not_found.
      ENDTRY.
    ENDIF.
  ENDMETHOD.


  METHOD get_filter_string.

    rv_filter = cl_shdb_seltab=>combine_seltabs(
      it_named_seltabs = VALUE #( BASE it_seltab[]
        ( name = 'ANLN1'  dref = REF #( gs_sscr-it_anln1[] ) )
        ( name = 'DEPGR'  dref = REF #( gs_sscr-it_depgr[] ) )
        ( name = 'KTANSW' dref = REF #( gs_sscr-it_hkont[] ) )
        ( name = 'LGORT'  dref = REF #( gs_sscr-it_lgort[] ) )
        ( name = 'KOSTL'  dref = REF #( gs_sscr-it_kostl[] ) )
        ( name = 'ANLKL'  dref = REF #( gs_sscr-it_anlkl[] ) )
        ( name = 'ZZBELNR' dref = REF #( gs_sscr-it_zzbelnr[] ) )
        ( name = 'STORT' dref = REF #( gs_sscr-it_stort[] ) )
        ( name = 'RAUMN' dref = REF #( gs_sscr-it_RAUMN[] ) )
        ( name = 'GLO_RUS_OKOF' dref = REF #( gs_sscr-IT_GLOAF[] ) )
      )
    ).

  ENDMETHOD.


  METHOD get_hkont_list.
    DATA: lt_hkont TYPE STANDARD TABLE OF hkont.

    LOOP AT gs_out-data[] ASSIGNING FIELD-SYMBOL(<ls_data>).
      READ TABLE lt_hkont[] WITH KEY table_line = <ls_data>-ktansw TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        APPEND <ls_data>-ktansw TO lt_hkont[].
      ENDIF.
    ENDLOOP.

    CONCATENATE LINES OF lt_hkont[] INTO rv_list SEPARATED BY `, `.
  ENDMETHOD.


  METHOD get_save_params.
    cv_laufd = zaa_cl_print_inventory=>gs_sscr-invdate.
    cv_type = zaa_cl_print_inventory=>gs_sscr-classtype.
    cv_laufi = zaa_cl_print_inventory=>gs_sscr-laufi.
    cv_comis = zaa_cl_print_inventory=>gs_sscr-comis.

    IF zaa_cl_print_inventory=>gs_sscr-previous = abap_false.
      SELECT MAX( laufi )
        FROM zaa_inv_head
        INTO cv_laufi
        WHERE laufd = cv_laufd.
      IF sy-subrc EQ 0.
        zaa_cl_print_inventory=>gs_sscr-laufi = cv_laufi.
      ENDIF.
    ENDIF.

    cv_text = gt_report_types[ key = cv_type ]-value.

    DATA(lt_values) = VALUE vrm_values(
      FOR <ls_type> IN gt_report_types[]
      ( key = <ls_type>-key text = <ls_type>-value ) ).

    CALL FUNCTION 'VRM_SET_VALUES'
      EXPORTING
        id              = 'PP_TYPE'
        values          = lt_values[]
      EXCEPTIONS
        id_illegal_name = 0
        OTHERS          = 0.

  ENDMETHOD.


  METHOD get_selected_reporttype.
    DATA: lt_sel TYPE STANDARD TABLE OF rsparams.

    "Определяем имя класса из активного checkbox СЭ
    CALL FUNCTION 'RS_REFRESH_FROM_SELECTOPTIONS'
      EXPORTING
        curr_report     = sy-cprog
      TABLES
        selection_table = lt_sel[]
      EXCEPTIONS
        not_found       = 1
        no_report       = 2
        OTHERS          = 3.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    LOOP AT lt_sel[] ASSIGNING FIELD-SYMBOL(<ls_sel>) WHERE selname CP 'PV_*' AND kind = 'P' AND low = abap_true.
      rv_type = <ls_sel>-selname+3.
      EXIT.
    ENDLOOP.
  ENDMETHOD.


  METHOD GET_SSCR_TEXT.
    rv_result = me->get_hkont_list( ).
  ENDMETHOD.


  METHOD get_variant.

    CALL FUNCTION 'LVC_VARIANT_F4'
      EXPORTING
        is_variant    = is_vari
        i_save        = 'A'
      IMPORTING
        es_variant    = is_vari
      EXCEPTIONS
        not_found     = 1
        program_error = 2
        OTHERS        = 3.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ELSE.
      rv_variant = is_vari-variant.
    ENDIF.
  ENDMETHOD.


  METHOD get_zzbelnr.
    TYPES:
      BEGIN OF lty_s_zzbelnr,
        zzbelnr TYPE anlz-zzbelnr,
      END OF lty_s_zzbelnr.
    DATA: lt_zzbelnr TYPE STANDARD TABLE OF lty_s_zzbelnr,
          lt_return  TYPE STANDARD TABLE OF ddshretval,
          lt_fld     TYPE STANDARD TABLE OF dynpread,
          p_date     TYPE p.

    lt_fld = VALUE #( ( fieldname = 'P_DATE' ) ).
    CALL FUNCTION 'DYNP_VALUES_READ'
      EXPORTING
        dyname     = sy-cprog
        dynumb     = sy-dynnr
      TABLES
        dynpfields = lt_fld
      EXCEPTIONS
        OTHERS     = 4.

    IF sy-subrc = 0.

      CALL FUNCTION 'CONVERT_DATE_TO_INTERNAL'
        EXPORTING
          date_external = lt_fld[ 1 ]-fieldvalue
        IMPORTING
          date_internal = p_date
        EXCEPTIONS
          OTHERS        = 4.
    ENDIF.


    SELECT DISTINCT zzbelnr
      FROM anlz
      INTO TABLE @lt_zzbelnr[]
      WHERE bukrs = @iv_bukrs AND
      adatu = @p_date .

    CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
      EXPORTING
        retfield        = 'ZZBELNR'
        dynpprog        = sy-repid
        dynpnr          = sy-dynnr
        value_org       = 'S'
      TABLES
        value_tab       = lt_zzbelnr[]
        return_tab      = lt_return[]
      EXCEPTIONS
        parameter_error = 1
        no_values_found = 2
        OTHERS          = 3.

    IF sy-subrc = 0.
      TRY.
          rv_zzbelnr =  lt_return[ 1 ]-fieldval.
        CATCH cx_sy_itab_line_not_found.
      ENDTRY.
    ENDIF.



  ENDMETHOD.


  METHOD initiate_report.
    DATA: lv_defcls TYPE seoclsname VALUE 'LCL_PRINT_INVENTORY'.

    gs_sscr = VALUE #( BASE gs_sscr
      classtype = SWITCH #( gs_sscr-previous
        WHEN ' ' THEN get_selected_reporttype( )
        ELSE gs_sscr-classtype )
      classname = |{ lv_defcls }_{ gs_sscr-classtype }| ).

    IF gr_handler IS BOUND.
      gr_handler->free( ).
      FREE gr_handler.
    ENDIF.

    TRY.
        CREATE OBJECT gr_handler TYPE (gs_sscr-classname).
      CATCH cx_sy_create_object_error.
        DATA(lv_class) = lv_defcls && '_RIG'.
        CREATE OBJECT gr_handler TYPE (lv_class).
    ENDTRY.

    gs_out = VALUE #( BASE gs_out
      title = gt_report_types[ key = gs_sscr-classtype ]-value ).

    gs_sscr-title = gs_out-title.
  ENDMETHOD.


  METHOD init_screen_500_alv.
    IF ir_grid IS BOUND.
      ir_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true )
                                      EXCEPTIONS OTHERS = 0
                                    ).
      RETURN.
    ENDIF.

    DATA(lt_fcat) = CORRESPONDING lvc_t_fcat(
      cl_salv_data_descr=>read_structdescr(
        CAST cl_abap_structdescr(
          CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data_ref( ir_table ) )->get_table_line_type( ) ) ) ).

    LOOP AT lt_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>).
      CASE <ls_fcat>-fieldname.
        WHEN 'PERNR' OR 'STELL'.
          <ls_fcat>-no_out = abap_true.
          <ls_fcat>-edit = abap_true.
        WHEN 'WERKS' OR 'LGORT'.
          <ls_fcat>-no_out = SWITCH #( iv_num
            WHEN 2 THEN abap_false
            ELSE abap_true ).
          <ls_fcat>-edit = abap_false.
        WHEN 'ENAME'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-13l.
          <ls_fcat>-scrtext_m = TEXT-13m.
          <ls_fcat>-scrtext_s = TEXT-13s.
          <ls_fcat>-outputlen = 30.
          <ls_fcat>-edit = abap_true.
          <ls_fcat>-f4availabl = abap_true.
          <ls_fcat>-lowercase = abap_true.
          <ls_fcat>-edit = abap_true.
        WHEN 'STEXT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-14l.
          <ls_fcat>-scrtext_m = TEXT-14m.
          <ls_fcat>-scrtext_s = TEXT-14s.
          <ls_fcat>-edit = abap_true.
          <ls_fcat>-outputlen = SWITCH #( iv_num
            WHEN 2 THEN 60
            ELSE 70 ).
          <ls_fcat>-lowercase = abap_true.
          <ls_fcat>-edit = abap_true.
        WHEN 'KEY'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-18l.
          <ls_fcat>-scrtext_m = TEXT-18m.
          <ls_fcat>-scrtext_s = TEXT-18s.
          <ls_fcat>-no_out = abap_true.
          <ls_fcat>-edit = abap_true.
        WHEN 'VALUE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-19l.
          <ls_fcat>-scrtext_m = TEXT-19m.
          <ls_fcat>-scrtext_s = TEXT-19s.
          <ls_fcat>-f4availabl = abap_true.
          <ls_fcat>-outputlen = 100.
          <ls_fcat>-edit = abap_true.
      ENDCASE.
    ENDLOOP.

    ir_grid = NEW cl_gui_alv_grid( i_parent =
      NEW  cl_gui_custom_container(
        container_name = SWITCH #( iv_num
          WHEN 1 THEN 'ALV_PARTICIPANTS'
          WHEN 2 THEN 'ALV_RESPONSIBLE'
          WHEN 3 THEN 'ALV_DEPGR' ) )
    ).

    ASSIGN ir_table->* TO FIELD-SYMBOL(<lt_data>).

    ir_grid->set_table_for_first_display(
      EXPORTING
        is_layout            = VALUE lvc_s_layo( edit = abap_false no_rowmark = abap_true )
        i_default            = 'X'

        it_toolbar_excluding = VALUE rsd_t_func(
                                ( cl_gui_alv_grid=>mc_fc_detail )
                                ( cl_gui_alv_grid=>mc_fc_check )
                                ( cl_gui_alv_grid=>mc_fc_sort_asc )
                                ( cl_gui_alv_grid=>mc_fc_sort_dsc )
                                ( cl_gui_alv_grid=>mc_fc_find )
                                ( cl_gui_alv_grid=>mc_fc_find_more )
                                ( cl_gui_alv_grid=>mc_fc_filter )
                                ( cl_gui_alv_grid=>mc_mb_subtot )
                                ( cl_gui_alv_grid=>mc_mb_sum )
                                ( cl_gui_alv_grid=>mc_fc_print_back )
                                ( cl_gui_alv_grid=>mc_mb_export )
                                ( cl_gui_alv_grid=>mc_mb_variant )
                                ( cl_gui_alv_grid=>mc_fc_loc_cut )
                                ( cl_gui_alv_grid=>mc_fc_loc_move_row )
                                ( cl_gui_alv_grid=>mc_fc_loc_paste )
                                ( cl_gui_alv_grid=>mc_fc_refresh )
                                ( cl_gui_alv_grid=>mc_fc_loc_undo )
                                ( cl_gui_alv_grid=>mc_mb_view )
                                ( cl_gui_alv_grid=>mc_fc_info ) )
      CHANGING
        it_outtab            = <lt_data>
        it_fieldcatalog      = lt_fcat[] ).

    ir_grid->register_f4_for_fields(
      it_f4 = VALUE #(
        ( fieldname = 'ENAME' register = abap_true chngeafter = abap_true )
        ( fieldname = 'VALUE' register = abap_true chngeafter = abap_true ) ) ).

  ENDMETHOD.


  METHOD load_default_sscr.
    IF gs_sscr-initialized = abap_false.
      CALL FUNCTION 'RS_SUPPORT_SELECTIONS'
        EXPORTING
          report               = sy-cprog
          variant              = CONV rsvar-variant( |@{ sy-uname }| )
        EXCEPTIONS
          variant_not_existent = 1
          variant_obsolete     = 2
          OTHERS               = 3.
      "Do not care about exceptions

      gs_sscr-initialized = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD load_hkont_defaults.
    DATA(lv_var) = 'ZAA_INVENTORY_HKONT_' && get_selected_reporttype( ).

    SELECT sign opti AS option low high
      FROM tvarvc
      INTO TABLE rt_hkont
      WHERE name = lv_var.

  ENDMETHOD.


  METHOD modify_0500_grid.
    FIELD-SYMBOLS: <lt_tab> TYPE STANDARD TABLE.

    DATA(lr_grid) = CAST cl_gui_alv_grid( ir_sender ).
    ASSIGN ir_event->m_data->* TO <lt_tab>.

    DATA(lt_dfcat) = cl_salv_data_descr=>read_structdescr(
      CAST cl_abap_structdescr(
        CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data_ref( p_data_ref = COND #(
          WHEN lr_grid = gr_part THEN REF #( gs_out-comis-participants[] )
          WHEN lr_grid = gr_resp THEN REF #( gs_out-comis-responsible[] )
          WHEN lr_grid = gr_depgr THEN REF #( gs_out-comis-depgroups[] ) ) ) )->get_table_line_type( ) ) ).

    LOOP AT lt_dfcat[] ASSIGNING FIELD-SYMBOL(<ls_dfcat>).
      CHECK <ls_dfcat>-fieldname <> 'WERKS' AND <ls_dfcat>-fieldname <> 'LGORT'.

      ASSIGN COMPONENT <ls_dfcat>-fieldname OF STRUCTURE is_tabline TO FIELD-SYMBOL(<fs_src>).
      CHECK sy-subrc = 0.

      <lt_tab> = CORRESPONDING #( VALUE lvc_t_modi( BASE <lt_tab>
        ( row_id     = iv_row_id
          fieldname  = <ls_dfcat>-fieldname
          value      = SWITCH #( <ls_dfcat>-fieldname
                          WHEN 'STEXT' THEN COND #( WHEN strlen( iv_long ) > strlen( <fs_src> ) THEN iv_long ELSE <fs_src> )
                          ELSE <fs_src> ) ) ) ).
    ENDLOOP.
  ENDMETHOD.


  METHOD on_context_menu.
    e_object->add_separator( ).

    e_object->add_function(
        fcode       = 'NEW'
        text        = CONV #( TEXT-t00 ) ).

    e_object->add_function(
        fcode       = 'MASS'
        text        = CONV #( TEXT-t04 ) ).

  ENDMETHOD.


  METHOD on_data_changed.
    FIELD-SYMBOLS: <lt_data> TYPE zaa_cl_print_inventory_amdp=>gty_t_data.

    IF e_modified <> abap_true.
      RETURN.
    ENDIF.

    LOOP AT et_good_cells[] ASSIGNING FIELD-SYMBOL(<ls_cell>).
      me->set_prices( CHANGING cs_data = gs_out-data[ <ls_cell>-row_id ] ).
      gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
    ENDLOOP.

  ENDMETHOD.


  METHOD on_head_dblclick.
    lr_stored->close_screen( ).
  ENDMETHOD.


  METHOD on_hotspot_event.

    TRY.
        DATA(ls_key) = VALUE zaa_cl_print_inventory_amdp=>gty_s_key(
          bukrs = gs_out-data[ es_row_no-row_id ]-bukrs
          anln1 = gs_out-data[ es_row_no-row_id ]-anln1
          anln2 = gs_out-data[ es_row_no-row_id ]-anln2 ).
      CATCH cx_sy_itab_line_not_found.
        RETURN.
    ENDTRY.

    CASE e_column_id-fieldname.
      WHEN 'ANLN'.
        SET PARAMETER ID 'BUK' FIELD ls_key-bukrs.
        SET PARAMETER ID 'AN1' FIELD ls_key-anln1.
        SET PARAMETER ID 'AN2' FIELD ls_key-anln2.
        CALL TRANSACTION 'AS03' AND SKIP FIRST SCREEN.
    ENDCASE.
  ENDMETHOD.


  METHOD on_screen500_f4.
    DATA: ls_pernr TYPE zaa_cl_print_inventory_amdp=>gty_s_pernr_data,
          lv_long  TYPE string,
          lt_ret   TYPE STANDARD TABLE OF ddshretval,
          lt_fcat  TYPE lvc_t_fcat.

    IF e_fieldname = 'VALUE'.
      "Search-help для группы амортизации
      TRY.
          zaa_cl_print_inventory_amdp=>read_depgr_f4(
              IMPORTING
                et_depgr  = DATA(lt_depgr) ).
        CATCH cx_root.
          MESSAGE i999(zaa) WITH TEXT-e09 DISPLAY LIKE 'E'.
          RETURN.
      ENDTRY.

      CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
        EXPORTING
          retfield        = 'KEY'
          dynpprog        = sy-repid
          dynpnr          = sy-dynnr
          value_org       = 'S'
        TABLES
          value_tab       = lt_depgr[]
          return_tab      = lt_ret[]
        EXCEPTIONS
          parameter_error = 1
          no_values_found = 2
          OTHERS          = 3.

      IF sy-subrc = 0.
        TRY.
            me->modify_0500_grid( ir_sender = sender ir_event = er_event_data is_tabline = lt_depgr[ key = lt_ret[ 1 ]-fieldval ] iv_row_id = es_row_no-row_id ).
          CATCH cx_sy_itab_line_not_found.
        ENDTRY.
      ENDIF.

    ELSEIF me->pernr_f4( IMPORTING es_pernr = ls_pernr ev_long = lv_long ).

      me->modify_0500_grid(
        ir_sender   = sender
        ir_event    = er_event_data
        is_tabline  = ls_pernr
        iv_long     = lv_long
        iv_row_id   = es_row_no-row_id ).
    ENDIF.

    er_event_data->m_event_handled = 'X'.

  ENDMETHOD.


  METHOD on_toolbar_event.
*--> #8000000273 AK_BUTVILOVS Разработка роли для просмотра z-транзакций по БНУ
*    APPEND LINES OF VALUE ttb_button(
*  ( butn_type = 3 )
*  ( function = 'NEW' icon = icon_add_row            text = TEXT-t00 quickinfo = TEXT-q00 )
*  ( function = 'MASS' icon = icon_copy_object       text = TEXT-t04 quickinfo = TEXT-q04 )
*  ( butn_type = 3 )
*  ( function = 'SAVE' icon = icon_save_as_template  text = TEXT-t05 quickinfo = TEXT-q05 )
*  ( function = 'READ' icon = icon_import            text = TEXT-t06 quickinfo = TEXT-q06 )
*  ( butn_type = 3 )
*) TO e_object->mt_toolbar[].

    e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
                                                   ( butn_type = 3 ) ).

    AUTHORITY-CHECK OBJECT 'ZBN_DISPLA'
          ID 'ACTVT' FIELD '02'.
    IF sy-subrc = 0.
      e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
                                                     ( function = 'NEW'               " Вставить новую строку
                                                       icon = icon_add_row
                                                       text = TEXT-t00
                                                       quickinfo = TEXT-q00 ) ).
    ENDIF.

    e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
                                                   ( function = 'MASS'
                                                     icon = icon_copy_object
                                                     text = TEXT-t04
                                                     quickinfo = TEXT-q04 )
                                                   ( butn_type = 3 )
                                                   ( function = 'SAVE'
                                                     icon = icon_save_as_template
                                                     text = TEXT-t05
                                                     quickinfo = TEXT-q05 ) ).

    AUTHORITY-CHECK OBJECT 'ZBN_DISPLA'
          ID 'ACTVT' FIELD '02'.
    IF sy-subrc = 0.
      e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
                                                     ( function = 'READ'              " Загрузить опись
                                                       icon = icon_import
                                                       text = TEXT-t06
                                                       quickinfo = TEXT-q06 ) ).
    ENDIF.

    e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
                                                   ( butn_type = 3 ) ).
*<-- #8000000273 AK_BUTVILOVS
  ENDMETHOD.


  METHOD on_ucomm_event.
    CASE e_ucomm.
      WHEN 'MASS'.
        LOOP AT gs_out-data[] ASSIGNING FIELD-SYMBOL(<ls_price>).
          me->set_prices( EXPORTING iv_copy_menge = abap_true CHANGING cs_data = <ls_price> ).
        ENDLOOP.
        gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
      WHEN 'NEW'.
        set_ucomm( 'NEW_RECORD' ).
      WHEN 'READ'.
        select_stored_result( ).
        initiate_report( ).
        me->select_data(  ).
        me->show_alv( ).
        SUPPRESS DIALOG.
      WHEN 'SAVE'.
        set_ucomm( 'SAVE_LIST' ).
      WHEN 'PRINT_INV'.
        gs_sscr-print_title = TEXT-t10.
        gs_out-comis-sscr500-text = me->get_sscr_text( ).
        set_ucomm( 'PRINT_INV' ).
      WHEN 'PRINT_VED'.
        gs_sscr-print_title = TEXT-t11.
        set_ucomm( 'PRINT_COLL' ).
      WHEN 'PRINT_SVOD'.
        gs_sscr-print_title = TEXT-t12.
        gs_out-comis-sscr500-text = me->get_hkont_list( ).
        set_ucomm( 'PRINT_SVOD' ).
      WHEN 'PRINT_AKT'.
        gs_sscr-print_title = TEXT-t13.
        gs_out-comis-sscr500-text = me->get_sscr_text( ).
        set_ucomm( 'PRINT_AKT' ).
    ENDCASE.
  ENDMETHOD.


  METHOD pernr_f4.
    DATA: ls_shlp TYPE shlp_descr,
          lt_ret  TYPE STANDARD TABLE OF ddshretval.

    "Search-help для табельного номера (PREM)
    CALL FUNCTION 'F4IF_GET_SHLP_DESCR'
      EXPORTING
        shlpname = CONV shlpname( 'PREM' )
      IMPORTING
        shlp     = ls_shlp.

    TRY.
        ls_shlp-interface[ shlpfield = 'PERNR' ]-valfield = abap_true.
      CATCH cx_sy_itab_line_not_found.
        RETURN.
    ENDTRY.

    CALL FUNCTION 'F4IF_START_VALUE_REQUEST'
      EXPORTING
        shlp          = ls_shlp
      TABLES
        return_values = lt_ret[].

    TRY.
        zaa_cl_print_inventory_amdp=>read_pernr(
          EXPORTING
            iv_pernr    = VALUE pernr_d( lt_ret[ 1 ]-fieldval )
            iv_ondate   = gs_out-invdate
          IMPORTING
            et_pernr  = DATA(lt_pernr)
            et_long   = DATA(lt_long) ).
      CATCH cx_sy_itab_line_not_found.
        RETURN.
      CATCH cx_root.
        MESSAGE i999(zaa) WITH TEXT-e08 DISPLAY LIKE 'E'.
        RETURN.
    ENDTRY.

    IF lt_pernr[] IS NOT INITIAL.
      es_pernr = VALUE #(
        pernr = lt_pernr[ 1 ]-pernr
        ename = lt_pernr[ 1 ]-ename
        stell = lt_pernr[ 1 ]-stell
        stext = lt_pernr[ 1 ]-stext ).
    ENDIF.

    ev_long = REDUCE #( INIT lv_str TYPE string
      FOR <ls_line> IN lt_long[]
      NEXT lv_str = lv_str && <ls_line>-value ).

    rv_ok = abap_true.

  ENDMETHOD.


  METHOD read_set_pernr.
    DATA: lv_field TYPE fieldname,
          lv_long  TYPE string,
          ls_pernr TYPE zaa_cl_print_inventory_amdp=>gty_s_pernr_data.

    FIELD-SYMBOLS: <fs_dst> TYPE any.


    IF me->pernr_f4( IMPORTING es_pernr = ls_pernr ev_long = lv_long ).
      GET CURSOR FIELD lv_field.
      DATA(lr_matcher) =
        NEW cl_abap_regex( pattern = '\w+-(\w+)_\w+' ignore_case = abap_true )->create_matcher( text = lv_field ).
      IF lr_matcher->match( ).
        TRY.
            lv_field = lr_matcher->get_submatch( 1 ).
          CATCH cx_sy_matcher.
            RETURN.
        ENDTRY.
      ENDIF.


      DATA(lt_sscr) = VALUE dynpread_t(
          ( fieldname = |GS_COMIS-{ lv_field }_FIO| fieldvalue = ls_pernr-ename )
          ( fieldname = |GS_COMIS-{ lv_field }_POS| fieldvalue =
            COND #( WHEN strlen( lv_long ) > strlen( ls_pernr-stext ) THEN lv_long ELSE ls_pernr-stext ) ) ).

      CALL FUNCTION 'DYNP_UPDATE_FIELDS'
        EXPORTING
          dyname     = sy-cprog
          dynumb     = sy-dynnr
          request    = 'A'
        TABLES
          dynpfields = lt_sscr[].

      ASSIGN COMPONENT |{ lv_field }_FIO| OF STRUCTURE cs_comis TO <fs_dst>.
      IF sy-subrc = 0.
        <fs_dst> = lt_sscr[ 1 ]-fieldvalue.
      ENDIF.

      ASSIGN COMPONENT |{ lv_field }_POS| OF STRUCTURE cs_comis TO <fs_dst>.
      IF sy-subrc = 0.
        <fs_dst> = lt_sscr[ 2 ]-fieldvalue.
      ENDIF.

    ENDIF.
  ENDMETHOD.


  METHOD save_comis.
    DATA: lr_data      TYPE REF TO data,
          lv_answ      TYPE c,
          ls_comish    TYPE zmcomish,
          lt_comisp    TYPE STANDARD TABLE OF zmcomisp,
          lt_comis_add TYPE STANDARD TABLE OF zmcomis_add.

    SELECT SINGLE * FROM zmcomish
      INTO ls_comish
      WHERE comis_num = is_comis-comis_num
        AND bukrs = is_comis-bukrs.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_VALUE'
        EXPORTING
          titel          = TEXT-000
          text_before    = TEXT-001
          objectvalue    = |{ is_comis-comis_num }/{ is_comis-bukrs }|
          text_after     = TEXT-002
          cancel_display = abap_false
        IMPORTING
          answer         = lv_answ.

      IF sy-subrc <> 0 OR lv_answ <> 'J'.
        RETURN.
      ENDIF.
    ENDIF.

    ls_comish = CORRESPONDING #( is_comis ).

    lt_comisp[] = VALUE #(
      FOR <ls_part> IN gs_out-comis-participants[] INDEX INTO lv_idx
      ( comis_num = ls_comish-comis_num
        c_index   = lv_idx
        zposition = <ls_part>-stext
        fio       = <ls_part>-ename ) ).

    lt_comis_add[] = VALUE #(
      ( comis_num = ls_comish-comis_num
        bukrs     = ls_comish-bukrs
        type_add  = 1                     "Бухгалтер
        c_index   = 1
        memb_pos  = is_comis-accnt_pos
        memb_fio  = is_comis-accnt_fio )

      ( comis_num = ls_comish-comis_num
        bukrs     = ls_comish-bukrs
        type_add  = 2                     "Сдал
        c_index   = 1
        memb_pos  = is_comis-deliv_pos
        memb_fio  = is_comis-deliv_fio )

      ( comis_num = ls_comish-comis_num
        bukrs     = ls_comish-bukrs
        type_add  = 3                     "Проверил
        c_index   = 1
        memb_pos  = is_comis-visor_pos
        memb_fio  = is_comis-visor_fio )

      ( comis_num = ls_comish-comis_num
        bukrs     = ls_comish-bukrs
        type_add  = 4                     "Принял
        c_index   = 1
        memb_pos  = is_comis-taker_pos
        memb_fio  = is_comis-taker_fio )

      ( comis_num = ls_comish-comis_num
        bukrs     = ls_comish-bukrs
        type_add  = 5                     "МОЛ
        c_index   = 1
        memb_pos  = is_comis-mol_pos
        memb_fio  = is_comis-mol_fio ) ).

    DELETE zmcomish FROM ls_comish.
    MODIFY zmcomish FROM ls_comish.

    DELETE FROM zmcomisp WHERE comis_num = ls_comish-comis_num." and bukrs = ls_comish-bukrs.
    MODIFY zmcomisp FROM TABLE lt_comisp[].

    DELETE FROM zmcomis_add WHERE comis_num = ls_comish-comis_num AND bukrs = ls_comish-bukrs.
    MODIFY zmcomis_add FROM TABLE lt_comis_add[].


  ENDMETHOD.


  METHOD select_data.
    "Чтение из AMDP наиболее общим методом (возможны переопределения в child-ах).
    IF gs_sscr-previous = abap_true.
      TRY.
          zaa_cl_print_inventory_amdp=>read_db_results(
            EXPORTING
              iv_laufd  = gs_sscr-invdate
              iv_laufi  = gs_sscr-laufi
              iv_colors = me->color_negative && me->color_positive && me->color_equivalent
            IMPORTING
              et_data     = gs_out-data[]
              et_depgr    = gs_out-comis-depgroups[]
              et_resp     = gs_out-comis-responsible[]
              et_locat    = gs_out-comis-locations[]
              et_adds     = DATA(lt_adds)
              et_textkeys = DATA(lt_textkeys) ).
        CATCH cx_root.
          MESSAGE i999(zaa) WITH TEXT-e03 DISPLAY LIKE 'E'.
          RETURN.
      ENDTRY.
    ELSE.
      TRY.
          zaa_cl_print_inventory_amdp=>read_data(
            EXPORTING
              iv_bukrs      = gs_sscr-bukrs
              iv_ondate     = gs_sscr-invdate
              iv_adatu      = gs_sscr-adatu
              iv_afabe      = '01'
              iv_filter     = me->get_filter_string( )
              iv_list       = abap_true
            IMPORTING
              et_data     = gs_out-data[]
              et_depgr    = gs_out-comis-depgroups[]
              et_resp     = gs_out-comis-responsible[]
              et_locat    = gs_out-comis-locations[]
              et_adds     = lt_adds[]
              et_textkeys = lt_textkeys ).
        CATCH cx_root.
          MESSAGE i999(zaa) WITH TEXT-e01 DISPLAY LIKE 'E'.
          RETURN.
      ENDTRY.
    ENDIF.

    IF gs_sscr-full_ozos = abap_true.
      me->fill_ozos( lt_textkeys[] ).
    ENDIF.
    IF gs_out-data[] IS NOT INITIAL.
      " наименование БЕ
      zcl_names=>get_org_names(
       EXPORTING
         it_bukrs = VALUE #( ( sign = 'I' option = 'EQ' low = gs_sscr-bukrs ) )
       IMPORTING
         ev_butxt = DATA(lv_bukrs)
     ).
      gs_out = VALUE #( BASE gs_out
        bukrs       = gs_sscr-bukrs
        butxt       = lv_bukrs
        buname      = lv_bukrs
        adds        = lt_adds[ 1 ]
        invdate     = gs_sscr-invdate
        title       = gt_report_types[ key = gs_sscr-classtype ]-value
        repeat_sign = gs_sscr-repeat_sign
        mol_signs   = gs_sscr-mol_signs ).

      rv_ok = abap_true.

      gs_out-adds-name1 = shift_left( val = gs_out-adds-name1 sub = ` ` ).
      gs_out-adds-name2 = shift_left( val = gs_out-adds-name2 sub = ` ` ).
    ENDIF.

    gs_out-buname = replace( val = replace( val = gs_out-buname sub = `  ` with = ` ` ) sub = `  ` with = ` ` ).
  ENDMETHOD.


  METHOD select_stored_result.
    TYPES:
      BEGIN OF lty_s_t001,
        bukrs TYPE t001-bukrs,
      END OF lty_s_t001.
    DATA: lt_t001 TYPE STANDARD TABLE OF lty_s_t001 WITH DEFAULT KEY.

    TRY.
        zaa_cl_print_inventory_amdp=>read_result_head(
          IMPORTING
            et_head  = DATA(lt_head) ).
      CATCH cx_root.
        MESSAGE i999(zaa) WITH TEXT-e02 DISPLAY LIKE 'E'.
        RETURN.
    ENDTRY.

    IF lt_head[] IS INITIAL.
      MESSAGE i999(zaa) WITH TEXT-e02 DISPLAY LIKE 'I'.
      RETURN.
    ENDIF.

    TRY.
        cl_salv_table=>factory(
          IMPORTING r_salv_table = lr_stored
          CHANGING  t_table      = lt_head[] ).
      CATCH cx_salv_msg.
    ENDTRY.

    DATA(lr_events) = lr_stored->get_event( ).
    SET HANDLER on_head_dblclick FOR lr_events.

    lr_stored->set_screen_popup(
      start_column = 15
      end_column  = 100
      start_line  = 5
      end_line    = 25 ).

    lr_stored->display( ).

    IF sy-ucomm = '&AC1'.
      RETURN.
    ENDIF.

    DATA(ls_cell) = lr_stored->get_selections( )->get_current_cell( ).

    IF ls_cell-row > 0.
      gs_sscr = VALUE #( BASE gs_sscr
        invdate   = lt_head[ ls_cell-row ]-laufd
        laufi     = lt_head[ ls_cell-row ]-laufi
        classtype = SWITCH #( lt_head[ ls_cell-row ]-type WHEN ' ' THEN 'RIG' ELSE lt_head[ ls_cell-row ]-type )
        previous  = abap_true
        comis     = lt_head[ ls_cell-row ]-comis
        variant   = gs_sscr-variant ).

      FREE lr_events.
      FREE lr_stored.

      rv_ok = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD set_page_header.
    IF cl_gui_alv_grid=>offline( ) IS NOT INITIAL.
      RETURN.
    ENDIF.

    DATA(lr_html) = NEW cl_dd_document( style = 'ALV_GRID' background_color = 35 ).

    lr_html->add_text( text = TEXT-t01 sap_emphasis = cl_dd_document=>strong ).
    lr_html->add_gap( width = 2 ).
    lr_html->add_text( text = SWITCH #( gs_sscr-previous
      WHEN abap_true THEN |{ gs_out-title } ({ TEXT-tt0 })|
      ELSE gs_out-title ) ).

    lr_html->new_line( ).
    lr_html->add_text( text = TEXT-t02 sap_emphasis = cl_dd_document=>strong ).
    lr_html->add_gap( width = 16 ).
    lr_html->add_text( text = CONV #( gs_out-butxt ) ).

    lr_html->new_line( ).
    lr_html->add_text( text = TEXT-t03 sap_emphasis = cl_dd_document=>strong ).
    lr_html->add_gap( width = 12 ).
    lr_html->add_text( text = |{ gs_out-invdate+6(2) }.{ gs_out-invdate+4(2) }.{ gs_out-invdate(4) }| ).

    lr_html->display_document( parent = ir_container ).
  ENDMETHOD.


  METHOD set_prices.
    FIELD-SYMBOLS: <ls_cost> TYPE zaa_cl_print_inventory_amdp=>gty_s_stoim.

    IF iv_copy_menge = abap_true.
      cs_data-cost-fmeng = cs_data-cost-menge.
      cs_data-cost-confirmed = cs_data-cost-costre_ac.
      cs_data-cost-unconfirmed = 0.
    ELSE.
      cs_data-cost-unconfirmed = cs_data-cost-costre_ac - cs_data-cost-confirmed.
    ENDIF.

    cs_data-cost-fact = cs_data-cost-fmeng * cs_data-cost-price.
    "cs_data-cost-fact = COND #(
    "  WHEN cs_data-cost-menge = cs_data-cost-fmeng
    "    THEN cs_data-cost-stoim
    "    ELSE cs_data-cost-fmeng * cs_data-cost-price ).

    cs_data-cost = VALUE #( BASE cs_data-cost
      dif_n_amt = COND #(
        WHEN cs_data-cost-fmeng <= cs_data-cost-menge THEN cs_data-cost-menge - cs_data-cost-fmeng
        ELSE 0 )
      dif_n = COND #(
        WHEN cs_data-cost-fmeng <= cs_data-cost-menge THEN cs_data-cost-stoim - cs_data-cost-fact
        ELSE 0 )
      dif_p_amt = COND #(
        WHEN cs_data-cost-fmeng >= cs_data-cost-menge THEN cs_data-cost-fmeng - cs_data-cost-menge
        ELSE 0 )
      dif_p = COND #(
        WHEN cs_data-cost-fmeng >= cs_data-cost-menge THEN cs_data-cost-fact - cs_data-cost-stoim
        ELSE 0 )
      color = COND #(
        WHEN cs_data-cost-menge > cs_data-cost-fmeng THEN me->color_negative
        WHEN cs_data-cost-menge < cs_data-cost-fmeng THEN me->color_positive
        ELSE me->color_equivalent ) ).
  ENDMETHOD.


  METHOD set_ucomm.
    CALL FUNCTION 'SAPGUI_SET_FUNCTIONCODE'
      EXPORTING
        functioncode           = iv_ucomm
      EXCEPTIONS
        function_not_supported = 1
        OTHERS                 = 2.

  ENDMETHOD.


  METHOD show_alv.
    DATA: lr_splitter TYPE REF TO cl_gui_splitter_container.
    FIELD-SYMBOLS: <lt_data> TYPE STANDARD TABLE.

    IF gr_grid IS BOUND.
      lr_splitter = CAST #( gr_grid->parent->parent ).

      IF lr_splitter IS BOUND.
        lr_splitter->remove_control( row = 1 column = 1 ).
        me->set_page_header( lr_splitter->get_container( row = 1 column = 1 ) ).
      ENDIF.

      gr_grid->refresh_table_display( EXPORTING is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true )
                                      EXCEPTIONS OTHERS = 0
                                     ).
      RETURN.
    ENDIF.

    DATA(lt_fcat)     = me->fill_fieldcat( ).
    DATA(ls_layout)   = VALUE lvc_s_layo( zebra = abap_true col_opt = abap_true info_fname = 'COLOR' ).
    DATA(lt_sort)     = VALUE lvc_t_sort(
      ( spos = 1 fieldname = 'BUKRS'   up = abap_true )
      ( spos = 2 fieldname = 'ANLN'   up = abap_true )
    ).

    lr_splitter = NEW #(
      parent = NEW cl_gui_custom_container( container_name = 'ALV_CONTAINER' )
      rows = 2
      columns = 1 ).
    lr_splitter->set_row_height( id = 1 height = 7 ).
    me->set_page_header( lr_splitter->get_container( row = 1 column = 1 ) ).

    gr_grid = NEW #( i_parent =  lr_splitter->get_container( row = 2 column = 1 ) ).

    gr_grid->register_edit_event( i_event_id = cl_gui_alv_grid=>mc_evt_modified ).

    DATA(lt_exclude) = VALUE rsd_t_func(
      ( cl_gui_alv_grid=>mc_fc_loc_copy_row )
      ( cl_gui_alv_grid=>mc_fc_loc_paste )
      ( cl_gui_alv_grid=>mc_fc_loc_cut )
      ( cl_gui_alv_grid=>mc_fc_loc_copy )
      ( cl_gui_alv_grid=>mc_fc_loc_insert_row )
      ( cl_gui_alv_grid=>mc_fc_loc_move_row )
      ( cl_gui_alv_grid=>mc_fc_loc_paste )
      ( cl_gui_alv_grid=>mc_fc_loc_paste_new_row )
      ( cl_gui_alv_grid=>mc_fc_refresh )
      ( cl_gui_alv_grid=>mc_fc_loc_undo )
      ( cl_gui_alv_grid=>mc_fc_loc_append_row )
      ( cl_gui_alv_grid=>mc_fc_loc_delete_row )
      ( cl_gui_alv_grid=>mc_mb_view )
      ( cl_gui_alv_grid=>mc_fc_info )
    ).

    SET HANDLER
      gr_handler->on_data_changed
      gr_handler->on_hotspot_event
      gr_handler->on_ucomm_event
      gr_handler->on_toolbar_event
      gr_handler->on_context_menu
      FOR gr_grid.

    gr_grid->set_table_for_first_display(
      EXPORTING is_layout             = ls_layout
                i_save                = 'A'
                i_default             = abap_true
                is_variant            = gs_sscr-variant
                it_toolbar_excluding  = lt_exclude[]
      CHANGING  it_outtab             = gs_out-data[]
                it_fieldcatalog       = lt_fcat[]
                it_sort               = lt_sort[] ).

  ENDMETHOD.


  METHOD show_comis.
    DATA: lt_comis TYPE STANDARD TABLE OF zmcomisp.
    DATA: lt_comdata TYPE STANDARD TABLE OF zfi_cl_comiss=>gty_s_comdata WITH DEFAULT KEY.
    FIELD-SYMBOLS: <lt_part> TYPE STANDARD TABLE,
                   <fs_src>  TYPE any.

    IF gs_out-title = TEXT-tt3.
      FREE: gs_out-comis-depgroups[].
      LOOP AT  gs_out-data[] ASSIGNING FIELD-SYMBOL(<ls_dat>) GROUP BY <ls_dat>-anlkl.
        APPEND VALUE #( key = <ls_dat>-anlkl  value = <ls_dat>-ankt_long  ) TO gs_out-comis-depgroups[].
      ENDLOOP.
    ENDIF.

    lt_comis = VALUE #(
      FOR <ls_part> IN gs_out-comis-participants[]
      ( fio = <ls_part>-ename zposition = <ls_part>-stext ) ).

    lt_comdata[] = VALUE #(
      ( data_key = 'ALV_PART'             is_alv = abap_true data_ref = REF #( lt_comis[] ) )
      ( data_key = 'ALV_RESP'             is_alv = abap_true data_ref = REF #( gs_out-comis-responsible[] ) )
      ( data_key = 'ALV_DEPG'             is_alv = abap_true data_ref = REF #( gs_out-comis-depgroups[] ) )
      ( data_key = 'ALV_LOCAT'            is_alv = abap_true data_ref = REF #( gs_out-comis-locations[] ) )
      ( data_key = 'ALV_BUKRS'            is_alv = abap_false data_ref = REF #( gs_out-bukrs ) )                    " ins 12.03.2024 V.Lipskij #37512
      ( data_key = 'GS_COMIS-TEXT'        data_ref = REF #( gs_out-comis-sscr500-text ) )
      ( data_key = 'GS_COMIS-FLAG'        data_ref = REF #( gs_out-comis-sscr500-flag ) )
      ( data_key = 'GS_COMIS-VISOR_FIO'   data_ref = REF #( gs_out-comis-sscr500-visor_fio ) )
      ( data_key = 'GS_COMIS-VISOR_POS'   data_ref = REF #( gs_out-comis-sscr500-visor_pos ) )
      ( data_key = 'GS_COMIS-DATE_INV_E'  data_ref = REF #( gs_out-comis-sscr500-date_inv_e ) )
      ( data_key = 'GS_COMIS-DOCNUM'      data_ref = REF #( gs_out-comis-sscr500-docnum ) )
    ).

    DATA(lv_screen) = COND #(
      WHEN im_screen IS SUPPLIED THEN CONV char4( CONV numc4( im_screen ) )
      ELSE CONV char4( CONV numc4( im_dynnr ) ) ).

    IF gs_sscr-mol_signs = abap_false.
      DATA(lt_hide_groups) = VALUE wdy_key_value_list( ( key = 'GROUP2' value = 'HID' ) ).
    ENDIF.

    rs_comis = CORRESPONDING #( zfi_cl_comiss=>show_comiss(
      EXPORTING
        im_comis        = gs_sscr-comis
        im_dynnr        = im_dynnr
        im_screen       = lv_screen
        it_hide_groups  = lt_hide_groups[]
      CHANGING
        ct_comisdata = lt_comdata[] ) ).

    LOOP AT lt_comdata[] ASSIGNING FIELD-SYMBOL(<ls_comdata>).
      IF <ls_comdata>-is_alv = abap_false.
        ASSIGN <ls_comdata>-data_ref->* TO <fs_src>.
        IF sy-subrc = 0.
          CASE <ls_comdata>-data_key.
            WHEN 'GS_COMIS-TEXT'. rs_comis-text = <fs_src>.
            WHEN 'GS_COMIS-FLAG'. rs_comis-flag = <fs_src>.
          ENDCASE.
        ENDIF.
      ELSE.
        IF <ls_comdata>-data_key = 'ALV_PART'.
          ASSIGN <ls_comdata>-data_ref->* TO <lt_part>.
          lt_comis[] = CORRESPONDING #( <lt_part>[] ).
          gs_out-comis-participants[] = VALUE #(
            FOR <ls_data> IN lt_comis[]
              ( ename = <ls_data>-fio stext = <ls_data>-zposition ) )..
        ENDIF.
      ENDIF.
    ENDLOOP.

    gs_out-comis-sscr500 = rs_comis.
    gs_sscr-comis = rs_comis-comis_num.
  ENDMETHOD.


  METHOD start_print_dialog.
    DATA: lv_comis  TYPE zaa_inv_head-comis,
          lv_prefix TYPE fieldname VALUE 'GS_COMIS-',
          lt_comis  TYPE STANDARD TABLE OF zaa_cl_print_inventory_amdp=>gty_s_comis_head,
          lt_ret    TYPE STANDARD TABLE OF ddshretval,
          lt_sscr   TYPE STANDARD TABLE OF dynpread,
          lt_sel    TYPE STANDARD TABLE OF rsparams.

    IF iv_number IS NOT SUPPLIED.
      TRY.
          zaa_cl_print_inventory_amdp=>read_comis(
            EXPORTING
              iv_list   = abap_true
            IMPORTING
              et_comis  = DATA(lt_data) ).
        CATCH cx_root.
          MESSAGE i999(zaa) WITH TEXT-e07 DISPLAY LIKE 'E'.
          RETURN.
      ENDTRY.

      lt_comis[] = CORRESPONDING #( lt_data[] ).

      CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
        EXPORTING
          retfield   = 'COMIS_NUM'
          value_org  = 'S'
        TABLES
          value_tab  = lt_comis[]
          return_tab = lt_ret[].

      IF sy-subrc <> 0 OR lt_ret[] IS INITIAL.
        RETURN.
      ENDIF.
      lv_comis = CONV #( lt_ret[ 1 ]-fieldval ).
    ELSE.
      lv_comis = is_comis-comis_num.
    ENDIF.

    TRY.
        zaa_cl_print_inventory_amdp=>read_comis(
          EXPORTING
            iv_number       = lv_comis
          IMPORTING
            et_comis        = lt_data[]
            et_participants = gs_out-comis-participants[] ).
      CATCH cx_root.
        MESSAGE i999(zaa) WITH TEXT-e08 DISPLAY LIKE 'E'.
    ENDTRY.

    TRY.
        rs_comis = gs_out-comis-sscr500 = CORRESPONDING #( lt_data[ 1 ] ).
        rs_comis = VALUE #( BASE rs_comis
          text = is_comis-text ).
      CATCH cx_sy_itab_line_not_found.
    ENDTRY.

    DATA(lr_descr) = CAST cl_abap_structdescr( cl_abap_structdescr=>describe_by_data( rs_comis ) ).

    LOOP AT lr_descr->components[] ASSIGNING FIELD-SYMBOL(<ls_descr>) WHERE type_kind <> 'h' AND name <> 'FLAG'.
      ASSIGN COMPONENT <ls_descr>-name OF STRUCTURE rs_comis TO FIELD-SYMBOL(<ls_val>).
      lt_sscr[] = VALUE #( BASE lt_sscr[]
        ( fieldname = lv_prefix && <ls_descr>-name
          fieldvalue = SWITCH #( <ls_descr>-type_kind
            WHEN 'D' THEN |{ CONV datum( <ls_val> ) DATE = ENVIRONMENT }|
            ELSE <ls_val> ) ) ).
    ENDLOOP.

    CALL FUNCTION 'DYNP_UPDATE_FIELDS'
      EXPORTING
        dyname     = sy-cprog
        dynumb     = sy-dynnr
        request    = 'A'
      TABLES
        dynpfields = lt_sscr[].

    me->init_screen_500_alv( EXPORTING iv_num = 1 ir_table = REF #( gs_out-comis-participants[] ) CHANGING ir_grid = gr_part ).
    me->init_screen_500_alv( EXPORTING iv_num = 2 ir_table = REF #( gs_out-comis-responsible[] ) CHANGING ir_grid = gr_resp  ).
    me->init_screen_500_alv( EXPORTING iv_num = 3 ir_table = REF #( gs_out-comis-depgroups[] ) CHANGING ir_grid = gr_depgr  ).

    rs_comis-text = me->get_hkont_list( ).

    SET HANDLER
      me->on_screen500_f4
      FOR ALL INSTANCES.

  ENDMETHOD.


  METHOD store_record.
    DATA: ls_data TYPE zaa_cl_print_inventory_amdp=>gty_s_data.

    ls_data = CORRESPONDING #( cs_data ).

    me->set_prices( CHANGING cs_data = ls_data ).
    APPEND ls_data TO gs_out-data[].

    READ TABLE gs_out-data[] TRANSPORTING NO FIELDS WITH KEY bukrs = cs_data-bukrs anln1 = cs_data-anln1 anln2 = cs_data-anln2 BINARY SEARCH.
    IF sy-subrc EQ 0.
      gr_grid->set_selected_rows( it_row_no = VALUE lvc_t_roid( ( row_id = sy-tabix ) ) ).
    ENDIF.
    gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
  ENDMETHOD.


  METHOD store_to_db.
    DATA: lv_answ TYPE c,
          ls_inv  TYPE zaa_inv,
          lt_inv  TYPE STANDARD TABLE OF zaa_inv.

    SELECT SINGLE laufi
      FROM zaa_inv_head
      INTO ls_inv
      WHERE laufd = is_head-laufd
        AND laufi = is_head-laufi
        AND type  = is_head-type.

    IF sy-subrc = 0.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = TEXT-t07
          text_question         = TEXT-t08
          display_cancel_button = space
        IMPORTING
          answer                = lv_answ
        EXCEPTIONS
          text_not_found        = 1
          OTHERS                = 2.
      IF sy-subrc <> 0 OR lv_answ <> '1' .
        RETURN.
      ENDIF.
    ENDIF.

    DATA(ls_head) = VALUE zaa_inv_head( laufd = is_head-laufd laufi = is_head-laufi type = is_head-type comis = is_head-comis ).
    DELETE FROM zaa_inv_head WHERE laufd = ls_head-laufd AND laufi = ls_head-laufi AND type = ls_head-type.
    MODIFY zaa_inv_head FROM ls_head.

    DELETE FROM zaa_inv WHERE laufd = is_head-laufd AND laufi = is_head-laufi.

    LOOP AT gs_out-data[] ASSIGNING FIELD-SYMBOL(<ls_data>).
      APPEND INITIAL LINE TO lt_inv ASSIGNING FIELD-SYMBOL(<ls_inv>).
      MOVE-CORRESPONDING <ls_data> TO <ls_inv>.
      <ls_inv>-bukrs = gs_sscr-bukrs.
      <ls_inv>-laufd = is_head-laufd.
      <ls_inv>-laufi = is_head-laufi.
    ENDLOOP.

    MODIFY zaa_inv FROM TABLE lt_inv[].
    COMMIT WORK.
    MESSAGE i999(zaa) WITH TEXT-t09.

  ENDMETHOD.
ENDCLASS.