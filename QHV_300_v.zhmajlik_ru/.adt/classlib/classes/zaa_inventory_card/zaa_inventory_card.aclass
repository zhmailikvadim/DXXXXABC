class ZAA_INVENTORY_CARD definition
  public
  create public .

public section.

  types:
    BEGIN OF gty_s_oss,
             bukrs TYPE bukrs,
             anln1 TYPE anln1,
             anln2 TYPE anln2,
           END OF gty_s_oss .
  types:
    GTY_T_OSS TYPE STANDARD TABLE OF GTY_s_OSS .
  types:
    BEGIN OF gty_s_group_os,
        bukrs        TYPE bukrs,
        anlkl        TYPE anla-anlkl,
        glo_rus_okof TYPE j_3rfokof,
        lgort        TYPE lgort_d,
        raumn        TYPE anlz-raumn,
      END OF gty_s_group_os .

  data:
    BEGIN OF gs_setup,
        responsible TYPE pernr_d,
        precious    TYPE pernr_d,
        lgort       TYPE t001l-lgort,
      END OF gs_setup .

  methods START_OF_SELECTION
    importing
      value(IV_BUKRS) type ANLA-BUKRS
      value(IV_ANLN1) type ANLA-ANLN1
      value(IV_ANLN2) type ANLA-ANLN2
    changing
      value(CV_PREC) type PERNR_D
      value(CV_RESP) type PERNR_D
      value(CV_PRECTX) type STRING
      value(CV_RESPTX) type STRING
    returning
      value(RV_CLASS) type J_3RFANKA-ANKA_TYPE
    exceptions
      OS_READ_ERROR .
  methods SHOW_INVENTORY_CARD
    importing
      value(IV_TYPE) type C
      value(IV_ONDATE) type DATUM
      value(IV_RESPONS) type PERNR_D
      !IV_PRECIOUS type PERNR_D
    returning
      value(RV_RESULT) type FLAG .
  methods SHOW_INVENTORY_CARD_GR
    importing
      value(IV_ONDATE) type DATUM
      value(IV_RESPONS) type PERNR_D
      !IV_PRECIOUS type PERNR_D
      !IT_OSS type GTY_T_OSS
      value(IV_LGORT) type LGORT_D
      value(IV_NAME_LGORT) type STRING .
  methods F4_PERNR
    importing
      value(IM_PERNR) type PERNR_D optional
    changing
      value(CV_ENAME) type STRING optional
    returning
      value(RV_PERNR) type PERNR_D .
  PROTECTED SECTION.
private section.

  types:
    BEGIN OF gty_s_lifetime,
      hist_calc  TYPE abap_bool,
      begda      TYPE begda,
      endda      TYPE endda,
      nss_gjahr  TYPE i,
      nss_month  TYPE i,
      spi_gjahr  TYPE i,
      spi_month  TYPE i,
      rest_gjahr TYPE i,
      rest_month TYPE i,
      used_gjahr TYPE i,
      used_month TYPE i,
      nss_text   TYPE zaa_inventory_card_sect1_line-nss_text,
      spi_text   TYPE zaa_inventory_card_sect1_line-nss_text,
      fact_text  TYPE zaa_inventory_card_sect1_line-nss_text,
      rest_text  TYPE zaa_inventory_card_sect1_line-nss_text,
    END OF gty_s_lifetime .

  data GC_R4_SET type SETHIER-SETID value 'Z_TTYPE_OC6_R4' ##NO_TEXT.
  data GC_R5_SET type SETHIER-SETID value 'Z_TTYPE_OC6_R5' ##NO_TEXT.
  data GC_R6_SET type TVARVC-NAME value 'ZAA_BWASL_MODERN_OC6' ##NO_TEXT.
  data GS_ANLN type ZAA_INVENTORY_CARD_ANLN .
  data GT_DENOMINATIONS type WDY_KEY_VALUE_LIST .
  data GC_R6_VVOD_SET type TVARVC-NAME value 'ZAA_BWASL_VVOD_OS6' ##NO_TEXT.

  methods READ_STRUCT_FIELD
    importing
      value(IV_FIELD) type FIELDNAME optional
      value(IS_STRUCT) type ANY optional
      value(IV_DEFAULT) type CLIKE optional
    returning
      value(RV_VALUE) type STRING .
  methods FILL_SECT2
    importing
      value(IS_FORM) type ZAA_INVENTORY_CARD_OS
      value(IT_SECT2) type ZAA_INVENTORY_CARD_SECT2
      value(IT_HIST) type ZAA_INVENTORY_CARD_OS_HDB=>GTY_T_HIST_BASE
    returning
      value(RT_SECT2) type ZAA_INVENTORY_CARD_SECT2 .
  methods LIFETIME_TO_VERB
    importing
      value(IV_TEXT) type CLIKE
    returning
      value(RV_TEXT) type GTY_S_LIFETIME-NSS_TEXT .
  methods GET_MONAM
    importing
      value(IV_ONDATE) type DATUM
    returning
      value(RV_MONAM) type T015M-MONAM .
  methods GET_FIXEDASSET
    importing
      value(IS_ANLN) type ZAA_INVENTORY_CARD_ANLN
    returning
      value(RS_FORM) type ZAA_INVENTORY_CARD_OS .
  methods GET_INTANASSET
    importing
      value(IS_ANLN) type ZAA_INVENTORY_CARD_ANLN
    returning
      value(RS_FORM) type ZAA_INVENTORY_CARD_NMA .
  methods SET_NMA_TEXTS
    importing
      value(IS_FORM) type ZAA_INVENTORY_CARD_NMA
    returning
      value(RS_FORM) type ZAA_INVENTORY_CARD_NMA .
  methods SET_OS_TEXTS
    importing
      value(IS_FORM) type ZAA_INVENTORY_CARD_OS
    returning
      value(RS_FORM) type ZAA_INVENTORY_CARD_OS .
  methods SHOW_CARD
    importing
      value(IV_FORM) type FPNAME
      value(IS_DATA) type ANY .
  methods SHOW_CARD_GR
    importing
      value(IV_FORM) type FPNAME
      value(IS_DATA) type ANY
      value(IS_DATA_GR) type ANY .
  methods GET_ANLN_TEXT
    importing
      !IS_ANLN type ZAA_INVENTORY_CARD_ANLN
    returning
      value(RV_TEXT) type STRING .
  methods GET_ANLN_TEXT_XKAL
    importing
      !IS_ANLN type ZAA_INVENTORY_CARD_ANLN
    returning
      value(RV_TEXT) type STRING .
  methods GET_LIFETIME_TEXTS
    importing
      value(IS_FORM) type GTY_S_LIFETIME
      value(IV_LONG) type ABAP_BOOL default 'X'
      value(IV_CALC) type ABAP_BOOL default 'X'
    returning
      value(RS_TEXTS) type GTY_S_LIFETIME .
  methods GET_SET_FILTER
    importing
      value(IV_FIELDNAME) type FIELDNAME
      value(IT_SET) type RGSBV_TAB
    returning
      value(RV_FILTER) type STRING .
  methods GET_TVARV_FILTER
    importing
      value(IV_FIELDNAME) type FIELDNAME
      value(IV_NAME) type TVARV-NAME
    returning
      value(RV_FILTER) type STRING .
  methods READ_SET
    importing
      value(IV_NAME) type C
    returning
      value(RT_SET) type RGSBV_TAB .
  methods SHOW_WARNING
    importing
      value(IV_TYPE) type SY-MSGTY default 'I'
      value(IV_TEXT) type C
      value(IV_VAR1) type C optional
      value(IV_VAR2) type C optional
      value(IV_VAR3) type C optional
      value(IV_VAR4) type C optional
      value(IV_ASTYPE) type SY-MSGTY optional .
ENDCLASS.



CLASS ZAA_INVENTORY_CARD IMPLEMENTATION.


  METHOD f4_pernr.
    DATA: ls_shlp TYPE shlp_descr,
          lt_ret  TYPE STANDARD TABLE OF ddshretval.
    DATA: lv_pernr TYPE pernr_d.

    IF im_pernr IS NOT SUPPLIED.
      "Search-help для табельного номера (PREM)
      CALL FUNCTION 'F4IF_GET_SHLP_DESCR'
        EXPORTING
          shlpname = CONV shlpname( 'PREM' )
        IMPORTING
          shlp     = ls_shlp.

      TRY.
          ls_shlp-interface[ shlpfield = 'PERNR' ]-valfield = abap_true.
        CATCH cx_sy_itab_line_not_found.
          RETURN.
      ENDTRY.

      CALL FUNCTION 'F4IF_START_VALUE_REQUEST'
        EXPORTING
          shlp          = ls_shlp
        TABLES
          return_values = lt_ret[].

      IF lt_ret[] IS NOT INITIAL.
        lv_pernr = VALUE pernr_d( lt_ret[ 1 ]-fieldval ).
      ENDIF.
    ELSE.
      lv_pernr = im_pernr.
    ENDIF.

    TRY.
        zcl_names=>get_fio_formatted(
          EXPORTING
            iv_pernr = lv_pernr
          IMPORTING
            et_pernr = DATA(lt_fio) ).

        ASSIGN lt_fio[ 1 ] TO FIELD-SYMBOL(<ls_fio>).
        IF sy-subrc = 0.
          rv_pernr = <ls_fio>-pernr.
          cv_ename = |{ <ls_fio>-ename }, { <ls_fio>-ptext }|.
        ENDIF.

      CATCH cx_root.
    ENDTRY.
  ENDMETHOD.


  METHOD fill_sect2.
    DATA: lv_shifr TYPE fieldname VALUE 'SHIFR_'.
    FIELD-SYMBOLS: <fs_src> TYPE any.

    ASSIGN it_hist[ 1 ] TO FIELD-SYMBOL(<ls_hist_base>).
    IF sy-subrc <> 0.
      rt_sect2[] = it_sect2[].
      RETURN.
    ENDIF.

    SELECT domvalue_l, ddtext
      FROM dd07t
      INTO TABLE @DATA(lt_texts)
      WHERE domname     = 'ZDEPKEY'
        AND ddlanguage  = @sy-langu
        AND as4local    = 'A'.

    "Есть исторические данные
    DATA(lt_fcat) = CORRESPONDING lvc_t_fcat(
      cl_salv_data_descr=>read_structdescr(
        CAST cl_abap_structdescr( cl_abap_tabledescr=>describe_by_data( <ls_hist_base> ) ) ) ).

    "is_form частично заполнена
    "is_form-ondate - запрошенная дата, is_form-load_date - дата загрузки...
    "Идея - бежать по полю SHIFR_* и заполнить временную таблицу lt_sect:
    LOOP AT lt_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>) WHERE fieldname CP lv_shifr && '*'.
      DATA(lv_rest) = shift_left( val = <ls_fcat>-fieldname sub = lv_shifr ).

      APPEND INITIAL LINE TO rt_sect2[] ASSIGNING FIELD-SYMBOL(<ls_sect2>).
      <ls_sect2> = VALUE #(
        costre_ac   = SWITCH #( sy-tabix WHEN 1 THEN <ls_hist_base>-costre_ac ELSE '' )
        shifr_year  =
          COND #( WHEN lv_rest CO '0123456789'
            THEN lv_rest
            ELSE me->read_struct_field( iv_field = 'YEAR_' && lv_rest  is_struct = <ls_hist_base> ) )
        shifr       = me->read_struct_field( iv_field = <ls_fcat>-fieldname is_struct = <ls_hist_base> )
        shifr_norm  = me->read_struct_field( iv_field = 'SROK_' && lv_rest  is_struct = <ls_hist_base> )
        koef        = me->read_struct_field( iv_field = 'KOEF_' && lv_rest  is_struct = <ls_hist_base> iv_default = '0' )

        afasl       = me->read_struct_field( iv_field = 'DEPKEY_' && lv_rest  is_struct = <ls_hist_base> )
        afatxt      = |{ <ls_sect2>-afasl } - { VALUE #( lt_texts[ domvalue_l = <ls_sect2>-afasl ]-ddtext DEFAULT '' ) }|
        from_okof   = 'H' ).

      DATA(ls_norm) = me->get_lifetime_texts( is_form = VALUE gty_s_lifetime(
        hist_calc = abap_true
        nss_gjahr = <ls_hist_base>-ndjar
        nss_month = <ls_hist_base>-ndper
        spi_gjahr = trunc( me->read_struct_field( iv_field = 'SROK_' && lv_rest  is_struct = <ls_hist_base> ) )
        spi_month = frac( me->read_struct_field( iv_field = 'SROK_' && lv_rest  is_struct = <ls_hist_base> ) )
        rest_gjahr = me->read_struct_field( iv_field = 'OST_YEAR_' && lv_rest  is_struct = <ls_hist_base> iv_default = '0' )
        rest_month = me->read_struct_field( iv_field = 'OST_MONTH_' && lv_rest  is_struct = <ls_hist_base> iv_default = '0' )
        ) ).

      <ls_sect2> = VALUE #( BASE <ls_sect2>
        nss_text  = ls_norm-nss_text
        spi_text  = ls_norm-spi_text
        rest_text = ls_norm-rest_text
        fact_text = ls_norm-fact_text ).
    ENDLOOP.

    "Добавить те строки, у которых ZFI_SHIFR_VER-DATE_FROM > is_form-head-LOAD_DATE
    rt_sect2 = VALUE #( BASE rt_sect2
      FOR <ls_sect> IN it_sect2[]
      WHERE ( shifr_begda > is_form-head-load_date )
      ( CORRESPONDING #( <ls_sect> ) ) ).

  ENDMETHOD.


  METHOD get_anln_text.
    DATA: lv_tdname TYPE thead-tdname,
          lt_lines  TYPE STANDARD TABLE OF tline.

    CONCATENATE is_anln-bukrs is_anln-anln1 is_anln-anln2 INTO lv_tdname RESPECTING BLANKS.

    CALL FUNCTION 'READ_TEXT'
      EXPORTING
        id                      = 'XTCH'          "Технический ракурс вместо общего - 'XLTX' инц. ##17420, 17419
        language                = sy-langu
        name                    = lv_tdname
        object                  = 'ANLA'
      TABLES
        lines                   = lt_lines[]
      EXCEPTIONS
        id                      = 1
        language                = 2
        name                    = 3
        not_found               = 4
        object                  = 5
        reference_check         = 6
        wrong_access_to_archive = 7
        OTHERS                  = 8.

    IF sy-subrc = 0.
      rv_text = REDUCE #( INIT lv_line TYPE string
                FOR <ls_line> IN lt_lines[] INDEX INTO lv_idx
                NEXT lv_line = SWITCH #( lv_idx WHEN 1
                                  THEN <ls_line>-tdline
                                  ELSE |{ lv_line } { <ls_line>-tdline }| ) ).
      REPLACE ALL OCCURRENCES OF REGEX ',,' IN rv_text WITH space.
      REPLACE ALL OCCURRENCES OF '<(>,<)>'  IN rv_text WITH ','.
      REPLACE ALL OCCURRENCES OF '<(> ,<)>'  IN rv_text WITH ','.
    ENDIF.
  ENDMETHOD.


  METHOD GET_ANLN_TEXT_XKAL.
    DATA: lv_tdname TYPE thead-tdname,
          lt_lines  TYPE STANDARD TABLE OF tline.

    CONCATENATE is_anln-bukrs is_anln-anln1 is_anln-anln2 INTO lv_tdname RESPECTING BLANKS.

    CALL FUNCTION 'READ_TEXT'
      EXPORTING
        id                      = 'XKAL'
        language                = sy-langu
        name                    = lv_tdname
        object                  = 'ANLA'
      TABLES
        lines                   = lt_lines[]
      EXCEPTIONS
        id                      = 1
        language                = 2
        name                    = 3
        not_found               = 4
        object                  = 5
        reference_check         = 6
        wrong_access_to_archive = 7
        OTHERS                  = 8.

    IF sy-subrc = 0.
      rv_text = REDUCE #( INIT lv_line TYPE string
                FOR <ls_line> IN lt_lines[] INDEX INTO lv_idx
                NEXT lv_line = SWITCH #( lv_idx when 1
                                  THEN <ls_line>-tdline
                                  ELSE |{ lv_line } { <ls_line>-tdline }| ) ).
    ENDIF.

  ENDMETHOD.


  METHOD get_fixedasset.
    TRY.
        zaa_inventory_card_os_hdb=>read_form_data(
          EXPORTING
            iv_bukrs        = is_anln-bukrs
            iv_anln1        = is_anln-anln1
            iv_anln2        = is_anln-anln2
            iv_invnr        = is_anln-invnr
            iv_ondate       = is_anln-ondate
            iv_r4_filtr     = me->get_set_filter( iv_fieldname = 'BWASL' it_set = me->read_set( me->gc_r4_set ) )
            iv_r5_filtr     = me->get_set_filter( iv_fieldname = 'BWASL' it_set = me->read_set( me->gc_r5_set ) )
            iv_r6_filtr     = me->get_tvarv_filter( iv_fieldname = 'BWASL' iv_name = me->gc_r6_set )
            iv_r6_vvod_os   = me->get_tvarv_filter( iv_fieldname = 'BWASL' iv_name = me->gc_r6_vvod_set )
            iv_responsible  = me->gs_setup-responsible
            iv_precious     = me->gs_setup-precious
            iv_nonumb       = CONV #( TEXT-005 )
            iv_dmtext       = CONV #( TEXT-006 )
            iv_dktext       = CONV #( TEXT-007 )
            iv_no           = CONV #( TEXT-008 )
            iv_unit1        = CONV #( TEXT-009 )
            iv_unit2        = CONV #( TEXT-010 )

          IMPORTING
            et_head         = DATA(lt_head)
            et_sect1        = rs_form-sect1[]
            et_sect2        = DATA(lt_sect2)
            et_hist_base    = DATA(lt_hist_base)
            et_sect3        = rs_form-sect3[]
            et_sect4        = rs_form-sect4[]
            et_sect5        = rs_form-sect5[]
            et_sect7        = rs_form-sect7[]
            et_sect8        = DATA(lt_sect8)
            et_sect9        = rs_form-sect9[]
            et_participants = rs_form-participants[]
        ).
      CATCH  cx_root INTO DATA(lx_root).
        me->show_warning( iv_text = TEXT-e01 iv_astype = 'E' ).
        MESSAGE lx_root TYPE 'I'.
        IF lx_root->previous IS BOUND.
          MESSAGE lx_root->previous TYPE 'I'.
        ENDIF.
        IF lx_root->previous->previous IS BOUND.
          MESSAGE lx_root->previous->previous TYPE 'I'.
        ENDIF.
        RETURN.


    ENDTRY.
    LOOP AT rs_form-sect1 ASSIGNING FIELD-SYMBOL(<ls_rs_form>).
      IF <ls_rs_form>-blart_text IS INITIAL.
        <ls_rs_form>-blart_text = 'Акт приема-передачи'.
      ENDIF.
    ENDLOOP.
    SORT lt_sect2 BY shifr_year.

    TRY.
        rs_form = VALUE #( BASE rs_form
          anln = is_anln
          head  = CORRESPONDING #( lt_head[ 1 ] )
          sect2 = me->fill_sect2( is_form = rs_form it_sect2 = lt_sect2[] it_hist = lt_hist_base[] )
          details = get_anln_text( is_anln )
          details2 = get_anln_text_xkal( is_anln )
        ).
        CONDENSE rs_form-head-butxt.
      CATCH cx_sy_itab_line_not_found.
        me->show_warning( iv_text = TEXT-e02 ).
        RETURN.
    ENDTRY.

    rs_form-head-location = shift_left(
      val = shift_left( val = rs_form-head-location sub = `,` )
      sub = space ).

    DATA:
      BEGIN OF ls_names,
        ename TYPE char50,
        stell TYPE char40,
      END OF ls_names.

    CALL FUNCTION 'ZMM_CHIEF_OUT'
      EXPORTING
        iv_bukrs        = is_anln-bukrs
        iv_date         = rs_form-head-ondate
      IMPORTING
        ev_acc_s_fio    = ls_names-ename
        ev_acc_position = ls_names-stell
      EXCEPTIONS
        OTHERS          = 1.

    "--> #34838 H.Domanikova 15/12/2023 Изменение ФИО - инициалы ставим спереди
    IF ls_names-ename IS NOT INITIAL.
      DATA(lv_count) = strlen( ls_names-ename ).
      DATA(lv_str) = COND i( WHEN lv_count > 4 THEN lv_count - 4 ELSE 0 ).
      IF lv_str <> 0.
        ls_names-ename = |{ ls_names-ename+lv_str(4) } { ls_names-ename(lv_str) }|.
      ENDIF.
    ENDIF.
    "<-- #34838 H.Domanikova 15/12/2023

    rs_form-head = VALUE #( BASE rs_form-head
      accnt_ename = ls_names-ename
      accnt_stell = ls_names-stell ).

    TRY.
        rs_form-sect8 = lt_sect8[ 1 ].
      CATCH cx_sy_itab_line_not_found.
    ENDTRY.
  ENDMETHOD.


  METHOD get_intanasset.
    TRY.
        zaa_inventory_card_nma_hdb=>read_form_data(
          EXPORTING
            iv_bukrs        = is_anln-bukrs
            iv_anln1        = is_anln-anln1
            iv_anln2        = is_anln-anln2
            iv_invnr        = is_anln-invnr
            iv_ondate       = is_anln-ondate
            iv_r4_filtr     = me->get_set_filter( iv_fieldname = 'BWASL' it_set = me->read_set( me->gc_r4_set ) )
            iv_r5_filtr     = me->get_set_filter( iv_fieldname = 'BWASL' it_set = me->read_set( me->gc_r5_set ) )
            iv_responsible  = me->gs_setup-responsible
            iv_nonumb       = CONV #( TEXT-005 )
          IMPORTING
            et_head          = DATA(lt_head)
            et_sect1         = DATA(lt_sect1)
            et_sect2         = DATA(lt_sect2)
            et_sect3         = rs_form-sect3[]
            et_sect4         = rs_form-sect4[]
            et_sect5         = DATA(lt_sect5)
            et_pernr         = DATA(lt_pernr)
        ).
      CATCH  cx_root INTO DATA(lr_error).
        me->show_warning( iv_text = TEXT-e06 iv_astype = 'E' ).
        RETURN.
    ENDTRY.
    LOOP AT lt_head ASSIGNING FIELD-SYMBOL(<ls_head>).
      IF <ls_head>-BLART_TEXT IS INITIAL.
         <ls_head>-BLART_TEXT = 'Акт'.
      endif.
    endloop.
     LOOP AT rs_form-sect3[] ASSIGNING FIELD-SYMBOL(<ls_sect3>).
      TRY.
          zaa_inventory_card_nma_hdb=>read_spi(
            EXPORTING
              iv_bukrs        = is_anln-bukrs
              iv_anln1        = is_anln-anln1
              iv_anln2        = is_anln-anln2
              iv_ondate       = <ls_sect3>-docdate
            IMPORTING
              et_spi          = DATA(lt_spi) ).

          <ls_sect3> = VALUE #( BASE <ls_sect3>
            rest_gjahr = VALUE #( lt_spi[ 1 ]-restj DEFAULT 0 )
            rest_month = VALUE #( lt_spi[ 1 ]-restp DEFAULT 0 )
            ).

        CATCH cx_sy_itab_line_not_found.
          me->show_warning( iv_text = TEXT-e02 ).

        CATCH  cx_root.
          me->show_warning( iv_text = TEXT-e08 iv_astype = 'E' ).
      ENDTRY.
    ENDLOOP.

    LOOP AT rs_form-sect4[] ASSIGNING FIELD-SYMBOL(<ls_sect4>).
      TRY.
          zaa_inventory_card_nma_hdb=>read_spi(
            EXPORTING
              iv_bukrs        = is_anln-bukrs
              iv_anln1        = is_anln-anln1
              iv_anln2        = is_anln-anln2
              iv_ondate       = <ls_sect4>-docdate
            IMPORTING
              et_spi          = lt_spi[] ).

          <ls_sect4> = VALUE #( BASE <ls_sect4>
            rest_gjahr = VALUE #( lt_spi[ 1 ]-restj DEFAULT 0 )
            rest_month = VALUE #( lt_spi[ 1 ]-restp DEFAULT 0 )
            ).

        CATCH cx_sy_itab_line_not_found.
          me->show_warning( iv_text = TEXT-e02 ).

        CATCH  cx_root.
          me->show_warning( iv_text = TEXT-e08 iv_astype = 'E' ).
      ENDTRY.
    ENDLOOP.

    TRY.
        rs_form = VALUE #( BASE rs_form
          anln          = is_anln
          head          = lt_head[ 1 ]
          sect1         = lt_sect1[ 1 ]
          sect2         = lt_sect2[ 1 ]
          details       = get_anln_text( is_anln )
          resp          = VALUE #(
                            key   = VALUE #( lt_pernr[ 1 ]-ename DEFAULT '' )
                            value = VALUE #( lt_pernr[ 1 ]-plong DEFAULT '' ) )
          denominations = VALUE #(
                            FOR <ls_den> IN gt_denominations[]
                            WHERE ( key > is_anln-aktiv )
                            ( <ls_den> ) )
        ).
        CONDENSE rs_form-head-butxt.
      CATCH cx_sy_itab_line_not_found.
        me->show_warning( iv_text = TEXT-e02 ).
        RETURN.
    ENDTRY.

    TRY.
        rs_form-sect5 = lt_sect5[ 1 ].
      CATCH cx_sy_itab_line_not_found.
    ENDTRY.
  ENDMETHOD.


  METHOD get_lifetime_texts.
    DATA: lv_years TYPE p,
          lv_month TYPE p.

    rs_texts = VALUE #( BASE is_form
       nss_text = |{ is_form-nss_gjahr }.{ is_form-nss_month }|
       spi_text = |{ is_form-spi_gjahr }.{ is_form-spi_month }| ).

    IF iv_calc = abap_false.
      " Без подсчёта (#13644 - из ракурса ZAA_ASSET_SPI)
      rs_texts = VALUE #( BASE rs_texts
        fact_text = |{ is_form-used_gjahr }.{ is_form-used_month }|
        rest_text = |{ is_form-rest_gjahr }.{ is_form-rest_month }| ).
    ELSE.

      CALL FUNCTION 'HR_GET_TIME_BETWEEN_DATES'
        EXPORTING
          beg_date       = is_form-begda
          end_date       = is_form-endda
        IMPORTING
          months         = lv_month
          years          = lv_years
        EXCEPTIONS
          invalid_period = 1
          OTHERS         = 2.
      IF sy-subrc = 0.
        rs_texts-fact_text = |{ lv_years }.{ lv_month }|.
      ENDIF.

      " Подсчет СПИ(мес.) - Факт(мес.) = Оставшийся СИ(мес.) -> Ост.СИ(ггг.мм)
      " При отсутствии данных СПИ берем НСС за нормативный срок
      DATA(lv_fact) = lv_years * 12 + lv_month.
      IF is_form-spi_gjahr <> 0 OR is_form-spi_month <> 0.
        DATA(lv_norm) = is_form-spi_gjahr * 12 +  is_form-spi_month.
      ELSE.
        lv_norm = is_form-nss_gjahr * 12 +  is_form-nss_month.
      ENDIF.

      IF is_form-hist_calc <> abap_true.
        DATA(lv_rest) = lv_norm - lv_fact.
      ELSE.
        lv_rest = is_form-rest_gjahr * 12 + is_form-rest_month.
        lv_fact = lv_norm - lv_rest.

        lv_years = trunc( lv_fact / 12 ).
        lv_years = lv_fact - ( lv_years * 12 ).
        rs_texts-fact_text = |{ lv_years }.{ lv_month }|.
      ENDIF.

      lv_years = trunc( lv_rest / 12 ).
      lv_month = lv_rest - ( lv_years * 12 ).

      rs_texts-rest_text = SWITCH #( iv_long
        WHEN abap_true THEN |{ abs( lv_years ) }{ TEXT-001 } { abs( lv_month ) }{ TEXT-002 }|
        ELSE |{ abs( lv_years ) }.{ abs( lv_month ) }| ).

      rs_texts-rest_text = |{ abs( lv_years ) }.{ abs( lv_month ) }|.

      IF lv_rest < 0 .
        rs_texts-rest_text = '-' && rs_texts-rest_text.
      ENDIF.

    ENDIF.

    rs_texts = VALUE #( BASE rs_texts
      nss_text = me->lifetime_to_verb( rs_texts-nss_text )
      spi_text = me->lifetime_to_verb( rs_texts-spi_text )
      fact_text = me->lifetime_to_verb( rs_texts-fact_text )
      rest_text = me->lifetime_to_verb( rs_texts-rest_text ) ).
  ENDMETHOD.


  METHOD get_monam.
    SELECT SINGLE monam
      FROM t015m
      INTO rv_monam
      WHERE spras = sy-langu
        AND monum = iv_ondate+4(2).

    TRANSLATE rv_monam TO LOWER CASE.
  ENDMETHOD.


  METHOD get_set_filter.
    DATA: lt_data TYPE RANGE OF rgsbv-from.

    lt_data[] = VALUE #(
      FOR <ls_set> IN it_set[]
      ( sign = 'I' option = 'BT' low = <ls_set>-from high = <ls_set>-to ) ).

    rv_filter = cl_shdb_seltab=>combine_seltabs(
      it_named_seltabs = VALUE #(
        ( name = iv_fieldname dref = REF #( lt_data[] ) ) ) ).

  ENDMETHOD.


  METHOD get_tvarv_filter.
    DATA: lt_data TYPE RANGE OF rgsbv-from.

    SELECT sign, opti AS option, low, high
      FROM tvarvc
      INTO TABLE @DATA(lt_moves)
      WHERE name = @iv_name.

    rv_filter = cl_shdb_seltab=>combine_seltabs(
      it_named_seltabs = VALUE #(
        ( name = iv_fieldname dref = REF #( lt_moves[] ) ) ) ).

  ENDMETHOD.


  METHOD lifetime_to_verb.
    IF iv_text = '0' OR iv_text = ''.
      rv_text = ''.
    ELSE.
      "XXX лет YY мес
      "rv_text = replace( val = iv_text sub = '.' with = ` ` && text-001 && ` ` ) && ` ` && text-002.

      "XXXл. YYм.
      rv_text = replace( val = iv_text sub = '.' with = TEXT-003 && ` ` ) && TEXT-004.
    ENDIF.
  ENDMETHOD.


  METHOD read_set.
    DATA: lv_setid TYPE sethier-setid.

    CALL FUNCTION 'G_SET_GET_ID_FROM_NAME'
      EXPORTING
        shortname                = iv_name
      IMPORTING
        new_setid                = lv_setid
      EXCEPTIONS
        no_set_found             = 1
        no_set_picked_from_popup = 2
        wrong_class              = 3
        wrong_subclass           = 4
        table_field_not_found    = 5
        fields_dont_match        = 6
        set_is_empty             = 7
        formula_in_set           = 8
        set_is_dynamic           = 9
        OTHERS                   = 10.

    IF sy-subrc <> 0.
      show_warning( iv_text = TEXT-e03 iv_var1 = iv_name iv_astype = 'E' ).
      RETURN.
    ENDIF.

    CALL FUNCTION 'G_SET_FETCH'
      EXPORTING
        setnr           = lv_setid
      TABLES
        set_lines_basic = rt_set[]
      EXCEPTIONS
        no_authority    = 1
        set_is_broken   = 2
        set_not_found   = 3
        OTHERS          = 4.
    IF sy-subrc <> 0.
      show_warning( iv_text = TEXT-e04 iv_var1 = iv_name iv_astype = 'E' ).
      RETURN.
    ENDIF.

  ENDMETHOD.


  METHOD read_struct_field.
    ASSIGN COMPONENT iv_field OF STRUCTURE is_struct TO FIELD-SYMBOL(<fs_dst>).
    IF sy-subrc = 0.
      rv_value = <fs_dst>.
    ELSE.
      rv_value = iv_default.
    ENDIF.
  ENDMETHOD.


  METHOD set_nma_texts.
    rs_form = is_form.

    rs_form-sect2 = VALUE #( BASE rs_form-sect2
      monam = |{ get_monam( is_form-anln-ondate ) } { rs_form-sect2-monam }|
      nss_text  = me->lifetime_to_verb( rs_form-sect2-spi_text )
      spi_text  = me->lifetime_to_verb( rs_form-sect2-spi_text )
      fact_text = me->lifetime_to_verb( rs_form-sect2-fact_text )
      rest_text = me->lifetime_to_verb( rs_form-sect2-rest_text ) ).

    LOOP AT rs_form-sect3[] ASSIGNING FIELD-SYMBOL(<ls_sect3>).
      <ls_sect3>-rest_text = me->get_lifetime_texts(
        iv_calc = abap_false
        is_form =
          VALUE gty_s_lifetime(
            begda     = rs_form-head-actdate
            endda     = <ls_sect3>-docdate
            rest_gjahr = <ls_sect3>-rest_gjahr
            rest_month = <ls_sect3>-rest_month
        ) )-rest_text.
    ENDLOOP.

    LOOP AT rs_form-sect4 ASSIGNING FIELD-SYMBOL(<ls_sect4>).
      <ls_sect4>-rest_text = me->get_lifetime_texts(
        iv_calc = abap_false
        is_form =
          VALUE gty_s_lifetime(
            begda     = rs_form-head-actdate
            endda     = <ls_sect4>-docdate
            rest_gjahr = <ls_sect4>-rest_gjahr
            rest_month = <ls_sect4>-rest_month
             ) )-rest_text.
    ENDLOOP.

  ENDMETHOD.


  METHOD set_os_texts.
    DATA: ls_lifetime     TYPE gty_s_lifetime,
          ls_lifetimeempt TYPE gty_s_lifetime.

    rs_form = is_form.

    ls_lifetime = me->get_lifetime_texts(
      iv_calc   = abap_false
      iv_long   = abap_true
      is_form = VALUE gty_s_lifetime(
        begda     = rs_form-head-aktiv
        endda     = SWITCH #( rs_form-head-deakt
                      WHEN '00000000' THEN rs_form-head-ondate
                      ELSE rs_form-head-deakt ) ) ).

    LOOP AT rs_form-sect1[] ASSIGNING FIELD-SYMBOL(<ls_sect1>).
      <ls_sect1> = VALUE #( BASE <ls_sect1>
        nss_text  = me->lifetime_to_verb( <ls_sect1>-nss_text )
        spi_text  = me->lifetime_to_verb( <ls_sect1>-spi_text )
        fact_text = me->lifetime_to_verb( <ls_sect1>-fact_text )
        rest_text = me->lifetime_to_verb( <ls_sect1>-rest_text ) ).
    ENDLOOP.

    LOOP AT rs_form-sect2[] ASSIGNING FIELD-SYMBOL(<ls_sect2>).
      <ls_sect2> =  VALUE #( BASE <ls_sect2>
        nss_text  = me->lifetime_to_verb( <ls_sect2>-nss_text )
        spi_text  = me->lifetime_to_verb( <ls_sect2>-spi_text )
        fact_text = me->lifetime_to_verb( <ls_sect2>-fact_text )
        rest_text = me->lifetime_to_verb( <ls_sect2>-rest_text ) ).
    ENDLOOP.

    LOOP AT rs_form-sect3[] ASSIGNING FIELD-SYMBOL(<ls_sect3>) WHERE occ_rest IS NOT INITIAL.
      <ls_sect3>-occ_rest = me->lifetime_to_verb( <ls_sect3>-occ_rest ).
    ENDLOOP.

    LOOP AT rs_form-sect5[] ASSIGNING FIELD-SYMBOL(<ls_sect5>).
      IF <ls_sect5>-history = abap_true.
        <ls_sect5>-rest_text = me->lifetime_to_verb( <ls_sect5>-rest_text ).
      ELSE.
        ls_lifetime = me->get_lifetime_texts(
          is_form = VALUE gty_s_lifetime(
            begda     = rs_form-sect1[ 1 ]-utvdate
            endda     = <ls_sect5>-docdate
            nss_gjahr = 0
            nss_month = 0
            spi_gjahr = <ls_sect5>-ndjar
            spi_month = <ls_sect5>-ndper
        ) ).

        <ls_sect5> = VALUE #( BASE <ls_sect5>
          nss_text = ls_lifetime-nss_text
          spi_text = ls_lifetime-spi_text
          fact_text = ls_lifetime-fact_text ).
      ENDIF.
    ENDLOOP.

    LOOP AT rs_form-sect9[] ASSIGNING FIELD-SYMBOL(<ls_sect9>) FROM 2.
      CLEAR: <ls_sect9>-anla_text, <ls_sect9>-menge.
    ENDLOOP.
  ENDMETHOD.


  METHOD show_card.
    DATA: lv_function   TYPE funcname,
          lv_error      TYPE string,
          ls_pri_params TYPE pri_params,
          ls_formoutput TYPE fpformoutput,
          ls_joboutput  TYPE sfpjoboutput.

    CALL FUNCTION 'GET_PRINT_PARAMETERS'
      EXPORTING
        no_dialog      = 'X'
        mode           = 'CURRENT'
      IMPORTING
        out_parameters = ls_pri_params.

    DATA(ls_outparams) = VALUE sfpoutputparams(
      copies    = ls_pri_params-prcop
      dest      = ls_pri_params-pdest
      reqnew    = ls_pri_params-prnew
      reqimm    = ls_pri_params-primm
      reqdel    = ls_pri_params-prrel
      lifetime  = ls_pri_params-pexpi
      title     = ls_pri_params-prtxt
      cover     = ls_pri_params-prsap
      covtitle  = ls_pri_params-prtxt
      receiver  = ls_pri_params-prrec
      division  = ls_pri_params-prabt
      authority = ls_pri_params-prber
      preview   = abap_true
    ).

    DATA(ls_docparams) = VALUE sfpdocparams(
      country   = SWITCH #( sy-langu WHEN 'R' THEN 'RU' )
      langu     = sy-langu
      fillable  = abap_true
      dynamic   = abap_true
    ).

    TRY.
        CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'
          EXPORTING
            i_name     = iv_form
          IMPORTING
            e_funcname = lv_function.
      CATCH cx_fp_api_repository
            cx_fp_api_internal
            cx_fp_api_usage
            cx_root.
        EXIT.
    ENDTRY.

    CALL FUNCTION 'FP_JOB_OPEN'
      CHANGING
        ie_outputparams = ls_outparams
      EXCEPTIONS
        cancel          = 1
        usage_error     = 2
        system_error    = 3
        internal_error  = 4
        OTHERS          = 5.
    IF sy-subrc <> 0.
      EXIT.
    ENDIF.

    CALL FUNCTION lv_function
      EXPORTING
        /1bcdwb/docparams  = ls_docparams
        h_form             = is_data
      IMPORTING
        /1bcdwb/formoutput = ls_formoutput
      EXCEPTIONS
        usage_error        = 1
        system_error       = 2
        internal_error     = 3
        OTHERS             = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

      CALL FUNCTION 'FP_GET_LAST_ADS_ERRSTR'
        IMPORTING
          e_adserrstr = lv_error.

    ENDIF.

    CALL FUNCTION 'FP_JOB_CLOSE'
      IMPORTING
        e_result       = ls_joboutput
      EXCEPTIONS
        usage_error    = 1
        system_error   = 2
        internal_error = 3
        OTHERS         = 4.
  ENDMETHOD.


  METHOD SHOW_CARD_GR.
    DATA: lv_function   TYPE funcname,
          lv_error      TYPE string,
          ls_pri_params TYPE pri_params,
          ls_formoutput TYPE fpformoutput,
          ls_joboutput  TYPE sfpjoboutput.

    CALL FUNCTION 'GET_PRINT_PARAMETERS'
      EXPORTING
        no_dialog      = 'X'
        mode           = 'CURRENT'
      IMPORTING
        out_parameters = ls_pri_params.

    DATA(ls_outparams) = VALUE sfpoutputparams(
      copies    = ls_pri_params-prcop
      dest      = ls_pri_params-pdest
      reqnew    = ls_pri_params-prnew
      reqimm    = ls_pri_params-primm
      reqdel    = ls_pri_params-prrel
      lifetime  = ls_pri_params-pexpi
      title     = ls_pri_params-prtxt
      cover     = ls_pri_params-prsap
      covtitle  = ls_pri_params-prtxt
      receiver  = ls_pri_params-prrec
      division  = ls_pri_params-prabt
      authority = ls_pri_params-prber
      preview   = abap_true
    ).

    DATA(ls_docparams) = VALUE sfpdocparams(
      country   = SWITCH #( sy-langu WHEN 'R' THEN 'RU' )
      langu     = sy-langu
      fillable  = abap_true
      dynamic   = abap_true
    ).

    TRY.
        CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'
          EXPORTING
            i_name     = iv_form
          IMPORTING
            e_funcname = lv_function.
      CATCH cx_fp_api_repository
            cx_fp_api_internal
            cx_fp_api_usage
            cx_root.
        EXIT.
    ENDTRY.

    CALL FUNCTION 'FP_JOB_OPEN'
      CHANGING
        ie_outputparams = ls_outparams
      EXCEPTIONS
        cancel          = 1
        usage_error     = 2
        system_error    = 3
        internal_error  = 4
        OTHERS          = 5.
    IF sy-subrc <> 0.
      EXIT.
    ENDIF.

    CALL FUNCTION lv_function
      EXPORTING
        /1bcdwb/docparams  = ls_docparams
        h_form             = is_data
        h_form_gr          = is_data_gr
      IMPORTING
        /1bcdwb/formoutput = ls_formoutput
      EXCEPTIONS
        usage_error        = 1
        system_error       = 2
        internal_error     = 3
        OTHERS             = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

      CALL FUNCTION 'FP_GET_LAST_ADS_ERRSTR'
        IMPORTING
          e_adserrstr = lv_error.

    ENDIF.

    CALL FUNCTION 'FP_JOB_CLOSE'
      IMPORTING
        e_result       = ls_joboutput
      EXCEPTIONS
        usage_error    = 1
        system_error   = 2
        internal_error = 3
        OTHERS         = 4.
  ENDMETHOD.


  METHOD show_inventory_card.
    gs_anln-ondate = iv_ondate.

    IF gs_anln-ondate < gs_anln-zugdt.
      me->show_warning( iv_text = TEXT-e07 iv_var1 = gs_anln-anln1 iv_var2 = gs_anln-anln2
        iv_var3 = |{ gs_anln-ondate DATE = ENVIRONMENT }|
        iv_astype = 'E' ).
      rv_result = 'I'.
      RETURN.
    ELSEIF gs_anln-deakt IS NOT INITIAL AND gs_anln-ondate > gs_anln-deakt.
      me->show_warning( iv_text = TEXT-e09
        iv_var1 = gs_anln-bukrs iv_var2 = gs_anln-anln1 iv_var3 = gs_anln-anln2
        iv_var4 = |{ gs_anln-deakt DATE = ENVIRONMENT }|
        iv_astype = 'E' ).
      rv_result = 'I'.
      RETURN.
    ENDIF.

    CASE iv_type.
      WHEN '1'.
        me->show_card(
          iv_form = 'ZAA_INVENTORY_CARD_OS'
          is_data = me->set_os_texts( me->get_fixedasset( is_anln = gs_anln ) ) ).
      WHEN '2'.
        me->show_card(
          iv_form = 'ZAA_INVENTORY_CARD_NMA'
          is_data = set_nma_texts( get_intanasset( is_anln = gs_anln ) ) ).
    ENDCASE.
  ENDMETHOD.


  METHOD show_inventory_card_gr.

    DATA: lv_resp    TYPE pa0002-pernr,
          lv_resptx  TYPE string,
          lv_prec    TYPE pa0002-pernr,
          lv_prectx  TYPE string,
          lv_os_type TYPE j_3rfanka-anka_type.

    DATA: lt_form    TYPE STANDARD TABLE OF zaa_inventory_card_os,
          ls_form    TYPE zaa_inventory_card_os,
          ls_form_gr TYPE zaa_inventory_card_os_gr.

    LOOP AT it_oss ASSIGNING FIELD-SYMBOL(<fs_oss>).
      me->start_of_selection(
        EXPORTING
          iv_bukrs    = <fs_oss>-bukrs
          iv_anln1    = <fs_oss>-anln1
          iv_anln2    = <fs_oss>-anln2
        CHANGING
          cv_resp     = lv_resp
          cv_resptx   = lv_resptx
          cv_prec     = lv_prec
          cv_prectx   = lv_prectx
        RECEIVING
          rv_class = lv_os_type
        EXCEPTIONS
          os_read_error  = 1 ).
      IF sy-subrc NE 0.
        MESSAGE e103(zaa) WITH <fs_oss>-bukrs <fs_oss>-anln1 <fs_oss>-anln2.
        RETURN.
      ENDIF.
      gs_anln-ondate = iv_ondate.
      IF gs_anln-ondate < gs_anln-zugdt.
        me->show_warning( iv_text = TEXT-e07 iv_var1 = gs_anln-anln1 iv_var2 = gs_anln-anln2
          iv_var3 = |{ gs_anln-ondate DATE = ENVIRONMENT }|
          iv_astype = 'E' ).
        RETURN.
      ELSEIF gs_anln-deakt IS NOT INITIAL AND gs_anln-ondate > gs_anln-deakt.
        me->show_warning( iv_text = TEXT-e09
          iv_var1 = gs_anln-bukrs iv_var2 = gs_anln-anln1 iv_var3 = gs_anln-anln2
          iv_var4 = |{ gs_anln-deakt DATE = ENVIRONMENT }|
          iv_astype = 'E' ).
        RETURN.
      ENDIF.

      lv_resp = me->gs_setup-responsible = me->f4_pernr(
        EXPORTING
          im_pernr = iv_respons
        CHANGING
          cv_ename = lv_resptx ).
      SUPPRESS DIALOG.

      lv_prec = me->gs_setup-precious = me->f4_pernr(
        EXPORTING
          im_pernr = iv_precious
        CHANGING
          cv_ename = lv_prectx ).

      ls_form = me->set_os_texts( me->get_fixedasset( is_anln = gs_anln ) ) .
      APPEND ls_form TO lt_form.
    ENDLOOP.

    DATA: lv_invno1 TYPE invnr_anla,
          lv_invno2 TYPE invnr_anla,
          lv_index1 TYPE numc2,
          lv_index2 TYPE numc2,
          lv_tabix  TYPE sy-tabix,
          lv_tabix2 TYPE sy-tabix.

    DATA: lt_sect1 TYPE STANDARD TABLE OF zaa_inventory_card_sect1_lngr,
          lt_tabw  TYPE STANDARD TABLE OF tabw.

    SELECT * FROM tabw INTO TABLE lt_tabw.

    SORT lt_form BY head-actno.
    READ TABLE lt_form ASSIGNING FIELD-SYMBOL(<fs_form>) INDEX 1.
    lv_invno1 = <fs_form>-head-actno.

    CLEAR lv_index1.
    LOOP AT lt_form ASSIGNING <fs_form>.
      CLEAR: lv_tabix, lv_tabix2.
      ADD 1 TO lv_index1.
      "Драгоценные металлы
      LOOP AT <fs_form>-sect9 ASSIGNING FIELD-SYMBOL(<fs_sect9>).
        APPEND INITIAL LINE TO ls_form_gr-sect9 ASSIGNING FIELD-SYMBOL(<fs_sect9_gr>).
        MOVE-CORRESPONDING <fs_sect9> TO <fs_sect9_gr>.
        <fs_sect9_gr>-actno = <fs_form>-head-actno.
      ENDLOOP.
      "Перенабивка позиций
      LOOP AT <fs_form>-sect1 ASSIGNING FIELD-SYMBOL(<fs_sect1>).
        APPEND INITIAL LINE TO lt_sect1 ASSIGNING FIELD-SYMBOL(<fs_sect1_lt1>).
        IF lv_tabix IS INITIAL. lv_tabix = sy-tabix. ENDIF.
        lv_tabix2 = sy-tabix.
        MOVE-CORRESPONDING <fs_sect1> TO <fs_sect1_lt1>.
        <fs_sect1_lt1>-actno = <fs_form>-head-actno.
        <fs_sect1_lt1>-zafull = <fs_form>-head-zafull.
        <fs_sect1_lt1>-pos_no = lv_index1.
        CONCATENATE <fs_sect1_lt1>-blart_text <fs_sect1_lt1>-utvdate <fs_sect1_lt1>-aktnum
        INTO <fs_sect1_lt1>-doc_vvoda SEPARATED BY space.
        "Переоценка
        CLEAR lv_index2.
        LOOP AT <fs_form>-sect3 ASSIGNING FIELD-SYMBOL(<fs_sect3>).
          ADD 1 TO lv_index2.
          IF lv_index2 > 1.
            APPEND INITIAL LINE TO lt_sect1 ASSIGNING <fs_sect1_lt1>.
            <fs_sect1_lt1>-pos_no = lv_index1.
            lv_tabix2 = sy-tabix.
          ENDIF.
          MOVE-CORRESPONDING  <fs_sect3> TO <fs_sect1_lt1>-pereocenka.
        ENDLOOP.
        "Выбытия
        LOOP AT <fs_form>-sect4 ASSIGNING FIELD-SYMBOL(<fs_sect4>).
          READ TABLE lt_tabw ASSIGNING FIELD-SYMBOL(<fs_tabw>)
           WITH KEY bwasl = <fs_sect4>-bwasl.
          IF sy-subrc = 0.
            IF <fs_tabw>-xdeakt = 'X'.
              READ TABLE  lt_sect1 ASSIGNING FIELD-SYMBOL(<fs_sect1_lt2>) INDEX lv_tabix.
              IF sy-subrc = 0.
                MOVE-CORRESPONDING <fs_sect4> TO <fs_sect1_lt2>-moves.
                ADD 1 TO lv_tabix.
              ELSE.
                APPEND INITIAL LINE TO lt_sect1 ASSIGNING <fs_sect1_lt1>.
                <fs_sect1_lt1>-pos_no = lv_index1.
                lv_tabix = sy-tabix.
*                MOVE-CORRESPONDING <fs_sect1_lt2> TO <fs_sect1_lt1>.
                MOVE-CORRESPONDING <fs_sect4> TO <fs_sect1_lt1>-moves.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDLOOP.
*        LOOP AT <fs_form>-sect3 ASSIGNING FIELD-SYMBOL(<fs_sect3>).
*          APPEND INITIAL LINE TO <fs_sect1_gr>-pereocenka_tab ASSIGNING FIELD-SYMBOL(<fs_pereocenka>).
*          MOVE-CORRESPONDING <fs_sect3> TO <fs_pereocenka>.
*        ENDLOOP.
      ENDLOOP.
      ls_form_gr-head-lgort = iv_lgort.
      ls_form_gr-head-name_lgort = iv_name_lgort.
      ls_form_gr-head-raumn = <fs_form>-head-raumn.
    ENDLOOP.
    IF NOT lines( lt_sect1 ) = 0.
      REFRESH ls_form_gr-sect1.
      APPEND LINES OF lt_sect1 TO ls_form_gr-sect1.
      REFRESH lt_sect1.
    ENDIF.
    lv_invno2 = <fs_form>-head-actno.
    CONCATENATE lv_invno1 lv_invno2 INTO ls_form_gr-head-actno_gr SEPARATED BY '/'.
*    me->show_card(
*      iv_form = 'ZAA_GROUP_INVENTORY_CARD_OS'
*      is_data = lt_form ).


    me->show_card_gr(
      iv_form = 'ZAA_INVENTORY_CARD_OS_GR'
      is_data = ls_form
      is_data_gr = ls_form_gr ).

  ENDMETHOD.


  METHOD show_warning.
    DATA: lv_message TYPE string.

    lv_message = iv_text.

    lv_message = replace( val =
      replace( val =
        replace( val =
          replace( val = lv_message sub = '&' with = iv_var1 occ = 1 )
        sub = '&' with = iv_var2 occ = 1 )
      sub = '&' with = iv_var3 occ = 1 )
    sub = '&' with = iv_var4 occ = 1 ).

    IF iv_astype IS SUPPLIED.
      MESSAGE lv_message TYPE iv_type DISPLAY LIKE iv_astype.
    ELSE.
      MESSAGE lv_message TYPE iv_type.
    ENDIF.

  ENDMETHOD.


  METHOD start_of_selection.
    DATA(lt_class) = VALUE wdy_key_value_list(
      ( key = 'FIXEDASSET' value = '1' )
      ( key = 'INTANASSET' value = '2' )
      ( key = '' value = '' ) ).

    "Заполнены данные по деноминациям
    gt_denominations[] = VALUE #(
      ( key = '19940801' value = TEXT-d01 )
      ( key = '19990101' value = TEXT-d02 )
      ( key = '20160701' value = TEXT-d03 ) ).

    "Табельный № ответственного по драг.металлам - ??
    TRY.
        zaa_inventory_card_os_hdb=>read_anln_data(
          EXPORTING
            iv_bukrs      = iv_bukrs
            iv_anln1      = iv_anln1
            iv_anln2      = CONV anln2( CONV numc4( iv_anln2 ) )
            iv_user       = sy-uname
            iv_dm_pernr   = '0'
            iv_typeflt    = ''
          IMPORTING
            et_anln      = DATA(lt_anln)
            et_resp      = DATA(lt_resp) ).   "1 строка - ответственный за форму, 2 - за драг. металлы.
      CATCH  cx_root.
        me->show_warning( iv_text = TEXT-e00 iv_astype = 'E' ).
        RETURN.
    ENDTRY.

    TRY.
        gs_anln  = lt_anln[ 1 ].
        rv_class = lt_class[ key = gs_anln-antyp ]-value.
        DATA(ls_formresp) = lt_resp[ 1 ].
        DATA(ls_dmresp)   = lt_resp[ 2 ].

        cv_resp   = me->gs_setup-responsible = ls_formresp-pernr.
        cv_resptx = SWITCH #( ls_formresp-pernr
                      WHEN '' THEN ''
                      ELSE |{ ls_formresp-ename }, { ls_formresp-plong }| ).
        cv_prec   = me->gs_setup-precious = ls_dmresp-pernr.
        cv_prectx = SWITCH #( ls_dmresp-pernr
                      WHEN '' THEN ''
                      ELSE |{ ls_dmresp-ename }, { ls_dmresp-plong }| ).
      CATCH cx_sy_itab_line_not_found.
        me->show_warning( iv_text = TEXT-e02 iv_astype = 'E' iv_var1 = iv_anln1 iv_var2 = iv_anln2 iv_var3 = iv_bukrs ).
        RAISE os_read_error.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.