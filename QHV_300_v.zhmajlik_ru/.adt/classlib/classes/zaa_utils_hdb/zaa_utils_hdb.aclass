CLASS zaa_utils_hdb DEFINITION
  PUBLIC FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES if_amdp_marker_hdb.

    TYPES: BEGIN OF gty_s_spi,
             budat TYPE bkpf-budat,
             bukrs TYPE bukrs,      " БЕ
             anln1 TYPE anln1,      " СИСТЕМНЫЙ НОМЕР ОСА
             anln2 TYPE anln2,      " СУБНОМЕР ОС
             afabe TYPE afabe_d,    " ОБЛАСТЬ ОЦЕНКИ
             afabg TYPE afabg,
             afasl TYPE afasl,
             ndper TYPE ndper,
             ndjar TYPE ndjar,
             usep  TYPE ndabp,      " ИСТЕКШИЙ СРОК СЛУЖБЫ В МЕСЯЦАХ
             usej  TYPE ndabj,      " ИСТЕКШИЙ СРОК СЛУЖБЫ В ГОДАХ
             restp TYPE ndabp,      " ОСТАВШИЙСЯ СРОК СЛУЖБЫ В МЕСЯЦАХ
             restj TYPE ndabj,      " ОСТАВШИЙСЯ СРОК СЛУЖБЫ В ГОДАХ
           END OF gty_s_spi,
           gty_t_spi TYPE STANDARD TABLE OF gty_s_spi.
    TYPES: BEGIN OF gty_s_avals,
             client TYPE mandt,
             bukrs  TYPE bukrs,   " БЕ
             anln1  TYPE anln1,   " Системный номер ОСА
             anln2  TYPE anln2,   " Субномер ОС
             afabe  TYPE afabe_d, " Область оценки
             kansw  TYPE kansw,   " ПС на начало года и все изменения ПС (поступления, выбытия, переоценка) за текущий год до даты отчета
             kaufw  TYPE kaufw,   " Повышение восстановительной стоимости
             knafa  TYPE knafa,   " Накопленная амортизация типовая
             kaafa  TYPE kaafa,   " Внеплановая амортизация
             kaufn  TYPE kaufn,   " Коррект. амортизации
             netvl  TYPE vtcur12, " Остаточная стоимость
           END OF gty_s_avals,
           gty_t_avals TYPE STANDARD TABLE OF gty_s_avals WITH EMPTY KEY.
    TYPES: BEGIN OF gty_s_asset,
             bukrs  TYPE anla-bukrs,
             anln1  TYPE anla-anln1,
             anln2  TYPE anla-anln2,
             mv_val TYPE anlc-kansw,   " значение в проводке
             storn  TYPE abap_bool,
             bwasl  TYPE anep-bwasl,
             gitcol TYPE tabwg-gitcol,
             invnr  TYPE anla-invnr,
             aa_val TYPE anlc-kansw,   " стоимость ОС
             pbukr  TYPE anla-bukrs,
             panl1  TYPE anla-anln1,
             panl2  TYPE anla-anln2,
             sgtxt  TYPE bseg-sgtxt,
             xinvm  TYPE anla-xinvm,   " инвестиционное ОС
             pxinv  TYPE anla-xinvm,   " партнер - инвестиционное ОС
           END OF gty_s_asset,
           gty_t_asset TYPE HASHED TABLE OF gty_s_asset WITH UNIQUE KEY bukrs anln1 anln2.
    TYPES: BEGIN OF gty_s_afabe,
             afabe TYPE afaber,
           END OF gty_s_afabe.

    TYPES: BEGIN OF gty_s_amort,
             bukrs TYPE bukrs,      " БЕ
             anln1 TYPE anln1,      " СИСТЕМНЫЙ НОМЕР ОСА
             anln2 TYPE anln2,      " СУБНОМЕР ОС
             budat TYPE bkpf-budat,
           END OF gty_s_amort,
           gty_t_amort TYPE STANDARD TABLE OF gty_s_amort.

    TYPES: BEGIN OF gty_s_amort_stoim,
             bukrs TYPE bukrs,      " БЕ
             anln1 TYPE anln1,      " СИСТЕМНЫЙ НОМЕР ОСА
             anln2 TYPE anln2,      " СУБНОМЕР ОС
             budat TYPE bkpf-budat,
             netvl TYPE vtcur12,    " Остаточная стоимость
           END OF gty_s_amort_stoim,
           gty_t_amort_stoim TYPE STANDARD TABLE OF gty_s_amort_stoim.

    TYPES gty_t_afabe TYPE STANDARD TABLE OF gty_s_afabe WITH EMPTY KEY.

    CLASS-METHODS fill_dm_nmove " заполнить номера проводок для документов по ДМ
      IMPORTING VALUE(it_movh) TYPE zfi_drag_moveh_t
      EXPORTING VALUE(et_movh) TYPE zfi_drag_moveh_t.

    CLASS-METHODS fill_dm_on_move " заполнить данные для драгметаллов при проводке ОС
      IMPORTING VALUE(iv_budat) TYPE budat
                VALUE(it_asset) TYPE gty_t_asset
      EXPORTING VALUE(et_asset) TYPE gty_t_asset
                VALUE(et_movi)  TYPE zfi_drag_movei_t.

    CLASS-METHODS get_spp_hist " получить историю по СПП на дату
      IMPORTING VALUE(iv_budat) TYPE budat
                VALUE(iv_posnr) TYPE anla-posnr
                VALUE(iv_invnr) TYPE anla-invnr.

*        EXPORTING VALUE(et_hist)  TYPE zfiaa_price_hist_t

    CLASS-METHODS check_year
      IMPORTING VALUE(iv_gjahr) TYPE gjahr
                VALUE(iv_flt)   TYPE string
      EXPORTING VALUE(ev_bukrs) TYPE string.

    CLASS-METHODS get_asset_values FOR TABLE FUNCTION  zaa_v2_stock.
    CLASS-METHODS get_asset_value  FOR TABLE FUNCTION  zaa_v3_stock.        " ins 24.04.2024 V.Lipskij #37710

    CLASS-METHODS get_asset_val_ch FOR TABLE FUNCTION  zaa_v2_stock_change. " ins Tararenko O - #31850
    CLASS-METHODS get_asset_values_y FOR TABLE FUNCTION  zaa_v2_stock_y.
    CLASS-METHODS get_asset_val_ng FOR TABLE FUNCTION  zaa_v_val_ng.
    CLASS-METHODS get_asset_spi    FOR TABLE FUNCTION  zaa_asset_spi. " срок полезного использования

    CLASS-METHODS get_asset_calc_dates FOR TABLE FUNCTION zaa_asset_calc_dates.

    CLASS-METHODS get_asset_spi_ondate
              AMDP OPTIONS READ-ONLY
                   CDS SESSION CLIENT current
      IMPORTING VALUE(it_data)      TYPE gty_t_spi   " список ОС для расчета СПИ
                VALUE(iv_ex_curper) TYPE abap_bool DEFAULT abap_false
      EXPORTING VALUE(et_data)      TYPE gty_t_spi.

    CLASS-METHODS get_ifrs_acpt    FOR TABLE FUNCTION  zaa_ifrs_acpt.

    CLASS-METHODS get_assets_values
                  AMDP OPTIONS READ-ONLY
                   CDS SESSION CLIENT current
      IMPORTING VALUE(iv_date)    TYPE d
                VALUE(iv_end_day) TYPE char1 DEFAULT '' " вывод значений на конец отчетной даты
                VALUE(it_asset)   TYPE gty_t_avals   " список ОС для расчета стоимости
      EXPORTING VALUE(et_vals)    TYPE gty_t_avals.

    CLASS-METHODS get_aa_vals
          AMDP OPTIONS READ-ONLY
                   CDS SESSION CLIENT current
      IMPORTING VALUE(iv_date)    TYPE d
                VALUE(iv_end_day) TYPE char1 DEFAULT '' " вывод значений на конец отчетной даты
                VALUE(it_asset)   TYPE gty_t_avals   " список ОС для расчета стоимости
      EXPORTING VALUE(et_vals)    TYPE gty_t_avals.

    CLASS-METHODS get_asset_amort_stoim
     AMDP OPTIONS READ-ONLY
                   CDS SESSION CLIENT current
      IMPORTING VALUE(iv_eod)   TYPE abap_bool DEFAULT abap_false   " вывод значений на конец дня
                VALUE(it_am_st) TYPE gty_t_amort
      EXPORTING VALUE(et_am_st) TYPE gty_t_amort_stoim.

    CLASS-METHODS get_asset_amort_st
              AMDP OPTIONS READ-ONLY
                   CDS SESSION CLIENT current
      IMPORTING VALUE(iv_eod)   TYPE abap_bool DEFAULT abap_false   " вывод значений на конец дня
                VALUE(it_am_st) TYPE gty_t_amort
      EXPORTING VALUE(et_am_st) TYPE gty_t_amort_stoim.

ENDCLASS.


CLASS zaa_utils_hdb IMPLEMENTATION.
  METHOD get_ifrs_acpt
      BY DATABASE FUNCTION FOR HDB
           LANGUAGE SQLSCRIPT
           OPTIONS READ-ONLY
           USING acdoca anla tabwt
           faat_doc_it.
    declare lv_mandt CHAR( 3) := session_context( 'CLIENT' );
    declare lv_spras CHAR( 3) := session_context( 'LOCALE_SAP' );



    lt_ret =
      SELECT DISTINCT ac.rclnt AS CLIENT,
                      ac.rbukrs AS bukrs,
                      ac.gjahr,
                      ac.afabe,
                      ac.anln1,
                      ac.anln2,
                      ac.anbwa AS bwasl,
                      ac.subta,
                      ac.budat,
                      ac.xreversing AS ifrs_x,
                      CASE WHEN ac.subta_rev <> 0 THEN 'X' ELSE '' END AS storno
         FROM acdoca AS ac
           LEFT JOIN
             ( SELECT DISTINCT rbukrs AS bukrs, gjahr, afabe, anln1, anln2, subta, budat
                 FROM acdoca AS rev
           WHERE rev.rclnt = :lv_mandt
             AND rev.afabe IN ('50', '51') ) AS rev ON   rev.bukrs = ac.rbukrs
                                                    AND  rev.anln1 = ac.anln1
                                                    AND  rev.anln2 = ac.anln2
                                                    AND  rev.gjahr = ac.gjahr
                                                    AND  rev.subta = ac.subta_rev
         WHERE ac.rclnt = :lv_mandt
           AND ac.afabe IN ('50', '51')
           AND COALESCE(rev.budat,'00000000') <> ac.budat
           AND ac.anbwa IN ('M33', 'M34')
      UNION ALL
      SELECT DISTINCT ac.mandt AS CLIENT,
                      ac.bukrs AS bukrs,
                      ac.gjahr,
                      ac.afabe,
                      ac.anln1,
                      ac.anln2,
                      ac.bwasl,
                      ac.subta,
                      ac.budat,
                      ac.xreversing AS ifrs_x,
                      CASE WHEN ac.subta_rev <> 0 THEN 'X' ELSE '' END AS storno
        FROM faat_doc_it AS ac
          LEFT JOIN
           ( SELECT DISTINCT bukrs , gjahr, afabe, anln1, anln2, bwasl , subta, budat
               FROM faat_doc_it AS rev
               WHERE rev.mandt = :lv_mandt
                 AND rev.afabe IN ('50', '51') ) AS rev ON   rev.bukrs = ac.bukrs
                                                        AND  rev.anln1 = ac.anln1
                                                        AND  rev.anln2 = ac.anln2
                                                        AND  rev.gjahr = ac.gjahr
                                                        AND  rev.afabe = ac.afabe
                                                        AND  rev.subta = ac.subta_rev
       WHERE ac.mandt = :lv_mandt
         AND ac.afabe IN ('50', '51')
         AND COALESCE(rev.budat,'00000000') <> ac.budat
         AND ac.bwasl IN ('M33', 'M34')
 ;
     RETURN
     SELECT DISTINCT * FROM
     ( SELECT
           :lv_mandt AS CLIENT,
           ret.bukrs,
           ret.anln1,
           ret.anln2,
           ret.ifrs_x,
           ret.budat AS adatu,
           ret.bwasl,
           tabwt.bwatxt,
           ret.storno
       FROM :lt_ret AS ret
         LEFT JOIN tabwt AS tabwt ON  tabwt.mandt = :lv_mandt
                             AND tabwt.spras = :lv_spras
                             AND tabwt.bwasl = ret.bwasl
   UNION ALL
     SELECT
           :lv_mandt AS CLIENT,
           anla.bukrs,
           anla.anln1,
           anla.anln2,
           'X' AS ifrs_x,
           '19000101' AS adatu,
           '' AS bwasl,
           '' AS bwatxt,
           '' AS storno
       FROM anla AS anla
         WHERE mandt = :lv_mandt )   ORDER BY bukrs, anln1, anln2, adatu;
  ENDMETHOD.

  METHOD get_asset_spi
    BY DATABASE FUNCTION FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY

         USING anlb anlbza faav_anlc anlz anla.
    declare lv_sdate STRING := LEFT(:iv_date,4) || '0101';
    declare lv_edate STRING := LEFT(:iv_date,4) || '1231';
    declare lv_mdate STRING := LEFT(:iv_date,6) || '01'; /*начало месяца*/
    /*таблица последних дней месяцев с начала года по отчетную дату*/
    ld =
        SELECT to_dats(add_days(generated_period_end,-1)) AS ld
          FROM series_generate_date('INTERVAL 1 MONTH', :lv_sdate, add_days(last_day(:lv_mdate),1) );

    lt_ret =
      SELECT anlb.mandt AS CLIENT,
             anlb.bukrs,
             anlb.anln1,
             anlb.anln2,
             anlb.afabe,
             anlb.afabg,
             COALESCE(aza.afasl,anlb.afasl) AS afasl,
             COALESCE(aza.ndper,anlb.ndper) AS ndper,
             COALESCE(aza.ndjar,anlb.ndjar) AS ndjar,
             CASE WHEN :iv_date < anla.aktiv THEN 0 ELSE COALESCE(aza.ndper,anlb.ndper) + COALESCE(aza.ndjar,anlb.ndjar) *12 END AS spi_per,
             CASE WHEN :iv_date < anla.aktiv THEN 0 ELSE anlc.ndabp + anlc.ndabj * 12
               + COALESCE(per.per,0) END AS use_per
        FROM anlb AS anlb
          JOIN anla AS anla ON  anla.mandt =  anlb.mandt
                            AND anla.bukrs =  anlb.bukrs
                            AND anla.anln1 =  anlb.anln1
                            AND anla.anln2 =  anlb.anln2

          LEFT OUTER JOIN anlbza AS aza ON  aza.mandt =  anlb.mandt
                                        AND aza.bukrs =  anlb.bukrs
                                        AND aza.anln1 =  anlb.anln1
                                        AND aza.anln2 =  anlb.anln2
                                        AND aza.afabe =  anlb.afabe
                                        AND aza.bdatu >= :iv_date
                                        AND aza.adatu <= :iv_date
          LEFT OUTER JOIN faav_anlc AS anlc ON  anlc.mandt =  anlb.mandt
                                             AND anlc.bukrs =  anlb.bukrs
                                             AND anlc.anln1 =  anlb.anln1
                                             AND anlc.anln2 =  anlb.anln2
                                             AND anlc.afabe =  anlb.afabe
                                             AND anlc.gjahr =  LEFT(:iv_date,4)
          LEFT OUTER JOIN
            ( SELECT ab.bukrs,
                     ab.anln1,
                     ab.anln2,
                     ab.afabe,
                     COUNT( ld.ld )
                     AS per
                FROM :ld AS ld
                  JOIN anlz AS az ON az.adatu <= ld.ld AND az.bdatu >= ld.ld
                  JOIN anlb AS ab ON az.mandt =  ab.mandt
                           AND az.bukrs =  ab.bukrs
                           AND az.anln1 =  ab.anln1
                           AND az.anln2 =  ab.anln2
                           AND ld.ld    >=  ab.afabg
                WHERE az.mandt =  :iv_clnt
/*                  AND az.bdatu >= :lv_sdate
                  AND az.adatu <= :iv_date
*/
                  AND ab.afabg <= :iv_date
                  AND az.xstil = ''
                GROUP BY ab.bukrs,
                     ab.anln1,
                     ab.anln2,
                     ab.afabe) AS per ON per.bukrs =  anlb.bukrs
                                        AND per.anln1 =  anlb.anln1
                                        AND per.anln2 =  anlb.anln2
                                        AND per.afabe =  anlb.afabe


          WHERE anlb.mandt = :iv_clnt;
    RETURN
      SELECT CLIENT,
             bukrs,
             anln1,
             anln2,
             afabe,
             afabg,
             afasl,
             ndper,
             ndjar,
             MOD(use_per ,12) AS usep,
             FLOOR(( use_per  )/ 12) AS usej,
             CASE WHEN spi_per < use_per THEN 0
                  ELSE MOD( (spi_per-use_per  ),12) END AS restp,
             CASE WHEN spi_per < use_per THEN 0
                  ELSE FLOOR( (spi_per-use_per  )/12) END AS restj
      FROM
        :lt_ret;
  ENDMETHOD.

  METHOD check_year BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
                    USING t093c.

    DECLARE LV_MANDT CHAR( 3) := SESSION_CONTEXT( 'CLIENT' );

    LT_TABLE = SELECT BUKRS
                 FROM T093C
                WHERE MANDT = :LV_MANDT
                  AND LGJAHR < :IV_GJAHR;

    IF IS_EMPTY ( :LT_TABLE ) THEN
      RETURN;
    ELSE
      LT_TABLE = APPLY_FILTER( :LT_TABLE, :IV_FLT );
    END IF;

    --ПЕРЕЧИСЛЕНИЕ НОМЕРОВ БЕ ЧЕРЕЗ ЗАПЯТУЮ
    SELECT STRING_AGG( BUKRS, ', ') INTO EV_BUKRS
      FROM (
        SELECT
             FIRST_VALUE(D.BUKRS) OVER ( PARTITION BY D.BUKRS ORDER BY D.BUKRS ) AS BUKRS
           FROM :LT_TABLE AS D
           GROUP BY BUKRS );
  ENDMETHOD.

  METHOD get_asset_amort_stoim
  BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
   OPTIONS READ-ONLY
         USING faav_anlc faav_anep faav_anek faav_anea faav_anlp tabw
               zrevdate faav_anek setleaf t093c anla tabwg.

    declare lv_mandt CHAR(3) := session_context( 'CLIENT' );


     lt_dates_all =               /*выборка возможных дат расчета амортизируемой стоимости */
       SELECT anla.invnr,
              anla.anln1,
              anla.anln2,
              t093c.datum,                                                  /*дата загрузки*/
              greatest( t093c.datum,                                        /*дата загрузки*/
                        anla.aktiv,                                         /*дата оприходования*/
                                                                            /*дата переоценки*/
                       ( SELECT to_dats( COALESCE ( MAX( vallast ), '00000000' ) )
                           FROM zrevdate
                          WHERE mandt = :lv_mandt
                            AND invnr = anla.invnr
                            AND vallast < it.budat ) ,
                                                                           /*дата проводки*/
                       ( SELECT to_dats( COALESCE ( MAX( anek.budat ), '00000000' ) )
                           FROM faav_anep
                           JOIN faav_anek AS anek ON anek.mandt = faav_anep.mandt
                                                 AND anek.bukrs = faav_anep.bukrs
                                                 AND anek.anln1 = faav_anep.anln1
                                                 AND anek.anln2 = faav_anep.anln2
                                                 AND anek.lnran = faav_anep.lnran
                          WHERE faav_anep.mandt = :lv_mandt
                            AND faav_anep.bukrs = it.bukrs
                            AND faav_anep.anln1 = it.anln1
                            AND faav_anep.anln2 = it.anln2
                            AND faav_anep.afabe = '01'
                            AND faav_anep.bwasl IN ( SELECT valfrom
                                                       FROM setleaf
                                                      WHERE setclass = '0000'
                                                        AND subclass = ''
                                                        AND setname  = 'Z_TTYPE_AMORT' )
                           AND ( anek.budat < it.budat OR anek.budat = it.budat AND :iv_eod = 'X' ) ) ) as budat
          FROM :it_am_st AS it
            INNER JOIN anla AS anla ON anla.mandt = :lv_mandt
                                   AND anla.bukrs = it.bukrs
                                   AND anla.anln1 = it.anln1
                                   AND anla.anln2 = it.anln2
                                   AND anla.zugdt <= it.budat
            INNER JOIN t093c AS t093c ON t093c.mandt = :lv_mandt
                                     AND t093c.bukrs = it.bukrs ;
    /*определение наибольшей даты для инв номера и признака , это дата загрузки или нет*/
    lt_date_last =
      SELECT invnr,
             anln2,
             budat,
             CASE WHEN lead(invnr) over (partition BY invnr ORDER BY budat) IS NULL THEN 'X' ELSE '' END AS max_date,
             CASE WHEN budat = datum THEN 'X' ELSE '' END AS LOAD
             FROM :lt_dates_all;
    lt_date_last = SELECT * FROM :lt_date_last WHERE max_date = 'X';
    lt_ret =
    -- формирование аморт стоим по инв №
    SELECT
        invnr AS invnr,
        anln2,
        SUM(netvl) AS netvl
      FROM (
        -- выборка значений на начало года
        SELECT
             anla.invnr AS invnr,
             anlc.mandt AS CLIENT,
             anlc.bukrs AS bukrs,
             anlc.anln1 AS anln1,
             anlc.anln2 AS anln2,
             anlc.afabe AS afabe,
             anlc.kansw + anlc.kaufw + anlc.knafa +  anlc.kaafa + anlc.kaufn
             + CASE WHEN ld.LOAD = 'X' THEN anlc.answl ELSE 0.00 END
             + CASE WHEN ld.LOAD = 'X' THEN anlc.nafav ELSE 0.00 END
             + CASE WHEN ld.LOAD = 'X' THEN anlc.safav ELSE 0.00 END AS netvl
          FROM anla
          JOIN :lt_date_last as ld ON ld.invnr = anla.invnr
                                  AND ld.anln2 = anla.anln2
                                  AND  ( anla.deakt >= ld.budat OR anla.deakt < '19000101' )
          JOIN faav_anlc AS anlc ON anla.bukrs = anlc.bukrs
                                AND anla.anln1 = anlc.anln1
                                AND anla.anln2 = anlc.anln2
                                AND anlc.afabe = '01'
                                AND anlc.mandt = :lv_mandt
                                AND anlc.gjahr =  year( ld.budat )
          WHERE anla.mandt = :lv_mandt
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            ld.invnr AS invnr,
            anep.mandt AS mandt,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anep.anbtr + anea.aufwv + anea.aufwl
            + anea.nafav + anea.nafal
            + anea.aafav + anea.aafal
            + anea.aufnv + anea.aufnl netvl
          FROM faav_anep AS anep
            JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                  AND anek.bukrs = anep.bukrs
                                  AND anek.anln1 = anep.anln1
                                  AND anek.anln2 = anep.anln2
                                  AND anek.gjahr = anep.gjahr
                                  AND anek.lnran = anep.lnran
            JOIN anla ON anla.mandt = anek.mandt
                     AND anla.bukrs = anek.bukrs
                     AND anla.anln1 = anek.anln1
                     AND anla.anln2 = anek.anln2
            JOIN :lt_date_last as ld ON ld.invnr = anla.invnr
                                    AND ld.anln2 = anla.anln2
                                    AND  ( anla.deakt >= ld.budat OR anla.deakt < '19000101' )
            JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                             AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'
            LEFT OUTER JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                              AND anea.bukrs = anep.bukrs
                                              AND anea.anln1 = anep.anln1
                                              AND anea.anln2 = anep.anln2
                                              AND anea.gjahr = anep.gjahr
                                              AND anea.afabe = anep.afabe
                                              AND anea.lnran = anep.lnran
                                              AND anea.zucod = anep.zucod
          WHERE anep.mandt = :lv_mandt
            AND anep.gjahr =  year ( ld.budat )
            AND anep.afabe = '01'
            AND anek.budat <= ld.budat
        UNION ALL
         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            ld.invnr AS invnr,
            anlp.mandt AS mandt,
            anlp.bukrs AS bukrs,
            anlp.anln1 AS anln1,
            anlp.anln2 AS anln2,
            anlp.afaber AS afabe,
            anlp.nafaz + anlp.aafaz +  anlp.aufng  as netvl
          FROM faav_anlp AS anlp
            JOIN anla ON anla.mandt = anlp.mandt
                     AND anla.bukrs = anlp.bukrs
                     AND anla.anln1 = anlp.anln1
                     AND anla.anln2 = anlp.anln2
            JOIN :lt_date_last AS ld  ON ld.invnr = anla.invnr
                              AND ld.anln2 = anla.anln2
                              AND  ( anla.deakt >= ld.budat OR anla.deakt < '19000101' )
          WHERE anlp.mandt = :lv_mandt
            AND anlp.afaber = '01'
            AND anlp.gjahr = year ( ld.budat )
            AND RIGHT( anlp.peraf, 2 ) <= month( ld.budat )
      )
        GROUP BY invnr, anln2;

    et_am_st =
    SELECT
        it.bukrs,
        it.anln1,
        it.anln2,
        it.budat,
        ret.netvl
     FROM :it_am_st AS it
       JOIN anla ON  anla.mandt = :lv_mandt
                 AND anla.bukrs = it.bukrs
                 AND anla.anln1 = it.anln1
                 AND anla.anln2 = it.anln2
       JOIN :lt_ret AS ret ON anla.invnr = ret.invnr
                          AND anla.anln2 = ret.anln2
      ;
  ENDMETHOD.

  METHOD get_asset_value
     BY DATABASE FUNCTION FOR HDB LANGUAGE SQLSCRIPT
           OPTIONS READ-ONLY
           USING faav_anlc faav_anep faav_anek faav_anea faav_anlp tabw tabwg.

    declare lv_gjahr CHAR(4) := LEFT( :p_date, 4 );
    declare lv_peraf CHAR(3) := LPAD(month( :p_date ), 3, '0' );

      lt_budat =
        SELECT '' bukrs, '' anln1, '' anln2, '' budat FROM dummy;

    lt_ret =
    -- формирование итоговых строк разрезе ос и области оценки
    SELECT
        CLIENT,
        bukrs,
        anln1,
        anln2,
        afabe,
        SUM(kansw) + SUM(kaufw) AS kansw,
        SUM(kaufw) AS kaufw,
        SUM(knafa) AS knafa,
        SUM(kaafa) AS kaafa,
        SUM(kaufn) AS kaufn,
        SUM(kansw) + SUM(kaufw) + SUM(knafa) +  SUM(kaafa) +  SUM(kaufn) AS netvl
      FROM (
        -- выборка значений на начало года
        SELECT
             anlc.mandt AS CLIENT,
             anlc.bukrs AS bukrs,
             anlc.anln1 AS anln1,
             anlc.anln2 AS anln2,
             anlc.afabe AS afabe,
             anlc.kansw AS kansw,
             anlc.kaufw,
             anlc.knafa,
             anlc.kaafa,
             anlc.kaufn
          FROM faav_anlc AS anlc LEFT JOIN :lt_budat ON  :lt_budat.bukrs = anlc.bukrs
                                                    AND  :lt_budat.anln1 = anlc.anln1
                                                    AND  :lt_budat.anln2 = anlc.anln2
          WHERE anlc.mandt = :p_clnt
            AND anlc.bukrs = :p_bukrs
            AND anlc.anln1 = :p_anln1
            AND anlc.anln2 = :p_anln2
            AND anlc.gjahr = :lv_gjahr
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            anep.mandt AS mandt,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anep.anbtr AS kansw,
            anea.aufwv + anea.aufwl AS kaufw,
            anea.nafav + anea.nafal AS knafa,
            anea.aafav + anea.aafal AS kaafa,
            anea.aufnv + anea.aufnl AS kaufn
          FROM faav_anep AS anep
            INNER JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                        AND anek.bukrs = anep.bukrs
                                        AND anek.anln1 = anep.anln1
                                        AND anek.anln2 = anep.anln2
                                        AND anek.gjahr = anep.gjahr
                                        AND anek.lnran = anep.lnran
            LEFT JOIN :lt_budat ON   :lt_budat.bukrs = anek.bukrs
                                AND  :lt_budat.anln1 = anek.anln1
                                AND  :lt_budat.anln2 = anek.anln2
            INNER JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                                    AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'
            LEFT OUTER JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                              AND anea.bukrs = anep.bukrs
                                              AND anea.anln1 = anep.anln1
                                              AND anea.anln2 = anep.anln2
                                              AND anea.gjahr = anep.gjahr
                                              AND anea.afabe = anep.afabe
                                              AND anea.lnran = anep.lnran
                                              AND anea.zucod = anep.zucod
          WHERE anep.mandt = :p_clnt
            AND anep.gjahr = :lv_gjahr
            AND anep.bukrs = :p_bukrs
            AND anep.anln1 = :p_anln1
            AND anep.anln2 = :p_anln2
            AND anek.budat <= :p_date
        UNION ALL
         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            anlp.mandt  AS mandt,
            anlp.bukrs  AS bukrs,
            anlp.anln1  AS anln1,
            anlp.anln2  AS anln2,
            anlp.afaber AS afabe,
            0           AS kansw,
            0           AS kaufw ,
            anlp.nafaz  AS knafa,
            anlp.aafaz  AS kaafa,
            anlp.aufng  AS kaufn
            FROM ( SELECT mandt,
                          bukrs,
                          anln1,
                          anln2,
                          afaber,
                          nafaz,
                          aafaz,
                          aufng,
                          gjahr,
                          peraf,
                          afbnr,
                          MIN( kostl ) FROM faav_anlp
                          WHERE mandt = :p_clnt
                           AND bukrs = :p_bukrs
                           AND anln1 = :p_anln1
                           AND anln2 = :p_anln2
                          GROUP BY mandt, bukrs, anln1, anln2, afaber, nafaz, aafaz, aufng, gjahr, peraf, afbnr ) AS anlp
            LEFT JOIN :lt_budat ON :lt_budat.bukrs = anlp.bukrs
                               AND :lt_budat.anln1 = anlp.anln1
                               AND :lt_budat.anln2 = anlp.anln2
          WHERE anlp.gjahr =  :lv_gjahr
            AND anlp.bukrs = :p_bukrs
            AND anlp.anln1 = :p_anln1
            AND anlp.anln2 = :p_anln2
            AND anlp.peraf < :lv_peraf
      )
      GROUP BY CLIENT, bukrs,anln1,anln2,afabe
       ;
      RETURN :lt_ret;
  ENDMETHOD.

  METHOD get_asset_val_ch
   BY DATABASE FUNCTION FOR HDB LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING faav_anlc faav_anep faav_anek faav_anea faav_anlp tabw tabwg tvarvc.
    declare lv_gjahr CHAR(4) := LEFT( :p_date, 4 );
    declare lv_peraf CHAR(3) := LPAD(month( :p_date ), 3, '0' );

*    IF RIGHT( :P_DATE, 4 ) = '0101' THEN
*       LV_GJAHR = LV_GJAHR - 1;
*       LV_PERAF = '013';
*    END IF;

    -- если указан параметр амортизируемая стоимость, то для каждого ос определяется дата последней проводки по ос
    IF :p_amnt = 'X' THEN
      lt_budat =
        SELECT bukrs, anln1, anln2,  MAX( budat )  AS budat
          FROM faav_anek
          WHERE budat <= :p_date
            AND mandt = :p_clnt
          GROUP BY bukrs, anln1, anln2 ;
    ELSE
      lt_budat =
        SELECT '' bukrs, '' anln1, '' anln2, '' budat FROM dummy;
    END if;


    lt_ret =
    -- формирование итоговых строк разрезе ос и области оценки
    SELECT
        CLIENT,
        bukrs,
        anln1,
        anln2,
        afabe,
        SUM(kansw) + SUM(kaufw) AS kansw,
        SUM(kaufw) AS kaufw,
        SUM(knafa) AS knafa,
        SUM(kaafa) AS kaafa,
        SUM(kaufn) AS kaufn,
        SUM(kansw) + SUM(kaufw) + SUM(knafa) +  SUM(kaafa) +  SUM(kaufn) AS netvl
      FROM (
        -- выборка значений на начало года
        SELECT
             anlc.mandt AS CLIENT,
             anlc.bukrs AS bukrs,
             anlc.anln1 AS anln1,
             anlc.anln2 AS anln2,
             anlc.afabe AS afabe,
             anlc.kansw AS kansw,
             anlc.kaufw,
             anlc.knafa,
             anlc.kaafa,
             anlc.kaufn
          FROM faav_anlc AS anlc LEFT JOIN :lt_budat ON  :lt_budat.bukrs = anlc.bukrs
                                                    AND  :lt_budat.anln1 = anlc.anln1
                                                    AND  :lt_budat.anln2 = anlc.anln2
          WHERE anlc.mandt = :p_clnt
            AND anlc.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat )
                                  ELSE :lv_gjahr
                              END
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            anep.mandt AS mandt,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anep.anbtr AS kansw,
            anea.aufwv + anea.aufwl AS kaufw,
            anea.nafav + anea.nafal AS knafa,
            anea.aafav + anea.aafal AS kaafa,
            anea.aufnv + anea.aufnl AS kaufn
          FROM faav_anep AS anep
            INNER JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                        AND anek.bukrs = anep.bukrs
                                        AND anek.anln1 = anep.anln1
                                        AND anek.anln2 = anep.anln2
                                        AND anek.gjahr = anep.gjahr
                                        AND anek.lnran = anep.lnran
            LEFT JOIN :lt_budat ON   :lt_budat.bukrs = anek.bukrs
                                AND  :lt_budat.anln1 = anek.anln1
                                AND  :lt_budat.anln2 = anek.anln2
            INNER JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                                    AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'
            LEFT OUTER JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                              AND anea.bukrs = anep.bukrs
                                              AND anea.anln1 = anep.anln1
                                              AND anea.anln2 = anep.anln2
                                              AND anea.gjahr = anep.gjahr
                                              AND anea.afabe = anep.afabe
                                              AND anea.lnran = anep.lnran
                                              AND anea.zucod = anep.zucod
          WHERE NOT EXISTS ( Select * FROM TVARVC AS tvarvc WHERE NAME  = 'ZAA_ACT_MASS_PRINT_BWASL_SPIS'
                 AND tvarvc.low = anep.bwasl )
                 and anep.mandt = :p_clnt
            AND anep.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
            AND (     :p_amnt =  'X'  AND anek.budat <= :lt_budat.budat
                  OR  :p_amnt <> 'X'  AND anek.budat < :p_date )
        UNION ALL
         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            anlp.mandt  AS mandt,
            anlp.bukrs  AS bukrs,
            anlp.anln1  AS anln1,
            anlp.anln2  AS anln2,
            anlp.afaber AS afabe,
            0           AS kansw,
            0           AS kaufw ,
            anlp.nafaz  AS knafa,
            anlp.aafaz  AS kaafa,
            anlp.aufng  AS kaufn
-- --> ak_butvilovs #8000001276, аморт. ос в ведом.распред. амортизации
            FROM ( SELECT mandt,
                          bukrs,
                          anln1,
                          anln2,
                          afaber,
                          nafaz,
                          aafaz,
                          aufng,
                          gjahr,
                          peraf,
                          afbnr,
                          MIN( kostl ) FROM faav_anlp
                          WHERE mandt = :p_clnt
                          GROUP BY mandt, bukrs, anln1, anln2, afaber, nafaz, aafaz, aufng, gjahr, peraf, afbnr ) AS anlp
 --          FROM faav_anlp AS anlp
-- <-- ak_butvilovs #8000001276
            LEFT JOIN :lt_budat ON :lt_budat.bukrs = anlp.bukrs
                               AND :lt_budat.anln1 = anlp.anln1
                               AND :lt_budat.anln2 = anlp.anln2
-- --> ak_butvilovs #8000001276, аморт. ос в ведом.распред. амортизации
--          WHERE anlp.mandt = :p_clnt
--            AND anlp.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
            WHERE anlp.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
-- <-- ak_butvilovs #8000001276
            AND anlp.peraf < CASE WHEN :p_amnt = 'X' THEN month( :lt_budat.budat ) ELSE :lv_peraf END
 --          FROM faav_anlp AS anlp
      )
      GROUP BY CLIENT, bukrs,anln1,anln2,afabe
       ;
      RETURN :lt_ret;
  ENDMETHOD.

  METHOD get_asset_calc_dates
     BY DATABASE FUNCTION FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING anlb.

    lt_anlb = SELECT anlb.mandt AS CLIENT,
                      anlb.bukrs,
                      anlb.anln1,
                      anlb.anln2,
                      anlb.afabe,
                      anlb.afabg,
                      anlb.ndper,
                      anlb.ndjar,
                      anlb.ndper + anlb.ndjar *12  AS per

              FROM anlb;

    RETURN SELECT
            CLIENT,
            bukrs,
            anln1,
            anln2,
            afabe,
            afabg,
            ndper,
            ndjar,
            to_dats(add_months (afabg, per)) as dependdate

  FROM :lt_anlb;
  ENDMETHOD.

  METHOD get_assets_values
  BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
           OPTIONS READ-ONLY
           USING faav_anlc faav_anep faav_anek faav_anea tabw tabwg.
    declare lv_gjahr CHAR(4) := LEFT( :iv_date, 4 );
    declare lv_mandt STRING := session_context('CLIENT');

    et_vals =
    -- формирование итоговых строк разрезе ос и области оценки
    SELECT
        CLIENT,
        bukrs,
        anln1,
        anln2,
        afabe,
        SUM(kansw) + SUM(kaufw) AS kansw,
        SUM(kaufw) AS kaufw,
        SUM(knafa) AS knafa,
        SUM(kaafa) AS kaafa,
        SUM(kaufn) AS kaufn,
        SUM(kansw) + SUM(kaufw) + SUM(knafa) +  SUM(kaafa) +  SUM(kaufn) AS netvl
      FROM (
        -- выборка значений на начало года
        SELECT
             anlc.mandt AS CLIENT,
             anlc.bukrs AS bukrs,
             anlc.anln1 AS anln1,
             anlc.anln2 AS anln2,
             anlc.afabe AS afabe,
             anlc.kansw AS kansw,
             anlc.kaufw,
             anlc.knafa,
             anlc.kaafa,
             anlc.kaufn
          FROM faav_anlc AS anlc
           JOIN :it_asset as aa ON  aa.bukrs = anlc.bukrs
                               AND  aa.anln1 = anlc.anln1
                               AND  aa.anln2 = anlc.anln2
                               and  aa.afabe = anlc.afabe
          WHERE anlc.mandt = :lv_mandt
            AND anlc.gjahr = :lv_gjahr
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            anep.mandt AS mandt,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anep.anbtr AS kansw,
            anea.aufwv + anea.aufwl AS kaufw,
            anea.nafav + anea.nafal AS knafa,
            anea.aafav + anea.aafal AS kaafa,
            anea.aufnv + anea.aufnl AS kaufn
          FROM faav_anep AS anep
            INNER JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                        AND anek.bukrs = anep.bukrs
                                        AND anek.anln1 = anep.anln1
                                        AND anek.anln2 = anep.anln2
                                        AND anek.gjahr = anep.gjahr
                                        AND anek.lnran = anep.lnran
            JOIN :it_asset as aa ON aa.bukrs = anek.bukrs
                                AND aa.anln1 = anek.anln1
                                AND aa.anln2 = anek.anln2
            INNER JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                                    AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'
            LEFT OUTER JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                              AND anea.bukrs = anep.bukrs
                                              AND anea.anln1 = anep.anln1
                                              AND anea.anln2 = anep.anln2
                                              AND anea.gjahr = anep.gjahr
                                              AND anea.afabe = anep.afabe
                                              AND anea.lnran = anep.lnran
                                              AND anea.zucod = anep.zucod
          WHERE anep.mandt = :lv_mandt
            AND anep.gjahr = :lv_gjahr
            AND anek.budat < :iv_date
            )
                  GROUP BY CLIENT, bukrs,anln1,anln2,afabe
            ;
  ENDMETHOD.

  METHOD get_aa_vals
        BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
        USING zaa_utils_hdb=>get_asset_values_y
         faav_anlc faav_anep faav_anek faav_anea tabw tabwg faav_anlp.

    declare lv_gjahr char(4) := left( :iv_date, 4 );
    declare lv_peraf CHAR(3) := LPAD(month( :iv_date ), 3, '0' );
    declare lv_last char(1);
    declare lv_mandt STRING := session_context('CLIENT');
    IF iv_end_day <> 'X' THEN
      et_vals =
      SELECT  stock.client ,
              stock.bukrs  ,
              stock.anln1  ,
              stock.anln2  ,
              stock.afabe  ,
              stock.kansw  ,
              stock.kaufw  ,
              stock.knafa  ,
              stock.kaafa  ,
              stock.kaufn  ,
              stock.netvl
        from "ZAA_UTILS_HDB=>GET_ASSET_VALUES_Y"( :LV_MANDT, :IV_DATE,  '' ) AS STOCK
         join :it_asset as aa on   aa.bukrs = stock.bukrs
                               and aa.anln1 = stock.anln1
                               and aa.anln2 = stock.anln2
                               and aa.afabe = stock.afabe;
      return;
    end if;
    if :iv_date = last_day( :iv_date )
      then lv_last = 'X';
    end if;

    et_vals =
    -- формирование итоговых строк разрезе ос и области оценки
    SELECT
        client,
        bukrs,
        anln1,
        anln2,
        afabe,
        sum(kansw + kaufw) AS kansw,
        sum(kaufw) as kaufw,
        sum(knafa) as knafa,
        sum(kaafa) as kaafa,
        sum(kaufn) as kaufn,
        sum(kansw) + sum(kaufw) + sum(knafa) +  sum(kaafa) +  sum(kaufn) as netvl
      from (
        -- выборка значений на начало года
        SELECT
             anlc.mandt as client,
             anlc.bukrs as bukrs,
             anlc.anln1 as anln1,
             anlc.anln2 as anln2,
             anlc.afabe as afabe,
             anlc.kansw as kansw,
             anlc.kaufw,
             anlc.knafa,
             anlc.kaafa,
             anlc.kaufn
          from faav_anlc as anlc
            join :it_asset as aa on  aa.bukrs = anlc.bukrs
                                 and aa.anln1 = anlc.anln1
                                 and aa.anln2 = anlc.anln2
                                 and aa.afabe = anlc.afabe
          where anlc.mandt = :lv_mandt
            AND anlc.gjahr = :lv_gjahr
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            anep.mandt as mandt,
            anep.bukrs as bukrs,
            anep.anln1 as anln1,
            anep.anln2 as anln2,
            anep.afabe as afabe,
            anep.anbtr as kansw,
            anea.aufwv + anea.aufwl as kaufw,
            anea.nafav + anea.nafal as knafa,
            anea.aafav + anea.aafal as kaafa,
            anea.aufnv + anea.aufnl as kaufn
          from faav_anep as anep
            inner join faav_anek as anek on anek.mandt = anep.mandt
                                        and anek.bukrs = anep.bukrs
                                        and anek.anln1 = anep.anln1
                                        and anek.anln2 = anep.anln2
                                        and anek.gjahr = anep.gjahr
                                        and anek.lnran = anep.lnran
            join :it_asset as aa on  aa.bukrs = anep.bukrs
                                 and aa.anln1 = anep.anln1
                                 and aa.anln2 = anep.anln2
                                 and aa.afabe = anep.afabe
            inner join tabw as tabw on tabw.mandt = anep.mandt
                                    and tabw.bwasl = anep.bwasl
            inner join tabwg as tabwg on  tabwg.mandt = tabw.mandt
                                    and tabwg.bwagrp = tabw.bwagrp
                                    and tabwg.bwatyp <> '4'
            left outer join faav_anea as anea on  anea.mandt = anep.mandt
                                              and anea.bukrs = anep.bukrs
                                              and anea.anln1 = anep.anln1
                                              and anea.anln2 = anep.anln2
                                              and anea.gjahr = anep.gjahr
                                              and anea.afabe = anep.afabe
                                              and anea.lnran = anep.lnran
                                              and anea.zucod = anep.zucod
          where anep.mandt = :lv_mandt
            AND anep.gjahr = :lv_gjahr
            AND anek.budat <= :iv_date
        union all
         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            anlp.mandt as mandt,
            anlp.bukrs as bukrs,
            anlp.anln1 as anln1,
            anlp.anln2 as anln2,
            anlp.afaber as afabe,
            0           AS kansw,
            0           AS kaufw ,
            anlp.nafaz as knafa,
            anlp.aafaz as kaafa,
            anlp.aufng as kaufn
          from faav_anlp as anlp
            join :it_asset as aa on  aa.bukrs = anlp.bukrs
                                 and aa.anln1 = anlp.anln1
                                 and aa.anln2 = anlp.anln2
                                 and aa.afabe = anlp.afaber
          where anlp.mandt = :lv_mandt
            AND anlp.gjahr = :lv_gjahr
            AND ( anlp.peraf < :lv_peraf or :lv_last = 'X' and anlp.peraf = :lv_peraf    ) )
      GROUP BY CLIENT, bukrs,anln1,anln2,afabe;
  ENDMETHOD.

  METHOD get_asset_values_y
     BY DATABASE FUNCTION FOR HDB LANGUAGE SQLSCRIPT
           OPTIONS READ-ONLY
           USING faav_anlc faav_anep faav_anek faav_anea faav_anlp tabw tabwg.

    -- амортизация с учетом всех данных независимо от даты проводки, проведенных в текущем месяце ( месяц даты отчета)
     declare lv_gjahr CHAR(4) := LEFT( :p_date, 4 );
     declare lv_peraf CHAR(3) := LPAD(month( :p_date ), 3, '0' );

     lt_ts = select 'Start' as point, current_utctimestamp as timestamp from dummy;

     -- если указан параметр амортизируемая стоимость, то для каждого ос определяется дата последней проводки по ос
     IF :p_amnt = 'X' THEN
       lt_budat =
         SELECT bukrs, anln1, anln2,  MAX( budat )  AS budat
           FROM faav_anek
           WHERE budat <= :p_date
             AND mandt = :p_clnt
           GROUP BY bukrs, anln1, anln2 ;
     ELSE
       lt_budat =
         SELECT '' bukrs, '' anln1, '' anln2, '' budat FROM dummy;
     END if;

     lt_ts = select * from :lt_ts union select 'LT_BUDAT' as point, current_utctimestamp as timestamp from dummy;

     lt_ret =
     -- формирование итоговых строк разрезе ос и области оценки
     SELECT
         CLIENT,
         bukrs,
         anln1,
         anln2,
         afabe,
         SUM(kansw) + SUM(kaufw) AS kansw,
         SUM(kaufw) AS kaufw,
         SUM(knafa) AS knafa,
         SUM(kaafa) AS kaafa,
         SUM(kaufn) AS kaufn,
         SUM(kansw) + SUM(kaufw) + SUM(knafa) +  SUM(kaafa) +  SUM(kaufn) AS netvl
       FROM (
         -- выборка значений на начало года
         SELECT
              anlc.mandt AS CLIENT,
              anlc.bukrs AS bukrs,
              anlc.anln1 AS anln1,
              anlc.anln2 AS anln2,
              anlc.afabe AS afabe,
              anlc.kansw AS kansw,
              anlc.kaufw,
              anlc.knafa,
              anlc.kaafa,
              anlc.kaufn
           FROM faav_anlc AS anlc LEFT JOIN :lt_budat ON  :lt_budat.bukrs = anlc.bukrs
                                                     AND  :lt_budat.anln1 = anlc.anln1
                                                     AND  :lt_budat.anln2 = anlc.anln2
           WHERE anlc.mandt = :p_clnt
             AND anlc.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat )
                                   ELSE :lv_gjahr
                               END
         UNION ALL
          -- выборка движений стоимости и износа с начала года до отчетной даты
         SELECT
             anep.mandt AS mandt,
             anep.bukrs AS bukrs,
             anep.anln1 AS anln1,
             anep.anln2 AS anln2,
             anep.afabe AS afabe,
             anep.anbtr AS kansw,
             anea.aufwv + anea.aufwl AS kaufw,
             anea.nafav + anea.nafal AS knafa,
             anea.aafav + anea.aafal AS kaafa,
             anea.aufnv + anea.aufnl AS kaufn
           FROM faav_anep AS anep
             INNER JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                         AND anek.bukrs = anep.bukrs
                                         AND anek.anln1 = anep.anln1
                                         AND anek.anln2 = anep.anln2
                                         AND anek.gjahr = anep.gjahr
                                         AND anek.lnran = anep.lnran
             LEFT JOIN :lt_budat ON   :lt_budat.bukrs = anek.bukrs
                                 AND  :lt_budat.anln1 = anek.anln1
                                 AND  :lt_budat.anln2 = anek.anln2
             INNER JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                                     AND tabw.bwasl = anep.bwasl
             INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                     AND tabwg.bwagrp = tabw.bwagrp
                                     AND tabwg.bwatyp <> '4'
             LEFT OUTER JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                               AND anea.bukrs = anep.bukrs
                                               AND anea.anln1 = anep.anln1
                                               AND anea.anln2 = anep.anln2
                                               AND anea.gjahr = anep.gjahr
                                               AND anea.afabe = anep.afabe
                                               AND anea.lnran = anep.lnran
                                               AND anea.zucod = anep.zucod
           WHERE anep.mandt = :p_clnt
             AND anep.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
             AND (     :p_amnt =  'X'  AND anek.budat <= :lt_budat.budat
                   OR  :p_amnt <> 'X'  AND anek.budat <= :p_date )
            -- AND anep.augln = '00000' ak_butvilovs #23851 "ZFI_STOCK_ASSETS-Неправильная первоначальная стоимость"
         UNION ALL
          -- выборка амортизации с начала года до отчетного месяца
         SELECT
             anlp.mandt AS mandt,
             anlp.bukrs AS bukrs,
             anlp.anln1 AS anln1,
             anlp.anln2 AS anln2,
             anlp.afaber AS afabe,
             0           AS kansw,
             0           AS kaufw ,
             anlp.nafaz AS knafa,
             anlp.aafaz AS kaafa,
             anlp.aufng AS kaufn
           FROM faav_anlp AS anlp
             LEFT JOIN :lt_budat ON :lt_budat.bukrs = anlp.bukrs
                                AND :lt_budat.anln1 = anlp.anln1
                                AND :lt_budat.anln2 = anlp.anln2
           WHERE anlp.mandt = :p_clnt
             AND anlp.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
             AND anlp.peraf <= CASE WHEN :p_amnt = 'X' THEN month( :lt_budat.budat ) ELSE :lv_peraf END
       ) GROUP BY CLIENT, bukrs, anln1, anln2, afabe;

     lt_ts = select * from :lt_ts union select 'LT_RET' as point, current_utctimestamp as timestamp from dummy;

       RETURN :lt_ret;
  ENDMETHOD.

  METHOD get_asset_val_ng
   BY DATABASE FUNCTION FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING faav_anlc tabw
         faav_anep faav_anek faav_anea
         faav_anlp anla tabwg.

    RETURN
    -- формирование итоговых строк разрезе ос и области оценки
        -- выборка значений на начало года
        SELECT
             anlc.mandt AS CLIENT,
             anlc.bukrs AS bukrs,
             anlc.anln1 AS anln1,
             anlc.anln2 AS anln2,
             anlc.afabe AS afabe,
             anla.invnr AS invnr,
             anla.deakt AS deakt,
             (anlc.gjahr || '0000') AS budat,
             ' ' AS bwasl,
             anlc.kansw + anlc.kaufw as kansw,
             anlc.kaufw,
             anlc.knafa,
             anlc.kaafa,
             anlc.kaufn,
             kansw + kaufw + knafa + kaafa + kaufn AS netvl,
             '00000' AS lnran,
             '00000' AS lnsan,
             '00' AS monat,
             '' AS belnr
          FROM faav_anlc AS anlc
            INNER JOIN anla AS anla ON  anla.mandt = anlc.mandt
                                    AND anla.bukrs = anlc.bukrs
                                    AND anla.anln1 = anlc.anln1
                                    AND anla.anln2 = anlc.anln2
          WHERE anlc.mandt = :p_clnt
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            anep.mandt AS CLIENT,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anla.invnr AS invnr,
            anla.deakt AS deakt,
            anek.budat,
            anep.bwasl,
            anep.anbtr + COALESCE(anea.aufwv, 0) + COALESCE(anea.aufwl, 0) AS kansw,
            COALESCE(anea.aufwv, 0) + COALESCE(anea.aufwl, 0) AS kaufw,
            COALESCE(anea.nafav, 0) + COALESCE(anea.nafal,0) AS knafa,
            COALESCE(anea.aafav, 0) + COALESCE(anea.aafal,0) AS kaafa,
            COALESCE(anea.aufnv, 0) + COALESCE(anea.aufnl, 0)AS kaufn,
            anep.anbtr + COALESCE(anea.aufwv, 0) + COALESCE(anea.aufwl, 0) + COALESCE(anea.nafav, 0) + COALESCE(anea.aafav, 0)
            + COALESCE(anea.nafal, 0) + COALESCE(anea.aafal, 0)
            + COALESCE(anea.aufnv, 0) AS netvl,
            anep.lnran,
            anep.lnsan,
            anek.monat,
            anep.belnr
          FROM faav_anep AS anep
            INNER JOIN anla AS anla ON  anla.mandt = anep.mandt
                                    AND anla.bukrs = anep.bukrs
                                    AND anla.anln1 = anep.anln1
                                    AND anla.anln2 = anep.anln2
            INNER JOIN faav_anek AS anek ON  anek.mandt = anep.mandt
                                         AND anek.bukrs = anep.bukrs
                                         AND anek.anln1 = anep.anln1
                                         AND anek.anln2 = anep.anln2
                                         AND anek.gjahr = anep.gjahr
                                         AND anek.lnran = anep.lnran
            INNER JOIN tabw AS tabw ON  tabw.mandt = anep.mandt
                                    AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'
            LEFT OUTER JOIN faav_anea AS anea ON   anea.bukrs = anep.bukrs
                                              AND anea.mandt = anep.mandt
                                              AND anea.anln1 = anep.anln1
                                              AND anea.anln2 = anep.anln2
                                              AND anea.gjahr = anep.gjahr
                                              AND anea.afabe = anep.afabe
                                              AND anea.lnran = anep.lnran
                                              AND anea.zucod = anep.zucod
          WHERE anep.mandt = :p_clnt
        UNION ALL

         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            anlp.mandt AS CLIENT,
            anlp.bukrs AS bukrs,
            anlp.anln1 AS anln1,
            anlp.anln2 AS anln2,
            anlp.afaber AS afabe,
            anla.invnr AS invnr,
            anla.deakt AS deakt,
            to_dats(last_day(anlp.gjahr || RIGHT (anlp.peraf,2) || '01')) AS budat,
            ' '        AS bwasl,
            0          AS kansw,
            0          AS kaufw ,
            SUM(anlp.nafaz) AS knafa,
            SUM(anlp.aafaz) AS kaafa,
            SUM(anlp.aufng) AS kaufn,
            SUM(anlp.nafaz + anlp.aafaz + anlp.aufng) AS netvl,
            '00000' AS lnran,
            '00000' AS lnsan,
            RIGHT(anlp.peraf,2) AS monat,
            '' AS belnr
-- --> ak_butvilovs #8000001276, аморт. ос в ведом.распред. амортизации
--         FROM faav_anlp AS anlp
            FROM ( SELECT mandt,
                          bukrs,
                          anln1,
                          anln2,
                          nafaz,
                          safaz,
                          aufng,
                          afbnr,
                          aafaz,
                          afaber,
                          gjahr,
-- --> ak_butvilovs #8000001319, дамп zfi_assets_move, zfi_amort_turn
                          -- peraf,
                          CASE WHEN peraf = '000'
                               THEN '001'
                               ELSE peraf
                          END AS peraf,
-- <-- ak_butvilovs #8000001319
                          MIN( kostl ) FROM faav_anlp
                     GROUP BY mandt, bukrs, anln1, anln2, nafaz, aufng, safaz, afbnr, aafaz, afaber, gjahr, peraf ) AS anlp
-- <-- ak_butvilovs #8000001276;
            INNER JOIN anla AS anla ON  anla.mandt = anlp.mandt
                                    AND anla.bukrs = anlp.bukrs
                                    AND anla.anln1 = anlp.anln1
                                    AND anla.anln2 = anlp.anln2
          WHERE anlp.mandt = :p_clnt
            group by
              anlp.mandt,
              anlp.bukrs,
              anlp.anln1,
              anlp.anln2,
              anlp.afaber,
              anla.invnr,
              anla.deakt,
              to_dats(last_day(anlp.gjahr || RIGHT (anlp.peraf,2) || '01')) ,
              anlp.peraf

      ;
  ENDMETHOD.

  METHOD get_asset_amort_st
   BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
    OPTIONS READ-ONLY
          USING faav_anlc faav_anep faav_anek faav_anlp tabw
                zrevdate faav_anek setleaf t093c anla tabwg faav_anea.

    declare lv_mandt char(3) := session_context( 'CLIENT' );

    lt_ts = SELECT 'Start' AS point, current_utctimestamp as timestamp from dummy;

     lt_dates_all =               /*выборка возможных дат расчета амортизируемой стоимости */
       SELECT anla.invnr,
              anla.anln1,
              anla.anln2,
              t093c.datum,                                                  /*дата загрузки*/
              greatest( t093c.datum,                                        /*дата загрузки*/
                        anla.aktiv,                                         /*дата оприходования*/
                                                                            /*дата переоценки*/
                       ( SELECT to_dats( COALESCE ( MAX( vallast ), '00000000' ) )
                           FROM zrevdate
                          WHERE mandt = :lv_mandt
                            AND invnr = anla.invnr
                            and vallast < it.budat ) ,
                                                                           /*дата проводки*/
                       ( SELECT to_dats( COALESCE ( MAX( anek.budat ), '00000000' ) )
                           FROM faav_anep
                           JOIN faav_anek AS anek ON anek.mandt = faav_anep.mandt
                                                 and anek.bukrs = faav_anep.bukrs
                                                 and anek.anln1 = faav_anep.anln1
                                                 and anek.anln2 = faav_anep.anln2
                                                 and anek.lnran = faav_anep.lnran
                          where faav_anep.mandt = :lv_mandt
                            AND faav_anep.bukrs = it.bukrs
                            and faav_anep.anln1 = it.anln1
                            and faav_anep.anln2 = it.anln2
                            and faav_anep.afabe = '01'
                            AND faav_anep.bwasl in ( select valfrom
                                                       from setleaf
                                                      where setclass = '0000'
                                                        and subclass = ''
                                                        and setname  = 'Z_TTYPE_AMORT' )
                           and  anek.budat <= it.budat ) ) as budat,
          it.budat as rep_date
          from :it_am_st as it
            inner join anla as anla on anla.mandt = :lv_mandt
                                   AND anla.bukrs = it.bukrs
                                   and anla.anln1 = it.anln1
                                   and anla.anln2 = it.anln2
                                   and anla.zugdt <= it.budat
            inner join t093c as t093c on t093c.mandt = :lv_mandt
                                     AND t093c.bukrs = it.bukrs ;

    lt_ts = select * from :lt_ts union select 'LT_DATES_ALL' as point, current_utctimestamp as timestamp from dummy;

    /*определение наибольшей даты для инв номера и признака , это дата загрузки или нет*/
    lt_date_last =
      select invnr,
             anln2,
             budat,
             case when lead(invnr) over (partition BY invnr ORDER BY budat) IS NULL THEN 'X' ELSE '' END AS max_date,
             case when budat = datum then 'X' else '' end as load,
             rep_date
             from :lt_dates_all;

    lt_ts = select * from :lt_ts union select 'LT_DATE_LAST' as point, current_utctimestamp as timestamp from dummy;

    lt_date_last = select * from :lt_date_last where max_date = 'X';

    lt_ts = select * from :lt_ts union select 'LT_DATE_LAST2' as point, current_utctimestamp as timestamp from dummy;

    lt_ret =
    -- формирование аморт стоим по инв №
    SELECT
        invnr AS invnr,
        anln2,
        sum(netvl) as netvl
      from (
        -- выборка значений на начало года
        SELECT
             anla.invnr as invnr,
             anlc.mandt as client,
             anlc.bukrs as bukrs,
             anlc.anln1 as anln1,
             anlc.anln2 as anln2,
             anlc.afabe as afabe,
             anlc.kansw + anlc.kaufw + anlc.knafa +  anlc.kaafa + anlc.kaufn
             + case when ld.load = 'X' THEN anlc.answl else 0.00 END
             + CASE WHEN ld.LOAD = 'X' THEN anlc.nafav ELSE 0.00 END
             + CASE WHEN ld.LOAD = 'X' THEN anlc.safav ELSE 0.00 END AS netvl

          FROM anla
          JOIN :lt_date_last as ld ON ld.invnr = anla.invnr
                                  AND ld.anln2 = anla.anln2
                                  AND  ( anla.deakt >= ld.budat OR anla.deakt < '19000101' )
          JOIN faav_anlc AS anlc ON anla.bukrs = anlc.bukrs
                                AND anla.anln1 = anlc.anln1
                                AND anla.anln2 = anlc.anln2
                                AND anlc.afabe = '01'
                                AND anlc.mandt = :lv_mandt
                                AND anlc.gjahr =  year( ld.budat )
          WHERE anla.mandt = :lv_mandt

        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            ld.invnr AS invnr,
            anep.mandt AS mandt,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anep.anbtr
            + COALESCE( anea.aufwv, 0 ) + COALESCE( anea.aufwl, 0 )
            + COALESCE( anea.nafav, 0 ) + COALESCE( anea.nafal, 0 )
            + COALESCE( anea.aafav, 0 ) + COALESCE( anea.aafal, 0 )
            + COALESCE( anea.aufnv, 0 ) + COALESCE( anea.aufnl, 0 )  AS netvl

          FROM faav_anep AS anep
            JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                  AND anek.bukrs = anep.bukrs
                                  AND anek.anln1 = anep.anln1
                                  AND anek.anln2 = anep.anln2
                                  AND anek.gjahr = anep.gjahr
                                  AND anek.lnran = anep.lnran
            JOIN anla ON anla.mandt = anek.mandt
                     AND anla.bukrs = anek.bukrs
                     AND anla.anln1 = anek.anln1
                     AND anla.anln2 = anek.anln2

            JOIN :lt_date_last as ld ON ld.invnr = anla.invnr
                                    AND ld.anln2 = anla.anln2
                                    AND  ( anla.deakt >= ld.budat OR anla.deakt < '19000101' )
            JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                             AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'

            LEFT JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                        AND anea.bukrs = anep.bukrs
                                        AND anea.anln1 = anep.anln1
                                        AND anea.anln2 = anep.anln2
                                        AND anea.gjahr = anep.gjahr
                                        AND anea.afabe = anep.afabe
                                        AND anea.lnran = anep.lnran
                                        AND anea.zucod = anep.zucod

          WHERE anep.mandt = :lv_mandt
            AND anep.gjahr =  year ( ld.budat )
            AND anep.afabe = '01'
            AND anek.budat <= ld.budat
            AND year ( anek.budat ) = year ( ld.budat )

        UNION ALL
         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            ld.invnr AS invnr,
            anlp.mandt AS mandt,
            anlp.bukrs AS bukrs,
            anlp.anln1 AS anln1,
            anlp.anln2 AS anln2,
            anlp.afaber AS afabe,
            anlp.nafaz + anlp.aafaz +  anlp.aufng  as netvl

          FROM faav_anlp AS anlp
            JOIN anla ON anla.mandt = anlp.mandt
                     AND anla.bukrs = anlp.bukrs
                     AND anla.anln1 = anlp.anln1
                     AND anla.anln2 = anlp.anln2

            JOIN :lt_date_last AS ld  ON ld.invnr = anla.invnr
                              AND ld.anln2 = anla.anln2
                              AND  ( anla.deakt >= ld.budat OR anla.deakt < '19000101' )
          WHERE anlp.mandt = :lv_mandt
            AND anlp.afaber = '01'
            AND anlp.gjahr = year ( ld.budat )
            AND RIGHT( anlp.peraf, 2 ) <= month( ld.budat )
      )
        GROUP BY invnr, anln2;

    lt_ts = select * from :lt_ts union select 'LT_RET' as point, current_utctimestamp as timestamp from dummy;


    et_am_st =
    SELECT
        it.bukrs,
        it.anln1,
        it.anln2,
        it.budat,
        ret.netvl
     FROM :it_am_st AS it
       JOIN anla ON  anla.mandt = :lv_mandt
                 AND anla.bukrs = it.bukrs
                 AND anla.anln1 = it.anln1
                 AND anla.anln2 = it.anln2
       JOIN :lt_ret AS ret ON anla.invnr = ret.invnr
                          AND anla.anln2 = ret.anln2;

     lt_ts = select * from :lt_ts union select 'ET_AM_ST' as point, current_utctimestamp as timestamp from dummy;
  ENDMETHOD.

  METHOD get_spp_hist
        BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
        USING acdoca zfiaa_expense zfi_ifrs_inf_t.
    declare lv_mandt char( 3);
    lv_mandt = session_context( 'CLIENT' );
    et_hist =
      SELECT
          :lv_mandt AS mandt,
          :iv_invnr AS invnr,
          :iv_budat AS adatu,
          acd.typez,
          datum,
          CASE when inf = 'X' then :iv_budat END as inf_date,
          '99991231' as bdatu,
          acd.active,
          hsl as amount,
          CAST (0 as dec( 13,2) ) as inf_cpi,
          '00000000' as deval_date,
          cast( 0 as decimal( 13,2) ) as deval_amount,
          :iv_budat as aktiv,
          '0000000001' as hkont,
          '' as lifnr
        from
            ( SELECT
                 SUM(-hsl) AS hsl,
                 CASE when coalesce(b_inf.bwasl, '') = '' then '' ELSE 'X' END as inf,
                 substr( ac.racct,7,2 ) as typez,
                 exp.active,
                 left(ac.budat,6) || '01' as datum
                 from acdoca as ac   left join zfiaa_expense as exp ON  exp.mandt = :lv_mandt
                                                                   and exp.typez = substr( racct,7,2 )
                                     left join zfi_ifrs_inf_t as b_inf ON b_inf.mandt = ac.rclnt
                                                                     and  b_inf.bwasl = ac.anbwa
                   where ac.rclnt = :lv_mandt
                     and ac.bldat <= :iv_budat
                     and ac.gkont like '08%'
                     and ps_psp_pnr = :iv_posnr
                   group by b_inf.bwasl, substr( ac.racct,7,2 ), exp.active ,ps_psp_pnr, left(ac.budat,6) || '01' ) as acd
       ;
  ENDMETHOD.

  METHOD get_asset_spi_ondate
       BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
       USING anlb anlbza faav_anlc anlz anla.
    declare lv_mandt CHAR( 3) := session_context( 'CLIENT' );
    declare lv_mindate CHAR( 8 );
    declare lv_maxdate CHAR( 8 );
    declare lv_day int := 0;
    SELECT MIN( budat ), MAX( budat )
      INTO lv_mindate, lv_maxdate
      FROM :it_data;
   lv_mindate := LEFT( :lv_mindate,4 ) || '0101';
    /*таблица последних дней месяцев с начала года по отчетную дату*/
    ld =
        SELECT to_dats(add_days(generated_period_end,-1)) AS ld
          FROM series_generate_date('INTERVAL 1 MONTH', :lv_mindate, add_days(last_day(:lv_maxdate),1) )
        ;
   IF :iv_ex_curper = 'X'
     THEN lv_day = -1;
   END if;
   /*подсчет месяцев с начала года до даты расчета */
   lt_year_usep =
      SELECT aa.bukrs,
             aa.anln1,
             aa.anln2,
             aa.afabe,
             aa.budat,
             COUNT( per.ld ) AS per
        FROM :it_data AS  aa
          JOIN :ld AS per ON year(per.ld) = year( aa.budat )
                          AND  per.ld <= to_dats(add_days(last_day( aa.budat ),lv_day))
          JOIN anlz AS az ON az.adatu <= per.ld
                           AND az.bdatu >= per.ld
                           AND az.mandt =  :lv_mandt
                           AND az.bukrs =  aa.bukrs
                           AND az.anln1 =  aa.anln1
                           AND az.anln2 =  aa.anln2
          JOIN anlb AS ab ON az.mandt =  ab.mandt
                   AND aa.bukrs =  ab.bukrs
                   AND aa.anln1 =  ab.anln1
                   AND aa.anln2 =  ab.anln2
                   AND per.ld    >=  ab.afabg
                   AND ab.afabe = aa.afabe
                WHERE az.mandt =  :lv_mandt
                  AND ab.afabg <= aa.budat
                  AND az.xstil = ''
                GROUP BY aa.bukrs,
                     aa.anln1,
                     aa.anln2,
                     aa.afabe,
                     aa.budat;
    lt_data =
      SELECT aa.budat,
             anlb.bukrs,
             anlb.anln1,
             anlb.anln2,
             anlb.afabe,
             anlb.afabg,
             COALESCE(aza.afasl,anlb.afasl) AS afasl,
             COALESCE(aza.ndper,anlb.ndper) AS ndper,
             COALESCE(aza.ndjar,anlb.ndjar) AS ndjar,
             CASE WHEN aa.budat < anla.aktiv THEN 0 ELSE COALESCE(aza.ndper,anlb.ndper) + COALESCE(aza.ndjar,anlb.ndjar) *12 END AS spi_per,
             CASE WHEN aa.budat < anla.aktiv THEN 0 ELSE anlc.ndabp + anlc.ndabj * 12 + COALESCE(per.per,0) END AS use_per
        FROM anlb AS anlb
          JOIN :it_data AS  aa ON aa.bukrs =  anlb.bukrs
                              AND aa.anln1 =  anlb.anln1
                              AND aa.anln2 =  anlb.anln2
                              AND aa.afabe =  anlb.afabe
          JOIN anla AS anla ON  anla.mandt =  anlb.mandt
                            AND anla.bukrs =  anlb.bukrs
                            AND anla.anln1 =  anlb.anln1
                            AND anla.anln2 =  anlb.anln2

          LEFT OUTER JOIN anlbza AS aza ON  aza.mandt =  anlb.mandt
                                        AND aza.bukrs =  anlb.bukrs
                                        AND aza.anln1 =  anlb.anln1
                                        AND aza.anln2 =  anlb.anln2
                                        AND aza.afabe =  anlb.afabe
                                        AND aza.bdatu >= aa.budat
                                        AND aza.adatu <= aa.budat
          LEFT OUTER JOIN faav_anlc AS anlc ON  anlc.mandt =  anlb.mandt
                                             AND anlc.bukrs =  anlb.bukrs
                                             AND anlc.anln1 =  anlb.anln1
                                             AND anlc.anln2 =  anlb.anln2
                                             AND anlc.afabe =  anlb.afabe
                                             AND anlc.gjahr =  LEFT(aa.budat,4)
          LEFT OUTER JOIN
/*            ( SELECT az.bukrs,
                     az.anln1,
                     az.anln2,
                     ab.afabe,
                     SUM( month (least(az.bdatu, aa.budat, LEFT(aa.budat,4) || '1231' ))
                           - month( greatest(ab.afabg, LEFT(aa.budat,4) || '0101' ,az.adatu) ) + 1 )
                     AS per
                FROM anlz AS az
                  JOIN anlb AS ab ON az.mandt =  ab.mandt
                           AND az.bukrs =  ab.bukrs
                           AND az.anln1 =  ab.anln1
                           AND az.anln2 =  ab.anln2
                  JOIN :it_data AS  aa ON aa.bukrs =   ab.bukrs
                                       AND aa.anln1 =  ab.anln1
                                       AND aa.anln2 =  ab.anln2
                                       AND aa.afabe =  ab.afabe

                WHERE az.mandt =  :lv_mandt
                  AND az.bdatu >= LEFT(aa.budat,4) || '0101'
                  AND az.adatu <= aa.budat
                  AND ab.afabg <= aa.budat
                  AND az.xstil = ''
                GROUP BY az.bukrs,
                     az.anln1,
                     az.anln2,
                     ab.afabe) */

           :lt_year_usep AS per ON per.bukrs =  aa.bukrs
                            AND per.anln1 =  aa.anln1
                            AND per.anln2 =  aa.anln2
                            AND per.afabe =  aa.afabe
                            AND per.budat =  aa.budat
          WHERE anlb.mandt = :lv_mandt
     ;
     et_data =
      SELECT budat,
             bukrs,
             anln1,
             anln2,
             afabe,
             afabg,
             afasl,
             ndper,
             ndjar,
             MOD(use_per ,12) AS usep,
             FLOOR(( use_per  )/ 12) AS usej,
             CASE WHEN spi_per < use_per THEN 0
                  ELSE MOD( (spi_per-use_per  ),12) END AS restp,
             CASE WHEN spi_per < use_per THEN 0
                  ELSE FLOOR( (spi_per-use_per  )/12) END AS restj
       FROM
         :lt_data;
  ENDMETHOD.

  METHOD fill_dm_nmove
        BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
        USING zfi_drag_moveh.
    et_movh =
    select
        it.mandt,
        it.bukrs,
        it.anln1,
        it.anln2,
        it.date_move,
        lpad( ( select coalesce ( max( nmove ), 0) + 1
          FROM zfi_drag_moveh
          WHERE mandt      = session_context( 'CLIENT')
            AND bukrs      = it.bukrs
            and anln1      = it.anln1
            and anln2      = it.anln2
            and date_move  = it.date_move ), 2, 0 )
        as nmove,
        it.invnr,
        it.avt_man,
        it.acq_ret,
        it.bwasl_a,
        it.bwasl_m,
        it.text,
        it.werks,
        it.lgort,
        it.matnr, --8000000137, карточка нкс-учет драгметалов
        it.menge, --8000000137, карточка нкс-учет драгметалов
        it.meins, --8000000137, карточка нкс-учет драгметалов
        it.belnr,
        it.stblg,
        it.stjah,
        it.usnam,
        it.bldat,
        it.cputm
      from :it_movh as it;
  ENDMETHOD.

  METHOD fill_dm_on_move
        BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT
        USING anla zaa_real_values tabw tabwg zfi_drag_movei zfi_drag_moveh zanlu.
    declare lv_mandt char( 3) := session_context( 'CLIENT' );
    --выборка данных по ос
    et_asset =
    SELECT
        in_aa.bukrs,
        in_aa.anln1,
        in_aa.anln2,
        in_aa.mv_val,
        in_aa.storn,
        in_aa.bwasl,
        tabwg.gitcol,
        anla.invnr,
        val.kansw as aa_val,
        in_aa.pbukr,
        in_aa.panl1,
        in_aa.panl2,
        in_aa.sgtxt,
        anla.xinvm as xinvm,
        panl.xinvm as pxinv
      from :it_asset as in_aa
        inner join anla as anla on anla.mandt = :lv_mandt
                               AND anla.anln1 = in_aa.anln1
                               and anla.anln2 = in_aa.anln2
                               and anla.bukrs = in_aa.bukrs
                               and anla.xinvm = ''   --8000000137, карточка нкс-учет драгметалов
        LEFT JOIN anla AS panl  ON  panl.mandt = :lv_mandt
                               AND panl.anln1 = in_aa.panl1
                               and panl.anln2 = in_aa.panl2
                               and panl.bukrs = in_aa.pbukr
                               and panl.anln2 <> ''
        inner join zanlu as zanlu on zanlu.mandt = anla.mandt
                                 and zanlu.invnr = anla.invnr
                                 and zanlu.dmdkflag = 'X'

        LEFT JOIN tabw AS tabw ON tabw.mandt = :lv_mandt
                              AND tabw.bwasl = in_aa.bwasl
        left join tabwg as tabwg on tabwg.mandt = :lv_mandt
                                AND tabwg.bwagrp = tabw.bwagrp
        left join zaa_real_values( :iv_budat ) as val on  val.bukrs = anla.bukrs
                                                     and val.anln1 = anla.anln1
                                                     and val.anln2 = anla.anln2
                                                     and val.rclnt = :lv_mandt
                                                     AND val.afabe = '01';
     IF is_empty ( :et_asset ) THEN
         return;
     END if;
     et_movi =
     SELECT
         movi.mandt,
         movi.bukrs,
         movi.anln1,
         movi.anln2,
         '' AS date_move,
         '' AS nmove,
         movi.kod_mk,
         movi.pasp_kom,
         sum( case when movh.acq_ret = '1' THEN movi.weight else - movi.weight end ) as weight
       from zfi_drag_movei as movi
         inner join zfi_drag_moveh as movh on movh.mandt     = movi.mandt
                                          and movh.bukrs     = movi.bukrs
                                          and movh.anln1     = movi.anln1
                                          and movh.anln2     = movi.anln2
                                          and movh.date_move = movi.date_move
                                          and movh.nmove     = movi.nmove
         inner join :et_asset as lt on  lt.bukrs    = movi.bukrs
                                   and lt.anln1     = movi.anln1
                                   and lt.anln2     = movi.anln2
                                   and lt.gitcol    in ( '2' , '4' )
       where movh.mandt = :lv_mandt
         AND movh.date_move <= :iv_budat
         and movh.stblg = ''
       GROUP BY movi.mandt,
                movi.bukrs,
                movi.anln1,
                movi.anln2,
                movi.kod_mk,
                movi.pasp_kom
       order by movi.bukrs,
                movi.anln1,
                movi.anln2  ;
  ENDMETHOD.

  METHOD get_asset_values
   BY DATABASE FUNCTION FOR HDB LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING faav_anlc faav_anep faav_anek faav_anea faav_anlp tabw tabwg.
    declare lv_gjahr CHAR(4) := LEFT( :p_date, 4 );
    declare lv_peraf CHAR(3) := LPAD(month( :p_date ), 3, '0' );

*    IF RIGHT( :P_DATE, 4 ) = '0101' THEN
*       LV_GJAHR = LV_GJAHR - 1;
*       LV_PERAF = '013';
*    END IF;

    -- если указан параметр амортизируемая стоимость, то для каждого ос определяется дата последней проводки по ос
    IF :p_amnt = 'X' THEN
      lt_budat =
        SELECT bukrs, anln1, anln2,  MAX( budat )  AS budat
          FROM faav_anek
          WHERE budat <= :p_date
            AND mandt = :p_clnt
          GROUP BY bukrs, anln1, anln2 ;
    ELSE
      lt_budat =
        SELECT '' bukrs, '' anln1, '' anln2, '' budat FROM dummy;
    END if;

    lt_ret =
    -- формирование итоговых строк разрезе ос и области оценки
    SELECT
        CLIENT,
        bukrs,
        anln1,
        anln2,
        afabe,
        SUM(kansw) + SUM(kaufw) AS kansw,
        SUM(kaufw) AS kaufw,
        SUM(knafa) AS knafa,
        SUM(kaafa) AS kaafa,
        SUM(kaufn) AS kaufn,
        SUM(kansw) + SUM(kaufw) + SUM(knafa) +  SUM(kaafa) +  SUM(kaufn) AS netvl
      FROM (
        -- выборка значений на начало года
        SELECT
             anlc.mandt AS CLIENT,
             anlc.bukrs AS bukrs,
             anlc.anln1 AS anln1,
             anlc.anln2 AS anln2,
             anlc.afabe AS afabe,
             anlc.kansw AS kansw,
             anlc.kaufw,
             anlc.knafa,
             anlc.kaafa,
             anlc.kaufn
          FROM faav_anlc AS anlc LEFT JOIN :lt_budat ON  :lt_budat.bukrs = anlc.bukrs
                                                    AND  :lt_budat.anln1 = anlc.anln1
                                                    AND  :lt_budat.anln2 = anlc.anln2
          WHERE anlc.mandt = :p_clnt
            AND anlc.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat )
                                  ELSE :lv_gjahr
                              END
        UNION ALL
         -- выборка движений стоимости и износа с начала года до отчетной даты
        SELECT
            anep.mandt AS mandt,
            anep.bukrs AS bukrs,
            anep.anln1 AS anln1,
            anep.anln2 AS anln2,
            anep.afabe AS afabe,
            anep.anbtr AS kansw,
            anea.aufwv + anea.aufwl AS kaufw,
            anea.nafav + anea.nafal AS knafa,
            anea.aafav + anea.aafal AS kaafa,
            anea.aufnv + anea.aufnl AS kaufn
          FROM faav_anep AS anep
            INNER JOIN faav_anek AS anek ON anek.mandt = anep.mandt
                                        AND anek.bukrs = anep.bukrs
                                        AND anek.anln1 = anep.anln1
                                        AND anek.anln2 = anep.anln2
                                        AND anek.gjahr = anep.gjahr
                                        AND anek.lnran = anep.lnran
            LEFT JOIN :lt_budat ON   :lt_budat.bukrs = anek.bukrs
                                AND  :lt_budat.anln1 = anek.anln1
                                AND  :lt_budat.anln2 = anek.anln2
            INNER JOIN tabw AS tabw ON tabw.mandt = anep.mandt
                                    AND tabw.bwasl = anep.bwasl
            INNER JOIN tabwg AS tabwg ON  tabwg.mandt = tabw.mandt
                                    AND tabwg.bwagrp = tabw.bwagrp
                                    AND tabwg.bwatyp <> '4'
            LEFT OUTER JOIN faav_anea AS anea ON  anea.mandt = anep.mandt
                                              AND anea.bukrs = anep.bukrs
                                              AND anea.anln1 = anep.anln1
                                              AND anea.anln2 = anep.anln2
                                              AND anea.gjahr = anep.gjahr
                                              AND anea.afabe = anep.afabe
                                              AND anea.lnran = anep.lnran
                                              AND anea.zucod = anep.zucod
          WHERE anep.mandt = :p_clnt
            AND anep.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
            AND (     :p_amnt =  'X'  AND anek.budat <= :lt_budat.budat
                  --OR  :p_amnt <> 'X'  AND anek.budat < :p_date )                -- del 22.04.2024 V.Lipskij #37710
                  OR  :p_amnt <> 'X'  AND anek.budat <= :p_date )                 -- ins 22.04.2024 V.Lipskij #37710
        UNION ALL
         -- выборка амортизации с начала года до отчетного месяца
        SELECT
            anlp.mandt  AS mandt,
            anlp.bukrs  AS bukrs,
            anlp.anln1  AS anln1,
            anlp.anln2  AS anln2,
            anlp.afaber AS afabe,
            0           AS kansw,
            0           AS kaufw ,
            anlp.nafaz  AS knafa,
            anlp.aafaz  AS kaafa,
            anlp.aufng  AS kaufn
-- --> ak_butvilovs #8000001276, аморт. ос в ведом.распред. амортизации
            FROM ( SELECT mandt,
                          bukrs,
                          anln1,
                          anln2,
                          afaber,
                          nafaz,
                          aafaz,
                          aufng,
                          gjahr,
                          peraf,
                          afbnr,
                          MIN( kostl ) FROM faav_anlp
                          WHERE mandt = :p_clnt
                          GROUP BY mandt, bukrs, anln1, anln2, afaber, nafaz, aafaz, aufng, gjahr, peraf, afbnr ) AS anlp
 --          FROM faav_anlp AS anlp
-- <-- ak_butvilovs #8000001276
            LEFT JOIN :lt_budat ON :lt_budat.bukrs = anlp.bukrs
                               AND :lt_budat.anln1 = anlp.anln1
                               AND :lt_budat.anln2 = anlp.anln2
-- --> ak_butvilovs #8000001276, аморт. ос в ведом.распред. амортизации
--          WHERE anlp.mandt = :p_clnt
--            AND anlp.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
            WHERE anlp.gjahr = CASE WHEN :p_amnt = 'X' THEN year ( :lt_budat.budat ) ELSE :lv_gjahr END
-- <-- ak_butvilovs #8000001276
            AND anlp.peraf < CASE WHEN :p_amnt = 'X' THEN month( :lt_budat.budat ) ELSE :lv_peraf END
 --          FROM faav_anlp AS anlp
      )
      GROUP BY CLIENT, bukrs,anln1,anln2,afabe
       ;
      RETURN :lt_ret;
  ENDMETHOD.
ENDCLASS.