class ZCL_IM_FAA_EE_CUSTOMER definition
  public
  final
  create public .

public section.

  interfaces IF_EX_FAA_EE_CUSTOMER .

  class-methods GET_LAST_MONTH_DAY
    importing
      !IV_DATE type D
    returning
      value(RV_DATE) type D .
  PROTECTED SECTION.
private section.

  types:
    BEGIN OF gty_s_zumo_vals,
      gjahr TYPE anlc-gjahr,
      afabe TYPE anep-afabe,
      monat TYPE anek-monat,
      stoim TYPE anep-anbtr,
      k_umo TYPE zaa_kumo-k_umo,
    END OF gty_s_zumo_vals .
  types:
    gty_t_zumo_vals TYPE SORTED TABLE OF gty_s_zumo_vals WITH UNIQUE KEY gjahr afabe monat .
  types:
    BEGIN OF gty_s_zumo,
      bukrs  TYPE anla-bukrs,
      anln1  TYPE anla-anln1,
      anln2  TYPE anla-anln2,
      last   TYPE gjahr,     "последний год расчета
      t_vals TYPE gty_t_zumo_vals,
    END OF gty_s_zumo .
  types:
    BEGIN OF gty_s_zumo_val,
      bukrs      TYPE anla-bukrs,
      anln1      TYPE anla-anln1,
      anln2      TYPE anla-anln2,
      afabe      TYPE anep-afabe,
      gjahr      TYPE anlc-gjahr,
      monat      TYPE anek-monat,
      stoim      TYPE anep-anbtr,
      rest_yr    TYPE p LENGTH 2 DECIMALS 2,
      newul      TYPE faa_dc_useful_life,
      amount     TYPE faa_ee_amount,
      ost_stoim  TYPE anep-anbtr,
      amount_sum TYPE anep-anbtr,
      k_umo      TYPE zaa_kumo-k_umo,
    END OF gty_s_zumo_val .
  types:
    gty_t_zumo_val TYPE SORTED TABLE OF  gty_s_zumo_val
      WITH UNIQUE KEY bukrs
                      anln1
                      anln2
                      afabe
                      gjahr
                      monat .
  types:
    gty_t_zumo TYPE SORTED TABLE OF  gty_s_zumo
        WITH UNIQUE KEY bukrs
                        anln1
                        anln2 .
  types:
    BEGIN OF gty_s_date,
      budat  TYPE d,              "дата действия
      period TYPE char6,
      ndper  TYPE ndper,
      ndjar  TYPE ndjar,
      cond   TYPE char1,
      mark   TYPE char1,
    END OF gty_s_date .
  types:
    gty_t_date TYPE STANDARD TABLE OF gty_s_date WITH DEFAULT KEY .
  types:
    BEGIN OF gty_s_zsum,
      bukrs  TYPE anla-bukrs,
      anln1  TYPE anla-anln1,
      anln2  TYPE anla-anln2,
      afabe  TYPE anep-afabe,
      t_date TYPE gty_t_date,
    END OF gty_s_zsum .
  types:
    gty_t_zsum TYPE SORTED TABLE OF  gty_s_zsum
        WITH UNIQUE KEY bukrs
                        anln1
                        anln2
                        afabe .
  types:
    BEGIN OF gty_s_anla,
      bukrs TYPE anla-bukrs,
      anln1 TYPE anla-anln1,
      anln2 TYPE anla-anln2,
      zugdt TYPE anla-zugdt,
      aktiv TYPE anla-aktiv,
      deakt TYPE anla-deakt,
    END OF gty_s_anla .
  types:
    gty_t_anla TYPE STANDARD TABLE OF gty_s_anla WITH DEFAULT KEY .
  types:
    BEGIN OF gty_s_spi,
      bukrs TYPE anla-bukrs,
      anln1 TYPE anla-anln1,
      anln2 TYPE anla-anln2,
      afabe TYPE anlbza-afabe,
      bdatu TYPE anlbza-bdatu,
      adatu TYPE anlbza-adatu,
      ndjar TYPE anlbza-ndjar,
      ndper TYPE anlbza-ndper,
    END OF gty_s_spi .
  types:
    gty_t_spi TYPE STANDARD TABLE OF gty_s_spi WITH DEFAULT KEY .

  class-data GT_ZUMO_VALS type GTY_T_ZUMO_VAL .
  class-data GT_ZUMO_PAR type GTY_T_ZUMO .
  data GT_Z_DATES type GTY_T_ZSUM .
  data GT_Z_VALS type GTY_T_ZUMO_VAL .
  data GV_INVNR type INVNR_ANLA .

  methods CALC_ZSUM_AMORT
    importing
      !IS_CALCDATA type FAA_EE_S_CALCDATA
      !IS_HELPSEG type FAA_DC_S_HLPSEG
    changing
      !CS_CALCDATA type FAA_EE_S_CALCDATA .
  methods CALC_ZLND_AMORT
    importing
      !IS_CALCDATA type FAA_EE_S_CALCDATA
    changing
      !CS_CALCDATA type FAA_EE_S_CALCDATA .
  methods CALC_ZPRD_AMORT
    importing
      !IS_CALCDATA type FAA_EE_S_CALCDATA
    changing
      !CS_CALCDATA type FAA_EE_S_CALCDATA .
  methods CALC_ZSES_AMORT
    importing
      !IS_CALCDATA type FAA_EE_S_CALCDATA
      !IS_HELPSEG type FAA_DC_S_HLPSEG
    changing
      !CS_CALCDATA type FAA_EE_S_CALCDATA .
  methods CALC_ZUMO_AMORT
    importing
      !IS_CALCDATA type FAA_EE_S_CALCDATA
      !IS_HELPSEG type FAA_DC_S_HLPSEG
    changing
      !CS_CALCDATA type FAA_EE_S_CALCDATA .
  methods CALC_ZOSM_AMORT
    importing
      !IS_CALCDATA type FAA_EE_S_CALCDATA
      !IS_HELPSEG type FAA_DC_S_HLPSEG
    changing
      !CS_CALCDATA type FAA_EE_S_CALCDATA .
  methods FILL_DATES
    importing
      !IV_BUKRS type ANLA-BUKRS
      !IV_ANLN1 type ANLA-ANLN1
      !IV_ANLN2 type ANLA-ANLN2
      !IV_AFABE type ANLB-AFABE
      !IV_DATE type ANEK-BUDAT
      !IV_AFASL type ANLB-AFASL
      !IV_USEFUL_LIFE type FAA_DC_USEFUL_LIFE
    changing
      !CV_OLD_USEFUL_LIFE type FAA_DC_USEFUL_LIFE .
  methods CHECK_OS
    importing
      !IV_BUKRS type ANLA-BUKRS
      !IV_ANLN1 type ANLA-ANLN1
      !IV_ANLN2 type ANLA-ANLN2
      !IV_DATE type ANEK-BUDAT
      !IV_AFASL type ANLB-AFASL
      !IV_USEFUL_LIFE type FAA_DC_USEFUL_LIFE
    exporting
      !ET_ANLA type GTY_T_ANLA
      !ET_SPI type GTY_T_SPI
      !EV_MOVE type BOOLEAN .
ENDCLASS.



CLASS ZCL_IM_FAA_EE_CUSTOMER IMPLEMENTATION.


  METHOD calc_zlnd_amort.
    " DEV.030-БНУ.13.E-293
    " Пользовательский расчет амортизации по дням (Начало) *
    DATA:
      ls_anlu      TYPE anlu,
      lv_days_m    TYPE i,
      lv_netamount TYPE anlc-kansw,
      lv_days_r    TYPE i, "осталось дней амортизации
      lv_sdate_m   TYPE d, "дата начала месяца
      lv_edate_m   TYPE d, "дата окончания месяца
      lv_sdate     TYPE d, "дата начала расчета за месяц
      lv_edate     TYPE d. "дата окончания расчета за месяц

    FIELD-SYMBOLS:
      <ls_anlu> TYPE anlu.
    lv_edate_m = lv_sdate_m = is_calcdata-fyear && is_calcdata-period_to+2(2) && '01'.
    " заполнение последнего дня месяца
    lv_edate_m = get_last_month_day( lv_sdate_m ).
    "выборка дат начала и окончания амортизации ОС
    ASSIGN ('(SAPLXAIS)ANLU') TO <ls_anlu>.
    IF sy-subrc = 0.
      ls_anlu = <ls_anlu>.
    ELSE.
      SELECT SINGLE  zzbegin, zzend
        FROM anlu
        INTO CORRESPONDING FIELDS OF @ls_anlu
        WHERE bukrs = @zcl_im_aa_dc_customer=>gv_asset_key-bukrs
          AND anln1 = @zcl_im_aa_dc_customer=>gv_asset_key-anln1
          AND anln2 = @zcl_im_aa_dc_customer=>gv_asset_key-anln2.
    ENDIF.
    IF ls_anlu-zzbegin < '19000101' OR ls_anlu-zzend < '19000101' . "не заданы сроки амортизации по дням
      RETURN.
    ENDIF.
    "определение кол-ва дней амортизации текущего месяца
    IF ls_anlu-zzend  < lv_sdate_m OR
       ls_anlu-zzbegin > lv_edate_m .
      RETURN.
    ENDIF.
    IF ls_anlu-zzbegin BETWEEN lv_sdate_m AND lv_edate_m.
      lv_sdate = ls_anlu-zzbegin.
    ELSE.
      lv_sdate = lv_sdate_m.
    ENDIF.
    IF ls_anlu-zzend BETWEEN lv_sdate_m AND lv_edate_m.
      lv_edate = ls_anlu-zzend.
    ELSE.
      lv_edate = lv_edate_m.
    ENDIF.
    lv_days_m = lv_edate - lv_sdate + 1.
    " определение остаточного срока ( дней ) амортизации
    lv_days_r = ls_anlu-zzend - lv_sdate + 1.

    IF lv_days_r <= 0 .
      RETURN.
    ENDIF.

    IF is_calcdata-netvalue = is_calcdata-basevalue."если не было расчета амортизации
      lv_netamount = is_calcdata-basevalue * ( 1 - ( lv_sdate - ls_anlu-zzbegin ) / ( ls_anlu-zzend - ls_anlu-zzbegin ) ).
    ELSE.
      lv_netamount = is_calcdata-netvalue.
    ENDIF.
    cs_calcdata-amount = is_calcdata-netvalue * lv_days_m / lv_days_r.


    " Пользовательский расчет амортизации пао дням  (Конец) *

  ENDMETHOD.


  METHOD calc_zosm_amort.
*  DEV.030-БНУ.07.E-011
*  АмНормаГод = 100 * 2 * ( СПИ - ОстСПИ + 1 ) / ( СПИ *( СПИ + 1 ))
*  СумАмМес = АмСт * АмНормаГод / 12.
*  АмСт - амортизируемая стоимость

    DATA: lr_res         TYPE REF TO data,
          lo_exc         TYPE REF TO cx_sql_exception,
          lv_amount      TYPE faa_ee_amount,
          lv_monat       TYPE anek-monat,
          lv_netvl       TYPE anlc-kansw,
          lv_amount_sum  TYPE anep-anbtr,
          lv_sdate       TYPE d,
          lv_edate       TYPE d,
          lv_last_date   TYPE d,   "дата последней амортизации
          lv_spi_rest    TYPE i,   "оставшийся срок СПИ периодах
          lv_spi_rest_yr TYPE p LENGTH 2 DECIMALS 2,  "оставшийся срок СПИ в годах
          lv_spi_zosm    TYPE p LENGTH 2 DECIMALS 2.

    " определение кол-ва оставшихся мес СПИ
    lv_spi_rest = is_helpseg-useful_life - ( is_calcdata-fyear - is_helpseg-start_yr ) * 12 -  is_calcdata-period_to+2(2) + is_helpseg-start_prd.
    lv_spi_rest_yr = lv_spi_rest / 12.
    DATA(lv_snyr) = round( val = is_helpseg-useful_life * ( is_helpseg-useful_life / 12 + 1 ) / 24 dec = 0 ).
    lv_sdate = is_calcdata-fyear && is_calcdata-period_to+2(2) && '01'.

    CALL FUNCTION 'MONTH_PLUS_DETERMINE'
      EXPORTING
        months  = '-1'
        olddate = lv_sdate
      IMPORTING
        newdate = lv_edate.

    CALL FUNCTION 'MONTH_PLUS_DETERMINE'
      EXPORTING
        months  = is_helpseg-useful_life - 1
        olddate = is_helpseg-start_date
      IMPORTING
        newdate = lv_last_date.

    check_os( EXPORTING iv_bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                        iv_anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                        iv_anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                        iv_afasl = is_helpseg-depr_key
                        iv_date = lv_last_date
                        iv_useful_life = is_helpseg-useful_life
              IMPORTING et_anla = DATA(lt_anla)
                        et_spi = DATA(lt_spi)
                        ev_move = DATA(lv_move) ).

    "первонач заполнение
    IF NOT line_exists( gt_z_vals[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                   anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                   anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                   afabe = CONV anlb-afabe( is_calcdata-area ) ] ).

      " АмСт = первоначальной стоимости
      IF lv_move = abap_true.
        ASSIGN lt_anla[ 1 ] TO FIELD-SYMBOL(<fs_anla>).
        CHECK <fs_anla> IS ASSIGNED.

        zaa_utils_hdb=>get_aa_vals( EXPORTING iv_date = get_last_month_day( lv_edate+0(6) && '01' )
                                              it_asset = VALUE #( ( bukrs = <fs_anla>-bukrs
                                                                    anln1 = <fs_anla>-anln1
                                                                    anln2 = <fs_anla>-anln2
                                                                    afabe = is_calcdata-area ) )
                                              iv_end_day = abap_true
                                    IMPORTING et_vals = DATA(lt_aa_stoim) ).

        IF lt_aa_stoim IS NOT INITIAL.
          lv_netvl = lt_aa_stoim[ 1 ]-netvl.
        ENDIF.

      ELSE.
        lv_netvl = is_calcdata-netvalue.
      ENDIF.

      DATA(lv_old_useful_life) = is_helpseg-useful_life.
      LOOP AT lt_spi ASSIGNING FIELD-SYMBOL(<ls_spi>) WHERE adatu = '19000101' AND afabe = CONV anlb-afabe( is_calcdata-area ).
        lv_old_useful_life = <ls_spi>-ndjar * 12 + <ls_spi>-ndper.
        EXIT.
      ENDLOOP.

      lv_spi_rest_yr = lv_old_useful_life / 12.
      lv_spi_zosm = lv_old_useful_life / 12.
      lv_snyr = round( val = lv_old_useful_life * ( lv_old_useful_life / 12 + 1 ) / 24 dec = 0 ).
      DATA(lv_year) = is_helpseg-start_yr.
      lv_monat = is_helpseg-start_prd.
      lv_amount_sum = 0.
      DATA(lv_ost_stoim_prev) = lv_netvl.
      DATA(lv_count) = lv_old_useful_life.

      WHILE lv_spi_rest_yr > 0 AND lv_count > 0.

        DO 12 TIMES.

          CHECK lv_count > 0.

          lv_amount = lv_netvl * ( lv_spi_zosm - lv_spi_rest_yr + 1 ) / lv_snyr / 12.

          IF lv_ost_stoim_prev = 0 OR lv_ost_stoim_prev < lv_amount.
            lv_amount = lv_ost_stoim_prev.                        " остаточная стоимость на конец предыдущего месяца
          ENDIF.

          lv_amount_sum = lv_amount_sum + lv_amount.

          IF lv_year = lv_last_date+0(4) AND lv_monat = lv_last_date+4(2).
            lv_amount = lv_ost_stoim_prev.                        " в последнем месяце СПИ должна списаться вся остаточная стоимость
          ENDIF.

          INSERT VALUE #(  bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                       anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                       anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                       gjahr = lv_year
                       monat = lv_monat
                       afabe = CONV anlb-afabe( is_calcdata-area )
                       stoim = lv_netvl                           " амортизируемая стоимость
                       rest_yr = lv_spi_rest_yr                   " осталось лет
                       newul = lv_snyr
                       amount = lv_amount                         " амортизация за период
*                       ost_stoim = lv_netvl - lv_amount_sum       " остаточная стоимость на конец месяца
                       ost_stoim = lv_ost_stoim_prev - lv_amount
                       amount_sum = lv_amount_sum )               " накопленная амортизация
            INTO TABLE gt_z_vals[].

          lv_ost_stoim_prev = lv_ost_stoim_prev - lv_amount.

          IF lv_monat = '12'.
            lv_monat = '01'.
            lv_year = lv_year + 1.
          ELSE.
            lv_monat = lv_monat + 1.
          ENDIF.
          lv_count = lv_count - 1.
        ENDDO.

        lv_spi_rest_yr = lv_spi_rest_yr - 1.

      ENDWHILE.

      IF lv_old_useful_life < is_helpseg-useful_life.

        DATA(lv_countt) = is_helpseg-useful_life - lv_old_useful_life.

        DO lv_countt TIMES.

          INSERT VALUE #(  bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                       anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                       anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                       gjahr = lv_year
                       monat = lv_monat
                       afabe = CONV anlb-afabe( is_calcdata-area ) ) INTO TABLE gt_z_vals[].

          IF lv_monat = '12'.
            lv_monat = '01'.
            lv_year = lv_year + 1.
          ELSE.
            lv_monat = lv_monat + 1.
          ENDIF.

        ENDDO.
      ENDIF.
    ENDIF.

    "если модернизация, то пересчет значений
    DATA(lv_afabe) = CONV anlb-afabe( is_calcdata-area ).

    IF lv_move = abap_true.
      LOOP AT lt_anla[] ASSIGNING FIELD-SYMBOL(<ls_anla>).

        IF NOT line_exists( gt_z_dates[ bukrs = <ls_anla>-bukrs
                                        anln1 = <ls_anla>-anln1
                                        anln2 = <ls_anla>-anln2
                                        afabe = lv_afabe ] ).

          fill_dates( EXPORTING iv_bukrs = <ls_anla>-bukrs
                                iv_anln1 = <ls_anla>-anln1
                                iv_anln2 = <ls_anla>-anln2
                                iv_afabe = lv_afabe
                                iv_date = lv_last_date
                                iv_afasl = is_helpseg-depr_key
                                iv_useful_life = is_helpseg-useful_life
                      CHANGING  cv_old_useful_life = lv_old_useful_life ).

        ENDIF.
      ENDLOOP.
    ENDIF.

    IF NOT line_exists( gt_z_dates[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                    anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                    anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                    afabe = lv_afabe ] ).

      fill_dates( EXPORTING iv_bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                            iv_anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                            iv_anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                            iv_afabe = lv_afabe
                            iv_date = lv_last_date
                            iv_afasl = is_helpseg-depr_key
                            iv_useful_life = is_helpseg-useful_life
                  CHANGING  cv_old_useful_life = lv_old_useful_life ).

    ENDIF.

********************************************************************************
* если была модернизация по ОС, с которых было перемещение
    IF lv_move = abap_true.
      LOOP AT lt_anla[] ASSIGNING <ls_anla>.

        ASSIGN  gt_z_dates[ bukrs = <ls_anla>-bukrs
                            anln1 = <ls_anla>-anln1
                            anln2 = <ls_anla>-anln2
                            afabe = lv_afabe ] TO FIELD-SYMBOL(<ls_zosm_date>).

        CHECK <ls_zosm_date> IS ASSIGNED.

        DELETE <ls_zosm_date>-t_date WHERE budat < is_helpseg-start_date.

        LOOP AT <ls_zosm_date>-t_date[] ASSIGNING FIELD-SYMBOL(<ls_date>) WHERE mark = abap_false.

          <ls_date>-mark = abap_true.

          zaa_utils_hdb=>get_aa_vals( EXPORTING iv_date = get_last_month_day( <ls_date>-budat+0(6) && '01' )
                                                it_asset = VALUE #( ( bukrs = <ls_anla>-bukrs anln1 = <ls_anla>-anln1 anln2 = <ls_anla>-anln2 afabe = is_calcdata-area ) )
                                                iv_end_day = abap_true
                                      IMPORTING et_vals = lt_aa_stoim ).

          IF lt_aa_stoim IS NOT INITIAL.
            lv_netvl = lt_aa_stoim[ 1 ]-netvl.
          ENDIF.

          READ TABLE gt_z_vals ASSIGNING FIELD-SYMBOL(<ls_zosm_val>) WITH KEY primary_key COMPONENTS
                                                                              bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                                                              anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                                                              anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                                                              afabe = CONV anlb-afabe( is_calcdata-area )
                                                                              gjahr = <ls_date>-budat+0(4)
                                                                              monat = <ls_date>-budat+4(2).

          CHECK sy-subrc IS INITIAL.

          DATA(lv_tabix) = sy-tabix + 1.
          lv_netvl = lv_netvl - <ls_zosm_val>-amount_sum.
          lv_amount_sum = <ls_zosm_val>-amount_sum.
          lv_ost_stoim_prev = lv_netvl.
          lv_old_useful_life = <ls_date>-ndjar * 12 + <ls_date>-ndper.
          DATA(lv_new_useful_life) = lv_old_useful_life - ( <ls_date>-budat+0(4) - is_helpseg-start_yr ) * 12 -  <ls_date>-budat+4(2) + is_helpseg-start_prd - 1.
          lv_snyr = round( val = lv_new_useful_life * ( lv_new_useful_life / 12 + 1 ) / 24 dec = 0 ).
          lv_spi_rest_yr = lv_new_useful_life / 12.
          lv_spi_zosm = lv_new_useful_life / 12.
          lv_count = 1.

          LOOP AT gt_z_vals[] ASSIGNING <ls_zosm_val> FROM lv_tabix WHERE afabe = CONV anlb-afabe( is_calcdata-area ).

            <ls_zosm_val>-amount = lv_netvl * ( lv_spi_zosm - lv_spi_rest_yr + 1 ) / lv_snyr / 12.       " амортизация за текущий период
            <ls_zosm_val>-rest_yr = lv_spi_rest_yr.                                " осталось лет
            <ls_zosm_val>-stoim = lv_netvl.                                        " амортизируемая стоимость
            <ls_zosm_val>-newul = lv_snyr.                                         " СПИ
            lv_amount_sum = lv_amount_sum + <ls_zosm_val>-amount.
            <ls_zosm_val>-amount_sum = lv_amount_sum.                              " сумма накопленной амортизации
            <ls_zosm_val>-ost_stoim = lv_netvl - <ls_zosm_val>-amount_sum.         " остаточная стоимость
            <ls_zosm_val>-ost_stoim = lv_ost_stoim_prev - <ls_zosm_val>-amount.

            IF lv_ost_stoim_prev = 0 OR lv_ost_stoim_prev < <ls_zosm_val>-amount.
              <ls_zosm_val>-amount = lv_ost_stoim_prev.                            " остаточная стоимость на конец предыдущего месяца
              <ls_zosm_val>-ost_stoim = 0.
              lv_netvl = 0.
            ENDIF.

            IF <ls_zosm_val>-gjahr = lv_last_date+0(4) AND <ls_zosm_val>-monat = lv_last_date+4(2).
              <ls_zosm_val>-amount = lv_ost_stoim_prev.                            " в последнем месяце СПИ должна списаться вся остаточная стоимость
            ENDIF.

            lv_ost_stoim_prev = <ls_zosm_val>-ost_stoim.

            IF lv_count < 12.
              lv_count = lv_count + 1.
            ELSE.
              lv_count = 1.
              lv_spi_rest_yr = lv_spi_rest_yr - 1.
            ENDIF.

          ENDLOOP.

        ENDLOOP.
      ENDLOOP.
    ENDIF.
*******************************************************************************
    ASSIGN  gt_z_dates[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                        anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                        anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                        afabe = lv_afabe ]
            TO FIELD-SYMBOL(<ls_zosm_dates>).

    IF <ls_zosm_dates> IS ASSIGNED.

      READ TABLE <ls_zosm_dates>-t_date ASSIGNING FIELD-SYMBOL(<ls_dates>) WITH KEY period = lv_edate+0(6)
                                                                                    mark = abap_false.
      IF sy-subrc = 0.

        <ls_dates>-mark = abap_true.
        lv_netvl = is_calcdata-netvalue.

        READ TABLE gt_z_vals ASSIGNING <ls_zosm_val> WITH KEY primary_key COMPONENTS
                                                                            bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                                                            anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                                                            anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                                                            afabe = CONV anlb-afabe( is_calcdata-area )
                                                                            gjahr = is_calcdata-fyear
                                                                            monat = is_calcdata-period_to+2(2).
        IF sy-subrc = 0.

          lv_ost_stoim_prev = lv_netvl.
          lv_old_useful_life = <ls_dates>-ndjar * 12 + <ls_dates>-ndper.
          lv_new_useful_life = lv_old_useful_life - ( is_calcdata-fyear - is_helpseg-start_yr ) * 12 -  is_calcdata-period_to+2(2) + is_helpseg-start_prd.
          lv_snyr = round( val = lv_new_useful_life * ( lv_new_useful_life / 12 + 1 ) / 24 dec = 0 ).
          lv_spi_rest_yr = lv_new_useful_life / 12.
          lv_spi_zosm = lv_new_useful_life / 12.
          lv_count = 1.

          LOOP AT gt_z_vals[] ASSIGNING <ls_zosm_val> FROM sy-tabix WHERE afabe = CONV anlb-afabe( is_calcdata-area ).

            <ls_zosm_val>-amount = lv_netvl * ( lv_spi_zosm - lv_spi_rest_yr + 1 ) / lv_snyr / 12.       " амортизация за текущий период
            <ls_zosm_val>-rest_yr = lv_spi_rest_yr.                                " осталось лет
            <ls_zosm_val>-stoim = lv_netvl.                                        " амортизируемая стоимость
            <ls_zosm_val>-newul = lv_snyr.                                         " СПИ
            <ls_zosm_val>-ost_stoim = lv_ost_stoim_prev - <ls_zosm_val>-amount.

            IF lv_ost_stoim_prev = 0 OR lv_ost_stoim_prev < <ls_zosm_val>-amount.
              <ls_zosm_val>-amount = lv_ost_stoim_prev.                            " остаточная стоимость на конец предыдущего месяца
              <ls_zosm_val>-ost_stoim = 0.
              lv_netvl = 0.
            ENDIF.

            IF <ls_zosm_val>-gjahr = lv_last_date+0(4) AND <ls_zosm_val>-monat = lv_last_date+4(2).
              <ls_zosm_val>-amount = lv_ost_stoim_prev.                            " в последнем месяце СПИ должна списаться вся остаточная стоимость
            ENDIF.

            lv_ost_stoim_prev = <ls_zosm_val>-ost_stoim.

            IF lv_count < 12.
              lv_count = lv_count + 1.
            ELSE.
              lv_count = 1.
              lv_spi_rest_yr = lv_spi_rest_yr - 1.
            ENDIF.

          ENDLOOP.
        ENDIF.

      ENDIF.
    ENDIF.

    "возвращаем значение амортизации на заданный период
    ASSIGN  gt_z_vals[ KEY primary_key bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                       anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                       anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                       afabe = CONV anlb-afabe( is_calcdata-area )
                                       gjahr = is_calcdata-fyear
                                       monat = is_calcdata-period_to+2(2) ] TO <ls_zosm_val>.

    IF sy-subrc IS INITIAL.
      cs_calcdata-amount = <ls_zosm_val>-amount.
    ELSE.
      cs_calcdata-amount = 0.
    ENDIF.

  ENDMETHOD.


  METHOD calc_zprd_amort.
    " DEV.030-БНУ.07.E-009
    " Пользовательский расчет амортизации от пробега (Начало) *
    TYPES:
      BEGIN OF lty_s_fact,
        gjahr TYPE zaa_mnth_fact-gjahr,
        afper TYPE zaa_mnth_fact-afper,
        factw TYPE zaa_mnth_fact-factw,
      END OF lty_s_fact.

    DATA:
      lt_fact        TYPE STANDARD TABLE OF lty_s_fact,
      lv_sdate       TYPE d, "дата начала месяца
      lv_normw       TYPE zaa_std_value-normw, "Действующая норма объема работ
      lv_factw_month TYPE zaa_mnth_fact-factw, "месячный пробег
      lv_factw_prev  TYPE zaa_mnth_fact-factw. "пробеги за прошлые периоды

    lv_sdate = is_calcdata-fyear && is_calcdata-period_to+2(2) && '01'.

    "  Определение действующей нормы объема работ
    SELECT SINGLE normw INTO lv_normw
      FROM zaa_std_value
      WHERE bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
        AND anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
        AND anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
        AND adatu <= lv_sdate
        AND bdatu >= lv_sdate.

    "  Выборка всех записей фактического пробега для ОС
    SELECT gjahr,afper,factw
      FROM zaa_mnth_fact
      INTO TABLE @lt_fact
      WHERE bukrs = @zcl_im_aa_dc_customer=>gv_asset_key-bukrs
        AND anln1 = @zcl_im_aa_dc_customer=>gv_asset_key-anln1
        AND anln2 = @zcl_im_aa_dc_customer=>gv_asset_key-anln2
        AND gjahr <= @is_calcdata-fyear
      ORDER BY gjahr,afper.

    "   Определение фактич работы за период амортизации, и за весь предыдущий срок
    LOOP AT lt_fact ASSIGNING FIELD-SYMBOL(<ls_fact>).
      IF <ls_fact>-gjahr = is_calcdata-fyear
         AND  <ls_fact>-afper =  is_calcdata-period_to+2(2).
        lv_factw_month = <ls_fact>-factw.
        EXIT.
      ELSEIF <ls_fact>-gjahr = is_calcdata-fyear AND  <ls_fact>-afper <  is_calcdata-period_to+2(2)
             OR <ls_fact>-gjahr < is_calcdata-fyear.
        ADD <ls_fact>-factw TO lv_factw_prev.
      ENDIF.
    ENDLOOP.
    " если фактич объем работ превышает норму то амортизацияравна остаточной стоимости
    IF lv_factw_prev + lv_factw_month >= lv_normw.
      cs_calcdata-amount = is_calcdata-netvalue.
    ELSE.
      cs_calcdata-amount = is_calcdata-netvalue * lv_factw_month / ( lv_normw - lv_factw_prev ).
    ENDIF.

    " Пользовательский расчет амортизации от пробега (Конец) *

  ENDMETHOD.


  METHOD calc_zses_amort.
    DATA:
      BEGIN OF ls_info,
        m_stop TYPE i, "количество месяцев останова
        x_stop TYPE i, "признак - останов в тек месяце >0
      END OF ls_info,
      lv_sdate    TYPE d, "нач тек месяца расчета
      lv_adatu    TYPE d,
      lv_medat    TYPE d, "последний день месяца расчета
      lv_bdatu    TYPE d,
      lr_res      TYPE REF TO data,
      lv_edate    TYPE d, "окончание СПИ
      lv_spi_stop TYPE i, "кол-во мес останова в оставш срок.
      lv_spi_rest TYPE i. "оставш срок СПИ .
    " DEV.030-БНУ.07.E-009
    " Пользовательский расчет амортизации периодам без останова (Начало) *

    " дата начала тек месяца
    lv_sdate = is_calcdata-fyear && is_calcdata-period_to+2(2) && '01'.
    "последний день месяца расчета
    lv_medat = get_last_month_day( lv_sdate ).
    "окончание СПИ
    CALL FUNCTION 'HR_HU_ADD_MONTH_TO_DATE'
      EXPORTING
        months  = is_helpseg-useful_life
        olddate = is_helpseg-start_date
      IMPORTING
        newdate = lv_edate.
    "Дата окончания СПИ - последний день предпоследнего месяца
    lv_edate+6 = '01'.
    lv_edate = lv_edate - 1.
    " определение кол-ва оставшихся мес СПИ
    lv_spi_rest = is_helpseg-useful_life - ( is_calcdata-fyear - is_helpseg-start_yr ) * 12 -  is_calcdata-period_to+2(2) + is_helpseg-start_prd.
    IF lv_spi_rest <= 0.
      RETURN.
    ENDIF.
    " определение кол-ва оставшишся мес СПИ c остановом
    GET REFERENCE OF ls_info INTO lr_res  .
    DATA(result) = NEW cl_sql_statement( )->execute_query(
    `SELECT SUM( ( LEFT(M_BDATU,4) - LEFT(M_ADATU,4) ) * 12 +  SUBSTR(M_BDATU,5,2) - SUBSTR(M_ADATU,5,2) + 1 ) AS M_STOP, SUM(X_STOP ) AS X_STOP `
     && ` FROM`
     && ` ( SELECT CASE WHEN ZAA_OSTANOV.ADATU < '` && lv_sdate && `' THEN  '` && lv_sdate && `' ELSE ZAA_OSTANOV.ADATU END  AS M_ADATU,`
     &&          ` CASE WHEN ZAA_OSTANOV.BDATU > '` && lv_edate && `' THEN  '` && lv_edate && `' ELSE ZAA_OSTANOV.BDATU END  AS M_BDATU,`
     &&          ` CASE WHEN ZAA_OSTANOV.BDATU >= '` && lv_medat && `' AND ZAA_OSTANOV.ADATU <= '` && lv_medat && `' THEN 1 ELSE 0 END AS X_STOP`

     &&     ` FROM ZAA_OSTANOV  JOIN ANLA ON ANLA.MANDT = ZAA_OSTANOV.MANDT AND ANLA.INVNR = ZAA_OSTANOV.INVNR`
     &&     ` WHERE ZAA_OSTANOV.MANDT = '` && sy-mandt && `'`
     &&     `   AND ANLA.BUKRS = '` && zcl_im_aa_dc_customer=>gv_asset_key-bukrs && `'`
     &&     `   AND ANLA.ANLN1 = '` && zcl_im_aa_dc_customer=>gv_asset_key-anln1 && `'`
     &&     `   AND ANLA.ANLN2 = '` && zcl_im_aa_dc_customer=>gv_asset_key-anln2 && `'`
     &&     `   AND ZAA_OSTANOV.XSTIL = 'X'`
     &&     `   AND ZAA_OSTANOV.BDATU >= '` && lv_sdate && `'`
     &&     `   AND ZAA_OSTANOV.ADATU <= '` && lv_edate && `' )` ).

    result->set_param_struct( REF #( ls_info ) ).
    sy-dbcnt = result->next( ).
    result->close( ).
    IF ls_info-x_stop > 0.
      RETURN.
    ENDIF.
    lv_spi_rest = lv_spi_rest - ls_info-m_stop.
    IF lv_spi_rest > 0.
      cs_calcdata-amount = is_calcdata-netvalue / lv_spi_rest.
    ENDIF.
    " Пользовательский расчет амортизации без останова (Конец) *
  ENDMETHOD.


  METHOD calc_zsum_amort.
*  DEV.030-БНУ.07.E-010
*  АмНормаГод = 100 * ( ОстСПИ *2 ) / ( СПИ *( СПИ + 1 ))
*  СумАмМес = АмСт * АмНормаГод / 12.
*  АмСт - амортизируемая стоимость

    DATA: lr_res         TYPE REF TO data,
          lo_exc         TYPE REF TO cx_sql_exception,
          lv_amount      TYPE faa_ee_amount,
          lv_monat       TYPE anek-monat,
          lv_netvl       TYPE anlc-kansw,
          lv_amount_sum  TYPE anep-anbtr,
          lv_sdate       TYPE d,
          lv_edate       TYPE d,
          lv_last_date   TYPE d,   "дата последней амортизации
          lv_spi_rest    TYPE i,   "оставшийся срок СПИ периодах
          lv_spi_rest_yr TYPE p LENGTH 2 DECIMALS 2.  "оставшийся срок СПИ в годах

    " определение кол-ва оставшихся мес СПИ
    lv_spi_rest = is_helpseg-useful_life - ( is_calcdata-fyear - is_helpseg-start_yr ) * 12 -  is_calcdata-period_to+2(2) + is_helpseg-start_prd.
    lv_spi_rest_yr = lv_spi_rest / 12.
    DATA(lv_snyr) = round( val = is_helpseg-useful_life * ( is_helpseg-useful_life / 12 + 1 ) / 24 dec = 0 ).
    lv_sdate = is_calcdata-fyear && is_calcdata-period_to+2(2) && '01'.

    CALL FUNCTION 'MONTH_PLUS_DETERMINE'
      EXPORTING
        months  = '-1'
        olddate = lv_sdate
      IMPORTING
        newdate = lv_edate.

    CALL FUNCTION 'MONTH_PLUS_DETERMINE'
      EXPORTING
        months  = is_helpseg-useful_life - 1
        olddate = is_helpseg-start_date
      IMPORTING
        newdate = lv_last_date.

    check_os( EXPORTING iv_bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                        iv_anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                        iv_anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                        iv_afasl = is_helpseg-depr_key
                        iv_date = lv_last_date
                        iv_useful_life = is_helpseg-useful_life
              IMPORTING et_anla = DATA(lt_anla)
                        et_spi = DATA(lt_spi)
                        ev_move = DATA(lv_move) ).

    "первонач заполнение
    IF NOT line_exists( gt_z_vals[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                   anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                   anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                   afabe = CONV anlb-afabe( is_calcdata-area ) ] ).
      " АмСт = первоначальной стоимости
      IF lv_move = abap_true.
        ASSIGN lt_anla[ 1 ] TO FIELD-SYMBOL(<fs_anla>).
        CHECK <fs_anla> IS ASSIGNED.

        zaa_utils_hdb=>get_aa_vals( EXPORTING iv_date = get_last_month_day( lv_edate+0(6) && '01' )
                                              it_asset = VALUE #( ( bukrs = <fs_anla>-bukrs
                                                                    anln1 = <fs_anla>-anln1
                                                                    anln2 = <fs_anla>-anln2
                                                                    afabe = is_calcdata-area ) )
                                              iv_end_day = abap_true
                                    IMPORTING et_vals = DATA(lt_aa_stoim) ).

        IF lt_aa_stoim IS NOT INITIAL.
          lv_netvl = lt_aa_stoim[ 1 ]-netvl.
        ENDIF.

      ELSE.
        lv_netvl = is_calcdata-netvalue.
      ENDIF.

      DATA(lv_old_useful_life) = is_helpseg-useful_life.
      LOOP AT lt_spi ASSIGNING FIELD-SYMBOL(<ls_spi>) WHERE adatu = '19000101' AND afabe = CONV anlb-afabe( is_calcdata-area ).
        lv_old_useful_life = <ls_spi>-ndjar * 12 + <ls_spi>-ndper.
        EXIT.
      ENDLOOP.

      lv_spi_rest_yr = lv_old_useful_life / 12.
      lv_snyr = round( val = lv_old_useful_life * ( lv_old_useful_life / 12 + 1 ) / 24 dec = 0 ).
      DATA(lv_year) = is_helpseg-start_yr.
      lv_monat = is_helpseg-start_prd.
      lv_amount_sum = 0.
      DATA(lv_ost_stoim_prev) = lv_netvl.
      DATA(lv_count) = lv_old_useful_life.

      WHILE lv_spi_rest_yr > 0 AND lv_count > 0.

        DO 12 TIMES.

          CHECK lv_count > 0.

          lv_amount = lv_netvl * lv_spi_rest_yr / lv_snyr / 12.

          IF lv_ost_stoim_prev = 0 OR lv_ost_stoim_prev < lv_amount.
            lv_amount = lv_ost_stoim_prev.                        " остаточная стоимость на конец предыдущего месяца
          ENDIF.

          lv_amount_sum = lv_amount_sum + lv_amount.

          IF lv_year = lv_last_date+0(4) AND lv_monat = lv_last_date+4(2).
            lv_amount = lv_ost_stoim_prev.                        " в последнем месяце СПИ должна списаться вся остаточная стоимость
          ENDIF.

          INSERT VALUE #(  bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                           anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                           anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                           gjahr = lv_year
                           monat = lv_monat
                           afabe = CONV anlb-afabe( is_calcdata-area )
                           stoim = lv_netvl                           " амортизируемая стоимость
                           rest_yr = lv_spi_rest_yr                   " осталось лет
                           newul = lv_snyr
                           amount = lv_amount                         " амортизация за период
*                          ost_stoim = lv_netvl - lv_amount_sum       " остаточная стоимость на конец месяца
                           ost_stoim = lv_ost_stoim_prev - lv_amount
                           amount_sum = lv_amount_sum )               " накопленная амортизация
                INTO TABLE gt_z_vals.

          lv_ost_stoim_prev = lv_ost_stoim_prev - lv_amount.

          IF lv_monat = '12'.
            lv_monat = '01'.
            lv_year = lv_year + 1.
          ELSE.
            lv_monat = lv_monat + 1.
          ENDIF.

          lv_count = lv_count - 1.

        ENDDO.

        lv_spi_rest_yr = lv_spi_rest_yr - 1.

      ENDWHILE.

      IF lv_old_useful_life < is_helpseg-useful_life.

        DATA(lv_countt) = is_helpseg-useful_life - lv_old_useful_life.

        DO lv_countt TIMES.

          INSERT VALUE #(  bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                           anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                           anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                           gjahr = lv_year
                           monat = lv_monat
                           afabe = CONV anlb-afabe( is_calcdata-area ) )
                INTO TABLE gt_z_vals.

          IF lv_monat = '12'.
            lv_monat = '01'.
            lv_year = lv_year + 1.
          ELSE.
            lv_monat = lv_monat + 1.
          ENDIF.

        ENDDO.
      ENDIF.
    ENDIF.

    "если модернизация, то пересчет значений
    DATA(lv_afabe) = CONV anlb-afabe( is_calcdata-area ).

    IF lv_move = abap_true.
      LOOP AT lt_anla ASSIGNING FIELD-SYMBOL(<ls_anla>).

        IF NOT line_exists( gt_z_dates[ bukrs = <ls_anla>-bukrs
                                        anln1 = <ls_anla>-anln1
                                        anln2 = <ls_anla>-anln2
                                        afabe = lv_afabe ] ).

          fill_dates( EXPORTING iv_bukrs = <ls_anla>-bukrs
                                iv_anln1 = <ls_anla>-anln1
                                iv_anln2 = <ls_anla>-anln2
                                iv_afabe = lv_afabe
                                iv_afasl = is_helpseg-depr_key
                                iv_date = lv_last_date
                                iv_useful_life = is_helpseg-useful_life
                      CHANGING  cv_old_useful_life = lv_old_useful_life ).

        ENDIF.
      ENDLOOP.
    ENDIF.

    IF NOT line_exists( gt_z_dates[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                    anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                    anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                    afabe = lv_afabe ] ).

      fill_dates( EXPORTING iv_bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                            iv_anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                            iv_anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                            iv_afabe = lv_afabe
                            iv_afasl = is_helpseg-depr_key
                            iv_date = lv_last_date
                            iv_useful_life = is_helpseg-useful_life
                  CHANGING  cv_old_useful_life = lv_old_useful_life ).

    ENDIF.

********************************************************************************
* если была модернизация по ОС, с которых было перемещение
    IF lv_move = abap_true.

      LOOP AT lt_anla ASSIGNING <ls_anla>.

        ASSIGN  gt_z_dates[ bukrs = <ls_anla>-bukrs
                            anln1 = <ls_anla>-anln1
                            anln2 = <ls_anla>-anln2
                            afabe = lv_afabe ]
                TO FIELD-SYMBOL(<ls_zsum_date>).

        CHECK <ls_zsum_date> IS ASSIGNED.

        DELETE <ls_zsum_date>-t_date WHERE budat < is_helpseg-start_date.

        LOOP AT <ls_zsum_date>-t_date ASSIGNING FIELD-SYMBOL(<ls_date>) WHERE mark = abap_false.

          <ls_date>-mark = abap_true.

          zaa_utils_hdb=>get_aa_vals( EXPORTING iv_date = get_last_month_day( <ls_date>-budat+0(6) && '01' )
                                                it_asset = VALUE #( ( bukrs = <ls_anla>-bukrs
                                                                        anln1 = <ls_anla>-anln1
                                                                        anln2 = <ls_anla>-anln2
                                                                        afabe = is_calcdata-area ) )
                                                iv_end_day = abap_true
                                      IMPORTING et_vals = lt_aa_stoim ).

          IF lt_aa_stoim IS NOT INITIAL.
            lv_netvl = lt_aa_stoim[ 1 ]-netvl.
          ENDIF.

          READ TABLE gt_z_vals ASSIGNING FIELD-SYMBOL(<ls_zsum_val>) WITH KEY primary_key COMPONENTS
                                                                              bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                                                              anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                                                              anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                                                              afabe = CONV anlb-afabe( is_calcdata-area )
                                                                              gjahr = <ls_date>-budat+0(4)
                                                                              monat = <ls_date>-budat+4(2).

          CHECK sy-subrc IS INITIAL.

          DATA(lv_tabix) = sy-tabix + 1.
          lv_netvl = lv_netvl - <ls_zsum_val>-amount_sum.
          lv_amount_sum = <ls_zsum_val>-amount_sum.
          lv_ost_stoim_prev = lv_netvl.
          lv_old_useful_life = <ls_date>-ndjar * 12 + <ls_date>-ndper.
          DATA(lv_new_useful_life) = lv_old_useful_life - ( <ls_date>-budat+0(4) - is_helpseg-start_yr ) * 12 -  <ls_date>-budat+4(2) + is_helpseg-start_prd - 1.
          lv_snyr = round( val = lv_new_useful_life * ( lv_new_useful_life / 12 + 1 ) / 24 dec = 0 ).
          lv_spi_rest_yr = lv_new_useful_life / 12.
          lv_count = 1.

          LOOP AT gt_z_vals ASSIGNING <ls_zsum_val> FROM lv_tabix
                                                    WHERE afabe = CONV anlb-afabe( is_calcdata-area ).

            <ls_zsum_val>-amount = lv_netvl * lv_spi_rest_yr / lv_snyr / 12.       " амортизация за текущий период
            <ls_zsum_val>-rest_yr = lv_spi_rest_yr.                                " осталось лет
            <ls_zsum_val>-stoim = lv_netvl.                                        " амортизируемая стоимость
            <ls_zsum_val>-newul = lv_snyr.                                         " СПИ
            lv_amount_sum = lv_amount_sum + <ls_zsum_val>-amount.
            <ls_zsum_val>-amount_sum = lv_amount_sum.                              " сумма накопленной амортизации
            <ls_zsum_val>-ost_stoim = lv_netvl - <ls_zsum_val>-amount_sum.         " остаточная стоимость
            <ls_zsum_val>-ost_stoim = lv_ost_stoim_prev - <ls_zsum_val>-amount.

            IF lv_ost_stoim_prev = 0 OR lv_ost_stoim_prev < <ls_zsum_val>-amount.
              <ls_zsum_val>-amount = lv_ost_stoim_prev.                            " остаточная стоимость на конец предыдущего месяца
              <ls_zsum_val>-ost_stoim = 0.
              lv_netvl = 0.
            ENDIF.

            IF <ls_zsum_val>-gjahr = lv_last_date+0(4) AND <ls_zsum_val>-monat = lv_last_date+4(2).
              <ls_zsum_val>-amount = lv_ost_stoim_prev.                            " в последнем месяце СПИ должна списаться вся остаточная стоимость
            ENDIF.

            lv_ost_stoim_prev = <ls_zsum_val>-ost_stoim.

            IF lv_count < 12.
              lv_count = lv_count + 1.
            ELSE.
              lv_count = 1.
              lv_spi_rest_yr = lv_spi_rest_yr - 1.
            ENDIF.

          ENDLOOP.

        ENDLOOP.
      ENDLOOP.
    ENDIF.
*******************************************************************************
    ASSIGN  gt_z_dates[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                        anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                        anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                        afabe = lv_afabe ]
            TO FIELD-SYMBOL(<ls_zsum_dates>).

    IF <ls_zsum_dates> IS ASSIGNED.

      READ TABLE <ls_zsum_dates>-t_date ASSIGNING FIELD-SYMBOL(<ls_dates>) WITH KEY period = lv_edate+0(6)
                                                                                    mark = abap_false.
      IF sy-subrc IS INITIAL.

        <ls_dates>-mark = abap_true.
        lv_netvl = is_calcdata-netvalue.

        READ TABLE gt_z_vals ASSIGNING <ls_zsum_val> WITH KEY primary_key COMPONENTS
                                                                            bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                                                            anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                                                            anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                                                            afabe = CONV anlb-afabe( is_calcdata-area )
                                                                            gjahr = is_calcdata-fyear
                                                                            monat = is_calcdata-period_to+2(2).
        IF sy-subrc = 0.

          lv_ost_stoim_prev = lv_netvl.
          lv_old_useful_life = <ls_dates>-ndjar * 12 + <ls_dates>-ndper.
          lv_new_useful_life = lv_old_useful_life - ( is_calcdata-fyear - is_helpseg-start_yr ) * 12 -  is_calcdata-period_to+2(2) + is_helpseg-start_prd.
          lv_snyr = round( val = lv_new_useful_life * ( lv_new_useful_life / 12 + 1 ) / 24 dec = 0 ).
          lv_spi_rest_yr = lv_new_useful_life / 12.
          lv_count = 1.

          LOOP AT gt_z_vals ASSIGNING <ls_zsum_val> FROM sy-tabix
                                                    WHERE afabe = CONV anlb-afabe( is_calcdata-area ).

            <ls_zsum_val>-amount = lv_netvl * lv_spi_rest_yr / lv_snyr / 12.       " амортизация за текущий период
            <ls_zsum_val>-rest_yr = lv_spi_rest_yr.                                " осталось лет
            <ls_zsum_val>-stoim = lv_netvl.                                        " амортизируемая стоимость
            <ls_zsum_val>-newul = lv_snyr.                                         " СПИ
            <ls_zsum_val>-ost_stoim = lv_ost_stoim_prev - <ls_zsum_val>-amount.

            IF lv_ost_stoim_prev = 0 OR lv_ost_stoim_prev < <ls_zsum_val>-amount.
              <ls_zsum_val>-amount = lv_ost_stoim_prev.                            " остаточная стоимость на конец предыдущего месяца
              <ls_zsum_val>-ost_stoim = 0.
              lv_netvl = 0.
            ENDIF.

            IF <ls_zsum_val>-gjahr = lv_last_date+0(4) AND <ls_zsum_val>-monat = lv_last_date+4(2).
              <ls_zsum_val>-amount = lv_ost_stoim_prev.                            " в последнем месяце СПИ должна списаться вся остаточная стоимость
            ENDIF.

            lv_ost_stoim_prev = <ls_zsum_val>-ost_stoim.

            IF lv_count < 12.
              lv_count = lv_count + 1.
            ELSE.
              lv_count = 1.
              lv_spi_rest_yr = lv_spi_rest_yr - 1.
            ENDIF.

          ENDLOOP.

        ENDIF.

      ENDIF.
    ENDIF.

    "возвращаем значение амортизации на заданный период
    ASSIGN  gt_z_vals[ bukrs = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                       anln1 = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                       anln2 = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                       afabe = CONV anlb-afabe( is_calcdata-area )
                       gjahr = is_calcdata-fyear
                       monat = is_calcdata-period_to+2(2) ]
            TO <ls_zsum_val>.

    IF sy-subrc = 0.
      cs_calcdata-amount = <ls_zsum_val>-amount.
    ELSE.
      cs_calcdata-amount = 0.
    ENDIF.

  ENDMETHOD.


  METHOD calc_zumo_amort.
*  DEV.030-БНУ.07.E-012
    cs_calcdata-amount = zcl_aa_ee_customer_hdb=>zumo_get_amount( EXPORTING
                                                  iv_bukrs  = zcl_im_aa_dc_customer=>gv_asset_key-bukrs
                                                  iv_anln1  = zcl_im_aa_dc_customer=>gv_asset_key-anln1
                                                  iv_anln2  = zcl_im_aa_dc_customer=>gv_asset_key-anln2
                                                  iv_afabe  = CONV anlb-afabe( is_calcdata-area )
                                                  iv_gjahr  = is_calcdata-fyear
                                                  iv_monat  = is_calcdata-period_to+2(2)
                                                  iv_sdate  = is_helpseg-start_date
                                                  iv_rest   = is_calcdata-netvalue ).

  ENDMETHOD.


  METHOD check_os.

    CHECK gv_invnr IS INITIAL.

* проверяем, было ли перемещение по данному инвентарному номеру
    SELECT SINGLE invnr
        INTO @gv_invnr
        FROM anla AS a
        WHERE a~bukrs = @iv_bukrs
          AND a~anln1 = @iv_anln1
          AND a~anln2 = @iv_anln2.
    SELECT bukrs,
           anln1,
           anln2,
           zugdt,
           aktiv,
           deakt
      INTO TABLE @et_anla
      FROM anla
      WHERE invnr = @gv_invnr
        AND deakt > '00000000'
        AND deakt <= @iv_date.
    IF sy-subrc = 0.
      ev_move = abap_true.
      SORT et_anla BY deakt ASCENDING.
    ENDIF.
* проверяем, менялся ли СПИ для всех ОС по данному инвентарному номеру
    DATA(lv_ndjar) = CONV numc3( iv_useful_life DIV 12 ).
    DATA(lv_ndper) = CONV numc3( iv_useful_life MOD 12 ).
    SELECT anlbza~bukrs,
           anlbza~anln1,
           anlbza~anln2,
           anlbza~afabe,
           anlbza~bdatu,
           anlbza~adatu,
           anlbza~ndjar,
           anlbza~ndper
       INTO TABLE @et_spi
      FROM anlbza
      INNER JOIN anla ON anla~bukrs = anlbza~bukrs
                     AND anla~anln1 = anlbza~anln1
                     AND anla~anln2 = anlbza~anln2
      WHERE anla~invnr = @gv_invnr
        AND anlbza~bdatu <= @iv_date
        AND anlbza~afasl = @iv_afasl
        AND ( ndjar <> @lv_ndjar OR ndper <> @lv_ndper ).
    SORT et_spi BY anln1 ASCENDING.

  ENDMETHOD.


  METHOD fill_dates.

    INSERT VALUE #( bukrs = iv_bukrs
                    anln1 = iv_anln1
                    anln2 = iv_anln2
                    afabe = iv_afabe )
      INTO TABLE gt_z_dates ASSIGNING FIELD-SYMBOL(<ls_dates>) .

    zaa_zsum_calc=>get_dates( EXPORTING iv_bukrs = iv_bukrs
                                        iv_anln1 = iv_anln1
                                        iv_anln2 = iv_anln2
                                        iv_afabe = iv_afabe
                                        iv_date = iv_date
                              IMPORTING et_dates = DATA(lt_dates) ).
    <ls_dates>-t_date[] = lt_dates[].

    DATA(lv_ndjar) = CONV numc3( iv_useful_life DIV 12 ).
    DATA(lv_ndper) = CONV numc3( iv_useful_life MOD 12 ).
    SELECT adatu, bdatu, afasl, ndjar, ndper
      INTO TABLE @DATA(lt_spi)
      FROM anlbza
      WHERE bukrs = @iv_bukrs
        AND anln1 = @iv_anln1
        AND anln2 = @iv_anln2
        AND afabe = @iv_afabe
        AND afasl = @iv_afasl.
    IF sy-subrc = 0.
      DELETE lt_spi WHERE adatu <= '19000101'.
    ENDIF.

    LOOP AT lt_spi ASSIGNING FIELD-SYMBOL(<ls_spi>).
      CALL FUNCTION 'MONTH_PLUS_DETERMINE'
        EXPORTING
          months  = '-1'
          olddate = <ls_spi>-adatu
        IMPORTING
          newdate = <ls_spi>-adatu.
      APPEND VALUE #( budat  = <ls_spi>-adatu
                      period = <ls_spi>-adatu+0(6)
                      ndper  = <ls_spi>-ndper
                      ndjar  = <ls_spi>-ndjar
                      cond   = 'S' )
          TO <ls_dates>-t_date.
    ENDLOOP.

    SORT <ls_dates>-t_date BY budat ASCENDING cond DESCENDING.
    DELETE ADJACENT DUPLICATES FROM <ls_dates>-t_date COMPARING period cond.

*  заполняем актуальные СПИ на выбранные даты
    lv_ndper  = cv_old_useful_life MOD 12.
    lv_ndjar  = cv_old_useful_life DIV 12.
    LOOP AT <ls_dates>-t_date ASSIGNING FIELD-SYMBOL(<ls_date>).
      CASE <ls_date>-cond.
        WHEN 'M'.
          <ls_date>-ndper = lv_ndper.
          <ls_date>-ndjar = lv_ndjar.
        WHEN 'S'.
          lv_ndper = <ls_date>-ndper.
          lv_ndjar = <ls_date>-ndjar.
          cv_old_useful_life = lv_ndper + lv_ndjar * 12.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.


  method GET_LAST_MONTH_DAY.
    rv_date = iv_date + 35.
    rv_date+6(2) = '01'.
    rv_date = rv_date - 1.
  endmethod.


  METHOD if_ex_faa_ee_customer~set_base_value.
  ENDMETHOD.


  METHOD if_ex_faa_ee_customer~set_minval_virtarea.
  ENDMETHOD.


  METHOD if_ex_faa_ee_customer~set_percent_amount.
    FIELD-SYMBOLS:
      <ls_hlpseg>   TYPE faa_dc_s_hlpseg,
      <ls_calcdata> TYPE  faa_ee_s_calcdata.
    ASSIGN: isx_cdata-s_segment  TO FIELD-SYMBOL(<ls_segment>).
    ASSIGN: <ls_segment>-ref_calcdata->*  TO <ls_calcdata>.
    "определение номера ОС
    IF  zcl_im_aa_dc_customer=>gv_asset_key IS INITIAL.
      RETURN.
    ENDIF.
    "определение кода амортизации
    TRY.
        ASSIGN zcl_im_aa_dc_customer=>gs_helpseg[ fyear       = <ls_calcdata>-fyear
                                                  area        = <ls_calcdata>-area
                                                  amount_type = <ls_calcdata>-amount_type
                                                  period_to   = <ls_calcdata>-period_to   ]
          TO <ls_hlpseg>.
    ENDTRY.
    IF <ls_hlpseg> IS NOT ASSIGNED.
      MESSAGE e037(zaa).
    ENDIF.

    CASE  <ls_hlpseg>-depr_key.
      WHEN 'ZLND' . "расчет по дням
        calc_zlnd_amort( EXPORTING is_calcdata = <ls_calcdata>
                         CHANGING  cs_calcdata = cs_calcdata ).
      WHEN 'ZPRD'.  "расчет по пробегу
        calc_zprd_amort( EXPORTING is_calcdata = <ls_calcdata>
                         CHANGING  cs_calcdata = cs_calcdata ).
      WHEN 'ZSES' . "расчет по месяцам с учетом остановов
        calc_zses_amort( EXPORTING is_calcdata = <ls_calcdata>
                                   is_helpseg  = <ls_hlpseg>
                         CHANGING  cs_calcdata = cs_calcdata ).
      WHEN 'ZUMO'.  "расчет по пробегу
        calc_zumo_amort( EXPORTING is_calcdata = <ls_calcdata>
                                   is_helpseg  = <ls_hlpseg>
                         CHANGING  cs_calcdata = cs_calcdata ).
      WHEN 'ZSUM'.  "прямой метод суммы чисел лет
        calc_zsum_amort( EXPORTING is_calcdata = <ls_calcdata>
                                   is_helpseg  = <ls_hlpseg>
                         CHANGING  cs_calcdata = cs_calcdata ).
      WHEN 'ZOSM'.  "обратный метод суммы чисел лет
        calc_zosm_amort( EXPORTING is_calcdata = <ls_calcdata>
                                   is_helpseg  = <ls_hlpseg>
                         CHANGING  cs_calcdata = cs_calcdata ).
      WHEN OTHERS.
        MESSAGE w038(zaa) WITH <ls_hlpseg>-depr_key.
    ENDCASE.





  ENDMETHOD.
ENDCLASS.