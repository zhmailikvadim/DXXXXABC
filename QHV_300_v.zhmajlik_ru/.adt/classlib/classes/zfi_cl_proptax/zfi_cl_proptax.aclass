class ZFI_CL_PROPTAX definition
  public
  final
  create public .

public section.

  interfaces IF_F4CALLBACK_VALUE_REQUEST .

  types:
    BEGIN OF lty_s_params,
        report_mode	      TYPE flag,
        bukrs             TYPE RANGE OF anla-bukrs,
        format            TYPE disvariant-variant,
        error             TYPE string,
        fcode             TYPE sy-ucomm,
        budat             TYPE sy-datum,
        blart             TYPE bkpf-blart,
        gkont             TYPE bseg-hkont,
        hkont             TYPE bseg-hkont,
        hkont_inv         TYPE bseg-hkont,    "AK_INPRANNIK #25584 ZFI_PROPTAX - Расчет налога на недвижимость
        submode           TYPE flag,        "Режим отображения Grid2 - A - к проводке, N - Начислено, P - проведено
        nks_range         TYPE RANGE OF anlkl,
        taxrates          TYPE wdy_key_value_table,
        bwasl_incomes     TYPE RANGE OF bwasl,
        bwasl_moves       TYPE RANGE OF bwasl,
        initialized       TYPE abap_bool,
        setup_initialized TYPE abap_bool,
        bwasl_div         TYPE RANGE OF bwasl,        " #8000000096 AK_BUTVILOVS Налог-Объединение ОС
        bwasl_add         TYPE RANGE OF bwasl,        " #8000000096 AK_BUTVILOVS Налог-Объединение ОС
        bwasl_change      TYPE RANGE OF bwasl,        " #30891 ZFI_PROPTAX - налог на недвижимость
      END OF lty_s_params .
  types:
    BEGIN OF lty_s_quart.
        INCLUDE TYPE hcp_s_begda_endda.
    TYPES:
      rate     TYPE j_3rfproptaxrate,
      nks_rate TYPE j_3rfproptaxrate,
      END OF lty_s_quart .
  types:
    BEGIN OF lty_s_sscr,
        budat  TYPE bkpf-budat,
        nquart TYPE zfi_proptax-quart.
        INCLUDE        TYPE hcp_s_begda_endda AS dates.

    TYPES:
      is_plan        TYPE abap_bool,
      trate          TYPE j_3rfproptaxrate,
      nrate          TYPE j_3rfproptaxrate,
      quart1         TYPE lty_s_quart,
      quart2         TYPE lty_s_quart,
      quart3         TYPE lty_s_quart,
      quart4         TYPE lty_s_quart,
      seldats        TYPE hcp_s_begda_endda,
      format         TYPE disvariant-variant,
      " AK_BUTVILOVS #8000000241, ZFI_PROPTAX Доработка отбора по параметрам
      rate           TYPE zeanlz_tax,         " Ставка налогообложения
      koeff          TYPE zkoef_tax,          " Коэффициент налогообложения
      it_okt1        TYPE RANGE OF z_coato1,  " Область
      it_okt2        TYPE RANGE OF z_coato2,  " Район
      it_okt3        TYPE RANGE OF z_coato3,  " Сельсовет
      it_okt4        TYPE RANGE OF z_coato4,  " Населенный пункт
      " end AK_BUTVILOVS #8000000241
      it_bukrs       TYPE RANGE OF anla-bukrs,
      it_anln1       TYPE RANGE OF anla-anln1,
      it_anln2       TYPE RANGE OF anla-anln2,
      it_anlkl       TYPE RANGE OF anla-anlkl,
      it_anln1_nks   TYPE RANGE OF anla-anln1,
      it_anln2_nks   TYPE RANGE OF anla-anln2,
      it_anlkl_nks   TYPE RANGE OF anla-anlkl,
      it_inner_bwasl TYPE RANGE OF anep-bwasl,
      END OF lty_s_sscr .
  types:
    BEGIN OF lty_s_proptax.
        INCLUDE TYPE zfi_proptax.
    TYPES:
      END OF lty_s_proptax .
  types:
    lty_t_tax TYPE STANDARD TABLE OF lty_s_proptax WITH DEFAULT KEY .
  types:
    BEGIN OF lty_s_cost,
        kansw TYPE anlc-kansw,
        amort TYPE anlc-knafa,
        netvl TYPE anlc-kansw,
      END OF lty_s_cost .
  types:
    begin of lty_s_coeff,
      key       TYPE t247-ktx,
      mnr       TYPE t247-mnr,
      tax_koeff TYPE f,
      flag      TYPE flag,
    END OF lty_s_coeff.

  types:
    BEGIN OF lty_s_summ,
        bukrs   TYPE zfi_cl_proptax_amdp=>gty_s_data-bukrs,
        anln    TYPE zfi_cl_proptax_amdp=>gty_s_data-anln_full,
        base    TYPE anlc-kansw,
        monthly TYPE zfi_proptax-kansw,
        tax     TYPE zfi_proptax-kansw, "p LENGTH 15 DECIMALS 5,
        extax   TYPE zfi_proptax-kansw, "p LENGTH 15 DECIMALS 5,
        exmonth TYPE c LENGTH 12,
        kostl   TYPE zfi_cl_proptax_amdp=>gty_s_data-kostl,
        caufn   TYPE zfi_cl_proptax_amdp=>gty_s_data-caufn,
        posnr   TYPE zfi_cl_proptax_amdp=>gty_s_data-posnr,
        jan     TYPE maxbt, "f, "zfi_proptax-kansw,
        feb     TYPE maxbt, "f, "zfi_proptax-kansw,
        mar     TYPE maxbt, "f, "zfi_proptax-kansw,
        prtax1  TYPE maxbt, "f, "zfi_proptax-kansw,
        apr     TYPE maxbt, "f, "zfi_proptax-kansw,
        may     TYPE maxbt, "f, "zfi_proptax-kansw,
        jun     TYPE maxbt, "f, "zfi_proptax-kansw,
        prtax2  TYPE maxbt, "f, "zfi_proptax-kansw,
        jul     TYPE maxbt, "f, "zfi_proptax-kansw,
        aug     TYPE maxbt, "f, "zfi_proptax-kansw,
        sep     TYPE maxbt, "f, "zfi_proptax-kansw,
        prtax3  TYPE maxbt, "f, "zfi_proptax-kansw,
        oct     TYPE maxbt, "f, "zfi_proptax-kansw,
        nov     TYPE maxbt, "f, "zfi_proptax-kansw,
        dec     TYPE maxbt, "f, "zfi_proptax-kansw,
        prtax4  TYPE maxbt, "f, "zfi_proptax-kansw,
        total   TYPE maxbt, "f, "zfi_proptax-kansw,
        coeff   TYPE STANDARD TABLE OF lty_s_coeff with DEFAULT KEY,
        colors  TYPE STANDARD TABLE OF lvc_s_scol WITH DEFAULT KEY,
      END OF lty_s_summ .
  types:
    BEGIN OF lty_s_exempts,
        offpriv     TYPE zanlz_tax-ofprivilege,
        adatu       TYPE begda,
        bdatu       TYPE endda,
        begda       TYPE begda,
        endda       TYPE endda,
        bquart      TYPE n LENGTH 1,
        equart      TYPE n LENGTH 1,
        exempt_rate TYPE zfi_cl_proptax_amdp=>gty_s_data-exempt_rate,
      END OF lty_s_exempts .
  types:
    lty_t_exempts TYPE SORTED TABLE OF lty_s_exempts WITH UNIQUE KEY primary_key COMPONENTS offpriv adatu bdatu .
  types:
    BEGIN OF lty_s_data.
        INCLUDE TYPE zfi_cl_proptax_amdp=>gty_s_data.
    TYPES:
      is_costs      TYPE lty_s_cost,
      is_summ       TYPE lty_s_summ,
      exempts       TYPE lty_t_exempts,
      only_expenses type zanlz_tax-only_expenses,
      END OF lty_s_data .
  types:
    lty_t_data TYPE STANDARD TABLE OF lty_s_data WITH NON-UNIQUE SORTED KEY key COMPONENTS bukrs anln1 anln2 .
  types:
    lty_t_proptax TYPE STANDARD TABLE OF lty_s_data WITH DEFAULT KEY .

  data GT_DATA type LTY_T_DATA .
  data:
    gt_summ TYPE STANDARD TABLE OF lty_s_summ WITH NON-UNIQUE SORTED KEY key COMPONENTS bukrs anln .
  data GS_PARAMS type LTY_S_PARAMS .
  data GT_COSTS type ZFI_CL_PROPTAX_AMDP=>GTY_T_COSTS .
  data GT_MOVES type ZFI_CL_PROPTAX_AMDP=>GTY_T_MOVES .
  data GT_CHAIN type ZFI_CL_PROPTAX_AMDP=>GTY_T_CHAIN .
  data GT_TAXES type LTY_T_TAX .
  data GT_ZANLZ_TAX type ZFI_CL_PROPTAX_AMDP=>GTY_T_ZANLZ_TAX .
  data GT_ACCDOCS type ZFI_CL_PROPTAX_AMDP=>GTY_T_ACCDOCS .
  class-data GV_MODE type FLAG .
  data GS_SSCR type LTY_S_SSCR .

  methods CONSTRUCTOR .
  methods GET_DATA
    importing
      value(IS_SSCR) type LTY_S_SSCR
      value(IV_FILTER) type STRING optional
      value(IV_DEAKT_FILTER) type ABAP_BOOL default 'X'
    returning
      value(RT_DATA) type LTY_T_PROPTAX .
  methods SHOW_DATA .
  methods LOAD_RESULTS
    importing
      value(IS_SSCR) type LTY_S_SSCR .
  methods LOAD_DEFAULT_SSCR .
  class-methods F4_VARIANT
    changing
      value(CV_VARIANT) type DISVARIANT-VARIANT .
  class-methods F4_BUDAT
    importing
      value(IV_DATE) type SY-DATUM optional
    changing
      value(CV_BUDAT) type BUDAT optional
      value(CV_QUART) type NUMC1 optional
    returning
      value(RV_TEXT) type STRING .
  methods END_OF_SELECTION
    returning
      value(RV_OK) type ABAP_BOOL .
  methods CHECK_SSCR
    importing
      value(IT_BUKRS) type BUKRS_RAN_ITAB
    returning
      value(RV_OK) type ABAP_BOOL .
  methods SHOW_SUBREPORT
    returning
      value(RV_OK) type ABAP_BOOL .
  methods FREE_SUBREPORT .
  methods GET_CURRENT_FORMAT
    returning
      value(RV_FORMAT) type DISVARIANT-VARIANT .
  methods INITIALIZE_SETUP_SSCR
    changing
      !CV_1 type PROZT
      !CV_2 type PROZT
      !CV_3 type PROZT
      !CV_4 type PROZT
      !CV_1_NKS type PROZT
      !CV_2_NKS type PROZT
      !CV_3_NKS type PROZT
      !CV_4_NKS type PROZT
      !CT_NKSCL type LTY_S_PARAMS-NKS_RANGE
      !CT_INCOM type LTY_S_PARAMS-BWASL_INCOMES
      !CT_MOVES type LTY_S_PARAMS-BWASL_MOVES .
  methods STORE_SETUP
    importing
      !IV_1 type PROZT
      !IV_2 type PROZT
      !IV_3 type PROZT
      !IV_4 type PROZT
      !IV_1_NKS type PROZT
      !IV_2_NKS type PROZT
      !IV_3_NKS type PROZT
      !IV_4_NKS type PROZT
      !IT_NKSCL type LTY_S_PARAMS-NKS_RANGE
      !IT_INCOM type LTY_S_PARAMS-BWASL_INCOMES
      !IT_MOVES type LTY_S_PARAMS-BWASL_MOVES
    returning
      value(RV_RESULT) type FLAG .
  methods READ_SETUP .
  methods UPDATE_RECORD
    importing
      value(IS_PROPTAX) type ZFI_PROPTAX .
  methods ADD_RECORD
    importing
      value(IS_PROPTAX) type ZFI_PROPTAX .
  methods GET_ANLN_DATA
    importing
      value(IV_BUKRS) type ANLA-BUKRS optional
      value(IV_ANLN1) type ANLA-ANLN1 optional
      value(IV_ANLN2) type ANLA-ANLN2 optional
    changing
      !CV_ANLN2 type ANLA-ANLN2 optional
      !CV_INVNR type ANLA-INVNR
      !CV_ANLKL type ANLA-ANLKL
      !CV_KANSW type ZFI_PROPTAX-KANSW
      !CV_AMORT type ZFI_PROPTAX-AMORT
      !CV_NETVL type ZFI_PROPTAX-NETVL
      !CV_BASE type ZFI_PROPTAX-BASE
      !CV_TAX type ZFI_PROPTAX-TAX
      !CV_EXTAX type ZFI_PROPTAX-EXTAX
      !CV_EXSUM type ZFI_PROPTAX-EXSUM
      !CV_KOEFF type ZFI_PROPTAX-KOEFF
      !CV_EXEMP type ZFI_PROPTAX-EXCODE
      !CV_RATE type ZFI_PROPTAX-RATE
      !CV_REGION type ZFI_PROPTAX-REGION
      !CV_DESCR type ZFI_PROPTAX-DESCR
      !CV_BUKRS type ANLA-BUKRS optional
      !CV_ANLN1 type ANLA-ANLN1 optional .
  methods PREPARE_AMDP_FILTER
    returning
      value(RV_RESULT) type STRING .
protected section.

  class-data GS_DATA type LTY_S_DATA .

  methods LOADDLG_DBLCLICK
    for event DOUBLE_CLICK of CL_SALV_EVENTS_TABLE
    importing
      !ROW
      !COLUMN
      !SENDER .
  methods DELETE_RECORD
    importing
      value(IV_NUMBER) type LVC_INDEX optional .
  methods SAVE_RESULTS .
  methods GET_EXEMPTS
    importing
      value(IS_DATA) type LTY_S_DATA
      value(IS_PERIOD) type HCP_S_BEGDA_ENDDA optional
    returning
      value(RT_EXEMPTS) type LTY_T_EXEMPTS .
  methods REFRESH_SECONDARY .
  methods SHOW_ACCDOCS
    importing
      !IV_MONTH type MONUM
      !IV_BUKRS type BUKRS
      !IV_ASSET type LTY_S_SUMM-ANLN .
  methods FILL_SECONDARY_TABLE .
  methods REFRESH_GRID2
    importing
      value(IM_REFRESH) type ABAP_BOOL default 'X' .
  methods PREPARE_RESULTS
    returning
      value(RV_OK) type ABAP_BOOL .
  methods POST_DOCUMENTS
    importing
      value(IS_TEST) type ABAP_BOOL optional .
  methods SHOW_PROTOCOL .
  methods ON_ACCDOC_HOTSPOT
    for event LINK_CLICK of CL_SALV_EVENTS_TABLE
    importing
      !ROW
      !COLUMN .
private section.

  types:
    BEGIN OF gty_s_messtab,
        status     TYPE icon_132,
        bukrs      TYPE anla-bukrs,
        anln1      TYPE anla-anln1,
        anln2      TYPE anla-anln2,
        type       TYPE bapi_mtype,
        id         TYPE symsgid,
        number     TYPE symsgno,
        message    TYPE char255,
        message_v1 TYPE symsgv,
        message_v2 TYPE symsgv,
        message_v3 TYPE symsgv,
        message_v4 TYPE symsgv,
      END OF gty_s_messtab .
  types:
    lty_t_accdoc TYPE STANDARD TABLE OF zfi_cl_proptax_amdp=>gty_s_accdoc WITH DEFAULT KEY .
  types:
    lty_t_month TYPE SORTED TABLE OF zfi_cl_proptax_amdp=>gty_s_month WITH UNIQUE KEY primary_key COMPONENTS mnr .

  data GT_MONTH type ZFI_CL_PROPTAX_AMDP=>GTY_T_MONTH .
  class-data:
    gt_messtab     TYPE STANDARD TABLE OF gty_s_messtab .
  data GR_GRID type ref to CL_GUI_ALV_GRID .
  data GR_GRID2 type ref to CL_GUI_ALV_GRID .
  data GR_SUBREP type ref to OBJECT .
  data GR_ACCDOCS type ref to LTY_T_ACCDOC .
  data GT_PARTIAL type ZFI_CL_PROPTAX_AMDP=>GTY_T_PART_DISP .

  methods FILL_MONTH_DATA
    importing
      value(IS_DATA) type LTY_S_DATA optional
    returning
      value(RT_MONTH) type LTY_T_MONTH .
  methods BUILD_ACCDOCS_FCAT
    importing
      !IR_COLUMNS type ref to CL_SALV_COLUMNS_TABLE
    changing
      !CT_FCAT type LVC_T_FCAT .
  methods FILL_QUART_TOTALS
    changing
      !CS_SUMM type LTY_S_SUMM .
  methods PROCESS_TAXES
    importing
      value(IS_DATA) type LTY_S_DATA
    returning
      value(RS_NNN) type LTY_S_SUMM .
  methods FILL_COSTS
    importing
      value(IS_DATA) type LTY_S_DATA
    returning
      value(RS_COST) type LTY_S_COST .
  methods RECURS_FIND_OS
    importing
      !IV_BUKRS type ZFI_CL_PROPTAX_AMDP=>GTY_S_DATA-BUKRS
      !IV_ANLN1 type ZFI_CL_PROPTAX_AMDP=>GTY_S_DATA-ANLN1
      !IV_ANLN2 type ZFI_CL_PROPTAX_AMDP=>GTY_S_DATA-ANLN2
      !IV_BEGDA type ZFI_CL_PROPTAX_AMDP=>GTY_S_DATA-ZUGDT
    changing
      value(CS_DATA) type LTY_S_DATA .
  methods FILL_TAX_BASES
    changing
      value(CS_DATA) type LTY_S_DATA .
  methods FILL_SSCR_STRUCTURE
    importing
      value(IS_SSCR) type LTY_S_SSCR
    returning
      value(RS_SSCR) type LTY_S_SSCR .
  methods BUILD_FIELDCAT
    returning
      value(RT_FCAT) type LVC_T_FCAT .
  methods BUILD_FIELDCAT2
    returning
      value(RT_FCAT) type LVC_T_FCAT .
  methods VIEW_ASSET
    importing
      !IV_INDEX type LVC_INDEX optional
      !IV_BUKRS type BUKRS optional
      !IV_ANLN1 type ANLN1 optional
      !IV_ANLN2 type ANLN2 optional .
  methods SHOW_LOG
    importing
      !IV_INDEX type LVC_INDEX .
  methods BUILD_QUARTER
    importing
      value(IV_GJAHR) type GJAHR
      value(IV_QUARTER) type I
    returning
      value(RS_RESULT) type LTY_S_QUART .
  class-methods ADD_MESSTAB
    importing
      !IV_BUKRS type BUKRS
      !IV_ANLN1 type ANLN1
      !IV_ANLN2 type ANLN2
      !IS_RETURN type BAPIRET2 .
  methods ON_HOTSPOT2
    for event HOTSPOT_CLICK of CL_GUI_ALV_GRID
    importing
      !E_ROW_ID .
  methods ON_HOTSPOT
    for event HOTSPOT_CLICK of CL_GUI_ALV_GRID
    importing
      !E_ROW_ID .
  methods ON_DOUBLE_CLICK2
    for event DOUBLE_CLICK of CL_GUI_ALV_GRID
    importing
      !E_COLUMN .
  methods ON_DOUBLE_CLICK
    for event DOUBLE_CLICK of CL_GUI_ALV_GRID
    importing
      !E_ROW
      !E_COLUMN .
  methods PERFORM_SELECTION
    importing
      !IM_UCOMM type SY-UCOMM .
  methods ON_USER_COMMAND2
    for event USER_COMMAND of CL_GUI_ALV_GRID
    importing
      !E_UCOMM .
  methods ON_USER_COMMAND
    for event USER_COMMAND of CL_GUI_ALV_GRID
    importing
      !E_UCOMM .
  class-methods ON_TOOLBAR2
    for event TOOLBAR of CL_GUI_ALV_GRID
    importing
      !E_OBJECT .
  class-methods ON_TOOLBAR
    for event TOOLBAR of CL_GUI_ALV_GRID
    importing
      !E_OBJECT
      !SENDER .
  methods SHOW_WARNING
    importing
      value(IV_TYPE) type SY-MSGTY default 'I'
      value(IV_TEXT) type C
      value(IV_VAR1) type C optional
      value(IV_VAR2) type C optional
      value(IV_VAR3) type C optional
      value(IV_VAR4) type C optional
      value(IV_ASTYPE) type SY-MSGTY optional .
  methods ON_MENU
    for event MENU_BUTTON of CL_GUI_ALV_GRID
    importing
      !E_OBJECT .
  methods ON_DATA_CHANGED2
    for event DATA_CHANGED_FINISHED of CL_GUI_ALV_GRID
    importing
      !E_MODIFIED
      !ET_GOOD_CELLS .
  methods ON_DATA_CHANGED
    for event DATA_CHANGED_FINISHED of CL_GUI_ALV_GRID
    importing
      !E_MODIFIED
      !ET_GOOD_CELLS .
  methods ON_DELAYED_CALLBACK
    for event DELAYED_CALLBACK of CL_GUI_ALV_GRID .
ENDCLASS.



CLASS ZFI_CL_PROPTAX IMPLEMENTATION.


  METHOD add_messtab.
    gt_messtab[] = VALUE #( BASE gt_messtab[]
      ( status     = SWITCH #( is_return-type
                        WHEN 'A' THEN icon_led_red
                        WHEN 'E' THEN icon_led_red
                        WHEN 'W' THEN icon_led_yellow
                        WHEN 'S' THEN icon_led_green
                        WHEN 'I' THEN icon_led_green )
        bukrs      = iv_bukrs
        anln1      = iv_anln1
        anln2      = iv_anln2
        type       = is_return-type
        id         = is_return-id
        number     = is_return-number
        message    = is_return-message
        message_v1 = is_return-message_v1
        message_v2 = is_return-message_v2
        message_v3 = is_return-message_v3
        message_v4 = is_return-message_v4 ) ).
  ENDMETHOD.


  METHOD build_fieldcat.

    rt_fcat[] = CORRESPONDING #(
      cl_salv_data_descr=>read_structdescr(
        CAST cl_abap_structdescr(
          CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( gt_data[] ) )->get_table_line_type( ) ) ) ).

    LOOP AT rt_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>).
      IF <ls_fcat>-fieldname CP 'IS_SUMM-*'.
        <ls_fcat>-tech = abap_true.
      ENDIF.
      CASE <ls_fcat>-fieldname.
        WHEN 'CHECKED'.
          <ls_fcat>-checkbox = abap_true.
          <ls_fcat>-edit = abap_true.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-00l.
        WHEN 'STATUS'.
          <ls_fcat>-icon = 'X'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-15l.
          <ls_fcat>-scrtext_m = TEXT-15m.
          <ls_fcat>-scrtext_s = TEXT-15s.
        WHEN 'MANDT'.
          <ls_fcat>-no_out = abap_true.
        WHEN 'BUKRS'.
          <ls_fcat>-ref_table = 'T001'.
          <ls_fcat>-ref_field = 'BUKRS'.
        WHEN 'OKATO_DESCR'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-18l.
          <ls_fcat>-scrtext_m = TEXT-18m.
          <ls_fcat>-scrtext_s = TEXT-18s.
        WHEN 'PROPTAX'.
          <ls_fcat>-no_out = abap_true.
        WHEN 'KOEFF'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-19l.
          <ls_fcat>-scrtext_m = TEXT-19m.
          <ls_fcat>-scrtext_s = TEXT-19s.
        WHEN 'KOEF_SQUARE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-44l.
          <ls_fcat>-scrtext_m = TEXT-44m.
          <ls_fcat>-scrtext_s = TEXT-44s.
          <ls_fcat>-decimals_o = 5.
          <ls_fcat>-exponent = 0.
        WHEN 'TAX_RATE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-20l.
          <ls_fcat>-scrtext_m = TEXT-20m.
          <ls_fcat>-scrtext_s = TEXT-20s.
        WHEN 'EXEMPTION'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-21l.
          <ls_fcat>-scrtext_m = TEXT-21m.
          <ls_fcat>-scrtext_s = TEXT-21s.
          <ls_fcat>-ref_table = 'J_3RFPRTEXEMPT'.
          <ls_fcat>-ref_field = 'EXEMPTION'.
        WHEN 'EXEMPTION_T'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-22l.
          <ls_fcat>-scrtext_m = TEXT-22m.
          <ls_fcat>-scrtext_s = TEXT-22s.
        WHEN 'EXEMPT_RATE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-17l.
          <ls_fcat>-scrtext_m = TEXT-17m.
          <ls_fcat>-scrtext_s = TEXT-17s.
        WHEN 'ANLKL'.
          <ls_fcat>-ref_table = 'ANLA'.
          <ls_fcat>-ref_field = 'ANLKL'.
        WHEN 'ANLNT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-23l.
          <ls_fcat>-scrtext_m = TEXT-23m.
          <ls_fcat>-scrtext_s = TEXT-23s.
        WHEN 'ANLN1' OR 'ANLN2'.
          <ls_fcat>-no_out = abap_true.
        WHEN 'ANLN_FULL'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-24l.
          <ls_fcat>-scrtext_m = TEXT-24m.
          <ls_fcat>-scrtext_s = TEXT-24s.
          <ls_fcat>-hotspot = abap_true.
        WHEN 'TXT50'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-25l.
          <ls_fcat>-scrtext_m = TEXT-25m.
          <ls_fcat>-scrtext_s = TEXT-25s.
        WHEN 'CAUFN'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-26l.
          <ls_fcat>-scrtext_m = TEXT-26m.
          <ls_fcat>-scrtext_s = TEXT-26s.
        WHEN 'ZUGDT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-27l.
          <ls_fcat>-scrtext_m = TEXT-27m.
          <ls_fcat>-scrtext_s = TEXT-27s.
          <ls_fcat>-ref_table = 'ANLA'.
          <ls_fcat>-ref_field = 'ZUGDT'.
        WHEN 'IS_COSTS-KANSW'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-28l.
          <ls_fcat>-scrtext_m = TEXT-28m.
          <ls_fcat>-scrtext_s = TEXT-28s.
          <ls_fcat>-ref_table = 'ANLC'.
          <ls_fcat>-ref_field = 'KANSW'.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'IS_COSTS-AMORT'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-29l.
          <ls_fcat>-scrtext_m = TEXT-29m.
          <ls_fcat>-scrtext_s = TEXT-29s.
          <ls_fcat>-ref_table = 'ANLC'.
          <ls_fcat>-ref_field = 'KANSW'.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'IS_COSTS-NETVL'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = <ls_fcat>-coltext = TEXT-30l.
          <ls_fcat>-ref_table = 'ANLC'.
          <ls_fcat>-ref_field = 'KANSW'.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'GLO_RUS_OKOF'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = <ls_fcat>-coltext = TEXT-31l.
          <ls_fcat>-ref_table = 'GLOFAAASSETDATA'.
          <ls_fcat>-ref_field = 'GLO_RUS_OKOF'.
        WHEN 'IS_SUMM-BASE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = <ls_fcat>-coltext = TEXT-32l.
          <ls_fcat>-tech = abap_false.
          <ls_fcat>-edit = abap_true.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'IS_SUMM-TAX'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = <ls_fcat>-coltext = TEXT-33l.
          <ls_fcat>-tech = abap_false.
          <ls_fcat>-do_sum = abap_true.
          <ls_fcat>-decimals_o = 2.
        WHEN 'IS_SUMM-EXTAX'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-16l.
          <ls_fcat>-scrtext_m = TEXT-16m.
          <ls_fcat>-scrtext_s = TEXT-16s.
          <ls_fcat>-do_sum = abap_true.
          <ls_fcat>-decimals_o = 2.
        WHEN 'EXEMPTION_SUM'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-34l.
          <ls_fcat>-scrtext_m = TEXT-34m.
          <ls_fcat>-scrtext_s = TEXT-34s.
*          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-do_sum = abap_true.
        WHEN 'PAY_DAY'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = <ls_fcat>-coltext = TEXT-35l.
        WHEN 'REGION'.
          <ls_fcat>-no_out = abap_true.
        WHEN 'DISTRICT'.
          <ls_fcat>-no_out = abap_true.
        WHEN 'IS_NKS'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-46l.
          <ls_fcat>-scrtext_m = TEXT-46m.
          <ls_fcat>-scrtext_s = TEXT-46s.
          <ls_fcat>-checkbox = abap_true.
        WHEN 'FLAG'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-47l.
          <ls_fcat>-scrtext_m = TEXT-47m.
          <ls_fcat>-scrtext_s = TEXT-47s.
        WHEN 'OKT1' OR 'OKT2' OR 'OKT3' OR 'OKT4' OR 'GLO_DAT' OR 'DEAKT' OR 'DEAKT_PER' OR 'POSKI' OR
            'POSKI_02' OR 'WAERS' OR 'FLAG' OR 'TAX_QUART' OR 'TXA50'.
          <ls_fcat>-no_out = abap_true.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.


  METHOD on_toolbar2.
    e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
      ( butn_type = 3 )
      ( function = 'SWITCH' icon = icon_view_switch text = TEXT-t20 quickinfo = TEXT-q20 ) ).
  ENDMETHOD.


  METHOD build_quarter.
    rs_result-begda = |{ iv_gjahr }0101|.
    rs_result-begda+4(2) = iv_quarter * 3 - 2.
    rs_result-endda = |{ iv_gjahr }0101|.
    rs_result-endda+4(2) = iv_quarter * 3.

    CALL FUNCTION '/CPD/DATE_GET_MONTH_LASTDAY'
      EXPORTING
        i_date = rs_result-endda
      IMPORTING
        e_date = rs_result-endda.

    READ TABLE me->gs_params-taxrates[] ASSIGNING FIELD-SYMBOL(<ls_rate>) WITH TABLE KEY key = |{ iv_quarter }|.
    IF sy-subrc = 0.
      rs_result-rate = replace( val = <ls_rate>-value sub = ',' with = '.' ).
      READ TABLE me->gs_params-taxrates[] ASSIGNING <ls_rate> INDEX sy-tabix + 1.
      IF sy-subrc = 0.
        rs_result-nks_rate = replace( val = <ls_rate>-value sub = ',' with = '.' ).
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD load_default_sscr.
    CALL FUNCTION 'RS_SUPPORT_SELECTIONS'
      EXPORTING
        report               = sy-cprog
        variant              = CONV rsvar-variant( |@{ sy-uname }| )
      EXCEPTIONS
        variant_not_existent = 1
        variant_obsolete     = 2
        OTHERS               = 3.

    SUPPRESS DIALOG.
  ENDMETHOD.


  METHOD show_warning.
    DATA: lv_message TYPE string.

    lv_message = iv_text.

    lv_message = replace( val = lv_message sub = '&' with = iv_var1 occ = 1 ).
    lv_message = replace( val = lv_message sub = '&' with = iv_var2 occ = 1 ).
    lv_message = replace( val = lv_message sub = '&' with = iv_var3 occ = 1 ).
    lv_message = replace( val = lv_message sub = '&' with = iv_var4 occ = 1 ).

    IF iv_astype IS SUPPLIED.
      MESSAGE lv_message TYPE iv_type DISPLAY LIKE iv_astype.
    ELSE.
      MESSAGE lv_message TYPE iv_type.
    ENDIF.

  ENDMETHOD.


  METHOD f4_variant.
    DATA(ls_vari) = VALUE disvariant( variant = cv_variant report = sy-cprog ).

    CALL FUNCTION 'LVC_VARIANT_F4'
      EXPORTING
        is_variant    = ls_vari
        i_save        = 'A'
      IMPORTING
        es_variant    = ls_vari
      EXCEPTIONS
        not_found     = 1
        program_error = 2
        OTHERS        = 3.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ELSE.
      cv_variant = ls_vari-variant.
    ENDIF.
  ENDMETHOD.


  METHOD check_sscr.
    IF it_bukrs[] IS INITIAL.
      DATA(lv_error) = replace( val = TEXT-e04 sub = '&' with = TEXT-f03 ).
    ELSE.
      rv_ok = abap_true.
    ENDIF.

    IF rv_ok <> abap_true.
      MESSAGE lv_error TYPE 'S'.
    ENDIF.
  ENDMETHOD.


  METHOD on_user_command2.
    CASE e_ucomm.
      WHEN 'SWITCH'.
        gs_params-submode = SWITCH #( gs_params-submode
          WHEN 'A' THEN 'N'
          WHEN 'N' THEN 'P'
          WHEN 'P' OR '' THEN 'A' ).

        me->refresh_secondary( ).
        gr_grid2->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
    ENDCASE.
  ENDMETHOD.


  METHOD get_data.

    IF me->gs_params-report_mode = 'L'.               "Загружено из БД
      EXIT.
    ENDIF.

    f4_budat( EXPORTING iv_date = is_sscr-budat CHANGING cv_quart = is_sscr-nquart ).

    gs_sscr = me->fill_sscr_structure( is_sscr ).

    me->gs_params = VALUE #( BASE me->gs_params
      bukrs   = is_sscr-it_bukrs[]
      format  = is_sscr-format ).

    gs_sscr-dates = SWITCH #( gs_sscr-nquart
      WHEN 1 THEN gs_sscr-quart1
      WHEN 2 THEN gs_sscr-quart2
      WHEN 3 THEN gs_sscr-quart3
      WHEN 4 THEN gs_sscr-quart4 ).

    TRY.
        zfi_cl_proptax_amdp=>get_data(
          EXPORTING
            iv_perio        = gs_sscr-nquart
            iv_ondate       = gs_sscr-budat
            iv_begda        = gs_sscr-begda
            iv_cond         = SWITCH #( me->gs_params-report_mode
                                WHEN 'A' THEN iv_filter
                                ELSE me->prepare_amdp_filter( ) )
            iv_blart        = me->gs_params-blart
            iv_deakt_filter = iv_deakt_filter
          IMPORTING
            et_data         = DATA(lt_proptax)
            et_chain        = me->gt_chain[]        "Sorted by bukrs anln1 anln2
            et_moves        = me->gt_moves[]        "Sorted by bukrs anln1 anln2 bzdat
            et_costs        = me->gt_costs[]        "Sorted by bukrs anln1 anln2 ondate
            et_zanlz_tax    = me->gt_zanlz_tax[]    "Sorted by invnr bdatu adatu
            et_accdocs      = me->gt_accdocs[]      "
            et_month        = me->gt_month[]        "Sorted by key
            et_partial_disp = me->gt_partial[]      "ВДв для частичного выбытия
          ).
      CATCH  cx_root.
        me->show_warning( iv_text = TEXT-e00 iv_var1 = 'get_data' iv_astype = 'E' ).
        RETURN.
    ENDTRY.

    CLEAR me->gs_params-report_mode.

    LOOP AT lt_proptax[] ASSIGNING FIELD-SYMBOL(<ls_dirty>).
      APPEND CORRESPONDING #( <ls_dirty> ) TO rt_data[] ASSIGNING FIELD-SYMBOL(<ls_data>).

      <ls_data>-is_nks = COND #(
        WHEN <ls_data>-anlkl IN me->gs_params-nks_range[] THEN abap_true ).

      "Базы Налога на недвижимость
      me->fill_tax_bases( CHANGING cs_data = <ls_data> ).
      <ls_data>-exempts[] = me->get_exempts( <ls_data> ).
      <ls_data> = VALUE #( BASE <ls_data>
        koeff       =  SWITCH #( <ls_data>-koeff
                          WHEN '' OR '0' THEN 1
                          ELSE <ls_data>-koeff )
        koef_square = SWITCH #( <ls_data>-koef_square
                          WHEN '' OR '0' THEN 1
                          ELSE <ls_data>-koef_square )
        exempt_rate = VALUE #( <ls_data>-exempts[ 1 ]-exempt_rate DEFAULT 0 ) ).

      <ls_data>-is_summ = me->process_taxes( is_data = <ls_data> ).
*      <ls_data>-tax = <ls_data>-is_summ-total.


      "Занулить сумму базы, если выбыло до расчетного периода.
      "Однако НнН за периоды до (включительно) рассчитывается.
      IF <ls_data>-deakt IS NOT INITIAL AND <ls_data>-deakt < gs_sscr-begda.
        <ls_data>-is_summ-base = 0.
        <ls_data>-is_summ-tax = 0.
      ENDIF.
    ENDLOOP.

    gs_params-submode = 'A'.

    "Удаляем по фильтрам ОС и НКС, поскольку при фильтрации на стороне AMDP использовался "сборный" фильтр из ОС и НКС
    DELETE rt_data[] WHERE
      ( is_nks = abap_true AND NOT ( anln1 IN gs_sscr-it_anln1_nks[] AND anln2 IN gs_sscr-it_anln2_nks[] ) ) OR
      ( is_nks = abap_false AND NOT ( anln1 IN gs_sscr-it_anln1[] AND anln2 IN gs_sscr-it_anln2[] ) ).

    IF NOT rt_data IS REQUESTED.
      me->gt_data[] = rt_data[].
      SORT me->gt_data[].
    ENDIF.
  ENDMETHOD.


  METHOD fill_secondary_table.

    CLEAR gt_summ[].

    LOOP AT gt_data[] ASSIGNING FIELD-SYMBOL(<ls_data>) WHERE checked = abap_true.
      gt_summ[] = VALUE #( BASE gt_summ[]
        ( <ls_data>-is_summ ) ).
    ENDLOOP.

    me->refresh_secondary( ).
  ENDMETHOD.


  METHOD refresh_secondary.
    DATA: lv_done TYPE bseg-dmbtr,
          ls_data TYPE lty_s_summ.

    LOOP AT gt_summ[] ASSIGNING FIELD-SYMBOL(<ls_summ>).
      ls_data = gt_data[ bukrs = <ls_summ>-bukrs
                         anln1 = <ls_summ>-anln(12)
                         anln2 = <ls_summ>-anln+13(4) ]-is_summ.


      LOOP AT me->gt_month[] ASSIGNING FIELD-SYMBOL(<ls_month>).
        CLEAR: lv_done.
        ASSIGN COMPONENT <ls_month>-key OF STRUCTURE <ls_summ> TO FIELD-SYMBOL(<lv_dst>).
        ASSIGN COMPONENT <ls_month>-key OF STRUCTURE ls_data TO FIELD-SYMBOL(<lv_data>).
        CHECK <lv_dst> IS ASSIGNED AND <lv_data> IS ASSIGNED.

        LOOP AT gt_accdocs[] ASSIGNING FIELD-SYMBOL(<ls_accdoc>) WHERE bukrs = <ls_summ>-bukrs
                                                                   AND anln  = <ls_summ>-anln
                                                                   AND gjahr = gs_params-budat(4)
                                                                   AND budat+4(2) = <ls_month>-mnr.
          lv_done = lv_done + <ls_accdoc>-dmbtr.
        ENDLOOP.

        CASE gs_params-submode.
          WHEN 'A'.
            <lv_dst> = <lv_data> - lv_done.
          WHEN 'N'.
            <lv_dst> = <lv_data>.
          WHEN 'P'.
            <lv_dst> = lv_done.
          WHEN ''.
        ENDCASE.

        UNASSIGN: <lv_dst>, <lv_data>.
      ENDLOOP.

      me->fill_quart_totals( CHANGING cs_summ = <ls_summ> ).
    ENDLOOP.

    gr_grid2->set_gridtitle( SWITCH #( gs_params-submode
      WHEN 'A' THEN TEXT-t17
      WHEN 'N' THEN TEXT-t18
      WHEN 'P' THEN TEXT-t19 ) ).

  ENDMETHOD.


  METHOD if_f4callback_value_request~f4_call_callback.

    cs_shlp-interface = VALUE #(
      ( shlpfield = 'F0001' valfield  = 'BUKRS' f4field = 'X' )
      ( shlpfield = 'F0002' valfield  = 'GJAHR' f4field = 'X' )
      ( shlpfield = 'F0003' valfield  = 'PTAX_TYPE' f4field = 'X' )
      ).

    ASSIGN cs_shlp-fielddescr[ lfieldname = 'PTAX_TYPE' ] TO FIELD-SYMBOL(<ls_descr>).
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    <ls_descr> = VALUE #( BASE <ls_descr>
      fieldtext = TEXT-01l
      reptext   = TEXT-01l
      scrtext_s = TEXT-01s
      scrtext_m = TEXT-01m
      scrtext_l = TEXT-01l ).

  ENDMETHOD.


  METHOD show_subreport.
    DATA: lv_name   TYPE seoclass-clsname,
          lr_subrep TYPE REF TO lcl_additional.

    IF me->gs_params-fcode IS INITIAL.
      RETURN.
    ENDIF.

    lv_name = 'LCL_' && me->gs_params-fcode.

    TRY.
        CREATE OBJECT lr_subrep TYPE (lv_name)
          EXPORTING
            ir_parent   = me
            is_sscr     = me->gs_sscr.
      CATCH cx_sy_create_object_error.
        me->gs_params-error = replace( val = TEXT-e08 sub = '&' with = lv_name ).
        RETURN.
    ENDTRY.
    gr_subrep = lr_subrep.

    IF lr_subrep->prepare_results( ).
      lr_subrep->show_results( ).
      rv_ok = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD prepare_results.
    "Dummy here
  ENDMETHOD.


  METHOD recurs_find_os.
    IF iv_begda <= me->gs_sscr-seldats-begda.
      ASSIGN me->gt_costs[ bukrs = iv_bukrs
                           anln1 = iv_anln1
                           anln2 = iv_anln2
                           ondate = me->gs_sscr-seldats-begda ] TO FIELD-SYMBOL(<ls_cost>).
      IF sy-subrc = 0.
        cs_data-is_costs = me->fill_costs( is_data = cs_data ).
      ENDIF.
    ELSE.
      ASSIGN me->gt_chain[ bukrs = iv_bukrs anln1 = iv_anln1 anln2 = iv_anln2 ] TO FIELD-SYMBOL(<ls_chain>).
      IF sy-subrc = 0.
        ASSIGN me->gt_chain[ bukrs = <ls_chain>-aibkr anln1 = <ls_chain>-aibn1 anln2 = <ls_chain>-aibn2 ] TO <ls_chain>.
        IF sy-subrc = 0.
          me->recurs_find_os(
            EXPORTING
              iv_bukrs = <ls_chain>-bukrs
              iv_anln1 = <ls_chain>-anln1
              iv_anln2 = <ls_chain>-anln2
              iv_begda = <ls_chain>-begda
            CHANGING
              cs_data = cs_data ).
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD store_setup.
    DATA: lt_tvarvc TYPE STANDARD TABLE OF tvarvc,
          lv_field  TYPE fieldname.


    FIELD-SYMBOLS: <lt_range> TYPE STANDARD TABLE.

    "Обработка параметров - процентных ставок
    DO 4 TIMES.
      lv_field = |IV_{ CONV numc1( sy-index ) }|.
      ASSIGN (lv_field) TO FIELD-SYMBOL(<lv_src>).

      lt_tvarvc[] = VALUE #( BASE lt_tvarvc
        ( name = sy-cprog && '-' && CONV numc1( sy-index )
          type = 'P'
          low = replace( val = shift_left( val = <lv_src> ) sub = '.' with = ',' )
        ) ).

      lv_field = |{ lv_field }_NKS|.
      ASSIGN (lv_field) TO <lv_src>.

      lt_tvarvc[] = VALUE #( BASE lt_tvarvc
        ( name = sy-cprog && '-' && CONV numc1( sy-index ) && '_NKS'
          type = 'P'
          low = replace( val = shift_left( val = <lv_src> ) sub = '.' with = ',' )
        ) ).
    ENDDO.

    "Обработка опций
    DO 3 TIMES.
      CASE sy-index.
        WHEN 1.
          ASSIGN it_incom[] TO <lt_range>.
          lv_field = 'ZFI_PROPTAX-INCOMES'.
        WHEN 2.
          ASSIGN it_moves[] TO <lt_range>.
          lv_field = 'ZFI_PROPTAX-MOVES'.
        WHEN 3.
          ASSIGN it_nkscl[] TO <lt_range>.
          lv_field = 'ZFI_PROPTAX-NKS_CLASS'.
        WHEN OTHERS.
          CONTINUE.
      ENDCASE.

      DELETE lt_tvarvc[] WHERE name = lv_field.

      LOOP AT <lt_range>[] ASSIGNING FIELD-SYMBOL(<ls_range>).
        DATA(ls_range) = CORRESPONDING ucon_browser_range_url_char( <ls_range> ).
        lt_tvarvc[] = VALUE #( BASE lt_tvarvc[]
          ( name = lv_field
            type = 'S'
            numb  = sy-tabix - 1
            sign  = ls_range-sign
            opti  = ls_range-option
            low   = ls_range-low
            high  = ls_range-high
          ) ).
      ENDLOOP.
    ENDDO.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = TEXT-t09
        text_question         = TEXT-t10
        icon_button_1         = 'ICON_OKAY'
        icon_button_2         = 'ICON_CANCEL'
        display_cancel_button = abap_false
        popup_type            = 'ICON_MESSAGE_WARNING'
      IMPORTING
        answer                = rv_result
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF sy-subrc <> 0 OR rv_result <> 1.
      RETURN.
    ENDIF.

    DATA(lv_like) = |{ sy-cprog }-%|.
    DELETE FROM tvarvc WHERE name LIKE lv_like.
    IF sy-subrc = 0.
      MODIFY tvarvc FROM TABLE lt_tvarvc[].
      IF sy-subrc = 0.
        COMMIT WORK.

        rv_result = abap_true.
        MESSAGE s999 WITH TEXT-t12.
      ELSE.
        rv_result = 'M'.
        MESSAGE e999 WITH TEXT-t11 '-(' rv_result ')'.
      ENDIF.
    ELSE.
      rv_result = 'D'.
      MESSAGE e999 WITH TEXT-t11 '-(' rv_result ')'.
    ENDIF.

  ENDMETHOD.


  METHOD on_double_click.
    me->refresh_grid2( ).

    CASE e_column.
      WHEN 'STATUS'.
        me->show_log( EXPORTING iv_index = e_row-index ).
      WHEN 'ANLN_FULL' OR 'INVNR'.
        me->view_asset( EXPORTING iv_index = e_row-index ).
    ENDCASE.
  ENDMETHOD.


  METHOD on_data_changed2.
    IF e_modified = abap_false.
      RETURN.
    ENDIF.

    LOOP AT et_good_cells[] ASSIGNING FIELD-SYMBOL(<ls_cell>).
      TRY.
          ASSIGN gt_summ[ <ls_cell>-row_id ] TO FIELD-SYMBOL(<ls_summ>).
        CATCH cx_sy_itab_line_not_found.
          RETURN.
      ENDTRY.

      TRY.
          ASSIGN gt_data[ bukrs = <ls_summ>-bukrs
                          anln1 = <ls_summ>-anln(12)
                          anln2 = <ls_summ>-anln+13(4) ] TO FIELD-SYMBOL(<ls_data>).
        CATCH cx_sy_itab_line_not_found.
          RETURN.
      ENDTRY.

      IF <ls_cell>-fieldname = 'BASE'.
        <ls_data>-is_summ-base = <ls_summ>-base.
        <ls_data>-is_summ = me->process_taxes( is_data = <ls_data> ).
      ELSE. "Месяца jan-dec.
        ASSIGN COMPONENT <ls_cell>-fieldname OF STRUCTURE <ls_data>-is_summ TO FIELD-SYMBOL(<lv_summ>).
        ASSIGN COMPONENT <ls_cell>-fieldname OF STRUCTURE <ls_summ> TO FIELD-SYMBOL(<lv_currsumm>).
        CHECK <lv_summ> IS ASSIGNED AND <lv_currsumm> IS ASSIGNED.

        DATA(lv_distr) = <lv_summ> - <lv_currsumm>.
        READ TABLE me->gt_month[] TRANSPORTING NO FIELDS WITH KEY key = <ls_cell>-fieldname.
        "Если есть возможность - записать разницу на след. месяц.
        TRY.
            DATA(lv_dst_month) = me->gt_month[ sy-tabix + 1 ]-key.
          CATCH cx_root.
            <lv_summ> = <lv_currsumm>.
            CONTINUE.
        ENDTRY.
        UNASSIGN: <lv_summ>, <lv_currsumm>.

        ASSIGN COMPONENT lv_dst_month OF STRUCTURE <ls_summ> TO <lv_summ>.
        ASSIGN COMPONENT lv_dst_month OF STRUCTURE <ls_data>-is_summ TO <lv_currsumm>.
        CHECK <lv_summ> IS ASSIGNED AND <lv_currsumm> IS ASSIGNED.
        <lv_summ> = <lv_currsumm> + lv_distr.
        UNASSIGN: <lv_summ>, <lv_currsumm>.

        me->fill_quart_totals( CHANGING cs_summ = <ls_summ> ).
        <ls_summ>-tax = <ls_summ>-total.
        gs_params-submode = ''.
      ENDIF.
    ENDLOOP.

    me->refresh_secondary( ).
    gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
    gr_grid2->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
  ENDMETHOD.


  METHOD get_current_format.
    rv_format = gs_sscr-format.
  ENDMETHOD.


  METHOD perform_selection.
    LOOP AT gt_data[] ASSIGNING FIELD-SYMBOL(<ls_data>).
      <ls_data>-checked = SWITCH #( im_ucomm
        WHEN 'SELECT_ALL' THEN abap_true
        WHEN 'DESELECT_ALL' THEN abap_false
        WHEN 'REVERT_SELECTION' THEN SWITCH #( <ls_data>-checked
          WHEN abap_true THEN abap_false
          WHEN abap_false THEN abap_true ) ).
    ENDLOOP.

    gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).

  ENDMETHOD.


  METHOD on_delayed_callback.
    me->refresh_grid2( ).
  ENDMETHOD.


  METHOD process_taxes.
    DATA: lv_mncount TYPE i VALUE 12,
          lv_pemonth TYPE i VALUE 1,
          lv_pkoeff  TYPE f,
          lv_tkoeff  TYPE f,
          lv_1st_mnr TYPE i.

    "Если поступил ранее (tax_date < month )
    "Если не активен на дату
    "Если освобождение от налога не 100%
    LOOP AT me->gt_month[] ASSIGNING FIELD-SYMBOL(<ls_month>).
      CLEAR <ls_month>-flag.

      DATA(lv_checkdate) = |{ gs_sscr-begda(4) }{ <ls_month>-mnr }01|.

      "Коэффициент (множитель) ставки       "24185 #16
      LOOP AT me->gt_zanlz_tax[] ASSIGNING FIELD-SYMBOL(<ls_tax>) WHERE invnr = is_data-invnr
                                                                    AND adatu <= lv_checkdate
                                                                    AND bdatu >= lv_checkdate.
        lv_tkoeff = <ls_month>-tax_koeff = <ls_tax>-rate.
        EXIT.
      ENDLOOP.
      IF sy-subrc <> 0.
        lv_tkoeff = <ls_month>-tax_koeff.
      ENDIF.

      IF is_data-tax_date > lv_checkdate.
        <ls_month>-flag = 'I'.         "Inactive, ОС еще не поступил
        lv_tkoeff = 0.
        lv_mncount = lv_mncount - 1.
        CONTINUE.
      ENDIF.

      IF is_data-deakt IS NOT INITIAL.
        "1-е число квартала, следующего за выбытием
        DATA(lv_deakt_qdate) = |{ is_data-tax_date(4) }{ CONV numc2( ( ( is_data-deakt+4(2) - 1 ) DIV 3 + 1 ) * 3 + 1 ) }01|.
        IF lv_deakt_qdate IS NOT INITIAL AND lv_checkdate >= lv_deakt_qdate.
          lv_tkoeff = 0.
          <ls_month>-flag = 'R'.                                        "Inactive, ОС выбыл
          CONTINUE.
        ENDIF.
      ENDIF.

      LOOP AT me->gt_zanlz_tax[] ASSIGNING <ls_tax> WHERE invnr = is_data-invnr
                                                      AND adatu <= lv_checkdate
                                                      AND bdatu >= lv_checkdate
                                                      AND is_exempt = abap_true.
        <ls_month>-flag = 'P'.
        DATA(lv_exempt) = abap_true.
        IF <ls_tax>-sqare = 0 OR <ls_tax>-sqare = <ls_tax>-sqarenb.
          lv_tkoeff = 0.
          EXIT.
        ELSE.
          lv_tkoeff = <ls_tax>-square_koeff.
        ENDIF.
      ENDLOOP.
      IF sy-subrc = 0.
        IF <ls_month>-mnr = 12 AND lv_exempt = abap_true.
          "Льготируется всю дорогу
          lv_pemonth = <ls_month>-mnr.
        ENDIF.
      ELSE.
        IF lv_pemonth = 1 AND lv_exempt = abap_true.
          lv_pemonth = <ls_month>-mnr.
        ENDIF.
      ENDIF.
    ENDLOOP.

    "Если месяц окончания льготирования меньше, чем конец выборки - учитываем как понижающий коэфф.
    lv_pkoeff = COND #( WHEN lv_pemonth < gs_sscr-endda+4(2)
                          THEN ( 13 - lv_pemonth ) / 12
                          ELSE 1 ).
    rs_nnn = VALUE #(
      bukrs   = is_data-bukrs
      anln    = is_data-anln_full
      base    = is_data-is_summ-base
      caufn   = is_data-caufn
      kostl   = is_data-kostl
      posnr   = is_data-posnr
      tax     = ( ( lv_mncount / 12 ) * lv_pkoeff * is_data-is_summ-base * is_data-koeff / 100 )
                                                                                    * is_data-rate " # 20106
      extax   = is_data-exempt_rate * lv_pkoeff * is_data-exemption_sum * is_data-koeff / 100
      monthly = round( val = rs_nnn-tax / lv_pkoeff / lv_mncount  dec = 2 mode = cl_abap_math=>round_down ) ).

    DATA: BEGIN OF ls_count,
            total   TYPE maxbt,
            monthly TYPE maxbt,
            summ    TYPE maxbt,
          END OF ls_count.

    ls_count = VALUE #( total   = <ls_month>-tax_koeff * rs_nnn-base * is_data-koeff / 100
                        summ    = 0 ).

    LOOP AT me->gt_month[] ASSIGNING <ls_month>.

      ASSIGN COMPONENT <ls_month>-key OF STRUCTURE rs_nnn TO FIELD-SYMBOL(<lv_dst>).
      CHECK <lv_dst> IS ASSIGNED.

* --> AK_BUTVILOVS #25716 ZFI_PROPTAX - Расчет налога на недвижимость
**     <lv_dst> = rs_nnn-monthly.                                                  "#25650 - неверный расчет
*      <lv_dst> = SWITCH #( <ls_month>-flag WHEN '' THEN rs_nnn-monthly ELSE 0 ).

      <lv_dst> = COND #( WHEN <ls_month>-flag = '' OR ( <ls_month>-flag = 'P' AND is_data-exemption_sum <> 0 ) THEN rs_nnn-monthly
                         ELSE 0 ).
* <-- AK_BUTVILOVS #25716

      "Только для льготируемых, если льгота уже закончилась, прежние месяца выводим с коэфф. льготы
      IF lv_pemonth > 1 AND lv_pkoeff <> 1.
        IF <ls_month>-mnr < gs_sscr-begda+4(2).
          <lv_dst> = <lv_dst> * lv_tkoeff.
        ENDIF.
      ENDIF.

      IF lv_tkoeff <> 1.
        DATA(lv_offset) = <ls_month>-mnr - 1.
        rs_nnn-exmonth+lv_offset(1) = abap_true.
        rs_nnn-colors[] = VALUE #( BASE rs_nnn-colors[]
        ( fname = <ls_month>-key color = SWITCH #( <ls_month>-flag
                                                  "P - льготирование (0-100%), 'I'nactive, 'R'etired
                                                  WHEN 'P' THEN VALUE #( col = 5 int = 0 inv = 0 )
                                                  WHEN 'I' OR 'R' THEN VALUE #( col = 6 int = 0 inv = 0 ) ) ) ).
      ENDIF.

      IF <lv_dst> > 0 AND lv_1st_mnr = 0.
        lv_1st_mnr = <ls_month>-mnr.
      ENDIF.

      ADD <lv_dst> TO ls_count-summ.
    ENDLOOP.

    "24185 #16 - хвоста не будет, все данные просчитаны во Float согласно коэфф.
*    "Оставшийся хвост - в первый налогооблагаемый месяц.
    IF lv_1st_mnr <> 0.
      ASSIGN COMPONENT me->gt_month[ mnr = lv_1st_mnr ]-key OF STRUCTURE rs_nnn TO <lv_dst>.
      IF <lv_dst> IS ASSIGNED.
        <lv_dst> = rs_nnn-tax - rs_nnn-monthly * lv_pkoeff * lv_mncount + <lv_dst>.
      ENDIF.
    ENDIF.

    "Если 100% льготировано на дату tax_date, зануляем базы и суммы НнН,
    "оставляя рассчитанные суммы помесчно / поквартально
    "(вычисление коффициента, кода освобождения  - в fill_tax_bases)
    IF is_data-exemption <> '' AND lv_pemonth > gs_sscr-endda+4(2).
      IF me->gt_month[ mnr = gs_sscr-endda+4(2) ]-tax_koeff = 0.
        rs_nnn-base = 0.
        rs_nnn-tax = 0.
      ENDIF.
    ENDIF.

    me->fill_quart_totals( CHANGING cs_summ = rs_nnn ).

  ENDMETHOD.


  METHOD on_data_changed.

    IF e_modified = abap_false.
      RETURN.
    ENDIF.

    LOOP AT et_good_cells[] ASSIGNING FIELD-SYMBOL(<ls_cell>).
      TRY.
          ASSIGN gt_data[ <ls_cell>-row_id ] TO FIELD-SYMBOL(<ls_data>).
          CHECK sy-subrc = 0.
        CATCH cx_sy_itab_line_not_found.
          RETURN.
      ENDTRY.

      IF <ls_cell>-fieldname = 'IS_SUMM-BASE'.
        <ls_data>-is_summ = me->process_taxes( is_data = <ls_data> ).
      ENDIF.
    ENDLOOP.

    me->refresh_grid2( ).
    gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).

  ENDMETHOD.


  METHOD refresh_grid2.
    gr_grid->get_selected_cells( IMPORTING et_cell = DATA(lt_cell) ).

    IF lt_cell[] IS INITIAL.
      RETURN.
    ENDIF.

    me->fill_secondary_table(  ).

    TRY.
        ASSIGN gt_data[ lt_cell[ 1 ]-row_id ] TO FIELD-SYMBOL(<ls_data>).
      CATCH cx_sy_conversion_no_number.
        RETURN.
    ENDTRY.

    IF im_refresh = abap_false.
      RETURN.
    ENDIF.

    gr_grid2->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).

  ENDMETHOD.


      METHOD fill_costs.

        READ TABLE gt_costs[] ASSIGNING FIELD-SYMBOL(<ls_cost>) WITH KEY bukrs  = is_data-bukrs
                                                                         anln1  = is_data-anln1
                                                                         anln2  = is_data-anln2
                                                                         ondate = is_data-tax_date
                                                                BINARY SEARCH.
        IF sy-subrc <> 0.

          RETURN.
        ENDIF.
        rs_cost = VALUE #(
          kansw = <ls_cost>-start_cost + <ls_cost>-cost_change
          amort = SWITCH knafa( gs_sscr-is_plan WHEN abap_true
                      "04.04.2019 - в плановую включать фактически проведенную
                      THEN
                      <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-plan_amort + <ls_cost>-fact_amort
                      ELSE <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-fact_amort ) * -1
          netvl = rs_cost-kansw - rs_cost-amort ).
*--> V.Zaretsky - #30891 Расчет амортизации при перемещении между БЕ
        " Движение перемещения
        DATA: lv_knafa_sum TYPE anlc-knafa,
              lv_move      TYPE abap_bool.
        LOOP AT gt_moves ASSIGNING FIELD-SYMBOL(<ls_move>) WHERE budat < gs_params-budat
                                                  AND bwasl IN gs_params-bwasl_change
                                                  AND bukrs = is_data-bukrs
                                                  AND anln1 = is_data-anln1
                                                  AND anln2 = is_data-anln2.
         IF is_data-aktiv(4) < <ls_move>-gjahr.
           SELECT SUM( ABS( nafav ) + ABS( aafav ) ) AS SUM
             INTO @DATA(lv_knafa)
             FROM anea
             WHERE anea~bukrs = @is_data-bukrs
             AND anea~anln1 = @is_data-anln1
             AND anea~anln2 = @is_data-anln2
             AND anea~afabe = '01'
             AND anea~gjahr = @<ls_move>-gjahr.
           lv_knafa_sum = lv_knafa_sum + lv_knafa.
           lv_move = abap_true.
         ENDIF.
        ENDLOOP.
        IF lv_move IS NOT INITIAL AND gs_sscr-is_plan = abap_true.
          rs_cost-amort = lv_knafa_sum.
          rs_cost-netvl = rs_cost-kansw - rs_cost-amort.
        ENDIF.
*<-- V.Zaretsky - #30891 Расчет амортизации при перемещении между БЕ
*--> #8000000096 AK_BUTVILOVS Налог-Объединение ОС
        DATA:
          lv_ondate TYPE dats,
          lv_quart  TYPE i.

        FIELD-SYMBOLS <ls_chain> TYPE zfi_cl_proptax_amdp=>gty_s_chain.

        " Движение объединения
        LOOP AT gt_moves TRANSPORTING NO FIELDS WHERE budat < gs_params-budat
                                                  AND bwasl IN gs_params-bwasl_add
                                                  AND bukrs = is_data-bukrs
                                                  AND anln1 = is_data-anln1
                                                  AND anln2 = is_data-anln2.
          EXIT.
        ENDLOOP.
        IF sy-subrc = 0.
          LOOP AT gt_chain ASSIGNING <ls_chain> WHERE anln1   = is_data-aibn1
                                                  AND anln2   = is_data-aibn2
                                                  AND bukrs   = is_data-bukrs.
            CLEAR:
              lv_quart,
              lv_ondate.

            lv_quart = ( ( <ls_chain>-begda+4(2) - 1 ) DIV 3 ) + 1.

            IF <ls_chain>-begda(6) < gs_sscr-seldats-begda(6).
              lv_ondate = gs_sscr-seldats-begda.
            ELSEIF <ls_chain>-begda BETWEEN gs_sscr-seldats-begda AND gs_sscr-seldats-endda.
              lv_ondate = SWITCH sy-datum( lv_quart
                              WHEN 4 THEN CONV sy-datum( |{ gs_sscr-seldats-begda(4) }1231| ) + 1
                              ELSE |{ gs_sscr-seldats-begda(4) }{ CONV numc2( lv_quart * 3 + 1 ) }01| ).
            ENDIF.

            READ TABLE gt_costs ASSIGNING <ls_cost> WITH KEY bukrs  = <ls_chain>-bukrs
                                                             anln1  = <ls_chain>-anln1
                                                             anln2  = <ls_chain>-anln2
                                                             ondate = lv_ondate
                                                     BINARY SEARCH.
            IF sy-subrc <> 0.
              CONTINUE.
            ENDIF.

            CHECK <ls_cost> IS ASSIGNED.
            rs_cost-kansw = rs_cost-kansw + <ls_cost>-start_cost + <ls_cost>-cost_change.
            rs_cost-amort = rs_cost-amort + ( SWITCH knafa( gs_sscr-is_plan WHEN abap_true
                                                                            THEN <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-plan_amort + <ls_cost>-fact_amort
                                                                            ELSE <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-fact_amort ) * -1 ).
            rs_cost-netvl = rs_cost-netvl +
                            ( <ls_cost>-start_cost + <ls_cost>-cost_change ) -           " rs_cost-kansw
                            ( ( SWITCH knafa( gs_sscr-is_plan WHEN abap_true             " rs_cost-amort
                                                              THEN <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-plan_amort + <ls_cost>-fact_amort
                                                              ELSE <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-fact_amort ) * -1 ) ).
          ENDLOOP.
        ENDIF.

        " Движение разукрупнения
        LOOP AT gt_moves TRANSPORTING NO FIELDS WHERE budat < gs_params-budat
                                                  AND bwasl IN gs_params-bwasl_div
                                                  AND bukrs = is_data-bukrs
                                                  AND anln1 = is_data-anln1
                                                  AND anln2 = is_data-anln2.
          EXIT.
        ENDLOOP.
        CHECK sy-subrc = 0.

        LOOP AT gt_chain ASSIGNING <ls_chain> WHERE aibn1   = is_data-anln1
                                                AND aibn2   = is_data-anln2
                                                AND bukrs   = is_data-bukrs.

          lv_quart = ( ( <ls_chain>-begda+4(2) - 1 ) DIV 3 ) + 1.

          IF <ls_chain>-begda(6) < gs_sscr-seldats-begda(6).
            lv_ondate = gs_sscr-seldats-begda.
          ELSEIF <ls_chain>-begda BETWEEN gs_sscr-seldats-begda AND gs_sscr-seldats-endda.
            lv_ondate = SWITCH sy-datum( lv_quart
                            WHEN 4 THEN CONV sy-datum( |{ gs_sscr-seldats-begda(4) }1231| ) + 1
                            ELSE |{ gs_sscr-seldats-begda(4) }{ CONV numc2( lv_quart * 3 + 1 ) }01| ).
          ENDIF.

*          CHECK lv_ondate BETWEEN gs_sscr-endda AND gs_params-budat.

          READ TABLE gt_costs ASSIGNING <ls_cost> WITH KEY bukrs  = <ls_chain>-bukrs
                                                           anln1  = <ls_chain>-anln1
                                                           anln2  = <ls_chain>-anln2
                                                           ondate = lv_ondate
                                                   BINARY SEARCH.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.

          CHECK <ls_cost> IS ASSIGNED.
          rs_cost-kansw = rs_cost-kansw - ( <ls_cost>-start_cost + <ls_cost>-cost_change ).
          rs_cost-amort = rs_cost-amort - ( SWITCH knafa( gs_sscr-is_plan WHEN abap_true
                      THEN <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-plan_amort + <ls_cost>-fact_amort
                      ELSE <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-fact_amort ) * -1 ).
          rs_cost-netvl = rs_cost-netvl -
                            ( <ls_cost>-start_cost + <ls_cost>-cost_change ) +           " rs_cost-kansw
                            ( ( SWITCH knafa( gs_sscr-is_plan WHEN abap_true             " rs_cost-amort
                                                              THEN <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-plan_amort + <ls_cost>-fact_amort
                                                              ELSE <ls_cost>-start_amort + <ls_cost>-amort_change + <ls_cost>-fact_amort ) * -1 ) ).
        ENDLOOP.
*<-- #8000000096 AK_BUTVILOVS
      ENDMETHOD.


  METHOD fill_month_data.
    DATA: lv_oldflag TYPE flag.

    rt_month[] = me->gt_month[].

    "Если поступил ранее (tax_date < month )
    "Если не активен на дату
    "Если освобождение от налога не 100%
    LOOP AT rt_month[] ASSIGNING FIELD-SYMBOL(<ls_month>).
      DATA(lv_checkdate) = |{ gs_sscr-begda(4) }{ <ls_month>-mnr }01|.
      IF is_data-tax_date > lv_checkdate.
        <ls_month>-flag = 'I'.                                          "Inactive, ОС еще не поступил
        <ls_month>-tax_koeff = 0.
        CONTINUE.
      ENDIF.

      IF is_data-deakt IS NOT INITIAL.
        "1-е число квартала, следующего за выбытием
        DATA(lv_deakt_qdate) = |{ is_data-tax_date(4) }{ CONV numc2( ( ( is_data-deakt+4(2) - 1 ) DIV 3 + 1 ) * 3 + 1 ) }01|.
        IF lv_deakt_qdate IS NOT INITIAL AND lv_checkdate >= lv_deakt_qdate.
          <ls_month>-tax_koeff = 0.
          <ls_month>-flag = 'R'.                                        "Inactive, ОС выбыл
          CONTINUE.
        ENDIF.
      ENDIF.

      LOOP AT me->gt_zanlz_tax[] ASSIGNING FIELD-SYMBOL(<ls_tax>) WHERE invnr = is_data-invnr
                                                                    AND adatu <= lv_checkdate
                                                                    AND bdatu >= lv_checkdate.
        <ls_month>-tax_koeff = <ls_tax>-square_koeff.
        IF <ls_tax>-is_exempt = abap_true.
          <ls_month>-flag = 'P'.
        ELSEIF ( lv_oldflag = 'P' OR lv_oldflag = 'U' ) AND <ls_tax>-is_exempt <> abap_true.
          <ls_month>-flag = 'U'.
        ENDIF.
        lv_oldflag = <ls_month>-flag.
        IF <ls_tax>-sqare = 0 OR <ls_tax>-sqare = <ls_tax>-sqarenb.
          <ls_month>-tax_koeff = 0.
          EXIT.
        ENDIF.
      ENDLOOP.

    ENDLOOP.
  ENDMETHOD.


  METHOD on_hotspot.
    me->view_asset( EXPORTING iv_index = e_row_id-index ).
  ENDMETHOD.


  METHOD on_user_command.
    CASE e_ucomm.
      WHEN 'DOC_POST'.
        me->post_documents( ).
      WHEN 'SELECT_ALL' OR 'DESELECT_ALL' OR 'REVERT_SELECTION'.
        me->perform_selection( e_ucomm ).
        me->refresh_grid2( ).
      WHEN 'ADD'.
        me->gs_params-fcode = e_ucomm.
        CALL FUNCTION 'SAPGUI_SET_FUNCTIONCODE'
          EXPORTING
            functioncode = 'ADD_RECORD'.
      WHEN 'DEL'.
        me->delete_record( ).
      WHEN 'EDT'.
        CALL FUNCTION 'SAPGUI_SET_FUNCTIONCODE'
          EXPORTING
            functioncode = 'EDIT_RECORD'.
      WHEN 'SAVE'.
        gv_mode = ''.
        gr_grid->set_toolbar_interactive( ).
      WHEN 'CANC'.
        gv_mode = ''.
        gr_grid->set_toolbar_interactive( ).
      WHEN 'SAVE_TO_DB'.
        me->save_results( ).
      WHEN OTHERS.
        me->gs_params-fcode = e_ucomm.
        CALL FUNCTION 'SAPGUI_SET_FUNCTIONCODE'
          EXPORTING
            functioncode = 'SUBREP'.
    ENDCASE.
  ENDMETHOD.


  METHOD prepare_amdp_filter.
    " AK_BUTVILOVS #8000000241, ZFI_PROPTAX Доработка отбора по параметрам
    DATA: lv_sql_cond_tmp TYPE string.

    DATA(lt_anlkl) = gs_sscr-it_anlkl[].
    IF lt_anlkl[] IS INITIAL.
      lt_anlkl[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.
    APPEND LINES OF gs_sscr-it_anlkl_nks[] TO lt_anlkl[].

    DATA(lt_anln1) = gs_sscr-it_anln1[].
    IF lt_anln1[] IS INITIAL.
      lt_anln1[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.
    APPEND LINES OF gs_sscr-it_anln1_nks[] TO lt_anln1[].

    DATA(lt_anln2) = gs_sscr-it_anln2[].
    IF lt_anln2[] IS INITIAL.
      lt_anln2[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.
    APPEND LINES OF gs_sscr-it_anln2_nks[] TO lt_anln2[].

    " AK_BUTVILOVS #8000000241, ZFI_PROPTAX Доработка отбора по параметрам
    DATA(lt_okt1) = gs_sscr-it_okt1[].
    IF lt_okt1[] IS INITIAL.
      lt_okt1[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.

    DATA(lt_okt2) = gs_sscr-it_okt2[].
    IF lt_okt2[] IS INITIAL.
      lt_okt2[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.

    DATA(lt_okt3) = gs_sscr-it_okt3[].
    IF lt_okt3[] IS INITIAL.
      lt_okt3[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.

    DATA(lt_okt4) = gs_sscr-it_okt4[].
    IF lt_okt4[] IS INITIAL.
      lt_okt4[] = VALUE #( ( sign = 'I' option = 'CP' low = '*' ) ).
    ENDIF.
    " end AK_BUTVILOVS #8000000241

    TRY.
        rv_result = cl_shdb_seltab=>combine_seltabs(
            it_named_seltabs = VALUE #(
              ( name = 'BUKRS'  dref = REF #( gs_sscr-it_bukrs[] ) )
              ( name = 'ANLN1'  dref = REF #( lt_anln1[] ) )
              ( name = 'ANLN2'  dref = REF #( lt_anln2[] ) )
              ( name = 'ANLKL'  dref = REF #( lt_anlkl[] ) )
              " AK_BUTVILOVS #8000000241, ZFI_PROPTAX Доработка отбора по параметрам
              ( name = 'OKT1'   dref = REF #( lt_okt1[] ) )
              ( name = 'OKT2'   dref = REF #( lt_okt2[] ) )
              ( name = 'OKT3'   dref = REF #( lt_okt3[] ) )
              ( name = 'OKT4'   dref = REF #( lt_okt4[] ) ) ) ).
              " end AK_BUTVILOVS #8000000241
      CATCH cx_shdb_exception.
        RETURN.
    ENDTRY.

    " AK_BUTVILOVS #8000000241, ZFI_PROPTAX Доработка отбора по параметрам
    CLEAR lv_sql_cond_tmp.
    IF gs_sscr-rate IS NOT INITIAL.
      lv_sql_cond_tmp = | RATE = '{ gs_sscr-rate }' |.
      lv_sql_cond_tmp = `(` && lv_sql_cond_tmp && `)`.

      IF rv_result IS INITIAL.
        rv_result = lv_sql_cond_tmp.
      ELSE.
        rv_result = rv_result && ` AND ` && lv_sql_cond_tmp.
      ENDIF.
    ENDIF.

    CLEAR lv_sql_cond_tmp.
    IF gs_sscr-koeff IS NOT INITIAL.
      lv_sql_cond_tmp = | KOEFF = '{ gs_sscr-koeff }' |.
      lv_sql_cond_tmp = `(` && lv_sql_cond_tmp && `)`.

      IF rv_result IS INITIAL.
        rv_result = lv_sql_cond_tmp.
      ELSE.
        rv_result = rv_result && ` AND ` && lv_sql_cond_tmp.
      ENDIF.
    ENDIF.
    " end AK_BUTVILOVS #8000000241
  ENDMETHOD.


  METHOD build_accdocs_fcat.
    DATA: lr_column TYPE REF TO cl_salv_column_list.

    LOOP AT ct_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>).
      <ls_fcat>-hotspot = SWITCH #( <ls_fcat>-fieldname
                            WHEN 'BELNR' OR 'STBLG' THEN abap_true ).
      <ls_fcat>-do_sum  = SWITCH #( <ls_fcat>-fieldname
                            WHEN 'DMBTR' THEN abap_true ).
      <ls_fcat>-no_out  = SWITCH #( <ls_fcat>-fieldname
                            WHEN 'ANLN' OR 'TCODE' OR 'USNAM' THEN abap_true ).
      <ls_fcat>-tech    = SWITCH #( <ls_fcat>-fieldname
                            WHEN 'MANDT' THEN abap_true ).

      IF <ls_fcat>-hotspot = abap_true.
        TRY.
            lr_column ?= ir_columns->get_column( <ls_fcat>-fieldname ).
            lr_column->set_cell_type( if_salv_c_cell_type=>hotspot ).
          CATCH cx_salv_not_found.
            RETURN.
        ENDTRY.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD show_data.
    IF gr_grid IS BOUND.
      gr_grid->refresh_table_display(
        EXPORTING is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true )
        EXCEPTIONS OTHERS = 0 ).
      RETURN.
    ENDIF.

    DATA(lt_fcat) = me->build_fieldcat( ).
    DATA(ls_layout) = VALUE lvc_s_layo( sel_mode = 'A' no_rowmark = abap_true
      zebra = abap_true cwidth_opt = abap_true col_opt = abap_true ).
    DATA(ls_variant) = VALUE disvariant( report = sy-cprog variant = gs_sscr-format ).

    DATA(lr_splitter) = NEW cl_gui_splitter_container(
      rows = 2
      columns = 1
      parent = NEW cl_gui_docking_container(
        side      = cl_gui_docking_container=>dock_at_top
        extension = cl_gui_docking_container=>ws_maximizebox ) ).
    lr_splitter->set_row_height( id = 1 height = 70 ).

    gr_grid = NEW #( i_parent = lr_splitter->get_container( row = 1 column = 1 ) ).

    SET HANDLER on_hotspot
                on_double_click
                on_delayed_callback
                on_user_command
                on_data_changed
                on_toolbar
                on_menu FOR gr_grid.

    gr_grid->register_edit_event( i_event_id = cl_gui_alv_grid=>mc_evt_modified ).
    gr_grid->register_delayed_event( cl_gui_alv_grid=>mc_evt_delayed_move_curr_cell ).

    gr_grid->set_table_for_first_display(
      EXPORTING is_layout             = ls_layout
                is_variant            = ls_variant
                i_save                = 'A'
                i_default             = 'X'
                it_toolbar_excluding  = VALUE #(
                                          ( '&LOCAL&CUT' )
                                          ( '&LOCAL&COPY' )
                                          ( '&LOCAL&PASTE' )
                                          ( '&LOCAL&UNDO' )
                                          ( '&&SEP02' )
                                          ( '&LOCAL&APPEND' )
                                          ( '&LOCAL&INSERT_ROW' )
                                          ( '&LOCAL&DELETE_ROW' )
                                          ( '&LOCAL&COPY_ROW' )
                                          ( '&&SEP03' )
                                          ( '&LOCAL&PASTE_NEW_ROW' )
                                          ( '&REFRESH' ) )
      CHANGING  it_outtab             = gt_data[]
                it_fieldcatalog       = lt_fcat[] ).

    "Подчиненная ALV
    lt_fcat[] = me->build_fieldcat2( ).
    DATA(lt_sort) = VALUE lvc_t_sort(
      ( fieldname = 'BUKRS' spos = 1 up = abap_true subtot = abap_true )
      ( fieldname = 'ANLN'  spos = 2 up = abap_true ) ).

    ls_variant-handle = 'SUB'.
    ls_layout     = VALUE lvc_s_layo(
      sel_mode    = 'A'
      no_rowmark  = abap_true
      zebra       = abap_true
      col_opt     = abap_true
      grid_title  = TEXT-t17
      ctab_fname  = 'COLORS'
      stylefname  = 'CELLTAB' ).

    gr_grid2 = NEW #( i_parent = lr_splitter->get_container( row = 2 column = 1 ) ).

    SET HANDLER on_data_changed2
                on_toolbar2
                on_user_command2
                on_hotspot2
                on_double_click2 FOR gr_grid2.
    gr_grid2->register_edit_event( i_event_id = cl_gui_alv_grid=>mc_evt_modified ).

    "Подчиненный
    me->refresh_grid2( im_refresh = abap_false ).

    gr_grid2->set_table_for_first_display(
      EXPORTING is_layout             = ls_layout
                i_save                = 'A'
                i_default             = 'X'
                is_variant            = ls_variant
      CHANGING  it_outtab             = gt_summ[]
                it_fieldcatalog       = lt_fcat[]
                it_sort               = lt_sort[] ).

  ENDMETHOD.


  METHOD on_accdoc_hotspot.
    DATA: BEGIN OF ls_belnr,
            bukrs TYPE bkpf-bukrs,
            belnr TYPE bkpf-belnr,
            gjahr TYPE bkpf-gjahr,
          END OF ls_belnr.


    DATA(lt_accdocs) = me->gr_accdocs->*.

    TRY.
        DATA(ls_data) = CORRESPONDING zfi_cl_proptax_amdp=>gty_s_accdoc( lt_accdocs[ row ] ).
      CATCH cx_sy_itab_line_not_found.
        RETURN.
    ENDTRY.

    ls_belnr = VALUE #(
      bukrs = ls_data-bukrs
      belnr = SWITCH #( column
                WHEN 'BELNR' THEN ls_data-belnr
                WHEN 'STBLG' THEN ls_data-stblg )
      gjahr = SWITCH #( column
                WHEN 'BELNR' THEN ls_data-gjahr
                WHEN 'STBLG' THEN ls_data-stjah ) ).


    CHECK ls_belnr-belnr IS NOT INITIAL.
    SET PARAMETER ID 'BUK' FIELD ls_belnr-bukrs.
    SET PARAMETER ID 'BLN' FIELD ls_belnr-belnr.
    SET PARAMETER ID 'GJR' FIELD ls_belnr-gjahr.
    CALL TRANSACTION 'FB03' AND SKIP FIRST SCREEN.

  ENDMETHOD.


  METHOD on_double_click2.
    "Под assign - только обработка месяцев
    ASSIGN me->gt_month[ key = CONV t247-ktx( e_column ) ] TO FIELD-SYMBOL(<ls_month>).
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    gr_grid2->get_selected_cells( IMPORTING et_cell = DATA(lt_cell) ).
    IF lt_cell[] IS INITIAL.
      RETURN.
    ENDIF.

    TRY.
        ASSIGN gt_summ[ lt_cell[ 1 ]-row_id ] TO FIELD-SYMBOL(<ls_summ>).
      CATCH cx_sy_conversion_no_number.
        RETURN.
    ENDTRY.

    me->show_accdocs( iv_month = <ls_month>-mnr iv_bukrs = <ls_summ>-bukrs iv_asset = <ls_summ>-anln ).
  ENDMETHOD.


  METHOD build_fieldcat2.
    rt_fcat[] = CORRESPONDING #(
      cl_salv_data_descr=>read_structdescr(
        CAST cl_abap_structdescr(
          CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( gt_summ[] ) )->get_table_line_type( ) ) ) ).

    LOOP AT rt_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>).
      CASE <ls_fcat>-fieldname.
        WHEN 'TYPE'.
          <ls_fcat>-tech = abap_true.
        WHEN 'ANLN'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-24l.
          <ls_fcat>-scrtext_m = TEXT-24m.
          <ls_fcat>-scrtext_s = TEXT-24s.
          <ls_fcat>-hotspot = abap_true.
        WHEN 'EXEMPT'.
          <ls_fcat>-tech = abap_true.
        WHEN 'OFPRIV'.
          <ls_fcat>-tech = abap_true.
        WHEN 'NAME'.
          <ls_fcat>-outputlen = 25.
        WHEN 'BASE'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-32l.
          <ls_fcat>-scrtext_m = TEXT-32m.
          <ls_fcat>-scrtext_s = TEXT-32s.
          <ls_fcat>-edit = abap_true.
          <ls_fcat>-no_out = abap_true.
        WHEN 'TAX'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = <ls_fcat>-coltext = TEXT-33l.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-do_sum = abap_true.
          <ls_fcat>-no_out = abap_true.
        WHEN 'PRTAX1'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-36l.
          <ls_fcat>-scrtext_m = TEXT-36m.
          <ls_fcat>-scrtext_s = TEXT-36s.
          <ls_fcat>-do_sum    = abap_true.
          <ls_fcat>-exponent = 0.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-outputlen = 12.
        WHEN 'PRTAX2'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-37l.
          <ls_fcat>-scrtext_m = TEXT-37m.
          <ls_fcat>-scrtext_s = TEXT-37s.
          <ls_fcat>-do_sum    = abap_true.
          <ls_fcat>-exponent = 0.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-outputlen = 12.
        WHEN 'PRTAX3'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-38l.
          <ls_fcat>-scrtext_m = TEXT-38m.
          <ls_fcat>-scrtext_s = TEXT-38s.
          <ls_fcat>-do_sum    = abap_true.
          <ls_fcat>-exponent = 0.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-outputlen = 12.
        WHEN 'PRTAX4'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-39l.
          <ls_fcat>-scrtext_m = TEXT-39m.
          <ls_fcat>-scrtext_s = TEXT-39s.
          <ls_fcat>-do_sum    = abap_true.
          <ls_fcat>-exponent = 0.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-outputlen = 12.
        WHEN 'TOTAL'.
          <ls_fcat>-scrtext_l = <ls_fcat>-reptext = TEXT-50l.
          <ls_fcat>-scrtext_m = TEXT-50m.
          <ls_fcat>-scrtext_s = TEXT-50s.
          <ls_fcat>-exponent = 0.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-do_sum    = abap_true.
          <ls_fcat>-outputlen = 15.
        WHEN OTHERS.
          TRY.
              ASSIGN gt_month[ key = CONV t247-ktx( <ls_fcat>-fieldname ) ] TO FIELD-SYMBOL(<ls_month>).
            CATCH cx_sy_itab_line_not_found.
              CONTINUE.
          ENDTRY.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.

          <ls_fcat>-scrtext_l = <ls_fcat>-scrtext_m = <ls_fcat>-reptext = <ls_month>-ktx.
          <ls_fcat>-scrtext_s = <ls_month>-ltx.
          IF <ls_month>-mnr = gs_sscr-budat+4(2).
            <ls_fcat>-edit = abap_true.
          ENDIF.
          <ls_fcat>-exponent = 0.
          <ls_fcat>-decimals_o = 2.
          <ls_fcat>-do_sum    = abap_true.
          <ls_fcat>-outputlen = 10.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.


  METHOD initialize_setup_sscr.
    DATA(lt_ucomm) = VALUE ucomm_it( ).

    CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
      EXPORTING
        p_status  = '1010'
      TABLES
        p_exclude = lt_ucomm[].

    me->read_setup( ).

    LOOP AT me->gs_params-taxrates[] ASSIGNING FIELD-SYMBOL(<ls_rate>).
      DATA(lv_name) = 'CV_' && <ls_rate>-key.
      ASSIGN (lv_name) TO FIELD-SYMBOL(<lv_dst>).
      IF sy-subrc = 0.
        <lv_dst> = replace( val = <ls_rate>-value sub = ',' with = '.' ).
      ENDIF.
    ENDLOOP.

    ct_nkscl[] = me->gs_params-nks_range[].
    ct_incom[] = me->gs_params-bwasl_incomes[].
    ct_moves[] = me->gs_params-bwasl_moves[].

  ENDMETHOD.


  METHOD fill_quart_totals.
    cs_summ-prtax1 = cs_summ-jan + cs_summ-feb + cs_summ-mar.
    cs_summ-prtax2 = cs_summ-apr + cs_summ-may + cs_summ-jun.
    cs_summ-prtax3 = cs_summ-jul + cs_summ-aug + cs_summ-sep.
    cs_summ-prtax4 = cs_summ-oct + cs_summ-nov + cs_summ-dec.
    "#25650 - после пересчета total, собранный из месяцев должен равняться предрассчитанному tax
*    cs_summ-tax = cs_summ-total  = cs_summ-prtax1 + cs_summ-prtax2 + cs_summ-prtax3 + cs_summ-prtax4.
    cs_summ-total  = cs_summ-prtax1 + cs_summ-prtax2 + cs_summ-prtax3 + cs_summ-prtax4.

    cs_summ-colors[] = VALUE #( BASE cs_summ-colors[]
      ( fname = 'PRTAX1' color = VALUE #( col = 4 int = 1 inv = 0 ) )
      ( fname = 'PRTAX2' color = VALUE #( col = 4 int = 1 inv = 0 ) )
      ( fname = 'PRTAX3' color = VALUE #( col = 4 int = 1 inv = 0 ) )
      ( fname = 'PRTAX4' color = VALUE #( col = 4 int = 1 inv = 0 ) )
      ( fname = 'TOTAL'  color = VALUE #( col = 3 int = 0 inv = 0 ) ) ).

  ENDMETHOD.


  METHOD post_documents.

    DATA: lv_answer   TYPE char1,
          ls_header   TYPE bapiache09,
          lt_return   TYPE TABLE OF bapiret2,
          lv_str(150) TYPE c,     "Tararenko O. - #33376
          lv_len      TYPE i,     "Tararenko O. - #33376
          lv_old_buk  TYPE bukrs. "Tararenko O. - #33376

*Выводим информационное  сообщение (желтое тип W )  «Проводки по выбранным ОС уже были проведены!»
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = TEXT-tp1
        text_question         = TEXT-tp2
        icon_button_1         = 'ICON_OKAY'
        icon_button_2         = 'ICON_CANCEL'
        display_cancel_button = abap_false
      IMPORTING
        answer                = lv_answer.
    IF lv_answer <> '1'.
      MESSAGE TEXT-e03 TYPE 'I' DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

"start 33376 - Tararenko O проверка, документ был проведен или нет ранее
    SELECT *
      FROM bkpf
      INTO TABLE @DATA(lt_bkpf)
     WHERE tcode = 'ZFI_PROPTAX'
      AND bukrs IN @gs_sscr-it_bukrs
      AND xreversed = ''
      AND gjahr = @gs_sscr-budat(4)
      AND monat = @gs_sscr-budat+4(2).
      DELETE lt_bkpf WHERE bukrs = '01' AND bvorg <> ''." #36362 налог на недвижимость V.Zaretsky 31.01.2024
      IF lt_bkpf IS NOT INITIAL.
        lv_str = TEXT-tp8.
        LOOP AT me->gt_data[] ASSIGNING FIELD-SYMBOL(<ls_bukrs>) WHERE checked = abap_true.
         IF <ls_bukrs>-bukrs <> lv_old_buk.
            lv_str = lv_str && ` ` && <ls_bukrs>-bukrs && `,`.
         ENDIF.
         lv_old_buk = <ls_bukrs>-bukrs.
        ENDLOOP.

        lv_len = strlen( lv_str ) - 1.
        lv_str = lv_str+0(lv_len).

        CALL FUNCTION 'POPUP_TO_CONFIRM'
         EXPORTING
           titlebar              = TEXT-tp1
           text_question         = lv_str
           icon_button_1         = 'ICON_OKAY'
           icon_button_2         = 'ICON_CANCEL'
           popup_type            = 'ICON_MESSAGE_CRITICAL'
           display_cancel_button = abap_false
         IMPORTING
           answer                = lv_answer.
       IF lv_answer <> '1'.
         MESSAGE TEXT-e03 TYPE 'I' DISPLAY LIKE 'E'.
         RETURN.
       ENDIF.
      ENDIF.
"end 33376 - Tararenko O проверка, документ был проведен или нет ранее

    CALL FUNCTION 'OWN_LOGICAL_SYSTEM_GET'
      IMPORTING
        own_logical_system = ls_header-obj_sys.

    "При группировке или сортировке me->gt_summ[] на уровне ALV нарушается ключ, и binary search не срабатывает
    DATA(lt_summ) = me->gt_summ[].
    SORT lt_summ[] BY bukrs anln.

    LOOP AT me->gt_data[] ASSIGNING FIELD-SYMBOL(<ls_data>) WHERE checked = abap_true.

      TRY.
          READ TABLE lt_summ[] ASSIGNING FIELD-SYMBOL(<ls_summ>) WITH KEY bukrs = <ls_data>-bukrs
                                                                          anln = <ls_data>-anln_full
                                                                 BINARY SEARCH.
        CATCH cx_sy_itab_line_not_found.
          CONTINUE.
      ENDTRY.

      READ TABLE me->gt_month[] ASSIGNING FIELD-SYMBOL(<ls_month>) WITH KEY mnr = gs_sscr-budat+4(2).
      IF sy-subrc = 0.
        ASSIGN COMPONENT <ls_month>-key OF STRUCTURE <ls_summ> TO FIELD-SYMBOL(<lv_tax>).
        CHECK sy-subrc = 0 AND <lv_tax> <> 0.
      ENDIF.

      " заголовок
      ls_header = VALUE #( BASE ls_header
        username    = sy-uname
        bus_act     = 'RFBU'
        doc_type    = gs_params-blart
        obj_type    = 'BKPFF'
        doc_date    = gs_sscr-budat
        pstng_date  = gs_sscr-budat
        fisc_year   =  gs_sscr-budat(4)
        fis_period  = gs_sscr-budat+4(2)
        header_txt  = TEXT-tp7 ).

      DATA(lt_curramt) = VALUE bapiaccr09_tab(
        ( itemno_acc = 10 amt_doccur = - <lv_tax> currency_iso = <ls_data>-waers currency = <ls_data>-waers
          curr_type = '00'  )
        ( itemno_acc = 20 amt_doccur = <lv_tax> currency_iso = <ls_data>-waers currency = <ls_data>-waers
          curr_type = '00' ) ).

      DATA(lt_accgl) = VALUE bapiacgl09_tab(
        ( itemno_acc = 10
          comp_code = '01'
          gl_account = gs_params-gkont
          item_text = TEXT-001
          cmmt_item = 'TECH'
          vendor_no = <ls_data>-lifnr )
        ( itemno_acc = 20
          comp_code = <ls_data>-bukrs
          gl_account = SWITCH #( <ls_data>-only_expenses when abap_true then gs_params-hkont "RM 26154 - с признаком "Только_затраты" - проводить на gs_params-hkont невзирая на класс ОС
                         ELSE COND #( WHEN <ls_data>-ktogr(1) = '3' THEN gs_params-hkont_inv
                                                                    ELSE gs_params-hkont ) ) "AK_INPRANNIK #25584 ZFI_PROPTAX - Расчет налога на недвижимость
          ref_key_1 = <ls_data>-anln1
          ref_key_2 = <ls_data>-anln2
          costcenter = <ls_data>-kostl
          orderid    = <ls_data>-caufn
          item_text = TEXT-001
          cmmt_item = 'TECH'
          wbs_element = <ls_data>-poski ) ).

      " проверка перед проводкой
      CALL FUNCTION 'BAPI_ACC_DOCUMENT_CHECK'
        EXPORTING
          documentheader = ls_header
        TABLES
          currencyamount = lt_curramt[]
          accountgl      = lt_accgl[]
          return         = lt_return[].

      LOOP AT lt_return ASSIGNING FIELD-SYMBOL(<ls_return>) WHERE type = 'E' OR type = 'A'.
        add_messtab(
            iv_bukrs = <ls_data>-bukrs
            iv_anln1 = <ls_data>-anln1
            iv_anln2 = <ls_data>-anln2
            is_return = <ls_return> ).
      ENDLOOP.
      IF sy-subrc = 0.
        <ls_data>-status = icon_red_light.
        CONTINUE.
      ELSEIF is_test = abap_false.
        " проводка
        CALL FUNCTION 'BAPI_ACC_DOCUMENT_POST'
          EXPORTING
            documentheader = ls_header
          TABLES
            currencyamount = lt_curramt[]
            accountgl      = lt_accgl[]
            return         = lt_return[].

        LOOP AT lt_return ASSIGNING <ls_return>.
          add_messtab(
            iv_bukrs = <ls_data>-bukrs
            iv_anln1 = <ls_data>-anln1
            iv_anln2 = <ls_data>-anln2
            is_return = <ls_return> ).

          IF <ls_return>-type = 'E' OR <ls_return>-type = 'A'.
            add_messtab(
              iv_bukrs = <ls_data>-bukrs
              iv_anln1 = <ls_data>-anln1
              iv_anln2 = <ls_data>-anln2
              is_return = <ls_return> ).
            DATA(lv_rollback) = abap_true.
          ENDIF.
        ENDLOOP.

        IF lv_rollback = abap_true.
          CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
          EXIT.
        ELSE.
          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
            EXPORTING
              wait = 'X'.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF gt_messtab[] IS NOT INITIAL.
      me->show_protocol( ).
    ENDIF.

    gr_grid->refresh_table_display( ).
  ENDMETHOD.


  METHOD show_accdocs.
    DATA: lt_accdocs TYPE STANDARD TABLE OF zfi_cl_proptax_amdp=>gty_s_accdoc.

    lt_accdocs[] = VALUE #(
      FOR <ls_accdoc> IN gt_accdocs[]
      WHERE ( bukrs = iv_bukrs AND anln = iv_asset AND budat(6) = gs_params-budat(4) && iv_month )
      ( CORRESPONDING #( <ls_accdoc> ) ) ).

    IF lt_accdocs[] IS INITIAL.
      RETURN.
    ENDIF.

    me->gr_accdocs = REF #( lt_accdocs[] ).

    TRY.
        cl_salv_table=>factory(
          IMPORTING r_salv_table = DATA(lr_alv)
          CHANGING  t_table      = lt_accdocs[] ).
      CATCH cx_salv_msg.
        RETURN.
    ENDTRY.

    DATA(lr_columns) = lr_alv->get_columns( ).
    DATA(lr_aggregations) = lr_alv->get_aggregations( ).

    DATA(lt_fcat) = cl_salv_controller_metadata=>get_lvc_fieldcatalog( r_columns = lr_columns r_aggregations = lr_aggregations ).
    me->build_accdocs_fcat( EXPORTING ir_columns = lr_columns CHANGING ct_fcat = lt_fcat[] ).
    cl_salv_controller_metadata=>set_lvc_fieldcatalog( t_fieldcatalog = lt_fcat[] r_columns = lr_columns r_aggregations = lr_aggregations ).

    DATA(lr_sort) = lr_alv->get_sorts( ).
    TRY.
        lr_sort->add_sort( 'BELNR' ).
        lr_sort->add_sort( 'GJAHR' ).
      CATCH cx_root.
    ENDTRY.

    DATA(lr_events) = lr_alv->get_event( ).
    SET HANDLER on_accdoc_hotspot FOR lr_events.

    lr_alv->set_screen_popup(
      start_column = 15
      end_column  = 150
      start_line  = 10
      end_line    = 20 ).

    lr_alv->display( ).
  ENDMETHOD.


  METHOD get_exempts.
    IF is_period IS SUPPLIED.
      DATA(ls_period) = is_period.
    ELSE.
      ls_period = VALUE #( begda = gs_sscr-begda endda = gs_sscr-endda ).
    ENDIF.

    LOOP AT me->gt_zanlz_tax[] ASSIGNING FIELD-SYMBOL(<ls_exempt>) WHERE invnr = is_data-invnr
                                                                     AND bdatu >= ls_period-begda
                                                                     AND adatu <= ls_period-endda
                                                                     AND is_exempt = abap_true
                                                                     AND ofprivilege <> ''.
      APPEND VALUE #(
        adatu = <ls_exempt>-adatu
        bdatu = <ls_exempt>-bdatu
        offpriv = <ls_exempt>-ofprivilege ) TO rt_exempts[] ASSIGNING FIELD-SYMBOL(<ls_ret>).


      <ls_ret> = VALUE #( BASE <ls_ret>
        begda    = COND #( WHEN <ls_ret>-adatu <= me->gs_sscr-quart1-endda THEN me->gs_sscr-quart1-begda
                              ELSE <ls_ret>-adatu )
        endda    = COND #( WHEN <ls_ret>-bdatu > me->gs_sscr-quart4-endda THEN me->gs_sscr-quart4-endda
                              WHEN <ls_ret>-bdatu < ls_period-begda THEN ''
                              ELSE <ls_ret>-bdatu )
        bquart      = ( <ls_ret>-begda+4(2) - 1 ) DIV 3 + 1
        equart      = COND #( WHEN <ls_ret>-endda IS INITIAL THEN 0 ELSE ( <ls_ret>-endda+4(2) - 1 ) DIV 3 + 1 )
        exempt_rate = ( <ls_ret>-equart - <ls_ret>-bquart + 1 ) / 4 ).
    ENDLOOP.

  ENDMETHOD.


  METHOD show_log.
    ASSIGN gt_data[ iv_index ] TO FIELD-SYMBOL(<ls_data>).
    IF sy-subrc = 0.
      CALL FUNCTION 'MESSAGES_INITIALIZE'.

      LOOP AT gt_messtab ASSIGNING FIELD-SYMBOL(<ls_messtab>)
                         WHERE bukrs = <ls_data>-bukrs
                           AND anln1 = <ls_data>-anln1
                           AND anln2 = <ls_data>-anln2.
        CALL FUNCTION 'MESSAGE_STORE'
          EXPORTING
            arbgb  = <ls_messtab>-id
            msgty  = <ls_messtab>-type
            msgv1  = <ls_messtab>-message_v1
            msgv2  = <ls_messtab>-message_v2
            msgv3  = <ls_messtab>-message_v3
            msgv4  = <ls_messtab>-message_v4
            txtnr  = <ls_messtab>-number
          EXCEPTIONS
            OTHERS = 0.
      ENDLOOP.

      CALL FUNCTION 'MESSAGES_SHOW'
        EXCEPTIONS
          OTHERS = 0.
    ENDIF.
  ENDMETHOD.


  METHOD view_asset.
    IF iv_index IS SUPPLIED.
      ASSIGN gt_data[ iv_index ] TO FIELD-SYMBOL(<ls_data>).
    ELSE.
      READ TABLE gt_data[] ASSIGNING <ls_data> WITH KEY bukrs = iv_bukrs anln1 = iv_anln1 anln2 = iv_anln2
                                               BINARY SEARCH.
    ENDIF.

    IF <ls_data> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    SET PARAMETER ID: 'AN1' FIELD <ls_data>-anln1,
                      'AN2' FIELD <ls_data>-anln2,
                      'BUK' FIELD <ls_data>-bukrs.
    CALL TRANSACTION 'AS03' AND SKIP FIRST SCREEN.

  ENDMETHOD.


  METHOD constructor.
    me->read_setup( ).
  ENDMETHOD.


  METHOD read_setup.
    DATA(lv_like) = |{ sy-cprog }-%|.
    FIELD-SYMBOLS: <lt_range> TYPE STANDARD TABLE.

    SELECT *
      FROM tvarvc
      INTO TABLE @DATA(lt_tvarvc)
      WHERE name LIKE @lv_like.

    CLEAR: me->gs_params-nks_range[],
      me->gs_params-bwasl_incomes[],
      me->gs_params-bwasl_moves[],
      me->gs_params-taxrates[],
      me->gs_params-bwasl_div[],    " #8000000096 AK_BUTVILOVS Налог-Объединение ОС
      me->gs_params-bwasl_add[],    " #8000000096 AK_BUTVILOVS Налог-Объединение ОС
      me->gs_params-bwasl_change[]. " #30891 ZFI_PROPTAX - налог на недвижимость

    LOOP AT lt_tvarvc[] ASSIGNING FIELD-SYMBOL(<ls_tvarvc>).
      IF <ls_tvarvc>-type = 'P'.
        me->gs_params-taxrates[] = VALUE #( BASE me->gs_params-taxrates[]
          ( key = <ls_tvarvc>-name+12 value = <ls_tvarvc>-low ) ).
      ELSE.
        CASE <ls_tvarvc>-name.
          WHEN 'ZFI_PROPTAX-INCOMES'.
            ASSIGN me->gs_params-bwasl_incomes[] TO <lt_range>.
          WHEN 'ZFI_PROPTAX-MOVES'.
            ASSIGN me->gs_params-bwasl_moves[] TO <lt_range>.
          WHEN 'ZFI_PROPTAX-NKS_CLASS'.
            ASSIGN me->gs_params-nks_range[] TO <lt_range>.
*--> #8000000096 AK_BUTVILOVS Налог-Объединение ОС
          WHEN 'ZFI_PROPTAX-BWASL_DIV'.
            ASSIGN me->gs_params-bwasl_div[] TO <lt_range>.
          WHEN 'ZFI_PROPTAX-BWASL_ADD'.
            ASSIGN me->gs_params-bwasl_add[] TO <lt_range>.
*<-- #8000000096 AK_BUTVILOVS Налог-Объединение ОС
*--> V.Zaretsky #30891 ZFI_PROPTAX - налог на недвижимость
          WHEN 'ZFI_PROPTAX-BWASL_CHANGE'.
            ASSIGN me->gs_params-bwasl_change[] TO <lt_range>.
*<-- V.Zaretsky #30891 ZFI_PROPTAX - налог на недвижимость
          WHEN OTHERS.
            CONTINUE.
        ENDCASE.

        APPEND INITIAL LINE TO <lt_range>[] ASSIGNING FIELD-SYMBOL(<ls_range>).
        <ls_range> = CORRESPONDING #(
          VALUE ucon_browser_range_url_char(
             sign   = <ls_tvarvc>-sign
             option = <ls_tvarvc>-opti
             low    = <ls_tvarvc>-low
             high   = <ls_tvarvc>-high ) ).
      ENDIF.
    ENDLOOP.

    gs_params = VALUE #( BASE gs_params
      hkont     = '3562001209'
      hkont_inv = '9142100000'        "AK_INPRANNIK #25584 ZFI_PROPTAX - Расчет налога на недвижимость
      gkont     = '6820100000'
      blart     = 'NN' ).
  ENDMETHOD.


  METHOD on_menu.
    e_object->add_function( fcode = 'PRIVELEGE'   text = CONV #( TEXT-cm0 ) icon = icon_money ).
    e_object->add_function( fcode = 'REFERENCE'   text = CONV #( TEXT-cm1 ) icon = icon_preference ).
    "#25651 - оставлем только новую версию экспорта ->
*    e_object->add_function( fcode = 'TAX_INFO'   text = CONV #( TEXT-cm2 ) icon = icon_information ).
    e_object->add_function( fcode = 'TAX_INFO_NEW'  text = CONV #( TEXT-cm2 ) icon = icon_information ).
    "#25651 - оставлем только новую версию экспорта <-
    e_object->add_function( fcode = 'OTHERS'  text = CONV #( TEXT-cm3 ) icon = icon_information ).
    "#25651 - оставлем только новую версию экспорта ->
*    e_object->add_separator( ).
*    e_object->add_function( fcode = 'TAX_INFO_NEW'  text = CONV #( TEXT-cm2 ) icon = icon_information ).
    "#25651 - оставлем только новую версию экспорта <-
  ENDMETHOD.


  METHOD on_hotspot2.
    TRY.
        DATA(ls_asset) = gt_summ[ e_row_id-index ].
      CATCH cx_root.
        RETURN.
    ENDTRY.

    IF sy-subrc = 0.
      me->view_asset( iv_bukrs = ls_asset-bukrs iv_anln1 = ls_asset-anln(12) iv_anln2 = ls_asset-anln+13(4) ).
    ENDIF.
  ENDMETHOD.


  METHOD on_toolbar.
    DATA(lt_toolbar) = VALUE ttb_button(
      FOR <ls_btn> IN e_object->mt_toolbar[] FROM 1 TO 2
      ( CORRESPONDING #( <ls_btn> ) ) ).

    lt_toolbar[] = VALUE #( BASE lt_toolbar[]
      ( butn_type = 3 )
      ( function = 'SELECT_ALL' icon = icon_select_all quickinfo = TEXT-q13 )
      ( function = 'DESELECT_ALL' icon = icon_deselect_all quickinfo = TEXT-q14 )
      ( function = 'REVERT_SELECTION' icon = icon_select_with_condition quickinfo = TEXT-q15 )
      ( butn_type = 3 )
      ( function = 'ADD' icon = icon_insert_row quickinfo = TEXT-q16 )
      ( function = 'DEL' icon = icon_delete_row quickinfo = TEXT-q17 ) ).
*--> #8000000273 AK_BUTVILOVS Разработка роли для просмотра z-транзакций по БНУ
    AUTHORITY-CHECK OBJECT 'ZBN_DISPLA'
          ID 'ACTVT' FIELD '02'.
    IF sy-subrc = 0.
      lt_toolbar[] = VALUE #( BASE lt_toolbar[]
      " Редактировать запись
      ( function = 'EDT' icon = icon_change quickinfo = TEXT-q18 disabled = SWITCH #( gv_mode WHEN 'E' THEN abap_true ELSE  abap_false ) ) ).
    ENDIF.
*<-- #8000000273 AK_BUTVILOVS

    lt_toolbar[] = VALUE #( BASE lt_toolbar[]
      FOR <ls_btn> IN e_object->mt_toolbar[] FROM 3
      ( CORRESPONDING #( <ls_btn> ) ) ).

*--> #8000000273 AK_BUTVILOVS Разработка роли для просмотра z-транзакций по БНУ
    AUTHORITY-CHECK OBJECT 'ZBN_DISPLA'
          ID 'ACTVT' FIELD '02'.
    IF sy-subrc = 0.
      lt_toolbar[] = VALUE #( BASE lt_toolbar[]
      " Выполнить проводки
      ( butn_type = 3 ) ( function = 'DOC_POST' icon = icon_release     text = TEXT-t21 ) ).
    ENDIF.
*<-- #8000000273 AK_BUTVILOVS
    e_object->mt_toolbar[] = VALUE #( BASE lt_toolbar[]
      ( butn_type = 3 ) ( function = 'EXTENTION' icon = icon_next_node  text = TEXT-tl3 butn_type = 2 ) ).
*--> #8000000273 AK_BUTVILOVS Разработка роли для просмотра z-транзакций по БНУ
    AUTHORITY-CHECK OBJECT 'ZBN_DISPLA'
          ID 'ACTVT' FIELD '02'.
    IF sy-subrc = 0.
      e_object->mt_toolbar[] = VALUE #( BASE e_object->mt_toolbar[]
      " Сохранить
      ( butn_type = 3 ) ( function = 'SAVE_TO_DB' icon = icon_system_save  text = TEXT-tl4 ) ).
    ENDIF.
*<-- #8000000273 AK_BUTVILOVS
  ENDMETHOD.


  METHOD fill_sscr_structure.
    FIELD-SYMBOLS:
      <lv_quart> TYPE lty_s_sscr-quart1.

    rs_sscr = is_sscr.

    " формирование констант периодов
    DO 4 TIMES.
      DATA(lv_inc) = sy-index  - 1.
      ASSIGN rs_sscr-quart1 INCREMENT lv_inc TO <lv_quart> RANGE rs_sscr.
      IF sy-subrc = 0.
        <lv_quart> = me->build_quarter( EXPORTING iv_gjahr = is_sscr-budat(4) iv_quarter = sy-index ).
      ENDIF.
    ENDDO.

    " формирование параметров выборки
    rs_sscr-seldats = me->build_quarter( EXPORTING iv_gjahr = is_sscr-budat(4) iv_quarter = CONV i( is_sscr-nquart )  ).
    rs_sscr-seldats-begda+4(4) = '0101'.

    SELECT sign opti AS option low high
      FROM tvarvc
      INTO CORRESPONDING FIELDS OF TABLE rs_sscr-it_inner_bwasl[]
     WHERE name = 'ZAA_BWASL_INNER_MOVE'.

  ENDMETHOD.


  METHOD add_record.
    IF me->gs_params-report_mode <> 'N'.
      RETURN.
    ENDIF.

    APPEND VALUE #( BASE me->gs_data
      bukrs = is_proptax-bukrs
      anln1 = is_proptax-anln1
      anln2 = is_proptax-anln2
      anln_full = |{ is_proptax-anln1 } { is_proptax-anln2 }|
      invnr = is_proptax-invnr
      txt50 = is_proptax-descr
      anlnt = is_proptax-descr
      anlkl = is_proptax-anlkl
      is_costs = VALUE #( BASE gs_data-is_costs
        kansw = is_proptax-kansw
        amort = is_proptax-amort
        netvl = is_proptax-netvl )
      is_summ = VALUE #( BASE gs_data-is_summ
        bukrs = is_proptax-bukrs
        anln  = |{ is_proptax-anln1 } { is_proptax-anln2 }|
        base  =  is_proptax-base
        tax   = is_proptax-tax
        extax = is_proptax-extax )
      exemption_sum = is_proptax-exsum
      koeff = is_proptax-koeff
      exemption = is_proptax-excode
      tax_rate = is_proptax-rate
      region = is_proptax-region ) TO me->gt_data[].

    CLEAR: gs_data, me->gs_params-report_mode.
  ENDMETHOD.


  METHOD delete_record.
    DATA: lv_answ TYPE c LENGTH 1.

    DATA(lv_row) = iv_number.
    IF iv_number IS NOT SUPPLIED.
      gr_grid->get_selected_cells( IMPORTING et_cell = DATA(lt_cells) ).
      TRY.
          lv_row = lt_cells[ 1 ]-row_id.
        CATCH cx_sy_itab_line_not_found.
          me->show_warning( iv_text = TEXT-e18 iv_astype = 'E' ).
          RETURN.
      ENDTRY.
    ENDIF.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = TEXT-tp1
        text_question         = CONV text132( replace( val = TEXT-q19 sub = '&'
                                                       with = me->gt_data[ lv_row ]-invnr ) )
        display_cancel_button = space
      IMPORTING
        answer                = lv_answ.

    IF lv_answ = '1'.
      DELETE me->gt_data[] INDEX lv_row.
      me->gr_grid->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).
    ENDIF.
  ENDMETHOD.


  METHOD end_of_selection.
    IF gt_data[] IS NOT INITIAL.
      rv_ok = abap_true.
    ELSE.
      me->show_warning( iv_text = TEXT-e01 iv_astype = 'E' ).
    ENDIF.
  ENDMETHOD.


  METHOD f4_budat.
    IF NOT iv_date IS SUPPLIED.
      CALL FUNCTION 'F4_DATE'
        EXPORTING
          date_for_first_month         = iv_date
        IMPORTING
          select_date                  = cv_budat
        EXCEPTIONS
          calendar_buffer_not_loadable = 1
          date_after_range             = 2
          date_before_range            = 3
          date_invalid                 = 4
          factory_calendar_not_found   = 5
          holiday_calendar_not_found   = 6
          parameter_conflict           = 7
          OTHERS                       = 8.
      IF sy-subrc <> 0.
        RETURN.
      ENDIF.
    ELSE.
      cv_budat = iv_date.
    ENDIF.


    cv_quart = ( cv_budat+4(2) - 1 ) DIV 3 + 1.
    rv_text = SWITCH #( cv_quart
      WHEN 1 THEN |I { TEXT-01m }|
      WHEN 2 THEN |II { TEXT-01m }|
      WHEN 3 THEN |III { TEXT-01m }|
      WHEN 4 THEN |IV { TEXT-01m }| ).

  ENDMETHOD.


  METHOD fill_tax_bases.

    "--> AK_RUBAHOV #25629 ZFI_PROPTAX Доработка расчета налога на недвижимость
    DATA: lv_sum_move TYPE zaa_v0_move-kaufn,
          lv_st_ng    TYPE anlc-kansw,
          lv_am_ng    TYPE anlc-knafa,
          lv_net_ng   TYPE anlc-kansw.
    "<-- AK_RUBAHOV #25629 ZFI_PROPTAX Доработка расчета налога на недвижимость

*--> #8000000096 AK_BUTVILOVS Налог-Объединение ОС
*    DATA lt_moves_copy TYPE TABLE OF zaa_v0_move.
*
*    FIELD-SYMBOLS <ls_move> TYPE zaa_v0_move.
*
*    APPEND LINES OF me->gt_moves TO lt_moves_copy.
*    SORT lt_moves_copy BY bukrs anln1 anln2 ASCENDING bzdat DESCENDING.
*
*    LOOP AT me->gt_moves ASSIGNING <ls_move> WHERE bukrs = cs_data-bukrs
*                                               AND anln1 = cs_data-anln1
*                                               AND anln2 = cs_data-anln2
*                                               AND bwasl IN me->gs_params-bwasl_div
*                                               AND bzdat <= gs_sscr-seldats-endda.
*      DATA(lv_quart) = ( ( <ls_move>-bzdat+4(2) - 1 ) DIV 3 ) + 1.
*      cs_data = VALUE #( BASE cs_data
*        flag = SWITCH #( lv_quart
*                  WHEN 1 THEN zfi_cl_proptax_amdp=>q1
*                  WHEN 2 THEN zfi_cl_proptax_amdp=>q2
*                  WHEN 3 THEN zfi_cl_proptax_amdp=>q3
*                  WHEN 4 THEN zfi_cl_proptax_amdp=>q4 )
*        tax_date   = SWITCH sy-datum( cs_data-flag
*                        WHEN zfi_cl_proptax_amdp=>q4 THEN CONV sy-datum( |{ me->gs_sscr-seldats-begda(4) }1231| ) + 1
*                        ELSE |{ me->gs_sscr-seldats-begda(4) }{ CONV numc2( lv_quart * 3 + 1 ) }01| ) ).
*      EXIT.
*    ENDLOOP.
*    IF sy-subrc <> 0.
*<-- #8000000096 AK_BUTVILOVS Налог-Объединение ОС
    IF cs_data-zugdt(6) < me->gs_sscr-seldats-begda(6).
      "1. Для поступивших до начала отчетного года:
      cs_data = VALUE #( BASE cs_data
        flag     = zfi_cl_proptax_amdp=>jan_1
        tax_date = me->gs_sscr-seldats-begda ).

      "23.11.2021 - Если были ВДв частичного списания, для квартала, следующего задатой частичного списания, найти изменную базу
      CLEAR lv_sum_move.
      LOOP AT me->gt_moves ASSIGNING FIELD-SYMBOL(<ls_move>) WHERE bukrs = cs_data-bukrs
                                                               AND anln1 = cs_data-anln1
                                                               AND anln2 = cs_data-anln2
"                                                               AND bwasl CP 'Z*' " AK_RUBAHOV #25629 ZFI_PROPTAX Доработка расчета налога на недвижимость
                                                               AND bwasl IN me->gt_partial[] "V.Zaretsky #33080 налог на недвижимость
                                                               AND budat < me->gs_sscr-begda.
        lv_sum_move = lv_sum_move + <ls_move>-kansw. " AK_RUBAHOV #25629 ZFI_PROPTAX Доработка расчета налога на недвижимость
*        IF cs_data-tax_date < <ls_move>-budat.
*          IF  <ls_move>-budat BETWEEN gs_sscr-quart1-begda AND gs_sscr-quart1-endda.
*            cs_data-tax_date = gs_sscr-quart2-begda.
*            cs_data-flag = zfi_cl_proptax_amdp=>q2.
*          ELSEIF <ls_move>-budat BETWEEN gs_sscr-quart2-begda AND gs_sscr-quart2-endda.
*            cs_data-tax_date = gs_sscr-quart3-begda.
*            cs_data-flag = zfi_cl_proptax_amdp=>q3.
*          ELSEIF <ls_move>-budat BETWEEN gs_sscr-quart3-begda AND gs_sscr-quart3-endda.
*            cs_data-tax_date = gs_sscr-quart4-begda.
*            cs_data-flag = zfi_cl_proptax_amdp=>q4.
*          ENDIF.
*        ENDIF.
      ENDLOOP.

    ELSEIF cs_data-zugdt BETWEEN me->gs_sscr-seldats-begda AND me->gs_sscr-seldats-endda.
      "2. Для поступивших в течении отчетного года
      DATA(lv_quart) = ( ( cs_data-zugdt+4(2) - 1 ) DIV 3 ) + 1.
      cs_data = VALUE #( BASE cs_data
        flag = SWITCH #( lv_quart
                  WHEN 1 THEN zfi_cl_proptax_amdp=>q1
                  WHEN 2 THEN zfi_cl_proptax_amdp=>q2
                  WHEN 3 THEN zfi_cl_proptax_amdp=>q3
                  WHEN 4 THEN zfi_cl_proptax_amdp=>q4 )
        tax_date   = SWITCH sy-datum( cs_data-flag
                        WHEN zfi_cl_proptax_amdp=>q4 THEN CONV sy-datum( |{ me->gs_sscr-seldats-begda(4) }1231| ) + 1
                        ELSE |{ me->gs_sscr-seldats-begda(4) }{ CONV numc2( lv_quart * 3 + 1 ) }01| ) ).
    ELSE.
      cs_data-flag = zfi_cl_proptax_amdp=>out_of_dates.
      RETURN.
    ENDIF.
*    ENDIF.

    cs_data = VALUE #( BASE cs_data
      is_costs      = me->fill_costs( is_data = cs_data )
      is_summ-bukrs = cs_data-bukrs
      is_summ-anln  = cs_data-anln_full
      is_summ-base  = COND #( WHEN cs_data-tax_date > gs_sscr-endda THEN 0
                              ELSE cs_data-is_costs-netvl )
      tax_rate      = SWITCH #( cs_data-is_nks
                        WHEN abap_true THEN SWITCH #( cs_data-flag
                                              WHEN zfi_cl_proptax_amdp=>jan_1 THEN me->gs_sscr-quart1-nks_rate
                                              WHEN zfi_cl_proptax_amdp=>q1 THEN me->gs_sscr-quart2-nks_rate
                                              WHEN zfi_cl_proptax_amdp=>q2 THEN me->gs_sscr-quart3-nks_rate
                                              WHEN zfi_cl_proptax_amdp=>q3 THEN me->gs_sscr-quart4-nks_rate
                                              ELSE 0 )
                        WHEN abap_false THEN SWITCH #( cs_data-flag
                                              WHEN zfi_cl_proptax_amdp=>jan_1 THEN me->gs_sscr-quart1-rate
                                              WHEN zfi_cl_proptax_amdp=>q1 THEN me->gs_sscr-quart2-rate
                                              WHEN zfi_cl_proptax_amdp=>q2 THEN me->gs_sscr-quart3-rate
                                              WHEN zfi_cl_proptax_amdp=>q3 THEN me->gs_sscr-quart4-rate
                                              ELSE 0 ) ) ).
    "--> AK_RUBAHOV #25629 ZFI_PROPTAX Доработка расчета налога на недвижимость
    IF lv_sum_move IS NOT INITIAL.
      IF abs( lv_sum_move ) < cs_data-is_costs-kansw.
        lv_st_ng = cs_data-is_costs-kansw - abs( lv_sum_move ).
        lv_am_ng = cs_data-is_costs-amort - abs( lv_sum_move ) / cs_data-is_costs-kansw * cs_data-is_costs-amort.
        lv_net_ng = lv_st_ng - lv_am_ng.

        cs_data-is_costs-kansw = lv_st_ng.
        cs_data-is_costs-amort = lv_am_ng.
        cs_data-is_costs-netvl = lv_net_ng.
        cs_data-is_summ-base   = lv_net_ng.
      ENDIF.
    ENDIF.
    "<-- AK_RUBAHOV #25629 ZFI_PROPTAX Доработка расчета налога на недвижимость
    "ENDIF.


    LOOP AT me->gt_zanlz_tax[] ASSIGNING FIELD-SYMBOL(<ls_proptax>) WHERE invnr  = cs_data-invnr
                                                                      AND adatu <= me->gs_sscr-begda
                                                                      AND bdatu >= me->gs_sscr-begda.
      IF <ls_proptax>-is_exempt = abap_true.
        cs_data = VALUE #( BASE cs_data
          exemption   = <ls_proptax>-ofprivilege
          sqarenb     = <ls_proptax>-sqarenb
          square      = <ls_proptax>-sqare
          koef_square = COND #( WHEN cs_data-square = 0 THEN 1
                                ELSE cs_data-sqarenb / cs_data-square ) ).
      endif.

      "RM 26154
      cs_data-only_expenses = <ls_proptax>-only_expenses.
      EXIT.
    ENDLOOP.

    "льготируется (ZANLZ_TAX-OFPRIVILEGE ≠ пусто), при этом часть здается в аренду и т.о. освобождается от льготы
    "(ZANLZ_TAX-SQARENB≠пусто), то остаточную стоимость умножаем на коэффициент площади
    IF cs_data-exemption <> ''."
      cs_data-exemption_sum = SWITCH #( cs_data-koef_square
        WHEN 1 THEN cs_data-is_summ-base
        ELSE cs_data-is_summ-base - cs_data-is_summ-base * cs_data-koef_square ).
      cs_data-is_summ-base = cs_data-is_summ-base - cs_data-exemption_sum.
    ENDIF.

  ENDMETHOD.


  METHOD free_subreport.
    IF gr_subrep IS NOT BOUND.
      RETURN.
    ENDIF.

    DATA(lr_report) = CAST lcl_additional( gr_subrep ).
    IF lr_report IS BOUND.
      lr_report->free( ).
      FREE gr_subrep.
    ENDIF.
  ENDMETHOD.


  METHOD get_anln_data.
    DATA: lc_filter TYPE string VALUE 'BUKRS = ''&'' AND ANLN1 = ''&'' AND ANLN2 = ''&'''.

    IF iv_anln1 IS SUPPLIED.
      "New record
      me->gs_params-report_mode = 'A'.
      DATA(lt_data) = me->get_data( is_sscr   = gs_sscr
                                    iv_filter = replace( val = replace(
                                                           val = replace( val = lc_filter sub = '&' with = iv_bukrs )
                                                           sub = '&'
                                                           with = iv_anln1 )
                                                         sub = '&'
                                                         with = CONV numc4( iv_anln2 ) )
                                    iv_deakt_filter = abap_false ).
      IF lt_data[] IS INITIAL.
        RETURN.
      ENDIF.

      READ TABLE lt_data[] INTO gs_data INDEX 1.
      IF sy-subrc <> 0.
        RETURN.
      ENDIF.
      me->gs_params-report_mode = 'N'.
    ELSE.
      "Update mode
      gr_grid->get_selected_cells( IMPORTING et_cell = DATA(lt_cell) ).

      IF lt_cell[] IS INITIAL.
        RETURN.
      ENDIF.

      me->gs_data = me->gt_data[ lt_cell[ 1 ]-row_id ].
      me->gs_params-report_mode = 'U'.
    ENDIF.

    cv_bukrs  = gs_data-bukrs.
    cv_anln1  = gs_data-anln1.
    cv_anln2  = gs_data-anln2.
    cv_invnr  = gs_data-invnr.
    cv_anlkl  = gs_data-anlkl.
    cv_kansw  = gs_data-is_costs-kansw.
    cv_amort  = gs_data-is_costs-amort.
    cv_netvl  = gs_data-is_costs-netvl.
    cv_base   = gs_data-is_summ-base.
    cv_tax    = gs_data-is_summ-tax.
    cv_extax  = gs_data-is_summ-extax.
    cv_exsum  = gs_data-exemption_sum.
    cv_koeff  = gs_data-koeff.
    cv_exemp  = gs_data-exemption.
    cv_rate   = gs_data-rate.
    cv_region = gs_data-region.
    cv_descr  = gs_data-txt50.

  ENDMETHOD.


  METHOD loaddlg_dblclick.
    CALL FUNCTION 'SAPGUI_SET_FUNCTIONCODE'
      EXPORTING
        functioncode = '&ONT'.
  ENDMETHOD.


  METHOD load_results.
    DATA: lt_costs TYPE STANDARD TABLE OF zfi_cl_proptax_amdp=>gty_s_cost.

    me->gs_sscr = is_sscr.

    TRY.
        zfi_cl_proptax_amdp=>get_saved_list(
          EXPORTING
            iv_bukrs_filter = ''
          IMPORTING
            et_list         = DATA(lt_list) ).
      CATCH  cx_root.
        me->show_warning( iv_text = TEXT-e00 iv_var1 = 'get_saved_list' iv_astype = 'E' ).
        RETURN.
    ENDTRY.

    IF lt_list[] IS INITIAL.
      me->show_warning( iv_text = TEXT-e13 iv_astype = 'I' ).
      RETURN.
    ENDIF.

    SORT lt_list[] BY bukrs gjahr quart.

    DATA: lr_alv TYPE REF TO cl_salv_table.
    TRY.
        cl_salv_table=>factory(
          IMPORTING
            r_salv_table = lr_alv
          CHANGING
            t_table      = lt_list[] ).

      CATCH cx_salv_msg.
    ENDTRY.

    IF NOT lr_alv IS BOUND.
      RETURN.
    ENDIF.

    "Fieldcat
    DATA(lr_cols) = lr_alv->get_columns( ).
    DATA(lr_aggr) = lr_alv->get_aggregations( ).
    lr_cols->get_column( 'QUART' )->set_technical( if_salv_c_bool_sap=>true ).
    DATA(lr_column) = lr_cols->get_column( 'GJAHR' ).
    lr_column->set_short_text( CONV #( TEXT-t13 ) ).
    lr_column->set_medium_text( CONV #( TEXT-t13 ) ).
    lr_column->set_long_text( CONV #( TEXT-t13 ) ).
    lr_column->set_output_length( 7 ).

    lr_column = lr_cols->get_column( 'TEXT' ).
    lr_column->set_short_text( CONV #( TEXT-t14 ) ).
    lr_column->set_medium_text( CONV #( TEXT-t14 ) ).
    lr_column->set_long_text( CONV #( TEXT-t14 ) ).

    "Стандартные кнопки
    lr_column = lr_cols->get_column( 'BUKRS' ).
    lr_column->set_output_length( 5 ).
    lr_alv->get_functions( )->set_all( ).

    "Заголовок (подпись)
    DATA(lr_header) = NEW cl_salv_form_layout_grid( ).
    lr_header->create_label( row = 1 column = 1 )->set_text( TEXT-h00 ).
    lr_alv->set_end_of_list( lr_header ).

    "Фильтры
    DATA(lr_filters) = lr_alv->get_filters( ).
    LOOP AT me->gs_sscr-it_bukrs[] ASSIGNING FIELD-SYMBOL(<ls_bukrs>).
      lr_filters->add_filter( columnname = 'BUKRS'
                              sign       = <ls_bukrs>-sign
                              option     = <ls_bukrs>-option
                              low        = CONV #( <ls_bukrs>-low )
                              high       = CONV #( <ls_bukrs>-high ) ).
    ENDLOOP.

    "События
    DATA(lr_events) = lr_alv->get_event( ).
    SET HANDLER me->loaddlg_dblclick FOR lr_events.

    lr_alv->set_screen_popup(
     start_column = 15
     end_column   = 50
     start_line  = 5
     end_line    = 20 ).

    lr_alv->display( ).

    IF sy-ucomm <> '&ONT'.
      me->show_warning( iv_text = TEXT-e19 iv_astype = 'W' ).
      RETURN.
    ENDIF.

    DATA(lt_row) = lr_alv->get_selections( )->get_selected_rows( ).
    IF lt_row[] IS INITIAL.
      RETURN.
    ENDIF.

    ASSIGN lt_list[ lt_row[ 1 ] ] TO FIELD-SYMBOL(<ls_line>).
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    me->gs_sscr = VALUE #(
      budat     = |{ <ls_line>-gjahr }{ CONV numc2( <ls_line>-quart * 3 ) }01|
      it_bukrs  = VALUE #( ( sign = 'I' option = 'EQ' low = <ls_line>-bukrs ) ) ).
    me->gs_params-bukrs = me->gs_sscr-it_bukrs[].

    me->gs_sscr = me->fill_sscr_structure( me->gs_sscr ).

    TRY.
        zfi_cl_proptax_amdp=>read_saved_data(
          EXPORTING
            iv_bukrs       = <ls_line>-bukrs
            iv_gjahr       = <ls_line>-gjahr
            iv_quart       = <ls_line>-quart
            iv_ondate      = me->gs_sscr-budat
          IMPORTING
            et_data         = DATA(lt_data)
            et_proptax      = DATA(lt_proptax)
            et_zanlz_tax    = me->gt_zanlz_tax[]
            et_month        = me->gt_month[] ).
      CATCH  cx_root.
        me->show_warning( iv_text = TEXT-e00 iv_var1 = 'read_saved_data' iv_astype = 'E' ).
        RETURN.
    ENDTRY.
    me->gs_sscr-begda = |{ <ls_line>-gjahr }{ CONV numc2( <ls_line>-quart * 3 - 2 ) }01|.
    me->gs_sscr-endda = me->gs_sscr-begda + 92.
    me->gs_sscr-endda+6(2) = '01'.
    me->gs_sscr-endda = me->gs_sscr-endda - 1.

    "lt_proptax - первична
    LOOP AT lt_data[] ASSIGNING FIELD-SYMBOL(<ls_stored>).
      APPEND CORRESPONDING #( <ls_stored> ) TO me->gt_data[] ASSIGNING FIELD-SYMBOL(<ls_data>).
      <ls_data>-is_summ = me->process_taxes( is_data = <ls_data> ).

      READ TABLE lt_proptax[] ASSIGNING FIELD-SYMBOL(<ls_proptax>) WITH TABLE KEY bukrs = <ls_stored>-bukrs
                                                                                  anln1 = <ls_stored>-anln1
                                                                                  anln2 = <ls_stored>-anln2.
      <ls_data> = VALUE #( BASE <ls_data>

        txt50     = <ls_proptax>-descr
        anlnt     = <ls_proptax>-descr
        exemption = <ls_proptax>-excode
        exemption_sum = SWITCH #( <ls_proptax>-excode WHEN '' THEN 0 ELSE <ls_proptax>-netvl )
        tax_rate  = <ls_proptax>-rate
        is_costs = VALUE #( BASE <ls_data>-is_costs
          kansw = <ls_proptax>-kansw
          amort = <ls_proptax>-amort
          netvl = <ls_proptax>-netvl )
        is_summ = VALUE #( BASE <ls_data>-is_summ
          bukrs = <ls_proptax>-bukrs
          anln  = |{ <ls_proptax>-anln1 } { <ls_proptax>-anln2 }|
          base  = <ls_proptax>-base
          tax   = <ls_proptax>-tax
          extax = <ls_proptax>-extax )
        exempts = me->get_exempts( <ls_data> ) ).

      APPEND CORRESPONDING #( <ls_data> ) TO lt_costs[] ASSIGNING FIELD-SYMBOL(<ls_cost>).
      <ls_cost> = VALUE #( BASE <ls_cost>
        start_cost  = <ls_data>-is_costs-kansw
        start_amort = <ls_data>-is_costs-amort * -1
        ondate      = me->gs_sscr-quart1-begda
        gjahr       = me->gs_sscr-quart1-begda(4) ).
    ENDLOOP.
    me->gt_costs[] = lt_costs[].


    me->gs_sscr = VALUE #( BASE me->gs_sscr
      it_bukrs = VALUE #( ( sign = 'I' option = 'EQ' low = <ls_line>-bukrs ) )
      nquart   = <ls_line>-quart
      budat    = |{ <ls_line>-gjahr }{ CONV numc2( <ls_line>-quart * 3 ) }01| ).

    me->gs_params-report_mode = 'L'.
    CALL FUNCTION 'SAPGUI_SET_FUNCTIONCODE'
      EXPORTING
        functioncode = 'ONLI'.

  ENDMETHOD.


  METHOD save_results.
    DATA: lv_answ    TYPE c LENGTH 1,
          lt_proptax TYPE STANDARD TABLE OF zfi_proptax.

    TRY.
        zfi_cl_proptax_amdp=>get_saved_list(
          EXPORTING
            iv_gjahr        = me->gs_sscr-budat(4)
            iv_quart        = me->gs_sscr-nquart
            iv_bukrs_filter = cl_shdb_seltab=>combine_seltabs(
                                it_named_seltabs = VALUE #(
                                  ( name = 'BUKRS' dref = REF #( me->gs_sscr-it_bukrs[] ) ) ) )
          IMPORTING
            et_list         = DATA(lt_list) ).
      CATCH  cx_root.
        me->show_warning( iv_text = TEXT-e00 iv_var1 = 'get_saved_list' iv_astype = 'E' ).
        RETURN.
    ENDTRY.

    IF lt_list[] IS NOT INITIAL.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar              = TEXT-t09
          text_question         = CONV char256( replace( val = TEXT-q02 sub = '&' with = lt_list[ 1 ]-text ) )
          text_button_1         = TEXT-q07
          text_button_2         = TEXT-q08
          iv_quickinfo_button_1 = TEXT-q03
          iv_quickinfo_button_2 = TEXT-q04
        IMPORTING
          answer                = lv_answ.
      IF lv_answ = 'A'.
        me->show_warning( iv_text = TEXT-e14 iv_astype = 'E' ).
        RETURN.
      ENDIF.
    ENDIF.

    LOOP AT me->gt_data[] ASSIGNING FIELD-SYMBOL(<ls_data>).
      APPEND CORRESPONDING #( <ls_data>
        MAPPING
          kansw = is_costs-kansw
          amort = is_costs-amort
          netvl = is_costs-netvl
          base  = is_summ-base
          tax   = is_summ-tax
          extax = is_summ-extax
          excode = exemption
          descr = anlnt
          rate  = tax_rate ) TO lt_proptax[] ASSIGNING FIELD-SYMBOL(<ls_store>).
      <ls_store> = VALUE #( BASE <ls_store>
        gjahr = me->gs_sscr-budat(4)
        quart = me->gs_sscr-nquart ).
    ENDLOOP.

    IF lv_answ = '1'.
      DELETE FROM zfi_proptax WHERE bukrs IN @me->gs_sscr-it_bukrs
                                AND gjahr = @me->gs_sscr-budat(4)
                                AND quart = @me->gs_sscr-nquart.
      IF sy-subrc <> 0.
        me->show_warning( iv_text = TEXT-e15 iv_astype = 'E' ).
      ENDIF.
    ENDIF.

    MODIFY zfi_proptax FROM TABLE lt_proptax[].
    IF sy-subrc <> 0.
      me->show_warning( iv_text = TEXT-e16 iv_astype = 'E' ).
    ELSE.
      me->show_warning( iv_text = TEXT-e17 iv_astype = 'I' ).
    ENDIF.

  ENDMETHOD.


  METHOD show_protocol.
    DATA: lr_alv     TYPE REF TO cl_salv_table.

    TRY.
        cl_salv_table=>factory(
          IMPORTING r_salv_table = lr_alv
          CHANGING  t_table      = me->gt_messtab[] ).
      CATCH cx_salv_msg.
        RETURN.
    ENDTRY.

    DATA(lr_columns) = lr_alv->get_columns( ).
    DATA(lr_aggregations) = lr_alv->get_aggregations( ).
    DATA(lt_fcat) = cl_salv_controller_metadata=>get_lvc_fieldcatalog( r_columns = lr_columns r_aggregations = lr_aggregations ).

    LOOP AT lt_fcat[] ASSIGNING FIELD-SYMBOL(<ls_fcat>).
      CASE <ls_fcat>-fieldname.
        WHEN 'STATUS'.
          <ls_fcat>-outputlen = 5.
          <ls_fcat>-just = 'C'.
          <ls_fcat>-scrtext_l = TEXT-51l.
          <ls_fcat>-scrtext_m = TEXT-51m.
          <ls_fcat>-scrtext_s = TEXT-51s.
          <ls_fcat>-reptext = TEXT-51l.
        WHEN 'TYPE' OR 'ID' OR 'NUMBER'.
          <ls_fcat>-no_out = abap_true.
        WHEN 'MESSAGE'.
          <ls_fcat>-outputlen = 63.
        WHEN OTHERS.
          IF <ls_fcat>-fieldname CP 'MESSAGE_V+'.
            <ls_fcat>-no_out = abap_true.
          ENDIF.
      ENDCASE.
    ENDLOOP.
    cl_salv_controller_metadata=>set_lvc_fieldcatalog( t_fieldcatalog = lt_fcat[] r_columns = lr_columns r_aggregations = lr_aggregations ).

    DATA(lr_sort) = lr_alv->get_sorts( ).
    TRY.
        lr_sort->add_sort( 'ANLN1' ).
        lr_sort->add_sort( 'ANLN2' ).
      CATCH cx_root.
    ENDTRY.

    lr_alv->set_screen_popup(
      start_column = 10
      end_column  = 110
      start_line  = 5
      end_line    = 20 ).

    lr_alv->display( ).

  ENDMETHOD.


  METHOD update_record.
    IF me->gs_params-report_mode <> 'U'.
      RETURN.
    ENDIF.

    "Update mode
    gr_grid->get_selected_cells( IMPORTING et_cell = DATA(lt_cell) ).
    IF lt_cell[] IS INITIAL.
      RETURN.
    ENDIF.

    ASSIGN me->gt_data[ lt_cell[ 1 ]-row_id ] TO FIELD-SYMBOL(<ls_data>).
    IF sy-subrc = 0.

      <ls_data> = VALUE #( BASE <ls_data>
        bukrs = is_proptax-bukrs
        anln1 = is_proptax-anln1
        anln2 = is_proptax-anln2
        anln_full = |{ is_proptax-anln1 } { is_proptax-anln2 }|
        invnr = is_proptax-invnr
        txt50 = is_proptax-descr
        anlnt = is_proptax-descr
        anlkl = is_proptax-anlkl
        is_costs = VALUE #( BASE gs_data-is_costs
          kansw = is_proptax-kansw
          amort = is_proptax-amort
          netvl = is_proptax-netvl )
        is_summ = VALUE #( BASE gs_data-is_summ
          bukrs = is_proptax-bukrs
          anln  = |{ is_proptax-anln1 } { is_proptax-anln2 }|
          base  =  is_proptax-base
          tax   = is_proptax-tax
          extax = is_proptax-extax )
        exemption_sum = is_proptax-exsum
        koeff = is_proptax-koeff
        exemption = is_proptax-excode
        tax_rate = is_proptax-rate
        region = is_proptax-region ).
    ENDIF.

    CLEAR: gs_data, me->gs_params-report_mode.

  ENDMETHOD.
ENDCLASS.