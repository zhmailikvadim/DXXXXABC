class CL_ATP_CHARC_VALUE_UTILITY definition
  public
  create public .

public section.

  types:
    tt_vbkd TYPE STANDARD TABLE OF vbkd WITH DEFAULT KEY
                                        WITH NON-UNIQUE SORTED KEY order_item COMPONENTS vbeln posnr .
  types:
    BEGIN OF ty_cvc_data,
        path_id TYPE prodalloccharcctlgpathintid,
        value   TYPE atp_abc_characteristic,
      END OF ty_cvc_data .
  types:
    tt_cvc_data TYPE STANDARD TABLE OF ty_cvc_data WITH KEY path_id .
  types:
    BEGIN OF ty_order_cvc,
        sched_key TYPE atp_sched_key,
        cvc_data  TYPE tt_cvc_data,
      END OF ty_order_cvc .
  types:
    tt_order_cvc TYPE SORTED TABLE OF ty_order_cvc WITH UNIQUE KEY sched_key .
  types:
    BEGIN OF ty_value_grp_fallback_value,
        path_id        TYPE atp_fc_path_info-path_id,
        fallback_value TYPE atp_abc_characteristic,
      END OF ty_value_grp_fallback_value .
  types:
    tt_value_grp_fallback_value TYPE SORTED TABLE OF ty_value_grp_fallback_value WITH UNIQUE KEY path_id .
  types:
    BEGIN OF ty_field_mapping,
        actual_table   TYPE prodalloccharcctlglegacytable,
        actual_field   TYPE prodalloccharcctlglegacypath,
        original_table TYPE prodalloccharcctlglegacytable,
        original_field TYPE prodalloccharcctlglegacypath,
      END OF ty_field_mapping .
  types:
    tt_field_mapping TYPE STANDARD TABLE OF ty_field_mapping .

  methods CONSTRUCTOR
    importing
      !IO_DATA_ACCESS type ref to IF_ATP_DATA_ACCESS optional
      !IO_PAL_DB_ACCESS type ref to IF_PAL_DB_ACCESS optional
      !IO_CHARC_CTLG_UTILITY type ref to IF_CHARC_CTLG_UTILITY optional
      !IO_HIERARCHY_UTILITY type ref to IF_ATP_HIERARCHY_UTILITY optional .
  methods GET_CHARC_VALUE_FOR_PATH
    importing
      !IS_PATH_INFO type ATP_FC_PATH_INFO
      !IS_SCHEDKEY type ATP_SCHED_KEY
      !IV_LOCATION type WERKS_EXT
    exporting
      !EV_SUCCESS type BOOLE_D
    returning
      value(RV_CHARC_VALUE) type PRODALLOCATIONCHARACTERISTIC .
  methods GET_CHARC_VALUE_FROM_DB
    importing
      !IT_SCHED_KEY type TBL_ATP_SCHED_KEY
      !IV_CONTEXT type PRODALLOCCHARCCATALOGUSETYPE optional
      !IT_PATH_INFO type TBL_ATP_FC_PATH_INFO
      !IT_PAL_DATA type IF_READ_PAL_DATA=>TT_PAL optional
    exporting
      !ET_ORDER_CVC type CL_ATP_CHARC_VALUE_UTILITY=>TT_ORDER_CVC
      !ET_CHARAC_HIERARCHY_PATH type CL_READ_PAL_DATA=>TT_TMP_CHARAC_HIERARCHY_PATH .
  methods GET_VALUE_OR_SUBSTN_FROM_DB
    importing
      !IT_SCHEDULELINE type TBL_ATP_REQ_CHAR_VALUE_DETER
      !IT_PATH_INFO type TBL_ATP_FC_PATH_INFO
      !IT_PAL_DATA type IF_READ_PAL_DATA=>TT_PAL optional
    exporting
      !ET_ORDER_CVC type CL_ATP_CHARC_VALUE_UTILITY=>TT_ORDER_CVC
      !ET_CHARAC_HIERARCHY_PATH type CL_READ_PAL_DATA=>TT_TMP_CHARAC_HIERARCHY_PATH .
*        if_read_pal_data=>tt_charac_hierarchy_path.
  methods GET_CHARC_VALUE_HELP_PATH
    importing
      !IT_FILTER_SELECT_OPTIONS type /IWBEP/T_MGW_SELECT_OPTION
    exporting
      !ES_CATALOG_PATH type PACTLG_PATH
      !ET_ID_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS
      !ET_DESC_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS
      !ET_CATALOG_PATH type PACTLG_PATH_TAB .
  methods GET_CHARC_VALUE_HELP_DATA
    importing
      !IS_CATALOG_PATH type PACTLG_PATH
      !IS_PAGING type /IWBEP/S_MGW_PAGING
      !IT_ID_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS optional
      !IT_DESC_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS optional
      !IV_HAS_COUNT type BOOLE_D default ABAP_FALSE
      !IV_SELOPT_AND type BOOLE_D default ABAP_FALSE
      !IV_NO_CONVERSION type BOOLE_D default ABAP_FALSE
    exporting
      !ET_VALUE type TBL_ATP_CHARC_VALUE_VALUE_HELP
      !EV_COUNT type I .
  methods GET_CHARC_VALUE_HELP_DATA_MULT
    importing
      !IT_CATALOG_PATH type PACTLG_PATH_TAB
      !IS_PAGING type /IWBEP/S_MGW_PAGING
      !IT_ID_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS optional
      !IT_DESC_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS optional
      !IV_HAS_COUNT type BOOLE_D default ABAP_FALSE
      !IV_SELOPT_AND type BOOLE_D default ABAP_FALSE
    exporting
      !ET_VALUE type TBL_ATP_CHARC_VALUE_VALUE_HELP
      !EV_COUNT type I .
  methods ADJUST_FIELD_VALUES
    importing
      !IS_VBAK type VBAK
      !IS_VBAP type VBAP
      !IT_VBKD type TT_VBKD
    returning
      value(RS_VBAP) type VBAP .
protected section.

  data MO_DATA_ACCESS type ref to IF_ATP_DATA_ACCESS .
  data MO_DB_ACCESS type ref to IF_PAL_DB_ACCESS .
  data MO_CHARC_CTLG_UTILITY type ref to IF_CHARC_CTLG_UTILITY .
  data MO_HIERARCHY_UTILITY type ref to IF_ATP_HIERARCHY_UTILITY .
  constants GC_VALGRP type PRODALLOCCHARCVALUEHELP value 'I_ALLOCCHARCCTLGVALGRPVAL' ##NO_TEXT.
private section.

  data MT_VALUE_GRP_BASE_PATH_INFO type IF_READ_PAL_DATA=>TT_VALUE_GROUP_BASE_INFO .
  data LS_VALUE_GRP_BASE_PATH_INFO type IF_READ_PAL_DATA=>TY_VALUE_GROUP_BASE_INFO .
  data MT_FIELD_MAPPING type TT_FIELD_MAPPING .

  methods GRP_CHARC_VALUE_ONLINE
    importing
      !IS_PATH_INFO type ATP_FC_PATH_INFO
      !IS_SCHEDKEY type ATP_SCHED_KEY
      !IV_LOCATION type WERKS_EXT
    exporting
      !EV_SUCCESS type BOOLE_D
    returning
      value(RV_CHARC_VALUE) type PRODALLOCATIONCHARACTERISTIC .
  methods CONVERT_SELOPT_EXT_TO_INT
    importing
      !IS_CATALOG_PATH type PACTLG_PATH
      !IT_ID_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS
    exporting
      !ET_ID_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS
      !EV_SELECT_ON_EXTERNAL type BOOLE_D .
  methods SELECT_ON_EXTERNAL
    importing
      !IS_PAGING type /IWBEP/S_MGW_PAGING
      !IT_ID_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS
      !IT_DESC_SELOPT type /IWBEP/T_COD_SELECT_OPTIONS
      !IV_SELOPT_AND type BOOLE_D default ABAP_FALSE
    changing
      !CT_VALUE type TBL_ATP_CHARC_VALUE_VALUE_HELP
      !CV_COUNT type I .
  methods HAS_MULTI_VALUE_HELPS
    importing
      !IT_CATALOG_PATH type PACTLG_PATH_TAB
    returning
      value(RV_RESULT) type BOOLE_D .
  methods POPULATE_FIELD_MAPPING .
ENDCLASS.



CLASS CL_ATP_CHARC_VALUE_UTILITY IMPLEMENTATION.


  METHOD adjust_field_values.

* Initialise the returning item structure with all the actual values.
    rs_vbap = is_vbap.

* Populate field mapping table.
    populate_field_mapping( ).

* In case of the VBKD the value for the fields can be available on header or item level.
* Therefore, we first need to check if the VBKD values are available on item level and if not so instead
* take the values from header level.
    IF NOT it_vbkd IS INITIAL.

      READ TABLE it_vbkd
        WITH TABLE KEY order_item
          COMPONENTS vbeln = rs_vbap-vbeln
                     posnr = rs_vbap-posnr
        INTO DATA(ls_vbkd).

      IF sy-subrc <> 0.

        READ TABLE it_vbkd
          WITH KEY order_item
            COMPONENTS vbeln = rs_vbap-vbeln
          INTO ls_vbkd.
      ENDIF.
    ENDIF.

* Ajdust the field values of the returning item structure
* by mapping the original source values to the corresponding actual
* field values for each entry in the field mapping.
    LOOP AT mt_field_mapping
      ASSIGNING FIELD-SYMBOL(<ls_field_mapping>).

* We also overwrite fields which might have a value already,
* because SD might supply values in the affected fields but their
* value not necessarily is correct (= up to date).

      TRY.
* Map the values.
          CASE <ls_field_mapping>-original_table.

            WHEN 'VBAK'.

              IF NOT is_vbak IS INITIAL.

                rs_vbap-(<ls_field_mapping>-actual_field) = is_vbak-(<ls_field_mapping>-original_field).
              ENDIF.

            WHEN 'VBAP'.

              IF NOT is_vbap IS INITIAL.

                rs_vbap-(<ls_field_mapping>-actual_field) = is_vbap-(<ls_field_mapping>-original_field).
              ENDIF.

            WHEN 'VBKD'.

              IF NOT ls_vbkd IS INITIAL.

                rs_vbap-(<ls_field_mapping>-actual_field) = ls_vbkd-(<ls_field_mapping>-original_field).
              ENDIF.
          ENDCASE.

        CATCH cx_sy_conversion_error.

* If one of the above assignments (unexpectedly) will not work, we do not raise a short dump or an error message,
* since we are deep inside the aATP check call stack.
          CONTINUE.
      ENDTRY.
    ENDLOOP.
  ENDMETHOD.


  METHOD constructor.
    IF io_data_access IS BOUND.
      mo_data_access = io_data_access.
    ELSE.
      mo_data_access = NEW cl_atp_data_access( ).
    ENDIF.

    IF io_pal_db_access IS BOUND.
      mo_db_access = io_pal_db_access.
    ELSE.
      mo_db_access = NEW cl_pal_db_access( ).
    ENDIF.

    IF io_charc_ctlg_utility IS BOUND.
      mo_charc_ctlg_utility = io_charc_ctlg_utility.
    ELSE.
      mo_charc_ctlg_utility = NEW cl_charc_ctlg_utility( ).
    ENDIF.

    IF io_hierarchy_utility IS BOUND.
      mo_hierarchy_utility = io_hierarchy_utility.
    ELSE.
      mo_hierarchy_utility = NEW cl_atp_hierarchy_utility(  ).
    ENDIF.


  ENDMETHOD.


  METHOD convert_selopt_ext_to_int.

    DATA:
      lv_funcname  TYPE funcname,
      lt_range_int TYPE RANGE OF char40,
      lt_range_ext TYPE RANGE OF char40,
      lr_input     TYPE REF TO data,
      lr_output    TYPE REF TO data.

    FIELD-SYMBOLS:
      <lv_input>  TYPE any,
      <lv_output> TYPE any.

    CLEAR:
      et_id_selopt,
      ev_select_on_external.

    CHECK it_id_selopt IS NOT INITIAL.

    IF is_catalog_path-charcvalueconversionroutine IS INITIAL.
      "No conversion routine, this means there is no difference between external and internal representation.
      et_id_selopt = it_id_selopt.
      RETURN.
    ENDIF.

    "Check if a range conversion function module does exist for the conversion routine.
    lv_funcname = 'CONVERSION_EXIT_' && is_catalog_path-charcvalueconversionroutine && '_RANGE_I'.

    CALL FUNCTION 'FUNCTION_EXISTS'
      EXPORTING
        funcname           = lv_funcname
      EXCEPTIONS
        function_not_exist = 1
        OTHERS             = 2.

    IF sy-subrc <> 0.
      "Here conversion routines like 'AUART' (sales document type) are handled.
      "It is not known how to convert the select options from external into internal format.
      "Therefore all data will be selected, converted, and the select options are used on that data.
      ev_select_on_external = abap_true.
      RETURN.
    ENDIF.

    "Convert select options of ID from external into internal format
    CREATE DATA lr_input TYPE (is_catalog_path-abapdataelement).
    ASSIGN lr_input->* TO <lv_input>.
    CREATE DATA lr_output TYPE (is_catalog_path-abapdataelement).
    ASSIGN lr_output->* TO <lv_output>.

    lt_range_ext = CORRESPONDING #( it_id_selopt ).

    "Here function modules like CONVERSION_EXIT_MATN1_RANGE_I (for materials) or CONVERSION_EXIT_ALPHA_RANGE_I (for e.g. customers) are called
    CALL FUNCTION lv_funcname
      EXPORTING
        input     = <lv_input>
      IMPORTING
        output    = <lv_output>
      TABLES
        range_int = lt_range_int
        range_ext = lt_range_ext.

    et_id_selopt = CORRESPONDING #( lt_range_int ).

  ENDMETHOD.


  METHOD get_charc_value_for_path.

    DATA: lt_charac_value TYPE if_atp_data_access=>ttsk_charac_values,
          ls_charac_value TYPE if_atp_data_access=>ty_charac_values,
          lt_failed_key   TYPE if_atp_data_access=>tt_charac_value_key,
          ls_address      TYPE if_atp_data_access=>ty_address,
          ls_cust         TYPE kna1,
          ls_location     TYPE if_atp_data_access=>ty_location,
          lv_order_type   TYPE prodallocassignedordertype.

    FIELD-SYMBOLS: <fs_charac_value> TYPE any.

    CLEAR: rv_charc_value,
           ev_success.

*-->Populate characteristic value search paramters with order and item IDs
    ls_charac_value-atpcat  = is_schedkey-atpcat.
    ls_charac_value-delnr   = is_schedkey-delnr.
    ls_charac_value-delps   = is_schedkey-delps.
    ls_charac_value-subitem = is_schedkey-subitem.

    lv_order_type = cl_pal_utility=>get_instance( )->convert_atpcat_to_order_type( iv_atpcat = is_schedkey-atpcat ).

    SPLIT is_path_info-path AT '-' INTO: DATA(lv_path)  DATA(lv_charac) ##NEEDED.

    IF is_path_info-charc_type = if_pacharccatalogcharctype_c=>sc_charc_value_group. "Value group value has to be determined via base characteristic

      rv_charc_value = me->grp_charc_value_online( EXPORTING is_path_info = is_path_info
                                                             is_schedkey  = is_schedkey
                                                             iv_location  = iv_location
                                                   IMPORTING ev_success   = ev_success ).
      RETURN.

    ENDIF.

    IF is_path_info-clfncharacteristicusetype = if_clfncharacteristicusetype_c=>sc_domainvalues-variantconfiguration.

      mo_data_access->read_vc_data(
        EXPORTING
          is_vc_data_key = VALUE #( order_id = is_schedkey-delnr item_id = is_schedkey-delps charcintid = is_path_info-charcinternalid  )
        IMPORTING
          et_vc_data     = DATA(lt_vc_data)
      ).
      READ TABLE lt_vc_data INTO DATA(ls_vc_data) INDEX 1.
      ev_success = xsdbool( sy-subrc = 0 ).
      rv_charc_value = ls_vc_data-charcvalue.

*--> Sales order header/item, STO etc. related characteristic value
    ELSEIF is_path_info-order_field IS NOT INITIAL
      AND ( is_path_info-db_table = 'VBAK'
         OR is_path_info-db_table = 'VBAP'
         OR is_path_info-db_table = 'EKKO'
         OR is_path_info-db_table = 'EKPO'
         OR is_path_info-db_table = 'EKPV'
         OR is_path_info-db_table = 'KNA1'
       ).

      ls_charac_value-db_table = is_path_info-db_table.
      ls_charac_value-field_name = is_path_info-order_field.
      INSERT ls_charac_value INTO TABLE lt_charac_value.


      mo_data_access->get_charac_values(
        EXPORTING
          iv_order_type    = lv_order_type
        IMPORTING
          et_failed_key    = lt_failed_key
        CHANGING
          ct_charac_values = lt_charac_value
      ).

      ev_success = xsdbool( lt_failed_key IS INITIAL ).

      READ TABLE lt_charac_value INTO ls_charac_value INDEX 1.
      IF sy-subrc = 0.
        rv_charc_value = ls_charac_value-value.
      ENDIF.

*--> Business data related characteristic value
    ELSEIF is_path_info-order_field IS NOT INITIAL AND is_path_info-db_table = 'VBKD'.
      "For header business data clear item position number
      "There is always a row for header business data with empty position number
      DATA(lv_delps) = ls_charac_value-delps.
      IF is_path_info-path = lv_path.
        ls_charac_value-delps = '000000'.
      ENDIF.

      ls_charac_value-db_table = is_path_info-db_table.
      ls_charac_value-field_name = is_path_info-order_field.
      INSERT ls_charac_value INTO TABLE lt_charac_value.

      mo_data_access->get_charac_values(
        EXPORTING
          iv_order_type    = lv_order_type
        IMPORTING
          et_failed_key    = lt_failed_key
        CHANGING
          ct_charac_values = lt_charac_value
      ).

      ev_success = xsdbool( lt_failed_key IS INITIAL ).

      READ TABLE lt_charac_value INTO ls_charac_value INDEX 1.
      IF sy-subrc = 0.
        rv_charc_value = ls_charac_value-value.
      ENDIF.

*--> Location related characteristic value
    ELSEIF is_path_info-db_table = 'T001W'.
      ls_location = mo_data_access->get_location_data( iv_location_id = iv_location ).
      ASSIGN COMPONENT is_path_info-order_field OF STRUCTURE ls_location TO <fs_charac_value>.
      IF <fs_charac_value> IS ASSIGNED.
        rv_charc_value = <fs_charac_value>.
        ev_success     = abap_true.
      ENDIF.

*--> Sales organization related characteristic value
    ELSEIF is_path_info-db_table = 'TVKO'.
      ls_charac_value-field_name = 'VKORG'.
      ls_charac_value-db_table = 'VBAK'.
      INSERT ls_charac_value INTO TABLE lt_charac_value.
      mo_data_access->get_charac_values(
        IMPORTING
          et_failed_key    = lt_failed_key
        CHANGING
          ct_charac_values = lt_charac_value
      ).

      ev_success = xsdbool( lt_failed_key IS INITIAL ).

      READ TABLE lt_charac_value INTO ls_charac_value INDEX 1.
      IF sy-subrc = 0.
        DATA(ls_salesorg) = mo_data_access->get_salesorg_data( iv_salesorg = CONV #( ls_charac_value-value ) ).
        ASSIGN COMPONENT is_path_info-order_field OF STRUCTURE ls_salesorg TO <fs_charac_value>.
        IF <fs_charac_value> IS ASSIGNED.
          rv_charc_value = <fs_charac_value>.
        ENDIF.
      ENDIF.

*--> Production plant address data related characteristic value
    ELSEIF lv_path = if_prod_alloc_charc_catalog_c=>sc_path-gc_item_plant_addr.
      "need to read production plant from item first
      ls_charac_value-field_name = 'WERKS'.
      ls_charac_value-db_table = 'VBAP'.
      INSERT ls_charac_value INTO TABLE lt_charac_value.
      mo_data_access->get_charac_values(
        EXPORTING
          iv_order_type    = lv_order_type
        IMPORTING
          et_failed_key    = lt_failed_key
        CHANGING
          ct_charac_values = lt_charac_value
      ).

      ev_success = xsdbool( lt_failed_key IS INITIAL ).

      READ TABLE lt_charac_value INTO ls_charac_value INDEX 1.
      CHECK sy-subrc = 0.

      "get location and address for the plant
      ls_location = mo_data_access->get_location_data( iv_location_id = CONV #( ls_charac_value-value ) ).
*      ls_address =  me->if_atp_data_access~get_address( iv_addrnumber = ls_location-adrnr ).
      ls_address = CORRESPONDING #( mo_data_access->get_address( iv_addrnumber  = ls_location-adrnr ) ).
      IF ls_address IS NOT INITIAL.
        CASE lv_charac.
          WHEN 'COUNTRY'.
            rv_charc_value = ls_address-country.
          WHEN 'REGION'.
            rv_charc_value = ls_address-region.
          WHEN OTHERS.
            "other are currently not supported
        ENDCASE.
      ENDIF.

*--> Partner functions related characteristic value
    ELSEIF is_path_info-sel_key = 'PARTNERFUNCTION'.
      mo_data_access->get_partner_data(
        EXPORTING
          it_partner_functions = VALUE #( ( delnr = is_schedkey-delnr
                                            delps = is_schedkey-delps
                                            partner_function = is_path_info-sel_value ) )
        IMPORTING
          et_partner_data      = DATA(lt_partner_data)
      ).

      READ TABLE lt_partner_data INTO DATA(ls_partner_data) INDEX 1.
      IF sy-subrc = 0.
        CASE lv_charac.
          WHEN 'CUSTOMER'      OR
               'SUPPLIER'      OR
               'CONTACTPERSON' OR
               'PERSONNEL'.
            ASSIGN COMPONENT is_path_info-order_field OF STRUCTURE ls_partner_data TO <fs_charac_value>.
            IF <fs_charac_value> IS ASSIGNED.
              rv_charc_value = <fs_charac_value>.
              ev_success     = abap_true.
            ENDIF.
          WHEN 'COUNTRY'.
            rv_charc_value = ls_partner_data-land1.
            ev_success     = abap_true.
          WHEN 'REGION'.
*            rv_charc_value =  me->if_atp_data_access~get_address( iv_addrnumber = ls_partner_data-adrnr )-region.
            rv_charc_value = mo_data_access->get_address( iv_addrnumber  = ls_partner_data-adrnr )-region.
            IF rv_charc_value IS INITIAL.
*               retrieve defaulted value from KNA1 DB as Buffer does not have the info.
              SELECT SINGLE * FROM kna1  INTO ls_cust
                WHERE kunnr = ls_partner_data-kunnr.
              CHECK sy-subrc EQ 0.
              ls_address =  mo_data_access->get_address( iv_addrnumber = ls_cust-adrnr ).
              IF ls_address IS NOT INITIAL.
                rv_charc_value = ls_address-region.
              ENDIF.
            ENDIF.
            ev_success     = abap_true.
          WHEN OTHERS.
        ENDCASE.
      ENDIF.

*--> STO ship to party address related characteristic value
    ELSEIF lv_path = if_prod_alloc_charc_catalog_c=>sc_path-gc_sto_item_shp_adr.
      DATA(ls_customer) = mo_data_access->get_sto_customer_data( is_btd_ref = VALUE #( order_id = is_schedkey-delnr item_id = is_schedkey-delps order_type = lv_order_type ) ).

      CASE lv_charac.
        WHEN 'COUNTRY'.
          rv_charc_value = ls_customer-country.
          ev_success     = abap_true.
        WHEN 'REGION'.
          rv_charc_value = ls_customer-region.
          ev_success     = abap_true.
        WHEN OTHERS.
*          -->only  the characterisitics customer ID, country and region are supported in the first increment.
      ENDCASE.

*--> STO ship to party sales area related characteristic value (for new Fashion releated fields)
    ELSEIF lv_path = if_prod_alloc_charc_catalog_c=>sc_path-gc_sto_item_shp_sa.

* Get the KNVV key field values.
      ls_charac_value-field_name = 'KUNNR'.
      ls_charac_value-db_table   = 'EKPV'.
      INSERT ls_charac_value INTO TABLE lt_charac_value.

      ls_charac_value-field_name = 'VKORG'.
      ls_charac_value-db_table   = 'EKPV'.
      INSERT ls_charac_value INTO TABLE lt_charac_value.

      ls_charac_value-field_name = 'VTWEG'.
      ls_charac_value-db_table   = 'EKPV'.
      INSERT ls_charac_value INTO TABLE lt_charac_value.

      ls_charac_value-field_name = 'SPART'.
      ls_charac_value-db_table   = 'EKPV'.
      INSERT ls_charac_value INTO TABLE lt_charac_value.

      mo_data_access->get_charac_values(
        EXPORTING
          iv_order_type   = lv_order_type
        IMPORTING
          et_failed_key   = lt_failed_key
       CHANGING
         ct_charac_values = lt_charac_value
     ).

      ev_success = xsdbool( lt_failed_key IS INITIAL ).

      IF NOT lt_charac_value IS INITIAL.

        LOOP AT lt_charac_value
          ASSIGNING FIELD-SYMBOL(<ls_charc_field>).

* Check if the KNVV key field values could be determined, otherwise we cannot determine the KNVV field value
* and stop processing. We assume that (parts of) the key of the KNVV table cannot be initial!
          IF <ls_charc_field>-value IS INITIAL.
            CLEAR:
              rv_charc_value.
            EXIT.
          ENDIF.

          CASE <ls_charc_field>-field_name.

            WHEN 'KUNNR'.
              DATA(lv_kunnr) = <ls_charc_field>-value.

            WHEN 'VKORG'.
              DATA(lv_vkorg) = <ls_charc_field>-value.

            WHEN 'VTWEG'.
              DATA(lv_vtweg) = <ls_charc_field>-value.

            WHEN 'SPART'.
              DATA(lv_spart) = <ls_charc_field>-value.
          ENDCASE.
        ENDLOOP.

        DATA(ls_salesarea) = mo_data_access->get_salesarea_data(
                                               iv_customer    = CONV #( lv_kunnr )
                                               iv_salesorg    = CONV #( lv_vkorg )
                                               iv_distchannel = CONV #( lv_vtweg )
                                               iv_division    = CONV #( lv_spart )
                                             ).

        ASSIGN COMPONENT is_path_info-order_field OF STRUCTURE ls_salesarea TO <fs_charac_value>.

        IF <fs_charac_value> IS ASSIGNED.

          rv_charc_value = <fs_charac_value>.
        ENDIF.
      ENDIF.

    ENDIF.
  ENDMETHOD.


  METHOD get_charc_value_from_db.
    DATA lv_order_type TYPE prodallocassignedordertype.
    DATA lt_sched_key TYPE tbl_atp_sched_key.
    DATA lt_path_info TYPE tbl_atp_fc_path_info.
    DATA lt_order_cvc LIKE et_order_cvc.


    CLEAR et_order_cvc.

    CHECK it_path_info IS NOT INITIAL AND
          it_sched_key IS NOT INITIAL.

    cf_atp_common_factory=>get(  )->create_charc_value_reader(  )->get_value(
                 EXPORTING
                   it_scheduleline          = CORRESPONDING #( it_sched_key )
                   it_path_info             = it_path_info
                   it_pal_data              = it_pal_data
                 IMPORTING
                   et_order_cvc             = et_order_cvc
                   et_charac_hierarchy_path = et_charac_hierarchy_path
               ).
  ENDMETHOD.


  METHOD get_charc_value_help_data.
*! This method determines the value help data for a characteristics of the characteristics catalog.
*  In general the input data (IT_ID_SELOPT and IT_DESC_SELOPT) must be provided in external representation and
*  the result (ET_VALUE) will be in external representation, too.
*  Use IV_NO_CONVERSION to work with internal data only (input and result).
*  Use IV_SELOPT_AND to define how the select options (IT_ID_SELOPT and IT_DESC_SELOPT) should be combined. If the
*  value help has only one single input field, it is suggested to use OR logic, if there are separate fields for IDs and
*  descriptions, it is suggested to use AND logic.

    DATA:
      lv_charc              TYPE c LENGTH 40,
      lv_select_on_external TYPE boole_d,
      ls_paging             LIKE is_paging,
      lt_id_selopt          LIKE it_id_selopt,
      lt_desc_selopt        LIKE it_desc_selopt.

    FIELD-SYMBOLS:
      <ls_value>  LIKE LINE OF et_value.

    CLEAR:
      et_value,
      ev_count.

    CHECK is_catalog_path-prodalloccharcvaluehelp IS NOT INITIAL. "No value help => no data.

    lt_desc_selopt = it_desc_selopt.
    ls_paging      = is_paging.

    IF it_id_selopt IS NOT INITIAL.
      IF iv_no_conversion = abap_true.  "Should only be used in special cases, like old configure alternative control app.
        lt_id_selopt = it_id_selopt.
      ELSE.

        convert_selopt_ext_to_int(
          EXPORTING
            is_catalog_path       = is_catalog_path       " Characteristic Catalog Path
            it_id_selopt          = it_id_selopt          " Select Options for IDs in external format
          IMPORTING
            et_id_selopt          = lt_id_selopt          " Select Options for IDs in internal format
            ev_select_on_external = lv_select_on_external " Do the selection on external data
        ).

        IF lv_select_on_external = abap_true.
          CLEAR:
            lt_desc_selopt,
            ls_paging.
        ENDIF.
      ENDIF.
    ENDIF.

    mo_data_access->get_fc_catalog_value_help_data(
      EXPORTING
        is_catalog_path = is_catalog_path
        is_paging       = ls_paging
        it_id_selopt    = lt_id_selopt
        it_desc_selopt  = lt_desc_selopt
        iv_selopt_and   = iv_selopt_and   "Combine select options for IDs and descriptions with AND logic
      IMPORTING
        et_value        = et_value
        ev_count        = ev_count
    ).

    IF  iv_has_count     = abap_false
    AND iv_no_conversion = abap_false.
      "Convert fields that have a conversion exit
      LOOP AT et_value ASSIGNING <ls_value>.
        lv_charc = mo_charc_ctlg_utility->convert_charc_value_out( iv_path_intid = is_catalog_path-prodalloccharcctlgpathintid  iv_value = <ls_value>-prodalloccharc ).
        <ls_value>-prodalloccharc = lv_charc.
      ENDLOOP.
    ENDIF.

    IF lines( et_value ) < 10000.
      "If more than 10.000 values were found, it makes no sense to sort them.
      "The user should provide more selective select options.
      SORT et_value BY prodalloccharc.
    ENDIF.

    IF lv_select_on_external = abap_true.
      "The used characteristic has a conversion routine. Do the selection on the already converted data.
      select_on_external(
        EXPORTING
          is_paging      = is_paging
          it_id_selopt   = it_id_selopt
          it_desc_selopt = it_desc_selopt
          iv_selopt_and  = iv_selopt_and  "Combine select options for IDs and descriptions with AND logic
        CHANGING
          ct_value       = et_value
          cv_count       = ev_count
      ).
    ENDIF.

  ENDMETHOD.


  METHOD get_charc_value_help_data_mult.
*! This method determines the value help data for a characteristics of one or multiple catalogs.
*  In case of a 'mixed catalog' (e.g. sales documents and STOs), the value help data is based
*  on its corresponding individual catalog value helps.
*  In general a characteristic that is used in different catalogs should have the same value help
*  and select the same value help data. In case of value groups, the selected data depends on the catalog, too.

    DATA:
      lt_catalog_path    TYPE STANDARD TABLE OF pactlg_path,
      lv_multi           TYPE boole_d,
      ls_paging          TYPE /iwbep/s_mgw_paging,
      lv_last_value_help TYPE prodalloccharcvaluehelp,
      lt_value           LIKE et_value,
      lv_counter         TYPE i.

    FIELD-SYMBOLS:
      <ls_catalog_path> LIKE LINE OF it_catalog_path,
      <ls_value>        LIKE LINE OF et_value.

    CLEAR:
      et_value,
      ev_count.

    CHECK it_catalog_path IS NOT INITIAL.

    lv_multi = has_multi_value_helps( it_catalog_path = it_catalog_path ).

    IF lv_multi = abap_true.
      "In case of multi value helps, the paging must be applied to the combined value help data.
      CLEAR ls_paging.
    ELSE.
      "In case of a single value help, the paging must be done (for performance reasons) with the data selection.
      ls_paging = is_paging.
    ENDIF.

    lt_catalog_path = it_catalog_path.
    SORT lt_catalog_path BY prodalloccharcvaluehelp.

    LOOP AT lt_catalog_path ASSIGNING <ls_catalog_path>
      WHERE prodalloccharcvaluehelp IS NOT INITIAL.

      CHECK <ls_catalog_path>-prodalloccharcvaluehelp = gc_valgrp             "The value group value help might have different data per catalog.
         OR <ls_catalog_path>-prodalloccharcvaluehelp <> lv_last_value_help.  "All other value helps have the same data in each catalog.

      lv_last_value_help = <ls_catalog_path>-prodalloccharcvaluehelp.

      get_charc_value_help_data(
        EXPORTING
          is_catalog_path  = <ls_catalog_path>
          is_paging        = ls_paging
          it_id_selopt     = it_id_selopt
          it_desc_selopt   = it_desc_selopt
          iv_has_count     = iv_has_count
          iv_selopt_and    = iv_selopt_and
        IMPORTING
          et_value         = et_value
          ev_count         = ev_count
      ).

      IF lv_multi = abap_false.
        RETURN.
      ENDIF.

      INSERT LINES OF et_value INTO TABLE lt_value.
    ENDLOOP.

    IF lt_value IS INITIAL.
      RETURN.
    ENDIF.

    "Combine the values from the different value helps and apply paging data.
    CLEAR:
      et_value,
      ev_count.

    SORT lt_value BY prodalloccharc.
    DELETE ADJACENT DUPLICATES FROM lt_value COMPARING prodalloccharc.

    ev_count = lines( lt_value ).

    IF is_paging IS INITIAL.
      et_value = lt_value.
      RETURN.
    ENDIF.

    LOOP AT lt_value ASSIGNING <ls_value>.

      lv_counter += 1.

      IF is_paging-skip IS NOT INITIAL.
        CHECK lv_counter > is_paging-skip.
      ENDIF.

      IF is_paging-top IS INITIAL
      OR lines( et_value ) < is_paging-top.
        INSERT <ls_value> INTO TABLE et_value.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.


  METHOD get_charc_value_help_path.
    DATA:
      lv_catalog_path_uuid TYPE prodalloccharcctlgpathuuid.

    DATA:
      lv_field_length TYPE i,
      lo_ref          TYPE REF TO cl_abap_elemdescr.

    FIELD-SYMBOLS:
      <ls_filter_selopt> TYPE LINE OF /iwbep/t_mgw_select_option,
      <ls_selopt>        TYPE LINE OF /iwbep/t_cod_select_options.

    CLEAR: es_catalog_path, et_id_selopt, et_desc_selopt.

*   extract data from filter
    LOOP AT it_filter_select_options ASSIGNING <ls_filter_selopt>.
      CASE <ls_filter_selopt>-property.
        WHEN 'ProdAllocCharcCtlgPathUUID'.
          READ TABLE <ls_filter_selopt>-select_options INDEX 1 ASSIGNING <ls_selopt>.
          IF sy-subrc = 0.
            lv_catalog_path_uuid = <ls_selopt>-low.
          ENDIF.
        WHEN 'ProdAllocCharc' OR 'ATPFldCtlgCharcValue'.    "AB2700361
          et_id_selopt  = <ls_filter_selopt>-select_options.
          et_desc_selopt = <ls_filter_selopt>-select_options.
          "convert ID to upper case"
          READ TABLE et_id_selopt INDEX 1 ASSIGNING <ls_selopt>.
          IF sy-subrc = 0.
            <ls_selopt>-low = to_upper( <ls_selopt>-low ).
          ENDIF.
      ENDCASE.
    ENDLOOP.

*   get catalog path data from DB
    mo_data_access->get_fc_catalog_path_and_base(
      EXPORTING
        it_catalog_path_uuid = VALUE #( ( charc_path_uuid = lv_catalog_path_uuid ) )
      IMPORTING
        et_catalog_path      = et_catalog_path
    ).
    IF lines( et_catalog_path ) > 0.
      es_catalog_path = et_catalog_path[ 1 ].
    ENDIF.

*   remove id selection option, if content is greater than data element length plus two characters
*   for CP wildcardds
    READ TABLE et_id_selopt INDEX 1 ASSIGNING <ls_selopt>.
    IF sy-subrc = 0.
*      DESCRIBE FIELD (es_catalog_path-abapdataelement) LENGTH lv_field_length IN CHARACTER MODE.
      lo_ref ?= cl_abap_typedescr=>describe_by_name( es_catalog_path-abapdataelement ).
      lv_field_length = lo_ref->output_length.
      IF strlen( <ls_selopt>-low ) - 2 > lv_field_length.
        CLEAR et_id_selopt.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD get_value_or_substn_from_db.

    CLEAR et_order_cvc.

    cf_atp_common_factory=>get(  )->create_charc_value_reader(  )->get_value_or_substitution(
              EXPORTING
                it_scheduleline          = it_scheduleline
                it_path_info             = it_path_info
                it_pal_data              = it_pal_data
              IMPORTING
                et_order_cvc             = et_order_cvc
                et_charac_hierarchy_path = et_charac_hierarchy_path
            ).
  ENDMETHOD.


  METHOD grp_charc_value_online.
    DATA: ls_value_grp_base_path_info TYPE if_read_pal_data=>ty_value_group_base_info,
          ls_atp_base_path_info       TYPE atp_fc_path_info,
          lv_base_char_value          TYPE prodallocationcharacteristic,
          lt_map                      TYPE if_read_pal_data=>tt_value_group_value_map,
          ls_value_group_map          LIKE LINE OF lt_map.

    CLEAR: lt_map,
           ls_value_group_map.

    "first get the base characteristic for the value group
    mo_db_access->get_base_info_for_value_grp( EXPORTING iv_value_grp_parpathintid = is_path_info-parent_path_id
    IMPORTING es_base_path_info = ls_value_grp_base_path_info ).

    ls_atp_base_path_info-path_id = ls_value_grp_base_path_info-base_path_id.
    ls_atp_base_path_info-path = ls_value_grp_base_path_info-base_path.
    ls_atp_base_path_info-alt_path = ls_value_grp_base_path_info-base_alt_path.
    ls_atp_base_path_info-order_field = ls_value_grp_base_path_info-base_order_field.
    ls_atp_base_path_info-db_table = ls_value_grp_base_path_info-base_db_table.
    ls_atp_base_path_info-sel_key = ls_value_grp_base_path_info-base_sel_key.
    ls_atp_base_path_info-sel_value = ls_value_grp_base_path_info-base_sel_value.
    ls_atp_base_path_info-cat_type = is_path_info-cat_type.
    ls_atp_base_path_info-clfncharacteristicusetype = ls_value_grp_base_path_info-base_clfncharacteristicusetype.
    ls_atp_base_path_info-charcinternalid = ls_value_grp_base_path_info-base_charcinternalid.
    ls_atp_base_path_info-parent_path_id = ls_value_grp_base_path_info-base_par_path_id.
    ls_atp_base_path_info-charc_type = if_pacharccatalogcharctype_c=>sc_base.
    ls_atp_base_path_info-charccatalogpathhierarchytype = ls_value_grp_base_path_info-base_hierarchy_type.

    "get the characteristic value for the base characteristic. This value is stored within the sales order
    me->get_charc_value_for_path( EXPORTING is_path_info   = ls_atp_base_path_info is_schedkey = is_schedkey iv_location = iv_location
    IMPORTING ev_success     = DATA(ls_success)
          RECEIVING rv_charc_value = lv_base_char_value ).

* In case of product hierarchy characteristics we need to translate the PH / PH node UUID.
    IF ls_value_grp_base_path_info-base_hierarchy_type =  if_charcctlgpathhiertype_c=>sc_domainvalues-producthierarchy.

      DATA(lv_ph_uuid) = lv_base_char_value.

      mo_hierarchy_utility->determine_hierarchy_evaluation(
        EXPORTING
          iv_charac_value   = lv_ph_uuid
          iv_charac         = substring_after( val = ls_atp_base_path_info-path
                                               sub = if_prod_alloc_charc_catalog_c=>sc_field_access_symbol )
          iv_hierarchy_type = ls_value_grp_base_path_info-base_hierarchy_type
        IMPORTING
          ev_charac_value   = lv_base_char_value
      ).
    ENDIF.

    ls_value_group_map-value_group_path_id = is_path_info-path_id.
    ls_value_group_map-value_group_base_value = lv_base_char_value.
    ls_value_group_map-value_group_value = ''.

    INSERT ls_value_group_map INTO lt_map INDEX 1.

    "with the characteristic value of the base characteristic (from sales order) we can now determine the group value
    IF is_path_info-characteristicvaluegrouptype = if_charcvaluegrouptype_c=>sc_continuous.
      mo_db_access->get_grp_vals_for_cont_val_grp(
        CHANGING
          ct_value_grp_value_map = lt_map
      ).
    ELSE.
      mo_db_access->get_grp_values_for_base_values(
      CHANGING
        ct_value_grp_value_map = lt_map
        ).
    ENDIF.

    READ TABLE lt_map INTO DATA(ls_map) INDEX 1.
    ev_success = xsdbool( sy-subrc = 0 ).
    rv_charc_value = ls_map-value_group_value.
  ENDMETHOD.


  METHOD has_multi_value_helps.

    DATA:
      lt_value_help   TYPE STANDARD TABLE OF prodalloccharcvaluehelp.

    FIELD-SYMBOLS:
      <ls_catalog_path> LIKE LINE OF it_catalog_path.

    rv_result = abap_false.

    CHECK lines( it_catalog_path ) > 1.

    LOOP AT it_catalog_path ASSIGNING <ls_catalog_path>
      WHERE prodalloccharcvaluehelp IS NOT INITIAL.

      IF <ls_catalog_path>-prodalloccharcvaluehelp = gc_valgrp.
        "In case of value groups all value helps have to be used for data selection.
        rv_result = abap_true.
        RETURN.
      ENDIF.

      INSERT <ls_catalog_path>-prodalloccharcvaluehelp INTO TABLE lt_value_help.
    ENDLOOP.

    SORT lt_value_help.
    DELETE ADJACENT DUPLICATES FROM lt_value_help.

    IF lines( lt_value_help ) > 1.
      "In case of different value helps, use all of them.
      rv_result = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD POPULATE_FIELD_MAPPING.

    IF mt_field_mapping IS INITIAL.

      mt_field_mapping = VALUE #(
* The following fields were redirected (from original source to new source) by SD in the I_SalesDocumentItem VDM CDS view for usage in SD analytics.
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VBTYP_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VBTYP'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'BSTKD_ANA'
                                            original_table = 'VBKD'
                                            original_field = 'BSTKD'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'BZIRK_ANA'
                                            original_table = 'VBKD'
                                            original_field = 'BZIRK'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KDGRP_ANA'
                                            original_table = 'VBKD'
                                            original_field = 'KDGRP'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KNUMV_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KNUMV'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VSART_ANA'
                                            original_table = 'VBKD'
                                            original_field = 'VSART'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'FKDAT_ANA'
                                            original_table = 'VBKD'
                                            original_field = 'FKDAT'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'FPLNR_ANA'
                                            original_table = 'VBKD'
                                            original_field = 'FPLNR'
                                          )
* The following fields were added by SD in the I_SalesDocumentItem VDM CDS view for usage in SD analytics.
* These fields have a different original source.
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'AUART_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'AUART'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VKORG_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VKORG'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VTWEG_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VTWEG'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'SPART_ANA'
                                            original_table = 'VBAP'
                                            original_field = 'SPART'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VKBUR_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VKBUR'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VKGRP_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VKGRP'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KUNNR_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KUNNR'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KVGR1_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KVGR1'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KVGR2_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KVGR2'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KVGR3_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KVGR3'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KVGR4_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KVGR4'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'KVGR5_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'KVGR5'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'AUDAT_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'AUDAT'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'AUGRU_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'AUGRU'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VDATU_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VDATU'
                                          )
                                          ( actual_table   = 'VBAP'
                                            actual_field   = 'VSBED_ANA'
                                            original_table = 'VBAK'
                                            original_field = 'VSBED'
                                          )
                                        ).
    ENDIF.
  ENDMETHOD.


  METHOD select_on_external.

    DATA:
      lt_value   LIKE ct_value,
      lv_counter TYPE i,
      lv_where   TYPE string.

    FIELD-SYMBOLS:
      <ls_value>  LIKE LINE OF ct_value.

    CHECK ct_value IS NOT INITIAL.
    CHECK it_id_selopt IS NOT INITIAL OR it_desc_selopt IS NOT INITIAL.

    IF it_id_selopt IS NOT INITIAL AND it_desc_selopt IS NOT INITIAL.
      IF iv_selopt_and = abap_true.
        lv_where = 'prodalloccharc IN it_id_selopt AND prodalloccharcdesc IN it_desc_selopt' ##NO_TEXT.
      ELSE.
        lv_where = 'prodalloccharc IN it_id_selopt OR prodalloccharcdesc IN it_desc_selopt' ##NO_TEXT.
      ENDIF.
    ELSEIF it_id_selopt IS NOT INITIAL.
      lv_where = 'prodalloccharc IN it_id_selopt' ##NO_TEXT.
    ELSEIF it_desc_selopt IS NOT INITIAL.
      lv_where = 'prodalloccharcdesc IN it_desc_selopt' ##NO_TEXT.
    ENDIF.

    LOOP AT ct_value ASSIGNING <ls_value>
      WHERE (lv_where).

      lv_counter += 1.

      IF is_paging-skip IS NOT INITIAL.
        CHECK lv_counter > is_paging-skip.
      ENDIF.

      IF is_paging-top IS INITIAL
      OR lines( lt_value ) < is_paging-top.
        INSERT <ls_value> INTO TABLE lt_value.
      ENDIF.

    ENDLOOP.

    ct_value = lt_value.
    cv_count = lv_counter.

  ENDMETHOD.
ENDCLASS.