CLASS cl_atp_data_access DEFINITION
  PUBLIC
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES if_atp_data_access .

    METHODS constructor
      IMPORTING
        !io_masterdata_db           TYPE REF TO cl_atp_pac_db_masterdata OPTIONAL
        !io_pal_db                  TYPE REF TO if_pal_db_access OPTIONAL
        !io_fieldcatalog_db         TYPE REF TO if_atp_fieldcatalog_db OPTIONAL
        !io_charc_dp                TYPE REF TO if_atp_charc_data_provider OPTIONAL
        !io_order_info_dp           TYPE REF TO if_atp_order_info_data_providr OPTIONAL
        !io_document_data_provider  TYPE REF TO if_atp_document_data_provider OPTIONAL
        !io_sd_dbsel_cust           TYPE REF TO if_sd_dbsel_cust OPTIONAL
        !io_customizing_db          TYPE REF TO if_atp_customizing_db OPTIONAL
        !io_customizing_data_access TYPE REF TO if_atp_customizing_data_access OPTIONAL
        !io_masterdata_access       TYPE REF TO if_atp_master_data_access OPTIONAL.

  PROTECTED SECTION.

    METHODS get_itm_bef_chk_from_appl_buf
      IMPORTING
        !it_item_key      TYPE tbl_atp_item_key_wo_subitem
      EXPORTING
        !et_data          TYPE REF TO data
        !et_key_not_found TYPE REF TO data .
    METHODS fill_key_not_found
      IMPORTING
        !it_item_key      TYPE tbl_atp_item_key_wo_subitem
        !it_data          TYPE REF TO data
      EXPORTING
        !et_key_not_found TYPE REF TO data .

  PRIVATE SECTION.

    DATA mo_sd_dbsel_cust TYPE REF TO if_sd_dbsel_cust .
    DATA mo_masterdata_db TYPE REF TO cl_atp_pac_db_masterdata .
    DATA mo_pal_db TYPE REF TO if_pal_db_access .
    DATA mo_fieldcatalog_db TYPE REF TO if_atp_fieldcatalog_db .
    DATA mo_charc_dp TYPE REF TO if_atp_charc_data_provider .
    DATA mo_order_info_dp TYPE REF TO if_atp_order_info_data_providr .
    DATA mo_document_data_provider TYPE REF TO if_atp_document_data_provider .
    DATA mo_item_buffer_handler TYPE REF TO cl_atp_item_buffer_handler .
    DATA mo_customizing_data_access TYPE REF TO if_atp_customizing_data_access.
    DATA mo_masterdata_access TYPE REF TO if_atp_master_data_access.

    METHODS get_item_data_from_appl_buffer
      IMPORTING
        !it_item_key  TYPE tbl_atp_item_key_wo_subitem
      EXPORTING
        !et_item_data TYPE if_atp_data_access=>tt_vbap_db_state_data
        !ev_not_found TYPE boole_d .
    METHODS insert_to_negative_buffer
      IMPORTING
        !it_key    TYPE REF TO data
        !io_buffer TYPE REF TO if_atp_buffer .
    METHODS get_charc_value_from_buffer
      IMPORTING
        !it_key          TYPE REF TO data
        !io_buffer       TYPE REF TO if_atp_buffer
        !is_charac_value TYPE if_atp_data_access=>ty_charac_values
      EXPORTING
        VALUE(ev_value)  TYPE char40
      EXCEPTIONS
        key_not_found_in_buffer .
    METHODS get_abc_subst_charac_values
      IMPORTING
        !is_charac_value  TYPE if_atp_data_access=>ty_charac_values
      CHANGING
        !cr_buffer_result TYPE REF TO data .
    METHODS find_address_by
      IMPORTING
        !iv_addrnumber    TYPE ad_addrnum
      RETURNING
        VALUE(rs_address) TYPE adrc .
    METHODS copy_info_from_base_to_mix
      IMPORTING
        !it_catalog_path_ref       TYPE if_atp_fieldcatalog_db=>tt_catalog_path_ref
        !it_base_path              TYPE pactlg_path_tab
      EXPORTING
        !et_base_path_uuid_missing TYPE if_atp_data_access=>tt_fc_catalog_path_uuid
      CHANGING
        !ct_catalog_path           TYPE pactlg_path_tab .
    METHODS convert_appl_buf_to_item_data
      IMPORTING
        !it_item_key  TYPE tbl_atp_item_key_wo_subitem
        !it_xvbap     TYPE va_vbapvb_t OPTIONAL
        !it_yvbap     TYPE va_vbapvb_t OPTIONAL
        !it_vbap      TYPE vbap_t
      EXPORTING
        !et_item_data TYPE if_atp_data_access=>tt_vbap_db_state_data .
    METHODS get_partner_data_from_buffer
      IMPORTING
        !it_key           TYPE if_atp_order_info_data_providr=>tt_partner_function_key
      EXPORTING
        !et_partner_data  TYPE if_atp_data_access=>ttsk_partner_data
        !et_key_not_found TYPE if_atp_order_info_data_providr=>tt_partner_function_key .
    METHODS get_partner_data_from_db
      IMPORTING
        !it_key          TYPE if_atp_order_info_data_providr=>tt_partner_function_key
      EXPORTING
        !et_partner_data TYPE if_atp_data_access=>ttsk_partner_data .
    METHODS merge_vbep_db_state
      IMPORTING
        !it_item_key               TYPE tbl_atp_item_key_wo_subitem
        !it_vbep_db_state_base     TYPE if_atp_data_access=>tt_vbep_db_state_data
        !it_vbep_db_state_to_merge TYPE if_atp_data_access=>tt_vbep_db_state_data
      EXPORTING
        !et_vbep_db_state_merged   TYPE if_atp_data_access=>tt_vbep_db_state_data
        !et_item_key_not_found     TYPE tbl_atp_item_key_wo_subitem .
    METHODS fill_vbep_db_state_buffer
      IMPORTING
        !it_item_key_not_exist      TYPE tbl_atp_item_key_wo_subitem
        !it_vbep_db_state_to_buffer TYPE if_atp_data_access=>tt_vbep_db_state_data .
    METHODS get_atpmat_from_buffer
      IMPORTING
        !it_mat_key_sorted         TYPE tbl_atp_mat_key_sorted
        !io_buffer                 TYPE REF TO if_atp_buffer
      EXPORTING
        !et_atpmat                 TYPE tbl_atpmat_sorted
        !et_key_not_found_unsorted TYPE tbl_atp_mat_key.
    METHODS fill_atpmat_buffers
      IMPORTING
        !io_buffer                 TYPE REF TO if_atp_buffer
        !it_atpmat_from_db_sorted  TYPE tbl_atpmat_sorted
        !it_key_not_found_unsorted TYPE tbl_atp_mat_key.
ENDCLASS.



CLASS CL_ATP_DATA_ACCESS IMPLEMENTATION.


  METHOD constructor.

    IF io_fieldcatalog_db IS BOUND.
      mo_fieldcatalog_db = io_fieldcatalog_db.
    ELSE.
      mo_fieldcatalog_db = NEW cl_atp_fieldcatalog_db( ).
    ENDIF.

    IF io_pal_db IS BOUND.
      mo_pal_db = io_pal_db.
    ELSE.
      mo_pal_db = NEW cl_pal_db_access( ).
    ENDIF.

    IF io_masterdata_db IS BOUND.
      mo_masterdata_db = io_masterdata_db.
    ELSE.
      mo_masterdata_db = NEW cl_atp_pac_db_masterdata( ).
    ENDIF.

    IF io_charc_dp IS BOUND.
      mo_charc_dp = io_charc_dp.
    ELSE.
      mo_charc_dp = NEW cl_atp_charc_data_provider( ).
    ENDIF.

    IF io_order_info_dp IS BOUND.
      mo_order_info_dp = io_order_info_dp.
    ELSE.
      mo_order_info_dp = NEW cl_atp_order_info_data_providr( ).
    ENDIF.

    IF io_document_data_provider IS BOUND.
      mo_document_data_provider = io_document_data_provider.
    ELSE.
      mo_document_data_provider = NEW cl_atp_document_data_provider( ).
    ENDIF.

    IF io_sd_dbsel_cust IS BOUND.
      mo_sd_dbsel_cust = io_sd_dbsel_cust.
    ELSE.
      mo_sd_dbsel_cust = cl_sd_dbsel_cust=>so_instance.
*      NEW cl_sd_dbsel_cust( ).
    ENDIF.

    IF io_customizing_db IS BOUND.
      DATA(lo_customizing_db) = io_customizing_db.
    ELSE.
      lo_customizing_db = NEW cl_atp_customizing_db( ).
    ENDIF.

    IF io_customizing_data_access IS BOUND.
      mo_customizing_data_access = io_customizing_data_access.
    ELSE.
      mo_customizing_data_access = NEW cl_atp_customizing_data_access(
        io_customizing_db = lo_customizing_db
      ).
    ENDIF.

    IF io_masterdata_access IS BOUND.
      mo_masterdata_access = io_masterdata_access.
    ELSE.
      mo_masterdata_access = NEW cl_atp_master_data_access(
        masterdata_access = io_masterdata_db ).
    ENDIF.

  ENDMETHOD.


  METHOD convert_appl_buf_to_item_data.

    DATA:
      ls_item_data LIKE LINE OF et_item_data.

    "First priority: Add VBAP from Delivery buffer
    LOOP AT it_vbap ASSIGNING FIELD-SYMBOL(<ls_vbap>).
      CLEAR ls_item_data.
      READ TABLE it_item_key ASSIGNING FIELD-SYMBOL(<ls_item_key>)
        WITH KEY delnr = <ls_vbap>-vbeln.
      IF sy-subrc = 0.
        ls_item_data-atpcat = <ls_item_key>-atpcat.
        MOVE-CORRESPONDING <ls_vbap> TO ls_item_data ##enh_ok .
        ls_item_data-delnr = <ls_vbap>-vbeln.
        ls_item_data-delps = <ls_vbap>-posnr.
        ls_item_data-substitution_status = <ls_vbap>-atp_abc_substitution_status.
        INSERT ls_item_data INTO TABLE et_item_data.
      ENDIF.
    ENDLOOP.
    UNASSIGN <ls_vbap>.

    "Second priority: use DB state from sales order buffer
    LOOP AT it_yvbap ASSIGNING FIELD-SYMBOL(<ls_yvbap>)
      WHERE updkz IS INITIAL.
      CLEAR ls_item_data.
      READ TABLE it_item_key ASSIGNING <ls_item_key>
        WITH KEY delnr = <ls_yvbap>-vbeln.
      IF sy-subrc = 0.
        ls_item_data-atpcat = <ls_item_key>-atpcat.
        MOVE-CORRESPONDING <ls_yvbap> TO ls_item_data  ##enh_ok .
        ls_item_data-delnr = <ls_yvbap>-vbeln.
        ls_item_data-delps = <ls_yvbap>-posnr.
        ls_item_data-substitution_status = <ls_yvbap>-atp_abc_substitution_status.
        INSERT ls_item_data INTO TABLE et_item_data.
      ENDIF.
    ENDLOOP.
    UNASSIGN <ls_yvbap>.

    "lowest priority: use current state from sales order buffer
    LOOP AT it_xvbap ASSIGNING FIELD-SYMBOL(<ls_xvbap>)
      WHERE updkz IS INITIAL.
      CLEAR ls_item_data.
      READ TABLE it_item_key ASSIGNING <ls_item_key>
        WITH KEY delnr = <ls_xvbap>-vbeln.
      IF sy-subrc = 0.
        ls_item_data-atpcat = <ls_item_key>-atpcat.
        MOVE-CORRESPONDING <ls_xvbap> TO ls_item_data  ##enh_ok .
        ls_item_data-delnr = <ls_xvbap>-vbeln.
        ls_item_data-delps = <ls_xvbap>-posnr.
        ls_item_data-substitution_status = <ls_xvbap>-atp_abc_substitution_status.
        INSERT ls_item_data INTO TABLE et_item_data.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD copy_info_from_base_to_mix.

    CLEAR et_base_path_uuid_missing.

    LOOP AT it_catalog_path_ref ASSIGNING FIELD-SYMBOL(<ls_path_ref>) WHERE prodalloccharccatalogismain = abap_true.

      READ TABLE it_base_path ASSIGNING FIELD-SYMBOL(<ls_base_path>)
                              WITH KEY prodalloccharcctlgpathuuid = <ls_path_ref>-basecharccatalogpathuuid.
      IF sy-subrc <> 0.
        INSERT VALUE #( charc_path_uuid = <ls_path_ref>-basecharccatalogpathuuid ) INTO TABLE et_base_path_uuid_missing.
        CONTINUE.
      ENDIF.

      READ TABLE ct_catalog_path ASSIGNING FIELD-SYMBOL(<ls_mixed_path>)
                                 WITH KEY prodalloccharcctlgpathuuid = <ls_path_ref>-prodalloccharcctlgpathuuid.
      CHECK sy-subrc = 0.

      <ls_mixed_path>-prodalloccharcvaluehelp        = <ls_base_path>-prodalloccharcvaluehelp.
      <ls_mixed_path>-prodalloccharcvalhelptblfield  = <ls_base_path>-prodalloccharcvalhelptblfield.
      <ls_mixed_path>-prodalloccharcvalhelptextlink  = <ls_base_path>-prodalloccharcvalhelptextlink.
      <ls_mixed_path>-prodalloccharcvalhelptxttblfld = <ls_base_path>-prodalloccharcvalhelptxttblfld.
      <ls_mixed_path>-charcvalexistencechecktype     = <ls_base_path>-charcvalexistencechecktype.

    ENDLOOP.

  ENDMETHOD.


  METHOD fill_atpmat_buffers.

    io_buffer->set( it_data = it_atpmat_from_db_sorted ).

    DATA lt_negative_buffer TYPE tbl_atp_mat_key_sorted.

    LOOP AT it_key_not_found_unsorted ASSIGNING FIELD-SYMBOL(<ls_atp_mat_key>).

      IF NOT line_exists( it_atpmat_from_db_sorted[ matnr = <ls_atp_mat_key>-matnr
                                                    werks = <ls_atp_mat_key>-werks
                                                    berid = <ls_atp_mat_key>-berid ] ).

        INSERT <ls_atp_mat_key> INTO TABLE lt_negative_buffer.

      ENDIF.

    ENDLOOP.

    "all entries left in keys are also not available on DB, so put it to negative buffer.
    IF lt_negative_buffer IS NOT INITIAL.
      me->insert_to_negative_buffer(
        EXPORTING
          it_key    = REF #( lt_negative_buffer )
          io_buffer = io_buffer
      ).
    ENDIF.

  ENDMETHOD.


  METHOD fill_key_not_found.
    " Check if all keys were found

    FIELD-SYMBOLS:
      <lt_key_not_found> TYPE tbl_atp_item_key_wo_subitem,
      <lt_data>          TYPE if_atp_data_access=>tt_vbap_db_state_data.


    ASSIGN et_key_not_found->* TO <lt_key_not_found>.
    CHECK sy-subrc = 0.
    ASSIGN it_data->* TO <lt_data>.
    CHECK sy-subrc = 0.

    LOOP AT it_item_key INTO DATA(ls_item_key).
      READ TABLE <lt_data>
      WITH KEY item_key = ls_item_key
      TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        INSERT ls_item_key INTO TABLE <lt_key_not_found>.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD fill_vbep_db_state_buffer.

    DATA: lr_negative_key       TYPE REF TO data.

    FIELD-SYMBOLS: <lt_negative_key>       TYPE ANY TABLE.

    DATA(lo_buffer) = cl_atp_buffer_manager=>get_vbep_db_state_buffer( ).
    lo_buffer->set( it_data = it_vbep_db_state_to_buffer ).


    CHECK it_item_key_not_exist IS NOT INITIAL.

    lo_buffer->get_key_table_structure(
      IMPORTING
        er_key_table_structure = lr_negative_key
    ).

    ASSIGN lr_negative_key->* TO <lt_negative_key>.

    <lt_negative_key> = CORRESPONDING #( it_item_key_not_exist DISCARDING DUPLICATES ).

    me->insert_to_negative_buffer(
      EXPORTING
        it_key    = REF #( <lt_negative_key> )
        io_buffer = lo_buffer
    ).

  ENDMETHOD.


  METHOD find_address_by.

    DATA:
      lt_address_parameter TYPE TABLE OF adrc,
      lt_address           TYPE if_atp_data_access=>tts_address.

    FIELD-SYMBOLS: <lt_address> TYPE any.

    lt_address_parameter = VALUE #( ( addrnumber = iv_addrnumber ) ).
    cl_atp_buffer_manager=>get_address_buffer( )->find(
      EXPORTING
        it_data           = REF #( lt_address_parameter )
      IMPORTING
        et_data           = DATA(lr_address_res)
    ).

    ASSIGN lr_address_res->* TO <lt_address>.
    lt_address = CORRESPONDING #( <lt_address> ).
    LOOP AT lt_address ASSIGNING FIELD-SYMBOL(<ls_address>).
      rs_address = CORRESPONDING #( <ls_address> ).
      EXIT.
    ENDLOOP.

    FREE: <lt_address>.

  ENDMETHOD.


  METHOD get_abc_subst_charac_values.

    DATA: lr_sched_key      TYPE REF TO data,
          lr_pac_key        TYPE REF TO data,
          lt_sched_key      TYPE if_atp_abc_data_access=>tt_sched_pac_key,
          lo_pac_key_buffer TYPE REF TO if_atp_buffer.
    FIELD-SYMBOLS:
      <lt_buffer_result> TYPE ANY TABLE,
      <lt_pac_key>       TYPE ANY TABLE,
      <ls_buffer_result> TYPE any,
      <ls_pac_key>       TYPE any.

    ASSIGN cr_buffer_result->* TO <lt_buffer_result>.
    lo_pac_key_buffer = cl_atp_buffer_manager=>get_pac_key_buffer( ).

    LOOP AT <lt_buffer_result> ASSIGNING <ls_buffer_result>.

      IF is_charac_value-db_table = 'VBAP' OR
         is_charac_value-db_table = 'EKPO'.

        lt_sched_key = VALUE #( ( atpcat = is_charac_value-atpcat
                                  delnr = is_charac_value-delnr
                                  delps = is_charac_value-delps
                                  subitem = is_charac_value-subitem ) ).

        lr_sched_key = lo_pac_key_buffer->convert_to_buffer_key( REF #( lt_sched_key ) ).

        lo_pac_key_buffer->get(
          EXPORTING
            it_key  = lr_sched_key
          IMPORTING
            et_data = lr_pac_key
        ).

        ASSIGN lr_pac_key->* TO <lt_pac_key>.
        LOOP AT <lt_pac_key> ASSIGNING <ls_pac_key>.
          MOVE-CORRESPONDING <ls_pac_key> TO <ls_buffer_result>.
        ENDLOOP.

      ENDIF.

    ENDLOOP.

  ENDMETHOD.


  METHOD get_atpmat_from_buffer.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    FIELD-SYMBOLS <lt_key> TYPE tbl_atp_mat_key_sorted.
    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.

    CREATE DATA lr_key TYPE tbl_atp_mat_key_sorted.
    ASSIGN lr_key->* TO <lt_key>.

    <lt_key> = it_mat_key_sorted.

    io_buffer->get(
      EXPORTING
        it_key           = lr_key
      IMPORTING
        et_data          = lr_result
        et_key_not_found = lr_key_not_found
    ).

    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.

    et_atpmat = CORRESPONDING #( <lt_result> ).
    et_key_not_found_unsorted = CORRESPONDING #( <lt_key_not_found> ).

    FREE: <lt_result>,
          <lt_key_not_found>.

  ENDMETHOD.


  METHOD get_charc_value_from_buffer.
    DATA: lr_data          TYPE REF TO data,
          lr_key_not_found TYPE REF TO data.
    FIELD-SYMBOLS <lt_buffer_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <ls_buffer_result> TYPE any.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.

    io_buffer->get(
      EXPORTING
        it_key           = it_key
      IMPORTING
        et_data          = lr_data
        et_key_not_found = lr_key_not_found
    ).

    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.

    IF 0 < lines( <lt_key_not_found> ).
      RAISE key_not_found_in_buffer.
    ENDIF.

    "ABC call, we have to substitute some fields (like werks, matnr) with the help of pac_key buffer
    IF is_charac_value-subitem <> 0.
      get_abc_subst_charac_values(
        EXPORTING
          is_charac_value  = is_charac_value
        CHANGING
          cr_buffer_result = lr_data
      ).
    ENDIF.

    ASSIGN lr_data->* TO <lt_buffer_result>.

    LOOP AT <lt_buffer_result> ASSIGNING <ls_buffer_result>.
      ASSIGN COMPONENT is_charac_value-field_name OF STRUCTURE <ls_buffer_result> TO FIELD-SYMBOL(<charac_value>).
      IF sy-subrc = 0.
        ev_value = <charac_value>.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD get_item_data_from_appl_buffer.

    DATA:
      lt_vbak_key TYPE STANDARD TABLE OF sales_key,
      lt_vbap     TYPE STANDARD TABLE OF vbap.

    CLEAR: et_item_data, ev_not_found.

    cl_atp_db_controller=>get_instance( )->get_item_keys_from_pred(
      EXPORTING
        it_item_key          = it_item_key
      IMPORTING
        et_item_key_delivery = DATA(lt_item_key_delivery)
        et_item_key_sales    = DATA(lt_item_key_sales)
           ).

    IF lt_item_key_delivery IS NOT INITIAL.
      lt_vbak_key  = CORRESPONDING #( lt_item_key_delivery MAPPING vbeln = delnr ).
      CALL FUNCTION 'SD_VBAP_ARRAY_READ_VBELN'
        TABLES
          it_vbak_key = lt_vbak_key
          et_vbap     = lt_vbap
        EXCEPTIONS
          OTHERS      = 0.
    ENDIF.

    IF lt_item_key_sales IS NOT INITIAL.

      DATA(lo_sls_data) = cl_sls_data_ref=>get_instance( ).
      IF lo_sls_data IS BOUND.
        lo_sls_data->get_xvbap(
          IMPORTING
            et_xvbap = DATA(lt_xvbap)
            et_yvbap = DATA(lt_yvbap) ).
      ENDIF.

    ENDIF.

    IF lt_vbap IS INITIAL AND lt_xvbap IS INITIAL AND lt_yvbap IS INITIAL.
      ev_not_found = abap_true.
      RETURN.
    ENDIF.

    convert_appl_buf_to_item_data(
      EXPORTING
        it_item_key  = it_item_key
        it_xvbap     = lt_xvbap
        it_yvbap     = lt_yvbap
        it_vbap      = lt_vbap
      IMPORTING
        et_item_data = et_item_data
    ).

  ENDMETHOD.


  METHOD get_itm_bef_chk_from_appl_buf.

    DATA:
      lt_item_key    LIKE it_item_key,
      lr_item_key    TYPE REF TO data,
      lo_appl_buffer TYPE REF TO if_atp_buffer_read_only,
      lt_vbak_key    TYPE STANDARD TABLE OF sales_key,
      lt_vbap        TYPE STANDARD TABLE OF vbap.

    FIELD-SYMBOLS:
      <lt_item_key>  TYPE ANY TABLE,
      <lt_item_data> TYPE if_atp_data_access=>tt_vbap_db_state_data.

    CLEAR: et_data, et_key_not_found.

    CHECK it_item_key IS NOT INITIAL.

    cl_atp_db_controller=>get_instance( )->get_item_keys_from_pred(
      EXPORTING
        it_item_key          = it_item_key
      IMPORTING
        et_item_key_delivery = DATA(lt_item_key_delivery)
        et_item_key_sales    = DATA(lt_item_key_sales)
    ).

    IF lt_item_key_sales IS NOT INITIAL.
      lo_appl_buffer = cl_atp_buffer_manager=>get_vbap_sales_db_state_buffer( ).
      lo_appl_buffer->get_key_table_structure( IMPORTING er_key_table_structure = lr_item_key ).

      LOOP AT lt_item_key_sales ASSIGNING FIELD-SYMBOL(<ls_item_key>)
        WHERE atpcat IN cl_atpcat_c=>get_range_4_sales_documents( )
          AND delnr IS NOT INITIAL.
        INSERT <ls_item_key> INTO TABLE lt_item_key.
      ENDLOOP.

      IF lt_item_key IS NOT INITIAL.

        ASSIGN lr_item_key->* TO <lt_item_key>.
        <lt_item_key> = CORRESPONDING #( lt_item_key DISCARDING DUPLICATES ).

        lo_appl_buffer->get(
          EXPORTING
            it_key           = lr_item_key
          IMPORTING
            et_data          = et_data
            et_key_not_found = et_key_not_found
        ).

      ENDIF.
    ENDIF.

    IF lt_item_key_delivery IS NOT INITIAL.
      lt_vbak_key  = CORRESPONDING #( lt_item_key_delivery MAPPING vbeln = delnr  ).
      CALL FUNCTION 'SD_VBAP_ARRAY_READ_VBELN'
        TABLES
          it_vbak_key = lt_vbak_key
          et_vbap     = lt_vbap
        EXCEPTIONS
          OTHERS      = 0.

      convert_appl_buf_to_item_data(
        EXPORTING
          it_item_key  = lt_item_key_delivery "it_item_key
          it_vbap      = lt_vbap
        IMPORTING
          et_item_data = DATA(lt_item_data)
      ).

      IF lt_item_data IS NOT INITIAL.
        ASSIGN et_data->* TO <lt_item_data>.
        CHECK sy-subrc = 0.
        INSERT LINES OF lt_item_data INTO TABLE <lt_item_data>.
        UNASSIGN <lt_item_data>.
      ENDIF.
    ENDIF.

    " Check if all keys were found
    fill_key_not_found(
      EXPORTING
        it_item_key      = it_item_key
        it_data          = et_data
      IMPORTING
        et_key_not_found = et_key_not_found
    ).

  ENDMETHOD.


  METHOD get_partner_data_from_buffer.

    DATA: lv_initial_posnr TYPE posnr.

    CLEAR: et_partner_data, et_key_not_found.
    CHECK it_key IS NOT INITIAL.

    mo_order_info_dp->get_partner_data(
      EXPORTING
        it_partner_function_key = it_key
      IMPORTING
        et_partner_data         = et_partner_data
        et_key_not_found        = DATA(lt_key_for_header_buffer)
    ).

    CHECK lt_key_for_header_buffer IS NOT INITIAL.

    MODIFY lt_key_for_header_buffer FROM VALUE #( posnr = lv_initial_posnr ) TRANSPORTING posnr WHERE posnr IS NOT INITIAL.

    mo_order_info_dp->get_partner_data(
      EXPORTING
        it_partner_function_key = lt_key_for_header_buffer
      IMPORTING
        et_partner_data         = DATA(lt_partner_data_from_header)
        et_key_not_found        = et_key_not_found
    ).

    INSERT LINES OF lt_partner_data_from_header INTO TABLE et_partner_data.

  ENDMETHOD.


  METHOD get_partner_data_from_db.

    DATA: lt_key_not_found_on_item TYPE if_atp_order_info_data_providr=>tt_partner_function_key.

    CHECK it_key IS NOT INITIAL.

    DATA(lt_key) = it_key.

    mo_document_data_provider->get_partner_data(
      EXPORTING
        partner_function_keys = it_key
      IMPORTING
        partner_data          = et_partner_data
    ).

    LOOP AT lt_key ASSIGNING FIELD-SYMBOL(<ls_key>).

      IF NOT line_exists( et_partner_data[ KEY order_pf COMPONENTS vbeln = <ls_key>-vbeln
                                                                   posnr = <ls_key>-posnr
                                                                   parvw = <ls_key>-parvw ] ).

        CLEAR <ls_key>-posnr.
        INSERT <ls_key> INTO TABLE lt_key_not_found_on_item.

      ENDIF.

    ENDLOOP.

    CHECK lt_key_not_found_on_item IS NOT INITIAL.

    mo_document_data_provider->get_partner_data(
      EXPORTING
        partner_function_keys = lt_key_not_found_on_item
      IMPORTING
        partner_data          = DATA(lt_partner_data_from_header)
    ).

    INSERT LINES OF lt_partner_data_from_header INTO TABLE et_partner_data.

  ENDMETHOD.


  METHOD if_atp_data_access~get_address.
    DATA lt_address_key TYPE TABLE OF adrc.
    DATA lt_address TYPE if_atp_data_access=>tts_address.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.

    CHECK is_address_key IS NOT INITIAL OR iv_addrnumber IS NOT INITIAL.

    lo_buffer = cl_atp_buffer_manager=>get_address_buffer( ).

    IF is_address_key IS SUPPLIED.
      INSERT CORRESPONDING #( is_address_key ) INTO TABLE lt_address_key.

      lr_key = lo_buffer->convert_to_buffer_key( REF #( lt_address_key ) ).

      lo_buffer->get(
        EXPORTING
          it_key           = lr_key
        IMPORTING
          et_data          = lr_result
          et_key_not_found = lr_key_not_found
      ).

    ELSEIF iv_addrnumber IS SUPPLIED.
      lt_address_key = VALUE #( ( addrnumber = iv_addrnumber ) ).

      lo_buffer->find(
        EXPORTING
          it_data           = REF #( lt_address_key )
        IMPORTING
          et_data           = lr_result
          et_data_not_found = lr_key_not_found
      ).
    ENDIF.



    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    lt_address = CORRESPONDING #( <lt_result> ).

    IF lt_address IS NOT INITIAL.
      rs_address = CORRESPONDING #( lt_address[ 1 ] )."solved analog to PAL solution. They also took the first one, in case there are duplicates on ADDRNUMBER
    ENDIF.

    " Read missing data from db
    IF <lt_key_not_found> IS NOT INITIAL.
      CLEAR lt_address_key.
      lt_address_key = CORRESPONDING #( <lt_key_not_found> ).

      lt_address = mo_pal_db->get_address_data( it_addrnumber = VALUE #( ( lt_address_key[ 1 ]-addrnumber ) ) ).

      "knowledge transfer from PAL read
      IF lt_address IS NOT INITIAL. "if address is changed within the sales order, the result can be empty!
        " Fill to buffer
        DATA lt_adrc TYPE TABLE OF adrc.
        lt_adrc = CORRESPONDING #( lt_address ).
        lo_buffer->set( it_data = lt_adrc ).

        rs_address = lt_address[ 1 ].
      ENDIF.

    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~get_atpmat.

    DATA(lo_buffer) = cl_atp_buffer_manager=>get_atpmat_buffer( ).

    get_atpmat_from_buffer(
      EXPORTING
        it_mat_key_sorted         = it_mat_key
        io_buffer                 = lo_buffer
      IMPORTING
        et_atpmat                 = et_atpmat
        et_key_not_found_unsorted = DATA(lt_key_not_found_unsorted)
    ).

    IF lt_key_not_found_unsorted IS NOT INITIAL.

      mo_masterdata_db->read_material(
        EXPORTING
          it_mat_key = lt_key_not_found_unsorted
        IMPORTING
          et_atpmat  = DATA(lt_atpmat_from_db) ).

      DATA(lt_atpmat_from_db_sorted) = CORRESPONDING tbl_atpmat_sorted( lt_atpmat_from_db ).
      et_atpmat = CORRESPONDING #( BASE ( et_atpmat ) lt_atpmat_from_db_sorted DISCARDING DUPLICATES ).

      fill_atpmat_buffers(
        EXPORTING
          io_buffer                 = lo_buffer
          it_atpmat_from_db_sorted  = lt_atpmat_from_db_sorted
          it_key_not_found_unsorted = lt_key_not_found_unsorted
      ).

    ENDIF.

  ENDMETHOD.


  METHOD if_atp_data_access~get_atpplant.

    CLEAR: es_atpplant, et_atpplant.

    DATA(lt_plant_key) = VALUE if_atp_data_access=>tt_plant_keys( ).

    IF it_plant_key IS SUPPLIED.
      lt_plant_key = it_plant_key.
    ELSEIF is_mat_key IS SUPPLIED.
      INSERT CORRESPONDING #( is_mat_key ) INTO TABLE lt_plant_key.
    ELSE.
      lt_plant_key = CORRESPONDING #( it_mat_key DISCARDING DUPLICATES  ).
    ENDIF.

    et_atpplant = mo_masterdata_access->get_atpplant( lt_plant_key ).

    IF es_atpplant IS REQUESTED.
      IF et_atpplant IS NOT INITIAL.
        es_atpplant = et_atpplant[ 1 ].
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD if_atp_data_access~get_atp_stor_loc.

    DATA lt_atp_storage_location TYPE tbl_atp_storage_location.
    DATA lt_atp_stor_loc_key TYPE tbl_atp_stor_loc_key.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key> TYPE tbl_atp_stor_loc_key.

    lo_buffer = cl_atp_buffer_manager=>get_atp_stor_loc_buffer( ).

* Since buffered TBL_ATP_STORAGE_LOCATION does not have any key defined, key explicitly needs to be defined
    CREATE DATA lr_key TYPE tbl_atp_stor_loc_key.
    ASSIGN lr_key->* TO <lt_key>.

    <lt_key> = CORRESPONDING #( it_stor_loc_key DISCARDING DUPLICATES ).

    DELETE <lt_key> WHERE lgort = ''.

    " Get data
    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.

    et_atp_storage_location = CORRESPONDING #( <lt_result> ).

    " Read missing data from db
    IF <lt_key_not_found> IS NOT INITIAL.
      lt_atp_stor_loc_key = CORRESPONDING #( <lt_key_not_found> ).
      mo_masterdata_db->select_atp_stor_loc(
        EXPORTING
          it_stor_loc_key         = lt_atp_stor_loc_key
        IMPORTING
          et_atp_storage_location = lt_atp_storage_location
      ).

      " Fill to buffer
      lo_buffer->set( it_data = lt_atp_storage_location ).
      INSERT LINES OF lt_atp_storage_location INTO TABLE et_atp_storage_location.

      DATA lt_negative_buffer LIKE lt_atp_stor_loc_key.
      LOOP AT lt_atp_stor_loc_key ASSIGNING FIELD-SYMBOL(<ls_atp_stor_loc_key>).
        READ TABLE lt_atp_storage_location WITH TABLE KEY werks = <ls_atp_stor_loc_key>-werks
                                                          lgort = <ls_atp_stor_loc_key>-lgort TRANSPORTING NO FIELDS.
        IF 0 <> sy-subrc.
          INSERT <ls_atp_stor_loc_key> INTO TABLE lt_negative_buffer.
        ENDIF.
      ENDLOOP.

      "all entries left in keys are also not available on DB, so put it to negative buffer.
      IF lt_negative_buffer IS NOT INITIAL.
        me->insert_to_negative_buffer(
          EXPORTING
            it_key    = REF #( lt_negative_buffer )
            io_buffer = lo_buffer
        ).
      ENDIF.
    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~get_catalog_info_by_usetype.
    mo_fieldcatalog_db->read_catalog_info_by_usetype(
      EXPORTING
        iv_catalog_use_type = iv_catalog_use_type
      IMPORTING
        et_catalog_info     = et_catalog_info ).
  ENDMETHOD.


  METHOD if_atp_data_access~get_charac_values.
    mo_charc_dp->get_charac_values(
      EXPORTING
        iv_order_type    = iv_order_type
      IMPORTING
        et_failed_key    = et_failed_key
      CHANGING
        ct_charac_values = ct_charac_values
    ).
  ENDMETHOD.


  METHOD if_atp_data_access~get_check_group.

    rt_check_group = mo_customizing_data_access->get_check_group( it_mtvfp ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_customer_data.
    DATA lt_kna1 TYPE TABLE OF kna1.
    DATA lt_kna1_key TYPE TABLE OF kna1.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.

    lo_buffer = cl_atp_buffer_manager=>get_customer_buffer( ).
    lt_kna1_key = VALUE #( ( kunnr = iv_kunnr ) ).

    lr_key = lo_buffer->convert_to_buffer_key( REF #( lt_kna1_key ) ).

    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    et_customer_data = CORRESPONDING #( <lt_result> ).

    " Read missing data from db
    IF <lt_key_not_found> IS NOT INITIAL.
      CLEAR lt_kna1_key.
      lt_kna1_key = CORRESPONDING #( <lt_key_not_found> ).

      DATA ls_customer TYPE if_pal_db_access=>ty_customer.
      LOOP AT lt_kna1_key ASSIGNING FIELD-SYMBOL(<ls_kna1_key>).
        CLEAR ls_customer.
        ls_customer = mo_pal_db->get_sto_customer_data( iv_customer = <ls_kna1_key>-kunnr ).
        INSERT CORRESPONDING #( ls_customer ) INTO TABLE lt_kna1.
        INSERT CORRESPONDING #( ls_customer ) INTO TABLE et_customer_data.
      ENDLOOP.

      " Fill to buffer
      lo_buffer->set( it_data = lt_kna1 ).
    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~get_db_slines_for_items.

    CHECK it_item_key IS NOT INITIAL.

    mo_order_info_dp->get_vbep_db_state_by_item(
      EXPORTING
        it_item_key           = it_item_key
      IMPORTING
        et_vbep_db_state      = DATA(lt_vbep_db_state_fr_buffer)
        et_item_key_not_found = DATA(lt_item_without_sline_in_buf)
    ).

    mo_document_data_provider->get_req_sline_qty_before_check(
      EXPORTING
        item_keys         = lt_item_without_sline_in_buf
      IMPORTING
        scheduleline_data = DATA(lt_vbep_db_state_fr_db)
    ).

    merge_vbep_db_state(
      EXPORTING
        it_item_key               = lt_item_without_sline_in_buf
        it_vbep_db_state_base     = lt_vbep_db_state_fr_buffer
        it_vbep_db_state_to_merge = lt_vbep_db_state_fr_db
      IMPORTING
        et_vbep_db_state_merged   = et_scheduleline_data
        et_item_key_not_found     = DATA(lt_item_key_not_exist)
    ).

    fill_vbep_db_state_buffer(
      EXPORTING
        it_item_key_not_exist      = lt_item_key_not_exist
        it_vbep_db_state_to_buffer = lt_vbep_db_state_fr_db
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_enhanced_check_methods.

    rt_enhanced_check_methods = mo_customizing_data_access->get_enhanced_check_methods( it_enhanced_check_key ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_info.
    mo_fieldcatalog_db->read_catalog_info(
      EXPORTING
        it_catalog_uuid = it_catalog_uuid
      IMPORTING
        et_catalog_info = et_catalog_info
    ).
  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_info_via_type.
    mo_fieldcatalog_db->read_catalog_info_via_type(
      EXPORTING
        iv_catalog_type     = iv_catalog_type
        iv_catalog_use_type = iv_catalog_use_type
      IMPORTING
        es_catalog_info     = es_catalog_info
    ).
  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_path.

    DATA: lt_mixed_path_uuid LIKE it_catalog_path_uuid.

    CLEAR: et_catalog_path,
           es_catalog_path.

    CHECK it_catalog_path_uuid   IS NOT INITIAL OR
          it_catalog_path_int_id IS NOT INITIAL.

    mo_fieldcatalog_db->read_catalog_paths(
      EXPORTING
        it_catalog_path_uuid   = it_catalog_path_uuid
        it_catalog_path_int_id = it_catalog_path_int_id
      IMPORTING
        et_catalog_path        = DATA(lt_catalog_path)
    ).

    LOOP AT lt_catalog_path ASSIGNING FIELD-SYMBOL(<ls_catalog_path>)
                            WHERE prodalloccharccatalogtype =  if_prodalloccharccatalogtype_c=>sc_mixed.
      INSERT VALUE #( charc_path_uuid = <ls_catalog_path>-prodalloccharcctlgpathuuid ) INTO TABLE lt_mixed_path_uuid.
    ENDLOOP.

    mo_fieldcatalog_db->read_catalog_path_refs_by(
      EXPORTING
        it_catalog_path_uuid = lt_mixed_path_uuid
      IMPORTING
        et_catalog_path_ref  = DATA(lt_mixed_path_ref)
    ).

    copy_info_from_base_to_mix(
      EXPORTING
        it_catalog_path_ref       = lt_mixed_path_ref
        it_base_path              = lt_catalog_path
      IMPORTING
        et_base_path_uuid_missing = DATA(lt_base_path_uuid_missing)
      CHANGING
        ct_catalog_path           = lt_catalog_path
    ).

    mo_fieldcatalog_db->read_catalog_paths(
      EXPORTING
        it_catalog_path_uuid = lt_base_path_uuid_missing
      IMPORTING
        et_catalog_path      = DATA(lt_base_path)
    ).

    copy_info_from_base_to_mix(
      EXPORTING
        it_catalog_path_ref = lt_mixed_path_ref
        it_base_path        = lt_base_path
      CHANGING
        ct_catalog_path     = lt_catalog_path
    ).

    IF es_catalog_path IS REQUESTED AND
       0 < lines( lt_catalog_path ).
      es_catalog_path = lt_catalog_path[ 1 ].
      RETURN.
    ENDIF.

    et_catalog_path = lt_catalog_path.

  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_path_and_base.

    CHECK it_catalog_path_uuid IS NOT INITIAL.

    mo_fieldcatalog_db->read_catalog_paths(
      EXPORTING
        it_catalog_path_uuid = it_catalog_path_uuid
      IMPORTING
        et_catalog_path      = et_catalog_path
    ).

    mo_fieldcatalog_db->read_catalog_base_paths(
      EXPORTING
        it_catalog_path_uuid = it_catalog_path_uuid
      IMPORTING
        et_catalog_path      = DATA(lt_base_catalog_path)
    ).

    LOOP AT lt_base_catalog_path ASSIGNING FIELD-SYMBOL(<ls_base_catalog_path>).
      INSERT <ls_base_catalog_path> INTO TABLE et_catalog_path.
    ENDLOOP.

  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_path_ref.
    CHECK it_catalog_path_ref_uuid IS NOT INITIAL.

    mo_fieldcatalog_db->read_catalog_path_refs(
      EXPORTING
        it_catalog_path_ref_uuid = it_catalog_path_ref_uuid
      IMPORTING
        et_catalog_path_ref      = DATA(lt_catalog_path_ref)
    ).

    IF es_catalog_path_ref IS REQUESTED.
      LOOP AT lt_catalog_path_ref ASSIGNING FIELD-SYMBOL(<ls_catalog_path_ref>).
        es_catalog_path_ref = <ls_catalog_path_ref>.
        EXIT.
      ENDLOOP.
      RETURN.
    ENDIF.

    et_catalog_path_ref = lt_catalog_path_ref.

  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_path_ref_by.

    mo_fieldcatalog_db->read_catalog_path_refs_by(
      EXPORTING
        it_catalog_uuid     = it_catalog_uuid
      IMPORTING
        et_catalog_path_ref = et_catalog_path_ref ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_fc_catalog_value_help_data.
    CHECK is_catalog_path IS NOT INITIAL.

    mo_fieldcatalog_db->read_value_for_value_help(
      EXPORTING
        is_catalog_path = is_catalog_path
        is_paging       = is_paging
        it_id_selopt    = it_id_selopt
        it_desc_selopt  = it_desc_selopt
        iv_selopt_and   = iv_selopt_and     "Combine select options for IDs and Descrs. with AND logic
      IMPORTING
        et_value        = et_value
        ev_count        = ev_count
    ).
  ENDMETHOD.


  METHOD if_atp_data_access~get_header_data.
    mo_order_info_dp->get_document_data(
      EXPORTING
        it_document_key  = it_header_key
      IMPORTING
        et_document_data = et_header_data ).
*    " only supports sales documents for now...
*    DATA lt_vbak_data TYPE TABLE OF vbak.
*    DATA lt_vbak_key TYPE TABLE OF vbak.
*
*    DATA lr_result TYPE REF TO data.
*    DATA lr_key TYPE REF TO data.
*    DATA lr_key_not_found TYPE REF TO data.
*
*    DATA lo_buffer TYPE REF TO if_atp_buffer.
*
*    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
*    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
*
*    lo_buffer = cl_atp_buffer_manager=>get_vbak_buffer( ).
*
*    lt_vbak_key = CORRESPONDING #( it_header_key MAPPING vbeln = delnr ).
*    lr_key = me->convert_to_buffer_key(
*                EXPORTING
*                    it_key = REF #( lt_vbak_key )
*                    io_buffer = lo_buffer
*    ).
*
*
*    lo_buffer->get( EXPORTING it_key           = lr_key
*                    IMPORTING et_data          = lr_result
*                              et_key_not_found = lr_key_not_found ).
*    ASSIGN lr_result->* TO <lt_result>.
*    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
*    lt_vbak_data = CORRESPONDING #( <lt_result> ).
*
*    "This method for now only works for sales documents.
*    LOOP AT lt_vbak_data ASSIGNING FIELD-SYMBOL(<ls_vbak_data>).
*      INSERT VALUE #( BASE CORRESPONDING #( <ls_vbak_data> )
*          atpcat = cl_atpcat_c=>sales_order
*          delnr = <ls_vbak_data>-vbeln ) INTO TABLE et_header_data.
*    ENDLOOP.
*-----------------------------------
*    et_header_data = CORRESPONDING #( lt_vbak_data MAPPING delnr = vbeln ).
*
*    " Read missing data from db
*    IF <lt_key_not_found> IS NOT INITIAL.
*      CLEAR lt_vbak_key.
*      lt_vbak_key = CORRESPONDING #( <lt_key_not_found> ).
*      "this should actually not happen for now...
*      "transactional data access object should be used here
*
*      " Fill to buffer
*      lo_buffer->set( it_data = lt_vbak_data ).
*      LOOP AT lt_vbak_data ASSIGNING FIELD-SYMBOL(<ls_vbak_data>).
*        INSERT CORRESPONDING #( <ls_vbak_data> ) INTO TABLE et_header_data.
*      ENDLOOP.
*    ENDIF.

  ENDMETHOD.


  METHOD if_atp_data_access~get_item_data.
    mo_order_info_dp->get_item_data(
      EXPORTING
        it_item_key  = it_item_key
      IMPORTING
        et_item_data = et_item_data ).

*    " only supports sales documents for now...
*    DATA lt_vbap_data TYPE TABLE OF vbap.
*    DATA lt_vbap_key TYPE TABLE OF vbap.
*
*    DATA lr_result TYPE REF TO data.
*    DATA lr_key TYPE REF TO data.
*    DATA lr_key_not_found TYPE REF TO data.
*
*    DATA lo_buffer TYPE REF TO if_atp_buffer.
*
*    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
*    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
*
*    lo_buffer = cl_atp_buffer_manager=>get_vbap_buffer( ).
*
*    lt_vbap_key = CORRESPONDING #( it_item_key MAPPING vbeln = delnr posnr = delps ).
*    lr_key = me->convert_to_buffer_key(
*                EXPORTING
*                    it_key = REF #( lt_vbap_key )
*                    io_buffer = lo_buffer
*    ).
*
*
*    lo_buffer->get( EXPORTING it_key           = lr_key
*                    IMPORTING et_data          = lr_result
*                              et_key_not_found = lr_key_not_found ).
*    ASSIGN lr_result->* TO <lt_result>.
*    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
*    lt_vbap_data = CORRESPONDING #( <lt_result> ).
*
*    "This method for now only works for sales documents.
*    LOOP AT lt_vbap_data ASSIGNING FIELD-SYMBOL(<ls_vbap_data>).
*      INSERT VALUE #( BASE CORRESPONDING #( <ls_vbap_data> )
*          atpcat                  = cl_atpcat_c=>sales_order
*          delnr                   = <ls_vbap_data>-vbeln
*          delps                   = <ls_vbap_data>-posnr
*          substitution_status = <ls_vbap_data>-atp_abc_substitution_status ) INTO TABLE et_item_data.
*    ENDLOOP.
*
*
*
*    " Read missing data from db
*    IF <lt_key_not_found> IS NOT INITIAL.
*      CLEAR lt_vbap_key.
*      lt_vbap_key = CORRESPONDING #( <lt_key_not_found> ).
*      "this should actually not happen for now...
*      "ATP transactional data access object should be used here.
*
*      " Fill to buffer
*      lo_buffer->set( it_data = lt_vbap_data ).
*      LOOP AT lt_vbap_data ASSIGNING <ls_vbap_data>.
*        INSERT CORRESPONDING #( <ls_vbap_data> ) INTO TABLE et_item_data.
*      ENDLOOP.
*    ENDIF.
  ENDMETHOD.


  METHOD if_atp_data_access~get_item_data_before_check.

    IF mo_item_buffer_handler IS NOT BOUND.
      mo_item_buffer_handler = NEW #( io_document_data_provider = mo_document_data_provider ).
    ENDIF.

    et_item_data = mo_item_buffer_handler->get_items_before_check( it_item_key = it_item_key ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_lc_active_status_fae.


    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
    lo_buffer = cl_atp_buffer_manager=>get_livecache_ts_active_buffer( ).

    lr_key = lo_buffer->convert_to_buffer_key( REF #( it_mat_key ) ).

    lo_buffer->get(
      EXPORTING
        it_key           = lr_key
      IMPORTING
        et_data          = lr_result
        et_key_not_found = lr_key_not_found
    ).

    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.

    et_atp_ts_in_lc = CORRESPONDING #( <lt_result> ).

    FREE: <lt_result>, <lt_key_not_found>.

*    " Read missing data from db => this is still in the class cl_atp_pac_livecache_status( ) => Mocking is not possible there...
*    IF <lt_key_not_found> IS NOT INITIAL.
*      DATA lt_atp_ts_in_lc LIKE et_atp_ts_in_lc.
*      DATA lt_atp_mat_key TYPE tbl_atp_matnr_werks.
*
*      lt_atp_mat_key = CORRESPONDING #( <lt_key_not_found> ).
*      NEW cl_atp_pac_livecache_status( )->select_atp_ts_in_lc_fae(
*        EXPORTING
*          it_mat_key              = lt_atp_mat_key
*          ir_vbbe_status_selected = ir_vbbe_status_selected
*          ir_resb_status_selected = ir_resb_status_selected
*        IMPORTING
*          et_atp_ts_in_lc         = lt_atp_ts_in_lc
*      ).
*
*      " Fill to buffer
*      lo_buffer->set( it_data = lt_atp_ts_in_lc ).
*      LOOP AT lt_atp_ts_in_lc ASSIGNING FIELD-SYMBOL(<ls_timeseries_in_lc>).
*        INSERT <ls_timeseries_in_lc> INTO TABLE et_atp_ts_in_lc.
*      ENDLOOP.
*    ENDIF.

  ENDMETHOD.


  METHOD if_atp_data_access~get_location_data.
    DATA lt_t001w TYPE TABLE OF t001w.
    DATA lt_t001w_key TYPE TABLE OF t001w.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.

    lo_buffer = cl_atp_buffer_manager=>get_t001w_buffer( ).
    lt_t001w_key = VALUE #( ( werks = iv_location_id ) ).

    lr_key = lo_buffer->convert_to_buffer_key( REF #( lt_t001w_key ) ).

    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    lt_t001w = CORRESPONDING #( <lt_result> ).
    IF lt_t001w IS NOT INITIAL.
      rs_location_data = CORRESPONDING #( lt_t001w[ 1 ] ).
    ENDIF.

    " Read missing data from db
    IF <lt_key_not_found> IS NOT INITIAL.
      CLEAR lt_t001w_key.
      lt_t001w_key = CORRESPONDING #( <lt_key_not_found> ).

      mo_masterdata_db->select_t001w(
        EXPORTING
          it_mat_key = VALUE #( ( werks = iv_location_id ) )
        IMPORTING
          et_t001w   = DATA(lt_small_t001w)
      ).

      " Fill to buffer
      lt_t001w = CORRESPONDING #( lt_small_t001w ).
      lo_buffer->set( it_data = lt_t001w ).
      LOOP AT lt_t001w ASSIGNING FIELD-SYMBOL(<ls_t001w>).
        rs_location_data = CORRESPONDING #( <ls_t001w> ).
        EXIT.
      ENDLOOP.
    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~get_material.

    mo_masterdata_db->select_mara(
      EXPORTING
        it_matnr = it_matnr
      IMPORTING
        et_mara  = et_material
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_partner_data.

    DATA: lt_key      TYPE if_atp_order_info_data_providr=>tt_partner_function_key.

    CHECK it_partner_functions IS NOT INITIAL.

    lt_key = CORRESPONDING #( it_partner_functions MAPPING vbeln = delnr
                                                           posnr = delps
                                                           parvw = partner_function ).

    get_partner_data_from_buffer(
      EXPORTING
        it_key           = lt_key
      IMPORTING
        et_partner_data  = et_partner_data
        et_key_not_found = DATA(lt_key_not_in_buffer)
    ).

    CHECK lt_key_not_in_buffer IS NOT INITIAL.

    get_partner_data_from_db(
      EXPORTING
        it_key          = lt_key
      IMPORTING
        et_partner_data = DATA(lt_partner_data_from_db)
    ).

    INSERT LINES OF lt_partner_data_from_db INTO TABLE et_partner_data.

  ENDMETHOD.


  METHOD if_atp_data_access~get_product_sales_data.

    mo_masterdata_db->select_product_sales_data(
      EXPORTING
        it_product_sales_data_key = it_product_sales_data_key
      IMPORTING
        et_product_sales_data     = et_product_sales_data
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_requested_delivery_date.

    DATA: lt_scheduleline TYPE if_atp_order_info_data_providr=>tt_scheduleline.

    me->if_atp_data_access~get_scheduleline_data(
      EXPORTING
        it_scheduleline_key  = VALUE #( ( is_scheduleline_key ) )
      IMPORTING
        et_scheduleline_data = lt_scheduleline
    ).

    IF lt_scheduleline IS NOT INITIAL.
      rv_requested_delivery_date = lt_scheduleline[ 1 ]-sline_date.
    ENDIF.

  ENDMETHOD.


  METHOD if_atp_data_access~get_salesarea_data.
    DATA:
      lt_knvv          TYPE TABLE OF knvv,
      lt_knvv_key      TYPE TABLE OF knvv,
      lr_result        TYPE REF TO data,
      lr_key           TYPE REF TO data,
      lr_key_not_found TYPE REF TO data,
      lo_buffer        TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS:
      <lt_result>        TYPE ANY TABLE,
      <lt_key_not_found> TYPE ANY TABLE.


    lo_buffer = cl_atp_buffer_manager=>get_knvv_buffer( ).
    lt_knvv_key = VALUE #( ( kunnr = iv_customer
                             vkorg = iv_salesorg
                             vtweg = iv_distchannel
                             spart = iv_division
                           )
                         ).

    lr_key = lo_buffer->convert_to_buffer_key( REF #( lt_knvv_key ) ).

    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    lt_knvv = CORRESPONDING #( <lt_result> ).
    IF lt_knvv IS NOT INITIAL.
      rs_salesarea = VALUE #( lt_knvv[ 1 ] ).
    ENDIF.

    " Read missing data from db
    IF <lt_key_not_found> IS NOT INITIAL.
      CLEAR lt_knvv_key.
      lt_knvv_key = CORRESPONDING #( <lt_key_not_found> ).

      DATA(ls_small_knvv) = mo_pal_db->get_salesarea_data( iv_customer    = iv_customer
                                                           iv_salesorg    = iv_salesorg
                                                           iv_distchannel = iv_distchannel
                                                           iv_division    = iv_division ).

      IF ls_small_knvv IS INITIAL.
        RETURN.
      ENDIF.

      " Fill to buffer
      INSERT CORRESPONDING #( ls_small_knvv ) INTO TABLE lt_knvv.
      lo_buffer->set( it_data = lt_knvv ).
      LOOP AT lt_knvv ASSIGNING FIELD-SYMBOL(<ls_knvv>).
        rs_salesarea = CORRESPONDING #( <ls_knvv> ).
        EXIT.
      ENDLOOP.
    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~get_salesorg_data.
    DATA lt_tvko TYPE TABLE OF tvko.
    DATA lt_tvko_key TYPE TABLE OF tvko.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.

    lo_buffer = cl_atp_buffer_manager=>get_salesorg_buffer( ).
    lt_tvko_key = VALUE #( ( vkorg = iv_salesorg ) ).

    lr_key = lo_buffer->convert_to_buffer_key( REF #( lt_tvko_key ) ).

    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    lt_tvko = CORRESPONDING #( <lt_result> ).
    IF lt_tvko IS NOT INITIAL.
      rs_salesorg = CORRESPONDING #( lt_tvko[ 1 ] ).
    ENDIF.

    " Read missing data from db
    IF <lt_key_not_found> IS NOT INITIAL.
      CLEAR lt_tvko_key.
      lt_tvko_key = CORRESPONDING #( <lt_key_not_found> ).

      DATA(ls_small_tvko) = mo_pal_db->get_salesorg_data( iv_salesorg = iv_salesorg ).

      IF ls_small_tvko IS INITIAL.
        RETURN.
      ENDIF.

      " Fill to buffer
      INSERT CORRESPONDING #( ls_small_tvko ) INTO TABLE lt_tvko.
      lo_buffer->set( it_data = lt_tvko ).
      LOOP AT lt_tvko ASSIGNING FIELD-SYMBOL(<ls_tvko>).
        rs_salesorg = CORRESPONDING #( <ls_tvko> ).
        EXIT.
      ENDLOOP.
    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~get_scheduleline_data.
    mo_order_info_dp->get_scheduleline_data(
      EXPORTING
        it_scheduleline_key  = it_scheduleline_key
      IMPORTING
        et_scheduleline_data = et_scheduleline_data ).
*    " only supports sales documents for now...
*
*    DATA lt_vbep_data TYPE TABLE OF vbep.
*    DATA lt_vbep_key TYPE TABLE OF vbep.
*
*    DATA lr_result TYPE REF TO data.
*    DATA lr_key TYPE REF TO data.
*    DATA lr_key_not_found TYPE REF TO data.
*
*    DATA lo_buffer TYPE REF TO if_atp_buffer.
*
*    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
*    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
*
*    lo_buffer = cl_atp_buffer_manager=>get_vbep_buffer( ).
*
*    lt_vbep_key = CORRESPONDING #( it_scheduleline_key MAPPING vbeln = delnr posnr = delps etenr = delet ).
*    lr_key = me->convert_to_buffer_key(
*                EXPORTING
*                    it_key = REF #( lt_vbep_key )
*                    io_buffer = lo_buffer
*    ).
*
*
*    lo_buffer->get( EXPORTING it_key           = lr_key
*                    IMPORTING et_data          = lr_result
*                              et_key_not_found = lr_key_not_found ).
*    ASSIGN lr_result->* TO <lt_result>.
*    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
*    lt_vbep_data = CORRESPONDING #( <lt_result> ).
*
*    "This method for now only works for sales documents.
*    LOOP AT lt_vbep_data ASSIGNING FIELD-SYMBOL(<ls_vbep_data>).
*      INSERT VALUE #( BASE CORRESPONDING #( <ls_vbep_data> )
*                      atpcat            = cl_atpcat_c=>sales_order
*                      delnr             = <ls_vbep_data>-vbeln
*                      delps             = <ls_vbep_data>-posnr
*                      delet             = <ls_vbep_data>-etenr
*                      delivered_qty     = <ls_vbep_data>-dlvqty_su
*                      delivered_qty_uom = <ls_vbep_data>-vrkme
*                      sline_category    = <ls_vbep_data>-ettyp
*                      sline_date        = <ls_vbep_data>-edatu ) INTO TABLE et_scheduleline_data.
*    ENDLOOP.
*
*    " Read missing data from db
*    IF <lt_key_not_found> IS NOT INITIAL.
*      CLEAR lt_vbep_key.
*      lt_vbep_key = CORRESPONDING #( <lt_key_not_found> ).
*      "this should actually not happen for now...
*      "transactional data access object should be used here
*
*      " Fill to buffer
*      lo_buffer->set( it_data = lt_vbep_data ).
*      LOOP AT lt_vbep_data ASSIGNING <ls_vbep_data>.
*        INSERT CORRESPONDING #( <ls_vbep_data> ) INTO TABLE et_scheduleline_data.
*      ENDLOOP.
*    ENDIF.
  ENDMETHOD.


  METHOD if_atp_data_access~get_scope_of_check.

    rt_scope_of_check = mo_customizing_data_access->get_scope_of_check( it_mtvfp_prreg ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_sto_customer_data.
    DATA lt_sto_customer_data TYPE if_read_order_trans_buffer=>tts_customer.
    DATA lt_sto_customer_data_key TYPE if_read_order_trans_buffer=>tts_customer.
    DATA ls_sto_customer_data_key TYPE if_read_order_trans_buffer=>ty_customer.

    DATA lr_result TYPE REF TO data.
    DATA lr_key TYPE REF TO data.
    DATA lr_key_not_found TYPE REF TO data.

    DATA lo_buffer TYPE REF TO if_atp_buffer.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.


    CHECK is_btd_ref IS NOT INITIAL.

    lo_buffer = cl_atp_buffer_manager=>get_sto_customer_buffer( ).
    ls_sto_customer_data_key = CORRESPONDING #( is_btd_ref ).
    INSERT ls_sto_customer_data_key INTO TABLE lt_sto_customer_data_key.

    lr_key = lo_buffer->convert_to_buffer_key( REF #( lt_sto_customer_data_key ) ).

    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    lt_sto_customer_data = CORRESPONDING #( <lt_result> ).
    IF lt_sto_customer_data IS NOT INITIAL.
      rs_sto_shiptoparty = CORRESPONDING #( lt_sto_customer_data[ 1 ] ).
    ENDIF.

    FREE: <lt_result>, <lt_key_not_found>.
    "the current implementation of this method does not give the chance to read based on order

  ENDMETHOD.


  METHOD if_atp_data_access~get_subitems.

    IF mo_item_buffer_handler IS NOT BOUND.
      mo_item_buffer_handler = NEW #( io_document_data_provider = mo_document_data_provider ).
    ENDIF.

    et_subitems = mo_item_buffer_handler->get_subitems( it_item_key = it_item_key ).

  ENDMETHOD.


  METHOD if_atp_data_access~get_tvap.
    DATA:
      lt_item_category TYPE if_atp_pac_db=>tt_item_category,
      lt_tvap          TYPE if_atp_pac_db=>tt_tvap.

    CHECK iv_item_category IS NOT INITIAL.

    lt_item_category = VALUE #( ( pstyv = iv_item_category ) ).

    lt_tvap = me->if_atp_data_access~get_tvap_multi( it_item_category = lt_item_category ).

    IF lt_tvap IS NOT INITIAL.
      rs_tvap = CORRESPONDING #( lt_tvap[ 1 ] ).
    ENDIF.

  ENDMETHOD.


  METHOD if_atp_data_access~get_tvap_multi.

    DATA:
      lo_buffer        TYPE REF TO if_atp_buffer,
      lr_item_category TYPE REF TO data,
      lr_tvap          TYPE REF TO data,
      lr_key_not_found TYPE REF TO data.

    FIELD-SYMBOLS:
      <lt_key_not_found> TYPE ANY TABLE,
      <lt_tvap>          TYPE ANY TABLE.

    CHECK it_item_category IS NOT INITIAL.

    lo_buffer = cl_atp_buffer_manager=>get_tvap_buffer( ).

    lr_item_category = lo_buffer->convert_to_buffer_key( REF #( it_item_category ) ).

    lo_buffer->get( EXPORTING it_key           = lr_item_category
                    IMPORTING et_data          = lr_tvap
                              et_key_not_found = lr_key_not_found
                             ).

    ASSIGN lr_tvap->* TO <lt_tvap>.
    rt_tvap = CORRESPONDING #( <lt_tvap> ).

    " Read missing data from db
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    IF <lt_key_not_found> IS NOT INITIAL.

      mo_masterdata_db->select_tvap(
        EXPORTING
          it_item_category = CORRESPONDING #( <lt_key_not_found> )
        IMPORTING
          et_tvap          = DATA(lt_tvap)
      ).

      "Fill to buffer
      IF lt_tvap IS NOT INITIAL.
        lo_buffer->set( it_data = lt_tvap ).
        INSERT LINES OF lt_tvap INTO TABLE rt_tvap.
      ENDIF.
    ENDIF.

    FREE: <lt_tvap>, <lt_key_not_found>.

  ENDMETHOD.


  METHOD if_atp_data_access~is_sd_merge_active.

    TRY.
        mo_sd_dbsel_cust->get_merge_sub_sls_single(
          EXPORTING
            iv_merge_id      = cl_atp_abc_c=>sd_subitem_merge_id
          IMPORTING
            es_merge_sub_sls = DATA(ls_merge_sub_sls) " Merge Subitem Results in Sales
        ).
      CATCH cx_sd_dbsel_dynamic ##no_handler .
    ENDTRY.

    is_active = ls_merge_sub_sls-merge_active.

  ENDMETHOD.


  METHOD if_atp_data_access~read_all_path_refs_for_charc.

    CLEAR et_path_ref_for_charc.

    CHECK it_path_ref_for_charc IS NOT INITIAL.

    mo_fieldcatalog_db->read_all_path_refs_for_charc(
      EXPORTING
        it_path_ref_for_charc = it_path_ref_for_charc
      IMPORTING
        et_path_ref_for_charc = et_path_ref_for_charc
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~read_catalog_paths_by.

    CLEAR et_catalog_path.

    CHECK iv_catalog_use_type IS NOT INITIAL.

    mo_fieldcatalog_db->read_catalog_paths_by(
      EXPORTING
        iv_catalog_use_type = iv_catalog_use_type
        iv_catalog_type     = iv_catalog_type
      IMPORTING
        et_catalog_path     = et_catalog_path
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~read_catalog_path_text.

    CLEAR et_catalog_path_text.

    CHECK it_catalog_path_int_id IS NOT INITIAL.

    mo_fieldcatalog_db->read_catalog_path_text(
      EXPORTING
        it_catalog_path_int_id = it_catalog_path_int_id
      IMPORTING
        et_catalog_path_text   = et_catalog_path_text
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~read_catalog_text.

    mo_fieldcatalog_db->read_catalog_text(
      EXPORTING
        it_catalog_uuid = it_catalog_uuid
      IMPORTING
        et_catalog_text = et_catalog_text
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~read_value_groups.

    CLEAR: et_value_group,
           et_value_group_parent,
           et_value_group_value.

    CHECK it_catalog_path_uuid IS NOT INITIAL.

    mo_fieldcatalog_db->read_value_groups(
      EXPORTING
        it_catalog_path_uuid  = it_catalog_path_uuid
      IMPORTING
        et_value_group        = et_value_group
        et_value_group_value  = et_value_group_value
        et_value_group_parent = et_value_group_parent
    ).

  ENDMETHOD.


  METHOD if_atp_data_access~read_vc_data.
    DATA: lr_key            TYPE REF TO data,
          lr_key_not_found  TYPE REF TO data,
          lr_result         TYPE REF TO data,
          lo_buffer         TYPE REF TO if_atp_buffer,
          vc_data_key_table TYPE TABLE OF if_read_order_trans_buffer=>ty_vc_key WITH NON-UNIQUE SORTED KEY vc_key COMPONENTS order_id item_id charcintid.

    FIELD-SYMBOLS <lt_result> TYPE ANY TABLE.
    FIELD-SYMBOLS <lt_key_not_found> TYPE ANY TABLE.
    CLEAR et_vc_data.

    CHECK is_vc_data_key-charcintid IS NOT INITIAL.
    CHECK is_vc_data_key-item_id IS NOT INITIAL.
    vc_data_key_table = VALUE #( ( is_vc_data_key ) ).

    lo_buffer = cl_atp_buffer_manager=>get_vc_buffer( ).

    lr_key = lo_buffer->convert_to_buffer_key( REF #( vc_data_key_table ) ).

    lo_buffer->get( EXPORTING it_key           = lr_key
                    IMPORTING et_data          = lr_result
                              et_key_not_found = lr_key_not_found ).
    ASSIGN lr_result->* TO <lt_result>.
    ASSIGN lr_key_not_found->* TO <lt_key_not_found>.
    et_vc_data = CORRESPONDING #( <lt_result> ).

    CLEAR: <lt_result>.

  ENDMETHOD.


  METHOD insert_to_negative_buffer.

    FIELD-SYMBOLS <lt_negative_buffer> TYPE ANY TABLE.

    ASSIGN it_key->* TO FIELD-SYMBOL(<lt_buffer_key>).
    io_buffer->get_negative_table_struct(
      IMPORTING
        er_negative_table_structure = DATA(lr_negative_buffer) ).
    ASSIGN lr_negative_buffer->* TO <lt_negative_buffer>.
    <lt_negative_buffer> = CORRESPONDING #( <lt_buffer_key> ).
    io_buffer->set_negative( it_data = <lt_negative_buffer> ).

  ENDMETHOD.


  METHOD merge_vbep_db_state.

    DATA: lv_entry_found TYPE boole_d.

    CLEAR: et_vbep_db_state_merged,
           et_item_key_not_found.

    et_vbep_db_state_merged = it_vbep_db_state_base.

    LOOP AT it_item_key ASSIGNING FIELD-SYMBOL(<ls_item_key>).

      lv_entry_found = abap_false.

      LOOP AT it_vbep_db_state_to_merge ASSIGNING FIELD-SYMBOL(<ls_scheduleline_data>)
                                        WHERE item_key = <ls_item_key>.
        lv_entry_found = abap_true.

        INSERT <ls_scheduleline_data> INTO TABLE et_vbep_db_state_merged.
      ENDLOOP.

      CHECK lv_entry_found = abap_false.

      INSERT <ls_item_key> INTO TABLE et_item_key_not_found.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.