"!@testing CLAS:CL_ATP_INFO_API_DATA_PROVIDER
"!@testing CLAS:CL_ATP_INFO_API_VALIDATOR
CLASS ltcl_atp_info_api_get_availy DEFINITION DEFERRED.
CLASS cl_atp_info_api_get_availy DEFINITION LOCAL FRIENDS ltcl_atp_info_api_get_availy.

CLASS ltcl_atp_info_api_get_availy DEFINITION FOR TESTING
  DURATION SHORT
  RISK LEVEL HARMLESS.

  PRIVATE SECTION.

    CONSTANTS product         TYPE matnr   VALUE 'RDSU01' ##NO_TEXT.
    CONSTANTS mrparea         TYPE berid   VALUE '0001' ##NO_TEXT.
    CONSTANTS storagelocation TYPE lgort_d VALUE 'A100' ##NO_TEXT.

    DATA:
      cut            TYPE REF TO cl_atp_info_api_get_availy,
      data_provider              TYPE REF TO td_atp_info_api_data_provider,
      validator                  TYPE REF TO td_atp_info_api_validator,
      converter                  TYPE REF TO td_atp_info_api_converter,
      characteristic             TYPE REF TO td_atp_info_api_characteristic,
      api_usage                  TYPE REF TO td_atp_info_api_usage,
      fixtures                   TYPE REF TO td_atp_info_api_fixtures,

      mrp_failed                 TYPE if_atprlvtproductmrparea=>failed,
      mrp_reported               TYPE if_atprlvtproductmrparea=>reported,
      storeloc_failed            TYPE if_atprlvtproductstoreloc=>failed,
      storeloc_reported          TYPE if_atprlvtproductstoreloc=>reported,
      mrparea_timeseries_keys    TYPE if_atprlvtproductmrparea=>timeseries_keys,
      mrparea_timeseries_result  TYPE if_atprlvtproductmrparea=>timeseries_result,
      mrparea_atdatetme_keys     TYPE if_atprlvtproductmrparea=>atdatetme_keys,
      mrparea_atdatetme_result   TYPE if_atprlvtproductmrparea=>atdatetme_result,
      mrparea_ofqty_keys         TYPE if_atprlvtproductmrparea=>ofqty_keys,
      mrparea_ofqty_result       TYPE if_atprlvtproductmrparea=>ofqty_result,
      storeloc_timeseries_keys   TYPE if_atprlvtproductstoreloc=>timeseries_keys,
      storeloc_timeseries_result TYPE if_atprlvtproductstoreloc=>timeseries_result,
      storeloc_atdatetme_keys    TYPE if_atprlvtproductstoreloc=>atdatetme_keys,
      storeloc_atdatetme_result  TYPE if_atprlvtproductstoreloc=>atdatetme_result,
      storeloc_ofqty_keys        TYPE if_atprlvtproductstoreloc=>ofqty_keys,
      storeloc_ofqty_result      TYPE if_atprlvtproductstoreloc=>ofqty_result.


    METHODS:
      test_charc_mapping_exc FOR TESTING RAISING cx_static_check,
      read_a_atprlvtproductmrparea FOR TESTING RAISING cx_static_check,
      read_a_atprlvtproductstoreloc FOR TESTING RAISING cx_static_check,
      empty_mrparea_ts_to_result FOR TESTING RAISING cx_static_check,
      empty_sloc_ts_to_result FOR TESTING RAISING cx_static_check,
      get_avail_at_datim_nokey FOR TESTING RAISING cx_static_check,
      get_avail_at_datim_sloc_nokey FOR TESTING RAISING cx_static_check,
      find_ts_at_date_4_mrparea FOR TESTING RAISING cx_static_check,
      find_ts_empty_mrparea FOR TESTING RAISING cx_static_check,
      mrp_sum_of_timeseries_nothing FOR TESTING RAISING cx_static_check,
      find_ts_all_4_mrparea FOR TESTING RAISING cx_static_check,
      sloc_sum_of_timeseries_at_date FOR TESTING RAISING cx_static_check,
      sloc_sum_of_empty_timeseries FOR TESTING RAISING cx_static_check,
      sloc_sum_of_timeseries_nothing FOR TESTING RAISING cx_static_check,
      sloc_sum_of_timeseries_all FOR TESTING RAISING cx_static_check,
      get_mrpelmnt_by_purpose_sls2vc  FOR TESTING RAISING cx_static_check,
      get_mrpelmnt_by_purpose_sto2u1 FOR TESTING RAISING cx_static_check,
      get_mrpelmnt_by_purpose_exec  FOR TESTING RAISING cx_static_check,
      find_ts_at_date_4_mrparea_rlt FOR TESTING RAISING cx_static_check,
      plant_initial FOR TESTING RAISING cx_static_check,
      input_not_ok_empty_product           FOR TESTING RAISING cx_static_check,
      get_ts_by_mrparea_1_check FOR TESTING RAISING cx_static_check,
      get_ts_by_mrparea_empty_keys FOR TESTING RAISING cx_static_check,
      get_ts_by_sloc_empty FOR TESTING RAISING cx_static_check,
      get_ts_by_sloc FOR TESTING RAISING cx_static_check,
      get_avail_of_qty_nokey FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_mrparea FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_mrparea_e FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_mrparea_rlt FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_sloc FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_sloc_e FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_sloc_rlt FOR TESTING RAISING cx_static_check,
      get_avail_of_qty_storloc_nokey FOR TESTING RAISING cx_static_check,
      get_avail_of_qty_by_storloc FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_mrp_no_iana FOR TESTING RAISING cx_static_check,
      get_ts_by_mrparea_nokey FOR TESTING RAISING cx_static_check,
      find_ts_at_date_4_mrparea_nots FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_mrparea_nots FOR TESTING RAISING cx_static_check,
      find_ts_of_qty_4_sloc_nots FOR TESTING RAISING cx_static_check,
      find_ts_at_date_4_sloc_nots  FOR TESTING RAISING cx_static_check,
      get_time_series_by_mrp FOR TESTING RAISING cx_static_check,
      get_avail_at_datim_by_mrp FOR TESTING RAISING cx_static_check,
      get_avail_of_qty_by_mrp FOR TESTING RAISING cx_static_check,
      get_time_series_by_stl FOR TESTING RAISING cx_static_check,
      get_avail_at_datim_by_stl FOR TESTING RAISING cx_static_check,
      get_avail_of_qty_by_stl FOR TESTING RAISING cx_static_check,
      setup,
      get_timestamp_cet
        IMPORTING
          utc_timestamp        TYPE d_availydetmavailytmesersr-prodavailyperdstrtutcdtetme
        RETURNING
          VALUE(cet_timestamp) TYPE timestamp.


ENDCLASS.



CLASS ltcl_atp_info_api_get_availy IMPLEMENTATION.
  METHOD setup.
    data_provider = NEW td_atp_info_api_data_provider( ).
    validator = NEW td_atp_info_api_validator( mdmas = VALUE #( ) ).
    characteristic = NEW td_atp_info_api_characteristic( ).
    converter = NEW td_atp_info_api_converter( ).
    api_usage = NEW td_atp_info_api_usage( ).
    fixtures = NEW td_atp_info_api_fixtures( ).
    cut = NEW #( atp_info_api_data_provider  = data_provider
                 atp_info_api_validator      = validator
                 atp_info_api_converter      = converter
                 atp_info_api_characteristic = characteristic
                 atp_info_api_usage          = api_usage ).

    CLEAR: mrp_failed,
    mrp_reported,
    storeloc_failed,
    storeloc_reported,
    mrparea_timeseries_keys,
    mrparea_timeseries_result,
    mrparea_atdatetme_keys,
    mrparea_atdatetme_result,
    mrparea_ofqty_keys,
    mrparea_ofqty_result,
    storeloc_timeseries_keys,
    storeloc_timeseries_result,
    storeloc_atdatetme_keys,
    storeloc_atdatetme_result,
    storeloc_ofqty_keys,
    storeloc_ofqty_result.
  ENDMETHOD.


  METHOD read_a_atprlvtproductstoreloc.
    " Given
    data_provider = NEW td_atp_info_api_data_provider( product_mrparea_storlocs = VALUE #(
        ( product = product mrparea = mrparea  storagelocation = storagelocation ) ) ).

    cut = NEW #( atp_info_api_data_provider = data_provider atp_info_api_validator = validator ).

    " When
    DATA(result) = cut->if_atp_info_api_get_availy~read_a_atprlvtproductstorloc( product = product mrparea = mrparea lgort = storagelocation ).

    " Then
    cl_abap_unit_assert=>assert_equals( act = result-product
                                        exp = product ).
    cl_abap_unit_assert=>assert_equals( act = result-mrparea
                                        exp = mrparea ).
    cl_abap_unit_assert=>assert_equals( act = result-storagelocation
                                        exp = storagelocation ).
  ENDMETHOD.


  METHOD read_a_atprlvtproductmrparea.
    " Given
    data_provider = NEW td_atp_info_api_data_provider( product_mrpareas = VALUE #(
        ( product = product mrparea = mrparea ) ) ).
    cut = NEW #( atp_info_api_data_provider = data_provider atp_info_api_validator = validator ).

    " When
    DATA(result) = cut->if_atp_info_api_get_availy~read_a_atprlvtproductmrparea( product = product mrparea = mrparea ).

    " Then
    cl_abap_unit_assert=>assert_equals( act = result-product
                                        exp = product ).
    cl_abap_unit_assert=>assert_equals( act = result-mrparea
                                        exp = mrparea ).
  ENDMETHOD.


  METHOD test_charc_mapping_exc.
    " Given
    data_provider = NEW #( mdlvs = VALUE #( ( berid = '0001' werzg = 'AB01' ) ) ).
    validator = NEW #( mdmas = VALUE #( ( matnr = 'RDSU01' berid = '0001' ) ) ).

    mrparea_timeseries_keys = VALUE #(
               ( mrparea                                     = '0001'
                 product                                     = 'RDSU01'
                 %param-_documentattributes-_characteristics = VALUE #(
                     ( charccatalogcharacteristicname = 'DONT_EXIST' charccatalogcharcvalue = '' )
                     ( charccatalogcharacteristicname = 'SD_PAR_ADR_PF.S1-COUNTRY' charccatalogcharcvalue = 'FR' ) ) ) ).

    " When
    NEW cl_atp_info_api_get_availy( atp_info_api_characteristic = characteristic
                                    atp_info_api_converter      = converter
                                    atp_info_api_data_provider  = data_provider
                                    atp_info_api_validator      = validator
                                    atp_info_api_usage          = api_usage )->if_atp_info_api_get_availy~get_time_series_by_mrparea(
          EXPORTING keys     = mrparea_timeseries_keys
          CHANGING  result   = mrparea_timeseries_result
                    failed   = mrp_failed
                    reported = mrp_reported ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( mrp_failed-productmrparea ).
    cl_abap_unit_assert=>assert_not_initial( mrp_reported ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_dyn_msg~msgty
                                        exp = 'E' ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgno
                                        exp = '113' ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgid
                                        exp = 'ATP_INFO_API' ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_dyn_msg~msgv1
                                        exp = 'DONT_EXIST' ).
  ENDMETHOD.


  METHOD get_avail_at_datim_nokey.
    " Removed temporarily
*    " Given
*    DATA(td_atp_info_api_usage) = CAST cl_atp_info_api_usage( cl_abap_testdouble=>create( 'CL_ATP_INFO_API_USAGE' ) ).
*    cl_abap_testdouble=>configure_call( td_atp_info_api_usage
*                                            )->ignore_all_parameters(
*                                            )->and_expect(
*                                            )->is_called_once( ).
*
*    td_atp_info_api_usage->if_atp_info_api_usage~count_usage(
*        function_name   = if_atp_info_api_usage=>function_name-susage_insert
*        feature_name    = if_atp_info_api_usage=>feature-atp_info_api_usage
*        feature_type    = if_atp_info_api_usage=>type-mrparea
*        feature_subtype = if_atp_info_api_usage=>subtype-at_date_time ).
*    cut = NEW #(  atp_info_api_usage = td_atp_info_api_usage ).
*
*    " When
*    cut->if_atp_info_api_get_availy~get_avail_at_datim_by_mrparea( EXPORTING keys     = VALUE #( )
*                                                                   CHANGING  result   = mrparea_atdatetme_result
*                                                                             failed   = mrp_failed
*                                                                             reported = mrp_reported ).
*
*    " Then
*    cl_abap_unit_assert=>assert_initial( mrparea_atdatetme_result ).
*    cl_abap_unit_assert=>assert_initial( mrp_failed ).
*    cl_abap_unit_assert=>assert_initial( mrp_reported ).
*    cl_abap_testdouble=>verify_expectations( td_atp_info_api_usage ).
  ENDMETHOD.


  METHOD get_avail_of_qty_nokey.
    " Removed temporarily
*    " Given
*    DATA(td_atp_info_api_usage) = CAST cl_atp_info_api_usage( cl_abap_testdouble=>create( 'CL_ATP_INFO_API_USAGE' ) ).
*    cl_abap_testdouble=>configure_call( td_atp_info_api_usage
*                                            )->ignore_all_parameters(
*                                            )->and_expect(
*                                            )->is_called_once( ).
*
*    td_atp_info_api_usage->if_atp_info_api_usage~count_usage(
*        function_name   = if_atp_info_api_usage=>function_name-susage_insert
*        feature_name    = if_atp_info_api_usage=>feature-atp_info_api_usage
*        feature_type    = if_atp_info_api_usage=>type-mrparea
*        feature_subtype = if_atp_info_api_usage=>subtype-of_quantity ).
*    cut = NEW #(  atp_info_api_usage = td_atp_info_api_usage ).
*    " When
*    cut->if_atp_info_api_get_availy~get_avail_of_qty_by_mrparea( EXPORTING keys     = VALUE #( )
*                                                                 CHANGING  result   = mrparea_ofqty_result
*                                                                           failed   = mrp_failed
*                                                                           reported = mrp_reported ).
*    " Then
*    cl_abap_unit_assert=>assert_initial( mrparea_ofqty_result ).
*    cl_abap_unit_assert=>assert_initial( mrp_failed ).
*    cl_abap_unit_assert=>assert_initial( mrp_reported ).
*    cl_abap_testdouble=>verify_expectations( td_atp_info_api_usage ).
  ENDMETHOD.


  METHOD get_ts_by_mrparea_nokey.
    " Removed temporarily
*    " Given
*    DATA(td_atp_info_api_usage) = CAST cl_atp_info_api_usage( cl_abap_testdouble=>create( 'CL_ATP_INFO_API_USAGE' ) ).
*    cl_abap_testdouble=>configure_call( td_atp_info_api_usage
*                                            )->ignore_all_parameters(
*                                            )->and_expect(
*                                            )->is_called_once( ).
*
*    td_atp_info_api_usage->if_atp_info_api_usage~count_usage(
*        function_name   = if_atp_info_api_usage=>function_name-susage_insert
*        feature_name    = if_atp_info_api_usage=>feature-atp_info_api_usage
*        feature_type    = if_atp_info_api_usage=>type-mrparea
*        feature_subtype = if_atp_info_api_usage=>subtype-of_quantity ).
*    cut = NEW #(  atp_info_api_usage = td_atp_info_api_usage ).
*    " When
*    cut->if_atp_info_api_get_availy~get_time_series_by_mrparea( EXPORTING keys     = VALUE #( )
*                                                                CHANGING  result   = mrparea_timeseries_result
*                                                                          failed   = mrp_failed
*                                                                          reported = mrp_reported ).
*    " Then
*    cl_abap_unit_assert=>assert_initial( mrparea_timeseries_result ).
*    cl_abap_unit_assert=>assert_initial( mrp_failed ).
*    cl_abap_unit_assert=>assert_initial( mrp_reported ).
*    cl_abap_testdouble=>verify_expectations( td_atp_info_api_usage ).
  ENDMETHOD.


  METHOD get_avail_of_qty_storloc_nokey.
    " Removed temporarily
*    " Given
*    DATA(td_atp_info_api_usage) = CAST cl_atp_info_api_usage( cl_abap_testdouble=>create( 'CL_ATP_INFO_API_USAGE' ) ).
*    cl_abap_testdouble=>configure_call( td_atp_info_api_usage
*                                            )->ignore_all_parameters(
*                                            )->and_expect(
*                                            )->is_called_once( ).
*
*    td_atp_info_api_usage->if_atp_info_api_usage~count_usage(
*        function_name   = if_atp_info_api_usage=>function_name-susage_insert
*        feature_name    = if_atp_info_api_usage=>feature-atp_info_api_usage
*        feature_type    = if_atp_info_api_usage=>type-storage_location
*        feature_subtype = if_atp_info_api_usage=>subtype-of_quantity ).
*    " When
*    cut = NEW #(  atp_info_api_usage = td_atp_info_api_usage ).
*
*    cut->if_atp_info_api_get_availy~get_avail_of_qty_by_storloc( EXPORTING keys     = VALUE #( )
*                                                                 CHANGING  result   = storeloc_ofqty_result
*                                                                           failed   = storeloc_failed
*                                                                           reported = storeloc_reported ).
*    " Then
*    cl_abap_unit_assert=>assert_initial( storeloc_ofqty_result ).
*    cl_abap_unit_assert=>assert_initial( storeloc_failed ).
*    cl_abap_unit_assert=>assert_initial( storeloc_reported ).
*    cl_abap_testdouble=>verify_expectations( td_atp_info_api_usage ).
  ENDMETHOD.


  METHOD empty_mrparea_ts_to_result.
    " When
    DATA(result) = cut->mrp_timeseries_to_result( timeseries = VALUE #( ) key = VALUE #( ) ).

    " Then
    cl_abap_unit_assert=>assert_initial( result ).
  ENDMETHOD.


  METHOD empty_sloc_ts_to_result.
    " when
    DATA(result) = cut->storloc_timeseries_to_result( timeseries = VALUE #( ) key = VALUE #( ) ).

    " Then
    cl_abap_unit_assert=>assert_initial( result ).
  ENDMETHOD.


  METHOD get_avail_at_datim_sloc_nokey.
    " Removed temporarily
*    " Given
*    DATA(td_atp_info_api_usage) = CAST cl_atp_info_api_usage( cl_abap_testdouble=>create( 'CL_ATP_INFO_API_USAGE' ) ).
*    cl_abap_testdouble=>configure_call( td_atp_info_api_usage
*                                            )->ignore_all_parameters(
*                                            )->and_expect(
*                                            )->is_called_once( ).
*
*    td_atp_info_api_usage->if_atp_info_api_usage~count_usage(
*        function_name   = if_atp_info_api_usage=>function_name-susage_insert
*        feature_name    = if_atp_info_api_usage=>feature-atp_info_api_usage
*        feature_type    = if_atp_info_api_usage=>type-storage_location
*        feature_subtype = if_atp_info_api_usage=>subtype-at_date_time ).
*    " When
*    cut = NEW #(  atp_info_api_usage = td_atp_info_api_usage ).
*    " When
*    cut->if_atp_info_api_get_availy~get_avail_at_datim_by_storloc( EXPORTING keys     = VALUE #( )
*                                                                   CHANGING  result   = storeloc_atdatetme_result
*                                                                             failed   = storeloc_failed
*                                                                             reported = storeloc_reported ).
*
*    " Then
*    cl_abap_unit_assert=>assert_initial( storeloc_atdatetme_result ).
*    cl_abap_unit_assert=>assert_initial( storeloc_failed ).
*    cl_abap_unit_assert=>assert_initial( storeloc_reported ).
*    cl_abap_testdouble=>verify_expectations( td_atp_info_api_usage ).
  ENDMETHOD.


  METHOD find_ts_at_date_4_mrparea.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>atdatetme_key( product                               = product
                                                               mrparea                               = mrparea
                                                               %param-productavailabilityutcdatetime = '20220407220000' ).
    " When
    DATA(result) = cut->find_ts_at_date_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #( baseunit = 'PC'
                              ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                              ( availablequantityinbaseunit = 300 prodavailyperdstrtutcdtetme = '20220406220000' )
                              ( availablequantityinbaseunit = 700 prodavailyperdstrtutcdtetme = '20220408220000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '300' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_at_date_4_mrparea_rlt.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>atdatetme_key( product                               = product
                                                               mrparea                               = mrparea
                                                               %param-productavailabilityutcdatetime = '20220409220000' ).
    " When
    DATA(result) = cut->find_ts_at_date_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #(
            baseunit = 'PC'
            ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
            ( availablequantityinbaseunit = 300 prodavailyperdstrtutcdtetme = '20220406220000' )
            ( availablequantityinbaseunit = 700 prodavailyperdstrtutcdtetme = '20220408220000' )
            ( availablequantityinbaseunit = cl_atp_info_api_get_availy=>max_quantity prodavailyperdstrtutcdtetme = '99991231235959' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '700' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_mrparea.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>ofqty_key( product                            = product
                                                           mrparea                            = mrparea
                                                           %param-availablequantityinbaseunit = '1100' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #(
            baseunit = 'PC'
                           prodavailyperdstrttimezone = 'CET'
                           ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                           ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220406220000' )
                           ( availablequantityinbaseunit = 1100 prodavailyperdstrtutcdtetme = '20220408220000' )
                           ( availablequantityinbaseunit = 1500 prodavailyperdstrtutcdtetme = '20220408230000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilityutcdatetime exp = '20220408220000' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'CET' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0355' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_mrp_no_iana.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>ofqty_key( product                            = product
                                                           mrparea                            = mrparea
                                                           %param-availablequantityinbaseunit = '1100' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_mrparea( key        = REF #( key )
                                                  timeseries = VALUE #( ( baseunit                    = 'PC'
                                                                          availablequantityinbaseunit = 1500
                                                                          prodavailyperdstrtutcdtetme = '20220408230000'
                                                                          prodavailyperdstrttimezone  = 'XXX' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'XXX' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0000' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_mrparea_e.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>ofqty_key( product                            = product
                                                           mrparea                            = mrparea
                                                           %param-availablequantityinbaseunit = '2200' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #(
            baseunit = 'PC'
                           prodavailyperdstrttimezone = 'CET'
                           ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                           ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220406220000' )
                           ( availablequantityinbaseunit = 1100 prodavailyperdstrtutcdtetme = '20220408220000' )
                           ( availablequantityinbaseunit = 1500 prodavailyperdstrtutcdtetme = '20220408230000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilityutcdatetime exp = cl_atp_info_api_get_availy=>max_timestamp ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'CET' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0355' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_mrparea_rlt.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>ofqty_key( product                            = product
                                                           mrparea                            = mrparea
                                                           %param-availablequantityinbaseunit = '2200' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #(
            baseunit = 'PC'
            prodavailyperdstrttimezone = 'CET'
            ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
            ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220406220000' )
            ( availablequantityinbaseunit = 1100 prodavailyperdstrtutcdtetme = '20220408220000' )
            ( availablequantityinbaseunit = 1500 prodavailyperdstrtutcdtetme = '20220408230000' )
            ( availablequantityinbaseunit = cl_atp_info_api_get_availy=>max_quantity prodavailyperdstrtutcdtetme = '20230101100000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilityutcdatetime exp = '20230101100000' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'CET' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0355' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD mrp_sum_of_timeseries_nothing.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>atdatetme_key( product                               = product
                                                               mrparea                               = mrparea
                                                               %param-productavailabilityutcdatetime = '20220404220000' ).
    " When
    DATA(result) = cut->find_ts_at_date_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #( baseunit = 'PC'
                              ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                              ( availablequantityinbaseunit = 200 prodavailyperdstrtutcdtetme = '20220406220000' )
                              ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220408220000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '0' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_all_4_mrparea.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>atdatetme_key( product                               = product
                                                               mrparea                               = mrparea
                                                               %param-productavailabilityutcdatetime = '20220408220000' ).

    " When
    DATA(result) = cut->find_ts_at_date_4_mrparea(
        key        = REF #( key )
        timeseries = VALUE #( baseunit = 'PC'
                              ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                              ( availablequantityinbaseunit = 200 prodavailyperdstrtutcdtetme = '20220406220000' )
                              ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220408220000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '400' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_empty_mrparea.
    " Given
    DATA(key) = VALUE if_atprlvtproductmrparea=>atdatetme_key( product                               = product
                                                               mrparea                               = mrparea
                                                               %param-productavailabilityutcdatetime = '20220407220000' ).

    " When
    DATA(result) = cut->find_ts_at_date_4_mrparea( key        = REF #( key )
                                                   timeseries = VALUE #( ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '0' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = '' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD sloc_sum_of_timeseries_at_date.
    " Given
    DATA(key) = VALUE if_atprlvtproductstoreloc=>atdatetme_key( product                               = product
                                                                mrparea                               = mrparea
                                                                storagelocation                       = storagelocation
                                                                %param-productavailabilityutcdatetime = '20220407220000' ).
    " When
    DATA(result) = cut->find_ts_at_date_4_sloc(
        key        = REF #( key )
        timeseries = VALUE #( baseunit = 'PC'
                              ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                              ( availablequantityinbaseunit = 200 prodavailyperdstrtutcdtetme = '20220406220000' )
                              ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220408220000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-product exp = product ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-mrparea exp = mrparea ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-storagelocation exp = storagelocation ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '200' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD sloc_sum_of_timeseries_nothing.
    " Given
    DATA(key) = VALUE if_atprlvtproductstoreloc=>atdatetme_key( product                               = product
                                                                mrparea                               = mrparea
                                                                storagelocation                       = storagelocation
                                                                %param-productavailabilityutcdatetime = '20220404220000' ).
    " When
    DATA(result) = cut->find_ts_at_date_4_sloc(
        key        = REF #( key )
        timeseries = VALUE #( baseunit = 'PC'
                              ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                              ( availablequantityinbaseunit = 200 prodavailyperdstrtutcdtetme = '20220406220000' )
                              ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220408220000' ) ) ).
    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-product exp = product ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-mrparea exp = mrparea ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-storagelocation exp = storagelocation ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '0' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD sloc_sum_of_timeseries_all.
    " Given
    DATA(key) = VALUE if_atprlvtproductstoreloc=>atdatetme_key( product                               = product
                                                                mrparea                               = mrparea
                                                                storagelocation                       = storagelocation
                                                                %param-productavailabilityutcdatetime = '20220408220000' ).
    " When
    DATA(result) = cut->find_ts_at_date_4_sloc(
        key        = REF #( key )
        timeseries = VALUE #( baseunit = 'PC'
                              ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                              ( availablequantityinbaseunit = 200 prodavailyperdstrtutcdtetme = '20220406220000' )
                              ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220408220000' ) ) ).
    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-product exp = product ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-mrparea exp = mrparea ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-storagelocation exp = storagelocation ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '400' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = 'PC' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunitisocode exp = 'C62' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD get_mrpelmnt_by_purpose_exec.
    TRY.
        cut->get_mrp_element_by_purpose( 'MURP' ).
      CATCH cx_atp_info_api_fail.
        RETURN.
    ENDTRY.

    cl_abap_unit_assert=>fail( msg = 'Exception not raised' ).
  ENDMETHOD.


  METHOD get_mrpelmnt_by_purpose_sto2u1.
    cl_abap_unit_assert=>assert_equals( act = cut->get_mrp_element_by_purpose( 'STO' ) exp = cl_atpcat_c=>stock_transport_order ). "'STO' => 'U1'
  ENDMETHOD.


  METHOD get_mrpelmnt_by_purpose_sls2vc.
    cl_abap_unit_assert=>assert_equals(
        act = cut->get_mrp_element_by_purpose( cl_atp_check_customizing_c=>atp_relevant_document_purpose-sales )
        exp = cl_atpcat_c=>sales_order ). "'SLS' => 'VC'
  ENDMETHOD.


  METHOD sloc_sum_of_empty_timeseries.
    " Given
    DATA(key) = VALUE if_atprlvtproductstoreloc=>atdatetme_key( product                               = product
                                                                mrparea                               = mrparea
                                                                storagelocation                       = storagelocation
                                                                %param-productavailabilityutcdatetime = '20220407220000' ).

    " When
    DATA(result) = cut->find_ts_at_date_4_sloc( key        = REF #( key )
                                                timeseries = VALUE #( ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-product exp = product ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-mrparea exp = mrparea ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-storagelocation exp = storagelocation ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-availablequantityinbaseunit exp = '0' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-baseunit exp = '' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD plant_initial.
    " Given
    cut = fixtures->scenario_mrparea_one_check( ).
    fixtures->get_data_provider( )->delete_plants_from_mock( ).

    " When
    cut->if_atp_info_api_get_availy~get_time_series_by_mrparea(
      EXPORTING keys     = fixtures->get_timeseries_mrparea_keys( )
      CHANGING  result   = mrparea_timeseries_result
                failed   = mrp_failed
                reported = mrp_reported ).

    " Then
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->m_severity
                                        exp = if_abap_behv_message=>severity-error ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgid
                                        exp = 'ATP_INFO_API' ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgno
                                        exp = '111' ).
  ENDMETHOD.


  METHOD input_not_ok_empty_product.
    " Given
    cut = fixtures->scenario_mrparea_one_check( ).
    fixtures->get_validator( )->delete_plants_from_mock( ).

    DATA(keys) = fixtures->get_timeseries_mrparea_keys( ).

    CLEAR keys[ 1 ]-Product.

    " When
    cut->if_atp_info_api_get_availy~get_time_series_by_mrparea( EXPORTING keys     = keys
      CHANGING  result   = mrparea_timeseries_result
                failed   = mrp_failed
                reported = mrp_reported ).

    " Then
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->m_severity
                                        exp = if_abap_behv_message=>severity-error ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgid
                                        exp = 'ATP_INFO_API' ).
    cl_abap_unit_assert=>assert_equals( act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgno
                                        exp = '100' ).
  ENDMETHOD.


  METHOD get_ts_by_mrparea_1_check.
    " Given
    cut = fixtures->scenario_mrparea_one_check( ).

    " When
    cut->if_atp_info_api_get_availy~get_time_series_by_mrparea(
      EXPORTING keys     = fixtures->get_timeseries_mrparea_keys( )
      CHANGING  result   = mrparea_timeseries_result
                failed   = mrp_failed
                reported = mrp_reported ).

    " Then
    LOOP AT fixtures->get_mrparea_checks_timeseries( ) INTO DATA(check).

      cl_abap_unit_assert=>assert_equals( act = mrparea_timeseries_result[ sy-tabix ]-%param-availablequantityinbaseunit
                                          exp = check-results[ 1 ]-availablequantityinbaseunit ).
      cl_abap_unit_assert=>assert_equals( act = mrparea_timeseries_result[ sy-tabix ]-%param-baseunit
                                          exp = check-results[ 1 ]-baseunit ).
      cl_abap_unit_assert=>assert_equals( act = mrparea_timeseries_result[ sy-tabix ]-%param-prodavailyperdstrtutcdtetme
                                          exp = check-results[ 1 ]-prodavailyperdstrtutcdtetme ).
      cl_abap_unit_assert=>assert_equals( act = mrparea_timeseries_result[ sy-tabix ]-%param-prodavailyperdendtimezone
                                          exp = check-results[ 1 ]-prodavailyperdendtimezone ).
      cl_abap_unit_assert=>assert_equals(
          act = mrparea_timeseries_result[ sy-tabix ]-%param-ProdAvailyPerdEndTmznIANACode
          exp = check-results[ 1 ]-ProdAvailyPerdEndTmznIANACode ).
      cl_abap_unit_assert=>assert_equals( act = mrparea_timeseries_result[ sy-tabix ]-%param-prodavailyperdstrttimezone
                                          exp = check-results[ 1 ]-prodavailyperdstrttimezone ).
      cl_abap_unit_assert=>assert_equals(
          act = mrparea_timeseries_result[ sy-tabix ]-%param-ProdAvailyPerdStrtTmznIANACode
          exp = check-results[ 1 ]-ProdAvailyPerdStrtTmznIANACode ).
      cl_abap_unit_assert=>assert_equals( act = mrparea_timeseries_result[ sy-tabix ]-%param-prodavailyperdendutcdtetme
                                          exp = check-results[ 1 ]-prodavailyperdendutcdtetme ).
    ENDLOOP.
  ENDMETHOD.


  METHOD find_ts_at_date_4_mrparea_nots.
    DATA(result) = cut->find_ts_at_date_4_mrparea( key        = NEW #( )
                                                   timeseries = VALUE #( ) ).
    cl_abap_unit_assert=>assert_not_initial( result ).
  ENDMETHOD.


  METHOD find_ts_at_date_4_sloc_nots.
    DATA(result) = cut->find_ts_at_date_4_sloc( key        = NEW #( )
                                                timeseries = VALUE #( ) ).
    cl_abap_unit_assert=>assert_not_initial( result ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_mrparea_nots.
    DATA(result) = cut->find_ts_of_qty_4_mrparea( key        = NEW #( )
                                                  timeseries = VALUE #( ) ).
    cl_abap_unit_assert=>assert_not_initial( result ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_sloc_nots.
    DATA(result) = cut->find_ts_of_qty_4_sloc( key        = NEW #( )
                                               timeseries = VALUE #( ) ).
    cl_abap_unit_assert=>assert_not_initial( result ).
  ENDMETHOD.


  METHOD get_time_series_by_mrp.
    cut->if_atp_info_api_get_availy~get_time_series_by_mrparea( EXPORTING keys     = VALUE #( ( ) )
                                                                CHANGING  result   = mrparea_timeseries_result
                                                                          failed   = mrp_failed
                                                                          reported = mrp_reported ).
    cl_abap_unit_assert=>assert_initial( mrparea_timeseries_result ).
    cl_abap_unit_assert=>assert_not_initial( mrp_failed ).
    cl_abap_unit_assert=>assert_not_initial( mrp_reported ).
    cl_abap_unit_assert=>assert_equals( exp = '111'
                                        act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgno ).
  ENDMETHOD.


  METHOD get_avail_at_datim_by_mrp.
    cut->if_atp_info_api_get_availy~get_avail_at_datim_by_mrparea( EXPORTING keys     = VALUE #( ( ) )
                                                                   CHANGING  result   = mrparea_atdatetme_result
                                                                             failed   = mrp_failed
                                                                             reported = mrp_reported ).
    cl_abap_unit_assert=>assert_initial( mrparea_atdatetme_result ).
    cl_abap_unit_assert=>assert_not_initial( mrp_failed ).
    cl_abap_unit_assert=>assert_not_initial( mrp_reported ).
    cl_abap_unit_assert=>assert_equals( exp = '111'
                                        act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgno ).
  ENDMETHOD.


  METHOD get_avail_of_qty_by_mrp.
    cut->if_atp_info_api_get_availy~get_avail_of_qty_by_mrparea( EXPORTING keys     = VALUE #( ( ) )
                                                                 CHANGING  result   = mrparea_ofqty_result
                                                                           failed   = mrp_failed
                                                                           reported = mrp_reported ).
    cl_abap_unit_assert=>assert_initial( mrparea_ofqty_result ).
    cl_abap_unit_assert=>assert_not_initial( mrp_failed ).
    cl_abap_unit_assert=>assert_not_initial( mrp_reported ).
    cl_abap_unit_assert=>assert_equals( exp = '111'
                                        act = mrp_reported-productmrparea[ 1 ]-%msg->if_t100_message~t100key-msgno ).
  ENDMETHOD.


  METHOD get_time_series_by_stl.
    cut->if_atp_info_api_get_availy~get_time_series_by_storloc( EXPORTING keys     = VALUE #( ( ) )
                                                                CHANGING  result   = storeloc_timeseries_result
                                                                          failed   = storeloc_failed
                                                                          reported = storeloc_reported ).
    cl_abap_unit_assert=>assert_initial( storeloc_timeseries_result ).
    cl_abap_unit_assert=>assert_not_initial( storeloc_failed ).
    cl_abap_unit_assert=>assert_not_initial( storeloc_reported ).
    cl_abap_unit_assert=>assert_equals(
        exp = '111'
        act = storeloc_reported-productstoragelocation[ 1 ]-%msg->if_t100_message~t100key-msgno ).
  ENDMETHOD.


  METHOD get_avail_at_datim_by_stl.
    cut->if_atp_info_api_get_availy~get_avail_at_datim_by_storloc( EXPORTING keys     = VALUE #( ( ) )
                                                                   CHANGING  result   = storeloc_atdatetme_result
                                                                             failed   = storeloc_failed
                                                                             reported = storeloc_reported ).
    cl_abap_unit_assert=>assert_initial( storeloc_atdatetme_result ).
    cl_abap_unit_assert=>assert_not_initial( storeloc_failed ).
    cl_abap_unit_assert=>assert_not_initial( storeloc_reported ).
    cl_abap_unit_assert=>assert_equals(
        exp = '111'
        act = storeloc_reported-productstoragelocation[ 1 ]-%msg->if_t100_message~t100key-msgno ).
  ENDMETHOD.


  METHOD get_avail_of_qty_by_stl.
    cut->if_atp_info_api_get_availy~get_avail_of_qty_by_storloc( EXPORTING keys     = VALUE #( ( ) )
                                                                 CHANGING  result   = storeloc_ofqty_result
                                                                           failed   = storeloc_failed
                                                                           reported = storeloc_reported ).
    cl_abap_unit_assert=>assert_initial( storeloc_ofqty_result ).
    cl_abap_unit_assert=>assert_not_initial( storeloc_failed ).
    cl_abap_unit_assert=>assert_not_initial( storeloc_reported ).
    cl_abap_unit_assert=>assert_equals(
        exp = '111'
        act = storeloc_reported-productstoragelocation[ 1 ]-%msg->if_t100_message~t100key-msgno ).
  ENDMETHOD.


  METHOD get_avail_of_qty_by_storloc.
    " Given
    cut = fixtures->scenario_storeloc_one_check( ).

    " When
    cut->if_atp_info_api_get_availy~get_avail_of_qty_by_storloc(
      EXPORTING keys     = fixtures->get_ofqty_storeloc_keys( )
      CHANGING  result   = storeloc_ofqty_result
                failed   = storeloc_failed
                reported = storeloc_reported ).

    " Then
    LOOP AT fixtures->get_storeloc_checks( ) INTO DATA(check).

      cl_abap_unit_assert=>assert_equals( act = storeloc_ofqty_result[ sy-tabix ]-%param-productavailabilityutcdatetime
                                          exp = check-ofqty_results[ 1 ]-productavailabilityutcdatetime ).
      cl_abap_unit_assert=>assert_equals( act = storeloc_ofqty_result[ sy-tabix ]-%param-productavailabilitytimezone
                                          exp = check-results[ 1 ]-prodavailyperdendtimezone ).
      cl_abap_unit_assert=>assert_equals( act = storeloc_ofqty_result[ sy-tabix ]-%param-ProdAvailyTmeZnIANACode
                                          exp = check-results[ 1 ]-ProdAvailyPerdEndTmznIANACode ).
    ENDLOOP.
  ENDMETHOD.


  METHOD get_ts_by_mrparea_empty_keys.
    " Given
    cut = fixtures->scenario_mrparea_one_check( ).

    " When
    cut->if_atp_info_api_get_availy~get_time_series_by_mrparea( EXPORTING keys     = mrparea_timeseries_keys
                                                                CHANGING  result   = mrparea_timeseries_result
                                                                          failed   = mrp_failed
                                                                          reported = mrp_reported ).

    " Then
    cl_abap_unit_assert=>assert_initial( act = mrparea_timeseries_result ).
    cl_abap_unit_assert=>assert_initial( act = mrp_failed ).
    cl_abap_unit_assert=>assert_initial( act = mrp_reported ).
  ENDMETHOD.


  METHOD get_ts_by_sloc_empty.
    " Removed temporarily
*    " Given
*    DATA(td_atp_info_api_usage) = CAST cl_atp_info_api_usage( cl_abap_testdouble=>create( 'CL_ATP_INFO_API_USAGE' ) ).
*
*    cl_abap_testdouble=>configure_call( td_atp_info_api_usage
*                                            )->ignore_all_parameters(
*                                            )->and_expect(
*                                            )->is_called_once( ).
*
*    td_atp_info_api_usage->if_atp_info_api_usage~count_usage(
*        function_name   = if_atp_info_api_usage=>function_name-susage_insert
*        feature_name    = if_atp_info_api_usage=>feature-atp_info_api_usage
*        feature_type    = if_atp_info_api_usage=>type-storage_location
*        feature_subtype = if_atp_info_api_usage=>subtype-timeseries ).
*    cut = NEW #(  atp_info_api_usage = td_atp_info_api_usage ).
*
*    " When
*    cut->if_atp_info_api_get_availy~get_time_series_by_storloc( EXPORTING keys     = storeloc_timeseries_keys
*                                                                CHANGING  result   = storeloc_timeseries_result
*                                                                          failed   = storeloc_failed
*                                                                          reported = storeloc_reported ).
*
*    " Then
*    cl_abap_unit_assert=>assert_initial( act = storeloc_timeseries_result ).
*    cl_abap_unit_assert=>assert_initial( act = storeloc_failed ).
*    cl_abap_unit_assert=>assert_initial( act = storeloc_reported ).
*    cl_abap_testdouble=>verify_expectations( td_atp_info_api_usage ).
  ENDMETHOD.


  METHOD get_ts_by_sloc.
    " Given
    cut = fixtures->scenario_storeloc_one_check( ).

    storeloc_timeseries_keys = fixtures->get_timeseries_storeloc_keys( ).

    DATA(td_atp_info_api_strategy) = CAST if_atp_info_api_strategy( cl_abap_testdouble=>create( 'IF_ATP_INFO_API_STRATEGY' ) ).

    DATA(exp_timeseries) = VALUE if_atp_info_api_strategy=>timeserie_tab_type(
                                     ( availablequantityinbaseunit = 17
                                       baseunit                    = 'EA'
                                       prodavailyperdstrtutcdtetme = '20220309000000'
                                       prodavailyperdendtimezone   = 'CET'
                                       prodavailyperdstrttimezone  = 'CET'
                                       ProdAvailyPerdEndTmznIANACode  = '0355'
                                       ProdAvailyPerdStrtTmznIANACode = '0355'
                                       prodavailyperdendutcdtetme     = '99991231235959' )  ).

    cl_abap_testdouble=>configure_call( td_atp_info_api_strategy
      )->set_parameter( name = 'MATERIAL_NUMBER'   value = storeloc_timeseries_keys[ 1 ]-product
      )->set_parameter( name = 'MRP_AREA' value = storeloc_timeseries_keys[ 1 ]-mrparea
      )->set_parameter( name = 'MRP_ELEMENT' value = storeloc_timeseries_keys[ 1 ]-%param-_documentattributes-atprelevantdocumentpurpose
      )->set_parameter( name = 'PLANT' value = storeloc_timeseries_keys[ 1 ]-mrparea
      )->set_parameter( name = 'ATPCHECKINGRULE' value = storeloc_timeseries_keys[ 1 ]-%param-atpcheckingrule
      )->set_parameter( name = 'STORAGE_LOCATION' value = storeloc_timeseries_keys[ 1 ]-storagelocation
      )->returning( exp_timeseries
      )->ignore_all_parameters(
      )->and_expect(
      )->is_called_once( ).

    td_atp_info_api_strategy->get_availability( atpcheckingrule  = storeloc_timeseries_keys[ 1 ]-%param-atpcheckingrule
                                                material_number  = storeloc_timeseries_keys[ 1 ]-product
                                                mrp_area         = storeloc_timeseries_keys[ 1 ]-mrparea
                                                mrp_element      = 'VC'
                                                plant            = '0001'
                                                storage_location = storeloc_timeseries_keys[ 1 ]-storagelocation ).

    cut->set_atp_info_api_strategy( td_atp_info_api_strategy ).

    " When
    cut->if_atp_info_api_get_availy~get_time_series_by_storloc( EXPORTING keys     = storeloc_timeseries_keys
                                                                CHANGING  result   = storeloc_timeseries_result
                                                                          failed   = storeloc_failed
                                                                          reported = storeloc_reported ).

    " Then
    cl_abap_unit_assert=>assert_initial( act = storeloc_failed ).
    cl_abap_unit_assert=>assert_initial( act = storeloc_reported ).
  ENDMETHOD.


  METHOD get_timestamp_cet.
    CONVERT TIME STAMP utc_timestamp TIME ZONE 'UTC'
            INTO DATE DATA(start_date) TIME DATA(time).
    CONVERT DATE start_date TIME time INTO TIME STAMP      cet_timestamp  TIME ZONE 'CET'.
  ENDMETHOD.


  METHOD find_ts_of_qty_4_sloc.
    " Given
    DATA(KEY) = VALUE if_atprlvtproductstoreloc=>ofqty_key( product                            = product
                                                            mrparea                            = mrparea
                                                            storagelocation                    = storagelocation
                                                            %param-availablequantityinbaseunit = '1100' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_sloc(
                       key        = REF #( KEY )
                       timeseries = VALUE #( baseunit                   = 'PC'
                                             prodavailyperdstrttimezone = 'CET'
                                             ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                                             ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220406220000' )
                                             ( availablequantityinbaseunit = 1100 prodavailyperdstrtutcdtetme = '20220408220000' )
                                             ( availablequantityinbaseunit = 1500 prodavailyperdstrtutcdtetme = '20220408230000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilityutcdatetime exp = '20220408220000' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'CET' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0355' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_sloc_e.
    " Given
    DATA(KEY) = VALUE if_atprlvtproductstoreloc=>ofqty_key( product                            = product
                                                            mrparea                            = mrparea
                                                            storagelocation                    = storagelocation
                                                            %param-availablequantityinbaseunit = '2200' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_sloc(
                       key        = REF #( KEY )
                       timeseries = VALUE #( baseunit                   = 'PC'
                                             prodavailyperdstrttimezone = 'CET'
                                             ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                                             ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220406220000' )
                                             ( availablequantityinbaseunit = 1100 prodavailyperdstrtutcdtetme = '20220408220000' )
                                             ( availablequantityinbaseunit = 1500 prodavailyperdstrtutcdtetme = '20220408230000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilityutcdatetime exp = cl_atp_info_api_get_availy=>max_timestamp ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'CET' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0355' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.


  METHOD find_ts_of_qty_4_sloc_rlt.
    " Given
    DATA(KEY) = VALUE if_atprlvtproductstoreloc=>ofqty_key( product                            = product
                                                            mrparea                            = mrparea
                                                            StorageLocation                    = storagelocation
                                                            %param-availablequantityinbaseunit = '2200' ).
    " When
    DATA(result) = cut->find_ts_of_qty_4_sloc(
                       key        = REF #( KEY )
                       timeseries = VALUE #( baseunit                   = 'PC'
                                             prodavailyperdstrttimezone = 'CET'
                                             ( availablequantityinbaseunit = 100 prodavailyperdstrtutcdtetme = '20220405220000' )
                                             ( availablequantityinbaseunit = 400 prodavailyperdstrtutcdtetme = '20220406220000' )
                                             ( availablequantityinbaseunit = 1100 prodavailyperdstrtutcdtetme = '20220408220000' )
                                             ( availablequantityinbaseunit = 1500 prodavailyperdstrtutcdtetme = '20220408230000' )
                                             ( availablequantityinbaseunit = cl_atp_info_api_get_availy=>max_quantity
                                               prodavailyperdstrtutcdtetme = '20230101100000' ) ) ).

    " Then
    cl_abap_unit_assert=>assert_not_initial( result ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilityutcdatetime exp = '20230101100000' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-productavailabilitytimezone exp = 'CET' ).
    cl_abap_unit_assert=>assert_equals( act = result[ 1 ]-%param-ProdAvailyTmeZnIANACode   exp = '0355' ).
    cl_abap_unit_assert=>assert_equals( act = lines( result ) exp = 1 ).
  ENDMETHOD.
ENDCLASS.